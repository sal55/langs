# GAS VERSION
    .code64
    .intel_syntax prefix

    .global $cmdskip
    .global main

    .bss
    .align    8
msys.fmtparam:
    .space    8
    .align    8
msys.$cmdskip:
$cmdskip:
    .space    8
    .data
    .align    8
msys.needgap:
    .quad     0
    .align    8
msys.outdev:
    .quad     1
    .align    8
msys.outchan:
    .quad     0
    .align    8
msys.fmtstr:
    .quad     0
    .bss
    .align    8
msys.outchan_stack:
    .space    80
    .align    8
msys.outdev_stack:
    .space    80
    .align    8
msys.fmtstr_stack:
    .space    80
msys.needgap_stack:
    .space    10
    .align    8
msys.ptr_stack:
    .space    80
    .data
    .align    8
msys.niostack:
    .quad     0
msys.digits:
    .quad     0x3736353433323130
    .quad     0x4645444342413938
    .byte     0
#ENDDATA
    .align    8
msys.defaultfmt:
    .byte     0
    .byte     0
    .byte     10
    .byte     0
    .byte     32
    .byte     102
    .byte     0
    .byte     0
    .byte     0
    .byte     82
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .bss
    .align    8
msys.rd_buffer:
    .space    8
    .align    8
msys.rd_length:
    .space    8
    .align    8
msys.rd_pos:
    .space    8
    .align    8
msys.rd_lastpos:
    .space    8
    .align    8
msys.termchar:
    .space    8
    .align    8
msys.itemerror:
    .space    8
msys.printbuffer:
    .space    4096
    .align    8
msys.printptr:
    .space    8
    .align    8
msys.printlen:
    .space    8
    .align    8
msys.nsysparams:
    .space    8
    .align    8
msys.ncmdparams:
    .space    8
    .align    8
msys.nenvstrings:
    .space    8
    .align    8
msys.sysparams:
    .space    1024
    .align    8
msys.cmdparams:
    .space    8
    .align    8
msys.envstrings:
    .space    8
msys.start.startupinfo:
    .space    128
    .align    8
msys.getfmt.fmt:
    .space    16
msys.strint.str:
    .space    100
msys.strword.str:
    .space    100
msys.strreal.str:
    .space    320
    .align    8
mlib.allocupper:
    .space    2408
    .align    8
mlib.alloccode:
    .space    8
    .align    8
mlib.allocbytes:
    .space    8
    .data
    .align    8
mlib.fdebug:
    .quad     0
    .bss
    .align    8
mlib.rfsize:
    .space    8
    .align    8
mlib.maxmemory:
    .space    8
    .align    8
mlib.maxalloccode:
    .space    8
    .data
mlib.pcm_setup:
    .byte     0
    .align    8
mlib.show:
    .quad     0
    .align    8
mlib.memtotal:
    .quad     0
    .align    8
mlib.smallmemtotal:
    .quad     0
    .align    8
mlib.smallmemobjs:
    .quad     0
    .align    8
mlib.maxmemtotal:
    .quad     0
    .bss
    .align    8
mlib.memalloctable:
    .space    24
    .align    4
mlib.memallocsize:
    .space    12
    .align    8
mlib.pcheapstart:
    .space    8
    .align    8
mlib.pcheapend:
    .space    8
    .align    8
mlib.pcheapptr:
    .space    8
mlib.sizeindextable:
    .space    2049
    .align    8
mlib.freelist:
    .space    72
    .data
    .align    8
mlib.pmnames:
    .quad     L6850
    .quad     L6851
    .quad     L6852
    .quad     L6853
    .quad     L6854
    .quad     L6855
    .align    8
mlib.seed:
    .quad     0x2989881111111272
    .quad     0x1673267373358264
    .bss
    .align    8
mlib.pcm_newblock.totalheapsize:
    .space    8
    .data
    .align    4
mlib.pcm_round.allocbytes:
    .long     0
    .long     16
    .long     32
    .long     64
    .long     128
    .long     256
    .long     512
    .long     1024
    .long     2048
    .bss
mlib.changeext.newfile:
    .space    260
mlib.extractpath.str:
    .space    260
mlib.extractbasefile.str:
    .space    100
    .data
    .align    8
mlib.nextcmdparamnew.infile:
    .quad     0
    .align    8
mlib.nextcmdparamnew.filestart:
    .quad     0
    .align    8
mlib.nextcmdparamnew.fileptr:
    .quad     0
mlib.nextcmdparamnew.colonseen:
    .byte     0
    .bss
mlib.nextcmdparamnew.str:
    .space    300
mlib.readnextfileitem.str:
    .space    256
mlib.padstr.str:
    .space    256
mlib.chr.str:
    .space    8
    .data
pepcl.pc_userunpcl:
    .byte     0
pepcl.asmonly:
    .byte     1
pepcl.pdcc:
    .byte     1
    .bss
    .align    8
pc_api.pclseqno:
    .space    8
    .align    8
pc_api.stseqno:
    .space    8
    .align    8
pc_api.pcstart:
    .space    8
    .align    8
pc_api.pccurr:
    .space    8
    .align    8
pc_api.pcend:
    .space    8
    .align    8
pc_api.pcalloc:
    .space    8
pc_api.pcfixed:
    .space    1
    .align    8
pc_api.pcseqno:
    .space    8
    .align    8
pc_api.pcneedfntable:
    .space    8
    .data
    .align    8
pc_api.initpcalloc:
    .quad     0x10000
    .bss
    .align    8
pc_api.longstring:
    .space    8
    .align    8
pc_api.longstringlen:
    .space    8
    .align    8
pc_api.mlabelno:
    .space    8
pc_api.phighmem:
    .space    1
pc_api.pfullsys:
    .space    1
pc_api.fpshortnames:
    .space    1
    .align    8
pc_api.idomcl_assem:
    .space    8
    .align    8
pc_api.icheckasmlabel:
    .space    8
    .align    8
pc_api.igethostfn:
    .space    8
pc_api.strpmode.str:
    .space    32
pc_api.getfullname.str:
    .space    256
pc_api.addstr.str:
    .space    256
    .align    8
pc_decls.pinfo:
    .space    8
    .align    8
pc_decls.bspill:
    .space    8
    .align    8
pc_decls.bxspill:
    .space    8
pc_decls.r10used:
    .space    1
pc_decls.r11used:
    .space    1
pc_decls.localshadow:
    .space    1
    .align    8
pc_decls.mmpos:
    .space    8
    .align    8
pc_decls.psymboltable:
    .space    8
    .align    8
pc_decls.psymboltablex:
    .space    8
    .align    8
pc_decls.currprog:
    .space    8
    .align    8
pc_decls.currfunc:
    .space    8
    .align    8
pc_decls.blockretname:
    .space    8
    .align    8
pc_decls.entryproc:
    .space    8
    .align    8
pc_decls.sbuffer:
    .space    16
    .data
    .align    8
pc_decls.pdest:
    .quad     pc_decls.sbuffer
    .bss
    .align    8
pc_decls.plibfiles:
    .space    400
    .align    8
pc_decls.plibinst:
    .space    400
    .align    8
pc_decls.nplibfiles:
    .space    8
    .align    8
pc_decls.igetmsourceinfo:
    .space    8
pc_decls.pcldone:
    .space    1
pc_decls.mcldone:
    .space    1
pc_decls.ssdone:
    .space    1
pc_decls.objdone:
    .space    1
pc_decls.exedone:
    .space    1
pc_decls.pverbose:
    .space    1
    .align    8
pc_decls.pcmdskip:
    .space    8
    .data
    .align    8
pc_decls.assemtype:
    .quad     0x4141
    .bss
    .align    8
pc_decls.ppseqno:
    .space    8
    .data
pc_decls.fpeephole:
    .byte     1
pc_decls.fregoptim:
    .byte     1
pc_decls.fnoconst:
    .byte     0
pc_decls.fshowil:
    .byte     0
pc_decls.flong64:
    .byte     0
    .bss
    .align    8
pc_decls.pcltime:
    .space    8
    .align    8
pc_decls.mcltime:
    .space    8
    .align    8
pc_decls.sstime:
    .space    8
    .align    8
pc_decls.objtime:
    .space    8
    .align    8
pc_decls.exetime:
    .space    8
    .align    8
pc_decls.$pmodulename:
    .space    8
    .align    8
pc_decls.pclflags:
    .space    1144
    .align    8
pc_decls.pstartclock:
    .space    8
    .align    8
pc_decls.npcl:
    .space    8
    .align    8
pc_decls.npst:
    .space    8
    .data
    .align    8
pc_tables.pstdnames:
    .quad     L6856
    .quad     L6857
    .quad     L6858
    .quad     L6859
    .quad     L6860
    .quad     L6861
    .quad     L6862
    .quad     L6863
    .quad     L6864
    .quad     L6865
    .quad     L6866
    .quad     L6867
    .quad     L6868
    .quad     L6869
pc_tables.psize:
    .quad     0x108040201080400
    .byte     2
    .byte     4
    .byte     8
    .byte     0
    .byte     0
    .byte     0
#ENDDATA
pc_tables.psigned:
    .quad     0x100000000000000
    .byte     1
    .byte     1
    .byte     1
    .byte     0
    .byte     0
    .byte     0
#ENDDATA
pc_tables.pint:
    .quad     0x101010101000000
    .byte     1
    .byte     1
    .byte     1
    .byte     0
    .byte     0
    .byte     0
#ENDDATA
pc_tables.pfloat:
    .quad     0x10100
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
#ENDDATA
pc_tables.pmin:
    .quad     0x906050505020100
    .byte     9
    .byte     9
    .byte     10
    .byte     11
    .byte     12
    .byte     0
#ENDDATA
pc_tables.xxpiwrb:
    .quad     0xA06060606020100
    .byte     10
    .byte     10
    .byte     10
    .byte     0
    .byte     0
    .byte     0
#ENDDATA
    .align    8
pc_tables.opndnames:
    .quad     L6870
    .quad     L6871
    .quad     L6872
    .quad     L6873
    .quad     L6874
    .quad     L6875
    .quad     L6876
    .quad     L6877
    .quad     L6878
    .quad     L6879
    .quad     L6880
    .quad     L6881
    .quad     L6882
    .quad     L6883
    .align    8
pc_tables.pclnames:
    .quad     L6884
    .quad     L6885
    .quad     L6886
    .quad     L6887
    .quad     L6888
    .quad     L6889
    .quad     L6890
    .quad     L6891
    .quad     L6892
    .quad     L6893
    .quad     L6894
    .quad     L6895
    .quad     L6896
    .quad     L6897
    .quad     L6898
    .quad     L6899
    .quad     L6900
    .quad     L6901
    .quad     L6902
    .quad     L6903
    .quad     L6904
    .quad     L6905
    .quad     L6906
    .quad     L6907
    .quad     L6908
    .quad     L6909
    .quad     L6910
    .quad     L6911
    .quad     L6912
    .quad     L6913
    .quad     L6914
    .quad     L6915
    .quad     L6916
    .quad     L6917
    .quad     L6918
    .quad     L6919
    .quad     L6920
    .quad     L6921
    .quad     L6922
    .quad     L6923
    .quad     L6924
    .quad     L6925
    .quad     L6926
    .quad     L6927
    .quad     L6928
    .quad     L6929
    .quad     L6930
    .quad     L6931
    .quad     L6932
    .quad     L6933
    .quad     L6934
    .quad     L6935
    .quad     L6936
    .quad     L6937
    .quad     L6938
    .quad     L6939
    .quad     L6940
    .quad     L6941
    .quad     L6942
    .quad     L6943
    .quad     L6944
    .quad     L6945
    .quad     L6946
    .quad     L6947
    .quad     L6948
    .quad     L6949
    .quad     L6950
    .quad     L6951
    .quad     L6952
    .quad     L6953
    .quad     L6954
    .quad     L6955
    .quad     L6956
    .quad     L6957
    .quad     L6958
    .quad     L6959
    .quad     L6960
    .quad     L6961
    .quad     L6962
    .quad     L6963
    .quad     L6964
    .quad     L6965
    .quad     L6966
    .quad     L6967
    .quad     L6968
    .quad     L6969
    .quad     L6970
    .quad     L6971
    .quad     L6972
    .quad     L6973
    .quad     L6974
    .quad     L6975
    .quad     L6976
    .quad     L6977
    .quad     L6978
    .quad     L6979
    .quad     L6980
    .quad     L6981
    .quad     L6982
    .quad     L6983
    .quad     L6984
    .quad     L6985
    .quad     L6986
    .quad     L6987
    .quad     L6988
    .quad     L6989
    .quad     L6990
    .quad     L6991
    .quad     L6992
    .quad     L6993
    .quad     L6994
    .quad     L6995
    .quad     L6996
    .quad     L6997
    .quad     L6998
    .quad     L6999
    .quad     L7000
    .quad     L7001
    .quad     L7002
    .quad     L7003
    .quad     L7004
    .quad     L7005
    .quad     L7006
    .quad     L7007
    .quad     L7008
    .quad     L7009
    .quad     L7010
    .quad     L7011
    .quad     L7012
    .quad     L7013
    .quad     L7014
    .quad     L7015
    .quad     L7016
    .quad     L7017
    .quad     L7018
    .quad     L7019
    .quad     L7020
    .quad     L7021
    .quad     L7022
    .quad     L7023
    .quad     L7024
    .quad     L7025
    .quad     L7026
pc_tables.pclhastype:
    .quad     0x101010101010100
    .quad     0x101010101000000
    .quad     0x101010000000101
    .quad     0x101010101010100
    .quad     0x10101010100
    .quad     0x101010101000100
    .quad     0x101010101010101
    .quad     0x101010101010101
    .quad     0x101010101010202
    .quad     0x101010101010101
    .quad     0x101010101010101
    .quad     0x101010101010101
    .quad     0x101010101010101
    .quad     0x202010101010101
    .quad     0x101000202020202
    .quad     0x10101000000
    .quad     0
    .byte     0
    .byte     1
    .byte     1
    .byte     1
    .byte     0
    .byte     0
    .byte     0
#ENDDATA
pc_tables.pclextra:
    .quad     0x2000002000100
    .quad     0x20000
    .quad     0x2020002020000
    .quad     0x10000
    .quad     0x2020001010000
    .quad     0
    .quad     0
    .quad     0x1020200
    .quad     0
    .quad     0
    .quad     0x101010100000000
    .quad     0x101
    .quad     0x100000000000000
    .quad     1
    .quad     0
    .quad     0x20000000000
    .quad     0x201000000
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
#ENDDATA
pc_tables.pclhasopnd:
    .quad     0x100000D00
    .quad     0xD00000000
    .quad     0x20000020000
    .quad     0x3030303030003
    .quad     0x303030003030300
    .quad     0xD0000
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .quad     0x3000D0101000101
    .quad     2
    .byte     0
    .byte     1
    .byte     1
    .byte     0
    .byte     0
    .byte     7
    .byte     1
#ENDDATA
pc_tables.pclargs:
    .quad     0
    .quad     0x202000000000000
    .quad     0x9090009090202
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .quad     0x101010100000000
    .quad     0x101010101010101
    .quad     0x2020201
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
#ENDDATA
    .align    8
pc_tables.ccnames:
    .quad     L7027
    .quad     L7028
    .quad     L7029
    .quad     L7030
    .quad     L7031
    .quad     L7032
    .quad     L7033
    .align    8
pc_tables.idnames:
    .quad     L7034
    .quad     L7035
    .quad     L7036
    .quad     L7037
    .quad     L7038
    .quad     L7039
    .quad     L7040
    .quad     L7041
    .quad     L7042
    .quad     L7043
    .bss
    .align    8
mc_genmcl.debug:
    .space    8
    .align    8
mc_genmcl.frameoffset:
    .space    8
    .align    8
mc_genmcl.paramoffset:
    .space    8
    .align    8
mc_genmcl.framebytes:
    .space    8
    .align    8
mc_genmcl.px_handlertable:
    .space    1144
    .data
mc_genmcl.scondcodes:
    .byte     4
    .byte     5
    .byte     12
    .byte     14
    .byte     13
    .byte     15
#ENDDATA
mc_genmcl.ucondcodes:
    .byte     4
    .byte     5
    .byte     2
    .byte     6
    .byte     3
    .byte     7
#ENDDATA
mc_genmcl.inithandlers.initdone:
    .byte     0
mc_genmcl.inithandlers.dupltable:
    .ascii    "MX"
#ENDDATA
    .ascii    "A@"
#ENDDATA
    .byte     21
    .byte     18
#ENDDATA
    .byte     19
    .byte     18
#ENDDATA
    .byte     22
    .byte     18
#ENDDATA
    .ascii    "wv"
#ENDDATA
    .ascii    "yx"
#ENDDATA
    .ascii    "^/"
#ENDDATA
    .ascii    "_0"
#ENDDATA
    .bss
    .align    8
mc_auxmcl.nnn:
    .space    8
    .align    8
mc_auxmcl.nauxprocs:
    .space    8
    .align    8
mc_auxmcl.nauxnoframe:
    .space    8
    .align    8
mc_auxmcl.mclframesetup:
    .space    8
    .align    8
mc_libmcl.mclseqno:
    .space    8
    .align    8
mc_libmcl.nmclopnd:
    .space    8
    .align    8
mc_libmcl.smallinttable:
    .space    96
    .align    8
mc_libmcl.nametable:
    .space    160
    .align    8
mc_libmcl.nnametable:
    .space    8
    .align    8
mc_libmcl.mgenextname.table:
    .space    160
    .align    8
mc_libmcl.mgenextname.ntable:
    .space    8
mc_stackmcl.stropndstack.str:
    .space    512
    .align    8
mc_genss_dummy.psstime:
    .space    8
    .data
    .align    8
mc_decls.valtypenames:
    .quad     L7044
    .quad     L7045
    .quad     L7046
    .quad     L7047
    .quad     L7048
    .quad     L7049
    .quad     L7050
    .quad     L7051
    .quad     L7052
    .align    8
mc_decls.mclnames:
    .quad     L7053
    .quad     L7054
    .quad     L7055
    .quad     L7056
    .quad     L7057
    .quad     L7058
    .quad     L7059
    .quad     L7060
    .quad     L7061
    .quad     L7062
    .quad     L7063
    .quad     L7064
    .quad     L7065
    .quad     L7066
    .quad     L7067
    .quad     L7068
    .quad     L7069
    .quad     L7070
    .quad     L7071
    .quad     L7072
    .quad     L7073
    .quad     L7074
    .quad     L7075
    .quad     L7076
    .quad     L7077
    .quad     L7078
    .quad     L7079
    .quad     L7080
    .quad     L7081
    .quad     L7082
    .quad     L7083
    .quad     L7084
    .quad     L7085
    .quad     L7086
    .quad     L7087
    .quad     L7088
    .quad     L7089
    .quad     L7090
    .quad     L7091
    .quad     L7092
    .quad     L7093
    .quad     L7094
    .quad     L7095
    .quad     L7096
    .quad     L7097
    .quad     L7098
    .quad     L7099
    .quad     L7100
    .quad     L7101
    .quad     L7102
    .quad     L7103
    .quad     L7104
    .quad     L7105
    .quad     L7106
    .quad     L7107
    .quad     L7108
    .quad     L7109
    .quad     L7110
    .quad     L7111
    .quad     L7112
    .quad     L7113
    .quad     L7114
    .quad     L7115
    .quad     L7116
    .quad     L7117
    .quad     L7118
    .quad     L7119
    .quad     L7120
    .quad     L7121
    .quad     L7122
    .quad     L7123
    .quad     L7124
    .quad     L7125
    .quad     L7126
    .quad     L7127
    .quad     L7128
    .quad     L7129
    .quad     L7130
    .quad     L7131
    .quad     L7132
    .quad     L7133
    .quad     L7134
    .quad     L7135
    .quad     L7136
    .quad     L7137
    .quad     L7138
    .quad     L7139
    .quad     L7140
    .quad     L7141
    .quad     L7142
    .quad     L7143
    .quad     L7144
    .quad     L7145
    .quad     L7146
    .quad     L7147
    .quad     L7148
    .quad     L7149
    .quad     L7150
    .quad     L7151
    .quad     L7152
    .quad     L7153
    .quad     L7154
    .quad     L7155
    .quad     L7156
    .quad     L7157
    .quad     L7158
    .quad     L7159
    .quad     L7160
    .quad     L7161
    .quad     L7162
    .quad     L7163
    .quad     L7164
    .quad     L7165
    .quad     L7166
    .quad     L7167
    .quad     L7168
    .quad     L7169
    .quad     L7170
    .quad     L7171
    .quad     L7172
    .quad     L7173
    .quad     L7174
    .quad     L7175
    .quad     L7176
    .quad     L7177
    .quad     L7178
    .quad     L7179
    .quad     L7180
    .quad     L7181
    .quad     L7182
    .quad     L7183
    .quad     L7184
    .quad     L7185
    .quad     L7186
    .quad     L7187
    .quad     L7188
    .quad     L7189
    .quad     L7190
    .quad     L7191
    .quad     L7192
    .quad     L7193
    .quad     L7194
    .quad     L7195
    .quad     L7196
    .quad     L7197
    .quad     L7198
    .quad     L7199
    .quad     L7200
    .quad     L7201
    .quad     L7202
    .quad     L7203
    .quad     L7204
mc_decls.mclnopnds:
    .quad     0
    .quad     0x202020101020001
    .quad     0x100000102020202
    .quad     0x102020202020101
    .quad     0x202020101030201
    .quad     0x202020202020202
    .quad     0x101010102
    .quad     0x202020202020100
    .quad     0x202020202020202
    .quad     0x202020202020202
    .quad     0x202020202020202
    .quad     0x101010303020202
    .quad     0x10101
    .quad     0x200000000000000
    .quad     0x101010101020202
    .quad     0x101010101000000
    .quad     0x10101010100
    .quad     0x102000000
    .quad     0
#ENDDATA
mc_decls.mclcodes:
    .quad     0
    .quad     0x9000
    .quad     0xC9C3E800000000
    .quad     0x5030205000000E9
    .quad     0x601040607000004
    .quad     0x201000507040700
    .quad     0x100020303
    .quad     0x5151ACA4BDBC0000
    .quad     0x5E5E59595C5C5858
    .quad     0xEF545457572E2F00
    .quad     0xDB
    .quad     0x302006263F36600
    .quad     0xFAF9C9E9C1030200
    .quad     0x5DE0E1F3F2FBFFFE
    .quad     0x5F5D5F
    .quad     0x804020100000000
    .quad     0xE3E3E2E1E0D7
    .quad     0xE8EE000000310000
    .quad     0xF4F400EDECEAE9EB
#ENDDATA
    .align    8
mc_decls.regnames:
    .quad     L7205
    .quad     L7206
    .quad     L7207
    .quad     L7208
    .quad     L7209
    .quad     L7210
    .quad     L7211
    .quad     L7212
    .quad     L7213
    .quad     L7214
    .quad     L7215
    .quad     L7216
    .quad     L7217
    .quad     L7218
    .quad     L7219
    .quad     L7220
    .quad     L7221
    .quad     L7222
    .quad     L7223
    .quad     L7224
    .quad     L7225
mc_decls.regcodes:
    .quad     0xC0603070B0A0000
    .quad     0x5090802010F0E0D
    .byte     4
    .byte     4
    .byte     7
    .byte     5
    .byte     6
#ENDDATA
    .align    8
mc_decls.condnames:
    .quad     L7226
    .quad     L7227
    .quad     L7228
    .quad     L7229
    .quad     L7230
    .quad     L7231
    .quad     L7232
    .quad     L7233
    .quad     L7234
    .quad     L7235
    .quad     L7236
    .quad     L7237
    .quad     L7238
    .quad     L7239
    .quad     L7240
    .quad     L7241
    .quad     L7242
    .quad     L7243
    .quad     L7244
    .quad     L7245
    .align    8
mc_decls.asmcondnames:
    .quad     L7246
    .quad     L7247
    .quad     L7248
    .quad     L7249
    .quad     L7250
    .quad     L7251
    .quad     L7252
    .quad     L7253
    .quad     L7254
    .quad     L7255
    .quad     L7256
    .quad     L7257
    .quad     L7258
    .quad     L7259
    .quad     L7260
    .quad     L7261
    .quad     L7262
    .quad     L7263
    .quad     L7264
    .quad     L7265
    .align    8
mc_decls.asmrevcond:
    .quad     1
    .quad     0
    .quad     3
    .quad     2
    .quad     5
    .quad     4
    .quad     7
    .quad     6
    .quad     9
    .quad     8
    .quad     0xB
    .quad     0xA
    .quad     0xD
    .quad     0xC
    .quad     0xF
    .quad     0xE
    .quad     0x11
    .quad     0x10
    .quad     0x13
    .quad     0x12
    .align    8
mc_decls.dregnames:
    .quad     L7266
    .quad     L7267
    .quad     L7268
    .quad     L7269
    .quad     L7270
    .quad     L7271
    .quad     L7272
    .quad     L7273
    .quad     L7274
    .quad     L7275
    .quad     L7276
    .quad     L7277
    .quad     L7278
    .quad     L7279
    .quad     L7280
    .quad     L7281
    .quad     L7282
    .quad     L7283
    .quad     L7284
    .quad     L7285
    .quad     L7286
    .quad     L7287
    .quad     L7288
    .quad     L7289
    .quad     L7290
    .quad     L7291
    .quad     L7292
    .quad     L7293
    .quad     L7294
    .quad     L7295
    .quad     L7296
    .quad     L7297
    .quad     L7298
    .quad     L7299
    .quad     L7300
    .quad     L7301
    .quad     L7302
    .quad     L7303
    .quad     L7304
    .quad     L7305
    .quad     L7306
    .quad     L7307
    .quad     L7308
    .quad     L7309
    .quad     L7310
    .quad     L7311
    .quad     L7312
    .quad     L7313
    .quad     L7314
    .quad     L7315
    .quad     L7316
    .quad     L7317
    .quad     L7318
    .quad     L7319
    .quad     L7320
    .quad     L7321
    .quad     L7322
    .quad     L7323
    .quad     L7324
    .quad     L7325
    .quad     L7326
    .quad     L7327
    .quad     L7328
    .quad     L7329
    .quad     L7330
    .quad     L7331
    .quad     L7332
    .quad     L7333
    .quad     L7334
    .quad     L7335
    .quad     L7336
    .quad     L7337
    .quad     L7338
    .quad     L7339
    .quad     L7340
    .quad     L7341
    .quad     L7342
    .quad     L7343
    .quad     L7344
    .quad     L7345
    .quad     L7346
    .quad     L7347
    .quad     L7348
    .quad     L7349
    .quad     L7350
    .quad     L7351
    .quad     L7352
    .quad     L7353
    .quad     L7354
    .quad     L7355
    .quad     L7356
    .quad     L7357
    .quad     L7358
    .quad     L7359
    .quad     L7360
    .quad     L7361
    .quad     L7362
    .quad     L7363
    .quad     L7364
    .quad     L7365
    .quad     L7366
    .quad     L7367
    .quad     L7368
    .quad     L7369
    .quad     L7370
    .quad     L7371
    .quad     L7372
    .quad     L7373
    .quad     L7374
    .quad     L7375
    .quad     L7376
    .quad     L7377
    .quad     L7378
    .quad     L7379
    .quad     L7380
    .quad     L7381
    .quad     L7382
    .quad     L7383
    .quad     L7384
    .quad     L7385
    .quad     L7386
    .quad     L7387
    .quad     L7388
    .quad     L7389
    .quad     L7390
    .quad     L7391
    .quad     L7392
    .quad     L7393
    .quad     L7394
    .quad     L7395
    .quad     L7396
    .quad     L7397
    .quad     L7398
    .quad     L7399
    .quad     L7400
    .quad     L7401
    .quad     L7402
mc_decls.regsizes:
    .quad     0x808080808080808
    .quad     0x808080808080808
    .quad     0x404040404040404
    .quad     0x404040404040404
    .quad     0x202020202020202
    .quad     0x202020202020202
    .quad     0x101010101010101
    .quad     0x101010101010101
    .quad     0x808080001010101
    .quad     0x808080808080808
    .quad     0x404040808080808
    .quad     0x404040404040404
    .quad     0x202020404040404
    .quad     0x202020202020202
    .quad     0x101010202020202
    .quad     0x101010101010101
    .quad     0x101010101010101
    .byte     1
#ENDDATA
mc_decls.regindices:
    .quad     0x807060504030201
    .quad     0x100F0E0D0C0B0A09
    .quad     0x807060504030201
    .quad     0x100F0E0D0C0B0A09
    .quad     0x807060504030201
    .quad     0x100F0E0D0C0B0A09
    .quad     0x807060504030201
    .quad     0x100F0E0D0C0B0A09
    .quad     0xB05010014131211
    .quad     0x20E0D100F04060C
    .quad     0xB05010A09080703
    .quad     0x20E0D100F04060C
    .quad     0xB05010A09080703
    .quad     0x20E0D100F04060C
    .quad     0xB05010A09080703
    .quad     0xF0406141312110C
    .quad     0x9080703020E0D10
    .byte     10
#ENDDATA
    .align    8
mc_decls.xmmregnames:
    .quad     L7403
    .quad     L7404
    .quad     L7405
    .quad     L7406
    .quad     L7407
    .quad     L7408
    .quad     L7409
    .quad     L7410
    .quad     L7411
    .quad     L7412
    .quad     L7413
    .quad     L7414
    .quad     L7415
    .quad     L7416
    .quad     L7417
    .quad     L7418
    .align    8
mc_decls.fregnames:
    .quad     L7419
    .quad     L7420
    .quad     L7421
    .quad     L7422
    .quad     L7423
    .quad     L7424
    .quad     L7425
    .quad     L7426
    .align    8
mc_decls.mregnames:
    .quad     L7427
    .quad     L7428
    .quad     L7429
    .quad     L7430
    .quad     L7431
    .quad     L7432
    .quad     L7433
    .quad     L7434
    .align    8
mc_decls.jmpccnames:
    .quad     L7435
    .quad     L7436
    .quad     L7437
    .quad     L7438
    .quad     L7439
    .quad     L7440
    .quad     L7441
    .quad     L7442
    .quad     L7443
    .quad     L7444
    .quad     L7445
    .quad     L7446
    .quad     L7447
    .quad     L7448
    .quad     L7449
    .quad     L7450
    .quad     L7451
    .quad     L7452
mc_decls.jmpcccodes:
    .quad     0x706050403020100
    .quad     0xF0E0D0C0B0A0908
    .byte     2
    .byte     3
#ENDDATA
    .align    8
mc_decls.setccnames:
    .quad     L7453
    .quad     L7454
    .quad     L7455
    .quad     L7456
    .quad     L7457
    .quad     L7458
    .quad     L7459
    .quad     L7460
    .quad     L7461
    .quad     L7462
    .quad     L7463
    .quad     L7464
    .quad     L7465
    .quad     L7466
    .quad     L7467
    .quad     L7468
mc_decls.setcccodes:
    .quad     0x706050403020100
    .quad     0xF0E0D0C0B0A0908
#ENDDATA
    .align    8
mc_decls.cmovccnames:
    .quad     L7469
    .quad     L7470
    .quad     L7471
    .quad     L7472
    .quad     L7473
    .quad     L7474
    .quad     L7475
    .quad     L7476
    .quad     L7477
    .quad     L7478
    .quad     L7479
    .quad     L7480
    .quad     L7481
    .quad     L7482
    .quad     L7483
    .quad     L7484
mc_decls.cmovcccodes:
    .quad     0x706050403020100
    .quad     0xF0E0D0C0B0A0908
#ENDDATA
    .align    8
mc_decls.segmentnames:
    .quad     L7485
    .quad     L7486
    .quad     L7487
    .quad     L7488
    .quad     L7489
    .quad     L7490
    .align    8
mc_decls.reftypenames:
    .quad     L7491
    .quad     L7492
    .quad     L7493
    .align    8
mc_decls.opndnames_ma:
    .quad     L7494
    .quad     L7495
    .quad     L7496
    .quad     L7497
    .quad     L7498
    .quad     L7499
    .bss
    .align    8
mc_decls.pclopnd:
    .space    400
mc_decls.pclreg:
    .space    50
mc_decls.pclmode:
    .space    50
mc_decls.pclcount:
    .space    50
mc_decls.pclloc:
    .space    50
mc_decls.pcltempflags:
    .space    50
    .align    8
mc_decls.pcltempopnds:
    .space    400
    .align    8
mc_decls.noperands:
    .space    8
    .align    8
mc_decls.mstackdepth:
    .space    8
    .data
    .align    8
mc_decls.locnames:
    .quad     L7500
    .quad     L7501
    .quad     L7502
    .quad     L7503
    .bss
mc_decls.workregs:
    .space    16
mc_decls.workxregs:
    .space    16
    .align    8
mc_decls.nworkregs:
    .space    8
    .align    8
mc_decls.nworkxregs:
    .space    8
    .align    8
mc_decls.nregvars:
    .space    8
    .align    8
mc_decls.nxregvars:
    .space    8
    .align    8
mc_decls.maxregvars:
    .space    8
    .align    8
mc_decls.maxxregvars:
    .space    8
    .align    8
mc_decls.xregmax:
    .space    8
mc_decls.regset:
    .space    16
mc_decls.xregset:
    .space    16
mc_decls.isregvar:
    .space    16
mc_decls.isxregvar:
    .space    16
mc_decls.usedregs:
    .space    16
mc_decls.usedxregs:
    .space    16
mc_decls.noxorclear:
    .space    1
    .data
    .align    8
mc_decls.xregnames:
    .quad     L7504
    .quad     L7505
    .quad     L7506
    .quad     L7507
    .quad     L7508
    .quad     L7509
    .quad     L7510
    .quad     L7511
    .quad     L7512
    .quad     L7513
    .quad     L7514
    .quad     L7515
    .quad     L7516
    .quad     L7517
    .quad     L7518
    .quad     L7519
    .quad     L7519
    .bss
mc_decls.callalign:
    .space    16
mc_decls.callblockret:
    .space    16
    .align    4
mc_decls.callblocksize:
    .space    64
mc_decls.callargmode:
    .space    512
    .align    4
mc_decls.callargsize:
    .space    2048
    .align    8
mc_decls.ncalldepth:
    .space    8
    .align    8
mc_decls.lababs32:
    .space    8
    .align    8
mc_decls.lababs64:
    .space    8
    .align    8
mc_decls.labneg32:
    .space    8
    .align    8
mc_decls.labneg64:
    .space    8
    .align    8
mc_decls.labmask63:
    .space    8
    .align    8
mc_decls.laboffset64:
    .space    8
    .align    8
mc_decls.labzero:
    .space    8
    .data
    .align    8
mc_decls.kk0used:
    .quad     0
    .bss
    .align    8
mc_decls.mccode:
    .space    8
    .align    8
mc_decls.mccodex:
    .space    8
    .data
    .align    8
mc_decls.currsegment:
    .quad     0
    .bss
    .align    8
mc_decls.dstackopnd:
    .space    8
    .align    8
mc_decls.dframeopnd:
    .space    8
    .align    8
mc_decls.regtable:
    .space    1024
    .align    8
mc_decls.frameregtable:
    .space    1544
    .align    8
mc_decls.cstringlist:
    .space    8
    .align    8
mc_decls.vstringlist:
    .space    8
    .align    8
mc_decls.creallist:
    .space    8
    .align    8
mc_decls.cr32list:
    .space    8
    .align    8
mc_decls.currasmproc:
    .space    8
    .align    8
mc_decls.lab_funcnametable:
    .space    8
    .align    8
mc_decls.lab_funcaddrtable:
    .space    8
    .align    8
mc_decls.lab_funcnprocs:
    .space    8
    .align    8
mc_decls.ss_zdatalen:
    .space    8
    .align    8
mc_decls.ss_zdata:
    .space    8
    .align    8
mc_decls.ss_idata:
    .space    8
    .align    8
mc_decls.ss_code:
    .space    8
    .align    8
mc_decls.ss_idatarelocs:
    .space    8
    .align    8
mc_decls.ss_coderelocs:
    .space    8
    .align    8
mc_decls.ss_nidatarelocs:
    .space    8
    .align    8
mc_decls.ss_ncoderelocs:
    .space    8
    .align    8
mc_decls.ss_symboltable:
    .space    8
    .align    8
mc_decls.ss_nsymbols:
    .space    8
    .align    8
mc_decls.ss_symboltablesize:
    .space    8
    .align    8
mc_decls.labeldeftable:
    .space    8
    .align    8
mc_decls.aaseqno:
    .space    8
    .align    8
mc_decls.aapos:
    .space    8
    .data
mc_decls.regmodes:
    .quad     0x600000005000403
#ENDDATA
    .bss
mc_decls.pmode:
    .space    1
    .align    8
mc_decls.currpcl:
    .space    8
    .align    8
mc_decls.mclprocentry:
    .space    8
    .align    8
mc_decls.mce_oldmccodex:
    .space    8
    .align    8
mc_decls.mce_lastmcl:
    .space    8
    .align    8
mc_decls.mce_nextmcl:
    .space    8
    .align    8
mc_decls.mcf_oldmccodex:
    .space    8
    .align    8
mc_decls.mcf_lastmcl:
    .space    8
    .align    8
mc_decls.mcf_nextmcl:
    .space    8
mc_decls.fpcheckunusedlocals:
    .space    1
    .align    8
mc_decls.riplist:
    .space    8
    .align    8
mc_decls.blockdefs:
    .space    400
    .align    8
mc_decls.nblocktemps:
    .space    8
    .data
    .align    8
mc_decls.multregs:
    .quad     1
    .quad     2
    .quad     3
    .quad     0xB
    .quad     0xC
    .quad     0xD
    .align    8
mc_decls.multxregs:
    .quad     1
    .quad     2
    .quad     3
    .quad     4
    .quad     5
    .quad     6
    .bss
mc_decls.ploadopx:
    .space    14
mc_decls.ploadop:
    .space    14
    .data
    .align    8
mc_objdecls.relocnames:
    .quad     L7520
    .quad     L7521
    .quad     L7522
    .quad     L7523
    .quad     L7524
    .quad     L7525
    .quad     L7526
    .align    8
mc_writegas.asmext:
    .quad     L7527
    .bss
    .align    8
mc_writegas.nregnames:
    .space    1024
mc_writegas.currseg:
    .space    1
mc_writegas.strmcl.str:
    .space    512
mc_writegas.mstropnd.str:
    .space    512
mc_writegas.strvalue.str:
    .space    512
mc_writegas.getxregname.str:
    .space    32
mc_writegas.getdispname.str:
    .space    256
mc_writegas.gettempname.str:
    .space    128
mc_writegas.strreg.str:
    .space    16
    .data
    .align    8
cc_cli.passnames:
    .quad     L7528
    .quad     L7529
    .quad     L7530
    .quad     L7531
    .quad     L7532
    .quad     L7533
    .quad     L7534
    .quad     L7535
    .quad     L7536
    .quad     L7537
    .quad     L7538
    .quad     L7539
    .quad     L7540
    .align    8
cc_cli.extnames:
    .quad     L7541
    .quad     L7542
    .quad     L7543
    .quad     L7543
    .quad     L7544
    .quad     L7545
    .quad     L7546
    .quad     L7546
    .quad     L7547
    .quad     L7548
    .quad     L7549
    .quad     L7550
    .quad     L7551
    .bss
cc_cli.cc_pass:
    .space    1
cc_cli.dummy:
    .space    20
cc_cli.debugmode:
    .space    1
    .align    8
cc_cli.outfile:
    .space    8
    .data
    .align    8
cc_cli.outext:
    .quad     L7552
    .bss
    .align    8
cc_cli.cmdskip:
    .space    8
    .align    8
cc_cli.ttt:
    .space    8
    .data
cc_cli.fverbose:
    .byte     1
cc_cli.fshowincludes:
    .byte     0
cc_cli.dointheaders:
    .byte     1
cc_cli.highmem:
    .byte     1
    .bss
cc_cli.fshowst:
    .space    1
cc_cli.fshowstflat:
    .space    1
cc_cli.fshowast:
    .space    1
cc_cli.fshowpcl:
    .space    1
cc_cli.fshowpst:
    .space    1
cc_cli.fshowmcl:
    .space    1
cc_cli.fshowss:
    .space    1
cc_cli.fshowtypes:
    .space    1
cc_cli.fshowfiles:
    .space    1
cc_cli.fshowpaths:
    .space    1
cc_cli.fshowheaders:
    .space    1
cc_cli.fwriteheaders:
    .space    1
cc_cli.fshowlog:
    .space    1
cc_cli.fshowtiming:
    .space    1
cc_cli.fgendll:
    .space    1
cc_cli.fstdout:
    .space    1
cc_cli.fshortnames:
    .space    1
    .data
cc_cli.fwriteerrors:
    .byte     1
    .bss
    .align    8
cc_cli.entrypointname:
    .space    8
    .data
    .align    8
cc_cli.optionnames:
    .quad     L7553
    .quad     L7554
    .quad     L7555
    .quad     L7556
    .quad     L7557
    .quad     L7558
    .quad     L7559
    .quad     L7560
    .quad     L7561
    .quad     L7562
    .quad     L7563
    .quad     L7564
    .quad     L7565
    .quad     L7566
    .quad     L7567
    .quad     L7568
    .quad     L7569
    .quad     L7570
    .quad     L7571
    .quad     L7572
    .quad     L7573
    .quad     L7574
    .quad     L7575
    .quad     L7576
    .quad     L7577
    .quad     L7578
    .quad     L7579
    .quad     L7580
    .quad     L7581
    .quad     L7582
    .quad     L7583
    .quad     L7584
    .quad     L7585
    .quad     L7586
    .quad     L7587
    .quad     L7588
    .quad     L7589
    .quad     L7590
    .quad     L7591
    .quad     L7592
    .quad     L7593
    .quad     L7594
    .quad     L7595
    .quad     L7596
    .quad     L7597
    .quad     L7598
    .quad     L7599
    .quad     L7600
    .quad     L7601
    .quad     L7602
    .quad     L7603
    .quad     L7604
    .quad     L7605
    .align    8
cc_cli.optvars:
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     pc_decls.fregoptim
    .quad     pc_decls.fpeephole
    .quad     0
    .quad     pc_decls.fnoconst
    .quad     cc_cli.fshowpaths
    .quad     cc_cli.fshowheaders
    .quad     0
    .quad     cc_cli.fshowincludes
    .quad     cc_cli.fshowst
    .quad     cc_cli.fshowstflat
    .quad     cc_cli.fshowast
    .quad     cc_cli.fshowpcl
    .quad     cc_cli.fshowpst
    .quad     cc_cli.fshowmcl
    .quad     cc_cli.fshowss
    .quad     cc_cli.fshowtypes
    .quad     cc_cli.fshowfiles
    .quad     cc_cli.fshowtiming
    .quad     cc_cli.fshowtiming
    .quad     cc_cli.fverbose
    .quad     cc_cli.fverbose
    .quad     cc_cli.fverbose
    .quad     pc_decls.pverbose
    .quad     pc_decls.pverbose
    .quad     0
    .quad     0
    .quad     cc_cli.dointheaders
    .quad     cc_cli.fwriteheaders
    .quad     0
    .quad     cc_cli.fstdout
    .quad     cc_cli.fshortnames
    .quad     cc_cli.highmem
    .quad     cc_cli.highmem
    .quad     0
    .quad     pc_decls.fshowil
    .quad     pc_decls.flong64
cc_cli.optvalues:
    .quad     0x605050403020201
    .quad     0xC0B090A0A080807
    .quad     0x10101010000000D
    .quad     0x101010101010101
    .quad     0x100030202010101
    .quad     0x101000100000002
    .byte     0
    .byte     2
    .byte     0
    .byte     1
    .byte     1
#ENDDATA
    .align    8
cc_cli.totallines:
    .quad     0
    .align    8
cc_cli.nstringobjects:
    .quad     0
    .bss
    .align    8
cc_cli.startclock:
    .space    8
    .align    8
cc_cli.loadtime:
    .space    8
    .align    8
cc_cli.parsetime:
    .space    8
    .align    8
cc_cli.pcltime:
    .space    8
    .align    8
cc_cli.compiletime:
    .space    8
    .align    8
cc_cli.inittime:
    .space    8
    .data
    .align    8
cc_cli.showextrainfo.infotext:
    .quad     L7606
    .bss
    .align    8
cc_decls.ntypes:
    .space    8
    .align    8
cc_decls.ttnamedef:
    .space    640000
    .align    2
cc_decls.ttbasetype:
    .space    160000
    .align    8
cc_decls.ttlength:
    .space    640000
cc_decls.ttconst:
    .space    80000
    .align    2
cc_decls.tttarget:
    .space    160000
    .align    2
cc_decls.ttreftype:
    .space    160000
    .align    2
cc_decls.ttconsttype:
    .space    160000
    .align    8
cc_decls.ttsize:
    .space    640000
cc_decls.ttisref:
    .space    80000
cc_decls.ttisblock:
    .space    80000
cc_decls.ttsigned:
    .space    80000
    .align    4
cc_decls.ttshared:
    .space    320000
    .align    8
cc_decls.ttparams:
    .space    640000
    .align    8
cc_decls.tttypedef:
    .space    640000
    .align    8
cc_decls.trefchar:
    .space    8
    .align    8
cc_decls.trefwchar:
    .space    8
    .align    8
cc_decls.inputfile:
    .space    8
    .align    8
cc_decls.mainfileno:
    .space    8
    .align    8
cc_decls.libfiles:
    .space    1608
    .align    8
cc_decls.sourcefilenames:
    .space    1608
    .align    8
cc_decls.sourcefilepaths:
    .space    1608
    .align    8
cc_decls.sourcefiletext:
    .space    1608
    .align    4
cc_decls.sourcefilesizes:
    .space    804
    .align    8
cc_decls.nsourcefiles:
    .space    8
    .align    8
cc_decls.nlibfiles:
    .space    8
    .align    8
cc_decls.searchdirs:
    .space    160
    .data
    .align    8
cc_decls.nsearchdirs:
    .quad     0
    .bss
    .align    8
cc_decls.includepaths:
    .space    160
    .data
    .align    8
cc_decls.nincludepaths:
    .quad     0
    .bss
    .align    8
cc_decls.stprogram:
    .space    8
    .align    8
cc_decls.stmodule:
    .space    8
    .align    8
cc_decls.logdev:
    .space    8
    .align    8
cc_decls.nullunit:
    .space    8
    .data
    .align    8
cc_decls.clineno:
    .quad     0
    .align    8
cc_decls.cfileno:
    .quad     0
    .bss
    .align    8
cc_decls.lx:
    .space    32
    .align    8
cc_decls.nextlx:
    .space    32
    .data
    .align    8
cc_decls.debug:
    .quad     0
    .align    8
cc_decls.hstsize:
    .quad     0x10000
    .bss
    .align    8
cc_decls.hstmask:
    .space    8
    .align    8
cc_decls.hashtable:
    .space    8
    .align    4
cc_decls.blockowner:
    .space    8404
    .align    4
cc_decls.blockcounts:
    .space    8404
    .align    4
cc_decls.blockstack:
    .space    404
    .align    8
cc_decls.currblockno:
    .space    8
    .align    8
cc_decls.nextblockno:
    .space    8
    .align    8
cc_decls.blocklevel:
    .space    8
    .align    8
cc_decls.currproc:
    .space    8
    .data
    .align    8
cc_decls.dheaderfile:
    .quad     0
    .align    8
cc_decls.structpadding:
    .quad     1
    .align    8
cc_decls.callbackflag:
    .quad     0
    .bss
    .align    8
cc_decls.slineno:
    .space    8
    .align    8
cc_decls.sfileno:
    .space    8
    .data
    .align    8
cc_decls.oemname:
    .quad     L7607
    .bss
    .align    8
cc_decls.mclstr:
    .space    8
    .align    8
cc_decls.mclstrlen:
    .space    8
    .align    8
cc_decls.nunits:
    .space    8
    .align    8
cc_decls.pmodulelist:
    .space    1592
    .align    8
cc_decls.pheaderlist:
    .space    800
    .align    8
cc_decls.pliblist:
    .space    800
    .align    8
cc_decls.npmodules:
    .space    8
    .align    8
cc_decls.npheaders:
    .space    8
    .align    8
cc_decls.nplibs:
    .space    8
cc_decls.pci_target:
    .space    1
    .data
    .align    8
cc_tables.stdtypenames:
    .quad     L7608
    .quad     L7609
    .quad     L7610
    .quad     L7611
    .quad     L7612
    .quad     L7613
    .quad     L7614
    .quad     L7615
    .quad     L7616
    .quad     L7617
    .quad     L7618
    .quad     L7619
    .quad     L7620
    .quad     L7621
    .quad     L7622
    .quad     L7623
    .quad     L7624
    .quad     L7625
    .quad     L7626
    .quad     L7627
    .quad     L7628
    .quad     L7629
cc_tables.stdtypewidths:
    .quad     0x1008084020100800
    .quad     0x4040400040204020
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
#ENDDATA
cc_tables.stdsigned:
    .quad     0x101010100
    .quad     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
#ENDDATA
cc_tables.stdpcl:
    .quad     0x403030A09080700
    .quad     0x60902010605
    .byte     11
    .byte     11
    .byte     11
    .byte     11
    .byte     0
    .byte     0
#ENDDATA
cc_tables.stdsize:
    .quad     0x201010804020100
    .quad     0x8040804
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
#ENDDATA
    .align    8
cc_tables.catnames:
    .quad     L7630
    .quad     L7631
    .quad     L7632
    .quad     L7633
    .quad     L7634
    .align    8
cc_tables.typespecnames:
    .quad     L7635
    .quad     L7636
    .quad     L7637
    .quad     L7638
    .quad     L7639
    .quad     L7640
    .quad     L7641
    .quad     L7642
    .quad     L7643
    .quad     L7644
    .quad     L7645
    .quad     L7646
    .quad     L7647
    .quad     L7648
    .quad     L7649
    .align    4
cc_tables.typespectypes:
    .long     0
    .long     1
    .long     0
    .long     0
    .long     3
    .long     10
    .long     11
    .long     0
    .long     0
    .long     5
    .long     0
    .long     0
    .long     0
    .long     0
    .long     0
cc_tables.typespecsizes:
    .quad     0x8040404020100
    .byte     0
    .byte     1
    .byte     0
    .byte     0
    .byte     0
    .byte     4
    .byte     0
#ENDDATA
    .align    8
cc_tables.pmflagnames:
    .quad     L7650
    .quad     L7651
    .quad     L7652
    .quad     L7653
    .align    8
cc_tables.scopenames:
    .quad     L7654
    .quad     L7655
    .quad     L7656
    .quad     L7657
    .quad     L7658
    .align    8
cc_tables.cccnames:
    .quad     L7659
    .quad     L7660
    .quad     L7661
    .quad     L7662
    .quad     L7663
    .quad     L7664
    .align    8
cc_tables.linkagenames:
    .quad     L7665
    .quad     L7666
    .quad     L7667
    .quad     L7668
    .quad     L7669
    .quad     L7670
    .align    8
cc_tables.typequalnames:
    .quad     L7671
    .quad     L7672
    .quad     L7673
    .quad     L7674
    .align    8
cc_tables.fnspecnames:
    .quad     L7675
    .quad     L7676
    .quad     L7677
    .align    8
cc_tables.jtagnames:
    .quad     L7678
    .quad     L7679
    .quad     L7680
    .quad     L7681
    .quad     L7682
    .quad     L7683
    .quad     L7684
    .quad     L7685
    .quad     L7686
    .quad     L7687
    .quad     L7688
    .quad     L7689
    .quad     L7690
    .quad     L7691
    .quad     L7692
    .quad     L7693
    .quad     L7694
    .quad     L7695
    .quad     L7696
    .quad     L7697
    .quad     L7698
    .quad     L7699
    .quad     L7700
    .quad     L7701
    .quad     L7702
    .quad     L7703
    .quad     L7704
    .quad     L7705
    .quad     L7706
    .quad     L7707
    .quad     L7708
    .quad     L7709
    .quad     L7710
    .quad     L7711
    .quad     L7712
    .quad     L7713
    .quad     L7714
    .quad     L7715
    .quad     L7716
    .quad     L7717
    .quad     L7718
    .quad     L7719
    .quad     L7720
    .quad     L7721
    .quad     L7722
    .quad     L7723
    .quad     L7724
    .quad     L7725
    .quad     L7726
    .quad     L7727
    .quad     L7728
    .quad     L7729
    .quad     L7730
    .quad     L7731
    .quad     L7732
    .quad     L7733
    .quad     L7734
    .quad     L7735
    .quad     L7736
    .quad     L7737
    .quad     L7738
    .quad     L7739
    .quad     L7740
    .quad     L7741
    .quad     L7742
    .quad     L7743
    .quad     L7744
    .quad     L7745
    .quad     L7746
    .quad     L7747
    .quad     L7748
    .quad     L7749
    .quad     L7750
    .quad     L7751
    .quad     L7752
    .quad     L7753
    .quad     L7754
    .quad     L7755
    .align    8
cc_tables.symbolnames:
    .quad     L7756
    .quad     L7757
    .quad     L7758
    .quad     L7759
    .quad     L7760
    .quad     L7761
    .quad     L7762
    .quad     L7763
    .quad     L7764
    .quad     L7765
    .quad     L7766
    .quad     L7767
    .quad     L7768
    .quad     L7769
    .quad     L7770
    .quad     L7771
    .quad     L7772
    .quad     L7773
    .quad     L7774
    .quad     L7775
    .quad     L7776
    .quad     L7777
    .quad     L7778
    .quad     L7779
    .quad     L7780
    .quad     L7781
    .quad     L7782
    .quad     L7783
    .quad     L7784
    .quad     L7785
    .quad     L7786
    .quad     L7787
    .quad     L7788
    .quad     L7789
    .quad     L7790
    .quad     L7791
    .quad     L7792
    .quad     L7793
    .quad     L7794
    .quad     L7795
    .quad     L7796
    .quad     L7797
    .quad     L7798
    .quad     L7799
    .quad     L7800
    .quad     L7801
    .quad     L7802
    .quad     L7803
    .quad     L7804
    .quad     L7805
    .quad     L7806
    .quad     L7807
    .quad     L7808
    .quad     L7809
    .quad     L7810
    .quad     L7811
    .quad     L7812
    .quad     L7813
    .quad     L7814
    .quad     L7815
    .quad     L7816
    .quad     L7817
    .quad     L7818
    .quad     L7819
    .quad     L7820
    .quad     L7821
    .quad     L7822
    .quad     L7823
    .quad     L7824
    .quad     L7825
    .quad     L7826
    .quad     L7827
    .quad     L7828
    .quad     L7829
    .quad     L7830
    .quad     L7831
    .quad     L7832
    .quad     L7833
    .quad     L7834
    .quad     L7835
    .quad     L7836
    .quad     L7837
    .quad     L7838
    .quad     L7839
    .quad     L7840
    .quad     L7841
    .quad     L7842
    .quad     L7843
    .quad     L7844
    .quad     L7845
    .quad     L7846
    .quad     L7847
    .quad     L7848
    .quad     L7849
    .quad     L7850
    .quad     L7851
    .quad     L7852
    .align    8
cc_tables.shortsymbolnames:
    .quad     L7853
    .quad     L7854
    .quad     L7855
    .quad     L7856
    .quad     L7856
    .quad     L7856
    .quad     L7857
    .quad     L7858
    .quad     L7859
    .quad     L7860
    .quad     L7861
    .quad     L7862
    .quad     L7863
    .quad     L7864
    .quad     L7865
    .quad     L7866
    .quad     L7867
    .quad     L7868
    .quad     L7869
    .quad     L7870
    .quad     L7871
    .quad     L7872
    .quad     L7873
    .quad     L7874
    .quad     L7875
    .quad     L7876
    .quad     L7877
    .quad     L7878
    .quad     L7879
    .quad     L7880
    .quad     L7881
    .quad     L7882
    .quad     L7883
    .quad     L7884
    .quad     L7885
    .quad     L7886
    .quad     L7887
    .quad     L7888
    .quad     L7889
    .quad     L7890
    .quad     L7891
    .quad     L7892
    .quad     L7893
    .quad     L7894
    .quad     L7895
    .quad     L7896
    .quad     L7897
    .quad     L7898
    .quad     L7899
    .quad     L7900
    .quad     L7901
    .quad     L7902
    .quad     L7903
    .quad     L7904
    .quad     L7905
    .quad     L7906
    .quad     L7906
    .quad     L7907
    .quad     L7907
    .quad     L7907
    .quad     L7908
    .quad     L7908
    .quad     L7908
    .quad     L7908
    .quad     L7909
    .quad     L7910
    .quad     L7911
    .quad     L7911
    .quad     L7911
    .quad     L7911
    .quad     L7911
    .quad     L7911
    .quad     L7911
    .quad     L7911
    .quad     L7911
    .quad     L7911
    .quad     L7911
    .quad     L7911
    .quad     L7911
    .quad     L7911
    .quad     L7911
    .quad     L7911
    .quad     L7911
    .quad     L7911
    .quad     L7911
    .quad     L7911
    .quad     L7911
    .quad     L7911
    .quad     L7911
    .quad     L7911
    .quad     L7911
    .quad     L7911
    .quad     L7911
    .quad     L7911
    .quad     L7911
    .quad     L7911
    .quad     L7912
cc_tables.symboltojtag:
    .quad     0x323100
    .quad     0xB0B0000
    .quad     0x2827000000000000
    .quad     0x18192E2C2D2B2A29
    .quad     0x213B48471A3C302F
    .quad     0x3F3E3D2526242322
    .quad     0x46454442434140
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .byte     0
#ENDDATA
    .align    8
cc_tables.sourcedirnames:
    .quad     L7913
    .quad     L7914
    .quad     L7915
    .quad     L7916
    .quad     L7917
    .quad     L7918
    .quad     L7919
    .quad     L7920
    .quad     L7921
    .quad     L7922
    .quad     L7923
    .quad     L7924
    .quad     L7925
    .quad     L7926
    .quad     L7927
    .align    8
cc_tables.namespacenames:
    .quad     L7928
    .quad     L7929
    .quad     L7930
    .quad     L7931
    .quad     L7932
    .align    8
cc_tables.namenames:
    .quad     L7933
    .quad     L7934
    .quad     L7935
    .quad     L7936
    .quad     L7937
    .quad     L7938
    .quad     L7939
    .quad     L7940
    .quad     L7941
    .quad     L7942
    .quad     L7943
    .quad     L7944
    .quad     L7945
    .quad     L7946
    .quad     L7947
    .align    4
cc_tables.namespaces:
    .long     0
    .long     0
    .long     0
    .long     0
    .long     0
    .long     1
    .long     1
    .long     1
    .long     1
    .long     1
    .long     4
    .long     1
    .long     2
    .long     2
    .long     3
cc_tables.name2pid:
    .quad     0x302000000000000
    .byte     4
    .byte     5
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     6
#ENDDATA
    .align    8
cc_tables.stnames:
    .quad     L7948
    .quad     L7949
    .quad     L7950
    .quad     L7951
    .quad     L7952
    .quad     L7953
    .quad     L7954
    .quad     L7955
    .quad     L7956
    .quad     L7957
    .quad     L7958
    .quad     L7959
    .quad     L7960
    .quad     L7961
    .quad     L7962
    .quad     L7963
    .quad     L7964
    .quad     L7965
    .quad     L7966
    .quad     L7967
    .quad     L7968
    .quad     L7969
    .quad     L7970
    .quad     L7971
    .quad     L7972
    .quad     L7973
    .quad     L7974
    .quad     L7975
    .quad     L7976
    .quad     L7977
    .quad     L7978
    .quad     L7979
    .quad     L7980
    .quad     L7981
    .quad     L7982
    .quad     L7983
    .quad     L7984
    .quad     L7985
    .quad     L7986
    .quad     L7987
    .quad     L7988
    .quad     L7989
    .quad     L7990
    .quad     L7991
    .quad     L7992
    .quad     L7993
    .quad     L7994
    .quad     L7995
    .quad     L7996
    .quad     L7997
    .quad     L7998
    .quad     L7999
    .quad     L8000
    .quad     L8001
    .quad     L8002
    .quad     L8003
    .quad     L8004
    .quad     L8005
    .quad     L8006
    .quad     L8007
    .quad     L8008
    .quad     L8009
    .quad     L8010
    .quad     L8011
    .align    4
cc_tables.stsymbols:
    .long     72
    .long     73
    .long     74
    .long     75
    .long     76
    .long     78
    .long     77
    .long     79
    .long     80
    .long     81
    .long     82
    .long     83
    .long     84
    .long     85
    .long     68
    .long     68
    .long     68
    .long     68
    .long     68
    .long     68
    .long     68
    .long     68
    .long     68
    .long     68
    .long     86
    .long     86
    .long     86
    .long     86
    .long     86
    .long     87
    .long     87
    .long     87
    .long     87
    .long     89
    .long     89
    .long     90
    .long     91
    .long     71
    .long     71
    .long     71
    .long     71
    .long     71
    .long     71
    .long     71
    .long     71
    .long     71
    .long     71
    .long     69
    .long     69
    .long     69
    .long     69
    .long     69
    .long     69
    .long     69
    .long     69
    .long     70
    .long     92
    .long     92
    .long     93
    .long     94
    .long     95
    .long     96
    .long     96
    .long     0
    .align    4
cc_tables.stsubcodes:
    .long     12
    .long     0
    .long     0
    .long     0
    .long     0
    .long     0
    .long     0
    .long     0
    .long     0
    .long     0
    .long     0
    .long     0
    .long     0
    .long     0
    .long     7
    .long     1
    .long     4
    .long     8
    .long     9
    .long     6
    .long     10
    .long     11
    .long     15
    .long     14
    .long     2
    .long     3
    .long     1
    .long     4
    .long     5
    .long     1
    .long     2
    .long     3
    .long     4
    .long     1
    .long     2
    .long     0
    .long     0
    .long     1
    .long     2
    .long     3
    .long     4
    .long     5
    .long     6
    .long     7
    .long     8
    .long     9
    .long     10
    .long     1
    .long     3
    .long     4
    .long     2
    .long     7
    .long     8
    .long     5
    .long     5
    .long     0
    .long     0
    .long     1
    .long     0
    .long     0
    .long     0
    .long     75
    .long     76
    .long     0
    .align    8
cc_tables.convnames:
    .quad     L8012
    .quad     L8013
    .quad     L8014
    .quad     L8015
    .quad     L8016
    .quad     L8017
    .quad     L8018
    .quad     L8019
    .quad     L8020
    .quad     L8021
    .quad     L8022
    .quad     L8023
    .quad     L8024
    .quad     L8025
    .bss
cc_tables.dominantmode:
    .space    1024
cc_tables.conversionops:
    .space    256
    .data
cc_tables.dominantsetuptable:
    .byte     1
    .byte     1
    .byte     3
#ENDDATA
    .byte     1
    .byte     2
    .byte     3
#ENDDATA
    .byte     1
    .byte     3
    .byte     3
#ENDDATA
    .byte     1
    .byte     4
    .byte     4
#ENDDATA
    .byte     1
    .byte     5
    .byte     3
#ENDDATA
    .byte     1
    .byte     6
    .byte     3
#ENDDATA
    .byte     1
    .byte     7
    .byte     3
#ENDDATA
    .byte     1
    .byte     8
    .byte     3
#ENDDATA
    .byte     1
    .byte     9
    .byte     4
#ENDDATA
    .byte     1
    .byte     10
    .byte     10
#ENDDATA
    .byte     1
    .byte     11
    .byte     11
#ENDDATA
    .byte     2
    .byte     1
    .byte     3
#ENDDATA
    .byte     2
    .byte     2
    .byte     3
#ENDDATA
    .byte     2
    .byte     3
    .byte     3
#ENDDATA
    .byte     2
    .byte     4
    .byte     4
#ENDDATA
    .byte     2
    .byte     5
    .byte     3
#ENDDATA
    .byte     2
    .byte     6
    .byte     3
#ENDDATA
    .byte     2
    .byte     7
    .byte     3
#ENDDATA
    .byte     2
    .byte     8
    .byte     3
#ENDDATA
    .byte     2
    .byte     9
    .byte     4
#ENDDATA
    .byte     2
    .byte     10
    .byte     10
#ENDDATA
    .byte     2
    .byte     11
    .byte     11
#ENDDATA
    .byte     3
    .byte     1
    .byte     3
#ENDDATA
    .byte     3
    .byte     2
    .byte     3
#ENDDATA
    .byte     3
    .byte     3
    .byte     3
#ENDDATA
    .byte     3
    .byte     4
    .byte     4
#ENDDATA
    .byte     3
    .byte     5
    .byte     3
#ENDDATA
    .byte     3
    .byte     6
    .byte     3
#ENDDATA
    .byte     3
    .byte     7
    .byte     3
#ENDDATA
    .byte     3
    .byte     8
    .byte     8
#ENDDATA
    .byte     3
    .byte     9
    .byte     4
#ENDDATA
    .byte     3
    .byte     10
    .byte     10
#ENDDATA
    .byte     3
    .byte     11
    .byte     11
#ENDDATA
    .byte     4
    .byte     1
    .byte     4
#ENDDATA
    .byte     4
    .byte     2
    .byte     4
#ENDDATA
    .byte     4
    .byte     3
    .byte     4
#ENDDATA
    .byte     4
    .byte     4
    .byte     4
#ENDDATA
    .byte     4
    .byte     5
    .byte     4
#ENDDATA
    .byte     4
    .byte     6
    .byte     4
#ENDDATA
    .byte     4
    .byte     7
    .byte     4
#ENDDATA
    .byte     4
    .byte     8
    .byte     4
#ENDDATA
    .byte     4
    .byte     9
    .byte     9
#ENDDATA
    .byte     4
    .byte     10
    .byte     10
#ENDDATA
    .byte     4
    .byte     11
    .byte     11
#ENDDATA
    .byte     5
    .byte     1
    .byte     3
#ENDDATA
    .byte     5
    .byte     2
    .byte     3
#ENDDATA
    .byte     5
    .byte     3
    .byte     3
#ENDDATA
    .byte     5
    .byte     4
    .byte     4
#ENDDATA
    .byte     5
    .byte     5
    .byte     8
#ENDDATA
    .byte     5
    .byte     6
    .byte     8
#ENDDATA
    .byte     5
    .byte     7
    .byte     8
#ENDDATA
    .byte     5
    .byte     8
    .byte     8
#ENDDATA
    .byte     5
    .byte     9
    .byte     9
#ENDDATA
    .byte     5
    .byte     10
    .byte     10
#ENDDATA
    .byte     5
    .byte     11
    .byte     11
#ENDDATA
    .byte     6
    .byte     1
    .byte     3
#ENDDATA
    .byte     6
    .byte     2
    .byte     3
#ENDDATA
    .byte     6
    .byte     3
    .byte     3
#ENDDATA
    .byte     6
    .byte     4
    .byte     4
#ENDDATA
    .byte     6
    .byte     5
    .byte     0
#ENDDATA
    .byte     6
    .byte     6
    .byte     8
#ENDDATA
    .byte     6
    .byte     7
    .byte     8
#ENDDATA
    .byte     6
    .byte     8
    .byte     8
#ENDDATA
    .byte     6
    .byte     9
    .byte     9
#ENDDATA
    .byte     6
    .byte     10
    .byte     10
#ENDDATA
    .byte     6
    .byte     11
    .byte     11
#ENDDATA
    .byte     7
    .byte     1
    .byte     3
#ENDDATA
    .byte     7
    .byte     2
    .byte     3
#ENDDATA
    .byte     7
    .byte     3
    .byte     3
#ENDDATA
    .byte     7
    .byte     4
    .byte     4
#ENDDATA
    .byte     7
    .byte     5
    .byte     8
#ENDDATA
    .byte     7
    .byte     6
    .byte     8
#ENDDATA
    .byte     7
    .byte     7
    .byte     8
#ENDDATA
    .byte     7
    .byte     8
    .byte     8
#ENDDATA
    .byte     7
    .byte     9
    .byte     9
#ENDDATA
    .byte     7
    .byte     10
    .byte     10
#ENDDATA
    .byte     7
    .byte     11
    .byte     11
#ENDDATA
    .byte     8
    .byte     1
    .byte     3
#ENDDATA
    .byte     8
    .byte     2
    .byte     3
#ENDDATA
    .byte     8
    .byte     3
    .byte     8
#ENDDATA
    .byte     8
    .byte     4
    .byte     4
#ENDDATA
    .byte     8
    .byte     5
    .byte     8
#ENDDATA
    .byte     8
    .byte     6
    .byte     8
#ENDDATA
    .byte     8
    .byte     7
    .byte     8
#ENDDATA
    .byte     8
    .byte     8
    .byte     8
#ENDDATA
    .byte     8
    .byte     9
    .byte     9
#ENDDATA
    .byte     8
    .byte     10
    .byte     10
#ENDDATA
    .byte     8
    .byte     11
    .byte     11
#ENDDATA
    .byte     9
    .byte     1
    .byte     9
#ENDDATA
    .byte     9
    .byte     2
    .byte     9
#ENDDATA
    .byte     9
    .byte     3
    .byte     9
#ENDDATA
    .byte     9
    .byte     4
    .byte     9
#ENDDATA
    .byte     9
    .byte     5
    .byte     9
#ENDDATA
    .byte     9
    .byte     6
    .byte     9
#ENDDATA
    .byte     9
    .byte     7
    .byte     9
#ENDDATA
    .byte     9
    .byte     8
    .byte     9
#ENDDATA
    .byte     9
    .byte     9
    .byte     9
#ENDDATA
    .byte     9
    .byte     10
    .byte     10
#ENDDATA
    .byte     9
    .byte     11
    .byte     11
#ENDDATA
    .byte     10
    .byte     1
    .byte     11
#ENDDATA
    .byte     10
    .byte     2
    .byte     11
#ENDDATA
    .byte     10
    .byte     3
    .byte     11
#ENDDATA
    .byte     10
    .byte     4
    .byte     11
#ENDDATA
    .byte     10
    .byte     5
    .byte     11
#ENDDATA
    .byte     10
    .byte     6
    .byte     11
#ENDDATA
    .byte     10
    .byte     7
    .byte     11
#ENDDATA
    .byte     10
    .byte     8
    .byte     11
#ENDDATA
    .byte     10
    .byte     9
    .byte     11
#ENDDATA
    .byte     10
    .byte     10
    .byte     10
#ENDDATA
    .byte     10
    .byte     11
    .byte     11
#ENDDATA
    .byte     11
    .byte     1
    .byte     11
#ENDDATA
    .byte     11
    .byte     2
    .byte     11
#ENDDATA
    .byte     11
    .byte     3
    .byte     11
#ENDDATA
    .byte     11
    .byte     4
    .byte     11
#ENDDATA
    .byte     11
    .byte     5
    .byte     11
#ENDDATA
    .byte     11
    .byte     6
    .byte     11
#ENDDATA
    .byte     11
    .byte     7
    .byte     11
#ENDDATA
    .byte     11
    .byte     8
    .byte     11
#ENDDATA
    .byte     11
    .byte     9
    .byte     11
#ENDDATA
    .byte     11
    .byte     10
    .byte     11
#ENDDATA
    .byte     11
    .byte     11
    .byte     11
#ENDDATA
cc_tables.convsetuptable:
    .byte     1
    .byte     1
    .byte     3
#ENDDATA
    .byte     1
    .byte     2
    .byte     3
#ENDDATA
    .byte     1
    .byte     3
    .byte     3
#ENDDATA
    .byte     1
    .byte     4
    .byte     3
#ENDDATA
    .byte     1
    .byte     5
    .byte     13
#ENDDATA
    .byte     1
    .byte     6
    .byte     1
#ENDDATA
    .byte     1
    .byte     7
    .byte     3
#ENDDATA
    .byte     1
    .byte     8
    .byte     3
#ENDDATA
    .byte     1
    .byte     9
    .byte     3
#ENDDATA
    .byte     1
    .byte     10
    .byte     5
#ENDDATA
    .byte     1
    .byte     11
    .byte     5
#ENDDATA
    .byte     2
    .byte     1
    .byte     12
#ENDDATA
    .byte     2
    .byte     2
    .byte     0
#ENDDATA
    .byte     2
    .byte     3
    .byte     3
#ENDDATA
    .byte     2
    .byte     4
    .byte     3
#ENDDATA
    .byte     2
    .byte     5
    .byte     13
#ENDDATA
    .byte     2
    .byte     6
    .byte     12
#ENDDATA
    .byte     2
    .byte     7
    .byte     1
#ENDDATA
    .byte     2
    .byte     8
    .byte     3
#ENDDATA
    .byte     2
    .byte     9
    .byte     3
#ENDDATA
    .byte     2
    .byte     10
    .byte     5
#ENDDATA
    .byte     2
    .byte     11
    .byte     5
#ENDDATA
    .byte     3
    .byte     1
    .byte     12
#ENDDATA
    .byte     3
    .byte     2
    .byte     12
#ENDDATA
    .byte     3
    .byte     3
    .byte     0
#ENDDATA
    .byte     3
    .byte     4
    .byte     3
#ENDDATA
    .byte     3
    .byte     5
    .byte     13
#ENDDATA
    .byte     3
    .byte     6
    .byte     12
#ENDDATA
    .byte     3
    .byte     7
    .byte     12
#ENDDATA
    .byte     3
    .byte     8
    .byte     1
#ENDDATA
    .byte     3
    .byte     9
    .byte     3
#ENDDATA
    .byte     3
    .byte     10
    .byte     5
#ENDDATA
    .byte     3
    .byte     11
    .byte     5
#ENDDATA
    .byte     4
    .byte     1
    .byte     12
#ENDDATA
    .byte     4
    .byte     2
    .byte     12
#ENDDATA
    .byte     4
    .byte     3
    .byte     12
#ENDDATA
    .byte     4
    .byte     4
    .byte     0
#ENDDATA
    .byte     4
    .byte     5
    .byte     13
#ENDDATA
    .byte     4
    .byte     6
    .byte     12
#ENDDATA
    .byte     4
    .byte     7
    .byte     12
#ENDDATA
    .byte     4
    .byte     8
    .byte     12
#ENDDATA
    .byte     4
    .byte     9
    .byte     1
#ENDDATA
    .byte     4
    .byte     10
    .byte     5
#ENDDATA
    .byte     4
    .byte     11
    .byte     5
#ENDDATA
    .byte     5
    .byte     1
    .byte     1
#ENDDATA
    .byte     5
    .byte     2
    .byte     4
#ENDDATA
    .byte     5
    .byte     3
    .byte     4
#ENDDATA
    .byte     5
    .byte     4
    .byte     4
#ENDDATA
    .byte     5
    .byte     5
    .byte     0
#ENDDATA
    .byte     5
    .byte     6
    .byte     1
#ENDDATA
    .byte     5
    .byte     7
    .byte     4
#ENDDATA
    .byte     5
    .byte     8
    .byte     4
#ENDDATA
    .byte     5
    .byte     9
    .byte     4
#ENDDATA
    .byte     5
    .byte     10
    .byte     6
#ENDDATA
    .byte     5
    .byte     11
    .byte     6
#ENDDATA
    .byte     6
    .byte     1
    .byte     1
#ENDDATA
    .byte     6
    .byte     2
    .byte     4
#ENDDATA
    .byte     6
    .byte     3
    .byte     4
#ENDDATA
    .byte     6
    .byte     4
    .byte     4
#ENDDATA
    .byte     6
    .byte     5
    .byte     13
#ENDDATA
    .byte     6
    .byte     6
    .byte     1
#ENDDATA
    .byte     6
    .byte     7
    .byte     4
#ENDDATA
    .byte     6
    .byte     8
    .byte     4
#ENDDATA
    .byte     6
    .byte     9
    .byte     4
#ENDDATA
    .byte     6
    .byte     10
    .byte     6
#ENDDATA
    .byte     6
    .byte     11
    .byte     6
#ENDDATA
    .byte     7
    .byte     1
    .byte     12
#ENDDATA
    .byte     7
    .byte     2
    .byte     1
#ENDDATA
    .byte     7
    .byte     3
    .byte     4
#ENDDATA
    .byte     7
    .byte     4
    .byte     4
#ENDDATA
    .byte     7
    .byte     5
    .byte     13
#ENDDATA
    .byte     7
    .byte     6
    .byte     12
#ENDDATA
    .byte     7
    .byte     7
    .byte     0
#ENDDATA
    .byte     7
    .byte     8
    .byte     4
#ENDDATA
    .byte     7
    .byte     9
    .byte     4
#ENDDATA
    .byte     7
    .byte     10
    .byte     6
#ENDDATA
    .byte     7
    .byte     11
    .byte     6
#ENDDATA
    .byte     8
    .byte     1
    .byte     12
#ENDDATA
    .byte     8
    .byte     2
    .byte     12
#ENDDATA
    .byte     8
    .byte     3
    .byte     1
#ENDDATA
    .byte     8
    .byte     4
    .byte     4
#ENDDATA
    .byte     8
    .byte     5
    .byte     13
#ENDDATA
    .byte     8
    .byte     6
    .byte     12
#ENDDATA
    .byte     8
    .byte     7
    .byte     12
#ENDDATA
    .byte     8
    .byte     8
    .byte     0
#ENDDATA
    .byte     8
    .byte     9
    .byte     4
#ENDDATA
    .byte     8
    .byte     10
    .byte     6
#ENDDATA
    .byte     8
    .byte     11
    .byte     6
#ENDDATA
    .byte     9
    .byte     1
    .byte     12
#ENDDATA
    .byte     9
    .byte     2
    .byte     12
#ENDDATA
    .byte     9
    .byte     3
    .byte     12
#ENDDATA
    .byte     9
    .byte     4
    .byte     1
#ENDDATA
    .byte     9
    .byte     5
    .byte     13
#ENDDATA
    .byte     9
    .byte     6
    .byte     12
#ENDDATA
    .byte     9
    .byte     7
    .byte     12
#ENDDATA
    .byte     9
    .byte     8
    .byte     12
#ENDDATA
    .byte     9
    .byte     9
    .byte     0
#ENDDATA
    .byte     9
    .byte     10
    .byte     6
#ENDDATA
    .byte     9
    .byte     11
    .byte     6
#ENDDATA
    .byte     10
    .byte     1
    .byte     7
#ENDDATA
    .byte     10
    .byte     2
    .byte     7
#ENDDATA
    .byte     10
    .byte     3
    .byte     7
#ENDDATA
    .byte     10
    .byte     4
    .byte     7
#ENDDATA
    .byte     10
    .byte     5
    .byte     8
#ENDDATA
    .byte     10
    .byte     6
    .byte     8
#ENDDATA
    .byte     10
    .byte     7
    .byte     8
#ENDDATA
    .byte     10
    .byte     8
    .byte     8
#ENDDATA
    .byte     10
    .byte     9
    .byte     8
#ENDDATA
    .byte     10
    .byte     10
    .byte     0
#ENDDATA
    .byte     10
    .byte     11
    .byte     9
#ENDDATA
    .byte     11
    .byte     1
    .byte     7
#ENDDATA
    .byte     11
    .byte     2
    .byte     7
#ENDDATA
    .byte     11
    .byte     3
    .byte     7
#ENDDATA
    .byte     11
    .byte     4
    .byte     7
#ENDDATA
    .byte     11
    .byte     5
    .byte     8
#ENDDATA
    .byte     11
    .byte     6
    .byte     8
#ENDDATA
    .byte     11
    .byte     7
    .byte     8
#ENDDATA
    .byte     11
    .byte     8
    .byte     8
#ENDDATA
    .byte     11
    .byte     9
    .byte     8
#ENDDATA
    .byte     11
    .byte     10
    .byte     10
#ENDDATA
    .byte     11
    .byte     11
    .byte     0
#ENDDATA
    .align    8
cc_tables.badexprs:
    .quad     1
    .quad     3
    .quad     0x1F
    .quad     0x18
    .quad     0x19
    .quad     0x1A
    .quad     0x1B
    .quad     0x1D
    .quad     0x20
    .quad     0x21
    .quad     0x22
    .quad     0x23
    .quad     0x24
    .quad     0x26
    .quad     0x25
    .quad     0x27
    .quad     0x28
    .quad     0x29
    .quad     0x2A
    .quad     0x2B
    .quad     0x2C
    .quad     0x2D
    .quad     0x2E
    .quad     0x2F
    .quad     0x30
    .quad     0x31
    .quad     0x32
    .quad     0x33
    .quad     0x34
    .quad     0x35
    .quad     0x36
    .quad     0x3A
    .quad     0x3B
    .quad     0x3C
    .align    8
cc_lex.tkptr:
    .quad     0
    .align    8
cc_lex.dowhitespace:
    .quad     0
    .bss
    .align    8
cc_lex.nincludes:
    .space    8
    .align    8
cc_lex.normaltkx:
    .space    32
    .data
    .align    8
cc_lex.normaltk:
    .quad     cc_lex.normaltkx
    .align    8
cc_lex.noexpand:
    .quad     0
    .bss
    .align    8
cc_lex.lx_stack:
    .space    480
    .align    8
cc_lex.lx_stackindex:
    .space    8
    .data
    .align    8
cc_lex.ifcondlevel:
    .quad     0
    .bss
    .align    8
cc_lex.headerpathlist:
    .space    160
cc_lex.headerpath:
    .space    300
    .align    8
cc_lex.lxstart:
    .space    8
    .align    8
cc_lex.lxsptr:
    .space    8
    .align    8
cc_lex.lxhashvalue:
    .space    8
    .align    8
cc_lex.lxsvalue:
    .space    8
cc_lex.alphamap:
    .space    256
cc_lex.digitmap:
    .space    256
cc_lex.commentmap:
    .space    256
cc_lex.linecommentmap:
    .space    256
cc_lex.spacemap:
    .space    256
    .align    8
cc_lex.destcopy:
    .space    8
    .align    8
cc_lex.pastedtokenlist:
    .space    696000
    .data
    .align    8
cc_lex.npastedtokens:
    .quad     0
    .align    8
cc_lex.isincludefile:
    .quad     0
    .align    8
cc_lex.firstsymbol:
    .quad     1
    .bss
    .align    8
cc_lex.reallxsptr:
    .space    8
    .align    8
cc_lex.nhstsymbols:
    .space    8
    .align    8
cc_lex.hstthreshold:
    .space    8
    .align    8
cc_lex.lex_preprocess_only.sbuffer:
    .space    16
    .data
    .align    8
cc_lex.lex_preprocess_only.dest:
    .quad     cc_lex.lex_preprocess_only.sbuffer
    .bss
cc_lex.getsourcefile.filespec:
    .space    300
    .data
    .align    8
cc_lex.lexm.doreset:
    .quad     0
    .align    8
cc_lex.lasttoken:
    .quad     0
    .bss
    .align    8
cc_lex.showtoken.buffer:
    .space    16
    .data
    .align    8
cc_lex.showtoken.dest:
    .quad     cc_lex.showtoken.buffer
    .bss
    .align    8
cc_lex.stringify.buffer:
    .space    16
    .data
    .align    8
cc_lex.stringify.deststr:
    .quad     cc_lex.stringify.buffer
    .align    8
cc_lex.expandpredefmacro.monthnames:
    .quad     L8026
    .quad     L8027
    .quad     L8028
    .quad     L8029
    .quad     L8030
    .quad     L8031
    .quad     L8032
    .quad     L8033
    .quad     L8034
    .quad     L8035
    .quad     L8036
    .quad     L8037
    .align    8
cc_lex.issimpleconstmacro.specialnames:
    .quad     L8038
    .quad     L8039
    .quad     L8040
    .bss
    .align    8
cc_parse.ist_symptr:
    .space    8
cc_parse.looptypestack:
    .space    64
    .align    8
cc_parse.loopindex:
    .space    8
    .align    8
cc_parse.casevaluestack:
    .space    512
    .data
cc_parse.ingeneric:
    .byte     0
    .bss
    .align    8
cc_genpcl.retindex:
    .space    8
    .align    8
cc_genpcl.initstaticsindex:
    .space    8
    .align    8
cc_genpcl.loopstack:
    .space    1600
    .align    8
cc_genpcl.loopindex:
    .space    8
    .align    8
cc_genpcl.zero_unit:
    .space    64
    .data
    .align    8
cc_genpcl.pzero:
    .quad     cc_genpcl.zero_unit
    .bss
    .align    8
cc_genpcl.nvarlocals:
    .space    8
    .align    8
cc_genpcl.nvarparams:
    .space    8
    .align    8
cc_blockpcl.continuestack:
    .space    512
    .align    8
cc_blockpcl.breakstack:
    .space    512
    .align    8
cc_blockpcl.loopindex:
    .space    8
    .align    8
cc_blockpcl.sw_labeltable:
    .space    8
    .align    8
cc_blockpcl.sw_valuetable:
    .space    8
    .align    8
cc_blockpcl.sw_lower:
    .space    8
    .align    8
cc_blockpcl.sw_ncases:
    .space    8
cc_blockpcl.sw_defaultseen:
    .space    1
    .align    8
cc_blockpcl.sw_defaultlabel:
    .space    8
    .align    8
cc_blockpcl.sw_breaklabel:
    .space    8
    .data
    .align    8
cc_lib.autotypeno:
    .quad     0
    .align    8
cc_lib.nextafindex:
    .quad     0
    .align    8
cc_lib.unitheapptr:
    .quad     0
    .align    8
cc_lib.remainingunits:
    .quad     0
    .bss
    .align    2
cc_lib.getoptocode.opctotable:
    .space    156
cc_lib.nextautotype.str:
    .space    32
cc_lib.getopcjname.str:
    .space    20
cc_lib.strmode.str:
    .space    16384
cc_lib.strmode2.str:
    .space    16384
cc_lib.typename.str:
    .space    300
cc_lib.getstname.name:
    .space    256
    .data
cc_support.bytemasks:
    .quad     0x8040201008040201
#ENDDATA
    .align    8
cc_headersx.builtinheaders:
    .quad     0
    .bss
    .align    8
cc_show.currfileno:
    .space    8
    .align    8
cc_show.currlineno:
    .space    8
    .align    8
cc_show.sbuffer:
    .space    16
    .data
    .align    8
cc_show.dest:
    .quad     cc_show.sbuffer
    .bss
    .align    8
cc_show.destlinestart:
    .space    8
    .align    8
cc_show.exprstrvar:
    .space    16
    .data
    .align    8
cc_show.exprstr:
    .quad     cc_show.exprstrvar
    .bss
cc_show.getprefix.str:
    .space    512
cc_show.getdottedname.str:
    .space    256
cc_show.getlineinfok.str:
    .space    40
    .text
# Proc msys.start
msys.start:
#?>>
    .set msys.start.nargs, -8
    .set msys.start.args, -16
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
#---------------
    sub       %rsp,	8
    lea       %rax,	[%rip+msys.start.startupinfo]
    push      %rax
    lea       %rcx,	[%rbp + msys.start.nargs]
    lea       %rdx,	[%rbp + msys.start.args]
    lea       %r8,	[%rip+msys.envstrings]
    xor       %r9d,	%r9d
    sub       %rsp,	32
    call      __getmainargs
    add       %rsp,	48
    movsxd    %r10,	%eax
    mov       %rbx,	%r10
    movsxd    %rax,	dword ptr[%rbp + msys.start.nargs]
    mov       [%rip+msys.nsysparams],	%rax
    mov       %rax,	[%rip+msys.nsysparams]
    cmp       %rax,	128
    jle       L3
    lea       %rcx,	[%rip+L8041]
    call      printf
    mov       %rcx,	50
    call      exit
L3:
    movsxd    %rax,	dword ptr[%rbp + msys.start.nargs]
    mov       %rdi,	%rax
    mov       %r12,	1
    cmp       %rdi,	1
    jl        L6
L4:
    mov       %rax,	[%rbp + msys.start.args]
    mov       %r10,	%r12
    mov       %rax,	[%rax + %r10*8-8]
    lea       %r10,	[%rip+msys.sysparams]
    mov       %r11,	%r12
    mov       [%r10 + %r11*8-8],	%rax
    inc       %r12
    cmp       %r12,	%rdi
    jle       L4
L6:
    mov       %rax,	[%rip+msys.$cmdskip]
    inc       %rax
    mov       %r10,	[%rip+msys.nsysparams]
    sub       %r10,	%rax
    mov       [%rip+msys.ncmdparams],	%r10
    lea       %rax,	[%rip+msys.sysparams]
    mov       %r10,	[%rip+msys.$cmdskip]
    lea       %rax,	[%rax + %r10*8]
    mov       [%rip+msys.cmdparams],	%rax
    mov       %rsi,	1
    xor       %eax,	%eax
    mov       [%rip+msys.nenvstrings],	%rax
    jmp       L8
L7:
    inc       qword ptr[%rip+msys.nenvstrings]
    inc       %rsi
L8:
    mov       %rax,	[%rip+msys.envstrings]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8-8]
    test      %rax,	%rax
    jnz       L7
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.pushio
msys.pushio:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    mov       %rax,	[%rip+msys.niostack]
    cmp       %rax,	10
    jl        L12
    lea       %rcx,	[%rip+L8042]
    call      printf
    mov       %rcx,	53
    call      exit
L12:
    inc       qword ptr[%rip+msys.niostack]
    mov       %rax,	[%rip+msys.outchan]
    lea       %r10,	[%rip+msys.outchan_stack]
    mov       %r11,	[%rip+msys.niostack]
    mov       [%r10 + %r11*8-8],	%rax
    mov       %rax,	[%rip+msys.outdev]
    lea       %r10,	[%rip+msys.outdev_stack]
    mov       %r11,	[%rip+msys.niostack]
    mov       [%r10 + %r11*8-8],	%rax
    mov       %rax,	[%rip+msys.fmtstr]
    lea       %r10,	[%rip+msys.fmtstr_stack]
    mov       %r11,	[%rip+msys.niostack]
    mov       [%r10 + %r11*8-8],	%rax
    mov       %al,	[%rip+msys.needgap]
    lea       %r10,	[%rip+msys.needgap_stack]
    mov       %r11,	[%rip+msys.niostack]
    mov       [%r10 + %r11-1],	%al
    xor       %eax,	%eax
    mov       [%rip+msys.needgap],	%rax
    xor       %eax,	%eax
    mov       [%rip+msys.fmtstr],	%rax
    xor       %eax,	%eax
    mov       [%rip+msys.outchan],	%rax
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc msys.m$print_startfile
msys.m$print_startfile:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    call      msys.pushio
    mov       [%rip+msys.outchan],	%rdi
    test      %rdi,	%rdi
    jz        L15
    mov       %rax,	2
    mov       [%rip+msys.outdev],	%rax
    jmp       L14
L15:
    mov       %rax,	1
    mov       [%rip+msys.outdev],	%rax
L14:
    call      msys.resetprintbuffer
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_startstr
msys.m$print_startstr:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    call      msys.pushio
    mov       %rax,	%rbx
    lea       %r10,	[%rip+msys.ptr_stack]
    mov       %r11,	[%rip+msys.niostack]
    mov       [%r10 + %r11*8-8],	%rax
    lea       %rax,	[%rip+msys.ptr_stack]
    mov       %r10,	[%rip+msys.niostack]
    lea       %rax,	[%rax + %r10*8-8]
    mov       %rdi,	%rax
    mov       [%rip+msys.outchan],	%rdi
    mov       %rax,	3
    mov       [%rip+msys.outdev],	%rax
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_startptr
msys.m$print_startptr:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    call      msys.pushio
    mov       [%rip+msys.outchan],	%rdi
    mov       %rax,	3
    mov       [%rip+msys.outdev],	%rax
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_startcon
msys.m$print_startcon:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    call      msys.pushio
    mov       %rax,	1
    mov       [%rip+msys.outdev],	%rax
    call      msys.resetprintbuffer
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc msys.m$print_setfmt
msys.m$print_setfmt:
#?>>
#?]]
#---------------
    mov       [%rip+msys.fmtstr],	%rcx
#---------------
    ret       
# End 
# Proc msys.m$print_end
msys.m$print_end:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    xor       %eax,	%eax
    mov       [%rip+msys.needgap],	%rax
    mov       %rcx,	1
    call      msys.nextfmtchars
    mov       %rax,	[%rip+msys.niostack]
    cmp       %rax,	1
    jnz       L22
    mov       %rax,	[%rip+msys.outdev]
    cmp       %rax,	1
    jz        L23
    cmp       %rax,	2
    jnz       L22
L23:
    call      msys.dumpprintbuffer
L22:
    mov       %rax,	[%rip+msys.niostack]
    test      %rax,	%rax
    jz        L20
L25:
    lea       %rax,	[%rip+msys.outchan_stack]
    mov       %r10,	[%rip+msys.niostack]
    mov       %rax,	[%rax + %r10*8-8]
    mov       [%rip+msys.outchan],	%rax
    lea       %rax,	[%rip+msys.outdev_stack]
    mov       %r10,	[%rip+msys.niostack]
    mov       %rax,	[%rax + %r10*8-8]
    mov       [%rip+msys.outdev],	%rax
    lea       %rax,	[%rip+msys.fmtstr_stack]
    mov       %r10,	[%rip+msys.niostack]
    mov       %rax,	[%rax + %r10*8-8]
    mov       [%rip+msys.fmtstr],	%rax
    lea       %rax,	[%rip+msys.needgap_stack]
    mov       %r10,	[%rip+msys.niostack]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       [%rip+msys.needgap],	%rax
    dec       qword ptr[%rip+msys.niostack]
L20:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc msys.m$print_ptr
msys.m$print_ptr:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    test      %rbx,	%rbx
    jnz       L28
    lea       %rax,	[%rip+L8043]
    mov       %rbx,	%rax
L28:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      msys.m$print_u64
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_ptr_nf
msys.m$print_ptr_nf:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      msys.m$print_ptr
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_i64
msys.m$print_i64:
#?>>
    .set msys.m$print_i64.s, -40
    .set msys.m$print_i64.fmt, -56
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	88
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    xor       %ecx,	%ecx
    call      msys.nextfmtchars
    test      %rsi,	%rsi
    jnz       L32
    cmp       %rbx,	0
    jl        L34
    mov       %rcx,	%rbx
    lea       %rdx,	[%rbp + msys.m$print_i64.s]
    mov       %r8,	10
    xor       %r9d,	%r9d
    call      msys.u64tostr
    mov       %rdi,	%rax
    jmp       L33
L34:
    mov       %rax,	%rbx
    mov       %r10,	-9223372036854775808
    cmp       %rax,	%r10
    jnz       L35
    lea       %rax,	[%rip+msys.defaultfmt]
    lea       %r10,	[%rbp + msys.m$print_i64.fmt]
    movdqu    %XMM4,	[%rax]
    movdqu    [%r10],	%XMM4
    jmp       L36
L35:
    mov       %al,	45
    mov       [%rbp + msys.m$print_i64.s],	%al
    lea       %rax,	[%rbp + msys.m$print_i64.s+1]
    mov       %r10,	%rbx
    neg       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    mov       %r8,	10
    xor       %r9d,	%r9d
    call      msys.u64tostr
    inc       %rax
    mov       %rdi,	%rax
L33:
    lea       %rcx,	[%rbp + msys.m$print_i64.s]
    mov       %rdx,	%rdi
    call      msys.printstr_n
    jmp       L31
L32:
    mov       %rcx,	%rsi
    mov       %rdx,	-1
    lea       %r8,	[%rbp + msys.m$print_i64.fmt]
    call      msys.strtofmt
    movzx     %rax,	byte ptr[%rbp + msys.m$print_i64.fmt+14]
    cmp       %rax,	86
    jnz       L38
    mov       [%rip+msys.fmtparam],	%rbx
    xor       %eax,	%eax
    mov       [%rip+msys.needgap],	%rax
    jmp       L37
L38:
#msys.m$print_i64.dofmt:
L36:
    mov       %rcx,	%rbx
    lea       %rdx,	[%rbp + msys.m$print_i64.fmt]
    call      msys.tostr_i64
L37:
L31:
    mov       %rax,	1
    mov       [%rip+msys.needgap],	%rax
#---------------
    add       %rsp,	88
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_i64_nf
msys.m$print_i64_nf:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      msys.m$print_i64
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_bool
msys.m$print_bool:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    test      %rdi,	%rdi
    jz        L42
    lea       %rcx,	[%rip+L8044]
    mov       %rdx,	%rbx
    call      msys.m$print_str
    jmp       L41
L42:
    lea       %rcx,	[%rip+L8045]
    mov       %rdx,	%rbx
    call      msys.m$print_str
L41:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_u64
msys.m$print_u64:
#?>>
    .set msys.m$print_u64.s, -40
    .set msys.m$print_u64.fmt, -56
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	96
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    xor       %ecx,	%ecx
    call      msys.nextfmtchars
    test      %rbx,	%rbx
    jnz       L45
    lea       %rcx,	[%rbp + msys.m$print_u64.s]
    lea       %rdx,	[%rip+L8046]
    mov       %r8,	%rdi
    call      sprintf
    lea       %rcx,	[%rbp + msys.m$print_u64.s]
    call      msys.printstr
    jmp       L44
L45:
    mov       %rcx,	%rbx
    mov       %rdx,	-1
    lea       %r8,	[%rbp + msys.m$print_u64.fmt]
    call      msys.strtofmt
    mov       %rcx,	%rdi
    lea       %rdx,	[%rbp + msys.m$print_u64.fmt]
    call      msys.tostr_u64
L44:
    mov       %rax,	1
    mov       [%rip+msys.needgap],	%rax
#---------------
    add       %rsp,	96
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_r64
msys.m$print_r64:
#?>>
    .set msys.m$print_r64.s, -360
    .set msys.m$print_r64.fmt, -376
    push      %rdi
    movq      %rax,	%XMM15
    push      %rax
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	416
    movq      %XMM15,	%XMM0
    mov       %rdi,	%rdx
#---------------
    xor       %ecx,	%ecx
    call      msys.nextfmtchars
    test      %rdi,	%rdi
    jnz       L48
    lea       %rcx,	[%rbp + msys.m$print_r64.s]
    lea       %rdx,	[%rip+L8047]
    movq      %XMM2,	%XMM15
    movq      %r8,	%XMM2
    call      sprintf
    lea       %rcx,	[%rbp + msys.m$print_r64.s]
    call      msys.printstr
    jmp       L47
L48:
    mov       %rcx,	%rdi
    mov       %rdx,	-1
    lea       %r8,	[%rbp + msys.m$print_r64.fmt]
    call      msys.strtofmt
    movq      %XMM0,	%XMM15
    lea       %rdx,	[%rbp + msys.m$print_r64.fmt]
    call      msys.tostr_r64
L47:
    mov       %rax,	1
    mov       [%rip+msys.needgap],	%rax
#---------------
    add       %rsp,	416
    pop       %rbp
    pop       %rcx
    movq      %XMM15,	%rcx
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_r32
msys.m$print_r32:
#?>>
    .set msys.m$print_r32.s, -360
    .set msys.m$print_r32.fmt, -376
    push      %rdi
    movq      %rax,	%XMM15
    push      %rax
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	416
    movq      %XMM15,	%XMM0
    mov       %rdi,	%rdx
#---------------
    xor       %ecx,	%ecx
    call      msys.nextfmtchars
    test      %rdi,	%rdi
    jnz       L51
    movq      %XMM4,	%XMM15
    cvtss2sd  %XMM4,	%XMM4
    lea       %rcx,	[%rbp + msys.m$print_r32.s]
    lea       %rdx,	[%rip+L8047]
    movq      %XMM2,	%XMM4
    movq      %r8,	%XMM2
    call      sprintf
    lea       %rcx,	[%rbp + msys.m$print_r32.s]
    call      msys.printstr
    jmp       L50
L51:
    mov       %rcx,	%rdi
    mov       %rdx,	-1
    lea       %r8,	[%rbp + msys.m$print_r32.fmt]
    call      msys.strtofmt
    movq      %XMM4,	%XMM15
    cvtss2sd  %XMM4,	%XMM4
    movq      %XMM0,	%XMM4
    lea       %rdx,	[%rbp + msys.m$print_r32.fmt]
    call      msys.tostr_r64
L50:
    mov       %rax,	1
    mov       [%rip+msys.needgap],	%rax
#---------------
    add       %rsp,	416
    pop       %rbp
    pop       %rcx
    movq      %XMM15,	%rcx
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_c8
msys.m$print_c8:
#?>>
    .set msys.m$print_c8.a, 40
    .set msys.m$print_c8.s, -32
    .set msys.m$print_c8.fmt, -48
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	88
    mov       [%rbp+40],	%rcx
    mov       %rsi,	%rdx
#---------------
    xor       %bl,	%bl
    xor       %ecx,	%ecx
    call      msys.nextfmtchars
    test      %rsi,	%rsi
    jz        L54
    mov       %rcx,	%rsi
    mov       %rdx,	-1
    lea       %r8,	[%rbp + msys.m$print_c8.fmt]
    call      msys.strtofmt
    mov       %bl,	[%rbp + msys.m$print_c8.fmt+12]
L54:
    movzx     %rax,	%bl
    cmp       %rax,	77
    jnz       L56
    lea       %rcx,	[%rbp + msys.m$print_c8.a]
    mov       %rdx,	8
    lea       %r8,	[%rbp + msys.m$print_c8.s]
    lea       %r9,	[%rbp + msys.m$print_c8.fmt]
    call      msys.domultichar
    mov       %rdi,	%rax
    jmp       L55
L56:
    mov       %rax,	[%rbp + msys.m$print_c8.a]
    mov       [%rbp + msys.m$print_c8.s],	%rax
    xor       %eax,	%eax
    mov       [%rbp + msys.m$print_c8.s+8],	%al
    lea       %rcx,	[%rbp + msys.m$print_c8.s]
    call      msys.getutfsize
    mov       %rdi,	%rax
L55:
    lea       %rcx,	[%rbp + msys.m$print_c8.s]
    mov       %rdx,	%rdi
    call      msys.printstr_n
    mov       %rax,	1
    mov       [%rip+msys.needgap],	%rax
#---------------
    add       %rsp,	88
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_str
msys.m$print_str:
#?>>
    .set msys.m$print_str.fmt, -16
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    xor       %ecx,	%ecx
    call      msys.nextfmtchars
    test      %rdi,	%rdi
    jnz       L59
    lea       %rcx,	[%rip+L8048]
    call      msys.printstr
    jmp       L57
L59:
    test      %rbx,	%rbx
    jnz       L61
    mov       %rcx,	%rdi
    call      msys.printstr
    jmp       L60
L61:
    mov       %rcx,	%rbx
    mov       %rdx,	-1
    lea       %r8,	[%rbp + msys.m$print_str.fmt]
    call      msys.strtofmt
    mov       %rcx,	%rdi
    mov       %rdx,	-1
    lea       %r8,	[%rbp + msys.m$print_str.fmt]
    call      msys.tostr_str
L60:
    mov       %rax,	1
    mov       [%rip+msys.needgap],	%rax
L57:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_strn
msys.m$print_strn:
#?>>
    .set msys.m$print_strn.fmt, -16
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	56
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    xor       %ecx,	%ecx
    call      msys.nextfmtchars
    test      %rdi,	%rdi
    jnz       L64
    lea       %rcx,	[%rip+L8048]
    call      msys.printstr
    jmp       L62
L64:
    test      %rsi,	%rsi
    jnz       L66
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      msys.printstr_n
    jmp       L65
L66:
    mov       %rcx,	%rsi
    mov       %rdx,	-1
    lea       %r8,	[%rbp + msys.m$print_strn.fmt]
    call      msys.strtofmt
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    lea       %r8,	[%rbp + msys.m$print_strn.fmt]
    call      msys.tostr_str
L65:
    mov       %rax,	1
    mov       [%rip+msys.needgap],	%rax
L62:
#---------------
    add       %rsp,	56
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_str_nf
msys.m$print_str_nf:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      msys.m$print_str
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_strsl
msys.m$print_strsl:
#?>>
    .set msys.m$print_strsl.s, 16
    .set msys.m$print_strsl.fmtstyle, 24
#?]]
    sub       %rsp,	40
#---------------
    lea       %rcx,	[%rip+L8049]
    call      mlib.abortprogram
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc msys.m$print_newline
msys.m$print_newline:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    xor       %eax,	%eax
    mov       [%rip+msys.needgap],	%rax
    mov       %rcx,	1
    call      msys.nextfmtchars
    lea       %rcx,	[%rip+L8050]
    call      msys.printstr
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc msys.m$print_nogap
msys.m$print_nogap:
#?>>
#?]]
#---------------
    xor       %eax,	%eax
    mov       [%rip+msys.needgap],	%rax
#---------------
    ret       
# End 
# Proc msys.m$print_space
msys.m$print_space:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    xor       %eax,	%eax
    mov       [%rip+msys.needgap],	%rax
    lea       %rcx,	[%rip+L8051]
    call      msys.printstr
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc msys.printstr
msys.printstr:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      strlen
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      msys.printstr_n
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc msys.printstr_n
msys.printstr_n:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      msys.dumpstr
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.printstrn_app
msys.printstrn_app:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    test      %rbx,	%rbx
    jz        L76
    test      %rsi,	%rsi
    jnz       L78
    lea       %rcx,	[%rip+L8052]
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      printf
    jmp       L77
L78:
    mov       %rcx,	%rsi
    lea       %rdx,	[%rip+L8052]
    mov       %r8,	%rbx
    mov       %r9,	%rdi
    call      fprintf
L77:
L76:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.printchar
msys.printchar:
#?>>
    .set msys.printchar.str, -8
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %rdi,	%rcx
#---------------
    mov       [%rbp + msys.printchar.str],	%dil
    xor       %eax,	%eax
    mov       [%rbp + msys.printchar.str+1],	%al
    lea       %rcx,	[%rbp + msys.printchar.str]
    mov       %rdx,	1
    call      msys.printstr_n
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc msys.nextfmtchars
msys.nextfmtchars:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
    mov       %rax,	[%rip+msys.fmtstr]
    test      %rax,	%rax
    jnz       L82
    mov       %rax,	[%rip+msys.needgap]
    test      %rax,	%rax
    jz        L84
    mov       %rcx,	32
    call      msys.printchar
L84:
    xor       %eax,	%eax
    mov       [%rip+msys.needgap],	%rax
    jmp       L80
L82:
    mov       %rbx,	[%rip+msys.fmtstr]
    xor       %rsi,	%rsi
L85:
    mov       %rax,	[%rip+msys.fmtstr]
    mov       %dil,	[%rax]
    movzx     %rax,	%dil
    cmp       %rax,	35
    jz        L88
    test      %rax,	%rax
    jz        L89
    cmp       %rax,	126
    jz        L90
    jmp       L91
L88:
    test      %r12,	%r12
    jz        L93
    jmp       L94
L93:
    inc       qword ptr[%rip+msys.fmtstr]
    test      %rsi,	%rsi
    jz        L96
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      msys.printstr_n
L96:
    jmp       L80
L89:
    test      %rsi,	%rsi
    jz        L98
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      msys.printstr_n
    jmp       L97
L98:
    test      %r12,	%r12
    jnz       L99
    lea       %rcx,	[%rip+L8053]
    mov       %rdx,	1
    call      msys.printstr_n
L99:
L97:
    jmp       L80
L90:
    test      %rsi,	%rsi
    jz        L101
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      msys.printstr_n
    xor       %rsi,	%rsi
L101:
    inc       qword ptr[%rip+msys.fmtstr]
    mov       %rax,	[%rip+msys.fmtstr]
    mov       %dil,	[%rax]
    test      %dil,	%dil
    jz        L103
    inc       qword ptr[%rip+msys.fmtstr]
    movzx     %rax,	%dil
    mov       %rcx,	%rax
    call      msys.printchar
L103:
    mov       %rbx,	[%rip+msys.fmtstr]
    jmp       L87
L91:
#msys.nextfmtchars.skip:
L94:
    inc       %rsi
    inc       qword ptr[%rip+msys.fmtstr]
L87:
    jmp       L85
L80:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.strtofmt
msys.strtofmt:
#?>>
    .set msys.strtofmt.str, -104
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	136
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       %r15,	%r8
#---------------
    lea       %rax,	[%rip+msys.defaultfmt]
    movdqu    %XMM4,	[%rax]
    movdqu    [%r15],	%XMM4
    test      %r13,	%r13
    jnz       L106
    jmp       L104
L106:
    cmp       %r14,	-1
    jnz       L108
    mov       %rcx,	%r13
    call      strlen
    mov       %r14,	%rax
L108:
    lea       %rcx,	[%rbp + msys.strtofmt.str]
    mov       %rdx,	%r13
    mov       %r8,	%r14
    call      memcpy
    xor       %eax,	%eax
    mov       [%rbp + %r14 + msys.strtofmt.str],	%al
    lea       %rax,	[%rbp + msys.strtofmt.str]
    mov       %r13,	%rax
    xor       %sil,	%sil
    jmp       L110
L109:
    movzx     %rax,	byte ptr[%r13]
    mov       %rdi,	%rax
    inc       %r13
    cmp       %rdi,	65
    jnz       L113
    mov       %al,	65
    mov       [%r15+8],	%al
    jmp       L112
L113:
    cmp       %rdi,	97
    jnz       L114
    mov       %al,	97
    mov       [%r15+8],	%al
    jmp       L112
L114:
    mov       %rcx,	%rdi
    call      toupper
    movsxd    %r10,	%eax
    sub       %r10,	66
    cmp       %r10,	25
    jae       L117
    lea       %rax,	[%rip+L116]
    jmp       [%rax + %r10*8]
    .data
L116:
    .quad     L118
    .quad     L147
    .quad     L146
    .quad     L143
    .quad     L144
    .quad     L145
    .quad     L119
    .quad     L117
    .quad     L129
    .quad     L117
    .quad     L117
    .quad     L148
    .quad     L151
    .quad     L120
    .quad     L136
    .quad     L128
    .quad     L117
    .quad     L133
    .quad     L139
    .quad     L142
    .quad     L149
    .quad     L117
    .quad     L121
    .quad     L150
    .quad     L132
    .text
L118:
    mov       %al,	2
    mov       [%r15+2],	%al
    jmp       L115
L119:
    mov       %al,	16
    mov       [%r15+2],	%al
    jmp       L115
L120:
    mov       %al,	8
    mov       [%r15+2],	%al
    jmp       L115
L121:
    xor       %rbx,	%rbx
L122:
    movzx     %rax,	byte ptr[%r13]
    mov       %rdi,	%rax
    mov       %rax,	%rdi
    cmp       %rax,	48
    jl        L125
    cmp       %rax,	57
    jg        L125
    mov       %rax,	%rbx
    shl       %rax,	1
    lea       %rax,	[%rax + %rax*4]
    add       %rax,	%rdi
    sub       %rax,	48
    mov       %rbx,	%rax
    inc       %r13
    jmp       L124
L125:
    jmp       L123
L124:
    jmp       L122
L123:
    mov       %rax,	%rbx
    cmp       %rax,	2
    jl        L127
    cmp       %rax,	16
    jg        L127
    mov       [%r15+2],	%bl
L127:
    jmp       L115
L128:
    mov       %al,	34
    mov       [%r15+3],	%al
    jmp       L115
L129:
    movzx     %rax,	byte ptr[%r13]
    mov       %rcx,	%rax
    call      toupper
    mov       [%r15+9],	%al
    mov       %al,	[%r13]
    test      %al,	%al
    jz        L131
    inc       %r13
L131:
    jmp       L115
L132:
    mov       %al,	48
    mov       [%r15+4],	%al
    jmp       L115
L133:
    mov       %al,	[%r13]
    mov       [%r15+7],	%al
    mov       %al,	[%r13]
    test      %al,	%al
    jz        L135
    inc       %r13
L135:
    jmp       L115
L136:
    mov       %al,	[%r13]
    mov       [%r15+4],	%al
    mov       %al,	[%r13]
    test      %al,	%al
    jz        L138
    inc       %r13
L138:
    jmp       L115
L139:
    mov       %al,	[%r13]
    mov       [%r15+10],	%al
    mov       %al,	[%r13]
    test      %al,	%al
    jz        L141
    inc       %r13
L141:
    jmp       L115
L142:
    mov       %al,	87
    mov       [%r15+11],	%al
    jmp       L115
L143:
    mov       %al,	101
    mov       [%r15+5],	%al
    jmp       L115
L144:
    mov       %al,	102
    mov       [%r15+5],	%al
    jmp       L115
L145:
    mov       %al,	103
    mov       [%r15+5],	%al
    jmp       L115
L146:
    mov       %al,	68
    mov       [%r15+13],	%al
    jmp       L115
L147:
    mov       %al,	67
    mov       [%r15+12],	%al
    jmp       L115
L148:
    mov       %al,	77
    mov       [%r15+12],	%al
    jmp       L115
L149:
    mov       %al,	86
    mov       [%r15+14],	%al
    jmp       L115
L150:
    lea       %rax,	[%r15+15]
    or        byte ptr[%rax],	1
    jmp       L115
L151:
    lea       %rax,	[%r15+15]
    or        byte ptr[%rax],	2
    jmp       L115
L117:
    mov       %rax,	%rdi
    cmp       %rax,	46
    jz        L153
    cmp       %rax,	44
    jz        L154
    cmp       %rax,	95
    jz        L154
    cmp       %rax,	43
    jz        L155
    cmp       %rax,	126
    jz        L156
    cmp       %rax,	42
    jz        L157
    jmp       L158
L153:
    mov       %sil,	1
    jmp       L152
L154:
    mov       [%r15+7],	%dil
    jmp       L152
L155:
    mov       %al,	43
    mov       [%r15+6],	%al
    jmp       L152
L156:
    mov       %al,	126
    mov       [%r15+3],	%al
    jmp       L152
L157:
    mov       %r12,	[%rip+msys.fmtparam]
    jmp       L159
L158:
    cmp       %rdi,	48
    jl        L161
    cmp       %rdi,	57
    jg        L161
    lea       %rax,	[%rdi-48]
    mov       %r12,	%rax
L162:
    movzx     %rax,	byte ptr[%r13]
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%r13]
    test      %rax,	%rax
    jz        L163
L165:
    cmp       %rdi,	48
    jl        L167
    cmp       %rdi,	57
    jg        L167
    inc       %r13
    mov       %rax,	%r12
    shl       %rax,	1
    lea       %rax,	[%rax + %rax*4]
    add       %rax,	%rdi
    sub       %rax,	48
    mov       %r12,	%rax
    jmp       L166
L167:
    jmp       L163
L166:
    jmp       L162
L163:
#msys.strtofmt.gotwidth:
L159:
    test      %sil,	%sil
    jnz       L169
    mov       [%r15],	%r12b
    mov       %sil,	1
    jmp       L168
L169:
    mov       [%r15+1],	%r12b
L168:
L161:
L152:
L115:
L112:
L110:
    mov       %al,	[%r13]
    test      %al,	%al
    jnz       L109
L104:
#---------------
    add       %rsp,	136
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.domultichar
msys.domultichar:
#?>>
    .set msys.domultichar.fmt, 88
    .set msys.domultichar.str, -24
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	64
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
    mov       [%rbp+88],	%r9
#---------------
    lea       %rax,	[%rbp + msys.domultichar.str]
    mov       %rdi,	%rax
    mov       %rbx,	%r13
    mov       %rsi,	%r13
    cmp       %rsi,	0
    jle       L173
L171:
    movzx     %rax,	byte ptr[%r12]
    test      %rax,	%rax
    jz        L173
L175:
    mov       %al,	[%r12]
    mov       [%rdi],	%al
    inc       %rdi
    inc       %r12
    dec       %rsi
    jnz       L171
L173:
    xor       %eax,	%eax
    mov       [%rdi],	%al
    lea       %rcx,	[%rbp + msys.domultichar.str]
    call      strlen
    lea       %rcx,	[%rbp + msys.domultichar.str]
    mov       %rdx,	%r14
    mov       %r8,	%rax
    mov       %r9,	[%rbp + msys.domultichar.fmt]
    call      msys.expandstr
L170:
#---------------
    add       %rsp,	64
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.expandstr
msys.expandstr:
#?>>
    .set msys.expandstr.n, 80
    .set msys.expandstr.fmt, 88
    .set msys.expandstr.av_2, -8
    .set msys.expandstr.av_3, -16
    .set msys.expandstr.av_4, -24
    .set msys.expandstr.av_5, -32
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	64
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       [%rbp+80],	%r8
    mov       [%rbp+88],	%r9
#---------------
    mov       %rax,	[%rbp + msys.expandstr.fmt]
    movzx     %rax,	byte ptr[%rax]
    mov       %rbx,	%rax
    test      %rbx,	%rbx
    jz        L179
    cmp       %rbx,	[%rbp + msys.expandstr.n]
    jg        L178
L179:
    mov       %rcx,	%r14
    mov       %rdx,	%r13
    mov       %r8,	[%rbp + msys.expandstr.n]
    call      strncpy
    xor       %eax,	%eax
    mov       %r10,	[%rbp + msys.expandstr.n]
    mov       [%r14 + %r10],	%al
    mov       %rax,	[%rbp + msys.expandstr.n]
    jmp       L176
L178:
    mov       %rax,	[%rbp + msys.expandstr.fmt]
    movzx     %rax,	byte ptr[%rax+9]
    cmp       %rax,	76
    jnz       L181
    mov       %rcx,	%r14
    mov       %rdx,	%r13
    mov       %r8,	[%rbp + msys.expandstr.n]
    call      strncpy
    mov       %rax,	[%rbp + msys.expandstr.n]
    add       %r14,	%rax
    mov       %rdi,	1
    mov       %rax,	%rbx
    sub       %rax,	[%rbp + msys.expandstr.n]
    mov       %r12,	%rax
    cmp       %r12,	1
    jl        L184
L182:
    mov       %rax,	[%rbp + msys.expandstr.fmt]
    mov       %al,	[%rax+4]
    mov       [%r14],	%al
    inc       %r14
    inc       %rdi
    cmp       %rdi,	%r12
    jle       L182
L184:
    xor       %eax,	%eax
    mov       [%r14],	%al
    jmp       L180
L181:
    mov       %rax,	[%rbp + msys.expandstr.fmt]
    movzx     %rax,	byte ptr[%rax+9]
    cmp       %rax,	82
    jnz       L185
    mov       %rax,	[%rbp + msys.expandstr.fmt]
    movzx     %rax,	byte ptr[%rax+4]
    cmp       %rax,	48
    jnz       L187
    mov       %rax,	[%rbp + msys.expandstr.fmt]
    mov       %al,	[%rax+2]
    test      %al,	%al
    jz        L187
    movzx     %rax,	byte ptr[%r13]
    cmp       %rax,	45
    jz        L188
    movzx     %rax,	byte ptr[%r13]
    cmp       %rax,	43
    jnz       L187
L188:
    mov       %al,	[%r13]
    mov       [%r14],	%al
    inc       %r14
    mov       %rax,	%rbx
    sub       %rax,	[%rbp + msys.expandstr.n]
    mov       [%rbp + msys.expandstr.av_2],	%rax
    mov       %rax,	[%rbp + msys.expandstr.av_2]
    cmp       %rax,	0
    jle       L191
L189:
    mov       %rax,	[%rbp + msys.expandstr.fmt]
    mov       %al,	[%rax+4]
    mov       [%r14],	%al
    inc       %r14
    dec       qword ptr[%rbp + msys.expandstr.av_2]
    jnz       L189
L191:
    mov       %rax,	[%rbp + msys.expandstr.n]
    dec       %rax
    lea       %r10,	[%r13+1]
    mov       %rcx,	%r14
    mov       %rdx,	%r10
    mov       %r8,	%rax
    call      strncpy
    mov       %rax,	[%rbp + msys.expandstr.n]
    lea       %r10,	[%r14 + %rax]
    sub       %r10,	1
    xor       %eax,	%eax
    mov       [%r10],	%al
    jmp       L186
L187:
    mov       %rax,	%rbx
    sub       %rax,	[%rbp + msys.expandstr.n]
    mov       [%rbp + msys.expandstr.av_3],	%rax
    mov       %rax,	[%rbp + msys.expandstr.av_3]
    cmp       %rax,	0
    jle       L194
L192:
    mov       %rax,	[%rbp + msys.expandstr.fmt]
    mov       %al,	[%rax+4]
    mov       [%r14],	%al
    inc       %r14
    dec       qword ptr[%rbp + msys.expandstr.av_3]
    jnz       L192
L194:
    mov       %rcx,	%r14
    mov       %rdx,	%r13
    mov       %r8,	[%rbp + msys.expandstr.n]
    call      strncpy
    xor       %eax,	%eax
    mov       %r10,	[%rbp + msys.expandstr.n]
    mov       [%r14 + %r10],	%al
L186:
    jmp       L180
L185:
    mov       %rax,	%rbx
    sub       %rax,	[%rbp + msys.expandstr.n]
    inc       %rax
    sar       %rax,	1
    mov       %rsi,	%rax
    mov       [%rbp + msys.expandstr.av_4],	%rsi
    mov       %rax,	[%rbp + msys.expandstr.av_4]
    cmp       %rax,	0
    jle       L197
L195:
    mov       %rax,	[%rbp + msys.expandstr.fmt]
    mov       %al,	[%rax+4]
    mov       [%r14],	%al
    inc       %r14
    dec       qword ptr[%rbp + msys.expandstr.av_4]
    jnz       L195
L197:
    mov       %rcx,	%r14
    mov       %rdx,	%r13
    mov       %r8,	[%rbp + msys.expandstr.n]
    call      strncpy
    mov       %rax,	[%rbp + msys.expandstr.n]
    add       %r14,	%rax
    mov       %rax,	%rbx
    sub       %rax,	[%rbp + msys.expandstr.n]
    sub       %rax,	%rsi
    mov       [%rbp + msys.expandstr.av_5],	%rax
    mov       %rax,	[%rbp + msys.expandstr.av_5]
    cmp       %rax,	0
    jle       L200
L198:
    mov       %rax,	[%rbp + msys.expandstr.fmt]
    mov       %al,	[%rax+4]
    mov       [%r14],	%al
    inc       %r14
    dec       qword ptr[%rbp + msys.expandstr.av_5]
    jnz       L198
L200:
    xor       %eax,	%eax
    mov       [%r14],	%al
L180:
    mov       %rax,	%rbx
L176:
#---------------
    add       %rsp,	64
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.u64tostr
msys.u64tostr:
#?>>
    .set msys.u64tostr.t, -360
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	368
#---------------
    xor       %rbx,	%rbx
    xor       %eax,	%eax
    mov       %r12,	%rax
    cmp       %r8,	10
    jnz       L203
    mov       %rax,	3
    jmp       L202
L203:
    mov       %rax,	4
L202:
    mov       %r13,	%rax
L204:
    mov       %rax,	%rcx
    mov       %r10,	%r8
    push      %rdx
    xor       %edx,	%edx
    div       %r10
    xchg      %rax,	%rdx
    pop       %rdx
    mov       %rdi,	%rax
    mov       %rax,	%rcx
    mov       %r10,	%r8
    push      %rdx
    xor       %edx,	%edx
    div       %r10
    pop       %rdx
    mov       %rcx,	%rax
    lea       %rax,	[%rip+msys.digits]
    mov       %r10,	%rdi
    mov       %al,	[%rax + %r10]
    inc       %rbx
    mov       %r10,	%rbx
    mov       [%rbp + %r10 + msys.u64tostr.t],	%al
    inc       %r12
    test      %r9,	%r9
    jz        L208
    test      %rcx,	%rcx
    jz        L208
    cmp       %r12,	%r13
    jnz       L208
    inc       %rbx
    mov       %rax,	%rbx
    mov       %r10b,	%r9b
    mov       [%rbp + %rax + msys.u64tostr.t],	%r10b
    xor       %r12,	%r12
L208:
    test      %rcx,	%rcx
    jnz       L204
    mov       %rsi,	%rbx
    mov       %r14,	%rdx
    jmp       L210
L209:
    mov       %rax,	%rbx
    dec       %rbx
    mov       %al,	[%rbp + %rax + msys.u64tostr.t]
    mov       [%rdx],	%al
    inc       %rdx
L210:
    test      %rbx,	%rbx
    jnz       L209
    xor       %eax,	%eax
    mov       [%rdx],	%al
    mov       %rax,	%rsi
L201:
#---------------
    add       %rsp,	368
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.i64tostrfmt
msys.i64tostrfmt:
#?>>
    .set msys.i64tostrfmt.str, -360
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	392
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
    xor       %rbx,	%rbx
    mov       %al,	[%r13+11]
    test      %al,	%al
    jz        L214
    mov       %rbx,	1
L214:
    mov       %rax,	%rsi
    mov       %r10,	-9223372036854775808
    cmp       %rax,	%r10
    jnz       L216
    test      %rbx,	%rbx
    jnz       L216
    mov       %al,	45
    mov       [%rbp + msys.i64tostrfmt.str],	%al
    movzx     %rax,	byte ptr[%r13+7]
    movzx     %r10,	byte ptr[%r13+2]
    lea       %r11,	[%rbp + msys.i64tostrfmt.str+1]
    mov       %rcx,	%r11
    mov       %rdx,	%r10
    mov       %r8,	%rax
    call      msys.i64mintostr
    inc       %rax
    mov       %rdi,	%rax
    jmp       L215
L216:
    test      %rbx,	%rbx
    jnz       L220
    cmp       %rsi,	0
    jl        L219
L220:
    mov       %al,	[%r13+6]
    test      %al,	%al
    jz        L218
L219:
    cmp       %rsi,	0
    jge       L222
    mov       %rax,	%rsi
    neg       %rax
    mov       %rsi,	%rax
    mov       %al,	45
    mov       [%rbp + msys.i64tostrfmt.str],	%al
    jmp       L221
L222:
    mov       %al,	43
    mov       [%rbp + msys.i64tostrfmt.str],	%al
L221:
    movzx     %rax,	byte ptr[%r13+7]
    movzx     %r10,	byte ptr[%r13+2]
    lea       %r11,	[%rbp + msys.i64tostrfmt.str+1]
    mov       %rcx,	%rsi
    mov       %rdx,	%r11
    mov       %r8,	%r10
    mov       %r9,	%rax
    call      msys.u64tostr
    inc       %rax
    mov       %rdi,	%rax
    jmp       L217
L218:
    movzx     %rax,	byte ptr[%r13+7]
    movzx     %r10,	byte ptr[%r13+2]
    mov       %rcx,	%rsi
    lea       %rdx,	[%rbp + msys.i64tostrfmt.str]
    mov       %r8,	%r10
    mov       %r9,	%rax
    call      msys.u64tostr
    mov       %rdi,	%rax
L217:
L215:
    mov       %al,	[%r13+10]
    test      %al,	%al
    jz        L224
    mov       %al,	[%r13+10]
    mov       [%rbp + %rdi + msys.i64tostrfmt.str],	%al
    inc       %rdi
    mov       %rax,	%rdi
    xor       %r10d,	%r10d
    mov       [%rbp + %rax + msys.i64tostrfmt.str],	%r10b
L224:
    movzx     %rax,	byte ptr[%r13+2]
    cmp       %rax,	10
    jg        L227
    mov       %al,	[%r13+10]
    test      %al,	%al
    jz        L226
L227:
    movzx     %rax,	byte ptr[%r13+8]
    cmp       %rax,	97
    jnz       L226
    lea       %rcx,	[%rbp + msys.i64tostrfmt.str]
    call      mlib.convlcstring
L226:
    lea       %rcx,	[%rbp + msys.i64tostrfmt.str]
    mov       %rdx,	%r12
    mov       %r8,	%rdi
    mov       %r9,	%r13
    call      msys.expandstr
L212:
#---------------
    add       %rsp,	392
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.u64tostrfmt
msys.u64tostrfmt:
#?>>
    .set msys.u64tostrfmt.str, -360
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	400
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    movzx     %rax,	byte ptr[%r12+7]
    movzx     %r10,	byte ptr[%r12+2]
    mov       %rcx,	%rbx
    lea       %rdx,	[%rbp + msys.u64tostrfmt.str]
    mov       %r8,	%r10
    mov       %r9,	%rax
    call      msys.u64tostr
    mov       %rdi,	%rax
    mov       %al,	[%r12+10]
    test      %al,	%al
    jz        L230
    mov       %al,	[%r12+10]
    mov       [%rbp + %rdi + msys.u64tostrfmt.str],	%al
    inc       %rdi
    mov       %rax,	%rdi
    xor       %r10d,	%r10d
    mov       [%rbp + %rax + msys.u64tostrfmt.str],	%r10b
L230:
    movzx     %rax,	byte ptr[%r12+2]
    cmp       %rax,	10
    jg        L233
    mov       %al,	[%r12+10]
    test      %al,	%al
    jz        L232
    movzx     %rax,	byte ptr[%r12+8]
    cmp       %rax,	97
    jnz       L232
L233:
L232:
    lea       %rcx,	[%rbp + msys.u64tostrfmt.str]
    mov       %rdx,	%rsi
    mov       %r8,	%rdi
    mov       %r9,	%r12
    call      msys.expandstr
L228:
#---------------
    add       %rsp,	400
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.i64mintostr
msys.i64mintostr:
#?>>
    .set msys.i64mintostr.t, -360
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	392
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       %r15,	%r8
#---------------
    mov       %rax,	%r14
    cmp       %rax,	10
    jz        L236
    cmp       %rax,	16
    jz        L237
    cmp       %rax,	2
    jz        L238
    jmp       L239
L236:
    lea       %rax,	[%rbp + msys.i64mintostr.t]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8054]
    call      strcpy
    mov       %rbx,	3
    jmp       L235
L237:
    lea       %rax,	[%rbp + msys.i64mintostr.t]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8055]
    call      strcpy
    mov       %rbx,	1
    jmp       L235
L238:
    lea       %rax,	[%rbp + msys.i64mintostr.t]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8056]
    call      strcpy
    mov       %rbx,	7
    jmp       L235
L239:
    lea       %rax,	[%rbp + msys.i64mintostr.t]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8057]
    call      strcpy
L235:
    lea       %rax,	[%rbp + msys.i64mintostr.t]
    mov       %rcx,	%rax
    call      strlen
    mov       %rdi,	%rax
    mov       %rax,	%rdi
    add       %r13,	%rax
    test      %r15,	%r15
    jz        L241
    mov       %rax,	%rbx
    add       %r13,	%rax
L241:
    xor       %eax,	%eax
    mov       [%r13],	%al
    xor       %rsi,	%rsi
    mov       %rax,	%r14
    cmp       %rax,	10
    jnz       L243
    mov       %rax,	3
    jmp       L242
L243:
    mov       %rax,	4
L242:
    mov       %r12,	%rax
    jmp       L245
L244:
    dec       %r13
    mov       %rax,	%rdi
    dec       %rdi
    mov       %al,	[%rbp + %rax + msys.i64mintostr.t-1]
    mov       [%r13],	%al
    test      %r15,	%r15
    jz        L248
    test      %rdi,	%rdi
    jz        L248
    inc       %rsi
    cmp       %rsi,	%r12
    jnz       L248
    dec       %r13
    mov       [%r13],	%r15b
    xor       %rsi,	%rsi
L248:
L245:
    test      %rdi,	%rdi
    jnz       L244
    mov       %rcx,	%r13
    call      strlen
L234:
#---------------
    add       %rsp,	392
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.strtostrfmt
msys.strtostrfmt:
#?>>
    .set msys.strtostrfmt.n, 80
    .set msys.strtostrfmt.fmt, 88
    .set msys.strtostrfmt.str, -256
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	288
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       [%rbp+80],	%r8
    mov       [%rbp+88],	%r9
#---------------
    xor       %r12,	%r12
    mov       %rax,	[%rbp + msys.strtostrfmt.fmt]
    mov       %al,	[%rax+3]
    test      %al,	%al
    jnz       L252
    mov       %rax,	[%rbp + msys.strtostrfmt.fmt]
    mov       %al,	[%rax+8]
    test      %al,	%al
    jz        L251
L252:
    mov       %rax,	[%rbp + msys.strtostrfmt.n]
    cmp       %rax,	256
    jge       L254
    lea       %rax,	[%rbp + msys.strtostrfmt.str]
    mov       %rdi,	%rax
    jmp       L253
L254:
    mov       %rax,	[%rbp + msys.strtostrfmt.n]
    add       %rax,	3
    mov       %r12,	%rax
    mov       %rcx,	%r12
    call      mlib.pcm_alloc
    mov       %rdi,	%rax
L253:
    mov       %rax,	[%rbp + msys.strtostrfmt.fmt]
    mov       %al,	[%rax+3]
    test      %al,	%al
    jz        L256
    mov       %rbx,	%rdi
    mov       %rax,	[%rbp + msys.strtostrfmt.fmt]
    mov       %al,	[%rax+3]
    mov       [%rbx],	%al
    inc       %rbx
    mov       %rax,	[%rbp + msys.strtostrfmt.n]
    test      %rax,	%rax
    jz        L258
    mov       %rcx,	%rbx
    mov       %rdx,	%r13
    call      strcpy
    mov       %rax,	[%rbp + msys.strtostrfmt.n]
    add       %rbx,	%rax
L258:
    mov       %rax,	[%rbp + msys.strtostrfmt.fmt]
    mov       %al,	[%rax+3]
    mov       [%rbx],	%al
    inc       %rbx
    xor       %eax,	%eax
    mov       [%rbx],	%al
    mov       %rax,	2
    add       [%rbp + msys.strtostrfmt.n],	%rax
    jmp       L255
L256:
    mov       %rcx,	%rdi
    mov       %rdx,	%r13
    mov       %r8,	[%rbp + msys.strtostrfmt.n]
    call      memcpy
L255:
    mov       %rax,	[%rbp + msys.strtostrfmt.fmt]
    movzx     %rax,	byte ptr[%rax+8]
    cmp       %rax,	97
    jz        L260
    cmp       %rax,	65
    jz        L261
    jmp       L262
L260:
    mov       %rcx,	%rdi
    call      mlib.convlcstring
    jmp       L259
L261:
    mov       %rcx,	%rdi
    call      mlib.convucstring
L262:
L259:
    mov       %r13,	%rdi
L251:
    mov       %rax,	[%rbp + msys.strtostrfmt.fmt]
    movzx     %rax,	byte ptr[%rax]
    mov       %rsi,	%rax
    cmp       %rsi,	[%rbp + msys.strtostrfmt.n]
    jle       L264
    mov       %rcx,	%r13
    mov       %rdx,	%r14
    mov       %r8,	[%rbp + msys.strtostrfmt.n]
    mov       %r9,	[%rbp + msys.strtostrfmt.fmt]
    call      msys.expandstr
    mov       [%rbp + msys.strtostrfmt.n],	%rax
    jmp       L263
L264:
    mov       %rcx,	%r14
    mov       %rdx,	%r13
    mov       %r8,	[%rbp + msys.strtostrfmt.n]
    call      memcpy
L263:
    test      %r12,	%r12
    jz        L266
    mov       %rcx,	%rdi
    mov       %rdx,	%r12
    call      mlib.pcm_free
L266:
    mov       %rax,	[%rbp + msys.strtostrfmt.n]
L249:
#---------------
    add       %rsp,	288
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.tostr_i64
msys.tostr_i64:
#?>>
    .set msys.tostr_i64.a, 32
    .set msys.tostr_i64.str, -360
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	400
    mov       [%rbp+32],	%rcx
    mov       %rbx,	%rdx
#---------------
    movzx     %rax,	byte ptr[%rbx+12]
    test      %rax,	%rax
    jz        L269
    cmp       %rax,	77
    jz        L270
    jmp       L271
L269:
    mov       %rcx,	[%rbp + msys.tostr_i64.a]
    lea       %rdx,	[%rbp + msys.tostr_i64.str]
    mov       %r8,	%rbx
    call      msys.i64tostrfmt
    mov       %rdi,	%rax
    jmp       L268
L270:
    lea       %rcx,	[%rbp + msys.tostr_i64.a]
    mov       %rdx,	8
    lea       %r8,	[%rbp + msys.tostr_i64.str]
    mov       %r9,	%rbx
    call      msys.domultichar
    mov       %rdi,	%rax
    jmp       L268
L271:
    mov       %rcx,	[%rbp + msys.tostr_i64.a]
    xor       %edx,	%edx
    call      msys.m$print_c8
    jmp       L267
L268:
    lea       %rcx,	[%rbp + msys.tostr_i64.str]
    mov       %rdx,	%rdi
    call      msys.printstr_n
L267:
#---------------
    add       %rsp,	400
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.tostr_u64
msys.tostr_u64:
#?>>
    .set msys.tostr_u64.a, 32
    .set msys.tostr_u64.str, -360
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	400
    mov       [%rbp+32],	%rcx
    mov       %rbx,	%rdx
#---------------
    movzx     %rax,	byte ptr[%rbx+12]
    cmp       %rax,	77
    jz        L274
    cmp       %rax,	67
    jz        L275
    jmp       L276
L274:
    lea       %rcx,	[%rbp + msys.tostr_u64.a]
    mov       %rdx,	8
    lea       %r8,	[%rbp + msys.tostr_u64.str]
    mov       %r9,	%rbx
    call      msys.domultichar
    mov       %rdi,	%rax
    jmp       L273
L275:
    mov       %rcx,	[%rbp + msys.tostr_u64.a]
    xor       %edx,	%edx
    call      msys.m$print_c8
    jmp       L272
L276:
    mov       %rcx,	[%rbp + msys.tostr_u64.a]
    lea       %rdx,	[%rbp + msys.tostr_u64.str]
    mov       %r8,	%rbx
    call      msys.u64tostrfmt
    mov       %rdi,	%rax
L273:
    lea       %rcx,	[%rbp + msys.tostr_u64.str]
    mov       %rdx,	%rdi
    call      msys.printstr_n
L272:
#---------------
    add       %rsp,	400
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.tostr_r64
msys.tostr_r64:
#?>>
    .set msys.tostr_r64.str, -360
    .set msys.tostr_r64.str2, -720
    .set msys.tostr_r64.cfmt, -736
    push      %rdi
    push      %rbx
    movq      %rax,	%XMM15
    push      %rax
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	776
    movq      %XMM15,	%XMM0
    mov       %rbx,	%rdx
#---------------
    mov       %al,	37
    mov       [%rbp + msys.tostr_r64.cfmt],	%al
    mov       %al,	[%rbx+1]
    test      %al,	%al
    jz        L279
    mov       %al,	46
    mov       [%rbp + msys.tostr_r64.cfmt+1],	%al
    mov       %al,	42
    mov       [%rbp + msys.tostr_r64.cfmt+2],	%al
    mov       %al,	[%rbx+5]
    mov       [%rbp + msys.tostr_r64.cfmt+3],	%al
    xor       %eax,	%eax
    mov       [%rbp + msys.tostr_r64.cfmt+4],	%al
    movsx     %rax,	byte ptr[%rbx+1]
    lea       %rcx,	[%rbp + msys.tostr_r64.str]
    lea       %rdx,	[%rbp + msys.tostr_r64.cfmt]
    mov       %r8,	%rax
    movq      %XMM3,	%XMM15
    movq      %r9,	%XMM3
    call      sprintf
    jmp       L278
L279:
    mov       %al,	[%rbx+5]
    mov       [%rbp + msys.tostr_r64.cfmt+1],	%al
    xor       %eax,	%eax
    mov       [%rbp + msys.tostr_r64.cfmt+2],	%al
    lea       %rcx,	[%rbp + msys.tostr_r64.str]
    lea       %rdx,	[%rbp + msys.tostr_r64.cfmt]
    movq      %XMM2,	%XMM15
    movq      %r8,	%XMM2
    call      sprintf
L278:
    lea       %rcx,	[%rbp + msys.tostr_r64.str]
    call      strlen
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rbx]
    mov       %r10,	%rdi
    cmp       %r10,	%rax
    jge       L281
    lea       %rcx,	[%rbp + msys.tostr_r64.str]
    lea       %rdx,	[%rbp + msys.tostr_r64.str2]
    mov       %r8,	%rdi
    mov       %r9,	%rbx
    call      msys.expandstr
    mov       %rdi,	%rax
    lea       %rcx,	[%rbp + msys.tostr_r64.str]
    lea       %rdx,	[%rbp + msys.tostr_r64.str2]
    call      strcpy
L281:
    lea       %rcx,	[%rbp + msys.tostr_r64.str]
    mov       %rdx,	%rdi
    call      msys.printstr_n
#---------------
    add       %rsp,	776
    pop       %rbp
    pop       %rcx
    movq      %XMM15,	%rcx
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.tostr_str
msys.tostr_str:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
#---------------
    cmp       %r13,	-1
    jnz       L284
    mov       %rcx,	%r12
    call      strlen
    mov       %r13,	%rax
L284:
    mov       %rdi,	%r13
    mov       %al,	[%r14+3]
    test      %al,	%al
    jnz       L287
    movzx     %rax,	byte ptr[%r14]
    cmp       %rax,	%rdi
    jg        L287
    mov       %al,	[%r14+8]
    test      %al,	%al
    jnz       L287
    mov       %al,	[%r14+1]
    test      %al,	%al
    jz        L286
L287:
    mov       %al,	[%r14+3]
    test      %al,	%al
    jz        L289
    mov       %rax,	2
    add       %rdi,	%rax
L289:
    movzx     %rax,	byte ptr[%r14]
    cmp       %rax,	%rdi
    jle       L291
    movzx     %rax,	byte ptr[%r14]
    mov       %rdi,	%rax
L291:
    lea       %rax,	[%rdi+1]
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       %rsi,	%rax
    mov       %rcx,	%r12
    mov       %rdx,	%rsi
    mov       %r8,	%r13
    mov       %r9,	%r14
    call      msys.strtostrfmt
    mov       %rbx,	%rax
    mov       %al,	[%r14+1]
    test      %al,	%al
    jz        L293
    movsx     %rax,	byte ptr[%r14+1]
    cmp       %rbx,	%rax
    jle       L8058
    mov       %rbx,	%rax
L8058:
L293:
    mov       %rcx,	%rsi
    mov       %rdx,	%rbx
    call      msys.printstr_n
    lea       %rax,	[%rdi+1]
    mov       %rcx,	%rsi
    mov       %rdx,	%rax
    call      mlib.pcm_free
    jmp       L285
L286:
    mov       %rcx,	%r12
    mov       %rdx,	%r13
    call      msys.printstr_n
L285:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.getfmt
msys.getfmt:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    test      %rdi,	%rdi
    jz        L296
    mov       %rcx,	%rdi
    mov       %rdx,	-1
    lea       %r8,	[%rip+msys.getfmt.fmt]
    call      msys.strtofmt
    lea       %rax,	[%rip+msys.getfmt.fmt]
    jmp       L295
L296:
    lea       %rax,	[%rip+msys.defaultfmt]
L295:
L294:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc msys.strint
msys.strint:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    lea       %rcx,	[%rip+msys.strint.str]
    call      msys.m$print_startstr
    mov       %rcx,	%rsi
    call      msys.getfmt
    mov       %r10,	%rax
    mov       %rdi,	%r10
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      msys.tostr_i64
    call      msys.m$print_end
    lea       %rcx,	[%rip+msys.strint.str]
    mov       %rdx,	%rdi
    call      msys.getstr
L297:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.getstrint
msys.getstrint:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rbx
    call      msys.m$print_startstr
    xor       %ecx,	%ecx
    call      msys.getfmt
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      msys.tostr_i64
    call      msys.m$print_end
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.strword
msys.strword:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    lea       %rcx,	[%rip+msys.strword.str]
    call      msys.m$print_startstr
    mov       %rcx,	%rsi
    call      msys.getfmt
    mov       %r10,	%rax
    mov       %rdi,	%r10
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      msys.tostr_u64
    call      msys.m$print_end
    lea       %rcx,	[%rip+msys.strword.str]
    mov       %rdx,	%rdi
    call      msys.getstr
L299:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.strreal
msys.strreal:
#?>>
    push      %rdi
    push      %rbx
    movq      %rax,	%XMM15
    push      %rax
#?]]
    sub       %rsp,	48
    movq      %XMM15,	%XMM0
    mov       %rbx,	%rdx
#---------------
    lea       %rcx,	[%rip+msys.strreal.str]
    call      msys.m$print_startstr
    mov       %rcx,	%rbx
    call      msys.getfmt
    mov       %r10,	%rax
    mov       %rdi,	%r10
    movq      %XMM0,	%XMM15
    mov       %rdx,	%rax
    call      msys.tostr_r64
    call      msys.m$print_end
    lea       %rcx,	[%rip+msys.strreal.str]
    mov       %rdx,	%rdi
    call      msys.getstr
L300:
#---------------
    add       %rsp,	48
    pop       %rcx
    movq      %XMM15,	%rcx
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.getstr
msys.getstr:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %al,	[%rbx+13]
    test      %al,	%al
    jz        L303
    mov       %rcx,	%rdi
    call      mlib.pcm_copyheapstring
    jmp       L302
L303:
    mov       %rax,	%rdi
L302:
L301:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.initreadbuffer
msys.initreadbuffer:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    mov       %rax,	[%rip+msys.rd_buffer]
    test      %rax,	%rax
    jnz       L304
L306:
    mov       %rcx,	16384
    call      mlib.pcm_alloc
    mov       [%rip+msys.rd_buffer],	%rax
    xor       %eax,	%eax
    mov       %r10,	[%rip+msys.rd_buffer]
    mov       [%r10],	%al
    mov       %rax,	[%rip+msys.rd_buffer]
    mov       [%rip+msys.rd_lastpos],	%rax
    mov       [%rip+msys.rd_pos],	%rax
L304:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc msys.m$read_conline
msys.m$read_conline:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    call      msys.initreadbuffer
    xor       %ecx,	%ecx
    mov       %rdx,	[%rip+msys.rd_buffer]
    mov       %r8,	16384
    call      mlib.readlinen
    mov       %rcx,	[%rip+msys.rd_buffer]
    call      strlen
    mov       [%rip+msys.rd_length],	%rax
    mov       %rax,	[%rip+msys.rd_buffer]
    mov       [%rip+msys.rd_pos],	%rax
    xor       %eax,	%eax
    mov       [%rip+msys.rd_lastpos],	%rax
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc msys.m$read_fileline
msys.m$read_fileline:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    call      msys.initreadbuffer
    cmp       %rdi,	1
    jnz       L310
    lea       %rcx,	[%rip+L8059]
    call      mlib.abortprogram
    jmp       L308
L310:
    mov       %rcx,	%rdi
    mov       %rdx,	[%rip+msys.rd_buffer]
    mov       %r8,	16384
    call      mlib.readlinen
    mov       %rcx,	[%rip+msys.rd_buffer]
    call      strlen
    mov       [%rip+msys.rd_length],	%rax
    mov       %rax,	[%rip+msys.rd_buffer]
    mov       [%rip+msys.rd_pos],	%rax
    xor       %eax,	%eax
    mov       [%rip+msys.rd_lastpos],	%rax
L308:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc msys.m$read_strline
msys.m$read_strline:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    call      msys.initreadbuffer
    mov       %rcx,	%rbx
    call      strlen
    mov       %rdi,	%rax
    cmp       %rdi,	16384
    jge       L313
    mov       %rcx,	[%rip+msys.rd_buffer]
    mov       %rdx,	%rbx
    call      strcpy
    jmp       L312
L313:
    mov       %rcx,	[%rip+msys.rd_buffer]
    mov       %rdx,	%rbx
    mov       %r8,	16383
    call      memcpy
    mov       %rax,	[%rip+msys.rd_buffer]
    lea       %rax,	[%rax+16384]
    sub       %rax,	1
    xor       %r10d,	%r10d
    mov       [%rax],	%r10b
L312:
    mov       [%rip+msys.rd_length],	%rdi
    mov       %rax,	[%rip+msys.rd_buffer]
    mov       [%rip+msys.rd_pos],	%rax
    xor       %eax,	%eax
    mov       [%rip+msys.rd_lastpos],	%rax
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.readitem
msys.readitem:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r14,	%rcx
#---------------
    mov       %rax,	[%rip+msys.rd_buffer]
    test      %rax,	%rax
    jnz       L316
    call      msys.initreadbuffer
L316:
    mov       %rbx,	[%rip+msys.rd_pos]
    jmp       L318
L317:
    inc       %rbx
L318:
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	32
    jz        L317
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	9
    jz        L317
    mov       %rsi,	%rbx
    mov       %rax,	%rbx
    mov       [%rip+msys.rd_pos],	%rax
    mov       [%rip+msys.rd_lastpos],	%rax
    movzx     %rax,	byte ptr[%rbx]
    test      %rax,	%rax
    jnz       L321
    xor       %eax,	%eax
    mov       [%rip+msys.termchar],	%rax
    xor       %eax,	%eax
    mov       [%r14],	%rax
    mov       %rax,	%rbx
    jmp       L314
L321:
    xor       %r12b,	%r12b
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	34
    jnz       L323
    mov       %r12b,	34
    inc       %rbx
    jmp       L322
L323:
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	39
    jnz       L324
    mov       %r12b,	39
    inc       %rbx
L324:
L322:
    mov       %rax,	%rbx
    mov       %rsi,	%rax
    mov       %rdi,	%rax
    jmp       L326
L325:
    mov       %rax,	%rbx
    inc       %rbx
    mov       %r13b,	[%rax]
    movzx     %rax,	%r13b
    cmp       %rax,	32
    jz        L329
    cmp       %rax,	9
    jz        L329
    cmp       %rax,	44
    jz        L329
    cmp       %rax,	61
    jnz       L330
L329:
    test      %r12b,	%r12b
    jnz       L333
    cmp       %rdi,	%rbx
    jnz       L332
L333:
    jmp       L334
L332:
    movzx     %rax,	%r13b
    mov       [%rip+msys.termchar],	%rax
    jmp       L327
L330:
#msys.readitem.normalchar:
L334:
    movzx     %rax,	%r13b
    movzx     %r10,	%r12b
    cmp       %rax,	%r10
    jnz       L336
    movzx     %rax,	byte ptr[%rbx]
    movzx     %r10,	%r12b
    cmp       %rax,	%r10
    jnz       L338
    mov       [%rdi],	%r13b
    inc       %rbx
    inc       %rdi
    jmp       L337
L338:
    movzx     %rax,	byte ptr[%rbx]
    mov       [%rip+msys.termchar],	%rax
    mov       %rax,	[%rip+msys.termchar]
    cmp       %rax,	44
    jz        L341
    cmp       %rax,	61
    jnz       L340
L341:
    inc       %rbx
    movzx     %rax,	byte ptr[%rbx]
    mov       [%rip+msys.termchar],	%rax
L340:
    jmp       L327
L337:
    jmp       L335
L336:
    mov       [%rdi],	%r13b
    inc       %rdi
L335:
L328:
L326:
    mov       %al,	[%rbx]
    test      %al,	%al
    jnz       L325
L327:
    movzx     %rax,	byte ptr[%rbx]
    test      %rax,	%rax
    jnz       L343
    xor       %eax,	%eax
    mov       [%rip+msys.termchar],	%rax
L343:
    mov       %rax,	%rdi
    sub       %rax,	%rsi
    mov       [%r14],	%rax
    mov       [%rip+msys.rd_pos],	%rbx
    mov       %rax,	%rsi
L314:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.strtoint
msys.strtoint:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       %r15,	%r8
#---------------
    xor       %eax,	%eax
    mov       [%rip+msys.itemerror],	%rax
    cmp       %r14,	-1
    jnz       L346
    mov       %rcx,	%r13
    call      strlen
    mov       %r14,	%rax
L346:
    xor       %dil,	%dil
    mov       %rax,	%r14
    test      %rax,	%rax
    jz        L348
    movzx     %rax,	byte ptr[%r13]
    cmp       %rax,	45
    jnz       L348
    mov       %dil,	1
    inc       %r13
    dec       %r14
    jmp       L347
L348:
    test      %r14,	%r14
    jz        L349
    movzx     %rax,	byte ptr[%r13]
    cmp       %rax,	43
    jnz       L349
    inc       %r13
    dec       %r14
L349:
L347:
    xor       %rbx,	%rbx
    jmp       L351
L350:
    mov       %rax,	%r13
    inc       %r13
    movzx     %rax,	byte ptr[%rax]
    mov       %rsi,	%rax
    dec       %r14
    mov       %rax,	%rsi
    cmp       %rax,	65
    jl        L354
    cmp       %rax,	70
    jg        L354
    lea       %rax,	[%rsi-65]
    add       %rax,	10
    mov       %r12,	%rax
    jmp       L353
L354:
    mov       %rax,	%rsi
    cmp       %rax,	97
    jl        L355
    cmp       %rax,	102
    jg        L355
    lea       %rax,	[%rsi-97]
    add       %rax,	10
    mov       %r12,	%rax
    jmp       L353
L355:
    mov       %rax,	%rsi
    cmp       %rax,	48
    jl        L356
    cmp       %rax,	57
    jg        L356
    lea       %rax,	[%rsi-48]
    mov       %r12,	%rax
    jmp       L353
L356:
    mov       %rax,	%rsi
    cmp       %rax,	95
    jz        L358
    cmp       %rax,	39
    jnz       L357
L358:
    jmp       L351
L357:
    mov       %rax,	1
    mov       [%rip+msys.itemerror],	%rax
    jmp       L352
L353:
    cmp       %r12,	%r15
    jb        L360
    mov       %rax,	1
    mov       [%rip+msys.itemerror],	%rax
    jmp       L352
L360:
    mov       %rax,	%rbx
    mov       %r10,	%r15
    imul      %rax,	%r10
    add       %rax,	%r12
    mov       %rbx,	%rax
L351:
    test      %r14,	%r14
    jnz       L350
L352:
    test      %dil,	%dil
    jz        L362
    mov       %rax,	%rbx
    neg       %rax
    jmp       L361
L362:
    mov       %rax,	%rbx
L361:
L344:
#---------------
    add       %rsp,	48
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.m$read_i64
msys.m$read_i64:
#?>>
    .set msys.m$read_i64.length, -8
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rbx,	%rcx
#---------------
    mov       %rcx,	%rbx
    call      toupper
    movsxd    %r10,	%eax
    mov       %rbx,	%r10
    mov       %rax,	%rbx
    cmp       %rax,	67
    jz        L365
    cmp       %rax,	84
    jz        L366
    cmp       %rax,	69
    jz        L367
    jmp       L368
L365:
    mov       %rax,	[%rip+msys.rd_pos]
    mov       [%rip+msys.rd_lastpos],	%rax
    mov       %rax,	[%rip+msys.rd_pos]
    mov       %al,	[%rax]
    test      %al,	%al
    jz        L370
    mov       %rax,	[%rip+msys.rd_pos]
    inc       qword ptr[%rip+msys.rd_pos]
    movzx     %rax,	byte ptr[%rax]
    jmp       L363
L370:
    xor       %eax,	%eax
    jmp       L363
L369:
    jmp       L364
L366:
    mov       %rax,	[%rip+msys.termchar]
    jmp       L363
L367:
    mov       %rax,	[%rip+msys.itemerror]
    jmp       L363
L368:
L364:
    lea       %rcx,	[%rbp + msys.m$read_i64.length]
    call      msys.readitem
    mov       %rdi,	%rax
    mov       %rax,	%rbx
    test      %rax,	%rax
    jz        L372
    cmp       %rax,	73
    jz        L372
    cmp       %rax,	66
    jz        L373
    cmp       %rax,	72
    jz        L374
    jmp       L375
L372:
    mov       %rcx,	%rdi
    mov       %rdx,	[%rbp + msys.m$read_i64.length]
    mov       %r8,	10
    call      msys.strtoint
    jmp       L363
L373:
    mov       %rcx,	%rdi
    mov       %rdx,	[%rbp + msys.m$read_i64.length]
    mov       %r8,	2
    call      msys.strtoint
    jmp       L363
L374:
    mov       %rcx,	%rdi
    mov       %rdx,	[%rbp + msys.m$read_i64.length]
    mov       %r8,	16
    call      msys.strtoint
    jmp       L363
L375:
L371:
    xor       %eax,	%eax
L363:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.m$read_r64
msys.m$read_r64:
#?>>
    .set msys.m$read_r64.fmt, 24
    .set msys.m$read_r64.str, -512
    .set msys.m$read_r64.length, -520
    .set msys.m$read_r64.numlength, -528
    .set msys.m$read_r64.x, -536
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	568
#---------------
    lea       %rcx,	[%rbp + msys.m$read_r64.length]
    call      msys.readitem
    mov       %rdi,	%rax
    mov       %rax,	[%rbp + msys.m$read_r64.length]
    test      %rax,	%rax
    jz        L379
    mov       %rax,	[%rbp + msys.m$read_r64.length]
    cmp       %rax,	512
    jl        L378
L379:
    movq      %XMM0,	[%rip+L8060]
    jmp       L376
L378:
    lea       %rcx,	[%rbp + msys.m$read_r64.str]
    mov       %rdx,	%rdi
    mov       %r8,	[%rbp + msys.m$read_r64.length]
    call      memcpy
    xor       %eax,	%eax
    mov       %r10,	[%rbp + msys.m$read_r64.length]
    mov       [%rbp + %r10 + msys.m$read_r64.str],	%al
    xor       %eax,	%eax
    mov       [%rip+msys.itemerror],	%rax
    lea       %rcx,	[%rbp + msys.m$read_r64.str]
    lea       %rdx,	[%rip+L8061]
    lea       %r8,	[%rbp + msys.m$read_r64.x]
    lea       %r9,	[%rbp + msys.m$read_r64.numlength]
    call      sscanf
    movsxd    %r10,	%eax
    test      %r10,	%r10
    jz        L382
    movsxd    %rax,	dword ptr[%rbp + msys.m$read_r64.numlength]
    cmp       %rax,	[%rbp + msys.m$read_r64.length]
    jz        L381
L382:
    movq      %XMM4,	[%rip+L8062]
    movq      [%rbp + msys.m$read_r64.x],	%XMM4
    mov       %rax,	1
    mov       [%rip+msys.itemerror],	%rax
L381:
    movq      %XMM0,	[%rbp + msys.m$read_r64.x]
L376:
#---------------
    add       %rsp,	568
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc msys.m$read_str
msys.m$read_str:
#?>>
    .set msys.m$read_str.length, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    xor       %eax,	%eax
    mov       [%rip+msys.itemerror],	%rax
    mov       %rax,	%r12
    cmp       %rax,	76
    jz        L386
    cmp       %rax,	108
    jnz       L385
L386:
    mov       %rdi,	[%rip+msys.rd_pos]
    mov       %rax,	[%rip+msys.rd_buffer]
    mov       %r10,	[%rip+msys.rd_length]
    lea       %rax,	[%rax + %r10]
    sub       %rax,	[%rip+msys.rd_pos]
    mov       [%rbp + msys.m$read_str.length],	%rax
    jmp       L384
L385:
    lea       %rcx,	[%rbp + msys.m$read_str.length]
    call      msys.readitem
    mov       %rdi,	%rax
    mov       %rax,	%r12
    cmp       %rax,	78
    jz        L389
    cmp       %rax,	110
    jnz       L388
L389:
    mov       %rcx,	%rdi
    mov       %rdx,	[%rbp + msys.m$read_str.length]
    call      mlib.iconvlcn
L388:
L384:
    cmp       %rsi,	0
    jle       L391
    mov       %rax,	[%rbp + msys.m$read_str.length]
    cmp       %rax,	%rsi
    jl        L393
    lea       %rax,	[%rsi-1]
    mov       [%rbp + msys.m$read_str.length],	%rax
    mov       %rax,	1
    mov       [%rip+msys.itemerror],	%rax
L393:
L391:
    mov       %rcx,	%rbx
    mov       %rdx,	%rdi
    mov       %r8,	[%rbp + msys.m$read_str.length]
    call      memcpy
    xor       %eax,	%eax
    mov       %r10,	[%rbp + msys.m$read_str.length]
    mov       [%rbx + %r10],	%al
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.readstr
msys.readstr:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rsi
    mov       %r8,	%rbx
    call      msys.m$read_str
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.rereadln
msys.rereadln:
#?>>
#?]]
#---------------
    mov       %rax,	[%rip+msys.rd_buffer]
    mov       [%rip+msys.rd_pos],	%rax
    mov       %rax,	[%rip+msys.rd_pos]
    mov       [%rip+msys.rd_lastpos],	%rax
#---------------
    ret       
# End 
# Proc msys.reread
msys.reread:
#?>>
#?]]
#---------------
    mov       %rax,	[%rip+msys.rd_lastpos]
    mov       [%rip+msys.rd_pos],	%rax
#---------------
    ret       
# End 
# Proc msys.valint
msys.valint:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r12,	%rcx
    mov       %r13,	%rdx
#---------------
    call      msys.initreadbuffer
    mov       %rdi,	[%rip+msys.rd_pos]
    mov       %rbx,	[%rip+msys.rd_lastpos]
    mov       [%rip+msys.rd_pos],	%r12
    mov       %rcx,	%r13
    call      msys.m$read_i64
    mov       %rsi,	%rax
    mov       [%rip+msys.rd_pos],	%rdi
    mov       [%rip+msys.rd_lastpos],	%rbx
    mov       %rax,	%rsi
L397:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.valreal
msys.valreal:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    movq      %rax,	%XMM15
    push      %rax
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
#---------------
    call      msys.initreadbuffer
    mov       %rdi,	[%rip+msys.rd_pos]
    mov       %rbx,	[%rip+msys.rd_lastpos]
    mov       [%rip+msys.rd_pos],	%rsi
    xor       %ecx,	%ecx
    call      msys.m$read_r64
    movq      %XMM15,	%XMM0
    mov       [%rip+msys.rd_pos],	%rdi
    mov       [%rip+msys.rd_lastpos],	%rbx
    movq      %XMM0,	%XMM15
L398:
#---------------
    add       %rsp,	40
    pop       %rcx
    movq      %XMM15,	%rcx
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.mclunimpl
msys.mclunimpl:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    lea       %rcx,	[%rip+L8063]
    mov       %rdx,	%rdi
    call      printf
    mov       %rcx,	1
    call      exit
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc msys.dumpstr
msys.dumpstr:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    mov       %rax,	[%rip+msys.outdev]
    cmp       %rax,	3
    jnz       L402
    mov       %rdi,	[%rip+msys.outchan]
    test      %rsi,	%rsi
    jz        L404
    mov       %rax,	[%rdi]
    mov       %rcx,	%rax
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      memcpy
    mov       %rax,	%rdi
    mov       %r10,	%rsi
    add       [%rax],	%r10
L404:
    mov       %rax,	[%rdi]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10b
    jmp       L400
L402:
    test      %rsi,	%rsi
    jnz       L406
    jmp       L400
L406:
    test      %r12,	%r12
    jz        L408
    cmp       %rsi,	2
    jl        L408
    mov       %rax,	[%rip+msys.outdev]
    cmp       %rax,	1
    jnz       L408
    dec       qword ptr[%rip+msys.printptr]
    mov       %rax,	[%rip+msys.printptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	10
    jnz       L410
    mov       %rax,	[%rip+msys.printptr]
    sub       %rax,	1
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	13
    jnz       L412
    mov       %rax,	[%rip+msys.printptr]
    sub       %rax,	1
    xor       %r10d,	%r10d
    mov       [%rax],	%r10b
    jmp       L411
L412:
    xor       %eax,	%eax
    mov       %r10,	[%rip+msys.printptr]
    mov       [%r10],	%al
L411:
    lea       %rcx,	[%rip+msys.printbuffer]
    call      puts
    jmp       L400
L410:
L408:
    mov       %rax,	[%rip+msys.outdev]
    cmp       %rax,	1
    jz        L414
    cmp       %rax,	2
    jz        L415
    jmp       L416
L414:
    lea       %rcx,	[%rip+L8064]
    mov       %rdx,	%rsi
    mov       %r8,	%rbx
    call      printf
    jmp       L413
L415:
    mov       %rcx,	[%rip+msys.outchan]
    lea       %rdx,	[%rip+L8064]
    mov       %r8,	%rsi
    mov       %r9,	%rbx
    call      fprintf
L416:
L413:
L400:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.dumpprintbuffer
msys.dumpprintbuffer:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    mov       %rax,	[%rip+msys.printlen]
    test      %rax,	%rax
    jz        L419
    lea       %rcx,	[%rip+msys.printbuffer]
    mov       %rdx,	[%rip+msys.printlen]
    mov       %r8,	1
    call      msys.dumpstr
L419:
    call      msys.resetprintbuffer
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc msys.resetprintbuffer
msys.resetprintbuffer:
#?>>
#?]]
#---------------
    lea       %rax,	[%rip+msys.printbuffer]
    mov       [%rip+msys.printptr],	%rax
    xor       %eax,	%eax
    mov       [%rip+msys.printlen],	%rax
#---------------
    ret       
# End 
# Proc msys.addtobuffer
msys.addtobuffer:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rax,	[%rip+msys.printlen]
    add       %rax,	%rbx
    cmp       %rax,	4088
    jl        L423
    call      msys.dumpprintbuffer
L423:
    cmp       %rbx,	4096
    jge       L425
    mov       %rcx,	[%rip+msys.printptr]
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      memcpy
    mov       %rax,	%rbx
    add       [%rip+msys.printptr],	%rax
    mov       %rax,	%rbx
    add       [%rip+msys.printlen],	%rax
    jmp       L421
L425:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      msys.dumpstr
L421:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.m$power_i64
msys.m$power_i64:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    cmp       %rbx,	0
    jge       L428
    xor       %eax,	%eax
    jmp       L427
L428:
    test      %rbx,	%rbx
    jnz       L429
    mov       %rax,	1
    jmp       L427
L429:
    cmp       %rbx,	1
    jnz       L430
    mov       %rax,	%rdi
    jmp       L427
L430:
    mov       %rax,	%rbx
    and       %rax,	1
    jnz       L431
    mov       %rax,	%rbx
    sar       %rax,	1
    mov       %r10,	%rdi
    imul      %r10,	%r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      msys.m$power_i64
    jmp       L427
L431:
    lea       %rax,	[%rbx-1]
    sar       %rax,	1
    mov       %r10,	%rdi
    imul      %r10,	%r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      msys.m$power_i64
    mov       %r10,	%rdi
    imul      %rax,	%r10
L427:
L426:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.getutfsize
msys.getutfsize:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	16
#---------------
    mov       %rax,	%rcx
    inc       %rcx
    movzx     %rax,	byte ptr[%rax]
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L434
    xor       %eax,	%eax
    jmp       L433
L434:
    mov       %eax,	%edi
    shr       %eax,	7
    and       %eax,	1
    test      %rax,	%rax
    jnz       L435
    mov       %rax,	1
    jmp       L433
L435:
    mov       %rax,	%rdi
    shr       %rax,	5
    and       %rax,	7
    cmp       %rax,	6
    jnz       L436
    mov       %rax,	2
    jmp       L433
L436:
    mov       %rax,	%rdi
    shr       %rax,	4
    and       %rax,	15
    cmp       %rax,	14
    jnz       L437
    mov       %rax,	3
    jmp       L433
L437:
    mov       %rax,	%rdi
    shr       %rax,	3
    and       %rax,	31
    cmp       %rax,	30
    jnz       L438
    mov       %rax,	4
    jmp       L433
L438:
    mov       %rax,	1
L433:
L432:
#---------------
    add       %rsp,	16
    pop       %rdi
    ret       
# End 
# Proc mlib.pcm_alloc
mlib.pcm_alloc:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %al,	[%rip+mlib.pcm_setup]
    test      %al,	%al
    jnz       L441
    call      mlib.pcm_init
L441:
    cmp       %rbx,	2048
    jle       L443
    mov       %rcx,	%rbx
    call      mlib.pcm_getac
    mov       [%rip+mlib.alloccode],	%rax
    lea       %rax,	[%rip+mlib.allocupper]
    mov       %r10,	[%rip+mlib.alloccode]
    mov       %rax,	[%rax + %r10*8]
    mov       [%rip+mlib.allocbytes],	%rax
    mov       %rcx,	[%rip+mlib.allocbytes]
    call      mlib.allocmem
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L445
    lea       %rcx,	[%rip+L8065]
    call      mlib.abortprogram
L445:
    mov       %rax,	%rdi
    jmp       L439
L443:
    lea       %rax,	[%rip+mlib.sizeindextable]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       [%rip+mlib.alloccode],	%rax
    lea       %rax,	[%rip+mlib.allocupper]
    mov       %r10,	[%rip+mlib.alloccode]
    mov       %rax,	[%rax + %r10*8]
    mov       [%rip+mlib.allocbytes],	%rax
    lea       %rax,	[%rip+mlib.freelist]
    mov       %r10,	[%rip+mlib.alloccode]
    mov       %rax,	[%rax + %r10*8]
    mov       %rdi,	%rax
    test      %rax,	%rax
    jz        L447
    lea       %rax,	[%rip+mlib.freelist]
    mov       %r10,	[%rip+mlib.alloccode]
    mov       %rax,	[%rax + %r10*8]
    mov       %rax,	[%rax]
    lea       %r10,	[%rip+mlib.freelist]
    mov       %r11,	[%rip+mlib.alloccode]
    mov       [%r10 + %r11*8],	%rax
    mov       %rax,	%rdi
    jmp       L439
L447:
    mov       %rdi,	[%rip+mlib.pcheapptr]
    mov       %rax,	[%rip+mlib.allocbytes]
    add       [%rip+mlib.pcheapptr],	%rax
    mov       %rax,	[%rip+mlib.pcheapptr]
    cmp       %rax,	[%rip+mlib.pcheapend]
    jb        L449
    mov       %rcx,	[%rip+mlib.allocbytes]
    call      mlib.pcm_newblock
    mov       %rdi,	%rax
    mov       %rax,	%rdi
    jmp       L439
L449:
    mov       %rax,	%rdi
L439:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.pcm_free
mlib.pcm_free:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    test      %rsi,	%rsi
    jz        L453
    test      %rbx,	%rbx
    jnz       L452
L453:
    jmp       L450
L452:
    cmp       %rsi,	2048
    jle       L455
    mov       %rcx,	%rbx
    call      free
    jmp       L454
L455:
    lea       %rax,	[%rip+mlib.sizeindextable]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %rdi,	%rax
    lea       %rax,	[%rip+mlib.freelist]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    mov       [%rbx],	%rax
    mov       %rax,	%rbx
    lea       %r10,	[%rip+mlib.freelist]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*8],	%rax
L454:
L450:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.pcm_freeac
mlib.pcm_freeac:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    lea       %rax,	[%rip+mlib.allocupper]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mlib.pcm_free
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.pcm_clearmem
mlib.pcm_clearmem:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    mov       %r8,	%rbx
    call      memset
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.pcm_init
mlib.pcm_init:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
#---------------
    xor       %eax,	%eax
    mov       [%rip+mlib.alloccode],	%rax
    mov       %al,	[%rip+mlib.pcm_setup]
    test      %al,	%al
    jnz       L458
L460:
    xor       %ecx,	%ecx
    call      mlib.pcm_newblock
    mov       %r13,	1
L461:
    mov       %rdi,	1
    mov       %rbx,	16
    jmp       L465
L464:
    mov       %rax,	%rbx
    shl       %rax,	1
    mov       %rbx,	%rax
    inc       %rdi
L465:
    cmp       %r13,	%rbx
    jg        L464
    mov       %al,	%dil
    lea       %r10,	[%rip+mlib.sizeindextable]
    mov       %r11,	%r13
    mov       [%r10 + %r11],	%al
    inc       %r13
    cmp       %r13,	2048
    jle       L461
    mov       %rax,	16
    lea       %r10,	[%rip+mlib.allocupper]
    mov       [%r10+8],	%rax
    mov       %rsi,	16
    mov       %r13,	2
L467:
    mov       %rax,	%rsi
    shl       %rax,	1
    mov       %rsi,	%rax
    mov       %rax,	%rsi
    lea       %r10,	[%rip+mlib.allocupper]
    mov       %r11,	%r13
    mov       [%r10 + %r11*8],	%rax
    cmp       %rsi,	33554432
    jl        L471
    mov       %rbx,	%r13
    jmp       L469
L471:
    inc       %r13
    cmp       %r13,	27
    jle       L467
L469:
    lea       %rax,	[%rbx+1]
    mov       %r13,	%rax
    mov       %r12,	300
    cmp       %r13,	%r12
    jg        L474
L472:
    mov       %rax,	33554432
    add       %rsi,	%rax
    mov       %rax,	%rsi
    mov       %r10,	8589934592
    cmp       %rax,	%r10
    jge       L476
    mov       %rax,	%rsi
    lea       %r10,	[%rip+mlib.allocupper]
    mov       %r11,	%r13
    mov       [%r10 + %r11*8],	%rax
    mov       [%rip+mlib.maxmemory],	%rsi
    jmp       L475
L476:
    lea       %rax,	[%r13-1]
    mov       [%rip+mlib.maxalloccode],	%rax
    jmp       L474
L475:
    inc       %r13
    cmp       %r13,	%r12
    jle       L472
L474:
    mov       %al,	1
    mov       [%rip+mlib.pcm_setup],	%al
L458:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.pcm_getac
mlib.pcm_getac:
#?>>
#?]]
#---------------
    cmp       %rcx,	2048
    jg        L479
    lea       %rax,	[%rip+mlib.sizeindextable]
    mov       %r10,	%rcx
    movzx     %rax,	byte ptr[%rax + %r10]
    jmp       L477
L479:
    lea       %rax,	[%rcx+255]
    sar       %rax,	8
    mov       %rcx,	%rax
    cmp       %rcx,	2048
    jg        L481
    lea       %rax,	[%rip+mlib.sizeindextable]
    mov       %r10,	%rcx
    movzx     %rax,	byte ptr[%rax + %r10]
    add       %rax,	8
    jmp       L477
L481:
    lea       %rax,	[%rcx+63]
    sar       %rax,	6
    mov       %rcx,	%rax
    cmp       %rcx,	2048
    jg        L483
    lea       %rax,	[%rip+mlib.sizeindextable]
    mov       %r10,	%rcx
    movzx     %rax,	byte ptr[%rax + %r10]
    add       %rax,	14
    jmp       L477
L483:
    lea       %rax,	[%rcx-2048]
    add       %rax,	2047
    sar       %rax,	11
    add       %rax,	22
    mov       %rcx,	%rax
    mov       %rax,	%rcx
L477:
#---------------
    ret       
# End 
# Proc mlib.pcm_newblock
mlib.pcm_newblock:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rax,	2097152
    add       [%rip+mlib.pcm_newblock.totalheapsize],	%rax
    xor       %eax,	%eax
    mov       [%rip+mlib.alloccode],	%rax
    mov       %rcx,	2097152
    call      mlib.allocmem
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L486
    lea       %rcx,	[%rip+L8066]
    call      mlib.abortprogram
L486:
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    mov       %r8,	2097152
    call      memset
    mov       [%rip+mlib.pcheapptr],	%rdi
    lea       %rax,	[%rdi+2097152]
    mov       [%rip+mlib.pcheapend],	%rax
    mov       %rax,	[%rip+mlib.pcheapstart]
    test      %rax,	%rax
    jnz       L488
    mov       [%rip+mlib.pcheapstart],	%rdi
L488:
    mov       %rax,	%rbx
    add       [%rip+mlib.pcheapptr],	%rax
    mov       %rax,	%rdi
L484:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.pcm_round
mlib.pcm_round:
#?>>
#?]]
#---------------
    cmp       %rcx,	2048
    jle       L491
    mov       %rax,	%rcx
    jmp       L490
L491:
    lea       %rax,	[%rip+mlib.sizeindextable]
    mov       %r10,	%rcx
    movzx     %rax,	byte ptr[%rax + %r10]
    lea       %r10,	[%rip+mlib.pcm_round.allocbytes]
    movsxd    %r10,	dword ptr[%r10 + %rax*4]
    mov       %rax,	%r10
L490:
L489:
#---------------
    ret       
# End 
# Proc mlib.pcm_allocz
mlib.pcm_allocz:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rcx,	%rbx
    call      mlib.pcm_alloc
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    mov       %r8,	%rbx
    call      memset
    mov       %rax,	%rdi
L492:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.pcm_copyheapstring
mlib.pcm_copyheapstring:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    test      %rsi,	%rsi
    jnz       L495
    xor       %eax,	%eax
    jmp       L493
L495:
    mov       %rcx,	%rsi
    call      strlen
    inc       %rax
    mov       %rbx,	%rax
    mov       %rcx,	%rbx
    call      mlib.pcm_alloc
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	%rsi
    mov       %r8,	%rbx
    call      memcpy
    mov       %rax,	%rdi
L493:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.pcm_copyheapstringn
mlib.pcm_copyheapstringn:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    test      %rbx,	%rbx
    jnz       L498
    xor       %eax,	%eax
    jmp       L496
L498:
    lea       %rax,	[%rsi+1]
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      memcpy
    xor       %eax,	%eax
    mov       [%rdi + %rsi],	%al
    mov       %rax,	%rdi
L496:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.pcm_copyheapblock
mlib.pcm_copyheapblock:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    test      %rsi,	%rsi
    jnz       L501
    xor       %eax,	%eax
    jmp       L499
L501:
    mov       %rcx,	%rsi
    call      mlib.pcm_alloc
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      memcpy
    mov       %rax,	%rdi
L499:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.allocmem
mlib.allocmem:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rcx,	%rbx
    call      malloc
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L504
    mov       %rax,	%rdi
    jmp       L502
L504:
    call      msys.m$print_startcon
    mov       %rcx,	%rbx
    call      msys.m$print_i64_nf
    mov       %rcx,	[%rip+mlib.memtotal]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8067]
    call      mlib.abortprogram
    xor       %eax,	%eax
L502:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.reallocmem
mlib.reallocmem:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      realloc
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L507
    mov       %rax,	%rdi
    jmp       L505
L507:
    call      msys.m$print_startcon
    mov       %rcx,	%rbx
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8068]
    call      mlib.abortprogram
    xor       %eax,	%eax
L505:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.abortprogram
mlib.abortprogram:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    call      msys.m$print_startcon
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8069]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       %rcx,	5
    call      exit
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mlib.getfilesize
mlib.getfilesize:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    mov       %rcx,	%rsi
    call      ftell
    mov       %edi,	%eax
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    mov       %r8,	2
    call      fseek
    mov       %rcx,	%rsi
    call      ftell
    mov       %ebx,	%eax
    mov       %eax,	%edi
    mov       %rcx,	%rsi
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      fseek
    mov       %eax,	%ebx
L509:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.readrandom
mlib.readrandom:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
    mov       %r13,	%r9
#---------------
    mov       %rcx,	%rbx
    mov       %rdx,	%r12
    xor       %r8d,	%r8d
    call      fseek
    mov       %rcx,	%rsi
    mov       %rdx,	1
    mov       %r8,	%r13
    mov       %r9,	%rbx
    call      fread
    mov       %rdi,	%rax
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.writerandom
mlib.writerandom:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
    mov       %r12,	%r9
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rsi
    xor       %r8d,	%r8d
    call      fseek
    mov       %rcx,	%rbx
    mov       %rdx,	1
    mov       %r8,	%r12
    mov       %r9,	%rdi
    call      fwrite
L511:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.setfilepos
mlib.setfilepos:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      fseek
    movsxd    %r10,	%eax
    mov       %rax,	%r10
L512:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.getfilepos
mlib.getfilepos:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      ftell
    movsxd    %r10,	%eax
    mov       %rax,	%r10
L513:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mlib.readfile
mlib.readfile:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
#---------------
    mov       %rcx,	%r13
    lea       %rdx,	[%rip+L8070]
    call      fopen
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L516
    xor       %eax,	%eax
    jmp       L514
L516:
    mov       %rcx,	%rdi
    call      mlib.getfilesize
    mov       %rbx,	%rax
    mov       [%rip+mlib.rfsize],	%rax
    lea       %rax,	[%rbx+2]
    mov       %rcx,	%rax
    call      malloc
    mov       %rsi,	%rax
    test      %rsi,	%rsi
    jnz       L518
    xor       %eax,	%eax
    jmp       L514
L518:
    mov       %rcx,	%rdi
    mov       %rdx,	%rsi
    xor       %r8d,	%r8d
    mov       %r9,	%rbx
    call      mlib.readrandom
    lea       %rax,	[%rsi + %rbx]
    mov       %r12,	%rax
    xor       %eax,	%eax
    mov       [%r12],	%ax
    mov       %rcx,	%rdi
    call      fclose
    mov       %rax,	%rsi
L514:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.writefile
mlib.writefile:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
    mov       %rcx,	%rsi
    lea       %rdx,	[%rip+L8071]
    call      fopen
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L521
    xor       %eax,	%eax
    jmp       L519
L521:
    mov       %rcx,	%rdi
    mov       %rdx,	%r12
    xor       %r8d,	%r8d
    mov       %r9,	%r13
    call      mlib.writerandom
    mov       %rbx,	%rax
    mov       %rcx,	%rdi
    call      fclose
    mov       %rax,	%rbx
L519:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.checkfile
mlib.checkfile:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rcx,	%rbx
    lea       %rdx,	[%rip+L8072]
    call      fopen
    mov       %rdi,	%rax
    test      %rax,	%rax
    jz        L524
    mov       %rcx,	%rdi
    call      fclose
    mov       %rax,	1
    jmp       L522
L524:
    xor       %eax,	%eax
L522:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.readlinen
mlib.readlinen:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       %r15,	%r8
#---------------
    test      %r13,	%r13
    jnz       L527
    call      mnoos.os_getstdin
    mov       %r13,	%rax
L527:
    test      %r13,	%r13
    jnz       L529
    xor       %rsi,	%rsi
    mov       %rax,	%r14
    mov       %rbx,	%rax
L530:
    call      getchar
    movsxd    %r10,	%eax
    mov       %rdi,	%r10
    cmp       %rdi,	13
    jz        L534
    cmp       %rdi,	10
    jz        L534
    cmp       %rdi,	-1
    jnz       L533
L534:
    xor       %eax,	%eax
    mov       [%rbx],	%al
    jmp       L525
L533:
    mov       %rax,	%rbx
    inc       %rbx
    mov       %r10b,	%dil
    mov       [%rax],	%r10b
    inc       %rsi
    lea       %rax,	[%r15-2]
    mov       %r10,	%rsi
    cmp       %r10,	%rax
    jl        L536
    xor       %eax,	%eax
    mov       [%rbx],	%al
    jmp       L525
L536:
    jmp       L530
L529:
    xor       %eax,	%eax
    mov       [%r14],	%al
    lea       %rax,	[%r15-2]
    mov       %rcx,	%r14
    mov       %rdx,	%rax
    mov       %r8,	%r13
    call      fgets
    test      %rax,	%rax
    jz        L525
L538:
    mov       %rcx,	%r14
    call      strlen
    mov       %rsi,	%rax
    test      %rsi,	%rsi
    jnz       L540
    jmp       L525
L540:
    lea       %rax,	[%r14 + %rsi]
    sub       %rax,	1
    mov       %rbx,	%rax
    xor       %r12b,	%r12b
    jmp       L542
L541:
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	13
    jz        L546
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	10
    jnz       L545
L546:
    mov       %r12b,	1
L545:
    mov       %rax,	%rbx
    dec       %rbx
    xor       %r10d,	%r10d
    mov       [%rax],	%r10b
L542:
    cmp       %rbx,	%r14
    jb        L547
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	13
    jz        L541
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	10
    jz        L541
L547:
    test      %r12b,	%r12b
    jnz       L549
    lea       %rax,	[%rsi+4]
    cmp       %rax,	%r15
    jle       L549
    call      msys.m$print_startcon
    mov       %rcx,	%r15
    call      msys.m$print_i64_nf
    mov       %rcx,	%rsi
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8073]
    call      mlib.abortprogram
L549:
L525:
#---------------
    add       %rsp,	48
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.iconvlcn
mlib.iconvlcn:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rdi,	%rsi
    cmp       %rdi,	0
    jle       L553
L551:
    movzx     %rax,	byte ptr[%rbx]
    mov       %rcx,	%rax
    call      tolower
    mov       [%rbx],	%al
    inc       %rbx
    dec       %rdi
    jnz       L551
L553:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.iconvucn
mlib.iconvucn:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rdi,	%rsi
    cmp       %rdi,	0
    jle       L557
L555:
    movzx     %rax,	byte ptr[%rbx]
    mov       %rcx,	%rax
    call      toupper
    mov       [%rbx],	%al
    inc       %rbx
    dec       %rdi
    jnz       L555
L557:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.convlcstring
mlib.convlcstring:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rdi,	%rbx
    jmp       L560
L559:
    movzx     %rax,	byte ptr[%rbx]
    mov       %rcx,	%rax
    call      tolower
    mov       [%rbx],	%al
    inc       %rbx
L560:
    mov       %al,	[%rbx]
    test      %al,	%al
    jnz       L559
    mov       %rax,	%rdi
L558:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.convucstring
mlib.convucstring:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rdi,	%rbx
    jmp       L564
L563:
    movzx     %rax,	byte ptr[%rbx]
    mov       %rcx,	%rax
    call      toupper
    mov       [%rbx],	%al
    inc       %rbx
L564:
    mov       %al,	[%rbx]
    test      %al,	%al
    jnz       L563
    mov       %rax,	%rdi
L562:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.changeext
mlib.changeext:
#?>>
    .set mlib.changeext.newext2, -32
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	64
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    lea       %rax,	[%rip+mlib.changeext.newfile]
    mov       %rcx,	%rax
    mov       %rdx,	%rsi
    call      strcpy
    movzx     %rax,	byte ptr[%r12]
    test      %rax,	%rax
    jz        L568
    cmp       %rax,	46
    jz        L569
    jmp       L570
L568:
    xor       %eax,	%eax
    mov       [%rbp + mlib.changeext.newext2],	%al
    xor       %eax,	%eax
    mov       [%rbp + mlib.changeext.newext2+1],	%al
    jmp       L567
L569:
    lea       %rax,	[%rbp + mlib.changeext.newext2]
    mov       %rcx,	%rax
    mov       %rdx,	%r12
    call      strcpy
    jmp       L567
L570:
    lea       %rax,	[%rbp + mlib.changeext.newext2]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8074]
    call      strcpy
    lea       %rax,	[%rbp + mlib.changeext.newext2]
    mov       %rcx,	%rax
    mov       %rdx,	%r12
    call      strcat
L567:
    mov       %rcx,	%rsi
    mov       %rdx,	1
    call      mlib.extractext
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rdi]
    test      %rax,	%rax
    jz        L572
    cmp       %rax,	46
    jz        L573
    jmp       L574
L572:
    lea       %rax,	[%rbp + mlib.changeext.newext2]
    lea       %r10,	[%rip+mlib.changeext.newfile]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      strcat
    jmp       L571
L573:
    lea       %rax,	[%rbp + mlib.changeext.newext2+1]
    lea       %r10,	[%rip+mlib.changeext.newfile]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      strcat
    jmp       L571
L574:
    mov       %rax,	%rdi
    sub       %rax,	%rsi
    sub       %rax,	2
    mov       %rbx,	%rax
    lea       %rax,	[%rbp + mlib.changeext.newext2]
    lea       %r10,	[%rip+mlib.changeext.newfile]
    mov       %r11,	%rbx
    lea       %r10,	[%r10 + %r11+1]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      strcpy
L571:
    lea       %rax,	[%rip+mlib.changeext.newfile]
L566:
#---------------
    add       %rsp,	64
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.extractext
mlib.extractext:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    mov       %rcx,	%rsi
    call      mlib.extractfile
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rdi]
    test      %rax,	%rax
    jnz       L577
    lea       %rax,	[%rip+L8075]
    jmp       L575
L577:
    mov       %rcx,	%rdi
    call      strlen
    lea       %r10,	[%rdi + %rax]
    sub       %r10,	1
    mov       %rbx,	%r10
    jmp       L579
L578:
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	46
    jnz       L582
    movzx     %rax,	byte ptr[%rbx+1]
    test      %rax,	%rax
    jnz       L584
    test      %r12,	%r12
    jz        L586
    lea       %rax,	[%rip+L8076]
    jmp       L585
L586:
    lea       %rax,	[%rip+L8077]
L585:
    jmp       L575
L584:
    lea       %rax,	[%rbx+1]
    jmp       L575
L582:
    dec       %rbx
L579:
    cmp       %rbx,	%rdi
    jae       L578
    lea       %rax,	[%rip+L8077]
L575:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.extractpath
mlib.extractpath:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    mov       %rcx,	%rsi
    call      strlen
    lea       %r10,	[%rsi + %rax]
    sub       %r10,	1
    mov       %rdi,	%r10
    jmp       L589
L588:
    movzx     %rax,	byte ptr[%rdi]
    cmp       %rax,	92
    jz        L592
    cmp       %rax,	47
    jz        L592
    cmp       %rax,	58
    jnz       L593
L592:
    mov       %rax,	%rdi
    sub       %rax,	%rsi
    inc       %rax
    mov       %rbx,	%rax
    lea       %rcx,	[%rip+mlib.extractpath.str]
    mov       %rdx,	%rsi
    mov       %r8,	%rbx
    call      memcpy
    xor       %eax,	%eax
    lea       %r10,	[%rip+mlib.extractpath.str]
    mov       %r11,	%rbx
    mov       [%r10 + %r11],	%al
    lea       %rax,	[%rip+mlib.extractpath.str]
    jmp       L587
L593:
L591:
    dec       %rdi
L589:
    cmp       %rdi,	%rsi
    jae       L588
    lea       %rax,	[%rip+L8077]
L587:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.extractfile
mlib.extractfile:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rcx,	%rbx
    call      mlib.extractpath
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rdi]
    test      %rax,	%rax
    jnz       L596
    mov       %rax,	%rbx
    jmp       L594
L596:
    mov       %rcx,	%rdi
    call      strlen
    lea       %r10,	[%rbx + %rax]
    mov       %rax,	%r10
L594:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.extractbasefile
mlib.extractbasefile:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
#---------------
    mov       %rcx,	%r13
    call      mlib.extractfile
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    call      strlen
    mov       %r12,	%rax
    test      %r12,	%r12
    jnz       L599
    lea       %rax,	[%rip+L8077]
    jmp       L597
L599:
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      mlib.extractext
    mov       %rbx,	%rax
    mov       %al,	[%rbx]
    test      %al,	%al
    jz        L601
    mov       %rcx,	%rbx
    call      strlen
    mov       %r10,	%r12
    sub       %r10,	%rax
    dec       %r10
    mov       %rsi,	%r10
    lea       %rcx,	[%rip+mlib.extractbasefile.str]
    mov       %rdx,	%rdi
    mov       %r8,	%rsi
    call      memcpy
    xor       %eax,	%eax
    lea       %r10,	[%rip+mlib.extractbasefile.str]
    mov       %r11,	%rsi
    mov       [%r10 + %r11],	%al
    lea       %rax,	[%rip+mlib.extractbasefile.str]
    jmp       L597
L601:
    lea       %rax,	[%rdi + %r12]
    sub       %rax,	1
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	46
    jnz       L603
    lea       %rax,	[%r12-1]
    lea       %rcx,	[%rip+mlib.extractbasefile.str]
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      memcpy
    xor       %eax,	%eax
    lea       %r10,	[%rip+mlib.extractbasefile.str]
    mov       %r11,	%r12
    mov       [%r10 + %r11-1],	%al
    lea       %rax,	[%rip+mlib.extractbasefile.str]
    jmp       L597
L603:
    mov       %rax,	%rdi
L597:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.addext
mlib.addext:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      mlib.extractext
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rdi]
    test      %rax,	%rax
    jnz       L606
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      mlib.changeext
    jmp       L604
L606:
    mov       %rax,	%rbx
L604:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.pcm_alloc32
mlib.pcm_alloc32:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rax,	32
    mov       [%rip+mlib.allocbytes],	%rax
    lea       %rax,	[%rip+mlib.freelist]
    mov       %rax,	[%rax+16]
    mov       %rdi,	%rax
    test      %rax,	%rax
    jz        L609
    lea       %rax,	[%rip+mlib.freelist]
    mov       %rax,	[%rax+16]
    mov       %rax,	[%rax]
    lea       %r10,	[%rip+mlib.freelist]
    mov       [%r10+16],	%rax
    mov       %rax,	%rdi
    jmp       L607
L609:
    mov       %rcx,	32
    call      mlib.pcm_alloc
L607:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mlib.pcm_free32
mlib.pcm_free32:
#?>>
#?]]
#---------------
    lea       %rax,	[%rip+mlib.freelist]
    mov       %rax,	[%rax+16]
    mov       [%rcx],	%rax
    mov       %rax,	%rcx
    lea       %r10,	[%rip+mlib.freelist]
    mov       [%r10+16],	%rax
#---------------
    ret       
# End 
# Proc mlib.outbyte
mlib.outbyte:
#?>>
    .set mlib.outbyte.x, 32
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       [%rbp+32],	%rdx
#---------------
    lea       %rcx,	[%rbp + mlib.outbyte.x]
    mov       %rdx,	1
    mov       %r8,	1
    mov       %r9,	%rdi
    call      fwrite
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc mlib.outu16
mlib.outu16:
#?>>
    .set mlib.outu16.x, 32
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       [%rbp+32],	%rdx
#---------------
    lea       %rcx,	[%rbp + mlib.outu16.x]
    mov       %rdx,	2
    mov       %r8,	1
    mov       %r9,	%rdi
    call      fwrite
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc mlib.outu32
mlib.outu32:
#?>>
    .set mlib.outu32.x, 32
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       [%rbp+32],	%rdx
#---------------
    lea       %rcx,	[%rbp + mlib.outu32.x]
    mov       %rdx,	4
    mov       %r8,	1
    mov       %r9,	%rdi
    call      fwrite
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc mlib.outu64
mlib.outu64:
#?>>
    .set mlib.outu64.x, 32
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       [%rbp+32],	%rdx
#---------------
    lea       %rcx,	[%rbp + mlib.outu64.x]
    mov       %rdx,	8
    mov       %r8,	1
    mov       %r9,	%rdi
    call      fwrite
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc mlib.outstring
mlib.outstring:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rbx
    call      strlen
    inc       %rax
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    mov       %r8,	1
    mov       %r9,	%rdi
    call      fwrite
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.outblock
mlib.outblock:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	1
    mov       %r9,	%rdi
    call      fwrite
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.myeof
mlib.myeof:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rcx,	%rbx
    call      fgetc
    movsxd    %r10,	%eax
    mov       %rdi,	%r10
    cmp       %rdi,	-1
    jnz       L619
    mov       %rax,	1
    jmp       L617
L619:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      ungetc
    xor       %eax,	%eax
L617:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.strbuffer_add
mlib.strbuffer_add:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
#---------------
    cmp       %r14,	-1
    jnz       L622
    mov       %rcx,	%r13
    call      strlen
    mov       %r14,	%rax
L622:
    movsxd    %rax,	dword ptr[%r12+8]
    mov       %rbx,	%rax
    test      %rbx,	%rbx
    jnz       L624
    lea       %rax,	[%r14+1]
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       [%r12],	%rax
    mov       %eax,	[%rip+mlib.allocbytes]
    mov       [%r12+12],	%eax
    mov       [%r12+8],	%r14d
    mov       %rax,	[%r12]
    mov       %rcx,	%rax
    mov       %rdx,	%r13
    mov       %r8,	%r14
    call      memcpy
    mov       %rax,	[%r12]
    xor       %r10d,	%r10d
    mov       %r11,	%r14
    mov       [%rax + %r11],	%r10b
    jmp       L620
L624:
    mov       %rax,	%rbx
    add       %rax,	%r14
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+1]
    movsxd    %r10,	dword ptr[%r12+12]
    cmp       %rax,	%r10
    jle       L626
    lea       %rax,	[%rdi+1]
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       %rsi,	%rax
    mov       %rax,	[%r12]
    mov       %rcx,	%rsi
    mov       %rdx,	%rax
    mov       %r8,	%rbx
    call      memcpy
    mov       [%r12],	%rsi
    mov       %eax,	[%rip+mlib.allocbytes]
    mov       [%r12+12],	%eax
L626:
    mov       %rax,	[%r12]
    mov       %r10,	%rbx
    lea       %rax,	[%rax + %r10]
    mov       %rcx,	%rax
    mov       %rdx,	%r13
    mov       %r8,	%r14
    call      memcpy
    mov       %rax,	[%r12]
    xor       %r10d,	%r10d
    mov       %r11,	%rdi
    mov       [%rax + %r11],	%r10b
    mov       [%r12+8],	%edi
L620:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.gs_init
mlib.gs_init:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	16
    call      mlib.pcm_clearmem
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mlib.gs_free
mlib.gs_free:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %eax,	[%rdi+12]
    test      %eax,	%eax
    jz        L630
    movsxd    %rax,	dword ptr[%rdi+12]
    mov       %r10,	[%rdi]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mlib.pcm_free
L630:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mlib.gs_str
mlib.gs_str:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	-1
    call      mlib.strbuffer_add
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.gs_char
mlib.gs_char:
#?>>
    .set mlib.gs_char.s, -16
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       [%rbp + mlib.gs_char.s],	%bl
    xor       %eax,	%eax
    mov       [%rbp + mlib.gs_char.s+1],	%al
    mov       %rcx,	%rdi
    lea       %rdx,	[%rbp + mlib.gs_char.s]
    mov       %r8,	1
    call      mlib.strbuffer_add
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.gs_strn
mlib.gs_strn:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      mlib.strbuffer_add
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.gs_strvar
mlib.gs_strvar:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rax,	[%rbx]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    mov       %r8,	-1
    call      mlib.strbuffer_add
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.gs_strint
mlib.gs_strint:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      msys.strint
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    mov       %r8,	-1
    call      mlib.strbuffer_add
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.gs_strln
mlib.gs_strln:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mlib.gs_str
    mov       %rcx,	%rdi
    call      mlib.gs_line
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.gs_strsp
mlib.gs_strsp:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mlib.gs_str
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8078]
    call      mlib.gs_str
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.gs_line
mlib.gs_line:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8079]
    mov       %r8,	-1
    call      mlib.strbuffer_add
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mlib.gs_getcol
mlib.gs_getcol:
#?>>
#?]]
#---------------
    movsxd    %rax,	dword ptr[%rcx+8]
L639:
#---------------
    ret       
# End 
# Proc mlib.gs_leftstr
mlib.gs_leftstr:
#?>>
    .set mlib.gs_leftstr.w, 80
    .set mlib.gs_leftstr.padch, 88
    .set mlib.gs_leftstr.str, -2560
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	2592
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       [%rbp+80],	%r8
    mov       [%rbp+88],	%r9
#---------------
    movsxd    %rax,	dword ptr[%r13+8]
    mov       %rdi,	%rax
    lea       %rcx,	[%rbp + mlib.gs_leftstr.str]
    mov       %rdx,	%r14
    call      strcpy
    mov       %rcx,	%r14
    call      strlen
    mov       %r12,	%rax
    mov       %rax,	[%rbp + mlib.gs_leftstr.w]
    sub       %rax,	%r12
    mov       %rsi,	%rax
    cmp       %rsi,	0
    jle       L642
    mov       %rbx,	1
    cmp       %rsi,	1
    jl        L645
L643:
    mov       %rax,	%r12
    add       %rax,	%rbx
    mov       %r10b,	[%rbp + mlib.gs_leftstr.padch]
    mov       [%rbp + %rax + mlib.gs_leftstr.str-1],	%r10b
    inc       %rbx
    cmp       %rbx,	%rsi
    jle       L643
L645:
    mov       %rax,	%r12
    add       %rax,	%rsi
    xor       %r10d,	%r10d
    mov       [%rbp + %rax + mlib.gs_leftstr.str],	%r10b
L642:
    mov       %rcx,	%r13
    lea       %rdx,	[%rbp + mlib.gs_leftstr.str]
    call      mlib.gs_str
#---------------
    add       %rsp,	2592
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.gs_leftint
mlib.gs_leftint:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
    mov       %r12,	%r9
#---------------
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      msys.strint
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    mov       %r8,	%rsi
    mov       %r9,	%r12
    call      mlib.gs_leftstr
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.gs_padto
mlib.gs_padto:
#?>>
    .set mlib.gs_padto.str, -2560
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	2600
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
    movsxd    %rax,	dword ptr[%rsi+8]
    mov       %r10,	%r12
    sub       %r10,	%rax
    mov       %rdi,	%r10
    cmp       %rdi,	0
    jle       L647
L649:
    mov       %rbx,	1
    cmp       %rdi,	1
    jl        L652
L650:
    mov       [%rbp + %rbx + mlib.gs_padto.str-1],	%r13b
    inc       %rbx
    cmp       %rbx,	%rdi
    jle       L650
L652:
    xor       %eax,	%eax
    mov       [%rbp + %rdi + mlib.gs_padto.str],	%al
    mov       %rcx,	%rsi
    lea       %rdx,	[%rbp + mlib.gs_padto.str]
    call      mlib.gs_str
L647:
#---------------
    add       %rsp,	2600
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.gs_println
mlib.gs_println:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    movsxd    %rax,	dword ptr[%rdi+8]
    test      %rax,	%rax
    jz        L653
L655:
    mov       %rax,	[%rdi]
    movsxd    %r10,	dword ptr[%rdi+8]
    xor       %r11d,	%r11d
    mov       [%rax + %r10],	%r11b
    test      %rbx,	%rbx
    jnz       L657
    call      msys.m$print_startcon
    mov       %rcx,	[%rdi]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L656
L657:
    mov       %rcx,	%rbx
    call      msys.m$print_startfile
    mov       %rcx,	[%rdi]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L656:
L653:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.nextcmdparamnew
mlib.nextcmdparamnew:
#?>>
    .set mlib.nextcmdparamnew.defext, 88
    .set mlib.nextcmdparamnew.item, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
    mov       [%rbp+88],	%r9
#---------------
#mlib.nextcmdparamnew.reenter:
L659:
    xor       %eax,	%eax
    mov       [%r14],	%rax
    xor       %eax,	%eax
    mov       [%r13],	%rax
    mov       %rax,	[%rip+mlib.nextcmdparamnew.infile]
    test      %rax,	%rax
    jz        L661
    lea       %rcx,	[%rip+mlib.nextcmdparamnew.fileptr]
    lea       %rdx,	[%rbp + mlib.nextcmdparamnew.item]
    call      mlib.readnextfileitem
    test      %rax,	%rax
    jnz       L663
    mov       %rcx,	[%rip+mlib.nextcmdparamnew.filestart]
    call      free
    xor       %eax,	%eax
    mov       [%rip+mlib.nextcmdparamnew.infile],	%rax
    jmp       L659
L663:
    jmp       L660
L661:
    mov       %rax,	[%r12]
    cmp       %rax,	[%rip+msys.ncmdparams]
    jle       L665
    xor       %eax,	%eax
    jmp       L658
L665:
    mov       %rax,	[%r12]
    mov       %r10,	[%rip+msys.cmdparams]
    mov       %r10,	[%r10 + %rax*8]
    mov       [%rbp + mlib.nextcmdparamnew.item],	%r10
    mov       %rax,	%r12
    inc       qword ptr[%rax]
    mov       %rcx,	[%rbp + mlib.nextcmdparamnew.item]
    call      strlen
    mov       %rsi,	%rax
    mov       %rax,	[%rbp + mlib.nextcmdparamnew.item]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	64
    jnz       L667
    mov       %rax,	[%rbp + mlib.nextcmdparamnew.item]
    lea       %rax,	[%rax+1]
    mov       %rcx,	%rax
    call      mlib.readfile
    mov       [%rip+mlib.nextcmdparamnew.fileptr],	%rax
    mov       [%rip+mlib.nextcmdparamnew.filestart],	%rax
    mov       %rax,	[%rip+mlib.nextcmdparamnew.filestart]
    test      %rax,	%rax
    jnz       L669
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8080]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rbp + mlib.nextcmdparamnew.item]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	7
    call      exit
L669:
    mov       %rax,	1
    mov       [%rip+mlib.nextcmdparamnew.infile],	%rax
    jmp       L659
L667:
    mov       %rax,	[%rbp + mlib.nextcmdparamnew.item]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	58
    jnz       L671
    mov       %al,	1
    mov       [%rip+mlib.nextcmdparamnew.colonseen],	%al
    mov       %rax,	4
    jmp       L658
L671:
L660:
    xor       %eax,	%eax
    mov       [%r14],	%rax
    mov       %rax,	[%rbp + mlib.nextcmdparamnew.item]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	45
    jnz       L673
    mov       %al,	[%rip+mlib.nextcmdparamnew.colonseen]
    test      %al,	%al
    jz        L675
    xor       %eax,	%eax
    jmp       L674
L675:
    mov       %rax,	1
L674:
    mov       %r10,	[%rbp + mlib.nextcmdparamnew.item]
    lea       %r10,	[%r10 + %rax]
    mov       [%r13],	%r10
    mov       %rcx,	[%rbp + mlib.nextcmdparamnew.item]
    mov       %rdx,	58
    call      strchr
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L677
    mov       %rcx,	[%rbp + mlib.nextcmdparamnew.item]
    mov       %rdx,	61
    call      strchr
    mov       %rdi,	%rax
L677:
    test      %rdi,	%rdi
    jz        L679
    lea       %rax,	[%rdi+1]
    mov       [%r14],	%rax
    xor       %eax,	%eax
    mov       [%rdi],	%al
L679:
    mov       %al,	[%rip+mlib.nextcmdparamnew.colonseen]
    test      %al,	%al
    jz        L681
    mov       %rax,	5
    jmp       L680
L681:
    mov       %rax,	1
L680:
    jmp       L658
L673:
    mov       %rcx,	[%rbp + mlib.nextcmdparamnew.item]
    xor       %edx,	%edx
    call      mlib.extractext
    mov       %rbx,	%rax
    mov       %rax,	[%rbp + mlib.nextcmdparamnew.item]
    mov       [%r13],	%rax
    movzx     %rax,	byte ptr[%rbx]
    test      %rax,	%rax
    jnz       L683
    mov       %rax,	[%r13]
    lea       %rcx,	[%rip+mlib.nextcmdparamnew.str]
    mov       %rdx,	%rax
    call      strcpy
    mov       %rax,	[%rbp + mlib.nextcmdparamnew.defext]
    test      %rax,	%rax
    jz        L685
    mov       %al,	[%rip+mlib.nextcmdparamnew.colonseen]
    test      %al,	%al
    jnz       L685
    lea       %rcx,	[%rip+mlib.nextcmdparamnew.str]
    mov       %rdx,	[%rbp + mlib.nextcmdparamnew.defext]
    call      mlib.addext
    mov       [%r13],	%rax
L685:
    jmp       L682
L683:
    mov       %rcx,	%rbx
    lea       %rdx,	[%rip+L8081]
    call      mlib.eqstring
    test      %rax,	%rax
    jnz       L687
    mov       %rcx,	%rbx
    lea       %rdx,	[%rip+L8082]
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L686
L687:
    mov       %al,	[%rip+mlib.nextcmdparamnew.colonseen]
    test      %al,	%al
    jz        L689
    mov       %rax,	5
    jmp       L688
L689:
    mov       %rax,	3
L688:
    jmp       L658
L686:
L682:
    mov       %al,	[%rip+mlib.nextcmdparamnew.colonseen]
    test      %al,	%al
    jz        L691
    mov       %rax,	5
    jmp       L690
L691:
    mov       %rax,	2
L690:
L658:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.readnextfileitem
mlib.readnextfileitem:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r13,	%rcx
    mov       %r14,	%rdx
#---------------
    mov       %rdi,	[%r13]
#mlib.readnextfileitem.reenter:
L693:
L694:
    movzx     %rax,	byte ptr[%rdi]
    cmp       %rax,	32
    jz        L697
    cmp       %rax,	9
    jz        L697
    cmp       %rax,	13
    jz        L697
    cmp       %rax,	10
    jz        L697
    cmp       %rax,	26
    jz        L698
    test      %rax,	%rax
    jz        L698
    jmp       L699
L697:
    inc       %rdi
    jmp       L696
L698:
    xor       %eax,	%eax
    jmp       L692
L699:
    jmp       L695
L696:
    jmp       L694
L695:
    movzx     %rax,	byte ptr[%rdi]
    cmp       %rax,	33
    jz        L701
    cmp       %rax,	35
    jnz       L702
L701:
    inc       %rdi
L703:
    mov       %rax,	%rdi
    inc       %rdi
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	10
    jz        L705
    cmp       %rax,	26
    jz        L706
    test      %rax,	%rax
    jz        L706
    jmp       L707
L705:
    jmp       L693
L706:
    lea       %rax,	[%rdi-1]
    mov       [%r13],	%rax
    xor       %eax,	%eax
    jmp       L692
L707:
    jmp       L703
L702:
L700:
    movzx     %rax,	byte ptr[%rdi]
    cmp       %rax,	34
    jnz       L710
L709:
    inc       %rdi
    mov       %rbx,	%rdi
L711:
    movzx     %rax,	byte ptr[%rdi]
    test      %rax,	%rax
    jz        L714
    cmp       %rax,	26
    jz        L714
    cmp       %rax,	34
    jz        L715
    jmp       L716
L714:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8083]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	8
    call      exit
    jmp       L713
L715:
    mov       %rax,	%rdi
    inc       %rdi
    mov       %rsi,	%rax
    movzx     %rax,	byte ptr[%rdi]
    cmp       %rax,	44
    jnz       L718
    inc       %rdi
L718:
    jmp       L712
L716:
L713:
    inc       %rdi
    jmp       L711
L712:
    jmp       L708
L710:
    mov       %rbx,	%rdi
L719:
    movzx     %rax,	byte ptr[%rdi]
    test      %rax,	%rax
    jz        L722
    cmp       %rax,	26
    jz        L722
    cmp       %rax,	32
    jz        L723
    cmp       %rax,	9
    jz        L723
    cmp       %rax,	44
    jz        L723
    cmp       %rax,	13
    jz        L723
    cmp       %rax,	10
    jz        L723
    jmp       L724
L722:
    mov       %rsi,	%rdi
    jmp       L720
L723:
    mov       %rax,	%rdi
    inc       %rdi
    mov       %rsi,	%rax
    jmp       L720
L724:
L721:
    inc       %rdi
    jmp       L719
L720:
L708:
    mov       %rax,	%rsi
    sub       %rax,	%rbx
    mov       %r12,	%rax
    cmp       %r12,	256
    jl        L726
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8084]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	9
    call      exit
L726:
    lea       %rcx,	[%rip+mlib.readnextfileitem.str]
    mov       %rdx,	%rbx
    mov       %r8,	%r12
    call      memcpy
    xor       %eax,	%eax
    lea       %r10,	[%rip+mlib.readnextfileitem.str]
    mov       %r11,	%r12
    mov       [%r10 + %r11],	%al
    lea       %rax,	[%rip+mlib.readnextfileitem.str]
    mov       [%r14],	%rax
    mov       [%r13],	%rdi
    mov       %rax,	1
L692:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.ipadstr
mlib.ipadstr:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
    mov       %rcx,	%rsi
    call      strlen
    mov       %rdi,	%rax
    mov       %rax,	%r12
    sub       %rax,	%rdi
    mov       %rbx,	%rax
    cmp       %rbx,	0
    jle       L730
L728:
    mov       %rcx,	%rsi
    mov       %rdx,	%r13
    call      strcat
    dec       %rbx
    jnz       L728
L730:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.padstr
mlib.padstr:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    lea       %rcx,	[%rip+mlib.padstr.str]
    mov       %rdx,	%rdi
    call      strcpy
    lea       %rcx,	[%rip+mlib.padstr.str]
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      mlib.ipadstr
    lea       %rax,	[%rip+mlib.padstr.str]
L731:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.chr
mlib.chr:
#?>>
#?]]
#---------------
    mov       %al,	%cl
    lea       %r10,	[%rip+mlib.chr.str]
    mov       [%r10],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+mlib.chr.str]
    mov       [%r10+1],	%al
    lea       %rax,	[%rip+mlib.chr.str]
L732:
#---------------
    ret       
# End 
# Proc mlib.cmpstring
mlib.cmpstring:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      strcmp
    movsxd    %r10,	%eax
    mov       %rdi,	%r10
    cmp       %r10,	0
    jge       L735
    mov       %rax,	-1
    jmp       L734
L735:
    cmp       %rdi,	0
    jle       L736
    mov       %rax,	1
    jmp       L734
L736:
    xor       %eax,	%eax
L734:
L733:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.cmpstringn
mlib.cmpstringn:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      strncmp
    movsxd    %r10,	%eax
    mov       %rdi,	%r10
    cmp       %r10,	0
    jge       L739
    mov       %rax,	-1
    jmp       L738
L739:
    cmp       %rdi,	0
    jle       L740
    mov       %rax,	1
    jmp       L738
L740:
    xor       %eax,	%eax
L738:
L737:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.eqstring
mlib.eqstring:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      strcmp
    movsxd    %r10,	%eax
    cmp       %r10,	0
    setz      %r10b
    movzx     %r10d,	%r10b
    mov       %rax,	%r10
L741:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.cmpbytes
mlib.cmpbytes:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      memcmp
    movsxd    %r10,	%eax
    mov       %rdi,	%r10
    cmp       %r10,	0
    jge       L744
    mov       %rax,	-1
    jmp       L743
L744:
    cmp       %rdi,	0
    jle       L745
    mov       %rax,	1
    jmp       L743
L745:
    xor       %eax,	%eax
L743:
L742:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.eqbytes
mlib.eqbytes:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      memcmp
    movsxd    %r10,	%eax
    cmp       %r10,	0
    setz      %r10b
    movzx     %r10d,	%r10b
    mov       %rax,	%r10
L746:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.mseed
mlib.mseed:
#?>>
#?]]
#---------------
    mov       %rax,	%rcx
    lea       %r10,	[%rip+mlib.seed]
    mov       [%r10],	%rax
    test      %rdx,	%rdx
    jz        L749
    mov       %rax,	%rdx
    lea       %r10,	[%rip+mlib.seed]
    mov       [%r10+8],	%rax
    jmp       L748
L749:
    lea       %rax,	[%rip+mlib.seed]
    lea       %rax,	[%rax+8]
    mov       %r10,	%rcx
    xor       [%rax],	%r10
L748:
#---------------
    ret       
# End 
# Proc mlib.mrandom
mlib.mrandom:
#?>>
    push      %rdi
    push      %rbx
#?]]
#---------------
    lea       %rax,	[%rip+mlib.seed]
    mov       %rdi,	[%rax]
    lea       %rax,	[%rip+mlib.seed]
    mov       %rbx,	[%rax+8]
    mov       %rax,	%rbx
    lea       %r10,	[%rip+mlib.seed]
    mov       [%r10],	%rax
    mov       %rax,	%rdi
    shl       %rax,	23
    xor       %rdi,	%rax
    mov       %rax,	%rdi
    xor       %rax,	%rbx
    mov       %r10,	%rdi
    sar       %r10,	17
    xor       %rax,	%r10
    mov       %r10,	%rbx
    sar       %r10,	26
    xor       %rax,	%r10
    lea       %r10,	[%rip+mlib.seed]
    mov       [%r10+8],	%rax
    lea       %rax,	[%rip+mlib.seed]
    mov       %rax,	[%rax+8]
    add       %rax,	%rbx
L750:
#---------------
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.mrandomp
mlib.mrandomp:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    call      mlib.mrandom
    mov       %r10,	9223372036854775807
    and       %rax,	%r10
L751:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mlib.mrandomint
mlib.mrandomint:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    call      mlib.mrandomp
    mov       %r10,	%rdi
    cqo       
    idiv      %r10
    xchg      %rax,	%rdx
L752:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mlib.mrandomrange
mlib.mrandomrange:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rax,	%rsi
    sub       %rax,	%rbx
    inc       %rax
    mov       %rdi,	%rax
    cmp       %rdi,	0
    jg        L755
    xor       %eax,	%eax
    jmp       L753
L755:
    call      mlib.mrandomp
    mov       %r10,	%rdi
    cqo       
    idiv      %r10
    xchg      %rax,	%rdx
    add       %rax,	%rbx
L753:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.mrandomreal
mlib.mrandomreal:
#?>>
    movq      %rax,	%XMM15
    push      %rax
#?]]
    sub       %rsp,	48
#---------------
L757:
    call      mlib.mrandomp
    cvtsi2sd  %XMM4,	%rax
    divsd     %XMM4,	[%rip+L8085]
    movq      %XMM15,	%XMM4
    movq      %XMM4,	%XMM15
    comisd    %XMM4,	[%rip+L8086]
    jz        L757
    movq      %XMM0,	%XMM15
L756:
#---------------
    add       %rsp,	48
    pop       %rcx
    movq      %XMM15,	%rcx
    ret       
# End 
# Proc mlib.mrandomreal1
mlib.mrandomreal1:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    call      mlib.mrandomp
    cvtsi2sd  %XMM4,	%rax
    divsd     %XMM4,	[%rip+L8087]
    movq      %XMM0,	%XMM4
L760:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mlib.readline
mlib.readline:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    call      msys.m$read_conline
    mov       %rax,	[%rip+msys.rd_buffer]
L761:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mlib.findfunction
mlib.findfunction:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    mov       %rbx,	1
    mov       %rdi,	[%rip+$nprocs]
    cmp       %rdi,	1
    jl        L765
L763:
    lea       %rax,	[%rip+$procname]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rcx,	%rax
    mov       %rdx,	%rsi
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L767
    lea       %rax,	[%rip+$procaddr]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8-8]
    jmp       L762
L767:
    inc       %rbx
    cmp       %rbx,	%rdi
    jle       L763
L765:
    xor       %eax,	%eax
L762:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.roundtoblock
mlib.roundtoblock:
#?>>
#?]]
#---------------
    lea       %rax,	[%rdx-1]
    mov       %r10,	%rcx
    and       %r10,	%rax
    test      %r10,	%r10
    jnz       L770
    mov       %rax,	%rcx
    jmp       L768
L770:
    lea       %rax,	[%rdx-1]
    mov       %r10,	%rcx
    and       %r10,	%rax
    mov       %rax,	%rdx
    sub       %rax,	%r10
    mov       %r10,	%rcx
    add       %r10,	%rax
    mov       %rax,	%r10
L768:
#---------------
    ret       
# End 
# Proc mlib.pcm_allocnfz
mlib.pcm_allocnfz:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rax,	%rbx
    and       %rax,	7
    jz        L773
    mov       %rax,	%rbx
    and       %rax,	7
    mov       %r10,	8
    sub       %r10,	%rax
    mov       %rax,	%rbx
    add       %rax,	%r10
    mov       %rbx,	%rax
L773:
    mov       %rdi,	[%rip+mlib.pcheapptr]
    mov       %rax,	%rbx
    add       [%rip+mlib.pcheapptr],	%rax
    mov       %rax,	[%rip+mlib.pcheapptr]
    cmp       %rax,	[%rip+mlib.pcheapend]
    jb        L775
    mov       %rcx,	%rbx
    call      mlib.pcm_newblock
    mov       %rdi,	%rax
L775:
    mov       %rax,	%rdi
L771:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mnoos.os_init
mnoos.os_init:
#?>>
#?]]
#---------------
#---
#---------------
    ret       
# End 
# Proc mnoos.os_execwait
mnoos.os_execwait:
#?>>
    .set mnoos.os_execwait.cmdline, 16
    .set mnoos.os_execwait.newconsole, 24
    .set mnoos.os_execwait.workdir, 32
#?]]
#---------------
    xor       %eax,	%eax
L777:
#---------------
    ret       
# End 
# Proc mnoos.os_execcmd
mnoos.os_execcmd:
#?>>
    .set mnoos.os_execcmd.cmdline, 16
    .set mnoos.os_execcmd.newconsole, 24
#?]]
#---------------
    xor       %eax,	%eax
L778:
#---------------
    ret       
# End 
# Proc mnoos.os_getch
mnoos.os_getch:
#?>>
#?]]
#---------------
    xor       %eax,	%eax
L779:
#---------------
    ret       
# End 
# Proc mnoos.os_kbhit
mnoos.os_kbhit:
#?>>
#?]]
#---------------
    xor       %eax,	%eax
L780:
#---------------
    ret       
# End 
# Proc mnoos.os_getdllinst
mnoos.os_getdllinst:
#?>>
    .set mnoos.os_getdllinst.name, 16
#?]]
#---------------
    xor       %eax,	%eax
L781:
#---------------
    ret       
# End 
# Proc mnoos.os_getdllprocaddr
mnoos.os_getdllprocaddr:
#?>>
    .set mnoos.os_getdllprocaddr.hinst, 16
    .set mnoos.os_getdllprocaddr.name, 24
#?]]
#---------------
    xor       %eax,	%eax
L782:
#---------------
    ret       
# End 
# Proc mnoos.os_initwindows
mnoos.os_initwindows:
#?>>
#?]]
#---------------
#---
#---------------
    ret       
# End 
# Proc mnoos.os_gxregisterclass
mnoos.os_gxregisterclass:
#?>>
    .set mnoos.os_gxregisterclass.classname, 16
#?]]
#---------------
#---
#---------------
    ret       
# End 
# Proc mnoos.os_setmesshandler
mnoos.os_setmesshandler:
#?>>
    .set mnoos.os_setmesshandler.addr, 16
#?]]
#---------------
#---
#---------------
    ret       
# End 
# Proc mnoos.os_getchx
mnoos.os_getchx:
#?>>
#?]]
#---------------
    mov       %rax,	27
L786:
#---------------
    ret       
# End 
# Proc mnoos.os_getos
mnoos.os_getos:
#?>>
#?]]
#---------------
    lea       %rax,	[%rip+L8088]
L787:
#---------------
    ret       
# End 
# Proc mnoos.os_gethostsize
mnoos.os_gethostsize:
#?>>
#?]]
#---------------
    mov       %rax,	64
L788:
#---------------
    ret       
# End 
# Proc mnoos.os_shellexec
mnoos.os_shellexec:
#?>>
    .set mnoos.os_shellexec.opc, 24
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rdx
#---------------
    mov       %rcx,	%rdi
    call      system
    movsxd    %r10,	%eax
    mov       %rax,	%r10
L789:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mnoos.os_sleep
mnoos.os_sleep:
#?>>
    .set mnoos.os_sleep.a, 16
#?]]
#---------------
#---
#---------------
    ret       
# End 
# Proc mnoos.os_getstdin
mnoos.os_getstdin:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    lea       %rcx,	[%rip+L8089]
    lea       %rdx,	[%rip+L8090]
    call      fopen
L791:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mnoos.os_getstdout
mnoos.os_getstdout:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    lea       %rcx,	[%rip+L8091]
    lea       %rdx,	[%rip+L8092]
    call      fopen
L792:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mnoos.os_gethostname
mnoos.os_gethostname:
#?>>
#?]]
#---------------
    lea       %rax,	[%rip+L8093]
L793:
#---------------
    ret       
# End 
# Proc mnoos.os_getmpath
mnoos.os_getmpath:
#?>>
#?]]
#---------------
    lea       %rax,	[%rip+L8094]
L794:
#---------------
    ret       
# End 
# Proc mnoos.os_clock
mnoos.os_clock:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    call      clock
    movsxd    %r10,	%eax
    mov       %rax,	%r10
L795:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mnoos.os_ticks
mnoos.os_ticks:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    call      clock
    movsxd    %r10,	%eax
    mov       %rax,	%r10
L796:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mnoos.os_iswindows
mnoos.os_iswindows:
#?>>
#?]]
#---------------
    mov       %rax,	1
L797:
#---------------
    ret       
# End 
# Proc mnoos.os_getsystime
mnoos.os_getsystime:
#?>>
    .set mnoos.os_getsystime.$1, 16
#?]]
#---------------
#---
#---------------
    ret       
# End 
# Proc mnoos.os_peek
mnoos.os_peek:
#?>>
#?]]
#---------------
#---
#---------------
    ret       
# End 
# Proc mnoos.os_allocexecmem
mnoos.os_allocexecmem:
#?>>
    .set mnoos.os_allocexecmem.n, 16
#?]]
#---------------
    xor       %eax,	%eax
L800:
#---------------
    ret       
# End 
# Proc mnoos.dirlist
mnoos.dirlist:
#?>>
    .set mnoos.dirlist.filespec, 16
    .set mnoos.dirlist.dest, 24
    .set mnoos.dirlist.capacity, 32
    .set mnoos.dirlist.t, 40
#?]]
#---------------
    xor       %eax,	%eax
L801:
#---------------
    ret       
# End 
# Proc mnoos.os_hpcounter
mnoos.os_hpcounter:
#?>>
#?]]
#---------------
    xor       %eax,	%eax
L802:
#---------------
    ret       
# End 
# Proc mnoos.os_hpfreq
mnoos.os_hpfreq:
#?>>
#?]]
#---------------
    xor       %eax,	%eax
L803:
#---------------
    ret       
# End 
# Proc mwindll.os_calldllfunction
mwindll.os_calldllfunction:
#?>>
    .set mwindll.os_calldllfunction.fnaddr, 16
    .set mwindll.os_calldllfunction.retcode, 24
    .set mwindll.os_calldllfunction.nargs, 32
    .set mwindll.os_calldllfunction.args, 40
    .set mwindll.os_calldllfunction.argcodes, 48
    .set mwindll.os_calldllfunction.a, -8
    .set mwindll.os_calldllfunction.x, -16
    .set mwindll.os_calldllfunction.nextra, -24
    .set mwindll.os_calldllfunction.pushedbytes, -32
    .set mwindll.os_calldllfunction.av_1, -40
    .set mwindll.os_calldllfunction.i, -48
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	80
    mov       [%rbp+16],	%rcx
    mov       [%rbp+24],	%rdx
    mov       [%rbp+32],	%r8
    mov       [%rbp+40],	%r9
#---------------
    xor       %eax,	%eax
    mov       [%rbp + mwindll.os_calldllfunction.nextra],	%rax
    mov       %rax,	[%rbp + mwindll.os_calldllfunction.nargs]
    cmp       %rax,	4
    jge       L806
    mov       %rax,	4
    sub       %rax,	[%rbp + mwindll.os_calldllfunction.nargs]
    mov       [%rbp + mwindll.os_calldllfunction.nextra],	%rax
    jmp       L805
L806:
    mov       %eax,	[%rbp + mwindll.os_calldllfunction.nargs]
    and       %eax,	1
    test      %rax,	%rax
    jz        L807
    mov       %rax,	1
    mov       [%rbp + mwindll.os_calldllfunction.nextra],	%rax
L807:
L805:
    mov       %rax,	[%rbp + mwindll.os_calldllfunction.nextra]
    add       %rax,	[%rbp + mwindll.os_calldllfunction.nargs]
    shl       %rax,	3
    mov       [%rbp + mwindll.os_calldllfunction.pushedbytes],	%rax
    mov       %rax,	[%rbp + mwindll.os_calldllfunction.nextra]
    mov       [%rbp + mwindll.os_calldllfunction.av_1],	%rax
    mov       %rax,	[%rbp + mwindll.os_calldllfunction.av_1]
    cmp       %rax,	0
    jle       L810
L808:
    push      0
    dec       qword ptr[%rbp + mwindll.os_calldllfunction.av_1]
    jnz       L808
L810:
    mov       %rax,	[%rbp + mwindll.os_calldllfunction.nargs]
    mov       [%rbp + mwindll.os_calldllfunction.i],	%rax
    mov       %rax,	[%rbp + mwindll.os_calldllfunction.i]
    cmp       %rax,	1
    jl        L813
L811:
    mov       %rax,	[%rbp + mwindll.os_calldllfunction.args]
    mov       %r10,	[%rbp + mwindll.os_calldllfunction.i]
    mov       %rax,	[%rax + %r10*8-8]
    mov       [%rbp + mwindll.os_calldllfunction.a],	%rax
    push      qword ptr[%rbp + mwindll.os_calldllfunction.a]
    mov       %rax,	[%rbp + mwindll.os_calldllfunction.i]
    dec       %rax
    mov       [%rbp + mwindll.os_calldllfunction.i],	%rax
    cmp       %rax,	1
    jge       L811
L813:
    mov       %rcx,	[%rsp]
    movq      %XMM0,	[%rsp]
    mov       %rdx,	[%rsp+8]
    movq      %XMM1,	[%rsp+8]
    mov       %r8,	[%rsp+16]
    movq      %XMM2,	[%rsp+16]
    mov       %r9,	[%rsp+24]
    movq      %XMM3,	[%rsp+24]
    mov       %rax,	[%rbp + mwindll.os_calldllfunction.retcode]
    cmp       %rax,	73
    jnz       L815
    mov       %rax,	[%rbp + mwindll.os_calldllfunction.fnaddr]
    call      %rax
    mov       [%rbp + mwindll.os_calldllfunction.a],	%rax
    add       %rsp,	[%rbp + mwindll.os_calldllfunction.pushedbytes]
    mov       %rax,	[%rbp + mwindll.os_calldllfunction.a]
    jmp       L814
L815:
    mov       %rax,	[%rbp + mwindll.os_calldllfunction.fnaddr]
    call      %rax
    movq      [%rbp + mwindll.os_calldllfunction.x],	%XMM0
    add       %rsp,	[%rbp + mwindll.os_calldllfunction.pushedbytes]
    movq      %XMM4,	[%rbp + mwindll.os_calldllfunction.x]
    movq      %rax,	%XMM4
L814:
L804:
#---------------
    add       %rsp,	80
    pop       %rbp
    ret       
# End 
# Proc pc_api.pcl_start
pc_api.pcl_start:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %al,	[%rip+pc_decls.pcldone]
    test      %al,	%al
    jz        L818
    lea       %rcx,	[%rip+L8095]
    call      pc_api.pclerror
L818:
    test      %rdi,	%rdi
    jz        L820
    mov       %rcx,	%rdi
    mov       %rdx,	9
    call      pc_api.pc_makesymbol
    mov       [%rip+pc_decls.currprog],	%rax
L820:
    mov       %rax,	[%rip+pc_api.initpcalloc]
    mov       [%rip+pc_api.pcalloc],	%rax
    test      %rbx,	%rbx
    jz        L822
    mov       %rax,	%rbx
    lea       %rax,	[%rax + %rax*8]
    sar       %rax,	3
    mov       %rbx,	%rax
    jmp       L824
L823:
    mov       %rax,	[%rip+pc_api.pcalloc]
    shl       %rax,	1
    mov       [%rip+pc_api.pcalloc],	%rax
L824:
    mov       %rax,	[%rip+pc_api.pcalloc]
    cmp       %rax,	%rbx
    jl        L823
L822:
    mov       %rax,	[%rip+pc_api.pcalloc]
    shl       %rax,	5
    mov       %rcx,	%rax
    call      mlib.pcm_allocz
    mov       [%rip+pc_api.pcstart],	%rax
    mov       %rax,	[%rip+pc_api.pcstart]
    mov       %r10,	[%rip+pc_api.pcalloc]
    shl       %r10,	5
    lea       %rax,	[%rax + %r10]
    sub       %rax,	256
    mov       [%rip+pc_api.pcend],	%rax
    mov       %rax,	[%rip+pc_api.pcstart]
    sub       %rax,	32
    mov       [%rip+pc_api.pccurr],	%rax
    xor       %eax,	%eax
    mov       [%rip+pc_api.pcfixed],	%al
    xor       %eax,	%eax
    mov       [%rip+pc_api.pcseqno],	%rax
    xor       %eax,	%eax
    mov       [%rip+pc_api.pcneedfntable],	%rax
    xor       %eax,	%eax
    mov       [%rip+pc_api.mlabelno],	%rax
    mov       %rax,	[%rip+pc_decls.currprog]
L816:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pcl_end
pc_api.pcl_end:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    mov       %rax,	[%rip+pc_api.pccurr]
    cmp       %rax,	[%rip+pc_api.pccurr]
    jb        L828
    mov       %rax,	[%rip+pc_api.pccurr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	136
    jz        L828
    mov       %rcx,	136
    xor       %edx,	%edx
    call      pc_api.pc_gen
L828:
    mov       %al,	1
    mov       [%rip+pc_decls.pcldone],	%al
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc pc_api.pcl_writepcl
pc_api.pcl_writepcl:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    call      pc_diags_dummy.writeallpcl
    mov       %rdi,	%rax
    test      %rbx,	%rbx
    jz        L831
    mov       %al,	[%rip+pc_decls.pverbose]
    test      %al,	%al
    jz        L833
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8096]
    call      msys.m$print_str_nf
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L833:
    movsxd    %rax,	dword ptr[%rdi+8]
    mov       %r10,	[%rdi]
    mov       %rcx,	%rbx
    mov       %rdx,	%r10
    mov       %r8,	%rax
    call      mlib.writefile
    lea       %rax,	[%rip+L8097]
    jmp       L830
L831:
    mov       %rax,	[%rdi]
L830:
L829:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pcl_writepst
pc_api.pcl_writepst:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    call      pc_diags_dummy.writepst
    mov       %rdi,	%rax
    test      %rbx,	%rbx
    jz        L836
    mov       %al,	[%rip+pc_decls.pverbose]
    test      %al,	%al
    jz        L838
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8098]
    call      msys.m$print_str_nf
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L838:
    movsxd    %rax,	dword ptr[%rdi+8]
    mov       %r10,	[%rdi]
    mov       %rcx,	%rbx
    mov       %rdx,	%r10
    mov       %r8,	%rax
    call      mlib.writefile
    lea       %rax,	[%rip+L8099]
    jmp       L835
L836:
    mov       %rax,	[%rdi]
L835:
L834:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pcl_genmcl
pc_api.pcl_genmcl:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    xor       %ecx,	%ecx
    call      mc_genmcl.genmcl
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc pc_api.pcl_genss
pc_api.pcl_genss:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    xor       %ecx,	%ecx
    call      mc_genmcl.genmcl
    mov       %rcx,	%rdi
    call      mc_genss_dummy.genss
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc pc_api.pcl_writess
pc_api.pcl_writess:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    xor       %ecx,	%ecx
    call      mc_genmcl.genmcl
    mov       %rcx,	%r12
    call      mc_genss_dummy.genss
    mov       %rax,	%r12
    test      %rax,	%rax
    setz      %al
    movzx     %eax,	%al
    mov       %rcx,	%rax
    call      mc_writess_dummy.writessdata
    mov       %rdi,	%rax
    test      %rsi,	%rsi
    jz        L843
    mov       %rcx,	%rsi
    lea       %rdx,	[%rip+L8100]
    call      fopen
    mov       %rbx,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mlib.gs_println
    mov       %rcx,	%rbx
    call      fclose
    mov       %rcx,	%rdi
    call      mlib.gs_free
    xor       %eax,	%eax
    jmp       L842
L843:
    mov       %rax,	[%rdi]
L842:
L841:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pcl_writeasm
pc_api.pcl_writeasm:
#?>>
    .set pc_api.pcl_writeasm.atype, 48
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    mov       %rax,	[%rip+pc_decls.assemtype]
    cmp       %rax,	1297301838
    jnz       L846
    mov       %al,	2
    mov       [%rip+pc_api.phighmem],	%al
L846:
    xor       %ecx,	%ecx
    call      mc_genmcl.genmcl
    call      mc_writegas.getassemstr
    mov       %rdi,	%rax
    test      %rsi,	%rsi
    jz        L848
    mov       %al,	[%rip+pc_decls.pverbose]
    test      %al,	%al
    jz        L850
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8101]
    call      msys.m$print_str_nf
    mov       %rcx,	%rsi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L850:
    mov       %rcx,	%rsi
    lea       %rdx,	[%rip+L8102]
    call      fopen
    mov       %rbx,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mlib.gs_println
    mov       %rcx,	%rbx
    call      fclose
    mov       %rcx,	%rdi
    call      mlib.gs_free
    xor       %eax,	%eax
    jmp       L847
L848:
    mov       %rax,	[%rdi]
L847:
L844:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pcl_writeobj
pc_api.pcl_writeobj:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    xor       %ecx,	%ecx
    call      mc_genmcl.genmcl
    mov       %rcx,	1
    call      mc_genss_dummy.genss
    call      mnoos.os_clock
    mov       %rdi,	%rax
    mov       %rcx,	%rbx
    call      mc_writeobj_dummy.writecoff
    call      mnoos.os_clock
    sub       %rax,	%rdi
    mov       [%rip+pc_decls.objtime],	%rax
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pcl_writedll
pc_api.pcl_writedll:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %al,	2
    mov       [%rip+pc_api.phighmem],	%al
    xor       %ecx,	%ecx
    call      mc_genmcl.genmcl
    xor       %ecx,	%ecx
    call      mc_genss_dummy.genss
    call      mnoos.os_clock
    mov       %rdi,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      mc_writeexe_dummy.writeexe
    call      mnoos.os_clock
    sub       %rax,	%rdi
    mov       [%rip+pc_decls.exetime],	%rax
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pcl_writeexe
pc_api.pcl_writeexe:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    xor       %ecx,	%ecx
    call      mc_genmcl.genmcl
    xor       %ecx,	%ecx
    call      mc_genss_dummy.genss
    call      mnoos.os_clock
    mov       %rdi,	%rax
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      mc_writeexe_dummy.writeexe
    call      mnoos.os_clock
    sub       %rax,	%rdi
    mov       [%rip+pc_decls.exetime],	%rax
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pcl_writemx
pc_api.pcl_writemx:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    xor       %ecx,	%ecx
    call      mc_genmcl.genmcl
    xor       %ecx,	%ecx
    call      mc_genss_dummy.genss
    mov       %rcx,	%rdi
    call      mx_run_dummy.writemcx
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc pc_api.pcl_exec
pc_api.pcl_exec:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    xor       %ecx,	%ecx
    call      mc_genmcl.genmcl
    xor       %ecx,	%ecx
    call      mc_genss_dummy.genss
    lea       %rcx,	[%rip+L8103]
    mov       %rdx,	[%rip+pc_decls.pcmdskip]
    call      mx_run_dummy.runlibfile
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc pc_api.pcl_setflags
pc_api.pcl_setflags:
#?>>
#?]]
#---------------
    cmp       %rcx,	0
    jl        L858
    mov       [%rip+pc_api.phighmem],	%cl
L858:
    cmp       %rdx,	0
    jl        L860
    mov       [%rip+pc_decls.pverbose],	%dl
L860:
    cmp       %r8,	0
    jl        L862
    mov       [%rip+pc_api.fpshortnames],	%r8b
L862:
#---------------
    ret       
# End 
# Proc pc_api.extendpclblock
pc_api.extendpclblock:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rax,	[%rip+pc_api.pcalloc]
    shl       %rax,	1
    mov       %rdi,	%rax
    mov       %rax,	[%rip+pc_api.pccurr]
    sub       %rax,	[%rip+pc_api.pcstart]
    shr       %rax,	5
    inc       %rax
    mov       %rbx,	%rax
    mov       %rax,	32
    mov       %r10,	%rdi
    imul      %rax,	%r10
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       %rsi,	%rax
    mov       %rax,	%rbx
    shl       %rax,	5
    mov       %rcx,	%rsi
    mov       %rdx,	[%rip+pc_api.pcstart]
    mov       %r8,	%rax
    call      memcpy
    mov       %rax,	%rdi
    sub       %rax,	%rbx
    shl       %rax,	5
    mov       %r10,	%rbx
    shl       %r10,	5
    lea       %r11,	[%rsi + %r10]
    mov       %rcx,	%r11
    mov       %rdx,	%rax
    call      mlib.pcm_clearmem
    mov       %rax,	[%rip+pc_api.pccurr]
    sub       %rax,	[%rip+pc_api.pcstart]
    shr       %rax,	5
    shl       %rax,	5
    lea       %r10,	[%rsi + %rax]
    mov       [%rip+pc_api.pccurr],	%r10
    mov       %rax,	%rdi
    shl       %rax,	5
    lea       %r10,	[%rsi + %rax]
    sub       %r10,	256
    mov       [%rip+pc_api.pcend],	%r10
    mov       %rax,	[%rip+pc_api.pcalloc]
    shl       %rax,	5
    mov       %rcx,	[%rip+pc_api.pcstart]
    mov       %rdx,	%rax
    call      mlib.pcm_free
    mov       [%rip+pc_api.pcstart],	%rsi
    mov       [%rip+pc_api.pcalloc],	%rdi
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.newpcl
pc_api.newpcl:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    mov       %rax,	[%rip+pc_api.pccurr]
    cmp       %rax,	[%rip+pc_api.pcend]
    jb        L866
    call      pc_api.extendpclblock
L866:
    add       qword ptr[%rip+pc_api.pccurr],	32
    mov       %eax,	[%rip+pc_decls.mmpos]
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+24],	%eax
    inc       qword ptr[%rip+pc_api.pclseqno]
    mov       %rax,	[%rip+pc_api.pclseqno]
    mov       %r10,	[%rip+pc_api.pccurr]
    lea       %r10,	[%r10+28]
    mov       %r9d,	[%r10]
    mov       %r11,	-4294967041
    shl       %eax,	8
    and       %r9d,	%r11d
    or        %r9d,	%eax
    mov       [%r10],	%r9d
    inc       qword ptr[%rip+pc_decls.npcl]
    mov       %rax,	[%rip+pc_api.pccurr]
L864:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc pc_api.pc_gen
pc_api.pc_gen:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    test      %rbx,	%rbx
    jnz       L869
    call      pc_api.newpcl
    mov       %rbx,	%rax
L869:
    mov       [%rbx],	%dil
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pc_genix
pc_api.pc_genix:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    call      pc_api.newpcl
    mov       %rdi,	%rax
    mov       [%rdi],	%bl
    mov       [%rdi+16],	%esi
    mov       [%rdi+20],	%r12d
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pc_genx
pc_api.pc_genx:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    test      %rsi,	%rsi
    jnz       L873
    call      pc_api.newpcl
    mov       %rsi,	%rax
L873:
    mov       [%rsi],	%dil
    mov       [%rsi+16],	%ebx
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pc_genxy
pc_api.pc_genxy:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
    mov       %r12,	%r9
#---------------
    test      %r12,	%r12
    jnz       L876
    call      pc_api.newpcl
    mov       %r12,	%rax
L876:
    mov       [%r12],	%dil
    mov       [%r12+16],	%ebx
    mov       [%r12+20],	%esi
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pc_gencond
pc_api.pc_gencond:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    test      %rsi,	%rsi
    jnz       L879
    call      pc_api.newpcl
    mov       %rsi,	%rax
L879:
    mov       [%rsi],	%dil
    mov       [%rsi+2],	%bl
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.genint
pc_api.genint:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    call      pc_api.newpcl
    mov       %rdi,	%rax
    mov       [%rdi+8],	%rbx
    mov       %al,	4
    mov       [%rdi+1],	%al
    mov       %rax,	%rdi
L880:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.genreal
pc_api.genreal:
#?>>
    push      %rdi
    push      %rbx
    movq      %rax,	%XMM15
    push      %rax
#?]]
    sub       %rsp,	48
    movq      %XMM15,	%XMM0
    mov       %rbx,	%rdx
#---------------
    call      pc_api.newpcl
    mov       %rdi,	%rax
    movq      %XMM4,	%XMM15
    movq      [%rdi+8],	%XMM4
    cmp       %rbx,	2
    jnz       L883
    mov       %rax,	5
    jmp       L882
L883:
    mov       %rax,	6
L882:
    mov       [%rdi+1],	%al
    mov       %rax,	%rdi
L881:
#---------------
    add       %rsp,	48
    pop       %rcx
    movq      %XMM15,	%rcx
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.genrealimm
pc_api.genrealimm:
#?>>
    push      %rdi
    push      %rbx
    movq      %rax,	%XMM15
    push      %rax
#?]]
    sub       %rsp,	48
    movq      %XMM15,	%XMM0
    mov       %rbx,	%rdx
#---------------
    call      pc_api.newpcl
    mov       %rdi,	%rax
    movq      %XMM4,	%XMM15
    movq      [%rdi+8],	%XMM4
    cmp       %rbx,	2
    jnz       L886
    mov       %rax,	10
    jmp       L885
L886:
    mov       %rax,	11
L885:
    mov       [%rdi+1],	%al
    mov       %rax,	%rdi
L884:
#---------------
    add       %rsp,	48
    pop       %rcx
    movq      %XMM15,	%rcx
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.genstring
pc_api.genstring:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    call      pc_api.newpcl
    mov       %rdi,	%rax
    cmp       %rsi,	0
    jge       L889
    mov       %rcx,	%rbx
    call      strlen
    inc       %rax
    mov       %rsi,	%rax
L889:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      mlib.pcm_copyheapstringn
    mov       [%rdi+8],	%rax
    mov       %al,	7
    mov       [%rdi+1],	%al
    mov       [%rdi+16],	%esi
    mov       %rax,	%rdi
L887:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.genpcstrimm
pc_api.genpcstrimm:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    call      pc_api.newpcl
    mov       %rdi,	%rax
    mov       %rcx,	%rbx
    call      mlib.pcm_copyheapstring
    mov       [%rdi+8],	%rax
    mov       %al,	8
    mov       [%rdi+1],	%al
    mov       %rax,	%rdi
L890:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.genlabel
pc_api.genlabel:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    call      pc_api.newpcl
    mov       %rdi,	%rax
    mov       [%rdi+8],	%rbx
    mov       %al,	3
    mov       [%rdi+1],	%al
    mov       %rax,	%rdi
L891:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.genmem
pc_api.genmem:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    call      pc_api.newpcl
    mov       %rdi,	%rax
    mov       [%rdi+8],	%rbx
    mov       %al,	1
    mov       [%rdi+1],	%al
    mov       %rax,	%rdi
L892:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.genmemaddr
pc_api.genmemaddr:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    call      pc_api.newpcl
    mov       %rdi,	%rax
    mov       [%rdi+8],	%rbx
    mov       %al,	2
    mov       [%rdi+1],	%al
    mov       %rax,	%rdi
L893:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.gendata
pc_api.gendata:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    call      pc_api.newpcl
    mov       %rdi,	%rax
    mov       [%rdi+8],	%rbx
    mov       %al,	12
    mov       [%rdi+1],	%al
    mov       %al,	11
    mov       [%rdi+3],	%al
    mov       [%rdi+4],	%esi
    mov       %rax,	%rdi
L894:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.gencomment
pc_api.gencomment:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %al,	[%rip+pc_decls.fregoptim]
    test      %al,	%al
    jnz       L898
    mov       %al,	[%rip+pc_decls.fpeephole]
    test      %al,	%al
    jz        L897
L898:
    jmp       L895
L897:
    mov       %rcx,	%rdi
    call      pc_api.genpcstrimm
    mov       %rcx,	135
    mov       %rdx,	%rax
    call      pc_api.pc_gen
L895:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc pc_api.genname
pc_api.genname:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	8
    call      pc_api.pc_makesymbol
    mov       %rcx,	%rax
    call      pc_api.genmem
L899:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc pc_api.gennameaddr
pc_api.gennameaddr:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	8
    call      pc_api.pc_makesymbol
    mov       %rcx,	%rax
    call      pc_api.genmemaddr
L900:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc pc_api.genassem
pc_api.genassem:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    call      pc_api.newpcl
    mov       %rdi,	%rax
    mov       [%rdi+8],	%rbx
    mov       %al,	9
    mov       [%rdi+1],	%al
    mov       %rax,	%rdi
L901:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.strpmode
pc_api.strpmode:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    lea       %rcx,	[%rip+pc_api.strpmode.str]
    lea       %rdx,	[%rip+L8104]
    call      strcpy
    mov       %rax,	%rdi
    cmp       %rax,	11
    jz        L904
    test      %rax,	%rax
    jz        L905
    jmp       L906
L904:
    lea       %rcx,	[%rip+pc_api.strpmode.str]
    lea       %rdx,	[%rip+L8105]
    call      strcpy
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      msys.strint
    lea       %rcx,	[%rip+pc_api.strpmode.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rax,	[%rip+pc_api.strpmode.str]
    jmp       L903
L905:
    lea       %rax,	[%rip+L8106]
    jmp       L903
L906:
    lea       %rax,	[%rip+pc_tables.pstdnames]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
L903:
L902:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pc_setmode
pc_api.pc_setmode:
#?>>
#?]]
#---------------
    mov       %al,	%cl
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+3],	%al
    test      %rdx,	%rdx
    jz        L909
    mov       %eax,	%edx
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+4],	%eax
    jmp       L908
L909:
    mov       %rax,	[%rip+pc_api.pccurr]
    movzx     %rax,	byte ptr[%rax+3]
    lea       %r10,	[%rip+pc_tables.psize]
    movzx     %r10,	byte ptr[%r10 + %rax]
    mov       %rax,	[%rip+pc_api.pccurr]
    mov       [%rax+4],	%r10d
L908:
    mov       %rax,	[%rip+pc_api.pccurr]
    movzx     %rax,	byte ptr[%rax]
    lea       %r10,	[%rip+pc_tables.pclhastype]
    movzx     %r10,	byte ptr[%r10 + %rax]
    cmp       %r10,	2
    jnz       L911
    mov       %rax,	[%rip+pc_api.pccurr]
    movzx     %rax,	byte ptr[%rax+3]
    mov       %r10,	[%rip+pc_api.pccurr]
    lea       %r10,	[%r10+28]
    mov       %r9d,	[%r10]
    mov       %r11,	-256
    and       %r9d,	%r11d
    or        %r9d,	%eax
    mov       [%r10],	%r9d
L911:
#---------------
    ret       
# End 
# Proc pc_api.pc_setmode2
pc_api.pc_setmode2:
#?>>
#?]]
#---------------
    mov       %rax,	[%rip+pc_api.pccurr]
    lea       %rax,	[%rax+28]
    mov       %r10d,	%ecx
    mov       %r9d,	[%rax]
    mov       %r11,	-256
    and       %r9d,	%r11d
    or        %r9d,	%r10d
    mov       [%rax],	%r9d
#---------------
    ret       
# End 
# Proc pc_api.pc_setxy
pc_api.pc_setxy:
#?>>
#?]]
#---------------
    mov       %eax,	%ecx
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+16],	%eax
    mov       %eax,	%edx
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+20],	%eax
#---------------
    ret       
# End 
# Proc pc_api.pc_setscaleoff
pc_api.pc_setscaleoff:
#?>>
#?]]
#---------------
    mov       %eax,	%ecx
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+16],	%eax
    mov       %eax,	%edx
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+20],	%eax
#---------------
    ret       
# End 
# Proc pc_api.pc_setoffset
pc_api.pc_setoffset:
#?>>
#?]]
#---------------
    mov       %eax,	%ecx
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+20],	%eax
#---------------
    ret       
# End 
# Proc pc_api.pc_addoffset
pc_api.pc_addoffset:
#?>>
#?]]
#---------------
    mov       %rax,	[%rip+pc_api.pccurr]
    lea       %rax,	[%rax+20]
    mov       %r10d,	%ecx
    add       [%rax],	%r10d
#---------------
    ret       
# End 
# Proc pc_api.pc_setincr
pc_api.pc_setincr:
#?>>
#?]]
#---------------
    mov       %eax,	%ecx
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+16],	%eax
#---------------
    ret       
# End 
# Proc pc_api.pc_setnargs
pc_api.pc_setnargs:
#?>>
#?]]
#---------------
    mov       %eax,	%ecx
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+16],	%eax
#---------------
    ret       
# End 
# Proc pc_api.pc_setnvariadics
pc_api.pc_setnvariadics:
#?>>
#?]]
#---------------
    mov       %eax,	%ecx
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+20],	%eax
#---------------
    ret       
# End 
# Proc pc_api.pc_setalign
pc_api.pc_setalign:
#?>>
#?]]
#---------------
    mov       %eax,	%ecx
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+16],	%eax
#---------------
    ret       
# End 
# Proc pc_api.perror
pc_api.perror:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      pc_api.perror_s
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc pc_api.perror_s
pc_api.perror_s:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8107]
    call      msys.m$print_str_nf
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    call      msys.m$print_end
    test      %rbx,	%rbx
    jz        L924
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8108]
    call      msys.m$print_str_nf
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    call      msys.m$print_end
L924:
    mov       %rcx,	1
    call      exit
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.getbasename
pc_api.getbasename:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rcx,	%rbx
    call      strlen
    lea       %r10,	[%rbx + %rax]
    sub       %r10,	1
    mov       %rdi,	%r10
    jmp       L927
L926:
    dec       %rdi
L927:
    cmp       %rdi,	%rbx
    jbe       L929
    lea       %rax,	[%rdi-1]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	46
    jnz       L926
L929:
    mov       %rax,	%rdi
L925:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pclerror
pc_api.pclerror:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8109]
    call      msys.m$print_str_nf
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	1
    call      exit
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc pc_api.pc_addsymbol
pc_api.pc_addsymbol:
#?>>
#?]]
#---------------
    mov       %rax,	[%rip+pc_decls.psymboltable]
    test      %rax,	%rax
    jnz       L933
    mov       %rax,	%rcx
    mov       [%rip+pc_decls.psymboltablex],	%rax
    mov       [%rip+pc_decls.psymboltable],	%rax
    jmp       L932
L933:
    mov       %rax,	%rcx
    mov       %r10,	[%rip+pc_decls.psymboltablex]
    mov       [%r10+8],	%rax
    mov       [%rip+pc_decls.psymboltablex],	%rcx
L932:
#---------------
    ret       
# End 
# Proc pc_api.pc_makesymbol
pc_api.pc_makesymbol:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    inc       qword ptr[%rip+pc_decls.npst]
    mov       %rcx,	128
    call      mlib.pcm_allocnfz
    mov       %rdi,	%rax
    mov       %rcx,	%rbx
    call      mlib.pcm_copyheapstring
    mov       [%rdi],	%rax
    inc       qword ptr[%rip+pc_api.stseqno]
    mov       %rax,	[%rip+pc_api.stseqno]
    mov       [%rdi+120],	%eax
    mov       %rax,	%rsi
    cmp       %rax,	1
    jz        L936
    cmp       %rax,	7
    jz        L937
    jmp       L938
L936:
    mov       %al,	1
    mov       [%rdi+80],	%al
    jmp       L935
L937:
    mov       %al,	1
    mov       [%rdi+81],	%al
    mov       %rsi,	2
L938:
L935:
    mov       [%rdi+72],	%sil
    mov       %rax,	%rsi
    cmp       %rax,	4
    jz        L941
    cmp       %rax,	5
    jnz       L940
L941:
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       [%rdi+32],	%rax
    jmp       L939
L940:
    test      %rsi,	%rsi
    jz        L942
    mov       %rcx,	%rdi
    call      pc_api.pc_addsymbol
L942:
L939:
    mov       %rax,	%rdi
L934:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.getfullname
pc_api.getfullname:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    xor       %rdi,	%rdi
    mov       %rax,	%rsi
    mov       %rbx,	%rax
    xor       %eax,	%eax
    lea       %r10,	[%rip+pc_api.getfullname.str]
    mov       [%r10],	%al
    test      %r12,	%r12
    jz        L945
    lea       %rcx,	[%rip+pc_api.getfullname.str]
    lea       %rdx,	[%rip+L8110]
    call      strcpy
L945:
    mov       %al,	[%rsi+80]
    test      %al,	%al
    jz        L947
    test      %r12,	%r12
    jz        L949
    mov       %rax,	[%rsi]
    lea       %rcx,	[%rip+pc_api.getfullname.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rcx,	[%rip+pc_api.getfullname.str]
    lea       %rdx,	[%rip+L8111]
    call      strcat
    jmp       L948
L949:
    mov       %rax,	[%rsi]
    lea       %rcx,	[%rip+pc_api.getfullname.str]
    mov       %rdx,	%rax
    call      strcat
L948:
    lea       %rax,	[%rip+pc_api.getfullname.str]
    jmp       L943
L947:
    movzx     %rax,	byte ptr[%rsi+72]
    cmp       %rax,	4
    jz        L952
    cmp       %rax,	5
    jnz       L951
L952:
    mov       %rax,	[%rsi+32]
    mov       %rax,	[%rax]
    lea       %rcx,	[%rip+pc_api.getfullname.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rcx,	[%rip+pc_api.getfullname.str]
    lea       %rdx,	[%rip+L8112]
    call      strcat
    mov       %rax,	[%rsi]
    lea       %rcx,	[%rip+pc_api.getfullname.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rax,	[%rip+pc_api.getfullname.str]
    jmp       L943
L951:
    test      %r12,	%r12
    jz        L954
    mov       %rax,	[%rsi]
    lea       %rcx,	[%rip+pc_api.getfullname.str]
    mov       %rdx,	%rax
    call      strcat
    jmp       L953
L954:
    mov       %rax,	[%rsi]
L953:
L943:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pcerrorstop
pc_api.pcerrorstop:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    lea       %rcx,	[%rip+L8113]
    lea       %rdx,	[%rip+L8114]
    call      fopen
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    call      msys.m$print_startfile
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    mov       %rcx,	%rsi
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%rdi
    call      fclose
    mov       %rcx,	1
    call      exit
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pc_addplib
pc_api.pc_addplib:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	[%rip+pc_decls.nplibfiles]
    cmp       %rax,	50
    jl        L958
    lea       %rcx,	[%rip+L8115]
    call      pc_api.perror
L958:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8116]
    call      mlib.changeext
    mov       %rcx,	%rax
    call      mlib.pcm_copyheapstring
    inc       qword ptr[%rip+pc_decls.nplibfiles]
    mov       %r10,	[%rip+pc_decls.nplibfiles]
    lea       %r11,	[%rip+pc_decls.plibfiles]
    mov       [%r11 + %r10*8-8],	%rax
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc pc_api.pc_defproc
pc_api.pc_defproc:
#?>>
    .set pc_api.pc_defproc.$T1, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
    mov       %r12,	%r9
#---------------
    mov       %rax,	[%rip+pc_decls.currfunc]
    test      %rax,	%rax
    jz        L961
    lea       %rcx,	[%rip+L8117]
    call      pc_api.pclerror
L961:
    mov       %rcx,	%rdi
    call      pc_api.genmem
    mov       [%rbp + pc_api.pc_defproc.$T1],	%rax
    test      %r12,	%r12
    jz        L963
    mov       %rax,	121
    jmp       L962
L963:
    mov       %rax,	120
L962:
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + pc_api.pc_defproc.$T1]
    call      pc_api.pc_gen
    test      %rbx,	%rbx
    jnz       L965
    movzx     %rax,	byte ptr[%rdi+82]
    mov       %rbx,	%rax
L965:
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      pc_api.pc_setmode
    mov       %rax,	[%rdi+56]
    test      %rax,	%rax
    jz        L967
    mov       %rax,	[%rdi]
    lea       %rcx,	[%rip+L8118]
    mov       %rdx,	%rax
    call      pc_api.addstr
    mov       %rcx,	%rax
    call      pc_api.pclerror
L967:
    mov       %rax,	[%rip+pc_api.pccurr]
    mov       [%rdi+56],	%rax
    mov       %rax,	[%rip+pc_decls.entryproc]
    test      %rax,	%rax
    jnz       L969
    test      %rsi,	%rsi
    jz        L969
    mov       [%rip+pc_decls.entryproc],	%rdi
    mov       %al,	1
    mov       [%rdi+83],	%al
L969:
    mov       [%rip+pc_decls.currfunc],	%rdi
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pc_setimport
pc_api.pc_setimport:
#?>>
#?]]
#---------------
    mov       [%rip+pc_decls.currfunc],	%rcx
#---------------
    ret       
# End 
# Proc pc_api.pc_addparam
pc_api.pc_addparam:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    mov       %rdi,	[%rip+pc_decls.currfunc]
    test      %rdi,	%rdi
    jnz       L973
    lea       %rcx,	[%rip+L8119]
    call      pc_api.pclerror
L973:
    mov       %rbx,	[%rdi+16]
    test      %rbx,	%rbx
    jnz       L975
    mov       [%rdi+16],	%rsi
    jmp       L974
L975:
    jmp       L977
L976:
    mov       %rbx,	[%rbx+16]
L977:
    mov       %rax,	[%rbx+16]
    test      %rax,	%rax
    jnz       L976
    mov       [%rbx+16],	%rsi
L974:
    mov       %rax,	[%rsi+32]
    test      %rax,	%rax
    jnz       L980
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       [%rsi+32],	%rax
L980:
    mov       %rax,	[%rip+pc_decls.currfunc]
    lea       %rax,	[%rax+112]
    inc       byte ptr[%rax]
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pc_addlocal
pc_api.pc_addlocal:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    mov       %rdi,	[%rip+pc_decls.currfunc]
    test      %rdi,	%rdi
    jnz       L983
    lea       %rcx,	[%rip+L8119]
    call      pc_api.pclerror
L983:
    mov       %rbx,	[%rdi+24]
    test      %rbx,	%rbx
    jnz       L985
    mov       [%rdi+24],	%rsi
    jmp       L984
L985:
    jmp       L987
L986:
    mov       %rbx,	[%rbx+24]
L987:
    mov       %rax,	[%rbx+24]
    test      %rax,	%rax
    jnz       L986
    mov       [%rbx+24],	%rsi
L984:
    mov       %rax,	[%rsi+32]
    test      %rax,	%rax
    jnz       L990
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       [%rsi+32],	%rax
L990:
    mov       %rax,	[%rip+pc_decls.currfunc]
    lea       %rax,	[%rax+114]
    inc       word ptr[%rax]
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pc_endproc
pc_api.pc_endproc:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    mov       %rax,	[%rip+pc_decls.currfunc]
    test      %rax,	%rax
    jnz       L993
    lea       %rcx,	[%rip+L8119]
    call      pc_api.pclerror
L993:
    mov       %rcx,	122
    xor       %edx,	%edx
    call      pc_api.pc_gen
    xor       %eax,	%eax
    mov       [%rip+pc_decls.currfunc],	%rax
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc pc_api.addstr
pc_api.addstr:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    lea       %rcx,	[%rip+pc_api.addstr.str]
    mov       %rdx,	%rdi
    call      strcpy
    lea       %rcx,	[%rip+pc_api.addstr.str]
    mov       %rdx,	%rbx
    call      strcat
    lea       %rax,	[%rip+pc_api.addstr.str]
L994:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.merror
pc_api.merror:
#?>>
    .set pc_api.merror.filename, -8
    .set pc_api.merror.sourceline, -16
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	56
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rax,	[%rip+pc_decls.igetmsourceinfo]
    test      %rax,	%rax
    jz        L997
    mov       %rcx,	[%rip+pc_decls.mmpos]
    lea       %rdx,	[%rbp + pc_api.merror.filename]
    lea       %r8,	[%rbp + pc_api.merror.sourceline]
    mov       %rax,	[%rip+pc_decls.igetmsourceinfo]
    call      %rax
    mov       %rdi,	%rax
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8120]
    call      msys.m$print_str_nf
    mov       %rcx,	%rdi
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8121]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rbp + pc_api.merror.filename]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L996
L997:
    xor       %rdi,	%rdi
    lea       %rax,	[%rip+L8122]
    mov       [%rbp + pc_api.merror.filename],	%rax
L996:
    mov       %rax,	[%rip+pc_decls.currfunc]
    test      %rax,	%rax
    jz        L999
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8123]
    call      msys.m$print_str_nf
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L999:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8124]
    call      msys.m$print_setfmt
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    mov       %rcx,	%rsi
    call      msys.m$print_str_nf
    mov       %rcx,	%rdi
    call      msys.m$print_i64_nf
    mov       %rcx,	[%rbp + pc_api.merror.filename]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+pc_decls.ppseqno]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	[%rbp + pc_api.merror.filename]
    mov       %rdx,	%rdi
    call      pc_api.pcerrorstop
#---------------
    add       %rsp,	56
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pc_duplpst
pc_api.pc_duplpst:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rcx,	128
    call      mlib.pcm_allocnfz
    mov       %rdi,	%rax
    mov       %rax,	%rbx
    push      %rdi
    mov       %r11,	16
L8125:
    mov       %r10,	[%rax]
    mov       [%rdi],	%r10
    add       %rdi,	8
    add       %rax,	8
    dec       %r11
    jnz       L8125
    pop       %rdi
    inc       qword ptr[%rip+pc_api.stseqno]
    mov       %rax,	[%rip+pc_api.stseqno]
    mov       [%rdi+120],	%eax
    xor       %eax,	%eax
    mov       [%rdi+8],	%rax
    mov       %rax,	%rdi
L1000:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pcl_cmdskip
pc_api.pcl_cmdskip:
#?>>
    .set pc_api.pcl_cmdskip.dcmdskip, 24
#?]]
#---------------
    mov       [%rip+pc_decls.pcmdskip],	%rcx
#---------------
    ret       
# End 
# Proc pc_api.convertstring
pc_api.convertstring:
#?>>
    .set pc_api.convertstring.str, -16
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    mov       %rbx,	%r12
    jmp       L1004
L1003:
    mov       %rax,	%rdi
    cmp       %rax,	34
    jz        L1007
    cmp       %rax,	10
    jz        L1008
    cmp       %rax,	13
    jz        L1009
    cmp       %rax,	9
    jz        L1010
    cmp       %rax,	92
    jz        L1011
    cmp       %rax,	7
    jz        L1012
    cmp       %rax,	8
    jz        L1012
    cmp       %rax,	26
    jz        L1012
    cmp       %rax,	27
    jz        L1012
    jmp       L1013
L1007:
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	34
    mov       [%rax],	%r10b
    jmp       L1006
L1008:
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	110
    mov       [%rax],	%r10b
    jmp       L1006
L1009:
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	114
    mov       [%rax],	%r10b
    jmp       L1006
L1010:
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	116
    mov       [%rax],	%r10b
    jmp       L1006
L1011:
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	92
    mov       [%rax],	%r10b
    jmp       L1006
L1012:
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	60
    mov       [%rax],	%r10b
    mov       %rax,	%rdi
    mov       %r10,	10
    cqo       
    idiv      %r10
    add       %rax,	48
    mov       %r10,	%r12
    inc       %r12
    mov       [%r10],	%al
    mov       %rax,	%rdi
    mov       %r10,	10
    cqo       
    idiv      %r10
    xchg      %rax,	%rdx
    add       %rax,	48
    mov       %r10,	%r12
    inc       %r12
    mov       [%r10],	%al
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	62
    mov       [%rax],	%r10b
    jmp       L1006
L1013:
    mov       %rax,	%rdi
    cmp       %rax,	32
    jl        L1015
    cmp       %rax,	126
    jg        L1015
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	%dil
    mov       [%rax],	%r10b
    jmp       L1014
L1015:
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	120
    mov       [%rax],	%r10b
    lea       %rcx,	[%rbp + pc_api.convertstring.str]
    call      msys.m$print_startstr
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8126]
    call      msys.m$print_i64
    call      msys.m$print_end
    mov       %al,	[%rbp + pc_api.convertstring.str]
    mov       %r10,	%r12
    inc       %r12
    mov       [%r10],	%al
    mov       %al,	[%rbp + pc_api.convertstring.str+1]
    mov       %r10,	%r12
    inc       %r12
    mov       [%r10],	%al
L1014:
L1006:
L1004:
    mov       %rax,	%rsi
    inc       %rsi
    movzx     %rax,	byte ptr[%rax]
    mov       %rdi,	%rax
    test      %rax,	%rax
    jnz       L1003
    xor       %eax,	%eax
    mov       [%r12],	%al
    mov       %rax,	%r12
    sub       %rax,	%rbx
L1002:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_diags_dummy.pshowlogfile
pc_diags_dummy.pshowlogfile:
#?>>
#?]]
#---------------
#---
#---------------
    ret       
# End 
# Proc pc_diags_dummy.strpcl
pc_diags_dummy.strpcl:
#?>>
    .set pc_diags_dummy.strpcl.p, 16
#?]]
#---------------
#---
#---------------
    ret       
# End 
# Proc pc_diags_dummy.stropnd
pc_diags_dummy.stropnd:
#?>>
    .set pc_diags_dummy.stropnd.p, 16
#?]]
#---------------
    xor       %eax,	%eax
L1018:
#---------------
    ret       
# End 
# Proc pc_diags_dummy.strpclstr
pc_diags_dummy.strpclstr:
#?>>
    .set pc_diags_dummy.strpclstr.p, 16
    .set pc_diags_dummy.strpclstr.buffsize, 24
#?]]
#---------------
    xor       %eax,	%eax
L1019:
#---------------
    ret       
# End 
# Proc pc_diags_dummy.writepcl
pc_diags_dummy.writepcl:
#?>>
    .set pc_diags_dummy.writepcl.p, 16
#?]]
#---------------
#---
#---------------
    ret       
# End 
# Proc pc_diags_dummy.writeallpcl
pc_diags_dummy.writeallpcl:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    lea       %rcx,	[%rip+L8127]
    call      mlib.abortprogram
    xor       %eax,	%eax
L1021:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc pc_diags_dummy.writepst
pc_diags_dummy.writepst:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    call      pc_diags_dummy.writeallpcl
L1022:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc pc_reduce.pcl_reducetest
pc_reduce.pcl_reducetest:
#?>>
    .set pc_reduce.pcl_reducetest.pcproc, -8
    .set pc_reduce.pcl_reducetest.labelmap, -16
    .set pc_reduce.pcl_reducetest.pdef, -24
    .set pc_reduce.pcl_reducetest.callstack, -152
    .set pc_reduce.pcl_reducetest.ncall, -160
    .set pc_reduce.pcl_reducetest.nprocs, -168
    .set pc_reduce.pcl_reducetest.nleaf, -176
    .set pc_reduce.pcl_reducetest.nallparams, -184
    .set pc_reduce.pcl_reducetest.nalllocals, -192
    .set pc_reduce.pcl_reducetest.av_1, -200
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	232
#---------------
    xor       %eax,	%eax
    mov       [%rbp + pc_reduce.pcl_reducetest.nprocs],	%rax
    xor       %eax,	%eax
    mov       [%rbp + pc_reduce.pcl_reducetest.nleaf],	%rax
    xor       %eax,	%eax
    mov       [%rbp + pc_reduce.pcl_reducetest.nallparams],	%rax
    xor       %eax,	%eax
    mov       [%rbp + pc_reduce.pcl_reducetest.nalllocals],	%rax
    mov       %rax,	[%rip+pc_api.pccurr]
    sub       %rax,	[%rip+pc_api.pcstart]
    shr       %rax,	5
    inc       %rax
    mov       %rdi,	%rax
    mov       %r13,	[%rip+pc_api.pcstart]
    mov       %rax,	[%rip+pc_api.mlabelno]
    shl       %rax,	1
    mov       %rcx,	%rax
    call      mlib.pcm_allocz
    mov       [%rbp + pc_reduce.pcl_reducetest.labelmap],	%rax
    jmp       L1027
L1024:
    movzx     %rax,	byte ptr[%r13]
    cmp       %rax,	127
    jz        L1029
    cmp       %rax,	42
    jz        L1030
    jmp       L1031
L1029:
    jmp       L1028
L1030:
    mov       %rax,	[%rip+pc_api.icheckasmlabel]
    test      %rax,	%rax
    jz        L1033
    mov       %rax,	[%r13+8]
    mov       %rcx,	%rax
    mov       %r10,	[%rip+pc_api.icheckasmlabel]
    call      %r10
    mov       %rsi,	%rax
    test      %rsi,	%rsi
    jz        L1035
    mov       %rax,	[%rbp + pc_reduce.pcl_reducetest.labelmap]
    mov       %r10,	%rsi
    lea       %rax,	[%rax + %r10*2-2]
    inc       word ptr[%rax]
L1035:
L1033:
    jmp       L1028
L1031:
    movzx     %rax,	byte ptr[%r13+1]
    cmp       %rax,	3
    jnz       L1037
    mov       %rax,	[%r13+8]
    mov       %r10,	[%rbp + pc_reduce.pcl_reducetest.labelmap]
    lea       %r10,	[%r10 + %rax*2-2]
    inc       word ptr[%r10]
L1037:
L1028:
    add       %r13,	32
L1027:
    cmp       %r13,	[%rip+pc_api.pccurr]
    jbe       L1024
#pc_reduce.pcl_reducetest.skip:
    mov       %r13,	[%rip+pc_api.pcstart]
    mov       %rax,	[%rip+pc_api.pcstart]
    sub       %rax,	32
    mov       %r14,	%rax
    xor       %rbx,	%rbx
    mov       %rax,	%rdi
    mov       [%rbp + pc_reduce.pcl_reducetest.av_1],	%rax
    mov       %rax,	[%rbp + pc_reduce.pcl_reducetest.av_1]
    cmp       %rax,	0
    jle       L1041
L1039:
    lea       %rax,	[%r13+32]
    mov       %r15,	%rax
    movzx     %rax,	byte ptr[%r13]
    lea       %r10,	[%rip+pc_tables.pclargs]
    movzx     %r10,	byte ptr[%r10 + %rax]
    mov       %r12,	%r10
    test      %r10,	%r10
    jz        L1043
    cmp       %r12,	9
    jnz       L1045
    movsxd    %rax,	dword ptr[%r13+16]
    mov       %r12,	%rax
L1045:
    mov       %rax,	[%rip+pc_decls.pinfo]
    movzx     %rax,	byte ptr[%rax+4]
    mov       %r10,	%r12
    cmp       %rax,	%r10
    cmovl     %rax,	%r10
    mov       %r10,	[%rip+pc_decls.pinfo]
    mov       [%r10+4],	%al
L1043:
    movzx     %rax,	byte ptr[%r13+3]
    cmp       %rax,	11
    jnz       L1047
    mov       %rax,	[%rip+pc_decls.pinfo]
    test      %rax,	%rax
    jz        L1047
    mov       %eax,	[%r13+4]
    cmp       %rax,	16
    jz        L1047
    mov       %al,	1
    mov       %r10,	[%rip+pc_decls.pinfo]
    mov       [%r10+7],	%al
L1047:
    movzx     %rax,	byte ptr[%r13]
    cmp       %rax,	135
    jz        L1049
    cmp       %rax,	127
    jz        L1050
    cmp       %rax,	120
    jz        L1051
    cmp       %rax,	121
    jz        L1051
    cmp       %rax,	18
    jz        L1052
    cmp       %rax,	21
    jz        L1052
    cmp       %rax,	19
    jz        L1052
    cmp       %rax,	22
    jz        L1052
    cmp       %rax,	131
    jz        L1053
    cmp       %rax,	122
    jz        L1054
    cmp       %rax,	42
    jz        L1055
    cmp       %rax,	2
    jz        L1056
    cmp       %rax,	5
    jz        L1056
    cmp       %rax,	114
    jz        L1057
    cmp       %rax,	113
    jz        L1058
    cmp       %rax,	1
    jz        L1059
    jmp       L1060
L1049:
    jmp       L1048
L1050:
    mov       %rax,	[%r13+8]
    mov       %r10,	[%rbp + pc_reduce.pcl_reducetest.labelmap]
    mov       %r10w,	[%r10 + %rax*2-2]
    test      %r10w,	%r10w
    jz        L1062
    jmp       L1060
L1062:
    jmp       L1048
L1051:
    inc       qword ptr[%rbp + pc_reduce.pcl_reducetest.nprocs]
    mov       %rax,	[%r13+8]
    mov       [%rbp + pc_reduce.pcl_reducetest.pdef],	%rax
    lea       %rax,	[%r14+32]
    mov       %r10,	[%rbp + pc_reduce.pcl_reducetest.pdef]
    mov       [%r10+56],	%rax
    mov       %rcx,	8
    call      mlib.pcm_alloc
    mov       [%rip+pc_decls.pinfo],	%rax
    mov       %rax,	[%rip+pc_decls.pinfo]
    mov       %r10,	[%rbp + pc_reduce.pcl_reducetest.pdef]
    mov       [%r10+48],	%rax
    mov       %al,	1
    mov       %r10,	[%rip+pc_decls.pinfo]
    mov       [%r10+3],	%al
    mov       %rax,	[%rbp + pc_reduce.pcl_reducetest.pdef]
    mov       %al,	[%rax+112]
    mov       %r10,	[%rip+pc_decls.pinfo]
    mov       [%r10+1],	%al
    mov       %rax,	[%rbp + pc_reduce.pcl_reducetest.pdef]
    mov       %ax,	[%rax+114]
    mov       %r10,	[%rip+pc_decls.pinfo]
    mov       [%r10+2],	%al
    mov       %rax,	[%rbp + pc_reduce.pcl_reducetest.pdef]
    movzx     %rax,	byte ptr[%rax+112]
    add       [%rbp + pc_reduce.pcl_reducetest.nallparams],	%rax
    mov       %rax,	[%rbp + pc_reduce.pcl_reducetest.pdef]
    movsx     %rax,	word ptr[%rax+114]
    add       [%rbp + pc_reduce.pcl_reducetest.nalllocals],	%rax
    xor       %eax,	%eax
    mov       [%rbp + pc_reduce.pcl_reducetest.ncall],	%rax
    lea       %rax,	[%r14+32]
    mov       [%rbp + pc_reduce.pcl_reducetest.pcproc],	%rax
    jmp       L1060
    jmp       L1048
L1052:
    xor       %eax,	%eax
    mov       %r10,	[%rip+pc_decls.pinfo]
    mov       [%r10+3],	%al
    dec       qword ptr[%rbp + pc_reduce.pcl_reducetest.ncall]
    jmp       L1060
    jmp       L1048
L1053:
    add       %r14,	32
    mov       %rax,	%r13
    mov       %r10,	[%rax]
    mov       [%r14],	%r10
    mov       %r10,	[%rax+8]
    mov       [%r14+8],	%r10
    mov       %r10,	[%rax+16]
    mov       [%r14+16],	%r10
    mov       %r10,	[%rax+24]
    mov       [%r14+24],	%r10
    inc       %rbx
    mov       %rax,	%rbx
    lea       %r10,	[%r14+28]
    mov       %r8d,	[%r10]
    mov       %r11,	-4294967041
    shl       %eax,	8
    and       %r8d,	%r11d
    or        %r8d,	%eax
    mov       [%r10],	%r8d
    inc       qword ptr[%rbp + pc_reduce.pcl_reducetest.ncall]
    mov       %rax,	[%rbp + pc_reduce.pcl_reducetest.ncall]
    mov       %r10,	%r14
    mov       [%rbp + %rax*8 + pc_reduce.pcl_reducetest.callstack-8],	%r10
    jmp       L1048
L1054:
    mov       %rax,	[%rip+pc_decls.pinfo]
    mov       %al,	[%rax+3]
    test      %al,	%al
    jz        L1064
    inc       qword ptr[%rbp + pc_reduce.pcl_reducetest.nleaf]
L1064:
    xor       %eax,	%eax
    mov       [%rip+pc_decls.pinfo],	%rax
    jmp       L1060
    jmp       L1048
L1055:
    mov       %al,	1
    mov       %r10,	[%rip+pc_decls.pinfo]
    mov       [%r10+5],	%al
    jmp       L1060
    jmp       L1048
L1056:
    movzx     %rax,	byte ptr[%r14]
    cmp       %rax,	57
    jnz       L1066
    movzx     %rax,	byte ptr[%r13+3]
    cmp       %rax,	11
    jz        L1066
    mov       %al,	[%r13+3]
    mov       [%r14+3],	%al
    movzx     %rax,	byte ptr[%r13]
    cmp       %rax,	2
    jnz       L1068
    mov       %rax,	3
    jmp       L1067
L1068:
    mov       %rax,	6
L1067:
    mov       [%r14],	%al
    jmp       L1065
L1066:
    jmp       L1060
L1065:
    jmp       L1048
L1057:
    movzx     %rax,	byte ptr[%r15]
    cmp       %rax,	113
    jnz       L1070
    movsxd    %rax,	dword ptr[%r13+28]
    and       %rax,	255
    movsxd    %r10,	dword ptr[%r15+28]
    and       %r10,	255
    cmp       %rax,	%r10
    jnz       L1070
    add       %r13,	32
    jmp       L1069
L1070:
    movzx     %rax,	byte ptr[%r15]
    cmp       %rax,	28
    jz        L1072
    cmp       %rax,	27
    jnz       L1071
L1072:
    movsxd    %rax,	dword ptr[%r13+28]
    and       %rax,	255
    mov       [%r15+3],	%al
    jmp       L1069
L1071:
    jmp       L1060
L1069:
    jmp       L1048
L1058:
    movzx     %rax,	byte ptr[%r14]
    cmp       %rax,	1
    jz        L1075
    cmp       %rax,	2
    jz        L1075
    cmp       %rax,	3
    jnz       L1074
L1075:
    movzx     %rax,	byte ptr[%r14+3]
    movsxd    %r10,	dword ptr[%r13+28]
    and       %r10,	255
    cmp       %rax,	%r10
    jz        L1073
L1074:
    jmp       L1060
L1073:
    jmp       L1048
L1059:
    movzx     %rax,	byte ptr[%r13+1]
    cmp       %rax,	4
    jnz       L1077
    movzx     %rax,	byte ptr[%r15]
    movzx     %r10,	byte ptr[%r14]
    cmp       %r10,	%rax
    jnz       L1078
    cmp       %r10,	57
    jnz       L1078
    mov       %rax,	1
    jmp       L1079
L1078:
    xor       %eax,	%eax
L1079:
    test      %rax,	%rax
    setnz     %al
    movzx     %eax,	%al
    test      %ax,	%ax
    jz        L1077
    mov       %rax,	[%r13+8]
    movsxd    %r10,	dword ptr[%r15+16]
    imul      %rax,	%r10
    movsxd    %r10,	dword ptr[%r15+20]
    add       %rax,	%r10
    lea       %r10,	[%r14+20]
    add       [%r10],	%eax
    add       %r13,	32
    jmp       L1076
L1077:
    movzx     %rax,	byte ptr[%r15]
    cmp       %rax,	11
    jnz       L1080
    add       %r13,	32
    jmp       L1076
L1080:
    jmp       L1060
L1076:
    jmp       L1048
L1060:
    add       %r14,	32
    mov       %rax,	%r13
    mov       %r10,	[%rax]
    mov       [%r14],	%r10
    mov       %r10,	[%rax+8]
    mov       [%r14+8],	%r10
    mov       %r10,	[%rax+16]
    mov       [%r14+16],	%r10
    mov       %r10,	[%rax+24]
    mov       [%r14+24],	%r10
    inc       %rbx
    mov       %rax,	%rbx
    lea       %r10,	[%r14+28]
    mov       %r8d,	[%r10]
    mov       %r11,	-4294967041
    shl       %eax,	8
    and       %r8d,	%r11d
    or        %r8d,	%eax
    mov       [%r10],	%r8d
    movzx     %rax,	byte ptr[%r14+1]
    cmp       %rax,	2
    jnz       L1082
    movzx     %rax,	byte ptr[%r14]
    cmp       %rax,	1
    jnz       L1085
    mov       %eax,	[%r14+16]
    test      %eax,	%eax
    jnz       L1084
L1085:
    mov       %rax,	[%r14+8]
    mov       %r10b,	1
    mov       [%rax+88],	%r10b
L1084:
L1082:
L1048:
    add       %r13,	32
    dec       qword ptr[%rbp + pc_reduce.pcl_reducetest.av_1]
    jnz       L1039
L1041:
    mov       [%rip+pc_api.pccurr],	%r14
    mov       %rcx,	[%rbp + pc_reduce.pcl_reducetest.labelmap]
    mov       %rdx,	[%rip+pc_api.mlabelno]
    call      mlib.pcm_free
#---------------
    add       %rsp,	232
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_run_dummy.pcl_runpcl
pc_run_dummy.pcl_runpcl:
#?>>
#?]]
#---------------
#---
#---------------
    ret       
# End 
# Proc mc_genmcl.genmcl
mc_genmcl.genmcl:
#?>>
    .set mc_genmcl.genmcl.dummy, 32
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
    mov       %al,	[%rip+pc_decls.mcldone]
    test      %al,	%al
    jnz       L1087
L1089:
    call      mnoos.os_clock
    mov       %rdi,	%rax
    call      mc_genmcl.inithandlers
    xor       %ecx,	%ecx
    call      mc_libmcl.mclinit
    mov       %rax,	[%rip+pc_api.pcstart]
    mov       [%rip+mc_decls.currpcl],	%rax
    xor       %rbx,	%rbx
L1090:
    mov       %rcx,	[%rip+mc_decls.currpcl]
    call      mc_genmcl.convertpcl
    xor       %eax,	%eax
    test      %ax,	%ax
    jz        L1094
    mov       %rax,	[%rip+mc_decls.currpcl]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	127
    jz        L1094
    cmp       %rax,	135
    jz        L1094
    cmp       %rax,	120
    jz        L1094
    cmp       %rax,	121
    jz        L1094
    cmp       %rax,	20
    jz        L1094
    cmp       %rax,	122
    jz        L1094
    call      mc_stackmcl.showopndstack
L1094:
    add       qword ptr[%rip+mc_decls.currpcl],	32
    mov       %rax,	[%rip+mc_decls.currpcl]
    cmp       %rax,	[%rip+pc_api.pccurr]
    ja        L1095
    mov       %rax,	[%rip+mc_decls.currpcl]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	136
    jnz       L1090
L1095:
    call      mc_auxmcl.genrealtable
    call      mc_auxmcl.genabsneg
    call      mc_auxmcl.genstringtable
    mov       %rcx,	8
    xor       %edx,	%edx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	8
    xor       %edx,	%edx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %al,	[%rip+pc_decls.fpeephole]
    test      %al,	%al
    jz        L1097
    call      mc_optim.peephole
L1097:
    mov       %al,	1
    mov       [%rip+pc_decls.mcldone],	%al
    call      mnoos.os_clock
    sub       %rax,	%rdi
    mov       [%rip+pc_decls.mcltime],	%rax
L1087:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.convertpcl
mc_genmcl.convertpcl:
#?>>
    .set mc_genmcl.convertpcl.oldregset, -16
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	56
    mov       %rsi,	%rcx
#---------------
    mov       %al,	[%rip+pc_decls.fshowil]
    test      %al,	%al
    jz        L1100
    mov       %rcx,	%rsi
    call      mc_genmcl.doshowpcl
L1100:
    mov       %al,	[%rsi+3]
    mov       [%rip+mc_decls.pmode],	%al
    mov       [%rip+mc_decls.currpcl],	%rsi
    mov       %eax,	[%rsi+24]
    mov       [%rip+pc_decls.mmpos],	%rax
    movsxd    %rax,	dword ptr[%rsi+28]
    shr       %rax,	8
    and       %rax,	16777215
    mov       [%rip+pc_decls.ppseqno],	%rax
    movzx     %rax,	byte ptr[%rsi]
    lea       %r10,	[%rip+mc_genmcl.px_handlertable]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%rsi
    call      %r10
    lea       %rax,	[%rip+mc_decls.regset]
    lea       %r10,	[%rbp + mc_genmcl.convertpcl.oldregset]
    movdqu    %XMM4,	[%rax]
    movdqu    [%r10],	%XMM4
    lea       %rax,	[%rip+mc_decls.regset]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    lea       %rax,	[%rip+mc_decls.xregset]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    mov       %rbx,	1
    mov       %rax,	[%rip+mc_decls.noperands]
    cmp       %rax,	1
    jl        L1103
L1101:
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L1105
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	2
    jg        L1107
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.xregset]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    jmp       L1106
L1107:
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.regset]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
L1106:
L1105:
    inc       %rbx
    cmp       %rbx,	[%rip+mc_decls.noperands]
    jle       L1101
L1103:
    mov       %rax,	[%rbp + mc_genmcl.convertpcl.oldregset]
    lea       %r10,	[%rip+mc_decls.regset]
    mov       %r10,	[%r10]
    lea       %r11,	[%rip+mc_decls.isregvar]
    mov       %r11,	[%r11]
    or        %r10,	%r11
    mov       %r11,	72340172838076673
    xor       %r10,	%r11
    and       %rax,	%r10
    mov       %r10,	[%rip+mc_decls.mccodex]
    lea       %r10,	[%r10+48]
    or        [%r10],	%rax
    mov       %rax,	[%rbp + mc_genmcl.convertpcl.oldregset+8]
    lea       %r10,	[%rip+mc_decls.regset]
    mov       %r10,	[%r10+8]
    lea       %r11,	[%rip+mc_decls.isregvar]
    mov       %r11,	[%r11+8]
    or        %r10,	%r11
    mov       %r11,	72340172838076673
    xor       %r10,	%r11
    and       %rax,	%r10
    mov       %r10,	[%rip+mc_decls.mccodex]
    lea       %r10,	[%r10+56]
    or        [%r10],	%rax
#---------------
    add       %rsp,	56
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.inithandlers
mc_genmcl.inithandlers:
#?>>
    .set mc_genmcl.inithandlers.k, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
#---------------
    mov       %al,	[%rip+mc_genmcl.inithandlers.initdone]
    test      %al,	%al
    jnz       L1108
L1110:
    mov       %rsi,	[%rip+$nprocs]
    mov       %r15,	1
    cmp       %rsi,	1
    jl        L1113
L1111:
    lea       %rax,	[%rip+$procname]
    mov       %r10,	%r15
    mov       %rdi,	[%rax + %r10*8-8]
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8128]
    mov       %r8,	3
    call      mlib.eqbytes
    test      %rax,	%rax
    jz        L1115
    xor       %eax,	%eax
    mov       [%rbp + mc_genmcl.inithandlers.k],	%rax
    mov       %r12,	142
    cmp       %r12,	0
    jl        L1119
L1116:
    lea       %rax,	[%rip+pc_tables.pclnames]
    mov       %r10,	[%rbp + mc_genmcl.inithandlers.k]
    mov       %rbx,	[%rax + %r10*8]
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	107
    jnz       L1121
    inc       %rbx
L1121:
    lea       %rax,	[%rdi+3]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L1123
    lea       %rax,	[%rip+$procaddr]
    mov       %r10,	%r15
    mov       %rax,	[%rax + %r10*8-8]
    lea       %r10,	[%rip+mc_genmcl.px_handlertable]
    mov       %r11,	[%rbp + mc_genmcl.inithandlers.k]
    mov       [%r10 + %r11*8],	%rax
    jmp       L1118
L1123:
    mov       %rax,	[%rbp + mc_genmcl.inithandlers.k]
    inc       %rax
    mov       [%rbp + mc_genmcl.inithandlers.k],	%rax
    cmp       %rax,	%r12
    jle       L1116
L1119:
    lea       %rcx,	[%rip+L8129]
    mov       %rdx,	%rdi
    call      pc_api.merror
L1118:
L1115:
    inc       %r15
    cmp       %r15,	%rsi
    jle       L1111
L1113:
    mov       %r15,	1
    mov       %r13,	9
    cmp       %r13,	1
    jl        L1126
L1124:
    lea       %rax,	[%rip+mc_genmcl.inithandlers.dupltable]
    mov       %r10,	%r15
    lea       %rax,	[%rax + %r10*2-2]
    movzx     %rax,	byte ptr[%rax+1]
    lea       %r10,	[%rip+mc_genmcl.px_handlertable]
    mov       %r10,	[%r10 + %rax*8]
    lea       %rax,	[%rip+mc_genmcl.inithandlers.dupltable]
    mov       %r11,	%r15
    lea       %rax,	[%rax + %r11*2-2]
    movzx     %rax,	byte ptr[%rax]
    lea       %r11,	[%rip+mc_genmcl.px_handlertable]
    mov       [%r11 + %rax*8],	%r10
    inc       %r15
    cmp       %r15,	%r13
    jle       L1124
L1126:
    xor       %r15,	%r15
    mov       %rax,	142
    mov       %r14,	%rax
    cmp       %r14,	0
    jl        L1129
L1127:
    lea       %rax,	[%rip+mc_genmcl.px_handlertable]
    mov       %r10,	%r15
    mov       %rax,	[%rax + %r10*8]
    test      %rax,	%rax
    jnz       L1131
    lea       %rax,	[%rip+mc_genmcl.unimpl]
    lea       %r10,	[%rip+mc_genmcl.px_handlertable]
    mov       %r11,	%r15
    mov       [%r10 + %r11*8],	%rax
L1131:
    inc       %r15
    cmp       %r15,	%r14
    jle       L1127
L1129:
    mov       %al,	1
    mov       [%rip+mc_genmcl.inithandlers.initdone],	%al
L1108:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.doshowpcl
mc_genmcl.doshowpcl:
#?>>
    .set mc_genmcl.doshowpcl.str, -1256
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	1288
    mov       %rdi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rdi]
    cmp       %rax,	120
    jz        L1134
    cmp       %rax,	121
    jz        L1134
    cmp       %rax,	122
    jz        L1134
    cmp       %rax,	123
    jz        L1134
    cmp       %rax,	124
    jz        L1134
    cmp       %rax,	125
    jnz       L1135
L1134:
    jmp       L1133
L1135:
    lea       %rcx,	[%rbp + mc_genmcl.doshowpcl.str]
    lea       %rdx,	[%rip+L8130]
    call      strcpy
    mov       %rcx,	%rdi
    mov       %rdx,	1256
    call      pc_diags_dummy.strpclstr
    lea       %rcx,	[%rbp + mc_genmcl.doshowpcl.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rcx,	[%rbp + mc_genmcl.doshowpcl.str]
    call      mlib.pcm_copyheapstring
    mov       %rcx,	%rax
    call      mc_libmcl.mgencomment
L1133:
#---------------
    add       %rsp,	1288
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.unimpl
mc_genmcl.unimpl:
#?>>
    .set mc_genmcl.unimpl.str, -104
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	136
    mov       %rdi,	%rcx
#---------------
    lea       %rcx,	[%rbp + mc_genmcl.unimpl.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8131]
    call      msys.m$print_setfmt
    movzx     %rax,	byte ptr[%rdi]
    lea       %r10,	[%rip+pc_tables.pclnames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      pc_api.strpmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       %rcx,	[%rbp + mc_genmcl.unimpl.str]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rbp + mc_genmcl.unimpl.str]
    call      mlib.pcm_copyheapstring
    mov       %rcx,	%rax
    call      mc_libmcl.mgencomment
#---------------
    add       %rsp,	136
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_nop
mc_genmcl.px_nop:
#?>>
    .set mc_genmcl.px_nop.p, 16
#?]]
#---------------
#---
#---------------
    ret       
# End 
# Proc mc_genmcl.px_dupl
mc_genmcl.px_dupl:
#?>>
    .set mc_genmcl.px_dupl.p, 16
#?]]
    sub       %rsp,	40
#---------------
    call      mc_stackmcl.duplpcl
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_genmcl.px_double
mc_genmcl.px_double:
#?>>
    .set mc_genmcl.px_double.p, 16
#?]]
    sub       %rsp,	40
#---------------
    mov       %rax,	[%rip+mc_decls.ncalldepth]
    test      %rax,	%rax
    jz        L1141
    call      mc_stackmcl.duplpcl
    jmp       L1140
L1141:
    lea       %rax,	[%rip+mc_decls.pclcount]
    mov       %r10,	[%rip+mc_decls.noperands]
    lea       %rax,	[%rax + %r10-1]
    inc       byte ptr[%rax]
L1140:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_genmcl.px_opnd
mc_genmcl.px_opnd:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      mc_genmcl.unimpl
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_type
mc_genmcl.px_type:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      mc_genmcl.unimpl
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_comment
mc_genmcl.px_comment:
#?>>
    .set mc_genmcl.px_comment.p, 16
#?]]
#---------------
#---
#---------------
    ret       
# End 
# Proc mc_genmcl.px_proc
mc_genmcl.px_proc:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	[%rdi+8]
    mov       [%rip+pc_decls.currfunc],	%rax
    mov       %rcx,	67
    mov       %rdx,	1
    call      mc_libmcl.setsegment
    mov       %rcx,	[%rip+pc_decls.currfunc]
    call      mc_libmcl.mgenmemaddr
    mov       %rcx,	1
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	[%rip+pc_decls.currfunc]
    call      mc_libmcl.mgenmemaddr
    mov       %rcx,	4
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	[%rip+pc_decls.currfunc]
    call      mc_auxmcl.initproc
    lea       %rcx,	[%rip+L8132]
    call      mc_libmcl.mgencomment
    mov       %rax,	[%rip+mc_decls.mccodex]
    mov       [%rip+mc_decls.mclprocentry],	%rax
    mov       %rax,	[%rip+pc_decls.currfunc]
    movzx     %rax,	byte ptr[%rax+112]
    cmp       %rax,	2
    jnz       L1147
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %al,	[%rax+83]
    test      %al,	%al
    jz        L1147
    mov       %al,	[%rip+pepcl.pdcc]
    test      %al,	%al
    jnz       L1147
    call      mc_auxmcl.fixmain
L1147:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_endproc
mc_genmcl.px_endproc:
#?>>
    .set mc_genmcl.px_endproc.p, 16
#?]]
    sub       %rsp,	40
#---------------
    mov       %rax,	[%rip+mc_decls.noperands]
    test      %rax,	%rax
    jz        L1150
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8133]
    call      msys.m$print_str_nf
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8133]
    call      mc_libmcl.mgencomment
L1150:
    mov       %rcx,	2
    xor       %edx,	%edx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_genmcl.px_endprog
mc_genmcl.px_endprog:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      mc_genmcl.unimpl
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_istatic
mc_genmcl.px_istatic:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%rdi+16]
    mov       %rcx,	73
    mov       %rdx,	%rax
    call      mc_libmcl.setsegment
    mov       %rax,	[%rdi+8]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenmemaddr
    mov       %rcx,	4
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_zstatic
mc_genmcl.px_zstatic:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rdi,	[%rbx+8]
    movsxd    %rax,	dword ptr[%rbx+16]
    mov       %rcx,	90
    mov       %rdx,	%rax
    call      mc_libmcl.setsegment
    mov       %rcx,	%rdi
    call      mc_libmcl.mgenmemaddr
    mov       %rcx,	4
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %eax,	[%rbx+4]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	125
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_data
mc_genmcl.px_data:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rsi+3]
    cmp       %rax,	11
    jnz       L1156
    mov       %rcx,	%rsi
    call      mc_auxmcl.do_blockdata
    jmp       L1154
L1156:
    movzx     %rax,	byte ptr[%rsi+1]
    cmp       %rax,	4
    jz        L1158
    cmp       %rax,	10
    jz        L1159
    cmp       %rax,	11
    jz        L1160
    cmp       %rax,	6
    jz        L1161
    cmp       %rax,	7
    jz        L1162
    cmp       %rax,	2
    jz        L1163
    cmp       %rax,	3
    jz        L1164
    jmp       L1165
L1158:
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rdi,	%rax
    jmp       L1157
L1159:
    movq      %XMM4,	[%rsi+8]
    movq      %XMM0,	%XMM4
    mov       %rdx,	2
    call      mc_libmcl.mgenrealimm
    mov       %rdi,	%rax
    jmp       L1157
L1160:
    movq      %XMM4,	[%rsi+8]
    movq      %XMM0,	%XMM4
    mov       %rdx,	1
    call      mc_libmcl.mgenrealimm
    mov       %rdi,	%rax
    jmp       L1157
L1161:
    movq      %XMM4,	[%rsi+8]
    movq      %XMM0,	%XMM4
    mov       %rdx,	1
    call      mc_libmcl.mgenrealimm
    mov       %rdi,	%rax
    jmp       L1157
L1162:
    mov       %eax,	[%rsi+16]
    mov       %r10,	[%rsi+8]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_libmcl.getstringindex
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %rdi,	%rax
    jmp       L1157
L1163:
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenmemaddr
    mov       %rdi,	%rax
    mov       %eax,	[%rsi+20]
    mov       [%rdi+12],	%eax
    jmp       L1157
L1164:
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %rdi,	%rax
    jmp       L1157
L1165:
    movzx     %rax,	byte ptr[%rsi+1]
    lea       %r10,	[%rip+pc_tables.opndnames]
    mov       %r10,	[%r10 + %rax*8]
    lea       %rcx,	[%rip+L8134]
    mov       %rdx,	%r10
    call      pc_api.merror
L1157:
    mov       %eax,	[%rsi+4]
    cmp       %rax,	1
    jz        L1167
    cmp       %rax,	2
    jz        L1168
    cmp       %rax,	4
    jz        L1169
    cmp       %rax,	8
    jz        L1170
    jmp       L1171
L1167:
    mov       %rbx,	116
    jmp       L1166
L1168:
    mov       %rbx,	117
    jmp       L1166
L1169:
    mov       %rbx,	118
    jmp       L1166
L1170:
    mov       %rbx,	119
    jmp       L1166
L1171:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8135]
    call      msys.m$print_str_nf
    mov       %eax,	[%rsi+4]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    lea       %rcx,	[%rip+L8136]
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rsi+3]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      pc_api.strpmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8137]
    lea       %rdx,	[%rip+L8138]
    call      pc_api.merror
L1166:
    mov       %rcx,	%rbx
    mov       %rdx,	%rdi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L1154:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_label
mc_genmcl.px_label:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	[%rdi+8]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_load
mc_genmcl.px_load:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      mc_stackmcl.pushpcl
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_store
mc_genmcl.px_store:
#?>>
    .set mc_genmcl.px_store.$T1, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %r12,	%rcx
#---------------
    movzx     %rax,	byte ptr[%r12+3]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%r12+3]
    cmp       %rax,	11
    jz        L1176
    movzx     %rax,	byte ptr[%r12+3]
    mov       %r10,	[%r12+8]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_libmcl.mgenmem
    mov       %rdi,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    jmp       L1175
L1176:
    mov       %rcx,	6
    call      mc_stackmcl.getworkregm
    mov       %rdi,	%rax
    mov       %rsi,	[%r12+8]
    mov       %rcx,	%rsi
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       [%rbp + mc_genmcl.px_store.$T1],	%rax
    movzx     %rax,	byte ptr[%rsi+72]
    cmp       %rax,	5
    jnz       L1178
    mov       %rax,	11
    jmp       L1177
L1178:
    mov       %rax,	14
L1177:
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    mov       %r8,	[%rbp + mc_genmcl.px_store.$T1]
    call      mc_libmcl.genmc
    mov       %rcx,	%rdi
    mov       %rdx,	6
    call      mc_stackmcl.makeopndind
    mov       %rdi,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	6
    call      mc_stackmcl.makeopndind
    mov       %rbx,	%rax
    mov       %eax,	[%r12+4]
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    mov       %r9,	1
    call      mc_auxmcl.copyblock
L1175:
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_add
mc_genmcl.px_add:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rsi+3]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rsi+3]
    cmp       %rax,	2
    jle       L1181
    mov       %rcx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.isimmload
    test      %rax,	%rax
    jz        L1183
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	[%rip+mc_decls.noperands]
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rax,	[%rax+8]
    cmp       %rax,	1
    jnz       L1183
    mov       %rcx,	52
    mov       %rdx,	%rdi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L1182
L1183:
    movzx     %rax,	byte ptr[%rsi+3]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    mov       %rcx,	28
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L1182:
    jmp       L1180
L1181:
    movzx     %rax,	byte ptr[%rsi+3]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rsi+3]
    dec       %rax
    mov       %r10,	65
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L1180:
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_sub
mc_genmcl.px_sub:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rsi+3]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rsi+3]
    cmp       %rax,	2
    jle       L1186
    mov       %rcx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.isimmload
    test      %rax,	%rax
    jz        L1188
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	[%rip+mc_decls.noperands]
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rax,	[%rax+8]
    cmp       %rax,	1
    jnz       L1188
    mov       %rcx,	53
    mov       %rdx,	%rdi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L1187
L1188:
    movzx     %rax,	byte ptr[%rsi+3]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    mov       %rcx,	29
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L1187:
    jmp       L1185
L1186:
    movzx     %rax,	byte ptr[%rsi+3]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rsi+3]
    dec       %rax
    mov       %r10,	67
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L1185:
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_mul
mc_genmcl.px_mul:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rsi+3]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rsi+3]
    cmp       %rax,	2
    jle       L1191
    mov       %rcx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.isimmload
    test      %rax,	%rax
    jz        L1193
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	[%rip+mc_decls.noperands]
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rax,	[%rax+8]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mc_auxmcl.mulimm
    jmp       L1192
L1193:
    movzx     %rax,	byte ptr[%rsi+3]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    mov       %rcx,	34
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L1192:
    jmp       L1190
L1191:
    movzx     %rax,	byte ptr[%rsi+3]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rsi+3]
    dec       %rax
    mov       %r10,	69
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L1190:
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_div
mc_genmcl.px_div:
#?>>
    .set mc_genmcl.px_div.p, 32
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    dec       %rax
    mov       %r10,	71
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_eval
mc_genmcl.px_eval:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rdi+3]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_widen
mc_genmcl.px_widen:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	6
    jnz       L1198
    movsxd    %rax,	dword ptr[%rsi+28]
    and       %rax,	255
    cmp       %rax,	5
    jnz       L1198
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	5
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    mov       %rax,	[%rip+mc_decls.mccodex]
    movzx     %rax,	byte ptr[%rax+33]
    cmp       %rax,	11
    jz        L1200
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
L1200:
    jmp       L1197
L1198:
    movsxd    %rax,	dword ptr[%rsi+28]
    and       %rax,	255
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rax
    call      mc_stackmcl.getworkregm
    mov       %rdi,	%rax
    movsxd    %rax,	dword ptr[%rsi+28]
    and       %rax,	255
    lea       %r10,	[%rip+pc_tables.psigned]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1202
    mov       %rax,	18
    jmp       L1201
L1202:
    mov       %rax,	19
L1201:
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    movzx     %r10,	byte ptr[%rdi+10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_stackmcl.setnewzz
L1197:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_jump
mc_genmcl.px_jump:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    mov       %rdi,	[%rsi+8]
    lea       %rax,	[%rsi+32]
    mov       %rbx,	%rax
    jmp       L1205
L1204:
    add       %rbx,	32
L1205:
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	135
    jz        L1204
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	127
    jz        L1208
    cmp       %rax,	24
    jz        L1209
    jmp       L1210
L1208:
    mov       %rax,	[%rbx+8]
    cmp       %rax,	%rdi
    jz        L1203
L1212:
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	127
    jnz       L1214
    mov       %rax,	[%rbx+8]
    cmp       %rax,	%rdi
    jz        L1203
L1214:
    jmp       L1207
L1209:
    xor       %eax,	%eax
    mov       [%rbx],	%al
L1210:
L1207:
    mov       %rcx,	%rdi
    call      mc_libmcl.mgenlabel
    mov       %rcx,	25
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L1203:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_ijump
mc_genmcl.px_ijump:
#?>>
    .set mc_genmcl.px_ijump.p, 16
#?]]
    sub       %rsp,	40
#---------------
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rcx,	25
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_genmcl.px_neg
mc_genmcl.px_neg:
#?>>
    .set mc_genmcl.px_neg.p, 24
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jle       L1218
    mov       %rcx,	50
    mov       %rdx,	%rdi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L1217
L1218:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mc_auxmcl.do_negreal
L1217:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_abs
mc_genmcl.px_abs:
#?>>
    .set mc_genmcl.px_abs.p, 32
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jle       L1221
    xor       %ecx,	%ecx
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	42
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rax,	[%rip+pc_api.mlabelno]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %r10,	%rax
    mov       %rbx,	%r10
    mov       %rcx,	26
    mov       %rdx,	13
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    mov       %rcx,	50
    mov       %rdx,	%rdi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	9
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L1220
L1221:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mc_auxmcl.do_absreal
L1220:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_bitnot
mc_genmcl.px_bitnot:
#?>>
    .set mc_genmcl.px_bitnot.p, 24
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    mov       %rcx,	51
    mov       %rdx,	%rdi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_not
mc_genmcl.px_not:
#?>>
    .set mc_genmcl.px_not.p, 24
    .set mc_genmcl.px_not.$T1, -8
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    mov       %rcx,	1
    mov       %rdx,	3
    call      mc_libmcl.mgenint
    mov       [%rbp + mc_genmcl.px_not.$T1],	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      mc_libmcl.changeopndsize
    mov       %rcx,	40
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_genmcl.px_not.$T1]
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_toboolt
mc_genmcl.px_toboolt:
#?>>
    .set mc_genmcl.px_toboolt.$T2, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %r13,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%r13+28]
    and       %rax,	255
    mov       %r12b,	%al
    movzx     %rax,	%r12b
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	%r12b
    cmp       %rax,	2
    jg        L1226
    movzx     %rax,	%r12b
    mov       %rcx,	%rax
    call      mc_stackmcl.getworkregm
    mov       %rbx,	%rax
    mov       %rcx,	3
    call      mc_stackmcl.getworkregm
    mov       %rsi,	%rax
    movzx     %rax,	%r12b
    dec       %rax
    mov       %r10,	76
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rbx
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    movzx     %rax,	%r12b
    dec       %rax
    mov       %r10,	73
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%r13]
    cmp       %rax,	64
    jnz       L1228
    mov       %rax,	5
    jmp       L1227
L1228:
    mov       %rax,	4
L1227:
    mov       %rcx,	58
    mov       %rdx,	%rax
    mov       %r8,	%rsi
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    mov       %rcx,	%rsi
    mov       %rdx,	4
    call      mc_libmcl.changeopndsize
    mov       %rcx,	19
    mov       %rdx,	%rax
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    movzx     %r10,	byte ptr[%rsi+10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_stackmcl.setnewzz
    jmp       L1225
L1226:
    mov       %rcx,	41
    mov       %rdx,	%rdi
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      mc_libmcl.changeopndsize
    mov       %r10,	%rax
    mov       %rbx,	%r10
    mov       [%rbp + mc_genmcl.px_toboolt.$T2],	%rax
    movzx     %rax,	byte ptr[%r13]
    cmp       %rax,	64
    jnz       L1230
    mov       %rax,	5
    jmp       L1229
L1230:
    mov       %rax,	4
L1229:
    mov       %rcx,	58
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_genmcl.px_toboolt.$T2]
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    mov       %rcx,	%rdi
    mov       %rdx,	4
    call      mc_libmcl.changeopndsize
    mov       %rcx,	19
    mov       %rdx,	%rax
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    mov       %al,	[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+mc_decls.pclmode]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11-3],	%al
L1225:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_sqr
mc_genmcl.px_sqr:
#?>>
    .set mc_genmcl.px_sqr.p, 24
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jle       L1233
    mov       %rcx,	34
    mov       %rdx,	%rdi
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    jmp       L1232
L1233:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    dec       %rax
    mov       %r10,	69
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rdi
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
L1232:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_sqrt
mc_genmcl.px_sqrt:
#?>>
    .set mc_genmcl.px_sqrt.p, 24
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    dec       %rax
    mov       %r10,	63
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rdi
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_jumpcc
mc_genmcl.px_jumpcc:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
#---------------
    movzx     %rax,	byte ptr[%r13+2]
    lea       %r10,	[%rip+mc_genmcl.ucondcodes]
    movzx     %r10,	byte ptr[%r10 + %rax-1]
    mov       %rdi,	%r10
    mov       %rax,	[%r13+8]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %r12,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	11
    jnz       L1237
    lea       %rcx,	[%rip+L8139]
    lea       %rdx,	[%rip+L8140]
    call      pc_api.merror
    jmp       L1236
L1237:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jle       L1239
    mov       %rcx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.isimmload
    test      %rax,	%rax
    jz        L1241
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	[%rip+mc_decls.noperands]
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rax,	[%rax+8]
    test      %rax,	%rax
    jnz       L1241
    movzx     %rax,	byte ptr[%r13+2]
    cmp       %rax,	1
    jz        L1242
    cmp       %rax,	2
    jnz       L1241
L1242:
    mov       %rcx,	41
    mov       %rdx,	%rbx
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    jmp       L1240
L1241:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rsi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.psigned]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1244
    movzx     %rax,	byte ptr[%r13+2]
    lea       %r10,	[%rip+mc_genmcl.scondcodes]
    movzx     %r10,	byte ptr[%r10 + %rax-1]
    mov       %rdi,	%r10
L1244:
    mov       %rcx,	42
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
L1240:
    jmp       L1238
L1239:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rsi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    dec       %rax
    mov       %r10,	73
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
L1238:
    mov       %rcx,	26
    mov       %rdx,	%rdi
    mov       %r8,	%r12
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    call      mc_stackmcl.poppcl
    mov       %eax,	[%r13+16]
    test      %eax,	%eax
    jnz       L1246
    call      mc_stackmcl.poppcl
L1246:
L1236:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_jumpt
mc_genmcl.px_jumpt:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	5
    call      mc_auxmcl.do_jumptruefalse
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_jumpf
mc_genmcl.px_jumpf:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	4
    call      mc_auxmcl.do_jumptruefalse
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_bitand
mc_genmcl.px_bitand:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	38
    call      mc_auxmcl.do_bitwise
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_bitor
mc_genmcl.px_bitor:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	39
    call      mc_auxmcl.do_bitwise
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_bitxor
mc_genmcl.px_bitxor:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	40
    call      mc_auxmcl.do_bitwise
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_shl
mc_genmcl.px_shl:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	43
    call      mc_auxmcl.do_shift
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_shr
mc_genmcl.px_shr:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.psigned]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1255
    mov       %rax,	44
    jmp       L1254
L1255:
    mov       %rax,	45
L1254:
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mc_auxmcl.do_shift
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_retproc
mc_genmcl.px_retproc:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	[%rip+mc_decls.mclprocentry]
    cmp       %rax,	[%rip+mc_decls.mccodex]
    jnz       L1258
    lea       %rcx,	[%rip+L8141]
    call      mc_libmcl.mgencomment
L1258:
    mov       %rcx,	%rdi
    call      mc_auxmcl.do_procentry
    call      mc_auxmcl.do_procexit
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_retfn
mc_genmcl.px_retfn:
#?>>
    .set mc_genmcl.px_retfn.$T1, -8
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %rsi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	11
    jnz       L1261
    mov       %rcx,	1
    mov       %rdx,	10
    xor       %r8d,	%r8d
    call      mc_libmcl.mgenireg
    mov       %rbx,	%rax
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.regset]
    mov       [%r10],	%al
    mov       %rcx,	6
    call      mc_stackmcl.getworkregm
    mov       %rdi,	%rax
    mov       %rcx,	[%rip+pc_decls.blockretname]
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rdi+10]
    mov       %rcx,	%rax
    mov       %rdx,	10
    xor       %r8d,	%r8d
    call      mc_libmcl.mgenireg
    mov       %rdi,	%rax
    mov       %eax,	[%rsi+4]
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    mov       %r9,	1
    call      mc_auxmcl.copyblock
    mov       %rcx,	[%rip+pc_decls.blockretname]
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       [%rbp + mc_genmcl.px_retfn.$T1],	%rax
    mov       %rcx,	1
    mov       %rdx,	6
    call      mc_libmcl.mgenreg
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_genmcl.px_retfn.$T1]
    call      mc_libmcl.genmc
L1261:
    mov       %rcx,	%rsi
    call      mc_genmcl.px_retproc
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_setcall
mc_genmcl.px_setcall:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    xor       %ecx,	%ecx
    call      mc_stackmcl.saveopnds
    mov       %rax,	[%rip+mc_decls.ncalldepth]
    cmp       %rax,	16
    jl        L1264
    lea       %rcx,	[%rip+L8142]
    lea       %rdx,	[%rip+L8143]
    call      pc_api.merror
L1264:
    inc       qword ptr[%rip+mc_decls.ncalldepth]
    movsxd    %rax,	dword ptr[%rdi+16]
    cmp       %rax,	4
    jg        L1266
    mov       %eax,	[%rip+mc_decls.mstackdepth]
    and       %eax,	1
    lea       %r10,	[%rip+mc_decls.callalign]
    mov       %r11,	[%rip+mc_decls.ncalldepth]
    mov       [%r10 + %r11-1],	%al
    jmp       L1265
L1266:
    movsxd    %rax,	dword ptr[%rdi+16]
    and       %eax,	1
    mov       %r10d,	[%rip+mc_decls.mstackdepth]
    and       %r10d,	1
    xor       %rax,	%r10
    lea       %r10,	[%rip+mc_decls.callalign]
    mov       %r11,	[%rip+mc_decls.ncalldepth]
    mov       [%r10 + %r11-1],	%al
L1265:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	11
    setz      %al
    movzx     %eax,	%al
    lea       %r10,	[%rip+mc_decls.callblockret]
    mov       %r11,	[%rip+mc_decls.ncalldepth]
    mov       [%r10 + %r11-1],	%al
    mov       %eax,	[%rdi+4]
    lea       %r10,	[%rip+mc_decls.callblocksize]
    mov       %r11,	[%rip+mc_decls.ncalldepth]
    mov       [%r10 + %r11*4-4],	%eax
    lea       %rax,	[%rip+mc_decls.callalign]
    mov       %r10,	[%rip+mc_decls.ncalldepth]
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L1268
    mov       %rcx,	1
    call      mc_libmcl.pushslots
L1268:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_setarg
mc_genmcl.px_setarg:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%rbx+16]
    lea       %r10,	[%rip+mc_decls.callblockret]
    mov       %r11,	[%rip+mc_decls.ncalldepth]
    movzx     %r10,	byte ptr[%r10 + %r11-1]
    add       %rax,	%r10
    mov       %rdi,	%rax
    lea       %rax,	[%rip+mc_decls.callargmode]
    mov       %r10,	[%rip+mc_decls.ncalldepth]
    shl       %r10,	5
    lea       %rax,	[%rax + %r10-32]
    mov       %r10b,	[%rip+mc_decls.pmode]
    mov       %r11,	%rdi
    mov       [%rax + %r11-1],	%r10b
    mov       %eax,	[%rbx+4]
    lea       %r10,	[%rip+mc_decls.callargsize]
    mov       %r11,	[%rip+mc_decls.ncalldepth]
    shl       %r11,	7
    lea       %r10,	[%r10 + %r11-128]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*4-4],	%eax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	11
    jnz       L1271
    mov       %al,	6
    lea       %r10,	[%rip+mc_decls.pclmode]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11-1],	%al
    jmp       L1270
L1271:
    mov       %al,	[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+mc_decls.pclmode]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11-1],	%al
L1270:
    cmp       %rdi,	4
    jle       L1273
    mov       %eax,	[%rbx+4]
    movzx     %r10,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%r10
    mov       %r8,	%rax
    call      mc_stackmcl.pushopnd
    jmp       L1272
L1273:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	11
    jnz       L1274
    mov       %eax,	[%rbx+4]
    lea       %r10,	[%rip+mc_decls.callargsize]
    mov       %r11,	[%rip+mc_decls.ncalldepth]
    shl       %r11,	7
    lea       %r10,	[%r10 + %r11-128]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*4-4],	%eax
L1274:
L1272:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_callp
mc_genmcl.px_callp:
#?>>
    .set mc_genmcl.px_callp.p, 64
    .set mc_genmcl.px_callp.av_1, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       [%rbp+64],	%rcx
#---------------
    xor       %r12,	%r12
    xor       %eax,	%eax
    mov       %r13,	%rax
    lea       %rax,	[%rip+mc_decls.callblockret]
    mov       %r10,	[%rip+mc_decls.ncalldepth]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %r14,	%rax
    mov       %rax,	[%rbp + mc_genmcl.px_callp.p]
    movsxd    %rax,	dword ptr[%rax+16]
    add       %rax,	%r14
    mov       %rdi,	%rax
    mov       %rax,	%rdi
    mov       %r10,	4
    cmp       %rax,	%r10
    cmovg     %rax,	%r10
    mov       %rbx,	%rax
    mov       %rax,	[%rbp + mc_genmcl.px_callp.p]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	19
    jz        L1278
    cmp       %rax,	22
    jnz       L1277
L1278:
    mov       %r12,	1
L1277:
    mov       %rax,	[%rbp + mc_genmcl.px_callp.p]
    movsxd    %rax,	dword ptr[%rax+20]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    mov       %r8,	%r12
    xor       %r9d,	%r9d
    call      mc_auxmcl.do_pushlowargs
    xor       %rsi,	%rsi
    mov       %rax,	%rdi
    cmp       %rax,	4
    jg        L1280
    mov       %rax,	[%rip+mc_decls.mstackdepth]
    test      %rax,	%rax
    jz        L1282
    mov       %rax,	4
    add       %rsi,	%rax
    mov       %rcx,	4
    call      mc_libmcl.pushslots
    lea       %rax,	[%rip+mc_decls.callalign]
    mov       %r10,	[%rip+mc_decls.ncalldepth]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    add       %rsi,	%rax
    jmp       L1281
L1282:
    mov       %al,	1
    mov       [%rip+pc_decls.localshadow],	%al
L1281:
    jmp       L1279
L1280:
    lea       %rax,	[%rip+mc_decls.callalign]
    mov       %r10,	[%rip+mc_decls.ncalldepth]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %r10,	%rdi
    add       %r10,	%rax
    mov       %rsi,	%r10
    mov       %rcx,	4
    call      mc_libmcl.pushslots
L1279:
    test      %r12,	%r12
    jz        L1284
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rcx,	21
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    jmp       L1283
L1284:
    mov       %rax,	[%rbp + mc_genmcl.px_callp.p]
    mov       %rax,	[%rax+8]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenmemaddr
    mov       %rcx,	21
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L1283:
    mov       %rax,	%rbx
    sub       %rax,	%r14
    mov       [%rbp + mc_genmcl.px_callp.av_1],	%rax
    mov       %rax,	[%rbp + mc_genmcl.px_callp.av_1]
    cmp       %rax,	0
    jle       L1287
L1285:
    call      mc_stackmcl.poppcl
    dec       qword ptr[%rbp + mc_genmcl.px_callp.av_1]
    jnz       L1285
L1287:
    test      %rsi,	%rsi
    jz        L1289
    mov       %rcx,	%rsi
    call      mc_libmcl.popslots
L1289:
    mov       %al,	[%rip+mc_decls.pmode]
    test      %al,	%al
    jz        L1291
    mov       %rcx,	[%rbp + mc_genmcl.px_callp.p]
    call      mc_auxmcl.do_getretvalue
L1291:
    dec       qword ptr[%rip+mc_decls.ncalldepth]
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_jumpret
mc_genmcl.px_jumpret:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %al,	[%rip+mc_decls.pmode]
    test      %al,	%al
    jz        L1294
    mov       %rax,	[%rip+mc_decls.noperands]
    test      %rax,	%rax
    jz        L1296
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    mov       %r8,	1
    call      mc_stackmcl.loadparam
    call      mc_stackmcl.poppcl
L1296:
L1294:
    mov       %rcx,	%rdi
    call      mc_genmcl.px_jump
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_jumpretm
mc_genmcl.px_jumpretm:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%r13+16]
    mov       %r10,	[%rip+mc_decls.noperands]
    sub       %r10,	%rax
    inc       %r10
    mov       %rdi,	%r10
    movsxd    %rax,	dword ptr[%r13+16]
    mov       %rsi,	%rax
    cmp       %rsi,	0
    jle       L1300
L1298:
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    inc       %rdi
    dec       %rsi
    jnz       L1298
L1300:
    mov       %rbx,	1
    movsxd    %rax,	dword ptr[%r13+16]
    mov       %r12,	%rax
    cmp       %r12,	0
    jle       L1303
L1301:
    cmp       %rbx,	4
    jnz       L1305
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	2
    jle       L1305
    mov       %rbx,	11
L1305:
    mov       %rcx,	%rbx
    call      mc_stackmcl.movetoreg
    call      mc_stackmcl.poppcl
    inc       %rbx
    dec       %r12
    jnz       L1301
L1303:
    mov       %rcx,	%r13
    call      mc_genmcl.px_jump
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_startmx
mc_genmcl.px_startmx:
#?>>
    .set mc_genmcl.px_startmx.p, 16
#?]]
    sub       %rsp,	40
#---------------
    xor       %ecx,	%ecx
    call      mc_stackmcl.saveopnds
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_genmcl.px_resetmx
mc_genmcl.px_resetmx:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	1
    call      mc_stackmcl.movetoreg
    movzx     %rax,	byte ptr[%rdi]
    cmp       %rax,	118
    jnz       L1309
    call      mc_stackmcl.poppcl
L1309:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_stop
mc_genmcl.px_stop:
#?>>
    .set mc_genmcl.px_stop.p, 16
#?]]
    sub       %rsp,	40
#---------------
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	6
    mov       %r8,	11
    call      mc_stackmcl.loadparam
    lea       %rcx,	[%rip+L8144]
    call      mc_libmcl.mgenextname
    mov       %rcx,	21
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %al,	1
    mov       [%rip+pc_decls.localshadow],	%al
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_genmcl.px_incrto
mc_genmcl.px_incrto:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	52
    mov       %r8,	28
    call      mc_auxmcl.do_incr
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_decrto
mc_genmcl.px_decrto:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	53
    mov       %r8,	29
    call      mc_auxmcl.do_incr
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_incrload
mc_genmcl.px_incrload:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	52
    mov       %r8,	28
    call      mc_auxmcl.do_incrload
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_decrload
mc_genmcl.px_decrload:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	53
    mov       %r8,	29
    call      mc_auxmcl.do_incrload
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_loadincr
mc_genmcl.px_loadincr:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	52
    mov       %r8,	28
    call      mc_auxmcl.do_loadincr
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_loaddecr
mc_genmcl.px_loaddecr:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	53
    mov       %r8,	29
    call      mc_auxmcl.do_loadincr
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_forup
mc_genmcl.px_forup:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	52
    mov       %r8,	28
    mov       %r9,	14
    call      mc_auxmcl.do_for
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_fordown
mc_genmcl.px_fordown:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	53
    mov       %r8,	29
    mov       %r9,	13
    call      mc_auxmcl.do_for
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_iload
mc_genmcl.px_iload:
#?>>
    .set mc_genmcl.px_iload.p, 40
    .set mc_genmcl.px_iload.$T1, -8
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	11
    jz        L1321
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	2
    jnz       L1323
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	[%rip+mc_decls.noperands]
    movzx     %r10,	byte ptr[%r10 + %r11-1]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.mgenireg
    mov       %rbx,	%rax
    jmp       L1322
L1323:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rbx,	%rax
L1322:
    mov       %rax,	[%rip+mc_decls.currpcl]
    lea       %rax,	[%rax+32]
    mov       %rsi,	%rax
    movzx     %rax,	byte ptr[%rsi]
    cmp       %rax,	114
    jnz       L1325
    movzx     %rax,	byte ptr[%rsi+3]
    mov       [%rbp + mc_genmcl.px_iload.$T1],	%rax
    movzx     %rax,	byte ptr[%rsi+3]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      mc_genmcl.getsharereg
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_genmcl.px_iload.$T1]
    call      mc_stackmcl.getworkreg_rm
    mov       %rdi,	%rax
    movsxd    %rax,	dword ptr[%rsi+28]
    and       %rax,	255
    lea       %r10,	[%rip+mc_decls.ploadop]
    movzx     %r10,	byte ptr[%r10 + %rax]
    mov       %rcx,	%r10
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rsi+3]
    movzx     %r10,	byte ptr[%rdi+10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_stackmcl.setnewzz
    mov       [%rip+mc_decls.currpcl],	%rsi
    jmp       L1324
L1325:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       [%rbp + mc_genmcl.px_iload.$T1],	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      mc_genmcl.getsharereg
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_genmcl.px_iload.$T1]
    call      mc_stackmcl.getworkreg_rm
    mov       %rdi,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    movzx     %r10,	byte ptr[%rdi+10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_stackmcl.setnewzz
L1324:
    jmp       L1320
L1321:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind_simp
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rbx+10]
    mov       %rcx,	%rax
    mov       %rdx,	6
    call      mc_stackmcl.getworkreg_rm
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mc_auxmcl.dolea
L1320:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.getsharereg
mc_genmcl.getsharereg:
#?>>
    push      %rdi
    push      %rbx
#?]]
#---------------
    mov       %dil,	[%rcx+10]
    mov       %bl,	[%rcx+11]
    cmp       %rdx,	2
    jg        L1328
    xor       %eax,	%eax
    jmp       L1326
L1328:
    test      %dil,	%dil
    jz        L1330
    movzx     %rax,	%dil
    lea       %r10,	[%rip+mc_decls.workregs]
    mov       %r10b,	[%r10 + %rax-1]
    test      %r10b,	%r10b
    jnz       L1331
    movzx     %rax,	%dil
    cmp       %rax,	11
    jl        L1330
    cmp       %rax,	14
    jg        L1330
L1331:
    movzx     %rax,	%dil
    jmp       L1326
L1330:
    test      %bl,	%bl
    jz        L1332
    movzx     %rax,	%bl
    lea       %r10,	[%rip+mc_decls.workregs]
    mov       %r10b,	[%r10 + %rax-1]
    test      %r10b,	%r10b
    jnz       L1333
    movzx     %rax,	%dil
    cmp       %rax,	11
    jl        L1332
    cmp       %rax,	14
    jg        L1332
L1333:
    movzx     %rax,	%bl
    jmp       L1326
L1332:
L1329:
    xor       %eax,	%eax
L1326:
#---------------
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_iloadx
mc_genmcl.px_iloadx:
#?>>
    .set mc_genmcl.px_iloadx.$T1, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %r12,	%rcx
#---------------
    mov       %rcx,	%r12
    call      mc_auxmcl.do_addrmode
    mov       %rsi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	11
    jnz       L1336
    movzx     %rax,	byte ptr[%rsi+10]
    mov       %rcx,	%rax
    mov       %rdx,	6
    call      mc_stackmcl.getworkreg_rm
    mov       %rbx,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      mc_auxmcl.dolea
    call      mc_stackmcl.poppcl
    movzx     %rax,	byte ptr[%rbx+10]
    mov       %rcx,	%rax
    mov       %rdx,	6
    call      mc_stackmcl.setnewzz
    jmp       L1335
L1336:
    mov       %rax,	[%rip+mc_decls.currpcl]
    lea       %rax,	[%rax+32]
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rdi]
    cmp       %rax,	114
    jnz       L1338
    movzx     %rax,	byte ptr[%rdi+3]
    mov       [%rbp + mc_genmcl.px_iloadx.$T1],	%rax
    movzx     %rax,	byte ptr[%rdi+3]
    mov       %rcx,	%rsi
    mov       %rdx,	%rax
    call      mc_genmcl.getsharereg
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_genmcl.px_iloadx.$T1]
    call      mc_stackmcl.getworkreg_rm
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%rdi+28]
    and       %rax,	255
    lea       %r10,	[%rip+mc_decls.ploadop]
    movzx     %r10,	byte ptr[%r10 + %rax]
    mov       %rcx,	%r10
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    movzx     %rax,	byte ptr[%rdi+3]
    movzx     %r10,	byte ptr[%rbx+10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_stackmcl.setnewzz
    mov       [%rip+mc_decls.currpcl],	%rdi
    jmp       L1337
L1338:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       [%rbp + mc_genmcl.px_iloadx.$T1],	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rsi
    mov       %rdx,	%rax
    call      mc_genmcl.getsharereg
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_genmcl.px_iloadx.$T1]
    call      mc_stackmcl.getworkreg_rm
    mov       %rbx,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    movzx     %r10,	byte ptr[%rbx+10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_stackmcl.setnewzz
L1337:
L1335:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_istore
mc_genmcl.px_istore:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	2
    jnz       L1341
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	[%rip+mc_decls.noperands]
    movzx     %r10,	byte ptr[%r10 + %r11-1]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.mgenireg
    mov       %rbx,	%rax
    jmp       L1340
L1341:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rbx,	%rax
L1340:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	11
    jnz       L1343
    mov       %rcx,	%rbx
    call      mc_stackmcl.makesimpleaddr
    mov       %rbx,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	6
    call      mc_stackmcl.makeopndind
    mov       %rdi,	%rax
    mov       %eax,	[%rsi+4]
    mov       %rcx,	%rbx
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    mov       %r9,	1
    call      mc_auxmcl.copyblock
    jmp       L1342
L1343:
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
L1342:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_istorex
mc_genmcl.px_istorex:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    sub       %r10,	2
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    mov       %rcx,	%rsi
    call      mc_auxmcl.do_addrmode
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	11
    jnz       L1346
    mov       %rcx,	%rbx
    call      mc_stackmcl.makesimpleaddr
    mov       %rbx,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	6
    call      mc_stackmcl.makeopndind
    mov       %rdi,	%rax
    mov       %eax,	[%rsi+4]
    mov       %rcx,	%rbx
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    mov       %r9,	1
    call      mc_auxmcl.copyblock
    jmp       L1345
L1346:
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
L1345:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_storem
mc_genmcl.px_storem:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
    mov       %eax,	[%r12+4]
    cmp       %rax,	16
    jz        L1349
    lea       %rcx,	[%rip+L8145]
    lea       %rdx,	[%rip+L8146]
    call      pc_api.merror
L1349:
    mov       %rcx,	16
    call      mc_libmcl.newblocktemp
    mov       %rsi,	%rax
    mov       %rcx,	%rsi
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       %rbx,	%rax
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	8
    xor       %r8d,	%r8d
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rdi+10]
    mov       %rcx,	%rax
    mov       %rdx,	6
    call      mc_libmcl.mgenreg
    mov       %rcx,	14
    mov       %rdx,	%rax
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rdi+10]
    mov       %rcx,	%rax
    mov       %rdx,	6
    call      mc_stackmcl.setnewzz
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_addpx
mc_genmcl.px_addpx:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    mov       %rcx,	%rsi
    call      mc_auxmcl.do_addrmode
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rbx+10]
    mov       %rcx,	%rax
    mov       %rdx,	6
    call      mc_stackmcl.getworkreg_rm
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mc_auxmcl.dolea
    call      mc_stackmcl.poppcl
    movzx     %rax,	byte ptr[%rdi+10]
    mov       %rcx,	%rax
    mov       %rdx,	6
    call      mc_stackmcl.setnewzz
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_subpx
mc_genmcl.px_subpx:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r14,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%r14+16]
    mov       %rdi,	%rax
    movsxd    %rax,	dword ptr[%r14+20]
    mov       %rbx,	%rax
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rsi,	%rax
    mov       %rcx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.isimmload
    mov       %r13,	%rax
    test      %rax,	%rax
    jz        L1353
    mov       %rax,	[%r13+8]
    mov       %r10,	%rdi
    imul      %rax,	%r10
    add       %rax,	%rbx
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	29
    mov       %rdx,	%rsi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L1352
L1353:
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %r12,	%rax
    mov       %rcx,	%r12
    mov       %rdx,	%rdi
    call      mc_auxmcl.scaleindex
    mov       %rdi,	%rax
    cmp       %rdi,	1
    jle       L1355
    mov       %rcx,	%r12
    mov       %rdx,	%rdi
    call      mc_auxmcl.mulimm
L1355:
    mov       %rcx,	29
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      mc_libmcl.genmc
    test      %rbx,	%rbx
    jz        L1357
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8147]
    call      msys.m$print_str_nf
    mov       %rcx,	%rbx
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8148]
    lea       %rdx,	[%rip+L8149]
    call      pc_api.merror
L1357:
L1352:
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_to
mc_genmcl.px_to:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    lea       %rax,	[%rsi+32]
    mov       [%rip+mc_decls.currpcl],	%rax
    mov       %rdi,	%rax
    mov       %rax,	[%rdi+8]
    mov       %rcx,	%rax
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       %rbx,	%rax
    mov       %rcx,	53
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %rcx,	26
    mov       %rdx,	5
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_iswap
mc_genmcl.px_iswap:
#?>>
    .set mc_genmcl.px_iswap.p, 48
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rsi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %r12,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rax
    call      mc_stackmcl.getworkregm
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rax
    call      mc_stackmcl.getworkregm
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	11
    jz        L1361
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%r12
    call      mc_libmcl.genmc
    mov       %rcx,	11
    mov       %rdx,	%r12
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rcx,	11
    mov       %rdx,	%rsi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    jmp       L1360
L1361:
    lea       %rcx,	[%rip+L8150]
    lea       %rdx,	[%rip+L8151]
    call      pc_api.merror
L1360:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_swapstk
mc_genmcl.px_swapstk:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%rdi+20]
    mov       %r10,	[%rip+mc_decls.noperands]
    sub       %r10,	%rax
    inc       %r10
    movsxd    %rax,	dword ptr[%rdi+16]
    mov       %r11,	[%rip+mc_decls.noperands]
    sub       %r11,	%rax
    inc       %r11
    mov       %rcx,	%r11
    mov       %rdx,	%r10
    call      mc_stackmcl.swapopnds
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_labeldef
mc_genmcl.px_labeldef:
#?>>
    .set mc_genmcl.px_labeldef.str, -104
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	136
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	[%rdi+8]
    mov       %rax,	[%rax]
    lea       %rcx,	[%rbp + mc_genmcl.px_labeldef.str]
    mov       %rdx,	%rax
    call      strcpy
    lea       %rcx,	[%rbp + mc_genmcl.px_labeldef.str]
    lea       %rdx,	[%rip+L8152]
    call      strcat
    lea       %rcx,	[%rbp + mc_genmcl.px_labeldef.str]
    call      mc_libmcl.mgencomment
#---------------
    add       %rsp,	136
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_addto
mc_genmcl.px_addto:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	28
    mov       %r8,	65
    call      mc_auxmcl.do_binto
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_subto
mc_genmcl.px_subto:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	29
    mov       %r8,	67
    call      mc_auxmcl.do_binto
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_multo
mc_genmcl.px_multo:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jg        L1368
    mov       %rcx,	%r13
    mov       %rdx,	69
    call      mc_auxmcl.do_binto_float
    jmp       L1366
L1368:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.psize]
    movzx     %r10,	byte ptr[%r10 + %rax]
    cmp       %r10,	1
    jnz       L1370
    lea       %rcx,	[%rip+L8153]
    lea       %rdx,	[%rip+L8154]
    call      pc_api.merror
L1370:
    mov       %rcx,	10
    xor       %edx,	%edx
    call      mc_stackmcl.pushpcl_reg
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    sub       %r10,	2
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rsi,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rsi
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rax,	[%rip+mc_decls.noperands]
    sub       %rax,	2
    mov       %rcx,	%rax
    call      mc_stackmcl.isimmload
    mov       %r12,	%rax
    test      %rax,	%rax
    jz        L1372
    mov       %rax,	[%r12+8]
    mov       %rcx,	%rsi
    mov       %rdx,	%rax
    call      mc_auxmcl.mulimm
    jmp       L1371
L1372:
    mov       %rcx,	34
    mov       %rdx,	%rsi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L1371:
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
L1366:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_bitandto
mc_genmcl.px_bitandto:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	38
    xor       %r8d,	%r8d
    call      mc_auxmcl.do_binto
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_bitorto
mc_genmcl.px_bitorto:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	39
    xor       %r8d,	%r8d
    call      mc_auxmcl.do_binto
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_bitxorto
mc_genmcl.px_bitxorto:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	40
    xor       %r8d,	%r8d
    call      mc_auxmcl.do_binto
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_shlto
mc_genmcl.px_shlto:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	43
    call      mc_auxmcl.do_shiftnto
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_shrto
mc_genmcl.px_shrto:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.psigned]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1379
    mov       %rax,	44
    jmp       L1378
L1379:
    mov       %rax,	45
L1378:
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mc_auxmcl.do_shiftnto
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_fix
mc_genmcl.px_fix:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%rsi+28]
    and       %rax,	255
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      mc_stackmcl.pushpcl_reg
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.pmin]
    movzx     %r10,	byte ptr[%r10 + %rax]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%r10
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%rsi+28]
    and       %rax,	255
    dec       %rax
    mov       %r10,	84
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    call      mc_stackmcl.poppcl
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    movzx     %r10,	byte ptr[%rbx+10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_stackmcl.setnewzz
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_float
mc_genmcl.px_float:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r14,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%r14+28]
    and       %rax,	255
    mov       %r13b,	%al
    movzx     %rax,	%r13b
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	%r13b
    lea       %r10,	[%rip+pc_tables.psize]
    movzx     %r10,	byte ptr[%r10 + %rax]
    cmp       %r10,	4
    jge       L1383
    lea       %rcx,	[%rip+L8155]
    lea       %rdx,	[%rip+L8156]
    call      pc_api.merror
L1383:
    movzx     %rax,	%r13b
    lea       %r10,	[%rip+pc_tables.psigned]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1385
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      mc_stackmcl.pushpcl_reg
    movzx     %rax,	byte ptr[%r14+3]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    dec       %rax
    mov       %r10,	86
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    jmp       L1384
L1385:
    movzx     %rax,	%r13b
    cmp       %rax,	6
    jnz       L1386
    mov       %rcx,	2
    xor       %edx,	%edx
    call      mc_stackmcl.pushpcl_reg
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	2
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    call      mc_libmcl.mcreatefwdlabel
    mov       %rsi,	%rax
    call      mc_libmcl.mcreatefwdlabel
    mov       %r12,	%rax
    xor       %ecx,	%ecx
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	42
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	%rsi
    call      mc_libmcl.mgenlabel
    mov       %rcx,	26
    mov       %rdx,	12
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    mov       %rcx,	87
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rcx,	%r12
    call      mc_libmcl.mgenlabel
    mov       %rcx,	25
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	%rsi
    call      mc_libmcl.mdefinefwdlabel
    mov       %rax,	[%rip+mc_decls.labmask63]
    test      %rax,	%rax
    jnz       L1388
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rax,	[%rip+pc_api.mlabelno]
    mov       [%rip+mc_decls.labmask63],	%rax
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rax,	[%rip+pc_api.mlabelno]
    mov       [%rip+mc_decls.laboffset64],	%rax
L1388:
    mov       %rcx,	[%rip+mc_decls.labmask63]
    call      mc_libmcl.mgenlabelmem
    mov       %rcx,	38
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	87
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rcx,	[%rip+mc_decls.laboffset64]
    call      mc_libmcl.mgenlabelmem
    mov       %rcx,	66
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	%r12
    call      mc_libmcl.mdefinefwdlabel
#mc_genmcl.px_float.reduce:
L1389:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	1
    jnz       L1391
    mov       %rcx,	%rbx
    mov       %rdx,	4
    call      mc_libmcl.changeopndsize
    mov       %rcx,	88
    mov       %rdx,	%rax
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.pclmode]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11-1],	%al
L1391:
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    jmp       L1384
L1386:
    mov       %rcx,	2
    xor       %edx,	%edx
    call      mc_stackmcl.pushpcl_reg
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	2
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	8
    call      mc_libmcl.changeopndsize
    mov       %rdi,	%rax
    mov       %rcx,	87
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    jmp       L1389
L1384:
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_idiv
mc_genmcl.px_idiv:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.psigned]
    movzx     %r10,	byte ptr[%r10 + %rax]
    mov       %rcx,	%rdi
    mov       %rdx,	%r10
    mov       %r8,	1
    call      mc_auxmcl.do_divrem
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_irem
mc_genmcl.px_irem:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.psigned]
    movzx     %r10,	byte ptr[%r10 + %rax]
    mov       %rcx,	%rdi
    mov       %rdx,	%r10
    xor       %r8d,	%r8d
    call      mc_auxmcl.do_divrem
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_idivrem
mc_genmcl.px_idivrem:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.psigned]
    movzx     %r10,	byte ptr[%r10 + %rax]
    mov       %rcx,	%rdi
    mov       %rdx,	%r10
    mov       %r8,	2
    call      mc_auxmcl.do_divrem
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_clear
mc_genmcl.px_clear:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	6
    call      mc_stackmcl.getopnd_ind_simp
    mov       %rdi,	%rax
    mov       %eax,	[%rbx+4]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mc_auxmcl.clearblock
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_subp
mc_genmcl.px_subp:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    mov       %rcx,	29
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    movsxd    %rax,	dword ptr[%r12+16]
    cmp       %rax,	1
    jle       L1398
    movsxd    %rax,	dword ptr[%r12+16]
    mov       %rcx,	%rax
    call      mc_libmcl.ispoweroftwo
    mov       %rsi,	%rax
    test      %rsi,	%rsi
    jz        L1400
    mov       %rcx,	%rsi
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	45
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L1399
L1400:
    call      msys.m$print_startcon
    movsxd    %rax,	dword ptr[%r12+16]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8157]
    lea       %rdx,	[%rip+L8158]
    call      pc_api.merror
L1399:
L1398:
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_switch
mc_genmcl.px_switch:
#?>>
    .set mc_genmcl.px_switch.p, 64
    .set mc_genmcl.px_switch.bx, -8
    .set mc_genmcl.px_switch.ax2, -16
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       [%rbp+64],	%rcx
#---------------
    mov       %rax,	[%rbp + mc_genmcl.px_switch.p]
    movsxd    %rax,	dword ptr[%rax+16]
    mov       %rdi,	%rax
    mov       %rax,	[%rbp + mc_genmcl.px_switch.p]
    movsxd    %rax,	dword ptr[%rax+20]
    mov       %rbx,	%rax
    mov       %rax,	[%rbp + mc_genmcl.px_switch.p]
    mov       %rsi,	[%rax+8]
    mov       %rax,	[%rbp + mc_genmcl.px_switch.p]
    lea       %rax,	[%rax+32]
    mov       [%rip+mc_decls.currpcl],	%rax
    mov       %rax,	[%rip+mc_decls.currpcl]
    mov       %r12,	[%rax+8]
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %r14,	%rax
    mov       %rax,	[%rbp + mc_genmcl.px_switch.p]
    mov       %eax,	[%rax+4]
    cmp       %rax,	8
    jge       L1403
    mov       %rcx,	%r14
    mov       %rdx,	8
    call      mc_libmcl.changeopndsize
    mov       %r10,	%rax
    mov       [%rbp + mc_genmcl.px_switch.ax2],	%r10
    mov       %rcx,	18
    mov       %rdx,	%rax
    mov       %r8,	%r14
    call      mc_libmcl.genmc
    mov       %r14,	[%rbp + mc_genmcl.px_switch.ax2]
L1403:
    test      %rdi,	%rdi
    jz        L1405
    mov       %rcx,	%rdi
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	29
    mov       %rdx,	%r14
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L1405:
    mov       %rax,	%rbx
    sub       %rax,	%rdi
    inc       %rax
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	42
    mov       %rdx,	%r14
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	%r12
    call      mc_libmcl.mgenlabel
    mov       %rcx,	26
    mov       %rdx,	3
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    movzx     %rax,	byte ptr[%rip+pc_api.phighmem]
    cmp       %rax,	2
    jnz       L1407
    call      mc_stackmcl.getworkireg
    mov       %r13,	%rax
    mov       %rcx,	%r13
    mov       %rdx,	6
    call      mc_libmcl.mgenreg
    mov       [%rbp + mc_genmcl.px_switch.bx],	%rax
    mov       %rcx,	%rsi
    call      mc_libmcl.mgenlabelmem
    mov       %rcx,	14
    mov       %rdx,	[%rbp + mc_genmcl.px_switch.bx]
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    sub       %rsp,	8
    push      0
    push      0
    push      0
    movzx     %rax,	byte ptr[%r14+10]
    mov       %rcx,	%r13
    mov       %rdx,	%rax
    mov       %r8,	8
    xor       %r9d,	%r9d
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rcx,	25
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L1406
L1407:
    sub       %rsp,	8
    push      0
    mov       %rax,	%rsi
    push      %rax
    push      0
    movzx     %rax,	byte ptr[%r14+10]
    xor       %ecx,	%ecx
    mov       %rdx,	%rax
    mov       %r8,	8
    xor       %r9d,	%r9d
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rcx,	25
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L1406:
    call      mc_stackmcl.poppcl
    mov       %rcx,	73
    mov       %rdx,	1
    call      mc_libmcl.setsegment
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_switchu
mc_genmcl.px_switchu:
#?>>
    .set mc_genmcl.px_switchu.p, 64
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	32
    mov       [%rbp+64],	%rcx
#---------------
    mov       %rax,	[%rbp + mc_genmcl.px_switchu.p]
    movsxd    %rax,	dword ptr[%rax+16]
    mov       %rdi,	%rax
    mov       %rax,	[%rbp + mc_genmcl.px_switchu.p]
    movsxd    %rax,	dword ptr[%rax+20]
    mov       %rbx,	%rax
    mov       %rax,	[%rbp + mc_genmcl.px_switchu.p]
    mov       %rsi,	[%rax+8]
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %r13,	%rax
    movzx     %rax,	byte ptr[%rip+pc_api.phighmem]
    cmp       %rax,	2
    jnz       L1410
    call      mc_stackmcl.getworkireg
    mov       %r12,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      mc_libmcl.mgenreg
    mov       %r14,	%rax
    mov       %rcx,	%rsi
    call      mc_libmcl.mgenlabelmem
    mov       %rcx,	14
    mov       %rdx,	%r14
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    sub       %rsp,	8
    push      0
    push      0
    push      0
    mov       %rax,	%rdi
    neg       %rax
    shl       %rax,	3
    movzx     %r10,	byte ptr[%r13+10]
    mov       %rcx,	%r12
    mov       %rdx,	%r10
    mov       %r8,	8
    mov       %r9,	%rax
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rcx,	25
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L1409
L1410:
    sub       %rsp,	8
    push      0
    mov       %rax,	%rsi
    push      %rax
    push      0
    mov       %rax,	%rdi
    neg       %rax
    shl       %rax,	3
    movzx     %r10,	byte ptr[%r13+10]
    xor       %ecx,	%ecx
    mov       %rdx,	%r10
    mov       %r8,	8
    mov       %r9,	%rax
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rcx,	25
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L1409:
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	32
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_swlabel
mc_genmcl.px_swlabel:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	[%rdi+8]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %rcx,	119
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_endsw
mc_genmcl.px_endsw:
#?>>
    .set mc_genmcl.px_endsw.p, 16
#?]]
    sub       %rsp,	40
#---------------
    mov       %rcx,	67
    mov       %rdx,	1
    call      mc_libmcl.setsegment
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_genmcl.px_fwiden
mc_genmcl.px_fwiden:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%rbx+28]
    and       %rax,	255
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	8
    call      mc_libmcl.changeopndsize
    mov       %rcx,	89
    mov       %rdx,	%rax
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %al,	2
    lea       %r10,	[%rip+mc_decls.pclmode]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11-1],	%al
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_fnarrow
mc_genmcl.px_fnarrow:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%rbx+28]
    and       %rax,	255
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	4
    call      mc_libmcl.changeopndsize
    mov       %rcx,	88
    mov       %rdx,	%rax
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.pclmode]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11-1],	%al
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_truncate
mc_genmcl.px_truncate:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%rsi+28]
    and       %rax,	255
    mov       %bl,	%al
    movzx     %rax,	%bl
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    mov       %eax,	[%rsi+4]
    movzx     %r10,	%bl
    lea       %r11,	[%rip+pc_tables.psize]
    movzx     %r11,	byte ptr[%r11 + %r10]
    cmp       %rax,	%r11
    jz        L1417
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.psize]
    movzx     %r10,	byte ptr[%r10 + %rax]
    mov       %rcx,	%rdi
    mov       %rdx,	%r10
    call      mc_libmcl.changeopndsize
    movzx     %r10,	%bl
    lea       %r11,	[%rip+mc_decls.ploadop]
    movzx     %r11,	byte ptr[%r11 + %r10]
    mov       %rcx,	%r11
    mov       %rdx,	%rax
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
L1417:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_typepun
mc_genmcl.px_typepun:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%rsi+28]
    and       %rax,	255
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rax
    call      mc_stackmcl.getworkregm
    mov       %rdi,	%rax
    movzx     %rax,	word ptr[%rdi+8]
    and       %rax,	31
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      mc_libmcl.changeopndsize
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    movzx     %r10,	byte ptr[%rdi+10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_stackmcl.setnewzz
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_unload
mc_genmcl.px_unload:
#?>>
    .set mc_genmcl.px_unload.p, 16
#?]]
    sub       %rsp,	40
#---------------
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_genmcl.px_loadbit
mc_genmcl.px_loadbit:
#?>>
    .set mc_genmcl.px_loadbit.p, 48
    .set mc_genmcl.px_loadbit.$T1, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
#---------------
    mov       %rcx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.isimmload
    mov       %rbx,	%rax
    test      %rax,	%rax
    jz        L1422
    mov       %rsi,	[%rbx+8]
    mov       %rax,	%rsi
    cmp       %rax,	0
    jl        L1424
    cmp       %rax,	31
    jg        L1424
    mov       %rax,	5
    jmp       L1423
L1424:
    mov       %rax,	6
L1423:
    mov       %r12,	%rax
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	%r12
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    test      %rsi,	%rsi
    jz        L1426
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    call      mc_libmcl.mgenint
    mov       %rcx,	45
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    cmp       %rsi,	63
    jz        L1429
L1428:
L1426:
    jmp       L1421
L1422:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    mov       %al,	[%rip+pc_decls.r10used]
    test      %al,	%al
    jz        L1431
    mov       %rcx,	11
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	12
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L1431:
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	3
    mov       %r8,	11
    call      mc_stackmcl.loadparam
    mov       %rcx,	45
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %al,	[%rip+pc_decls.r10used]
    test      %al,	%al
    jz        L1433
    mov       %rcx,	11
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	13
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L1433:
L1421:
    mov       %rcx,	1
    mov       %rdx,	5
    call      mc_libmcl.mgenint
    mov       [%rbp + mc_genmcl.px_loadbit.$T1],	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	4
    call      mc_libmcl.changeopndsize
    mov       %rcx,	38
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_genmcl.px_loadbit.$T1]
    call      mc_libmcl.genmc
#mc_genmcl.px_loadbit.skip:
L1429:
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_assem
mc_genmcl.px_assem:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	[%rip+pc_api.idomcl_assem]
    test      %rax,	%rax
    jz        L1436
    mov       %rax,	[%rdi+8]
    mov       %rcx,	%rax
    mov       %r10,	[%rip+pc_api.idomcl_assem]
    call      %r10
    jmp       L1435
L1436:
    lea       %rcx,	[%rip+L8159]
    lea       %rdx,	[%rip+L8160]
    call      pc_api.merror
L1435:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_sin
mc_genmcl.px_sin:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8161]
    mov       %r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_cos
mc_genmcl.px_cos:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8162]
    mov       %r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_tan
mc_genmcl.px_tan:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8163]
    mov       %r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_asin
mc_genmcl.px_asin:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8164]
    mov       %r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_acos
mc_genmcl.px_acos:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8165]
    mov       %r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_atan
mc_genmcl.px_atan:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8166]
    mov       %r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_log
mc_genmcl.px_log:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8167]
    mov       %r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_log10
mc_genmcl.px_log10:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8168]
    mov       %r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_exp
mc_genmcl.px_exp:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8169]
    mov       %r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_round
mc_genmcl.px_round:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8170]
    mov       %r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_floor
mc_genmcl.px_floor:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8171]
    mov       %r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_ceil
mc_genmcl.px_ceil:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8172]
    mov       %r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_atan2
mc_genmcl.px_atan2:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8173]
    mov       %r8,	2
    call      mc_auxmcl.do_maths
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_fmod
mc_genmcl.px_fmod:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8174]
    mov       %r8,	2
    call      mc_auxmcl.do_maths
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_setcc
mc_genmcl.px_setcc:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rsi,	%rax
    movzx     %rax,	byte ptr[%r13+2]
    lea       %r10,	[%rip+mc_genmcl.ucondcodes]
    movzx     %r10,	byte ptr[%r10 + %rax-1]
    mov       %rdi,	%r10
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	11
    jnz       L1453
    lea       %rcx,	[%rip+L8175]
    lea       %rdx,	[%rip+L8176]
    call      pc_api.merror
    jmp       L1452
L1453:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jle       L1454
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.psigned]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1456
    movzx     %rax,	byte ptr[%r13+2]
    lea       %r10,	[%rip+mc_genmcl.scondcodes]
    movzx     %r10,	byte ptr[%r10 + %rax-1]
    mov       %rdi,	%r10
L1456:
    mov       %rcx,	42
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      mc_libmcl.changeopndsize
    mov       %r12,	%rax
    jmp       L1452
L1454:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    dec       %rax
    mov       %r10,	73
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
    mov       %rcx,	3
    call      mc_stackmcl.getworkregm
    mov       %r12,	%rax
    movzx     %rax,	byte ptr[%r12+10]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_stackmcl.setnewzz
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
L1452:
    mov       %rcx,	58
    mov       %rdx,	%rdi
    mov       %r8,	%r12
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    mov       %rcx,	%r12
    mov       %rdx,	4
    call      mc_libmcl.changeopndsize
    mov       %rcx,	19
    mov       %rdx,	%rax
    mov       %r8,	%r12
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_min
mc_genmcl.px_min:
#?>>
    .set mc_genmcl.px_min.p, 16
#?]]
    sub       %rsp,	40
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jle       L1459
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.psigned]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1461
    mov       %rax,	15
    jmp       L1460
L1461:
    mov       %rax,	7
L1460:
    mov       %rcx,	%rax
    call      mc_auxmcl.do_max_int
    jmp       L1458
L1459:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    dec       %rax
    mov       %r10,	112
    add       %r10,	%rax
    mov       %rcx,	%r10
    call      mc_auxmcl.do_max_float
L1458:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_genmcl.px_max
mc_genmcl.px_max:
#?>>
    .set mc_genmcl.px_max.p, 16
#?]]
    sub       %rsp,	40
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jle       L1464
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.psigned]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1466
    mov       %rax,	12
    jmp       L1465
L1466:
    mov       %rax,	2
L1465:
    mov       %rcx,	%rax
    call      mc_auxmcl.do_max_int
    jmp       L1463
L1464:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    dec       %rax
    mov       %r10,	113
    add       %r10,	%rax
    mov       %rcx,	%r10
    call      mc_auxmcl.do_max_float
L1463:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_genmcl.px_power
mc_genmcl.px_power:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jle       L1469
    mov       %rcx,	82
    call      mc_auxmcl.gethostfn
    mov       %rdi,	%rax
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    mov       %rcx,	%rbx
    mov       %rdx,	%rdi
    mov       %r8,	2
    call      mc_auxmcl.do_host
    jmp       L1468
L1469:
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    mov       %rcx,	%rbx
    lea       %rdx,	[%rip+L8177]
    mov       %r8,	2
    call      mc_auxmcl.do_maths
L1468:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_minto
mc_genmcl.px_minto:
#?>>
    .set mc_genmcl.px_minto.p, 16
    .set mc_genmcl.px_minto.$T1, -8
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jle       L1472
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       [%rbp + mc_genmcl.px_minto.$T1],	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.psigned]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1474
    mov       %rax,	14
    jmp       L1473
L1474:
    mov       %rax,	6
L1473:
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_genmcl.px_minto.$T1]
    call      mc_auxmcl.do_maxto_int
    jmp       L1471
L1472:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	6
    mov       %rdx,	%rax
    call      mc_auxmcl.do_maxto_real
L1471:
#---------------
    add       %rsp,	48
    pop       %rbp
    ret       
# End 
# Proc mc_genmcl.px_maxto
mc_genmcl.px_maxto:
#?>>
    .set mc_genmcl.px_maxto.p, 16
    .set mc_genmcl.px_maxto.$T1, -8
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jle       L1477
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       [%rbp + mc_genmcl.px_maxto.$T1],	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.psigned]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1479
    mov       %rax,	13
    jmp       L1478
L1479:
    mov       %rax,	3
L1478:
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_genmcl.px_maxto.$T1]
    call      mc_auxmcl.do_maxto_int
    jmp       L1476
L1477:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	3
    mov       %rdx,	%rax
    call      mc_auxmcl.do_maxto_real
L1476:
#---------------
    add       %rsp,	48
    pop       %rbp
    ret       
# End 
# Proc mc_genmcl.px_negto
mc_genmcl.px_negto:
#?>>
    .set mc_genmcl.px_negto.p, 32
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jle       L1482
    mov       %rcx,	50
    mov       %rdx,	%rdi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L1481
L1482:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rax
    call      mc_stackmcl.getworkregm
    mov       %rbx,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      mc_auxmcl.do_negreal
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L1481:
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_absto
mc_genmcl.px_absto:
#?>>
    .set mc_genmcl.px_absto.p, 40
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rax
    call      mc_stackmcl.getworkregm
    mov       %rbx,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jle       L1485
    xor       %ecx,	%ecx
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	42
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rax,	[%rip+pc_api.mlabelno]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %r10,	%rax
    mov       %rsi,	%r10
    mov       %rcx,	26
    mov       %rdx,	13
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    mov       %rcx,	50
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	9
    mov       %rdx,	%rsi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L1484
L1485:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      mc_auxmcl.do_absreal
L1484:
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_addpxto
mc_genmcl.px_addpxto:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    call      mc_stackmcl.isimmload
    mov       %rsi,	%rax
    test      %rax,	%rax
    jz        L1488
    mov       %rax,	[%rsi+8]
    movsxd    %r10,	dword ptr[%r12+16]
    imul      %rax,	%r10
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	28
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L1487
L1488:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%r12+16]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      mc_auxmcl.mulimm
    mov       %rcx,	28
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L1487:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_subpxto
mc_genmcl.px_subpxto:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    call      mc_stackmcl.isimmload
    mov       %rsi,	%rax
    test      %rax,	%rax
    jz        L1491
    mov       %rax,	[%rsi+8]
    movsxd    %r10,	dword ptr[%r12+16]
    imul      %rax,	%r10
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	29
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L1490
L1491:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%r12+16]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      mc_auxmcl.mulimm
    mov       %rcx,	29
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    mov       %eax,	[%r12+20]
    test      %eax,	%eax
    jz        L1493
    lea       %rcx,	[%rip+L8178]
    lea       %rdx,	[%rip+L8179]
    call      pc_api.merror
L1493:
L1490:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_divto
mc_genmcl.px_divto:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	71
    call      mc_auxmcl.do_binto_float
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_bitnotto
mc_genmcl.px_bitnotto:
#?>>
    .set mc_genmcl.px_bitnotto.p, 24
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    mov       %rcx,	51
    mov       %rdx,	%rdi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_notto
mc_genmcl.px_notto:
#?>>
    .set mc_genmcl.px_notto.p, 24
    .set mc_genmcl.px_notto.$T1, -8
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
#---------------
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	3
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    mov       %rcx,	1
    mov       %rdx,	3
    call      mc_libmcl.mgenint
    mov       [%rbp + mc_genmcl.px_notto.$T1],	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      mc_libmcl.changeopndsize
    mov       %rcx,	40
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_genmcl.px_notto.$T1]
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_toboolto
mc_genmcl.px_toboolto:
#?>>
    .set mc_genmcl.px_toboolto.p, 40
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	3
    call      mc_stackmcl.getopnd_ind
    mov       %rsi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rax
    call      mc_stackmcl.getworkregm
    mov       %rdi,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
    mov       %rcx,	41
    mov       %rdx,	%rdi
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      mc_libmcl.changeopndsize
    mov       %r10,	%rax
    mov       %rbx,	%r10
    mov       %rcx,	58
    mov       %rdx,	5
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    mov       %rcx,	%rdi
    mov       %rdx,	4
    call      mc_libmcl.changeopndsize
    mov       %rcx,	19
    mov       %rdx,	%rax
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    mov       %rcx,	11
    mov       %rdx,	%rsi
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_sign
mc_genmcl.px_sign:
#?>>
    .set mc_genmcl.px_sign.p, 64
    .set mc_genmcl.px_sign.ltop, -8
    .set mc_genmcl.px_sign.$T1, -16
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    mov       %rcx,	10
    call      mc_stackmcl.getworkregm
    mov       %rbx,	%rax
    mov       %rcx,	%rbx
    call      mc_libmcl.clearreg
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jg        L1500
    mov       %r14b,	7
    mov       %al,	2
    mov       [%rbp + mc_genmcl.px_sign.ltop],	%al
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    movq      %XMM0,	[%rip+L8180]
    mov       %rdx,	%rax
    call      mc_libmcl.mgenrealmem
    movzx     %r10,	byte ptr[%rip+mc_decls.pmode]
    dec       %r10
    mov       %r11,	73
    add       %r11,	%r10
    mov       %rcx,	%r11
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L1499
L1500:
    mov       %r14b,	15
    mov       %al,	12
    mov       [%rbp + mc_genmcl.px_sign.ltop],	%al
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    xor       %ecx,	%ecx
    mov       %rdx,	%rax
    call      mc_libmcl.mgenint
    mov       %rcx,	42
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L1499:
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rax,	[%rip+pc_api.mlabelno]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %r10,	%rax
    mov       %rsi,	%r10
    movzx     %r10,	%r14b
    mov       %rcx,	26
    mov       %rdx,	%r10
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rax,	[%rip+pc_api.mlabelno]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %r10,	%rax
    mov       %r12,	%r10
    movzx     %r10,	byte ptr[%rbp + mc_genmcl.px_sign.ltop]
    mov       %rcx,	26
    mov       %rdx,	%r10
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rax,	[%rip+pc_api.mlabelno]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %r10,	%rax
    mov       %r13,	%r10
    mov       %rcx,	25
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	9
    mov       %rdx,	%rsi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	1
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       [%rbp + mc_genmcl.px_sign.$T1],	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      mc_libmcl.changeopndsize
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_genmcl.px_sign.$T1]
    call      mc_libmcl.genmc
    mov       %rcx,	25
    mov       %rdx,	%r13
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	9
    mov       %rdx,	%r12
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	53
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	9
    mov       %rdx,	%r13
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rbx+10]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_stackmcl.setnewzz
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_loadbf
mc_genmcl.px_loadbf:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    call      mc_stackmcl.isimmload
    mov       %rdi,	%rax
    mov       %rcx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.isimmload
    mov       %rbx,	%rax
    test      %rdi,	%rdi
    jz        L1503
    test      %rbx,	%rbx
    jz        L1503
    mov       %rax,	[%rbx+8]
    mov       %r10,	[%rdi+8]
    mov       %rcx,	%rsi
    mov       %rdx,	%r10
    mov       %r8,	%rax
    call      mc_auxmcl.do_loadbf_const
    jmp       L1502
L1503:
    mov       %rcx,	%rsi
    call      mc_auxmcl.do_loadbf_var
L1502:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_storebit
mc_genmcl.px_storebit:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      mc_auxmcl.do_storebit
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_storebf
mc_genmcl.px_storebf:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      mc_auxmcl.do_storebf
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_loadall
mc_genmcl.px_loadall:
#?>>
    .set mc_genmcl.px_loadall.p, 16
#?]]
    sub       %rsp,	40
#---------------
    call      mc_stackmcl.checkallloaded
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_genmcl.px_setjmp
mc_genmcl.px_setjmp:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
    call      mc_libmcl.mcreatefwdlabel
    mov       %rsi,	%rax
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	6
    call      mc_stackmcl.getopnd_ind
    mov       %rbx,	%rax
    mov       %rcx,	6
    xor       %edx,	%edx
    call      mc_stackmcl.pushpcl_reg
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rdi,	%rax
    mov       %rcx,	%rsi
    call      mc_libmcl.mgenlabel
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rcx,	%rbx
    mov       %rdx,	8
    xor       %r8d,	%r8d
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	[%rip+mc_decls.dstackopnd]
    call      mc_libmcl.genmc
    mov       %rcx,	%rbx
    mov       %rdx,	16
    xor       %r8d,	%r8d
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	[%rip+mc_decls.dframeopnd]
    call      mc_libmcl.genmc
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    call      mc_stackmcl.poppcl
    mov       %rcx,	%rdi
    call      mc_libmcl.clearreg
    mov       %rcx,	%r12
    call      mc_stackmcl.freeworkregs
    mov       %rcx,	1
    call      mc_stackmcl.movetoreg
    mov       %rcx,	%rsi
    call      mc_libmcl.mdefinefwdlabel
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_longjmp
mc_genmcl.px_longjmp:
#?>>
    .set mc_genmcl.px_longjmp.p, 40
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	6
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	8
    xor       %r8d,	%r8d
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	[%rip+mc_decls.dstackopnd]
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	%rdi
    mov       %rdx,	16
    xor       %r8d,	%r8d
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	[%rip+mc_decls.dframeopnd]
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	6
    xor       %edx,	%edx
    call      mc_stackmcl.pushpcl_reg
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rsi,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rsi
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rax,	[%rip+mc_decls.noperands]
    sub       %rax,	2
    mov       %rcx,	%rax
    mov       %rdx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    call      mc_stackmcl.poppcl
    mov       %rcx,	1
    call      mc_stackmcl.swapopndregs
    mov       %rcx,	25
    mov       %rdx,	%rsi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_initdswx
mc_genmcl.px_initdswx:
#?>>
    .set mc_genmcl.px_initdswx.p, 16
#?]]
#---------------
#---
#---------------
    ret       
# End 
# Proc mc_auxmcl.allocregvars
mc_auxmcl.allocregvars:
#?>>
    .set mc_auxmcl.allocregvars.params, -32
    .set mc_auxmcl.allocregvars.xparams, -64
    .set mc_auxmcl.allocregvars.leafparams, -96
    .set mc_auxmcl.allocregvars.xleafparams, -128
    .set mc_auxmcl.allocregvars.leafparamno, -136
    .set mc_auxmcl.allocregvars.xleafparamno, -144
    .set mc_auxmcl.allocregvars.locals, -400
    .set mc_auxmcl.allocregvars.xlocals, -656
    .set mc_auxmcl.allocregvars.reg, -664
    .set mc_auxmcl.allocregvars.nl, -672
    .set mc_auxmcl.allocregvars.np, -680
    .set mc_auxmcl.allocregvars.nlx, -688
    .set mc_auxmcl.allocregvars.npx, -696
    .set mc_auxmcl.allocregvars.d, -704
    .set mc_auxmcl.allocregvars.i, -712
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	712
#---------------
    xor       %rdi,	%rdi
    xor       %eax,	%eax
    mov       %rbx,	%rax
    xor       %rsi,	%rsi
    xor       %eax,	%eax
    mov       %r12,	%rax
    xor       %r13,	%r13
    xor       %eax,	%eax
    mov       %r14,	%rax
    mov       %rax,	[%rip+mc_decls.maxregvars]
    add       %rax,	[%rip+mc_decls.maxxregvars]
    test      %rax,	%rax
    jz        L1510
L1512:
    test      %rcx,	%rcx
    jnz       L1514
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %rax,	[%rax+16]
    mov       [%rbp + mc_auxmcl.allocregvars.d],	%rax
    xor       %r15,	%r15
    jmp       L1518
L1515:
    inc       %r15
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       %al,	[%rax+92]
    test      %al,	%al
    jz        L1520
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       %al,	[%rax+91]
    test      %al,	%al
    jnz       L1520
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       %al,	[%rax+88]
    test      %al,	%al
    jnz       L1520
    cmp       %r15,	4
    jg        L1520
    test      %rdx,	%rdx
    jnz       L1522
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    movzx     %rax,	byte ptr[%rax+82]
    lea       %r10,	[%rip+pc_tables.pint]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1524
    cmp       %rdi,	4
    jge       L1526
    inc       %rdi
    mov       %rax,	%rdi
    mov       %r10,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       [%rbp + %rax*8 + mc_auxmcl.allocregvars.params-8],	%r10
L1526:
    jmp       L1523
L1524:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    movzx     %rax,	byte ptr[%rax+82]
    lea       %r10,	[%rip+pc_tables.pfloat]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1527
    cmp       %rbx,	4
    jge       L1529
    inc       %rbx
    mov       %rax,	%rbx
    mov       %r10,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       [%rbp + %rax*8 + mc_auxmcl.allocregvars.xparams-8],	%r10
L1529:
L1527:
L1523:
    jmp       L1521
L1522:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    movzx     %rax,	byte ptr[%rax+82]
    lea       %r10,	[%rip+pc_tables.pint]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1531
    cmp       %rsi,	4
    jge       L1533
    inc       %rsi
    mov       %rax,	%rsi
    mov       %r10,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       [%rbp + %rax*8 + mc_auxmcl.allocregvars.leafparams-8],	%r10
    mov       [%rbp + %rsi + mc_auxmcl.allocregvars.leafparamno-1],	%r15b
L1533:
    jmp       L1530
L1531:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    movzx     %rax,	byte ptr[%rax+82]
    lea       %r10,	[%rip+pc_tables.pfloat]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1534
    cmp       %r12,	4
    jge       L1536
    inc       %r12
    mov       %rax,	%r12
    mov       %r10,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       [%rbp + %rax*8 + mc_auxmcl.allocregvars.xleafparams-8],	%r10
    mov       [%rbp + %r12 + mc_auxmcl.allocregvars.xleafparamno-1],	%r15b
L1536:
L1534:
L1530:
L1521:
L1520:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       %rax,	[%rax+16]
    mov       [%rbp + mc_auxmcl.allocregvars.d],	%rax
L1518:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    test      %rax,	%rax
    jnz       L1515
L1514:
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %rax,	[%rax+24]
    mov       [%rbp + mc_auxmcl.allocregvars.d],	%rax
    jmp       L1540
L1537:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       %al,	[%rax+92]
    test      %al,	%al
    jz        L1542
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       %al,	[%rax+91]
    test      %al,	%al
    jnz       L1542
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       %al,	[%rax+88]
    test      %al,	%al
    jnz       L1542
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    movzx     %rax,	byte ptr[%rax+82]
    lea       %r10,	[%rip+pc_tables.pint]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1544
    cmp       %r13,	32
    jge       L1546
    inc       %r13
    mov       %rax,	%r13
    mov       %r10,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       [%rbp + %rax*8 + mc_auxmcl.allocregvars.locals-8],	%r10
L1546:
    jmp       L1543
L1544:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    movzx     %rax,	byte ptr[%rax+82]
    lea       %r10,	[%rip+pc_tables.pfloat]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1547
    cmp       %r14,	32
    jge       L1547
    inc       %r14
    mov       %rax,	%r14
    mov       %r10,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       [%rbp + %rax*8 + mc_auxmcl.allocregvars.xlocals-8],	%r10
L1547:
L1543:
L1542:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       %rax,	[%rax+24]
    mov       [%rbp + mc_auxmcl.allocregvars.d],	%rax
L1540:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    test      %rax,	%rax
    jnz       L1537
    test      %r13,	%r13
    jnz       L1549
    mov       %rax,	[%rip+mc_decls.maxregvars]
    mov       %r10,	%rdi
    cmp       %rax,	%r10
    cmovg     %rax,	%r10
    mov       [%rbp + mc_auxmcl.allocregvars.np],	%rax
    xor       %eax,	%eax
    mov       [%rbp + mc_auxmcl.allocregvars.nl],	%rax
    jmp       L1548
L1549:
    test      %rdi,	%rdi
    jnz       L1550
    mov       %rax,	[%rip+mc_decls.maxregvars]
    mov       %r10,	%r13
    cmp       %rax,	%r10
    cmovg     %rax,	%r10
    mov       [%rbp + mc_auxmcl.allocregvars.nl],	%rax
    xor       %eax,	%eax
    mov       [%rbp + mc_auxmcl.allocregvars.np],	%rax
    jmp       L1548
L1550:
    mov       [%rbp + mc_auxmcl.allocregvars.nl],	%r13
    mov       [%rbp + mc_auxmcl.allocregvars.np],	%rdi
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.np]
    add       %rax,	[%rbp + mc_auxmcl.allocregvars.nl]
    sub       %rax,	[%rip+mc_decls.maxregvars]
    mov       %r15,	%rax
    cmp       %r15,	0
    jle       L1552
    dec       qword ptr[%rbp + mc_auxmcl.allocregvars.np]
    dec       %r15
    cmp       %r15,	0
    jle       L1554
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.np]
    cmp       %rax,	0
    jle       L1554
    dec       qword ptr[%rbp + mc_auxmcl.allocregvars.np]
    dec       %r15
L1554:
    cmp       %r15,	0
    jle       L1556
    mov       %rax,	%r15
    sub       [%rbp + mc_auxmcl.allocregvars.nl],	%rax
L1556:
L1552:
L1548:
    mov       %rax,	4
    mov       [%rbp + mc_auxmcl.allocregvars.reg],	%rax
    mov       %rax,	1
    mov       [%rbp + mc_auxmcl.allocregvars.i],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.nl]
    cmp       %rax,	1
    jl        L1559
L1557:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.i]
    mov       %rax,	[%rbp + %rax*8 + mc_auxmcl.allocregvars.locals-8]
    mov       [%rbp + mc_auxmcl.allocregvars.d],	%rax
    mov       %al,	[%rbp + mc_auxmcl.allocregvars.reg]
    mov       %r10,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       [%r10+90],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.isregvar]
    mov       %r11,	[%rbp + mc_auxmcl.allocregvars.reg]
    mov       [%r10 + %r11-1],	%al
    inc       qword ptr[%rbp + mc_auxmcl.allocregvars.reg]
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.i]
    inc       %rax
    mov       [%rbp + mc_auxmcl.allocregvars.i],	%rax
    cmp       %rax,	[%rbp + mc_auxmcl.allocregvars.nl]
    jle       L1557
L1559:
    mov       %rax,	1
    mov       [%rbp + mc_auxmcl.allocregvars.i],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.np]
    cmp       %rax,	1
    jl        L1562
L1560:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.i]
    mov       %rax,	[%rbp + %rax*8 + mc_auxmcl.allocregvars.params-8]
    mov       [%rbp + mc_auxmcl.allocregvars.d],	%rax
    mov       %al,	[%rbp + mc_auxmcl.allocregvars.reg]
    mov       %r10,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       [%r10+90],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.isregvar]
    mov       %r11,	[%rbp + mc_auxmcl.allocregvars.reg]
    mov       [%r10 + %r11-1],	%al
    inc       qword ptr[%rbp + mc_auxmcl.allocregvars.reg]
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.i]
    inc       %rax
    mov       [%rbp + mc_auxmcl.allocregvars.i],	%rax
    cmp       %rax,	[%rbp + mc_auxmcl.allocregvars.np]
    jle       L1560
L1562:
    mov       %rax,	1
    mov       [%rbp + mc_auxmcl.allocregvars.i],	%rax
    cmp       %rsi,	1
    jl        L1565
L1563:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.i]
    mov       %rax,	[%rbp + %rax*8 + mc_auxmcl.allocregvars.leafparams-8]
    mov       [%rbp + mc_auxmcl.allocregvars.d],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.i]
    movzx     %rax,	byte ptr[%rbp + %rax + mc_auxmcl.allocregvars.leafparamno-1]
    add       %rax,	11
    dec       %rax
    mov       [%rbp + mc_auxmcl.allocregvars.reg],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.reg]
    cmp       %rax,	11
    jnz       L1567
    mov       %al,	1
    mov       [%rip+pc_decls.r10used],	%al
L1567:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.reg]
    cmp       %rax,	12
    jnz       L1569
    mov       %al,	1
    mov       [%rip+pc_decls.r11used],	%al
L1569:
    mov       %al,	[%rbp + mc_auxmcl.allocregvars.reg]
    mov       %r10,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       [%r10+90],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.isregvar]
    mov       %r11,	[%rbp + mc_auxmcl.allocregvars.reg]
    mov       [%r10 + %r11-1],	%al
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.i]
    inc       %rax
    mov       [%rbp + mc_auxmcl.allocregvars.i],	%rax
    cmp       %rax,	%rsi
    jle       L1563
L1565:
    test      %r14,	%r14
    jnz       L1571
    mov       %rax,	[%rip+mc_decls.maxxregvars]
    mov       %r10,	%rbx
    cmp       %rax,	%r10
    cmovg     %rax,	%r10
    mov       [%rbp + mc_auxmcl.allocregvars.npx],	%rax
    xor       %eax,	%eax
    mov       [%rbp + mc_auxmcl.allocregvars.nlx],	%rax
    jmp       L1570
L1571:
    test      %rbx,	%rbx
    jnz       L1572
    mov       %rax,	[%rip+mc_decls.maxxregvars]
    mov       %r10,	%r14
    cmp       %rax,	%r10
    cmovg     %rax,	%r10
    mov       [%rbp + mc_auxmcl.allocregvars.nlx],	%rax
    xor       %eax,	%eax
    mov       [%rbp + mc_auxmcl.allocregvars.npx],	%rax
    jmp       L1570
L1572:
    mov       [%rbp + mc_auxmcl.allocregvars.nlx],	%r14
    mov       [%rbp + mc_auxmcl.allocregvars.npx],	%rbx
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.npx]
    add       %rax,	[%rbp + mc_auxmcl.allocregvars.nlx]
    sub       %rax,	[%rip+mc_decls.maxregvars]
    mov       %r15,	%rax
    cmp       %r15,	0
    jle       L1574
    dec       qword ptr[%rbp + mc_auxmcl.allocregvars.npx]
    dec       %r15
    cmp       %r15,	0
    jle       L1576
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.npx]
    cmp       %rax,	0
    jle       L1576
    dec       qword ptr[%rbp + mc_auxmcl.allocregvars.npx]
    dec       %r15
L1576:
    cmp       %r15,	0
    jle       L1578
    mov       %rax,	%r15
    sub       [%rbp + mc_auxmcl.allocregvars.nlx],	%rax
L1578:
L1574:
L1570:
    mov       %rax,	16
    mov       [%rbp + mc_auxmcl.allocregvars.reg],	%rax
    mov       %rax,	1
    mov       [%rbp + mc_auxmcl.allocregvars.i],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.nlx]
    cmp       %rax,	1
    jl        L1581
L1579:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.i]
    mov       %rax,	[%rbp + %rax*8 + mc_auxmcl.allocregvars.xlocals-8]
    mov       [%rbp + mc_auxmcl.allocregvars.d],	%rax
    mov       %al,	[%rbp + mc_auxmcl.allocregvars.reg]
    mov       %r10,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       [%r10+90],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.isxregvar]
    mov       %r11,	[%rbp + mc_auxmcl.allocregvars.reg]
    mov       [%r10 + %r11-1],	%al
    dec       qword ptr[%rbp + mc_auxmcl.allocregvars.reg]
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.i]
    inc       %rax
    mov       [%rbp + mc_auxmcl.allocregvars.i],	%rax
    cmp       %rax,	[%rbp + mc_auxmcl.allocregvars.nlx]
    jle       L1579
L1581:
    mov       %rax,	1
    mov       [%rbp + mc_auxmcl.allocregvars.i],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.npx]
    cmp       %rax,	1
    jl        L1584
L1582:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.i]
    mov       %rax,	[%rbp + %rax*8 + mc_auxmcl.allocregvars.xparams-8]
    mov       [%rbp + mc_auxmcl.allocregvars.d],	%rax
    mov       %al,	[%rbp + mc_auxmcl.allocregvars.reg]
    mov       %r10,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       [%r10+90],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.isxregvar]
    mov       %r11,	[%rbp + mc_auxmcl.allocregvars.reg]
    mov       [%r10 + %r11-1],	%al
    dec       qword ptr[%rbp + mc_auxmcl.allocregvars.reg]
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.i]
    inc       %rax
    mov       [%rbp + mc_auxmcl.allocregvars.i],	%rax
    cmp       %rax,	[%rbp + mc_auxmcl.allocregvars.npx]
    jle       L1582
L1584:
    mov       %rax,	1
    mov       [%rbp + mc_auxmcl.allocregvars.i],	%rax
    cmp       %r12,	1
    jl        L1587
L1585:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.i]
    mov       %rax,	[%rbp + %rax*8 + mc_auxmcl.allocregvars.xleafparams-8]
    mov       [%rbp + mc_auxmcl.allocregvars.d],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.i]
    movzx     %rax,	byte ptr[%rbp + %rax + mc_auxmcl.allocregvars.xleafparamno-1]
    inc       %rax
    dec       %rax
    mov       [%rbp + mc_auxmcl.allocregvars.reg],	%rax
    mov       %al,	[%rbp + mc_auxmcl.allocregvars.reg]
    mov       %r10,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       [%r10+90],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.isxregvar]
    mov       %r11,	[%rbp + mc_auxmcl.allocregvars.reg]
    mov       [%r10 + %r11-1],	%al
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.i]
    inc       %rax
    mov       [%rbp + mc_auxmcl.allocregvars.i],	%rax
    cmp       %rax,	%r12
    jle       L1585
L1587:
L1510:
#---------------
    add       %rsp,	712
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.initproc
mc_auxmcl.initproc:
#?>>
    .set mc_auxmcl.initproc.$T1, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %r15,	%rcx
#---------------
    lea       %rax,	[%rip+mc_decls.regset]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    lea       %rax,	[%rip+mc_decls.xregset]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    lea       %rax,	[%rip+mc_decls.workregs]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    lea       %rax,	[%rip+mc_decls.workxregs]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    lea       %rax,	[%rip+mc_decls.isregvar]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    lea       %rax,	[%rip+mc_decls.isxregvar]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    mov       %rax,	3
    mov       [%rip+mc_decls.nworkregs],	%rax
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.workregs]
    mov       [%r10],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.workregs]
    mov       [%r10+1],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.workregs]
    mov       [%r10+2],	%al
    mov       %rax,	2
    mov       [%rip+mc_decls.nworkxregs],	%rax
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.workxregs]
    mov       [%r10+4],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.workxregs]
    mov       [%r10+5],	%al
    xor       %eax,	%eax
    mov       [%rip+mc_decls.maxxregvars],	%rax
    mov       [%rip+mc_decls.maxregvars],	%rax
    xor       %r12,	%r12
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %rax,	[%rax+48]
    mov       [%rip+pc_decls.pinfo],	%rax
    mov       %rax,	[%rip+pc_decls.pinfo]
    test      %rax,	%rax
    jnz       L1590
    mov       %rax,	10
    mov       [%rip+mc_decls.nworkregs],	%rax
    mov       %rax,	12
    mov       [%rip+mc_decls.nworkxregs],	%rax
    mov       %rsi,	4
L1591:
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.workregs]
    mov       %r11,	%rsi
    mov       [%r10 + %r11-1],	%al
    inc       %rsi
    cmp       %rsi,	10
    jle       L1591
    mov       %rsi,	7
L1594:
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.workxregs]
    mov       %r11,	%rsi
    mov       [%r10 + %r11-1],	%al
    inc       %rsi
    cmp       %rsi,	16
    jle       L1594
    jmp       L1589
L1590:
    mov       %rax,	[%rip+pc_decls.currfunc]
    movzx     %rax,	byte ptr[%rax+112]
    mov       %r10,	[%rip+pc_decls.pinfo]
    movzx     %r10,	byte ptr[%r10+4]
    cmp       %rax,	%r10
    cmovl     %rax,	%r10
    mov       %r10,	4
    cmp       %r10,	%rax
    cmovg     %r10,	%rax
    mov       %r12,	%r10
    mov       %rax,	4
    mov       [%rip+mc_decls.nworkregs],	%rax
    mov       %rax,	[%rip+pc_decls.pinfo]
    mov       %al,	[%rax+7]
    test      %al,	%al
    jz        L1598
    inc       qword ptr[%rip+mc_decls.nworkregs]
L1598:
    mov       %rax,	5
    mov       [%rip+mc_decls.nworkxregs],	%rax
    mov       %rax,	[%rip+mc_decls.nworkregs]
    sub       %rax,	3
    mov       %rbx,	%rax
    cmp       %r12,	3
    jg        L1600
    test      %rbx,	%rbx
    jz        L1600
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.workregs]
    mov       [%r10+13],	%al
    dec       %rbx
    cmp       %r12,	2
    jg        L1602
    test      %rbx,	%rbx
    jz        L1602
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.workregs]
    mov       [%r10+12],	%al
    dec       %rbx
L1602:
L1600:
    mov       %rsi,	10
    mov       %r13,	%rbx
    cmp       %r13,	0
    jle       L1605
L1603:
    mov       %rax,	%rsi
    dec       %rsi
    mov       %r10b,	1
    lea       %r11,	[%rip+mc_decls.workregs]
    mov       [%r11 + %rax-1],	%r10b
    dec       %r13
    jnz       L1603
L1605:
    mov       %rsi,	7
    mov       %rax,	[%rip+mc_decls.nworkxregs]
    sub       %rax,	2
    mov       %r14,	%rax
    cmp       %r14,	0
    jle       L1608
L1606:
    mov       %rax,	%rsi
    inc       %rsi
    mov       %r10b,	1
    lea       %r11,	[%rip+mc_decls.workxregs]
    mov       [%r11 + %rax-1],	%r10b
    dec       %r14
    jnz       L1606
L1608:
L1589:
    mov       %rsi,	4
L1609:
    lea       %rax,	[%rip+mc_decls.workregs]
    mov       %r10,	%rsi
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jnz       L1613
    inc       qword ptr[%rip+mc_decls.maxregvars]
L1613:
    inc       %rsi
    cmp       %rsi,	10
    jle       L1609
    mov       %rsi,	7
L1614:
    lea       %rax,	[%rip+mc_decls.workxregs]
    mov       %r10,	%rsi
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jnz       L1618
    inc       qword ptr[%rip+mc_decls.maxxregvars]
L1618:
    inc       %rsi
    cmp       %rsi,	16
    jle       L1614
    lea       %rax,	[%rip+mc_decls.usedregs]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    lea       %rax,	[%rip+mc_decls.usedxregs]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    lea       %rax,	[%rip+mc_decls.pcltempflags]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    mov       [%rax+16],	%r10
    mov       [%rax+24],	%r10
    mov       [%rax+32],	%r10
    mov       [%rax+40],	%r10
    mov       [%rax+48],	%r10w
    xor       %eax,	%eax
    mov       [%rip+pc_decls.r11used],	%al
    mov       [%rip+pc_decls.r10used],	%al
    xor       %eax,	%eax
    mov       [%rip+mc_decls.mstackdepth],	%rax
    xor       %eax,	%eax
    mov       [%rip+mc_decls.noperands],	%rax
    xor       %eax,	%eax
    mov       [%rip+mc_genmcl.framebytes],	%rax
    mov       [%rip+mc_genmcl.paramoffset],	%rax
    mov       [%rip+mc_genmcl.frameoffset],	%rax
    xor       %eax,	%eax
    mov       [%rip+pc_decls.localshadow],	%al
    xor       %eax,	%eax
    mov       [%rip+mc_decls.nblocktemps],	%rax
    movzx     %rax,	byte ptr[%r15+82]
    cmp       %rax,	11
    jnz       L1620
    lea       %rcx,	[%rip+L8181]
    mov       %rdx,	8
    call      pc_api.pc_makesymbol
    mov       %rdi,	%rax
    mov       %al,	[%r15+82]
    mov       [%rdi+82],	%al
    mov       %al,	1
    mov       [%rdi+92],	%al
    mov       %al,	5
    mov       [%rdi+72],	%al
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %rax,	[%rax+16]
    mov       [%rdi+16],	%rax
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       [%rdi+32],	%rax
    mov       %rax,	%rdi
    mov       %r10,	[%rip+pc_decls.currfunc]
    mov       [%r10+16],	%rax
    mov       [%rip+pc_decls.blockretname],	%rdi
L1620:
    mov       %al,	[%rip+pc_decls.fregoptim]
    test      %al,	%al
    jz        L1623
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %rax,	[%rax+48]
    test      %rax,	%rax
    jnz       L1622
L1623:
    jmp       L1588
L1622:
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %rax,	[%rax+48]
    mov       %al,	[%rax+5]
    test      %al,	%al
    jnz       L1588
L1625:
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %rax,	[%rax+48]
    movzx     %rax,	byte ptr[%rax+3]
    mov       [%rbp + mc_auxmcl.initproc.$T1],	%rax
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %al,	[%rax+110]
    test      %al,	%al
    jnz       L1626
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %al,	[%rax+113]
    test      %al,	%al
    jz        L1627
L1626:
    mov       %rax,	1
    jmp       L1628
L1627:
    xor       %eax,	%eax
L1628:
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_auxmcl.initproc.$T1]
    call      mc_auxmcl.allocregvars
L1588:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_procentry
mc_auxmcl.do_procentry:
#?>>
    .set mc_auxmcl.do_procentry.p, 72
    .set mc_auxmcl.do_procentry.ff, -8
    .set mc_auxmcl.do_procentry.r, -16
    .set mc_auxmcl.do_procentry.i, -24
    .set mc_auxmcl.do_procentry.$T1, -32
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	72
#---------------
    mov       %rcx,	[%rip+mc_decls.mclprocentry]
    call      mc_auxmcl.setmclentry
    xor       %eax,	%eax
    mov       [%rip+pc_decls.bxspill],	%rax
    mov       [%rip+pc_decls.bspill],	%rax
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %rax,	[%rax+48]
    test      %rax,	%rax
    jz        L1632
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %rax,	[%rax+48]
    mov       %al,	[%rax+5]
    test      %al,	%al
    jnz       L1631
L1632:
    mov       %rax,	4
    mov       [%rbp + mc_auxmcl.do_procentry.r],	%rax
L1633:
    lea       %rax,	[%rip+mc_decls.usedregs]
    mov       %r10,	[%rbp + mc_auxmcl.do_procentry.r]
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jnz       L1638
    lea       %rax,	[%rip+mc_decls.isregvar]
    mov       %r10,	[%rbp + mc_auxmcl.do_procentry.r]
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L1637
L1638:
    inc       qword ptr[%rip+pc_decls.bspill]
L1637:
    mov       %rax,	[%rbp + mc_auxmcl.do_procentry.r]
    inc       %rax
    mov       [%rbp + mc_auxmcl.do_procentry.r],	%rax
    cmp       %rax,	10
    jle       L1633
    mov       %rax,	7
    mov       [%rbp + mc_auxmcl.do_procentry.r],	%rax
L1639:
    lea       %rax,	[%rip+mc_decls.usedxregs]
    mov       %r10,	[%rbp + mc_auxmcl.do_procentry.r]
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jnz       L1644
    lea       %rax,	[%rip+mc_decls.isxregvar]
    mov       %r10,	[%rbp + mc_auxmcl.do_procentry.r]
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L1643
L1644:
    inc       qword ptr[%rip+pc_decls.bxspill]
L1643:
    mov       %rax,	[%rbp + mc_auxmcl.do_procentry.r]
    inc       %rax
    mov       [%rbp + mc_auxmcl.do_procentry.r],	%rax
    cmp       %rax,	16
    jle       L1639
L1631:
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %r14,	[%rax+16]
    jmp       L1648
L1645:
    mov       %al,	[%r14+91]
    test      %al,	%al
    jz        L1650
    lea       %rcx,	[%rip+L8182]
    lea       %rdx,	[%rip+L8183]
    call      pc_api.merror
L1650:
    mov       %al,	[%r14+90]
    test      %al,	%al
    jnz       L1652
    mov       %rax,	[%rip+mc_genmcl.paramoffset]
    add       %rax,	16
    mov       %r10,	[%rip+pc_decls.bspill]
    add       %r10,	[%rip+pc_decls.bxspill]
    shl       %r10,	3
    add       %rax,	%r10
    mov       [%r14+76],	%eax
    movsxd    %rax,	dword ptr[%r14+76]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       [%rbp + mc_auxmcl.do_procentry.$T1],	%rax
    mov       %rcx,	%r14
    call      mc_writegas.getdispname
    mov       %rcx,	%rax
    call      mc_libmcl.mgenname
    mov       %rcx,	5
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.do_procentry.$T1]
    call      mc_libmcl.genmc
    jmp       L1651
L1652:
    movzx     %rax,	byte ptr[%r14+90]
    mov       %r15,	%rax
    lea       %rax,	[%rip+mc_decls.usedregs]
    movzx     %rax,	byte ptr[%rax+14]
    mov       [%rbp + mc_auxmcl.do_procentry.ff],	%rax
    xor       %eax,	%eax
    mov       [%r14+90],	%al
    movzx     %rax,	byte ptr[%r14+82]
    mov       %rcx,	%r15
    mov       %rdx,	%rax
    call      mc_libmcl.mgenreg
    mov       [%rbp + mc_auxmcl.do_procentry.$T1],	%rax
    mov       %rcx,	%r14
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       %rcx,	6
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.do_procentry.$T1]
    call      mc_libmcl.genmc
    mov       [%r14+90],	%r15b
    mov       %al,	[%rbp + mc_auxmcl.do_procentry.ff]
    lea       %r10,	[%rip+mc_decls.usedregs]
    mov       [%r10+14],	%al
L1651:
    mov       %rax,	8
    add       [%rip+mc_genmcl.paramoffset],	%rax
    mov       %r14,	[%r14+16]
L1648:
    test      %r14,	%r14
    jnz       L1645
    mov       %rax,	[%rip+pc_decls.currfunc]
    movzx     %rax,	byte ptr[%rax+82]
    mov       %rdi,	%rax
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %r14,	[%rax+24]
    jmp       L1656
L1653:
    movzx     %rax,	byte ptr[%r14+82]
    lea       %r10,	[%rip+pc_tables.psize]
    movzx     %r10,	byte ptr[%r10 + %rax]
    mov       %r12,	%r10
    movzx     %rax,	byte ptr[%r14+82]
    cmp       %rax,	11
    jnz       L1658
    mov       %eax,	[%r14+84]
    mov       %r12,	%rax
L1658:
    mov       %al,	[%r14+92]
    test      %al,	%al
    jz        L1654
L1660:
    mov       %al,	[%r14+91]
    test      %al,	%al
    jz        L1662
    mov       %rsi,	1
    jmp       L1661
L1662:
    mov       %al,	[%r14+90]
    test      %al,	%al
    jz        L1663
    movzx     %rax,	byte ptr[%r14+90]
    mov       %r15,	%rax
    lea       %rax,	[%rip+mc_decls.usedregs]
    movzx     %rax,	byte ptr[%rax+14]
    mov       [%rbp + mc_auxmcl.do_procentry.ff],	%rax
    xor       %eax,	%eax
    mov       [%r14+90],	%al
    movzx     %rax,	byte ptr[%r14+82]
    mov       %rcx,	%r15
    mov       %rdx,	%rax
    call      mc_libmcl.mgenreg
    mov       [%rbp + mc_auxmcl.do_procentry.$T1],	%rax
    mov       %rcx,	%r14
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       %rcx,	6
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.do_procentry.$T1]
    call      mc_libmcl.genmc
    mov       [%r14+90],	%r15b
    mov       %al,	[%rbp + mc_auxmcl.do_procentry.ff]
    lea       %r10,	[%rip+mc_decls.usedregs]
    mov       [%r10+14],	%al
    jmp       L1661
L1663:
    mov       %rcx,	%r12
    call      mc_libmcl.roundsizetg
    sub       [%rip+mc_genmcl.frameoffset],	%rax
    mov       %eax,	[%rip+mc_genmcl.frameoffset]
    mov       [%r14+76],	%eax
    movsxd    %rax,	dword ptr[%r14+76]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       [%rbp + mc_auxmcl.do_procentry.$T1],	%rax
    mov       %rcx,	%r14
    call      mc_writegas.getdispname
    mov       %rcx,	%rax
    call      mc_libmcl.mgenname
    mov       %rcx,	5
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.do_procentry.$T1]
    call      mc_libmcl.genmc
L1661:
L1654:
    mov       %r14,	[%r14+24]
L1656:
    test      %r14,	%r14
    jnz       L1653
    xor       %rbx,	%rbx
    mov       %rax,	1
    mov       [%rbp + mc_auxmcl.do_procentry.i],	%rax
L1664:
    lea       %rax,	[%rip+mc_decls.pcltempflags]
    mov       %r10,	[%rbp + mc_auxmcl.do_procentry.i]
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L1668
    inc       %rbx
    mov       %rax,	8
    sub       [%rip+mc_genmcl.frameoffset],	%rax
    lea       %rax,	[%rip+mc_decls.pcltempopnds]
    mov       %r10,	[%rbp + mc_auxmcl.do_procentry.i]
    mov       %r13,	[%rax + %r10*8-8]
    mov       %eax,	[%rip+mc_genmcl.frameoffset]
    mov       [%r13+12],	%eax
    movsxd    %rax,	dword ptr[%r13+12]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       [%rbp + mc_auxmcl.do_procentry.$T1],	%rax
    mov       %rcx,	[%rip+pc_decls.currfunc]
    mov       %rdx,	[%rbp + mc_auxmcl.do_procentry.i]
    call      mc_writegas.gettempname
    mov       %rcx,	%rax
    call      mc_libmcl.mgenname
    mov       %rcx,	5
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.do_procentry.$T1]
    call      mc_libmcl.genmc
L1668:
    mov       %rax,	[%rbp + mc_auxmcl.do_procentry.i]
    inc       %rax
    mov       [%rbp + mc_auxmcl.do_procentry.i],	%rax
    cmp       %rax,	50
    jle       L1664
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %al,	[%rax+108]
    test      %al,	%al
    jz        L1670
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %ax,	[%rax+114]
    test      %ax,	%ax
    jnz       L1673
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %al,	[%rax+112]
    test      %al,	%al
    jz        L1672
L1673:
    lea       %rcx,	[%rip+L8184]
    lea       %rdx,	[%rip+L8185]
    call      pc_api.merror
L1672:
    test      %rbx,	%rbx
    jz        L1675
    lea       %rcx,	[%rip+L8186]
    lea       %rdx,	[%rip+L8187]
    call      pc_api.merror
L1675:
    call      mc_auxmcl.resetmclentry
    jmp       L1629
L1670:
    mov       %rax,	[%rip+mc_genmcl.frameoffset]
    neg       %rax
    mov       [%rip+mc_genmcl.framebytes],	%rax
    mov       %rax,	[%rip+pc_decls.bspill]
    add       %rax,	[%rip+pc_decls.bxspill]
    and       %eax,	1
    test      %rax,	%rax
    jz        L1677
    mov       %rax,	[%rip+mc_genmcl.framebytes]
    and       %rax,	8
    jnz       L1679
    mov       %rax,	8
    add       [%rip+mc_genmcl.framebytes],	%rax
L1679:
    jmp       L1676
L1677:
    mov       %rax,	[%rip+mc_genmcl.framebytes]
    and       %rax,	8
    jz        L1681
    mov       %rax,	8
    add       [%rip+mc_genmcl.framebytes],	%rax
L1681:
L1676:
    mov       %al,	[%rip+pc_decls.localshadow]
    test      %al,	%al
    jz        L1683
    mov       %rax,	32
    add       [%rip+mc_genmcl.framebytes],	%rax
L1683:
    mov       %rax,	[%rip+pc_decls.bspill]
    test      %rax,	%rax
    jz        L1685
    mov       %rax,	4
    mov       [%rbp + mc_auxmcl.do_procentry.r],	%rax
L1686:
    lea       %rax,	[%rip+mc_decls.usedregs]
    mov       %r10,	[%rbp + mc_auxmcl.do_procentry.r]
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jnz       L1691
    lea       %rax,	[%rip+mc_decls.isregvar]
    mov       %r10,	[%rbp + mc_auxmcl.do_procentry.r]
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L1690
L1691:
    mov       %rcx,	[%rbp + mc_auxmcl.do_procentry.r]
    mov       %rdx,	6
    call      mc_libmcl.mgenreg
    mov       %rcx,	12
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L1690:
    mov       %rax,	[%rbp + mc_auxmcl.do_procentry.r]
    inc       %rax
    mov       [%rbp + mc_auxmcl.do_procentry.r],	%rax
    cmp       %rax,	10
    jle       L1686
L1685:
    mov       %rax,	[%rip+pc_decls.bxspill]
    test      %rax,	%rax
    jz        L1693
    mov       %rcx,	1
    mov       %rdx,	6
    call      mc_libmcl.mgenreg
    mov       %r13,	%rax
    mov       %rax,	7
    mov       [%rbp + mc_auxmcl.do_procentry.r],	%rax
L1694:
    lea       %rax,	[%rip+mc_decls.usedxregs]
    mov       %r10,	[%rbp + mc_auxmcl.do_procentry.r]
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jnz       L1699
    lea       %rax,	[%rip+mc_decls.isxregvar]
    mov       %r10,	[%rbp + mc_auxmcl.do_procentry.r]
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L1698
L1699:
    mov       %rcx,	[%rbp + mc_auxmcl.do_procentry.r]
    mov       %rdx,	8
    call      mc_libmcl.mgenxreg
    mov       %rcx,	17
    mov       %rdx,	%r13
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	12
    mov       %rdx,	%r13
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L1698:
    mov       %rax,	[%rbp + mc_auxmcl.do_procentry.r]
    inc       %rax
    mov       [%rbp + mc_auxmcl.do_procentry.r],	%rax
    cmp       %rax,	16
    jle       L1694
L1693:
    lea       %rcx,	[%rip+L8188]
    call      mc_libmcl.mgencomment
    mov       %rax,	[%rip+mc_decls.mccodex]
    mov       [%rip+mc_auxmcl.mclframesetup],	%rax
    call      mc_auxmcl.spillparams
    lea       %rcx,	[%rip+L8189]
    call      mc_libmcl.mgencomment
    call      mc_auxmcl.resetmclentry
L1629:
#---------------
    add       %rsp,	72
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_procexit
mc_auxmcl.do_procexit:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
    lea       %rcx,	[%rip+L8189]
    call      mc_libmcl.mgencomment
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %al,	[%rax+108]
    test      %al,	%al
    jz        L1702
    mov       %rcx,	22
    xor       %edx,	%edx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L1700
L1702:
    mov       %rcx,	[%rip+mc_auxmcl.mclframesetup]
    call      mc_auxmcl.setmclentryf
    mov       %rax,	[%rip+mc_genmcl.framebytes]
    test      %rax,	%rax
    jnz       L1705
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %al,	[%rax+112]
    test      %al,	%al
    jnz       L1705
    lea       %rax,	[%rip+mc_decls.usedregs]
    mov       %al,	[%rax+14]
    test      %al,	%al
    jz        L1704
L1705:
    lea       %rax,	[%rip+mc_decls.usedregs]
    mov       %al,	[%rax+14]
    test      %al,	%al
    jz        L1707
    mov       %rcx,	12
    mov       %rdx,	[%rip+mc_decls.dframeopnd]
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	11
    mov       %rdx,	[%rip+mc_decls.dframeopnd]
    mov       %r8,	[%rip+mc_decls.dstackopnd]
    call      mc_libmcl.genmc
    mov       %rcx,	[%rip+mc_genmcl.framebytes]
    call      mc_libmcl.pushstack
    jmp       L1706
L1707:
    mov       %rax,	[%rip+mc_genmcl.framebytes]
    test      %rax,	%rax
    jz        L1709
    mov       %rax,	[%rip+mc_genmcl.framebytes]
    add       %rax,	8
    mov       %rcx,	%rax
    call      mc_libmcl.pushstack
L1709:
L1706:
L1704:
    call      mc_auxmcl.resetmclentryf
    mov       %rax,	[%rip+mc_genmcl.framebytes]
    test      %rax,	%rax
    jnz       L1712
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %al,	[%rax+112]
    test      %al,	%al
    jnz       L1712
    lea       %rax,	[%rip+mc_decls.usedregs]
    mov       %al,	[%rax+14]
    test      %al,	%al
    jz        L1711
L1712:
    lea       %rax,	[%rip+mc_decls.usedregs]
    mov       %al,	[%rax+14]
    test      %al,	%al
    jz        L1714
    mov       %rcx,	[%rip+mc_genmcl.framebytes]
    call      mc_libmcl.popstack
    mov       %rcx,	13
    mov       %rdx,	[%rip+mc_decls.dframeopnd]
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L1713
L1714:
    mov       %rax,	[%rip+mc_genmcl.framebytes]
    test      %rax,	%rax
    jz        L1716
    mov       %rax,	[%rip+mc_genmcl.framebytes]
    add       %rax,	8
    mov       %rcx,	%rax
    call      mc_libmcl.popstack
L1716:
L1713:
L1711:
    mov       %rax,	[%rip+pc_decls.bxspill]
    test      %rax,	%rax
    jz        L1718
    mov       %rcx,	11
    mov       %rdx,	6
    call      mc_libmcl.mgenreg
    mov       %rdi,	%rax
    mov       %rbx,	16
L1719:
    lea       %rax,	[%rip+mc_decls.usedxregs]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L1723
    mov       %rcx,	13
    mov       %rdx,	%rdi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	%rbx
    mov       %rdx,	8
    call      mc_libmcl.mgenxreg
    mov       %rcx,	17
    mov       %rdx,	%rax
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
L1723:
    dec       %rbx
    cmp       %rbx,	7
    jge       L1719
L1718:
    mov       %rax,	[%rip+pc_decls.bspill]
    test      %rax,	%rax
    jz        L1725
    mov       %rbx,	10
L1726:
    lea       %rax,	[%rip+mc_decls.usedregs]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L1730
    mov       %rcx,	%rbx
    mov       %rdx,	6
    call      mc_libmcl.mgenreg
    mov       %rcx,	13
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L1730:
    dec       %rbx
    cmp       %rbx,	4
    jge       L1726
L1725:
    mov       %rcx,	22
    xor       %edx,	%edx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L1700:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.spillparams
mc_auxmcl.spillparams:
#?>>
    .set mc_auxmcl.spillparams.$T1, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
#---------------
    mov       %rsi,	16
    xor       %r12,	%r12
    xor       %eax,	%eax
    mov       %r12,	%rax
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %rdi,	[%rax+16]
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %al,	[%rax+113]
    test      %al,	%al
    jz        L1733
    movsxd    %rax,	dword ptr[%rdi+76]
    mov       %r13,	%rax
    mov       %rax,	[%rip+pc_decls.currfunc]
    movzx     %rax,	byte ptr[%rax+112]
    mov       %r14,	%rax
    cmp       %r14,	3
    jg        L1736
L1734:
    sub       %rsp,	8
    push      0
    push      0
    push      8
    mov       %rax,	%r14
    shl       %rax,	3
    add       %rax,	%r13
    mov       %rcx,	15
    xor       %edx,	%edx
    mov       %r8,	1
    mov       %r9,	%rax
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rbx,	%rax
    lea       %rax,	[%r14+11]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    inc       %r14
    cmp       %r14,	3
    jle       L1734
L1736:
L1733:
    jmp       L1740
L1737:
    cmp       %r12,	3
    jg        L1739
L1742:
    mov       %al,	[%rdi+92]
    test      %al,	%al
    jz        L1744
    mov       %al,	[%rdi+90]
    test      %al,	%al
    jnz       L1746
    sub       %rsp,	8
    push      0
    push      0
    push      8
    movsxd    %rax,	dword ptr[%rdi+76]
    mov       %rcx,	15
    xor       %edx,	%edx
    mov       %r8,	1
    mov       %r9,	%rax
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rdi+82]
    cmp       %rax,	2
    jz        L1748
    cmp       %rax,	1
    jz        L1749
    jmp       L1750
L1748:
    lea       %rax,	[%r12+1]
    mov       %rcx,	%rax
    mov       %rdx,	8
    call      mc_libmcl.mgenxreg
    mov       %rcx,	17
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L1747
L1749:
    lea       %rax,	[%r12+1]
    mov       %rcx,	%rax
    mov       %rdx,	8
    call      mc_libmcl.mgenxreg
    mov       [%rbp + mc_auxmcl.spillparams.$T1],	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	4
    call      mc_libmcl.changeopndsize
    mov       %rcx,	16
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.spillparams.$T1]
    call      mc_libmcl.genmc
    jmp       L1747
L1750:
    lea       %rax,	[%r12+11]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L1747:
    jmp       L1745
L1746:
    mov       %al,	[%rdi+90]
    test      %al,	%al
    jz        L1751
    movzx     %rax,	byte ptr[%rdi+82]
    cmp       %rax,	2
    jg        L1753
    movzx     %rax,	byte ptr[%rdi+90]
    cmp       %rax,	5
    jl        L1755
    movzx     %rax,	byte ptr[%rdi+82]
    lea       %r10,	[%r12+1]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_libmcl.mgenxreg
    mov       [%rbp + mc_auxmcl.spillparams.$T1],	%rax
    movzx     %rax,	byte ptr[%rdi+90]
    mov       %rcx,	%rax
    mov       %rdx,	8
    call      mc_libmcl.mgenxreg
    mov       %rcx,	17
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.spillparams.$T1]
    call      mc_libmcl.genmc
L1755:
    jmp       L1752
L1753:
    movzx     %rax,	byte ptr[%rdi+90]
    cmp       %rax,	10
    jg        L1756
    movzx     %rax,	byte ptr[%rdi+82]
    lea       %r10,	[%r12+11]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_libmcl.mgenreg
    mov       [%rbp + mc_auxmcl.spillparams.$T1],	%rax
    movzx     %rax,	byte ptr[%rdi+82]
    movzx     %r10,	byte ptr[%rdi+90]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_libmcl.mgenreg
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.spillparams.$T1]
    call      mc_libmcl.genmc
L1756:
L1752:
L1751:
L1745:
L1744:
    mov       %rax,	8
    add       %rsi,	%rax
    inc       %r12
    mov       %rdi,	[%rdi+16]
L1740:
    test      %rdi,	%rdi
    jnz       L1737
L1739:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_jumptruefalse
mc_auxmcl.do_jumptruefalse:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jle       L1759
    mov       %rcx,	41
    mov       %rdx,	%rdi
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    jmp       L1758
L1759:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rax
    call      mc_stackmcl.getworkregm
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    dec       %rax
    mov       %r10,	76
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rbx
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    dec       %rax
    mov       %r10,	73
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L1758:
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %rcx,	26
    mov       %rdx,	%r12
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_bitwise
mc_auxmcl.do_bitwise:
#?>>
    .set mc_auxmcl.do_bitwise.p, 40
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rdx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    mov       %rcx,	%rsi
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_shift
mc_auxmcl.do_shift:
#?>>
    .set mc_auxmcl.do_shift.p, 48
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rdx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	[%rip+mc_decls.noperands]
    mov       %rsi,	[%rax + %r10*8-8]
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    test      %rax,	%rax
    jnz       L1763
    movzx     %rax,	byte ptr[%rsi+1]
    cmp       %rax,	4
    jnz       L1763
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	%r12
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L1762
L1763:
    mov       %al,	[%rip+pc_decls.r10used]
    test      %al,	%al
    jz        L1765
    mov       %rcx,	11
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	12
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L1765:
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	3
    mov       %r8,	11
    call      mc_stackmcl.loadparam
    mov       %rbx,	%rax
    mov       %rcx,	%r12
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    mov       %al,	[%rip+pc_decls.r10used]
    test      %al,	%al
    jz        L1767
    mov       %rcx,	11
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	13
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L1767:
L1762:
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.setmclentry
mc_auxmcl.setmclentry:
#?>>
#?]]
#---------------
    mov       %rax,	[%rip+mc_decls.mccodex]
    mov       [%rip+mc_decls.mce_oldmccodex],	%rax
    mov       [%rip+mc_decls.mccodex],	%rcx
    mov       %rax,	[%rcx]
    mov       [%rip+mc_decls.mce_lastmcl],	%rax
    mov       %rax,	[%rcx+8]
    mov       [%rip+mc_decls.mce_nextmcl],	%rax
#---------------
    ret       
# End 
# Proc mc_auxmcl.resetmclentry
mc_auxmcl.resetmclentry:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	16
#---------------
    mov       %rax,	[%rip+mc_decls.mce_lastmcl]
    mov       %r10,	[%rip+mc_decls.mccodex]
    mov       [%r10],	%rax
    mov       %rax,	[%rip+mc_decls.mce_nextmcl]
    mov       %r10,	[%rip+mc_decls.mccodex]
    mov       [%r10+8],	%rax
    mov       %rdi,	[%rip+mc_decls.mccodex]
    mov       %rax,	[%rip+mc_decls.mce_oldmccodex]
    mov       [%rip+mc_decls.mccodex],	%rax
    mov       %rax,	%rdi
L1769:
#---------------
    add       %rsp,	16
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.setmclentryf
mc_auxmcl.setmclentryf:
#?>>
#?]]
#---------------
    mov       %rax,	[%rip+mc_decls.mccodex]
    mov       [%rip+mc_decls.mcf_oldmccodex],	%rax
    mov       [%rip+mc_decls.mccodex],	%rcx
    mov       %rax,	[%rcx]
    mov       [%rip+mc_decls.mcf_lastmcl],	%rax
    mov       %rax,	[%rcx+8]
    mov       [%rip+mc_decls.mcf_nextmcl],	%rax
#---------------
    ret       
# End 
# Proc mc_auxmcl.resetmclentryf
mc_auxmcl.resetmclentryf:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	16
#---------------
    mov       %rax,	[%rip+mc_decls.mcf_lastmcl]
    mov       %r10,	[%rip+mc_decls.mccodex]
    mov       [%r10],	%rax
    mov       %rax,	[%rip+mc_decls.mcf_nextmcl]
    mov       %r10,	[%rip+mc_decls.mccodex]
    mov       [%r10+8],	%rax
    mov       %rdi,	[%rip+mc_decls.mccodex]
    mov       %rax,	[%rip+mc_decls.mcf_oldmccodex]
    mov       [%rip+mc_decls.mccodex],	%rax
    mov       %rax,	%rdi
L1771:
#---------------
    add       %rsp,	16
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_pushlowargs
mc_auxmcl.do_pushlowargs:
#?>>
    .set mc_auxmcl.do_pushlowargs.isptr, 72
    .set mc_auxmcl.do_pushlowargs.pstack, 80
    .set mc_auxmcl.do_pushlowargs.nextireg, -8
    .set mc_auxmcl.do_pushlowargs.nextxreg, -16
    .set mc_auxmcl.do_pushlowargs.mode, -24
    .set mc_auxmcl.do_pushlowargs.imode, -32
    .set mc_auxmcl.do_pushlowargs.blockret, -40
    .set mc_auxmcl.do_pushlowargs.dblock, -48
    .set mc_auxmcl.do_pushlowargs.av_1, -56
    .set mc_auxmcl.do_pushlowargs.i, -64
    .set mc_auxmcl.do_pushlowargs.$T1, -72
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	104
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       [%rbp+72],	%r8
    mov       [%rbp+80],	%r9
#---------------
    test      %r12,	%r12
    jnz       L1774
    jmp       L1772
L1774:
    mov       %rax,	[%rbp + mc_auxmcl.do_pushlowargs.pstack]
    test      %rax,	%rax
    jz        L1776
    xor       %eax,	%eax
    mov       [%rbp + mc_auxmcl.do_pushlowargs.blockret],	%rax
    jmp       L1775
L1776:
    lea       %rax,	[%rip+mc_decls.callblockret]
    mov       %r10,	[%rip+mc_decls.ncalldepth]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       [%rbp + mc_auxmcl.do_pushlowargs.blockret],	%rax
L1775:
    mov       %rax,	11
    mov       [%rbp + mc_auxmcl.do_pushlowargs.nextireg],	%rax
    mov       %rax,	1
    mov       [%rbp + mc_auxmcl.do_pushlowargs.nextxreg],	%rax
    xor       %rsi,	%rsi
    mov       %rax,	[%rip+mc_decls.noperands]
    mov       [%rbp + mc_auxmcl.do_pushlowargs.i],	%rax
    mov       %rax,	[%rip+mc_decls.noperands]
    sub       %rax,	%r12
    inc       %rax
    mov       [%rbp + mc_auxmcl.do_pushlowargs.av_1],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.do_pushlowargs.i]
    cmp       %rax,	[%rbp + mc_auxmcl.do_pushlowargs.av_1]
    jl        L1779
L1777:
    inc       %rsi
    cmp       %rsi,	1
    jnz       L1781
    mov       %rax,	[%rbp + mc_auxmcl.do_pushlowargs.blockret]
    test      %rax,	%rax
    jz        L1781
    lea       %rax,	[%rip+mc_decls.callblocksize]
    mov       %r10,	[%rip+mc_decls.ncalldepth]
    mov       %eax,	[%rax + %r10*4-4]
    mov       %rcx,	%rax
    call      mc_libmcl.newblocktemp
    mov       [%rbp + mc_auxmcl.do_pushlowargs.dblock],	%rax
    mov       %al,	1
    mov       %r10,	[%rbp + mc_auxmcl.do_pushlowargs.dblock]
    mov       [%r10+92],	%al
    mov       %rcx,	[%rbp + mc_auxmcl.do_pushlowargs.dblock]
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       [%rbp + mc_auxmcl.do_pushlowargs.$T1],	%rax
    mov       %rcx,	11
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	14
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.do_pushlowargs.$T1]
    call      mc_libmcl.genmc
    jmp       L1780
L1781:
    mov       %rax,	[%rbp + mc_auxmcl.do_pushlowargs.i]
    sub       %rax,	[%rbp + mc_auxmcl.do_pushlowargs.isptr]
    add       %rax,	[%rbp + mc_auxmcl.do_pushlowargs.blockret]
    mov       %rbx,	%rax
    mov       %rax,	[%rbp + mc_auxmcl.do_pushlowargs.pstack]
    test      %rax,	%rax
    jz        L1783
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       [%rbp + mc_auxmcl.do_pushlowargs.mode],	%rax
    jmp       L1782
L1783:
    lea       %rax,	[%rip+mc_decls.callargmode]
    mov       %r10,	[%rip+mc_decls.ncalldepth]
    shl       %r10,	5
    lea       %rax,	[%rax + %r10-32]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       [%rbp + mc_auxmcl.do_pushlowargs.mode],	%rax
L1782:
    mov       %rax,	[%rbp + mc_auxmcl.do_pushlowargs.mode]
    cmp       %rax,	11
    jz        L1785
    cmp       %rax,	2
    jz        L1786
    cmp       %rax,	1
    jz        L1786
    jmp       L1787
L1785:
    mov       %rcx,	%rbx
    mov       %rdx,	[%rbp + mc_auxmcl.do_pushlowargs.mode]
    mov       %r8,	[%rbp + mc_auxmcl.do_pushlowargs.nextireg]
    call      mc_stackmcl.loadparam
    mov       %rdi,	%rax
    lea       %rax,	[%rip+mc_decls.callargsize]
    mov       %r10,	[%rip+mc_decls.ncalldepth]
    shl       %r10,	7
    lea       %rax,	[%rax + %r10-128]
    mov       %r10,	%rsi
    mov       %eax,	[%rax + %r10*4-4]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    mov       %r8,	%rsi
    call      mc_auxmcl.copyblockarg
    jmp       L1784
L1786:
    mov       %rcx,	%rbx
    mov       %rdx,	[%rbp + mc_auxmcl.do_pushlowargs.mode]
    mov       %r8,	[%rbp + mc_auxmcl.do_pushlowargs.nextxreg]
    call      mc_stackmcl.loadparam
    test      %r13,	%r13
    jz        L1789
    cmp       %rsi,	%r13
    jl        L1789
    mov       %rax,	[%rbp + mc_auxmcl.do_pushlowargs.mode]
    cmp       %rax,	1
    jnz       L1791
    mov       %rax,	5
    jmp       L1790
L1791:
    mov       %rax,	6
L1790:
    mov       [%rbp + mc_auxmcl.do_pushlowargs.imode],	%rax
    mov       %rcx,	[%rbp + mc_auxmcl.do_pushlowargs.nextxreg]
    mov       %rdx,	[%rbp + mc_auxmcl.do_pushlowargs.mode]
    call      mc_libmcl.mgenreg
    mov       [%rbp + mc_auxmcl.do_pushlowargs.$T1],	%rax
    mov       %rcx,	[%rbp + mc_auxmcl.do_pushlowargs.nextireg]
    mov       %rdx,	[%rbp + mc_auxmcl.do_pushlowargs.imode]
    call      mc_libmcl.mgenreg
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.do_pushlowargs.$T1]
    call      mc_libmcl.genmc
L1789:
    jmp       L1784
L1787:
#mc_auxmcl.do_pushlowargs.doint:
    mov       %rcx,	%rbx
    mov       %rdx,	[%rbp + mc_auxmcl.do_pushlowargs.mode]
    mov       %r8,	[%rbp + mc_auxmcl.do_pushlowargs.nextireg]
    call      mc_stackmcl.loadparam
L1784:
L1780:
    inc       qword ptr[%rbp + mc_auxmcl.do_pushlowargs.nextireg]
    inc       qword ptr[%rbp + mc_auxmcl.do_pushlowargs.nextxreg]
    mov       %rax,	[%rbp + mc_auxmcl.do_pushlowargs.i]
    dec       %rax
    mov       [%rbp + mc_auxmcl.do_pushlowargs.i],	%rax
    cmp       %rax,	[%rbp + mc_auxmcl.do_pushlowargs.av_1]
    jge       L1777
L1779:
L1772:
#---------------
    add       %rsp,	104
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_getretvalue
mc_auxmcl.do_getretvalue:
#?>>
    .set mc_auxmcl.do_getretvalue.modes, -80
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	112
    mov       %r12,	%rcx
#---------------
    lea       %rax,	[%r12+32]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	13
    jnz       L1795
    xor       %rbx,	%rbx
    jmp       L1797
L1796:
    movzx     %rax,	byte ptr[%r12+3]
    inc       %rbx
    mov       %r10,	%rbx
    mov       [%rbp + %r10*8 + mc_auxmcl.do_getretvalue.modes-8],	%rax
L1797:
    add       %r12,	32
    mov       %rax,	%r12
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	13
    jz        L1796
    lea       %rax,	[%r12-32]
    mov       [%rip+mc_decls.currpcl],	%rax
    mov       %rdi,	%rbx
    cmp       %rdi,	1
    jl        L1801
L1799:
    mov       %rsi,	[%rbp + %rdi*8 + mc_auxmcl.do_getretvalue.modes-8]
    cmp       %rsi,	2
    jg        L1803
    lea       %rax,	[%rip+mc_decls.multxregs]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    jmp       L1802
L1803:
    lea       %rax,	[%rip+mc_decls.multregs]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
L1802:
    mov       %rcx,	%rsi
    mov       %rdx,	%rax
    call      mc_stackmcl.pushpcl_reg
    dec       %rdi
    cmp       %rdi,	1
    jge       L1799
L1801:
    jmp       L1794
L1795:
    mov       %al,	[%r12+3]
    test      %al,	%al
    jz        L1804
    movzx     %rax,	byte ptr[%r12+3]
    mov       %rcx,	%rax
    mov       %rdx,	1
    call      mc_stackmcl.pushpcl_reg
L1804:
L1794:
#---------------
    add       %rsp,	112
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.ismemaddr
mc_auxmcl.ismemaddr:
#?>>
#?]]
#---------------
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rcx
    movzx     %rax,	byte ptr[%rax + %r10-1]
    test      %rax,	%rax
    jnz       L1807
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	%rcx
    mov       %rax,	[%rax + %r10*8-8]
    movzx     %rax,	byte ptr[%rax+1]
    cmp       %rax,	2
    jnz       L1807
    mov       %rax,	1
    jmp       L1805
L1807:
    xor       %eax,	%eax
L1805:
#---------------
    ret       
# End 
# Proc mc_auxmcl.do_incr
mc_auxmcl.do_incr:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    movzx     %rax,	byte ptr[%rbx+3]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    movsxd    %rax,	dword ptr[%rbx+16]
    cmp       %rax,	1
    jnz       L1810
    mov       %rcx,	%rsi
    mov       %rdx,	%rdi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L1809
L1810:
    movsxd    %rax,	dword ptr[%rbx+16]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	%r12
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L1809:
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_incrload
mc_auxmcl.do_incrload:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	[%rip+mc_decls.noperands]
    movzx     %r10,	byte ptr[%r10 + %r11-1]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_stackmcl.getworkreg_rm
    mov       %rdi,	%rax
    movsxd    %rax,	dword ptr[%rsi+16]
    cmp       %rax,	1
    jnz       L1813
    mov       %rcx,	%r12
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L1812
L1813:
    movsxd    %rax,	dword ptr[%rsi+16]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	%r13
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L1812:
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.pclloc]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11-1],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+mc_decls.pclopnd]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11*8-8],	%rax
    mov       %al,	[%rdi+10]
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11-1],	%al
    mov       %al,	[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+mc_decls.pclmode]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11-1],	%al
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_loadincr
mc_auxmcl.do_loadincr:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      mc_stackmcl.pushpcl_reg
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rdi,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    movsxd    %rax,	dword ptr[%rsi+16]
    cmp       %rax,	1
    jnz       L1816
    mov       %rcx,	%r12
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L1815
L1816:
    movsxd    %rax,	dword ptr[%rsi+16]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	%r13
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L1815:
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_for
mc_auxmcl.do_for:
#?>>
    .set mc_auxmcl.do_for.addop, 80
    .set mc_auxmcl.do_for.cond, 88
    .set mc_auxmcl.do_for.mx, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       [%rbp+80],	%r8
    mov       [%rbp+88],	%r9
#---------------
    lea       %rax,	[%r13+32]
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+32]
    mov       [%rip+mc_decls.currpcl],	%rax
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rdi+8]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_libmcl.mgenmem
    mov       [%rbp + mc_auxmcl.do_for.mx],	%rax
    mov       %rax,	[%rdi+8]
    mov       %al,	[%rax+90]
    test      %al,	%al
    jz        L1819
    movsxd    %rax,	dword ptr[%r13+16]
    cmp       %rax,	1
    jnz       L1821
    mov       %rcx,	%r14
    mov       %rdx,	[%rbp + mc_auxmcl.do_for.mx]
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L1820
L1821:
    movsxd    %rax,	dword ptr[%r13+16]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	[%rbp + mc_auxmcl.do_for.addop]
    mov       %rdx,	[%rbp + mc_auxmcl.do_for.mx]
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L1820:
    mov       %rsi,	[%rbp + mc_auxmcl.do_for.mx]
    jmp       L1818
L1819:
    call      mc_stackmcl.getworkireg
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rsi,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rsi
    mov       %r8,	[%rbp + mc_auxmcl.do_for.mx]
    call      mc_libmcl.genmc
    movsxd    %rax,	dword ptr[%r13+16]
    cmp       %rax,	1
    jnz       L1823
    mov       %rcx,	%r14
    mov       %rdx,	%rsi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L1822
L1823:
    movsxd    %rax,	dword ptr[%r13+16]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	[%rbp + mc_auxmcl.do_for.addop]
    mov       %rdx,	%rsi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L1822:
    mov       %rcx,	11
    mov       %rdx,	[%rbp + mc_auxmcl.do_for.mx]
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
L1818:
    movzx     %rax,	byte ptr[%rbx+1]
    cmp       %rax,	4
    jnz       L1825
    mov       %rax,	[%rbx+8]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %r12,	%rax
    jmp       L1824
L1825:
    mov       %rax,	[%rbx+8]
    mov       %rcx,	%rax
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       %r12,	%rax
L1824:
    mov       %rcx,	42
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      mc_libmcl.genmc
    mov       %rax,	[%r13+8]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %rcx,	26
    mov       %rdx,	[%rbp + mc_auxmcl.do_for.cond]
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.scaleindex
mc_auxmcl.scaleindex:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rax,	%rbx
    cmp       %rax,	1
    jz        L1829
    cmp       %rax,	2
    jz        L1829
    cmp       %rax,	4
    jz        L1829
    cmp       %rax,	8
    jnz       L1828
L1829:
    mov       %rax,	%rbx
    jmp       L1826
L1828:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mc_auxmcl.mulimm
    mov       %rax,	1
L1826:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.mulimm
mc_auxmcl.mulimm:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r12,	%rcx
    mov       %r13,	%rdx
#---------------
    mov       %rax,	%r13
    test      %rax,	%rax
    jz        L1832
    cmp       %rax,	1
    jz        L1833
    cmp       %rax,	-1
    jz        L1834
    jmp       L1835
L1832:
    mov       %rcx,	%r12
    call      mc_libmcl.clearreg
    jmp       L1830
L1833:
    jmp       L1830
L1834:
    mov       %rcx,	50
    mov       %rdx,	%r12
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L1830
L1835:
L1831:
    xor       %rdi,	%rdi
    mov       %rax,	%r13
    mov       %rbx,	%rax
    jmp       L1837
L1836:
    sar       %rbx,	1
    inc       %rdi
L1837:
    mov       %eax,	%ebx
    and       %eax,	1
    test      %rax,	%rax
    jz        L1836
    test      %rdi,	%rdi
    jz        L1840
    mov       %rcx,	%rdi
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	43
    mov       %rdx,	%r12
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L1840:
    mov       %rax,	%rbx
    cmp       %rax,	1
    jz        L1842
    cmp       %rax,	3
    jz        L1843
    cmp       %rax,	5
    jz        L1843
    cmp       %rax,	9
    jz        L1843
    jmp       L1844
L1842:
    jmp       L1830
L1843:
    sub       %rsp,	8
    push      0
    push      0
    push      0
    lea       %rax,	[%rbx-1]
    movzx     %r10,	byte ptr[%r12+10]
    movzx     %r11,	byte ptr[%r12+10]
    mov       %rcx,	%r11
    mov       %rdx,	%r10
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rcx,	14
    mov       %rdx,	%r12
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L1841
L1844:
    test      %rdi,	%rdi
    jz        L1846
    mov       %al,	34
    mov       %r10,	[%rip+mc_decls.mccodex]
    mov       [%r10+33],	%al
    mov       %rcx,	%r13
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %r10,	[%rip+mc_decls.mccodex]
    mov       [%r10+24],	%rax
    jmp       L1845
L1846:
    movzx     %rax,	word ptr[%r12+8]
    and       %rax,	31
    cmp       %rax,	4
    jnz       L1848
    mov       %rax,	9
    jmp       L1847
L1848:
    mov       %rax,	10
L1847:
    mov       %rcx,	%rax
    call      mc_stackmcl.getworkregm
    mov       %rsi,	%rax
    mov       %rcx,	%r13
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	11
    mov       %rdx,	%rsi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	34
    mov       %rdx,	%r12
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
L1845:
L1841:
L1830:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_addrmode
mc_auxmcl.do_addrmode:
#?>>
    .set mc_auxmcl.do_addrmode.p, 72
    .set mc_auxmcl.do_addrmode.scale, -8
    .set mc_auxmcl.do_addrmode.regix, -16
    .set mc_auxmcl.do_addrmode.d, -24
    .set mc_auxmcl.do_addrmode.q, -32
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	72
    mov       [%rbp+72],	%rcx
#---------------
    mov       %rax,	[%rbp + mc_auxmcl.do_addrmode.p]
    movsxd    %rax,	dword ptr[%rax+16]
    mov       [%rbp + mc_auxmcl.do_addrmode.scale],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.do_addrmode.p]
    movsxd    %rax,	dword ptr[%rax+20]
    mov       %r12,	%rax
    mov       %rcx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.isimmload
    mov       [%rbp + mc_auxmcl.do_addrmode.q],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.do_addrmode.q]
    test      %rax,	%rax
    jz        L1851
    mov       %rax,	[%rbp + mc_auxmcl.do_addrmode.q]
    mov       %rax,	[%rax+8]
    mov       %r10,	[%rbp + mc_auxmcl.do_addrmode.scale]
    imul      %rax,	%r10
    add       %rax,	%r12
    mov       %r13,	%rax
L1851:
    xor       %rdi,	%rdi
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-2]
    cmp       %rax,	2
    jnz       L1853
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	2
    jnz       L1855
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %r14,	%rax
    mov       %rcx,	%r14
    lea       %rdx,	[%rbp + mc_auxmcl.do_addrmode.scale]
    mov       %r8,	[%rip+mc_decls.noperands]
    call      mc_auxmcl.scaleregvar
    mov       [%rbp + mc_auxmcl.do_addrmode.regix],	%rax
    sub       %rsp,	8
    push      0
    push      0
    push      0
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-2]
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_auxmcl.do_addrmode.regix]
    mov       %r8,	[%rbp + mc_auxmcl.do_addrmode.scale]
    mov       %r9,	%r12
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rdi,	%rax
    jmp       L1854
L1855:
    mov       %rax,	[%rbp + mc_auxmcl.do_addrmode.q]
    test      %rax,	%rax
    jz        L1856
    sub       %rsp,	8
    push      0
    push      0
    push      0
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-2]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    mov       %r8,	1
    mov       %r9,	%r13
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rdi,	%rax
    jmp       L1854
L1856:
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %r10,	%rax
    mov       %rsi,	%r10
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_auxmcl.do_addrmode.scale]
    call      mc_auxmcl.scaleindex
    mov       [%rbp + mc_auxmcl.do_addrmode.scale],	%rax
    sub       %rsp,	8
    push      0
    push      0
    push      0
    movzx     %rax,	byte ptr[%rsi+10]
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	[%rip+mc_decls.noperands]
    movzx     %r10,	byte ptr[%r10 + %r11-2]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.do_addrmode.scale]
    mov       %r9,	%r12
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rdi,	%rax
L1854:
    jmp       L1852
L1853:
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    call      mc_auxmcl.ismemaddr
    test      %rax,	%rax
    jz        L1857
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	[%rip+mc_decls.noperands]
    mov       %rax,	[%rax + %r10*8-16]
    mov       %rax,	[%rax+8]
    mov       [%rbp + mc_auxmcl.do_addrmode.d],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.do_addrmode.d]
    movzx     %rax,	byte ptr[%rax+72]
    cmp       %rax,	3
    jz        L1862
    cmp       %rax,	1
    jnz       L1861
L1862:
    movzx     %rax,	byte ptr[%rip+pc_api.phighmem]
    cmp       %rax,	2
    jz        L1860
L1861:
    mov       %rax,	[%rbp + mc_auxmcl.do_addrmode.d]
    movzx     %rax,	byte ptr[%rax+72]
    cmp       %rax,	5
    jnz       L1859
    mov       %rax,	[%rbp + mc_auxmcl.do_addrmode.d]
    movzx     %rax,	byte ptr[%rax+82]
    cmp       %rax,	11
    jnz       L1859
L1860:
    jmp       L1863
L1859:
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	2
    jnz       L1865
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %r14,	%rax
    mov       %rcx,	%r14
    lea       %rdx,	[%rbp + mc_auxmcl.do_addrmode.scale]
    mov       %r8,	[%rip+mc_decls.noperands]
    call      mc_auxmcl.scaleregvar
    mov       [%rbp + mc_auxmcl.do_addrmode.regix],	%rax
    sub       %rsp,	8
    push      qword ptr[%rbp + mc_auxmcl.do_addrmode.d]
    push      0
    push      0
    xor       %ecx,	%ecx
    mov       %rdx,	[%rbp + mc_auxmcl.do_addrmode.regix]
    mov       %r8,	[%rbp + mc_auxmcl.do_addrmode.scale]
    mov       %r9,	%r12
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rdi,	%rax
    jmp       L1864
L1865:
    mov       %rax,	[%rbp + mc_auxmcl.do_addrmode.q]
    test      %rax,	%rax
    jz        L1866
    sub       %rsp,	8
    push      qword ptr[%rbp + mc_auxmcl.do_addrmode.d]
    push      0
    push      0
    xor       %ecx,	%ecx
    xor       %edx,	%edx
    mov       %r8,	1
    mov       %r9,	%r13
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rdi,	%rax
    jmp       L1864
L1866:
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	10
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %r10,	%rax
    mov       %rsi,	%r10
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_auxmcl.do_addrmode.scale]
    call      mc_auxmcl.scaleindex
    mov       [%rbp + mc_auxmcl.do_addrmode.scale],	%rax
    sub       %rsp,	8
    push      qword ptr[%rbp + mc_auxmcl.do_addrmode.d]
    push      0
    push      0
    movzx     %rax,	byte ptr[%rsi+10]
    xor       %ecx,	%ecx
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.do_addrmode.scale]
    mov       %r9,	%r12
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rdi,	%rax
L1864:
    jmp       L1852
L1857:
#mc_auxmcl.do_addrmode.skip:
L1863:
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	1
    jnz       L1868
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %r14,	%rax
    mov       %rcx,	%r14
    lea       %rdx,	[%rbp + mc_auxmcl.do_addrmode.scale]
    mov       %r8,	[%rip+mc_decls.noperands]
    call      mc_auxmcl.scaleregvar
    mov       [%rbp + mc_auxmcl.do_addrmode.regix],	%rax
    sub       %rsp,	8
    push      0
    push      0
    push      0
    movzx     %rax,	byte ptr[%rbx+10]
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_auxmcl.do_addrmode.regix]
    mov       %r8,	[%rbp + mc_auxmcl.do_addrmode.scale]
    mov       %r9,	%r12
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rdi,	%rax
    jmp       L1867
L1868:
    mov       %rax,	[%rbp + mc_auxmcl.do_addrmode.q]
    test      %rax,	%rax
    jz        L1869
    sub       %rsp,	8
    push      0
    push      0
    push      0
    movzx     %rax,	byte ptr[%rbx+10]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    mov       %r8,	1
    mov       %r9,	%r13
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rdi,	%rax
    jmp       L1867
L1869:
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %r10,	%rax
    mov       %rsi,	%r10
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_auxmcl.do_addrmode.scale]
    call      mc_auxmcl.scaleindex
    mov       [%rbp + mc_auxmcl.do_addrmode.scale],	%rax
    sub       %rsp,	8
    push      0
    push      0
    push      0
    movzx     %rax,	byte ptr[%rsi+10]
    movzx     %r10,	byte ptr[%rbx+10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.do_addrmode.scale]
    mov       %r9,	%r12
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rdi,	%rax
L1867:
L1852:
    mov       %rax,	[%rbp + mc_auxmcl.do_addrmode.p]
    movzx     %rax,	byte ptr[%rax+3]
    lea       %r10,	[%rip+pc_tables.psize]
    movzx     %r10,	byte ptr[%r10 + %rax]
    lea       %rax,	[%rdi+8]
    mov       %r15w,	[%rax]
    mov       %r11,	-32
    and       %r15w,	%r11w
    or        %r15w,	%r10w
    mov       [%rax],	%r15w
    mov       %rax,	%rdi
L1849:
#---------------
    add       %rsp,	72
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.scaleregvar
mc_auxmcl.scaleregvar:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
    mov       %rax,	[%r12]
    cmp       %rax,	1
    jz        L1873
    cmp       %rax,	2
    jz        L1873
    cmp       %rax,	4
    jz        L1873
    cmp       %rax,	8
    jnz       L1872
L1873:
    mov       %rax,	%rsi
    jmp       L1870
L1872:
    call      mc_stackmcl.getworkireg
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rbx,	%rax
    mov       %rax,	[%r12]
    cmp       %rax,	16
    jnz       L1875
    sub       %rsp,	8
    push      0
    push      0
    push      0
    mov       %rcx,	%rsi
    mov       %rdx,	%rsi
    mov       %r8,	1
    xor       %r9d,	%r9d
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rcx,	14
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rax,	8
    mov       [%r12],	%rax
    jmp       L1874
L1875:
    mov       %rcx,	%rsi
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rax,	[%r12]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      mc_auxmcl.mulimm
    mov       %rax,	1
    mov       [%r12],	%rax
L1874:
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.pclloc]
    mov       %r11,	%r13
    mov       [%r10 + %r11-1],	%al
    mov       %al,	%dil
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	%r13
    mov       [%r10 + %r11-1],	%al
    mov       %al,	10
    lea       %r10,	[%rip+mc_decls.pclmode]
    mov       %r11,	%r13
    mov       [%r10 + %r11-1],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+mc_decls.pclopnd]
    mov       %r11,	%r13
    mov       [%r10 + %r11*8-8],	%rax
    mov       %rax,	%rdi
L1870:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.dolea
mc_auxmcl.dolea:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    movzx     %rax,	byte ptr[%rbx+11]
    movzx     %r10,	word ptr[%rbx+8]
    shr       %r10,	12
    and       %r10,	15
    cmp       %r10,	%rax
    jnz       L1880
    movsxd    %rax,	dword ptr[%rbx+12]
    cmp       %rax,	%r10
    jnz       L1880
    test      %rax,	%rax
    jnz       L1880
    mov       %rax,	1
    jmp       L1881
L1880:
    xor       %eax,	%eax
L1881:
    test      %rax,	%rax
    setnz     %al
    movzx     %eax,	%al
    test      %ax,	%ax
    jz        L1879
    movzx     %rax,	byte ptr[%rbx+10]
    movzx     %r10,	byte ptr[%rdi+10]
    cmp       %rax,	%r10
    jz        L1878
L1879:
    mov       %rcx,	14
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L1878:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_binto
mc_auxmcl.do_binto:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jg        L1884
    mov       %rcx,	%rsi
    mov       %rdx,	%r13
    call      mc_auxmcl.do_binto_float
    jmp       L1882
L1884:
    movzx     %rax,	byte ptr[%rsi+3]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rsi+3]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    mov       %rcx,	%r12
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
L1882:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_binto_float
mc_auxmcl.do_binto_float:
#?>>
    .set mc_auxmcl.do_binto_float.p, 48
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rdx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      mc_stackmcl.pushpcl_reg
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    sub       %r10,	2
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rsi,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rsi
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    dec       %rax
    mov       %r10,	%r12
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rsi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_shiftnto
mc_auxmcl.do_shiftnto:
#?>>
    .set mc_auxmcl.do_shiftnto.p, 40
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rdx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-2]
    test      %rax,	%rax
    jnz       L1888
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	[%rip+mc_decls.noperands]
    mov       %rax,	[%rax + %r10*8-16]
    movzx     %rax,	byte ptr[%rax+1]
    cmp       %rax,	4
    jnz       L1888
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	[%rip+mc_decls.noperands]
    mov       %rax,	[%rax + %r10*8-16]
    mov       %rax,	[%rax+8]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	%rsi
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L1887
L1888:
    mov       %al,	[%rip+pc_decls.r10used]
    test      %al,	%al
    jz        L1890
    mov       %rcx,	11
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	12
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L1890:
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	3
    mov       %r8,	11
    call      mc_stackmcl.loadparam
    mov       %rbx,	%rax
    mov       %rcx,	%rsi
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    mov       %al,	[%rip+pc_decls.r10used]
    test      %al,	%al
    jz        L1892
    mov       %rcx,	11
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	13
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L1892:
L1887:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_divrem
mc_auxmcl.do_divrem:
#?>>
    .set mc_auxmcl.do_divrem.issigned, 80
    .set mc_auxmcl.do_divrem.isdiv, 88
    .set mc_auxmcl.do_divrem.shifts, -8
    .set mc_auxmcl.do_divrem.fdivto, -16
    .set mc_auxmcl.do_divrem.locyy, -24
    .set mc_auxmcl.do_divrem.loczz, -32
    .set mc_auxmcl.do_divrem.$T1, -40
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	72
    mov       %r15,	%rcx
    mov       [%rbp+80],	%rdx
    mov       [%rbp+88],	%r8
#---------------
    xor       %eax,	%eax
    mov       [%rbp + mc_auxmcl.do_divrem.fdivto],	%al
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       [%rbp + mc_auxmcl.do_divrem.locyy],	%rax
    mov       %rax,	[%rip+mc_decls.noperands]
    mov       [%rbp + mc_auxmcl.do_divrem.loczz],	%rax
    movzx     %rax,	byte ptr[%r15]
    cmp       %rax,	94
    jz        L1896
    cmp       %rax,	95
    jnz       L1895
L1896:
    mov       %rax,	[%rbp + mc_auxmcl.do_divrem.locyy]
    mov       %r10,	[%rbp + mc_auxmcl.do_divrem.loczz]
    mov       [%rbp + mc_auxmcl.do_divrem.loczz],	%rax
    mov       [%rbp + mc_auxmcl.do_divrem.locyy],	%r10
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rbp + mc_auxmcl.do_divrem.locyy]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    mov       %al,	1
    mov       [%rbp + mc_auxmcl.do_divrem.fdivto],	%al
    mov       %rcx,	%rdi
    mov       %rdx,	8
    call      mc_libmcl.changeopndsize
    mov       %rcx,	12
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mc_stackmcl.makeopndind
    mov       %rsi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    movzx     %r10,	byte ptr[%rdi+10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_libmcl.mgenreg
    mov       %rdi,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
    jmp       L1894
L1895:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rbp + mc_auxmcl.do_divrem.locyy]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
L1894:
    mov       %rcx,	[%rbp + mc_auxmcl.do_divrem.loczz]
    call      mc_stackmcl.isimmload
    mov       %r12,	%rax
    test      %r12,	%r12
    jz        L1898
    mov       %rax,	[%rbp + mc_auxmcl.do_divrem.isdiv]
    cmp       %rax,	1
    jnz       L1898
    mov       %r14,	[%r12+8]
    mov       %rax,	%r14
    test      %rax,	%rax
    jz        L1900
    cmp       %rax,	1
    jz        L1901
    jmp       L1902
L1900:
    lea       %rcx,	[%rip+L8190]
    lea       %rdx,	[%rip+L8191]
    call      pc_api.merror
    jmp       L1899
L1901:
    call      mc_stackmcl.poppcl
    jmp       L1893
L1902:
    mov       %rcx,	%r14
    call      mc_libmcl.ispoweroftwo
    mov       [%rbp + mc_auxmcl.do_divrem.shifts],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.do_divrem.shifts]
    test      %rax,	%rax
    jz        L1904
    mov       %al,	[%rbp + mc_auxmcl.do_divrem.fdivto]
    test      %al,	%al
    jnz       L1904
    mov       %rcx,	[%rbp + mc_auxmcl.do_divrem.shifts]
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       [%rbp + mc_auxmcl.do_divrem.$T1],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.do_divrem.issigned]
    test      %rax,	%rax
    jz        L1906
    mov       %rax,	44
    jmp       L1905
L1906:
    mov       %rax,	45
L1905:
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    mov       %r8,	[%rbp + mc_auxmcl.do_divrem.$T1]
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    jmp       L1893
L1904:
L1899:
L1898:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rbp + mc_auxmcl.do_divrem.loczz]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    call      mc_auxmcl.saverdx
    mov       %rcx,	[%rbp + mc_auxmcl.do_divrem.locyy]
    mov       %rdx,	[%rbp + mc_auxmcl.do_divrem.loczz]
    call      mc_auxmcl.fixdivopnds
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rbp + mc_auxmcl.do_divrem.loczz]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    mov       %rax,	[%rbp + mc_auxmcl.do_divrem.issigned]
    test      %rax,	%rax
    jz        L1908
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.psize]
    movzx     %r10,	byte ptr[%r10 + %rax]
    cmp       %r10,	8
    jz        L1910
    cmp       %r10,	4
    jz        L1911
    cmp       %r10,	2
    jz        L1912
    jmp       L1913
L1910:
    mov       %rax,	57
    jmp       L1909
L1911:
    mov       %rax,	56
    jmp       L1909
L1912:
    mov       %rax,	55
    jmp       L1909
L1913:
    lea       %rcx,	[%rip+L8192]
    lea       %rdx,	[%rip+L8193]
    call      pc_api.merror
    xor       %eax,	%eax
L1909:
    mov       %r13,	%rax
    mov       %rcx,	%r13
    xor       %edx,	%edx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %r13,	36
    jmp       L1907
L1908:
    mov       %rcx,	12
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	%rax
    call      mc_libmcl.clearreg
    mov       %r13,	37
L1907:
    mov       %rcx,	%r13
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rax,	[%rbp + mc_auxmcl.do_divrem.isdiv]
    test      %rax,	%rax
    jz        L1915
    cmp       %rax,	2
    jz        L1916
    jmp       L1917
L1915:
    mov       %rcx,	12
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       [%rbp + mc_auxmcl.do_divrem.$T1],	%rax
    mov       %rcx,	1
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	27
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.do_divrem.$T1]
    call      mc_libmcl.genmc
    jmp       L1914
L1916:
    mov       %rcx,	12
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	27
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	2
    call      mc_stackmcl.swapopndregs
    mov       %rcx,	[%rbp + mc_auxmcl.do_divrem.locyy]
    mov       %rdx,	[%rbp + mc_auxmcl.do_divrem.loczz]
    call      mc_stackmcl.swapopnds
L1917:
L1914:
    call      mc_auxmcl.restorerdx
    mov       %al,	[%rbp + mc_auxmcl.do_divrem.fdivto]
    test      %al,	%al
    jz        L1919
    mov       %rcx,	6
    call      mc_stackmcl.getworkregm
    mov       %rbx,	%rax
    mov       %rcx,	13
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rbp + mc_auxmcl.do_divrem.locyy]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       [%rbp + mc_auxmcl.do_divrem.$T1],	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      mc_stackmcl.makeopndind
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.do_divrem.$T1]
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
L1919:
    mov       %rax,	[%rbp + mc_auxmcl.do_divrem.isdiv]
    cmp       %rax,	2
    jz        L1921
    call      mc_stackmcl.poppcl
L1921:
L1893:
#---------------
    add       %rsp,	72
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.fixdivopnds
mc_auxmcl.fixdivopnds:
#?>>
    .set mc_auxmcl.fixdivopnds.$T1, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %r14,	%rcx
    mov       %r15,	%rdx
#---------------
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%r14
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rdi,	%rax
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%r15
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rbx,	%rax
    cmp       %rdi,	1
    jz        L1922
L1924:
    mov       %rcx,	%r14
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %r12,	%rax
    mov       %rcx,	%r15
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %r13,	%rax
    cmp       %rbx,	1
    jnz       L1926
    mov       %rcx,	27
    mov       %rdx,	%r12
    mov       %r8,	%r13
    call      mc_libmcl.genmc
    mov       %rcx,	%r14
    mov       %rdx,	%r15
    call      mc_stackmcl.swapopnds
    jmp       L1922
L1926:
    lea       %rax,	[%rip+mc_decls.regset]
    movzx     %rax,	byte ptr[%rax]
    test      %rax,	%rax
    jnz       L1928
    mov       %rcx,	1
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	27
    mov       %rdx,	%rax
    mov       %r8,	%r12
    call      mc_libmcl.genmc
    xor       %eax,	%eax
    lea       %r10,	[%rip+mc_decls.regset]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	%r14
    mov       [%r10 + %r11-1],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.regset]
    mov       [%r10],	%al
    jmp       L1922
L1928:
    mov       %rsi,	[%rip+mc_decls.noperands]
    cmp       %rsi,	1
    jl        L1932
L1929:
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	1
    jnz       L1934
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	1
    jz        L1931
L1934:
    dec       %rsi
    cmp       %rsi,	1
    jge       L1929
L1932:
    jmp       L1922
L1931:
    mov       %rcx,	%r14
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       [%rbp + mc_auxmcl.fixdivopnds.$T1],	%rax
    mov       %rcx,	1
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	27
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.fixdivopnds.$T1]
    call      mc_libmcl.genmc
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%r14
    lea       %rax,	[%rax + %r10-1]
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	%rsi
    lea       %r10,	[%r10 + %r11-1]
    mov       %r11b,	[%rax]
    mov       %r9b,	[%r10]
    mov       [%r10],	%r11b
    mov       [%rax],	%r9b
L1922:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.saverdx
mc_auxmcl.saverdx:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    mov       %al,	[%rip+pc_decls.r11used]
    test      %al,	%al
    jz        L1937
    mov       %rcx,	12
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	12
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L1937:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_auxmcl.restorerdx
mc_auxmcl.restorerdx:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    mov       %al,	[%rip+pc_decls.r11used]
    test      %al,	%al
    jz        L1940
    mov       %rcx,	12
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	13
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L1940:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_auxmcl.clearblock
mc_auxmcl.clearblock:
#?>>
    .set mc_auxmcl.clearblock.ax, 64
    .set mc_auxmcl.clearblock.n, 72
    .set mc_auxmcl.clearblock.countreg, -8
    .set mc_auxmcl.clearblock.av_1, -16
    .set mc_auxmcl.clearblock.i, -24
    .set mc_auxmcl.clearblock.$T1, -32
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	64
    mov       [%rbp+64],	%rcx
    mov       [%rbp+72],	%rdx
#---------------
    mov       %rax,	[%rbp + mc_auxmcl.clearblock.n]
    mov       %r10,	8
    cqo       
    idiv      %r10
    xchg      %rax,	%rdx
    mov       %r13,	%rax
    mov       %rax,	%r13
    sub       [%rbp + mc_auxmcl.clearblock.n],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.clearblock.n]
    sar       %rax,	3
    mov       %rsi,	%rax
    mov       %rcx,	6
    call      mc_stackmcl.getworkregm
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    call      mc_libmcl.clearreg
    xor       %r14,	%r14
    mov       %rax,	%rsi
    cmp       %rax,	1
    jl        L1943
    cmp       %rax,	8
    jg        L1943
    mov       %rcx,	[%rbp + mc_auxmcl.clearblock.ax]
    mov       %rdx,	8
    call      mc_libmcl.changeopndsize
    mov       [%rbp + mc_auxmcl.clearblock.ax],	%rax
    mov       [%rbp + mc_auxmcl.clearblock.av_1],	%rsi
    mov       %rax,	[%rbp + mc_auxmcl.clearblock.av_1]
    cmp       %rax,	0
    jle       L1946
L1944:
    mov       %rcx,	[%rbp + mc_auxmcl.clearblock.ax]
    mov       %rdx,	%r14
    xor       %r8d,	%r8d
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rax,	8
    add       %r14,	%rax
    dec       qword ptr[%rbp + mc_auxmcl.clearblock.av_1]
    jnz       L1944
L1946:
    jmp       L1942
L1943:
    test      %rsi,	%rsi
    jz        L1947
    mov       %rax,	%rsi
    and       %rax,	3
    jz        L1949
    call      mc_stackmcl.getworkireg
    mov       %r10,	%rax
    mov       [%rbp + mc_auxmcl.clearblock.countreg],	%r10
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rbx,	%rax
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %r12,	[%rip+pc_api.mlabelno]
    mov       %rcx,	[%rbp + mc_auxmcl.clearblock.ax]
    call      mc_stackmcl.makesimpleaddr
    mov       [%rbp + mc_auxmcl.clearblock.ax],	%rax
    mov       %rcx,	%rsi
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	%r12
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	11
    mov       %rdx,	[%rbp + mc_auxmcl.clearblock.ax]
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rcx,	8
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       [%rbp + mc_auxmcl.clearblock.$T1],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.clearblock.ax]
    movzx     %rax,	byte ptr[%rax+10]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	28
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.clearblock.$T1]
    call      mc_libmcl.genmc
    mov       %rcx,	53
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	%r12
    call      mc_libmcl.mgenlabel
    mov       %rcx,	26
    mov       %rdx,	5
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    xor       %r14,	%r14
    jmp       L1948
L1949:
    call      mc_stackmcl.getworkireg
    mov       %r10,	%rax
    mov       [%rbp + mc_auxmcl.clearblock.countreg],	%r10
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rbx,	%rax
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %r12,	[%rip+pc_api.mlabelno]
    mov       %rcx,	[%rbp + mc_auxmcl.clearblock.ax]
    call      mc_stackmcl.makesimpleaddr
    mov       [%rbp + mc_auxmcl.clearblock.ax],	%rax
    mov       %rax,	%rsi
    sar       %rax,	2
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	%r12
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rax,	1
    mov       [%rbp + mc_auxmcl.clearblock.i],	%rax
L1950:
    mov       %rcx,	[%rbp + mc_auxmcl.clearblock.ax]
    mov       %rdx,	%r14
    xor       %r8d,	%r8d
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rax,	8
    add       %r14,	%rax
    mov       %rax,	[%rbp + mc_auxmcl.clearblock.i]
    inc       %rax
    mov       [%rbp + mc_auxmcl.clearblock.i],	%rax
    cmp       %rax,	4
    jle       L1950
    mov       %rcx,	32
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       [%rbp + mc_auxmcl.clearblock.$T1],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.clearblock.ax]
    movzx     %rax,	byte ptr[%rax+10]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	28
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.clearblock.$T1]
    call      mc_libmcl.genmc
    mov       %rcx,	53
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	%r12
    call      mc_libmcl.mgenlabel
    mov       %rcx,	26
    mov       %rdx,	5
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    xor       %r14,	%r14
L1948:
L1947:
L1942:
    test      %r13,	%r13
    jz        L1954
    mov       [%rbp + mc_auxmcl.clearblock.n],	%r13
    mov       %rax,	[%rbp + mc_auxmcl.clearblock.n]
    cmp       %rax,	4
    jl        L1956
    mov       %rcx,	%rdi
    mov       %rdx,	4
    call      mc_libmcl.changeopndsize
    mov       %rdi,	%rax
    mov       %rcx,	[%rbp + mc_auxmcl.clearblock.ax]
    mov       %rdx,	%r14
    mov       %r8,	4
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rax,	4
    sub       [%rbp + mc_auxmcl.clearblock.n],	%rax
    mov       %rax,	4
    add       %r14,	%rax
L1956:
    mov       %rax,	[%rbp + mc_auxmcl.clearblock.n]
    cmp       %rax,	2
    jl        L1958
    mov       %rcx,	%rdi
    mov       %rdx,	2
    call      mc_libmcl.changeopndsize
    mov       %rdi,	%rax
    mov       %rcx,	[%rbp + mc_auxmcl.clearblock.ax]
    mov       %rdx,	%r14
    mov       %r8,	2
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rax,	2
    sub       [%rbp + mc_auxmcl.clearblock.n],	%rax
    mov       %rax,	2
    add       %r14,	%rax
L1958:
    mov       %rax,	[%rbp + mc_auxmcl.clearblock.n]
    cmp       %rax,	1
    jnz       L1960
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      mc_libmcl.changeopndsize
    mov       %rdi,	%rax
    mov       %rcx,	[%rbp + mc_auxmcl.clearblock.ax]
    mov       %rdx,	%r14
    mov       %r8,	1
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
L1960:
L1954:
#---------------
    add       %rsp,	64
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_blockdata
mc_auxmcl.do_blockdata:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r14,	%rcx
#---------------
    mov       %eax,	[%r14+4]
    mov       %rbx,	%rax
    test      %rbx,	%rbx
    jnz       L1963
    jmp       L1961
L1963:
    mov       %rax,	%rbx
    sar       %rax,	3
    mov       %rsi,	%rax
    mov       %rdi,	[%r14+8]
    mov       %r13,	%rsi
    cmp       %r13,	0
    jle       L1966
L1964:
    mov       %rax,	%rdi
    add       %rdi,	8
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	119
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    dec       %r13
    jnz       L1964
L1966:
    mov       %rax,	%rsi
    shl       %rax,	3
    mov       %r10,	%rbx
    sub       %r10,	%rax
    mov       %r12,	%r10
    test      %r12,	%r12
    jz        L1968
    mov       %rcx,	%rdi
    mov       %rdx,	%r12
    mov       %r8,	66
    call      mc_auxmcl.genstring_db
L1968:
    lea       %rcx,	[%rip+L8194]
    call      mc_libmcl.mgencomment
L1961:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.copyblock
mc_auxmcl.copyblock:
#?>>
    .set mc_auxmcl.copyblock.n, 88
    .set mc_auxmcl.copyblock.savedest, 96
    .set mc_auxmcl.copyblock.oddbytes, -8
    .set mc_auxmcl.copyblock.offset, -16
    .set mc_auxmcl.copyblock.axreg, -24
    .set mc_auxmcl.copyblock.saved, -32
    .set mc_auxmcl.copyblock.av_1, -40
    .set mc_auxmcl.copyblock.$T1, -48
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	88
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       [%rbp+88],	%r8
    mov       [%rbp+96],	%r9
#---------------
    xor       %eax,	%eax
    mov       [%rbp + mc_auxmcl.copyblock.saved],	%al
    mov       %rax,	[%rbp + mc_auxmcl.copyblock.n]
    cmp       %rax,	16
    jnz       L1971
    mov       %rcx,	2
    call      mc_stackmcl.getworkregm
    mov       %rdi,	%rax
    mov       %rcx,	91
    mov       %rdx,	%rdi
    mov       %r8,	%r14
    call      mc_libmcl.genmc
    mov       %rcx,	91
    mov       %rdx,	%r13
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    jmp       L1969
L1971:
    mov       %rax,	[%rbp + mc_auxmcl.copyblock.n]
    mov       %r10,	8
    cqo       
    idiv      %r10
    xchg      %rax,	%rdx
    mov       [%rbp + mc_auxmcl.copyblock.oddbytes],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.copyblock.oddbytes]
    sub       [%rbp + mc_auxmcl.copyblock.n],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.copyblock.n]
    sar       %rax,	3
    mov       %rsi,	%rax
    mov       %rcx,	6
    call      mc_stackmcl.getworkregm
    mov       %rdi,	%rax
    xor       %eax,	%eax
    mov       [%rbp + mc_auxmcl.copyblock.offset],	%rax
    mov       %rax,	%rsi
    cmp       %rax,	1
    jl        L1973
    cmp       %rax,	4
    jg        L1973
    mov       %rcx,	%r13
    mov       %rdx,	8
    call      mc_libmcl.changeopndsize
    mov       %r13,	%rax
    mov       %rcx,	%r14
    mov       %rdx,	8
    call      mc_libmcl.changeopndsize
    mov       %r14,	%rax
    mov       [%rbp + mc_auxmcl.copyblock.av_1],	%rsi
    mov       %rax,	[%rbp + mc_auxmcl.copyblock.av_1]
    cmp       %rax,	0
    jle       L1976
L1974:
    mov       %rcx,	%r14
    mov       %rdx,	[%rbp + mc_auxmcl.copyblock.offset]
    xor       %r8d,	%r8d
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + mc_auxmcl.copyblock.offset]
    xor       %r8d,	%r8d
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rax,	8
    add       [%rbp + mc_auxmcl.copyblock.offset],	%rax
    dec       qword ptr[%rbp + mc_auxmcl.copyblock.av_1]
    jnz       L1974
L1976:
    jmp       L1972
L1973:
    test      %rsi,	%rsi
    jz        L1977
    mov       %rcx,	6
    call      mc_stackmcl.getworkregm
    mov       %rbx,	%rax
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %r12,	[%rip+pc_api.mlabelno]
    mov       %rax,	[%rbp + mc_auxmcl.copyblock.savedest]
    test      %rax,	%rax
    jz        L1979
    movzx     %rax,	byte ptr[%r13+10]
    mov       [%rbp + mc_auxmcl.copyblock.axreg],	%rax
    mov       %rcx,	[%rbp + mc_auxmcl.copyblock.axreg]
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	12
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %al,	1
    mov       [%rbp + mc_auxmcl.copyblock.saved],	%al
L1979:
    mov       %rcx,	%r13
    call      mc_stackmcl.makesimpleaddr
    mov       %r13,	%rax
    mov       %rcx,	%r14
    call      mc_stackmcl.makesimpleaddr
    mov       %r14,	%rax
    lea       %rax,	[%r13+8]
    mov       %r10w,	8
    mov       %r15w,	[%rax]
    mov       %r11,	-32
    and       %r15w,	%r11w
    or        %r15w,	%r10w
    mov       [%rax],	%r15w
    mov       %rcx,	%rsi
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	%r12
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%r14
    call      mc_libmcl.genmc
    mov       %rcx,	11
    mov       %rdx,	%r13
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rcx,	8
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       [%rbp + mc_auxmcl.copyblock.$T1],	%rax
    movzx     %rax,	byte ptr[%r13+10]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	28
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.copyblock.$T1]
    call      mc_libmcl.genmc
    mov       %rcx,	8
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       [%rbp + mc_auxmcl.copyblock.$T1],	%rax
    movzx     %rax,	byte ptr[%r14+10]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	28
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.copyblock.$T1]
    call      mc_libmcl.genmc
    mov       %rcx,	53
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	%r12
    call      mc_libmcl.mgenlabel
    mov       %rcx,	26
    mov       %rdx,	5
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    xor       %eax,	%eax
    mov       [%rbp + mc_auxmcl.copyblock.offset],	%rax
L1977:
L1972:
    mov       %rax,	[%rbp + mc_auxmcl.copyblock.oddbytes]
    test      %rax,	%rax
    jz        L1981
    mov       %rax,	[%rbp + mc_auxmcl.copyblock.oddbytes]
    mov       [%rbp + mc_auxmcl.copyblock.n],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.copyblock.n]
    cmp       %rax,	4
    jl        L1983
    mov       %rcx,	%rdi
    mov       %rdx,	4
    call      mc_libmcl.changeopndsize
    mov       %rdi,	%rax
    mov       %rcx,	%r14
    mov       %rdx,	[%rbp + mc_auxmcl.copyblock.offset]
    mov       %r8,	4
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + mc_auxmcl.copyblock.offset]
    mov       %r8,	4
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rax,	4
    sub       [%rbp + mc_auxmcl.copyblock.n],	%rax
    mov       %rax,	4
    add       [%rbp + mc_auxmcl.copyblock.offset],	%rax
L1983:
    mov       %rax,	[%rbp + mc_auxmcl.copyblock.n]
    cmp       %rax,	2
    jl        L1985
    mov       %rcx,	%rdi
    mov       %rdx,	2
    call      mc_libmcl.changeopndsize
    mov       %rdi,	%rax
    mov       %rcx,	%r14
    mov       %rdx,	[%rbp + mc_auxmcl.copyblock.offset]
    mov       %r8,	2
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + mc_auxmcl.copyblock.offset]
    mov       %r8,	2
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rax,	2
    sub       [%rbp + mc_auxmcl.copyblock.n],	%rax
    mov       %rax,	2
    add       [%rbp + mc_auxmcl.copyblock.offset],	%rax
L1985:
    mov       %rax,	[%rbp + mc_auxmcl.copyblock.n]
    cmp       %rax,	1
    jnz       L1987
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      mc_libmcl.changeopndsize
    mov       %rdi,	%rax
    mov       %rcx,	%r14
    mov       %rdx,	[%rbp + mc_auxmcl.copyblock.offset]
    mov       %r8,	1
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + mc_auxmcl.copyblock.offset]
    mov       %r8,	1
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
L1987:
L1981:
    mov       %al,	[%rbp + mc_auxmcl.copyblock.saved]
    test      %al,	%al
    jz        L1989
    mov       %rcx,	[%rbp + mc_auxmcl.copyblock.axreg]
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	13
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L1989:
L1969:
#---------------
    add       %rsp,	88
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.genstringtable
mc_auxmcl.genstringtable:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rax,	[%rip+mc_decls.cstringlist]
    test      %rax,	%rax
    jz        L1990
L1992:
    lea       %rcx,	[%rip+L8195]
    call      mc_libmcl.mgencomment
    mov       %rcx,	73
    mov       %rdx,	8
    call      mc_libmcl.setsegment
    mov       %rax,	[%rip+mc_decls.kk0used]
    test      %rax,	%rax
    jz        L1994
    mov       %rcx,	[%rip+mc_decls.kk0used]
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    xor       %ecx,	%ecx
    call      mc_auxmcl.gendb
L1994:
    mov       %rdi,	[%rip+mc_decls.cstringlist]
    jmp       L1998
L1995:
    mov       %rax,	[%rdi+16]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rax,	[%rdi+24]
    mov       %r10,	[%rdi]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    mov       %r8,	1
    call      mc_auxmcl.genstring_db
    mov       %rdi,	[%rdi+8]
L1998:
    test      %rdi,	%rdi
    jnz       L1995
L1990:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.genstring_db
mc_auxmcl.genstring_db:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       %r15,	%r8
#---------------
    cmp       %r14,	-1
    jnz       L2001
    mov       %rcx,	%r13
    call      strlen
    mov       %r14,	%rax
L2001:
    test      %r14,	%r14
    jnz       L2003
    xor       %ecx,	%ecx
    call      mc_auxmcl.gendb
    jmp       L1999
L2003:
    xor       %rbx,	%rbx
    mov       %rax,	%r14
    mov       %r12,	%rax
    cmp       %r12,	0
    jle       L2006
L2004:
    mov       %rax,	%r13
    inc       %r13
    movzx     %rax,	byte ptr[%rax]
    mov       %rdi,	%rax
    cmp       %rdi,	32
    jl        L2009
    cmp       %rdi,	127
    jge       L2009
    mov       %rax,	%rdi
    cmp       %rax,	34
    jz        L2010
    cmp       %rax,	92
    jnz       L2008
L2010:
L2009:
    test      %rbx,	%rbx
    jz        L2012
    mov       %rcx,	%rsi
    mov       %rdx,	%rbx
    call      mc_auxmcl.gendbstring
    xor       %rbx,	%rbx
L2012:
    mov       %rcx,	%rdi
    call      mc_auxmcl.gendb
    jmp       L2007
L2008:
    test      %rbx,	%rbx
    jnz       L2014
    mov       %rbx,	1
    lea       %rax,	[%r13-1]
    mov       %rsi,	%rax
    jmp       L2013
L2014:
    inc       %rbx
L2013:
L2007:
    dec       %r12
    jnz       L2004
L2006:
    test      %rbx,	%rbx
    jz        L2016
    mov       %rcx,	%rsi
    mov       %rdx,	%rbx
    call      mc_auxmcl.gendbstring
L2016:
    test      %r15,	%r15
    jnz       L2018
    xor       %ecx,	%ecx
    call      mc_auxmcl.gendb
L2018:
L1999:
#---------------
    add       %rsp,	48
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.gendb
mc_auxmcl.gendb:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	116
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.gendbstring
mc_auxmcl.gendbstring:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mc_libmcl.mgenstring
    mov       %rcx,	120
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.gendq
mc_auxmcl.gendq:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	119
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.genrealtable
mc_auxmcl.genrealtable:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rax,	[%rip+mc_decls.creallist]
    test      %rax,	%rax
    jnz       L2024
    mov       %rax,	[%rip+mc_decls.cr32list]
    test      %rax,	%rax
    jz        L2022
L2024:
    lea       %rcx,	[%rip+L8196]
    call      mc_libmcl.mgencomment
    mov       %rcx,	73
    mov       %rdx,	8
    call      mc_libmcl.setsegment
    mov       %rdi,	[%rip+mc_decls.creallist]
    jmp       L2028
L2025:
    mov       %rax,	[%rdi+16]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    movq      %XMM4,	[%rdi]
    comisd    %XMM4,	[%rip+L8197]
    jnz       L2030
    movq      %XMM4,	[%rdi]
    movq      %rax,	%XMM4
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	119
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L2029
L2030:
    movq      %XMM4,	[%rdi]
    movq      %rax,	%XMM4
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	119
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L2029:
    mov       %rdi,	[%rdi+8]
L2028:
    test      %rdi,	%rdi
    jnz       L2025
    lea       %rcx,	[%rip+L8198]
    call      mc_libmcl.mgencomment
    mov       %rdi,	[%rip+mc_decls.cr32list]
    jmp       L2034
L2031:
    mov       %rax,	[%rdi+16]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    movq      %XMM4,	[%rdi]
    comisd    %XMM4,	[%rip+L8199]
    jnz       L2036
    movq      %XMM4,	[%rdi]
    cvtsd2ss  %XMM4,	%XMM4
    movd      %eax,	%XMM4
    mov       %ecx,	%eax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	118
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L2035
L2036:
    movq      %XMM4,	[%rdi]
    movq      %XMM0,	%XMM4
    mov       %rdx,	1
    call      mc_libmcl.mgenrealimm
    mov       %rcx,	118
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L2035:
    mov       %rdi,	[%rdi+8]
L2034:
    test      %rdi,	%rdi
    jnz       L2031
L2022:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.genabsneg
mc_auxmcl.genabsneg:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    mov       %rax,	[%rip+mc_decls.lababs32]
    add       %rax,	[%rip+mc_decls.lababs64]
    add       %rax,	[%rip+mc_decls.labneg32]
    add       %rax,	[%rip+mc_decls.labneg64]
    test      %rax,	%rax
    jz        L2039
    mov       %rcx,	73
    mov       %rdx,	16
    call      mc_libmcl.setsegment
L2039:
    mov       %rax,	[%rip+mc_decls.lababs32]
    test      %rax,	%rax
    jz        L2041
    lea       %rcx,	[%rip+L8200]
    call      mc_libmcl.mgencomment
    mov       %rcx,	[%rip+mc_decls.lababs32]
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	9223372034707292159
    call      mc_auxmcl.gendq
    mov       %rcx,	9223372034707292159
    call      mc_auxmcl.gendq
L2041:
    mov       %rax,	[%rip+mc_decls.lababs64]
    test      %rax,	%rax
    jz        L2043
    lea       %rcx,	[%rip+L8201]
    call      mc_libmcl.mgencomment
    mov       %rcx,	[%rip+mc_decls.lababs64]
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	9223372036854775807
    call      mc_auxmcl.gendq
    mov       %rcx,	9223372036854775807
    call      mc_auxmcl.gendq
L2043:
    mov       %rax,	[%rip+mc_decls.labneg32]
    test      %rax,	%rax
    jz        L2045
    lea       %rcx,	[%rip+L8202]
    call      mc_libmcl.mgencomment
    mov       %rcx,	[%rip+mc_decls.labneg32]
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	-9223372034707292160
    call      mc_auxmcl.gendq
    mov       %rcx,	-9223372034707292160
    call      mc_auxmcl.gendq
L2045:
    mov       %rax,	[%rip+mc_decls.labneg64]
    test      %rax,	%rax
    jz        L2047
    lea       %rcx,	[%rip+L8203]
    call      mc_libmcl.mgencomment
    mov       %rcx,	[%rip+mc_decls.labneg64]
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	-9223372036854775808
    call      mc_auxmcl.gendq
    mov       %rcx,	-9223372036854775808
    call      mc_auxmcl.gendq
L2047:
    mov       %rax,	[%rip+mc_decls.labzero]
    test      %rax,	%rax
    jz        L2049
    lea       %rcx,	[%rip+L8204]
    call      mc_libmcl.mgencomment
    mov       %rcx,	[%rip+mc_decls.labzero]
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    xor       %ecx,	%ecx
    call      mc_auxmcl.gendq
L2049:
    mov       %rax,	[%rip+mc_decls.labmask63]
    test      %rax,	%rax
    jz        L2051
    lea       %rcx,	[%rip+L8205]
    call      mc_libmcl.mgencomment
    mov       %rcx,	[%rip+mc_decls.labmask63]
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	9223372036854775807
    call      mc_auxmcl.gendq
    mov       %rcx,	[%rip+mc_decls.laboffset64]
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	4890909195324358656
    call      mc_auxmcl.gendq
L2051:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_auxmcl.do_maths
mc_auxmcl.do_maths:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    mov       %r9,	%rsi
    call      mc_auxmcl.do_callrts
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_host
mc_auxmcl.do_host:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    mov       %r8,	%rbx
    mov       %r9,	%rsi
    call      mc_auxmcl.do_callrts
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_callrts
mc_auxmcl.do_callrts:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
    mov       %r14,	%r9
#---------------
    mov       %rcx,	%r14
    call      mc_stackmcl.saveopnds
    xor       %rdi,	%rdi
    mov       %eax,	[%rip+mc_decls.mstackdepth]
    and       %eax,	1
    test      %rax,	%rax
    jz        L2056
    mov       %rcx,	1
    call      mc_libmcl.pushslots
    mov       %rdi,	1
L2056:
    mov       %rcx,	%r14
    xor       %edx,	%edx
    xor       %r8d,	%r8d
    mov       %r9,	1
    call      mc_auxmcl.do_pushlowargs
    mov       %rax,	[%rip+mc_decls.mstackdepth]
    test      %rax,	%rax
    jz        L2058
    mov       %rax,	4
    add       %rdi,	%rax
    mov       %rcx,	4
    call      mc_libmcl.pushslots
    jmp       L2057
L2058:
    mov       %al,	1
    mov       [%rip+pc_decls.localshadow],	%al
L2057:
    test      %r12,	%r12
    jz        L2060
    mov       %rcx,	%r12
    call      mc_libmcl.mgenextname
    mov       %rcx,	21
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L2059
L2060:
    mov       %rcx,	%r13
    call      mc_libmcl.mgenmemaddr
    mov       %rcx,	21
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L2059:
    mov       %rbx,	%r14
    cmp       %rbx,	0
    jle       L2063
L2061:
    call      mc_stackmcl.poppcl
    dec       %rbx
    jnz       L2061
L2063:
    test      %rdi,	%rdi
    jz        L2065
    mov       %rcx,	%rdi
    call      mc_libmcl.popslots
L2065:
    mov       %rcx,	%rsi
    call      mc_auxmcl.do_getretvalue
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_max_int
mc_auxmcl.do_max_int:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    mov       %rcx,	42
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    mov       %rcx,	15
    mov       %rdx,	%rsi
    mov       %r8,	%rdi
    mov       %r9,	%rbx
    call      mc_libmcl.genmc_cond
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_max_float
mc_auxmcl.do_max_float:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    mov       %rcx,	%rsi
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_maxto_int
mc_auxmcl.do_maxto_int:
#?>>
    .set mc_auxmcl.do_maxto_int.mode, 64
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    mov       %rcx,	42
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %r12,	[%rip+pc_api.mlabelno]
    mov       %rcx,	%r12
    call      mc_libmcl.mgenlabel
    mov       %r10,	%rax
    mov       %rsi,	%r10
    mov       %rcx,	26
    mov       %rdx,	%r13
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    mov       %rcx,	9
    mov       %rdx,	%rsi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_maxto_real
mc_auxmcl.do_maxto_real:
#?>>
    .set mc_auxmcl.do_maxto_real.mode, 72
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	32
    mov       %r14,	%rcx
    mov       [%rbp+72],	%rdx
#---------------
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	[%rbp + mc_auxmcl.do_maxto_real.mode]
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_auxmcl.do_maxto_real.mode]
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rsi,	%rax
    mov       %rcx,	[%rbp + mc_auxmcl.do_maxto_real.mode]
    xor       %edx,	%edx
    call      mc_stackmcl.pushpcl_reg
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rax,	[%rbp + mc_auxmcl.do_maxto_real.mode]
    dec       %rax
    mov       %r10,	73
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %r13,	[%rip+pc_api.mlabelno]
    mov       %rcx,	%r13
    call      mc_libmcl.mgenlabel
    mov       %r10,	%rax
    mov       %r12,	%r10
    mov       %rcx,	26
    mov       %rdx,	%r14
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
    mov       %rcx,	9
    mov       %rdx,	%r12
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	32
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_negreal
mc_auxmcl.do_negreal:
#?>>
    .set mc_auxmcl.do_negreal.mode, 32
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    dec       %rax
    test      %rax,	%rax
    jz        L2072
    mov       %rax,	[%rip+mc_decls.labneg64]
    test      %rax,	%rax
    jnz       L2074
    call      mc_libmcl.mcreatefwdlabel
    mov       [%rip+mc_decls.labneg64],	%rax
L2074:
    mov       %rcx,	[%rip+mc_decls.labneg64]
    call      mc_libmcl.mgenlabelmem
    mov       %rcx,	77
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L2071
L2072:
    mov       %rax,	[%rip+mc_decls.labneg32]
    test      %rax,	%rax
    jnz       L2076
    call      mc_libmcl.mcreatefwdlabel
    mov       [%rip+mc_decls.labneg32],	%rax
L2076:
    mov       %rcx,	[%rip+mc_decls.labneg32]
    call      mc_libmcl.mgenlabelmem
    mov       %rcx,	76
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2071:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_absreal
mc_auxmcl.do_absreal:
#?>>
    .set mc_auxmcl.do_absreal.mode, 32
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    dec       %rax
    test      %rax,	%rax
    jz        L2079
    mov       %rax,	[%rip+mc_decls.lababs64]
    test      %rax,	%rax
    jnz       L2081
    call      mc_libmcl.mcreatefwdlabel
    mov       [%rip+mc_decls.lababs64],	%rax
L2081:
    mov       %rcx,	[%rip+mc_decls.lababs64]
    call      mc_libmcl.mgenlabelmem
    mov       %rcx,	79
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L2078
L2079:
    mov       %rax,	[%rip+mc_decls.lababs32]
    test      %rax,	%rax
    jnz       L2083
    call      mc_libmcl.mcreatefwdlabel
    mov       [%rip+mc_decls.lababs32],	%rax
L2083:
    mov       %rcx,	[%rip+mc_decls.lababs32]
    call      mc_libmcl.mgenlabelmem
    mov       %rcx,	78
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2078:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_loadbf_const
mc_auxmcl.do_loadbf_const:
#?>>
    .set mc_auxmcl.do_loadbf_const.p, 56
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    sub       %r10,	2
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    cmp       %r13,	63
    jnz       L2086
    mov       %rcx,	%r12
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	44
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L2085
L2086:
    test      %r12,	%r12
    jz        L2088
    mov       %rcx,	%r12
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	45
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2088:
    mov       %rax,	%r13
    sub       %rax,	%r12
    inc       %rax
    mov       %r10,	-1
    mov       %cl,	%al
    shl       %r10,	%cl
    not       %r10
    mov       %rsi,	%r10
    cmp       %rsi,	2147483647
    ja        L2090
    mov       %rcx,	%rsi
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	38
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L2089
L2090:
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    mov       %rcx,	%rsi
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	38
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L2089:
L2085:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_loadbf_var
mc_auxmcl.do_loadbf_var:
#?>>
    .set mc_auxmcl.do_loadbf_var.p, 16
#?]]
    sub       %rsp,	40
#---------------
    lea       %rcx,	[%rip+L8206]
    lea       %rdx,	[%rip+L8207]
    call      pc_api.merror
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_auxmcl.do_storebit
mc_auxmcl.do_storebit:
#?>>
    .set mc_auxmcl.do_storebit.p, 72
    .set mc_auxmcl.do_storebit.offset, -8
    .set mc_auxmcl.do_storebit.mask1s, -16
    .set mc_auxmcl.do_storebit.mask0s, -24
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	56
#---------------
    mov       %rcx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.isimmload
    mov       %r13,	%rax
    mov       %rax,	[%rip+mc_decls.noperands]
    sub       %rax,	2
    mov       %rcx,	%rax
    call      mc_stackmcl.isimmload
    mov       %r14,	%rax
    test      %r13,	%r13
    jz        L2094
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	3
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    mov       %r15,	[%r13+8]
    mov       %rax,	%r15
    sar       %rax,	3
    mov       [%rbp + mc_auxmcl.do_storebit.offset],	%rax
    mov       %rax,	7
    and       %r15,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	[%rbp + mc_auxmcl.do_storebit.offset]
    xor       %r8d,	%r8d
    call      mc_libmcl.applyoffset
    mov       %rdi,	%rax
    mov       %rax,	1
    mov       %cl,	%r15b
    shl       %rax,	%cl
    mov       [%rbp + mc_auxmcl.do_storebit.mask0s],	%al
    mov       %rax,	1
    mov       %cl,	%r15b
    shl       %rax,	%cl
    not       %rax
    mov       [%rbp + mc_auxmcl.do_storebit.mask1s],	%al
    test      %r14,	%r14
    jz        L2096
    mov       %rax,	[%r14+8]
    test      %rax,	%rax
    jnz       L2098
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    movzx     %r10,	byte ptr[%rbp + mc_auxmcl.do_storebit.mask1s]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_libmcl.mgenint
    mov       %rcx,	38
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L2097
L2098:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    movzx     %r10,	byte ptr[%rbp + mc_auxmcl.do_storebit.mask0s]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_libmcl.mgenint
    mov       %rcx,	39
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2097:
    jmp       L2095
L2096:
    mov       %rax,	[%rip+mc_decls.noperands]
    sub       %rax,	2
    mov       %rcx,	%rax
    mov       %rdx,	3
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    movzx     %r10,	byte ptr[%rbp + mc_auxmcl.do_storebit.mask1s]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_libmcl.mgenint
    mov       %rcx,	38
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    test      %r15,	%r15
    jz        L2100
    mov       %rcx,	%r15
    mov       %rdx,	3
    call      mc_libmcl.mgenint
    mov       %rcx,	43
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2100:
    mov       %rcx,	39
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L2095:
    jmp       L2093
L2094:
    test      %r14,	%r14
    jz        L2101
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    test      %r13,	%r13
    jnz       L2103
    mov       %rcx,	6
    call      mc_stackmcl.getworkregm
    mov       %rbx,	%rax
    mov       %rcx,	1
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	11
    mov       %rdx,	6
    call      mc_libmcl.mgenreg
    mov       %rsi,	%rax
    mov       %al,	[%rip+pc_decls.r10used]
    test      %al,	%al
    jz        L2105
    mov       %rcx,	12
    mov       %rdx,	%rsi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L2105:
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	10
    mov       %r8,	11
    call      mc_stackmcl.loadparam
    mov       %r12,	%rax
    mov       %rcx,	%rsi
    mov       %rdx,	1
    call      mc_libmcl.changeopndsize
    mov       %rcx,	43
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %al,	[%rip+pc_decls.r10used]
    test      %al,	%al
    jz        L2107
    mov       %rcx,	13
    mov       %rdx,	%rsi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L2107:
    mov       %rax,	[%r14+8]
    test      %rax,	%rax
    jnz       L2109
    mov       %rcx,	51
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	38
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    jmp       L2108
L2109:
    mov       %rcx,	39
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L2108:
    jmp       L2102
L2103:
    lea       %rcx,	[%rip+L8208]
    lea       %rdx,	[%rip+L8209]
    call      pc_api.merror
L2102:
    jmp       L2093
L2101:
    lea       %rcx,	[%rip+L8210]
    lea       %rdx,	[%rip+L8211]
    call      pc_api.merror
L2093:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	56
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_storebf
mc_auxmcl.do_storebf:
#?>>
    .set mc_auxmcl.do_storebf.p, 72
    .set mc_auxmcl.do_storebf.r, -8
    .set mc_auxmcl.do_storebf.mask, -16
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	56
    mov       [%rbp+72],	%rcx
#---------------
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    call      mc_stackmcl.isimmload
    mov       %r15,	%rax
    mov       %rcx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.isimmload
    mov       [%rbp + mc_auxmcl.do_storebf.r],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.do_storebf.r]
    cmp       %rax,	%r15
    jnz       L2112
    test      %rax,	%rax
    jnz       L2112
    lea       %rcx,	[%rip+L8212]
    lea       %rdx,	[%rip+L8213]
    call      pc_api.merror
L2112:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    sub       %r10,	3
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %r12,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    sub       %r10,	2
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    mov       %r13,	[%r15+8]
    mov       %rax,	[%rbp + mc_auxmcl.do_storebf.r]
    mov       %r14,	[%rax+8]
    mov       %rcx,	6
    call      mc_stackmcl.getworkregm
    mov       %rsi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rax
    call      mc_stackmcl.getworkregm
    mov       %rbx,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rax,	%r14
    sub       %rax,	%r13
    inc       %rax
    mov       %r10,	-1
    mov       %cl,	%al
    shl       %r10,	%cl
    not       %r10
    mov       %cl,	%r13b
    shl       %r10,	%cl
    not       %r10
    mov       [%rbp + mc_auxmcl.do_storebf.mask],	%r10
    mov       %rcx,	[%rbp + mc_auxmcl.do_storebf.mask]
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	11
    mov       %rdx,	%rsi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    test      %r13,	%r13
    jz        L2114
    mov       %rcx,	%r13
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	43
    mov       %rdx,	%r12
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2114:
    mov       %rax,	[%rbp + mc_auxmcl.do_storebf.p]
    mov       %eax,	[%rax+4]
    mov       %rcx,	%rsi
    mov       %rdx,	%rax
    call      mc_libmcl.changeopndsize
    mov       %rcx,	38
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	39
    mov       %rdx,	%rbx
    mov       %r8,	%r12
    call      mc_libmcl.genmc
    mov       %rax,	[%rbp + mc_auxmcl.do_storebf.p]
    mov       %eax,	[%rax+4]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      mc_libmcl.changeopndsize
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	56
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.gethostfn
mc_auxmcl.gethostfn:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
#---------------
    mov       %rax,	[%rip+pc_api.igethostfn]
    test      %rax,	%rax
    jnz       L2117
    cmp       %r13,	82
    jnz       L2120
L2119:
    lea       %rax,	[%rip+L8214]
    mov       %rbx,	%rax
    lea       %rax,	[%rip+L8215]
    mov       %rsi,	%rax
    jmp       L2118
L2120:
    xor       %rbx,	%rbx
L2118:
    test      %rbx,	%rbx
    jz        L2122
    mov       %r12,	[%rip+pc_decls.psymboltable]
    jmp       L2126
L2123:
    mov       %rax,	[%r12]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      mlib.eqstring
    test      %rax,	%rax
    jnz       L2129
    mov       %rax,	[%r12]
    mov       %rcx,	%rsi
    mov       %rdx,	%rax
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L2128
L2129:
    mov       %rax,	%r12
    jmp       L2115
L2128:
    mov       %r12,	[%r12+8]
L2126:
    test      %r12,	%r12
    jnz       L2123
L2122:
    lea       %rax,	[%rip+pc_tables.pclnames]
    mov       %r10,	%r13
    mov       %rax,	[%rax + %r10*8]
    lea       %rcx,	[%rip+L8216]
    mov       %rdx,	%rax
    call      pc_api.merror
L2117:
    mov       %rcx,	%r13
    mov       %rax,	[%rip+pc_api.igethostfn]
    call      %rax
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L2131
    lea       %rax,	[%rip+pc_tables.pclnames]
    mov       %r10,	%r13
    mov       %rax,	[%rax + %r10*8]
    lea       %rcx,	[%rip+L8217]
    mov       %rdx,	%rax
    call      pc_api.merror
L2131:
    mov       %rax,	%rdi
L2115:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.copyblockarg
mc_auxmcl.copyblockarg:
#?>>
    .set mc_auxmcl.copyblockarg.argno, 72
    .set mc_auxmcl.copyblockarg.$T3, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %r12,	%rcx
    mov       %r13,	%rdx
#---------------
    test      %r12,	%r12
    jnz       L2134
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8218]
    call      msys.m$print_str_nf
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L8219]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L2132
L2134:
    mov       %rcx,	%r13
    call      mc_libmcl.newblocktemp
    mov       %rdi,	%rax
    mov       %al,	1
    mov       [%rdi+92],	%al
    test      %r12,	%r12
    jz        L2136
    mov       %rcx,	6
    call      mc_stackmcl.getworkregm
    mov       %rsi,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      mc_libmcl.genmc
    jmp       L2135
L2136:
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	11
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rsi,	%rax
L2135:
    mov       %rcx,	6
    call      mc_stackmcl.getworkregm
    mov       %rbx,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       %rcx,	14
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rsi+10]
    mov       %rcx,	%rax
    mov       %rdx,	10
    xor       %r8d,	%r8d
    call      mc_libmcl.mgenireg
    mov       [%rbp + mc_auxmcl.copyblockarg.$T3],	%rax
    movzx     %rax,	byte ptr[%rbx+10]
    mov       %rcx,	%rax
    mov       %rdx,	10
    xor       %r8d,	%r8d
    call      mc_libmcl.mgenireg
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_auxmcl.copyblockarg.$T3]
    mov       %r8,	%r13
    mov       %r9,	1
    call      mc_auxmcl.copyblock
    test      %r12,	%r12
    jz        L2138
    mov       %rcx,	%rdi
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       %rcx,	14
    mov       %rdx,	%r12
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2138:
    xor       %ecx,	%ecx
    call      mc_stackmcl.freeworkregs
L2132:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.fixmain
mc_auxmcl.fixmain:
#?>>
    .set mc_auxmcl.fixmain.$T1, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
#---------------
    mov       %rdi,	[%rip+pc_decls.currfunc]
    mov       %rbx,	[%rdi+16]
    mov       %rsi,	[%rbx+16]
    lea       %rcx,	[%rip+L8220]
    mov       %rdx,	3
    call      pc_api.pc_makesymbol
    mov       %r12,	%rax
    mov       %al,	6
    mov       [%r12+82],	%al
    mov       %eax,	8
    mov       [%r12+84],	%eax
    lea       %rcx,	[%rip+L8221]
    mov       %rdx,	3
    call      pc_api.pc_makesymbol
    mov       %r13,	%rax
    mov       %al,	11
    mov       [%r13+82],	%al
    mov       %eax,	128
    mov       [%r13+84],	%eax
    mov       %rcx,	90
    mov       %rdx,	8
    call      mc_libmcl.setsegment
    mov       %rcx,	%r13
    call      mc_libmcl.mgenmemaddr
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	128
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	125
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	%r12
    call      mc_libmcl.mgenmemaddr
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	8
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	125
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	67
    mov       %rdx,	1
    call      mc_libmcl.setsegment
    mov       %rcx,	%r12
    call      pc_api.pc_addlocal
    mov       %rcx,	%r13
    call      pc_api.pc_addlocal
    xor       %eax,	%eax
    mov       [%rdi+16],	%rax
    mov       [%rsi+16],	%rax
    mov       [%rbx+16],	%rax
    xor       %eax,	%eax
    mov       [%rdi+112],	%al
    mov       %al,	4
    mov       [%rbx+72],	%al
    mov       %al,	1
    mov       [%rbx+92],	%al
    mov       %al,	4
    mov       [%rsi+72],	%al
    mov       %al,	4
    mov       [%rsi+92],	%al
    mov       %rcx,	%rsi
    call      pc_api.pc_addlocal
    mov       %rcx,	%rbx
    call      pc_api.pc_addlocal
    mov       %rcx,	1
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %r10,	%rax
    mov       %r14,	%r10
    mov       %rcx,	12
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	%r13
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       %rcx,	14
    mov       %rdx,	%r14
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %al,	1
    mov       [%r13+88],	%al
    mov       %rcx,	12
    mov       %rdx,	%r14
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	32
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	29
    mov       %rdx,	[%rip+mc_decls.dstackopnd]
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	%rbx
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       [%rbp + mc_auxmcl.fixmain.$T1],	%rax
    mov       %rcx,	11
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	14
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.fixmain.$T1]
    call      mc_libmcl.genmc
    mov       %al,	1
    mov       [%rbx+88],	%al
    mov       %rcx,	%rsi
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       [%rbp + mc_auxmcl.fixmain.$T1],	%rax
    mov       %rcx,	12
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	14
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.fixmain.$T1]
    call      mc_libmcl.genmc
    mov       %al,	1
    mov       [%rsi+88],	%al
    mov       %rcx,	%r12
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       [%rbp + mc_auxmcl.fixmain.$T1],	%rax
    mov       %rcx,	13
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	14
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.fixmain.$T1]
    call      mc_libmcl.genmc
    mov       %al,	1
    mov       [%r12+88],	%al
    mov       %rcx,	14
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	%rax
    call      mc_libmcl.clearreg
    lea       %rcx,	[%rip+L8222]
    call      mc_libmcl.mgenextname
    mov       %rcx,	21
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	48
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	29
    mov       %rdx,	[%rip+mc_decls.dstackopnd]
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rax,	[%rip+pc_decls.pcmdskip]
    test      %rax,	%rax
    jz        L2141
    mov       %rcx,	[%rip+pc_decls.pcmdskip]
    mov       %rdx,	9
    call      mc_libmcl.mgenint
    mov       [%rbp + mc_auxmcl.fixmain.$T1],	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       %rcx,	29
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.fixmain.$T1]
    call      mc_libmcl.genmc
    mov       %rax,	[%rip+pc_decls.pcmdskip]
    shl       %rax,	3
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       [%rbp + mc_auxmcl.fixmain.$T1],	%rax
    mov       %rcx,	%rsi
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       %rcx,	28
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.fixmain.$T1]
    call      mc_libmcl.genmc
L2141:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mclinit
mc_libmcl.mclinit:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r14,	%rcx
#---------------
    mov       %rax,	64
    cmp       %rax,	64
    jle       L2144
    lea       %rcx,	[%rip+L8223]
    call      mlib.abortprogram
L2144:
    mov       %rbx,	1
L2145:
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      mc_libmcl.mgenreg0
    lea       %r10,	[%rip+mc_decls.regtable]
    mov       %r11,	%rbx
    shl       %r11,	6
    lea       %r10,	[%r10 + %r11-64]
    mov       [%r10],	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	2
    call      mc_libmcl.mgenreg0
    lea       %r10,	[%rip+mc_decls.regtable]
    mov       %r11,	%rbx
    shl       %r11,	6
    lea       %r10,	[%r10 + %r11-64]
    mov       [%r10+8],	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	4
    call      mc_libmcl.mgenreg0
    lea       %r10,	[%rip+mc_decls.regtable]
    mov       %r11,	%rbx
    shl       %r11,	6
    lea       %r10,	[%r10 + %r11-64]
    mov       [%r10+24],	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	8
    call      mc_libmcl.mgenreg0
    lea       %r10,	[%rip+mc_decls.regtable]
    mov       %r11,	%rbx
    shl       %r11,	6
    lea       %r10,	[%r10 + %r11-64]
    mov       [%r10+56],	%rax
    inc       %rbx
    cmp       %rbx,	16
    jle       L2145
    mov       %r13,	-128
    mov       %rsi,	64
    cmp       %rsi,	-128
    jl        L2150
L2148:
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	3
    mov       %r8w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r8w,	%r11w
    or        %r8w,	%r10w
    mov       [%rax],	%r8w
    mov       %al,	15
    mov       [%rdi+10],	%al
    lea       %rax,	[%rdi+8]
    mov       %r10w,	8
    mov       %r8w,	[%rax]
    mov       %r11,	-32
    and       %r8w,	%r11w
    or        %r8w,	%r10w
    mov       [%rax],	%r8w
    mov       [%rdi+12],	%r13d
    mov       %rax,	%rdi
    lea       %r10,	[%rip+mc_decls.frameregtable]
    mov       %r11,	%r13
    mov       [%r10 + %r11*8+1024],	%rax
    inc       %r13
    cmp       %r13,	%rsi
    jle       L2148
L2150:
    mov       %rcx,	15
    mov       %rdx,	6
    call      mc_libmcl.mgenreg
    mov       [%rip+mc_decls.dframeopnd],	%rax
    mov       %rcx,	16
    mov       %rdx,	6
    call      mc_libmcl.mgenreg
    mov       [%rip+mc_decls.dstackopnd],	%rax
    call      mc_libmcl.initmcdest
    mov       %rcx,	67
    mov       %rdx,	1
    call      mc_libmcl.setsegment
    xor       %eax,	%eax
    mov       [%rip+mc_decls.lab_funcnametable],	%rax
    xor       %eax,	%eax
    mov       [%rip+mc_decls.lab_funcaddrtable],	%rax
    mov       %r13,	-1
    mov       %r12,	10
    cmp       %r12,	-1
    jl        L2153
L2151:
    mov       %rcx,	%r13
    mov       %rdx,	8
    call      mc_libmcl.mgenint0
    lea       %r10,	[%rip+mc_libmcl.smallinttable]
    mov       %r11,	%r13
    mov       [%r10 + %r11*8+8],	%rax
    inc       %r13
    cmp       %r13,	%r12
    jle       L2151
L2153:
    test      %r14,	%r14
    jz        L2155
    mov       %al,	1
    mov       [%rip+pc_decls.mcldone],	%al
L2155:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.initmcdest
mc_libmcl.initmcdest:
#?>>
#?]]
#---------------
    xor       %eax,	%eax
    mov       [%rip+mc_decls.mccodex],	%rax
    mov       [%rip+mc_decls.mccode],	%rax
#---------------
    ret       
# End 
# Proc mc_libmcl.genmc
mc_libmcl.genmc:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
    mov       %rcx,	64
    call      mlib.pcm_allocnfz
    mov       %rdi,	%rax
    mov       [%rdi+33],	%sil
    inc       qword ptr[%rip+mc_libmcl.mclseqno]
    mov       %rax,	[%rip+mc_libmcl.mclseqno]
    mov       [%rdi+36],	%eax
    mov       %eax,	[%rip+pc_decls.mmpos]
    mov       [%rdi+40],	%eax
    mov       [%rdi+16],	%r12
    mov       [%rdi+24],	%r13
    mov       %rax,	%rsi
    cmp       %rax,	14
    jz        L2159
    cmp       %rax,	9
    jz        L2160
    cmp       %rax,	11
    jz        L2161
    jmp       L2162
L2159:
    test      %r13,	%r13
    jz        L2164
    movzx     %rax,	word ptr[%r13+8]
    shr       %rax,	12
    and       %rax,	15
    cmp       %rax,	5
    jnz       L2164
    mov       %rax,	[%r13]
    mov       %r10b,	1
    mov       [%rax+88],	%r10b
L2164:
    jmp       L2158
L2160:
    mov       %rbx,	[%r12]
    jmp       L2158
L2161:
    movzx     %rax,	word ptr[%r12+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	5
    jz        L2167
    test      %r13,	%r13
    jz        L2166
    movzx     %rax,	word ptr[%r13+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	5
    jnz       L2166
L2167:
    movzx     %rax,	word ptr[%r12+8]
    and       %rax,	31
    cmp       %rax,	8
    jnz       L2169
    mov       %rax,	17
    jmp       L2168
L2169:
    mov       %rax,	16
L2168:
    mov       [%rdi+33],	%al
L2166:
L2162:
L2158:
    mov       %rax,	[%rip+mc_decls.mccode]
    test      %rax,	%rax
    jz        L2171
    mov       %rax,	[%rip+mc_decls.mccodex]
    mov       [%rdi],	%rax
    mov       %rax,	%rdi
    mov       %r10,	[%rip+mc_decls.mccodex]
    mov       [%r10+8],	%rax
    mov       [%rip+mc_decls.mccodex],	%rdi
    jmp       L2170
L2171:
    mov       %rax,	%rdi
    mov       [%rip+mc_decls.mccodex],	%rax
    mov       [%rip+mc_decls.mccode],	%rax
L2170:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.genmc_cond
mc_libmcl.genmc_cond:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
    mov       %r12,	%r9
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      mc_libmcl.genmc
    mov       %al,	%bl
    mov       %r10,	[%rip+mc_decls.mccodex]
    mov       [%r10+34],	%al
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.genmc_str
mc_libmcl.genmc_str:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rbx
    mov       %rdx,	-1
    call      mc_libmcl.mgenstring
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.newmclopnd
mc_libmcl.newmclopnd:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rcx,	16
    call      mlib.pcm_allocnfz
    mov       %rdi,	%rax
    inc       qword ptr[%rip+mc_libmcl.nmclopnd]
    mov       %rax,	%rdi
L2174:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.duplopnd
mc_libmcl.duplopnd:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rcx,	16
    call      mlib.pcm_allocnfz
    mov       %rdi,	%rax
    mov       %rax,	%rbx
    movdqu    %XMM4,	[%rax]
    movdqu    [%rdi],	%XMM4
    mov       %rax,	%rdi
L2175:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenindex
mc_libmcl.mgenindex:
#?>>
    .set mc_libmcl.mgenindex.size, 96
    .set mc_libmcl.mgenindex.labno, 104
    .set mc_libmcl.mgenindex.def, 112
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	32
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
    mov       %r13,	%r9
#---------------
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	3
    mov       %r15w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r15w,	%r11w
    or        %r15w,	%r10w
    mov       [%rax],	%r15w
    mov       [%rdi+10],	%bl
    cmp       %rbx,	15
    jz        L2179
    cmp       %rsi,	15
    jnz       L2178
L2179:
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.usedregs]
    mov       [%r10+14],	%al
L2178:
    mov       [%rdi+11],	%sil
    lea       %rax,	[%rdi+8]
    mov       %r10w,	%r12w
    mov       %r15w,	[%rax]
    mov       %r11,	-481
    shl       %r10w,	5
    and       %r15w,	%r11w
    or        %r15w,	%r10w
    mov       [%rax],	%r15w
    lea       %rax,	[%rdi+8]
    mov       %r10w,	[%rbp + mc_libmcl.mgenindex.size]
    mov       %r15w,	[%rax]
    mov       %r11,	-32
    and       %r15w,	%r11w
    or        %r15w,	%r10w
    mov       [%rax],	%r15w
    mov       [%rdi+12],	%r13d
    mov       %rax,	[%rbp + mc_libmcl.mgenindex.labno]
    test      %rax,	%rax
    jz        L2181
    mov       %rax,	[%rbp + mc_libmcl.mgenindex.labno]
    mov       [%rdi],	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	6
    mov       %r15w,	[%rax]
    mov       %r11,	-61441
    shl       %r10w,	12
    and       %r15w,	%r11w
    or        %r15w,	%r10w
    mov       [%rax],	%r15w
    jmp       L2180
L2181:
    mov       %rax,	[%rbp + mc_libmcl.mgenindex.def]
    test      %rax,	%rax
    jz        L2182
    mov       %rax,	[%rbp + mc_libmcl.mgenindex.def]
    mov       [%rdi],	%rax
    mov       %rax,	[%rbp + mc_libmcl.mgenindex.def]
    lea       %rax,	[%rax+89]
    inc       byte ptr[%rax]
    lea       %rax,	[%rdi+8]
    mov       %r10w,	5
    mov       %r15w,	[%rax]
    mov       %r11,	-61441
    shl       %r10w,	12
    and       %r15w,	%r11w
    or        %r15w,	%r10w
    mov       [%rax],	%r15w
    mov       %rax,	[%rbp + mc_libmcl.mgenindex.def]
    movzx     %rax,	byte ptr[%rax+72]
    cmp       %rax,	4
    jz        L2185
    cmp       %rax,	5
    jnz       L2184
L2185:
    mov       %al,	15
    mov       [%rdi+10],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.usedregs]
    mov       [%r10+14],	%al
L2184:
L2182:
L2180:
    mov       %rax,	%rdi
L2176:
#---------------
    add       %rsp,	32
    pop       %rbp
    pop       %r15
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgencomment
mc_libmcl.mgencomment:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	3
    mov       %rdx,	%rdi
    call      mc_libmcl.genmc_str
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenstring
mc_libmcl.mgenstring:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	2
    mov       %r9w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    cmp       %rsi,	0
    jge       L2189
    mov       %rcx,	%rbx
    call      strlen
    mov       %rsi,	%rax
L2189:
    lea       %rax,	[%rsi+1]
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       [%rdi],	%rax
    mov       %rax,	[%rdi]
    mov       %rcx,	%rax
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      memcpy
    mov       %rax,	[%rdi]
    xor       %r10d,	%r10d
    mov       %r11,	%rsi
    mov       [%rax + %r11],	%r10b
    lea       %rax,	[%rdi+8]
    mov       %r10w,	4
    mov       %r9w,	[%rax]
    mov       %r11,	-61441
    shl       %r10w,	12
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    lea       %rax,	[%rdi+8]
    mov       %r10w,	8
    mov       %r9w,	[%rax]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       %rax,	%rdi
L2187:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenname
mc_libmcl.mgenname:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	2
    mov       %r9w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       %rcx,	%rbx
    call      mlib.pcm_copyheapstring
    mov       [%rdi],	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	7
    mov       %r9w,	[%rax]
    mov       %r11,	-61441
    shl       %r10w,	12
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    lea       %rax,	[%rdi+8]
    mov       %r10w,	8
    mov       %r9w,	[%rax]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       %rax,	%rdi
L2190:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.setsegment
mc_libmcl.setsegment:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    cmp       %rsi,	[%rip+mc_decls.currsegment]
    jz        L2193
    mov       %rax,	%rsi
    cmp       %rax,	73
    jz        L2195
    cmp       %rax,	90
    jz        L2196
    cmp       %rax,	67
    jz        L2197
    cmp       %rax,	82
    jz        L2198
    jmp       L2199
L2195:
    mov       %rdi,	121
    jmp       L2194
L2196:
    mov       %rdi,	122
    jmp       L2194
L2197:
    mov       %rdi,	123
    jmp       L2194
L2198:
    lea       %rcx,	[%rip+L8224]
    lea       %rdx,	[%rip+L8225]
    call      pc_api.merror
    jmp       L2194
L2199:
    lea       %rcx,	[%rip+L8226]
    lea       %rdx,	[%rip+L8227]
    call      pc_api.merror
L2194:
    mov       %rax,	[%rip+mc_decls.mccodex]
    test      %rax,	%rax
    jz        L2201
    mov       %rax,	[%rip+mc_decls.mccodex]
    movzx     %rax,	byte ptr[%rax+33]
    cmp       %rax,	121
    jz        L2202
    cmp       %rax,	122
    jz        L2202
    cmp       %rax,	123
    jnz       L2201
L2202:
    mov       %al,	%dil
    mov       %r10,	[%rip+mc_decls.mccodex]
    mov       [%r10+33],	%al
    jmp       L2200
L2201:
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L2200:
    mov       [%rip+mc_decls.currsegment],	%rsi
L2193:
    cmp       %r12,	1
    jle       L2204
    mov       %rax,	[%rip+mc_decls.mccodex]
    movzx     %rax,	byte ptr[%rax+33]
    cmp       %rax,	124
    jnz       L2206
    mov       %rax,	[%rip+mc_decls.mccodex]
    mov       %rax,	[%rax+16]
    mov       %rbx,	[%rax]
    cmp       %rbx,	%r12
    jge       L2191
L2208:
L2206:
    mov       %rcx,	%r12
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	124
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L2204:
L2191:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.changeopndsize
mc_libmcl.changeopndsize:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    movzx     %rax,	word ptr[%rbx+8]
    and       %rax,	31
    cmp       %rax,	%rsi
    jz        L2211
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jnz       L2213
    movzx     %rax,	byte ptr[%rbx+10]
    lea       %r10,	[%rip+mc_decls.regtable]
    mov       %r11,	%rax
    shl       %r11,	6
    lea       %r10,	[%r10 + %r11-64]
    mov       %rax,	%rsi
    mov       %r10,	[%r10 + %rax*8-8]
    mov       %rdi,	%r10
    jmp       L2212
L2213:
    mov       %rcx,	%rbx
    call      mc_libmcl.duplopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	%si
    mov       %r8w,	[%rax]
    mov       %r11,	-32
    and       %r8w,	%r11w
    or        %r8w,	%r10w
    mov       [%rax],	%r8w
L2212:
    mov       %rax,	%rdi
    jmp       L2209
L2211:
    mov       %rax,	%rbx
L2209:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.applyoffset
mc_libmcl.applyoffset:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    test      %rsi,	%rsi
    jnz       L2216
    test      %r12,	%r12
    jnz       L2216
    mov       %rax,	%rbx
    jmp       L2214
L2216:
    mov       %rcx,	%rbx
    call      mc_libmcl.duplopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+12]
    mov       %r10d,	%esi
    add       [%rax],	%r10d
    test      %r12,	%r12
    jz        L2218
    lea       %rax,	[%rdi+8]
    mov       %r10w,	%r12w
    mov       %r9w,	[%rax]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
L2218:
    mov       %rax,	%rdi
L2214:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenint
mc_libmcl.mgenint:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    lea       %rax,	[%rip+pc_tables.psize]
    mov       %r10,	%r12
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %rbx,	%rax
    mov       %rax,	%rsi
    cmp       %rax,	-1
    jl        L2221
    cmp       %rax,	10
    jg        L2221
    cmp       %rbx,	8
    jnz       L2221
    lea       %rax,	[%rip+mc_libmcl.smallinttable]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8+8]
    jmp       L2219
L2221:
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	2
    mov       %r9w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       [%rdi],	%rsi
    lea       %rax,	[%rdi+8]
    mov       %r10w,	1
    mov       %r9w,	[%rax]
    mov       %r11,	-61441
    shl       %r10w,	12
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    lea       %rax,	[%rdi+8]
    mov       %r10w,	%bx
    mov       %r9w,	[%rax]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       %rax,	%rdi
L2219:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenint0
mc_libmcl.mgenint0:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	2
    mov       %r9w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       [%rdi],	%rbx
    lea       %rax,	[%rdi+8]
    mov       %r10w,	1
    mov       %r9w,	[%rax]
    mov       %r11,	-61441
    shl       %r10w,	12
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    lea       %rax,	[%rdi+8]
    mov       %r10w,	%si
    mov       %r9w,	[%rax]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       %rax,	%rdi
L2222:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenrealmem
mc_libmcl.mgenrealmem:
#?>>
    push      %rdi
    push      %rbx
    movq      %rax,	%XMM15
    push      %rax
#?]]
    sub       %rsp,	48
    movq      %XMM15,	%XMM0
    mov       %rbx,	%rdx
#---------------
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	3
    mov       %r9w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    lea       %rax,	[%rbx-1]
    test      %rax,	%rax
    jz        L2225
    movq      %XMM0,	%XMM15
    call      mc_libmcl.getrealindex
    mov       [%rdi],	%rax
    jmp       L2224
L2225:
    movq      %XMM0,	%XMM15
    call      mc_libmcl.getr32index
    mov       [%rdi],	%rax
L2224:
    lea       %rax,	[%rdi+8]
    mov       %r10w,	6
    mov       %r9w,	[%rax]
    mov       %r11,	-61441
    shl       %r10w,	12
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    lea       %rax,	[%rip+pc_tables.psize]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10]
    lea       %r10,	[%rdi+8]
    mov       %r9w,	[%r10]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%ax
    mov       [%r10],	%r9w
    mov       %rax,	%rdi
L2223:
#---------------
    add       %rsp,	48
    pop       %rcx
    movq      %XMM15,	%rcx
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenrealimm
mc_libmcl.mgenrealimm:
#?>>
    push      %rdi
    push      %rbx
    movq      %rax,	%XMM15
    push      %rax
#?]]
    sub       %rsp,	48
    movq      %XMM15,	%XMM0
    mov       %rbx,	%rdx
#---------------
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	2
    mov       %r9w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    movq      %XMM4,	%XMM15
    movq      [%rdi],	%XMM4
    lea       %rax,	[%rdi+8]
    mov       %r10w,	2
    mov       %r9w,	[%rax]
    mov       %r11,	-61441
    shl       %r10w,	12
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    lea       %rax,	[%rip+pc_tables.psize]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10]
    lea       %r10,	[%rdi+8]
    mov       %r9w,	[%r10]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%ax
    mov       [%r10],	%r9w
    mov       %rax,	%rdi
L2226:
#---------------
    add       %rsp,	48
    pop       %rcx
    movq      %XMM15,	%rcx
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenlabel
mc_libmcl.mgenlabel:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	2
    mov       %r9w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    test      %rbx,	%rbx
    jnz       L2229
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rbx,	[%rip+pc_api.mlabelno]
L2229:
    mov       [%rdi],	%rbx
    lea       %rax,	[%rdi+8]
    mov       %r10w,	6
    mov       %r9w,	[%rax]
    mov       %r11,	-61441
    shl       %r10w,	12
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       %rax,	%rdi
L2227:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenlabelmem
mc_libmcl.mgenlabelmem:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rcx,	%rbx
    call      mc_libmcl.mgenlabel
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	3
    mov       %r9w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       %rax,	%rdi
L2230:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenmem
mc_libmcl.mgenmem:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    mov       %al,	[%rsi+90]
    test      %al,	%al
    jz        L2233
    movzx     %rax,	byte ptr[%rsi+82]
    lea       %r10,	[%rip+pc_tables.pfloat]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L2235
    mov       %rcx,	%rsi
    call      mc_libmcl.mgenxregvar
    jmp       L2231
L2235:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    call      mc_libmcl.mgenregvar
    jmp       L2231
L2234:
L2233:
    xor       %rbx,	%rbx
    movzx     %rax,	byte ptr[%rsi+72]
    cmp       %rax,	4
    jz        L2238
    cmp       %rax,	5
    jnz       L2237
L2238:
    mov       %rbx,	15
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.usedregs]
    mov       [%r10+14],	%al
L2237:
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	3
    mov       %r9w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       [%rdi+10],	%bl
    mov       [%rdi],	%rsi
    lea       %rax,	[%rsi+89]
    inc       byte ptr[%rax]
    lea       %rax,	[%rdi+8]
    mov       %r10w,	5
    mov       %r9w,	[%rax]
    mov       %r11,	-61441
    shl       %r10w,	12
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    test      %r12,	%r12
    jz        L2240
    lea       %rax,	[%rip+pc_tables.psize]
    mov       %r10,	%r12
    movzx     %rax,	byte ptr[%rax + %r10]
    lea       %r10,	[%rdi+8]
    mov       %r9w,	[%r10]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%ax
    mov       [%r10],	%r9w
    jmp       L2239
L2240:
    mov       %eax,	[%rsi+84]
    mov       %r10,	8
    cmp       %rax,	%r10
    cmova     %rax,	%r10
    lea       %r10,	[%rdi+8]
    mov       %r9w,	[%r10]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%ax
    mov       [%r10],	%r9w
L2239:
    mov       %rax,	%rdi
L2231:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenmemaddr
mc_libmcl.mgenmemaddr:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %al,	1
    mov       [%rbx+88],	%al
    lea       %rax,	[%rbx+89]
    inc       byte ptr[%rax]
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	2
    mov       %r9w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       [%rdi],	%rbx
    lea       %rax,	[%rbx+89]
    inc       byte ptr[%rax]
    lea       %rax,	[%rdi+8]
    mov       %r10w,	5
    mov       %r9w,	[%rax]
    mov       %r11,	-61441
    shl       %r10w,	12
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    lea       %rax,	[%rdi+8]
    mov       %r10w,	8
    mov       %r9w,	[%rax]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       %rax,	%rdi
L2241:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenreg0
mc_libmcl.mgenreg0:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	1
    mov       %r9w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       [%rdi+10],	%bl
    lea       %rax,	[%rdi+8]
    mov       %r10w,	%si
    mov       %r9w,	[%rax]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    test      %rsi,	%rsi
    jnz       L2244
    lea       %rcx,	[%rip+L8228]
    lea       %rdx,	[%rip+L8229]
    call      pc_api.merror
L2244:
    mov       %rax,	%rdi
L2242:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenxreg
mc_libmcl.mgenxreg:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	5
    mov       %r9w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       [%rdi+10],	%bl
    lea       %rax,	[%rdi+8]
    mov       %r10w,	%si
    mov       %r9w,	[%rax]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    test      %rsi,	%rsi
    jnz       L2247
    lea       %rcx,	[%rip+L8230]
    lea       %rdx,	[%rip+L8231]
    call      pc_api.merror
L2247:
    mov       %rax,	%rdi
L2245:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenreg
mc_libmcl.mgenreg:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    lea       %rax,	[%rip+pc_tables.psize]
    mov       %r10,	%r12
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %rbx,	%rax
    cmp       %r12,	2
    jg        L2250
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	5
    mov       %r8w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r8w,	%r11w
    or        %r8w,	%r10w
    mov       [%rax],	%r8w
    mov       [%rdi+10],	%sil
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.usedxregs]
    mov       %r11,	%rsi
    mov       [%r10 + %r11-1],	%al
    lea       %rax,	[%rip+pc_tables.psize]
    mov       %r10,	%r12
    movzx     %rax,	byte ptr[%rax + %r10]
    lea       %r10,	[%rdi+8]
    mov       %r8w,	[%r10]
    mov       %r11,	-32
    and       %r8w,	%r11w
    or        %r8w,	%ax
    mov       [%r10],	%r8w
    mov       %rax,	%rdi
    jmp       L2249
L2250:
    test      %rbx,	%rbx
    jnz       L2252
    mov       %rbx,	8
L2252:
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.usedregs]
    mov       %r11,	%rsi
    mov       [%r10 + %r11-1],	%al
    mov       %rax,	%rsi
    cmp       %rax,	11
    jl        L2254
    cmp       %rax,	14
    jg        L2254
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.regset]
    mov       %r11,	%rsi
    mov       [%r10 + %r11-1],	%al
L2254:
    lea       %rax,	[%rip+mc_decls.regtable]
    mov       %r10,	%rsi
    shl       %r10,	6
    lea       %rax,	[%rax + %r10-64]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8-8]
    jmp       L2248
    mov       %rcx,	%rsi
    mov       %rdx,	%rbx
    call      mc_libmcl.mgenreg0
L2249:
L2248:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenregi
mc_libmcl.mgenregi:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    lea       %rax,	[%rip+mc_decls.regtable]
    mov       %r10,	%rdi
    shl       %r10,	6
    lea       %rax,	[%rax + %r10-64]
    lea       %r10,	[%rip+pc_tables.psize]
    mov       %r11,	%rbx
    movzx     %r10,	byte ptr[%r10 + %r11]
    mov       %rax,	[%rax + %r10*8-8]
    jmp       L2255
    lea       %rax,	[%rip+pc_tables.psize]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mc_libmcl.mgenreg0
L2255:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenireg
mc_libmcl.mgenireg:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	3
    mov       %r9w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       [%rdi+10],	%bl
    lea       %rax,	[%rip+pc_tables.psize]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10]
    lea       %r10,	[%rdi+8]
    mov       %r9w,	[%r10]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%ax
    mov       [%r10],	%r9w
    mov       [%rdi+12],	%r12d
    mov       %rax,	%rdi
L2256:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgentemp
mc_libmcl.mgentemp:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    lea       %rax,	[%rip+mc_decls.pcltempflags]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L2259
    lea       %rax,	[%rip+pc_tables.psize]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10]
    lea       %r10,	[%rip+mc_decls.pcltempopnds]
    mov       %r11,	%rbx
    mov       %r10,	[%r10 + %r11*8-8]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_libmcl.changeopndsize
    jmp       L2257
L2259:
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	3
    mov       %r9w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       %al,	15
    mov       [%rdi+10],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.usedregs]
    mov       [%r10+14],	%al
    lea       %rax,	[%rdi+8]
    mov       %r10w,	8
    mov       %r9w,	[%rax]
    mov       %r11,	-61441
    shl       %r10w,	12
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    lea       %rax,	[%rip+pc_tables.psize]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10]
    lea       %r10,	[%rdi+8]
    mov       %r9w,	[%r10]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%ax
    mov       [%r10],	%r9w
    mov       [%rdi],	%rbx
    mov       %rax,	%rdi
    lea       %r10,	[%rip+mc_decls.pcltempopnds]
    mov       %r11,	%rbx
    mov       [%r10 + %r11*8-8],	%rax
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.pcltempflags]
    mov       %r11,	%rbx
    mov       [%r10 + %r11-1],	%al
    mov       %rax,	%rdi
L2257:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.roundsizetg
mc_libmcl.roundsizetg:
#?>>
#?]]
#---------------
    mov       %rax,	%rcx
    and       %rax,	7
    jnz       L2262
    mov       %rax,	%rcx
    jmp       L2260
L2262:
    mov       %rax,	%rcx
    and       %rax,	7
    mov       %r10,	8
    sub       %r10,	%rax
    mov       %rax,	%rcx
    add       %rax,	%r10
L2260:
#---------------
    ret       
# End 
# Proc mc_libmcl.merroropnd
mc_libmcl.merroropnd:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8232]
    call      msys.m$print_setfmt
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+pc_tables.opndnames]
    mov       %r10,	%rbx
    mov       %rcx,	[%rax + %r10*8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	1
    call      exit
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mcreatefwdlabel
mc_libmcl.mcreatefwdlabel:
#?>>
#?]]
#---------------
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rax,	[%rip+pc_api.mlabelno]
L2264:
#---------------
    ret       
# End 
# Proc mc_libmcl.mdefinefwdlabel
mc_libmcl.mdefinefwdlabel:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenextname
mc_libmcl.mgenextname:
#?>>
    .set mc_libmcl.mgenextname.str, -64
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	96
    mov       %rbx,	%rcx
#---------------
    lea       %rcx,	[%rbp + mc_libmcl.mgenextname.str]
    mov       %rdx,	%rbx
    call      strcpy
    mov       %rcx,	%rbx
    call      strlen
    xor       %r10d,	%r10d
    mov       [%rbp + %rax + mc_libmcl.mgenextname.str-1],	%r10b
    lea       %rcx,	[%rbp + mc_libmcl.mgenextname.str]
    call      mc_libmcl.findnamesym
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L2268
    mov       %rcx,	128
    call      mlib.pcm_allocnfz
    mov       %rdi,	%rax
    lea       %rcx,	[%rbp + mc_libmcl.mgenextname.str]
    call      mlib.pcm_copyheapstring
    mov       [%rdi],	%rax
    mov       %al,	1
    mov       [%rdi+72],	%al
    mov       %al,	1
    mov       [%rdi+80],	%al
    mov       %rcx,	%rdi
    call      mc_libmcl.addnamesym
L2268:
    mov       %rcx,	%rdi
    call      mc_libmcl.mgenmemaddr
L2266:
#---------------
    add       %rsp,	96
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenregvar
mc_libmcl.mgenregvar:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    movzx     %rax,	byte ptr[%rbx+90]
    mov       %rcx,	%rax
    mov       %rdx,	%rsi
    call      mc_libmcl.mgenreg
    mov       %rdi,	%rax
    mov       %rax,	%rdi
L2269:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenxregvar
mc_libmcl.mgenxregvar:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rbx+90]
    mov       %rcx,	%rax
    mov       %rdx,	8
    call      mc_libmcl.mgenxreg
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rbx+90]
    mov       %r10b,	1
    lea       %r11,	[%rip+mc_decls.isxregvar]
    mov       [%r11 + %rax-1],	%r10b
    mov       %rax,	%rdi
L2270:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.getprimreg
mc_libmcl.getprimreg:
#?>>
#?]]
#---------------
    mov       %al,	[%rcx+10]
    test      %al,	%al
    jz        L2273
    movzx     %rax,	byte ptr[%rcx+10]
    jmp       L2272
L2273:
    movzx     %rax,	byte ptr[%rcx+11]
L2272:
L2271:
#---------------
    ret       
# End 
# Proc mc_libmcl.pushslots
mc_libmcl.pushslots:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	%rdi
    shl       %rax,	3
    mov       %rcx,	%rax
    call      mc_libmcl.pushstack
    mov       %rax,	%rdi
    add       [%rip+mc_decls.mstackdepth],	%rax
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.popslots
mc_libmcl.popslots:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	%rdi
    shl       %rax,	3
    mov       %rcx,	%rax
    call      mc_libmcl.popstack
    mov       %rax,	%rdi
    sub       [%rip+mc_decls.mstackdepth],	%rax
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.pushstack
mc_libmcl.pushstack:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    test      %rdi,	%rdi
    jz        L2278
    mov       %rcx,	%rdi
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	29
    mov       %rdx,	[%rip+mc_decls.dstackopnd]
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2278:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.popstack
mc_libmcl.popstack:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    test      %rdi,	%rdi
    jz        L2281
    mov       %rcx,	%rdi
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	28
    mov       %rdx,	[%rip+mc_decls.dstackopnd]
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2281:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.getstringindex
mc_libmcl.getstringindex:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    test      %rdi,	%rdi
    jnz       L2284
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rax,	[%rip+pc_api.mlabelno]
    mov       [%rip+mc_decls.kk0used],	%rax
    mov       %rax,	[%rip+mc_decls.kk0used]
    jmp       L2282
L2284:
    mov       %rax,	[%rip+mc_decls.cstringlist]
    test      %rax,	%rax
    jz        L2286
    mov       %rax,	[%rip+mc_decls.cstringlist]
    mov       %rax,	[%rax+24]
    mov       %r10,	%rbx
    cmp       %r10,	%rax
    jnz       L2286
    mov       %rax,	[%rip+mc_decls.cstringlist]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mlib.eqbytes
    test      %rax,	%rax
    jz        L2286
    mov       %rax,	[%rip+mc_decls.cstringlist]
    mov       %rax,	[%rax+16]
    jmp       L2282
L2286:
    lea       %rcx,	[%rip+mc_decls.cstringlist]
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.addconst
L2282:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.addconst
mc_libmcl.addconst:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    mov       %rcx,	32
    call      mlib.pcm_allocnfz
    mov       %rdi,	%rax
    mov       [%rdi],	%rsi
    mov       [%rdi+24],	%r12
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rax,	[%rip+pc_api.mlabelno]
    mov       [%rdi+16],	%rax
    mov       %rax,	[%rbx]
    mov       [%rdi+8],	%rax
    mov       [%rbx],	%rdi
    mov       %rax,	[%rip+pc_api.mlabelno]
L2287:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.getrealindex
mc_libmcl.getrealindex:
#?>>
    movq      %rax,	%XMM15
    push      %rax
#?]]
    sub       %rsp,	48
    movq      %XMM15,	%XMM0
#---------------
    movq      %XMM4,	%XMM15
    movq      %rax,	%XMM4
    lea       %rcx,	[%rip+mc_decls.creallist]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.addconst
L2288:
#---------------
    add       %rsp,	48
    pop       %rcx
    movq      %XMM15,	%rcx
    ret       
# End 
# Proc mc_libmcl.getr32index
mc_libmcl.getr32index:
#?>>
    movq      %rax,	%XMM15
    push      %rax
#?]]
    sub       %rsp,	48
    movq      %XMM15,	%XMM0
#---------------
    movq      %XMM4,	%XMM15
    movq      %rax,	%XMM4
    lea       %rcx,	[%rip+mc_decls.cr32list]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.addconst
L2289:
#---------------
    add       %rsp,	48
    pop       %rcx
    movq      %XMM15,	%rcx
    ret       
# End 
# Proc mc_libmcl.ispoweroftwo
mc_libmcl.ispoweroftwo:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	16
#---------------
    mov       %rdi,	1
    xor       %rbx,	%rbx
    mov       %rax,	60
    mov       %rsi,	%rax
L2291:
    inc       %rbx
    mov       %rax,	%rdi
    shl       %rax,	1
    mov       %rdi,	%rax
    cmp       %rdi,	%rcx
    jnz       L2295
    mov       %rax,	%rbx
    jmp       L2290
L2295:
    dec       %rsi
    jnz       L2291
    xor       %eax,	%eax
L2290:
#---------------
    add       %rsp,	16
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.axerror
mc_libmcl.axerror:
#?>>
    .set mc_libmcl.axerror.filename, -8
    .set mc_libmcl.axerror.sourceline, -16
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rbx,	%rcx
#---------------
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8233]
    call      msys.m$print_str_nf
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L8234]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+mc_decls.aaseqno]
    call      msys.m$print_i64_nf
    lea       %rcx,	[%rip+L8235]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+mc_decls.aapos]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rax,	[%rip+pc_decls.igetmsourceinfo]
    test      %rax,	%rax
    jz        L2298
    mov       %rcx,	[%rip+pc_decls.mmpos]
    lea       %rdx,	[%rbp + mc_libmcl.axerror.filename]
    lea       %r8,	[%rbp + mc_libmcl.axerror.sourceline]
    mov       %rax,	[%rip+pc_decls.igetmsourceinfo]
    call      %rax
    mov       %rdi,	%rax
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8236]
    call      msys.m$print_str_nf
    mov       %rcx,	%rdi
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8237]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rbp + mc_libmcl.axerror.filename]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L2298:
    mov       %rcx,	1
    call      exit
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.newblocktemp
mc_libmcl.newblocktemp:
#?>>
    .set mc_libmcl.newblocktemp.str, -16
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rbx,	%rcx
#---------------
    mov       %rax,	[%rip+mc_decls.nblocktemps]
    cmp       %rax,	50
    jle       L2301
    lea       %rcx,	[%rip+L8238]
    lea       %rdx,	[%rip+L8239]
    call      pc_api.merror
L2301:
    inc       qword ptr[%rip+mc_decls.nblocktemps]
    lea       %rcx,	[%rbp + mc_libmcl.newblocktemp.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8240]
    call      msys.m$print_setfmt
    mov       %rcx,	[%rip+mc_decls.nblocktemps]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + mc_libmcl.newblocktemp.str]
    mov       %rdx,	8
    call      pc_api.pc_makesymbol
    mov       %rdi,	%rax
    mov       %al,	11
    mov       [%rdi+82],	%al
    mov       [%rdi+84],	%ebx
    mov       %al,	1
    mov       [%rdi+92],	%al
    mov       %al,	4
    mov       [%rdi+72],	%al
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %rax,	[%rax+24]
    mov       [%rdi+24],	%rax
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       [%rdi+32],	%rax
    mov       %rax,	%rdi
    mov       %r10,	[%rip+pc_decls.currfunc]
    mov       [%r10+24],	%rax
    mov       %rax,	%rdi
    lea       %r10,	[%rip+mc_decls.blockdefs]
    mov       %r11,	[%rip+mc_decls.nblocktemps]
    mov       [%r10 + %r11*8-8],	%rax
    mov       %rax,	%rdi
L2299:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.findnamesym
mc_libmcl.findnamesym:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rdi,	1
    mov       %rax,	[%rip+mc_libmcl.nnametable]
    cmp       %rax,	1
    jl        L2305
L2303:
    lea       %rax,	[%rip+mc_libmcl.nametable]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rax,	[%rax]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L2307
    lea       %rax,	[%rip+mc_libmcl.nametable]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    jmp       L2302
L2307:
    inc       %rdi
    cmp       %rdi,	[%rip+mc_libmcl.nnametable]
    jle       L2303
L2305:
    xor       %eax,	%eax
L2302:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.addnamesym
mc_libmcl.addnamesym:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	[%rip+mc_libmcl.nnametable]
    cmp       %rax,	20
    jge       L2310
    inc       qword ptr[%rip+mc_libmcl.nnametable]
    mov       %rax,	[%rip+mc_libmcl.nnametable]
    mov       %r10,	%rdi
    lea       %r11,	[%rip+mc_libmcl.nametable]
    mov       [%r11 + %rax*8-8],	%r10
    jmp       L2309
L2310:
    lea       %rcx,	[%rip+L8241]
    lea       %rdx,	[%rip+L8242]
    call      pc_api.merror
L2309:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.clearreg
mc_libmcl.clearreg:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    movzx     %rax,	word ptr[%rdi+8]
    and       %rax,	31
    cmp       %rax,	8
    jnz       L2313
    mov       %rcx,	%rdi
    mov       %rdx,	4
    call      mc_libmcl.changeopndsize
    mov       %rdi,	%rax
L2313:
    mov       %rcx,	40
    mov       %rdx,	%rdi
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.getopnd
mc_stackmcl.getopnd:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       %r15,	%r8
#---------------
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	%r13
    mov       %rsi,	[%rax + %r10*8-8]
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%r13
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	1
    jz        L2316
    cmp       %rax,	2
    jz        L2316
    cmp       %rax,	3
    jz        L2317
    jmp       L2318
L2316:
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%r13
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rcx,	%rax
    mov       %rdx,	%r14
    call      mc_libmcl.mgenreg
    jmp       L2314
L2317:
    mov       %rcx,	%r13
    mov       %rdx,	%r14
    call      mc_libmcl.mgentemp
    mov       %rbx,	%rax
    mov       %rax,	%rbx
    jmp       L2314
L2318:
L2315:
    movzx     %rax,	byte ptr[%rsi+1]
    cmp       %rax,	1
    jz        L2320
    cmp       %rax,	2
    jz        L2321
    cmp       %rax,	4
    jz        L2322
    cmp       %rax,	5
    jz        L2323
    cmp       %rax,	6
    jz        L2323
    cmp       %rax,	7
    jz        L2324
    cmp       %rax,	3
    jz        L2325
    jmp       L2326
L2320:
    mov       %r12,	[%rsi+8]
    cmp       %r14,	11
    jnz       L2328
    movzx     %rax,	byte ptr[%r12+72]
    cmp       %rax,	5
    jz        L2328
    mov       %r14,	6
    jmp       L2321
L2328:
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    mov       %rdx,	%r14
    call      mc_libmcl.mgenmem
    mov       %rdi,	%rax
L2327:
    jmp       L2319
L2321:
    mov       %r12,	[%rsi+8]
    movzx     %rax,	byte ptr[%r12+72]
    cmp       %rax,	5
    jnz       L2330
    movzx     %rax,	byte ptr[%r12+82]
    cmp       %rax,	11
    jnz       L2330
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    mov       %rdx,	%r14
    call      mc_libmcl.mgenmem
    mov       %rdi,	%rax
    jmp       L2329
L2330:
    mov       %rcx,	%r15
    mov       %rdx,	%r14
    call      mc_stackmcl.getworkreg_rm
    mov       %rdi,	%rax
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    mov       %rdx,	%r14
    call      mc_libmcl.mgenmem
    mov       %rcx,	14
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2329:
    jmp       L2319
L2322:
    lea       %rax,	[%rip+pc_tables.psize]
    mov       %r10,	%r14
    movzx     %rax,	byte ptr[%rax + %r10]
    cmp       %rax,	2
    jz        L2332
    cmp       %rax,	4
    jz        L2333
    jmp       L2334
L2332:
    lea       %rax,	[%rsi+8]
    mov       %r10,	65535
    and       [%rax],	%r10
    jmp       L2331
L2333:
    lea       %rax,	[%rsi+8]
    mov       %r10,	4294967295
    and       [%rax],	%r10
L2334:
L2331:
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    mov       %rdx,	%r14
    call      mc_libmcl.mgenint
    mov       %rbx,	%rax
    mov       %rax,	[%rsi+8]
    cmp       %rax,	-2147483648
    jl        L2336
    cmp       %rax,	2147483647
    jg        L2336
    mov       %rdi,	%rbx
    jmp       L2335
L2336:
    mov       %rcx,	%r15
    mov       %rdx,	%r14
    call      mc_stackmcl.getworkreg_rm
    mov       %rdi,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L2335:
    jmp       L2319
L2323:
    movq      %XMM4,	[%rsi+8]
    movq      %XMM0,	%XMM4
    mov       %rdx,	%r14
    call      mc_libmcl.mgenrealmem
    mov       %rdi,	%rax
    jmp       L2319
L2324:
    mov       %rcx,	%r15
    mov       %rdx,	%r14
    call      mc_stackmcl.getworkreg_rm
    mov       %rdi,	%rax
    mov       %eax,	[%rsi+16]
    mov       %r10,	[%rsi+8]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_libmcl.getstringindex
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabelmem
    mov       %rcx,	14
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L2319
L2325:
    mov       %rcx,	%r15
    mov       %rdx,	%r14
    call      mc_stackmcl.getworkreg_rm
    mov       %rdi,	%rax
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabelmem
    mov       %rcx,	14
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L2319
L2326:
#mc_stackmcl.getopnd.error:
    movzx     %rax,	byte ptr[%rsi+1]
    lea       %r10,	[%rip+pc_tables.opndnames]
    mov       %r10,	[%r10 + %rax*8]
    lea       %rcx,	[%rip+L8243]
    mov       %rdx,	%r10
    call      pc_api.merror
L2319:
    mov       %rax,	%rdi
L2314:
#---------------
    add       %rsp,	48
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.loadopnd
mc_stackmcl.loadopnd:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      mc_stackmcl.getopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	2
    jnz       L2340
    test      %r12,	%r12
    jnz       L2342
    mov       %rcx,	%rsi
    call      mc_stackmcl.getworkreg
    mov       %r12,	%rax
L2342:
L2340:
    mov       %rcx,	%rdi
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      mc_stackmcl.loadtoreg
    mov       %rdi,	%rax
    xor       %eax,	%eax
    lea       %r10,	[%rip+mc_decls.pclopnd]
    mov       %r11,	%rbx
    mov       [%r10 + %r11*8-8],	%rax
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.pclloc]
    mov       %r11,	%rbx
    mov       [%r10 + %r11-1],	%al
    mov       %al,	[%rdi+10]
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	%rbx
    mov       [%r10 + %r11-1],	%al
    mov       %rax,	%rdi
L2338:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.loadparam
mc_stackmcl.loadparam:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      mc_stackmcl.getopnd
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      mc_stackmcl.loadtoreg_m
    mov       %rdi,	%rax
    mov       %rax,	%rdi
L2343:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.pushopnd
mc_stackmcl.pushopnd:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
#---------------
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	%r12
    mov       %rsi,	[%rax + %r10*8-8]
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%r12
    movzx     %rax,	byte ptr[%rax + %r10-1]
    test      %rax,	%rax
    jnz       L2346
    movzx     %rax,	byte ptr[%rsi+1]
    cmp       %rax,	1
    jz        L2348
    cmp       %rax,	4
    jz        L2349
    cmp       %rax,	5
    jz        L2350
    jmp       L2351
L2348:
    cmp       %r14,	8
    jnz       L2353
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rsi+8]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_libmcl.mgenmem
    mov       %rdi,	%rax
    jmp       L2354
L2353:
    jmp       L2347
L2349:
    mov       %rax,	[%rsi+8]
    cmp       %rax,	-2147483648
    jl        L2356
    cmp       %rax,	2147483647
    jg        L2356
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rdi,	%rax
    jmp       L2354
L2356:
    jmp       L2347
L2350:
    movq      %XMM4,	[%rsi+8]
    movq      %XMM0,	%XMM4
    mov       %rdx,	2
    call      mc_libmcl.mgenrealmem
    mov       %rdi,	%rax
    jmp       L2354
L2351:
L2347:
L2346:
    mov       %rcx,	%r12
    mov       %rdx,	%r13
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    cmp       %r13,	11
    jnz       L2358
    mov       %rcx,	%rdi
    mov       %rdx,	%r14
    mov       %r8,	%r12
    call      mc_auxmcl.copyblockarg
    mov       %r13,	6
L2358:
    movzx     %rax,	word ptr[%rdi+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	5
    jnz       L2360
    mov       %rbx,	%rdi
    cmp       %r13,	4
    jnz       L2362
    mov       %rax,	5
    jmp       L2361
L2362:
    mov       %rax,	6
L2361:
    mov       %rcx,	%rax
    call      mc_stackmcl.getworkregm
    mov       %rdi,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L2360:
#mc_stackmcl.pushopnd.pushit:
L2354:
    mov       %rcx,	%rdi
    mov       %rdx,	8
    call      mc_libmcl.changeopndsize
    mov       %rcx,	12
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    inc       qword ptr[%rip+mc_decls.mstackdepth]
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.loadtoreg
mc_stackmcl.loadtoreg:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jz        L2366
    cmp       %rax,	5
    jnz       L2365
L2366:
    test      %r12,	%r12
    jz        L2369
    movzx     %rax,	byte ptr[%rbx+10]
    cmp       %rax,	%r12
    jnz       L2368
L2369:
    mov       %rax,	%rbx
    jmp       L2363
L2368:
L2365:
    mov       %rcx,	%r12
    mov       %rdx,	%rsi
    call      mc_stackmcl.getworkreg_rm
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mc_stackmcl.loadtoreg_common
    mov       %rax,	%rdi
L2363:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.loadtoreg_m
mc_stackmcl.loadtoreg_m:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jz        L2373
    cmp       %rax,	5
    jnz       L2372
L2373:
    movzx     %rax,	byte ptr[%rbx+10]
    cmp       %rax,	%r12
    jnz       L2375
    mov       %rax,	%rbx
    jmp       L2370
L2375:
L2372:
    mov       %rcx,	%r12
    mov       %rdx,	%rsi
    call      mc_libmcl.mgenreg
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mc_stackmcl.loadtoreg_common
    mov       %rax,	%rdi
L2370:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.loadtoreg_common
mc_stackmcl.loadtoreg_common:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	2
    jnz       L2378
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	12
    and       %rax,	15
    cmp       %rax,	1
    jnz       L2378
    mov       %rax,	[%rbx]
    test      %rax,	%rax
    jnz       L2378
    mov       %rcx,	%rdi
    mov       %rdx,	4
    call      mc_libmcl.changeopndsize
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    call      mc_libmcl.clearreg
    jmp       L2377
L2378:
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L2377:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.pushpcl
mc_stackmcl.pushpcl:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rax,	[%rip+mc_decls.noperands]
    cmp       %rax,	50
    jl        L2381
    lea       %rcx,	[%rip+L8244]
    lea       %rdx,	[%rip+L8245]
    call      pc_api.merror
L2381:
    inc       qword ptr[%rip+mc_decls.noperands]
    mov       %rdi,	[%rip+mc_decls.noperands]
    xor       %eax,	%eax
    lea       %r10,	[%rip+mc_decls.pclloc]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    mov       %rax,	%rbx
    lea       %r10,	[%rip+mc_decls.pclopnd]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*8-8],	%rax
    xor       %eax,	%eax
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.pclcount]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    mov       %al,	[%rbx+3]
    lea       %r10,	[%rip+mc_decls.pclmode]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    movzx     %rax,	byte ptr[%rbx+1]
    cmp       %rax,	1
    jnz       L2383
    mov       %rax,	[%rbx+8]
    mov       %al,	[%rax+90]
    test      %al,	%al
    jz        L2383
    mov       %rax,	[%rbx+8]
    mov       %al,	[%rax+90]
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    mov       %al,	2
    lea       %r10,	[%rip+mc_decls.pclloc]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
L2383:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.pushpcl_reg
mc_stackmcl.pushpcl_reg:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rax,	[%rip+mc_decls.noperands]
    cmp       %rax,	50
    jl        L2386
    lea       %rcx,	[%rip+L8246]
    lea       %rdx,	[%rip+L8247]
    call      pc_api.merror
L2386:
    test      %rsi,	%rsi
    jnz       L2388
    mov       %rcx,	%rbx
    call      mc_stackmcl.getworkreg
    mov       %rsi,	%rax
L2388:
    inc       qword ptr[%rip+mc_decls.noperands]
    mov       %rdi,	[%rip+mc_decls.noperands]
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.pclloc]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+mc_decls.pclopnd]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*8-8],	%rax
    mov       %al,	%sil
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.pclcount]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    mov       %al,	%bl
    lea       %r10,	[%rip+mc_decls.pclmode]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    cmp       %rbx,	2
    jg        L2390
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.xregset]
    mov       %r11,	%rsi
    mov       [%r10 + %r11-1],	%al
    jmp       L2389
L2390:
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.regset]
    mov       %r11,	%rsi
    mov       [%r10 + %r11-1],	%al
L2389:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.poppcl
mc_stackmcl.poppcl:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rdi,	[%rip+mc_decls.noperands]
    cmp       %rdi,	0
    jg        L2393
    lea       %rcx,	[%rip+L8248]
    lea       %rdx,	[%rip+L8249]
    call      pc_api.merror
L2393:
    lea       %rax,	[%rip+mc_decls.pclcount]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	1
    jle       L2395
    lea       %rax,	[%rip+mc_decls.pclcount]
    mov       %r10,	%rdi
    lea       %rax,	[%rax + %r10-1]
    dec       byte ptr[%rax]
    jmp       L2391
L2395:
    dec       qword ptr[%rip+mc_decls.noperands]
L2391:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.duplpcl
mc_stackmcl.duplpcl:
#?>>
    .set mc_stackmcl.duplpcl.$T1, -8
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
#---------------
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rdi,	%rax
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rdi
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      mc_stackmcl.pushpcl_reg
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       [%rbp + mc_stackmcl.duplpcl.$T1],	%rax
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rdi
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_stackmcl.duplpcl.$T1]
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.getworkireg
mc_stackmcl.getworkireg:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
    mov       %rbx,	10
L2398:
    mov       %rdi,	1
L2401:
    lea       %rax,	[%rip+mc_decls.workregs]
    mov       %r10,	%rdi
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L2405
    lea       %rax,	[%rip+mc_decls.regset]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    test      %rax,	%rax
    jnz       L2405
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.regset]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    mov       %rax,	%rdi
    jmp       L2397
L2405:
    inc       %rdi
    cmp       %rdi,	14
    jle       L2401
    call      mc_stackmcl.savenextopnd
    dec       %rbx
    jnz       L2398
    lea       %rcx,	[%rip+L8250]
    lea       %rdx,	[%rip+L8251]
    call      pc_api.merror
    xor       %eax,	%eax
L2397:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.getworkxreg
mc_stackmcl.getworkxreg:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rdi,	5
L2407:
    lea       %rax,	[%rip+mc_decls.workxregs]
    mov       %r10,	%rdi
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L2411
    lea       %rax,	[%rip+mc_decls.xregset]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    test      %rax,	%rax
    jnz       L2411
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.xregset]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    mov       %rax,	%rdi
    jmp       L2406
L2411:
    inc       %rdi
    cmp       %rdi,	16
    jle       L2407
    lea       %rcx,	[%rip+L8252]
    lea       %rdx,	[%rip+L8253]
    call      pc_api.merror
    xor       %eax,	%eax
L2406:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.getworkregm
mc_stackmcl.getworkregm:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      mc_stackmcl.getworkreg
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    call      mc_libmcl.mgenreg
L2412:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.getworkreg
mc_stackmcl.getworkreg:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    cmp       %rdi,	2
    jg        L2415
    call      mc_stackmcl.getworkxreg
    jmp       L2414
L2415:
    call      mc_stackmcl.getworkireg
L2414:
L2413:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.getworkreg_rm
mc_stackmcl.getworkreg_rm:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rax,	%rdi
    test      %rax,	%rax
    jz        L2419
    cmp       %rax,	15
    jnz       L2418
L2419:
    mov       %rcx,	%rbx
    call      mc_stackmcl.getworkregm
    jmp       L2416
L2418:
    cmp       %rbx,	2
    jle       L2423
    lea       %rax,	[%rip+mc_decls.isregvar]
    mov       %r10,	%rdi
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jnz       L2422
L2423:
    lea       %rax,	[%rip+mc_decls.isxregvar]
    mov       %r10,	%rdi
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L2421
L2422:
    mov       %rcx,	%rbx
    call      mc_stackmcl.getworkregm
    jmp       L2416
L2421:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mc_libmcl.mgenreg
L2416:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.saveopnd
mc_stackmcl.saveopnd:
#?>>
    .set mc_stackmcl.saveopnd.$T1, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	1
    jnz       L2424
L2426:
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rdi,	%rax
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rbx,	%rax
    cmp       %rbx,	2
    jle       L2428
    test      %r12,	%r12
    jnz       L2431
    mov       %rax,	%rdi
    cmp       %rax,	4
    jl        L2432
    cmp       %rax,	10
    jle       L2430
L2432:
L2431:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mc_libmcl.mgenreg
    mov       [%rbp + mc_stackmcl.saveopnd.$T1],	%rax
    mov       %rcx,	%rsi
    mov       %rdx,	%rbx
    call      mc_libmcl.mgentemp
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_stackmcl.saveopnd.$T1]
    call      mc_libmcl.genmc
L2430:
    xor       %eax,	%eax
    lea       %r10,	[%rip+mc_decls.regset]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    jmp       L2427
L2428:
    test      %r12,	%r12
    jnz       L2435
    mov       %rax,	%rdi
    cmp       %rax,	1
    jl        L2434
    cmp       %rax,	6
    jg        L2434
L2435:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mc_libmcl.mgenxreg
    mov       [%rbp + mc_stackmcl.saveopnd.$T1],	%rax
    mov       %rcx,	%rsi
    mov       %rdx,	%rbx
    call      mc_libmcl.mgentemp
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_stackmcl.saveopnd.$T1]
    call      mc_libmcl.genmc
L2434:
    xor       %eax,	%eax
    lea       %r10,	[%rip+mc_decls.xregset]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
L2427:
    mov       %al,	3
    lea       %r10,	[%rip+mc_decls.pclloc]
    mov       %r11,	%rsi
    mov       [%r10 + %r11-1],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	%rsi
    mov       [%r10 + %r11-1],	%al
L2424:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.saveopnds
mc_stackmcl.saveopnds:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    mov       %rbx,	1
    mov       %rax,	[%rip+mc_decls.noperands]
    sub       %rax,	%rsi
    mov       %rdi,	%rax
    cmp       %rdi,	1
    jl        L2439
L2437:
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      mc_stackmcl.saveopnd
    inc       %rbx
    cmp       %rbx,	%rdi
    jle       L2437
L2439:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.savenextopnd
mc_stackmcl.savenextopnd:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rdi,	1
    mov       %rax,	[%rip+mc_decls.noperands]
    cmp       %rax,	1
    jl        L2443
L2441:
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	1
    jnz       L2445
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	2
    jle       L2445
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      mc_stackmcl.saveopnd
    jmp       L2440
L2445:
    inc       %rdi
    cmp       %rdi,	[%rip+mc_decls.noperands]
    jle       L2441
L2443:
L2440:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.savenextxopnd
mc_stackmcl.savenextxopnd:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rdi,	1
    mov       %rax,	[%rip+mc_decls.noperands]
    cmp       %rax,	1
    jl        L2449
L2447:
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	1
    jnz       L2451
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	2
    jg        L2451
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      mc_stackmcl.saveopnd
    jmp       L2446
L2451:
    inc       %rdi
    cmp       %rdi,	[%rip+mc_decls.noperands]
    jle       L2447
L2449:
L2446:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.movetoreg
mc_stackmcl.movetoreg:
#?>>
    .set mc_stackmcl.movetoreg.$T1, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %r12,	%rcx
#---------------
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rbx,	%rax
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
#mc_stackmcl.movetoreg.retry:
L2453:
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rdi,	%rax
    cmp       %rdi,	%r12
    jz        L2452
L2455:
    cmp       %rbx,	2
    jg        L2457
    lea       %rax,	[%rip+mc_decls.xregset]
    mov       %r10,	%r12
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L2459
    lea       %rcx,	[%rip+L8254]
    lea       %rdx,	[%rip+L8255]
    call      pc_api.merror
L2459:
    jmp       L2456
L2457:
    lea       %rax,	[%rip+mc_decls.regset]
    mov       %r10,	%r12
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L2461
    mov       %rsi,	1
    mov       %rax,	[%rip+mc_decls.noperands]
    cmp       %rax,	1
    jl        L2464
L2462:
    cmp       %rbx,	2
    jle       L2466
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	%r12
    jnz       L2466
    mov       %rcx,	%rsi
    mov       %rdx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    mov       %rcx,	%r12
    mov       %rdx,	6
    call      mc_libmcl.mgenreg
    mov       [%rbp + mc_stackmcl.movetoreg.$T1],	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	6
    call      mc_libmcl.mgenreg
    mov       %rcx,	27
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_stackmcl.movetoreg.$T1]
    call      mc_libmcl.genmc
    jmp       L2453
L2466:
    inc       %rsi
    cmp       %rsi,	[%rip+mc_decls.noperands]
    jle       L2462
L2464:
L2461:
L2456:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mc_libmcl.mgenreg
    mov       [%rbp + mc_stackmcl.movetoreg.$T1],	%rax
    mov       %rcx,	%r12
    mov       %rdx,	%rbx
    call      mc_libmcl.mgenreg
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_stackmcl.movetoreg.$T1]
    call      mc_libmcl.genmc
    mov       %al,	%r12b
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11-1],	%al
    cmp       %rbx,	2
    jg        L2468
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.xregset]
    mov       %r11,	%r12
    mov       [%r10 + %r11-1],	%al
    jmp       L2467
L2468:
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.regset]
    mov       %r11,	%r12
    mov       [%r10 + %r11-1],	%al
L2467:
L2452:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.getopnd_ind
mc_stackmcl.getopnd_ind:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    test      %rax,	%rax
    jnz       L2471
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	%rsi
    mov       %rdi,	[%rax + %r10*8-8]
    movzx     %rax,	byte ptr[%rdi+1]
    cmp       %rax,	2
    jnz       L2473
    mov       %rbx,	[%rdi+8]
    movzx     %rax,	byte ptr[%rbx+72]
    cmp       %rax,	5
    jnz       L2476
    movzx     %rax,	byte ptr[%rbx+82]
    cmp       %rax,	11
    jz        L2475
L2476:
    mov       %rax,	[%rdi+8]
    mov       %rcx,	%rax
    mov       %rdx,	%r12
    call      mc_libmcl.mgenmem
    jmp       L2469
L2475:
L2473:
L2471:
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	1
    jz        L2478
    mov       %rcx,	%rsi
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
L2478:
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rcx,	%rax
    mov       %rdx,	%r12
    xor       %r8d,	%r8d
    call      mc_libmcl.mgenireg
L2469:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.getopnd_ind_simp
mc_stackmcl.getopnd_ind_simp:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	1
    jz        L2481
    mov       %rcx,	%rdi
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
L2481:
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rcx,	%rax
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_libmcl.mgenireg
L2479:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.swapopnds
mc_stackmcl.swapopnds:
#?>>
#?]]
#---------------
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	%rcx
    lea       %rax,	[%rax + %r10*8-8]
    lea       %r10,	[%rip+mc_decls.pclopnd]
    mov       %r11,	%rdx
    lea       %r10,	[%r10 + %r11*8-8]
    mov       %r11,	[%rax]
    mov       %r9,	[%r10]
    mov       [%r10],	%r11
    mov       [%rax],	%r9
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rcx
    lea       %rax,	[%rax + %r10-1]
    lea       %r10,	[%rip+mc_decls.pclloc]
    mov       %r11,	%rdx
    lea       %r10,	[%r10 + %r11-1]
    mov       %r11b,	[%rax]
    mov       %r9b,	[%r10]
    mov       [%r10],	%r11b
    mov       [%rax],	%r9b
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%rcx
    lea       %rax,	[%rax + %r10-1]
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	%rdx
    lea       %r10,	[%r10 + %r11-1]
    mov       %r11b,	[%rax]
    mov       %r9b,	[%r10]
    mov       [%r10],	%r11b
    mov       [%rax],	%r9b
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	%rcx
    lea       %rax,	[%rax + %r10-1]
    lea       %r10,	[%rip+mc_decls.pclmode]
    mov       %r11,	%rdx
    lea       %r10,	[%r10 + %r11-1]
    mov       %r11b,	[%rax]
    mov       %r9b,	[%r10]
    mov       [%r10],	%r11b
    mov       [%rax],	%r9b
    lea       %rax,	[%rip+mc_decls.pclcount]
    mov       %r10,	%rcx
    lea       %rax,	[%rax + %r10-1]
    lea       %r10,	[%rip+mc_decls.pclcount]
    mov       %r11,	%rdx
    lea       %r10,	[%r10 + %r11-1]
    mov       %r11b,	[%rax]
    mov       %r9b,	[%r10]
    mov       [%r10],	%r11b
    mov       [%rax],	%r9b
#---------------
    ret       
# End 
# Proc mc_stackmcl.isimmload
mc_stackmcl.isimmload:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	16
#---------------
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	%rcx
    mov       %rdi,	[%rax + %r10*8-8]
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rcx
    movzx     %rax,	byte ptr[%rax + %r10-1]
    test      %rax,	%rax
    jnz       L2485
    movzx     %rax,	byte ptr[%rdi]
    cmp       %rax,	1
    jnz       L2485
    movzx     %rax,	byte ptr[%rdi+1]
    cmp       %rax,	4
    jnz       L2485
    mov       %rax,	%rdi
    jmp       L2484
L2485:
    xor       %eax,	%eax
L2484:
L2483:
#---------------
    add       %rsp,	16
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.setnewzz
mc_stackmcl.setnewzz:
#?>>
#?]]
#---------------
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.pclloc]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11-1],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+mc_decls.pclopnd]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11*8-8],	%rax
    mov       %al,	%cl
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11-1],	%al
    mov       %al,	%dl
    lea       %r10,	[%rip+mc_decls.pclmode]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11-1],	%al
#---------------
    ret       
# End 
# Proc mc_stackmcl.freeworkregs
mc_stackmcl.freeworkregs:
#?>>
    .set mc_stackmcl.freeworkregs.p, 32
    push      %rdi
    push      %rbx
#?]]
#---------------
    lea       %rax,	[%rip+mc_decls.regset]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    lea       %rax,	[%rip+mc_decls.xregset]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    mov       %rbx,	1
    mov       %rax,	[%rip+mc_decls.noperands]
    cmp       %rax,	1
    jl        L2490
L2488:
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rdi,	%rax
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L2492
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	2
    jg        L2494
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.xregset]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    jmp       L2493
L2494:
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.regset]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
L2493:
L2492:
    inc       %rbx
    cmp       %rbx,	[%rip+mc_decls.noperands]
    jle       L2488
L2490:
#---------------
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.swapopndregs
mc_stackmcl.swapopndregs:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	2
    jg        L2497
    lea       %rcx,	[%rip+L8256]
    lea       %rdx,	[%rip+L8257]
    call      pc_api.merror
L2497:
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rdi,	%rax
    cmp       %rdi,	%rsi
    jz        L2495
L2499:
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rbx,	%rax
    cmp       %rbx,	1
    jl        L2503
L2500:
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	1
    jnz       L2505
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	%rsi
    jnz       L2505
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	[%rip+mc_decls.noperands]
    lea       %rax,	[%rax + %r10-1]
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	%rbx
    lea       %r10,	[%r10 + %r11-1]
    mov       %r11b,	[%rax]
    mov       %r9b,	[%r10]
    mov       [%r10],	%r11b
    mov       [%rax],	%r9b
    jmp       L2495
L2505:
    dec       %rbx
    cmp       %rbx,	1
    jge       L2500
L2503:
    xor       %eax,	%eax
    lea       %r10,	[%rip+mc_decls.regset]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    mov       %al,	%sil
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11-1],	%al
L2495:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.makeopndind
mc_stackmcl.makeopndind:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    movzx     %rax,	word ptr[%rdi+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jz        L2508
    lea       %rcx,	[%rip+L8258]
    lea       %rdx,	[%rip+L8259]
    call      pc_api.merror
L2508:
    movzx     %rax,	byte ptr[%rdi+10]
    mov       %rcx,	%rax
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_libmcl.mgenireg
L2506:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.makesimpleaddr
mc_stackmcl.makesimpleaddr:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
#---------------
    movzx     %rax,	byte ptr[%r13+10]
    mov       %rsi,	%rax
    movzx     %rax,	byte ptr[%r13+11]
    mov       %r12,	%rax
    cmp       %rsi,	15
    jnz       L2511
    xor       %rsi,	%rsi
L2511:
    movzx     %rax,	word ptr[%r13+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	3
    jz        L2513
    lea       %rcx,	[%rip+L8260]
    lea       %rdx,	[%rip+L8261]
    call      pc_api.merror
L2513:
    test      %rsi,	%rsi
    jnz       L2515
    test      %r12,	%r12
    jnz       L2515
    call      mc_stackmcl.getworkireg
    mov       %rbx,	%rax
    jmp       L2514
L2515:
    test      %rsi,	%rsi
    jz        L2516
    mov       %rax,	%r13
    jmp       L2509
L2516:
    test      %r12,	%r12
    jz        L2517
    mov       %rbx,	%r12
    jmp       L2514
L2517:
    mov       %rbx,	%r12
L2514:
    mov       %rcx,	%rbx
    mov       %rdx,	10
    xor       %r8d,	%r8d
    call      mc_libmcl.mgenireg
    mov       %rdi,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	14
    mov       %rdx,	%rax
    mov       %r8,	%r13
    call      mc_libmcl.genmc
    mov       %rax,	%rdi
L2509:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.checkallloaded
mc_stackmcl.checkallloaded:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rdi,	1
    mov       %rax,	[%rip+mc_decls.noperands]
    cmp       %rax,	1
    jl        L2521
L2519:
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    test      %rax,	%rax
    jnz       L2523
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    movzx     %rax,	byte ptr[%rax+1]
    cmp       %rax,	1
    jnz       L2523
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    movzx     %rax,	byte ptr[%rax+3]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
L2523:
    inc       %rdi
    cmp       %rdi,	[%rip+mc_decls.noperands]
    jle       L2519
L2521:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.stropndstack
mc_stackmcl.stropndstack:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
    lea       %rax,	[%rip+mc_stackmcl.stropndstack.str]
    mov       %rdi,	%rax
    test      %r12,	%r12
    jz        L2526
    mov       %rcx,	%rdi
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8262]
    call      msys.m$print_setfmt
    mov       %rcx,	[%rip+mc_decls.noperands]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L2525
L2526:
    mov       %rcx,	%rdi
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8263]
    call      msys.m$print_setfmt
    mov       %rcx,	[%rip+mc_decls.noperands]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
L2525:
    mov       %rbx,	1
    mov       %rax,	[%rip+mc_decls.noperands]
    cmp       %rax,	1
    jl        L2529
L2527:
    mov       %rax,	[%rip+mc_decls.noperands]
    sub       %rax,	%rbx
    inc       %rax
    sub       %rax,	1
    cmp       %rax,	4
    jae       L2532
    lea       %r10,	[%rip+L2531]
    jmp       [%r10 + %rax*8]
    .data
L2531:
    .quad     L2533
    .quad     L2534
    .quad     L2535
    .quad     L2536
    .text
L2533:
    lea       %rax,	[%rip+L8264]
    jmp       L2530
L2534:
    lea       %rax,	[%rip+L8265]
    jmp       L2530
L2535:
    lea       %rax,	[%rip+L8266]
    jmp       L2530
L2536:
    lea       %rax,	[%rip+L8267]
    jmp       L2530
L2532:
    lea       %rax,	[%rip+L8268]
L2530:
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      strcat
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	1
    jz        L2538
    cmp       %rax,	2
    jz        L2538
    cmp       %rax,	3
    jz        L2539
    jmp       L2540
L2538:
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	2
    jg        L2542
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10-1]
    lea       %r10,	[%rip+mc_decls.xregnames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%rdi
    mov       %rdx,	%r10
    call      strcat
    jmp       L2541
L2542:
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10-1]
    lea       %r10,	[%rip+mc_decls.regnames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%rdi
    mov       %rdx,	%r10
    call      strcat
L2541:
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	2
    jnz       L2544
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8269]
    call      strcat
L2544:
    jmp       L2537
L2539:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8270]
    call      strcat
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      msys.strint
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      strcat
    jmp       L2537
L2540:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8271]
    call      strcat
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8272]
    call      strcat
L2537:
    lea       %rax,	[%rip+mc_decls.pclcount]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	1
    jle       L2546
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8273]
    call      strcat
L2546:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8274]
    call      strcat
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10-1]
    lea       %r10,	[%rip+pc_tables.pstdnames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%rdi
    mov       %rdx,	%r10
    call      strcat
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8275]
    call      strcat
    cmp       %rbx,	[%rip+mc_decls.noperands]
    jge       L2548
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8276]
    call      strcat
L2548:
    inc       %rbx
    cmp       %rbx,	[%rip+mc_decls.noperands]
    jle       L2527
L2529:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8277]
    call      strcat
    lea       %rcx,	[%rip+mc_stackmcl.stropndstack.str]
    mov       %rdx,	50
    lea       %r8,	[%rip+L8278]
    call      mlib.ipadstr
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8279]
    call      strcat
    mov       %rsi,	1
L2549:
    lea       %rax,	[%rip+mc_decls.regset]
    mov       %r10,	%rsi
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L2553
    lea       %rax,	[%rip+L8280]
    jmp       L2552
L2553:
    lea       %rax,	[%rip+L8281]
L2552:
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      strcat
    inc       %rsi
    cmp       %rsi,	10
    jle       L2549
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8282]
    call      strcat
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8283]
    call      strcat
    mov       %rsi,	1
    mov       %rax,	[%rip+mc_decls.xregmax]
    cmp       %rax,	1
    jl        L2556
L2554:
    lea       %rax,	[%rip+mc_decls.xregset]
    mov       %r10,	%rsi
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L2558
    lea       %rax,	[%rip+L8284]
    jmp       L2557
L2558:
    lea       %rax,	[%rip+L8285]
L2557:
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      strcat
    inc       %rsi
    cmp       %rsi,	[%rip+mc_decls.xregmax]
    jle       L2554
L2556:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8286]
    call      strcat
    mov       %rcx,	[%rip+mc_decls.mstackdepth]
    xor       %edx,	%edx
    call      msys.strint
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      strcat
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8287]
    call      strcat
    mov       %rcx,	[%rip+mc_decls.noperands]
    xor       %edx,	%edx
    call      msys.strint
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      strcat
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8288]
    call      strcat
    mov       %rcx,	[%rip+mc_decls.ncalldepth]
    xor       %edx,	%edx
    call      msys.strint
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      strcat
    mov       %rax,	%rdi
L2524:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.showopndstack
mc_stackmcl.showopndstack:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    mov       %rcx,	1
    call      mc_stackmcl.stropndstack
    mov       %rcx,	%rax
    call      mc_libmcl.mgencomment
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_optim.peephole
mc_optim.peephole:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
    mov       %al,	[%rip+pc_decls.fpeephole]
    test      %al,	%al
    jz        L2560
L2562:
    mov       %rax,	[%rip+mc_decls.mccode]
    mov       %rdi,	[%rax+8]
    jmp       L2566
L2563:
    mov       %rbx,	[%rdi+8]
    mov       %rsi,	[%rbx+8]
    movzx     %rax,	byte ptr[%rdi+33]
    cmp       %rax,	8
    jz        L2568
    cmp       %rax,	11
    jz        L2569
    cmp       %rax,	38
    jz        L2570
    cmp       %rax,	40
    jz        L2571
    cmp       %rax,	26
    jz        L2572
    jmp       L2573
L2568:
    jmp       L2565
L2569:
    movzx     %rax,	byte ptr[%rbx+33]
    cmp       %rax,	11
    jz        L2575
    cmp       %rax,	41
    jz        L2576
    cmp       %rax,	42
    jz        L2577
    cmp       %rax,	28
    jz        L2578
    cmp       %rax,	29
    jz        L2578
    cmp       %rax,	52
    jz        L2579
    cmp       %rax,	53
    jz        L2579
    cmp       %rax,	25
    jz        L2580
    jmp       L2581
L2575:
    mov       %rax,	[%rdi+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg0
    test      %rax,	%rax
    jz        L2583
    mov       %rax,	[%rdi+16]
    mov       %r10,	[%rbx+24]
    cmp       %rax,	%r10
    jnz       L2583
    mov       %rcx,	%rbx
    call      mc_optim.endr0
    test      %rax,	%rax
    jz        L2583
    mov       %rax,	[%rbx+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg10
    test      %rax,	%rax
    jnz       L2584
L2585:
    mov       %rax,	[%rbx+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg
    test      %rax,	%rax
    jnz       L2587
    mov       %rax,	[%rdi+24]
    mov       %rcx,	%rax
    call      mc_optim.isreg
    test      %rax,	%rax
    jz        L2586
L2587:
    mov       %rax,	[%rbx+16]
    mov       [%rdi+16],	%rax
    mov       %rcx,	%rbx
    call      mc_optim.deletemcl
L2586:
L2584:
    jmp       L2582
L2583:
    mov       %rax,	[%rdi+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg0
    test      %rax,	%rax
    jz        L2588
    mov       %rax,	[%rdi+16]
    mov       %r10,	[%rbx+24]
    cmp       %rax,	%r10
    jnz       L2588
    mov       %rax,	[%rbx+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg10
    test      %rax,	%rax
    jz        L2588
    movzx     %rax,	byte ptr[%rsi+33]
    cmp       %rax,	21
    jnz       L2588
    mov       %rcx,	%rsi
    call      mc_optim.endr0
    test      %rax,	%rax
    jz        L2588
    mov       %rax,	[%rbx+16]
    mov       [%rdi+16],	%rax
    mov       %rcx,	%rbx
    call      mc_optim.deletemcl
L2588:
L2582:
    jmp       L2574
L2576:
    mov       %rax,	[%rdi+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg0
    test      %rax,	%rax
    jz        L2590
    mov       %rax,	[%rdi+16]
    mov       %r10,	[%rbx+16]
    cmp       %r10,	%rax
    jnz       L2591
    mov       %rax,	[%rbx+24]
    cmp       %r10,	%rax
    jnz       L2591
    mov       %rax,	1
    jmp       L2592
L2591:
    xor       %eax,	%eax
L2592:
    test      %rax,	%rax
    setnz     %al
    movzx     %eax,	%al
    test      %ax,	%ax
    jz        L2590
    mov       %rax,	[%rdi+24]
    mov       %rcx,	%rax
    call      mc_optim.isreg
    test      %rax,	%rax
    jz        L2590
    mov       %rcx,	%rsi
    call      mc_optim.endr0
    test      %rax,	%rax
    jz        L2590
    mov       %al,	41
    mov       [%rdi+33],	%al
    mov       %rax,	[%rdi+24]
    mov       [%rdi+16],	%rax
    mov       %rcx,	%rbx
    call      mc_optim.deletemcl
    mov       %rdi,	%rax
L2590:
    jmp       L2574
L2577:
    mov       %rax,	[%rdi+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg0
    test      %rax,	%rax
    jz        L2594
    mov       %rax,	[%rdi+16]
    mov       %r10,	[%rbx+16]
    cmp       %rax,	%r10
    jnz       L2594
    mov       %rax,	[%rdi+24]
    mov       %rcx,	%rax
    call      mc_optim.isreg
    test      %rax,	%rax
    jz        L2594
    mov       %rcx,	%rsi
    call      mc_optim.endr0
    test      %rax,	%rax
    jz        L2594
    mov       %al,	42
    mov       [%rdi+33],	%al
    mov       %rax,	[%rdi+24]
    mov       [%rdi+16],	%rax
    mov       %rax,	[%rbx+24]
    mov       [%rdi+24],	%rax
    mov       %rcx,	%rbx
    call      mc_optim.deletemcl
L2594:
    jmp       L2574
L2578:
    mov       %rax,	[%rdi+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg
    test      %rax,	%rax
    jz        L2596
    mov       %rax,	[%rdi+16]
    mov       %r10,	[%rbx+16]
    cmp       %rax,	%r10
    jnz       L2596
    mov       %rax,	[%rdi+24]
    mov       %rcx,	%rax
    call      mc_optim.isreg
    test      %rax,	%rax
    jz        L2596
    mov       %rax,	[%rbx+24]
    mov       %rcx,	%rax
    call      mc_optim.isconst
    test      %rax,	%rax
    jz        L2596
    mov       %al,	14
    mov       [%rdi+33],	%al
    sub       %rsp,	8
    push      0
    push      0
    push      0
    movzx     %rax,	byte ptr[%rbx+33]
    cmp       %rax,	28
    jnz       L2598
    mov       %rax,	[%rbx+24]
    mov       %rax,	[%rax]
    jmp       L2597
L2598:
    mov       %rax,	[%rbx+24]
    mov       %rax,	[%rax]
    neg       %rax
L2597:
    mov       %r10,	[%rdi+24]
    movzx     %r10,	byte ptr[%r10+10]
    mov       %rcx,	%r10
    xor       %edx,	%edx
    mov       %r8,	1
    mov       %r9,	%rax
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       [%rdi+24],	%rax
    mov       %rcx,	%rbx
    call      mc_optim.deletemcl
L2596:
    jmp       L2574
L2579:
    mov       %rax,	[%rdi+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg
    test      %rax,	%rax
    jz        L2600
    mov       %rax,	[%rdi+16]
    mov       %r10,	[%rbx+16]
    cmp       %rax,	%r10
    jnz       L2600
    mov       %rax,	[%rdi+24]
    mov       %rcx,	%rax
    call      mc_optim.isreg
    test      %rax,	%rax
    jz        L2600
    mov       %al,	14
    mov       [%rdi+33],	%al
    sub       %rsp,	8
    push      0
    push      0
    push      0
    movzx     %rax,	byte ptr[%rbx+33]
    cmp       %rax,	52
    jnz       L2602
    mov       %rax,	1
    jmp       L2601
L2602:
    mov       %rax,	-1
L2601:
    mov       %r10,	[%rdi+24]
    movzx     %r10,	byte ptr[%r10+10]
    mov       %rcx,	%r10
    xor       %edx,	%edx
    mov       %r8,	1
    mov       %r9,	%rax
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       [%rdi+24],	%rax
    mov       %rcx,	%rbx
    call      mc_optim.deletemcl
L2600:
    jmp       L2574
L2580:
    mov       %rax,	[%rdi+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg0
    test      %rax,	%rax
    jz        L2604
    mov       %rax,	[%rbx+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg0
    test      %rax,	%rax
    jz        L2604
    mov       %al,	25
    mov       [%rdi+33],	%al
    mov       %rax,	[%rdi+24]
    mov       [%rdi+16],	%rax
    xor       %eax,	%eax
    mov       [%rdi+24],	%rax
    mov       %rcx,	%rbx
    call      mc_optim.deletemcl
L2604:
L2581:
L2574:
    jmp       L2567
L2570:
    movzx     %rax,	byte ptr[%rbx+33]
    cmp       %rax,	41
    jnz       L2606
    mov       %rax,	[%rdi+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg0
    test      %rax,	%rax
    jz        L2608
    mov       %rax,	[%rdi+16]
    mov       %r10,	[%rbx+16]
    cmp       %r10,	%rax
    jnz       L2609
    mov       %rax,	[%rbx+24]
    cmp       %r10,	%rax
    jnz       L2609
    mov       %rax,	1
    jmp       L2610
L2609:
    xor       %eax,	%eax
L2610:
    test      %rax,	%rax
    setnz     %al
    movzx     %eax,	%al
    test      %ax,	%ax
    jz        L2608
    mov       %rcx,	%rsi
    call      mc_optim.endr0
    test      %rax,	%rax
    jz        L2608
    mov       %rcx,	%rbx
    call      mc_optim.deletemcl
    mov       %rdi,	%rax
L2608:
L2606:
    jmp       L2567
L2571:
    movzx     %rax,	byte ptr[%rbx+33]
    cmp       %rax,	11
    jnz       L2612
    mov       %rax,	[%rdi+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg0
    test      %rax,	%rax
    jz        L2614
    mov       %rax,	[%rdi+16]
    mov       %r10,	[%rdi+24]
    cmp       %rax,	%r10
    jnz       L2614
    mov       %rax,	[%rbx+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg
    test      %rax,	%rax
    jz        L2614
    mov       %rax,	[%rbx+24]
    mov       %rcx,	%rax
    call      mc_optim.isreg0
    test      %rax,	%rax
    jz        L2614
    mov       %rcx,	%rbx
    call      mc_optim.endr0
    test      %rax,	%rax
    jz        L2614
    mov       %rax,	[%rbx+16]
    mov       [%rdi+24],	%rax
    mov       [%rdi+16],	%rax
    mov       %rcx,	%rbx
    call      mc_optim.deletemcl
    mov       %rdi,	%rax
L2614:
L2612:
    jmp       L2567
L2572:
    movzx     %rax,	byte ptr[%rbx+33]
    cmp       %rax,	25
    jnz       L2616
    movzx     %rax,	byte ptr[%rsi+33]
    cmp       %rax,	9
    jnz       L2616
    mov       %rax,	[%rdi+16]
    mov       %rax,	[%rax]
    mov       %r10,	[%rsi+16]
    mov       %r10,	[%r10]
    cmp       %rax,	%r10
    jnz       L2616
    mov       %rcx,	%rdi
    call      mc_optim.endr0
    test      %rax,	%rax
    jz        L2616
    movzx     %rax,	byte ptr[%rdi+34]
    lea       %r10,	[%rip+mc_decls.asmrevcond]
    mov       %r10,	[%r10 + %rax*8]
    mov       [%rdi+34],	%r10b
    mov       %rax,	[%rbx+16]
    mov       [%rdi+16],	%rax
    mov       %rcx,	%rbx
    call      mc_optim.deletemcl
    mov       %rdi,	%rax
L2616:
L2573:
L2567:
    mov       %rdi,	[%rdi+8]
L2566:
    test      %rdi,	%rdi
    jnz       L2563
L2565:
L2560:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_optim.isreg
mc_optim.isreg:
#?>>
#?]]
#---------------
    movzx     %rax,	word ptr[%rcx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    setz      %al
    movzx     %eax,	%al
L2617:
#---------------
    ret       
# End 
# Proc mc_optim.isreg0
mc_optim.isreg0:
#?>>
#?]]
#---------------
    test      %rcx,	%rcx
    jnz       L2620
    xor       %eax,	%eax
    jmp       L2618
L2620:
    movzx     %rax,	word ptr[%rcx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jnz       L2622
    movzx     %rax,	byte ptr[%rcx+10]
    cmp       %rax,	1
    jnz       L2622
    mov       %rax,	1
    jmp       L2618
L2622:
    xor       %eax,	%eax
L2618:
#---------------
    ret       
# End 
# Proc mc_optim.isreg10
mc_optim.isreg10:
#?>>
#?]]
#---------------
    test      %rcx,	%rcx
    jnz       L2625
    xor       %eax,	%eax
    jmp       L2623
L2625:
    movzx     %rax,	word ptr[%rcx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jnz       L2627
    movzx     %rax,	byte ptr[%rcx+10]
    cmp       %rax,	11
    jnz       L2627
    mov       %rax,	1
    jmp       L2623
L2627:
    xor       %eax,	%eax
L2623:
#---------------
    ret       
# End 
# Proc mc_optim.isreg00
mc_optim.isreg00:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	[%rdi+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg
    test      %rax,	%rax
    jz        L2630
    mov       %rax,	[%rdi+16]
    mov       %r10,	[%rdi+24]
    cmp       %rax,	%r10
    jnz       L2630
    mov       %rax,	1
    jmp       L2628
L2630:
    xor       %eax,	%eax
L2628:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_optim.isconst
mc_optim.isconst:
#?>>
#?]]
#---------------
    test      %rcx,	%rcx
    jnz       L2633
    xor       %eax,	%eax
    jmp       L2631
L2633:
    movzx     %rax,	word ptr[%rcx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	2
    jnz       L2635
    movzx     %rax,	word ptr[%rcx+8]
    shr       %rax,	12
    and       %rax,	15
    cmp       %rax,	1
    jnz       L2635
    mov       %rax,	1
    jmp       L2631
L2635:
    xor       %eax,	%eax
L2631:
#---------------
    ret       
# End 
# Proc mc_optim.sameoperand
mc_optim.sameoperand:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	16
    call      memcmp
    movsxd    %r10,	%eax
    cmp       %r10,	0
    setz      %r10b
    movzx     %r10d,	%r10b
    mov       %rax,	%r10
L2636:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_optim.sameregopnd
mc_optim.sameregopnd:
#?>>
#?]]
#---------------
    movzx     %rax,	word ptr[%rcx+8]
    shr       %rax,	9
    and       %rax,	7
    movzx     %r10,	word ptr[%rdx+8]
    shr       %r10,	9
    and       %r10,	7
    cmp       %r10,	%rax
    jnz       L2640
    cmp       %r10,	1
    jz        L2639
L2640:
    xor       %eax,	%eax
    jmp       L2637
L2639:
    movzx     %rax,	byte ptr[%rcx+10]
    movzx     %r10,	byte ptr[%rdx+10]
    cmp       %rax,	%r10
    setz      %al
    movzx     %eax,	%al
L2637:
#---------------
    ret       
# End 
# Proc mc_optim.deletemcl
mc_optim.deletemcl:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    mov       %rdi,	[%rsi]
    mov       %rbx,	[%rsi+8]
    test      %rdi,	%rdi
    jz        L2644
    test      %rbx,	%rbx
    jnz       L2643
L2644:
    lea       %rcx,	[%rip+L8289]
    lea       %rdx,	[%rip+L8290]
    call      pc_api.merror
L2643:
    mov       [%rdi+8],	%rbx
    mov       [%rbx],	%rdi
    mov       %rax,	%rbx
L2641:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_optim.endr0
mc_optim.endr0:
#?>>
#?]]
#---------------
    lea       %rax,	[%rcx+48]
    movzx     %rax,	byte ptr[%rax]
L2645:
#---------------
    ret       
# End 
# Proc mc_genss_dummy.genss
mc_genss_dummy.genss:
#?>>
    .set mc_genss_dummy.genss.obj, 16
#?]]
#---------------
#---
#---------------
    ret       
# End 
# Proc mc_decls.start
mc_decls.start:
#?>>
    push      %rdi
    push      %rbx
#?]]
#---------------
    xor       %rbx,	%rbx
    mov       %rax,	13
    mov       %rdi,	%rax
    cmp       %rdi,	0
    jl        L2650
L2648:
    mov       %al,	10
    lea       %r10,	[%rip+mc_decls.ploadop]
    mov       %r11,	%rbx
    mov       [%r10 + %r11],	%al
    inc       %rbx
    cmp       %rbx,	%rdi
    jle       L2648
L2650:
    mov       %al,	19
    lea       %r10,	[%rip+mc_decls.ploadop]
    mov       [%r10+5],	%al
    lea       %r10,	[%rip+mc_decls.ploadop]
    mov       [%r10+4],	%al
    lea       %r10,	[%rip+mc_decls.ploadop]
    mov       [%r10+3],	%al
    mov       %al,	18
    lea       %r10,	[%rip+mc_decls.ploadop]
    mov       [%r10+9],	%al
    lea       %r10,	[%rip+mc_decls.ploadop]
    mov       [%r10+8],	%al
    lea       %r10,	[%rip+mc_decls.ploadop]
    mov       [%r10+7],	%al
    mov       %al,	16
    lea       %r10,	[%rip+mc_decls.ploadop]
    mov       [%r10+1],	%al
    mov       %al,	17
    lea       %r10,	[%rip+mc_decls.ploadop]
    mov       [%r10+2],	%al
    mov       %al,	11
    lea       %r10,	[%rip+mc_decls.ploadop]
    mov       [%r10+10],	%al
    lea       %r10,	[%rip+mc_decls.ploadop]
    mov       [%r10+6],	%al
#---------------
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writegas.getassemstr
mc_writegas.getassemstr:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
#---------------
    mov       %rcx,	[%rip+pc_decls.pdest]
    call      mlib.gs_init
    lea       %rcx,	[%rip+L8291]
    call      mc_writegas.asmstr
    lea       %rcx,	[%rip+L8292]
    call      mc_writegas.asmstr
    lea       %rcx,	[%rip+L8293]
    call      mc_writegas.asmstr
    mov       %rdi,	[%rip+pc_decls.psymboltable]
    jmp       L2655
L2652:
    mov       %al,	[%rdi+81]
    test      %al,	%al
    jz        L2657
    lea       %rcx,	[%rip+L8294]
    call      mc_writegas.asmstr
    mov       %rax,	[%rdi]
    mov       %rcx,	%rax
    call      pc_api.getbasename
    mov       %rcx,	%rax
    call      mc_writegas.asmstr
    lea       %rcx,	[%rip+L8295]
    call      mc_writegas.asmstr
L2657:
    mov       %rdi,	[%rdi+8]
L2655:
    test      %rdi,	%rdi
    jnz       L2652
    lea       %rcx,	[%rip+L8295]
    call      mc_writegas.asmstr
    mov       %rbx,	[%rip+mc_decls.mccode]
    mov       %rsi,	1
    jmp       L2659
L2658:
    mov       %rcx,	%rsi
    mov       %rdx,	%rbx
    call      mc_writegas.writemcl
    inc       %rsi
    mov       %rbx,	[%rbx+8]
L2659:
    test      %rbx,	%rbx
    jnz       L2658
    mov       %r12b,	1
    mov       %rdi,	[%rip+pc_decls.psymboltable]
    jmp       L2664
L2661:
    movzx     %rax,	byte ptr[%rdi+104]
    shr       %eax,	2
    and       %eax,	1
    test      %rax,	%rax
    jz        L2666
    test      %r12b,	%r12b
    jz        L2668
    xor       %r12b,	%r12b
    lea       %rcx,	[%rip+L8296]
    call      mc_writegas.asmstr
L2668:
    lea       %rcx,	[%rip+L8297]
    call      mc_writegas.asmstr
    mov       %rcx,	[%rdi]
    call      mc_writegas.asmstr
    lea       %rcx,	[%rip+L8298]
    call      mc_writegas.asmstr
L2666:
    mov       %rdi,	[%rdi+8]
L2664:
    test      %rdi,	%rdi
    jnz       L2661
    lea       %rcx,	[%rip+L8299]
    call      mc_writegas.asmstr
    mov       %rax,	[%rip+pc_decls.pdest]
L2651:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writegas.writemcl
mc_writegas.writemcl:
#?>>
    .set mc_writegas.writemcl.index, 24
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rdx
#---------------
    movzx     %rax,	byte ptr[%rdi+33]
    cmp       %rax,	6
    jnz       L2672
L2671:
    jmp       L2670
L2672:
    mov       %rcx,	%rdi
    call      mc_writegas.strmcl
    mov       %rcx,	[%rip+pc_decls.pdest]
    call      mlib.gs_line
L2670:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_writegas.start
mc_writegas.start:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	16
#---------------
    mov       %rax,	5456199
    mov       [%rip+pc_decls.assemtype],	%rax
    mov       %rsi,	1
L2674:
    mov       %rax,	%rsi
    cmp       %rax,	1
    jz        L2679
    cmp       %rax,	2
    jz        L2679
    cmp       %rax,	4
    jz        L2679
    cmp       %rax,	8
    jnz       L2678
L2679:
    mov       %r12,	1
L2680:
    xor       %dil,	%dil
    mov       %rax,	1
    mov       %r13,	%rax
    mov       %rbx,	137
    cmp       %rbx,	1
    jl        L2685
L2683:
    test      %dil,	%dil
    jz        L2687
    lea       %rax,	[%rip+mc_decls.regsizes]
    mov       %r10,	%r13
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	%rsi
    jnz       L2689
    lea       %rax,	[%rip+mc_decls.regindices]
    mov       %r10,	%r13
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	%r12
    jnz       L2689
    lea       %rax,	[%rip+mc_decls.dregnames]
    mov       %r10,	%r13
    mov       %rax,	[%rax + %r10*8-8]
    lea       %r10,	[%rip+mc_writegas.nregnames]
    mov       %r11,	%rsi
    shl       %r11,	7
    lea       %r10,	[%r10 + %r11-128]
    mov       %r11,	%r12
    mov       [%r10 + %r11*8-8],	%rax
L2689:
    jmp       L2686
L2687:
    lea       %rax,	[%rip+mc_decls.regsizes]
    mov       %r10,	%r13
    movzx     %rax,	byte ptr[%rax + %r10-1]
    test      %rax,	%rax
    jnz       L2690
    mov       %dil,	1
L2690:
L2686:
    inc       %r13
    cmp       %r13,	%rbx
    jle       L2683
L2685:
    inc       %r12
    cmp       %r12,	16
    jle       L2680
L2678:
    inc       %rsi
    cmp       %rsi,	8
    jle       L2674
#---------------
    add       %rsp,	16
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writegas.strmcl
mc_writegas.strmcl:
#?>>
    .set mc_writegas.strmcl.mcl, 72
    .set mc_writegas.strmcl.opcname, -128
    .set mc_writegas.strmcl.$T1, -136
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	168
    mov       [%rbp+72],	%rcx
#---------------
    mov       %rax,	[%rbp + mc_writegas.strmcl.mcl]
    movzx     %rax,	byte ptr[%rax+33]
    mov       %rsi,	%rax
    mov       %rax,	[%rbp + mc_writegas.strmcl.mcl]
    movzx     %rax,	byte ptr[%rax+34]
    mov       %r12,	%rax
    mov       %rax,	[%rbp + mc_writegas.strmcl.mcl]
    mov       %rdi,	[%rax+16]
    mov       %rax,	[%rbp + mc_writegas.strmcl.mcl]
    mov       %rbx,	[%rax+24]
    xor       %r14,	%r14
    mov       %rax,	%rsi
    cmp       %rax,	1
    jz        L2693
    cmp       %rax,	2
    jz        L2694
    cmp       %rax,	3
    jz        L2695
    cmp       %rax,	4
    jz        L2696
    cmp       %rax,	9
    jz        L2697
    cmp       %rax,	5
    jz        L2698
    cmp       %rax,	123
    jz        L2699
    cmp       %rax,	121
    jz        L2700
    cmp       %rax,	122
    jz        L2701
    jmp       L2702
L2693:
    lea       %rcx,	[%rip+L8300]
    call      mc_writegas.asmstr
    mov       %rax,	[%rdi]
    mov       %rcx,	[%rax]
    call      mc_writegas.asmstr
    mov       %rax,	[%rdi]
    mov       [%rip+mc_decls.currasmproc],	%rax
    jmp       L2691
L2694:
    lea       %rcx,	[%rip+L8301]
    call      mc_writegas.asmstr
    xor       %eax,	%eax
    mov       [%rip+mc_decls.currasmproc],	%rax
    jmp       L2691
L2695:
    mov       %rcx,	8227
    call      mc_writegas.asmchar
    mov       %rcx,	[%rdi]
    call      mc_writegas.asmstr
    jmp       L2691
L2696:
    mov       %r15,	[%rdi]
    movzx     %rax,	word ptr[%rdi+8]
    shr       %rax,	12
    and       %rax,	15
    cmp       %rax,	5
    jz        L2704
    cmp       %rax,	4
    jz        L2705
    jmp       L2706
L2704:
    mov       %rcx,	%r15
    call      mc_writegas.getdispname
    mov       %rcx,	%rax
    call      mc_writegas.asmstr
    jmp       L2703
L2705:
    mov       %rcx,	[%rdi]
    call      mc_writegas.asmstr
    jmp       L2691
L2706:
    lea       %rcx,	[%rip+L8302]
    lea       %rdx,	[%rip+L8303]
    call      pc_api.merror
L2703:
    lea       %rcx,	[%rip+L8304]
    call      mc_writegas.asmstr
    mov       %al,	[%r15+81]
    test      %al,	%al
    jz        L2708
    mov       %rax,	[%r15]
    mov       [%rbp + mc_writegas.strmcl.$T1],	%rax
    mov       %rax,	[%r15]
    mov       %rcx,	%rax
    call      pc_api.getbasename
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_writegas.strmcl.$T1]
    call      mlib.eqstring
    test      %rax,	%rax
    jnz       L2709
L2710:
    lea       %rcx,	[%rip+L8305]
    call      mc_writegas.asmstr
    mov       %rax,	[%r15]
    mov       %rcx,	%rax
    call      pc_api.getbasename
    mov       %rcx,	%rax
    call      mc_writegas.asmstr
    lea       %rcx,	[%rip+L8306]
    call      mc_writegas.asmstr
L2709:
L2708:
    jmp       L2691
L2697:
    movzx     %rax,	word ptr[%rdi+8]
    shr       %rax,	12
    and       %rax,	15
    cmp       %rax,	6
    jnz       L2712
    lea       %rcx,	[%rip+mc_writegas.strmcl.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8307]
    call      msys.m$print_setfmt
    mov       %rcx,	[%rdi]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L2711
L2712:
    jmp       L2696
L2711:
    lea       %rcx,	[%rip+mc_writegas.strmcl.str]
    call      mc_writegas.asmstr
    jmp       L2691
L2698:
    lea       %rcx,	[%rip+L8308]
    call      mc_writegas.asmstr
    mov       %rcx,	[%rdi]
    call      mc_writegas.asmstr
    lea       %rcx,	[%rip+L8309]
    call      mc_writegas.asmstr
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    xor       %r8d,	%r8d
    call      mc_writegas.asmopnd
    jmp       L2691
    jmp       L2692
L2699:
    lea       %rcx,	[%rip+L8310]
    call      mc_writegas.asmstr
    mov       %al,	1
    mov       [%rip+mc_writegas.currseg],	%al
    jmp       L2691
L2700:
    lea       %rcx,	[%rip+L8311]
    call      mc_writegas.asmstr
    mov       %al,	2
    mov       [%rip+mc_writegas.currseg],	%al
    jmp       L2691
L2701:
    lea       %rcx,	[%rip+L8312]
    call      mc_writegas.asmstr
    mov       %al,	3
    mov       [%rip+mc_writegas.currseg],	%al
    jmp       L2691
L2702:
L2692:
    mov       %rax,	%rsi
    cmp       %rax,	26
    jz        L2714
    cmp       %rax,	58
    jz        L2715
    cmp       %rax,	15
    jz        L2716
    cmp       %rax,	38
    jz        L2717
    cmp       %rax,	39
    jz        L2718
    cmp       %rax,	40
    jz        L2719
    cmp       %rax,	51
    jz        L2720
    cmp       %rax,	34
    jz        L2721
    cmp       %rax,	19
    jz        L2722
    cmp       %rax,	18
    jz        L2723
    cmp       %rax,	16
    jz        L2724
    cmp       %rax,	11
    jz        L2725
    cmp       %rax,	124
    jz        L2726
    cmp       %rax,	125
    jz        L2727
    cmp       %rax,	116
    jz        L2728
    cmp       %rax,	117
    jz        L2729
    cmp       %rax,	118
    jz        L2730
    cmp       %rax,	119
    jz        L2731
    cmp       %rax,	120
    jz        L2732
    cmp       %rax,	8
    jz        L2733
    jmp       L2734
L2714:
    lea       %rcx,	[%rbp + mc_writegas.strmcl.opcname]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8313]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rax,	[%rip+mc_decls.asmcondnames]
    mov       %r10,	%r12
    mov       %rcx,	[%rax + %r10*8]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L2713
L2715:
    lea       %rcx,	[%rbp + mc_writegas.strmcl.opcname]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8314]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rax,	[%rip+mc_decls.asmcondnames]
    mov       %r10,	%r12
    mov       %rcx,	[%rax + %r10*8]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L2713
L2716:
    lea       %rcx,	[%rbp + mc_writegas.strmcl.opcname]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8315]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rax,	[%rip+mc_decls.asmcondnames]
    mov       %r10,	%r12
    mov       %rcx,	[%rax + %r10*8]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L2713
L2717:
    lea       %rcx,	[%rbp + mc_writegas.strmcl.opcname]
    lea       %rdx,	[%rip+L8316]
    call      strcpy
    jmp       L2713
L2718:
    lea       %rcx,	[%rbp + mc_writegas.strmcl.opcname]
    lea       %rdx,	[%rip+L8317]
    call      strcpy
    jmp       L2713
L2719:
    lea       %rcx,	[%rbp + mc_writegas.strmcl.opcname]
    lea       %rdx,	[%rip+L8318]
    call      strcpy
    jmp       L2713
L2720:
    lea       %rcx,	[%rbp + mc_writegas.strmcl.opcname]
    lea       %rdx,	[%rip+L8319]
    call      strcpy
    jmp       L2713
L2721:
    lea       %rcx,	[%rbp + mc_writegas.strmcl.opcname]
    lea       %rdx,	[%rip+L8320]
    call      strcpy
    jmp       L2713
L2722:
    movzx     %rax,	word ptr[%rdi+8]
    and       %rax,	31
    cmp       %rax,	8
    jnz       L2736
    movzx     %rax,	word ptr[%rbx+8]
    and       %rax,	31
    cmp       %rax,	4
    jnz       L2736
    mov       %rcx,	%rdi
    mov       %rdx,	4
    call      mc_libmcl.changeopndsize
    mov       %rdi,	%rax
    mov       %r10,	[%rbp + mc_writegas.strmcl.mcl]
    mov       [%r10+16],	%rax
    mov       %rsi,	11
L2736:
    jmp       L2734
    jmp       L2713
L2723:
    movzx     %rax,	word ptr[%rdi+8]
    and       %rax,	31
    cmp       %rax,	8
    jnz       L2738
    movzx     %rax,	word ptr[%rbx+8]
    and       %rax,	31
    cmp       %rax,	4
    jnz       L2738
    lea       %rcx,	[%rbp + mc_writegas.strmcl.opcname]
    lea       %rdx,	[%rip+L8321]
    call      strcpy
    jmp       L2737
L2738:
    jmp       L2734
L2737:
    jmp       L2713
L2724:
    movzx     %rax,	word ptr[%rdi+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	5
    jnz       L2740
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	5
    jnz       L2740
    mov       %rsi,	17
L2740:
    jmp       L2734
    jmp       L2713
L2725:
    movzx     %rax,	word ptr[%rdi+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jnz       L2742
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	2
    jnz       L2742
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	12
    and       %rax,	15
    cmp       %rax,	1
    jnz       L2742
    mov       %rax,	[%rbx]
    cmp       %rax,	-2147483648
    jl        L2743
    cmp       %rax,	2147483647
    jle       L2742
L2743:
    mov       %al,	17
    mov       %r10,	[%rbp + mc_writegas.strmcl.mcl]
    mov       [%r10+33],	%al
L2742:
    jmp       L2734
    jmp       L2713
L2726:
    lea       %rcx,	[%rbp + mc_writegas.strmcl.opcname]
    lea       %rdx,	[%rip+L8322]
    call      strcpy
    jmp       L2713
L2727:
    lea       %rcx,	[%rbp + mc_writegas.strmcl.opcname]
    lea       %rdx,	[%rip+L8323]
    call      strcpy
    jmp       L2713
L2728:
    lea       %rcx,	[%rbp + mc_writegas.strmcl.opcname]
    lea       %rdx,	[%rip+L8324]
    call      strcpy
    jmp       L2713
L2729:
    lea       %rcx,	[%rbp + mc_writegas.strmcl.opcname]
    lea       %rdx,	[%rip+L8325]
    call      strcpy
    jmp       L2713
L2730:
    lea       %rcx,	[%rbp + mc_writegas.strmcl.opcname]
    lea       %rdx,	[%rip+L8326]
    call      strcpy
    jmp       L2713
L2731:
    lea       %rcx,	[%rbp + mc_writegas.strmcl.opcname]
    lea       %rdx,	[%rip+L8327]
    call      strcpy
    jmp       L2713
L2732:
    lea       %rcx,	[%rbp + mc_writegas.strmcl.opcname]
    lea       %rdx,	[%rip+L8328]
    call      strcpy
    jmp       L2713
L2733:
    jmp       L2691
L2734:
    cmp       %rsi,	152
    jle       L2745
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    call      msys.strint
    lea       %rcx,	[%rbp + mc_writegas.strmcl.opcname]
    mov       %rdx,	%rax
    call      strcpy
    jmp       L2744
L2745:
    lea       %rax,	[%rip+mc_decls.mclnames]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8-8]
    lea       %rax,	[%rax+2]
    lea       %rcx,	[%rbp + mc_writegas.strmcl.opcname]
    mov       %rdx,	%rax
    call      strcpy
L2744:
L2713:
    lea       %rcx,	[%rbp + mc_writegas.strmcl.opcname]
    mov       %rdx,	10
    lea       %r8,	[%rip+L8329]
    call      mlib.ipadstr
    lea       %rcx,	[%rip+mc_writegas.strmcl.str]
    lea       %rdx,	[%rip+L8330]
    call      strcpy
    lea       %rcx,	[%rip+mc_writegas.strmcl.str]
    mov       %rdx,	4
    lea       %r8,	[%rip+L8331]
    call      mlib.ipadstr
    lea       %rcx,	[%rip+mc_writegas.strmcl.str]
    lea       %rdx,	[%rbp + mc_writegas.strmcl.opcname]
    call      strcat
    lea       %rcx,	[%rip+mc_writegas.strmcl.str]
    call      mc_writegas.asmstr
    test      %rdi,	%rdi
    jz        L2747
    test      %rbx,	%rbx
    jz        L2747
    mov       %rcx,	%rsi
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_writegas.needsizeprefix
    mov       %r13,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	%r13
    xor       %r8d,	%r8d
    call      mc_writegas.asmopnd
    lea       %rcx,	[%rip+L8332]
    call      mc_writegas.asmstr
    mov       %rcx,	%rbx
    mov       %rdx,	%r13
    xor       %r8d,	%r8d
    call      mc_writegas.asmopnd
    mov       %rax,	[%rbp + mc_writegas.strmcl.mcl]
    mov       %al,	[%rax+32]
    test      %al,	%al
    jz        L2749
    lea       %rcx,	[%rip+L8333]
    call      mc_writegas.asmstr
    mov       %rax,	[%rbp + mc_writegas.strmcl.mcl]
    movzx     %rax,	byte ptr[%rax+32]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.strint
    mov       %rcx,	%rax
    call      mc_writegas.asmstr
L2749:
    jmp       L2746
L2747:
    test      %rdi,	%rdi
    jz        L2750
    movzx     %rax,	word ptr[%rdi+8]
    shr       %rax,	9
    and       %rax,	7
    jz        L2750
    cmp       %rsi,	21
    jnz       L2752
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    mov       %r8,	%rsi
    call      mc_writegas.asmopnd
    jmp       L2751
L2752:
    mov       %rcx,	%rdi
    mov       %rdx,	1
    mov       %r8,	%rsi
    call      mc_writegas.asmopnd
L2751:
L2750:
L2746:
L2691:
#---------------
    add       %rsp,	168
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writegas.strmclstr
mc_writegas.strmclstr:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	[%rip+pc_decls.pdest]
    call      mlib.gs_init
    mov       %rcx,	%rdi
    call      mc_writegas.strmcl
    mov       %rax,	[%rip+pc_decls.pdest]
    mov       %rax,	[%rax]
L2753:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_writegas.mstropnd
mc_writegas.mstropnd:
#?>>
    .set mc_writegas.mstropnd.str2, -128
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	168
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
    xor       %eax,	%eax
    lea       %r10,	[%rip+mc_writegas.mstropnd.str]
    mov       [%r10],	%al
    movzx     %rax,	word ptr[%rsi+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jz        L2756
    cmp       %rax,	2
    jz        L2757
    cmp       %rax,	3
    jz        L2758
    cmp       %rax,	5
    jz        L2759
    jmp       L2760
L2756:
    movzx     %rax,	word ptr[%rsi+8]
    and       %rax,	31
    movzx     %r10,	byte ptr[%rsi+10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_writegas.strreg
    jmp       L2754
L2757:
    cmp       %r13,	119
    jnz       L2762
    movzx     %rax,	word ptr[%rsi+8]
    shr       %rax,	12
    and       %rax,	15
    cmp       %rax,	1
    jnz       L2762
    mov       %rax,	[%rsi]
    cmp       %rax,	0
    jl        L2764
    cmp       %rax,	9
    jg        L2764
    mov       %rax,	[%rsi]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.strint
    lea       %rcx,	[%rip+mc_writegas.mstropnd.str]
    mov       %rdx,	%rax
    call      strcat
    jmp       L2763
L2764:
    lea       %rcx,	[%rip+mc_writegas.mstropnd.str]
    lea       %rdx,	[%rip+L8334]
    call      strcat
    mov       %rax,	[%rsi]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8335]
    call      msys.strword
    lea       %rcx,	[%rip+mc_writegas.mstropnd.str]
    mov       %rdx,	%rax
    call      strcat
L2763:
    jmp       L2761
L2762:
    mov       %rcx,	%rsi
    call      mc_writegas.strvalue
    lea       %rcx,	[%rip+mc_writegas.mstropnd.str]
    mov       %rdx,	%rax
    call      strcpy
L2761:
    jmp       L2755
L2758:
    movzx     %rax,	word ptr[%rsi+8]
    and       %rax,	31
    mov       %rcx,	%rax
    mov       %rdx,	%r12
    call      mc_writegas.getsizeprefix
    lea       %rcx,	[%rip+mc_writegas.mstropnd.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rcx,	[%rip+mc_writegas.mstropnd.str]
    lea       %rdx,	[%rip+L8336]
    call      strcat
    lea       %rax,	[%rip+L8337]
    mov       %rdi,	%rax
    mov       %al,	[%rsi+10]
    test      %al,	%al
    jz        L2766
    movzx     %rax,	byte ptr[%rsi+10]
    mov       %rcx,	%rax
    mov       %rdx,	8
    call      mc_writegas.strreg
    lea       %rcx,	[%rip+mc_writegas.mstropnd.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rax,	[%rip+L8338]
    mov       %rdi,	%rax
L2766:
    mov       %al,	[%rsi+11]
    test      %al,	%al
    jz        L2768
    lea       %rcx,	[%rip+mc_writegas.mstropnd.str]
    mov       %rdx,	%rdi
    call      strcat
    movzx     %rax,	byte ptr[%rsi+11]
    mov       %rcx,	%rax
    mov       %rdx,	8
    call      mc_writegas.strreg
    lea       %rcx,	[%rip+mc_writegas.mstropnd.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rax,	[%rip+L8338]
    mov       %rdi,	%rax
    movzx     %rax,	word ptr[%rsi+8]
    shr       %rax,	5
    and       %rax,	15
    cmp       %rax,	1
    jle       L2770
    lea       %rcx,	[%rip+mc_writegas.mstropnd.str]
    lea       %rdx,	[%rip+L8339]
    call      strcat
    movzx     %rax,	word ptr[%rsi+8]
    shr       %rax,	5
    and       %rax,	15
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.strint
    lea       %rcx,	[%rip+mc_writegas.mstropnd.str]
    mov       %rdx,	%rax
    call      strcat
L2770:
L2768:
    movzx     %rax,	word ptr[%rsi+8]
    shr       %rax,	12
    and       %rax,	15
    cmp       %rax,	5
    jz        L2773
    cmp       %rax,	6
    jz        L2773
    cmp       %rax,	8
    jnz       L2772
L2773:
    movzx     %rax,	byte ptr[%rsi+10]
    movzx     %r10,	byte ptr[%rsi+11]
    cmp       %r10,	%rax
    jnz       L2776
    test      %r10,	%r10
    jnz       L2776
    mov       %rax,	1
    jmp       L2777
L2776:
    xor       %eax,	%eax
L2777:
    test      %rax,	%rax
    setnz     %al
    movzx     %eax,	%al
    test      %ax,	%ax
    jz        L2775
    mov       %al,	[%rip+pc_api.phighmem]
    test      %al,	%al
    jz        L2775
    lea       %rcx,	[%rip+mc_writegas.mstropnd.str]
    lea       %rdx,	[%rip+L8340]
    call      strcat
L2775:
    mov       %al,	[%rdi]
    test      %al,	%al
    jz        L2779
    lea       %rcx,	[%rip+mc_writegas.mstropnd.str]
    mov       %rdx,	%rdi
    call      strcat
L2779:
    mov       %rcx,	%rsi
    call      mc_writegas.strvalue
    lea       %rcx,	[%rip+mc_writegas.mstropnd.str]
    mov       %rdx,	%rax
    call      strcat
    jmp       L2771
L2772:
    movsxd    %rax,	dword ptr[%rsi+12]
    mov       %rbx,	%rax
    test      %rax,	%rax
    jz        L2780
    lea       %rcx,	[%rbp + mc_writegas.mstropnd.str2]
    call      msys.m$print_startstr
    mov       %rcx,	%rbx
    lea       %rdx,	[%rip+L8341]
    call      msys.m$print_i64
    call      msys.m$print_end
    lea       %rcx,	[%rip+mc_writegas.mstropnd.str]
    lea       %rdx,	[%rbp + mc_writegas.mstropnd.str2]
    call      strcat
L2780:
L2771:
    lea       %rcx,	[%rip+mc_writegas.mstropnd.str]
    lea       %rdx,	[%rip+L8342]
    call      strcat
    jmp       L2755
L2759:
    movzx     %rax,	word ptr[%rsi+8]
    and       %rax,	31
    movzx     %r10,	byte ptr[%rsi+10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_writegas.strxreg
    jmp       L2754
L2760:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8343]
    call      msys.m$print_str_nf
    movzx     %rax,	word ptr[%rsi+8]
    shr       %rax,	9
    and       %rax,	7
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.m$print_u64
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rax,	[%rip+L8344]
    jmp       L2754
L2755:
    lea       %rax,	[%rip+mc_writegas.mstropnd.str]
L2754:
#---------------
    add       %rsp,	168
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writegas.strvalue
mc_writegas.strvalue:
#?>>
    .set mc_writegas.strvalue.str2, -128
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	160
    mov       %r12,	%rcx
#---------------
    mov       %rdi,	[%r12]
    mov       %rbx,	[%r12]
    lea       %rcx,	[%rip+mc_writegas.strvalue.str]
    lea       %rdx,	[%rip+L8345]
    call      strcpy
    movzx     %rax,	word ptr[%r12+8]
    shr       %rax,	12
    and       %rax,	15
    cmp       %rax,	5
    jz        L2783
    cmp       %rax,	1
    jz        L2784
    cmp       %rax,	2
    jz        L2785
    cmp       %rax,	3
    jz        L2786
    cmp       %rax,	4
    jz        L2787
    cmp       %rax,	7
    jz        L2788
    cmp       %rax,	6
    jz        L2789
    cmp       %rax,	8
    jz        L2790
    jmp       L2791
L2783:
    mov       %rcx,	%rdi
    call      mc_writegas.getdispname
    lea       %rcx,	[%rip+mc_writegas.strvalue.str]
    mov       %rdx,	%rax
    call      strcat
#mc_writegas.strvalue.addoffset:
L2792:
    movsxd    %rax,	dword ptr[%r12+12]
    mov       %rsi,	%rax
    test      %rax,	%rax
    jz        L2794
    lea       %rcx,	[%rbp + mc_writegas.strvalue.str2]
    call      msys.m$print_startstr
    cmp       %rsi,	0
    jle       L2796
    lea       %rax,	[%rip+L8346]
    jmp       L2795
L2796:
    lea       %rax,	[%rip+L8347]
L2795:
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       %rcx,	%rsi
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rcx,	[%rip+mc_writegas.strvalue.str]
    lea       %rdx,	[%rbp + mc_writegas.strvalue.str2]
    call      strcat
L2794:
    jmp       L2782
L2784:
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      msys.strint
    lea       %rcx,	[%rip+mc_writegas.strvalue.str]
    mov       %rdx,	%rax
    call      strcat
    jmp       L2782
L2785:
    lea       %rcx,	[%rip+mc_writegas.strvalue.str]
    call      msys.m$print_startstr
    movq      %XMM4,	[%r12]
    movq      %XMM0,	%XMM4
    lea       %rdx,	[%rip+L8348]
    call      msys.m$print_r64
    call      msys.m$print_end
    jmp       L2782
L2786:
    lea       %rcx,	[%rip+mc_writegas.strvalue.str]
    lea       %rdx,	[%rip+L8349]
    call      strcat
    movq      %XMM4,	[%r12]
    movq      %XMM0,	%XMM4
    xor       %edx,	%edx
    call      msys.strreal
    lea       %rcx,	[%rip+mc_writegas.strvalue.str]
    mov       %rdx,	%rax
    call      strcat
    jmp       L2782
L2787:
    lea       %rcx,	[%rip+mc_writegas.strvalue.str]
    lea       %rdx,	[%rip+L8350]
    call      strcat
    mov       %rax,	[%r12]
    lea       %rcx,	[%rip+mc_writegas.strvalue.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rcx,	[%rip+mc_writegas.strvalue.str]
    lea       %rdx,	[%rip+L8350]
    call      strcat
    jmp       L2782
L2788:
    mov       %rax,	[%r12]
    lea       %rcx,	[%rip+mc_writegas.strvalue.str]
    mov       %rdx,	%rax
    call      strcat
    jmp       L2782
L2789:
    lea       %rcx,	[%rip+mc_writegas.strvalue.str]
    lea       %rdx,	[%rip+L8351]
    call      strcat
    mov       %rax,	[%r12]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.strint
    lea       %rcx,	[%rip+mc_writegas.strvalue.str]
    mov       %rdx,	%rax
    call      strcat
    jmp       L2792
L2790:
    mov       %rax,	[%r12]
    mov       %rcx,	[%rip+mc_decls.currasmproc]
    mov       %rdx,	%rax
    call      mc_writegas.gettempname
    jmp       L2781
L2791:
    lea       %rcx,	[%rip+L8352]
    lea       %rdx,	[%rip+L8353]
    call      pc_api.merror
L2782:
    lea       %rax,	[%rip+mc_writegas.strvalue.str]
L2781:
#---------------
    add       %rsp,	160
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writegas.asmopnd
mc_writegas.asmopnd:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      mc_writegas.mstropnd
    mov       %rcx,	%rax
    call      mc_writegas.asmstr
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writegas.getxregname
mc_writegas.getxregname:
#?>>
    .set mc_writegas.getxregname.size, 32
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    test      %rdi,	%rdi
    jnz       L2800
    lea       %rax,	[%rip+L8354]
    jmp       L2798
L2800:
    lea       %rcx,	[%rip+mc_writegas.getxregname.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8355]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rax,	[%rdi-1]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rax,	[%rip+mc_writegas.getxregname.str]
L2798:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_writegas.asmstr
mc_writegas.asmstr:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	[%rip+pc_decls.pdest]
    mov       %rdx,	%rdi
    call      mlib.gs_str
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_writegas.asmchar
mc_writegas.asmchar:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	[%rip+pc_decls.pdest]
    mov       %rdx,	%rdi
    call      mlib.gs_char
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_writegas.getdispname
mc_writegas.getdispname:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      pc_api.getfullname
L2803:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_writegas.gettempname
mc_writegas.gettempname:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %al,	[%rip+pc_api.fpshortnames]
    test      %al,	%al
    jz        L2806
    lea       %rcx,	[%rip+mc_writegas.gettempname.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8356]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       %rcx,	%rbx
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L2805
L2806:
    lea       %rcx,	[%rip+mc_writegas.gettempname.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8357]
    call      msys.m$print_setfmt
    mov       %rcx,	%rdi
    call      mc_writegas.getdispname
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    mov       %rcx,	%rbx
    call      msys.m$print_i64_nf
    call      msys.m$print_end
L2805:
    lea       %rax,	[%rip+mc_writegas.gettempname.str]
L2804:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writegas.strreg
mc_writegas.strreg:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    lea       %rcx,	[%rip+mc_writegas.strreg.str]
    lea       %rdx,	[%rip+L8358]
    call      strcpy
    lea       %rax,	[%rip+mc_writegas.nregnames]
    mov       %r10,	%rbx
    shl       %r10,	7
    lea       %rax,	[%rax + %r10-128]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    lea       %rcx,	[%rip+mc_writegas.strreg.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rax,	[%rip+mc_writegas.strreg.str]
L2807:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writegas.strxreg
mc_writegas.strxreg:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      mc_writegas.checkregvar
    mov       %rdi,	%rax
    cmp       %rsi,	8
    jnz       L2810
    test      %rdi,	%rdi
    jz        L2810
    mov       %rcx,	%rdi
    call      mc_writegas.getdispname
    jmp       L2809
L2810:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      mc_writegas.getxregname
L2809:
L2808:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writegas.needsizeprefix
mc_writegas.needsizeprefix:
#?>>
#?]]
#---------------
    mov       %rax,	%rcx
    cmp       %rax,	18
    jz        L2813
    cmp       %rax,	19
    jz        L2813
    cmp       %rax,	86
    jz        L2813
    cmp       %rax,	87
    jz        L2813
    cmp       %rax,	82
    jz        L2814
    cmp       %rax,	83
    jz        L2814
    cmp       %rax,	84
    jz        L2814
    cmp       %rax,	85
    jz        L2814
    cmp       %rax,	43
    jz        L2815
    cmp       %rax,	45
    jz        L2815
    cmp       %rax,	44
    jz        L2815
    jmp       L2816
L2813:
    mov       %rax,	1
    jmp       L2811
L2814:
    mov       %rax,	1
    jmp       L2811
L2815:
    movzx     %rax,	word ptr[%rdx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	3
    jnz       L2818
    mov       %rax,	1
    jmp       L2811
L2818:
    xor       %eax,	%eax
    jmp       L2811
L2816:
L2812:
    movzx     %rax,	word ptr[%rdx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jz        L2821
    movzx     %rax,	word ptr[%rdx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	5
    jz        L2821
    movzx     %rax,	word ptr[%r8+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jz        L2821
    movzx     %rax,	word ptr[%r8+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	5
    jnz       L2820
L2821:
    xor       %eax,	%eax
    jmp       L2811
L2820:
    mov       %rax,	1
L2811:
#---------------
    ret       
# End 
# Proc mc_writegas.getsizeprefix
mc_writegas.getsizeprefix:
#?>>
#?]]
#---------------
    test      %rdx,	%rdx
    jnz       L2824
    lea       %rax,	[%rip+L8359]
    jmp       L2822
L2824:
    mov       %rax,	%rcx
    cmp       %rax,	1
    jz        L2826
    cmp       %rax,	2
    jz        L2827
    cmp       %rax,	4
    jz        L2828
    cmp       %rax,	8
    jz        L2829
    jmp       L2830
L2826:
    lea       %rax,	[%rip+L8360]
    jmp       L2822
L2827:
    lea       %rax,	[%rip+L8361]
    jmp       L2822
L2828:
    lea       %rax,	[%rip+L8362]
    jmp       L2822
L2829:
    lea       %rax,	[%rip+L8363]
    jmp       L2822
L2830:
L2825:
    lea       %rax,	[%rip+L8364]
L2822:
#---------------
    ret       
# End 
# Proc mc_writegas.checkregvar
mc_writegas.checkregvar:
#?>>
    .set mc_writegas.checkregvar.reg, 16
    .set mc_writegas.checkregvar.ispfloat, 24
#?]]
#---------------
    xor       %eax,	%eax
L2831:
#---------------
    ret       
# End 
# Proc mc_writeexe_dummy.genexe
mc_writeexe_dummy.genexe:
#?>>
    .set mc_writeexe_dummy.genexe.entrypoint, 16
    .set mc_writeexe_dummy.genexe.outfile, 24
    .set mc_writeexe_dummy.genexe.dodll, 32
#?]]
#---------------
#---
#---------------
    ret       
# End 
# Proc mc_writeexe_dummy.writeexe
mc_writeexe_dummy.writeexe:
#?>>
    .set mc_writeexe_dummy.writeexe.outfile, 16
    .set mc_writeexe_dummy.writeexe.dodll, 24
#?]]
#---------------
#---
#---------------
    ret       
# End 
# Proc mc_writeobj_dummy.writecoff
mc_writeobj_dummy.writecoff:
#?>>
    .set mc_writeobj_dummy.writecoff.outfile, 16
#?]]
#---------------
#---
#---------------
    ret       
# End 
# Proc mc_writess_dummy.writessdata
mc_writess_dummy.writessdata:
#?>>
    .set mc_writess_dummy.writessdata.fexe, 16
#?]]
#---------------
    xor       %eax,	%eax
L2835:
#---------------
    ret       
# End 
# Proc mx_run_dummy.runlibfile
mx_run_dummy.runlibfile:
#?>>
    .set mx_run_dummy.runlibfile.filename, 16
    .set mx_run_dummy.runlibfile.cmdskip, 24
#?]]
    sub       %rsp,	40
#---------------
    lea       %rcx,	[%rip+L8365]
    call      mlib.abortprogram
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mx_run_dummy.writemcx
mx_run_dummy.writemcx:
#?>>
    .set mx_run_dummy.writemcx.filename, 16
#?]]
#---------------
#---
#---------------
    ret       
# End 
# Proc cc_cli.main
cc_cli.main:
main:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    call      msyswin.start
    call      pepcl.start
    call      mnoos.os_clock
    mov       [%rip+cc_cli.startclock],	%rax
    mov       %rax,	[%rip+cc_cli.startclock]
    mov       [%rip+pc_decls.pstartclock],	%rax
    call      cc_cli.starttiming
    call      cc_cli.initdata
    call      cc_cli.getinputoptions
    call      cc_cli.initsearchdirs
    movzx     %rax,	byte ptr[%rip+cc_cli.fverbose]
    cmp       %rax,	3
    jnz       L2840
    call      cc_cli.showsearchdirs
L2840:
    call      cc_cli.initlogfile
    call      cc_cli.gettiming
    mov       [%rip+cc_cli.inittime],	%rax
    mov       %al,	[%rip+cc_cli.fverbose]
    test      %al,	%al
    jz        L2842
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8366]
    call      msys.m$print_setfmt
    mov       %rcx,	[%rip+cc_decls.inputfile]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+cc_cli.outfile]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L2842:
    mov       %rcx,	[%rip+cc_decls.inputfile]
    call      mlib.extractbasefile
    mov       %rcx,	%rax
    call      mlib.pcm_copyheapstring
    mov       [%rip+pc_decls.$pmodulename],	%rax
    call      cc_cli.do_loadmodule
    call      cc_cli.do_preprocess
    call      cc_cli.do_parsemodule
    call      cc_cli.do_genpcl
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	6
    jz        L2844
    cmp       %rax,	7
    jz        L2845
    cmp       %rax,	8
    jz        L2846
    cmp       %rax,	10
    jz        L2847
    cmp       %rax,	11
    jz        L2848
    cmp       %rax,	12
    jz        L2849
    cmp       %rax,	9
    jz        L2850
    cmp       %rax,	13
    jz        L2851
    jmp       L2852
L2844:
    call      pc_run_dummy.pcl_runpcl
    jmp       L2843
L2845:
    call      cc_cli.do_genmcl
    jmp       L2843
L2846:
    call      cc_cli.do_asm
    jmp       L2843
L2847:
    call      cc_cli.do_obj
    jmp       L2843
L2848:
    call      cc_cli.do_dll
    jmp       L2843
L2849:
    call      cc_cli.do_exe
    jmp       L2843
L2850:
    call      cc_cli.do_mx
    jmp       L2843
L2851:
    call      cc_cli.do_run
    jmp       L2843
L2852:
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	7
    jl        L2854
    call      msys.m$print_startcon
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    lea       %r10,	[%rip+cc_cli.passnames]
    mov       %r10,	[%r10 + %rax*8-8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L8367]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L2854:
L2843:
    movzx     %rax,	byte ptr[%rip+cc_cli.fverbose]
    cmp       %rax,	2
    jl        L2856
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8368]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L2856:
    mov       %al,	[%rip+cc_cli.fshowtiming]
    test      %al,	%al
    jz        L2858
    call      cc_cli.showtiming
L2858:
    call      cc_cli.closelogfile
    xor       %ecx,	%ecx
    call      exit
    xor       %ecx,	%ecx
    call      exit
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.do_preprocess
cc_cli.do_preprocess:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	2
    jnz       L2861
    movzx     %rax,	byte ptr[%rip+cc_cli.fstdout]
    mov       %rcx,	[%rip+cc_decls.inputfile]
    mov       %rdx,	[%rip+cc_cli.outfile]
    mov       %r8,	%rax
    call      cc_lex.lex_preprocess_only
    xor       %ecx,	%ecx
    call      exit
L2861:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.do_loadmodule
cc_cli.do_loadmodule:
#?>>
    .set cc_cli.do_loadmodule.path, -304
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	336
#---------------
    movzx     %rax,	byte ptr[%rip+cc_cli.fverbose]
    cmp       %rax,	3
    jnz       L2864
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8369]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+cc_decls.inputfile]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L2864:
    call      cc_cli.starttiming
    lea       %rax,	[%rip+L8370]
    lea       %r10,	[%rip+cc_decls.sourcefilenames]
    mov       [%r10],	%rax
    lea       %rax,	[%rip+L8371]
    lea       %r10,	[%rip+cc_decls.sourcefilepaths]
    mov       [%r10],	%rax
    lea       %rax,	[%rip+L8372]
    lea       %r10,	[%rip+cc_decls.sourcefiletext]
    mov       [%r10],	%rax
    lea       %rax,	[%rip+cc_decls.sourcefiletext]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    call      strlen
    lea       %r10,	[%rip+cc_decls.sourcefilesizes]
    mov       [%r10],	%eax
    lea       %rcx,	[%rip+L8373]
    call      cc_lex.addnamestr
    xor       %ecx,	%ecx
    mov       %rdx,	%rax
    mov       %r8,	2
    call      cc_lib.createdupldef
    mov       [%rip+cc_decls.stprogram],	%rax
    mov       %rcx,	[%rip+cc_decls.inputfile]
    call      mlib.checkfile
    test      %rax,	%rax
    jnz       L2866
    lea       %rcx,	[%rip+L8374]
    mov       %rdx,	[%rip+cc_decls.inputfile]
    call      cc_support.loaderror
L2866:
    mov       %rcx,	[%rip+cc_decls.inputfile]
    mov       %rdx,	[%rip+cc_decls.inputfile]
    call      cc_support.loadsourcefile
    mov       [%rip+cc_decls.mainfileno],	%rax
    mov       %rcx,	[%rip+cc_decls.inputfile]
    call      mlib.extractbasefile
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    call      cc_lex.addnamestr
    mov       %rcx,	[%rip+cc_decls.stprogram]
    mov       %rdx,	%rax
    mov       %r8,	3
    call      cc_lib.createdupldef
    mov       [%rip+cc_decls.stmodule],	%rax
    mov       %rcx,	[%rip+cc_decls.inputfile]
    call      mlib.extractpath
    lea       %rcx,	[%rbp + cc_cli.do_loadmodule.path]
    mov       %rdx,	%rax
    call      strcpy
    mov       %al,	[%rbp + cc_cli.do_loadmodule.path]
    test      %al,	%al
    jz        L2868
    inc       qword ptr[%rip+cc_decls.nsearchdirs]
    mov       %rbx,	[%rip+cc_decls.nsearchdirs]
    cmp       %rbx,	2
    jl        L2871
L2869:
    lea       %rax,	[%rip+cc_decls.searchdirs]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8-16]
    lea       %r10,	[%rip+cc_decls.searchdirs]
    mov       %r11,	%rbx
    mov       [%r10 + %r11*8-8],	%rax
    dec       %rbx
    cmp       %rbx,	2
    jge       L2869
L2871:
    lea       %rcx,	[%rbp + cc_cli.do_loadmodule.path]
    call      mlib.pcm_copyheapstring
    lea       %r10,	[%rip+cc_decls.searchdirs]
    mov       [%r10],	%rax
L2868:
    call      cc_cli.gettiming
    mov       [%rip+cc_cli.loadtime],	%rax
#---------------
    add       %rsp,	336
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_cli.do_parsemodule
cc_cli.do_parsemodule:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    call      cc_cli.starttiming
    call      cc_parse.parsemodule
    call      cc_cli.gettiming
    mov       %rdi,	%rax
    mov       [%rip+cc_cli.parsetime],	%rax
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_cli.do_genpcl
cc_cli.do_genpcl:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	5
    jl        L2873
L2875:
    call      cc_cli.starttiming
    call      cc_genpcl.codegen_pcl
    call      cc_cli.gettiming
    mov       [%rip+cc_cli.pcltime],	%rax
    mov       %al,	[%rip+pc_decls.fregoptim]
    test      %al,	%al
    jnz       L2878
    mov       %al,	[%rip+pc_decls.fpeephole]
    test      %al,	%al
    jz        L2877
L2878:
    call      pc_reduce.pcl_reducetest
L2877:
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	5
    jnz       L2880
    mov       %rcx,	[%rip+cc_cli.outfile]
    call      pc_api.pcl_writepcl
L2880:
L2873:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.do_genmcl
cc_cli.do_genmcl:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	7
    jl        L2881
L2883:
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	7
    jnz       L2885
    mov       %rcx,	[%rip+cc_cli.outfile]
    mov       %rdx,	16705
    call      pc_api.pcl_writeasm
L2885:
L2881:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.do_asm
cc_cli.do_asm:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	8
    jl        L2886
L2888:
    mov       %rcx,	[%rip+cc_cli.outfile]
    mov       %rdx,	16705
    call      pc_api.pcl_writeasm
L2886:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.do_obj
cc_cli.do_obj:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	10
    jnz       L2889
L2891:
    mov       %rcx,	[%rip+cc_cli.outfile]
    call      pc_api.pcl_writeobj
L2889:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.do_dll
cc_cli.do_dll:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	11
    jnz       L2892
L2894:
    mov       %rcx,	[%rip+cc_cli.outfile]
    call      pc_api.pcl_writedll
L2892:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.do_exe
cc_cli.do_exe:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	12
    jnz       L2895
L2897:
    mov       %rcx,	[%rip+cc_cli.outfile]
    call      pc_api.pcl_writeexe
L2895:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.do_mx
cc_cli.do_mx:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	9
    jnz       L2898
L2900:
    mov       %rcx,	[%rip+cc_cli.outfile]
    call      pc_api.pcl_writemx
L2898:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.do_run
cc_cli.do_run:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	13
    jnz       L2901
L2903:
    call      pc_api.pcl_exec
L2901:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.initlogfile
cc_cli.initlogfile:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    movzx     %rax,	byte ptr[%rip+cc_cli.debugmode]
    cmp       %rax,	2
    jl        L2906
    lea       %rcx,	[%rip+L8375]
    call      remove
    lea       %rcx,	[%rip+L8375]
    lea       %rdx,	[%rip+L8376]
    call      fopen
    mov       [%rip+cc_decls.logdev],	%rax
L2906:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.closelogfile
cc_cli.closelogfile:
#?>>
    .set cc_cli.closelogfile.str, -104
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	144
#---------------
    movzx     %rax,	byte ptr[%rip+cc_cli.debugmode]
    cmp       %rax,	2
    jl        L2907
L2909:
    mov       %al,	[%rip+cc_cli.fshowmcl]
    test      %al,	%al
    jz        L2911
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	7
    jl        L2911
    mov       %rcx,	[%rip+cc_decls.logdev]
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L8377]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	[%rip+cc_decls.logdev]
    call      msys.m$print_startfile
    xor       %ecx,	%ecx
    mov       %rdx,	16705
    call      pc_api.pcl_writeasm
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L2911:
    mov       %al,	[%rip+cc_cli.fshowpcl]
    test      %al,	%al
    jz        L2913
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	5
    jl        L2913
    mov       %rcx,	[%rip+cc_decls.logdev]
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L8378]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	[%rip+cc_decls.logdev]
    call      msys.m$print_startfile
    xor       %ecx,	%ecx
    call      pc_api.pcl_writepcl
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %al,	[%rip+cc_cli.fshowpst]
    test      %al,	%al
    jz        L2915
    lea       %rcx,	[%rip+L8379]
    call      pc_api.pcl_writepst
    lea       %rcx,	[%rip+L8379]
    mov       %rdx,	[%rip+cc_decls.logdev]
    call      cc_lib.addtolog
L2915:
L2913:
    call      cc_cli.showast
    mov       %al,	[%rip+cc_cli.fshowst]
    test      %al,	%al
    jz        L2917
    lea       %rcx,	[%rip+L8380]
    call      cc_cli.showst
L2917:
    mov       %al,	[%rip+cc_cli.fshowstflat]
    test      %al,	%al
    jz        L2919
    lea       %rcx,	[%rip+L8381]
    call      cc_cli.showstflat
L2919:
    mov       %al,	[%rip+cc_cli.fshowtypes]
    test      %al,	%al
    jz        L2921
    mov       %rcx,	[%rip+cc_decls.logdev]
    call      cc_show.printmodelist
L2921:
    mov       %rcx,	[%rip+cc_decls.logdev]
    call      fclose
    lea       %rcx,	[%rip+L8382]
    call      mlib.checkfile
    test      %rax,	%rax
    jz        L2923
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8383]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      mnoos.os_getch
    cmp       %rax,	27
    jnz       L2925
    xor       %ecx,	%ecx
    call      exit
L2925:
    lea       %rcx,	[%rbp + cc_cli.closelogfile.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8384]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L8385]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + cc_cli.closelogfile.str]
    xor       %edx,	%edx
    xor       %r8d,	%r8d
    call      mnoos.os_execwait
    jmp       L2922
L2923:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8386]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L8387]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L2922:
L2907:
#---------------
    add       %rsp,	144
    pop       %rbp
    ret       
# End 
# Proc cc_cli.initdata
cc_cli.initdata:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    call      mlib.pcm_init
    call      cc_lex.lexsetup
    call      cc_lib.inittypetables
    call      cc_lib.initcclib
    xor       %eax,	%eax
    mov       [%rip+cc_decls.nlibfiles],	%rax
    inc       qword ptr[%rip+cc_decls.nlibfiles]
    mov       %rax,	[%rip+cc_decls.nlibfiles]
    lea       %r10,	[%rip+L8388]
    lea       %r11,	[%rip+cc_decls.libfiles]
    mov       [%r11 + %rax*8],	%r10
    inc       qword ptr[%rip+cc_decls.nlibfiles]
    mov       %rax,	[%rip+cc_decls.nlibfiles]
    lea       %r10,	[%rip+L8389]
    lea       %r11,	[%rip+cc_decls.libfiles]
    mov       [%r11 + %rax*8],	%r10
    inc       qword ptr[%rip+cc_decls.nlibfiles]
    mov       %rax,	[%rip+cc_decls.nlibfiles]
    lea       %r10,	[%rip+L8390]
    lea       %r11,	[%rip+cc_decls.libfiles]
    mov       [%r11 + %rax*8],	%r10
    inc       qword ptr[%rip+cc_decls.nlibfiles]
    mov       %rax,	[%rip+cc_decls.nlibfiles]
    lea       %r10,	[%rip+L8391]
    lea       %r11,	[%rip+cc_decls.libfiles]
    mov       [%r11 + %rax*8],	%r10
    lea       %rax,	[%rip+cc_cli.cgetsourceinfo]
    mov       [%rip+pc_decls.igetmsourceinfo],	%rax
    mov       %al,	[%rip+pepcl.pdcc]
    test      %al,	%al
    jz        L2928
    mov       %al,	2
    mov       [%rip+cc_cli.highmem],	%al
L2928:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.cgetsourceinfo
cc_cli.cgetsourceinfo:
#?>>
#?]]
#---------------
    mov       %rax,	%rcx
    shr       %rax,	24
    and       %rax,	511
    lea       %r10,	[%rip+cc_decls.sourcefilenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       [%rdx],	%r10
    lea       %rax,	[%rip+L8392]
    mov       [%r8],	%rax
    mov       %rax,	%rcx
    and       %rax,	16777215
L2929:
#---------------
    ret       
# End 
# Proc cc_cli.initsearchdirs
cc_cli.initsearchdirs:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    inc       qword ptr[%rip+cc_decls.nsearchdirs]
    mov       %rax,	[%rip+cc_decls.nsearchdirs]
    lea       %r10,	[%rip+L8393]
    lea       %r11,	[%rip+cc_decls.searchdirs]
    mov       [%r11 + %rax*8-8],	%r10
    inc       qword ptr[%rip+cc_decls.nsearchdirs]
    mov       %rax,	[%rip+cc_decls.nsearchdirs]
    lea       %r10,	[%rip+L8394]
    lea       %r11,	[%rip+cc_decls.searchdirs]
    mov       [%r11 + %rax*8-8],	%r10
    call      mnoos.os_gethostname
    mov       %rcx,	%rax
    call      mlib.extractpath
    mov       %rcx,	%rax
    call      mlib.pcm_copyheapstring
    inc       qword ptr[%rip+cc_decls.nsearchdirs]
    mov       %r10,	[%rip+cc_decls.nsearchdirs]
    lea       %r11,	[%rip+cc_decls.searchdirs]
    mov       [%r11 + %r10*8-8],	%rax
    mov       %rdi,	1
    mov       %rax,	[%rip+cc_decls.nincludepaths]
    cmp       %rax,	1
    jl        L2933
L2931:
    lea       %rax,	[%rip+cc_decls.includepaths]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    mov       %al,	[%rax]
    test      %al,	%al
    jz        L2935
    lea       %rax,	[%rip+cc_decls.includepaths]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    inc       qword ptr[%rip+cc_decls.nsearchdirs]
    mov       %r10,	[%rip+cc_decls.nsearchdirs]
    lea       %r11,	[%rip+cc_decls.searchdirs]
    mov       [%r11 + %r10*8-8],	%rax
L2935:
    inc       %rdi
    cmp       %rdi,	[%rip+cc_decls.nincludepaths]
    jle       L2931
L2933:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_cli.showsearchdirs
cc_cli.showsearchdirs:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8395]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %al,	[%rip+cc_cli.dointheaders]
    test      %al,	%al
    jz        L2938
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8396]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L2938:
    mov       %rdi,	1
    mov       %rax,	[%rip+cc_decls.nsearchdirs]
    cmp       %rax,	1
    jl        L2941
L2939:
    lea       %rax,	[%rip+cc_decls.searchdirs]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    mov       %al,	[%rax]
    test      %al,	%al
    jz        L2943
    call      msys.m$print_startcon
    mov       %rcx,	%rdi
    call      msys.m$print_i64_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L8397]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.searchdirs]
    mov       %r10,	%rdi
    mov       %rcx,	[%rax + %r10*8-8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L2942
L2943:
    call      msys.m$print_startcon
    mov       %rcx,	%rdi
    call      msys.m$print_i64_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L8398]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L2942:
    inc       %rdi
    cmp       %rdi,	[%rip+cc_decls.nsearchdirs]
    jle       L2939
L2941:
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_cli.showast
cc_cli.showast:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    mov       %al,	[%rip+cc_cli.fshowast]
    test      %al,	%al
    jz        L2946
    mov       %rcx,	[%rip+cc_decls.logdev]
    lea       %rdx,	[%rip+L8399]
    call      cc_show.printcode
    mov       %rcx,	[%rip+cc_decls.logdev]
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
L2946:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.showstflat
cc_cli.showstflat:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	[%rip+cc_decls.logdev]
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L8400]
    call      msys.m$print_str_nf
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	[%rip+cc_decls.logdev]
    call      cc_show.printstflat
    mov       %rcx,	[%rip+cc_decls.logdev]
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_cli.showst
cc_cli.showst:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	[%rip+cc_decls.logdev]
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L8400]
    call      msys.m$print_str_nf
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	[%rip+cc_decls.logdev]
    mov       %rdx,	[%rip+cc_decls.stmodule]
    xor       %r8d,	%r8d
    call      cc_show.printst
    mov       %rcx,	[%rip+cc_decls.logdev]
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_cli.showfiles
cc_cli.showfiles:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8401]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rdi,	1
    mov       %rax,	[%rip+cc_decls.nsourcefiles]
    cmp       %rax,	1
    jl        L2952
L2950:
    call      msys.m$print_startcon
    mov       %rcx,	%rdi
    call      msys.m$print_i64_nf
    lea       %rcx,	[%rip+L8402]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.sourcefilepaths]
    mov       %r10,	%rdi
    mov       %rcx,	[%rax + %r10*8]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.sourcefilenames]
    mov       %r10,	%rdi
    mov       %rcx,	[%rax + %r10*8]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L8403]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.sourcefilesizes]
    mov       %r10,	%rdi
    movsxd    %rax,	dword ptr[%rax + %r10*4]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    inc       %rdi
    cmp       %rdi,	[%rip+cc_decls.nsourcefiles]
    jle       L2950
L2952:
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_cli.showtime
cc_cli.showtime:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8404]
    call      msys.m$print_setfmt
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8405]
    call      msys.m$print_str
    mov       %rcx,	%rbx
    lea       %rdx,	[%rip+L8406]
    call      msys.m$print_i64
    mov       %rax,	%rbx
    cvtsi2sd  %XMM4,	%rax
    mulsd     %XMM4,	[%rip+L8407]
    mov       %rax,	[%rip+cc_cli.compiletime]
    cvtsi2sd  %XMM5,	%rax
    divsd     %XMM4,	%XMM5
    movq      %XMM0,	%XMM4
    lea       %rdx,	[%rip+L8408]
    call      msys.m$print_r64
    call      msys.m$print_newline
    call      msys.m$print_end
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_cli.showtiming
cc_cli.showtiming:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    call      mnoos.os_clock
    sub       %rax,	[%rip+cc_cli.startclock]
    mov       [%rip+cc_cli.compiletime],	%rax
    lea       %rcx,	[%rip+L8409]
    mov       %rdx,	[%rip+cc_cli.inittime]
    call      cc_cli.showtime
    lea       %rcx,	[%rip+L8410]
    mov       %rdx,	[%rip+cc_cli.loadtime]
    call      cc_cli.showtime
    lea       %rcx,	[%rip+L8411]
    mov       %rdx,	[%rip+cc_cli.parsetime]
    call      cc_cli.showtime
    lea       %rcx,	[%rip+L8412]
    mov       %rdx,	[%rip+cc_cli.pcltime]
    call      cc_cli.showtime
    lea       %rcx,	[%rip+L8413]
    mov       %rdx,	[%rip+pc_decls.mcltime]
    call      cc_cli.showtime
    lea       %rcx,	[%rip+L8414]
    mov       %rdx,	[%rip+pc_decls.sstime]
    call      cc_cli.showtime
    lea       %rcx,	[%rip+L8415]
    mov       %rdx,	[%rip+pc_decls.exetime]
    call      cc_cli.showtime
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8416]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8417]
    mov       %rdx,	[%rip+cc_cli.compiletime]
    call      cc_cli.showtime
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.getinputoptions
cc_cli.getinputoptions:
#?>>
    .set cc_cli.getinputoptions.paramno, -8
    .set cc_cli.getinputoptions.name, -16
    .set cc_cli.getinputoptions.value, -24
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	64
#---------------
    mov       %rax,	1
    mov       [%rbp + cc_cli.getinputoptions.paramno],	%rax
    xor       %rsi,	%rsi
    mov       %al,	[%rip+pepcl.pc_userunpcl]
    test      %al,	%al
    jz        L2957
    mov       %al,	6
    mov       [%rip+cc_cli.cc_pass],	%al
    xor       %eax,	%eax
    mov       [%rip+cc_cli.fverbose],	%al
L2957:
    call      mnoos.os_gethostname
    mov       %rcx,	%rax
    call      mlib.extractfile
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8418]
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L2959
    xor       %eax,	%eax
    mov       [%rip+cc_cli.fverbose],	%al
    mov       %rcx,	17
    lea       %rdx,	[%rip+L8419]
    call      cc_cli.do_option
L2959:
L2960:
    lea       %rcx,	[%rbp + cc_cli.getinputoptions.paramno]
    lea       %rdx,	[%rbp + cc_cli.getinputoptions.name]
    lea       %r8,	[%rbp + cc_cli.getinputoptions.value]
    lea       %r9,	[%rip+L8420]
    call      mlib.nextcmdparamnew
    mov       %rdi,	%rax
    mov       %rax,	%rdi
    cmp       %rax,	1
    jz        L2963
    cmp       %rax,	2
    jz        L2964
    cmp       %rax,	3
    jz        L2965
    test      %rax,	%rax
    jz        L2966
    jmp       L2967
L2963:
    mov       %rcx,	[%rbp + cc_cli.getinputoptions.name]
    call      mlib.convlcstring
    mov       %rbx,	1
    mov       %r12,	53
    cmp       %r12,	1
    jl        L2971
L2968:
    lea       %rax,	[%rip+cc_cli.optionnames]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rcx,	[%rbp + cc_cli.getinputoptions.name]
    mov       %rdx,	%rax
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L2973
    mov       %rcx,	%rbx
    mov       %rdx,	[%rbp + cc_cli.getinputoptions.value]
    call      cc_cli.do_option
    jmp       L2970
L2973:
    inc       %rbx
    cmp       %rbx,	%r12
    jle       L2968
L2971:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8421]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rbp + cc_cli.getinputoptions.name]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	1
    call      exit
L2970:
    jmp       L2962
L2964:
    mov       %rax,	[%rip+cc_decls.inputfile]
    test      %rax,	%rax
    jz        L2975
    lea       %rcx,	[%rip+L8422]
    lea       %rdx,	[%rip+L8423]
    call      cc_support.loaderror
L2975:
    mov       %rcx,	[%rbp + cc_cli.getinputoptions.name]
    call      mlib.pcm_copyheapstring
    mov       [%rip+cc_decls.inputfile],	%rax
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	13
    jz        L2978
    cmp       %rax,	6
    jnz       L2977
L2978:
    mov       %rax,	[%rbp + cc_cli.getinputoptions.paramno]
    dec       %rax
    add       %rax,	[%rip+msys.$cmdskip]
    mov       [%rip+cc_cli.cmdskip],	%rax
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	6
    setz      %al
    movzx     %eax,	%al
    mov       [%rip+cc_decls.pci_target],	%al
    jmp       L2961
L2977:
    jmp       L2962
L2965:
    mov       %rax,	[%rip+cc_decls.nlibfiles]
    cmp       %rax,	200
    jl        L2980
    lea       %rcx,	[%rip+L8424]
    lea       %rdx,	[%rip+L8425]
    call      cc_support.loaderror
L2980:
    mov       %rcx,	[%rbp + cc_cli.getinputoptions.name]
    call      mlib.pcm_copyheapstring
    inc       qword ptr[%rip+cc_decls.nlibfiles]
    mov       %r10,	[%rip+cc_decls.nlibfiles]
    lea       %r11,	[%rip+cc_decls.libfiles]
    mov       [%r11 + %r10*8],	%rax
    jmp       L2962
L2966:
    jmp       L2961
L2967:
L2962:
    jmp       L2960
L2961:
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    test      %rax,	%rax
    jnz       L2982
    mov       %al,	12
    mov       [%rip+cc_cli.cc_pass],	%al
    mov       %al,	[%rip+pepcl.asmonly]
    test      %al,	%al
    jz        L2984
    mov       %al,	8
    mov       [%rip+cc_cli.cc_pass],	%al
L2984:
L2982:
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	11
    jz        L2987
    cmp       %rax,	10
    jnz       L2986
L2987:
    mov       %al,	2
    mov       [%rip+cc_cli.highmem],	%al
    jmp       L2985
L2986:
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	9
    jz        L2989
    cmp       %rax,	13
    jnz       L2988
L2989:
    xor       %eax,	%eax
    mov       [%rip+cc_cli.highmem],	%al
L2988:
L2985:
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    lea       %r10,	[%rip+cc_cli.extnames]
    mov       %r10,	[%r10 + %rax*8-8]
    mov       [%rip+cc_cli.outext],	%r10
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	7
    jz        L2992
    cmp       %rax,	8
    jnz       L2991
L2992:
    mov       %rax,	[%rip+mc_writegas.asmext]
    mov       [%rip+cc_cli.outext],	%rax
L2991:
    mov       %rax,	[%rip+cc_decls.inputfile]
    test      %rax,	%rax
    jnz       L2994
    mov       %al,	[%rip+cc_cli.fwriteheaders]
    test      %al,	%al
    jnz       L2994
    call      cc_cli.showcaption
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8426]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8427]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       %rax,	[%rip+msys.cmdparams]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L8428]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8429]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       %rax,	[%rip+msys.cmdparams]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L8430]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8431]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       %rax,	[%rip+msys.cmdparams]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L8432]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8433]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       %rax,	[%rip+msys.cmdparams]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L8434]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	1
    call      exit
L2994:
    mov       %al,	[%rip+cc_cli.fwriteheaders]
    test      %al,	%al
    jz        L2996
    call      cc_headersx.writeheaders
    mov       %rcx,	20
    call      exit
L2996:
    mov       %rax,	[%rip+cc_cli.outfile]
    test      %rax,	%rax
    jnz       L2998
    mov       %rcx,	[%rip+cc_decls.inputfile]
    mov       %rdx,	[%rip+cc_cli.outext]
    call      mlib.changeext
    mov       %rcx,	%rax
    call      mlib.pcm_copyheapstring
    mov       [%rip+cc_cli.outfile],	%rax
L2998:
    movzx     %rax,	byte ptr[%rip+cc_cli.fshortnames]
    movzx     %r10,	byte ptr[%rip+cc_cli.highmem]
    mov       %rcx,	%r10
    mov       %rdx,	-1
    mov       %r8,	%rax
    call      pc_api.pcl_setflags
    mov       %rcx,	[%rip+cc_cli.cmdskip]
    xor       %edx,	%edx
    call      pc_api.pcl_cmdskip
#---------------
    add       %rsp,	64
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_cli.do_option
cc_cli.do_option:
#?>>
    .set cc_cli.do_option.str, -304
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	336
    mov       %r13,	%rcx
    mov       %r14,	%rdx
#---------------
    lea       %rax,	[%rip+cc_cli.optvars]
    mov       %r10,	%r13
    mov       %rbx,	[%rax + %r10*8-8]
    test      %rbx,	%rbx
    jz        L3001
    lea       %rax,	[%rip+cc_cli.optvalues]
    mov       %r10,	%r13
    mov       %al,	[%rax + %r10-1]
    mov       [%rbx],	%al
    mov       %rax,	%r13
    cmp       %rax,	1
    jl        L3003
    cmp       %rax,	9
    jg        L3003
    mov       %al,	1
    or        [%rip+cc_cli.debugmode],	%al
L3003:
    mov       %rax,	%r13
    cmp       %rax,	26
    jl        L3005
    cmp       %rax,	34
    jg        L3005
    mov       %al,	2
    or        [%rip+cc_cli.debugmode],	%al
L3005:
    cmp       %r13,	8
    jnz       L3007
    mov       %rax,	[%rip+cc_decls.inputfile]
    test      %rax,	%rax
    jz        L3007
    lea       %rcx,	[%rip+L8435]
    lea       %rdx,	[%rip+L8436]
    call      cc_support.loaderror
L3007:
    mov       %rax,	%r13
    cmp       %rax,	3
    jz        L3010
    cmp       %rax,	7
    jnz       L3009
L3010:
    mov       %al,	1
    mov       [%rip+cc_decls.pci_target],	%al
L3009:
    jmp       L2999
L3001:
    mov       %rax,	%r13
    cmp       %rax,	24
    jz        L3012
    cmp       %rax,	42
    jz        L3013
    cmp       %rax,	43
    jz        L3013
    cmp       %rax,	46
    jz        L3014
    cmp       %rax,	20
    jz        L3015
    cmp       %rax,	51
    jz        L3016
    jmp       L3017
L3012:
    mov       %rax,	[%rip+cc_decls.nincludepaths]
    cmp       %rax,	20
    jle       L3019
    lea       %rcx,	[%rip+L8437]
    lea       %rdx,	[%rip+L8438]
    call      cc_support.loaderror
L3019:
    mov       %rcx,	%r14
    call      strlen
    mov       %rdi,	%rax
    lea       %rax,	[%r14 + %rdi]
    sub       %rax,	1
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	92
    jz        L3021
    cmp       %rax,	47
    jnz       L3022
L3021:
    jmp       L3020
L3022:
    lea       %rcx,	[%rbp + cc_cli.do_option.str]
    mov       %rdx,	%r14
    call      strcpy
    lea       %rcx,	[%rbp + cc_cli.do_option.str]
    lea       %rdx,	[%rip+L8439]
    call      strcat
    lea       %rax,	[%rbp + cc_cli.do_option.str]
    mov       %r14,	%rax
L3020:
    mov       %rcx,	%r14
    call      mlib.pcm_copyheapstring
    inc       qword ptr[%rip+cc_decls.nincludepaths]
    mov       %r10,	[%rip+cc_decls.nincludepaths]
    lea       %r11,	[%rip+cc_decls.includepaths]
    mov       [%r11 + %r10*8-8],	%rax
    jmp       L3011
L3013:
    call      cc_cli.showhelp
    jmp       L3011
L3014:
    mov       %rcx,	%r14
    mov       %rdx,	[%rip+cc_cli.outext]
    call      mlib.addext
    mov       %rcx,	%rax
    call      mlib.pcm_copyheapstring
    mov       [%rip+cc_cli.outfile],	%rax
    jmp       L3011
L3015:
    xor       %eax,	%eax
    mov       [%rip+pc_decls.fpeephole],	%al
    mov       [%rip+pc_decls.fregoptim],	%al
    jmp       L3011
L3016:
    mov       %r12,	1
    mov       %rsi,	53
    cmp       %rsi,	1
    jl        L3025
L3023:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8440]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_cli.optionnames]
    mov       %r10,	%r12
    mov       %rcx,	[%rax + %r10*8-8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    inc       %r12
    cmp       %r12,	%rsi
    jle       L3023
L3025:
L3017:
L3011:
L2999:
#---------------
    add       %rsp,	336
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_cli.showincludepaths
cc_cli.showincludepaths:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8441]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+cc_decls.nincludepaths]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rdi,	1
    mov       %rax,	[%rip+cc_decls.nincludepaths]
    cmp       %rax,	1
    jl        L3029
L3027:
    call      msys.m$print_startcon
    mov       %rcx,	%rdi
    call      msys.m$print_i64_nf
    lea       %rax,	[%rip+cc_decls.includepaths]
    mov       %r10,	%rdi
    mov       %rcx,	[%rax + %r10*8-8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    inc       %rdi
    cmp       %rdi,	[%rip+cc_decls.nincludepaths]
    jle       L3027
L3029:
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_cli.showhelp
cc_cli.showhelp:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    call      cc_cli.showcaption
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8442]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	23
    call      exit
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.showextrainfo
cc_cli.showextrainfo:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    call      msys.m$print_startcon
    mov       %rcx,	[%rip+cc_cli.showextrainfo.infotext]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	24
    call      exit
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.showcaption
cc_cli.showcaption:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8443]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.starttiming
cc_cli.starttiming:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    call      mnoos.os_clock
    mov       [%rip+cc_cli.ttt],	%rax
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.gettiming
cc_cli.gettiming:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    call      mnoos.os_clock
    sub       %rax,	[%rip+cc_cli.ttt]
L3034:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_lex.lex_preprocess_only
cc_lex.lex_preprocess_only:
#?>>
    .set cc_lex.lex_preprocess_only.outfile, 80
    .set cc_lex.lex_preprocess_only.toconsole, 88
    .set cc_lex.lex_preprocess_only.hashtot, -8
    .set cc_lex.lex_preprocess_only.symtot, -16
    .set cc_lex.lex_preprocess_only.f, -24
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	56
    mov       %r15,	%rcx
    mov       [%rbp+80],	%rdx
    mov       [%rbp+88],	%r8
#---------------
    mov       %rax,	1
    mov       [%rip+cc_lex.dowhitespace],	%rax
    mov       %rcx,	%r15
    mov       %rdx,	%r15
    call      cc_support.loadsourcefile
    mov       %r12,	%rax
    lea       %rax,	[%rip+cc_decls.sourcefiletext]
    mov       %r10,	%r12
    mov       %rdi,	[%rax + %r10*8]
    lea       %rax,	[%rip+cc_decls.sourcefilesizes]
    mov       %r10,	%r12
    movsxd    %rax,	dword ptr[%rax + %r10*4]
    mov       %r13,	%rax
    xor       %eax,	%eax
    mov       %rbx,	%rax
    mov       %rsi,	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.lex_preprocess_only.symtot],	%rax
    mov       [%rbp + cc_lex.lex_preprocess_only.hashtot],	%rax
    call      mnoos.os_clock
    mov       %r14,	%rax
    mov       %rax,	[%rip+cc_lex.lex_preprocess_only.dest]
    mov       [%rip+cc_lex.destcopy],	%rax
    mov       %rcx,	[%rip+cc_lex.lex_preprocess_only.dest]
    call      mlib.gs_init
    mov       [%rip+cc_lex.lxsptr],	%rdi
    mov       %rax,	[%rip+cc_lex.lxsptr]
    mov       [%rip+cc_lex.lxstart],	%rax
    mov       %eax,	1
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+16],	%eax
    mov       %rcx,	1
    call      cc_lex.setfileno
    xor       %eax,	%eax
    mov       [%rip+cc_lex.ifcondlevel],	%rax
    lea       %rcx,	[%rip+L8444]
    mov       %rdx,	1
    call      cc_lex.stacksourcefile
    mov       %al,	56
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L3036:
    call      cc_lex.lexm
    inc       %rbx
    lea       %rcx,	[%rip+cc_decls.nextlx]
    mov       %rdx,	[%rip+cc_lex.lex_preprocess_only.dest]
    xor       %r8d,	%r8d
    call      cc_lex.emittoken
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	57
    jnz       L3036
    mov       %rax,	[%rip+cc_lex.ifcondlevel]
    test      %rax,	%rax
    jz        L3040
    lea       %rcx,	[%rip+L8445]
    call      cc_lex.lxerror
L3040:
    lea       %rax,	[%rip+cc_lex.showtokens]
    test      %rax,	%rax
    jz        L3042
    mov       %rax,	[%rbp + cc_lex.lex_preprocess_only.toconsole]
    test      %rax,	%rax
    jz        L3044
    mov       %rcx,	[%rip+cc_lex.lex_preprocess_only.dest]
    xor       %edx,	%edx
    call      mlib.gs_println
    jmp       L3043
L3044:
    mov       %rcx,	[%rbp + cc_lex.lex_preprocess_only.outfile]
    lea       %rdx,	[%rip+L8446]
    call      fopen
    mov       [%rbp + cc_lex.lex_preprocess_only.f],	%rax
    mov       %rcx,	[%rip+cc_lex.lex_preprocess_only.dest]
    mov       %rdx,	[%rbp + cc_lex.lex_preprocess_only.f]
    call      mlib.gs_println
    mov       %rcx,	[%rbp + cc_lex.lex_preprocess_only.f]
    call      fclose
L3043:
L3042:
#---------------
    add       %rsp,	56
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.lexreadtoken
cc_lex.lexreadtoken:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+23],	%al
    jmp       L3047
L3046:
    inc       qword ptr[%rip+cc_lex.lxsptr]
L3047:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	32
    jz        L3046
    cmp       %rax,	9
    jz        L3046
L3049:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	240
    jae       L3052
    lea       %r10,	[%rip+L3051]
    jmp       [%r10 + %rax*8]
    .data
L3051:
    .quad     L3186
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3171
    .quad     L3172
    .quad     L3052
    .quad     L3190
    .quad     L3180
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3171
    .quad     L3181
    .quad     L3170
    .quad     L3079
    .quad     L3053
    .quad     L3143
    .quad     L3164
    .quad     L3169
    .quad     L3109
    .quad     L3110
    .quad     L3134
    .quad     L3123
    .quad     L3103
    .quad     L3128
    .quad     L3095
    .quad     L3137
    .quad     L3070
    .quad     L3066
    .quad     L3066
    .quad     L3066
    .quad     L3066
    .quad     L3066
    .quad     L3066
    .quad     L3066
    .quad     L3066
    .quad     L3066
    .quad     L3105
    .quad     L3104
    .quad     L3150
    .quad     L3146
    .quad     L3157
    .quad     L3121
    .quad     L3185
    .quad     L3053
    .quad     L3053
    .quad     L3053
    .quad     L3053
    .quad     L3053
    .quad     L3053
    .quad     L3053
    .quad     L3053
    .quad     L3053
    .quad     L3053
    .quad     L3053
    .quad     L3053
    .quad     L3053
    .quad     L3053
    .quad     L3053
    .quad     L3053
    .quad     L3053
    .quad     L3053
    .quad     L3053
    .quad     L3053
    .quad     L3053
    .quad     L3053
    .quad     L3053
    .quad     L3053
    .quad     L3053
    .quad     L3053
    .quad     L3111
    .quad     L3083
    .quad     L3112
    .quad     L3118
    .quad     L3053
    .quad     L3052
    .quad     L3053
    .quad     L3053
    .quad     L3053
    .quad     L3053
    .quad     L3053
    .quad     L3053
    .quad     L3053
    .quad     L3053
    .quad     L3053
    .quad     L3053
    .quad     L3053
    .quad     L3053
    .quad     L3053
    .quad     L3053
    .quad     L3053
    .quad     L3053
    .quad     L3053
    .quad     L3053
    .quad     L3053
    .quad     L3053
    .quad     L3053
    .quad     L3053
    .quad     L3053
    .quad     L3053
    .quad     L3053
    .quad     L3053
    .quad     L3093
    .quad     L3113
    .quad     L3094
    .quad     L3122
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3052
    .quad     L3191
    .text
L3053:
#cc_lex.lexreadtoken.doname:
L3054:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	1
    mov       [%rip+cc_lex.lxsvalue],	%rax
    mov       %rax,	[%rip+cc_lex.lxsvalue]
    movzx     %rax,	byte ptr[%rax]
    mov       %rbx,	%rax
    jmp       L3056
L3055:
    mov       %rax,	%rbx
    shl       %rax,	4
    sub       %rax,	%rbx
    add       %rax,	%rdi
    mov       %rbx,	%rax
L3056:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    mov       %rdi,	%rax
    lea       %r10,	[%rip+cc_lex.alphamap]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jnz       L3055
    dec       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	67
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	[%rip+cc_lex.lxsvalue]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
    mov       %rax,	%rdi
    cmp       %rax,	39
    jz        L3059
    cmp       %rax,	34
    jnz       L3060
L3059:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+24]
    cmp       %rax,	1
    jnz       L3062
    mov       %rax,	[%rip+cc_lex.lxsvalue]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	108
    jz        L3064
    cmp       %rax,	76
    jz        L3064
    cmp       %rax,	117
    jz        L3064
    cmp       %rax,	85
    jnz       L3065
L3064:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      cc_lex.lxreadstring
    jmp       L3045
L3065:
L3063:
L3062:
L3060:
L3058:
    mov       %rax,	%rbx
    shl       %rax,	5
    sub       %rax,	%rbx
    mov       [%rip+cc_lex.lxhashvalue],	%rax
    call      cc_lex.lookup
    jmp       L3045
L3066:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	32
    jz        L3068
    cmp       %rax,	41
    jz        L3068
    cmp       %rax,	13
    jz        L3068
    cmp       %rax,	44
    jz        L3068
    cmp       %rax,	59
    jnz       L3069
L3068:
    mov       %al,	59
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    mov       %al,	3
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	1
    movzx     %rax,	byte ptr[%rax]
    sub       %rax,	48
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10],	%rax
    mov       %eax,	1
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	1
    sub       %rax,	[%rip+cc_lex.lxstart]
    mov       %rcx,	%rax
    call      cc_lex.setnumberoffset
    jmp       L3067
L3069:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	1
    mov       %rcx,	%rax
    call      cc_lex.readdecimal
L3067:
    jmp       L3045
L3070:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    sub       %rax,	10
    cmp       %rax,	116
    jae       L3073
    lea       %r10,	[%rip+L3072]
    jmp       [%r10 + %rax*8]
    .data
L3072:
    .quad     L3078
    .quad     L3073
    .quad     L3073
    .quad     L3078
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3078
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3078
    .quad     L3073
    .quad     L3073
    .quad     L3078
    .quad     L3073
    .quad     L3073
    .quad     L3078
    .quad     L3073
    .quad     L3076
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3078
    .quad     L3078
    .quad     L3073
    .quad     L3078
    .quad     L3073
    .quad     L3078
    .quad     L3073
    .quad     L3073
    .quad     L3075
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3077
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3077
    .quad     L3073
    .quad     L3073
    .quad     L3074
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3078
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3075
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3077
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3077
    .quad     L3073
    .quad     L3073
    .quad     L3074
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3073
    .quad     L3078
    .text
L3074:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	2
    mov       %rcx,	%rax
    call      cc_lex.readhex
    jmp       L3045
L3075:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	2
    mov       %rcx,	%rax
    call      cc_lex.readbinary
    jmp       L3045
L3076:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	1
    mov       %r10,	[%rip+cc_lex.lxsptr]
    sub       %r10,	1
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    mov       %r8,	1
    mov       %r9,	10
    call      cc_lex.readrealnumber
    jmp       L3045
L3077:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	1
    mov       %rcx,	%rax
    call      cc_lex.readdecimal
    jmp       L3045
L3078:
    mov       %al,	59
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    mov       %al,	3
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10],	%rax
    mov       %eax,	1
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	1
    sub       %rax,	[%rip+cc_lex.lxstart]
    mov       %rcx,	%rax
    call      cc_lex.setnumberoffset
    jmp       L3045
L3073:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	1
    mov       %rcx,	%rax
    call      cc_lex.readoctal
    jmp       L3045
L3071:
    jmp       L3049
L3079:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	56
    jnz       L3081
    mov       %al,	4
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3045
L3081:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	35
    jnz       L3082
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	7
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3045
L3082:
    mov       %al,	5
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3045
L3080:
    jmp       L3049
L3083:
L3084:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	13
    jz        L3086
    cmp       %rax,	10
    jz        L3086
    cmp       %rax,	32
    jz        L3087
    cmp       %rax,	9
    jz        L3087
    jmp       L3088
L3086:
    jmp       L3085
L3087:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L3084
L3088:
    mov       %al,	22
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3045
L3085:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	1
    mov       %r10b,	32
    mov       [%rax],	%r10b
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %rax,	[%rax+16]
    inc       dword ptr[%rax]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	13
    jz        L3090
    cmp       %rax,	10
    jz        L3091
    jmp       L3092
L3090:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %r10b,	32
    mov       [%rax],	%r10b
    jmp       L3089
L3091:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %r10b,	32
    mov       [%rax],	%r10b
L3092:
L3089:
    jmp       L3049
L3093:
    mov       %al,	17
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3045
L3094:
    mov       %al,	18
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3045
L3095:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    sub       %rax,	46
    cmp       %rax,	12
    jae       L3098
    lea       %r10,	[%rip+L3097]
    jmp       [%r10 + %rax*8]
    .data
L3097:
    .quad     L3099
    .quad     L3098
    .quad     L3102
    .quad     L3102
    .quad     L3102
    .quad     L3102
    .quad     L3102
    .quad     L3102
    .quad     L3102
    .quad     L3102
    .quad     L3102
    .quad     L3102
    .text
L3099:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	46
    jnz       L3101
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	21
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3100
L3101:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	2
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3045
L3100:
    jmp       L3045
L3102:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rcx,	[%rip+cc_lex.lxsptr]
    mov       %rdx,	[%rip+cc_lex.lxsptr]
    xor       %r8d,	%r8d
    mov       %r9,	10
    call      cc_lex.readrealnumber
    jmp       L3045
L3098:
    mov       %al,	2
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3045
L3096:
    jmp       L3049
L3103:
    mov       %al,	8
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3045
L3104:
    mov       %al,	9
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3045
L3105:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	61
    jnz       L3108
L3107:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	11
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3106
L3108:
    mov       %al,	10
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L3106:
    jmp       L3045
L3109:
    mov       %al,	13
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3045
L3110:
    mov       %al,	14
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3045
L3111:
    mov       %al,	15
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3045
L3112:
    mov       %al,	16
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3045
L3113:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	124
    jz        L3115
    cmp       %rax,	61
    jz        L3116
    jmp       L3117
L3115:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	31
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3114
L3116:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	51
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3114
L3117:
    mov       %al,	28
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L3114:
    jmp       L3045
L3118:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	61
    jnz       L3120
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	53
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3119
L3120:
    mov       %al,	30
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L3119:
    jmp       L3045
L3121:
    mov       %al,	19
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3045
L3122:
    mov       %al,	35
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3045
L3123:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	43
    jz        L3125
    cmp       %rax,	61
    jz        L3126
    jmp       L3127
L3125:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	37
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3124
L3126:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	46
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3124
L3127:
    mov       %al,	23
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L3124:
    jmp       L3045
L3128:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	45
    jz        L3130
    cmp       %rax,	62
    jz        L3131
    cmp       %rax,	61
    jz        L3132
    jmp       L3133
L3130:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	38
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3129
L3131:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	3
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3129
L3132:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	47
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3129
L3133:
    mov       %al,	24
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L3129:
    jmp       L3045
L3134:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	61
    jnz       L3136
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	48
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3135
L3136:
    mov       %al,	25
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L3135:
    jmp       L3045
L3137:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	47
    jz        L3139
    cmp       %rax,	42
    jz        L3140
    cmp       %rax,	61
    jz        L3141
    jmp       L3142
L3139:
    call      cc_lex.readlinecomment
    mov       %al,	56
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
    jmp       L3045
L3140:
    call      cc_lex.readblockcomment
    jmp       L3138
L3141:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	49
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3045
L3142:
    mov       %al,	26
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3045
L3138:
    jmp       L3049
L3143:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	61
    jnz       L3145
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	50
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3144
L3145:
    mov       %al,	27
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L3144:
    jmp       L3045
L3146:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	61
    jnz       L3149
L3148:
    mov       %al,	40
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    inc       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L3147
L3149:
    mov       %al,	11
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L3147:
    jmp       L3045
L3150:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	61
    jz        L3152
    cmp       %rax,	60
    jz        L3153
    jmp       L3154
L3152:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	43
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3151
L3153:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	61
    jnz       L3156
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	54
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3155
L3156:
    mov       %al,	33
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L3155:
    jmp       L3151
L3154:
    mov       %al,	42
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L3151:
    jmp       L3045
L3157:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	61
    jz        L3159
    cmp       %rax,	62
    jz        L3160
    jmp       L3161
L3159:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	44
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3158
L3160:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	61
    jnz       L3163
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	55
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3162
L3163:
    mov       %al,	34
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L3162:
    jmp       L3158
L3161:
    mov       %al,	45
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L3158:
    jmp       L3045
L3164:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	38
    jz        L3166
    cmp       %rax,	61
    jz        L3167
    jmp       L3168
L3166:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	32
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3165
L3167:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	52
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3165
L3168:
    mov       %al,	29
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L3165:
    jmp       L3045
L3169:
    mov       %rcx,	39
    xor       %edx,	%edx
    call      cc_lex.lxreadstring
    jmp       L3045
L3170:
    mov       %rcx,	34
    xor       %edx,	%edx
    call      cc_lex.lxreadstring
    jmp       L3045
L3171:
    jmp       L3049
L3172:
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %rax,	[%rax+16]
    inc       dword ptr[%rax]
    mov       %al,	56
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
    mov       %rax,	[%rip+cc_lex.dowhitespace]
    test      %rax,	%rax
    jz        L3174
    mov       %rax,	[%rip+cc_lex.lxsptr]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10],	%rax
L3175:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    sub       %rax,	9
    cmp       %rax,	24
    jae       L3178
    lea       %r10,	[%rip+L3177]
    jmp       [%r10 + %rax*8]
    .data
L3177:
    .quad     L3179
    .quad     L3178
    .quad     L3178
    .quad     L3178
    .quad     L3178
    .quad     L3178
    .quad     L3178
    .quad     L3178
    .quad     L3178
    .quad     L3178
    .quad     L3178
    .quad     L3178
    .quad     L3178
    .quad     L3178
    .quad     L3178
    .quad     L3178
    .quad     L3178
    .quad     L3178
    .quad     L3178
    .quad     L3178
    .quad     L3178
    .quad     L3178
    .quad     L3178
    .quad     L3179
    .text
L3179:
    jmp       L3175
L3178:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L3176
L3176:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    mov       %r10,	[%rip+cc_lex.lxsptr]
    sub       %r10,	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       [%rax+24],	%r10d
L3174:
    jmp       L3045
L3180:
    jmp       L3049
L3181:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	61
    jnz       L3184
L3183:
    mov       %al,	41
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    inc       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L3182
L3184:
    mov       %al,	36
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L3182:
    jmp       L3045
L3185:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8447]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %eax,	[%rax+16]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+20]
    lea       %r10,	[%rip+cc_decls.sourcefilenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+cc_lex.lx_stackindex]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L3049
L3186:
#cc_lex.lexreadtoken.doeof:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lx_stackindex]
    test      %rax,	%rax
    jz        L3189
    call      cc_lex.unstacksourcefile
    mov       %al,	56
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3188
L3189:
    mov       %al,	57
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L3188:
    jmp       L3045
L3190:
    jmp       L3049
L3191:
    add       qword ptr[%rip+cc_lex.lxsptr],	2
    jmp       L3049
L3052:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	1
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	128
    jl        L3193
    cmp       %rax,	255
    jle       L3054
L3193:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8448]
    call      msys.m$print_str_nf
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	1
    movzx     %rax,	byte ptr[%rax]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.m$print_c8
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	1
    movzx     %rax,	byte ptr[%rax]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    mov       %rcx,	[%rip+cc_lex.lx_stackindex]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8448]
    call      cc_lex.lxerror
    mov       %al,	1
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3045
L3045:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.readrealnumber
cc_lex.readrealnumber:
#?>>
    .set cc_lex.readrealnumber.intlen, 104
    .set cc_lex.readrealnumber.base, 112
    .set cc_lex.readrealnumber.badexpon, -8
    .set cc_lex.readrealnumber.realstr, -520
    .set cc_lex.readrealnumber.rs, -528
    .set cc_lex.readrealnumber.expstr, -560
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    movq      %rax,	%XMM13
    push      %rax
    movq      %rax,	%XMM14
    push      %rax
    movq      %rax,	%XMM15
    push      %rax
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	600
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       [%rbp+104],	%r8
    mov       [%rbp+112],	%r9
#---------------
    mov       %rax,	[%rbp + cc_lex.readrealnumber.base]
    cmp       %rax,	10
    jz        L3196
    mov       %rcx,	%r13
    mov       %rdx,	%r14
    mov       %r8,	[%rbp + cc_lex.readrealnumber.intlen]
    mov       %r9,	[%rbp + cc_lex.readrealnumber.base]
    call      cc_lex.old_readrealnumber
    jmp       L3194
L3196:
    xor       %rdi,	%rdi
    xor       %eax,	%eax
    mov       %rbx,	%rax
    xor       %rsi,	%rsi
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	46
    jnz       L3198
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rdi,	[%rip+cc_lex.lxsptr]
    mov       %rcx,	[%rbp + cc_lex.readrealnumber.base]
    call      cc_lex.scannumber
    sub       %rax,	%rdi
    mov       %rbx,	%rax
L3198:
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.readrealnumber.badexpon],	%rax
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	101
    jz        L3200
    cmp       %rax,	69
    jz        L3200
    cmp       %rax,	112
    jz        L3201
    cmp       %rax,	80
    jz        L3201
    jmp       L3202
L3200:
    mov       %rax,	[%rbp + cc_lex.readrealnumber.base]
    cmp       %rax,	16
    jz        L3204
    inc       qword ptr[%rip+cc_lex.lxsptr]
    lea       %rcx,	[%rbp + cc_lex.readrealnumber.badexpon]
    call      cc_lex.readexponent
    mov       %rsi,	%rax
L3204:
    jmp       L3199
L3201:
    mov       %rax,	[%rbp + cc_lex.readrealnumber.base]
    cmp       %rax,	16
    jnz       L3206
    inc       qword ptr[%rip+cc_lex.lxsptr]
    lea       %rcx,	[%rbp + cc_lex.readrealnumber.badexpon]
    call      cc_lex.readexponent
    mov       %rsi,	%rax
L3206:
L3202:
L3199:
    mov       %rax,	[%rbp + cc_lex.readrealnumber.badexpon]
    test      %rax,	%rax
    jz        L3208
    dec       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rcx,	%r13
    call      cc_lex.readalphanumeric
    jmp       L3194
L3208:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	102
    jz        L3210
    cmp       %rax,	70
    jz        L3210
    cmp       %rax,	108
    jz        L3210
    cmp       %rax,	76
    jnz       L3211
L3210:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L3209
L3211:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    lea       %r10,	[%rip+cc_lex.alphamap]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L3213
    mov       %rcx,	%r13
    call      cc_lex.readalphanumeric
    jmp       L3194
L3213:
L3209:
    mov       %rax,	[%rbp + cc_lex.readrealnumber.base]
    cmp       %rax,	16
    jnz       L3215
    mov       %al,	48
    mov       [%rbp + cc_lex.readrealnumber.realstr],	%al
    mov       %al,	120
    mov       [%rbp + cc_lex.readrealnumber.realstr+1],	%al
    lea       %rax,	[%rbp + cc_lex.readrealnumber.realstr+2]
    mov       [%rbp + cc_lex.readrealnumber.rs],	%rax
    mov       %r12,	2
    jmp       L3214
L3215:
    lea       %rax,	[%rbp + cc_lex.readrealnumber.realstr]
    mov       [%rbp + cc_lex.readrealnumber.rs],	%rax
    xor       %r12,	%r12
L3214:
    mov       %rax,	[%rbp + cc_lex.readrealnumber.intlen]
    add       %rax,	%rbx
    cmp       %rax,	500
    jle       L3217
    lea       %rcx,	[%rip+L8449]
    call      cc_lex.lxerror
L3217:
    mov       %rax,	[%rbp + cc_lex.readrealnumber.intlen]
    test      %rax,	%rax
    jz        L3219
    mov       %rcx,	[%rbp + cc_lex.readrealnumber.rs]
    mov       %rdx,	%r14
    mov       %r8,	[%rbp + cc_lex.readrealnumber.intlen]
    call      memcpy
L3219:
    test      %rbx,	%rbx
    jz        L3221
    mov       %rax,	[%rbp + cc_lex.readrealnumber.rs]
    mov       %r10,	[%rbp + cc_lex.readrealnumber.intlen]
    lea       %rax,	[%rax + %r10]
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      memcpy
L3221:
    mov       %rax,	[%rbp + cc_lex.readrealnumber.base]
    cvtsi2sd  %XMM4,	%rax
    movq      %XMM15,	%XMM4
    movq      %XMM13,	%XMM4
    mov       %rax,	[%rbp + cc_lex.readrealnumber.base]
    cmp       %rax,	10
    jnz       L3223
    mov       %rax,	%rbx
    sub       %rsi,	%rax
    jmp       L3222
L3223:
    mov       %rax,	%rbx
    shl       %rax,	2
    sub       %rsi,	%rax
    movq      %XMM4,	[%rip+L8450]
    movq      %XMM13,	%XMM4
L3222:
    mov       %rax,	%r12
    add       %rax,	[%rbp + cc_lex.readrealnumber.intlen]
    add       %rax,	%rbx
    xor       %r10d,	%r10d
    mov       [%rbp + %rax + cc_lex.readrealnumber.realstr],	%r10b
    lea       %rcx,	[%rbp + cc_lex.readrealnumber.expstr]
    call      msys.m$print_startstr
    mov       %rax,	[%rbp + cc_lex.readrealnumber.base]
    cmp       %rax,	10
    jnz       L3225
    lea       %rax,	[%rip+L8451]
    jmp       L3224
L3225:
    lea       %rax,	[%rip+L8452]
L3224:
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       %rcx,	%rsi
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + cc_lex.readrealnumber.realstr]
    lea       %rdx,	[%rbp + cc_lex.readrealnumber.expstr]
    call      strcat
    mov       %rax,	[%rbp + cc_lex.readrealnumber.base]
    cmp       %rax,	10
    jz        L3227
    lea       %rcx,	[%rip+L8453]
    call      cc_lex.lxerror
L3227:
    lea       %rcx,	[%rbp + cc_lex.readrealnumber.realstr]
    xor       %edx,	%edx
    call      strtod
    movq      %XMM14,	%XMM0
    mov       %al,	60
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    mov       %al,	11
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    movq      %XMM4,	%XMM14
    lea       %rax,	[%rip+cc_decls.nextlx]
    movq      [%rax],	%XMM4
    mov       %rax,	%r14
    sub       %rax,	[%rip+cc_lex.lxstart]
    mov       %rcx,	%rax
    call      cc_lex.setnumberoffset
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	%r14
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
L3194:
#---------------
    add       %rsp,	600
    pop       %rbp
    pop       %rcx
    movq      %XMM15,	%rcx
    pop       %rcx
    movq      %XMM14,	%rcx
    pop       %rcx
    movq      %XMM13,	%rcx
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.readexponent
cc_lex.readexponent:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    sub       %rsp,	48
    mov       %r15,	%rcx
#---------------
    xor       %rsi,	%rsi
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	43
    jz        L3230
    cmp       %rax,	45
    jz        L3231
    jmp       L3232
L3230:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L3229
L3231:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rsi,	1
L3232:
L3229:
    mov       %rdi,	[%rip+cc_lex.lxsptr]
    mov       %rcx,	10
    call      cc_lex.scannumber
    sub       %rax,	%rdi
    mov       %rbx,	%rax
    test      %rbx,	%rbx
    jnz       L3234
    mov       %rax,	1
    mov       [%r15],	%rax
    xor       %eax,	%eax
    jmp       L3228
L3234:
    xor       %r13,	%r13
    mov       %rax,	%rbx
    mov       %r14,	%rax
    cmp       %r14,	0
    jle       L3237
L3235:
    mov       %rax,	%rdi
    inc       %rdi
    movzx     %rax,	byte ptr[%rax]
    mov       %r12,	%rax
    mov       %rax,	%r13
    shl       %rax,	1
    lea       %rax,	[%rax + %rax*4]
    add       %rax,	%r12
    sub       %rax,	48
    mov       %r13,	%rax
    dec       %r14
    jnz       L3235
L3237:
    test      %rsi,	%rsi
    jz        L3239
    mov       %rax,	%r13
    neg       %rax
    jmp       L3238
L3239:
    mov       %rax,	%r13
L3238:
L3228:
#---------------
    add       %rsp,	48
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.lxerror
cc_lex.lxerror:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8454]
    call      msys.m$print_str_nf
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L8455]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    call      cc_lex.getfileno
    lea       %r10,	[%rip+cc_decls.sourcefilepaths]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L8456]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %eax,	[%rax+16]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	11
    call      exit
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lex.printsymbol
cc_lex.printsymbol:
#?>>
    .set cc_lex.printsymbol.l, -32
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	72
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	%rdi
    lea       %r10,	[%rbp + cc_lex.printsymbol.l]
    mov       %r11,	[%rax]
    mov       [%r10],	%r11
    mov       %r11,	[%rax+8]
    mov       [%r10+8],	%r11
    mov       %r11,	[%rax+16]
    mov       [%r10+16],	%r11
    mov       %r11,	[%rax+24]
    mov       [%r10+24],	%r11
    movzx     %rax,	byte ptr[%rbp + cc_lex.printsymbol.l+21]
    lea       %r10,	[%rip+cc_tables.symbolnames]
    mov       %r10,	[%r10 + %rax*8-8]
    lea       %rcx,	[%rip+L8457]
    mov       %rdx,	%r10
    call      printf
    movzx     %rax,	byte ptr[%rbp + cc_lex.printsymbol.l+21]
    cmp       %rax,	67
    jz        L3243
    cmp       %rax,	59
    jz        L3244
    cmp       %rax,	60
    jz        L3245
    cmp       %rax,	63
    jz        L3246
    cmp       %rax,	61
    jz        L3247
    jmp       L3248
L3243:
    mov       %rax,	[%rbp + cc_lex.printsymbol.l]
    movzx     %rax,	byte ptr[%rax+106]
    mov       %r10,	[%rbp + cc_lex.printsymbol.l]
    mov       %r10,	[%r10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      cc_lex.printstrn
    jmp       L3242
L3244:
    call      msys.m$print_startcon
    mov       %rcx,	[%rbp + cc_lex.printsymbol.l]
    call      msys.m$print_i64_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L8458]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      cc_lex.shownumberstr
    jmp       L3242
L3245:
    call      msys.m$print_startcon
    movq      %XMM4,	[%rbp + cc_lex.printsymbol.l]
    movq      %XMM0,	%XMM4
    xor       %edx,	%edx
    call      msys.m$print_r64
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L8458]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      cc_lex.shownumberstr
    jmp       L3242
L3246:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8459]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    movsxd    %rax,	dword ptr[%rbp + cc_lex.printsymbol.l+24]
    mov       %r10,	[%rbp + cc_lex.printsymbol.l]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      cc_lex.printstrn
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8459]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L3242
L3247:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8460]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    movsxd    %rax,	dword ptr[%rbp + cc_lex.printsymbol.l+24]
    mov       %r10,	[%rbp + cc_lex.printsymbol.l]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      cc_lex.printstrn
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8460]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L3242
L3248:
    mov       %al,	[%rbp + cc_lex.printsymbol.l+22]
    test      %al,	%al
    jz        L3250
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8461]
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rbp + cc_lex.printsymbol.l+22]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
L3250:
L3242:
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
#---------------
    add       %rsp,	72
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc cc_lex.lexsetup
cc_lex.lexsetup:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    call      cc_lex.inithashtable
    call      cc_lex.fillhashtable
    xor       %rdi,	%rdi
L3252:
    lea       %rax,	[%rdi-36]
    cmp       %rax,	220
    jae       L3257
    lea       %r10,	[%rip+L3256]
    jmp       [%r10 + %rax*8]
    .data
L3256:
    .quad     L3258
    .quad     L3257
    .quad     L3257
    .quad     L3257
    .quad     L3257
    .quad     L3257
    .quad     L3257
    .quad     L3257
    .quad     L3257
    .quad     L3257
    .quad     L3257
    .quad     L3257
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3257
    .quad     L3257
    .quad     L3257
    .quad     L3257
    .quad     L3257
    .quad     L3257
    .quad     L3257
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3257
    .quad     L3257
    .quad     L3257
    .quad     L3257
    .quad     L3258
    .quad     L3257
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3257
    .quad     L3257
    .quad     L3257
    .quad     L3257
    .quad     L3257
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .quad     L3258
    .text
L3258:
    mov       %al,	1
    lea       %r10,	[%rip+cc_lex.alphamap]
    mov       %r11,	%rdi
    mov       [%r10 + %r11],	%al
L3257:
L3255:
    lea       %rax,	[%rdi-48]
    cmp       %rax,	10
    jae       L3261
    lea       %r10,	[%rip+L3260]
    jmp       [%r10 + %rax*8]
    .data
L3260:
    .quad     L3262
    .quad     L3262
    .quad     L3262
    .quad     L3262
    .quad     L3262
    .quad     L3262
    .quad     L3262
    .quad     L3262
    .quad     L3262
    .quad     L3262
    .text
L3262:
    mov       %al,	1
    lea       %r10,	[%rip+cc_lex.digitmap]
    mov       %r11,	%rdi
    mov       [%r10 + %r11],	%al
L3261:
L3259:
    mov       %al,	1
    lea       %r10,	[%rip+cc_lex.commentmap]
    mov       %r11,	%rdi
    mov       [%r10 + %r11],	%al
    mov       %al,	1
    lea       %r10,	[%rip+cc_lex.linecommentmap]
    mov       %r11,	%rdi
    mov       [%r10 + %r11],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_lex.spacemap]
    mov       %r11,	%rdi
    mov       [%r10 + %r11],	%al
    inc       %rdi
    cmp       %rdi,	255
    jle       L3252
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_lex.commentmap]
    mov       [%r10+42],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_lex.commentmap]
    mov       [%r10],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_lex.commentmap]
    mov       [%r10+10],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_lex.linecommentmap]
    mov       [%r10],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_lex.linecommentmap]
    mov       [%r10+92],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_lex.linecommentmap]
    mov       [%r10+10],	%al
    mov       %al,	1
    lea       %r10,	[%rip+cc_lex.spacemap]
    mov       [%r10+32],	%al
    mov       %al,	1
    lea       %r10,	[%rip+cc_lex.spacemap]
    mov       [%r10+9],	%al
    mov       %al,	56
    lea       %r10,	[%rip+cc_lex.normaltkx]
    mov       [%r10+21],	%al
    xor       %eax,	%eax
    mov       [%rip+cc_lex.npastedtokens],	%rax
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lex.printstrn
cc_lex.printstrn:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    test      %rbx,	%rbx
    jz        L3265
    test      %rsi,	%rsi
    jnz       L3267
    call      msys.m$print_startcon
    mov       %rcx,	%rbx
    lea       %rdx,	[%rip+L8462]
    call      msys.m$print_i64
    call      msys.m$print_nogap
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8463]
    call      msys.m$print_str
    call      msys.m$print_end
    jmp       L3266
L3267:
    mov       %rcx,	%rsi
    call      msys.m$print_startfile
    mov       %rcx,	%rbx
    lea       %rdx,	[%rip+L8464]
    call      msys.m$print_i64
    call      msys.m$print_nogap
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8465]
    call      msys.m$print_str
    call      msys.m$print_end
L3266:
L3265:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.scannumber
cc_lex.scannumber:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    mov       %rdi,	[%rip+cc_lex.lxsptr]
L3269:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    mov       %rbx,	%rax
    sub       %rax,	39
    cmp       %rax,	64
    jae       L3272
    lea       %r10,	[%rip+L3271]
    jmp       [%r10 + %rax*8]
    .data
L3271:
    .quad     L3279
    .quad     L3272
    .quad     L3272
    .quad     L3272
    .quad     L3272
    .quad     L3272
    .quad     L3272
    .quad     L3272
    .quad     L3272
    .quad     L3273
    .quad     L3273
    .quad     L3273
    .quad     L3273
    .quad     L3273
    .quad     L3273
    .quad     L3273
    .quad     L3273
    .quad     L3273
    .quad     L3273
    .quad     L3272
    .quad     L3272
    .quad     L3272
    .quad     L3272
    .quad     L3272
    .quad     L3272
    .quad     L3272
    .quad     L3276
    .quad     L3276
    .quad     L3276
    .quad     L3276
    .quad     L3276
    .quad     L3276
    .quad     L3272
    .quad     L3272
    .quad     L3272
    .quad     L3272
    .quad     L3272
    .quad     L3272
    .quad     L3272
    .quad     L3272
    .quad     L3272
    .quad     L3272
    .quad     L3272
    .quad     L3272
    .quad     L3272
    .quad     L3272
    .quad     L3272
    .quad     L3272
    .quad     L3272
    .quad     L3272
    .quad     L3272
    .quad     L3272
    .quad     L3272
    .quad     L3272
    .quad     L3272
    .quad     L3272
    .quad     L3279
    .quad     L3279
    .quad     L3276
    .quad     L3276
    .quad     L3276
    .quad     L3276
    .quad     L3276
    .quad     L3276
    .text
L3273:
    mov       %rax,	%rdi
    inc       %rdi
    mov       %r10b,	%bl
    mov       [%rax],	%r10b
    mov       %rax,	48
    add       %rax,	%rsi
    mov       %r10,	%rbx
    cmp       %r10,	%rax
    jl        L3275
    lea       %rcx,	[%rip+L8466]
    call      cc_lex.lxerror
L3275:
    jmp       L3269
L3276:
    cmp       %rsi,	16
    jnz       L3278
    mov       %rax,	%rdi
    inc       %rdi
    mov       %r10b,	%bl
    mov       [%rax],	%r10b
    jmp       L3277
L3278:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L3270
L3277:
    jmp       L3269
L3279:
    jmp       L3269
L3272:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L3270
L3270:
    mov       %rax,	%rdi
L3268:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.lookup
cc_lex.lookup:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
#cc_lex.lookup.retry:
L3281:
    mov       %rax,	[%rip+cc_lex.lxhashvalue]
    and       %rax,	[%rip+cc_decls.hstmask]
    mov       %rdi,	%rax
    xor       %rbx,	%rbx
L3282:
    mov       %rax,	[%rip+cc_decls.hashtable]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10],	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    movzx     %rax,	byte ptr[%rax+106]
    mov       %rsi,	%rax
    test      %rsi,	%rsi
    jnz       L3285
    jmp       L3283
L3285:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+24]
    mov       %r10,	%rsi
    cmp       %r10,	%rax
    jnz       L3287
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    mov       %rdx,	[%rip+cc_lex.lxsvalue]
    mov       %r8,	%rsi
    call      memcmp
    movsxd    %r10,	%eax
    test      %r10,	%r10
    jnz       L3289
    mov       %rax,	1
    jmp       L3280
L3289:
L3287:
    inc       %rdi
    cmp       %rdi,	[%rip+cc_decls.hstsize]
    jl        L3291
    test      %rbx,	%rbx
    jz        L3293
    lea       %rcx,	[%rip+L8467]
    call      mlib.abortprogram
L3293:
    mov       %rbx,	1
    xor       %rdi,	%rdi
L3291:
    jmp       L3282
L3283:
    mov       %rax,	[%rip+cc_lex.nhstsymbols]
    cmp       %rax,	[%rip+cc_lex.hstthreshold]
    jl        L3295
    call      cc_lex.newhashtable
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+24]
    mov       %rcx,	[%rip+cc_lex.lxsvalue]
    mov       %rdx,	%rax
    call      cc_lex.gethashvalue
    mov       [%rip+cc_lex.lxhashvalue],	%rax
    jmp       L3281
L3295:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+24]
    mov       %rcx,	[%rip+cc_lex.lxsvalue]
    mov       %rdx,	%rax
    call      mlib.pcm_copyheapstringn
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       %r10,	[%r10]
    mov       [%r10],	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %eax,	[%rax+24]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       %r10,	[%r10]
    mov       [%r10+106],	%al
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    mov       %r10b,	67
    mov       [%rax+107],	%r10b
    inc       qword ptr[%rip+cc_lex.nhstsymbols]
    xor       %eax,	%eax
L3280:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.gethashvalue
cc_lex.gethashvalue:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    cmp       %r12,	-1
    jnz       L3298
    mov       %rcx,	%rsi
    call      strlen
    mov       %r12,	%rax
L3298:
    xor       %rdi,	%rdi
    mov       %rax,	%r12
    mov       %rbx,	%rax
    cmp       %rbx,	0
    jle       L3301
L3299:
    mov       %rax,	%rdi
    shl       %rax,	4
    sub       %rax,	%rdi
    mov       %r10,	%rsi
    inc       %rsi
    movzx     %r10,	byte ptr[%r10]
    add       %rax,	%r10
    mov       %rdi,	%rax
    dec       %rbx
    jnz       L3299
L3301:
    mov       %rax,	%rdi
    shl       %rax,	5
    sub       %rax,	%rdi
L3296:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.inithashtable
cc_lex.inithashtable:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rax,	[%rip+cc_decls.hstsize]
    shl       %rax,	3
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       [%rip+cc_decls.hashtable],	%rax
    mov       %rax,	[%rip+cc_decls.hstsize]
    dec       %rax
    mov       [%rip+cc_decls.hstmask],	%rax
    xor       %rdi,	%rdi
    mov       %rax,	[%rip+cc_decls.hstmask]
    cmp       %rax,	0
    jl        L3305
L3303:
    mov       %rcx,	128
    call      mlib.pcm_allocz
    mov       %r10,	[%rip+cc_decls.hashtable]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*8],	%rax
    inc       %rdi
    cmp       %rdi,	[%rip+cc_decls.hstmask]
    jle       L3303
L3305:
    xor       %eax,	%eax
    mov       [%rip+cc_lex.nhstsymbols],	%rax
    mov       %rax,	6
    mov       %r10,	[%rip+cc_decls.hstsize]
    imul      %rax,	%r10
    mov       %r10,	10
    cqo       
    idiv      %r10
    mov       [%rip+cc_lex.hstthreshold],	%rax
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lex.fillhashtable
cc_lex.fillhashtable:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
    mov       %rdi,	1
    mov       %rbx,	64
    cmp       %rbx,	1
    jl        L3309
L3307:
    lea       %rax,	[%rip+cc_tables.stnames]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    mov       [%rip+cc_lex.lxsvalue],	%rax
    lea       %rax,	[%rip+cc_tables.stsymbols]
    mov       %r10,	%rdi
    movsxd    %rax,	dword ptr[%rax + %r10*4-4]
    cmp       %rax,	68
    jnz       L3311
    mov       %rcx,	[%rip+cc_lex.lxsvalue]
    call      mlib.pcm_copyheapstring
    mov       [%rip+cc_lex.lxsvalue],	%rax
L3311:
    mov       %rcx,	[%rip+cc_lex.lxsvalue]
    call      strlen
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+24]
    mov       %rcx,	[%rip+cc_lex.lxsvalue]
    mov       %rdx,	%rax
    call      cc_lex.gethashvalue
    mov       [%rip+cc_lex.lxhashvalue],	%rax
    call      cc_lex.lookup
    test      %rax,	%rax
    jz        L3313
    call      msys.m$print_startcon
    lea       %rax,	[%rip+cc_tables.stnames]
    mov       %r10,	%rdi
    mov       %rcx,	[%rax + %r10*8-8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8468]
    call      mlib.abortprogram
L3313:
    lea       %rax,	[%rip+cc_tables.stsymbols]
    mov       %r10,	%rdi
    mov       %eax,	[%rax + %r10*4-4]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       %r10,	[%r10]
    mov       [%r10+107],	%al
    lea       %rax,	[%rip+cc_tables.stsubcodes]
    mov       %r10,	%rdi
    mov       %eax,	[%rax + %r10*4-4]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       %r10,	[%r10]
    mov       [%r10+100],	%ax
    inc       %rdi
    cmp       %rdi,	%rbx
    jle       L3307
L3309:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.dolexdirective
cc_lex.dolexdirective:
#?>>
    .set cc_lex.dolexdirective.dir, -8
    .set cc_lex.dolexdirective.length, -16
    .set cc_lex.dolexdirective.allowmacros, -24
    .set cc_lex.dolexdirective.filename, -328
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	360
#---------------
    mov       %rsi,	[%rip+cc_lex.lxsptr]
    call      cc_lex.getlexdirective
    mov       [%rbp + cc_lex.dolexdirective.dir],	%rax
    mov       %rax,	[%rbp + cc_lex.dolexdirective.dir]
    test      %rax,	%rax
    jnz       L3316
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	%rsi
    mov       %rcx,	%rsi
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      cc_lex.printstrn
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8469]
    call      cc_lex.lxerror
L3316:
    mov       %rax,	[%rbp + cc_lex.dolexdirective.dir]
    cmp       %rax,	7
    jz        L3318
    cmp       %rax,	1
    jz        L3319
    cmp       %rax,	10
    jz        L3320
    cmp       %rax,	8
    jz        L3321
    cmp       %rax,	9
    jz        L3322
    cmp       %rax,	3
    jz        L3323
    cmp       %rax,	4
    jz        L3324
    cmp       %rax,	5
    jz        L3324
    cmp       %rax,	6
    jz        L3325
    cmp       %rax,	13
    jz        L3326
    cmp       %rax,	14
    jz        L3327
    cmp       %rax,	11
    jz        L3328
    cmp       %rax,	15
    jz        L3329
    jmp       L3330
L3318:
    mov       %rax,	1
    mov       [%rip+cc_lex.isincludefile],	%rax
    jmp       L3332
L3331:
    inc       qword ptr[%rip+cc_lex.lxsptr]
L3332:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	32
    jz        L3331
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	9
    jz        L3331
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	60
    setnz     %al
    movzx     %eax,	%al
    mov       [%rbp + cc_lex.dolexdirective.allowmacros],	%rax
    call      cc_lex.lexm
    xor       %eax,	%eax
    mov       [%rip+cc_lex.isincludefile],	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	42
    jnz       L3335
    mov       %r15,	1
    lea       %rax,	[%rbp + cc_lex.dolexdirective.filename]
    mov       %rbx,	%rax
    mov       %rax,	[%rbp + cc_lex.dolexdirective.allowmacros]
    test      %rax,	%rax
    jz        L3337
L3338:
    call      cc_lex.lexm
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	57
    jz        L3341
    cmp       %rax,	56
    jz        L3341
    cmp       %rax,	45
    jz        L3342
    jmp       L3343
L3341:
    lea       %rcx,	[%rip+L8470]
    call      cc_lex.lxerror
    jmp       L3340
L3342:
    jmp       L3339
L3343:
    lea       %rcx,	[%rip+cc_decls.nextlx]
    lea       %rdx,	[%rbp + cc_lex.dolexdirective.length]
    call      cc_lex.strtoken
    mov       %r12,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	%r12
    mov       %r8,	[%rbp + cc_lex.dolexdirective.length]
    call      memcpy
    mov       %rax,	[%rbp + cc_lex.dolexdirective.length]
    add       %rbx,	%rax
L3340:
    jmp       L3338
L3339:
    jmp       L3336
L3337:
L3344:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    mov       %r14,	%rax
    mov       %rax,	%r14
    cmp       %rax,	62
    jz        L3347
    cmp       %rax,	10
    jz        L3348
    test      %rax,	%rax
    jz        L3348
    jmp       L3349
L3347:
    jmp       L3345
L3348:
    lea       %rcx,	[%rip+L8471]
    call      cc_lex.lxerror
    jmp       L3346
L3349:
    mov       %rax,	%rbx
    inc       %rbx
    mov       %r10b,	%r14b
    mov       [%rax],	%r10b
L3346:
    jmp       L3344
L3345:
L3336:
    xor       %eax,	%eax
    mov       [%rbx],	%al
    jmp       L3334
L3335:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	63
    jnz       L3350
    xor       %r15,	%r15
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    lea       %rcx,	[%rbp + cc_lex.dolexdirective.filename]
    mov       %rdx,	%rax
    call      strcpy
    jmp       L3334
L3350:
    lea       %rcx,	[%rip+L8472]
    call      cc_lex.lxerror
L3334:
    call      cc_lex.lexm
    mov       %al,	[%rip+cc_cli.fshowincludes]
    test      %al,	%al
    jz        L3352
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8473]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rbp + cc_lex.dolexdirective.filename]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L8474]
    call      msys.m$print_str_nf
    call      cc_lex.getfileno
    lea       %r10,	[%rip+cc_decls.sourcefilepaths]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %eax,	[%rax+16]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    lea       %rcx,	[%rip+L8475]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+cc_decls.nsourcefiles]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L3352:
    inc       qword ptr[%rip+cc_lex.nincludes]
    lea       %rcx,	[%rbp + cc_lex.dolexdirective.filename]
    mov       %rdx,	%r15
    call      cc_lex.stacksourcefile
    jmp       L3317
L3319:
    call      cc_lex.dodefine
    jmp       L3317
L3320:
    call      cc_lex.lexreadtoken
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L3354
    lea       %rcx,	[%rip+L8476]
    call      cc_lex.lxerror
L3354:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rdi,	[%rax]
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	1
    jnz       L3355
L3356:
    xor       %eax,	%eax
    mov       [%rdi+109],	%al
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    mov       %al,	[%rax+88]
    mov       [%rdi+107],	%al
    xor       %eax,	%eax
    mov       [%rdi+80],	%rax
    lea       %rax,	[%rdi+108]
    and       byte ptr[%rax],	251
L3355:
    jmp       L3317
L3321:
    call      cc_lex.getifdef
    mov       %r13,	%rax
    jmp       L3357
L3322:
    call      cc_lex.getifdef
    test      %rax,	%rax
    setz      %al
    movzx     %eax,	%al
    mov       %r13,	%rax
    jmp       L3357
L3323:
    call      cc_lex.getifexpr
    mov       %r13,	%rax
#cc_lex.dolexdirective.doif:
L3357:
    inc       qword ptr[%rip+cc_lex.ifcondlevel]
    test      %r13,	%r13
    jz        L3359
    xor       %eax,	%eax
    jmp       L3314
L3359:
#cc_lex.dolexdirective.doskipcode:
L3360:
    call      cc_lex.skipcode
    mov       [%rbp + cc_lex.dolexdirective.dir],	%rax
    mov       %rax,	[%rbp + cc_lex.dolexdirective.dir]
    cmp       %rax,	4
    jz        L3362
    cmp       %rax,	5
    jz        L3363
    cmp       %rax,	6
    jz        L3364
    jmp       L3365
L3362:
    call      cc_lex.getifexpr
    mov       %r13,	%rax
    test      %r13,	%r13
    jz        L3367
    xor       %eax,	%eax
    jmp       L3314
L3367:
    jmp       L3360
L3363:
    jmp       L3361
L3364:
    dec       qword ptr[%rip+cc_lex.ifcondlevel]
L3365:
L3361:
L3358:
    jmp       L3317
L3324:
    mov       %rax,	[%rip+cc_lex.ifcondlevel]
    test      %rax,	%rax
    jnz       L3369
    lea       %rcx,	[%rip+L8477]
    call      cc_lex.lxerror
L3369:
L3370:
    call      cc_lex.skipcode
    mov       [%rbp + cc_lex.dolexdirective.dir],	%rax
    mov       %rax,	[%rbp + cc_lex.dolexdirective.dir]
    cmp       %rax,	6
    jnz       L3370
    dec       qword ptr[%rip+cc_lex.ifcondlevel]
    jmp       L3317
L3325:
    mov       %rax,	[%rip+cc_lex.ifcondlevel]
    test      %rax,	%rax
    jnz       L3374
    lea       %rcx,	[%rip+L8478]
    call      cc_lex.lxerror
L3374:
    dec       qword ptr[%rip+cc_lex.ifcondlevel]
    jmp       L3317
L3326:
    jmp       L3317
L3327:
L3375:
    call      cc_lex.lexreadtoken
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	56
    jnz       L3375
    jmp       L3317
L3328:
    call      cc_lex.lexm
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8479]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       %rcx,	[%rip+cc_decls.nextlx]
    call      cc_lex.showtoken
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8480]
    call      cc_lex.lxerror
    jmp       L3317
L3329:
    call      cc_lex.dopragmadir
    jmp       L3317
L3330:
#cc_lex.dolexdirective.skip:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8481]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_tables.sourcedirnames]
    mov       %r10,	[%rbp + cc_lex.dolexdirective.dir]
    mov       %rcx,	[%rax + %r10*8-8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       [%rip+cc_lex.lxsptr],	%rsi
    mov       %al,	4
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    mov       %rax,	1
    jmp       L3314
    lea       %rcx,	[%rip+L8482]
    call      cc_lex.lxerror
L3317:
    xor       %eax,	%eax
L3314:
#---------------
    add       %rsp,	360
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.getlexdirective
cc_lex.getlexdirective:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    call      cc_lex.lexreadtoken
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L3381
    cmp       %rax,	56
    jz        L3382
    cmp       %rax,	59
    jz        L3383
    jmp       L3384
L3381:
    jmp       L3380
L3382:
    mov       %rax,	13
    jmp       L3379
L3383:
L3385:
    call      cc_lex.lexreadtoken
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	56
    jz        L3388
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	57
    jnz       L3385
L3388:
    mov       %rax,	13
    jmp       L3379
L3384:
    xor       %eax,	%eax
    jmp       L3379
L3380:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    movzx     %rax,	byte ptr[%rax+107]
    cmp       %rax,	68
    jz        L3390
    cmp       %rax,	72
    jz        L3391
    cmp       %rax,	73
    jz        L3392
    cmp       %rax,	56
    jz        L3393
    jmp       L3394
L3390:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    movsx     %rax,	word ptr[%rax+100]
    jmp       L3379
L3391:
    mov       %rax,	3
    jmp       L3379
L3392:
    mov       %rax,	5
    jmp       L3379
L3393:
    mov       %rax,	13
    jmp       L3379
L3394:
L3389:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rdi,	[%rax]
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	1
    jnz       L3396
    movzx     %rax,	byte ptr[%rdi+88]
    cmp       %rax,	68
    jnz       L3398
    movsx     %rax,	word ptr[%rdi+100]
    jmp       L3379
L3398:
L3396:
    xor       %eax,	%eax
L3379:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lex.startlex
cc_lex.startlex:
#?>>
    .set cc_lex.startlex.caption, 24
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rdx
#---------------
    xor       %eax,	%eax
    mov       [%rip+cc_lex.ifcondlevel],	%rax
    xor       %eax,	%eax
    mov       [%rip+cc_lex.lx_stackindex],	%rax
    xor       %eax,	%eax
    mov       [%rip+cc_lex.noexpand],	%rax
    lea       %rax,	[%rip+cc_lex.normaltkx]
    mov       [%rip+cc_lex.normaltk],	%rax
    xor       %eax,	%eax
    mov       [%rip+cc_lex.lx_stackindex],	%rax
    xor       %eax,	%eax
    mov       [%rip+cc_lex.ifcondlevel],	%rax
    mov       %rax,	1
    mov       [%rip+cc_lex.firstsymbol],	%rax
    xor       %eax,	%eax
    mov       [%rip+cc_lex.npastedtokens],	%rax
    xor       %eax,	%eax
    mov       [%rip+cc_lex.isincludefile],	%rax
    xor       %eax,	%eax
    mov       [%rip+cc_lex.tkptr],	%rax
    lea       %rax,	[%rip+cc_decls.sourcefiletext]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    mov       [%rip+cc_lex.lxsptr],	%rax
    mov       [%rip+cc_lex.lxstart],	%rax
    mov       %rcx,	%rdi
    call      cc_lex.setfileno
    mov       %eax,	1
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+16],	%eax
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+28],	%eax
    mov       %al,	56
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    call      cc_lex.lex
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lex.endlex
cc_lex.endlex:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    mov       %rax,	[%rip+cc_lex.ifcondlevel]
    test      %rax,	%rax
    jz        L3402
    call      msys.m$print_startcon
    mov       %rcx,	[%rip+cc_lex.ifcondlevel]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8483]
    call      cc_lex.lxerror
L3402:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_lex.ps
cc_lex.ps:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    call      msys.m$print_startcon
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L8484]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       %rcx,	[%rip+cc_decls.lx]
    call      cc_lex.printsymbol
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lex.psnext
cc_lex.psnext:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    call      msys.m$print_startcon
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L8485]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       %rcx,	[%rip+cc_decls.nextlx]
    call      cc_lex.printsymbol
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lex.gethashtablesize
cc_lex.gethashtablesize:
#?>>
    push      %rdi
    push      %rbx
#?]]
#---------------
    xor       %rbx,	%rbx
    xor       %eax,	%eax
    mov       %rdi,	%rax
    mov       %rax,	[%rip+cc_decls.hstmask]
    cmp       %rax,	0
    jl        L3408
L3406:
    mov       %rax,	[%rip+cc_decls.hashtable]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    mov       %rax,	[%rax]
    test      %rax,	%rax
    jz        L3410
    inc       %rbx
L3410:
    inc       %rdi
    cmp       %rdi,	[%rip+cc_decls.hstmask]
    jle       L3406
L3408:
    mov       %rax,	%rbx
L3405:
#---------------
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.readlinecomment
cc_lex.readlinecomment:
#?>>
#?]]
#---------------
L3412:
L3414:
L3415:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    lea       %r10,	[%rip+cc_lex.linecommentmap]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jnz       L3414
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	10
    jz        L3418
    test      %rax,	%rax
    jz        L3419
    cmp       %rax,	92
    jz        L3420
    jmp       L3421
L3418:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L3413
L3419:
    jmp       L3413
L3420:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	13
    jz        L3423
    cmp       %rax,	10
    jz        L3424
    jmp       L3425
L3423:
    add       qword ptr[%rip+cc_lex.lxsptr],	2
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %rax,	[%rax+16]
    inc       dword ptr[%rax]
    jmp       L3422
L3424:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %rax,	[%rax+16]
    inc       dword ptr[%rax]
L3425:
L3422:
L3421:
L3417:
    jmp       L3412
L3413:
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %rax,	[%rax+16]
    inc       dword ptr[%rax]
#---------------
    ret       
# End 
# Proc cc_lex.readblockcomment
cc_lex.readblockcomment:
#?>>
#?]]
    sub       %rsp,	40
#---------------
L3427:
L3429:
L3430:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    lea       %r10,	[%rip+cc_lex.commentmap]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jnz       L3429
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	10
    jz        L3433
    test      %rax,	%rax
    jz        L3434
    cmp       %rax,	42
    jz        L3435
    jmp       L3436
L3433:
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %rax,	[%rax+16]
    inc       dword ptr[%rax]
    jmp       L3432
L3434:
    lea       %rcx,	[%rip+L8486]
    call      cc_lex.lxerror
    jmp       L3432
L3435:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax+1]
    cmp       %rax,	47
    jnz       L3438
    add       qword ptr[%rip+cc_lex.lxsptr],	2
    jmp       L3428
L3438:
L3436:
L3432:
    jmp       L3427
L3428:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_lex.readhex
cc_lex.readhex:
#?>>
    .set cc_lex.readhex.pstart, 64
    .set cc_lex.readhex.p, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       [%rbp+64],	%rcx
#---------------
    xor       %rdi,	%rdi
    mov       %rax,	[%rip+cc_lex.lxsptr]
    mov       [%rbp + cc_lex.readhex.p],	%rax
    mov       %r12,	1
    xor       %eax,	%eax
    mov       %r14,	%rax
    mov       %r13,	%rax
    xor       %rsi,	%rsi
L3440:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    mov       %rbx,	%rax
    sub       %rax,	46
    cmp       %rax,	72
    jae       L3443
    lea       %r10,	[%rip+L3442]
    jmp       [%r10 + %rax*8]
    .data
L3442:
    .quad     L3450
    .quad     L3443
    .quad     L3445
    .quad     L3444
    .quad     L3444
    .quad     L3444
    .quad     L3444
    .quad     L3444
    .quad     L3444
    .quad     L3444
    .quad     L3444
    .quad     L3444
    .quad     L3443
    .quad     L3443
    .quad     L3443
    .quad     L3443
    .quad     L3443
    .quad     L3443
    .quad     L3443
    .quad     L3448
    .quad     L3448
    .quad     L3448
    .quad     L3448
    .quad     L3448
    .quad     L3448
    .quad     L3443
    .quad     L3443
    .quad     L3443
    .quad     L3443
    .quad     L3443
    .quad     L3451
    .quad     L3443
    .quad     L3443
    .quad     L3443
    .quad     L3450
    .quad     L3443
    .quad     L3443
    .quad     L3443
    .quad     L3443
    .quad     L3454
    .quad     L3443
    .quad     L3443
    .quad     L3443
    .quad     L3443
    .quad     L3443
    .quad     L3443
    .quad     L3443
    .quad     L3443
    .quad     L3443
    .quad     L3443
    .quad     L3443
    .quad     L3449
    .quad     L3449
    .quad     L3449
    .quad     L3449
    .quad     L3449
    .quad     L3449
    .quad     L3443
    .quad     L3443
    .quad     L3443
    .quad     L3443
    .quad     L3443
    .quad     L3451
    .quad     L3443
    .quad     L3443
    .quad     L3443
    .quad     L3450
    .quad     L3443
    .quad     L3443
    .quad     L3443
    .quad     L3443
    .quad     L3454
    .text
L3444:
    xor       %r12,	%r12
    mov       %rax,	%rdi
    shl       %rax,	4
    lea       %r10,	[%rbx-48]
    add       %rax,	%r10
    mov       %rdi,	%rax
    inc       %rsi
    jmp       L3440
L3445:
    test      %r12,	%r12
    jz        L3447
    inc       qword ptr[%rbp + cc_lex.readhex.p]
    jmp       L3446
L3447:
    inc       %rsi
    mov       %rax,	%rdi
    shl       %rax,	4
    mov       %rdi,	%rax
L3446:
    jmp       L3440
L3448:
    xor       %r12,	%r12
    inc       %rsi
    mov       %rax,	%rdi
    shl       %rax,	4
    lea       %r10,	[%rbx-65]
    add       %r10,	10
    add       %rax,	%r10
    mov       %rdi,	%rax
    jmp       L3440
L3449:
    xor       %r12,	%r12
    inc       %rsi
    mov       %rax,	%rdi
    shl       %rax,	4
    lea       %r10,	[%rbx-97]
    add       %r10,	10
    add       %rax,	%r10
    mov       %rdi,	%rax
    jmp       L3440
L3450:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	[%rbp + cc_lex.readhex.p]
    mov       %rcx,	[%rbp + cc_lex.readhex.pstart]
    mov       %rdx,	[%rbp + cc_lex.readhex.p]
    mov       %r8,	%rax
    mov       %r9,	16
    call      cc_lex.readrealnumber
    jmp       L3439
L3451:
    inc       %r13
    cmp       %r13,	2
    jle       L3453
    lea       %rcx,	[%rip+L8487]
    call      cc_lex.lxerror
L3453:
    jmp       L3440
L3454:
    test      %r14,	%r14
    jz        L3456
    lea       %rcx,	[%rip+L8488]
    call      cc_lex.lxerror
L3456:
    mov       %r14,	1
    jmp       L3440
L3443:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L3441
L3441:
    mov       %rax,	[%rbp + cc_lex.readhex.pstart]
    sub       %rax,	[%rip+cc_lex.lxstart]
    mov       %rcx,	%rax
    call      cc_lex.setnumberoffset
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	[%rbp + cc_lex.readhex.pstart]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
    cmp       %rsi,	16
    jle       L3458
    lea       %rcx,	[%rip+L8489]
    call      cc_lex.lxerror
L3458:
    mov       %al,	59
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    mov       %rax,	%rdi
    mov       %r10,	9223372036854775807
    cmp       %rax,	%r10
    jbe       L3460
    mov       %al,	9
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    jmp       L3459
L3460:
    mov       %rax,	%rdi
    mov       %r10,	4294967295
    cmp       %rax,	%r10
    jbe       L3461
    mov       %al,	4
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    jmp       L3459
L3461:
    cmp       %rdi,	2147483647
    jbe       L3462
    mov       %al,	8
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    jmp       L3459
L3462:
    mov       %al,	3
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
L3459:
    mov       %rax,	%rdi
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10],	%rax
    cmp       %r13,	2
    jz        L3465
    cmp       %r13,	1
    jnz       L3464
    mov       %al,	[%rip+pc_decls.flong64]
    test      %al,	%al
    jz        L3464
L3465:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+22]
    cmp       %rax,	8
    jz        L3467
    cmp       %rax,	3
    jz        L3468
    jmp       L3469
L3467:
    mov       %al,	9
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    jmp       L3466
L3468:
    mov       %al,	4
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
L3469:
L3466:
L3464:
    test      %r14,	%r14
    jz        L3471
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+22]
    cmp       %rax,	3
    jz        L3473
    cmp       %rax,	4
    jz        L3474
    jmp       L3475
L3473:
    mov       %al,	8
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    jmp       L3472
L3474:
    mov       %al,	9
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
L3475:
L3472:
L3471:
    call      cc_lex.checknumbersuffix
L3439:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.readbinary
cc_lex.readbinary:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    sub       %rsp,	48
    mov       %r15,	%rcx
#---------------
    xor       %rdi,	%rdi
    mov       %rax,	[%rip+cc_lex.lxsptr]
    mov       %r13,	%rax
    mov       %r12,	1
L3477:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    mov       %rbx,	%rax
    sub       %rax,	46
    cmp       %rax,	12
    jae       L3480
    lea       %r10,	[%rip+L3479]
    jmp       [%r10 + %rax*8]
    .data
L3479:
    .quad     L3486
    .quad     L3480
    .quad     L3482
    .quad     L3481
    .quad     L3485
    .quad     L3485
    .quad     L3485
    .quad     L3485
    .quad     L3485
    .quad     L3485
    .quad     L3485
    .quad     L3485
    .text
L3481:
    xor       %r12,	%r12
    jmp       L3477
L3482:
    test      %r12,	%r12
    jz        L3484
    inc       %r13
L3484:
    jmp       L3477
L3485:
    lea       %rcx,	[%rip+L8490]
    call      cc_lex.lxerror
    jmp       L3477
L3486:
    lea       %rcx,	[%rip+L8491]
    call      cc_lex.lxerror
    jmp       L3477
L3480:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L3478
L3478:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	%r13
    mov       %rsi,	%rax
    mov       %rax,	%r15
    sub       %rax,	[%rip+cc_lex.lxstart]
    mov       %rcx,	%rax
    call      cc_lex.setnumberoffset
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	%r15
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
    cmp       %rsi,	64
    jle       L3488
    lea       %rcx,	[%rip+L8492]
    call      cc_lex.lxerror
L3488:
    mov       %r14,	%rsi
    cmp       %r14,	0
    jle       L3491
L3489:
    mov       %rax,	%rdi
    shl       %rax,	1
    mov       %r10,	%r13
    inc       %r13
    movzx     %r10,	byte ptr[%r10]
    add       %rax,	%r10
    sub       %rax,	48
    mov       %rdi,	%rax
    dec       %r14
    jnz       L3489
L3491:
    mov       %al,	59
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    mov       %al,	3
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    cmp       %rdi,	2147483647
    jb        L3493
    mov       %al,	4
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
L3493:
    mov       %rax,	%rdi
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10],	%rax
    call      cc_lex.checknumbersuffix
#---------------
    add       %rsp,	48
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.readoctal
cc_lex.readoctal:
#?>>
    .set cc_lex.readoctal.pstart, 64
    .set cc_lex.readoctal.usigned, -8
    .set cc_lex.readoctal.p, -16
    .set cc_lex.readoctal.av_1, -24
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	64
    mov       [%rbp+64],	%rcx
#---------------
    xor       %rdi,	%rdi
    mov       %rax,	[%rip+cc_lex.lxsptr]
    mov       [%rbp + cc_lex.readoctal.p],	%rax
    mov       %r13,	1
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.readoctal.usigned],	%rax
    mov       %r14,	%rax
    xor       %rsi,	%rsi
L3495:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    mov       %rbx,	%rax
    sub       %rax,	46
    cmp       %rax,	72
    jae       L3498
    lea       %r10,	[%rip+L3497]
    jmp       [%r10 + %rax*8]
    .data
L3497:
    .quad     L3503
    .quad     L3498
    .quad     L3500
    .quad     L3499
    .quad     L3499
    .quad     L3499
    .quad     L3499
    .quad     L3499
    .quad     L3499
    .quad     L3499
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3504
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3507
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3504
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3507
    .text
L3499:
    xor       %r13,	%r13
    inc       %rsi
    jmp       L3495
L3500:
    test      %r13,	%r13
    jz        L3502
    inc       qword ptr[%rbp + cc_lex.readoctal.p]
    jmp       L3501
L3502:
    inc       %rsi
L3501:
    jmp       L3495
L3503:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	[%rbp + cc_lex.readoctal.p]
    mov       %rcx,	[%rbp + cc_lex.readoctal.pstart]
    mov       %rdx,	[%rbp + cc_lex.readoctal.p]
    mov       %r8,	%rax
    mov       %r9,	10
    call      cc_lex.readrealnumber
    jmp       L3494
L3504:
    inc       %r14
    cmp       %r14,	2
    jle       L3506
    lea       %rcx,	[%rip+L8493]
    call      cc_lex.lxerror
L3506:
    jmp       L3495
L3507:
    mov       %rax,	[%rbp + cc_lex.readoctal.usigned]
    test      %rax,	%rax
    jz        L3509
    lea       %rcx,	[%rip+L8494]
    call      cc_lex.lxerror
L3509:
    mov       %rax,	1
    mov       [%rbp + cc_lex.readoctal.usigned],	%rax
    jmp       L3495
L3498:
    lea       %rax,	[%rip+cc_lex.alphamap]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L3511
#cc_lex.readoctal.doalpha:
    mov       %rcx,	[%rbp + cc_lex.readoctal.pstart]
    call      cc_lex.readalphanumeric
    jmp       L3494
L3511:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L3496
L3496:
    mov       %rax,	[%rbp + cc_lex.readoctal.pstart]
    sub       %rax,	[%rip+cc_lex.lxstart]
    mov       %rcx,	%rax
    call      cc_lex.setnumberoffset
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	[%rbp + cc_lex.readoctal.pstart]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
    cmp       %rsi,	22
    jg        L3515
    cmp       %rsi,	22
    jnz       L3514
    mov       %rcx,	[%rbp + cc_lex.readoctal.p]
    lea       %rdx,	[%rip+L8495]
    mov       %r8,	22
    call      mlib.cmpstringn
    mov       %r12,	%rax
    cmp       %rax,	0
    jle       L3514
L3515:
    lea       %rcx,	[%rip+L8496]
    call      cc_lex.lxerror
L3514:
    mov       [%rbp + cc_lex.readoctal.av_1],	%rsi
    mov       %rax,	[%rbp + cc_lex.readoctal.av_1]
    cmp       %rax,	0
    jle       L3518
L3516:
    mov       %rax,	%rdi
    shl       %rax,	3
    mov       %r10,	[%rbp + cc_lex.readoctal.p]
    inc       qword ptr[%rbp + cc_lex.readoctal.p]
    movzx     %r10,	byte ptr[%r10]
    add       %rax,	%r10
    sub       %rax,	48
    mov       %rdi,	%rax
    dec       qword ptr[%rbp + cc_lex.readoctal.av_1]
    jnz       L3516
L3518:
    mov       %al,	59
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    mov       %al,	3
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    cmp       %rdi,	2147483647
    jb        L3520
    mov       %al,	4
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
L3520:
    mov       %rax,	%rdi
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10],	%rax
    call      cc_lex.checknumbersuffix
L3494:
#---------------
    add       %rsp,	64
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.readdecimal
cc_lex.readdecimal:
#?>>
    .set cc_lex.readdecimal.pstart, 64
    .set cc_lex.readdecimal.p, -8
    .set cc_lex.readdecimal.av_1, -16
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       [%rbp+64],	%rcx
#---------------
    xor       %rdi,	%rdi
    xor       %eax,	%eax
    mov       %r14b,	%al
    mov       %r13b,	%al
    dec       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    mov       [%rbp + cc_lex.readdecimal.p],	%rax
L3522:
L3523:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    lea       %r10,	[%rip+cc_lex.digitmap]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jnz       L3522
    jmp       L3526
L3525:
    inc       qword ptr[%rbp + cc_lex.readdecimal.p]
L3526:
    mov       %rax,	[%rbp + cc_lex.readdecimal.p]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	48
    jz        L3525
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	[%rbp + cc_lex.readdecimal.p]
    mov       %rsi,	%rax
L3528:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    mov       %rbx,	%rax
    sub       %rax,	46
    cmp       %rax,	72
    jae       L3531
    lea       %r10,	[%rip+L3530]
    jmp       [%r10 + %rax*8]
    .data
L3530:
    .quad     L3532
    .quad     L3531
    .quad     L3531
    .quad     L3531
    .quad     L3531
    .quad     L3531
    .quad     L3531
    .quad     L3531
    .quad     L3531
    .quad     L3531
    .quad     L3531
    .quad     L3531
    .quad     L3531
    .quad     L3531
    .quad     L3531
    .quad     L3531
    .quad     L3531
    .quad     L3531
    .quad     L3531
    .quad     L3531
    .quad     L3531
    .quad     L3531
    .quad     L3531
    .quad     L3532
    .quad     L3531
    .quad     L3531
    .quad     L3531
    .quad     L3531
    .quad     L3531
    .quad     L3531
    .quad     L3533
    .quad     L3531
    .quad     L3531
    .quad     L3531
    .quad     L3531
    .quad     L3531
    .quad     L3531
    .quad     L3531
    .quad     L3531
    .quad     L3536
    .quad     L3531
    .quad     L3531
    .quad     L3531
    .quad     L3531
    .quad     L3531
    .quad     L3531
    .quad     L3531
    .quad     L3531
    .quad     L3531
    .quad     L3531
    .quad     L3531
    .quad     L3531
    .quad     L3531
    .quad     L3531
    .quad     L3531
    .quad     L3532
    .quad     L3531
    .quad     L3531
    .quad     L3531
    .quad     L3531
    .quad     L3531
    .quad     L3531
    .quad     L3533
    .quad     L3531
    .quad     L3531
    .quad     L3531
    .quad     L3531
    .quad     L3531
    .quad     L3531
    .quad     L3531
    .quad     L3531
    .quad     L3536
    .text
L3532:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	[%rbp + cc_lex.readdecimal.p]
    mov       %rcx,	[%rbp + cc_lex.readdecimal.pstart]
    mov       %rdx,	[%rbp + cc_lex.readdecimal.p]
    mov       %r8,	%rax
    mov       %r9,	10
    call      cc_lex.readrealnumber
    jmp       L3521
L3533:
    inc       %r13b
    movzx     %rax,	%r13b
    cmp       %rax,	2
    jle       L3535
    lea       %rcx,	[%rip+L8497]
    call      cc_lex.lxerror
L3535:
    jmp       L3528
L3536:
    test      %r14b,	%r14b
    jz        L3538
    lea       %rcx,	[%rip+L8498]
    call      cc_lex.lxerror
L3538:
    mov       %r14b,	1
    jmp       L3528
L3531:
    lea       %rax,	[%rip+cc_lex.alphamap]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L3540
    mov       %rcx,	[%rbp + cc_lex.readdecimal.pstart]
    call      cc_lex.readalphanumeric
    jmp       L3521
L3540:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L3529
L3529:
    mov       %rax,	[%rbp + cc_lex.readdecimal.pstart]
    sub       %rax,	[%rip+cc_lex.lxstart]
    mov       %rcx,	%rax
    call      cc_lex.setnumberoffset
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	[%rbp + cc_lex.readdecimal.pstart]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
    cmp       %rsi,	20
    jg        L3543
    cmp       %rsi,	20
    jnz       L3542
    mov       %rcx,	[%rbp + cc_lex.readdecimal.p]
    lea       %rdx,	[%rip+L8499]
    mov       %r8,	20
    call      mlib.cmpstringn
    mov       %r12,	%rax
    cmp       %rax,	0
    jle       L3542
L3543:
    lea       %rcx,	[%rip+L8500]
    call      cc_lex.lxerror
L3542:
    mov       [%rbp + cc_lex.readdecimal.av_1],	%rsi
    mov       %rax,	[%rbp + cc_lex.readdecimal.av_1]
    cmp       %rax,	0
    jle       L3546
L3544:
    mov       %rax,	%rdi
    shl       %rax,	1
    lea       %rax,	[%rax + %rax*4]
    mov       %r10,	[%rbp + cc_lex.readdecimal.p]
    inc       qword ptr[%rbp + cc_lex.readdecimal.p]
    movzx     %r10,	byte ptr[%r10]
    sub       %r10,	48
    add       %rax,	%r10
    mov       %rdi,	%rax
    dec       qword ptr[%rbp + cc_lex.readdecimal.av_1]
    jnz       L3544
L3546:
    mov       %al,	59
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    movzx     %rax,	%r13b
    test      %rax,	%rax
    jz        L3548
    cmp       %rax,	1
    jz        L3549
    cmp       %rax,	2
    jz        L3550
    jmp       L3551
L3548:
    cmp       %rdi,	2147483647
    jl        L3553
    mov       %al,	4
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    jmp       L3552
L3553:
    mov       %al,	3
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
L3552:
    test      %r14b,	%r14b
    jz        L3555
    mov       %rax,	%rdi
    mov       %r10,	4294967295
    cmp       %rax,	%r10
    jb        L3557
    mov       %al,	9
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    jmp       L3556
L3557:
    mov       %al,	8
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
L3556:
    jmp       L3554
L3555:
    cmp       %rdi,	2147483647
    jb        L3559
    mov       %al,	4
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
L3559:
L3554:
    jmp       L3547
L3549:
    mov       %al,	[%rip+pc_decls.flong64]
    test      %al,	%al
    jnz       L3550
L3561:
    test      %r14b,	%r14b
    jz        L3563
    mov       %rax,	%rdi
    mov       %r10,	4294967295
    cmp       %rax,	%r10
    jb        L3565
    mov       %al,	9
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    jmp       L3564
L3565:
    mov       %al,	8
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
L3564:
    jmp       L3562
L3563:
    cmp       %rdi,	2147483647
    jb        L3567
    mov       %al,	4
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    jmp       L3566
L3567:
    mov       %al,	3
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
L3566:
L3562:
    jmp       L3547
L3550:
    test      %r14b,	%r14b
    jz        L3569
    mov       %al,	9
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    jmp       L3568
L3569:
    mov       %al,	4
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
L3568:
L3551:
L3547:
    mov       %rax,	%rdi
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10],	%rax
L3521:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.checknumbersuffix
cc_lex.checknumbersuffix:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	16
#---------------
L3571:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    mov       %dil,	%al
    sub       %rax,	76
    cmp       %rax,	42
    jae       L3574
    lea       %r10,	[%rip+L3573]
    jmp       [%r10 + %rax*8]
    .data
L3573:
    .quad     L3575
    .quad     L3574
    .quad     L3574
    .quad     L3574
    .quad     L3574
    .quad     L3574
    .quad     L3574
    .quad     L3574
    .quad     L3574
    .quad     L3575
    .quad     L3574
    .quad     L3574
    .quad     L3574
    .quad     L3574
    .quad     L3574
    .quad     L3574
    .quad     L3574
    .quad     L3574
    .quad     L3574
    .quad     L3574
    .quad     L3574
    .quad     L3574
    .quad     L3574
    .quad     L3574
    .quad     L3574
    .quad     L3574
    .quad     L3574
    .quad     L3574
    .quad     L3574
    .quad     L3574
    .quad     L3574
    .quad     L3574
    .quad     L3575
    .quad     L3574
    .quad     L3574
    .quad     L3574
    .quad     L3574
    .quad     L3574
    .quad     L3574
    .quad     L3574
    .quad     L3574
    .quad     L3575
    .text
L3575:
    jmp       L3571
L3574:
    movzx     %rax,	%dil
    lea       %r10,	[%rip+cc_lex.alphamap]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L3577
L3577:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L3572
L3572:
    mov       %rax,	3
L3570:
#---------------
    add       %rsp,	16
    pop       %rdi
    ret       
# End 
# Proc cc_lex.stacksourcefile
cc_lex.stacksourcefile:
#?>>
    .set cc_lex.stacksourcefile.info, -24
    .set cc_lex.stacksourcefile.fullpath, -528
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	568
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      cc_lex.getsourcefile
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L3580
    call      msys.m$print_startcon
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    mov       %rcx,	%rbx
    call      strlen
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8501]
    call      cc_lex.lxerror
L3580:
    mov       %rax,	[%rip+cc_lex.lx_stackindex]
    cmp       %rax,	20
    jl        L3582
    lea       %rcx,	[%rip+L8502]
    call      cc_lex.lxerror
L3582:
    inc       qword ptr[%rip+cc_lex.lx_stackindex]
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.stacksourcefile.fullpath],	%al
    mov       %rax,	[%rip+cc_lex.lx_stackindex]
    cmp       %rax,	1
    jle       L3584
    lea       %rax,	[%rip+cc_lex.headerpathlist]
    mov       %r10,	[%rip+cc_lex.lx_stackindex]
    mov       %rax,	[%rax + %r10*8-16]
    lea       %rcx,	[%rbp + cc_lex.stacksourcefile.fullpath]
    mov       %rdx,	%rax
    call      strcpy
L3584:
    lea       %rax,	[%rip+cc_lex.headerpath]
    mov       %al,	[%rax]
    test      %al,	%al
    jz        L3586
    lea       %rcx,	[%rip+cc_lex.headerpath]
    call      mlib.pcm_copyheapstring
    lea       %rcx,	[%rbp + cc_lex.stacksourcefile.fullpath]
    mov       %rdx,	%rax
    call      strcat
L3586:
    lea       %rcx,	[%rbp + cc_lex.stacksourcefile.fullpath]
    call      mlib.pcm_copyheapstring
    lea       %r10,	[%rip+cc_lex.headerpathlist]
    mov       %r11,	[%rip+cc_lex.lx_stackindex]
    mov       [%r10 + %r11*8-8],	%rax
    mov       %rax,	[%rip+cc_lex.lxstart]
    mov       [%rbp + cc_lex.stacksourcefile.info],	%rax
    mov       %rax,	[%rip+cc_lex.lxsptr]
    mov       [%rbp + cc_lex.stacksourcefile.info+8],	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %eax,	[%rax+16]
    mov       [%rbp + cc_lex.stacksourcefile.info+16],	%eax
    call      cc_lex.getfileno
    mov       [%rbp + cc_lex.stacksourcefile.info+20],	%eax
    lea       %rax,	[%rbp + cc_lex.stacksourcefile.info]
    lea       %r10,	[%rip+cc_lex.lx_stack]
    mov       %r11,	[%rip+cc_lex.lx_stackindex]
    shl       %r11,	3
    lea       %r11,	[%r11 + %r11*2]
    mov       %r8,	[%rax]
    mov       [%r10 + %r11-24],	%r8
    mov       %r8,	[%rax+8]
    mov       [%r10 + %r11-16],	%r8
    mov       %r8,	[%rax+16]
    mov       [%r10 + %r11-8],	%r8
    lea       %rax,	[%rip+cc_decls.sourcefiletext]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    mov       [%rip+cc_lex.lxsptr],	%rax
    mov       [%rip+cc_lex.lxstart],	%rax
    mov       %rcx,	%rdi
    call      cc_lex.setfileno
    mov       %eax,	1
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+16],	%eax
#---------------
    add       %rsp,	568
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.unstacksourcefile
cc_lex.unstacksourcefile:
#?>>
    .set cc_lex.unstacksourcefile.info, -24
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	56
#---------------
    lea       %rax,	[%rip+cc_lex.headerpathlist]
    mov       %r10,	[%rip+cc_lex.lx_stackindex]
    mov       %rdi,	[%rax + %r10*8-8]
    mov       %rcx,	%rdi
    call      strlen
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mlib.pcm_free
    mov       %rax,	[%rip+cc_lex.lx_stackindex]
    dec       qword ptr[%rip+cc_lex.lx_stackindex]
    lea       %r10,	[%rip+cc_lex.lx_stack]
    mov       %r11,	%rax
    shl       %r11,	3
    lea       %r11,	[%r11 + %r11*2]
    lea       %r10,	[%r10 + %r11-24]
    lea       %rax,	[%rbp + cc_lex.unstacksourcefile.info]
    mov       %r11,	[%r10]
    mov       [%rax],	%r11
    mov       %r11,	[%r10+8]
    mov       [%rax+8],	%r11
    mov       %r11,	[%r10+16]
    mov       [%rax+16],	%r11
    mov       %rax,	[%rbp + cc_lex.unstacksourcefile.info]
    mov       [%rip+cc_lex.lxstart],	%rax
    mov       %rax,	[%rbp + cc_lex.unstacksourcefile.info+8]
    mov       [%rip+cc_lex.lxsptr],	%rax
    mov       %eax,	[%rbp + cc_lex.unstacksourcefile.info+16]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+16],	%eax
    movsxd    %rax,	dword ptr[%rbp + cc_lex.unstacksourcefile.info+20]
    mov       %rcx,	%rax
    call      cc_lex.setfileno
#---------------
    add       %rsp,	56
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc cc_lex.getsourcefile
cc_lex.getsourcefile:
#?>>
    .set cc_lex.getsourcefile.syshdr, 48
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_lex.headerpath]
    mov       [%r10],	%al
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    mov       %rdx,	%rsi
    call      strcpy
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    call      mlib.convlcstring
    mov       %rbx,	1
    mov       %rax,	[%rip+cc_decls.nsourcefiles]
    cmp       %rax,	1
    jl        L3591
L3589:
    lea       %rax,	[%rip+cc_decls.sourcefilenames]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8]
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    mov       %rdx,	%rax
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L3593
    mov       %rax,	%rbx
    jmp       L3588
L3593:
    inc       %rbx
    cmp       %rbx,	[%rip+cc_decls.nsourcefiles]
    jle       L3589
L3591:
    mov       %al,	[%rip+cc_cli.dointheaders]
    test      %al,	%al
    jz        L3595
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    call      cc_headersx.findheader
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L3597
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    mov       %rdx,	%rdi
    call      cc_support.loadbuiltin
    jmp       L3588
L3597:
L3595:
    mov       %rcx,	%rsi
    lea       %rdx,	[%rip+L8503]
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L3599
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    lea       %rdx,	[%rip+L8504]
    call      cc_support.loadbuiltin
    jmp       L3588
L3599:
    mov       %rcx,	%rsi
    call      mlib.extractpath
    lea       %rcx,	[%rip+cc_lex.headerpath]
    mov       %rdx,	%rax
    call      strcpy
    lea       %rax,	[%rip+cc_lex.headerpath]
    mov       %al,	[%rax]
    test      %al,	%al
    jz        L3601
    lea       %rax,	[%rip+cc_lex.headerpath]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	47
    jz        L3604
    lea       %rax,	[%rip+cc_lex.headerpath]
    movzx     %rax,	byte ptr[%rax+1]
    cmp       %rax,	58
    jnz       L3603
    lea       %rax,	[%rip+cc_lex.headerpath]
    movzx     %rax,	byte ptr[%rax+2]
    cmp       %rax,	47
    jnz       L3603
L3604:
    mov       %rcx,	%rsi
    call      mlib.checkfile
    test      %rax,	%rax
    jz        L3606
    mov       %rcx,	%rsi
    mov       %rdx,	%rsi
    call      cc_support.loadsourcefile
    jmp       L3588
L3606:
    xor       %eax,	%eax
    jmp       L3588
L3603:
L3601:
    mov       %rbx,	[%rip+cc_lex.lx_stackindex]
    cmp       %rbx,	1
    jl        L3609
L3607:
    lea       %rax,	[%rip+cc_lex.headerpathlist]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8-8]
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    mov       %rdx,	%rax
    call      strcpy
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    mov       %rdx,	%rsi
    call      strcat
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    call      mlib.checkfile
    test      %rax,	%rax
    jz        L3611
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    mov       %rdx,	%rsi
    call      cc_support.loadsourcefile
    jmp       L3588
L3611:
    dec       %rbx
    cmp       %rbx,	1
    jge       L3607
L3609:
    mov       %rbx,	1
    mov       %rax,	[%rip+cc_decls.nsearchdirs]
    cmp       %rax,	1
    jl        L3614
L3612:
    lea       %rax,	[%rip+cc_decls.searchdirs]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8-8]
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    mov       %rdx,	%rax
    call      strcpy
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    mov       %rdx,	%rsi
    call      strcat
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    call      mlib.checkfile
    test      %rax,	%rax
    jz        L3616
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    call      mlib.extractpath
    lea       %rcx,	[%rip+cc_lex.headerpath]
    mov       %rdx,	%rax
    call      strcpy
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    mov       %rdx,	%rsi
    call      cc_support.loadsourcefile
    jmp       L3588
L3616:
    inc       %rbx
    cmp       %rbx,	[%rip+cc_decls.nsearchdirs]
    jle       L3612
L3614:
    xor       %eax,	%eax
L3588:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.lex
cc_lex.lex:
#?>>
#?]]
    sub       %rsp,	40
#---------------
#cc_lex.lex.reenter:
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %r10,	[%rip+cc_decls.lx]
    mov       %r11,	[%rax]
    mov       [%r10],	%r11
    mov       %r11,	[%rax+8]
    mov       [%r10+8],	%r11
    mov       %r11,	[%rax+16]
    mov       [%r10+16],	%r11
    mov       %r11,	[%rax+24]
    mov       [%r10+24],	%r11
    call      cc_lex.lexm
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jnz       L3620
    mov       %rax,	[%rip+cc_lex.lx_stackindex]
    test      %rax,	%rax
    jnz       L3620
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       %rax,	[%rax]
    lea       %r10,	[%rip+cc_decls.lx]
    movsxd    %r10,	dword ptr[%r10+24]
    xor       %r11d,	%r11d
    mov       [%rax + %r10],	%r11b
L3620:
L3621:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L3623
    cmp       %rax,	56
    jz        L3624
    jmp       L3625
L3623:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    mov       %al,	[%rax+107]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	68
    jnz       L3627
    mov       %al,	67
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L3627:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    mov       %ax,	[%rax+100]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    jmp       L3617
L3624:
    call      cc_lex.lexm
    jmp       L3621
L3625:
    jmp       L3617
L3617:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_lex.shownumberstr
cc_lex.shownumberstr:
#?>>
    .set cc_lex.shownumberstr.$T1, -8
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rcx,	%rbx
    call      cc_lex.getfilenox
    test      %rax,	%rax
    jz        L3630
    mov       %rcx,	%rbx
    call      cc_lex.getfilenox
    lea       %r10,	[%rip+cc_decls.sourcefiletext]
    mov       %r10,	[%r10 + %rax*8]
    mov       [%rbp + cc_lex.shownumberstr.$T1],	%r10
    mov       %rcx,	%rbx
    call      cc_lex.getnumberoffsetx
    mov       %r10,	[%rbp + cc_lex.shownumberstr.$T1]
    lea       %r10,	[%r10 + %rax]
    mov       %rdi,	%r10
    jmp       L3629
L3630:
    movsx     %rax,	word ptr[%rbx+28]
    lea       %r10,	[%rip+cc_lex.pastedtokenlist]
    mov       %r10,	[%r10 + %rax*8-8]
    mov       %rdi,	%r10
L3629:
    movsxd    %rax,	dword ptr[%rbx+24]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    mov       %r8,	%rsi
    call      cc_lex.printstrn
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.addnamestr
cc_lex.addnamestr:
#?>>
    .set cc_lex.addnamestr.oldlx, -32
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	64
    mov       %rbx,	%rcx
#---------------
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %r10,	[%rbp + cc_lex.addnamestr.oldlx]
    mov       %r11,	[%rax]
    mov       [%r10],	%r11
    mov       %r11,	[%rax+8]
    mov       [%r10+8],	%r11
    mov       %r11,	[%rax+16]
    mov       [%r10+16],	%r11
    mov       %r11,	[%rax+24]
    mov       [%r10+24],	%r11
    mov       %rcx,	%rbx
    call      strlen
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+24]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      cc_lex.gethashvalue
    mov       [%rip+cc_lex.lxhashvalue],	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+24]
    inc       %rax
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       [%rip+cc_lex.lxsvalue],	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+24]
    inc       %rax
    mov       %rcx,	[%rip+cc_lex.lxsvalue]
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      memcpy
    call      cc_lex.lookup
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rdi,	[%rax]
    lea       %rax,	[%rbp + cc_lex.addnamestr.oldlx]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       %r11,	[%rax]
    mov       [%r10],	%r11
    mov       %r11,	[%rax+8]
    mov       [%r10+8],	%r11
    mov       %r11,	[%rax+16]
    mov       [%r10+16],	%r11
    mov       %r11,	[%rax+24]
    mov       [%r10+24],	%r11
    mov       %rax,	%rdi
L3631:
#---------------
    add       %rsp,	64
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.lxreadstring
cc_lex.lxreadstring:
#?>>
    .set cc_lex.lxreadstring.termchar, 72
    .set cc_lex.lxreadstring.fwide, 80
    .set cc_lex.lxreadstring.str, -2048
    .set cc_lex.lxreadstring.useheap, -2056
    .set cc_lex.lxreadstring.av_1, -2064
    .set cc_lex.lxreadstring.av_2, -2072
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	2104
    mov       [%rbp+72],	%rcx
    mov       [%rbp+80],	%rdx
#---------------
    mov       %rax,	[%rbp + cc_lex.lxreadstring.termchar]
    cmp       %rax,	34
    jnz       L3634
    mov       %rax,	[%rbp + cc_lex.lxreadstring.fwide]
    test      %rax,	%rax
    jz        L3636
    mov       %rax,	64
    jmp       L3635
L3636:
    mov       %rax,	63
L3635:
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3633
L3634:
    mov       %al,	61
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L3633:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10],	%rax
    mov       %rax,	[%rip+cc_lex.lx_stackindex]
    test      %rax,	%rax
    jnz       L3638
    mov       %rax,	[%rbp + cc_lex.lxreadstring.fwide]
    test      %rax,	%rax
    jnz       L3638
    mov       %rdi,	[%rip+cc_lex.lxsptr]
    mov       %rbx,	%rdi
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.lxreadstring.useheap],	%rax
    jmp       L3637
L3638:
    lea       %rax,	[%rbp + cc_lex.lxreadstring.str]
    mov       %rdi,	%rax
    mov       %rbx,	%rdi
    mov       %rax,	1
    mov       [%rbp + cc_lex.lxreadstring.useheap],	%rax
L3637:
    xor       %r15,	%r15
L3639:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    mov       %r13,	%rax
    cmp       %rax,	92
    jz        L3642
    cmp       %rax,	34
    jz        L3643
    cmp       %rax,	39
    jz        L3643
    test      %rax,	%rax
    jz        L3644
    jmp       L3645
L3642:
    mov       %rax,	[%rip+cc_lex.isincludefile]
    test      %rax,	%rax
    jz        L3647
    mov       %r13,	47
    jmp       L3648
L3647:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    mov       %r13,	%rax
#cc_lex.lxreadstring.reenter:
    lea       %rax,	[%r13-10]
    cmp       %rax,	111
    jae       L3652
    lea       %r10,	[%rip+L3651]
    jmp       [%r10 + %rax*8]
    .data
L3651:
    .quad     L3682
    .quad     L3652
    .quad     L3652
    .quad     L3679
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3676
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3678
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3669
    .quad     L3669
    .quad     L3669
    .quad     L3669
    .quad     L3669
    .quad     L3669
    .quad     L3669
    .quad     L3669
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3677
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3653
    .quad     L3654
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3655
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3656
    .quad     L3652
    .quad     L3652
    .quad     L3652
    .quad     L3657
    .quad     L3652
    .quad     L3658
    .quad     L3652
    .quad     L3659
    .quad     L3652
    .quad     L3660
    .text
L3653:
    mov       %r13,	7
    jmp       L3650
L3654:
    mov       %r13,	8
    jmp       L3650
L3655:
    mov       %r13,	12
    jmp       L3650
L3656:
    mov       %r13,	10
    jmp       L3650
L3657:
    mov       %r13,	13
    jmp       L3650
L3658:
    mov       %r13,	9
    jmp       L3650
L3659:
    mov       %r13,	11
    jmp       L3650
L3660:
    xor       %r13,	%r13
L3661:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    mov       %r14,	%rax
    sub       %rax,	48
    cmp       %rax,	55
    jae       L3665
    lea       %r10,	[%rip+L3664]
    jmp       [%r10 + %rax*8]
    .data
L3664:
    .quad     L3668
    .quad     L3668
    .quad     L3668
    .quad     L3668
    .quad     L3668
    .quad     L3668
    .quad     L3668
    .quad     L3668
    .quad     L3668
    .quad     L3668
    .quad     L3665
    .quad     L3665
    .quad     L3665
    .quad     L3665
    .quad     L3665
    .quad     L3665
    .quad     L3665
    .quad     L3666
    .quad     L3666
    .quad     L3666
    .quad     L3666
    .quad     L3666
    .quad     L3666
    .quad     L3665
    .quad     L3665
    .quad     L3665
    .quad     L3665
    .quad     L3665
    .quad     L3665
    .quad     L3665
    .quad     L3665
    .quad     L3665
    .quad     L3665
    .quad     L3665
    .quad     L3665
    .quad     L3665
    .quad     L3665
    .quad     L3665
    .quad     L3665
    .quad     L3665
    .quad     L3665
    .quad     L3665
    .quad     L3665
    .quad     L3665
    .quad     L3665
    .quad     L3665
    .quad     L3665
    .quad     L3665
    .quad     L3665
    .quad     L3667
    .quad     L3667
    .quad     L3667
    .quad     L3667
    .quad     L3667
    .quad     L3667
    .text
L3666:
    mov       %rax,	%r13
    shl       %rax,	4
    add       %rax,	%r14
    sub       %rax,	65
    add       %rax,	10
    mov       %r13,	%rax
    jmp       L3663
L3667:
    mov       %rax,	%r13
    shl       %rax,	4
    add       %rax,	%r14
    sub       %rax,	97
    add       %rax,	10
    mov       %r13,	%rax
    jmp       L3663
L3668:
    mov       %rax,	%r13
    shl       %rax,	4
    add       %rax,	%r14
    sub       %rax,	48
    mov       %r13,	%rax
    jmp       L3663
L3665:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L3662
L3663:
    jmp       L3661
L3662:
    jmp       L3650
L3669:
    mov       %rax,	48
    sub       %r13,	%rax
    mov       %rax,	2
    mov       [%rbp + cc_lex.lxreadstring.av_1],	%rax
L3670:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    mov       %r14,	%rax
    cmp       %rax,	48
    jz        L3674
    cmp       %rax,	49
    jz        L3674
    cmp       %rax,	50
    jz        L3674
    cmp       %rax,	51
    jz        L3674
    cmp       %rax,	52
    jz        L3674
    cmp       %rax,	53
    jz        L3674
    cmp       %rax,	54
    jz        L3674
    cmp       %rax,	55
    jnz       L3675
L3674:
    mov       %rax,	%r13
    shl       %rax,	3
    add       %rax,	%r14
    sub       %rax,	48
    mov       %r13,	%rax
    jmp       L3673
L3675:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L3672
L3673:
    dec       qword ptr[%rbp + cc_lex.lxreadstring.av_1]
    jnz       L3670
L3672:
    jmp       L3650
L3676:
    mov       %r13,	34
    jmp       L3650
L3677:
    mov       %r13,	92
    jmp       L3650
L3678:
    mov       %r13,	39
    jmp       L3650
L3679:
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %rax,	[%rax+16]
    inc       dword ptr[%rax]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	10
    jnz       L3681
    inc       qword ptr[%rip+cc_lex.lxsptr]
L3681:
    jmp       L3639
L3682:
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %rax,	[%rax+16]
    inc       dword ptr[%rax]
    jmp       L3639
L3652:
L3650:
    jmp       L3641
L3643:
    cmp       %r13,	[%rbp + cc_lex.lxreadstring.termchar]
    jz        L3640
L3684:
    jmp       L3641
L3644:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8505]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %eax,	[%rax+16]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8506]
    call      cc_lex.lxerror
L3645:
L3641:
#cc_lex.lxreadstring.normalchar:
L3648:
    mov       %rax,	[%rbp + cc_lex.lxreadstring.useheap]
    test      %rax,	%rax
    jnz       L3686
    mov       %rax,	%rdi
    inc       %rdi
    mov       %r10b,	%r13b
    mov       [%rax],	%r10b
    jmp       L3685
L3686:
    inc       %r15
    cmp       %r15,	2048
    jge       L3687
    mov       %rax,	%rdi
    inc       %rdi
    mov       %r10b,	%r13b
    mov       [%rax],	%r10b
    jmp       L3685
L3687:
    lea       %rcx,	[%rip+L8507]
    call      cc_lex.lxerror
L3685:
    jmp       L3639
L3640:
    xor       %eax,	%eax
    mov       [%rdi],	%al
    mov       %rax,	[%rbp + cc_lex.lxreadstring.fwide]
    test      %rax,	%rax
    jz        L3689
    mov       %rax,	%r15
    shl       %rax,	1
    add       %rax,	2
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       %rsi,	%rax
    mov       %r12,	%rax
    mov       [%rbp + cc_lex.lxreadstring.av_2],	%r15
    mov       %rax,	[%rbp + cc_lex.lxreadstring.av_2]
    cmp       %rax,	0
    jle       L3692
L3690:
    mov       %rax,	%rbx
    inc       %rbx
    movzx     %rax,	byte ptr[%rax]
    mov       %r10,	%rsi
    add       %rsi,	2
    mov       [%r10],	%ax
    dec       qword ptr[%rbp + cc_lex.lxreadstring.av_2]
    jnz       L3690
L3692:
    xor       %eax,	%eax
    mov       [%rsi],	%ax
    mov       %rax,	%r12
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10],	%rax
    jmp       L3688
L3689:
    mov       %rax,	[%rbp + cc_lex.lxreadstring.useheap]
    test      %rax,	%rax
    jz        L3693
    mov       %eax,	%r15d
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
    lea       %rax,	[%r15+1]
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10],	%rax
    lea       %rax,	[%r15+1]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       %r10,	[%r10]
    mov       %rcx,	%r10
    lea       %rdx,	[%rbp + cc_lex.lxreadstring.str]
    mov       %r8,	%rax
    call      memcpy
    jmp       L3688
L3693:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    mov       %r10,	%rdi
    sub       %r10,	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       [%rax+24],	%r10d
L3688:
#---------------
    add       %rsp,	2104
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.addlisttoken
cc_lex.addlisttoken:
#?>>
#?]]
#---------------
    mov       %rax,	[%rcx]
    test      %rax,	%rax
    jnz       L3696
    mov       %rax,	%r8
    mov       [%rdx],	%rax
    mov       [%rcx],	%rax
    jmp       L3695
L3696:
    mov       %rax,	[%rdx]
    mov       %r10,	%r8
    mov       [%rax+8],	%r10
L3695:
    xor       %eax,	%eax
    mov       [%r8+8],	%rax
    mov       [%rdx],	%r8
#---------------
    ret       
# End 
# Proc cc_lex.addlisttoken_copy
cc_lex.addlisttoken_copy:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    call      cc_lex.alloctoken
    mov       %rdi,	%rax
    mov       %rax,	%r12
    mov       %r10,	[%rax]
    mov       [%rdi],	%r10
    mov       %r10,	[%rax+8]
    mov       [%rdi+8],	%r10
    mov       %r10,	[%rax+16]
    mov       [%rdi+16],	%r10
    mov       %r10,	[%rax+24]
    mov       [%rdi+24],	%r10
    xor       %eax,	%eax
    mov       [%rdi+8],	%rax
    mov       %rax,	[%rbx]
    test      %rax,	%rax
    jnz       L3699
    mov       %rax,	%rdi
    mov       [%rsi],	%rax
    mov       [%rbx],	%rax
    jmp       L3698
L3699:
    mov       %rax,	[%rsi]
    mov       %r10,	%rdi
    mov       [%rax+8],	%r10
L3698:
    xor       %eax,	%eax
    mov       [%rdi+8],	%rax
    mov       [%rsi],	%rdi
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.addlist_nextlx
cc_lex.addlist_nextlx:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    call      cc_lex.alloctoken
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %r10,	[%rax]
    mov       [%rdi],	%r10
    mov       %r10,	[%rax+8]
    mov       [%rdi+8],	%r10
    mov       %r10,	[%rax+16]
    mov       [%rdi+16],	%r10
    mov       %r10,	[%rax+24]
    mov       [%rdi+24],	%r10
    xor       %eax,	%eax
    mov       [%rdi+8],	%rax
    mov       %rax,	[%rbx]
    test      %rax,	%rax
    jnz       L3702
    mov       %rax,	%rdi
    mov       [%rsi],	%rax
    mov       [%rbx],	%rax
    jmp       L3701
L3702:
    mov       %rax,	[%rsi]
    mov       %r10,	%rdi
    mov       [%rax+8],	%r10
L3701:
    xor       %eax,	%eax
    mov       [%rdi+8],	%rax
    mov       [%rsi],	%rdi
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.addlisttoken_seq
cc_lex.addlisttoken_seq:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    jmp       L3705
L3704:
    call      cc_lex.alloctoken
    mov       %rdi,	%rax
    mov       %rax,	%r12
    mov       %r10,	[%rax]
    mov       [%rdi],	%r10
    mov       %r10,	[%rax+8]
    mov       [%rdi+8],	%r10
    mov       %r10,	[%rax+16]
    mov       [%rdi+16],	%r10
    mov       %r10,	[%rax+24]
    mov       [%rdi+24],	%r10
    mov       %rax,	[%rbx]
    test      %rax,	%rax
    jnz       L3708
    mov       %rax,	%rdi
    mov       [%rsi],	%rax
    mov       [%rbx],	%rax
    jmp       L3707
L3708:
    mov       %rax,	[%rsi]
    mov       %r10,	%rdi
    mov       [%rax+8],	%r10
L3707:
    xor       %eax,	%eax
    mov       [%rdi+8],	%rax
    mov       [%rsi],	%rdi
    mov       %r12,	[%r12+8]
L3705:
    test      %r12,	%r12
    jnz       L3704
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.addlistmparam
cc_lex.addlistmparam:
#?>>
#?]]
#---------------
    mov       %rax,	[%rcx]
    test      %rax,	%rax
    jnz       L3711
    mov       %rax,	%r8
    mov       [%rdx],	%rax
    mov       [%rcx],	%rax
    jmp       L3710
L3711:
    mov       %rax,	[%rdx]
    mov       %r10,	%r8
    mov       [%rax+8],	%r10
L3710:
    mov       [%rdx],	%r8
#---------------
    ret       
# End 
# Proc cc_lex.dodefine
cc_lex.dodefine:
#?>>
    .set cc_lex.dodefine.stlist, -8
    .set cc_lex.dodefine.stlistx, -16
    .set cc_lex.dodefine.tklist, -24
    .set cc_lex.dodefine.tklistx, -32
    .set cc_lex.dodefine.ntokens, -40
    .set cc_lex.dodefine.paramno, -48
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	80
#---------------
    call      cc_lex.lexreadtoken
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L3714
    lea       %rcx,	[%rip+L8508]
    call      cc_lex.lxerror
L3714:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rsi,	[%rax]
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %eax,	[%rax+16]
    mov       [%rsi+92],	%eax
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %al,	[%rax+20]
    mov       [%rsi+113],	%al
    mov       %al,	[%rsi+107]
    mov       [%rsi+88],	%al
    mov       %al,	67
    mov       [%rsi+107],	%al
    mov       %al,	1
    mov       [%rsi+109],	%al
    xor       %r14,	%r14
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	40
    jnz       L3716
    inc       qword ptr[%rip+cc_lex.lxsptr]
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.dodefine.stlistx],	%rax
    mov       [%rbp + cc_lex.dodefine.stlist],	%rax
    lea       %rax,	[%rsi+108]
    or        byte ptr[%rax],	4
    call      cc_lex.lexreadtoken
L3717:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L3720
    cmp       %rax,	14
    jz        L3721
    cmp       %rax,	21
    jz        L3722
    jmp       L3723
L3720:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %r12,	[%rax]
    mov       %rdi,	[%rbp + cc_lex.dodefine.stlist]
    jmp       L3725
L3724:
    mov       %rax,	[%rdi]
    cmp       %rax,	%r12
    jnz       L3728
    lea       %rcx,	[%rip+L8509]
    call      cc_lex.lxerror
L3728:
    mov       %rdi,	[%rdi+8]
L3725:
    test      %rdi,	%rdi
    jnz       L3724
    mov       %rcx,	16
    call      mlib.pcm_alloc
    mov       %rbx,	%rax
    mov       [%rbx],	%r12
    xor       %eax,	%eax
    mov       [%rbx+8],	%rax
    lea       %rcx,	[%rbp + cc_lex.dodefine.stlist]
    lea       %rdx,	[%rbp + cc_lex.dodefine.stlistx]
    mov       %r8,	%rbx
    call      cc_lex.addlistmparam
    inc       %r14
    call      cc_lex.lexreadtoken
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jnz       L3730
    call      cc_lex.lexreadtoken
L3730:
    jmp       L3719
L3721:
    jmp       L3718
L3722:
    lea       %rcx,	[%rip+L8510]
    call      cc_lex.addnamestr
    mov       %r12,	%rax
    lea       %rax,	[%rsi+108]
    or        byte ptr[%rax],	2
    call      cc_lex.lexreadtoken
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	14
    jz        L3732
    lea       %rcx,	[%rip+L8511]
    call      cc_lex.lxerror
L3732:
    mov       %rcx,	16
    call      mlib.pcm_alloc
    mov       %rbx,	%rax
    mov       [%rbx],	%r12
    xor       %eax,	%eax
    mov       [%rbx+8],	%rax
    lea       %rcx,	[%rbp + cc_lex.dodefine.stlist]
    lea       %rdx,	[%rbp + cc_lex.dodefine.stlistx]
    mov       %r8,	%rbx
    call      cc_lex.addlistmparam
    inc       %r14
    jmp       L3718
L3723:
    lea       %rcx,	[%rip+L8512]
    call      cc_lex.lxerror
L3719:
    jmp       L3717
L3718:
    mov       %rax,	[%rbp + cc_lex.dodefine.stlist]
    mov       [%rsi+80],	%rax
L3716:
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.dodefine.tklistx],	%rax
    mov       [%rbp + cc_lex.dodefine.tklist],	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.dodefine.ntokens],	%rax
L3733:
    call      cc_lex.lexreadtoken
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	56
    jz        L3736
    cmp       %rax,	57
    jz        L3736
    cmp       %rax,	67
    jz        L3737
    jmp       L3738
L3736:
    jmp       L3734
L3737:
    mov       %rdi,	[%rsi+80]
    mov       %rax,	1
    mov       [%rbp + cc_lex.dodefine.paramno],	%rax
    jmp       L3740
L3739:
    mov       %rax,	[%rdi]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       %r10,	[%r10]
    cmp       %rax,	%r10
    jnz       L3743
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %rax,	[%rax+23]
    mov       %r10b,	2
    or        [%rax],	%r10b
    mov       %ax,	[%rbp + cc_lex.dodefine.paramno]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+28],	%ax
    jmp       L3741
L3743:
    mov       %rdi,	[%rdi+8]
    inc       qword ptr[%rbp + cc_lex.dodefine.paramno]
L3740:
    test      %rdi,	%rdi
    jnz       L3739
L3741:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    cmp       %rax,	%rsi
    jnz       L3745
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %rax,	[%rax+23]
    mov       %r10b,	1
    or        [%rax],	%r10b
L3745:
L3738:
L3735:
    inc       qword ptr[%rbp + cc_lex.dodefine.ntokens]
    call      cc_lex.alloctoken
    mov       %r13,	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %r10,	[%rax]
    mov       [%r13],	%r10
    mov       %r10,	[%rax+8]
    mov       [%r13+8],	%r10
    mov       %r10,	[%rax+16]
    mov       [%r13+16],	%r10
    mov       %r10,	[%rax+24]
    mov       [%r13+24],	%r10
    lea       %rcx,	[%rbp + cc_lex.dodefine.tklist]
    lea       %rdx,	[%rbp + cc_lex.dodefine.tklistx]
    mov       %r8,	%r13
    call      cc_lex.addlisttoken
    jmp       L3733
L3734:
    mov       %rax,	[%rbp + cc_lex.dodefine.tklist]
    mov       [%rsi+72],	%rax
    mov       [%rsi+111],	%r14b
#---------------
    add       %rsp,	80
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.readalphanumeric
cc_lex.readalphanumeric:
#?>>
#?]]
#---------------
L3747:
L3748:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    lea       %r10,	[%rip+cc_lex.alphamap]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jnz       L3747
    dec       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	%rcx
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10],	%rax
    mov       %al,	58
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	%rcx
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
#---------------
    ret       
# End 
# Proc cc_lex.inmacrostack
cc_lex.inmacrostack:
#?>>
#?]]
#---------------
    jmp       L3752
L3751:
    mov       %rax,	[%rdx]
    cmp       %rax,	%rcx
    jnz       L3755
    mov       %rax,	1
    jmp       L3750
L3755:
    mov       %rdx,	[%rdx+8]
L3752:
    test      %rdx,	%rdx
    jnz       L3751
    xor       %eax,	%eax
L3750:
#---------------
    ret       
# End 
# Proc cc_lex.showtokens
cc_lex.showtokens:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    call      msys.m$print_startcon
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L8513]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L3758
L3757:
    mov       %rcx,	%rbx
    call      cc_lex.showtoken
    mov       %rbx,	[%rbx+8]
L3758:
    test      %rbx,	%rbx
    jnz       L3757
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8514]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.lexa
cc_lex.lexa:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	[%rdi]
    cmp       %rax,	[%rip+cc_lex.normaltk]
    jnz       L3762
    call      cc_lex.lexreadtoken
    jmp       L3760
L3762:
    mov       %rax,	[%rdi]
    test      %rax,	%rax
    jnz       L3764
    mov       %al,	57
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3760
L3764:
    mov       %rax,	[%rdi]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       %r11,	[%rax]
    mov       [%r10],	%r11
    mov       %r11,	[%rax+8]
    mov       [%r10+8],	%r11
    mov       %r11,	[%rax+16]
    mov       [%r10+16],	%r11
    mov       %r11,	[%rax+24]
    mov       [%r10+24],	%r11
    mov       %rax,	[%rdi]
    mov       %rax,	[%rax+8]
    mov       [%rdi],	%rax
L3760:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lex.lexm
cc_lex.lexm:
#?>>
    .set cc_lex.lexm.newlineno, -8
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
#---------------
L3766:
    mov       %rax,	[%rip+cc_lex.tkptr]
    test      %rax,	%rax
    jz        L3769
    mov       %rax,	[%rip+cc_lex.tkptr]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       %r11,	[%rax]
    mov       [%r10],	%r11
    mov       %r11,	[%rax+8]
    mov       [%r10+8],	%r11
    mov       %r11,	[%rax+16]
    mov       [%r10+16],	%r11
    mov       %r11,	[%rax+24]
    mov       [%r10+24],	%r11
    mov       %rax,	[%rip+cc_lex.tkptr]
    mov       %rax,	[%rax+8]
    mov       [%rip+cc_lex.tkptr],	%rax
    mov       %rax,	[%rip+cc_lex.tkptr]
    test      %rax,	%rax
    jnz       L3771
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jnz       L3773
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	1
    jnz       L3773
    call      cc_lex.peeklb
    test      %rax,	%rax
    jz        L3773
    mov       %rcx,	[%rip+cc_decls.sfileno]
    call      cc_lex.setfileno
    mov       %eax,	[%rip+cc_decls.slineno]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+16],	%eax
    xor       %eax,	%eax
    mov       [%rip+cc_lex.lexm.doreset],	%rax
    jmp       L3774
L3773:
    mov       %rax,	1
    mov       [%rip+cc_lex.lexm.doreset],	%rax
L3771:
    jmp       L3765
L3769:
    mov       %rax,	[%rip+cc_lex.lexm.doreset]
    test      %rax,	%rax
    jz        L3776
    mov       %rcx,	[%rip+cc_decls.sfileno]
    call      cc_lex.setfileno
    mov       %eax,	[%rip+cc_decls.slineno]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+16],	%eax
    xor       %eax,	%eax
    mov       [%rip+cc_lex.lexm.doreset],	%rax
L3776:
    mov       %rax,	[%rip+cc_lex.firstsymbol]
    test      %rax,	%rax
    jz        L3778
    xor       %eax,	%eax
    mov       [%rip+cc_lex.firstsymbol],	%rax
    call      cc_lex.dospecialinclude
L3778:
    call      cc_lex.lexreadtoken
#cc_lex.lexm.test1:
L3774:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	4
    jz        L3780
    cmp       %rax,	67
    jz        L3781
    jmp       L3782
L3780:
    call      cc_lex.dolexdirective
    test      %rax,	%rax
    jnz       L3765
L3784:
    jmp       L3766
L3781:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rdi,	[%rax]
    movzx     %rax,	byte ptr[%rdi+107]
    cmp       %rax,	69
    jnz       L3787
L3786:
    call      cc_lex.getfileno
    mov       [%rip+cc_decls.sfileno],	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %eax,	[%rax+16]
    mov       [%rip+cc_decls.slineno],	%rax
    movsx     %rax,	word ptr[%rdi+100]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+cc_decls.nextlx]
    mov       %r8,	[%rip+cc_decls.slineno]
    call      cc_lex.expandpredefmacro
    mov       %rax,	1
    mov       [%rip+cc_lex.lexm.doreset],	%rax
    jmp       L3765
L3787:
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	1
    jnz       L3790
    mov       %rax,	[%rip+cc_lex.noexpand]
    test      %rax,	%rax
    jz        L3789
L3790:
    jmp       L3765
L3789:
L3785:
    jmp       L3779
L3782:
    jmp       L3765
L3779:
    call      cc_lex.getfileno
    mov       [%rip+cc_decls.sfileno],	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %eax,	[%rax+16]
    mov       [%rip+cc_decls.slineno],	%rax
    movzx     %rax,	byte ptr[%rdi+108]
    shr       %eax,	2
    and       %eax,	1
    test      %rax,	%rax
    jz        L3792
    call      cc_lex.peeklb
    test      %rax,	%rax
    jz        L3765
L3794:
    sub       %rsp,	8
    lea       %rax,	[%rbp + cc_lex.lexm.newlineno]
    push      %rax
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    lea       %r8,	[%rip+cc_lex.normaltk]
    mov       %r9,	1
    sub       %rsp,	32
    call      cc_lex.expandfnmacro
    add       %rsp,	48
    mov       [%rip+cc_lex.tkptr],	%rax
    mov       %rax,	[%rbp + cc_lex.lexm.newlineno]
    mov       [%rip+cc_decls.slineno],	%rax
    jmp       L3791
L3792:
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    lea       %r8,	[%rip+cc_lex.normaltk]
    mov       %r9,	1
    call      cc_lex.expandobjmacro
    mov       [%rip+cc_lex.tkptr],	%rax
L3791:
    mov       %rax,	[%rip+cc_lex.tkptr]
    test      %rax,	%rax
    jnz       L3796
    mov       %rax,	1
    mov       [%rip+cc_lex.lexm.doreset],	%rax
L3796:
    jmp       L3766
L3765:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc cc_lex.peeklb
cc_lex.peeklb:
#?>>
#?]]
#---------------
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	40
    jz        L3800
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	32
    jnz       L3799
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax+1]
    cmp       %rax,	40
    jnz       L3799
L3800:
    mov       %rax,	1
    jmp       L3797
L3799:
    xor       %eax,	%eax
L3797:
#---------------
    ret       
# End 
# Proc cc_lex.peektk
cc_lex.peektk:
#?>>
#?]]
#---------------
    mov       %rax,	[%rcx+8]
    mov       %rcx,	%rax
    test      %rcx,	%rcx
    jnz       L3803
    xor       %eax,	%eax
    jmp       L3801
L3803:
    movzx     %rax,	byte ptr[%rcx+21]
    cmp       %rax,	13
    jnz       L3805
    mov       %rax,	1
    jmp       L3801
L3805:
    xor       %eax,	%eax
L3801:
#---------------
    ret       
# End 
# Proc cc_lex.expandobjmacro
cc_lex.expandobjmacro:
#?>>
    .set cc_lex.expandobjmacro.m, 64
    .set cc_lex.expandobjmacro.macrostack, 72
    .set cc_lex.expandobjmacro.tksource, 80
    .set cc_lex.expandobjmacro.frombaselevel, 88
    .set cc_lex.expandobjmacro.newmacro, -32
    .set cc_lex.expandobjmacro.expanded, -40
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	80
    mov       [%rbp+64],	%rcx
    mov       [%rbp+72],	%rdx
#---------------
    mov       %rax,	[%rbp + cc_lex.expandobjmacro.m]
    mov       %rax,	[%rax+72]
    mov       %rdi,	%rax
    mov       %rbx,	%rax
    xor       %eax,	%eax
    mov       %r13,	%rax
    mov       %r12,	%rax
    jmp       L3808
L3807:
    movzx     %rax,	byte ptr[%rbx+21]
    cmp       %rax,	67
    jnz       L3811
    mov       %r14,	[%rbx]
    movzx     %rax,	byte ptr[%r14+109]
    cmp       %rax,	1
    jz        L3814
    movzx     %rax,	byte ptr[%r14+107]
    cmp       %rax,	69
    jnz       L3813
L3814:
    mov       %r12,	1
    jmp       L3809
L3813:
    jmp       L3810
L3811:
    movzx     %rax,	byte ptr[%rbx+21]
    cmp       %rax,	7
    jnz       L3815
    mov       %rax,	1
    mov       %r13,	%rax
    mov       %r12,	%rax
    jmp       L3809
L3815:
L3810:
    mov       %rbx,	[%rbx+8]
L3808:
    test      %rbx,	%rbx
    jnz       L3807
L3809:
    test      %r12,	%r12
    jnz       L3817
    mov       %rax,	%rdi
    jmp       L3806
L3817:
    mov       %rax,	[%rbp + cc_lex.expandobjmacro.m]
    mov       [%rbp + cc_lex.expandobjmacro.newmacro],	%rax
    mov       %rax,	[%rbp + cc_lex.expandobjmacro.macrostack]
    mov       [%rbp + cc_lex.expandobjmacro.newmacro+8],	%rax
    test      %r13,	%r13
    jz        L3819
    sub       %rsp,	8
    push      0
    mov       %rcx,	[%rbp + cc_lex.expandobjmacro.m]
    xor       %edx,	%edx
    xor       %r8d,	%r8d
    xor       %r9d,	%r9d
    sub       %rsp,	32
    call      cc_lex.substituteargs
    add       %rsp,	48
    mov       %rsi,	%rax
    jmp       L3818
L3819:
    mov       %rax,	[%rbp + cc_lex.expandobjmacro.m]
    mov       %rsi,	[%rax+72]
L3818:
    mov       %rcx,	%rsi
    lea       %rdx,	[%rbp + cc_lex.expandobjmacro.newmacro]
    lea       %r8,	[%rbp + cc_lex.expandobjmacro.expanded]
    call      cc_lex.scantokenseq
    mov       %rdi,	%rax
    mov       %rax,	%rdi
L3806:
#---------------
    add       %rsp,	80
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.expandfnmacro
cc_lex.expandfnmacro:
#?>>
    .set cc_lex.expandfnmacro.frombaselevel, 88
    .set cc_lex.expandfnmacro.endlineno, 96
    .set cc_lex.expandfnmacro.args, -1600
    .set cc_lex.expandfnmacro.expargs, -3200
    .set cc_lex.expandfnmacro.newmacro, -3232
    .set cc_lex.expandfnmacro.expanded, -3240
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	3280
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
    mov       [%rbp+88],	%r9
#---------------
    mov       %rcx,	%r12
    lea       %rdx,	[%rbp + cc_lex.expandfnmacro.args]
    mov       %r8,	%r14
    call      cc_lex.readmacrocall
    mov       %rbx,	%rax
    mov       %rax,	[%rbp + cc_lex.expandfnmacro.frombaselevel]
    test      %rax,	%rax
    jz        L3822
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %eax,	[%rax+16]
    mov       %r10,	[%rbp + cc_lex.expandfnmacro.endlineno]
    mov       [%r10],	%rax
L3822:
    mov       %rsi,	1
    cmp       %rbx,	1
    jl        L3825
L3823:
    xor       %eax,	%eax
    mov       [%rbp + %rsi*8 + cc_lex.expandfnmacro.expargs-8],	%rax
    inc       %rsi
    cmp       %rsi,	%rbx
    jle       L3823
L3825:
    sub       %rsp,	8
    mov       %rax,	%r13
    push      %rax
    mov       %rcx,	%r12
    lea       %rdx,	[%rbp + cc_lex.expandfnmacro.args]
    lea       %r8,	[%rbp + cc_lex.expandfnmacro.expargs]
    mov       %r9,	%rbx
    sub       %rsp,	32
    call      cc_lex.substituteargs
    add       %rsp,	48
    mov       %rdi,	%rax
    mov       [%rbp + cc_lex.expandfnmacro.newmacro],	%r12
    mov       [%rbp + cc_lex.expandfnmacro.newmacro+8],	%r13
    mov       %rcx,	%rdi
    lea       %rdx,	[%rbp + cc_lex.expandfnmacro.newmacro]
    lea       %r8,	[%rbp + cc_lex.expandfnmacro.expanded]
    call      cc_lex.scantokenseq
    mov       %rdi,	%rax
    mov       %rax,	%rdi
L3820:
#---------------
    add       %rsp,	3280
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.scantokenseq
cc_lex.scantokenseq:
#?>>
    .set cc_lex.scantokenseq.tk, 64
    .set cc_lex.scantokenseq.expanded, 80
    .set cc_lex.scantokenseq.newtk, -8
    .set cc_lex.scantokenseq.newtkx, -16
    .set cc_lex.scantokenseq.dummy, -24
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	64
    mov       [%rbp+64],	%rcx
    mov       %r14,	%rdx
    mov       [%rbp+80],	%r8
#---------------
#cc_lex.scantokenseq.reenter:
L3827:
    xor       %eax,	%eax
    mov       %r10,	[%rbp + cc_lex.scantokenseq.expanded]
    mov       [%r10],	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.scantokenseq.newtkx],	%rax
    mov       [%rbp + cc_lex.scantokenseq.newtk],	%rax
    xor       %r12,	%r12
    mov       %rax,	1
    mov       %r13,	%rax
    mov       %rbx,	[%rbp + cc_lex.scantokenseq.tk]
    jmp       L3829
L3828:
    mov       %rax,	[%rbp + cc_lex.scantokenseq.tk]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jnz       L3833
L3832:
    mov       %rax,	[%rbp + cc_lex.scantokenseq.tk]
    mov       %rax,	[%rax]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	1
    jz        L3836
    mov       %rax,	[%rbp + cc_lex.scantokenseq.tk]
    mov       %rax,	[%rax]
    movzx     %rax,	byte ptr[%rax+107]
    cmp       %rax,	69
    jnz       L3835
L3836:
    xor       %r13,	%r13
    jmp       L3830
L3835:
L3833:
L3831:
    mov       %rax,	[%rbp + cc_lex.scantokenseq.tk]
    test      %rax,	%rax
    jz        L3830
L3838:
    mov       %rax,	[%rbp + cc_lex.scantokenseq.tk]
    mov       %rax,	[%rax+8]
    mov       [%rbp + cc_lex.scantokenseq.tk],	%rax
L3829:
    mov       %rax,	[%rbp + cc_lex.scantokenseq.tk]
    test      %rax,	%rax
    jnz       L3828
L3830:
    test      %r13,	%r13
    jz        L3840
    mov       %rax,	%rbx
    jmp       L3826
L3840:
    mov       [%rbp + cc_lex.scantokenseq.tk],	%rbx
    jmp       L3842
L3841:
    mov       %rax,	[%rbp + cc_lex.scantokenseq.tk]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jnz       L3846
L3845:
    mov       %rax,	[%rbp + cc_lex.scantokenseq.tk]
    mov       %rsi,	[%rax]
    movzx     %rax,	byte ptr[%rsi+109]
    cmp       %rax,	1
    jnz       L3848
    test      %r12,	%r12
    jnz       L3848
    mov       %rax,	[%rbp + cc_lex.scantokenseq.tk]
    movzx     %rax,	byte ptr[%rax+23]
    and       %rax,	4
    jnz       L3851
    mov       %rax,	[%rip+cc_lex.noexpand]
    test      %rax,	%rax
    jz        L3850
L3851:
    jmp       L3852
L3850:
    mov       %rcx,	%rsi
    mov       %rdx,	%r14
    call      cc_lex.inmacrostack
    test      %rax,	%rax
    jz        L3854
    lea       %rcx,	[%rbp + cc_lex.scantokenseq.newtk]
    lea       %rdx,	[%rbp + cc_lex.scantokenseq.newtkx]
    mov       %r8,	[%rbp + cc_lex.scantokenseq.tk]
    call      cc_lex.addlisttoken_copy
    mov       %rax,	[%rbp + cc_lex.scantokenseq.newtkx]
    lea       %rax,	[%rax+23]
    mov       %r10b,	4
    or        [%rax],	%r10b
    jmp       L3855
L3854:
    xor       %r13,	%r13
    movzx     %rax,	byte ptr[%rsi+108]
    shr       %eax,	2
    and       %eax,	1
    test      %rax,	%rax
    jz        L3857
    mov       %rcx,	[%rbp + cc_lex.scantokenseq.tk]
    call      cc_lex.peektk
    test      %rax,	%rax
    jz        L3852
L3859:
    lea       %rcx,	[%rbp + cc_lex.scantokenseq.tk]
    call      cc_lex.lexa
    sub       %rsp,	8
    lea       %rax,	[%rbp + cc_lex.scantokenseq.dummy]
    push      %rax
    mov       %rcx,	%rsi
    mov       %rdx,	%r14
    lea       %r8,	[%rbp + cc_lex.scantokenseq.tk]
    mov       %r9,	1
    sub       %rsp,	32
    call      cc_lex.expandfnmacro
    add       %rsp,	48
    mov       %rdi,	%rax
    lea       %rcx,	[%rbp + cc_lex.scantokenseq.newtk]
    lea       %rdx,	[%rbp + cc_lex.scantokenseq.newtkx]
    mov       %r8,	%rdi
    call      cc_lex.addlisttoken_seq
    mov       %rax,	1
    mov       %r10,	[%rbp + cc_lex.scantokenseq.expanded]
    mov       [%r10],	%rax
    jmp       L3842
L3857:
    mov       %rcx,	%rsi
    mov       %rdx,	%r14
    lea       %r8,	[%rbp + cc_lex.scantokenseq.tk]
    xor       %r9d,	%r9d
    call      cc_lex.expandobjmacro
    mov       %rdi,	%rax
    mov       %rax,	1
    mov       %r10,	[%rbp + cc_lex.scantokenseq.expanded]
    mov       [%r10],	%rax
    lea       %rcx,	[%rbp + cc_lex.scantokenseq.newtk]
    lea       %rdx,	[%rbp + cc_lex.scantokenseq.newtkx]
    mov       %r8,	%rdi
    call      cc_lex.addlisttoken_seq
L3856:
    jmp       L3847
L3848:
    movzx     %rax,	byte ptr[%rsi+107]
    cmp       %rax,	93
    jnz       L3860
    mov       %r12,	1
    jmp       L3852
L3860:
    movzx     %rax,	byte ptr[%rsi+107]
    cmp       %rax,	69
    jnz       L3861
    call      cc_lex.alloctokenz
    mov       %rdi,	%rax
    movsx     %rax,	word ptr[%rsi+100]
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    mov       %r8,	[%rip+cc_decls.slineno]
    call      cc_lex.expandpredefmacro
    lea       %rcx,	[%rbp + cc_lex.scantokenseq.newtk]
    lea       %rdx,	[%rbp + cc_lex.scantokenseq.newtkx]
    mov       %r8,	%rdi
    call      cc_lex.addlisttoken_copy
    jmp       L3862
L3861:
    xor       %r12,	%r12
    jmp       L3852
L3847:
    jmp       L3844
L3846:
#cc_lex.scantokenseq.simpletoken:
L3852:
    lea       %rcx,	[%rbp + cc_lex.scantokenseq.newtk]
    lea       %rdx,	[%rbp + cc_lex.scantokenseq.newtkx]
    mov       %r8,	[%rbp + cc_lex.scantokenseq.tk]
    call      cc_lex.addlisttoken_copy
L3844:
#cc_lex.scantokenseq.skip:
L3855:
    mov       %rax,	[%rbp + cc_lex.scantokenseq.tk]
    test      %rax,	%rax
    jz        L3843
L3864:
#cc_lex.scantokenseq.skip2:
L3862:
    mov       %rax,	[%rbp + cc_lex.scantokenseq.tk]
    mov       %rax,	[%rax+8]
    mov       [%rbp + cc_lex.scantokenseq.tk],	%rax
L3842:
    mov       %rax,	[%rbp + cc_lex.scantokenseq.tk]
    test      %rax,	%rax
    jnz       L3841
L3843:
    mov       %rax,	[%rbp + cc_lex.scantokenseq.expanded]
    mov       %rax,	[%rax]
    test      %rax,	%rax
    jz        L3866
    mov       %rax,	[%rbp + cc_lex.scantokenseq.newtk]
    mov       [%rbp + cc_lex.scantokenseq.tk],	%rax
    jmp       L3827
L3866:
    mov       %rax,	[%rbp + cc_lex.scantokenseq.newtk]
L3826:
#---------------
    add       %rsp,	64
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.readmacrocall
cc_lex.readmacrocall:
#?>>
    .set cc_lex.readmacrocall.args, 80
    .set cc_lex.readmacrocall.tksource, 88
    .set cc_lex.readmacrocall.tklist, -8
    .set cc_lex.readmacrocall.tklistx, -16
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	56
    mov       %r15,	%rcx
    mov       [%rbp+80],	%rdx
    mov       [%rbp+88],	%r8
#---------------
    mov       %rcx,	[%rbp + cc_lex.readmacrocall.tksource]
    call      cc_lex.lexa
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	13
    jz        L3869
    lea       %rcx,	[%rip+L8515]
    call      cc_lex.lxerror
L3869:
    movzx     %rax,	byte ptr[%r15+111]
    mov       %rdi,	%rax
    xor       %r12,	%r12
    mov       %rax,	%rdi
    test      %rax,	%rax
    jnz       L3871
    mov       %rcx,	[%rbp + cc_lex.readmacrocall.tksource]
    call      cc_lex.lexa
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	14
    jz        L3873
    lea       %rcx,	[%rip+L8516]
    call      cc_lex.lxerror
L3873:
    xor       %eax,	%eax
    jmp       L3867
L3871:
    mov       %rsi,	1
    mov       %rbx,	1
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.readmacrocall.tklistx],	%rax
    mov       [%rbp + cc_lex.readmacrocall.tklist],	%rax
    movzx     %rax,	byte ptr[%r15+108]
    shr       %eax,	1
    and       %eax,	1
    mov       %r13,	%rax
    xor       %r14,	%r14
L3874:
    cmp       %rsi,	%rdi
    jnz       L3877
    test      %r13,	%r13
    jz        L3877
    mov       %r14,	1
L3877:
    mov       %rcx,	[%rbp + cc_lex.readmacrocall.tksource]
    call      cc_lex.lexa
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jz        L3879
    cmp       %rax,	57
    jz        L3880
    cmp       %rax,	13
    jz        L3881
    cmp       %rax,	14
    jz        L3882
    jmp       L3883
L3879:
    cmp       %rbx,	1
    jnz       L3885
    test      %r14,	%r14
    jnz       L3885
    mov       %rax,	[%rbp + cc_lex.readmacrocall.tklist]
    test      %rax,	%rax
    jnz       L3887
    call      cc_lex.alloctokenz
    mov       [%rbp + cc_lex.readmacrocall.tklist],	%rax
    call      cc_lex.getfileno
    mov       %rcx,	[%rbp + cc_lex.readmacrocall.tklist]
    mov       %rdx,	%rax
    call      cc_lex.setfilenox
    mov       %al,	66
    mov       %r10,	[%rbp + cc_lex.readmacrocall.tklist]
    mov       [%r10+21],	%al
L3887:
    mov       %rax,	[%rbp + cc_lex.readmacrocall.tklist]
    mov       %r10,	[%rbp + cc_lex.readmacrocall.args]
    mov       %r11,	%rsi
    mov       [%r10 + %r11*8-8],	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.readmacrocall.tklistx],	%rax
    mov       [%rbp + cc_lex.readmacrocall.tklist],	%rax
    inc       %rsi
    jmp       L3884
L3885:
    jmp       L3888
L3884:
    jmp       L3878
L3880:
    lea       %rcx,	[%rip+L8517]
    call      cc_lex.lxerror
    jmp       L3878
L3881:
    inc       %rbx
    jmp       L3888
L3882:
    cmp       %rbx,	1
    jle       L3890
    dec       %rbx
    lea       %rcx,	[%rbp + cc_lex.readmacrocall.tklist]
    lea       %rdx,	[%rbp + cc_lex.readmacrocall.tklistx]
    call      cc_lex.addlist_nextlx
    jmp       L3889
L3890:
    mov       %rax,	[%rbp + cc_lex.readmacrocall.tklist]
    test      %rax,	%rax
    jnz       L3892
    call      cc_lex.alloctokenz
    mov       [%rbp + cc_lex.readmacrocall.tklist],	%rax
    call      cc_lex.getfileno
    mov       %rcx,	[%rbp + cc_lex.readmacrocall.tklist]
    mov       %rdx,	%rax
    call      cc_lex.setfilenox
    mov       %al,	66
    mov       %r10,	[%rbp + cc_lex.readmacrocall.tklist]
    mov       [%r10+21],	%al
L3892:
    mov       %rax,	[%rbp + cc_lex.readmacrocall.tklist]
    mov       %r10,	[%rbp + cc_lex.readmacrocall.args]
    mov       %r11,	%rsi
    mov       [%r10 + %r11*8-8],	%rax
    jmp       L3875
L3889:
    jmp       L3878
L3883:
#cc_lex.readmacrocall.addtoken:
L3888:
    lea       %rcx,	[%rbp + cc_lex.readmacrocall.tklist]
    lea       %rdx,	[%rbp + cc_lex.readmacrocall.tklistx]
    call      cc_lex.addlist_nextlx
L3878:
    jmp       L3874
L3875:
    cmp       %rsi,	%rdi
    jz        L3894
    lea       %rax,	[%rsi+1]
    cmp       %rax,	%rdi
    jnz       L3896
    test      %r13,	%r13
    jz        L3896
    xor       %eax,	%eax
    mov       %r10,	[%rbp + cc_lex.readmacrocall.args]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*8-8],	%rax
    jmp       L3895
L3896:
    lea       %rcx,	[%rip+L8518]
    call      cc_lex.lxerror
L3895:
L3894:
    mov       %rax,	%rdi
L3867:
#---------------
    add       %rsp,	56
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.substituteargs
cc_lex.substituteargs:
#?>>
    .set cc_lex.substituteargs.expargs, 80
    .set cc_lex.substituteargs.nargs, 88
    .set cc_lex.substituteargs.macrostack, 96
    .set cc_lex.substituteargs.newtk, -8
    .set cc_lex.substituteargs.newtkx, -16
    .set cc_lex.substituteargs.niltk, -24
    .set cc_lex.substituteargs.tkexp, -32
    .set cc_lex.substituteargs.tk, -64
    .set cc_lex.substituteargs.n, -72
    .set cc_lex.substituteargs.i, -80
    .set cc_lex.substituteargs.expanded, -88
    .set cc_lex.substituteargs.hhpoints, -2088
    .set cc_lex.substituteargs.nhashhash, -2096
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	2128
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       [%rbp+80],	%r8
    mov       [%rbp+88],	%r9
#---------------
    mov       %rdi,	[%r13+80]
    mov       %rax,	[%r13+72]
    mov       %rsi,	%rax
    mov       %rbx,	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.substituteargs.newtkx],	%rax
    mov       [%rbp + cc_lex.substituteargs.newtk],	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.substituteargs.nhashhash],	%rax
    xor       %r12,	%r12
    jmp       L3899
L3898:
    movzx     %rax,	byte ptr[%rbx+21]
    cmp       %rax,	5
    jz        L3902
    cmp       %rax,	7
    jz        L3903
    jmp       L3904
L3902:
    mov       %rax,	[%rbp + cc_lex.substituteargs.nargs]
    test      %rax,	%rax
    jz        L3906
    mov       %rbx,	[%rbx+8]
    test      %rbx,	%rbx
    jnz       L3908
    lea       %rcx,	[%rip+L8519]
    call      cc_lex.lxerror
L3908:
    movzx     %rax,	byte ptr[%rbx+23]
    and       %rax,	2
    jnz       L3910
    lea       %rcx,	[%rip+L8520]
    call      cc_lex.lxerror
L3910:
    movsx     %rax,	word ptr[%rbx+28]
    mov       [%rbp + cc_lex.substituteargs.n],	%rax
    mov       %rax,	[%rbp + cc_lex.substituteargs.n]
    mov       %rax,	[%r14 + %rax*8-8]
    mov       %rcx,	%rax
    lea       %rdx,	[%rbp + cc_lex.substituteargs.tk]
    call      cc_lex.stringify
    lea       %rcx,	[%rbp + cc_lex.substituteargs.newtk]
    lea       %rdx,	[%rbp + cc_lex.substituteargs.newtkx]
    lea       %r8,	[%rbp + cc_lex.substituteargs.tk]
    call      cc_lex.addlisttoken_copy
    jmp       L3905
L3906:
    lea       %rcx,	[%rbp + cc_lex.substituteargs.newtk]
    lea       %rdx,	[%rbp + cc_lex.substituteargs.newtkx]
    mov       %r8,	%rbx
    call      cc_lex.addlisttoken
    mov       %al,	6
    mov       %r10,	[%rbp + cc_lex.substituteargs.newtkx]
    mov       [%r10+21],	%al
L3905:
    jmp       L3901
L3903:
    cmp       %rbx,	%rsi
    jnz       L3912
    lea       %rcx,	[%rip+L8521]
    call      cc_lex.lxerror
L3912:
    mov       %rax,	[%rbp + cc_lex.substituteargs.nhashhash]
    cmp       %rax,	250
    jl        L3914
    lea       %rcx,	[%rip+L8522]
    call      cc_lex.lxerror
L3914:
    inc       qword ptr[%rbp + cc_lex.substituteargs.nhashhash]
    mov       %rax,	[%rbp + cc_lex.substituteargs.nhashhash]
    mov       %r10,	[%rbp + cc_lex.substituteargs.newtkx]
    mov       [%rbp + %rax*8 + cc_lex.substituteargs.hhpoints-8],	%r10
    jmp       L3901
L3904:
    movzx     %rax,	byte ptr[%rbx+21]
    cmp       %rax,	67
    jnz       L3916
    movzx     %rax,	byte ptr[%rbx+23]
    and       %rax,	2
    jz        L3916
    mov       %rax,	[%rbp + cc_lex.substituteargs.nargs]
    test      %rax,	%rax
    jz        L3916
    movsx     %rax,	word ptr[%rbx+28]
    mov       [%rbp + cc_lex.substituteargs.n],	%rax
    mov       %rax,	[%rbx+8]
    test      %rax,	%rax
    jz        L3920
    mov       %rax,	[%rbx+8]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	7
    jz        L3919
L3920:
    test      %r12,	%r12
    jz        L3918
    movzx     %rax,	byte ptr[%r12+21]
    cmp       %rax,	7
    jnz       L3918
L3919:
    mov       %rax,	[%rbp + cc_lex.substituteargs.n]
    mov       %rax,	[%r14 + %rax*8-8]
    lea       %rcx,	[%rbp + cc_lex.substituteargs.newtk]
    lea       %rdx,	[%rbp + cc_lex.substituteargs.newtkx]
    mov       %r8,	%rax
    call      cc_lex.addlisttoken_seq
    jmp       L3917
L3918:
    mov       %rax,	[%rbp + cc_lex.substituteargs.expargs]
    mov       %r10,	[%rbp + cc_lex.substituteargs.n]
    mov       %rax,	[%rax + %r10*8-8]
    mov       [%rbp + cc_lex.substituteargs.tkexp],	%rax
    mov       %rax,	[%rbp + cc_lex.substituteargs.tkexp]
    test      %rax,	%rax
    jnz       L3922
    mov       %rax,	[%rbp + cc_lex.substituteargs.n]
    mov       %rax,	[%r14 + %rax*8-8]
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + cc_lex.substituteargs.macrostack]
    lea       %r8,	[%rbp + cc_lex.substituteargs.expanded]
    call      cc_lex.scantokenseq
    mov       %r10,	[%rbp + cc_lex.substituteargs.expargs]
    mov       %r11,	[%rbp + cc_lex.substituteargs.n]
    mov       [%r10 + %r11*8-8],	%rax
    mov       [%rbp + cc_lex.substituteargs.tkexp],	%rax
L3922:
    lea       %rcx,	[%rbp + cc_lex.substituteargs.newtk]
    lea       %rdx,	[%rbp + cc_lex.substituteargs.newtkx]
    mov       %r8,	[%rbp + cc_lex.substituteargs.tkexp]
    call      cc_lex.addlisttoken_seq
L3917:
    jmp       L3915
L3916:
#cc_lex.substituteargs.doother:
    lea       %rcx,	[%rbp + cc_lex.substituteargs.newtk]
    lea       %rdx,	[%rbp + cc_lex.substituteargs.newtkx]
    mov       %r8,	%rbx
    call      cc_lex.addlisttoken_copy
L3915:
L3901:
    mov       %r12,	%rbx
    mov       %rbx,	[%rbx+8]
L3899:
    test      %rbx,	%rbx
    jnz       L3898
    mov       %rax,	[%rbp + cc_lex.substituteargs.nhashhash]
    test      %rax,	%rax
    jz        L3925
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.substituteargs.niltk],	%rax
    mov       %rax,	1
    mov       [%rbp + cc_lex.substituteargs.i],	%rax
    mov       %rax,	[%rbp + cc_lex.substituteargs.nhashhash]
    cmp       %rax,	1
    jl        L3928
L3926:
    mov       %rax,	[%rbp + cc_lex.substituteargs.i]
    cmp       %rax,	[%rbp + cc_lex.substituteargs.nhashhash]
    jge       L3930
    mov       %rax,	[%rbp + cc_lex.substituteargs.i]
    lea       %r10,	[%rbp + %rax*8 + cc_lex.substituteargs.hhpoints]
    mov       %rax,	%r10
    jmp       L3929
L3930:
    lea       %rax,	[%rbp + cc_lex.substituteargs.niltk]
L3929:
    mov       %r10,	[%rbp + cc_lex.substituteargs.i]
    mov       %r10,	[%rbp + %r10*8 + cc_lex.substituteargs.hhpoints-8]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      cc_lex.pastetokens
    mov       %rax,	[%rbp + cc_lex.substituteargs.i]
    inc       %rax
    mov       [%rbp + cc_lex.substituteargs.i],	%rax
    cmp       %rax,	[%rbp + cc_lex.substituteargs.nhashhash]
    jle       L3926
L3928:
L3925:
    mov       %rax,	[%rbp + cc_lex.substituteargs.newtk]
L3897:
#---------------
    add       %rsp,	2128
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.strtoken
cc_lex.strtoken:
#?>>
    .set cc_lex.strtoken.l, -32
    .set cc_lex.strtoken.$T1, -40
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	80
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    mov       %rax,	%rsi
    lea       %r10,	[%rbp + cc_lex.strtoken.l]
    mov       %r11,	[%rax]
    mov       [%r10],	%r11
    mov       %r11,	[%rax+8]
    mov       [%r10+8],	%r11
    mov       %r11,	[%rax+16]
    mov       [%r10+16],	%r11
    mov       %r11,	[%rax+24]
    mov       [%r10+24],	%r11
    movzx     %rax,	byte ptr[%rbp + cc_lex.strtoken.l+21]
    cmp       %rax,	67
    jz        L3933
    cmp       %rax,	59
    jz        L3934
    cmp       %rax,	60
    jz        L3934
    cmp       %rax,	58
    jz        L3935
    cmp       %rax,	63
    jz        L3936
    cmp       %rax,	64
    jz        L3936
    cmp       %rax,	61
    jz        L3937
    cmp       %rax,	56
    jz        L3938
    cmp       %rax,	57
    jz        L3939
    cmp       %rax,	71
    jz        L3940
    cmp       %rax,	87
    jz        L3940
    cmp       %rax,	86
    jz        L3940
    cmp       %rax,	89
    jz        L3940
    jmp       L3941
L3933:
#cc_lex.strtoken.doname:
L3942:
    mov       %rax,	[%rbp + cc_lex.strtoken.l]
    movzx     %rax,	byte ptr[%rax+106]
    mov       [%r12],	%rax
    mov       %rax,	[%rbp + cc_lex.strtoken.l]
    mov       %rax,	[%rax]
    jmp       L3931
L3934:
    movsxd    %rax,	dword ptr[%rbp + cc_lex.strtoken.l+24]
    mov       [%r12],	%rax
    lea       %rcx,	[%rbp + cc_lex.strtoken.l]
    call      cc_lex.getfilenox
    test      %rax,	%rax
    jz        L3944
    lea       %rcx,	[%rbp + cc_lex.strtoken.l]
    call      cc_lex.getfilenox
    lea       %r10,	[%rip+cc_decls.sourcefiletext]
    mov       %r10,	[%r10 + %rax*8]
    mov       [%rbp + cc_lex.strtoken.$T1],	%r10
    lea       %rcx,	[%rbp + cc_lex.strtoken.l]
    call      cc_lex.getnumberoffsetx
    mov       %r10,	[%rbp + cc_lex.strtoken.$T1]
    lea       %r10,	[%r10 + %rax]
    mov       %rax,	%r10
    jmp       L3931
L3944:
    movsx     %rax,	word ptr[%rbp + cc_lex.strtoken.l+28]
    lea       %r10,	[%rip+cc_lex.pastedtokenlist]
    mov       %r10,	[%r10 + %rax*8-8]
    mov       %rax,	%r10
    jmp       L3931
L3943:
    jmp       L3932
L3935:
    movsxd    %rax,	dword ptr[%rbp + cc_lex.strtoken.l+24]
    mov       [%r12],	%rax
    mov       %rax,	[%rbp + cc_lex.strtoken.l]
    jmp       L3931
L3936:
    movsxd    %rax,	dword ptr[%rbp + cc_lex.strtoken.l+24]
    mov       %r10,	[%rbp + cc_lex.strtoken.l]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    mov       %r8,	%r12
    mov       %r9,	34
    call      cc_lex.strstring
    mov       %rbx,	%rax
    mov       %rax,	%rbx
    jmp       L3931
L3937:
    movsxd    %rax,	dword ptr[%rbp + cc_lex.strtoken.l+24]
    mov       %r10,	[%rbp + cc_lex.strtoken.l]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    mov       %r8,	%r12
    mov       %r9,	39
    call      cc_lex.strstring
    mov       %rbx,	%rax
    mov       %rax,	%rbx
    jmp       L3931
L3938:
    mov       %rax,	[%rip+cc_lex.dowhitespace]
    test      %rax,	%rax
    jz        L3946
    movsxd    %rax,	dword ptr[%rbp + cc_lex.strtoken.l+24]
    inc       %rax
    mov       [%r12],	%rax
    mov       %rax,	[%r12]
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       %rbx,	%rax
    mov       %al,	10
    mov       [%rbx],	%al
    movsxd    %rax,	dword ptr[%rbp + cc_lex.strtoken.l+24]
    mov       %r10,	[%rbp + cc_lex.strtoken.l]
    lea       %r11,	[%rbx+1]
    mov       %rcx,	%r11
    mov       %rdx,	%r10
    mov       %r8,	%rax
    call      memcpy
    jmp       L3945
L3946:
    mov       %rax,	1
    mov       [%r12],	%rax
    lea       %rax,	[%rip+L8523]
    jmp       L3931
L3945:
    mov       %rax,	%rbx
    jmp       L3931
L3939:
    xor       %eax,	%eax
    mov       [%r12],	%rax
    lea       %rax,	[%rip+L8524]
    jmp       L3931
L3940:
    jmp       L3942
L3941:
    movzx     %rax,	byte ptr[%rbp + cc_lex.strtoken.l+21]
    lea       %r10,	[%rip+cc_tables.shortsymbolnames]
    mov       %r10,	[%r10 + %rax*8-8]
    mov       %rdi,	%r10
    mov       %rcx,	%rdi
    call      strlen
    mov       [%r12],	%rax
    test      %rax,	%rax
    jz        L3948
    movzx     %rax,	byte ptr[%rdi]
    cmp       %rax,	107
    jz        L3950
    mov       %rax,	%rdi
    jmp       L3931
L3950:
    movzx     %rax,	byte ptr[%rbp + cc_lex.strtoken.l+21]
    lea       %r10,	[%rip+cc_tables.symbolnames]
    mov       %r10,	[%r10 + %rax*8-8]
    lea       %r10,	[%r10+1]
    mov       %rcx,	%r10
    call      strlen
    mov       [%r12],	%rax
    movzx     %rax,	byte ptr[%rbp + cc_lex.strtoken.l+21]
    lea       %r10,	[%rip+cc_tables.symbolnames]
    mov       %r10,	[%r10 + %rax*8-8]
    lea       %r10,	[%r10+1]
    mov       %rax,	%r10
    jmp       L3931
L3949:
    jmp       L3947
L3948:
    lea       %rax,	[%rip+L8524]
    jmp       L3931
L3947:
L3932:
    lea       %rax,	[%rip+L8524]
L3931:
#---------------
    add       %rsp,	80
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.strstring
cc_lex.strstring:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
    mov       %r14,	%r9
#---------------
    mov       %rax,	%r12
    shl       %rax,	1
    add       %rax,	4
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       %rbx,	%rax
    mov       %rdi,	%rax
    test      %r14,	%r14
    jz        L3953
    mov       [%rbx],	%r14b
    inc       %rbx
L3953:
    mov       %rcx,	%rsi
    mov       %rdx,	%rbx
    mov       %r8,	%r12
    call      cc_lib.convertstringc
    mov       %rcx,	%rdi
    call      strlen
    mov       [%r13],	%rax
    test      %r14,	%r14
    jz        L3955
    mov       %rax,	[%r13]
    mov       %r10b,	%r14b
    mov       [%rdi + %rax],	%r10b
    mov       %rax,	%r13
    inc       qword ptr[%rax]
L3955:
    mov       %rax,	%rdi
L3951:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.emittoken
cc_lex.emittoken:
#?>>
    .set cc_lex.emittoken.length, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    movzx     %rax,	byte ptr[%rbx+21]
    cmp       %rax,	56
    jnz       L3958
    mov       %rax,	[%rip+cc_lex.lasttoken]
    cmp       %rax,	56
    jz        L3956
L3958:
    mov       %rcx,	%rbx
    lea       %rdx,	[%rbp + cc_lex.emittoken.length]
    call      cc_lex.strtoken
    mov       %rdi,	%rax
    test      %r12,	%r12
    jnz       L3961
    movzx     %rax,	byte ptr[%rbx+21]
    mov       %rcx,	[%rip+cc_lex.lasttoken]
    mov       %rdx,	%rax
    call      cc_lex.needspace
    test      %rax,	%rax
    jz        L3960
L3961:
    mov       %rcx,	%rsi
    mov       %rdx,	32
    call      mlib.gs_char
L3960:
    mov       %rcx,	%rsi
    mov       %rdx,	%rdi
    mov       %r8,	[%rbp + cc_lex.emittoken.length]
    call      mlib.gs_strn
    movzx     %rax,	byte ptr[%rbx+21]
    mov       [%rip+cc_lex.lasttoken],	%rax
L3956:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.showtoken
cc_lex.showtoken:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	[%rip+cc_lex.showtoken.dest]
    call      mlib.gs_init
    mov       %rcx,	%rdi
    mov       %rdx,	[%rip+cc_lex.showtoken.dest]
    xor       %r8d,	%r8d
    call      cc_lex.emittoken
    call      msys.m$print_startcon
    mov       %rax,	[%rip+cc_lex.showtoken.dest]
    movsxd    %rax,	dword ptr[%rax+8]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8525]
    call      msys.m$print_i64
    call      msys.m$print_nogap
    mov       %rax,	[%rip+cc_lex.showtoken.dest]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8526]
    call      msys.m$print_str
    call      msys.m$print_end
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lex.stringify
cc_lex.stringify:
#?>>
    .set cc_lex.stringify.length, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    mov       %al,	63
    mov       [%r12+21],	%al
    xor       %eax,	%eax
    mov       [%r12+8],	%rax
    mov       %rax,	[%rsi+8]
    test      %rax,	%rax
    jnz       L3965
    mov       %rcx,	%rsi
    lea       %rdx,	[%rbp + cc_lex.stringify.length]
    call      cc_lex.strtoken
    mov       %rdi,	%rax
    mov       %eax,	[%rbp + cc_lex.stringify.length]
    mov       [%r12+24],	%eax
    mov       [%r12],	%rdi
    jmp       L3963
L3965:
    mov       %rcx,	[%rip+cc_lex.stringify.deststr]
    call      mlib.gs_init
    xor       %eax,	%eax
    mov       [%rip+cc_lex.lasttoken],	%rax
    xor       %rbx,	%rbx
    jmp       L3967
L3966:
    mov       %rcx,	%rsi
    mov       %rdx,	[%rip+cc_lex.stringify.deststr]
    mov       %r8,	%rbx
    call      cc_lex.emittoken
    mov       %rbx,	1
    mov       %rsi,	[%rsi+8]
L3967:
    test      %rsi,	%rsi
    jnz       L3966
    mov       %eax,	[%rbp + cc_lex.stringify.length]
    mov       [%r12+24],	%eax
    mov       %rax,	[%rip+cc_lex.stringify.deststr]
    mov       %rax,	[%rax]
    mov       [%r12],	%rax
    mov       %rax,	[%rip+cc_lex.stringify.deststr]
    mov       %eax,	[%rax+8]
    mov       [%r12+24],	%eax
L3963:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.pastetokens
cc_lex.pastetokens:
#?>>
    .set cc_lex.pastetokens.tk, 64
    .set cc_lex.pastetokens.tknext, 72
    .set cc_lex.pastetokens.length1, -8
    .set cc_lex.pastetokens.length2, -16
    .set cc_lex.pastetokens.oldtoken, -48
    .set cc_lex.pastetokens.token, -80
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	112
    mov       [%rbp+64],	%rcx
    mov       [%rbp+72],	%rdx
#---------------
    mov       %rax,	[%rbp + cc_lex.pastetokens.tk]
    mov       %rdi,	[%rax+8]
    mov       %rax,	[%rbp + cc_lex.pastetokens.tknext]
    mov       %rax,	[%rax]
    mov       %r10,	%rdi
    cmp       %r10,	%rax
    jnz       L3971
    mov       %rax,	[%rbp + cc_lex.pastetokens.tk]
    mov       %r10,	[%rbp + cc_lex.pastetokens.tknext]
    mov       [%r10],	%rax
L3971:
    mov       %rax,	[%rdi+8]
    mov       %r10,	[%rbp + cc_lex.pastetokens.tk]
    mov       [%r10+8],	%rax
    mov       %rax,	[%rbp + cc_lex.pastetokens.tk]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	66
    jnz       L3973
    movzx     %rax,	byte ptr[%rdi+21]
    cmp       %rax,	66
    jz        L3974
L3975:
    mov       %rax,	%rdi
    mov       %r10,	[%rbp + cc_lex.pastetokens.tk]
    mov       %r11,	[%rax]
    mov       [%r10],	%r11
    mov       %r11,	[%rax+8]
    mov       [%r10+8],	%r11
    mov       %r11,	[%rax+16]
    mov       [%r10+16],	%r11
    mov       %r11,	[%rax+24]
    mov       [%r10+24],	%r11
L3974:
    jmp       L3972
L3973:
    movzx     %rax,	byte ptr[%rdi+21]
    cmp       %rax,	66
    jz        L3972
L3976:
    mov       %rcx,	[%rbp + cc_lex.pastetokens.tk]
    lea       %rdx,	[%rbp + cc_lex.pastetokens.length1]
    call      cc_lex.strtoken
    mov       %rbx,	%rax
    mov       %rcx,	%rdi
    lea       %rdx,	[%rbp + cc_lex.pastetokens.length2]
    call      cc_lex.strtoken
    mov       %rsi,	%rax
    mov       %rax,	[%rbp + cc_lex.pastetokens.length1]
    add       %rax,	[%rbp + cc_lex.pastetokens.length2]
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       %r12,	%rax
    mov       %rcx,	%r12
    mov       %rdx,	%rbx
    mov       %r8,	[%rbp + cc_lex.pastetokens.length1]
    call      memcpy
    mov       %rax,	[%rbp + cc_lex.pastetokens.length1]
    lea       %r10,	[%r12 + %rax]
    mov       %rcx,	%r10
    mov       %rdx,	%rsi
    mov       %r8,	[%rbp + cc_lex.pastetokens.length2]
    call      memcpy
    mov       %rax,	[%rbp + cc_lex.pastetokens.length1]
    lea       %r10,	[%r12 + %rax]
    xor       %eax,	%eax
    mov       %r11,	[%rbp + cc_lex.pastetokens.length2]
    mov       [%r10 + %r11],	%al
    mov       %rax,	[%rip+cc_lex.npastedtokens]
    cmp       %rax,	87000
    jl        L3978
    lea       %rcx,	[%rip+L8527]
    call      cc_lex.lxerror
L3978:
    inc       qword ptr[%rip+cc_lex.npastedtokens]
    mov       %rax,	[%rip+cc_lex.npastedtokens]
    mov       %r10,	%r12
    lea       %r11,	[%rip+cc_lex.pastedtokenlist]
    mov       [%r11 + %rax*8-8],	%r10
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %r10,	[%rbp + cc_lex.pastetokens.oldtoken]
    mov       %r11,	[%rax]
    mov       [%r10],	%r11
    mov       %r11,	[%rax+8]
    mov       [%r10+8],	%r11
    mov       %r11,	[%rax+16]
    mov       [%r10+16],	%r11
    mov       %r11,	[%rax+24]
    mov       [%r10+24],	%r11
    mov       %r13,	[%rip+cc_lex.lxsptr]
    mov       %r14,	[%rip+cc_lex.lx_stackindex]
    mov       [%rip+cc_lex.lxsptr],	%r12
    xor       %eax,	%eax
    mov       [%rip+cc_lex.lx_stackindex],	%rax
    xor       %ecx,	%ecx
    call      cc_lex.setfileno
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+16],	%eax
    call      cc_lex.lexreadtoken
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %r10,	[%rbp + cc_lex.pastetokens.token]
    mov       %r11,	[%rax]
    mov       [%r10],	%r11
    mov       %r11,	[%rax+8]
    mov       [%r10+8],	%r11
    mov       %r11,	[%rax+16]
    mov       [%r10+16],	%r11
    mov       %r11,	[%rax+24]
    mov       [%r10+24],	%r11
    call      cc_lex.lexreadtoken
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	57
    jz        L3980
L3980:
    lea       %rax,	[%rbp + cc_lex.pastetokens.oldtoken]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       %r11,	[%rax]
    mov       [%r10],	%r11
    mov       %r11,	[%rax+8]
    mov       [%r10+8],	%r11
    mov       %r11,	[%rax+16]
    mov       [%r10+16],	%r11
    mov       %r11,	[%rax+24]
    mov       [%r10+24],	%r11
    mov       [%rip+cc_lex.lxsptr],	%r13
    mov       [%rip+cc_lex.lx_stackindex],	%r14
    mov       %rax,	[%rbp + cc_lex.pastetokens.tk]
    mov       %rax,	[%rax+8]
    mov       [%rbp + cc_lex.pastetokens.token+8],	%rax
    lea       %rcx,	[%rbp + cc_lex.pastetokens.token]
    xor       %edx,	%edx
    call      cc_lex.setfilenox
    mov       %ax,	[%rip+cc_lex.npastedtokens]
    mov       [%rbp + cc_lex.pastetokens.token+28],	%ax
    lea       %rax,	[%rbp + cc_lex.pastetokens.token+23]
    mov       %r10b,	8
    or        [%rax],	%r10b
    lea       %rax,	[%rbp + cc_lex.pastetokens.token]
    mov       %r10,	[%rbp + cc_lex.pastetokens.tk]
    mov       %r11,	[%rax]
    mov       [%r10],	%r11
    mov       %r11,	[%rax+8]
    mov       [%r10+8],	%r11
    mov       %r11,	[%rax+16]
    mov       [%r10+16],	%r11
    mov       %r11,	[%rax+24]
    mov       [%r10+24],	%r11
L3972:
#---------------
    add       %rsp,	112
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.getifexpr
cc_lex.getifexpr:
#?>>
    .set cc_lex.getifexpr.sx, -8
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
#---------------
    call      cc_lex.lexm
    lea       %rcx,	[%rbp + cc_lex.getifexpr.sx]
    call      cc_lex.evalcondexpr
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	56
    jz        L3983
    lea       %rcx,	[%rip+L8528]
    call      cc_lex.lxerror
L3983:
    mov       %rax,	%rdi
    cmp       %rax,	0
    setnz     %al
    movzx     %eax,	%al
L3981:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc cc_lex.evalcondexpr
cc_lex.evalcondexpr:
#?>>
    .set cc_lex.evalcondexpr.sy, -8
    .set cc_lex.evalcondexpr.sz, -16
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %r12,	%rcx
#---------------
    mov       %rcx,	%r12
    call      cc_lex.evalorexpr
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	19
    jnz       L3986
    call      cc_lex.lexm
    lea       %rcx,	[%rbp + cc_lex.evalcondexpr.sy]
    call      cc_lex.evalcondexpr
    mov       %rbx,	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	10
    jz        L3988
    lea       %rcx,	[%rip+L8529]
    call      cc_lex.lxerror
L3988:
    call      cc_lex.lexm
    lea       %rcx,	[%rbp + cc_lex.evalcondexpr.sz]
    call      cc_lex.evalcondexpr
    mov       %rsi,	%rax
    test      %rdi,	%rdi
    jz        L3990
    mov       %rax,	[%rbp + cc_lex.evalcondexpr.sy]
    mov       [%r12],	%rax
    mov       %rdi,	%rbx
    jmp       L3989
L3990:
    mov       %rax,	[%rbp + cc_lex.evalcondexpr.sz]
    mov       [%r12],	%rax
    mov       %rdi,	%rsi
L3989:
L3986:
    mov       %rax,	%rdi
L3984:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.evalorexpr
cc_lex.evalorexpr:
#?>>
    .set cc_lex.evalorexpr.sy, -8
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %rsi,	%rcx
#---------------
    mov       %rcx,	%rsi
    call      cc_lex.evalandexpr
    mov       %rdi,	%rax
    jmp       L3993
L3992:
    call      cc_lex.lexm
    lea       %rcx,	[%rbp + cc_lex.evalorexpr.sy]
    call      cc_lex.evalandexpr
    mov       %rbx,	%rax
    test      %rdi,	%rdi
    jnz       L3997
    test      %rbx,	%rbx
    jz        L3996
L3997:
    mov       %rax,	1
    jmp       L3995
L3996:
    xor       %eax,	%eax
L3995:
    mov       %rdi,	%rax
L3993:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	31
    jz        L3992
    mov       %rax,	%rdi
L3991:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.evalandexpr
cc_lex.evalandexpr:
#?>>
    .set cc_lex.evalandexpr.sy, -8
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %rsi,	%rcx
#---------------
    mov       %rcx,	%rsi
    call      cc_lex.evaliorexpr
    mov       %rdi,	%rax
    jmp       L4000
L3999:
    call      cc_lex.lexm
    lea       %rcx,	[%rbp + cc_lex.evalandexpr.sy]
    call      cc_lex.evaliorexpr
    mov       %rbx,	%rax
    test      %rdi,	%rdi
    jz        L4003
    test      %rbx,	%rbx
    jz        L4003
    mov       %rax,	1
    jmp       L4002
L4003:
    xor       %eax,	%eax
L4002:
    mov       %rdi,	%rax
L4000:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	32
    jz        L3999
    mov       %rax,	%rdi
L3998:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.evaliorexpr
cc_lex.evaliorexpr:
#?>>
    .set cc_lex.evaliorexpr.sy, -8
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rbx,	%rcx
#---------------
    mov       %rcx,	%rbx
    call      cc_lex.evalixorexpr
    mov       %rdi,	%rax
    jmp       L4006
L4005:
    call      cc_lex.lexm
    lea       %rcx,	[%rbp + cc_lex.evaliorexpr.sy]
    call      cc_lex.evalixorexpr
    or        %rdi,	%rax
L4006:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	28
    jz        L4005
    mov       %rax,	%rdi
L4004:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.evalixorexpr
cc_lex.evalixorexpr:
#?>>
    .set cc_lex.evalixorexpr.sy, -8
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rbx,	%rcx
#---------------
    mov       %rcx,	%rbx
    call      cc_lex.evaliandexpr
    mov       %rdi,	%rax
    jmp       L4010
L4009:
    call      cc_lex.lexm
    lea       %rcx,	[%rbp + cc_lex.evalixorexpr.sy]
    call      cc_lex.evaliandexpr
    xor       %rdi,	%rax
L4010:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	30
    jz        L4009
    mov       %rax,	%rdi
L4008:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.evaliandexpr
cc_lex.evaliandexpr:
#?>>
    .set cc_lex.evaliandexpr.sy, -8
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rbx,	%rcx
#---------------
    mov       %rcx,	%rbx
    call      cc_lex.evaleqexpr
    mov       %rdi,	%rax
    jmp       L4014
L4013:
    call      cc_lex.lexm
    lea       %rcx,	[%rbp + cc_lex.evaliandexpr.sy]
    call      cc_lex.evaleqexpr
    and       %rdi,	%rax
L4014:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	29
    jz        L4013
    mov       %rax,	%rdi
L4012:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.evaleqexpr
cc_lex.evaleqexpr:
#?>>
    .set cc_lex.evaleqexpr.sy, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %r12,	%rcx
#---------------
    mov       %rcx,	%r12
    call      cc_lex.evalcmpexpr
    mov       %rdi,	%rax
    jmp       L4018
L4017:
    call      cc_lex.lexm
    lea       %rcx,	[%rbp + cc_lex.evaleqexpr.sy]
    call      cc_lex.evalcmpexpr
    mov       %rbx,	%rax
    mov       %rax,	%rsi
    cmp       %rax,	40
    jz        L4021
    cmp       %rax,	41
    jz        L4022
    jmp       L4023
L4021:
    mov       %rax,	%rdi
    cmp       %rax,	%rbx
    setz      %al
    movzx     %eax,	%al
    mov       %rdi,	%rax
    jmp       L4020
L4022:
    mov       %rax,	%rdi
    cmp       %rax,	%rbx
    setnz     %al
    movzx     %eax,	%al
    mov       %rdi,	%rax
L4023:
L4020:
L4018:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %rsi,	%rax
    cmp       %rax,	40
    jz        L4017
    cmp       %rsi,	41
    jz        L4017
    mov       %rax,	%rdi
L4016:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.evalcmpexpr
cc_lex.evalcmpexpr:
#?>>
    .set cc_lex.evalcmpexpr.sy, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %r12,	%rcx
#---------------
    mov       %rcx,	%r12
    call      cc_lex.evalshiftexpr
    mov       %rdi,	%rax
    jmp       L4026
L4025:
    call      cc_lex.lexm
    lea       %rcx,	[%rbp + cc_lex.evalcmpexpr.sy]
    call      cc_lex.evalshiftexpr
    mov       %rbx,	%rax
    mov       %rax,	%rsi
    cmp       %rax,	42
    jz        L4029
    cmp       %rax,	43
    jz        L4030
    cmp       %rax,	44
    jz        L4031
    cmp       %rax,	45
    jz        L4032
    jmp       L4033
L4029:
    mov       %rax,	%rdi
    cmp       %rax,	%rbx
    setl      %al
    movzx     %eax,	%al
    mov       %rdi,	%rax
    jmp       L4028
L4030:
    mov       %rax,	%rdi
    cmp       %rax,	%rbx
    setle     %al
    movzx     %eax,	%al
    mov       %rdi,	%rax
    jmp       L4028
L4031:
    mov       %rax,	%rdi
    cmp       %rax,	%rbx
    setge     %al
    movzx     %eax,	%al
    mov       %rdi,	%rax
    jmp       L4028
L4032:
    mov       %rax,	%rdi
    cmp       %rax,	%rbx
    setg      %al
    movzx     %eax,	%al
    mov       %rdi,	%rax
L4033:
L4028:
L4026:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %rsi,	%rax
    cmp       %rax,	42
    jz        L4025
    cmp       %rsi,	43
    jz        L4025
    cmp       %rsi,	44
    jz        L4025
    cmp       %rsi,	45
    jz        L4025
    mov       %rax,	%rdi
L4024:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.evalshiftexpr
cc_lex.evalshiftexpr:
#?>>
    .set cc_lex.evalshiftexpr.sy, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %r12,	%rcx
#---------------
    mov       %rcx,	%r12
    call      cc_lex.evaladdexpr
    mov       %rdi,	%rax
    jmp       L4036
L4035:
    call      cc_lex.lexm
    lea       %rcx,	[%rbp + cc_lex.evalshiftexpr.sy]
    call      cc_lex.evaladdexpr
    mov       %rbx,	%rax
    mov       %rax,	%rsi
    cmp       %rax,	34
    jz        L4039
    cmp       %rax,	33
    jz        L4040
    jmp       L4041
L4039:
    mov       %rax,	%rdi
    mov       %cl,	%bl
    sar       %rax,	%cl
    mov       %rdi,	%rax
    jmp       L4038
L4040:
    mov       %rax,	%rdi
    mov       %cl,	%bl
    shl       %rax,	%cl
    mov       %rdi,	%rax
L4041:
L4038:
L4036:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %rsi,	%rax
    cmp       %rax,	33
    jz        L4035
    cmp       %rsi,	34
    jz        L4035
    mov       %rax,	%rdi
L4034:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.evaladdexpr
cc_lex.evaladdexpr:
#?>>
    .set cc_lex.evaladdexpr.sy, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %r12,	%rcx
#---------------
    mov       %rcx,	%r12
    call      cc_lex.evalmulexpr
    mov       %rdi,	%rax
    jmp       L4044
L4043:
    call      cc_lex.lexm
    lea       %rcx,	[%rbp + cc_lex.evaladdexpr.sy]
    call      cc_lex.evalmulexpr
    mov       %rbx,	%rax
    mov       %rax,	%rsi
    cmp       %rax,	23
    jz        L4047
    cmp       %rax,	24
    jz        L4048
    jmp       L4049
L4047:
    mov       %rax,	%rbx
    add       %rdi,	%rax
    jmp       L4046
L4048:
    mov       %rax,	%rbx
    sub       %rdi,	%rax
L4049:
L4046:
L4044:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %rsi,	%rax
    cmp       %rax,	23
    jz        L4043
    cmp       %rsi,	24
    jz        L4043
    mov       %rax,	%rdi
L4042:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.evalmulexpr
cc_lex.evalmulexpr:
#?>>
    .set cc_lex.evalmulexpr.sy, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %r12,	%rcx
#---------------
    mov       %rcx,	%r12
    call      cc_lex.evalunaryexpr
    mov       %rdi,	%rax
    jmp       L4052
L4051:
    call      cc_lex.lexm
    lea       %rcx,	[%rbp + cc_lex.evalmulexpr.sy]
    call      cc_lex.evalunaryexpr
    mov       %rbx,	%rax
    test      %rbx,	%rbx
    jnz       L4055
    cmp       %rsi,	25
    jz        L4055
    lea       %rcx,	[%rip+L8530]
    call      cc_lex.lxerror
L4055:
    mov       %rax,	%rsi
    cmp       %rax,	25
    jz        L4057
    cmp       %rax,	26
    jz        L4058
    cmp       %rax,	27
    jz        L4059
    jmp       L4060
L4057:
    mov       %rax,	%rdi
    imul      %rax,	%rbx
    mov       %rdi,	%rax
    jmp       L4056
L4058:
    mov       %rax,	%rdi
    mov       %r10,	%rbx
    cqo       
    idiv      %r10
    mov       %rdi,	%rax
    jmp       L4056
L4059:
    mov       %rax,	%rdi
    mov       %r10,	%rbx
    cqo       
    idiv      %r10
    xchg      %rax,	%rdx
    mov       %rdi,	%rax
L4060:
L4056:
L4052:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %rsi,	%rax
    cmp       %rax,	25
    jz        L4051
    cmp       %rsi,	26
    jz        L4051
    cmp       %rsi,	27
    jz        L4051
    mov       %rax,	%rdi
L4050:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.evalunaryexpr
cc_lex.evalunaryexpr:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	23
    jz        L4063
    cmp       %rax,	24
    jz        L4063
    cmp       %rax,	36
    jz        L4063
    cmp       %rax,	35
    jnz       L4064
L4063:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %rbx,	%rax
    call      cc_lex.lexm
    mov       %rcx,	%rsi
    call      cc_lex.evalunaryexpr
    mov       %rdi,	%rax
    mov       %rax,	%rbx
    cmp       %rax,	23
    jz        L4066
    cmp       %rax,	24
    jz        L4067
    cmp       %rax,	36
    jz        L4068
    cmp       %rax,	35
    jz        L4069
    jmp       L4070
L4066:
    mov       %rax,	%rdi
    jmp       L4061
L4067:
    mov       %rax,	%rdi
    neg       %rax
    jmp       L4061
L4068:
    mov       %rax,	%rdi
    test      %rax,	%rax
    setz      %al
    movzx     %eax,	%al
    jmp       L4061
L4069:
    mov       %rax,	%rdi
    not       %rax
    jmp       L4061
L4070:
L4065:
L4064:
L4062:
    mov       %rcx,	%rsi
    call      cc_lex.evalterm
L4061:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.evalterm
cc_lex.evalterm:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    mov       %rax,	1
    mov       [%rsi],	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L4073
    cmp       %rax,	59
    jz        L4074
    cmp       %rax,	61
    jz        L4075
    cmp       %rax,	13
    jz        L4076
    jmp       L4077
L4073:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    movzx     %rax,	byte ptr[%rax+107]
    cmp       %rax,	93
    jz        L4079
    cmp       %rax,	92
    jz        L4080
    jmp       L4081
L4079:
    mov       %rax,	1
    mov       [%rip+cc_lex.noexpand],	%rax
    xor       %rbx,	%rbx
    call      cc_lex.lexm
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	13
    jnz       L4083
    mov       %rbx,	1
    call      cc_lex.lexm
L4083:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L4085
    lea       %rcx,	[%rip+L8531]
    call      cc_lex.lxerror
L4085:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	1
    setz      %al
    movzx     %eax,	%al
    mov       %rdi,	%rax
    call      cc_lex.lexm
    test      %rbx,	%rbx
    jz        L4087
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	14
    jz        L4089
    lea       %rcx,	[%rip+L8532]
    call      cc_lex.lxerror
L4089:
    call      cc_lex.lexm
L4087:
    xor       %eax,	%eax
    mov       [%rip+cc_lex.noexpand],	%rax
    jmp       L4078
L4080:
    call      cc_lex.lexm
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	13
    jz        L4091
    lea       %rcx,	[%rip+L8533]
    call      cc_lex.lxerror
L4091:
    call      cc_lex.lexm
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L4093
    lea       %rcx,	[%rip+L8534]
    call      cc_lex.lxerror
L4093:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    movzx     %rax,	byte ptr[%rax+107]
    cmp       %rax,	71
    jnz       L4096
L4095:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    movsx     %rax,	word ptr[%rax+100]
    lea       %r10,	[%rip+cc_tables.typespecsizes]
    movzx     %r10,	byte ptr[%r10 + %rax-1]
    mov       %rdi,	%r10
    jmp       L4094
L4096:
    lea       %rcx,	[%rip+L8535]
    call      cc_lex.lxerror
L4094:
    call      cc_lex.lexm
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	14
    jz        L4098
    lea       %rcx,	[%rip+L8536]
    call      cc_lex.lxerror
L4098:
    call      cc_lex.lexm
    jmp       L4078
L4081:
    call      cc_lex.lexm
    xor       %eax,	%eax
    jmp       L4071
L4078:
    jmp       L4072
L4074:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rdi,	[%rax]
    call      cc_lex.lexm
    jmp       L4072
L4075:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+24]
    test      %rax,	%rax
    jnz       L4100
    xor       %rdi,	%rdi
    jmp       L4099
L4100:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    movzx     %rax,	byte ptr[%rax]
    mov       %rdi,	%rax
L4099:
    call      cc_lex.lexm
    jmp       L4072
L4076:
    call      cc_lex.lexm
    mov       %rcx,	%rsi
    call      cc_lex.evalcondexpr
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	14
    jz        L4102
    lea       %rcx,	[%rip+L8537]
    call      cc_lex.lxerror
L4102:
    call      cc_lex.lexm
    jmp       L4072
L4077:
    lea       %rcx,	[%rip+cc_decls.nextlx]
    call      cc_lex.printsymbol
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+24]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       %r10,	[%r10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      cc_lex.printstrn
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8538]
    call      cc_lex.lxerror
L4072:
    mov       %rax,	%rdi
L4071:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.getifdef
cc_lex.getifdef:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
    mov       %rax,	1
    mov       [%rip+cc_lex.noexpand],	%rax
    call      cc_lex.lexreadtoken
    xor       %eax,	%eax
    mov       [%rip+cc_lex.noexpand],	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L4105
    lea       %rcx,	[%rip+L8539]
    call      cc_lex.lxerror
L4105:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rbx,	[%rax]
    xor       %rdi,	%rdi
    movzx     %rax,	byte ptr[%rbx+109]
    cmp       %rax,	1
    jnz       L4107
    mov       %rdi,	1
    jmp       L4106
L4107:
    movzx     %rax,	byte ptr[%rbx+107]
    cmp       %rax,	69
    jnz       L4108
    mov       %rdi,	1
L4108:
L4106:
    call      cc_lex.lexreadtoken
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	56
    jz        L4110
    lea       %rcx,	[%rip+L8540]
    call      cc_lex.lxerror
L4110:
    mov       %rax,	%rdi
L4103:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.skipcode
cc_lex.skipcode:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
    xor       %rdi,	%rdi
L4112:
    call      cc_lex.fastreadtoken
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	4
    jz        L4115
    cmp       %rax,	57
    jz        L4116
    jmp       L4117
L4115:
    call      cc_lex.getlexdirective
    mov       %rbx,	%rax
    mov       %rax,	%rbx
    cmp       %rax,	3
    jz        L4119
    cmp       %rax,	8
    jz        L4119
    cmp       %rax,	9
    jz        L4119
    cmp       %rax,	4
    jz        L4120
    cmp       %rax,	5
    jz        L4120
    cmp       %rax,	6
    jz        L4121
    jmp       L4122
L4119:
    inc       %rdi
    jmp       L4118
L4120:
    test      %rdi,	%rdi
    jnz       L4124
    mov       %rax,	%rbx
    jmp       L4111
L4124:
    jmp       L4118
L4121:
    test      %rdi,	%rdi
    jnz       L4126
    mov       %rax,	%rbx
    jmp       L4111
L4126:
    dec       %rdi
L4122:
L4118:
    jmp       L4114
L4116:
    lea       %rcx,	[%rip+L8541]
    call      cc_lex.lxerror
L4117:
L4114:
    jmp       L4112
    xor       %eax,	%eax
L4111:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.freetokens
cc_lex.freetokens:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	16
#---------------
    jmp       L4129
L4128:
    mov       %rdi,	[%rcx+8]
    mov       %rax,	%rdi
    mov       %rcx,	%rax
L4129:
    test      %rcx,	%rcx
    jnz       L4128
#---------------
    add       %rsp,	16
    pop       %rdi
    ret       
# End 
# Proc cc_lex.fastreadtoken
cc_lex.fastreadtoken:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
L4132:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    mov       %rdi,	%rax
    cmp       %rax,	48
    jae       L4135
    lea       %r10,	[%rip+L4134]
    jmp       [%r10 + %rax*8]
    .data
L4134:
    .quad     L4157
    .quad     L4135
    .quad     L4135
    .quad     L4135
    .quad     L4135
    .quad     L4135
    .quad     L4135
    .quad     L4135
    .quad     L4135
    .quad     L4135
    .quad     L4156
    .quad     L4135
    .quad     L4160
    .quad     L4155
    .quad     L4135
    .quad     L4135
    .quad     L4135
    .quad     L4135
    .quad     L4135
    .quad     L4135
    .quad     L4135
    .quad     L4135
    .quad     L4135
    .quad     L4135
    .quad     L4135
    .quad     L4135
    .quad     L4135
    .quad     L4135
    .quad     L4135
    .quad     L4135
    .quad     L4135
    .quad     L4135
    .quad     L4135
    .quad     L4135
    .quad     L4154
    .quad     L4136
    .quad     L4135
    .quad     L4135
    .quad     L4135
    .quad     L4153
    .quad     L4135
    .quad     L4135
    .quad     L4135
    .quad     L4135
    .quad     L4135
    .quad     L4135
    .quad     L4135
    .quad     L4148
    .text
L4136:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	2
    mov       %rsi,	%rax
    xor       %rbx,	%rbx
    jmp       L4138
L4137:
    movzx     %rax,	byte ptr[%rsi]
    cmp       %rax,	10
    jz        L4141
    cmp       %rax,	9
    jz        L4142
    cmp       %rax,	32
    jz        L4142
    jmp       L4143
L4141:
    mov       %rbx,	1
    jmp       L4139
L4142:
    jmp       L4140
L4143:
    jmp       L4139
L4140:
    dec       %rsi
L4138:
    cmp       %rsi,	[%rip+cc_lex.lxstart]
    jae       L4137
L4139:
    test      %rbx,	%rbx
    jnz       L4146
    cmp       %rsi,	[%rip+cc_lex.lxstart]
    jae       L4145
L4146:
    mov       %al,	4
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L4131
L4145:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	35
    jnz       L4147
    inc       qword ptr[%rip+cc_lex.lxsptr]
L4147:
L4144:
    jmp       L4132
L4148:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	47
    jz        L4150
    cmp       %rax,	42
    jz        L4151
    jmp       L4152
L4150:
    call      cc_lex.readlinecomment
    jmp       L4149
L4151:
    call      cc_lex.readblockcomment
L4152:
L4149:
    jmp       L4132
L4153:
    mov       %rcx,	39
    xor       %edx,	%edx
    call      cc_lex.lxreadstring
    jmp       L4132
L4154:
    mov       %rcx,	34
    xor       %edx,	%edx
    call      cc_lex.lxreadstring
    jmp       L4132
L4155:
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %rax,	[%rax+16]
    inc       dword ptr[%rax]
    mov       %al,	56
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
    inc       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L4132
L4156:
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %rax,	[%rax+16]
    inc       dword ptr[%rax]
    mov       %al,	56
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
    jmp       L4132
L4157:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lx_stackindex]
    test      %rax,	%rax
    jz        L4159
    call      cc_lex.unstacksourcefile
    jmp       L4158
L4159:
    mov       %al,	57
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L4131
L4158:
    jmp       L4132
L4160:
    jmp       L4132
L4135:
    jmp       L4132
L4131:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.alloctoken
cc_lex.alloctoken:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rcx,	32
    call      mlib.pcm_alloc
    mov       %rdi,	%rax
    mov       %rax,	%rdi
L4161:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lex.alloctokenz
cc_lex.alloctokenz:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rcx,	32
    call      mlib.pcm_alloc
    mov       %rdi,	%rax
    xor       %eax,	%eax
    mov       [%rdi+8],	%rax
    mov       %rax,	%rdi
L4162:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lex.expandpredefmacro
cc_lex.expandpredefmacro:
#?>>
    .set cc_lex.expandpredefmacro.str, -256
    .set cc_lex.expandpredefmacro.tm, -272
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	312
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
    mov       %rax,	[%rip+cc_lex.noexpand]
    test      %rax,	%rax
    jnz       L4163
L4165:
    mov       %rax,	%rsi
    cmp       %rax,	1
    jz        L4167
    cmp       %rax,	2
    jz        L4168
    cmp       %rax,	3
    jz        L4169
    cmp       %rax,	5
    jz        L4170
    cmp       %rax,	4
    jz        L4171
    cmp       %rax,	9
    jz        L4172
    cmp       %rax,	7
    jz        L4173
    cmp       %rax,	8
    jz        L4174
    jmp       L4175
L4167:
    lea       %rcx,	[%rbp + cc_lex.expandpredefmacro.tm]
    call      mnoos.os_getsystime
    lea       %rcx,	[%rbp + cc_lex.expandpredefmacro.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8542]
    call      msys.m$print_setfmt
    movzx     %rax,	word ptr[%rbp + cc_lex.expandpredefmacro.tm+6]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    movzx     %rax,	word ptr[%rbp + cc_lex.expandpredefmacro.tm+2]
    lea       %r10,	[%rip+cc_lex.expandpredefmacro.monthnames]
    mov       %r10,	[%r10 + %rax*8-8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    movzx     %rax,	word ptr[%rbp + cc_lex.expandpredefmacro.tm]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8543]
    call      msys.m$print_i64
    call      msys.m$print_end
    mov       %al,	63
    mov       [%r12+21],	%al
    lea       %rcx,	[%rbp + cc_lex.expandpredefmacro.str]
    call      mlib.pcm_copyheapstring
    mov       [%r12],	%rax
    jmp       L4166
L4168:
    lea       %rcx,	[%rbp + cc_lex.expandpredefmacro.tm]
    call      mnoos.os_getsystime
    lea       %rcx,	[%rbp + cc_lex.expandpredefmacro.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8544]
    call      msys.m$print_setfmt
    movzx     %rax,	word ptr[%rbp + cc_lex.expandpredefmacro.tm+8]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8545]
    call      msys.m$print_i64
    movzx     %rax,	word ptr[%rbp + cc_lex.expandpredefmacro.tm+10]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8546]
    call      msys.m$print_i64
    movzx     %rax,	word ptr[%rbp + cc_lex.expandpredefmacro.tm+12]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8546]
    call      msys.m$print_i64
    call      msys.m$print_end
    mov       %al,	63
    mov       [%r12+21],	%al
    lea       %rcx,	[%rbp + cc_lex.expandpredefmacro.str]
    call      mlib.pcm_copyheapstring
    mov       [%r12],	%rax
    jmp       L4166
L4169:
    mov       %al,	63
    mov       [%r12+21],	%al
    mov       %rcx,	%r12
    call      cc_lex.getfilenox
    mov       %rbx,	%rax
    test      %rbx,	%rbx
    jnz       L4177
    mov       %rbx,	[%rip+cc_decls.sfileno]
L4177:
    mov       %rax,	[%rip+cc_decls.sfileno]
    test      %rax,	%rax
    jz        L4179
    lea       %rax,	[%rip+cc_decls.sourcefilenames]
    mov       %r10,	[%rip+cc_decls.sfileno]
    mov       %rax,	[%rax + %r10*8]
    mov       [%r12],	%rax
    jmp       L4178
L4179:
    lea       %rax,	[%rip+L8547]
    mov       [%r12],	%rax
L4178:
    jmp       L4166
L4170:
    mov       %al,	63
    mov       [%r12+21],	%al
    mov       %rax,	[%rip+cc_decls.currproc]
    test      %rax,	%rax
    jz        L4181
    mov       %rax,	[%rip+cc_decls.currproc]
    mov       %rax,	[%rax]
    mov       [%r12],	%rax
    jmp       L4180
L4181:
    lea       %rax,	[%rip+L8548]
    mov       [%r12],	%rax
L4180:
    jmp       L4166
L4171:
    mov       %al,	59
    mov       [%r12+21],	%al
    mov       [%r12],	%r13
    jmp       L4166
L4172:
    mov       %al,	59
    mov       [%r12+21],	%al
    mov       %rax,	1
    mov       [%r12],	%rax
    jmp       L4166
L4173:
    mov       %al,	59
    mov       [%r12+21],	%al
    mov       %rax,	1
    mov       [%r12],	%rax
    jmp       L4166
L4174:
    mov       %al,	59
    mov       [%r12+21],	%al
    movzx     %rax,	byte ptr[%rip+cc_decls.pci_target]
    mov       [%r12],	%rax
    jmp       L4166
L4175:
    call      msys.m$print_startcon
    mov       %rcx,	%rsi
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8549]
    call      cc_lex.lxerror
L4166:
    movzx     %rax,	byte ptr[%r12+21]
    cmp       %rax,	63
    jnz       L4183
    mov       %rax,	[%r12]
    mov       %rcx,	%rax
    call      strlen
    mov       [%r12+24],	%eax
    mov       %al,	[%rip+cc_decls.trefchar]
    mov       [%r12+22],	%al
    jmp       L4182
L4183:
    mov       %al,	3
    mov       [%r12+22],	%al
    mov       %rcx,	16
    call      mlib.pcm_alloc
    mov       %rdi,	%rax
    mov       %rax,	[%r12]
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    call      msys.getstrint
    mov       %rcx,	%rdi
    call      strlen
    mov       [%r12+24],	%eax
    mov       %rax,	[%rip+cc_lex.npastedtokens]
    cmp       %rax,	87000
    jl        L4185
    lea       %rcx,	[%rip+L8550]
    call      cc_lex.lxerror
L4185:
    inc       qword ptr[%rip+cc_lex.npastedtokens]
    mov       %rax,	[%rip+cc_lex.npastedtokens]
    mov       %r10,	%rdi
    lea       %r11,	[%rip+cc_lex.pastedtokenlist]
    mov       [%r11 + %rax*8-8],	%r10
    mov       %rcx,	%r12
    xor       %edx,	%edx
    call      cc_lex.setfilenox
    mov       %ax,	[%rip+cc_lex.npastedtokens]
    mov       [%r12+28],	%ax
L4182:
L4163:
#---------------
    add       %rsp,	312
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.dopragmadir
cc_lex.dopragmadir:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    call      cc_lex.lexm
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jnz       L4188
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8551]
    mov       %r8,	4
    call      memcmp
    movsxd    %r10,	%eax
    test      %r10,	%r10
    jnz       L4190
    call      cc_lex.lexm
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	13
    jz        L4192
    lea       %rcx,	[%rip+L8552]
    call      cc_lex.lxerror
L4192:
    call      cc_lex.lexm
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	59
    jnz       L4194
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    cmp       %rax,	1
    jnz       L4197
L4196:
    xor       %eax,	%eax
    mov       [%rip+cc_decls.structpadding],	%rax
    jmp       L4195
L4197:
    jmp       L4198
    lea       %rcx,	[%rip+L8553]
    call      cc_lex.lxerror
L4195:
    call      cc_lex.lexm
    jmp       L4193
L4194:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	14
    jnz       L4199
    mov       %rax,	1
    mov       [%rip+cc_decls.structpadding],	%rax
L4199:
L4193:
    jmp       L4189
L4190:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8554]
    mov       %r8,	6
    call      memcmp
    movsxd    %r10,	%eax
    test      %r10,	%r10
    jnz       L4200
    mov       %rcx,	77
    call      cc_lex.addbuildinfo
    jmp       L4189
L4200:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8555]
    mov       %r8,	6
    call      memcmp
    movsxd    %r10,	%eax
    test      %r10,	%r10
    jnz       L4201
    mov       %rcx,	72
    call      cc_lex.addbuildinfo
    jmp       L4189
L4201:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8556]
    mov       %r8,	4
    call      memcmp
    movsxd    %r10,	%eax
    test      %r10,	%r10
    jnz       L4202
    mov       %rcx,	76
    call      cc_lex.addbuildinfo
L4202:
L4189:
L4188:
#cc_lex.dopragmadir.finish:
L4198:
    jmp       L4204
L4203:
    call      cc_lex.lexm
L4204:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	56
    jz        L4206
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	57
    jnz       L4203
L4206:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_lex.addbuildinfo
cc_lex.addbuildinfo:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    call      cc_lex.lexm
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	63
    jz        L4209
    lea       %rcx,	[%rip+L8557]
    call      cc_lex.lxerror
L4209:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    call      mlib.pcm_copyheapstring
    mov       %rdi,	%rax
    mov       %rax,	%rbx
    cmp       %rax,	77
    jz        L4211
    cmp       %rax,	72
    jz        L4212
    cmp       %rax,	76
    jz        L4213
    jmp       L4214
L4211:
    mov       %rax,	[%rip+cc_decls.npmodules]
    cmp       %rax,	199
    jl        L4216
    lea       %rcx,	[%rip+L8558]
    call      cc_lex.lxerror
L4216:
    inc       qword ptr[%rip+cc_decls.npmodules]
    mov       %rax,	[%rip+cc_decls.npmodules]
    mov       %r10,	%rdi
    lea       %r11,	[%rip+cc_decls.pmodulelist]
    mov       [%r11 + %rax*8-8],	%r10
    jmp       L4210
L4212:
    mov       %rax,	[%rip+cc_decls.npheaders]
    cmp       %rax,	100
    jl        L4218
    lea       %rcx,	[%rip+L8559]
    call      cc_lex.lxerror
L4218:
    inc       qword ptr[%rip+cc_decls.npheaders]
    mov       %rax,	[%rip+cc_decls.npheaders]
    mov       %r10,	%rdi
    lea       %r11,	[%rip+cc_decls.pheaderlist]
    mov       [%r11 + %rax*8-8],	%r10
    jmp       L4210
L4213:
    mov       %rax,	[%rip+cc_decls.nplibs]
    cmp       %rax,	100
    jl        L4220
    lea       %rcx,	[%rip+L8560]
    call      cc_lex.lxerror
L4220:
    inc       qword ptr[%rip+cc_decls.nplibs]
    mov       %rax,	[%rip+cc_decls.nplibs]
    mov       %r10,	%rdi
    lea       %r11,	[%rip+cc_decls.pliblist]
    mov       [%r11 + %rax*8-8],	%r10
L4214:
L4210:
    call      cc_lex.lexm
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.needspace
cc_lex.needspace:
#?>>
    push      %rdi
    push      %rbx
#?]]
#---------------
    test      %rcx,	%rcx
    jnz       L4223
    xor       %eax,	%eax
    jmp       L4221
L4223:
    lea       %rax,	[%rip+cc_tables.shortsymbolnames]
    mov       %r10,	%rcx
    mov       %rdi,	[%rax + %r10*8-8]
    lea       %rax,	[%rip+cc_tables.shortsymbolnames]
    mov       %r10,	%rdx
    mov       %rbx,	[%rax + %r10*8-8]
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	110
    jz        L4225
    cmp       %rax,	107
    jz        L4225
    cmp       %rax,	45
    jz        L4226
    cmp       %rax,	43
    jz        L4226
    jmp       L4227
L4225:
    movzx     %rax,	byte ptr[%rdi]
    cmp       %rax,	110
    jz        L4229
    cmp       %rax,	107
    jnz       L4230
L4229:
    mov       %rax,	1
    jmp       L4221
L4230:
L4228:
    jmp       L4224
L4226:
    movzx     %rax,	byte ptr[%rdi]
    cmp       %rax,	45
    jz        L4232
    cmp       %rax,	43
    jnz       L4233
L4232:
    mov       %rax,	1
    jmp       L4221
L4233:
L4231:
L4227:
L4224:
    xor       %eax,	%eax
L4221:
#---------------
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.dospecialinclude
cc_lex.dospecialinclude:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    lea       %rcx,	[%rip+L8561]
    mov       %rdx,	1
    call      cc_lex.stacksourcefile
    mov       %rax,	[%rip+cc_decls.dheaderfile]
    test      %rax,	%rax
    jz        L4236
    mov       %rcx,	[%rip+cc_decls.dheaderfile]
    mov       %rdx,	1
    call      cc_lex.stacksourcefile
L4236:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_lex.setnumberoffset
cc_lex.setnumberoffset:
#?>>
#?]]
#---------------
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+28]
    mov       %r10,	4278190080
    and       %rax,	%r10
    mov       %r10,	%rcx
    and       %r10,	16777215
    or        %rax,	%r10
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+28],	%eax
#---------------
    ret       
# End 
# Proc cc_lex.setfileno
cc_lex.setfileno:
#?>>
#?]]
#---------------
    mov       %rax,	%rcx
    and       %rax,	255
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+20],	%al
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+28]
    and       %rax,	16777215
    mov       %r10,	%rcx
    and       %r10,	65280
    shl       %r10,	16
    or        %rax,	%r10
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+28],	%eax
#---------------
    ret       
# End 
# Proc cc_lex.setfilenox
cc_lex.setfilenox:
#?>>
#?]]
#---------------
    mov       %rax,	%rdx
    and       %rax,	255
    mov       [%rcx+20],	%al
    movsxd    %rax,	dword ptr[%rcx+28]
    and       %rax,	16777215
    mov       %r10,	%rdx
    and       %r10,	65280
    shl       %r10,	16
    or        %rax,	%r10
    mov       [%rcx+28],	%eax
#---------------
    ret       
# End 
# Proc cc_lex.getfileno
cc_lex.getfileno:
#?>>
#?]]
#---------------
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+28]
    sar       %rax,	24
    shl       %rax,	8
    lea       %r10,	[%rip+cc_decls.nextlx]
    movzx     %r10,	byte ptr[%r10+20]
    or        %rax,	%r10
L4240:
#---------------
    ret       
# End 
# Proc cc_lex.getfilenox
cc_lex.getfilenox:
#?>>
#?]]
#---------------
    movsxd    %rax,	dword ptr[%rcx+28]
    sar       %rax,	24
    shl       %rax,	8
    movzx     %r10,	byte ptr[%rcx+20]
    or        %rax,	%r10
L4241:
#---------------
    ret       
# End 
# Proc cc_lex.getnumberoffsetx
cc_lex.getnumberoffsetx:
#?>>
#?]]
#---------------
    movsxd    %rax,	dword ptr[%rcx+28]
    and       %rax,	16777215
L4242:
#---------------
    ret       
# End 
# Proc cc_lex.freehashtable
cc_lex.freehashtable:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
#---------------
    xor       %r12,	%r12
    mov       %rax,	[%rip+cc_decls.hstmask]
    cmp       %rax,	0
    jl        L4246
L4244:
    mov       %rax,	[%rip+cc_decls.hashtable]
    mov       %r10,	%r12
    mov       %rdi,	[%rax + %r10*8]
    mov       %rax,	[%rdi]
    test      %rax,	%rax
    jz        L4248
    movzx     %rax,	byte ptr[%rdi+107]
    cmp       %rax,	67
    jnz       L4248
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	1
    jnz       L4250
    mov       %rcx,	[%rdi+72]
    call      cc_lex.freetokens
L4250:
    mov       %rsi,	[%rdi+40]
    jmp       L4252
L4251:
    mov       %rbx,	[%rsi+40]
    mov       %rcx,	%rsi
    mov       %rdx,	128
    call      mlib.pcm_free
    mov       %rsi,	%rbx
L4252:
    test      %rsi,	%rsi
    jnz       L4251
    mov       %rax,	[%rip+cc_decls.hashtable]
    mov       %r10,	%r12
    mov       %rax,	[%rax + %r10*8]
    mov       %rcx,	%rax
    mov       %rdx,	128
    call      mlib.pcm_clearmem
    jmp       L4247
L4248:
    mov       %rax,	[%rdi]
    test      %rax,	%rax
    jz        L4254
    xor       %eax,	%eax
    mov       [%rdi+40],	%rax
L4254:
L4247:
    inc       %r12
    cmp       %r12,	[%rip+cc_decls.hstmask]
    jle       L4244
L4246:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.regenlookup
cc_lex.regenlookup:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
#---------------
    movzx     %rax,	byte ptr[%r13+106]
    mov       %r10,	[%r13]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      cc_lex.gethashvalue
    and       %rax,	[%rip+cc_decls.hstmask]
    mov       %rdi,	%rax
    xor       %rbx,	%rbx
L4256:
    mov       %rax,	[%rip+cc_decls.hashtable]
    mov       %r10,	%rdi
    mov       %r12,	[%rax + %r10*8]
    movzx     %rax,	byte ptr[%r12+106]
    mov       %rsi,	%rax
    test      %rsi,	%rsi
    jnz       L4259
    mov       %rax,	[%rip+cc_decls.hashtable]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    mov       %rcx,	%rax
    mov       %rdx,	128
    call      mlib.pcm_free
    mov       %rax,	%r13
    mov       %r10,	[%rip+cc_decls.hashtable]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*8],	%rax
    inc       qword ptr[%rip+cc_lex.nhstsymbols]
    jmp       L4255
L4259:
    movzx     %rax,	byte ptr[%r13+106]
    mov       %r10,	%rsi
    cmp       %r10,	%rax
    jnz       L4261
    mov       %rax,	[%r13]
    mov       %r10,	[%r12]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    mov       %r8,	%rsi
    call      memcmp
    movsxd    %r10,	%eax
    test      %r10,	%r10
    jnz       L4263
    lea       %rcx,	[%rip+L8562]
    call      cc_lex.lxerror
L4263:
L4261:
    inc       %rdi
    cmp       %rdi,	[%rip+cc_decls.hstsize]
    jl        L4265
    test      %rbx,	%rbx
    jz        L4267
    lea       %rcx,	[%rip+L8563]
    call      mlib.abortprogram
L4267:
    mov       %rbx,	1
    xor       %rdi,	%rdi
L4265:
    jmp       L4256
L4255:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.newhashtable
cc_lex.newhashtable:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
#---------------
    mov       %rdi,	[%rip+cc_decls.hashtable]
    mov       %rbx,	[%rip+cc_decls.hstsize]
    mov       %rax,	[%rip+cc_decls.hstsize]
    shl       %rax,	1
    mov       [%rip+cc_decls.hstsize],	%rax
    mov       %rax,	[%rip+cc_decls.hstsize]
    dec       %rax
    mov       [%rip+cc_decls.hstmask],	%rax
    xor       %eax,	%eax
    mov       [%rip+cc_lex.nhstsymbols],	%rax
    mov       %rax,	6
    mov       %r10,	[%rip+cc_decls.hstsize]
    imul      %rax,	%r10
    mov       %r10,	10
    cqo       
    idiv      %r10
    mov       [%rip+cc_lex.hstthreshold],	%rax
    mov       %rax,	[%rip+cc_decls.hstsize]
    shl       %rax,	3
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       [%rip+cc_decls.hashtable],	%rax
    xor       %r13,	%r13
    mov       %rax,	[%rip+cc_decls.hstmask]
    cmp       %rax,	0
    jl        L4271
L4269:
    mov       %rcx,	128
    call      mlib.pcm_allocz
    mov       %r10,	[%rip+cc_decls.hashtable]
    mov       %r11,	%r13
    mov       [%r10 + %r11*8],	%rax
    inc       %r13
    cmp       %r13,	[%rip+cc_decls.hstmask]
    jle       L4269
L4271:
    xor       %r13,	%r13
    mov       %rax,	%rbx
    dec       %rax
    mov       %r12,	%rax
    cmp       %r12,	0
    jl        L4274
L4272:
    mov       %rsi,	[%rdi + %r13*8]
    mov       %rax,	[%rsi]
    test      %rax,	%rax
    jz        L4276
    mov       %rcx,	%rsi
    call      cc_lex.regenlookup
L4276:
    inc       %r13
    cmp       %r13,	%r12
    jle       L4272
L4274:
    mov       %rax,	%rbx
    shl       %rax,	3
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mlib.pcm_free
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.old_readrealnumber
cc_lex.old_readrealnumber:
#?>>
    .set cc_lex.old_readrealnumber.intlen, 104
    .set cc_lex.old_readrealnumber.base, 112
    .set cc_lex.old_readrealnumber.c, -8
    .set cc_lex.old_readrealnumber.badexpon, -16
    .set cc_lex.old_readrealnumber.realstr, -520
    .set cc_lex.old_readrealnumber.av_1, -528
    .set cc_lex.old_readrealnumber.av_2, -536
    .set cc_lex.old_readrealnumber.av_3, -544
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    movq      %rax,	%XMM13
    push      %rax
    movq      %rax,	%XMM14
    push      %rax
    movq      %rax,	%XMM15
    push      %rax
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	584
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       [%rbp+104],	%r8
    mov       [%rbp+112],	%r9
#---------------
    xor       %rdi,	%rdi
    xor       %eax,	%eax
    mov       %rbx,	%rax
    xor       %rsi,	%rsi
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	46
    jnz       L4279
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rdi,	[%rip+cc_lex.lxsptr]
    mov       %rcx,	[%rbp + cc_lex.old_readrealnumber.base]
    call      cc_lex.scannumber
    sub       %rax,	%rdi
    mov       %rbx,	%rax
L4279:
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.old_readrealnumber.badexpon],	%rax
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	101
    jz        L4281
    cmp       %rax,	69
    jz        L4281
    cmp       %rax,	112
    jz        L4282
    cmp       %rax,	80
    jz        L4282
    jmp       L4283
L4281:
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.base]
    cmp       %rax,	16
    jz        L4285
    inc       qword ptr[%rip+cc_lex.lxsptr]
    lea       %rcx,	[%rbp + cc_lex.old_readrealnumber.badexpon]
    call      cc_lex.readexponent
    mov       %rsi,	%rax
L4285:
    jmp       L4280
L4282:
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.base]
    cmp       %rax,	16
    jnz       L4287
    inc       qword ptr[%rip+cc_lex.lxsptr]
    lea       %rcx,	[%rbp + cc_lex.old_readrealnumber.badexpon]
    call      cc_lex.readexponent
    mov       %rsi,	%rax
L4287:
L4283:
L4280:
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.badexpon]
    test      %rax,	%rax
    jz        L4289
    dec       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rcx,	%r13
    call      cc_lex.readalphanumeric
    jmp       L4277
L4289:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	102
    jz        L4291
    cmp       %rax,	70
    jz        L4291
    cmp       %rax,	108
    jz        L4291
    cmp       %rax,	76
    jnz       L4292
L4291:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L4290
L4292:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    lea       %r10,	[%rip+cc_lex.alphamap]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L4294
    mov       %rcx,	%r13
    call      cc_lex.readalphanumeric
    jmp       L4277
L4294:
L4290:
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.intlen]
    add       %rax,	%rbx
    cmp       %rax,	500
    jle       L4296
    lea       %rcx,	[%rip+L8564]
    call      cc_lex.lxerror
L4296:
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.intlen]
    test      %rax,	%rax
    jz        L4298
    lea       %rcx,	[%rbp + cc_lex.old_readrealnumber.realstr]
    mov       %rdx,	%r14
    mov       %r8,	[%rbp + cc_lex.old_readrealnumber.intlen]
    call      memcpy
L4298:
    test      %rbx,	%rbx
    jz        L4300
    lea       %rax,	[%rbp + cc_lex.old_readrealnumber.realstr]
    mov       %r10,	[%rbp + cc_lex.old_readrealnumber.intlen]
    lea       %rax,	[%rax + %r10]
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      memcpy
L4300:
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.base]
    cvtsi2sd  %XMM4,	%rax
    movq      %XMM15,	%XMM4
    movq      %XMM13,	%XMM4
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.base]
    cmp       %rax,	10
    jnz       L4302
    mov       %rax,	%rbx
    sub       %rsi,	%rax
    jmp       L4301
L4302:
    mov       %rax,	%rbx
    shl       %rax,	2
    sub       %rsi,	%rax
    movq      %XMM4,	[%rip+L8565]
    movq      %XMM13,	%XMM4
L4301:
    movq      %XMM4,	[%rip+L8566]
    movq      %XMM14,	%XMM4
    mov       %r12,	1
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.intlen]
    add       %rax,	%rbx
    mov       [%rbp + cc_lex.old_readrealnumber.av_1],	%rax
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.av_1]
    cmp       %rax,	1
    jl        L4305
L4303:
    movzx     %rax,	byte ptr[%rbp + %r12 + cc_lex.old_readrealnumber.realstr-1]
    mov       [%rbp + cc_lex.old_readrealnumber.c],	%rax
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.c]
    cmp       %rax,	48
    jl        L4307
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.c]
    cmp       %rax,	57
    jg        L4307
    movq      %XMM4,	%XMM14
    mulsd     %XMM4,	%XMM15
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.c]
    sub       %rax,	48
    cvtsi2sd  %XMM5,	%rax
    addsd     %XMM4,	%XMM5
    movq      %XMM14,	%XMM4
    jmp       L4306
L4307:
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.c]
    cmp       %rax,	97
    jle       L4308
    movq      %XMM4,	%XMM14
    mulsd     %XMM4,	%XMM15
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.c]
    cvtsi2sd  %XMM5,	%rax
    addsd     %XMM4,	%XMM5
    mov       %rax,	97
    cmp       %rax,	0
    jl        L8567
    cvtsi2sd  %XMM5,	%rax
    jmp       L8568
L8567:
    and       %rax,	[%rip+L8569]
    cvtsi2sd  %XMM5,	%rax
    addsd     %XMM5,	[%rip+L8570]
L8568:
    subsd     %XMM4,	%XMM5
    addsd     %XMM4,	[%rip+L8571]
    movq      %XMM14,	%XMM4
    jmp       L4306
L4308:
    movq      %XMM4,	%XMM14
    mulsd     %XMM4,	%XMM15
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.c]
    cvtsi2sd  %XMM5,	%rax
    addsd     %XMM4,	%XMM5
    mov       %rax,	65
    cmp       %rax,	0
    jl        L8572
    cvtsi2sd  %XMM5,	%rax
    jmp       L8573
L8572:
    and       %rax,	[%rip+L8569]
    cvtsi2sd  %XMM5,	%rax
    addsd     %XMM5,	[%rip+L8570]
L8573:
    subsd     %XMM4,	%XMM5
    addsd     %XMM4,	[%rip+L8574]
    movq      %XMM14,	%XMM4
L4306:
    inc       %r12
    cmp       %r12,	[%rbp + cc_lex.old_readrealnumber.av_1]
    jle       L4303
L4305:
    cmp       %rsi,	0
    jl        L4310
    mov       [%rbp + cc_lex.old_readrealnumber.av_2],	%rsi
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.av_2]
    cmp       %rax,	0
    jle       L4313
L4311:
    movq      %XMM4,	%XMM14
    mulsd     %XMM4,	%XMM13
    movq      %XMM14,	%XMM4
    dec       qword ptr[%rbp + cc_lex.old_readrealnumber.av_2]
    jnz       L4311
L4313:
    jmp       L4309
L4310:
    mov       %rax,	%rsi
    neg       %rax
    mov       [%rbp + cc_lex.old_readrealnumber.av_3],	%rax
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.av_3]
    cmp       %rax,	0
    jle       L4316
L4314:
    movq      %XMM4,	%XMM14
    divsd     %XMM4,	%XMM13
    movq      %XMM14,	%XMM4
    dec       qword ptr[%rbp + cc_lex.old_readrealnumber.av_3]
    jnz       L4314
L4316:
L4309:
    mov       %al,	60
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    mov       %al,	11
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    movq      %XMM4,	%XMM14
    lea       %rax,	[%rip+cc_decls.nextlx]
    movq      [%rax],	%XMM4
    mov       %rax,	%r14
    sub       %rax,	[%rip+cc_lex.lxstart]
    mov       %rcx,	%rax
    call      cc_lex.setnumberoffset
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	%r14
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
L4277:
#---------------
    add       %rsp,	584
    pop       %rbp
    pop       %rcx
    movq      %XMM15,	%rcx
    pop       %rcx
    movq      %XMM14,	%rcx
    pop       %rcx
    movq      %XMM13,	%rcx
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.issimpleconstmacro
cc_lex.issimpleconstmacro:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
    mov       %rsi,	1
    mov       %rbx,	3
    cmp       %rbx,	1
    jl        L4320
L4318:
    mov       %rax,	[%r12]
    lea       %r10,	[%rip+cc_lex.issimpleconstmacro.specialnames]
    mov       %r11,	%rsi
    mov       %r10,	[%r10 + %r11*8-8]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L4322
    mov       %rax,	2
    jmp       L4317
L4322:
    inc       %rsi
    cmp       %rsi,	%rbx
    jle       L4318
L4320:
    mov       %rdi,	[%r12+72]
    test      %rdi,	%rdi
    jz        L4324
    mov       %rax,	[%rdi+8]
    test      %rax,	%rax
    jnz       L4324
    movzx     %rax,	byte ptr[%rdi+21]
    cmp       %rax,	59
    jz        L4327
    movzx     %rax,	byte ptr[%rdi+21]
    cmp       %rax,	60
    jnz       L4326
L4327:
    mov       %rax,	1
    jmp       L4317
L4326:
L4324:
    xor       %eax,	%eax
L4317:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readmodule
cc_parse.readmodule:
#?>>
    .set cc_parse.readmodule.linkage, -8
    .set cc_parse.readmodule.wasdef, -16
    .set cc_parse.readmodule.d, -24
    .set cc_parse.readmodule.pm, -32
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	64
#---------------
    jmp       L4330
L4329:
    xor       %r12,	%r12
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	9
    jnz       L4334
L4333:
    lea       %rcx,	[%rip+L8575]
    call      cc_support.serror
L4334:
L4332:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %r13,	%rax
    xor       %r14,	%r14
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	70
    jnz       L4336
    call      cc_parse.readdllexport
    mov       %r14,	%rax
L4336:
    mov       %rcx,	[%rip+cc_decls.stmodule]
    lea       %rdx,	[%rbp + cc_parse.readmodule.linkage]
    call      cc_parse.readdeclspec
    mov       %rbx,	%rax
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	70
    jnz       L4338
    call      cc_parse.readdllexport
    mov       %r14,	%rax
L4338:
    xor       %rsi,	%rsi
L4339:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L4341
    cmp       %rax,	25
    jz        L4341
    cmp       %rax,	13
    jnz       L4342
L4341:
    inc       %r12
    mov       %rcx,	[%rip+cc_decls.stmodule]
    lea       %rdx,	[%rbp + cc_parse.readmodule.d]
    mov       %r8,	%rbx
    lea       %r9,	[%rbp + cc_parse.readmodule.pm]
    call      cc_parse.readtype
    mov       %rdi,	%rax
    mov       %rax,	[%rbp + cc_parse.readmodule.d]
    test      %rax,	%rax
    jnz       L4344
    lea       %rcx,	[%rip+L8576]
    call      cc_support.serror
L4344:
    mov       %rax,	[%rbp + cc_parse.readmodule.linkage]
    cmp       %rax,	5
    jnz       L4346
    mov       %rax,	[%rbp + cc_parse.readmodule.pm]
    test      %rax,	%rax
    jz        L4348
    mov       %rcx,	%rdi
    mov       %rdx,	[%rbp + cc_parse.readmodule.pm]
    call      cc_lib.createprocmode
    mov       %rdi,	%rax
L4348:
    mov       %rcx,	[%rip+cc_decls.stmodule]
    mov       %rdx,	[%rbp + cc_parse.readmodule.d]
    mov       %r8,	%rdi
    call      cc_parse.createtypedef
    mov       [%rbp + cc_parse.readmodule.d],	%rax
    jmp       L4345
L4346:
    mov       %rax,	[%rbp + cc_parse.readmodule.pm]
    test      %rax,	%rax
    jz        L4349
#cc_parse.readmodule.readfn:
L4350:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	17
    jnz       L4352
    test      %rsi,	%rsi
    jz        L4352
    lea       %rcx,	[%rip+L8577]
    call      cc_support.serror
L4352:
    mov       %rax,	%r14
    push      %rax
    lea       %rax,	[%rbp + cc_parse.readmodule.wasdef]
    push      %rax
    mov       %rcx,	[%rbp + cc_parse.readmodule.d]
    mov       %rdx,	%rdi
    mov       %r8,	[%rbp + cc_parse.readmodule.linkage]
    mov       %r9,	[%rbp + cc_parse.readmodule.pm]
    sub       %rsp,	32
    call      cc_parse.readfunction
    add       %rsp,	48
    mov       [%rbp + cc_parse.readmodule.d],	%rax
    mov       %rax,	[%rbp + cc_parse.readmodule.wasdef]
    test      %rax,	%rax
    jnz       L4340
L4354:
    jmp       L4345
L4349:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	14
    jnz       L4355
    lea       %rax,	[%rip+cc_decls.ttparams]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    mov       [%rbp + cc_parse.readmodule.pm],	%rax
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rdi,	%rax
    jmp       L4350
L4355:
    mov       %rcx,	[%rbp + cc_parse.readmodule.d]
    mov       %rdx,	%rdi
    mov       %r8,	[%rbp + cc_parse.readmodule.linkage]
    call      cc_parse.readmodulevar
    mov       [%rbp + cc_parse.readmodule.d],	%rax
L4345:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jnz       L4358
L4357:
    mov       %rsi,	1
    call      cc_lex.lex
    jmp       L4356
L4358:
    mov       %rcx,	9
    call      cc_lib.skipsymbol
    jmp       L4340
L4356:
    jmp       L4339
L4342:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	12
    jz        L4360
    cmp       %rax,	18
    jz        L4360
    cmp       %rax,	19
    jz        L4360
    cmp       %rax,	3
    jz        L4361
    jmp       L4362
L4360:
    mov       %rcx,	9
    call      cc_lib.skipsymbol
    jmp       L4340
L4361:
    mov       %rcx,	9
    call      cc_lib.skipsymbol
    jmp       L4340
L4362:
    mov       %rcx,	%rbx
    call      cc_lib.typename
    lea       %rcx,	[%rip+L8578]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L4359:
    jmp       L4339
L4340:
L4330:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	57
    jnz       L4329
#---------------
    add       %rsp,	64
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.parsemodule
cc_parse.parsemodule:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    movzx     %rax,	byte ptr[%rip+cc_cli.fverbose]
    cmp       %rax,	3
    jnz       L4365
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8579]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+cc_decls.inputfile]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L4365:
    xor       %eax,	%eax
    mov       [%rip+cc_parse.ingeneric],	%al
    mov       [%rip+cc_parse.loopindex],	%rax
    xor       %eax,	%eax
    mov       [%rip+cc_parse.ist_symptr],	%rax
    lea       %rcx,	[%rip+cc_parse.casevaluestack]
    xor       %edx,	%edx
    mov       %r8,	512
    call      memset
    lea       %rcx,	[%rip+L8580]
    mov       %rdx,	[%rip+cc_decls.mainfileno]
    call      cc_lex.startlex
    mov       %rdi,	[%rip+cc_decls.stmodule]
    xor       %eax,	%eax
    mov       [%rip+cc_decls.currproc],	%rax
    xor       %eax,	%eax
    mov       [%rip+cc_parse.loopindex],	%rax
    call      cc_lex.lex
    call      cc_parse.readmodule
    call      cc_lex.endlex
    mov       %rax,	1
L4363:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readdeclspec
cc_parse.readdeclspec:
#?>>
    .set cc_parse.readdeclspec.d, -16
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %r13,	%rcx
    mov       %r14,	%rdx
#---------------
    lea       %rcx,	[%rbp + cc_parse.readdeclspec.d]
    xor       %edx,	%edx
    mov       %r8,	15
    call      memset
    mov       %eax,	20
    mov       [%rbp + cc_parse.readdeclspec.d],	%eax
    xor       %eax,	%eax
    mov       %rbx,	%rax
    mov       %r12,	%rax
L4367:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    sub       %rax,	67
    cmp       %rax,	25
    jae       L4370
    lea       %r10,	[%rip+L4369]
    jmp       [%r10 + %rax*8]
    .data
L4369:
    .quad     L4420
    .quad     L4370
    .quad     L4370
    .quad     L4370
    .quad     L4372
    .quad     L4370
    .quad     L4370
    .quad     L4370
    .quad     L4370
    .quad     L4370
    .quad     L4370
    .quad     L4370
    .quad     L4370
    .quad     L4370
    .quad     L4370
    .quad     L4370
    .quad     L4370
    .quad     L4414
    .quad     L4414
    .quad     L4407
    .quad     L4399
    .quad     L4371
    .quad     L4410
    .quad     L4370
    .quad     L4417
    .text
L4371:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+22]
    mov       [%rbp + cc_parse.readdeclspec.d],	%eax
    call      cc_lex.lex
    jmp       L4367
L4372:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+22]
    sub       %rax,	1
    cmp       %rax,	10
    jae       L4375
    lea       %r10,	[%rip+L4374]
    jmp       [%r10 + %rax*8]
    .data
L4374:
    .quad     L4376
    .quad     L4376
    .quad     L4382
    .quad     L4386
    .quad     L4376
    .quad     L4376
    .quad     L4376
    .quad     L4391
    .quad     L4395
    .quad     L4376
    .text
L4376:
    movsxd    %rax,	dword ptr[%rbp + cc_parse.readdeclspec.d]
    cmp       %rax,	20
    jz        L4378
    test      %r12,	%r12
    jz        L4380
    mov       %rcx,	9
    call      cc_lib.checksymbol
    jmp       L4379
L4380:
    jmp       L4381
L4379:
L4378:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+22]
    lea       %r10,	[%rip+cc_tables.typespectypes]
    mov       %r10d,	[%r10 + %rax*4-4]
    mov       [%rbp + cc_parse.readdeclspec.d],	%r10d
    jmp       L4373
L4382:
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+9]
    test      %al,	%al
    jnz       L4385
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+10]
    test      %al,	%al
    jnz       L4385
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+11]
    test      %al,	%al
    jz        L4384
L4385:
    jmp       L4381
L4384:
    mov       %rax,	1
    mov       %rbx,	%rax
    mov       [%rbp + cc_parse.readdeclspec.d+9],	%al
    jmp       L4373
L4386:
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+11]
    test      %al,	%al
    jnz       L4389
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+9]
    test      %al,	%al
    jz        L4388
L4389:
    jmp       L4381
L4388:
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+10]
    test      %al,	%al
    jz        L4390
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readdeclspec.d+10],	%al
    mov       %al,	1
    mov       [%rbp + cc_parse.readdeclspec.d+11],	%al
    jmp       L4387
L4390:
    mov       %al,	1
    mov       [%rbp + cc_parse.readdeclspec.d+10],	%al
L4387:
    mov       %rbx,	1
    jmp       L4373
L4391:
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+12]
    test      %al,	%al
    jnz       L4394
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+13]
    test      %al,	%al
    jz        L4393
L4394:
    jmp       L4381
L4393:
    mov       %rax,	1
    mov       %rbx,	%rax
    mov       [%rbp + cc_parse.readdeclspec.d+12],	%al
    jmp       L4373
L4395:
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+12]
    test      %al,	%al
    jnz       L4398
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+13]
    test      %al,	%al
    jz        L4397
L4398:
    jmp       L4381
L4397:
    mov       %rax,	1
    mov       %rbx,	%rax
    mov       [%rbp + cc_parse.readdeclspec.d+13],	%al
    jmp       L4373
L4375:
#cc_parse.readdeclspec.tserror:
L4381:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+22]
    lea       %r10,	[%rip+cc_tables.typespecnames]
    mov       %r10,	[%r10 + %rax*8-8]
    lea       %rcx,	[%rip+L8581]
    mov       %rdx,	%r10
    call      cc_support.serror_s
L4373:
    call      cc_lex.lex
    jmp       L4367
L4399:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+22]
    cmp       %rax,	1
    jz        L4401
    cmp       %rax,	2
    jz        L4402
    cmp       %rax,	3
    jz        L4403
    jmp       L4404
L4401:
    mov       %al,	[%rip+pc_decls.fnoconst]
    test      %al,	%al
    jnz       L4406
    mov       %al,	1
    mov       [%rbp + cc_parse.readdeclspec.d+4],	%al
L4406:
    jmp       L4400
L4402:
    mov       %al,	1
    mov       [%rbp + cc_parse.readdeclspec.d+5],	%al
    jmp       L4400
L4403:
    mov       %al,	1
    mov       [%rbp + cc_parse.readdeclspec.d+6],	%al
L4404:
L4400:
    call      cc_lex.lex
    jmp       L4367
L4407:
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+7]
    test      %al,	%al
    jz        L4409
    lea       %rcx,	[%rip+L8582]
    call      cc_support.serror
L4409:
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %al,	[%rax+22]
    mov       [%rbp + cc_parse.readdeclspec.d+7],	%al
    call      cc_lex.lex
    jmp       L4367
L4410:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+22]
    cmp       %rax,	1
    jnz       L4413
L4412:
    mov       %al,	1
    mov       [%rbp + cc_parse.readdeclspec.d+8],	%al
L4413:
L4411:
    call      cc_lex.lex
    jmp       L4367
L4414:
    movsxd    %rax,	dword ptr[%rbp + cc_parse.readdeclspec.d]
    cmp       %rax,	20
    jz        L4416
    lea       %rcx,	[%rip+L8583]
    call      cc_support.serror
L4416:
    mov       %rcx,	%r13
    call      cc_parse.readstructdecl
    mov       [%rbp + cc_parse.readdeclspec.d],	%eax
    mov       %al,	1
    mov       [%rbp + cc_parse.readdeclspec.d+14],	%al
    mov       %r12,	1
    jmp       L4367
L4417:
    movsxd    %rax,	dword ptr[%rbp + cc_parse.readdeclspec.d]
    cmp       %rax,	20
    jz        L4419
    lea       %rcx,	[%rip+L8584]
    call      cc_support.serror
L4419:
    mov       %rcx,	%r13
    call      cc_parse.readenumdecl
    mov       %eax,	3
    mov       [%rbp + cc_parse.readdeclspec.d],	%eax
    mov       %al,	1
    mov       [%rbp + cc_parse.readdeclspec.d+14],	%al
    jmp       L4367
L4420:
    movsxd    %rax,	dword ptr[%rbp + cc_parse.readdeclspec.d]
    cmp       %rax,	20
    jnz       L4422
    mov       %rcx,	%r13
    call      cc_parse.isusertype
    mov       %rsi,	%rax
    cmp       %rax,	20
    jz        L4422
    test      %rbx,	%rbx
    jz        L4424
    mov       %eax,	3
    mov       [%rbp + cc_parse.readdeclspec.d],	%eax
    jmp       L4368
L4424:
    mov       [%rbp + cc_parse.readdeclspec.d],	%esi
    mov       %al,	1
    mov       [%rbp + cc_parse.readdeclspec.d+14],	%al
    call      cc_lex.lex
    jmp       L4421
L4422:
    movsxd    %rax,	dword ptr[%rbp + cc_parse.readdeclspec.d]
    cmp       %rax,	20
    jnz       L4426
    test      %rbx,	%rbx
    jnz       L4426
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       %rax,	[%rax]
    lea       %rcx,	[%rip+L8585]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L4426:
    movsxd    %rax,	dword ptr[%rbp + cc_parse.readdeclspec.d]
    cmp       %rax,	20
    jnz       L4428
    mov       %eax,	3
    mov       [%rbp + cc_parse.readdeclspec.d],	%eax
L4428:
    jmp       L4368
L4421:
    jmp       L4367
L4370:
    jmp       L4368
L4368:
    movsxd    %rax,	dword ptr[%rbp + cc_parse.readdeclspec.d]
    cmp       %rax,	20
    jz        L4430
    movsxd    %rax,	dword ptr[%rbp + cc_parse.readdeclspec.d]
    jmp       L4429
L4430:
    mov       %rax,	3
L4429:
    mov       %rdi,	%rax
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+14]
    test      %al,	%al
    jnz       L4432
    mov       %rax,	%rdi
    cmp       %rax,	3
    jz        L4434
    cmp       %rax,	1
    jz        L4435
    cmp       %rax,	11
    jz        L4436
    jmp       L4437
L4434:
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+9]
    test      %al,	%al
    jz        L4439
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+13]
    test      %al,	%al
    jz        L4441
    mov       %rax,	7
    jmp       L4440
L4441:
    mov       %rax,	2
L4440:
    mov       %rdi,	%rax
    jmp       L4438
L4439:
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+10]
    test      %al,	%al
    jz        L4442
    mov       %al,	[%rip+pc_decls.flong64]
    test      %al,	%al
    jz        L4444
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+13]
    test      %al,	%al
    jz        L4446
    mov       %rax,	9
    jmp       L4445
L4446:
    mov       %rax,	4
L4445:
    mov       %rdi,	%rax
    jmp       L4443
L4444:
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+13]
    test      %al,	%al
    jz        L4448
    mov       %rax,	8
    jmp       L4447
L4448:
    mov       %rax,	3
L4447:
    mov       %rdi,	%rax
L4443:
    jmp       L4438
L4442:
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+11]
    test      %al,	%al
    jz        L4449
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+13]
    test      %al,	%al
    jz        L4451
    mov       %rax,	9
    jmp       L4450
L4451:
    mov       %rax,	4
L4450:
    mov       %rdi,	%rax
    jmp       L4438
L4449:
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+13]
    test      %al,	%al
    jz        L4452
    mov       %rdi,	8
L4452:
L4438:
    jmp       L4433
L4435:
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+9]
    test      %al,	%al
    jnz       L4455
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+10]
    test      %al,	%al
    jnz       L4455
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+11]
    test      %al,	%al
    jz        L4454
L4455:
    lea       %rcx,	[%rip+L8586]
    call      cc_support.serror
L4454:
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+13]
    test      %al,	%al
    jz        L4457
    mov       %rax,	6
    jmp       L4456
L4457:
    mov       %rax,	1
L4456:
    mov       %rdi,	%rax
    jmp       L4433
L4436:
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+9]
    test      %al,	%al
    jnz       L4460
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+11]
    test      %al,	%al
    jnz       L4460
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+12]
    test      %al,	%al
    jnz       L4460
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+13]
    test      %al,	%al
    jz        L4459
L4460:
    lea       %rcx,	[%rip+L8587]
    call      cc_support.serror
L4459:
    jmp       L4433
L4437:
    test      %rbx,	%rbx
    jz        L4462
    lea       %rcx,	[%rip+L8588]
    call      cc_support.serror
L4462:
L4433:
L4432:
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+4]
    test      %al,	%al
    jz        L4464
    mov       %rcx,	%rdi
    call      cc_lib.createconstmode
    mov       %rdi,	%rax
L4464:
    movzx     %rax,	byte ptr[%rbp + cc_parse.readdeclspec.d+7]
    mov       [%r14],	%rax
    mov       %rax,	%rdi
L4366:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.istypestarter
cc_parse.istypestarter:
#?>>
    .set cc_parse.istypestarter.$T3, -8
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
#---------------
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	71
    jz        L4467
    cmp       %rax,	88
    jz        L4467
    cmp       %rax,	87
    jz        L4468
    cmp       %rax,	67
    jz        L4469
    cmp       %rax,	84
    jz        L4470
    cmp       %rax,	85
    jz        L4470
    cmp       %rax,	91
    jz        L4470
    jmp       L4471
L4467:
    mov       %rax,	1
    jmp       L4465
L4468:
    mov       %rax,	1
    jmp       L4465
L4469:
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       [%rbp + cc_parse.istypestarter.$T3],	%rax
    mov       %rax,	[%rip+cc_decls.currproc]
    test      %rax,	%rax
    jz        L4473
    mov       %rax,	[%rip+cc_decls.currproc]
    jmp       L4472
L4473:
    mov       %rax,	[%rip+cc_decls.stmodule]
L4472:
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + cc_parse.istypestarter.$T3]
    mov       %r8,	1
    mov       %r9,	[%rip+cc_decls.currblockno]
    call      cc_lib.resolvename
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L4475
    mov       %rax,	%rdi
    lea       %r10,	[%rip+cc_decls.lx]
    mov       [%r10],	%rax
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	5
    setz      %al
    movzx     %eax,	%al
    jmp       L4465
L4475:
    jmp       L4466
L4470:
    mov       %rax,	1
    jmp       L4465
L4471:
L4466:
    xor       %eax,	%eax
L4465:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc cc_parse.istypestarter_next
cc_parse.istypestarter_next:
#?>>
    .set cc_parse.istypestarter_next.$T3, -8
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
#---------------
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	71
    jz        L4478
    cmp       %rax,	88
    jz        L4478
    cmp       %rax,	87
    jz        L4479
    cmp       %rax,	67
    jz        L4480
    cmp       %rax,	84
    jz        L4481
    cmp       %rax,	85
    jz        L4481
    cmp       %rax,	91
    jz        L4481
    jmp       L4482
L4478:
    mov       %rax,	1
    jmp       L4476
L4479:
    mov       %rax,	1
    jmp       L4476
L4480:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    mov       [%rbp + cc_parse.istypestarter_next.$T3],	%rax
    mov       %rax,	[%rip+cc_decls.currproc]
    test      %rax,	%rax
    jz        L4484
    mov       %rax,	[%rip+cc_decls.currproc]
    jmp       L4483
L4484:
    mov       %rax,	[%rip+cc_decls.stmodule]
L4483:
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + cc_parse.istypestarter_next.$T3]
    mov       %r8,	1
    mov       %r9,	[%rip+cc_decls.currblockno]
    call      cc_lib.resolvename
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L4486
    mov       %rax,	%rdi
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10],	%rax
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	5
    setz      %al
    movzx     %eax,	%al
    jmp       L4476
L4486:
    jmp       L4477
L4481:
    mov       %rax,	1
    jmp       L4476
L4482:
L4477:
    xor       %eax,	%eax
L4476:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readexpression
cc_parse.readexpression:
#?>>
    .set cc_parse.readexpression.ulist, -8
    .set cc_parse.readexpression.ulistx, -16
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	56
#---------------
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	9
    jz        L4489
    cmp       %rax,	14
    jnz       L4490
L4489:
    call      cc_parse.readterm
    jmp       L4487
L4490:
L4488:
    call      cc_parse.readassignexpr
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jnz       L4492
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readexpression.ulistx],	%rax
    mov       [%rbp + cc_parse.readexpression.ulist],	%rax
L4493:
    lea       %rcx,	[%rbp + cc_parse.readexpression.ulist]
    lea       %rdx,	[%rbp + cc_parse.readexpression.ulistx]
    mov       %r8,	%rdi
    call      cc_lib.addlistunit
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jnz       L4494
L4496:
    call      cc_lex.lex
    call      cc_parse.readassignexpr
    mov       %rdi,	%rax
    jmp       L4493
L4494:
    mov       %rcx,	29
    mov       %rdx,	[%rbp + cc_parse.readexpression.ulist]
    call      cc_lib.createunit1
    mov       %rdi,	%rax
    mov       %rax,	[%rbp + cc_parse.readexpression.ulistx]
    test      %rax,	%rax
    jz        L4498
    mov       %rax,	[%rbp + cc_parse.readexpression.ulistx]
    mov       %eax,	[%rax+52]
    mov       [%rdi+52],	%eax
L4498:
    mov       %rax,	%rdi
    jmp       L4487
L4492:
    mov       %rax,	%rdi
L4487:
#---------------
    add       %rsp,	56
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readassignexpr
cc_parse.readassignexpr:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
#---------------
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jz        L4501
    cmp       %rax,	9
    jz        L4501
    cmp       %rax,	14
    jz        L4501
    cmp       %rax,	11
    jz        L4502
    jmp       L4503
L4501:
    call      cc_parse.readterm
    jmp       L4499
L4502:
    call      cc_parse.readterm
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %r12,	%rax
    jmp       L4504
L4503:
L4500:
    call      cc_parse.readcondexpr
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %r12,	%rax
    sub       %rax,	11
    cmp       %rax,	45
    jae       L4507
    lea       %r10,	[%rip+L4506]
    jmp       [%r10 + %rax*8]
    .data
L4506:
    .quad     L4508
    .quad     L4507
    .quad     L4507
    .quad     L4507
    .quad     L4507
    .quad     L4507
    .quad     L4507
    .quad     L4507
    .quad     L4507
    .quad     L4507
    .quad     L4507
    .quad     L4507
    .quad     L4507
    .quad     L4507
    .quad     L4507
    .quad     L4507
    .quad     L4507
    .quad     L4507
    .quad     L4507
    .quad     L4507
    .quad     L4507
    .quad     L4507
    .quad     L4507
    .quad     L4507
    .quad     L4507
    .quad     L4507
    .quad     L4507
    .quad     L4507
    .quad     L4507
    .quad     L4507
    .quad     L4507
    .quad     L4507
    .quad     L4507
    .quad     L4507
    .quad     L4507
    .quad     L4508
    .quad     L4508
    .quad     L4508
    .quad     L4508
    .quad     L4508
    .quad     L4508
    .quad     L4508
    .quad     L4508
    .quad     L4508
    .quad     L4508
    .text
L4508:
#cc_parse.readassignexpr.gotp:
L4504:
    call      cc_lex.lex
    movsxd    %rax,	dword ptr[%rdi+52]
    mov       %r13,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      cc_parse.checklvalue
    call      cc_parse.readassignexpr
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%rdi+52]
    lea       %r10,	[%rip+cc_decls.ttisref]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L4510
    mov       %rcx,	%r12
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      cc_parse.createassignopref
    jmp       L4499
L4510:
    mov       %rcx,	%rbx
    mov       %rdx,	%r13
    call      cc_parse.coercemode
    mov       %rbx,	%rax
    lea       %rax,	[%rip+cc_decls.ttconst]
    mov       %r10,	%r13
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L4512
    lea       %rcx,	[%rip+L8589]
    call      cc_support.terror
L4512:
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	52
    jnz       L4514
    mov       %rax,	[%rdi+16]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L4514
    lea       %rcx,	[%rip+L8590]
    call      cc_support.terror
L4514:
    lea       %rax,	[%rip+cc_tables.symboltojtag]
    mov       %r10,	%r12
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      cc_lib.createunit2
    mov       %rsi,	%rax
    mov       [%rsi+52],	%r13d
    mov       %rax,	%rsi
    jmp       L4499
L4507:
L4505:
    mov       %rax,	%rdi
L4499:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readcondexpr
cc_parse.readcondexpr:
#?>>
    .set cc_parse.readcondexpr.u, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
#---------------
    call      cc_parse.readorlexpr
    mov       %rsi,	%rax
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	19
    jnz       L4517
    mov       %rcx,	%rsi
    call      cc_parse.coercecond
    call      cc_lex.lex
    call      cc_parse.readexpression
    mov       %rdi,	%rax
    mov       %rcx,	10
    call      cc_lib.skipsymbol
    call      cc_parse.readcondexpr
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%rdi+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %r12,	%r10
    lea       %rax,	[%rip+cc_tables.dominantmode]
    mov       %r11,	%r10
    shl       %r11,	5
    lea       %rax,	[%rax + %r11]
    movsxd    %r10,	dword ptr[%rbx+52]
    lea       %r11,	[%rip+cc_decls.ttbasetype]
    movsx     %r11,	word ptr[%r11 + %r10*2]
    mov       %r13,	%r11
    movzx     %rax,	byte ptr[%rax + %r11]
    mov       [%rbp + cc_parse.readcondexpr.u],	%rax
    test      %rax,	%rax
    jz        L4519
    mov       %rcx,	%rdi
    mov       %rdx,	[%rbp + cc_parse.readcondexpr.u]
    call      cc_parse.coercemode
    mov       %rdi,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	[%rbp + cc_parse.readcondexpr.u]
    call      cc_parse.coercemode
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%rsi+40]
    cmp       %rax,	1
    jnz       L4521
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	1
    jnz       L4521
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L4521
    mov       %rax,	[%rsi]
    test      %rax,	%rax
    jz        L4523
    mov       %rax,	%rdi
    jmp       L4522
L4523:
    mov       %rax,	%rbx
L4522:
    jmp       L4515
L4521:
    jmp       L4518
L4519:
    cmp       %r12,	13
    jnz       L4524
    cmp       %r13,	13
    jnz       L4524
    movsxd    %rax,	dword ptr[%rdi+52]
    mov       [%rbp + cc_parse.readcondexpr.u],	%rax
    jmp       L4518
L4524:
    cmp       %r12,	13
    jnz       L4525
    cmp       %r13,	3
    jnz       L4525
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L4525
    mov       %rax,	[%rbx]
    test      %rax,	%rax
    jnz       L4525
    movsxd    %rax,	dword ptr[%rdi+52]
    mov       [%rbp + cc_parse.readcondexpr.u],	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	[%rbp + cc_parse.readcondexpr.u]
    call      cc_parse.coercemode
    jmp       L4518
L4525:
    cmp       %r12,	3
    jnz       L4526
    cmp       %r13,	13
    jnz       L4526
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	1
    jnz       L4526
    mov       %rax,	[%rdi]
    test      %rax,	%rax
    jnz       L4526
    movsxd    %rax,	dword ptr[%rbx+52]
    mov       [%rbp + cc_parse.readcondexpr.u],	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	[%rbp + cc_parse.readcondexpr.u]
    call      cc_parse.coercemode
    jmp       L4518
L4526:
    cmp       %r12,	18
    jnz       L4527
    cmp       %r13,	18
    jnz       L4527
    movsxd    %rax,	dword ptr[%rdi+52]
    mov       [%rbp + cc_parse.readcondexpr.u],	%rax
    jmp       L4518
L4527:
    cmp       %r12,	19
    jnz       L4528
    cmp       %r13,	19
    jnz       L4528
    movsxd    %rax,	dword ptr[%rdi+52]
    mov       [%rbp + cc_parse.readcondexpr.u],	%rax
    jmp       L4518
L4528:
    mov       %rax,	%r13
    cmp       %rax,	%r12
    jnz       L4529
    test      %rax,	%rax
    jnz       L4529
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readcondexpr.u],	%rax
    jmp       L4518
L4529:
    call      msys.m$print_startcon
    movsxd    %rax,	dword ptr[%rdi+52]
    mov       %rcx,	%rax
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    movsxd    %rax,	dword ptr[%rbx+52]
    mov       %rcx,	%rax
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8591]
    call      cc_support.terror
L4518:
    mov       %rcx,	31
    mov       %rdx,	%rsi
    mov       %r8,	%rdi
    mov       %r9,	%rbx
    call      cc_lib.createunit3
    mov       %rsi,	%rax
    mov       %eax,	[%rbp + cc_parse.readcondexpr.u]
    mov       [%rsi+52],	%eax
L4517:
    mov       %rax,	%rsi
L4515:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readorlexpr
cc_parse.readorlexpr:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
    call      cc_parse.readandlexpr
    mov       %rdi,	%rax
    jmp       L4532
L4531:
    call      cc_lex.lex
    call      cc_parse.readandlexpr
    mov       %rbx,	%rax
    mov       %rcx,	%rdi
    call      cc_parse.coercecond
    mov       %rcx,	%rbx
    call      cc_parse.coercecond
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	1
    jnz       L4535
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L4535
    mov       %rax,	[%rdi]
    test      %rax,	%rax
    jnz       L4538
    mov       %rax,	[%rbx]
    test      %rax,	%rax
    jz        L4537
L4538:
    mov       %rax,	1
    jmp       L4536
L4537:
    xor       %eax,	%eax
L4536:
    mov       [%rdi],	%rax
    jmp       L4532
L4535:
    mov       %rcx,	25
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       %eax,	3
    mov       [%rdi+52],	%eax
L4532:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	31
    jz        L4531
    mov       %rax,	%rdi
L4530:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readandlexpr
cc_parse.readandlexpr:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
    call      cc_parse.readiorexpr
    mov       %rdi,	%rax
    jmp       L4541
L4540:
    call      cc_lex.lex
    call      cc_parse.readiorexpr
    mov       %rbx,	%rax
    mov       %rcx,	%rdi
    call      cc_parse.coercecond
    mov       %rcx,	%rbx
    call      cc_parse.coercecond
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	1
    jnz       L4544
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L4544
    mov       %rax,	[%rdi]
    test      %rax,	%rax
    jz        L4546
    mov       %rax,	[%rbx]
    test      %rax,	%rax
    jz        L4546
    mov       %rax,	1
    jmp       L4545
L4546:
    xor       %eax,	%eax
L4545:
    mov       [%rdi],	%rax
    jmp       L4541
L4544:
    mov       %rcx,	24
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       %eax,	3
    mov       [%rdi+52],	%eax
L4541:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	32
    jz        L4540
    mov       %rax,	%rdi
L4539:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readiorexpr
cc_parse.readiorexpr:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
    call      cc_parse.readixorexpr
    mov       %rdi,	%rax
    jmp       L4549
L4548:
    call      cc_lex.lex
    call      cc_parse.readixorexpr
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%rdi+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    lea       %rax,	[%rip+cc_tables.dominantmode]
    mov       %r11,	%r10
    shl       %r11,	5
    lea       %rax,	[%rax + %r11]
    movsxd    %r10,	dword ptr[%rbx+52]
    lea       %r11,	[%rip+cc_decls.ttbasetype]
    movsx     %r11,	word ptr[%r11 + %r10*2]
    movzx     %rax,	byte ptr[%rax + %r11]
    mov       %rsi,	%rax
    test      %rax,	%rax
    jz        L4552
    cmp       %rsi,	10
    jl        L4554
    lea       %rcx,	[%rip+L8592]
    call      cc_support.terror
L4554:
    mov       %rcx,	%rdi
    mov       %rdx,	%rsi
    call      cc_parse.coercemode
    mov       %rdi,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      cc_parse.coercemode
    mov       %rbx,	%rax
    jmp       L4551
L4552:
    lea       %rcx,	[%rip+L8593]
    call      cc_support.terror
L4551:
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	1
    jnz       L4556
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L4556
    mov       %rax,	%rsi
    cmp       %rax,	3
    jz        L4558
    cmp       %rax,	4
    jz        L4558
    cmp       %rax,	8
    jz        L4558
    cmp       %rax,	9
    jnz       L4559
L4558:
    mov       %rax,	[%rbx]
    mov       %r10,	%rdi
    or        [%r10],	%rax
    jmp       L4549
L4559:
L4557:
L4556:
    mov       %rcx,	45
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%esi
L4549:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	28
    jz        L4548
    mov       %rax,	%rdi
L4547:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readixorexpr
cc_parse.readixorexpr:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
    call      cc_parse.readiandexpr
    mov       %rdi,	%rax
    jmp       L4562
L4561:
    call      cc_lex.lex
    call      cc_parse.readiandexpr
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%rdi+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    lea       %rax,	[%rip+cc_tables.dominantmode]
    mov       %r11,	%r10
    shl       %r11,	5
    lea       %rax,	[%rax + %r11]
    movsxd    %r10,	dword ptr[%rbx+52]
    lea       %r11,	[%rip+cc_decls.ttbasetype]
    movsx     %r11,	word ptr[%r11 + %r10*2]
    movzx     %rax,	byte ptr[%rax + %r11]
    mov       %rsi,	%rax
    test      %rax,	%rax
    jz        L4565
    cmp       %rsi,	10
    jl        L4567
    lea       %rcx,	[%rip+L8594]
    call      cc_support.terror
L4567:
    mov       %rcx,	%rdi
    mov       %rdx,	%rsi
    call      cc_parse.coercemode
    mov       %rdi,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      cc_parse.coercemode
    mov       %rbx,	%rax
    jmp       L4564
L4565:
    lea       %rcx,	[%rip+L8595]
    call      cc_support.terror
L4564:
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	1
    jnz       L4569
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L4569
    mov       %rax,	%rsi
    cmp       %rax,	3
    jz        L4571
    cmp       %rax,	4
    jz        L4571
    cmp       %rax,	8
    jz        L4571
    cmp       %rax,	9
    jnz       L4572
L4571:
    mov       %rax,	[%rbx]
    mov       %r10,	%rdi
    xor       [%r10],	%rax
    jmp       L4562
L4572:
L4570:
L4569:
    mov       %rcx,	46
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%esi
L4562:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	30
    jz        L4561
    mov       %rax,	%rdi
L4560:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readiandexpr
cc_parse.readiandexpr:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
    call      cc_parse.readeqexpr
    mov       %rdi,	%rax
    jmp       L4575
L4574:
    call      cc_lex.lex
    call      cc_parse.readeqexpr
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%rdi+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    lea       %rax,	[%rip+cc_tables.dominantmode]
    mov       %r11,	%r10
    shl       %r11,	5
    lea       %rax,	[%rax + %r11]
    movsxd    %r10,	dword ptr[%rbx+52]
    lea       %r11,	[%rip+cc_decls.ttbasetype]
    movsx     %r11,	word ptr[%r11 + %r10*2]
    movzx     %rax,	byte ptr[%rax + %r11]
    mov       %rsi,	%rax
    test      %rax,	%rax
    jz        L4578
    cmp       %rsi,	10
    jl        L4580
    lea       %rcx,	[%rip+L8596]
    call      cc_support.terror
L4580:
    mov       %rcx,	%rdi
    mov       %rdx,	%rsi
    call      cc_parse.coercemode
    mov       %rdi,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      cc_parse.coercemode
    mov       %rbx,	%rax
    jmp       L4577
L4578:
    call      msys.m$print_startcon
    movsxd    %rax,	dword ptr[%rdi+52]
    mov       %rcx,	%rax
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    movsxd    %rax,	dword ptr[%rbx+52]
    mov       %rcx,	%rax
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8597]
    call      cc_support.terror
L4577:
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	1
    jnz       L4582
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L4582
    mov       %rax,	%rsi
    cmp       %rax,	3
    jz        L4584
    cmp       %rax,	4
    jz        L4584
    cmp       %rax,	8
    jz        L4584
    cmp       %rax,	9
    jnz       L4585
L4584:
    mov       %rax,	[%rbx]
    mov       %r10,	%rdi
    and       [%r10],	%rax
    jmp       L4575
L4585:
L4583:
L4582:
    mov       %rcx,	44
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%esi
L4575:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	29
    jz        L4574
    mov       %rax,	%rdi
L4573:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readeqexpr
cc_parse.readeqexpr:
#?>>
    .set cc_parse.readeqexpr.ss, -8
    .set cc_parse.readeqexpr.tt, -16
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
#---------------
    call      cc_parse.readrelexpr
    mov       %rdi,	%rax
    jmp       L4588
L4587:
    call      cc_lex.lex
    call      cc_parse.readrelexpr
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%rdi+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %r12,	%r10
    lea       %rax,	[%rip+cc_tables.dominantmode]
    mov       %r11,	%r10
    shl       %r11,	5
    lea       %rax,	[%rax + %r11]
    movsxd    %r10,	dword ptr[%rbx+52]
    lea       %r11,	[%rip+cc_decls.ttbasetype]
    movsx     %r11,	word ptr[%r11 + %r10*2]
    mov       %r13,	%r11
    movzx     %rax,	byte ptr[%rax + %r11]
    mov       %r14,	%rax
    test      %rax,	%rax
    jz        L4591
    mov       %rcx,	%rdi
    mov       %rdx,	%r14
    call      cc_parse.coercemode
    mov       %rdi,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	%r14
    call      cc_parse.coercemode
    mov       %rbx,	%rax
    jmp       L4590
L4591:
    cmp       %r12,	13
    jnz       L4592
    cmp       %r13,	13
    jnz       L4592
    movsxd    %rax,	dword ptr[%rdi+52]
    lea       %r10,	[%rip+cc_decls.tttarget]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       [%rbp + cc_parse.readeqexpr.ss],	%r10
    movsxd    %rax,	dword ptr[%rbx+52]
    lea       %r11,	[%rip+cc_decls.tttarget]
    movsx     %r11,	word ptr[%r11 + %rax*2]
    mov       [%rbp + cc_parse.readeqexpr.tt],	%r11
    cmp       %r10,	%r11
    jz        L4594
    mov       %rax,	[%rbp + cc_parse.readeqexpr.ss]
    test      %rax,	%rax
    jz        L4596
    mov       %rax,	[%rbp + cc_parse.readeqexpr.tt]
    test      %rax,	%rax
    jz        L4596
    movsxd    %rax,	dword ptr[%rbx+52]
    movsxd    %r10,	dword ptr[%rdi+52]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    mov       %r8,	1
    call      cc_parse.checkpointertypes
    test      %rax,	%rax
    jnz       L4598
    lea       %rcx,	[%rip+L8598]
    call      cc_support.terror
L4598:
L4596:
L4594:
    jmp       L4590
L4592:
    cmp       %r12,	13
    jnz       L4599
    cmp       %r13,	3
    jnz       L4599
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L4602
    mov       %rax,	[%rbx]
    test      %rax,	%rax
    jz        L4601
L4602:
    lea       %rcx,	[%rip+L8599]
    call      cc_support.terror
L4601:
    jmp       L4590
L4599:
    cmp       %r12,	3
    jnz       L4603
    cmp       %r13,	13
    jnz       L4603
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	1
    jnz       L4606
    mov       %rax,	[%rdi]
    test      %rax,	%rax
    jz        L4605
L4606:
    lea       %rcx,	[%rip+L8600]
    call      cc_support.terror
L4605:
    jmp       L4590
L4603:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8601]
    call      msys.m$print_str_nf
    mov       %rcx,	%r14
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8602]
    call      cc_support.terror
L4590:
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	1
    jnz       L4608
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L4608
    mov       %rax,	%r14
    cmp       %rax,	3
    jz        L4610
    cmp       %rax,	4
    jz        L4610
    cmp       %rax,	8
    jz        L4610
    cmp       %rax,	9
    jz        L4610
    test      %rax,	%rax
    jnz       L4611
L4610:
    cmp       %rsi,	40
    jnz       L4613
    mov       %rax,	[%rdi]
    mov       %r10,	[%rbx]
    cmp       %rax,	%r10
    setz      %al
    movzx     %eax,	%al
    mov       [%rdi],	%rax
    jmp       L4612
L4613:
    mov       %rax,	[%rdi]
    mov       %r10,	[%rbx]
    cmp       %rax,	%r10
    setnz     %al
    movzx     %eax,	%al
    mov       [%rdi],	%rax
L4612:
    jmp       L4588
L4611:
L4609:
L4608:
    lea       %rax,	[%rip+cc_tables.symboltojtag]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       %eax,	3
    mov       [%rdi+52],	%eax
L4588:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %rsi,	%rax
    cmp       %rax,	40
    jz        L4587
    cmp       %rsi,	41
    jz        L4587
    mov       %rax,	%rdi
L4586:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readrelexpr
cc_parse.readrelexpr:
#?>>
    .set cc_parse.readrelexpr.a, -8
    .set cc_parse.readrelexpr.b, -16
    .set cc_parse.readrelexpr.c, -24
    .set cc_parse.readrelexpr.aa, -32
    .set cc_parse.readrelexpr.bb, -40
    .set cc_parse.readrelexpr.cc, -48
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	80
#---------------
    call      cc_parse.readshiftexpr
    mov       %rdi,	%rax
    jmp       L4616
L4615:
    call      cc_lex.lex
    call      cc_parse.readshiftexpr
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%rdi+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %r12,	%r10
    lea       %rax,	[%rip+cc_tables.dominantmode]
    mov       %r11,	%r10
    shl       %r11,	5
    lea       %rax,	[%rax + %r11]
    movsxd    %r10,	dword ptr[%rbx+52]
    lea       %r11,	[%rip+cc_decls.ttbasetype]
    movsx     %r11,	word ptr[%r11 + %r10*2]
    mov       %r13,	%r11
    movzx     %rax,	byte ptr[%rax + %r11]
    mov       %r14,	%rax
    test      %rax,	%rax
    jz        L4619
    mov       %rcx,	%rdi
    mov       %rdx,	%r14
    call      cc_parse.coercemode
    mov       %rdi,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	%r14
    call      cc_parse.coercemode
    mov       %rbx,	%rax
    jmp       L4618
L4619:
    cmp       %r12,	13
    jnz       L4620
    cmp       %r13,	13
    jnz       L4620
    movsxd    %rax,	dword ptr[%rbx+52]
    movsxd    %r10,	dword ptr[%rdi+52]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    mov       %r8,	1
    call      cc_parse.checkpointertypes
    test      %rax,	%rax
    jnz       L4622
    lea       %rcx,	[%rip+L8603]
    call      cc_support.terror
L4622:
    jmp       L4618
L4620:
    lea       %rcx,	[%rip+L8604]
    call      cc_support.terror
L4618:
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	1
    jnz       L4624
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L4624
    mov       %rax,	[%rdi]
    mov       [%rbp + cc_parse.readrelexpr.a],	%rax
    mov       %rax,	[%rbx]
    mov       [%rbp + cc_parse.readrelexpr.b],	%rax
    mov       %rax,	%r14
    cmp       %rax,	3
    jz        L4626
    cmp       %rax,	4
    jz        L4626
    cmp       %rax,	8
    jz        L4627
    cmp       %rax,	9
    jz        L4627
    jmp       L4628
L4626:
    mov       %rax,	%rsi
    cmp       %rax,	42
    jz        L4630
    cmp       %rax,	43
    jz        L4631
    cmp       %rax,	44
    jz        L4632
    jmp       L4633
L4630:
    mov       %rax,	[%rbp + cc_parse.readrelexpr.a]
    cmp       %rax,	[%rbp + cc_parse.readrelexpr.b]
    setl      %al
    movzx     %eax,	%al
    mov       [%rbp + cc_parse.readrelexpr.c],	%rax
    jmp       L4629
L4631:
    mov       %rax,	[%rbp + cc_parse.readrelexpr.a]
    cmp       %rax,	[%rbp + cc_parse.readrelexpr.b]
    setle     %al
    movzx     %eax,	%al
    mov       [%rbp + cc_parse.readrelexpr.c],	%rax
    jmp       L4629
L4632:
    mov       %rax,	[%rbp + cc_parse.readrelexpr.a]
    cmp       %rax,	[%rbp + cc_parse.readrelexpr.b]
    setge     %al
    movzx     %eax,	%al
    mov       [%rbp + cc_parse.readrelexpr.c],	%rax
    jmp       L4629
L4633:
    mov       %rax,	[%rbp + cc_parse.readrelexpr.a]
    cmp       %rax,	[%rbp + cc_parse.readrelexpr.b]
    setg      %al
    movzx     %eax,	%al
    mov       [%rbp + cc_parse.readrelexpr.c],	%rax
L4629:
    mov       %rax,	[%rbp + cc_parse.readrelexpr.c]
    mov       [%rdi],	%rax
    jmp       L4616
L4627:
    mov       %rax,	[%rdi]
    mov       [%rbp + cc_parse.readrelexpr.aa],	%rax
    mov       %rax,	[%rbx]
    mov       [%rbp + cc_parse.readrelexpr.bb],	%rax
    mov       %rax,	%rsi
    cmp       %rax,	42
    jz        L4635
    cmp       %rax,	43
    jz        L4636
    cmp       %rax,	44
    jz        L4637
    jmp       L4638
L4635:
    mov       %rax,	[%rbp + cc_parse.readrelexpr.aa]
    cmp       %rax,	[%rbp + cc_parse.readrelexpr.bb]
    setb      %al
    movzx     %eax,	%al
    mov       [%rbp + cc_parse.readrelexpr.cc],	%rax
    jmp       L4634
L4636:
    mov       %rax,	[%rbp + cc_parse.readrelexpr.aa]
    cmp       %rax,	[%rbp + cc_parse.readrelexpr.bb]
    setbe     %al
    movzx     %eax,	%al
    mov       [%rbp + cc_parse.readrelexpr.cc],	%rax
    jmp       L4634
L4637:
    mov       %rax,	[%rbp + cc_parse.readrelexpr.aa]
    cmp       %rax,	[%rbp + cc_parse.readrelexpr.bb]
    setae     %al
    movzx     %eax,	%al
    mov       [%rbp + cc_parse.readrelexpr.cc],	%rax
    jmp       L4634
L4638:
    mov       %rax,	[%rbp + cc_parse.readrelexpr.aa]
    cmp       %rax,	[%rbp + cc_parse.readrelexpr.bb]
    seta      %al
    movzx     %eax,	%al
    mov       [%rbp + cc_parse.readrelexpr.cc],	%rax
L4634:
    mov       %rax,	[%rbp + cc_parse.readrelexpr.cc]
    mov       [%rdi],	%rax
    jmp       L4616
L4628:
L4625:
L4624:
    lea       %rax,	[%rip+cc_tables.symboltojtag]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       %eax,	3
    mov       [%rdi+52],	%eax
L4616:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %rsi,	%rax
    cmp       %rax,	42
    jz        L4615
    cmp       %rsi,	43
    jz        L4615
    cmp       %rsi,	44
    jz        L4615
    cmp       %rsi,	45
    jz        L4615
    mov       %rax,	%rdi
L4614:
#---------------
    add       %rsp,	80
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readshiftexpr
cc_parse.readshiftexpr:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
#---------------
    call      cc_parse.readaddexpr
    mov       %rdi,	%rax
    jmp       L4641
L4640:
    call      cc_lex.lex
    call      cc_parse.readaddexpr
    mov       %rbx,	%rax
    mov       %rcx,	%rdi
    call      cc_parse.coercebasetype
    movsxd    %rax,	dword ptr[%rdi+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %r12,	%r10
    cmp       %r10,	1
    jl        L4645
    cmp       %r12,	9
    jle       L4644
L4645:
    lea       %rcx,	[%rip+L8605]
    call      cc_support.terror
L4644:
    mov       %rcx,	%rbx
    mov       %rdx,	3
    call      cc_parse.coercemode
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	1
    jnz       L4647
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L4647
    mov       %rax,	%r12
    cmp       %rax,	3
    jz        L4649
    cmp       %rax,	4
    jz        L4649
    cmp       %rax,	8
    jz        L4650
    cmp       %rax,	9
    jz        L4650
    jmp       L4651
L4649:
    cmp       %rsi,	33
    jnz       L4653
    mov       %rax,	[%rdi]
    mov       %r10,	[%rbx]
    mov       %cl,	%r10b
    shl       %rax,	%cl
    mov       [%rdi],	%rax
    jmp       L4652
L4653:
    mov       %rax,	[%rdi]
    mov       %r10,	[%rbx]
    mov       %cl,	%r10b
    sar       %rax,	%cl
    mov       [%rdi],	%rax
L4652:
    jmp       L4641
L4650:
    cmp       %rsi,	33
    jnz       L4655
    mov       %rax,	[%rdi]
    mov       %r10,	[%rbx]
    mov       %cl,	%r10b
    shl       %rax,	%cl
    mov       [%rdi],	%rax
    jmp       L4654
L4655:
    mov       %rax,	[%rdi]
    mov       %r10,	[%rbx]
    mov       %cl,	%r10b
    shr       %rax,	%cl
    mov       [%rdi],	%rax
L4654:
    jmp       L4641
L4651:
L4648:
L4647:
    cmp       %rsi,	33
    jnz       L4657
    mov       %rax,	47
    jmp       L4656
L4657:
    mov       %rax,	48
L4656:
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%r12d
L4641:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %rsi,	%rax
    cmp       %rax,	33
    jz        L4640
    cmp       %rsi,	34
    jz        L4640
    mov       %rax,	%rdi
L4639:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readaddexpr
cc_parse.readaddexpr:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
    call      cc_parse.readmulexpr
    mov       %rdi,	%rax
    jmp       L4660
L4659:
    call      cc_lex.lex
    call      cc_parse.readmulexpr
    mov       %rbx,	%rax
    cmp       %rsi,	23
    jnz       L4663
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      cc_parse.createaddop
    mov       %rdi,	%rax
    jmp       L4662
L4663:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      cc_parse.createsubop
    mov       %rdi,	%rax
L4662:
L4660:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %rsi,	%rax
    cmp       %rax,	23
    jz        L4659
    cmp       %rsi,	24
    jz        L4659
    mov       %rax,	%rdi
L4658:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readmulexpr
cc_parse.readmulexpr:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
    call      cc_parse.readterm
    mov       %rdi,	%rax
    jmp       L4666
L4665:
    call      cc_lex.lex
    call      cc_parse.readterm
    mov       %rbx,	%rax
    mov       %rax,	%rsi
    cmp       %rax,	25
    jz        L4669
    cmp       %rax,	26
    jz        L4670
    cmp       %rax,	27
    jz        L4671
    jmp       L4672
L4669:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      cc_parse.createmulop
    mov       %rdi,	%rax
    jmp       L4668
L4670:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      cc_parse.createdivop
    mov       %rdi,	%rax
    jmp       L4668
L4671:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      cc_parse.createremop
    mov       %rdi,	%rax
L4672:
L4668:
L4666:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %rsi,	%rax
    cmp       %rax,	25
    jz        L4665
    cmp       %rsi,	26
    jz        L4665
    cmp       %rsi,	27
    jz        L4665
    mov       %rax,	%rdi
L4664:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readterm
cc_parse.readterm:
#?>>
    .set cc_parse.readterm.slength, -8
    .set cc_parse.readterm.fwide, -16
    .set cc_parse.readterm.tag, -24
    .set cc_parse.readterm.pbyte, -32
    .set cc_parse.readterm.a, -40
    .set cc_parse.readterm.d, -48
    .set cc_parse.readterm.ss, -56
    .set cc_parse.readterm.s, -64
    .set cc_parse.readterm.pm, -72
    .set cc_parse.readterm.av_1, -80
    .set cc_parse.readterm.$T3, -88
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	120
#---------------
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    sub       %rax,	13
    cmp       %rax,	84
    jae       L4676
    lea       %r10,	[%rip+L4675]
    jmp       [%r10 + %rax*8]
    .data
L4675:
    .quad     L4723
    .quad     L4676
    .quad     L4676
    .quad     L4676
    .quad     L4676
    .quad     L4676
    .quad     L4676
    .quad     L4676
    .quad     L4676
    .quad     L4676
    .quad     L4710
    .quad     L4711
    .quad     L4720
    .quad     L4676
    .quad     L4676
    .quad     L4676
    .quad     L4716
    .quad     L4676
    .quad     L4676
    .quad     L4719
    .quad     L4676
    .quad     L4676
    .quad     L4715
    .quad     L4712
    .quad     L4721
    .quad     L4721
    .quad     L4722
    .quad     L4676
    .quad     L4676
    .quad     L4676
    .quad     L4676
    .quad     L4676
    .quad     L4676
    .quad     L4676
    .quad     L4676
    .quad     L4676
    .quad     L4676
    .quad     L4676
    .quad     L4676
    .quad     L4676
    .quad     L4676
    .quad     L4676
    .quad     L4676
    .quad     L4676
    .quad     L4676
    .quad     L4676
    .quad     L4677
    .quad     L4677
    .quad     L4702
    .quad     L4676
    .quad     L4696
    .quad     L4696
    .quad     L4676
    .quad     L4676
    .quad     L4678
    .quad     L4676
    .quad     L4676
    .quad     L4676
    .quad     L4676
    .quad     L4676
    .quad     L4676
    .quad     L4676
    .quad     L4676
    .quad     L4676
    .quad     L4676
    .quad     L4676
    .quad     L4676
    .quad     L4676
    .quad     L4676
    .quad     L4676
    .quad     L4676
    .quad     L4676
    .quad     L4676
    .quad     L4676
    .quad     L4676
    .quad     L4676
    .quad     L4676
    .quad     L4676
    .quad     L4676
    .quad     L4728
    .quad     L4676
    .quad     L4739
    .quad     L4740
    .quad     L4741
    .text
L4677:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+22]
    lea       %r10,	[%rip+cc_decls.lx]
    mov       %r10,	[%r10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      cc_lib.createconstunit
    mov       %rdi,	%rax
    call      cc_lex.lex
    jmp       L4674
L4678:
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	1
    jg        L4680
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       [%rbp + cc_parse.readterm.$T3],	%rax
    mov       %rax,	[%rip+cc_decls.currproc]
    test      %rax,	%rax
    jz        L4682
    mov       %rax,	[%rip+cc_decls.currproc]
    jmp       L4681
L4682:
    mov       %rax,	[%rip+cc_decls.stmodule]
L4681:
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + cc_parse.readterm.$T3]
    mov       %r8,	1
    mov       %r9,	[%rip+cc_decls.currblockno]
    call      cc_lib.resolvename
    mov       [%rbp + cc_parse.readterm.d],	%rax
    mov       %rax,	[%rbp + cc_parse.readterm.d]
    test      %rax,	%rax
    jnz       L4684
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    call      cc_lib.getstname
    lea       %rcx,	[%rip+L8606]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L4684:
    jmp       L4679
L4680:
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       [%rbp + cc_parse.readterm.d],	%rax
L4679:
    mov       %rax,	[%rbp + cc_parse.readterm.d]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	11
    jz        L4686
    cmp       %rax,	6
    jz        L4687
    jmp       L4688
L4686:
    mov       %rax,	[%rbp + cc_parse.readterm.d]
    movsxd    %rax,	dword ptr[%rax+88]
    mov       %rcx,	%rax
    mov       %rdx,	3
    call      cc_lib.createconstunit
    mov       %rdi,	%rax
    jmp       L4685
L4687:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	13
    jz        L4690
    mov       %rcx,	5
    call      cc_lib.createunit0
    mov       %rdi,	%rax
    mov       %rax,	[%rbp + cc_parse.readterm.d]
    mov       [%rdi],	%rax
    mov       %rax,	[%rbp + cc_parse.readterm.d]
    mov       %rax,	[%rax+80]
    mov       %r10,	[%rbp + cc_parse.readterm.d]
    movzx     %r10,	word ptr[%r10+102]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      cc_lib.createprocmode
    mov       %rcx,	%rax
    call      cc_lib.createrefmode
    mov       [%rdi+52],	%eax
    jmp       L4689
L4690:
    jmp       L4691
L4689:
    jmp       L4685
L4688:
#cc_parse.readterm.doname:
L4691:
    mov       %rcx,	[%rbp + cc_parse.readterm.d]
    call      cc_lib.createname
    mov       %rdi,	%rax
    mov       %rax,	[%rbp + cc_parse.readterm.d]
    movzx     %rax,	word ptr[%rax+102]
    mov       %rsi,	%rax
    mov       [%rdi+52],	%eax
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rsi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jnz       L4693
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8]
    mov       [%rdi+48],	%eax
    mov       %rcx,	%rdi
    call      cc_parse.createaddrofop
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%rsi
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rcx,	%rax
    call      cc_lib.createrefmode
    mov       [%rdi+52],	%eax
    jmp       L4692
L4693:
    mov       %rax,	[%rbp + cc_parse.readterm.d]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	6
    jz        L4694
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8]
    cmp       %rax,	4
    jge       L4694
    mov       %rcx,	%rdi
    call      cc_parse.fixmemopnd
    jmp       L4692
L4694:
    mov       %rax,	[%rbp + cc_parse.readterm.d]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	9
    jnz       L4695
L4695:
L4692:
L4685:
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %eax,	[%rax+16]
    mov       [%rdi+44],	%eax
    call      cc_lex.lex
    jmp       L4674
L4696:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	64
    setz      %al
    movzx     %eax,	%al
    mov       [%rbp + cc_parse.readterm.fwide],	%rax
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       [%rbp + cc_parse.readterm.s],	%rax
    lea       %rax,	[%rip+cc_decls.lx]
    movsxd    %rax,	dword ptr[%rax+24]
    mov       [%rbp + cc_parse.readterm.slength],	%rax
    jmp       L4698
L4697:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+24]
    mov       %r10,	[%rbp + cc_parse.readterm.slength]
    add       %r10,	%rax
    mov       %r14,	%r10
    lea       %rax,	[%r14+1]
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       [%rbp + cc_parse.readterm.ss],	%rax
    mov       %rcx,	[%rbp + cc_parse.readterm.ss]
    mov       %rdx,	[%rbp + cc_parse.readterm.s]
    mov       %r8,	[%rbp + cc_parse.readterm.slength]
    call      memcpy
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+24]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       %r10,	[%r10]
    mov       %r11,	[%rbp + cc_parse.readterm.ss]
    mov       %r15,	[%rbp + cc_parse.readterm.slength]
    lea       %r11,	[%r11 + %r15]
    mov       %rcx,	%r11
    mov       %rdx,	%r10
    mov       %r8,	%rax
    call      memcpy
    xor       %eax,	%eax
    mov       %r10,	[%rbp + cc_parse.readterm.ss]
    mov       %r11,	%r14
    mov       [%r10 + %r11],	%al
    mov       %rax,	[%rbp + cc_parse.readterm.ss]
    mov       [%rbp + cc_parse.readterm.s],	%rax
    mov       [%rbp + cc_parse.readterm.slength],	%r14
    call      cc_lex.lex
L4698:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	63
    jz        L4697
    mov       %rax,	[%rbp + cc_parse.readterm.fwide]
    test      %rax,	%rax
    jz        L4701
    mov       %rcx,	[%rbp + cc_parse.readterm.s]
    mov       %rdx,	[%rbp + cc_parse.readterm.slength]
    call      cc_lib.createwstringconstunit
    mov       %rdi,	%rax
    mov       %eax,	[%rbp + cc_parse.readterm.slength]
    mov       [%rdi+48],	%eax
    mov       %eax,	[%rip+cc_decls.trefwchar]
    mov       [%rdi+52],	%eax
    jmp       L4700
L4701:
    mov       %rcx,	[%rbp + cc_parse.readterm.s]
    mov       %rdx,	[%rbp + cc_parse.readterm.slength]
    call      cc_lib.createstringconstunit
    mov       %rdi,	%rax
    mov       %eax,	[%rip+cc_decls.trefchar]
    mov       [%rdi+52],	%eax
L4700:
    call      cc_lex.lex
    jmp       L4674
L4702:
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readterm.a],	%rax
    xor       %r13,	%r13
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       [%rbp + cc_parse.readterm.pbyte],	%rax
    lea       %rax,	[%rip+cc_decls.lx]
    movsxd    %rax,	dword ptr[%rax+24]
    cmp       %rax,	8
    jle       L4704
    lea       %rcx,	[%rip+L8607]
    call      cc_support.serror
L4704:
    lea       %rax,	[%rip+cc_decls.lx]
    movsxd    %rax,	dword ptr[%rax+24]
    mov       [%rbp + cc_parse.readterm.av_1],	%rax
    mov       %rax,	[%rbp + cc_parse.readterm.av_1]
    cmp       %rax,	0
    jle       L4707
L4705:
    mov       %rax,	[%rbp + cc_parse.readterm.pbyte]
    movzx     %rax,	byte ptr[%rax]
    mov       %cl,	%r13b
    shl       %rax,	%cl
    mov       %r10,	[%rbp + cc_parse.readterm.a]
    or        %r10,	%rax
    mov       [%rbp + cc_parse.readterm.a],	%r10
    mov       %rax,	8
    add       %r13,	%rax
    inc       qword ptr[%rbp + cc_parse.readterm.pbyte]
    dec       qword ptr[%rbp + cc_parse.readterm.av_1]
    jnz       L4705
L4707:
    lea       %rax,	[%rip+cc_decls.lx]
    movsxd    %rax,	dword ptr[%rax+24]
    cmp       %rax,	4
    jg        L4709
    mov       %rax,	3
    jmp       L4708
L4709:
    mov       %rax,	4
L4708:
    mov       %rcx,	[%rbp + cc_parse.readterm.a]
    mov       %rdx,	%rax
    call      cc_lib.createconstunit
    mov       %rdi,	%rax
    call      cc_lex.lex
    jmp       L4674
L4710:
    call      cc_lex.lex
    call      cc_parse.readterm
    mov       %rdi,	%rax
    jmp       L4674
L4711:
    call      cc_lex.lex
    call      cc_parse.readterm
    mov       %rcx,	%rax
    call      cc_parse.createnegop
    mov       %rdi,	%rax
    jmp       L4674
L4712:
    call      cc_lex.lex
    call      cc_parse.readterm
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    call      cc_parse.coercecond
    mov       %rcx,	26
    mov       %rdx,	%rdi
    call      cc_lib.createunit1
    mov       %rdi,	%rax
    mov       %eax,	3
    mov       [%rdi+52],	%eax
    mov       %rax,	[%rdi+16]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	26
    jnz       L4714
    mov       %rax,	[%rdi+16]
    mov       %rax,	[%rax+16]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	26
    jnz       L4714
    mov       %rax,	[%rdi+16]
    mov       %rax,	[%rax+16]
    mov       %rax,	[%rax+16]
    mov       [%rdi+16],	%rax
L4714:
    jmp       L4674
L4715:
    call      cc_lex.lex
    call      cc_parse.readterm
    mov       %rcx,	%rax
    call      cc_parse.createinotop
    mov       %rdi,	%rax
    jmp       L4674
L4716:
    call      cc_lex.lex
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	25
    jnz       L4718
    call      cc_lex.lex
    call      cc_parse.readterm
    mov       %rdi,	%rax
    jmp       L4717
L4718:
    call      cc_parse.readterm
    mov       %rcx,	%rax
    call      cc_parse.createaddrofop
    mov       %rdi,	%rax
L4717:
    jmp       L4674
L4719:
    lea       %rcx,	[%rip+L8608]
    call      cc_support.serror
    jmp       L4674
L4720:
    call      cc_lex.lex
    call      cc_parse.readterm
    mov       %rcx,	%rax
    call      cc_parse.createptrop
    mov       %rdi,	%rax
    jmp       L4674
L4721:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    lea       %r10,	[%rip+cc_tables.symboltojtag]
    movzx     %r10,	byte ptr[%r10 + %rax-1]
    mov       %r12,	%r10
    call      cc_lex.lex
    call      cc_parse.readterm
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_parse.createincrop
    mov       %rdi,	%rax
    jmp       L4674
L4722:
    call      cc_lex.lex
    mov       %rcx,	13
    call      cc_lib.skipsymbol
    call      cc_parse.readexpression
    mov       %rcx,	%rax
    call      cc_parse.createabsop
    mov       %rdi,	%rax
    mov       %rcx,	14
    call      cc_lib.skipsymbol
    jmp       L4674
L4723:
    call      cc_lex.lex
    call      cc_parse.istypestarter
    test      %rax,	%rax
    jz        L4725
    sub       %rsp,	8
    push      0
    lea       %rcx,	[%rbp + cc_parse.readterm.d]
    xor       %edx,	%edx
    lea       %r8,	[%rbp + cc_parse.readterm.pm]
    xor       %r9d,	%r9d
    sub       %rsp,	32
    call      cc_parse.readcasttype
    add       %rsp,	48
    mov       %rsi,	%rax
    mov       %rcx,	14
    call      cc_lib.skipsymbol
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	17
    jnz       L4727
    lea       %rcx,	[%rip+L8609]
    call      cc_support.serror
    jmp       L4726
L4727:
    call      cc_parse.readterm
    mov       %rcx,	%rax
    mov       %rdx,	%rsi
    mov       %r8,	1
    xor       %r9d,	%r9d
    call      cc_parse.docast
    mov       %rdi,	%rax
L4726:
    jmp       L4724
L4725:
    call      cc_parse.readexpression
    mov       %rdi,	%rax
    mov       %rcx,	14
    call      cc_lib.skipsymbol
L4724:
    jmp       L4674
L4728:
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %al,	[%rax+22]
    test      %al,	%al
    jz        L4730
    call      cc_lex.lex
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	13
    jnz       L4732
    call      cc_lex.lex
    call      cc_parse.istypestarter
    test      %rax,	%rax
    jz        L4734
    sub       %rsp,	8
    push      0
    lea       %rcx,	[%rbp + cc_parse.readterm.d]
    xor       %edx,	%edx
    lea       %r8,	[%rbp + cc_parse.readterm.pm]
    xor       %r9d,	%r9d
    sub       %rsp,	32
    call      cc_parse.readcasttype
    add       %rsp,	48
    mov       %rsi,	%rax
    mov       %rcx,	14
    call      cc_lib.skipsymbol
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8]
    mov       %rcx,	%rax
    mov       %rdx,	9
    call      cc_lib.createconstunit
    mov       %rdi,	%rax
    jmp       L4733
L4734:
    call      cc_parse.readexpression
    mov       %rdi,	%rax
    mov       %rcx,	14
    call      cc_lib.skipsymbol
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      cc_parse.createsizeofop
    mov       %rdi,	%rax
L4733:
    jmp       L4731
L4732:
    call      cc_parse.readterm
    mov       %rcx,	%rax
    mov       %rdx,	1
    call      cc_parse.createsizeofop
    mov       %rdi,	%rax
L4731:
    jmp       L4729
L4730:
    call      cc_lex.lex
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	13
    jnz       L4736
    call      cc_parse.istypestarter_next
    test      %rax,	%rax
    jz        L4738
    call      cc_lex.lex
    sub       %rsp,	8
    push      0
    lea       %rcx,	[%rbp + cc_parse.readterm.d]
    xor       %edx,	%edx
    lea       %r8,	[%rbp + cc_parse.readterm.pm]
    xor       %r9d,	%r9d
    sub       %rsp,	32
    call      cc_parse.readcasttype
    add       %rsp,	48
    mov       %rsi,	%rax
    mov       %rcx,	14
    call      cc_lib.skipsymbol
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8]
    mov       %rcx,	%rax
    mov       %rdx,	9
    call      cc_lib.createconstunit
    mov       %rdi,	%rax
    jmp       L4737
L4738:
    call      cc_parse.readterm
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      cc_parse.createsizeofop
    mov       %rdi,	%rax
L4737:
    jmp       L4735
L4736:
    call      cc_parse.readterm
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      cc_parse.createsizeofop
    mov       %rdi,	%rax
L4735:
L4729:
    jmp       L4674
L4739:
    call      cc_parse.readgeneric
    mov       %rdi,	%rax
    jmp       L4674
L4740:
    lea       %rcx,	[%rip+L8610]
    call      cc_support.serror
    jmp       L4674
L4741:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+22]
    mov       [%rbp + cc_parse.readterm.tag],	%rax
    call      cc_lex.lex
    mov       %rcx,	13
    call      cc_lib.checksymbol
    call      cc_lex.lex
    call      cc_parse.readassignexpr
    mov       %rdi,	%rax
    mov       %rax,	[%rbp + cc_parse.readterm.tag]
    cmp       %rax,	76
    jnz       L4743
    mov       %rcx,	8
    call      cc_lib.checksymbol
    call      cc_lex.lex
    call      cc_parse.readassignexpr
    mov       %rbx,	%rax
    jmp       L4742
L4743:
    xor       %rbx,	%rbx
L4742:
    mov       %rcx,	[%rbp + cc_parse.readterm.tag]
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       %eax,	3
    mov       [%rdi+52],	%eax
    mov       %rcx,	14
    call      cc_lib.checksymbol
    call      cc_lex.lex
    jmp       L4674
L4676:
    lea       %rcx,	[%rip+L8611]
    call      cc_lex.ps
    lea       %rcx,	[%rip+L8612]
    call      cc_support.serror
L4674:
L4744:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    sub       %rax,	2
    cmp       %rax,	37
    jae       L4747
    lea       %r10,	[%rip+L4746]
    jmp       [%r10 + %rax*8]
    .data
L4746:
    .quad     L4749
    .quad     L4749
    .quad     L4747
    .quad     L4747
    .quad     L4747
    .quad     L4747
    .quad     L4747
    .quad     L4747
    .quad     L4747
    .quad     L4747
    .quad     L4747
    .quad     L4750
    .quad     L4747
    .quad     L4748
    .quad     L4747
    .quad     L4747
    .quad     L4747
    .quad     L4747
    .quad     L4747
    .quad     L4747
    .quad     L4747
    .quad     L4747
    .quad     L4747
    .quad     L4747
    .quad     L4747
    .quad     L4747
    .quad     L4747
    .quad     L4747
    .quad     L4747
    .quad     L4747
    .quad     L4747
    .quad     L4747
    .quad     L4747
    .quad     L4747
    .quad     L4747
    .quad     L4753
    .quad     L4754
    .text
L4748:
    call      cc_lex.lex
    call      cc_parse.readexpression
    mov       %rbx,	%rax
    mov       %rcx,	16
    call      cc_lib.skipsymbol
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      cc_parse.createindexop
    mov       %rdi,	%rax
    jmp       L4744
L4749:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    lea       %r10,	[%rip+cc_tables.symboltojtag]
    movzx     %r10,	byte ptr[%r10 + %rax-1]
    mov       %r12,	%r10
    call      cc_lex.lex
    mov       %rcx,	67
    call      cc_lib.checksymbol
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       [%rbp + cc_parse.readterm.d],	%rax
    call      cc_lex.lex
    mov       %rcx,	%r12
    mov       %rdx,	%rdi
    mov       %r8,	[%rbp + cc_parse.readterm.d]
    call      cc_parse.createdotop
    mov       %rdi,	%rax
    jmp       L4744
L4750:
    call      cc_lex.lex
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	14
    jnz       L4752
    xor       %rbx,	%rbx
    call      cc_lex.lex
    jmp       L4751
L4752:
    xor       %ecx,	%ecx
    call      cc_parse.readexprlist
    mov       %rbx,	%rax
    mov       %rcx,	14
    call      cc_lib.skipsymbol
L4751:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      cc_parse.createcall
    mov       %rdi,	%rax
    jmp       L4744
L4753:
    call      cc_lex.lex
    mov       %rcx,	73
    mov       %rdx,	%rdi
    call      cc_parse.createincrop
    mov       %rdi,	%rax
    jmp       L4744
L4754:
    call      cc_lex.lex
    mov       %rcx,	74
    mov       %rdx,	%rdi
    call      cc_parse.createincrop
    mov       %rdi,	%rax
    jmp       L4744
L4747:
    jmp       L4745
L4745:
    mov       %rax,	%rdi
L4673:
#---------------
    add       %rsp,	120
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readexprlist
cc_parse.readexprlist:
#?>>
    .set cc_parse.readexprlist.ulist, -8
    .set cc_parse.readexprlist.ulistx, -16
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	56
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	%rdi
    mov       [%rbp + cc_parse.readexprlist.ulistx],	%rax
    mov       [%rbp + cc_parse.readexprlist.ulist],	%rax
L4756:
    call      cc_parse.readassignexpr
    mov       %rdi,	%rax
    lea       %rcx,	[%rbp + cc_parse.readexprlist.ulist]
    lea       %rdx,	[%rbp + cc_parse.readexprlist.ulistx]
    mov       %r8,	%rdi
    call      cc_lib.addlistunit
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jnz       L4757
L4759:
    call      cc_lex.lex
    jmp       L4756
L4757:
    mov       %rax,	[%rbp + cc_parse.readexprlist.ulist]
L4755:
#---------------
    add       %rsp,	56
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readmodulevar
cc_parse.readmodulevar:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
#---------------
    mov       %rcx,	[%rip+cc_decls.stmodule]
    mov       %rdx,	%r12
    mov       %r8,	1
    xor       %r9d,	%r9d
    call      cc_lib.checkdupl
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L4762
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	7
    jz        L4764
    movzx     %rax,	byte ptr[%rdi+109]
    lea       %r10,	[%rip+cc_tables.namenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rax,	[%rdi]
    lea       %rcx,	[%rip+L8613]
    mov       %rdx,	%rax
    mov       %r8,	%r10
    call      cc_support.serror_ss
L4764:
    movzx     %rax,	word ptr[%rdi+102]
    mov       %rsi,	%rax
    cmp       %rsi,	%r13
    jz        L4766
    mov       %rcx,	%rsi
    mov       %rdx,	%r13
    call      cc_parse.comparemode
    test      %rax,	%rax
    jnz       L4768
#cc_parse.readmodulevar.redef:
L4769:
    mov       %rax,	[%rdi]
    lea       %rcx,	[%rip+L8614]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L4768:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rsi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jnz       L4772
L4771:
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8]
    test      %rax,	%rax
    jnz       L4774
    mov       [%rdi+102],	%r13w
    jmp       L4773
L4774:
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%r13
    mov       %rax,	[%rax + %r10*8]
    test      %rax,	%rax
    jz        L4775
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8]
    lea       %r10,	[%rip+cc_decls.ttlength]
    mov       %r11,	%r13
    mov       %r10,	[%r10 + %r11*8]
    cmp       %rax,	%r10
    jnz       L4769
L4775:
L4773:
L4772:
L4770:
L4766:
    mov       %r12,	%rdi
    movzx     %rax,	byte ptr[%r12+110]
    mov       %rbx,	%rax
    cmp       %rbx,	2
    jnz       L4779
    test      %r14,	%r14
    jz        L4778
L4779:
    cmp       %rbx,	4
    jnz       L4780
    cmp       %r14,	1
    jz        L4778
L4780:
    cmp       %rbx,	3
    jnz       L4777
    cmp       %r14,	1
    jnz       L4777
L4778:
    jmp       L4776
L4777:
    cmp       %rbx,	3
    jnz       L4781
    test      %r14,	%r14
    jnz       L4781
    mov       %rbx,	4
L4781:
L4776:
    jmp       L4761
L4762:
    mov       %rcx,	[%rip+cc_decls.stmodule]
    mov       %rdx,	%r12
    mov       %r8,	7
    call      cc_lib.createdupldef
    mov       %r12,	%rax
    mov       [%r12+102],	%r13w
    mov       %rax,	%r14
    cmp       %rax,	1
    jz        L4783
    cmp       %rax,	4
    jz        L4784
    jmp       L4785
L4783:
    mov       %rbx,	2
    jmp       L4782
L4784:
    mov       %rbx,	3
    jmp       L4782
L4785:
    mov       %rbx,	4
L4782:
L4761:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	11
    jnz       L4787
    mov       %rax,	[%r12+72]
    test      %rax,	%rax
    jz        L4789
    mov       %rax,	[%r12]
    lea       %rcx,	[%rip+L8615]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L4789:
    cmp       %rbx,	3
    jnz       L4791
    mov       %rax,	[%r12]
    lea       %rcx,	[%rip+L8616]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L4791:
    call      cc_lex.lex
    movzx     %rax,	word ptr[%r12+102]
    mov       %rcx,	[%rip+cc_decls.stmodule]
    mov       %rdx,	%rax
    call      cc_parse.readinitexpr
    mov       [%r12+72],	%rax
L4787:
    mov       [%r12+110],	%bl
    mov       %rax,	%r12
L4760:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readframevar
cc_parse.readframevar:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
#---------------
    mov       %rcx,	[%rip+cc_decls.currproc]
    mov       %rdx,	%r12
    mov       %r8,	1
    mov       %r9,	[%rip+cc_decls.currblockno]
    call      cc_lib.checkdupl_inproc
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L4794
    mov       %rax,	[%rdi]
    lea       %rcx,	[%rip+L8617]
    mov       %rdx,	%rax
    call      cc_support.serror_s
    mov       %r12,	%rdi
    movzx     %rax,	byte ptr[%r12+110]
    mov       %rbx,	%rax
    cmp       %rbx,	2
    jnz       L4798
    test      %r14,	%r14
    jz        L4797
L4798:
    cmp       %rbx,	4
    jnz       L4799
    cmp       %r14,	1
    jz        L4797
L4799:
    cmp       %rbx,	3
    jnz       L4796
    cmp       %r14,	1
    jnz       L4796
L4797:
    jmp       L4795
L4796:
    cmp       %rbx,	3
    jnz       L4800
    test      %r14,	%r14
    jnz       L4800
    mov       %rbx,	4
L4800:
L4795:
    jmp       L4793
L4794:
    mov       %rsi,	8
    mov       %rbx,	1
    mov       %rax,	%r14
    cmp       %rax,	1
    jz        L4802
    cmp       %rax,	4
    jz        L4803
    jmp       L4804
L4802:
    mov       %rsi,	7
    jmp       L4801
L4803:
    mov       %rbx,	3
    mov       %rsi,	7
L4804:
L4801:
    mov       %rcx,	[%rip+cc_decls.currproc]
    mov       %rdx,	%r12
    mov       %r8,	%rsi
    call      cc_lib.createdupldef
    mov       %r12,	%rax
    mov       [%r12+102],	%r13w
    mov       %ax,	[%rip+cc_decls.currblockno]
    mov       [%r12+96],	%ax
    mov       %eax,	1
    lea       %r10,	[%rip+cc_decls.blockcounts]
    mov       %r11,	[%rip+cc_decls.currblockno]
    mov       [%r10 + %r11*4],	%eax
L4793:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	11
    jnz       L4806
    mov       %rax,	[%r12+72]
    test      %rax,	%rax
    jz        L4808
    mov       %rax,	[%r12]
    lea       %rcx,	[%rip+L8618]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L4808:
    cmp       %rbx,	3
    jnz       L4810
    mov       %rax,	[%r12]
    lea       %rcx,	[%rip+L8619]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L4810:
    call      cc_lex.lex
    movzx     %rax,	word ptr[%r12+102]
    mov       %rcx,	[%rip+cc_decls.currproc]
    mov       %rdx,	%rax
    call      cc_parse.readinitexpr
    mov       [%r12+72],	%rax
L4806:
    mov       [%r12+110],	%bl
    mov       %rax,	%r12
L4792:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readtype
cc_parse.readtype:
#?>>
    .set cc_parse.readtype.modtype, -256
    .set cc_parse.readtype.modvalue, -512
    .set cc_parse.readtype.nmodifiers, -520
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	560
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
    mov       %r14,	%r9
#---------------
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readtype.nmodifiers],	%rax
    xor       %eax,	%eax
    mov       [%r14],	%rax
    sub       %rsp,	8
    lea       %rax,	[%rbp + cc_parse.readtype.nmodifiers]
    push      %rax
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    lea       %r8,	[%rbp + cc_parse.readtype.modtype]
    lea       %r9,	[%rbp + cc_parse.readtype.modvalue]
    sub       %rsp,	32
    call      cc_parse.readnamedtype
    add       %rsp,	48
    mov       %rbx,	[%rbp + cc_parse.readtype.nmodifiers]
    cmp       %rbx,	1
    jl        L4814
L4812:
    mov       %rax,	[%rbp + %rbx*8 + cc_parse.readtype.modtype-8]
    cmp       %rax,	65
    jz        L4816
    cmp       %rax,	82
    jz        L4817
    cmp       %rax,	67
    jz        L4818
    cmp       %rax,	70
    jz        L4819
    jmp       L4820
L4816:
    mov       %rax,	[%rbp + %rbx*8 + cc_parse.readtype.modvalue-8]
    mov       %rcx,	%r13
    mov       %rdx,	%rax
    call      cc_lib.createarraymode
    mov       %r13,	%rax
    jmp       L4815
L4817:
    mov       %rcx,	%r13
    call      cc_lib.createrefmode
    mov       %r13,	%rax
    jmp       L4815
L4818:
    mov       %rcx,	%r13
    call      cc_lib.createconstmode
    mov       %r13,	%rax
    jmp       L4815
L4819:
    mov       %rdi,	[%rbp + %rbx*8 + cc_parse.readtype.modvalue-8]
    cmp       %rbx,	1
    jnz       L4822
    mov       [%r14],	%rdi
    jmp       L4821
L4822:
    mov       %rcx,	%r13
    mov       %rdx,	%rdi
    call      cc_lib.createprocmode
    mov       %r13,	%rax
L4821:
L4820:
L4815:
    dec       %rbx
    cmp       %rbx,	1
    jge       L4812
L4814:
    mov       %rax,	%r13
L4811:
#---------------
    add       %rsp,	560
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readnamedtype
cc_parse.readnamedtype:
#?>>
    .set cc_parse.readnamedtype.modvalue, 88
    .set cc_parse.readnamedtype.nmodifiers, 96
    .set cc_parse.readnamedtype.fconst, -256
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	288
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
    mov       [%rbp+88],	%r9
#---------------
    xor       %eax,	%eax
    mov       [%r13],	%rax
    xor       %rbx,	%rbx
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	89
    jnz       L4825
    call      cc_lex.lex
L4825:
    jmp       L4827
L4826:
    inc       %rbx
    xor       %eax,	%eax
    mov       [%rbp + %rbx*8 + cc_parse.readnamedtype.fconst-8],	%rax
    call      cc_lex.lex
    jmp       L4830
L4829:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+22]
    cmp       %rax,	1
    jz        L4833
    cmp       %rax,	2
    jz        L4834
    cmp       %rax,	3
    jz        L4834
    jmp       L4835
L4833:
    mov       %rax,	1
    mov       [%rbp + %rbx*8 + cc_parse.readnamedtype.fconst-8],	%rax
    jmp       L4832
L4834:
    jmp       L4832
L4835:
    lea       %rcx,	[%rip+L8620]
    call      cc_support.serror
L4832:
    call      cc_lex.lex
L4830:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	87
    jz        L4829
L4827:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	25
    jz        L4826
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L4837
    cmp       %rax,	13
    jz        L4838
    jmp       L4839
L4837:
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       [%r13],	%rax
    call      cc_lex.lex
    jmp       L4836
L4838:
    call      cc_lex.lex
    sub       %rsp,	8
    push      qword ptr[%rbp + cc_parse.readnamedtype.nmodifiers]
    mov       %rcx,	%r12
    mov       %rdx,	%r13
    mov       %r8,	%r14
    mov       %r9,	[%rbp + cc_parse.readnamedtype.modvalue]
    sub       %rsp,	32
    call      cc_parse.readnamedtype
    add       %rsp,	48
    mov       %rcx,	14
    call      cc_lib.skipsymbol
L4839:
L4836:
L4840:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	15
    jz        L4842
    cmp       %rax,	13
    jz        L4843
    jmp       L4844
L4842:
    call      cc_lex.lex
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	16
    jnz       L4846
    xor       %rdi,	%rdi
    jmp       L4845
L4846:
    call      cc_parse.readassignexpr
    mov       %rsi,	%rax
    movsxd    %rax,	dword ptr[%rsi+40]
    cmp       %rax,	1
    jnz       L4848
    mov       %rdi,	[%rsi]
    jmp       L4847
L4848:
    lea       %rcx,	[%rip+L8621]
    call      cc_support.serror
L4847:
    mov       %rcx,	16
    call      cc_lib.checksymbol
    test      %rdi,	%rdi
    jnz       L4850
    lea       %rcx,	[%rip+L8622]
    call      cc_support.serror
L4850:
L4845:
    cmp       %rdi,	0
    jge       L4852
    lea       %rcx,	[%rip+L8623]
    call      cc_support.terror
L4852:
    call      cc_lex.lex
    mov       %rax,	[%rbp + cc_parse.readnamedtype.nmodifiers]
    inc       qword ptr[%rax]
    mov       %rax,	[%rax]
    mov       %r10,	65
    mov       [%r14 + %rax*8-8],	%r10
    mov       %rax,	[%rbp + cc_parse.readnamedtype.nmodifiers]
    mov       %rax,	[%rax]
    mov       %r10,	%rdi
    mov       %r11,	[%rbp + cc_parse.readnamedtype.modvalue]
    mov       [%r11 + %rax*8-8],	%r10
    jmp       L4840
L4843:
    call      cc_lex.lex
    mov       %rax,	[%rbp + cc_parse.readnamedtype.nmodifiers]
    inc       qword ptr[%rax]
    mov       %rax,	[%rax]
    mov       %r10,	70
    mov       [%r14 + %rax*8-8],	%r10
    mov       %rcx,	%r12
    call      cc_parse.readparams
    mov       %r10,	[%rbp + cc_parse.readnamedtype.nmodifiers]
    mov       %r10,	[%r10]
    mov       %r11,	[%rbp + cc_parse.readnamedtype.modvalue]
    mov       [%r11 + %r10*8-8],	%rax
    jmp       L4840
L4844:
    jmp       L4841
L4841:
    jmp       L4854
L4853:
    mov       %rax,	[%rbp + %rbx*8 + cc_parse.readnamedtype.fconst-8]
    test      %rax,	%rax
    jz        L4857
    mov       %rax,	[%rbp + cc_parse.readnamedtype.nmodifiers]
    inc       qword ptr[%rax]
    mov       %rax,	[%rax]
    mov       %r10,	67
    mov       [%r14 + %rax*8-8],	%r10
L4857:
    mov       %rax,	[%rbp + cc_parse.readnamedtype.nmodifiers]
    inc       qword ptr[%rax]
    mov       %rax,	[%rax]
    mov       %r10,	82
    mov       [%r14 + %rax*8-8],	%r10
    dec       %rbx
L4854:
    test      %rbx,	%rbx
    jnz       L4853
#---------------
    add       %rsp,	288
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readconstintexpr
cc_parse.readconstintexpr:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    call      cc_parse.readassignexpr
    mov       %rdi,	%rax
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	1
    jnz       L4861
L4860:
    mov       %rax,	[%rdi]
    jmp       L4858
L4861:
    movsxd    %rax,	dword ptr[%rdi+40]
    lea       %r10,	[%rip+cc_tables.jtagnames]
    mov       %r10,	[%r10 + %rax*8]
    lea       %rcx,	[%rip+L8624]
    mov       %rdx,	%r10
    call      cc_support.serror_s
L4859:
    xor       %eax,	%eax
L4858:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readinitexpr
cc_parse.readinitexpr:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	1
    call      cc_parse.readinitexpr2
    mov       %rdi,	%rax
    mov       %rax,	%rdi
L4862:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readinitexpr2
cc_parse.readinitexpr2:
#?>>
    .set cc_parse.readinitexpr2.m, 80
    .set cc_parse.readinitexpr2.istop, 88
    .set cc_parse.readinitexpr2.ulist, -8
    .set cc_parse.readinitexpr2.ulistx, -16
    .set cc_parse.readinitexpr2.d, -24
    .set cc_parse.readinitexpr2.e, -32
    .set cc_parse.readinitexpr2.braces, -40
    .set cc_parse.readinitexpr2.newstr, -48
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	88
    mov       %r15,	%rcx
    mov       [%rbp+80],	%rdx
    mov       [%rbp+88],	%r8
#---------------
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	[%rbp + cc_parse.readinitexpr2.m]
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rbx,	%rax
    xor       %r14,	%r14
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	17
    jnz       L4865
    call      cc_lex.lex
    xor       %r14,	%r14
    mov       %rax,	%rbx
    cmp       %rax,	17
    jz        L4867
    cmp       %rax,	18
    jz        L4868
    cmp       %rax,	19
    jz        L4868
    jmp       L4869
L4867:
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	[%rbp + cc_parse.readinitexpr2.m]
    mov       %r13,	[%rax + %r10*8]
    mov       %rax,	[%rbp + cc_parse.readinitexpr2.istop]
    test      %rax,	%rax
    jnz       L4871
    test      %r13,	%r13
    jnz       L4871
    lea       %rcx,	[%rip+L8625]
    call      cc_support.terror
L4871:
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	[%rbp + cc_parse.readinitexpr2.m]
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rsi,	%rax
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rsi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	1
    jnz       L4873
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	63
    jnz       L4873
    mov       %rax,	1
    mov       [%rbp + cc_parse.readinitexpr2.braces],	%rax
    jmp       L4874
L4873:
    jmp       L4866
L4868:
    lea       %rax,	[%rip+cc_decls.ttnamedef]
    mov       %r10,	[%rbp + cc_parse.readinitexpr2.m]
    mov       %rax,	[%rax + %r10*8]
    mov       [%rbp + cc_parse.readinitexpr2.d],	%rax
    mov       %rax,	[%rbp + cc_parse.readinitexpr2.d]
    mov       %rax,	[%rax+16]
    mov       [%rbp + cc_parse.readinitexpr2.e],	%rax
    mov       %rax,	[%rbp + cc_parse.readinitexpr2.e]
    test      %rax,	%rax
    jnz       L4876
    lea       %rcx,	[%rip+L8626]
    call      cc_support.terror
L4876:
    mov       %rax,	[%rbp + cc_parse.readinitexpr2.e]
    movzx     %rax,	word ptr[%rax+102]
    mov       %rsi,	%rax
    jmp       L4866
L4869:
    call      cc_parse.readassignexpr
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	[%rbp + cc_parse.readinitexpr2.m]
    call      cc_parse.coercemode
    mov       %rdi,	%rax
    mov       %rcx,	18
    call      cc_lib.skipsymbol
    mov       %rax,	%rdi
    jmp       L4863
L4866:
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readinitexpr2.ulistx],	%rax
    mov       [%rbp + cc_parse.readinitexpr2.ulist],	%rax
L4877:
    mov       %rcx,	%r15
    mov       %rdx,	%rsi
    xor       %r8d,	%r8d
    call      cc_parse.readinitexpr2
    mov       %rdi,	%rax
    inc       %r14
    mov       %rax,	%rbx
    cmp       %rax,	17
    jz        L4880
    cmp       %rax,	18
    jz        L4881
    cmp       %rax,	19
    jz        L4882
    jmp       L4883
L4880:
    test      %r13,	%r13
    jz        L4885
    cmp       %r14,	%r13
    jle       L4885
    lea       %rcx,	[%rip+L8627]
    call      cc_support.terror
L4885:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rsi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jnz       L4887
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%rsi
    movsx     %rax,	word ptr[%rax + %r10*2]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    cmp       %r10,	1
    jnz       L4887
    movsxd    %rax,	dword ptr[%rdi+52]
    cmp       %rax,	[%rip+cc_decls.trefchar]
    jz        L4886
L4887:
    mov       %rcx,	%rdi
    mov       %rdx,	%rsi
    call      cc_parse.coercemode
    mov       %rdi,	%rax
L4886:
    jmp       L4879
L4881:
    mov       %rax,	[%rbp + cc_parse.readinitexpr2.e]
    movzx     %rax,	word ptr[%rax+102]
    mov       %r12,	%rax
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%r12
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jnz       L4889
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%r12
    movsx     %rax,	word ptr[%rax + %r10*2]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    cmp       %r10,	6
    jnz       L4889
    movsxd    %rax,	dword ptr[%rdi+52]
    cmp       %rax,	[%rip+cc_decls.trefchar]
    jz        L4888
L4889:
    mov       %rcx,	%rdi
    mov       %rdx,	%r12
    call      cc_parse.coercemode
    mov       %rdi,	%rax
L4888:
    mov       %rax,	[%rbp + cc_parse.readinitexpr2.e]
    mov       %rax,	[%rax+32]
    mov       [%rbp + cc_parse.readinitexpr2.e],	%rax
    mov       %rax,	[%rbp + cc_parse.readinitexpr2.e]
    test      %rax,	%rax
    jnz       L4891
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jnz       L4893
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	18
    jz        L4893
    lea       %rcx,	[%rip+L8628]
    call      cc_support.terror
L4893:
    jmp       L4890
L4891:
    mov       %rax,	[%rbp + cc_parse.readinitexpr2.e]
    movzx     %rax,	word ptr[%rax+102]
    mov       %rsi,	%rax
L4890:
    jmp       L4879
L4882:
    mov       %rcx,	%rdi
    mov       %rdx,	%rsi
    call      cc_parse.coercemode
    mov       %rdi,	%rax
    mov       %rax,	%rdi
    mov       [%rbp + cc_parse.readinitexpr2.ulistx],	%rax
    mov       [%rbp + cc_parse.readinitexpr2.ulist],	%rax
    jmp       L4894
L4883:
L4879:
    lea       %rcx,	[%rbp + cc_parse.readinitexpr2.ulist]
    lea       %rdx,	[%rbp + cc_parse.readinitexpr2.ulistx]
    mov       %r8,	%rdi
    call      cc_lib.addlistunit
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jnz       L4878
L4896:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	18
    jnz       L4898
    call      cc_lex.lex
    jmp       L4878
L4898:
    call      cc_lex.lex
    jmp       L4877
L4878:
    cmp       %rbx,	17
    jnz       L4900
    test      %r13,	%r13
    jnz       L4900
    mov       %rax,	%r14
    lea       %r10,	[%rip+cc_decls.ttlength]
    mov       %r11,	[%rbp + cc_parse.readinitexpr2.m]
    mov       [%r10 + %r11*8],	%rax
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8]
    mov       %r10,	%r14
    imul      %r10,	%rax
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r11,	[%rbp + cc_parse.readinitexpr2.m]
    mov       [%rax + %r11*8],	%r10
L4900:
#cc_parse.readinitexpr2.donestruct:
L4894:
    mov       %rcx,	18
    call      cc_lib.skipsymbol
    mov       %rcx,	28
    mov       %rdx,	[%rbp + cc_parse.readinitexpr2.ulist]
    call      cc_lib.createunit1
    mov       %rdi,	%rax
    mov       [%rdi+48],	%r14d
    mov       %eax,	[%rbp + cc_parse.readinitexpr2.m]
    mov       [%rdi+52],	%eax
    jmp       L4864
L4865:
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readinitexpr2.braces],	%rax
    cmp       %rbx,	17
    jnz       L4903
L4902:
#cc_parse.readinitexpr2.doarraystring:
L4874:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	63
    jz        L4905
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	64
    jz        L4905
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	[%rbp + cc_parse.readinitexpr2.m]
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	1
    jz        L4905
    lea       %rcx,	[%rip+L8629]
    call      cc_support.terror
L4905:
    call      cc_parse.readassignexpr
    mov       %rdi,	%rax
    movsxd    %rax,	dword ptr[%rdi+52]
    cmp       %rax,	[%rip+cc_decls.trefchar]
    jz        L4907
    cmp       %rax,	[%rip+cc_decls.trefwchar]
    jz        L4908
    jmp       L4909
L4907:
    jmp       L4906
L4908:
    jmp       L4906
L4909:
    lea       %rcx,	[%rip+L8630]
    call      cc_support.terror
L4906:
    mov       %eax,	[%rbp + cc_parse.readinitexpr2.m]
    mov       [%rdi+52],	%eax
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	[%rbp + cc_parse.readinitexpr2.m]
    mov       %rax,	[%rax + %r10*8]
    mov       %r13,	%rax
    test      %rax,	%rax
    jnz       L4911
    movsxd    %rax,	dword ptr[%rdi+48]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r11,	[%rbp + cc_parse.readinitexpr2.m]
    mov       [%r10 + %r11*8],	%rax
    lea       %r10,	[%rip+cc_decls.ttlength]
    mov       %r11,	[%rbp + cc_parse.readinitexpr2.m]
    mov       [%r10 + %r11*8],	%rax
    jmp       L4910
L4911:
    movsxd    %rax,	dword ptr[%rdi+48]
    cmp       %rax,	%r13
    jle       L4913
    movsxd    %rax,	dword ptr[%rdi+48]
    lea       %r10,	[%r13+1]
    cmp       %rax,	%r10
    jz        L4913
    lea       %rcx,	[%rip+L8631]
    call      cc_support.terror
L4913:
    movsxd    %rax,	dword ptr[%rdi+48]
    cmp       %rax,	%r13
    jge       L4915
    mov       %rcx,	%r13
    call      mlib.pcm_allocz
    mov       [%rbp + cc_parse.readinitexpr2.newstr],	%rax
    movsxd    %rax,	dword ptr[%rdi+48]
    mov       %r10,	[%rdi]
    mov       %rcx,	[%rbp + cc_parse.readinitexpr2.newstr]
    mov       %rdx,	%r10
    mov       %r8,	%rax
    call      memcpy
    mov       %rax,	[%rbp + cc_parse.readinitexpr2.newstr]
    mov       [%rdi],	%rax
L4915:
    mov       [%rdi+48],	%r13d
L4910:
    mov       %rax,	[%rbp + cc_parse.readinitexpr2.braces]
    test      %rax,	%rax
    jz        L4917
    mov       %rcx,	18
    call      cc_lib.skipsymbol
L4917:
    mov       %rax,	%rdi
    jmp       L4863
L4903:
L4901:
    call      cc_parse.readassignexpr
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	[%rbp + cc_parse.readinitexpr2.m]
    call      cc_parse.coercemode
    mov       %rdi,	%rax
L4864:
    mov       %rax,	%rdi
L4863:
#---------------
    add       %rsp,	88
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.pushblock
cc_parse.pushblock:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
    mov       %rax,	[%rip+cc_decls.blocklevel]
    cmp       %rax,	100
    jl        L4920
    lea       %rcx,	[%rip+L8632]
    call      cc_support.serror
L4920:
    mov       %rax,	[%rip+cc_decls.nextblockno]
    cmp       %rax,	2100
    jl        L4922
    lea       %rcx,	[%rip+L8633]
    call      cc_support.serror
L4922:
    inc       qword ptr[%rip+cc_decls.blocklevel]
    inc       qword ptr[%rip+cc_decls.nextblockno]
    mov       %rdi,	[%rip+cc_decls.currblockno]
    mov       %rbx,	[%rip+cc_decls.blocklevel]
    jmp       L4924
L4923:
    dec       %rbx
    lea       %rax,	[%rip+cc_decls.blockstack]
    mov       %r10,	%rbx
    movsxd    %rax,	dword ptr[%rax + %r10*4]
    mov       %rdi,	%rax
L4924:
    test      %rbx,	%rbx
    jz        L4926
    lea       %rax,	[%rip+cc_decls.blockstack]
    mov       %r10,	%rbx
    movsxd    %rax,	dword ptr[%rax + %r10*4]
    lea       %r10,	[%rip+cc_decls.blockcounts]
    movsxd    %r10,	dword ptr[%r10 + %rax*4]
    test      %r10,	%r10
    jz        L4923
L4926:
    mov       %eax,	%edi
    lea       %r10,	[%rip+cc_decls.blockowner]
    mov       %r11,	[%rip+cc_decls.nextblockno]
    mov       [%r10 + %r11*4],	%eax
    mov       %eax,	[%rip+cc_decls.nextblockno]
    lea       %r10,	[%rip+cc_decls.blockstack]
    mov       %r11,	[%rip+cc_decls.blocklevel]
    mov       [%r10 + %r11*4],	%eax
    mov       [%rip+cc_decls.currblockno],	%rax
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_decls.blockcounts]
    mov       %r11,	[%rip+cc_decls.currblockno]
    mov       [%r10 + %r11*4],	%eax
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.popblock
cc_parse.popblock:
#?>>
#?]]
#---------------
    dec       qword ptr[%rip+cc_decls.blocklevel]
    mov       %rax,	[%rip+cc_decls.blocklevel]
    lea       %r10,	[%rip+cc_decls.blockstack]
    movsxd    %r10,	dword ptr[%r10 + %rax*4]
    mov       [%rip+cc_decls.currblockno],	%r10
#---------------
    ret       
# End 
# Proc cc_parse.readcompoundstmt
cc_parse.readcompoundstmt:
#?>>
    .set cc_parse.readcompoundstmt.ulist, -8
    .set cc_parse.readcompoundstmt.ulistx, -16
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	56
    mov       %rsi,	%rcx
#---------------
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readcompoundstmt.ulistx],	%rax
    mov       [%rbp + cc_parse.readcompoundstmt.ulist],	%rax
    call      cc_lex.lex
    call      cc_parse.pushblock
    test      %rsi,	%rsi
    jz        L4930
    mov       %eax,	1
    lea       %r10,	[%rip+cc_decls.blockcounts]
    mov       [%r10+4],	%eax
L4930:
    jmp       L4932
L4931:
    call      cc_parse.readstatement
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L4935
    jmp       L4932
L4935:
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	7
    jnz       L4937
L4938:
    mov       %rbx,	[%rdi+8]
    mov       %rax,	[%rdi]
    mov       %rax,	[%rax+72]
    test      %rax,	%rax
    jz        L4942
    mov       %rax,	[%rdi]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	7
    jz        L4942
    mov       %eax,	8
    mov       [%rdi+40],	%eax
    xor       %eax,	%eax
    mov       [%rdi+8],	%rax
    lea       %rcx,	[%rbp + cc_parse.readcompoundstmt.ulist]
    lea       %rdx,	[%rbp + cc_parse.readcompoundstmt.ulistx]
    mov       %r8,	%rdi
    call      cc_lib.addlistunit
L4942:
    mov       %rdi,	%rbx
    test      %rdi,	%rdi
    jnz       L4938
    jmp       L4936
L4937:
    lea       %rcx,	[%rbp + cc_parse.readcompoundstmt.ulist]
    lea       %rdx,	[%rbp + cc_parse.readcompoundstmt.ulistx]
    mov       %r8,	%rdi
    call      cc_lib.addlistunit
L4936:
L4932:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	18
    jnz       L4931
    call      cc_lex.lex
    call      cc_parse.popblock
    mov       %rcx,	6
    mov       %rdx,	[%rbp + cc_parse.readcompoundstmt.ulist]
    xor       %r8d,	%r8d
    mov       %r9,	[%rbp + cc_parse.readcompoundstmt.ulistx]
    call      cc_lib.createunit3
L4928:
#---------------
    add       %rsp,	56
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readblock
cc_parse.readblock:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    call      cc_parse.readstatement
    jmp       L4943
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	72
    jnz       L4945
    test      %rdi,	%rdi
    jz        L4945
    call      cc_parse.readstatement
    jmp       L4943
L4945:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	17
    jz        L4947
    lea       %rcx,	[%rip+L8634]
    call      cc_support.serror
L4947:
    xor       %ecx,	%ecx
    call      cc_parse.readcompoundstmt
L4943:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readstatement
cc_parse.readstatement:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    sub       %rax,	9
    cmp       %rax,	83
    jae       L4951
    lea       %r10,	[%rip+L4950]
    jmp       [%r10 + %rax*8]
    .data
L4950:
    .quad     L4974
    .quad     L4951
    .quad     L4951
    .quad     L4951
    .quad     L4951
    .quad     L4951
    .quad     L4951
    .quad     L4951
    .quad     L4958
    .quad     L4951
    .quad     L4951
    .quad     L4951
    .quad     L4951
    .quad     L4951
    .quad     L4951
    .quad     L4951
    .quad     L4951
    .quad     L4951
    .quad     L4951
    .quad     L4951
    .quad     L4951
    .quad     L4951
    .quad     L4951
    .quad     L4951
    .quad     L4951
    .quad     L4951
    .quad     L4951
    .quad     L4951
    .quad     L4951
    .quad     L4951
    .quad     L4951
    .quad     L4951
    .quad     L4951
    .quad     L4951
    .quad     L4951
    .quad     L4951
    .quad     L4951
    .quad     L4951
    .quad     L4951
    .quad     L4951
    .quad     L4951
    .quad     L4951
    .quad     L4951
    .quad     L4951
    .quad     L4951
    .quad     L4951
    .quad     L4951
    .quad     L4951
    .quad     L4951
    .quad     L4951
    .quad     L4951
    .quad     L4951
    .quad     L4951
    .quad     L4951
    .quad     L4951
    .quad     L4951
    .quad     L4951
    .quad     L4951
    .quad     L4975
    .quad     L4951
    .quad     L4951
    .quad     L4951
    .quad     L4991
    .quad     L4952
    .quad     L4951
    .quad     L4972
    .quad     L4973
    .quad     L4953
    .quad     L4954
    .quad     L4955
    .quad     L4956
    .quad     L4960
    .quad     L4965
    .quad     L4959
    .quad     L4957
    .quad     L4991
    .quad     L4991
    .quad     L4991
    .quad     L4991
    .quad     L4991
    .quad     L4991
    .quad     L4951
    .quad     L4991
    .text
L4952:
    call      cc_parse.readifstmt
    jmp       L4948
L4953:
    call      cc_parse.readforstmt
    jmp       L4948
L4954:
    call      cc_parse.readwhilestmt
    jmp       L4948
L4955:
    call      cc_parse.readdostmt
    jmp       L4948
L4956:
    call      cc_parse.readreturnstmt
    jmp       L4948
L4957:
    call      cc_parse.readswitchstmt
    jmp       L4948
L4958:
    xor       %ecx,	%ecx
    call      cc_parse.readcompoundstmt
    jmp       L4948
L4959:
    call      cc_parse.readgotostmt
    jmp       L4948
L4960:
    mov       %rax,	[%rip+cc_parse.loopindex]
    test      %rax,	%rax
    jz        L4962
    lea       %rax,	[%rip+cc_parse.looptypestack]
    mov       %r10,	[%rip+cc_parse.loopindex]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	76
    jnz       L4964
    mov       %rcx,	20
    call      cc_lib.createunit0
    mov       %rdi,	%rax
    call      cc_lex.lex
    jmp       L4963
L4964:
    mov       %rcx,	23
    call      cc_lib.createunit0
    mov       %rdi,	%rax
    call      cc_lex.lex
L4963:
    jmp       L4961
L4962:
    lea       %rcx,	[%rip+L8635]
    call      cc_support.serror
L4961:
    jmp       L4949
L4965:
    mov       %rsi,	[%rip+cc_parse.loopindex]
    jmp       L4967
L4966:
    dec       %rsi
L4967:
    test      %rsi,	%rsi
    jz        L4969
    lea       %rax,	[%rip+cc_parse.looptypestack]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	76
    jnz       L4966
L4969:
    test      %rsi,	%rsi
    jnz       L4971
    lea       %rcx,	[%rip+L8636]
    call      cc_support.serror
L4971:
    mov       %rcx,	21
    call      cc_lib.createunit0
    mov       %rdi,	%rax
    call      cc_lex.lex
    jmp       L4949
L4972:
    call      cc_parse.readcaselabel
    jmp       L4948
L4973:
    call      cc_lex.lex
    mov       %rcx,	10
    call      cc_lib.skipsymbol
    call      cc_parse.readstatement
    mov       %rcx,	19
    mov       %rdx,	%rax
    call      cc_lib.createunit1
    jmp       L4948
L4974:
    call      cc_lex.lex
    xor       %eax,	%eax
    jmp       L4948
L4975:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	10
    jnz       L4977
    mov       %rcx,	17
    xor       %edx,	%edx
    call      cc_lib.createunit1
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       %rcx,	[%rip+cc_decls.currproc]
    mov       %rdx,	%rax
    mov       %r8,	3
    xor       %r9d,	%r9d
    call      cc_lib.resolvename
    mov       %rbx,	%rax
    test      %rbx,	%rbx
    jz        L4979
    movsxd    %rax,	dword ptr[%rbx+88]
    cmp       %rax,	-1
    jnz       L4981
    call      msys.m$print_startcon
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8637]
    call      cc_support.terror
L4981:
    jmp       L4978
L4979:
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       %rcx,	[%rip+cc_decls.currproc]
    mov       %rdx,	%rax
    mov       %r8,	14
    call      cc_lib.createdupldef
    mov       %rbx,	%rax
    xor       %eax,	%eax
    mov       [%rbx+102],	%ax
L4978:
    mov       %eax,	4294967295
    mov       [%rbx+88],	%eax
    mov       [%rdi],	%rbx
    call      cc_lex.lex
    call      cc_lex.lex
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	18
    jz        L4982
L4983:
    call      cc_parse.istypestarter
    test      %rax,	%rax
    jnz       L4985
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	86
    jnz       L4984
L4985:
    jmp       L4982
L4984:
    call      cc_parse.readstatement
    mov       [%rdi+16],	%rax
L4982:
    mov       %rax,	%rdi
    jmp       L4948
L4977:
    xor       %eax,	%eax
    mov       [%rip+cc_parse.ist_symptr],	%rax
    mov       %rcx,	[%rip+cc_decls.currproc]
    call      cc_parse.isusertype
    cmp       %rax,	20
    jnz       L4988
L4987:
    mov       %rax,	[%rip+cc_parse.ist_symptr]
    test      %rax,	%rax
    jz        L4990
    mov       %rax,	[%rip+cc_parse.ist_symptr]
    lea       %r10,	[%rip+cc_decls.lx]
    mov       [%r10],	%rax
L4990:
    call      cc_parse.readexpression
    mov       %rdi,	%rax
L4976:
    jmp       L4949
L4991:
#cc_parse.readstatement.doreaddecl:
L4988:
    call      cc_parse.readlocaldecl
    jmp       L4948
L4951:
    call      cc_parse.readexpression
    mov       %rdi,	%rax
L4949:
    mov       %rcx,	9
    call      cc_lib.skipsymbol
    mov       %rax,	%rdi
L4948:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readifstmt
cc_parse.readifstmt:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
#---------------
    call      cc_lex.lex
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %eax,	[%rax+16]
    mov       %r13,	%rax
    call      cc_parse.readcond
    mov       %rbx,	%rax
    mov       %rcx,	%rbx
    call      cc_parse.coercecond
    xor       %ecx,	%ecx
    call      cc_parse.readblock
    mov       %rsi,	%rax
    xor       %r12,	%r12
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	73
    jnz       L4994
    call      cc_lex.lex
    mov       %rcx,	1
    call      cc_parse.readblock
    mov       %r12,	%rax
L4994:
    mov       %rcx,	12
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    mov       %r9,	%r12
    call      cc_lib.createunit3
    mov       %rdi,	%rax
    mov       [%rdi+44],	%r13d
    mov       %rcx,	%rbx
    call      cc_parse.iscondtrue
    test      %rax,	%rax
    jz        L4996
    test      %rsi,	%rsi
    jnz       L4998
    mov       %rcx,	6
    call      cc_lib.createunit0
    mov       %rsi,	%rax
L4998:
    mov       %rcx,	%rdi
    mov       %rdx,	%rsi
    call      cc_parse.deleteunit
    jmp       L4995
L4996:
    mov       %rcx,	%rbx
    call      cc_parse.iscondfalse
    test      %rax,	%rax
    jz        L4999
    test      %r12,	%r12
    jnz       L5001
    mov       %rcx,	6
    call      cc_lib.createunit0
    mov       %r12,	%rax
L5001:
    mov       %rcx,	%rdi
    mov       %rdx,	%r12
    call      cc_parse.deleteunit
L4999:
L4995:
    mov       %rax,	%rdi
L4992:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.iscondtrue
cc_parse.iscondtrue:
#?>>
#?]]
#---------------
    movsxd    %rax,	dword ptr[%rcx+40]
    cmp       %rax,	1
    jnz       L5003
    mov       %rax,	[%rcx]
    test      %rax,	%rax
    jz        L5003
    mov       %rax,	1
    jmp       L5004
L5003:
    xor       %eax,	%eax
L5004:
L5002:
#---------------
    ret       
# End 
# Proc cc_parse.iscondfalse
cc_parse.iscondfalse:
#?>>
#?]]
#---------------
    movsxd    %rax,	dword ptr[%rcx+40]
    cmp       %rax,	1
    jnz       L5006
    mov       %rax,	[%rcx]
    test      %rax,	%rax
    jnz       L5006
    mov       %rax,	1
    jmp       L5007
L5006:
    xor       %eax,	%eax
L5007:
L5005:
#---------------
    ret       
# End 
# Proc cc_parse.deleteunit
cc_parse.deleteunit:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	16
#---------------
    mov       %rdi,	[%rcx+8]
    mov       %rax,	%rdx
    push      %rcx
    mov       %r11,	8
L8638:
    mov       %r10,	[%rax]
    mov       [%rcx],	%r10
    add       %rcx,	8
    add       %rax,	8
    dec       %r11
    jnz       L8638
    pop       %rcx
    mov       [%rcx+8],	%rdi
#---------------
    add       %rsp,	16
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readforstmt
cc_parse.readforstmt:
#?>>
    .set cc_parse.readforstmt.ulist, -8
    .set cc_parse.readforstmt.ulistx, -16
    .set cc_parse.readforstmt.linkage, -24
    .set cc_parse.readforstmt.m, -32
    .set cc_parse.readforstmt.mbase, -40
    .set cc_parse.readforstmt.pm, -48
    .set cc_parse.readforstmt.d, -56
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	96
#---------------
    call      cc_lex.lex
    mov       %rcx,	13
    call      cc_lib.skipsymbol
    xor       %r14,	%r14
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	9
    jz        L5011
    call      cc_parse.istypestarter
    test      %rax,	%rax
    jz        L5013
    mov       %r14,	1
    call      cc_parse.pushblock
    mov       %rcx,	[%rip+cc_decls.currproc]
    lea       %rdx,	[%rbp + cc_parse.readforstmt.linkage]
    call      cc_parse.readdeclspec
    mov       [%rbp + cc_parse.readforstmt.mbase],	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readforstmt.ulistx],	%rax
    mov       [%rbp + cc_parse.readforstmt.ulist],	%rax
L5014:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L5016
    cmp       %rax,	25
    jz        L5016
    cmp       %rax,	13
    jnz       L5017
L5016:
    mov       %rcx,	[%rip+cc_decls.currproc]
    lea       %rdx,	[%rbp + cc_parse.readforstmt.d]
    mov       %r8,	[%rbp + cc_parse.readforstmt.mbase]
    lea       %r9,	[%rbp + cc_parse.readforstmt.pm]
    call      cc_parse.readtype
    mov       [%rbp + cc_parse.readforstmt.m],	%rax
    mov       %rax,	[%rbp + cc_parse.readforstmt.d]
    test      %rax,	%rax
    jnz       L5019
    lea       %rcx,	[%rip+L8639]
    call      cc_support.serror
L5019:
    mov       %rax,	[%rbp + cc_parse.readforstmt.linkage]
    cmp       %rax,	5
    jz        L5022
    mov       %rax,	[%rbp + cc_parse.readforstmt.pm]
    test      %rax,	%rax
    jz        L5021
L5022:
    lea       %rcx,	[%rip+L8640]
    call      cc_support.serror
L5021:
    mov       %rcx,	[%rbp + cc_parse.readforstmt.d]
    mov       %rdx,	[%rbp + cc_parse.readforstmt.m]
    mov       %r8,	[%rbp + cc_parse.readforstmt.linkage]
    call      cc_parse.readframevar
    mov       [%rbp + cc_parse.readforstmt.d],	%rax
    mov       %rax,	[%rbp + cc_parse.readforstmt.d]
    mov       %rax,	[%rax+72]
    test      %rax,	%rax
    jz        L5024
    mov       %rcx,	8
    call      cc_lib.createunit0
    mov       %r13,	%rax
    mov       %rax,	[%rbp + cc_parse.readforstmt.d]
    mov       [%r13],	%rax
    lea       %rcx,	[%rbp + cc_parse.readforstmt.ulist]
    lea       %rdx,	[%rbp + cc_parse.readforstmt.ulistx]
    mov       %r8,	%r13
    call      cc_lib.addlistunit
L5024:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jnz       L5027
L5026:
    call      cc_lex.lex
    jmp       L5025
L5027:
    jmp       L5015
L5025:
    jmp       L5014
L5017:
    lea       %rcx,	[%rip+L8641]
    call      cc_support.serror
    jmp       L5014
L5015:
    mov       %rcx,	6
    mov       %rdx,	[%rbp + cc_parse.readforstmt.ulist]
    xor       %r8d,	%r8d
    mov       %r9,	[%rbp + cc_parse.readforstmt.ulistx]
    call      cc_lib.createunit3
    mov       %rdi,	%rax
    jmp       L5012
L5013:
    call      cc_parse.readexpression
    mov       %rdi,	%rax
L5012:
    jmp       L5010
L5011:
    mov       %rcx,	2
    call      cc_lib.createunit0
    mov       %rdi,	%rax
L5010:
    mov       %rcx,	9
    call      cc_lib.skipsymbol
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	9
    jz        L5029
    call      cc_parse.readexpression
    mov       %rbx,	%rax
    mov       %rcx,	%rbx
    call      cc_parse.coercecond
    jmp       L5028
L5029:
    mov       %rcx,	2
    call      cc_lib.createunit0
    mov       %rbx,	%rax
L5028:
    mov       %rcx,	9
    call      cc_lib.skipsymbol
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	14
    jz        L5031
    call      cc_parse.readexprstmt
    mov       %rsi,	%rax
    jmp       L5030
L5031:
    xor       %rsi,	%rsi
L5030:
    mov       %rcx,	14
    call      cc_lib.skipsymbol
    mov       %rcx,	76
    call      cc_parse.pushloop
    xor       %ecx,	%ecx
    call      cc_parse.readblock
    mov       %r12,	%rax
    call      cc_parse.poploop
    test      %r14,	%r14
    jz        L5033
    call      cc_parse.popblock
L5033:
    mov       [%rdi+8],	%rbx
    mov       [%rbx+8],	%rsi
    mov       %rcx,	13
    mov       %rdx,	%rdi
    mov       %r8,	%r12
    call      cc_lib.createunit2
L5009:
#---------------
    add       %rsp,	96
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readwhilestmt
cc_parse.readwhilestmt:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
    call      cc_lex.lex
    call      cc_parse.readcond
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    call      cc_parse.coercecond
    mov       %rcx,	76
    call      cc_parse.pushloop
    xor       %ecx,	%ecx
    call      cc_parse.readblock
    mov       %rbx,	%rax
    call      cc_parse.poploop
    mov       %rcx,	14
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      cc_lib.createunit2
L5034:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readdostmt
cc_parse.readdostmt:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
    call      cc_lex.lex
    mov       %rcx,	76
    call      cc_parse.pushloop
    xor       %ecx,	%ecx
    call      cc_parse.readblock
    mov       %rdi,	%rax
    call      cc_parse.poploop
    mov       %rcx,	77
    call      cc_lib.skipsymbol
    call      cc_parse.readcond
    mov       %rbx,	%rax
    mov       %rcx,	%rbx
    call      cc_parse.coercecond
    mov       %rcx,	9
    call      cc_lib.skipsymbol
    mov       %rcx,	15
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      cc_lib.createunit2
L5035:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readreturnstmt
cc_parse.readreturnstmt:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    call      cc_lex.lex
    xor       %rdi,	%rdi
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	9
    jz        L5038
    mov       %rax,	[%rip+cc_decls.currproc]
    movzx     %rax,	word ptr[%rax+102]
    test      %rax,	%rax
    jnz       L5040
    lea       %rcx,	[%rip+L8642]
    call      cc_support.terror
L5040:
    call      cc_parse.readexpression
    mov       %rdi,	%rax
    mov       %rax,	[%rip+cc_decls.currproc]
    movzx     %rax,	word ptr[%rax+102]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      cc_parse.coercemode
    mov       %rdi,	%rax
    mov       %rcx,	9
    call      cc_lib.checksymbol
    jmp       L5037
L5038:
    mov       %rax,	[%rip+cc_decls.currproc]
    movzx     %rax,	word ptr[%rax+102]
    test      %rax,	%rax
    jz        L5041
    lea       %rcx,	[%rip+L8643]
    call      cc_support.terror
L5041:
L5037:
    call      cc_lex.lex
    mov       %rcx,	9
    mov       %rdx,	%rdi
    call      cc_lib.createunit1
L5036:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readgotostmt
cc_parse.readgotostmt:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
    call      cc_lex.lex
    mov       %rcx,	67
    call      cc_lib.checksymbol
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       %rcx,	[%rip+cc_decls.currproc]
    mov       %rdx,	%rax
    mov       %r8,	3
    xor       %r9d,	%r9d
    call      cc_lib.resolvename
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L5044
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       %rcx,	[%rip+cc_decls.currproc]
    mov       %rdx,	%rax
    mov       %r8,	14
    call      cc_lib.createdupldef
    mov       %rdi,	%rax
    xor       %eax,	%eax
    mov       [%rdi+102],	%ax
L5044:
    mov       %rcx,	16
    xor       %edx,	%edx
    call      cc_lib.createunit1
    mov       %rbx,	%rax
    mov       [%rbx],	%rdi
    call      cc_lex.lex
    mov       %rcx,	9
    call      cc_lib.skipsymbol
    mov       %rax,	%rbx
L5042:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readswitchstmt
cc_parse.readswitchstmt:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
    call      cc_lex.lex
    call      cc_parse.readcond
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	3
    call      cc_parse.coercemode
    mov       %rcx,	83
    call      cc_parse.pushloop
    xor       %ecx,	%ecx
    call      cc_parse.readblock
    mov       %rbx,	%rax
    mov       %rcx,	22
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      cc_lib.createunit2
    mov       %rsi,	%rax
    lea       %rax,	[%rip+cc_parse.casevaluestack]
    mov       %r10,	[%rip+cc_parse.loopindex]
    mov       %rax,	[%rax + %r10*8-8]
    mov       [%rsi],	%rax
    call      cc_parse.poploop
    mov       %rax,	%rsi
L5045:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readcaselabel
cc_parse.readcaselabel:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
    call      cc_lex.lex
    call      cc_parse.readconstintexpr
    mov       %rbx,	%rax
    mov       %rcx,	10
    call      cc_lib.skipsymbol
    call      cc_parse.readstatement
    mov       %rcx,	18
    mov       %rdx,	%rax
    call      cc_lib.createunit1
    mov       %rdi,	%rax
    mov       [%rdi],	%rbx
    mov       %rcx,	%rbx
    call      cc_parse.addcasevalue
    mov       %rax,	%rdi
L5046:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readexprstmt
cc_parse.readexprstmt:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    call      cc_parse.readexpression
L5047:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_parse.readcond
cc_parse.readcond:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rcx,	13
    call      cc_lib.skipsymbol
    call      cc_parse.readexpression
    mov       %rdi,	%rax
    mov       %rcx,	14
    call      cc_lib.skipsymbol
    mov       %rax,	%rdi
L5048:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_parse.isusertype
cc_parse.isusertype:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    mov       %r8,	1
    mov       %r9,	[%rip+cc_decls.currblockno]
    call      cc_lib.resolvename
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L5051
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	5
    jnz       L5053
    movzx     %rax,	word ptr[%rdi+102]
    jmp       L5049
L5053:
    mov       [%rip+cc_parse.ist_symptr],	%rdi
L5051:
    mov       %rax,	20
L5049:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readlocaldecl
cc_parse.readlocaldecl:
#?>>
    .set cc_parse.readlocaldecl.linkage, -8
    .set cc_parse.readlocaldecl.wasdef, -16
    .set cc_parse.readlocaldecl.d, -24
    .set cc_parse.readlocaldecl.ulist, -32
    .set cc_parse.readlocaldecl.ulistx, -40
    .set cc_parse.readlocaldecl.pm, -48
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	88
#---------------
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readlocaldecl.ulistx],	%rax
    mov       [%rbp + cc_parse.readlocaldecl.ulist],	%rax
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %r12,	%rax
    mov       %rcx,	[%rip+cc_decls.currproc]
    lea       %rdx,	[%rbp + cc_parse.readlocaldecl.linkage]
    call      cc_parse.readdeclspec
    mov       %rbx,	%rax
    xor       %rsi,	%rsi
L5055:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L5057
    cmp       %rax,	25
    jz        L5057
    cmp       %rax,	13
    jnz       L5058
L5057:
    inc       %rsi
    mov       %rcx,	[%rip+cc_decls.currproc]
    lea       %rdx,	[%rbp + cc_parse.readlocaldecl.d]
    mov       %r8,	%rbx
    lea       %r9,	[%rbp + cc_parse.readlocaldecl.pm]
    call      cc_parse.readtype
    mov       %rdi,	%rax
    mov       %rax,	[%rbp + cc_parse.readlocaldecl.d]
    test      %rax,	%rax
    jnz       L5060
    lea       %rcx,	[%rip+L8644]
    call      cc_support.serror
L5060:
    mov       %rax,	[%rbp + cc_parse.readlocaldecl.linkage]
    cmp       %rax,	5
    jnz       L5062
    mov       %rcx,	[%rip+cc_decls.currproc]
    mov       %rdx,	[%rbp + cc_parse.readlocaldecl.d]
    mov       %r8,	%rdi
    call      cc_parse.createtypedef
    mov       [%rbp + cc_parse.readlocaldecl.d],	%rax
    jmp       L5061
L5062:
    mov       %rax,	[%rbp + cc_parse.readlocaldecl.pm]
    test      %rax,	%rax
    jz        L5063
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	17
    jnz       L5065
    lea       %rcx,	[%rip+L8645]
    call      cc_support.serror
L5065:
    push      0
    lea       %rax,	[%rbp + cc_parse.readlocaldecl.wasdef]
    push      %rax
    mov       %rcx,	[%rbp + cc_parse.readlocaldecl.d]
    mov       %rdx,	%rdi
    mov       %r8,	[%rbp + cc_parse.readlocaldecl.linkage]
    mov       %r9,	[%rbp + cc_parse.readlocaldecl.pm]
    sub       %rsp,	32
    call      cc_parse.readfunction
    add       %rsp,	48
    mov       [%rbp + cc_parse.readlocaldecl.d],	%rax
    jmp       L5061
L5063:
    mov       %rcx,	[%rbp + cc_parse.readlocaldecl.d]
    mov       %rdx,	%rdi
    mov       %r8,	[%rbp + cc_parse.readlocaldecl.linkage]
    call      cc_parse.readframevar
    mov       [%rbp + cc_parse.readlocaldecl.d],	%rax
    mov       %rcx,	7
    call      cc_lib.createunit0
    mov       %r13,	%rax
    mov       %rax,	[%rbp + cc_parse.readlocaldecl.d]
    mov       [%r13],	%rax
    lea       %rcx,	[%rbp + cc_parse.readlocaldecl.ulist]
    lea       %rdx,	[%rbp + cc_parse.readlocaldecl.ulistx]
    mov       %r8,	%r13
    call      cc_lib.addlistunit
L5061:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jnz       L5068
L5067:
    call      cc_lex.lex
    jmp       L5066
L5068:
    mov       %rcx,	9
    call      cc_lib.skipsymbol
    jmp       L5056
L5066:
    jmp       L5055
L5058:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	12
    jz        L5070
    cmp       %rax,	18
    jz        L5070
    cmp       %rax,	19
    jz        L5070
    cmp       %rax,	3
    jz        L5071
    jmp       L5072
L5070:
    mov       %rcx,	9
    call      cc_lib.skipsymbol
    jmp       L5056
L5071:
    mov       %rcx,	9
    call      cc_lib.skipsymbol
    jmp       L5056
L5072:
    mov       %rcx,	%rdi
    call      cc_lib.typename
    lea       %rcx,	[%rip+L8646]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L5069:
    jmp       L5055
L5056:
    mov       %rax,	[%rbp + cc_parse.readlocaldecl.ulist]
L5054:
#---------------
    add       %rsp,	88
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createtypedef
cc_parse.createtypedef:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	1
    mov       %r9,	[%rip+cc_decls.currblockno]
    call      cc_lib.checkdupl
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L5075
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	5
    jz        L5077
    mov       %rax,	[%rdi]
    lea       %rcx,	[%rip+L8647]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L5077:
    movzx     %rax,	word ptr[%rdi+102]
    cmp       %rax,	%r12
    jz        L5079
    movzx     %rax,	word ptr[%rdi+102]
    mov       %rcx,	%rax
    mov       %rdx,	%r12
    call      cc_parse.comparemode
    test      %rax,	%rax
    jnz       L5081
    mov       %rax,	[%rdi]
    lea       %rcx,	[%rip+L8648]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L5081:
L5079:
    mov       %rax,	%rdi
    jmp       L5073
L5075:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	5
    call      cc_lib.createdupldef
    mov       %rdi,	%rax
    mov       [%rdi+102],	%r12w
    mov       %rax,	%rdi
    lea       %r10,	[%rip+cc_decls.tttypedef]
    mov       %r11,	%r12
    mov       [%r10 + %r11*8],	%rax
    mov       %ax,	[%rip+cc_decls.currblockno]
    mov       [%rdi+96],	%ax
    mov       %eax,	1
    lea       %r10,	[%rip+cc_decls.blockcounts]
    mov       %r11,	[%rip+cc_decls.currblockno]
    mov       [%r10 + %r11*4],	%eax
    mov       %rax,	%rdi
L5073:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readparams
cc_parse.readparams:
#?>>
    .set cc_parse.readparams.owner, 64
    .set cc_parse.readparams.ulist, -8
    .set cc_parse.readparams.ulistx, -16
    .set cc_parse.readparams.pm, -24
    .set cc_parse.readparams.lastbasetype, -32
    .set cc_parse.readparams.d, -40
    .set cc_parse.readparams.names, -48
    .set cc_parse.readparams.nonames, -56
    .set cc_parse.readparams.reported, -64
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	96
#---------------
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readparams.d],	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readparams.ulistx],	%rax
    mov       [%rbp + cc_parse.readparams.ulist],	%rax
    xor       %eax,	%eax
    mov       %r14,	%rax
    mov       %rsi,	%rax
    mov       %r12,	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readparams.lastbasetype],	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readparams.names],	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readparams.nonames],	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readparams.reported],	%rax
    jmp       L5084
L5083:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	21
    jnz       L5087
    mov       %r12,	1
    call      cc_lex.lex
    jmp       L5085
L5087:
    call      cc_parse.istypestarter
    test      %rax,	%rax
    jz        L5089
    sub       %rsp,	8
    lea       %rax,	[%rbp + cc_parse.readparams.lastbasetype]
    push      %rax
    lea       %rcx,	[%rbp + cc_parse.readparams.d]
    mov       %rdx,	1
    lea       %r8,	[%rbp + cc_parse.readparams.pm]
    xor       %r9d,	%r9d
    sub       %rsp,	32
    call      cc_parse.readcasttype
    add       %rsp,	48
    mov       %rbx,	%rax
    mov       %rax,	[%rbp + cc_parse.readparams.pm]
    test      %rax,	%rax
    jz        L5091
    mov       %rcx,	%rbx
    mov       %rdx,	[%rbp + cc_parse.readparams.pm]
    call      cc_lib.createprocmode
    mov       %rcx,	%rax
    call      cc_lib.createrefmode
    mov       %rbx,	%rax
L5091:
    jmp       L5088
L5089:
    mov       %rax,	[%rbp + cc_parse.readparams.lastbasetype]
    test      %rax,	%rax
    jnz       L5093
    lea       %rcx,	[%rip+L8649]
    call      cc_support.serror
L5093:
    sub       %rsp,	8
    push      0
    lea       %rcx,	[%rbp + cc_parse.readparams.d]
    mov       %rdx,	1
    lea       %r8,	[%rbp + cc_parse.readparams.pm]
    mov       %r9,	[%rbp + cc_parse.readparams.lastbasetype]
    sub       %rsp,	32
    call      cc_parse.readcasttype
    add       %rsp,	48
    mov       %rbx,	%rax
L5088:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jz        L5095
    cmp       %rax,	14
    jz        L5096
    jmp       L5097
L5095:
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rcx,	%rax
    call      cc_lib.createrefmode
    mov       %rbx,	%rax
    jmp       L5094
L5096:
    lea       %rax,	[%rip+cc_decls.ttparams]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      cc_lib.createprocmode
    mov       %rcx,	%rax
    call      cc_lib.createrefmode
    mov       %rbx,	%rax
L5097:
L5094:
    mov       %rcx,	24
    call      mlib.pcm_allocz
    mov       [%rbp + cc_parse.readparams.pm],	%rax
    mov       %rax,	[%rbp + cc_parse.readparams.d]
    mov       %r10,	[%rbp + cc_parse.readparams.pm]
    mov       [%r10],	%rax
    mov       %eax,	%ebx
    mov       %r10,	[%rbp + cc_parse.readparams.pm]
    mov       [%r10+16],	%eax
    inc       %rsi
    mov       %rax,	[%rbp + cc_parse.readparams.d]
    test      %rax,	%rax
    jz        L5099
    mov       %rax,	1
    mov       [%rbp + cc_parse.readparams.names],	%rax
    jmp       L5098
L5099:
    mov       %rax,	1
    mov       [%rbp + cc_parse.readparams.nonames],	%rax
L5098:
    mov       %rax,	[%rbp + cc_parse.readparams.names]
    test      %rax,	%rax
    jz        L5101
    mov       %rax,	[%rbp + cc_parse.readparams.nonames]
    test      %rax,	%rax
    jz        L5101
    mov       %rax,	[%rbp + cc_parse.readparams.reported]
    test      %rax,	%rax
    jnz       L5101
    mov       %rax,	1
    mov       [%rbp + cc_parse.readparams.reported],	%rax
L5101:
    mov       %rax,	[%rbp + cc_parse.readparams.d]
    test      %rax,	%rax
    jz        L5103
    inc       %r14
    mov       %rdi,	[%rbp + cc_parse.readparams.ulist]
    jmp       L5105
L5104:
    mov       %rax,	[%rdi]
    cmp       %rax,	[%rbp + cc_parse.readparams.d]
    jnz       L5108
    mov       %rax,	[%rbp + cc_parse.readparams.d]
    movzx     %rax,	byte ptr[%rax+109]
    lea       %r10,	[%rip+cc_tables.namenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rax,	[%rbp + cc_parse.readparams.d]
    mov       %rax,	[%rax]
    lea       %rcx,	[%rip+L8650]
    mov       %rdx,	%rax
    mov       %r8,	%r10
    call      cc_support.serror_ss
L5108:
    mov       %rdi,	[%rdi+8]
L5105:
    test      %rdi,	%rdi
    jnz       L5104
L5103:
    lea       %rcx,	[%rbp + cc_parse.readparams.ulist]
    lea       %rdx,	[%rbp + cc_parse.readparams.ulistx]
    mov       %r8,	[%rbp + cc_parse.readparams.pm]
    call      cc_lib.addlistparam
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jz        L5110
    cmp       %rax,	21
    jz        L5111
    cmp       %rax,	14
    jz        L5111
    jmp       L5112
L5110:
    call      cc_lex.lex
    jmp       L5109
L5111:
    jmp       L5109
L5112:
    lea       %rcx,	[%rip+L8651]
    call      cc_support.serror
L5109:
L5084:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	14
    jnz       L5083
L5085:
    xor       %r13,	%r13
    mov       %rcx,	14
    call      cc_lib.skipsymbol
    test      %r12,	%r12
    jz        L5114
    mov       %r13,	3
    jmp       L5113
L5114:
    test      %rsi,	%rsi
    jnz       L5115
    mov       %r13,	1
    jmp       L5113
L5115:
    cmp       %rsi,	1
    jnz       L5116
    test      %rbx,	%rbx
    jnz       L5116
    mov       %r13,	2
    xor       %rsi,	%rsi
    xor       %eax,	%eax
    mov       %r10,	[%rbp + cc_parse.readparams.ulist]
    mov       [%r10+16],	%eax
L5116:
L5113:
    mov       %rax,	[%rbp + cc_parse.readparams.ulist]
    test      %rax,	%rax
    jnz       L5118
    mov       %rcx,	24
    call      mlib.pcm_allocz
    mov       [%rbp + cc_parse.readparams.ulist],	%rax
L5118:
    mov       %ax,	%si
    mov       %r10,	[%rbp + cc_parse.readparams.ulist]
    mov       [%r10+20],	%ax
    mov       %ax,	%r13w
    mov       %r10,	[%rbp + cc_parse.readparams.ulist]
    mov       [%r10+22],	%ax
    mov       %rax,	[%rbp + cc_parse.readparams.ulist]
L5082:
#---------------
    add       %rsp,	96
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readcasttype
cc_parse.readcasttype:
#?>>
    .set cc_parse.readcasttype.mbase, 88
    .set cc_parse.readcasttype.linkage, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
    mov       %r13,	%r9
#---------------
    mov       %rax,	[%rip+cc_decls.currproc]
    test      %rax,	%rax
    jz        L5121
    mov       %rax,	[%rip+cc_decls.currproc]
    jmp       L5120
L5121:
    mov       %rax,	[%rip+cc_decls.stmodule]
L5120:
    mov       %rdi,	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readcasttype.linkage],	%rax
    xor       %eax,	%eax
    mov       [%rbx],	%rax
    test      %r13,	%r13
    jnz       L5123
    mov       %rcx,	%rdi
    lea       %rdx,	[%rbp + cc_parse.readcasttype.linkage]
    call      cc_parse.readdeclspec
    mov       %r13,	%rax
    mov       %rax,	[%rbp + cc_parse.readcasttype.mbase]
    test      %rax,	%rax
    jz        L5125
    mov       %rax,	%r13
    mov       %r10,	[%rbp + cc_parse.readcasttype.mbase]
    mov       [%r10],	%rax
L5125:
L5123:
    xor       %eax,	%eax
    mov       [%r12],	%rax
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L5127
    cmp       %rax,	25
    jz        L5127
    cmp       %rax,	13
    jz        L5127
    cmp       %rax,	15
    jnz       L5128
L5127:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	%r13
    mov       %r9,	%r12
    call      cc_parse.readtype
    mov       %r13,	%rax
    mov       %rax,	[%rbx]
    test      %rax,	%rax
    jz        L5130
    test      %rsi,	%rsi
    jnz       L5130
    mov       %rax,	[%rbx]
    mov       %rax,	[%rax]
    lea       %rcx,	[%rip+L8652]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L5130:
L5128:
L5126:
    mov       %rax,	%r13
L5119:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readfunction
cc_parse.readfunction:
#?>>
    .set cc_parse.readfunction.pm, 88
    .set cc_parse.readfunction.wasdef, 96
    .set cc_parse.readfunction.exported, 104
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	32
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
    mov       [%rbp+88],	%r9
#---------------
    mov       %rbx,	[%rip+cc_decls.stmodule]
    xor       %eax,	%eax
    mov       %r10,	[%rbp + cc_parse.readfunction.wasdef]
    mov       [%r10],	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	%r12
    mov       %r8,	1
    xor       %r9d,	%r9d
    call      cc_lib.checkdupl
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L5133
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	6
    jz        L5135
    mov       %rax,	[%r12]
    lea       %rcx,	[%rip+L8653]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L5135:
    mov       %r12,	%rdi
    movzx     %rax,	byte ptr[%r12+110]
    mov       %rsi,	%rax
    cmp       %rsi,	3
    jnz       L5137
    test      %r14,	%r14
    jnz       L5137
    mov       %rsi,	4
    jmp       L5136
L5137:
    cmp       %r14,	1
    jnz       L5138
    mov       %rsi,	2
L5138:
L5136:
    jmp       L5132
L5133:
    mov       %rcx,	%rbx
    mov       %rdx,	%r12
    mov       %r8,	6
    call      cc_lib.createdupldef
    mov       %r12,	%rax
    mov       [%r12+102],	%r13w
    mov       %rax,	%r14
    cmp       %rax,	1
    jz        L5140
    cmp       %rax,	4
    jz        L5141
    jmp       L5142
L5140:
    mov       %rsi,	2
    jmp       L5139
L5141:
    mov       %rsi,	3
    jmp       L5139
L5142:
    mov       %rsi,	4
L5139:
L5132:
    mov       %rax,	[%rbp + cc_parse.readfunction.pm]
    mov       [%r12+80],	%rax
    mov       [%r12+110],	%sil
    mov       %rax,	[%rbp + cc_parse.readfunction.exported]
    test      %rax,	%rax
    jz        L5144
    lea       %rax,	[%r12+108]
    or        byte ptr[%rax],	16
L5144:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	17
    jnz       L5146
    mov       %rax,	1
    mov       %r10,	[%rbp + cc_parse.readfunction.wasdef]
    mov       [%r10],	%rax
    mov       %rax,	[%r12+72]
    test      %rax,	%rax
    jz        L5148
    mov       %rax,	[%r12]
    lea       %rcx,	[%rip+L8654]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L5148:
    cmp       %rsi,	3
    jnz       L5150
    mov       %al,	4
    mov       [%r12+110],	%al
L5150:
    mov       %rcx,	%r12
    call      cc_parse.readfunctionbody
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	9
    jnz       L5152
    lea       %rcx,	[%rip+L8655]
    call      cc_support.serror
L5152:
L5146:
    mov       %rax,	%r12
L5131:
#---------------
    add       %rsp,	32
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readfunctionbody
cc_parse.readfunctionbody:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r14,	%rcx
#---------------
    mov       [%rip+cc_decls.currproc],	%r14
    xor       %eax,	%eax
    mov       [%rip+cc_decls.currblockno],	%rax
    mov       [%rip+cc_decls.nextblockno],	%rax
    xor       %r12,	%r12
    mov       %rax,	[%r14+80]
    mov       %rsi,	%rax
    movsx     %rax,	word ptr[%rsi+20]
    mov       %r13,	%rax
    cmp       %r13,	0
    jle       L5156
L5154:
    mov       %rax,	[%rsi]
    test      %rax,	%rax
    jz        L5157
L5158:
    mov       %rax,	[%rsi]
    mov       %rcx,	%r14
    mov       %rdx,	%rax
    mov       %r8,	9
    call      cc_lib.createdupldef
    mov       %rdi,	%rax
    mov       %rax,	[%rdi]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	36
    jnz       L5160
    mov       %al,	1
    mov       [%rdi+122],	%al
L5160:
    mov       %ax,	1
    mov       [%rdi+96],	%ax
    mov       %eax,	[%rsi+16]
    mov       [%rdi+102],	%ax
L5157:
    mov       %rsi,	[%rsi+8]
    mov       %r12,	1
    dec       %r13
    jnz       L5154
L5156:
    mov       %rcx,	%r12
    call      cc_parse.readcompoundstmt
    mov       %rbx,	%rax
    mov       %rax,	%rbx
    mov       %r10,	[%rip+cc_decls.currproc]
    mov       [%r10+72],	%rax
    xor       %eax,	%eax
    mov       [%rip+cc_decls.currproc],	%rax
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createnegop
cc_parse.createnegop:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%rsi+52]
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%rsi+40]
    cmp       %rax,	1
    jnz       L5163
    mov       %rax,	%rbx
    cmp       %rax,	3
    jz        L5165
    cmp       %rax,	4
    jz        L5165
    cmp       %rax,	9
    jz        L5165
    cmp       %rax,	8
    jz        L5166
    cmp       %rax,	11
    jz        L5167
    jmp       L5168
L5165:
    mov       %rax,	[%rsi]
    neg       %rax
    mov       [%rsi],	%rax
    mov       %rax,	%rsi
    jmp       L5161
L5166:
    mov       %rax,	[%rsi]
    neg       %rax
    mov       %r10,	4294967295
    and       %rax,	%r10
    mov       [%rsi],	%rax
    mov       %rax,	%rsi
    jmp       L5161
L5167:
    movq      %XMM4,	[%rsi]
    xorpd     %XMM4,	[%rip+L8656]
    movq      [%rsi],	%XMM4
    mov       %rax,	%rsi
    jmp       L5161
L5168:
L5164:
L5163:
#cc_parse.createnegop.retry:
L5169:
    cmp       %rbx,	1
    jl        L5171
    cmp       %rbx,	11
    jg        L5171
    mov       %rcx,	%rsi
    call      cc_parse.coercebasetype
    mov       %rcx,	58
    mov       %rdx,	%rsi
    call      cc_lib.createunit1
    mov       %rdi,	%rax
    jmp       L5170
L5171:
    lea       %rax,	[%rip+cc_decls.ttconst]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5172
    lea       %rax,	[%rip+cc_decls.ttconsttype]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rbx,	%rax
    jmp       L5169
L5172:
    call      msys.m$print_startcon
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8657]
    call      cc_support.terror
L5170:
    mov       %eax,	[%rsi+52]
    mov       [%rdi+52],	%eax
    mov       %rax,	%rdi
L5161:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createabsop
cc_parse.createabsop:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%rsi+52]
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%rsi+40]
    cmp       %rax,	1
    jnz       L5175
    mov       %rax,	%rbx
    cmp       %rax,	3
    jz        L5177
    cmp       %rax,	4
    jnz       L5178
L5177:
    mov       %rax,	[%rsi]
    cmp       %rax,	0
    jge       L8658
    neg       %rax
L8658:
    mov       [%rsi],	%rax
    mov       %rax,	%rsi
    jmp       L5173
L5178:
L5176:
L5175:
    mov       %rcx,	%rbx
    call      cc_lib.isintcc
    test      %rax,	%rax
    jz        L5180
    mov       %rcx,	%rsi
    call      cc_parse.coercebasetype
    mov       %rcx,	59
    mov       %rdx,	%rsi
    call      cc_lib.createunit1
    mov       %rdi,	%rax
    jmp       L5179
L5180:
    lea       %rcx,	[%rip+L8659]
    call      cc_support.terror
L5179:
    mov       %eax,	[%rsi+52]
    mov       [%rdi+52],	%eax
    mov       %rax,	%rdi
L5173:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createinotop
cc_parse.createinotop:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%rsi+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rbx,	%r10
    movsxd    %rax,	dword ptr[%rsi+40]
    cmp       %rax,	1
    jnz       L5183
    mov       %rax,	%rbx
    cmp       %rax,	3
    jz        L5185
    cmp       %rax,	4
    jz        L5185
    cmp       %rax,	8
    jz        L5185
    cmp       %rax,	9
    jnz       L5186
L5185:
    mov       %rax,	[%rsi]
    not       %rax
    mov       [%rsi],	%rax
    mov       %rax,	%rsi
    jmp       L5181
L5186:
L5184:
L5183:
    mov       %rcx,	%rbx
    call      cc_lib.isintcc
    test      %rax,	%rax
    jz        L5188
    mov       %rcx,	%rsi
    call      cc_parse.coercebasetype
    mov       %rcx,	60
    mov       %rdx,	%rsi
    call      cc_lib.createunit1
    mov       %rdi,	%rax
    jmp       L5187
L5188:
    call      msys.m$print_startcon
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8660]
    call      cc_support.terror
L5187:
    mov       %eax,	[%rsi+52]
    mov       [%rdi+52],	%eax
    mov       %rax,	%rdi
L5181:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createptrop
cc_parse.createptrop:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%r12+52]
    mov       %rbx,	%rax
    lea       %r10,	[%rip+cc_decls.ttisref]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jnz       L5191
    xor       %ecx,	%ecx
    mov       %rdx,	%r12
    xor       %r8d,	%r8d
    lea       %r9,	[%rip+L8661]
    call      cc_show.printunit
    lea       %rcx,	[%rip+L8662]
    call      cc_support.terror
L5191:
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rsi,	%rax
    movsxd    %rax,	dword ptr[%r12+40]
    cmp       %rax,	55
    jnz       L5194
L5193:
    mov       %rdi,	[%r12+16]
    movsxd    %rax,	dword ptr[%r12+52]
    lea       %r10,	[%rip+cc_decls.tttarget]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       [%rdi+52],	%r10d
    mov       %rcx,	%rdi
    call      cc_parse.fixmemopnd
    mov       %rax,	%rdi
    jmp       L5189
L5194:
L5192:
    mov       %rcx,	52
    mov       %rdx,	%r12
    call      cc_lib.createunit1
    mov       %rdi,	%rax
    mov       [%rdi+52],	%esi
    mov       %rcx,	%rdi
    call      cc_parse.arraytopointer
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    call      cc_parse.fixmemopnd
    mov       %rax,	%rdi
L5189:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createincrop
cc_parse.createincrop:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    movsxd    %rax,	dword ptr[%r12+52]
    mov       %rbx,	%rax
    mov       %rcx,	%r12
    mov       %rdx,	1
    call      cc_parse.checklvalue
    mov       %rcx,	%rbx
    call      cc_lib.isintcc
    test      %rax,	%rax
    jz        L5198
    cmp       %rbx,	5
    jnz       L5197
L5198:
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jnz       L5197
    lea       %rcx,	[%rip+L8663]
    call      cc_support.terror
L5197:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    call      cc_lib.createunit1
    mov       %rdi,	%rax
    mov       %eax,	[%r12+52]
    mov       [%rdi+52],	%eax
    mov       %rax,	%rdi
L5195:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createaddrofop
cc_parse.createaddrofop:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
    xor       %rsi,	%rsi
#cc_parse.createaddrofop.restartx:
L5200:
    movsxd    %rax,	dword ptr[%r12+52]
    mov       %rbx,	%rax
    mov       %ax,	[%r12+56]
    test      %ax,	%ax
    jz        L5202
    movsx     %rax,	word ptr[%r12+56]
    mov       %rbx,	%rax
L5202:
    movsxd    %rax,	dword ptr[%r12+40]
    cmp       %rax,	3
    jz        L5204
    cmp       %rax,	55
    jz        L5205
    cmp       %rax,	49
    jz        L5206
    cmp       %rax,	53
    jz        L5207
    cmp       %rax,	4
    jz        L5208
    cmp       %rax,	5
    jz        L5209
    jmp       L5210
L5204:
    mov       %rax,	[%r12]
    lea       %rax,	[%rax+108]
    or        byte ptr[%rax],	1
    mov       %eax,	[%r12+48]
    test      %eax,	%eax
    jz        L5212
    mov       %rax,	[%r12]
    movzx     %rax,	word ptr[%rax+102]
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%r12+48]
    mov       %rsi,	%rax
L5212:
    jmp       L5203
L5205:
    mov       %rax,	[%r12+16]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	3
    jnz       L5214
    mov       %rax,	[%r12+16]
    mov       %eax,	[%rax+48]
    test      %eax,	%eax
    jz        L5214
    mov       %rax,	[%r12+16]
    mov       %rax,	[%rax]
    movzx     %rax,	word ptr[%rax+102]
    mov       %rcx,	%rax
    call      cc_lib.createrefmode
    mov       [%r12+52],	%eax
    mov       %rax,	[%r12+16]
    mov       %eax,	[%rax+48]
    mov       [%r12+48],	%eax
    mov       %rax,	%r12
    jmp       L5199
L5214:
    jmp       L5203
L5206:
    mov       %rdi,	[%r12+16]
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	52
    jnz       L5216
    mov       %rax,	[%rdi+16]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5216
    movsxd    %rax,	dword ptr[%r12]
    mov       %r10,	[%rdi+16]
    mov       %r10,	[%r10]
    add       %rax,	%r10
    mov       %rcx,	%rax
    mov       %rdx,	3
    call      cc_lib.createconstunit
    mov       %r12,	%rax
    mov       %rax,	%r12
    jmp       L5199
L5216:
    jmp       L5217
L5207:
    mov       %eax,	[%r12+48]
    test      %eax,	%eax
    jz        L5219
    movsxd    %rax,	dword ptr[%r12+48]
    movsxd    %r10,	dword ptr[%r12+52]
    lea       %r11,	[%rip+cc_decls.tttarget]
    movsx     %r11,	word ptr[%r11 + %r10*2]
    mov       %rcx,	%r11
    mov       %rdx,	%rax
    call      cc_lib.createarraymode
    mov       %rcx,	%rax
    call      cc_lib.createrefmode
    mov       [%r12+52],	%eax
    mov       %rax,	%r12
    jmp       L5199
L5219:
    jmp       L5203
L5208:
    mov       %r12,	[%r12+16]
    jmp       L5200
L5209:
    mov       %rax,	%r12
    jmp       L5199
L5210:
#cc_parse.createaddrofop.cad1:
L5217:
    mov       %rcx,	%r12
    xor       %edx,	%edx
    call      cc_parse.checklvalue
L5203:
    mov       %rcx,	55
    mov       %rdx,	%r12
    call      cc_lib.createunit1
    mov       %r12,	%rax
    mov       %rcx,	%rbx
    call      cc_lib.createrefmode
    mov       [%r12+52],	%eax
    mov       [%r12+48],	%esi
    mov       %rax,	%r12
L5199:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createaddop
cc_parse.createaddop:
#?>>
    .set cc_parse.createaddop.x, 56
    .set cc_parse.createaddop.y, 64
    .set cc_parse.createaddop.elemsize, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       [%rbp+56],	%rcx
    mov       [%rbp+64],	%rdx
#---------------
    mov       %rcx,	[%rbp + cc_parse.createaddop.x]
    call      cc_parse.getmemmode
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rbx,	%r10
    mov       %rcx,	[%rbp + cc_parse.createaddop.y]
    call      cc_parse.getmemmode
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rsi,	%r10
    mov       %r13,	39
    lea       %rax,	[%rip+cc_tables.dominantmode]
    mov       %r10,	%rbx
    shl       %r10,	5
    lea       %rax,	[%rax + %r10]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %r12,	%rax
    test      %rax,	%rax
    jz        L5222
    mov       %rcx,	[%rbp + cc_parse.createaddop.x]
    mov       %rdx,	%r12
    call      cc_parse.coercemode
    mov       [%rbp + cc_parse.createaddop.x],	%rax
    mov       %rcx,	[%rbp + cc_parse.createaddop.y]
    mov       %rdx,	%r12
    call      cc_parse.coercemode
    mov       [%rbp + cc_parse.createaddop.y],	%rax
    jmp       L5221
L5222:
    cmp       %rbx,	13
    jnz       L5223
#cc_parse.createaddop.doaddref:
L5224:
    mov       %rax,	[%rbp + cc_parse.createaddop.x]
    movsxd    %rax,	dword ptr[%rax+52]
    mov       %r12,	%rax
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%r12
    movsx     %rax,	word ptr[%rax + %r10*2]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r10,	[%r10 + %rax*8]
    mov       [%rbp + cc_parse.createaddop.elemsize],	%r10
    mov       %rax,	[%rbp + cc_parse.createaddop.x]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5226
    mov       %rax,	[%rbp + cc_parse.createaddop.y]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5226
    mov       %rax,	[%rbp + cc_parse.createaddop.y]
    mov       %rax,	[%rax]
    mov       %r10,	[%rbp + cc_parse.createaddop.elemsize]
    imul      %rax,	%r10
    mov       %r10,	[%rbp + cc_parse.createaddop.x]
    add       [%r10],	%rax
    mov       %rax,	[%rbp + cc_parse.createaddop.x]
    jmp       L5220
L5226:
    mov       %rcx,	[%rbp + cc_parse.createaddop.y]
    mov       %rdx,	4
    call      cc_parse.coercemode
    mov       [%rbp + cc_parse.createaddop.y],	%rax
    mov       %rcx,	53
    mov       %rdx,	[%rbp + cc_parse.createaddop.x]
    mov       %r8,	[%rbp + cc_parse.createaddop.y]
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%r12d
    mov       %eax,	[%rbp + cc_parse.createaddop.elemsize]
    mov       [%rdi],	%eax
    mov       %rax,	%rdi
    jmp       L5220
L5223:
    cmp       %rsi,	13
    jnz       L5227
    mov       %rax,	[%rbp + cc_parse.createaddop.x]
    mov       %r10,	[%rbp + cc_parse.createaddop.y]
    mov       [%rbp + cc_parse.createaddop.y],	%rax
    mov       [%rbp + cc_parse.createaddop.x],	%r10
    jmp       L5224
    lea       %rcx,	[%rip+L8664]
    call      cc_support.terror
L5227:
L5221:
    mov       %rax,	[%rbp + cc_parse.createaddop.x]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5229
    mov       %rax,	[%rbp + cc_parse.createaddop.y]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5231
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + cc_parse.createaddop.x]
    mov       %r8,	[%rbp + cc_parse.createaddop.y]
    mov       %r9,	%r12
    call      cc_parse.eval_add
    jmp       L5220
L5231:
    mov       %rax,	[%rbp + cc_parse.createaddop.x]
    mov       %r10,	[%rbp + cc_parse.createaddop.y]
    mov       [%rbp + cc_parse.createaddop.y],	%rax
    mov       [%rbp + cc_parse.createaddop.x],	%r10
L5230:
    mov       %rax,	[%rbp + cc_parse.createaddop.y]
    mov       %rax,	[%rax]
    test      %rax,	%rax
    jnz       L5233
    mov       %rax,	[%rbp + cc_parse.createaddop.x]
    jmp       L5220
L5233:
L5229:
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + cc_parse.createaddop.x]
    mov       %r8,	[%rbp + cc_parse.createaddop.y]
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%r12d
    mov       %rax,	%rdi
L5220:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createsubop
cc_parse.createsubop:
#?>>
    .set cc_parse.createsubop.x, 56
    .set cc_parse.createsubop.y, 64
    .set cc_parse.createsubop.elemsize, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       [%rbp+56],	%rcx
    mov       [%rbp+64],	%rdx
#---------------
    mov       %rcx,	[%rbp + cc_parse.createsubop.x]
    call      cc_parse.getmemmode
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rbx,	%r10
    mov       %rcx,	[%rbp + cc_parse.createsubop.y]
    call      cc_parse.getmemmode
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rsi,	%r10
    mov       %r13,	40
    lea       %rax,	[%rip+cc_tables.dominantmode]
    mov       %r10,	%rbx
    shl       %r10,	5
    lea       %rax,	[%rax + %r10]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %r12,	%rax
    test      %rax,	%rax
    jz        L5236
    mov       %rcx,	[%rbp + cc_parse.createsubop.x]
    mov       %rdx,	%r12
    call      cc_parse.coercemode
    mov       [%rbp + cc_parse.createsubop.x],	%rax
    mov       %rcx,	[%rbp + cc_parse.createsubop.y]
    mov       %rdx,	%r12
    call      cc_parse.coercemode
    mov       [%rbp + cc_parse.createsubop.y],	%rax
    jmp       L5235
L5236:
    cmp       %rbx,	13
    jnz       L5237
    cmp       %rsi,	13
    jz        L5239
    mov       %rax,	[%rbp + cc_parse.createsubop.x]
    movsxd    %rax,	dword ptr[%rax+52]
    mov       %r12,	%rax
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%r12
    movsx     %rax,	word ptr[%rax + %r10*2]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r10,	[%r10 + %rax*8]
    mov       [%rbp + cc_parse.createsubop.elemsize],	%r10
    mov       %rcx,	[%rbp + cc_parse.createsubop.y]
    mov       %rdx,	4
    call      cc_parse.coercemode
    mov       [%rbp + cc_parse.createsubop.y],	%rax
    mov       %rcx,	54
    mov       %rdx,	[%rbp + cc_parse.createsubop.x]
    mov       %r8,	[%rbp + cc_parse.createsubop.y]
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%r12d
    mov       %eax,	[%rbp + cc_parse.createsubop.elemsize]
    mov       [%rdi],	%eax
    mov       %rax,	%rdi
    jmp       L5234
L5239:
    mov       %rax,	[%rbp + cc_parse.createsubop.x]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5241
    mov       %rax,	[%rbp + cc_parse.createsubop.y]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5241
    mov       %rax,	[%rbp + cc_parse.createsubop.y]
    mov       %rax,	[%rax]
    mov       %r10,	[%rbp + cc_parse.createsubop.x]
    movsxd    %r10,	dword ptr[%r10+52]
    lea       %r11,	[%rip+cc_decls.tttarget]
    movsx     %r11,	word ptr[%r11 + %r10*2]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r10,	[%r10 + %r11*8]
    cqo       
    idiv      %r10
    mov       %r10,	[%rbp + cc_parse.createsubop.x]
    sub       [%r10],	%rax
    mov       %eax,	3
    mov       %r10,	[%rbp + cc_parse.createsubop.x]
    mov       [%r10+52],	%eax
    mov       %rax,	[%rbp + cc_parse.createsubop.x]
    jmp       L5234
L5241:
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + cc_parse.createsubop.x]
    mov       %r8,	[%rbp + cc_parse.createsubop.y]
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       %eax,	4
    mov       [%rdi+52],	%eax
    mov       %rax,	[%rbp + cc_parse.createsubop.x]
    movsxd    %rax,	dword ptr[%rax+52]
    lea       %r10,	[%rip+cc_decls.tttarget]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rcx,	%rdi
    mov       %rdx,	%r10
    call      cc_parse.divunit
    mov       %rdi,	%rax
    mov       %eax,	4
    mov       [%rdi+52],	%eax
    mov       %rax,	%rdi
    jmp       L5234
L5240:
L5238:
    mov       %rax,	[%rbp + cc_parse.createsubop.x]
    movsxd    %rax,	dword ptr[%rax+52]
    lea       %r10,	[%rip+cc_decls.tttarget]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rcx,	[%rbp + cc_parse.createsubop.y]
    mov       %rdx,	%r10
    call      cc_parse.mulunit
    mov       [%rbp + cc_parse.createsubop.y],	%rax
    jmp       L5235
L5237:
    lea       %rcx,	[%rip+L8664]
    call      cc_support.terror
L5235:
    mov       %rax,	[%rbp + cc_parse.createsubop.x]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5243
    mov       %rax,	[%rbp + cc_parse.createsubop.y]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5243
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + cc_parse.createsubop.x]
    mov       %r8,	[%rbp + cc_parse.createsubop.y]
    mov       %r9,	%r12
    call      cc_parse.eval_sub
    jmp       L5234
L5243:
    mov       %rax,	[%rbp + cc_parse.createsubop.y]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5245
    mov       %rax,	[%rbp + cc_parse.createsubop.y]
    mov       %rax,	[%rax]
    test      %rax,	%rax
    jnz       L5245
L5245:
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + cc_parse.createsubop.x]
    mov       %r8,	[%rbp + cc_parse.createsubop.y]
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%r12d
    mov       %rax,	%rdi
L5234:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createmulop
cc_parse.createmulop:
#?>>
    .set cc_parse.createmulop.x, 56
    .set cc_parse.createmulop.y, 64
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       [%rbp+56],	%rcx
    mov       [%rbp+64],	%rdx
#---------------
    mov       %rcx,	[%rbp + cc_parse.createmulop.x]
    call      cc_parse.getmemmode
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rbx,	%r10
    mov       %rcx,	[%rbp + cc_parse.createmulop.y]
    call      cc_parse.getmemmode
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rsi,	%r10
    mov       %r13,	41
    lea       %rax,	[%rip+cc_tables.dominantmode]
    mov       %r10,	%rbx
    shl       %r10,	5
    lea       %rax,	[%rax + %r10]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %r12,	%rax
    test      %rax,	%rax
    jz        L5248
    mov       %rcx,	[%rbp + cc_parse.createmulop.x]
    mov       %rdx,	%r12
    call      cc_parse.coercemode
    mov       [%rbp + cc_parse.createmulop.x],	%rax
    mov       %rcx,	[%rbp + cc_parse.createmulop.y]
    mov       %rdx,	%r12
    call      cc_parse.coercemode
    mov       [%rbp + cc_parse.createmulop.y],	%rax
    jmp       L5247
L5248:
    lea       %rcx,	[%rip+L8665]
    call      cc_support.terror
L5247:
    mov       %rax,	[%rbp + cc_parse.createmulop.x]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5250
    mov       %rax,	[%rbp + cc_parse.createmulop.y]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5252
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + cc_parse.createmulop.x]
    mov       %r8,	[%rbp + cc_parse.createmulop.y]
    mov       %r9,	%r12
    call      cc_parse.eval_mul
    jmp       L5246
L5252:
    mov       %rax,	[%rbp + cc_parse.createmulop.x]
    mov       %r10,	[%rbp + cc_parse.createmulop.y]
    mov       [%rbp + cc_parse.createmulop.y],	%rax
    mov       [%rbp + cc_parse.createmulop.x],	%r10
L5251:
L5250:
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + cc_parse.createmulop.x]
    mov       %r8,	[%rbp + cc_parse.createmulop.y]
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%r12d
    mov       %rax,	%rdi
L5246:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createdivop
cc_parse.createdivop:
#?>>
    .set cc_parse.createdivop.x, 56
    .set cc_parse.createdivop.y, 64
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       [%rbp+56],	%rcx
    mov       [%rbp+64],	%rdx
#---------------
    mov       %rcx,	[%rbp + cc_parse.createdivop.x]
    call      cc_parse.getmemmode
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rbx,	%r10
    mov       %rcx,	[%rbp + cc_parse.createdivop.y]
    call      cc_parse.getmemmode
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rsi,	%r10
    mov       %r13,	42
    lea       %rax,	[%rip+cc_tables.dominantmode]
    mov       %r10,	%rbx
    shl       %r10,	5
    lea       %rax,	[%rax + %r10]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %r12,	%rax
    test      %rax,	%rax
    jz        L5255
    mov       %rcx,	[%rbp + cc_parse.createdivop.x]
    mov       %rdx,	%r12
    call      cc_parse.coercemode
    mov       [%rbp + cc_parse.createdivop.x],	%rax
    mov       %rcx,	[%rbp + cc_parse.createdivop.y]
    mov       %rdx,	%r12
    call      cc_parse.coercemode
    mov       [%rbp + cc_parse.createdivop.y],	%rax
    jmp       L5254
L5255:
    lea       %rcx,	[%rip+L8666]
    call      cc_support.terror
L5254:
    mov       %rax,	[%rbp + cc_parse.createdivop.x]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5257
    mov       %rax,	[%rbp + cc_parse.createdivop.y]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5257
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + cc_parse.createdivop.x]
    mov       %r8,	[%rbp + cc_parse.createdivop.y]
    mov       %r9,	%r12
    call      cc_parse.eval_div
    jmp       L5253
L5257:
    mov       %rax,	[%rbp + cc_parse.createdivop.y]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5258
    cmp       %r12,	11
    jnz       L5258
    mov       %r13,	41
    mov       %rax,	[%rbp + cc_parse.createdivop.y]
    movq      %XMM4,	[%rax]
    movq      %XMM5,	[%rip+L8667]
    divsd     %XMM5,	%XMM4
    mov       %rax,	[%rbp + cc_parse.createdivop.y]
    movq      [%rax],	%XMM5
L5258:
L5256:
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + cc_parse.createdivop.x]
    mov       %r8,	[%rbp + cc_parse.createdivop.y]
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%r12d
    mov       %rax,	%rdi
L5253:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createremop
cc_parse.createremop:
#?>>
    .set cc_parse.createremop.x, 56
    .set cc_parse.createremop.y, 64
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       [%rbp+56],	%rcx
    mov       [%rbp+64],	%rdx
#---------------
    mov       %rax,	[%rbp + cc_parse.createremop.x]
    movsxd    %rax,	dword ptr[%rax+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rbx,	%r10
    mov       %rax,	[%rbp + cc_parse.createremop.y]
    movsxd    %rax,	dword ptr[%rax+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rsi,	%r10
    mov       %r13,	43
    lea       %rax,	[%rip+cc_tables.dominantmode]
    mov       %r10,	%rbx
    shl       %r10,	5
    lea       %rax,	[%rax + %r10]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %r12,	%rax
    test      %rax,	%rax
    jz        L5261
    cmp       %r12,	11
    jz        L5264
    cmp       %r12,	10
    jnz       L5263
L5264:
    mov       %r12,	3
L5263:
    mov       %rcx,	[%rbp + cc_parse.createremop.x]
    mov       %rdx,	%r12
    call      cc_parse.coercemode
    mov       [%rbp + cc_parse.createremop.x],	%rax
    mov       %rcx,	[%rbp + cc_parse.createremop.y]
    mov       %rdx,	%r12
    call      cc_parse.coercemode
    mov       [%rbp + cc_parse.createremop.y],	%rax
    jmp       L5260
L5261:
    lea       %rcx,	[%rip+L8668]
    call      cc_support.terror
L5260:
    mov       %rax,	[%rbp + cc_parse.createremop.x]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5266
    mov       %rax,	[%rbp + cc_parse.createremop.y]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5266
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + cc_parse.createremop.x]
    mov       %r8,	[%rbp + cc_parse.createremop.y]
    mov       %r9,	%r12
    call      cc_parse.eval_rem
    jmp       L5259
L5266:
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + cc_parse.createremop.x]
    mov       %r8,	[%rbp + cc_parse.createremop.y]
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%r12d
    mov       %rax,	%rdi
L5259:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.insertunit
cc_parse.insertunit:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    xor       %ecx,	%ecx
    call      cc_lib.createunit0
    mov       %rdi,	%rax
    mov       %rax,	%rbx
    push      %rdi
    mov       %r11,	8
L8669:
    mov       %r10,	[%rax]
    mov       [%rdi],	%r10
    add       %rdi,	8
    add       %rax,	8
    dec       %r11
    jnz       L8669
    pop       %rdi
    mov       [%rbx+40],	%esi
    mov       [%rbx+16],	%rdi
    xor       %eax,	%eax
    mov       [%rbx+32],	%rax
    mov       [%rbx+24],	%rax
    mov       %eax,	[%rdi+44]
    mov       [%rbx+44],	%eax
    mov       %rax,	[%rdi+8]
    mov       [%rbx+8],	%rax
    xor       %eax,	%eax
    mov       [%rbx+56],	%ax
    xor       %eax,	%eax
    mov       [%rdi+8],	%rax
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.eval_add
cc_parse.eval_add:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
    mov       %r13,	%r9
#---------------
    mov       %rax,	%r13
    cmp       %rax,	3
    jz        L5270
    cmp       %rax,	4
    jz        L5270
    cmp       %rax,	8
    jz        L5270
    cmp       %rax,	9
    jz        L5270
    cmp       %rax,	11
    jz        L5271
    jmp       L5272
L5270:
    mov       %rax,	[%r12]
    mov       %r10,	%rsi
    add       [%r10],	%rax
    mov       %rax,	%rsi
    jmp       L5268
L5271:
    movq      %XMM4,	[%r12]
    mov       %rax,	%rsi
    movq      %XMM5,	[%rax]
    addsd     %XMM5,	%XMM4
    movq      [%rax],	%XMM5
    mov       %rax,	%rsi
    jmp       L5268
L5272:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%r13
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	13
    jnz       L5274
    mov       %rax,	[%r12]
    lea       %r10,	[%rip+cc_decls.tttarget]
    mov       %r11,	%r13
    movsx     %r10,	word ptr[%r10 + %r11*2]
    lea       %r11,	[%rip+cc_decls.ttsize]
    mov       %r11,	[%r11 + %r10*8]
    imul      %rax,	%r11
    mov       %r10,	%rsi
    add       [%r10],	%rax
    mov       %rax,	%rsi
    jmp       L5268
L5274:
L5269:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%r13d
    mov       %rax,	%rdi
L5268:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.eval_sub
cc_parse.eval_sub:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
    mov       %r13,	%r9
#---------------
    mov       %rax,	%r13
    cmp       %rax,	3
    jz        L5277
    cmp       %rax,	4
    jz        L5277
    cmp       %rax,	8
    jz        L5277
    cmp       %rax,	9
    jz        L5277
    cmp       %rax,	11
    jz        L5278
    jmp       L5279
L5277:
    mov       %rax,	[%r12]
    mov       %r10,	%rsi
    sub       [%r10],	%rax
    mov       %rax,	%rsi
    jmp       L5275
L5278:
    movq      %XMM4,	[%r12]
    mov       %rax,	%rsi
    movq      %XMM5,	[%rax]
    subsd     %XMM5,	%XMM4
    movq      [%rax],	%XMM5
    mov       %rax,	%rsi
    jmp       L5275
L5279:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%r13
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	13
    jnz       L5281
    movsxd    %rax,	dword ptr[%r12+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    cmp       %r10,	13
    jnz       L5283
    lea       %rcx,	[%rip+L8670]
    call      cc_support.terror
L5283:
    mov       %rax,	%rsi
    jmp       L5275
L5281:
L5276:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%r13d
    mov       %rax,	%rdi
L5275:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.eval_mul
cc_parse.eval_mul:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
    mov       %r13,	%r9
#---------------
    mov       %rax,	%r13
    cmp       %rax,	3
    jz        L5286
    cmp       %rax,	4
    jz        L5286
    cmp       %rax,	2
    jz        L5286
    cmp       %rax,	1
    jz        L5286
    cmp       %rax,	8
    jz        L5287
    cmp       %rax,	9
    jz        L5287
    cmp       %rax,	7
    jz        L5287
    cmp       %rax,	6
    jz        L5287
    cmp       %rax,	11
    jz        L5288
    jmp       L5289
L5286:
    mov       %rax,	[%r12]
    mov       %r11,	%rsi
    mov       %r10,	[%r11]
    imul      %r10,	%rax
    mov       [%r11],	%r10
    mov       %rax,	%rsi
    jmp       L5284
L5287:
    mov       %rax,	[%rsi]
    mov       %r10,	[%r12]
    imul      %rax,	%r10
    mov       [%rsi],	%rax
    mov       %rax,	%rsi
    jmp       L5284
L5288:
    movq      %XMM4,	[%r12]
    mov       %rax,	%rsi
    movq      %XMM5,	[%rax]
    mulsd     %XMM5,	%XMM4
    movq      [%rax],	%XMM5
    mov       %rax,	%rsi
    jmp       L5284
L5289:
L5285:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%r13d
    mov       %rax,	%rdi
L5284:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.eval_div
cc_parse.eval_div:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
    mov       %r13,	%r9
#---------------
    mov       %rax,	%r13
    cmp       %rax,	3
    jz        L5292
    cmp       %rax,	4
    jz        L5292
    cmp       %rax,	8
    jz        L5293
    cmp       %rax,	9
    jz        L5293
    cmp       %rax,	11
    jz        L5294
    jmp       L5295
L5292:
    mov       %rax,	[%r12]
    test      %rax,	%rax
    jnz       L5297
    lea       %rcx,	[%rip+L8671]
    call      cc_support.serror
L5297:
    mov       %rax,	[%rsi]
    mov       %r10,	[%r12]
    cqo       
    idiv      %r10
    mov       [%rsi],	%rax
    mov       %rax,	%rsi
    jmp       L5290
L5293:
    mov       %rax,	[%r12]
    test      %rax,	%rax
    jnz       L5299
    lea       %rcx,	[%rip+L8671]
    call      cc_support.serror
L5299:
    mov       %rax,	[%rsi]
    mov       %r10,	[%r12]
    xor       %edx,	%edx
    div       %r10
    mov       [%rsi],	%rax
    mov       %rax,	%rsi
    jmp       L5290
L5294:
    movq      %XMM4,	[%r12]
    mov       %rax,	%rsi
    movq      %XMM5,	[%rax]
    divsd     %XMM5,	%XMM4
    movq      [%rax],	%XMM5
    mov       %rax,	%rsi
    jmp       L5290
L5295:
L5291:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%r13d
    mov       %rax,	%rdi
L5290:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.eval_rem
cc_parse.eval_rem:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
    mov       %r13,	%r9
#---------------
    mov       %rax,	%r13
    cmp       %rax,	3
    jz        L5302
    cmp       %rax,	4
    jnz       L5303
L5302:
    mov       %rax,	[%r12]
    test      %rax,	%rax
    jnz       L5305
    lea       %rcx,	[%rip+L8672]
    call      cc_support.serror
L5305:
    mov       %rax,	[%rsi]
    mov       %r10,	[%r12]
    cqo       
    idiv      %r10
    xchg      %rax,	%rdx
    mov       [%rsi],	%rax
    mov       %rax,	%rsi
    jmp       L5300
L5303:
L5301:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%r13d
    mov       %rax,	%rdi
L5300:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.eval_convert
cc_parse.eval_convert:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	16
#---------------
    cmp       %r8,	1
    jnz       L5308
#cc_parse.eval_convert.dosoft:
L5309:
    mov       [%rcx+52],	%edx
    mov       %rax,	1
    jmp       L5306
L5308:
    movsxd    %rax,	dword ptr[%rcx+52]
    mov       %rdi,	%rax
    cmp       %rdi,	%rdx
    jnz       L5311
    mov       %rax,	1
    jmp       L5306
L5311:
    mov       %rax,	%rdi
    cmp       %rax,	3
    jz        L5313
    cmp       %rax,	2
    jz        L5313
    cmp       %rax,	1
    jz        L5313
    cmp       %rax,	4
    jz        L5313
    cmp       %rax,	8
    jz        L5314
    cmp       %rax,	6
    jz        L5314
    cmp       %rax,	7
    jz        L5314
    cmp       %rax,	9
    jz        L5314
    cmp       %rax,	11
    jz        L5315
    jmp       L5316
L5313:
    mov       %rax,	%rdx
    cmp       %rax,	11
    jz        L5318
    cmp       %rax,	10
    jz        L5318
    cmp       %rax,	9
    jz        L5319
    cmp       %rax,	4
    jz        L5319
    cmp       %rax,	8
    jz        L5319
    cmp       %rax,	3
    jz        L5319
    cmp       %rax,	2
    jz        L5319
    cmp       %rax,	1
    jz        L5319
    cmp       %rax,	6
    jz        L5319
    cmp       %rax,	7
    jz        L5319
    jmp       L5320
L5318:
    mov       %rax,	[%rcx]
    cvtsi2sd  %XMM4,	%rax
    movq      [%rcx],	%XMM4
    mov       [%rcx+52],	%edx
    mov       %rax,	1
    jmp       L5306
L5319:
#cc_parse.eval_convert.dotrunc:
L5321:
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rdx
    mov       %rax,	[%rax + %r10*8]
    cmp       %rax,	1
    jz        L5323
    cmp       %rax,	2
    jz        L5324
    cmp       %rax,	4
    jz        L5325
    jmp       L5326
L5323:
    mov       %rax,	%rcx
    mov       %r10,	255
    and       [%rax],	%r10
    lea       %rax,	[%rip+cc_tables.stdsigned]
    mov       %r10,	%rdx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5328
    mov       %rax,	[%rcx]
    movsx     %rax,	%al
    mov       [%rcx],	%rax
L5328:
    jmp       L5322
L5324:
    mov       %rax,	%rcx
    mov       %r10,	65535
    and       [%rax],	%r10
    lea       %rax,	[%rip+cc_tables.stdsigned]
    mov       %r10,	%rdx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5330
    mov       %rax,	[%rcx]
    movsx     %rax,	%ax
    mov       [%rcx],	%rax
L5330:
    jmp       L5322
L5325:
    mov       %rax,	[%rcx]
    mov       %r10,	4294967295
    and       %rax,	%r10
    mov       [%rcx],	%rax
    lea       %rax,	[%rip+cc_tables.stdsigned]
    mov       %r10,	%rdx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5332
    mov       %rax,	[%rcx]
    movsxd    %rax,	%eax
    mov       [%rcx],	%rax
L5332:
L5326:
L5322:
    jmp       L5309
L5320:
L5317:
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%rdx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5334
    mov       [%rcx+52],	%edx
    mov       %rax,	1
    jmp       L5306
L5334:
    jmp       L5312
L5314:
    mov       %rax,	%rdx
    cmp       %rax,	11
    jz        L5336
    cmp       %rax,	10
    jz        L5336
    cmp       %rax,	9
    jz        L5337
    cmp       %rax,	4
    jz        L5337
    cmp       %rax,	3
    jz        L5337
    cmp       %rax,	8
    jz        L5337
    cmp       %rax,	9
    jz        L5337
    cmp       %rax,	7
    jz        L5337
    cmp       %rax,	1
    jz        L5337
    cmp       %rax,	6
    jz        L5337
    cmp       %rax,	2
    jz        L5337
    jmp       L5338
L5336:
    xor       %eax,	%eax
    jmp       L5306
    mov       [%rcx+52],	%edx
    mov       %rax,	1
    jmp       L5306
L5337:
    jmp       L5321
L5338:
L5335:
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%rdx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5340
    mov       [%rcx+52],	%edx
    mov       %rax,	1
    jmp       L5306
L5340:
    jmp       L5312
L5315:
    mov       %rax,	%rdx
    cmp       %rax,	3
    jz        L5342
    cmp       %rax,	4
    jz        L5342
    cmp       %rax,	8
    jz        L5343
    cmp       %rax,	9
    jz        L5343
    cmp       %rax,	10
    jz        L5344
    jmp       L5345
L5342:
    movq      %XMM4,	[%rcx]
    cvttsd2si %rax,	%XMM4
    mov       [%rcx],	%rax
    mov       [%rcx+52],	%edx
    mov       %rax,	1
    jmp       L5306
L5343:
    movq      %XMM4,	[%rcx]
    cvttsd2si %rax,	%XMM4
    mov       [%rcx],	%rax
    mov       [%rcx+52],	%edx
    mov       %rax,	1
    jmp       L5306
L5344:
    mov       %eax,	10
    mov       [%rcx+52],	%eax
    mov       %rax,	1
    jmp       L5306
L5345:
L5341:
    jmp       L5312
L5316:
    movsxd    %rax,	dword ptr[%rcx+52]
    lea       %r10,	[%rip+cc_decls.ttisref]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L5347
    mov       %al,	[%rcx+61]
    test      %al,	%al
    jnz       L5349
    mov       %rax,	%rdx
    cmp       %rax,	3
    jz        L5351
    cmp       %rax,	4
    jz        L5351
    cmp       %rax,	8
    jz        L5351
    cmp       %rax,	9
    jnz       L5352
L5351:
    mov       [%rcx+52],	%edx
    mov       %rax,	1
    jmp       L5306
L5352:
L5350:
L5349:
L5347:
L5312:
    xor       %eax,	%eax
L5306:
#---------------
    add       %rsp,	16
    pop       %rdi
    ret       
# End 
# Proc cc_parse.coercecond
cc_parse.coercecond:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%rbx+52]
    mov       %rdi,	%rax
    cmp       %rax,	3
    jz        L5353
L5355:
#cc_parse.coercecond.retry:
L5356:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	10
    jz        L5358
    cmp       %rax,	11
    jz        L5358
    cmp       %rax,	13
    jnz       L5359
L5358:
    jmp       L5360
L5359:
    mov       %rcx,	%rdi
    call      cc_lib.isintcc
    test      %rax,	%rax
    jz        L5362
#cc_parse.coercecond.doint:
L5360:
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L5364
    mov       %rax,	[%rbx]
    test      %rax,	%rax
    jz        L5364
    mov       %rax,	1
    mov       [%rbx],	%rax
    jmp       L5363
L5364:
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L5365
    mov       %rax,	[%rbx]
    test      %rax,	%rax
    jnz       L5365
    xor       %eax,	%eax
    mov       [%rbx],	%rax
    jmp       L5363
L5365:
    mov       %rcx,	%rbx
    mov       %rdx,	27
    call      cc_parse.insertunit
L5363:
    jmp       L5361
L5362:
    lea       %rax,	[%rip+cc_decls.ttconst]
    mov       %r10,	%rdi
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5366
    lea       %rax,	[%rip+cc_decls.ttconsttype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rdi,	%rax
    jmp       L5356
L5366:
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      cc_lib.strmode
    lea       %rcx,	[%rip+L8673]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L5361:
L5357:
    mov       %eax,	3
    mov       [%rbx+52],	%eax
L5353:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.coercebasetype
cc_parse.coercebasetype:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%rbx+52]
    mov       %rdi,	%rax
    cmp       %rax,	1
    jl        L5369
    cmp       %rdi,	2
    jg        L5369
    mov       %rcx,	%rbx
    mov       %rdx,	3
    call      cc_parse.coercemode
    mov       %rbx,	%rax
    jmp       L5368
L5369:
    cmp       %rdi,	5
    jl        L5370
    cmp       %rdi,	7
    jg        L5370
    mov       %rcx,	%rbx
    mov       %rdx,	8
    call      cc_parse.coercemode
    mov       %rbx,	%rax
L5370:
L5368:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.checklvalue
cc_parse.checklvalue:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	3
    jz        L5373
    cmp       %rax,	52
    jz        L5374
    cmp       %rax,	5
    jz        L5375
    cmp       %rax,	4
    jz        L5376
    cmp       %rax,	49
    jz        L5377
    cmp       %rax,	1
    jz        L5378
    cmp       %rax,	56
    jz        L5379
    jmp       L5380
L5373:
    jmp       L5372
L5374:
    jmp       L5372
L5375:
    test      %rbx,	%rbx
    jz        L5382
    jmp       L5383
L5382:
    jmp       L5372
L5376:
    mov       %rax,	[%rdi+16]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	3
    jz        L5385
    cmp       %rax,	52
    jz        L5385
    cmp       %rax,	49
    jnz       L5386
L5385:
    mov       %rax,	[%rdi+16]
    push      %rdi
    mov       %r11,	8
L8674:
    mov       %r10,	[%rax]
    mov       [%rdi],	%r10
    add       %rdi,	8
    add       %rax,	8
    dec       %r11
    jnz       L8674
    pop       %rdi
    jmp       L5384
L5386:
    lea       %rcx,	[%rip+L8675]
    call      cc_support.terror
L5384:
    jmp       L5372
L5377:
    jmp       L5372
L5378:
    movsxd    %rax,	dword ptr[%rdi+52]
    lea       %r10,	[%rip+cc_decls.ttisref]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jnz       L5388
    jmp       L5383
L5388:
    jmp       L5372
L5379:
    test      %rbx,	%rbx
    jz        L5390
    jmp       L5383
L5390:
    jmp       L5372
L5380:
#cc_parse.checklvalue.notlv:
L5383:
    xor       %ecx,	%ecx
    mov       %rdx,	%rdi
    xor       %r8d,	%r8d
    lea       %r9,	[%rip+L8676]
    call      cc_show.printunit
    movsxd    %rax,	dword ptr[%rdi+40]
    lea       %r10,	[%rip+cc_tables.jtagnames]
    mov       %r10,	[%r10 + %rax*8]
    lea       %rcx,	[%rip+L8677]
    mov       %rdx,	%r10
    call      cc_support.terror_s
L5372:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createcall
cc_parse.createcall:
#?>>
    .set cc_parse.createcall.p, 64
    .set cc_parse.createcall.q, 72
    .set cc_parse.createcall.aparams, -8
    .set cc_parse.createcall.retmode, -16
    .set cc_parse.createcall.mproc, -24
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	64
    mov       [%rbp+64],	%rcx
    mov       [%rbp+72],	%rdx
#---------------
    xor       %rsi,	%rsi
    mov       %rax,	[%rbp + cc_parse.createcall.p]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	52
    jz        L5393
    cmp       %rax,	3
    jz        L5394
    cmp       %rax,	5
    jz        L5394
    cmp       %rax,	49
    jz        L5395
    cmp       %rax,	30
    jz        L5395
    cmp       %rax,	31
    jz        L5395
    cmp       %rax,	56
    jz        L5395
    cmp       %rax,	29
    jz        L5395
    jmp       L5396
L5393:
#cc_parse.createcall.doptr:
L5397:
    mov       %rax,	[%rbp + cc_parse.createcall.p]
    movsxd    %rax,	dword ptr[%rax+52]
    mov       [%rbp + cc_parse.createcall.mproc],	%rax
    jmp       L5399
L5398:
    mov       %rcx,	52
    mov       %rdx,	[%rbp + cc_parse.createcall.p]
    call      cc_lib.createunit1
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	[%rbp + cc_parse.createcall.mproc]
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       [%rbp + cc_parse.createcall.mproc],	%rax
    mov       %eax,	[%rbp + cc_parse.createcall.mproc]
    mov       [%rdi+52],	%eax
    mov       [%rbp + cc_parse.createcall.p],	%rdi
L5399:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	[%rbp + cc_parse.createcall.mproc]
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	13
    jz        L5398
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	[%rbp + cc_parse.createcall.mproc]
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	14
    jz        L5402
    mov       %rcx,	[%rbp + cc_parse.createcall.mproc]
    call      cc_lib.typename
    lea       %rcx,	[%rip+L8678]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L5402:
    lea       %rax,	[%rip+cc_decls.ttparams]
    mov       %r10,	[%rbp + cc_parse.createcall.mproc]
    mov       %r12,	[%rax + %r10*8]
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	[%rbp + cc_parse.createcall.mproc]
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       [%rbp + cc_parse.createcall.retmode],	%rax
    jmp       L5392
L5394:
    mov       %rax,	[%rbp + cc_parse.createcall.p]
    mov       %rsi,	[%rax]
    movzx     %rax,	byte ptr[%rsi+109]
    cmp       %rax,	6
    jnz       L5404
    mov       %r12,	[%rsi+80]
    movzx     %rax,	word ptr[%rsi+102]
    mov       [%rbp + cc_parse.createcall.retmode],	%rax
    jmp       L5403
L5404:
    jmp       L5397
L5403:
    jmp       L5392
L5395:
    mov       %rcx,	52
    mov       %rdx,	[%rbp + cc_parse.createcall.p]
    call      cc_lib.createunit1
    mov       %rdi,	%rax
    mov       %rax,	[%rbp + cc_parse.createcall.p]
    movsxd    %rax,	dword ptr[%rax+52]
    lea       %r10,	[%rip+cc_decls.tttarget]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       [%rdi+52],	%r10d
    mov       [%rbp + cc_parse.createcall.p],	%rdi
    jmp       L5397
L5396:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8679]
    call      msys.m$print_str_nf
    mov       %rax,	[%rbp + cc_parse.createcall.p]
    movsxd    %rax,	dword ptr[%rax+40]
    lea       %r10,	[%rip+cc_tables.jtagnames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    xor       %ecx,	%ecx
    mov       %rdx,	[%rbp + cc_parse.createcall.p]
    xor       %r8d,	%r8d
    lea       %r9,	[%rip+L8680]
    call      cc_show.printunit
    lea       %rcx,	[%rip+L8681]
    call      cc_support.serror
L5392:
    movsx     %rax,	word ptr[%r12+20]
    mov       %r14,	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.createcall.aparams],	%rax
    mov       %rbx,	[%rbp + cc_parse.createcall.q]
    jmp       L5406
L5405:
    inc       qword ptr[%rbp + cc_parse.createcall.aparams]
    mov       %rbx,	[%rbx+8]
L5406:
    test      %rbx,	%rbx
    jnz       L5405
    mov       %rax,	[%rbp + cc_parse.createcall.aparams]
    cmp       %rax,	%r14
    jge       L5409
    lea       %rcx,	[%rip+L8682]
    call      cc_support.terror
    jmp       L5408
L5409:
    mov       %rax,	[%rbp + cc_parse.createcall.aparams]
    cmp       %rax,	%r14
    jle       L5410
    movsx     %rax,	word ptr[%r12+22]
    cmp       %rax,	3
    jz        L5410
    movsx     %rax,	word ptr[%r12+22]
    cmp       %rax,	1
    jz        L5410
    movsx     %rax,	word ptr[%r12+22]
    cmp       %rax,	1
    jz        L5412
    call      msys.m$print_startcon
    mov       %rcx,	[%rbp + cc_parse.createcall.aparams]
    call      msys.m$print_i64_nf
    mov       %rcx,	%r14
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8683]
    call      cc_support.terror
L5412:
L5410:
L5408:
    mov       %rbx,	[%rbp + cc_parse.createcall.q]
    mov       %r13,	1
    mov       %rax,	[%rbp + cc_parse.createcall.aparams]
    cmp       %rax,	1
    jl        L5415
L5413:
    cmp       %r13,	%r14
    jg        L5417
    movsxd    %rax,	dword ptr[%r12+16]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      cc_parse.coercemode_inplace
    mov       %r12,	[%r12+8]
    jmp       L5416
L5417:
    movsxd    %rax,	dword ptr[%rbx+52]
    test      %rax,	%rax
    jnz       L5419
    lea       %rcx,	[%rip+L8684]
    call      cc_support.terror
L5419:
    mov       %rcx,	%rbx
    call      cc_parse.coercebasetype
L5416:
    mov       %rbx,	[%rbx+8]
    inc       %r13
    cmp       %r13,	[%rbp + cc_parse.createcall.aparams]
    jle       L5413
L5415:
    mov       %rcx,	30
    mov       %rdx,	[%rbp + cc_parse.createcall.p]
    mov       %r8,	[%rbp + cc_parse.createcall.q]
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       %eax,	[%rbp + cc_parse.createcall.retmode]
    mov       [%rdi+52],	%eax
    mov       %rcx,	%rdi
    call      cc_parse.fixmemopnd
    mov       %eax,	[%rbp + cc_parse.createcall.aparams]
    mov       [%rdi+48],	%eax
    mov       %rax,	%rdi
L5391:
#---------------
    add       %rsp,	64
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.arraytopointer
cc_parse.arraytopointer:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r14,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%r14+52]
    mov       %rsi,	%rax
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%rsi
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %r12,	%rax
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rsi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jnz       L5422
    mov       %rcx,	%r12
    call      cc_lib.createrefmode
    mov       %r13,	%rax
    movsxd    %rax,	dword ptr[%r14+40]
    cmp       %rax,	52
    jz        L5424
    cmp       %rax,	49
    jz        L5425
    jmp       L5426
L5424:
    mov       %r14,	[%r14+16]
    jmp       L5423
L5425:
    movsxd    %rax,	dword ptr[%r14]
    mov       %rbx,	%rax
    mov       %eax,	53
    mov       [%r14+40],	%eax
    mov       %eax,	1
    mov       [%r14],	%eax
    mov       %rax,	[%r14+16]
    mov       %rcx,	55
    mov       %rdx,	%rax
    call      cc_lib.createunit1
    mov       %rdi,	%rax
    mov       [%rdi+52],	%r13d
    mov       [%r14+16],	%rdi
    mov       %rcx,	%rbx
    mov       %rdx,	3
    call      cc_lib.createconstunit
    mov       [%r14+24],	%rax
    jmp       L5423
L5426:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8685]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    xor       %ecx,	%ecx
    mov       %rdx,	%r14
    xor       %r8d,	%r8d
    lea       %r9,	[%rip+L8686]
    call      cc_show.printunit
    lea       %rcx,	[%rip+L8687]
    call      cc_support.terror
L5423:
    mov       [%r14+52],	%r13d
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8]
    mov       [%r14+48],	%eax
L5422:
    mov       %rax,	%r14
L5420:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createindexop
cc_parse.createindexop:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      cc_parse.createaddop
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    call      cc_parse.createptrop
L5427:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readstructdecl
cc_parse.readstructdecl:
#?>>
    .set cc_parse.readstructdecl.owner, 64
    .set cc_parse.readstructdecl.d, -8
    .set cc_parse.readstructdecl.ulist, -16
    .set cc_parse.readstructdecl.ulistx, -24
    .set cc_parse.readstructdecl.linkage, -32
    .set cc_parse.readstructdecl.offset, -40
    .set cc_parse.readstructdecl.recsize, -48
    .set cc_parse.readstructdecl.maxsize, -56
    .set cc_parse.readstructdecl.maxalignment, -64
    .set cc_parse.readstructdecl.alignment, -72
    .set cc_parse.readstructdecl.size, -80
    .set cc_parse.readstructdecl.pm, -88
    .set cc_parse.readstructdecl.fieldlist, -96
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	128
#---------------
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	85
    setz      %al
    movzx     %eax,	%al
    mov       %r12,	%rax
    call      cc_lex.lex
    mov       %rax,	[%rip+cc_decls.currproc]
    test      %rax,	%rax
    jz        L5430
    mov       %rax,	[%rip+cc_decls.currproc]
    jmp       L5429
L5430:
    mov       %rax,	[%rip+cc_decls.stmodule]
L5429:
    mov       %rsi,	%rax
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	17
    jnz       L5432
    call      cc_lib.nextautotype
    mov       %rcx,	%rax
    call      cc_lex.addnamestr
    mov       [%rbp + cc_parse.readstructdecl.d],	%rax
    jmp       L5431
L5432:
    mov       %rcx,	67
    call      cc_lib.checksymbol
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       [%rbp + cc_parse.readstructdecl.d],	%rax
    call      cc_lex.lex
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	17
    jz        L5434
    mov       %rcx,	%rsi
    mov       %rdx,	[%rbp + cc_parse.readstructdecl.d]
    mov       %r8,	2
    mov       %r9,	[%rip+cc_decls.currblockno]
    call      cc_lib.resolvename
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L5436
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	13
    jz        L5438
    mov       %rax,	[%rdi]
    lea       %rcx,	[%rip+L8688]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L5438:
    movzx     %rax,	word ptr[%rdi+102]
    jmp       L5428
L5436:
    mov       %rcx,	%rsi
    mov       %rdx,	[%rbp + cc_parse.readstructdecl.d]
    mov       %r8,	13
    call      cc_lib.createdupldef
    mov       %rdi,	%rax
    test      %r12,	%r12
    jz        L5440
    mov       %rax,	19
    jmp       L5439
L5440:
    mov       %rax,	18
L5439:
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      cc_lib.createstructmode
    mov       [%rdi+102],	%ax
    mov       %ax,	[%rip+cc_decls.currblockno]
    mov       [%rdi+96],	%ax
    mov       %eax,	1
    lea       %r10,	[%rip+cc_decls.blockcounts]
    mov       %r11,	[%rip+cc_decls.currblockno]
    mov       [%r10 + %r11*4],	%eax
    movzx     %rax,	word ptr[%rdi+102]
    jmp       L5428
L5434:
L5431:
    mov       %rcx,	%rsi
    mov       %rdx,	[%rbp + cc_parse.readstructdecl.d]
    mov       %r8,	2
    mov       %r9,	[%rip+cc_decls.currblockno]
    call      cc_lib.checkdupl
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L5442
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	13
    jz        L5444
    mov       %rax,	[%rdi]
    lea       %rcx,	[%rip+L8688]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L5444:
    mov       %rax,	[%rdi+16]
    test      %rax,	%rax
    jz        L5446
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8689]
    call      msys.m$print_str_nf
    mov       %eax,	[%rdi+92]
    and       %rax,	1677215
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    mov       %eax,	[%rdi+92]
    sar       %rax,	24
    lea       %r10,	[%rip+cc_decls.sourcefilenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    mov       %eax,	[%rdi+92]
    sar       %rax,	24
    lea       %r10,	[%rip+cc_decls.sourcefilepaths]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rax,	[%rdi]
    lea       %rcx,	[%rip+L8690]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L5446:
    jmp       L5441
L5442:
    mov       %rcx,	%rsi
    mov       %rdx,	[%rbp + cc_parse.readstructdecl.d]
    mov       %r8,	13
    call      cc_lib.createdupldef
    mov       %rdi,	%rax
    test      %r12,	%r12
    jz        L5448
    mov       %rax,	19
    jmp       L5447
L5448:
    mov       %rax,	18
L5447:
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      cc_lib.createstructmode
    mov       [%rdi+102],	%ax
    mov       %ax,	[%rip+cc_decls.currblockno]
    mov       [%rdi+96],	%ax
    mov       %eax,	1
    lea       %r10,	[%rip+cc_decls.blockcounts]
    mov       %r11,	[%rip+cc_decls.currblockno]
    mov       [%r10 + %r11*4],	%eax
L5441:
    call      cc_lex.lex
    mov       %rbx,	%rdi
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readstructdecl.ulistx],	%rax
    mov       [%rbp + cc_parse.readstructdecl.ulist],	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readstructdecl.recsize],	%rax
    mov       [%rbp + cc_parse.readstructdecl.maxsize],	%rax
    mov       [%rbp + cc_parse.readstructdecl.offset],	%rax
    mov       %rax,	1
    mov       [%rbp + cc_parse.readstructdecl.maxalignment],	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readstructdecl.fieldlist],	%rax
    mov       %r14,	-1
    jmp       L5450
L5449:
    mov       %rcx,	%rbx
    lea       %rdx,	[%rbp + cc_parse.readstructdecl.linkage]
    call      cc_parse.readdeclspec
    mov       %r13,	%rax
L5452:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L5454
    cmp       %rax,	25
    jz        L5454
    cmp       %rax,	13
    jz        L5454
    cmp       %rax,	10
    jz        L5455
    jmp       L5456
L5454:
    mov       %rcx,	%rbx
    lea       %rdx,	[%rbp + cc_parse.readstructdecl.d]
    mov       %r8,	%r13
    lea       %r9,	[%rbp + cc_parse.readstructdecl.pm]
    call      cc_parse.readtype
    mov       %r14,	%rax
    mov       %rax,	[%rbp + cc_parse.readstructdecl.d]
    test      %rax,	%rax
    jnz       L5458
    lea       %rcx,	[%rip+L8691]
    call      cc_support.serror
L5458:
    mov       %rax,	[%rbp + cc_parse.readstructdecl.linkage]
    cmp       %rax,	5
    jz        L5461
    mov       %rax,	[%rbp + cc_parse.readstructdecl.pm]
    test      %rax,	%rax
    jz        L5460
L5461:
    lea       %rcx,	[%rip+L8692]
    call      cc_support.serror
L5460:
    mov       %rcx,	%rbx
    mov       %rdx,	[%rbp + cc_parse.readstructdecl.d]
    mov       %r8,	4
    xor       %r9d,	%r9d
    call      cc_lib.checkdupl
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L5463
    mov       %rax,	[%rdi]
    lea       %rcx,	[%rip+L8693]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L5463:
    mov       %rax,	[%rbp + cc_parse.readstructdecl.linkage]
    test      %rax,	%rax
    jz        L5465
    lea       %rcx,	[%rip+L8694]
    call      cc_support.serror
L5465:
#cc_parse.readstructdecl.addanonfield:
L5466:
    xor       %ecx,	%ecx
    mov       %rdx,	[%rbp + cc_parse.readstructdecl.d]
    mov       %r8,	10
    call      cc_lib.createdupldef
    mov       [%rbp + cc_parse.readstructdecl.d],	%rax
    mov       %ax,	%r14w
    mov       %r10,	[%rbp + cc_parse.readstructdecl.d]
    mov       [%r10+102],	%ax
    lea       %rcx,	[%rbp + cc_parse.readstructdecl.ulist]
    lea       %rdx,	[%rbp + cc_parse.readstructdecl.ulistx]
    mov       %r8,	[%rbp + cc_parse.readstructdecl.d]
    call      cc_lib.addlistdef
    mov       %rax,	[%rbp + cc_parse.readstructdecl.ulist]
    mov       [%rbx+16],	%rax
    mov       %rax,	[%rbp + cc_parse.readstructdecl.ulistx]
    mov       [%rbx+24],	%rax
    mov       %rax,	%rbx
    mov       %r10,	[%rbp + cc_parse.readstructdecl.d]
    mov       [%r10+8],	%rax
    mov       %rcx,	%r14
    call      cc_lib.getalignment
    mov       [%rbp + cc_parse.readstructdecl.alignment],	%rax
    mov       %rax,	[%rbp + cc_parse.readstructdecl.alignment]
    cmp       %rax,	[%rbp + cc_parse.readstructdecl.maxalignment]
    jle       L5468
    mov       %rax,	[%rbp + cc_parse.readstructdecl.alignment]
    mov       [%rbp + cc_parse.readstructdecl.maxalignment],	%rax
L5468:
    mov       %rcx,	[%rbp + cc_parse.readstructdecl.offset]
    mov       %rdx,	[%rbp + cc_parse.readstructdecl.alignment]
    call      cc_parse.roundoffset
    mov       %r10,	[%rbp + cc_parse.readstructdecl.d]
    mov       [%r10+88],	%eax
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%r14
    mov       %rax,	[%rax + %r10*8]
    mov       [%rbp + cc_parse.readstructdecl.size],	%rax
    mov       %rax,	[%rbp + cc_parse.readstructdecl.d]
    movsxd    %rax,	dword ptr[%rax+88]
    sub       %rax,	[%rbp + cc_parse.readstructdecl.offset]
    add       [%rbp + cc_parse.readstructdecl.recsize],	%rax
    mov       %rax,	[%rbp + cc_parse.readstructdecl.d]
    movsxd    %rax,	dword ptr[%rax+88]
    mov       [%rbp + cc_parse.readstructdecl.offset],	%rax
    lea       %rcx,	[%rbp + cc_parse.readstructdecl.fieldlist]
    mov       %rdx,	[%rbp + cc_parse.readstructdecl.d]
    mov       %r8,	[%rbp + cc_parse.readstructdecl.offset]
    call      cc_parse.addnewfield
    test      %r12,	%r12
    jz        L5470
    mov       %rax,	[%rbp + cc_parse.readstructdecl.maxsize]
    mov       %r10,	[%rbp + cc_parse.readstructdecl.size]
    cmp       %rax,	%r10
    cmovl     %rax,	%r10
    mov       [%rbp + cc_parse.readstructdecl.maxsize],	%rax
    jmp       L5469
L5470:
    mov       %rax,	[%rbp + cc_parse.readstructdecl.size]
    add       [%rbp + cc_parse.readstructdecl.offset],	%rax
    mov       %rax,	[%rbp + cc_parse.readstructdecl.size]
    add       [%rbp + cc_parse.readstructdecl.recsize],	%rax
L5469:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	10
    jnz       L5472
    call      cc_lex.lex
    call      cc_parse.readassignexpr
L5472:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jnz       L5475
L5474:
    call      cc_lex.lex
    jmp       L5473
L5475:
    mov       %rcx,	9
    call      cc_lib.skipsymbol
    jmp       L5453
L5473:
    jmp       L5452
L5455:
    call      cc_lex.lex
    call      cc_parse.readassignexpr
    mov       %rcx,	9
    call      cc_lib.skipsymbol
    jmp       L5453
L5456:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%r13
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	18
    jz        L5477
    cmp       %rax,	19
    jnz       L5478
L5477:
    call      cc_lib.getautofieldname
    mov       [%rbp + cc_parse.readstructdecl.d],	%rax
    mov       %r14,	%r13
    jmp       L5466
L5478:
    cmp       %r14,	-1
    jnz       L5480
    lea       %rcx,	[%rip+L8695]
    call      cc_support.serror
    jmp       L5479
L5480:
    mov       %rcx,	%r14
    call      cc_lib.typename
    lea       %rcx,	[%rip+L8696]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L5479:
L5476:
    jmp       L5452
L5453:
L5450:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	18
    jnz       L5449
    mov       %rcx,	18
    call      cc_lib.skipsymbol
    mov       %rax,	[%rbp + cc_parse.readstructdecl.fieldlist]
    mov       [%rbx+64],	%rax
    test      %r12,	%r12
    jz        L5482
    mov       %rax,	[%rbp + cc_parse.readstructdecl.maxsize]
    jmp       L5481
L5482:
    mov       %rax,	[%rbp + cc_parse.readstructdecl.recsize]
L5481:
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + cc_parse.readstructdecl.maxalignment]
    call      cc_parse.roundoffset
    movzx     %r10,	word ptr[%rbx+102]
    lea       %r11,	[%rip+cc_decls.ttsize]
    mov       [%r11 + %r10*8],	%rax
    mov       %al,	[%rbp + cc_parse.readstructdecl.maxalignment]
    mov       [%rbx+112],	%al
    movzx     %rax,	word ptr[%rbx+102]
    mov       %r14,	%rax
    lea       %rax,	[%rip+cc_decls.ttconsttype]
    mov       %r10,	%r14
    mov       %ax,	[%rax + %r10*2]
    test      %ax,	%ax
    jz        L5484
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%r14
    mov       %rax,	[%rax + %r10*8]
    lea       %r10,	[%rip+cc_decls.ttconsttype]
    mov       %r11,	%r14
    movsx     %r10,	word ptr[%r10 + %r11*2]
    lea       %r11,	[%rip+cc_decls.ttsize]
    mov       [%r11 + %r10*8],	%rax
L5484:
    movzx     %rax,	word ptr[%rbx+102]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r10,	[%r10 + %rax*8]
    cmp       %r10,	1
    jz        L5487
    cmp       %r10,	2
    jz        L5487
    cmp       %r10,	4
    jz        L5487
    cmp       %r10,	8
    jnz       L5486
L5487:
    movzx     %rax,	word ptr[%rbx+102]
    xor       %r10d,	%r10d
    lea       %r11,	[%rip+cc_decls.ttisblock]
    mov       [%r11 + %rax],	%r10b
L5486:
    movzx     %rax,	word ptr[%rbx+102]
L5428:
#---------------
    add       %rsp,	128
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.checkpointertypes
cc_parse.checkpointertypes:
#?>>
    .set cc_parse.checkpointertypes.t, 80
    .set cc_parse.checkpointertypes.hard, 88
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %r15,	%rcx
    mov       [%rbp+80],	%rdx
    mov       [%rbp+88],	%r8
#---------------
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%r15
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	[%rbp + cc_parse.checkpointertypes.t]
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rbx,	%rax
    xor       %r13,	%r13
    xor       %eax,	%eax
    mov       %r14,	%rax
    lea       %rax,	[%rip+cc_decls.ttconst]
    mov       %r10,	%rdi
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5490
    lea       %rax,	[%rip+cc_decls.ttconsttype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rdi,	%rax
    mov       %r13,	1
L5490:
    lea       %rax,	[%rip+cc_decls.ttconst]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5492
    lea       %rax,	[%rip+cc_decls.ttconsttype]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rbx,	%rax
    mov       %r14,	1
L5492:
    mov       %rax,	[%rbp + cc_parse.checkpointertypes.hard]
    test      %rax,	%rax
    jnz       L5494
    test      %r13,	%r13
    jz        L5494
    test      %r14,	%r14
    jnz       L5494
    call      msys.m$print_startcon
    mov       %rcx,	%r15
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    mov       %rcx,	[%rbp + cc_parse.checkpointertypes.t]
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8697]
    call      cc_support.terror
L5494:
    cmp       %rdi,	%rbx
    jnz       L5496
    mov       %rax,	1
    jmp       L5488
L5496:
    mov       %r15,	%rdi
    mov       [%rbp + cc_parse.checkpointertypes.t],	%rbx
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%r15
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rsi,	%rax
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	[%rbp + cc_parse.checkpointertypes.t]
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %r12,	%rax
    mov       %rax,	%rsi
    cmp       %rax,	1
    jl        L5498
    cmp       %rax,	9
    jg        L5498
    mov       %rax,	%r12
    cmp       %rax,	1
    jl        L5498
    cmp       %rax,	9
    jg        L5498
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r11,	%r12
    mov       %r10,	[%r10 + %r11*8]
    cmp       %rax,	%r10
    jnz       L5500
    mov       %rax,	1
    jmp       L5488
L5500:
L5498:
    test      %rsi,	%rsi
    jz        L5503
    test      %r12,	%r12
    jnz       L5502
L5503:
    mov       %rax,	1
    jmp       L5488
L5502:
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%r15
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5505
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	[%rbp + cc_parse.checkpointertypes.t]
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5505
    mov       %rcx,	%r15
    mov       %rdx,	[%rbp + cc_parse.checkpointertypes.t]
    mov       %r8,	[%rbp + cc_parse.checkpointertypes.hard]
    call      cc_parse.checkpointertypes
    jmp       L5488
L5505:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%r15
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jnz       L5506
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	[%rbp + cc_parse.checkpointertypes.t]
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jnz       L5506
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%r15
    mov       %rax,	[%rax + %r10*8]
    lea       %r10,	[%rip+cc_decls.ttlength]
    mov       %r11,	[%rbp + cc_parse.checkpointertypes.t]
    mov       %r10,	[%r10 + %r11*8]
    cmp       %rax,	%r10
    jz        L5508
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%r15
    mov       %rax,	[%rax + %r10*8]
    test      %rax,	%rax
    jz        L5510
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	[%rbp + cc_parse.checkpointertypes.t]
    mov       %rax,	[%rax + %r10*8]
    test      %rax,	%rax
    jz        L5510
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8698]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rax,	1
    jmp       L5488
    xor       %eax,	%eax
    jmp       L5488
L5510:
L5508:
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%r15
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	[%rbp + cc_parse.checkpointertypes.t]
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rbx,	%rax
    cmp       %rdi,	%rbx
    jnz       L5512
    mov       %rax,	1
    jmp       L5488
L5512:
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%rdi
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5514
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5514
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	[%rbp + cc_parse.checkpointertypes.hard]
    call      cc_parse.checkpointertypes
    jmp       L5488
L5514:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jnz       L5516
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jnz       L5516
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	[%rbp + cc_parse.checkpointertypes.hard]
    call      cc_parse.checkpointertypes
    jmp       L5488
L5516:
    jmp       L5504
L5506:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%r15
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	14
    jnz       L5517
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	[%rbp + cc_parse.checkpointertypes.t]
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	14
    jnz       L5517
    mov       %rax,	1
    jmp       L5488
L5517:
L5504:
    xor       %eax,	%eax
L5488:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.comparemode
cc_parse.comparemode:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    cmp       %rdi,	%rbx
    jnz       L5520
    mov       %rax,	1
    jmp       L5518
L5520:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jnz       L5522
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jnz       L5522
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    lea       %r10,	[%rip+cc_decls.tttarget]
    mov       %r11,	%rdi
    movsx     %r10,	word ptr[%r10 + %r11*2]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      cc_parse.comparemode
    test      %rax,	%rax
    jnz       L5524
    xor       %eax,	%eax
    jmp       L5518
L5524:
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    test      %rax,	%rax
    jz        L5527
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8]
    test      %rax,	%rax
    jz        L5527
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    lea       %r10,	[%rip+cc_decls.ttlength]
    mov       %r11,	%rbx
    mov       %r10,	[%r10 + %r11*8]
    cmp       %rax,	%r10
    jnz       L5526
L5527:
    mov       %rax,	1
    jmp       L5518
L5526:
L5522:
    xor       %eax,	%eax
L5518:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readenumdecl
cc_parse.readenumdecl:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    call      cc_lex.lex
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	17
    jnz       L5530
    mov       %rcx,	%rsi
    call      cc_parse.readenumnames
    mov       %rax,	12
    jmp       L5528
L5530:
    mov       %rcx,	67
    call      cc_lib.checksymbol
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rdi,	[%rax]
    call      cc_lex.lex
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	17
    jz        L5532
    mov       %rcx,	%rsi
    mov       %rdx,	%rdi
    mov       %r8,	2
    mov       %r9,	[%rip+cc_decls.currblockno]
    call      cc_lib.checkdupl
    mov       %rbx,	%rax
    test      %rbx,	%rbx
    jz        L5534
    movzx     %rax,	byte ptr[%rbx+109]
    cmp       %rax,	12
    jz        L5536
    mov       %rax,	[%rbx]
    lea       %rcx,	[%rip+L8699]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L5536:
L5534:
    mov       %rcx,	%rsi
    mov       %rdx,	%rdi
    mov       %r8,	12
    call      cc_lib.createdupldef
    mov       %rbx,	%rax
    mov       %rcx,	%rbx
    call      cc_lib.createenummode
    mov       [%rbx+102],	%ax
    mov       %ax,	[%rip+cc_decls.currblockno]
    mov       [%rbx+96],	%ax
    mov       %eax,	1
    lea       %r10,	[%rip+cc_decls.blockcounts]
    mov       %r11,	[%rip+cc_decls.currblockno]
    mov       [%r10 + %r11*4],	%eax
    movzx     %rax,	word ptr[%rbx+102]
    jmp       L5528
L5532:
    mov       %rcx,	%rsi
    mov       %rdx,	%rdi
    mov       %r8,	2
    mov       %r9,	[%rip+cc_decls.currblockno]
    call      cc_lib.checkdupl
    mov       %rbx,	%rax
    test      %rbx,	%rbx
    jz        L5538
    movzx     %rax,	byte ptr[%rbx+109]
    cmp       %rax,	12
    jz        L5540
    mov       %rax,	[%rbx]
    lea       %rcx,	[%rip+L8699]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L5540:
    mov       %rax,	[%rbx+16]
    test      %rax,	%rax
    jz        L5542
    mov       %rax,	[%rbx]
    lea       %rcx,	[%rip+L8700]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L5542:
    jmp       L5537
L5538:
    mov       %rcx,	%rsi
    mov       %rdx,	%rdi
    mov       %r8,	12
    call      cc_lib.createdupldef
    mov       %rbx,	%rax
    mov       %rcx,	%rbx
    call      cc_lib.createenummode
    mov       [%rbx+102],	%ax
    mov       %ax,	[%rip+cc_decls.currblockno]
    mov       [%rbx+96],	%ax
    mov       %eax,	1
    lea       %r10,	[%rip+cc_decls.blockcounts]
    mov       %r11,	[%rip+cc_decls.currblockno]
    mov       [%r10 + %r11*4],	%eax
L5537:
    mov       %rcx,	%rsi
    call      cc_parse.readenumnames
    movzx     %rax,	word ptr[%rbx+102]
    mov       %r10,	%rbx
    lea       %r11,	[%rip+cc_decls.ttnamedef]
    mov       [%r11 + %rax*8],	%r10
    movzx     %rax,	word ptr[%rbx+102]
L5528:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readenumnames
cc_parse.readenumnames:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
#---------------
    xor       %eax,	%eax
    mov       %rsi,	%rax
    mov       %rbx,	%rax
    xor       %r12,	%r12
    call      cc_lex.lex
    movzx     %rax,	byte ptr[%r13+109]
    cmp       %rax,	6
    jz        L5545
    cmp       %rax,	3
    jnz       L5546
L5545:
    jmp       L5544
L5546:
    mov       %rax,	[%rip+cc_decls.currproc]
    test      %rax,	%rax
    jz        L5548
    mov       %rax,	[%rip+cc_decls.currproc]
    jmp       L5547
L5548:
    mov       %rax,	[%rip+cc_decls.stmodule]
L5547:
    mov       %r13,	%rax
L5544:
    jmp       L5550
L5549:
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       %rcx,	%r13
    mov       %rdx,	%rax
    mov       %r8,	1
    mov       %r9,	[%rip+cc_decls.currblockno]
    call      cc_lib.checkdupl
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L5553
    mov       %rax,	[%rdi]
    lea       %rcx,	[%rip+L8701]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L5553:
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       %rcx,	%r13
    mov       %rdx,	%rax
    mov       %r8,	11
    call      cc_lib.createdupldef
    mov       %rdi,	%rax
    call      cc_lex.lex
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	11
    jnz       L5555
    call      cc_lex.lex
    call      cc_parse.readconstintexpr
    mov       %r12,	%rax
L5555:
    mov       [%rdi+88],	%r12d
    mov       %ax,	[%rip+cc_decls.currblockno]
    mov       [%rdi+96],	%ax
    mov       %eax,	1
    lea       %r10,	[%rip+cc_decls.blockcounts]
    mov       %r11,	[%rip+cc_decls.currblockno]
    mov       [%r10 + %r11*4],	%eax
    inc       %r12
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jnz       L5557
    call      cc_lex.lex
L5557:
L5550:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L5549
    mov       %rcx,	18
    call      cc_lib.skipsymbol
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createdotop
cc_parse.createdotop:
#?>>
    .set cc_parse.createdotop.p, 80
    .set cc_parse.createdotop.d, 88
    .set cc_parse.createdotop.fl, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %r15,	%rcx
    mov       [%rbp+80],	%rdx
    mov       [%rbp+88],	%r8
#---------------
    mov       %rax,	[%rbp + cc_parse.createdotop.p]
    movsxd    %rax,	dword ptr[%rax+52]
    mov       %r13,	%rax
    cmp       %r15,	50
    jnz       L5560
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%r13
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jnz       L5562
    lea       %rcx,	[%rip+L8702]
    call      cc_support.serror
L5562:
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%r13
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %r13,	%rax
L5560:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%r13
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	18
    jz        L5564
    cmp       %rax,	19
    jnz       L5565
L5564:
    jmp       L5563
L5565:
    lea       %rcx,	[%rip+L8703]
    call      cc_support.serror
L5563:
    lea       %rax,	[%rip+cc_decls.ttnamedef]
    mov       %r10,	%r13
    mov       %rsi,	[%rax + %r10*8]
    mov       %rbx,	[%rbp + cc_parse.createdotop.d]
    jmp       L5567
L5566:
    mov       %rax,	[%rbx+8]
    cmp       %rax,	%rsi
    jnz       L5570
    movsxd    %rax,	dword ptr[%rbx+88]
    mov       %r14,	%rax
    jmp       L5568
L5570:
L5567:
    mov       %rax,	[%rbx+40]
    mov       %rbx,	%rax
    test      %rax,	%rax
    jnz       L5566
L5568:
    test      %rbx,	%rbx
    jnz       L5572
    mov       %r12,	[%rbp + cc_parse.createdotop.d]
    jmp       L5574
L5573:
    mov       %r12,	[%r12+48]
L5574:
    mov       %rax,	[%r12+48]
    test      %rax,	%rax
    jnz       L5573
    mov       %rax,	[%rsi+64]
    mov       [%rbp + cc_parse.createdotop.fl],	%rax
    jmp       L5577
L5576:
    mov       %rax,	[%rbp + cc_parse.createdotop.fl]
    mov       %rax,	[%rax+8]
    cmp       %rax,	%r12
    jnz       L5580
    mov       %rax,	[%rbp + cc_parse.createdotop.fl]
    mov       %rbx,	[%rax]
    mov       %rax,	[%rbp + cc_parse.createdotop.fl]
    mov       %r14,	[%rax+24]
    jmp       L5578
L5580:
    mov       %rax,	[%rbp + cc_parse.createdotop.fl]
    mov       %rax,	[%rax+16]
    mov       [%rbp + cc_parse.createdotop.fl],	%rax
L5577:
    mov       %rax,	[%rbp + cc_parse.createdotop.fl]
    test      %rax,	%rax
    jnz       L5576
L5578:
L5572:
    test      %rbx,	%rbx
    jnz       L5582
    mov       %rcx,	%r13
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %r10,	[%rbp + cc_parse.createdotop.d]
    mov       %r10,	[%r10]
    lea       %rcx,	[%rip+L8704]
    mov       %rdx,	%r10
    mov       %r8,	%rax
    call      cc_support.terror_ss
L5582:
    mov       %rcx,	%r14
    mov       %rdx,	3
    call      cc_lib.createconstunit
    mov       %rdi,	%rax
    cmp       %r15,	50
    jnz       L5584
    mov       %rcx,	[%rbp + cc_parse.createdotop.p]
    call      cc_parse.createptrop
    mov       [%rbp + cc_parse.createdotop.p],	%rax
L5584:
    mov       %rcx,	49
    mov       %rdx,	[%rbp + cc_parse.createdotop.p]
    call      cc_lib.createunit1
    mov       [%rbp + cc_parse.createdotop.p],	%rax
    mov       %eax,	%r14d
    mov       %r10,	[%rbp + cc_parse.createdotop.p]
    mov       [%r10],	%eax
    movzx     %rax,	word ptr[%rbx+102]
    mov       %r10,	[%rbp + cc_parse.createdotop.p]
    mov       [%r10+52],	%eax
    mov       %rcx,	[%rbp + cc_parse.createdotop.p]
    call      cc_parse.arraytopointer
    mov       [%rbp + cc_parse.createdotop.p],	%rax
    mov       %rcx,	[%rbp + cc_parse.createdotop.p]
    call      cc_parse.fixmemopnd
    mov       %rax,	[%rbp + cc_parse.createdotop.p]
L5558:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.mulunit
cc_parse.mulunit:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8]
    mov       %rdi,	%rax
    cmp       %rax,	1
    jz        L5587
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L5589
    mov       %rax,	[%rbx]
    mov       %r10,	%rdi
    imul      %rax,	%r10
    mov       [%rbx],	%rax
    jmp       L5588
L5589:
    mov       %rcx,	57
    mov       %rdx,	%rbx
    call      cc_lib.createunit1
    mov       %rbx,	%rax
    mov       [%rbx+48],	%edi
    mov       %eax,	4
    mov       [%rbx+52],	%eax
L5588:
L5587:
    mov       %rax,	%rbx
L5585:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.divunit
cc_parse.divunit:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8]
    mov       %rdi,	%rax
    cmp       %rax,	1
    jz        L5592
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L5594
    mov       %rax,	[%rbx]
    mov       %r10,	%rdi
    cqo       
    idiv      %r10
    mov       [%rbx],	%rax
    jmp       L5593
L5594:
    mov       %rcx,	57
    mov       %rdx,	%rbx
    call      cc_lib.createunit1
    mov       %rbx,	%rax
    mov       %rax,	%rdi
    neg       %rax
    mov       [%rbx+48],	%eax
    mov       %eax,	4
    mov       [%rbx+52],	%eax
L5593:
L5592:
    mov       %rax,	%rbx
L5590:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createassignopref
cc_parse.createassignopref:
#?>>
    .set cc_parse.createassignopref.q, 88
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %r14,	%rcx
    mov       %r15,	%rdx
    mov       [%rbp+88],	%r8
#---------------
    movsxd    %rax,	dword ptr[%r15+52]
    mov       %rsi,	%rax
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %r12,	%rax
    mov       %rax,	[%rbp + cc_parse.createassignopref.q]
    movsxd    %rax,	dword ptr[%rax+52]
    mov       %rbx,	%rax
    mov       %rax,	%r14
    cmp       %rax,	11
    jz        L5597
    cmp       %rax,	46
    jz        L5598
    cmp       %rax,	47
    jz        L5599
    jmp       L5600
L5597:
    mov       %rcx,	[%rbp + cc_parse.createassignopref.q]
    mov       %rdx,	%rdi
    call      cc_parse.coercemode
    mov       [%rbp + cc_parse.createassignopref.q],	%rax
    mov       %rcx,	11
    mov       %rdx,	%r15
    mov       %r8,	[%rbp + cc_parse.createassignopref.q]
    call      cc_lib.createunit2
    mov       %r13,	%rax
    jmp       L5596
L5598:
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5602
    lea       %rcx,	[%rip+L8705]
    call      cc_support.serror
L5602:
    mov       %rcx,	[%rbp + cc_parse.createassignopref.q]
    mov       %rdx,	4
    call      cc_parse.coercemode
    mov       [%rbp + cc_parse.createassignopref.q],	%rax
    mov       %rcx,	[%rbp + cc_parse.createassignopref.q]
    mov       %rdx,	%r12
    call      cc_parse.mulunit
    mov       %rcx,	61
    mov       %rdx,	%r15
    mov       %r8,	%rax
    call      cc_lib.createunit2
    mov       %r13,	%rax
    jmp       L5596
L5599:
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5604
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      cc_parse.comparemode
    test      %rax,	%rax
    jnz       L5606
    lea       %rcx,	[%rip+L8706]
    call      cc_support.serror
L5606:
    mov       %rcx,	40
    mov       %rdx,	%r15
    mov       %r8,	[%rbp + cc_parse.createassignopref.q]
    call      cc_lib.createunit2
    mov       %rcx,	%rax
    mov       %rdx,	%r12
    call      cc_parse.divunit
    mov       %r13,	%rax
    mov       %rsi,	3
    jmp       L5603
L5604:
    mov       %rcx,	[%rbp + cc_parse.createassignopref.q]
    mov       %rdx,	%r12
    call      cc_parse.mulunit
    mov       %rcx,	62
    mov       %rdx,	%r15
    mov       %r8,	%rax
    call      cc_lib.createunit2
    mov       %r13,	%rax
L5603:
    jmp       L5596
L5600:
    lea       %rcx,	[%rip+L8707]
    call      cc_support.serror
L5596:
    mov       [%r13+52],	%esi
    mov       %rax,	%r13
L5595:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.addnewfield
cc_parse.addnewfield:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
    mov       %rax,	[%r12]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	36
    jz        L5609
    mov       %rcx,	32
    call      mlib.pcm_allocz
    mov       %rbx,	%rax
    mov       [%rbx],	%r12
    jmp       L5611
L5610:
    mov       %r12,	[%r12+48]
L5611:
    mov       %rax,	[%r12+48]
    test      %rax,	%rax
    jnz       L5610
    mov       [%rbx+8],	%r12
    mov       [%rbx+24],	%r13
    mov       %rax,	[%rsi]
    mov       [%rbx+16],	%rax
    mov       [%rsi],	%rbx
    jmp       L5608
L5609:
    movzx     %rax,	word ptr[%r12+102]
    lea       %r10,	[%rip+cc_decls.ttnamedef]
    mov       %r10,	[%r10 + %rax*8]
    mov       %r10,	[%r10+16]
    mov       %rdi,	%r10
    jmp       L5614
L5613:
    movsxd    %rax,	dword ptr[%rdi+88]
    mov       %r10,	%r13
    add       %r10,	%rax
    mov       %rcx,	%rsi
    mov       %rdx,	%rdi
    mov       %r8,	%r10
    call      cc_parse.addnewfield
    mov       %rdi,	[%rdi+32]
L5614:
    test      %rdi,	%rdi
    jnz       L5613
L5608:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.pushloop
cc_parse.pushloop:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	[%rip+cc_parse.loopindex]
    cmp       %rax,	64
    jl        L5618
    lea       %rcx,	[%rip+L8708]
    call      cc_support.serror
L5618:
    inc       qword ptr[%rip+cc_parse.loopindex]
    mov       %al,	%dil
    lea       %r10,	[%rip+cc_parse.looptypestack]
    mov       %r11,	[%rip+cc_parse.loopindex]
    mov       [%r10 + %r11-1],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_parse.casevaluestack]
    mov       %r11,	[%rip+cc_parse.loopindex]
    mov       [%r10 + %r11*8-8],	%rax
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_parse.poploop
cc_parse.poploop:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    mov       %rax,	[%rip+cc_parse.loopindex]
    test      %rax,	%rax
    jz        L5621
    dec       qword ptr[%rip+cc_parse.loopindex]
    jmp       L5620
L5621:
    lea       %rcx,	[%rip+L8709]
    call      cc_support.serror
L5620:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_parse.addcasevalue
cc_parse.addcasevalue:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    mov       %rbx,	[%rip+cc_parse.loopindex]
    jmp       L5624
L5623:
    dec       %rbx
L5624:
    test      %rbx,	%rbx
    jz        L5626
    lea       %rax,	[%rip+cc_parse.looptypestack]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	83
    jnz       L5623
L5626:
    test      %rbx,	%rbx
    jnz       L5628
    lea       %rcx,	[%rip+L8710]
    call      cc_support.serror
L5628:
    mov       %rcx,	16
    call      mlib.pcm_alloc
    mov       %rdi,	%rax
    mov       [%rdi+8],	%rsi
    lea       %rax,	[%rip+cc_parse.casevaluestack]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8-8]
    mov       [%rdi],	%rax
    mov       %rax,	%rdi
    lea       %r10,	[%rip+cc_parse.casevaluestack]
    mov       %r11,	%rbx
    mov       [%r10 + %r11*8-8],	%rax
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.roundoffset
cc_parse.roundoffset:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	16
#---------------
    mov       %rax,	[%rip+cc_decls.structpadding]
    test      %rax,	%rax
    jz        L5631
    cmp       %rdx,	1
    jnz       L5633
    mov       %rax,	%rcx
    jmp       L5629
L5633:
    lea       %rax,	[%rdx-1]
    mov       %rdi,	%rax
    jmp       L5635
L5634:
    inc       %rcx
L5635:
    mov       %rax,	%rcx
    and       %rax,	%rdi
    jnz       L5634
L5631:
    mov       %rax,	%rcx
L5629:
#---------------
    add       %rsp,	16
    pop       %rdi
    ret       
# End 
# Proc cc_parse.fixmemopnd
cc_parse.fixmemopnd:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	16
#---------------
    mov       %al,	[%rip+cc_parse.ingeneric]
    test      %al,	%al
    jnz       L5637
L5639:
    movsxd    %rax,	dword ptr[%rcx+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rdi,	%r10
    cmp       %r10,	1
    jz        L5641
    cmp       %r10,	2
    jz        L5641
    cmp       %r10,	6
    jz        L5641
    cmp       %r10,	7
    jz        L5641
    cmp       %r10,	5
    jz        L5641
    jmp       L5642
L5641:
    mov       [%rcx+56],	%di
    mov       %eax,	3
    mov       [%rcx+52],	%eax
L5642:
L5640:
L5637:
#---------------
    add       %rsp,	16
    pop       %rdi
    ret       
# End 
# Proc cc_parse.docast
cc_parse.docast:
#?>>
    .set cc_parse.docast.inplace, 88
    .set cc_parse.docast.$T1, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
    mov       [%rbp+88],	%r9
#---------------
    movsxd    %rax,	dword ptr[%r12+52]
    mov       %rbx,	%rax
#cc_parse.docast.retry:
L5644:
    cmp       %rbx,	%r13
    jnz       L5646
    mov       %rax,	%r12
    jmp       L5643
L5646:
    xor       %rsi,	%rsi
    mov       %rax,	%rbx
    cmp       %rax,	16
    jge       L5648
    cmp       %r13,	16
    jge       L5648
    lea       %rax,	[%rip+cc_tables.conversionops]
    mov       %r10,	%rbx
    shl       %r10,	4
    lea       %rax,	[%rax + %r10]
    mov       %r10,	%r13
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %rsi,	%rax
    jmp       L5647
L5648:
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5649
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%r13
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5649
    mov       %rcx,	%rbx
    mov       %rdx,	%r13
    mov       %r8,	%r14
    call      cc_parse.checkpointertypes
    test      %rax,	%rax
    jz        L5651
    mov       [%r12+52],	%r13d
    mov       %rax,	%r12
    jmp       L5643
L5651:
    jmp       L5647
L5649:
    lea       %rax,	[%rip+cc_decls.ttconst]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5652
    lea       %rax,	[%rip+cc_decls.ttconsttype]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rbx,	%rax
    jmp       L5644
L5652:
    lea       %rax,	[%rip+cc_decls.ttconst]
    mov       %r10,	%r13
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5653
    lea       %rax,	[%rip+cc_decls.ttconsttype]
    mov       %r10,	%r13
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %r13,	%rax
    jmp       L5644
L5653:
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%r13
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5654
    mov       %rcx,	%rbx
    call      cc_lib.isintcc
    test      %rax,	%rax
    jz        L5654
    movsxd    %rax,	dword ptr[%r12+40]
    cmp       %rax,	1
    jnz       L5654
    mov       %rax,	[%r12]
    test      %rax,	%rax
    jnz       L5654
    mov       %rsi,	1
L5654:
L5647:
    test      %rsi,	%rsi
    jnz       L5656
    test      %r14,	%r14
    jnz       L5658
    call      msys.m$print_startcon
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    mov       %rcx,	%r13
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    xor       %ecx,	%ecx
    mov       %rdx,	%r12
    xor       %r8d,	%r8d
    lea       %r9,	[%rip+L8711]
    call      cc_show.printunit
    mov       %rcx,	%r13
    call      cc_lib.typename
    mov       [%rbp + cc_parse.docast.$T1],	%rax
    mov       %rcx,	%rbx
    call      cc_lib.typename
    lea       %rcx,	[%rip+L8712]
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + cc_parse.docast.$T1]
    call      cc_support.terror_ss
L5658:
    mov       %rsi,	2
L5656:
    movsxd    %rax,	dword ptr[%r12+40]
    cmp       %rax,	1
    jz        L5660
    cmp       %rax,	5
    jz        L5661
    cmp       %rax,	39
    jz        L5662
    jmp       L5663
L5660:
    mov       %rcx,	%r12
    mov       %rdx,	%r13
    mov       %r8,	%rsi
    call      cc_parse.eval_convert
    test      %rax,	%rax
    jz        L5665
    mov       %rax,	%r12
    jmp       L5643
L5665:
    jmp       L5659
L5661:
    mov       [%r12+52],	%r13d
    mov       %rax,	%r12
    jmp       L5643
L5662:
    mov       %rax,	[%r12+16]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5667
    mov       %rax,	[%r12+24]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5667
    mov       %rax,	[%r12+16]
    mov       %rax,	[%rax]
    mov       %r10,	[%r12+24]
    mov       %r10,	[%r10]
    add       %rax,	%r10
    mov       [%r12],	%rax
    mov       [%r12+52],	%r13d
    mov       %eax,	1
    mov       [%r12+40],	%eax
    mov       %rax,	%r12
    jmp       L5643
L5667:
L5663:
L5659:
    mov       %rax,	[%rbp + cc_parse.docast.inplace]
    test      %rax,	%rax
    jz        L5669
    mov       %rcx,	%r12
    mov       %rdx,	56
    call      cc_parse.insertunit
    mov       [%r12+58],	%r13w
    mov       %rcx,	%r13
    call      cc_parse.getpromotedtype
    mov       [%r12+52],	%eax
    mov       [%r12+48],	%esi
    xor       %eax,	%eax
    jmp       L5643
L5669:
    mov       %rcx,	56
    mov       %rdx,	%r12
    call      cc_lib.createunit1
    mov       %rdi,	%rax
    mov       [%rdi+48],	%esi
    mov       [%rdi+58],	%r13w
    mov       %rcx,	%r13
    call      cc_parse.getpromotedtype
    mov       [%rdi+52],	%eax
L5668:
    mov       %rax,	%rdi
L5643:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.coercemode
cc_parse.coercemode:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    movsxd    %rax,	dword ptr[%rdi+52]
    cmp       %rax,	%rbx
    jnz       L5672
    mov       %rax,	%rdi
    jmp       L5670
L5672:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    mov       %r9,	1
    call      cc_parse.docast
    mov       %rax,	%rdi
L5670:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.coercemode_inplace
cc_parse.coercemode_inplace:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    movsxd    %rax,	dword ptr[%rdi+52]
    cmp       %rax,	%rbx
    jz        L5673
L5675:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    mov       %r9,	1
    call      cc_parse.docast
L5673:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createsizeofop
cc_parse.createsizeofop:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r12,	%rcx
    mov       %r13,	%rdx
#---------------
    test      %r13,	%r13
    jz        L5678
    movsxd    %rax,	dword ptr[%r12+40]
    cmp       %rax,	53
    jz        L5678
    cmp       %rax,	55
    jz        L5678
    xor       %ecx,	%ecx
    mov       %rdx,	%r12
    xor       %r8d,	%r8d
    lea       %r9,	[%rip+L8713]
    call      cc_show.printunit
    lea       %rcx,	[%rip+L8714]
    call      cc_support.serror
L5678:
    mov       %rcx,	%r12
    call      cc_parse.getmemmode
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%r12+40]
    cmp       %rax,	3
    jz        L5680
    cmp       %rax,	1
    jz        L5681
    cmp       %rax,	52
    jz        L5682
    cmp       %rax,	53
    jz        L5683
    cmp       %rax,	55
    jz        L5684
    cmp       %rax,	4
    jz        L5685
    jmp       L5686
L5680:
    mov       %eax,	[%r12+48]
    test      %eax,	%eax
    jz        L5688
    mov       %rax,	[%r12]
    movzx     %rax,	word ptr[%rax+102]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r10,	[%r10 + %rax*8]
    movsxd    %rax,	dword ptr[%r12+48]
    xchg      %r10,	%rax
    cqo       
    idiv      %r10
    mov       %rsi,	%rax
    jmp       L5687
L5688:
    mov       %rax,	[%r12]
    movzx     %rax,	word ptr[%rax+102]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rsi,	%r10
L5687:
    jmp       L5679
L5681:
    mov       %rax,	%rbx
    cmp       %rax,	[%rip+cc_decls.trefchar]
    jz        L5690
    cmp       %rax,	[%rip+cc_decls.trefwchar]
    jz        L5691
    jmp       L5692
L5690:
    movsxd    %rax,	dword ptr[%r12+48]
    mov       %rsi,	%rax
    jmp       L5689
L5691:
    movsxd    %rax,	dword ptr[%r12+48]
    shl       %rax,	1
    mov       %rsi,	%rax
    jmp       L5689
L5692:
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rbx
    mov       %rsi,	[%rax + %r10*8]
L5689:
    jmp       L5679
L5682:
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5694
    mov       %eax,	[%r12+48]
    test      %eax,	%eax
    jz        L5694
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r10,	[%r10 + %rax*8]
    movsxd    %rax,	dword ptr[%r12+48]
    imul      %r10,	%rax
    mov       %rsi,	%r10
    jmp       L5693
L5694:
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rbx
    mov       %rsi,	[%rax + %r10*8]
L5693:
    jmp       L5679
L5683:
    mov       %eax,	[%r12+48]
    test      %eax,	%eax
    jz        L5696
    test      %r13,	%r13
    jz        L5698
    movsxd    %rax,	dword ptr[%r12+48]
    mov       %rsi,	%rax
    jmp       L5697
L5698:
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r10,	[%r10 + %rax*8]
    movsxd    %rax,	dword ptr[%r12+48]
    imul      %r10,	%rax
    mov       %rsi,	%r10
L5697:
    jmp       L5695
L5696:
    jmp       L5699
L5695:
    jmp       L5679
L5684:
    mov       %rax,	[%r12+16]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	3
    jnz       L5701
    mov       %rax,	[%r12+16]
    mov       %eax,	[%rax+48]
    test      %eax,	%eax
    jz        L5701
    test      %r13,	%r13
    jz        L5703
    mov       %rax,	[%r12+16]
    movsxd    %rax,	dword ptr[%rax+48]
    mov       %rsi,	%rax
    jmp       L5702
L5703:
    mov       %rax,	[%r12+16]
    mov       %rax,	[%rax]
    movzx     %rax,	word ptr[%rax+102]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rsi,	%r10
L5702:
    jmp       L5700
L5701:
    mov       %rsi,	8
L5700:
    jmp       L5679
L5685:
    mov       %rax,	[%r12+16]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      cc_parse.createsizeofop
    jmp       L5676
L5686:
#cc_parse.createsizeofop.cad1:
L5699:
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rbx
    mov       %rsi,	[%rax + %r10*8]
L5679:
    mov       %rcx,	%rsi
    mov       %rdx,	9
    call      cc_lib.createconstunit
    mov       %rdi,	%rax
    mov       %rax,	%rdi
L5676:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readgeneric
cc_parse.readgeneric:
#?>>
    .set cc_parse.readgeneric.pm, -8
    .set cc_parse.readgeneric.oldingeneric, -16
    .set cc_parse.readgeneric.count, -24
    .set cc_parse.readgeneric.d, -32
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	64
#---------------
    call      cc_lex.lex
    mov       %rcx,	13
    call      cc_lib.checksymbol
    call      cc_lex.lex
    movzx     %rax,	byte ptr[%rip+cc_parse.ingeneric]
    mov       [%rbp + cc_parse.readgeneric.oldingeneric],	%rax
    mov       %al,	1
    mov       [%rip+cc_parse.ingeneric],	%al
    call      cc_parse.readassignexpr
    mov       %rdi,	%rax
    mov       %al,	[%rbp + cc_parse.readgeneric.oldingeneric]
    mov       [%rip+cc_parse.ingeneric],	%al
    movsxd    %rax,	dword ptr[%rdi+52]
    mov       %r12,	%rax
    xor       %rbx,	%rbx
    xor       %eax,	%eax
    mov       %r14,	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readgeneric.count],	%rax
    mov       %rcx,	8
    call      cc_lib.checksymbol
L5705:
    call      cc_lex.lex
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	75
    jnz       L5709
    test      %r14,	%r14
    jz        L5711
    lea       %rcx,	[%rip+L8715]
    call      cc_support.serror
L5711:
    mov       %r14,	1
    mov       %rax,	[%rbp + cc_parse.readgeneric.count]
    test      %rax,	%rax
    jnz       L5713
    mov       %r13,	-1
    jmp       L5712
L5713:
    mov       %r13,	-2
L5712:
    call      cc_lex.lex
    jmp       L5708
L5709:
    sub       %rsp,	8
    push      0
    lea       %rcx,	[%rbp + cc_parse.readgeneric.d]
    xor       %edx,	%edx
    lea       %r8,	[%rbp + cc_parse.readgeneric.pm]
    xor       %r9d,	%r9d
    sub       %rsp,	32
    call      cc_parse.readcasttype
    add       %rsp,	48
    mov       %r13,	%rax
L5708:
    mov       %rcx,	10
    call      cc_lib.checksymbol
    call      cc_lex.lex
    call      cc_parse.readassignexpr
    mov       %rsi,	%rax
    cmp       %r13,	-1
    jz        L5716
    cmp       %r13,	%r12
    jnz       L5715
L5716:
    mov       %rbx,	%rsi
    inc       qword ptr[%rbp + cc_parse.readgeneric.count]
L5715:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jz        L5705
    mov       %rcx,	14
    call      cc_lib.checksymbol
    call      cc_lex.lex
    test      %rbx,	%rbx
    jnz       L5718
    lea       %rcx,	[%rip+L8716]
    call      cc_support.serror
L5718:
    mov       %rax,	[%rbp + cc_parse.readgeneric.count]
    cmp       %rax,	1
    jle       L5720
    lea       %rcx,	[%rip+L8717]
    call      cc_support.serror
L5720:
    mov       %rax,	%rbx
L5704:
#---------------
    add       %rsp,	64
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.getmemmode
cc_parse.getmemmode:
#?>>
#?]]
#---------------
    mov       %ax,	[%rcx+56]
    test      %ax,	%ax
    jz        L5723
    movsx     %rax,	word ptr[%rcx+56]
    jmp       L5722
L5723:
    movsxd    %rax,	dword ptr[%rcx+52]
L5722:
L5721:
#---------------
    ret       
# End 
# Proc cc_parse.getpromotedtype
cc_parse.getpromotedtype:
#?>>
#?]]
#---------------
    test      %rcx,	%rcx
    jnz       L5726
    xor       %eax,	%eax
    jmp       L5724
L5726:
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rcx
    mov       %rax,	[%rax + %r10*8]
    cmp       %rax,	4
    jge       L5728
    mov       %rax,	3
    jmp       L5724
L5728:
    mov       %rax,	%rcx
L5724:
#---------------
    ret       
# End 
# Proc cc_parse.readdllexport
cc_parse.readdllexport:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    xor       %rdi,	%rdi
    call      cc_lex.lex
    mov       %rcx,	13
    call      cc_lib.checksymbol
    call      cc_lex.lex
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jnz       L5731
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8718]
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L5731
    mov       %rdi,	1
L5731:
    call      cc_lex.lex
    mov       %rcx,	14
    call      cc_lib.checksymbol
    call      cc_lex.lex
    mov       %rax,	%rdi
L5729:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_genpcl.codegen_pcl
cc_genpcl.codegen_pcl:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
    movzx     %rax,	byte ptr[%rip+cc_cli.fverbose]
    cmp       %rax,	3
    jnz       L5734
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8719]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+cc_decls.inputfile]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L5734:
    xor       %ecx,	%ecx
    mov       %rdx,	[%rip+cc_decls.nunits]
    call      pc_api.pcl_start
    call      cc_genpcl.dolibs
    lea       %rcx,	[%rip+L8720]
    call      pc_api.gencomment
    mov       %rax,	[%rip+cc_decls.stmodule]
    mov       %rdi,	[%rax+16]
    jmp       L5736
L5735:
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	7
    jz        L5739
    cmp       %rax,	6
    jz        L5740
    jmp       L5741
L5739:
    mov       %rcx,	%rdi
    call      cc_genpcl.dostaticvar
    jmp       L5738
L5740:
    movzx     %rax,	byte ptr[%rdi+110]
    cmp       %rax,	4
    jz        L5743
    cmp       %rax,	2
    jz        L5744
    jmp       L5745
L5743:
    mov       %rax,	[%rdi+72]
    test      %rax,	%rax
    jnz       L5747
    mov       %al,	3
    mov       [%rdi+110],	%al
L5747:
    jmp       L5742
L5744:
    mov       %rax,	[%rdi+72]
    test      %rax,	%rax
    jnz       L5749
    mov       %rax,	[%rdi]
    lea       %rcx,	[%rip+L8721]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      cc_support.gerror_s
L5749:
L5745:
L5742:
    mov       %rbx,	[%rdi+16]
    jmp       L5751
L5750:
    movzx     %rax,	byte ptr[%rbx+109]
    cmp       %rax,	7
    jz        L5754
    cmp       %rax,	8
    jz        L5755
    jmp       L5756
L5754:
    mov       %rcx,	%rbx
    call      cc_genpcl.dostaticvar
    jmp       L5753
L5755:
    mov       %rax,	[%rbx+72]
    test      %rax,	%rax
    jz        L5758
    mov       %rax,	[%rbx+72]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	28
    jz        L5761
    movzx     %rax,	word ptr[%rbx+102]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    cmp       %r10,	17
    jnz       L5760
    mov       %rax,	[%rbx+72]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5760
L5761:
    mov       %rcx,	%rbx
    call      cc_genpcl.dostaticvar
L5760:
L5758:
L5756:
L5753:
    mov       %rbx,	[%rbx+32]
L5751:
    test      %rbx,	%rbx
    jnz       L5750
L5741:
L5738:
    mov       %rdi,	[%rdi+32]
L5736:
    test      %rdi,	%rdi
    jnz       L5735
    lea       %rcx,	[%rip+L8722]
    call      pc_api.gencomment
    mov       %rax,	[%rip+cc_decls.stmodule]
    mov       %rdi,	[%rax+16]
    jmp       L5763
L5762:
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	6
    jnz       L5767
L5766:
    mov       %rax,	[%rdi+72]
    test      %rax,	%rax
    jz        L5769
    mov       %rcx,	%rdi
    call      cc_genpcl.genprocdef
L5769:
L5767:
L5765:
    mov       %rdi,	[%rdi+32]
L5763:
    test      %rdi,	%rdi
    jnz       L5762
    call      pc_api.pcl_end
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_genpcl.genprocdef
cc_genpcl.genprocdef:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
    xor       %rsi,	%rsi
    mov       %rax,	[%r12]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8723]
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L5772
    mov       %rsi,	1
    lea       %rax,	[%r12+108]
    or        byte ptr[%rax],	8
L5772:
    mov       [%rip+cc_decls.currproc],	%r12
    mov       %rcx,	%r12
    call      cc_libpcl.getpsymbol
    mov       %r10,	%rax
    mov       %rbx,	%r10
    mov       %rcx,	%rax
    xor       %edx,	%edx
    mov       %r8,	%rsi
    xor       %r9d,	%r9d
    call      pc_api.pc_defproc
    mov       %rax,	[%r12+80]
    movsx     %rax,	word ptr[%rax+22]
    cmp       %rax,	3
    setz      %al
    movzx     %eax,	%al
    mov       [%rbx+113],	%al
    mov       %rdi,	[%r12+16]
    jmp       L5776
L5773:
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	9
    jz        L5778
    cmp       %rax,	8
    jz        L5779
    jmp       L5780
L5778:
    mov       %rcx,	%rdi
    call      cc_libpcl.getpsymbol
    mov       %rcx,	%rax
    call      pc_api.pc_addparam
    jmp       L5777
L5779:
    mov       %rcx,	%rdi
    call      cc_libpcl.getpsymbol
    mov       %rcx,	%rax
    call      pc_api.pc_addlocal
L5780:
L5777:
    mov       %rdi,	[%rdi+32]
L5776:
    test      %rdi,	%rdi
    jnz       L5773
    call      cc_libpcl.createfwdlabel
    mov       [%rip+cc_genpcl.retindex],	%rax
    lea       %rcx,	[%rip+L8724]
    call      pc_api.gencomment
    mov       %rcx,	[%r12+72]
    call      cc_blockpcl.do_stmt
    lea       %rcx,	[%rip+L8724]
    call      pc_api.gencomment
    test      %rsi,	%rsi
    jz        L5782
    mov       %al,	[%rip+pepcl.pdcc]
    test      %al,	%al
    jz        L5782
    xor       %ecx,	%ecx
    call      pc_api.genint
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	3
    call      cc_libpcl.setmode
    mov       %rcx,	[%rip+cc_genpcl.retindex]
    call      pc_api.genlabel
    mov       %rcx,	29
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	3
    call      cc_libpcl.setmode
L5782:
    mov       %rcx,	[%rip+cc_genpcl.retindex]
    call      cc_libpcl.definefwdlabel
    test      %rsi,	%rsi
    jz        L5784
    mov       %al,	[%rip+pepcl.pdcc]
    test      %al,	%al
    jnz       L5784
    xor       %ecx,	%ecx
    call      pc_api.genint
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	3
    call      cc_libpcl.setmode
    mov       %rcx,	32
    xor       %edx,	%edx
    call      pc_api.pc_gen
L5784:
    movzx     %rax,	word ptr[%r12+102]
    test      %rax,	%rax
    jz        L5786
    mov       %rax,	23
    jmp       L5785
L5786:
    mov       %rax,	20
L5785:
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      pc_api.pc_gen
    movzx     %rax,	word ptr[%r12+102]
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    call      pc_api.pc_endproc
    lea       %rcx,	[%rip+L8725]
    call      pc_api.gencomment
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_genpcl.dostaticvar
cc_genpcl.dostaticvar:
#?>>
    .set cc_genpcl.dostaticvar.str, -256
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	288
    mov       %r12,	%rcx
#---------------
    movzx     %rax,	byte ptr[%r12+110]
    cmp       %rax,	3
    jz        L5787
L5789:
    movzx     %rax,	word ptr[%r12+102]
    mov       %rcx,	%rax
    call      cc_lib.getalignment
    mov       %rdi,	%rax
    mov       %rax,	[%r12+72]
    test      %rax,	%rax
    jz        L5791
    movzx     %rax,	byte ptr[%r12+109]
    cmp       %rax,	8
    jnz       L5793
    lea       %rcx,	[%rbp + cc_genpcl.dostaticvar.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8726]
    call      msys.m$print_setfmt
    mov       %rax,	[%r12+8]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    mov       %rcx,	[%r12]
    call      msys.m$print_str_nf
    movzx     %rax,	word ptr[%r12+96]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + cc_genpcl.dostaticvar.str]
    call      cc_lex.addnamestr
    xor       %ecx,	%ecx
    mov       %rdx,	%rax
    mov       %r8,	7
    call      cc_lib.createdupldef
    mov       %rbx,	%rax
    mov       %rcx,	%rbx
    call      cc_libpcl.getpsymbol
    mov       %rsi,	%rax
    mov       [%r12+114],	%rsi
    mov       %rcx,	%rsi
    call      pc_api.genmem
    mov       %rcx,	123
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    jmp       L5792
L5793:
    mov       %rcx,	%r12
    call      cc_libpcl.genmem_d
    mov       %rcx,	123
    mov       %rdx,	%rax
    call      pc_api.pc_gen
L5792:
    movzx     %rax,	word ptr[%r12+102]
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    mov       %rcx,	%rdi
    call      pc_api.pc_setalign
    mov       %rax,	[%r12+72]
    mov       %rcx,	%rax
    mov       %rdx,	1
    mov       %r8,	1
    xor       %r9d,	%r9d
    call      cc_genpcl.genidata
    jmp       L5790
L5791:
    mov       %rcx,	%r12
    call      cc_libpcl.genmem_d
    mov       %rcx,	124
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    movzx     %rax,	word ptr[%r12+102]
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    mov       %rcx,	%rdi
    call      pc_api.pc_setalign
L5790:
L5787:
#---------------
    add       %rsp,	288
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_genpcl.genidata
cc_genpcl.genidata:
#?>>
    .set cc_genpcl.genidata.p, 64
    .set cc_genpcl.genidata.doterm, 72
    .set cc_genpcl.genidata.am, 80
    .set cc_genpcl.genidata.offset, 88
    .set cc_genpcl.genidata.size, -8
    .set cc_genpcl.genidata.padding, -16
    .set cc_genpcl.genidata.isunion, -24
    .set cc_genpcl.genidata.q, -32
    .set cc_genpcl.genidata.a, -40
    .set cc_genpcl.genidata.b, -48
    .set cc_genpcl.genidata.d, -56
    .set cc_genpcl.genidata.sx, -64
    .set cc_genpcl.genidata.str, -320
    .set cc_genpcl.genidata.str2, -336
    .set cc_genpcl.genidata.av_1, -344
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	384
    mov       [%rbp+64],	%rcx
    mov       [%rbp+88],	%r9
#---------------
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    movsxd    %rax,	dword ptr[%rax+52]
    mov       %rdi,	%rax
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    mov       %rax,	[%rax+16]
    mov       [%rbp + cc_genpcl.genidata.a],	%rax
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    mov       %rax,	[%rax+24]
    mov       [%rbp + cc_genpcl.genidata.b],	%rax
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	28
    jz        L5796
    cmp       %rax,	1
    jz        L5797
    cmp       %rax,	3
    jz        L5798
    cmp       %rax,	5
    jz        L5798
    cmp       %rax,	39
    jz        L5799
    cmp       %rax,	55
    jz        L5800
    cmp       %rax,	53
    jz        L5801
    cmp       %rax,	54
    jz        L5801
    cmp       %rax,	56
    jz        L5802
    jmp       L5803
L5796:
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    movsxd    %rax,	dword ptr[%rax+48]
    mov       %rsi,	%rax
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jnz       L5805
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%rdi
    mov       %rbx,	[%rax + %r10*8]
    mov       %rax,	[%rbp + cc_genpcl.genidata.a]
    mov       [%rbp + cc_genpcl.genidata.q],	%rax
    mov       %r12,	1
    cmp       %rsi,	1
    jl        L5808
L5806:
    mov       %rcx,	[%rbp + cc_genpcl.genidata.q]
    mov       %rdx,	1
    mov       %r8,	1
    xor       %r9d,	%r9d
    call      cc_genpcl.genidata
    mov       %rax,	[%rbp + cc_genpcl.genidata.q]
    mov       %rax,	[%rax+8]
    mov       [%rbp + cc_genpcl.genidata.q],	%rax
    inc       %r12
    cmp       %r12,	%rsi
    jle       L5806
L5808:
    cmp       %rsi,	%rbx
    jge       L5810
    mov       %rax,	%rbx
    sub       %rax,	%rsi
    lea       %r10,	[%rip+cc_decls.tttarget]
    mov       %r11,	%rdi
    movsx     %r10,	word ptr[%r10 + %r11*2]
    lea       %r11,	[%rip+cc_decls.ttsize]
    mov       %r11,	[%r11 + %r10*8]
    imul      %rax,	%r11
    mov       %rcx,	%rax
    call      cc_genpcl.doresb
L5810:
    jmp       L5804
L5805:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	19
    setz      %al
    movzx     %eax,	%al
    mov       [%rbp + cc_genpcl.genidata.isunion],	%rax
    lea       %rax,	[%rip+cc_decls.ttnamedef]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    mov       %rax,	[%rax+16]
    mov       [%rbp + cc_genpcl.genidata.d],	%rax
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    mov       [%rbp + cc_genpcl.genidata.size],	%rax
    xor       %eax,	%eax
    mov       %r14,	%rax
    mov       %r13,	%rax
    mov       %rax,	[%rbp + cc_genpcl.genidata.a]
    mov       [%rbp + cc_genpcl.genidata.q],	%rax
    mov       %r12,	1
    cmp       %rsi,	1
    jl        L5813
L5811:
    mov       %rcx,	[%rbp + cc_genpcl.genidata.q]
    xor       %edx,	%edx
    mov       %r8,	1
    xor       %r9d,	%r9d
    call      cc_genpcl.genidata
    mov       %rax,	[%rbp + cc_genpcl.genidata.q]
    movsxd    %rax,	dword ptr[%rax+52]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r10,	[%r10 + %rax*8]
    add       %r13,	%r10
    mov       %rax,	[%rbp + cc_genpcl.genidata.d]
    mov       %rax,	[%rax+32]
    mov       [%rbp + cc_genpcl.genidata.d],	%rax
    mov       %rax,	[%rbp + cc_genpcl.genidata.d]
    test      %rax,	%rax
    jz        L5815
    mov       %rax,	[%rbp + cc_genpcl.genidata.isunion]
    test      %rax,	%rax
    jnz       L5815
    mov       %rax,	[%rbp + cc_genpcl.genidata.d]
    movsxd    %rax,	dword ptr[%rax+88]
    mov       %r14,	%rax
    jmp       L5814
L5815:
    mov       %r14,	[%rbp + cc_genpcl.genidata.size]
L5814:
    mov       %rax,	%r14
    sub       %rax,	%r13
    mov       [%rbp + cc_genpcl.genidata.padding],	%rax
    mov       %rax,	[%rbp + cc_genpcl.genidata.padding]
    cmp       %rax,	0
    jle       L5817
    mov       %rax,	%r14
    sub       %rax,	%r13
    mov       %rcx,	%rax
    call      cc_genpcl.doresb
    mov       %r13,	%r14
L5817:
    mov       %rax,	[%rbp + cc_genpcl.genidata.q]
    mov       %rax,	[%rax+8]
    mov       [%rbp + cc_genpcl.genidata.q],	%rax
    inc       %r12
    cmp       %r12,	%rsi
    jle       L5811
L5813:
    cmp       %r14,	[%rbp + cc_genpcl.genidata.size]
    jge       L5819
    mov       %rax,	[%rbp + cc_genpcl.genidata.size]
    sub       %rax,	%r14
    mov       %rcx,	%rax
    call      cc_genpcl.doresb
L5819:
L5804:
    jmp       L5794
L5797:
    mov       %rcx,	%rdi
    call      cc_lib.isintcc
    test      %rax,	%rax
    jnz       L5822
    mov       %rcx,	%rdi
    call      cc_lib.isrealcc
    test      %rax,	%rax
    jz        L5821
L5822:
    cmp       %rdi,	10
    jnz       L5824
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    movq      %XMM4,	[%rax]
    cvtsd2ss  %XMM4,	%XMM4
    movd      [%rbp + cc_genpcl.genidata.sx],	%XMM4
    mov       %eax,	[%rbp + cc_genpcl.genidata.sx]
    mov       %rcx,	%rax
    call      pc_api.genint
    mov       %rcx,	125
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    jmp       L5823
L5824:
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    call      pc_api.genint
    mov       %rcx,	125
    mov       %rdx,	%rax
    call      pc_api.pc_gen
L5823:
    mov       %rcx,	%rdi
    call      cc_libpcl.setmode
    jmp       L5820
L5821:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	13
    jnz       L5825
    xor       %eax,	%eax
    mov       [%rbp + cc_genpcl.genidata.padding],	%rax
#cc_genpcl.genidata.doref:
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    mov       %rax,	[%rax]
    test      %rax,	%rax
    jnz       L5828
    xor       %ecx,	%ecx
    call      pc_api.genint
    mov       %rcx,	125
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    jmp       L5827
L5828:
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    mov       %al,	[%rax+61]
    test      %al,	%al
    jz        L5829
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    movsxd    %rax,	dword ptr[%rax+48]
    mov       %r10,	[%rbp + cc_genpcl.genidata.p]
    mov       %r10,	[%r10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      pc_api.genstring
    mov       %rcx,	125
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    jmp       L5827
L5829:
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    mov       %al,	[%rax+62]
    test      %al,	%al
    jz        L5830
    lea       %rcx,	[%rip+L8727]
    xor       %edx,	%edx
    call      cc_support.gerror
    mov       %rcx,	[%rbp + cc_genpcl.genidata.padding]
    call      cc_genpcl.doresb
    jmp       L5827
L5830:
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    call      pc_api.genint
    mov       %rcx,	125
    mov       %rdx,	%rax
    call      pc_api.pc_gen
L5827:
    mov       %rcx,	%rdi
    call      cc_libpcl.setmode
    jmp       L5820
L5825:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jnz       L5831
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    mov       %r10,	[%rbp + cc_genpcl.genidata.p]
    movsxd    %r10,	dword ptr[%r10+48]
    sub       %rax,	%r10
    lea       %r10,	[%rip+cc_decls.tttarget]
    mov       %r11,	%rdi
    movsx     %r10,	word ptr[%r10 + %r11*2]
    lea       %r11,	[%rip+cc_decls.ttsize]
    mov       %r11,	[%r11 + %r10*8]
    imul      %rax,	%r11
    mov       [%rbp + cc_genpcl.genidata.padding],	%rax
    mov       %r12,	1
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    movsxd    %rax,	dword ptr[%rax+48]
    mov       [%rbp + cc_genpcl.genidata.av_1],	%rax
    mov       %rax,	[%rbp + cc_genpcl.genidata.av_1]
    cmp       %rax,	1
    jl        L5834
L5832:
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    mov       %rax,	[%rax]
    mov       %r10,	%r12
    lea       %rax,	[%rax + %r10]
    sub       %rax,	1
    movzx     %rax,	byte ptr[%rax]
    mov       %rcx,	%rax
    call      pc_api.genint
    mov       %rcx,	125
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	6
    call      cc_libpcl.setmode
    inc       %r12
    cmp       %r12,	[%rbp + cc_genpcl.genidata.av_1]
    jle       L5832
L5834:
    mov       %rcx,	[%rbp + cc_genpcl.genidata.padding]
    call      cc_genpcl.doresb
    jmp       L5820
L5831:
    call      msys.m$print_startcon
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8728]
    xor       %edx,	%edx
    call      cc_support.gerror
L5820:
    jmp       L5794
L5798:
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    mov       %rax,	[%rax]
    mov       [%rbp + cc_genpcl.genidata.d],	%rax
    mov       %rax,	[%rbp + cc_genpcl.genidata.d]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	7
    jz        L5836
    cmp       %rax,	6
    jnz       L5837
L5836:
    mov       %rcx,	[%rbp + cc_genpcl.genidata.d]
    call      cc_libpcl.genmemaddr_d
    mov       %rcx,	125
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %eax,	1
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+16],	%eax
    mov       %eax,	[%rbp + cc_genpcl.genidata.offset]
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+20],	%eax
    mov       %rcx,	9
    call      cc_libpcl.setmode
    jmp       L5835
L5837:
    lea       %rcx,	[%rip+L8729]
    mov       %rdx,	[%rbp + cc_genpcl.genidata.p]
    call      cc_support.gerror
L5835:
    jmp       L5794
L5799:
    mov       %rax,	[%rbp + cc_genpcl.genidata.a]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	3
    jnz       L5839
    mov       %rax,	[%rbp + cc_genpcl.genidata.b]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5839
    mov       %rax,	[%rbp + cc_genpcl.genidata.a]
    mov       %rax,	[%rax]
    mov       [%rbp + cc_genpcl.genidata.d],	%rax
    mov       %rax,	[%rbp + cc_genpcl.genidata.d]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	7
    jnz       L5842
L5841:
    lea       %rcx,	[%rbp + cc_genpcl.genidata.str]
    lea       %rdx,	[%rip+L8730]
    call      strcpy
    mov       %rax,	[%rbp + cc_genpcl.genidata.d]
    movzx     %rax,	byte ptr[%rax+110]
    cmp       %rax,	1
    jnz       L5844
    mov       %rax,	[%rip+cc_decls.currproc]
    mov       %rax,	[%rax]
    lea       %rcx,	[%rbp + cc_genpcl.genidata.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rcx,	[%rbp + cc_genpcl.genidata.str]
    lea       %rdx,	[%rip+L8731]
    call      strcat
L5844:
    mov       %rax,	[%rbp + cc_genpcl.genidata.d]
    mov       %rax,	[%rax]
    lea       %rcx,	[%rbp + cc_genpcl.genidata.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rcx,	[%rbp + cc_genpcl.genidata.str]
    lea       %rdx,	[%rip+L8732]
    call      strcat
    mov       %rax,	[%rbp + cc_genpcl.genidata.b]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    lea       %rdx,	[%rbp + cc_genpcl.genidata.str2]
    call      msys.getstrint
    lea       %rcx,	[%rbp + cc_genpcl.genidata.str]
    lea       %rdx,	[%rbp + cc_genpcl.genidata.str2]
    call      strcat
    lea       %rcx,	[%rbp + cc_genpcl.genidata.str]
    call      pc_api.genname
    mov       %rcx,	125
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    jmp       L5840
L5842:
    lea       %rcx,	[%rip+L8733]
    xor       %edx,	%edx
    call      cc_support.gerror
L5840:
    jmp       L5838
L5839:
    mov       %rax,	[%rbp + cc_genpcl.genidata.a]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5845
    mov       %rax,	[%rbp + cc_genpcl.genidata.b]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5845
    mov       %rax,	[%rbp + cc_genpcl.genidata.a]
    movsxd    %rax,	dword ptr[%rax+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    cmp       %r10,	13
    jnz       L5845
    lea       %rcx,	[%rbp + cc_genpcl.genidata.str]
    call      msys.m$print_startstr
    mov       %rax,	[%rbp + cc_genpcl.genidata.a]
    mov       %rcx,	[%rax]
    call      msys.m$print_i64_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L8734]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       %rax,	[%rbp + cc_genpcl.genidata.b]
    mov       %rcx,	[%rax]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + cc_genpcl.genidata.str]
    call      pc_api.genname
    mov       %rcx,	125
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    jmp       L5838
L5845:
    lea       %rcx,	[%rip+L8735]
    xor       %edx,	%edx
    call      cc_support.gerror
L5838:
    jmp       L5794
L5800:
    mov       %rax,	[%rbp + cc_genpcl.genidata.a]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	52
    jnz       L5847
    mov       %rax,	[%rbp + cc_genpcl.genidata.a]
    mov       %rax,	[%rax+16]
    mov       %rcx,	%rax
    mov       %rdx,	1
    mov       %r8,	1
    mov       %r9,	[%rbp + cc_genpcl.genidata.offset]
    call      cc_genpcl.genidata
    jmp       L5846
L5847:
    mov       %rcx,	[%rbp + cc_genpcl.genidata.a]
    mov       %rdx,	1
    xor       %r8d,	%r8d
    mov       %r9,	[%rbp + cc_genpcl.genidata.offset]
    call      cc_genpcl.genidata
L5846:
    jmp       L5795
L5801:
    mov       %rax,	[%rbp + cc_genpcl.genidata.b]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jz        L5849
    lea       %rcx,	[%rip+L8736]
    xor       %edx,	%edx
    call      cc_support.gerror
L5849:
    mov       %rax,	[%rbp + cc_genpcl.genidata.b]
    mov       %rax,	[%rax]
    mov       %r10,	[%rbp + cc_genpcl.genidata.p]
    movsxd    %r10,	dword ptr[%r10]
    imul      %rax,	%r10
    add       %rax,	[%rbp + cc_genpcl.genidata.offset]
    mov       %rcx,	[%rbp + cc_genpcl.genidata.a]
    mov       %rdx,	1
    mov       %r8,	1
    mov       %r9,	%rax
    call      cc_genpcl.genidata
    jmp       L5795
L5802:
    mov       %rcx,	[%rbp + cc_genpcl.genidata.a]
    mov       %rdx,	1
    mov       %r8,	1
    mov       %r9,	[%rbp + cc_genpcl.genidata.offset]
    call      cc_genpcl.genidata
    jmp       L5795
L5803:
    xor       %ecx,	%ecx
    mov       %rdx,	[%rbp + cc_genpcl.genidata.p]
    xor       %r8d,	%r8d
    lea       %r9,	[%rip+L8737]
    call      cc_show.printunit
    lea       %rcx,	[%rip+L8738]
    mov       %rdx,	[%rbp + cc_genpcl.genidata.p]
    call      cc_support.gerror
L5795:
L5794:
#---------------
    add       %rsp,	384
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_genpcl.doresb
cc_genpcl.doresb:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    jmp       L5852
L5851:
    xor       %ecx,	%ecx
    call      pc_api.genint
    mov       %rcx,	125
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rax,	8
    sub       %rbx,	%rax
    mov       %rcx,	9
    call      cc_libpcl.setmode
L5852:
    cmp       %rbx,	8
    jge       L5851
    mov       %rdi,	%rbx
    cmp       %rdi,	0
    jle       L5856
L5854:
    xor       %ecx,	%ecx
    call      pc_api.genint
    mov       %rcx,	125
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	6
    call      cc_libpcl.setmode
    dec       %rdi
    jnz       L5854
L5856:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_genpcl.pushint
cc_genpcl.pushint:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      pc_api.genint
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_genpcl.dolibs
cc_genpcl.dolibs:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rdi,	1
    mov       %rax,	[%rip+cc_decls.nlibfiles]
    cmp       %rax,	1
    jl        L5861
L5859:
    lea       %rax,	[%rip+cc_decls.libfiles]
    mov       %r10,	%rdi
    mov       %rcx,	[%rax + %r10*8]
    call      pc_api.pc_addplib
    inc       %rdi
    cmp       %rdi,	[%rip+cc_decls.nlibfiles]
    jle       L5859
L5861:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.do_stmt
cc_blockpcl.do_stmt:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
    test      %r12,	%r12
    jnz       L5864
    jmp       L5862
L5864:
    mov       %rdi,	[%rip+cc_decls.clineno]
    mov       %eax,	[%r12+44]
    mov       [%rip+cc_decls.clineno],	%rax
    movzx     %rax,	byte ptr[%r12+60]
    mov       [%rip+cc_decls.cfileno],	%rax
    mov       %rax,	[%rip+cc_decls.cfileno]
    shl       %rax,	24
    add       %rax,	[%rip+cc_decls.clineno]
    mov       [%rip+pc_decls.mmpos],	%rax
    mov       %rbx,	[%r12+16]
    mov       %rsi,	[%r12+24]
    movsxd    %rax,	dword ptr[%r12+40]
    sub       %rax,	6
    cmp       %rax,	69
    jae       L5867
    lea       %r10,	[%rip+L5866]
    jmp       [%r10 + %rax*8]
    .data
L5866:
    .quad     L5868
    .quad     L5867
    .quad     L5872
    .quad     L5874
    .quad     L5867
    .quad     L5875
    .quad     L5876
    .quad     L5877
    .quad     L5878
    .quad     L5879
    .quad     L5880
    .quad     L5881
    .quad     L5882
    .quad     L5883
    .quad     L5885
    .quad     L5886
    .quad     L5887
    .quad     L5884
    .quad     L5867
    .quad     L5867
    .quad     L5867
    .quad     L5867
    .quad     L5867
    .quad     L5902
    .quad     L5873
    .quad     L5876
    .quad     L5867
    .quad     L5867
    .quad     L5867
    .quad     L5867
    .quad     L5867
    .quad     L5867
    .quad     L5867
    .quad     L5867
    .quad     L5867
    .quad     L5867
    .quad     L5867
    .quad     L5867
    .quad     L5867
    .quad     L5867
    .quad     L5867
    .quad     L5867
    .quad     L5867
    .quad     L5867
    .quad     L5867
    .quad     L5867
    .quad     L5867
    .quad     L5867
    .quad     L5867
    .quad     L5867
    .quad     L5867
    .quad     L5867
    .quad     L5867
    .quad     L5867
    .quad     L5867
    .quad     L5888
    .quad     L5889
    .quad     L5890
    .quad     L5891
    .quad     L5894
    .quad     L5895
    .quad     L5896
    .quad     L5897
    .quad     L5898
    .quad     L5899
    .quad     L5900
    .quad     L5901
    .quad     L5900
    .quad     L5901
    .text
L5868:
    jmp       L5870
L5869:
    mov       %rcx,	%rbx
    call      cc_blockpcl.do_stmt
    mov       %rbx,	[%rbx+8]
L5870:
    test      %rbx,	%rbx
    jnz       L5869
    jmp       L5865
L5872:
    mov       %rcx,	[%r12]
    call      cc_blockpcl.do_decl
    jmp       L5865
L5873:
    mov       %rcx,	%r12
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    xor       %r9d,	%r9d
    call      cc_blockpcl.dx_call
    jmp       L5865
L5874:
    mov       %rcx,	%r12
    mov       %rdx,	%rbx
    call      cc_blockpcl.do_return
    jmp       L5865
L5875:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    xor       %r8d,	%r8d
    call      cc_blockpcl.do_assign
    jmp       L5865
L5876:
    mov       %rax,	[%r12+32]
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	%rax
    call      cc_blockpcl.do_if
    jmp       L5865
L5877:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      cc_blockpcl.do_for
    jmp       L5865
L5878:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      cc_blockpcl.do_while
    jmp       L5865
L5879:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      cc_blockpcl.do_dowhile
    jmp       L5865
L5880:
    mov       %rcx,	[%r12]
    call      cc_blockpcl.do_goto
    jmp       L5865
L5881:
    mov       %rcx,	[%r12]
    call      cc_blockpcl.do_labeldef
    mov       %rcx,	%rbx
    call      cc_blockpcl.do_stmt
    jmp       L5865
L5882:
    mov       %rcx,	%r12
    mov       %rdx,	%rbx
    call      cc_blockpcl.do_casestmt
    jmp       L5865
L5883:
    mov       %al,	1
    mov       [%rip+cc_blockpcl.sw_defaultseen],	%al
    mov       %rcx,	[%rip+cc_blockpcl.sw_defaultlabel]
    call      pc_api.genlabel
    mov       %rcx,	127
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	%rbx
    call      cc_blockpcl.do_stmt
    jmp       L5865
L5884:
    mov       %rcx,	[%rip+cc_blockpcl.sw_breaklabel]
    call      cc_blockpcl.genjumpl
    jmp       L5865
L5885:
    lea       %rax,	[%rip+cc_blockpcl.breakstack]
    mov       %r10,	[%rip+cc_blockpcl.loopindex]
    mov       %rcx,	[%rax + %r10*8-8]
    call      cc_blockpcl.genjumpl
    jmp       L5865
L5886:
    lea       %rax,	[%rip+cc_blockpcl.continuestack]
    mov       %r10,	[%rip+cc_blockpcl.loopindex]
    mov       %rcx,	[%rax + %r10*8-8]
    call      cc_blockpcl.genjumpl
    jmp       L5865
L5887:
    mov       %rcx,	%r12
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      cc_blockpcl.do_switch
    jmp       L5865
L5888:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	90
    xor       %r9d,	%r9d
    call      cc_blockpcl.dx_binto
    jmp       L5865
L5889:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	91
    xor       %r9d,	%r9d
    call      cc_blockpcl.dx_binto
    jmp       L5865
L5890:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	92
    xor       %r9d,	%r9d
    call      cc_blockpcl.dx_binto
    jmp       L5865
L5891:
    movsxd    %rax,	dword ptr[%rbx+52]
    mov       %rcx,	%rax
    call      cc_lib.isrealcc
    test      %rax,	%rax
    jz        L5893
    mov       %rax,	93
    jmp       L5892
L5893:
    mov       %rax,	94
L5892:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      cc_blockpcl.dx_binto
    jmp       L5865
L5894:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	95
    xor       %r9d,	%r9d
    call      cc_blockpcl.dx_binto
    jmp       L5865
L5895:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	96
    xor       %r9d,	%r9d
    call      cc_blockpcl.dx_binto
    jmp       L5865
L5896:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	97
    xor       %r9d,	%r9d
    call      cc_blockpcl.dx_binto
    jmp       L5865
L5897:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	98
    xor       %r9d,	%r9d
    call      cc_blockpcl.dx_binto
    jmp       L5865
L5898:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	99
    xor       %r9d,	%r9d
    call      cc_blockpcl.dx_binto
    jmp       L5865
L5899:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	100
    xor       %r9d,	%r9d
    call      cc_blockpcl.dx_binto
    jmp       L5865
L5900:
    mov       %rcx,	%rbx
    mov       %rdx,	84
    call      cc_blockpcl.do_preincr
    jmp       L5865
L5901:
    mov       %rcx,	%rbx
    mov       %rdx,	85
    call      cc_blockpcl.do_preincr
    jmp       L5865
L5902:
    jmp       L5904
L5903:
    mov       %rcx,	%rbx
    call      cc_blockpcl.do_stmt
    mov       %rbx,	[%rbx+8]
L5904:
    test      %rbx,	%rbx
    jnz       L5903
    jmp       L5865
L5867:
    mov       %rcx,	%r12
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	11
    xor       %edx,	%edx
    call      pc_api.pc_gen
    test      %rbx,	%rbx
    jz        L5907
    mov       %rax,	%rbx
    jmp       L5906
L5907:
    mov       %rax,	%r12
L5906:
    mov       %rcx,	%rax
    call      cc_libpcl.setmode_u
L5865:
L5862:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_expr
cc_blockpcl.dx_expr:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r13,	%rcx
    mov       %r14,	%rdx
#---------------
    test      %r13,	%r13
    jnz       L5910
    jmp       L5908
L5910:
    mov       %rdi,	[%rip+cc_decls.clineno]
    mov       %eax,	[%r13+44]
    mov       [%rip+cc_decls.clineno],	%rax
    movzx     %rax,	byte ptr[%r13+60]
    mov       [%rip+cc_decls.cfileno],	%rax
    mov       %rsi,	[%r13+16]
    mov       %r12,	[%r13+24]
    movsxd    %rax,	dword ptr[%r13+52]
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%r13+40]
    sub       %rax,	1
    cmp       %rax,	76
    jae       L5913
    lea       %r10,	[%rip+L5912]
    jmp       [%r10 + %rax*8]
    .data
L5912:
    .quad     L5914
    .quad     L5913
    .quad     L5915
    .quad     L5916
    .quad     L5917
    .quad     L5913
    .quad     L5913
    .quad     L5913
    .quad     L5913
    .quad     L5913
    .quad     L5918
    .quad     L5913
    .quad     L5913
    .quad     L5913
    .quad     L5913
    .quad     L5913
    .quad     L5913
    .quad     L5913
    .quad     L5913
    .quad     L5913
    .quad     L5913
    .quad     L5913
    .quad     L5913
    .quad     L5919
    .quad     L5919
    .quad     L5920
    .quad     L5927
    .quad     L5913
    .quad     L5930
    .quad     L5941
    .quad     L5942
    .quad     L5913
    .quad     L5943
    .quad     L5943
    .quad     L5943
    .quad     L5943
    .quad     L5943
    .quad     L5943
    .quad     L5944
    .quad     L5947
    .quad     L5948
    .quad     L5949
    .quad     L5952
    .quad     L5953
    .quad     L5954
    .quad     L5955
    .quad     L5956
    .quad     L5957
    .quad     L5980
    .quad     L5913
    .quad     L5913
    .quad     L5958
    .quad     L5959
    .quad     L5960
    .quad     L5979
    .quad     L5961
    .quad     L5964
    .quad     L5965
    .quad     L5913
    .quad     L5966
    .quad     L5969
    .quad     L5970
    .quad     L5971
    .quad     L5972
    .quad     L5973
    .quad     L5974
    .quad     L5975
    .quad     L5976
    .quad     L5977
    .quad     L5978
    .quad     L5967
    .quad     L5967
    .quad     L5968
    .quad     L5968
    .quad     L5981
    .quad     L5982
    .text
L5914:
    mov       %rcx,	%r13
    call      cc_blockpcl.dx_const
    jmp       L5911
L5915:
    mov       %rcx,	%r13
    mov       %rdx,	%r14
    call      cc_blockpcl.dx_name
    jmp       L5911
L5916:
    mov       %rcx,	%rsi
    mov       %rdx,	%r14
    call      cc_blockpcl.dx_expr
    jmp       L5911
L5917:
    mov       %rax,	[%r13]
    mov       %rcx,	%rax
    call      cc_libpcl.genmemaddr_d
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	9
    call      cc_libpcl.setmode
    jmp       L5911
L5918:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	1
    call      cc_blockpcl.do_assign
    jmp       L5911
L5919:
    mov       %rcx,	%r13
    call      cc_blockpcl.dx_andorl
    jmp       L5911
L5920:
    movsxd    %rax,	dword ptr[%rsi+40]
    cmp       %rax,	26
    jnz       L5922
    mov       %rax,	[%rsi+16]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rax,	[%rsi+16]
    mov       %rcx,	%rax
    call      cc_blockpcl.isboolexpr
    test      %rax,	%rax
    jnz       L5924
    mov       %rcx,	64
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	8
    call      cc_libpcl.setmode
    mov       %rax,	[%rsi+16]
    movsxd    %rax,	dword ptr[%rax+52]
    mov       %rcx,	%rax
    call      cc_libpcl.setmode2
L5924:
    jmp       L5921
L5922:
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	%rsi
    call      cc_blockpcl.isboolexpr
    test      %rax,	%rax
    jnz       L5926
    mov       %rcx,	65
    xor       %edx,	%edx
    call      pc_api.pc_gen
    jmp       L5925
L5926:
    mov       %rcx,	63
    xor       %edx,	%edx
    call      pc_api.pc_gen
L5925:
    mov       %rcx,	%rsi
    call      cc_libpcl.setmode_u
L5921:
    jmp       L5911
L5927:
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	%rsi
    call      cc_blockpcl.isboolexpr
    test      %rax,	%rax
    jnz       L5929
    mov       %rcx,	64
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	8
    call      cc_libpcl.setmode
    movsxd    %rax,	dword ptr[%rsi+52]
    mov       %rcx,	%rax
    call      cc_libpcl.setmode2
L5929:
    jmp       L5911
L5930:
    jmp       L5934
L5931:
    mov       %r12,	[%rsi+8]
    test      %r12,	%r12
    jz        L5936
    movsxd    %rax,	dword ptr[%rsi+40]
    cmp       %rax,	11
    jz        L5937
    cmp       %rax,	56
    jz        L5937
    cmp       %rax,	31
    jnz       L5936
L5937:
    mov       %rcx,	%rsi
    call      cc_blockpcl.do_stmt
    jmp       L5935
L5936:
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    test      %r12,	%r12
    jz        L5939
    movsxd    %rax,	dword ptr[%rsi+52]
    test      %rax,	%rax
    jnz       L5940
    movsxd    %rax,	dword ptr[%rsi+40]
    cmp       %rax,	56
    jnz       L5939
L5940:
    mov       %rcx,	134
    xor       %edx,	%edx
    call      pc_api.pc_gen
L5939:
L5935:
    mov       %rsi,	%r12
L5934:
    test      %rsi,	%rsi
    jnz       L5931
    jmp       L5911
L5941:
    mov       %rcx,	%r13
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    mov       %r9,	1
    call      cc_blockpcl.dx_call
    jmp       L5911
L5942:
    mov       %rax,	[%r13+32]
    mov       %rcx,	%r13
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    mov       %r9,	%rax
    call      cc_blockpcl.dx_ifx
    jmp       L5911
L5943:
    mov       %rcx,	%r13
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      cc_blockpcl.dx_eq
    jmp       L5911
L5944:
    movsxd    %rax,	dword ptr[%rsi+52]
    lea       %r10,	[%rip+cc_decls.ttisref]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L5946
    movsxd    %rax,	dword ptr[%r12+52]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r10,	[%r10 + %rax*8]
    cmp       %r10,	4
    jg        L5946
    mov       %eax,	9
    mov       [%r12+52],	%eax
L5946:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	43
    call      cc_blockpcl.dx_bin
    jmp       L5911
L5947:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	44
    call      cc_blockpcl.dx_bin
    jmp       L5911
L5948:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	45
    call      cc_blockpcl.dx_bin
    jmp       L5911
L5949:
    movsxd    %rax,	dword ptr[%rsi+52]
    mov       %rcx,	%rax
    call      cc_lib.isrealcc
    test      %rax,	%rax
    jz        L5951
    mov       %rax,	46
    jmp       L5950
L5951:
    mov       %rax,	47
L5950:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	%rax
    call      cc_blockpcl.dx_bin
    jmp       L5911
L5952:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	48
    call      cc_blockpcl.dx_bin
    jmp       L5911
L5953:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	50
    call      cc_blockpcl.dx_bin
    jmp       L5911
L5954:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	51
    call      cc_blockpcl.dx_bin
    jmp       L5911
L5955:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	52
    call      cc_blockpcl.dx_bin
    jmp       L5911
L5956:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	53
    call      cc_blockpcl.dx_bin
    jmp       L5911
L5957:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	54
    call      cc_blockpcl.dx_bin
    jmp       L5911
L5958:
    mov       %rcx,	%r13
    mov       %rdx,	%rsi
    mov       %r8,	%r14
    call      cc_blockpcl.dx_ptr
    jmp       L5911
L5959:
    sub       %rsp,	8
    mov       %rax,	%r14
    push      %rax
    mov       %rcx,	%r13
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    mov       %r9,	57
    sub       %rsp,	32
    call      cc_blockpcl.dx_addptr
    add       %rsp,	48
    jmp       L5911
L5960:
    sub       %rsp,	8
    mov       %rax,	%r14
    push      %rax
    mov       %rcx,	%r13
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    mov       %r9,	58
    sub       %rsp,	32
    call      cc_blockpcl.dx_addptr
    add       %rsp,	48
    jmp       L5911
L5961:
    movsx     %rax,	word ptr[%r13+58]
    test      %rax,	%rax
    jnz       L5963
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    jmp       L5962
L5963:
    movsxd    %rax,	dword ptr[%r13+48]
    movsx     %r10,	word ptr[%r13+58]
    mov       %rcx,	%r13
    mov       %rdx,	%rsi
    mov       %r8,	%r10
    mov       %r9,	%rax
    call      cc_blockpcl.dx_convert
L5962:
    jmp       L5911
L5964:
    mov       %rcx,	%r13
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      cc_blockpcl.dx_scale
    jmp       L5911
L5965:
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	60
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	%rsi
    call      cc_libpcl.setmode_u
    jmp       L5911
L5966:
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	62
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	%rsi
    call      cc_libpcl.setmode_u
    jmp       L5911
L5967:
    mov       %rcx,	%r13
    mov       %rdx,	%rsi
    call      cc_blockpcl.dx_preincrx
    jmp       L5911
L5968:
    mov       %rcx,	%r13
    mov       %rdx,	%rsi
    call      cc_blockpcl.dx_postincrx
    jmp       L5911
L5969:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	90
    mov       %r9,	1
    call      cc_blockpcl.dx_binto
    jmp       L5911
L5970:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	91
    mov       %r9,	1
    call      cc_blockpcl.dx_binto
    jmp       L5911
L5971:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	92
    mov       %r9,	1
    call      cc_blockpcl.dx_binto
    jmp       L5911
L5972:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	93
    mov       %r9,	1
    call      cc_blockpcl.dx_binto
    jmp       L5911
L5973:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	95
    mov       %r9,	1
    call      cc_blockpcl.dx_binto
    jmp       L5911
L5974:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	96
    mov       %r9,	1
    call      cc_blockpcl.dx_binto
    jmp       L5911
L5975:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	97
    mov       %r9,	1
    call      cc_blockpcl.dx_binto
    jmp       L5911
L5976:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	98
    mov       %r9,	1
    call      cc_blockpcl.dx_binto
    jmp       L5911
L5977:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	99
    mov       %r9,	1
    call      cc_blockpcl.dx_binto
    jmp       L5911
L5978:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	100
    mov       %r9,	1
    call      cc_blockpcl.dx_binto
    jmp       L5911
L5979:
    mov       %rcx,	%r13
    mov       %rdx,	%rsi
    mov       %r8,	%r14
    call      cc_blockpcl.dx_addrof
    jmp       L5911
L5980:
    mov       %rcx,	%r13
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    mov       %r9,	%r14
    call      cc_blockpcl.dx_dot
    jmp       L5911
L5981:
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	129
    xor       %edx,	%edx
    call      pc_api.pc_gen
    jmp       L5911
L5982:
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	%r12
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	130
    xor       %edx,	%edx
    call      pc_api.pc_gen
    jmp       L5911
L5913:
    movsxd    %rax,	dword ptr[%r13+40]
    lea       %r10,	[%rip+cc_tables.jtagnames]
    mov       %r10,	[%r10 + %rax*8]
    lea       %rcx,	[%rip+L8739]
    mov       %rdx,	%r10
    xor       %r8d,	%r8d
    call      cc_support.gerror_s
L5911:
    mov       [%rip+cc_decls.clineno],	%rdi
L5908:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_const
cc_blockpcl.dx_const:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%rbx+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rdi,	%r10
    mov       %rax,	%rdi
    cmp       %rax,	1
    jl        L5985
    cmp       %rax,	9
    jg        L5985
    mov       %rax,	[%rbx]
    mov       %rcx,	%rax
    call      pc_api.genint
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    jmp       L5984
L5985:
    mov       %rax,	%rdi
    cmp       %rax,	10
    jz        L5987
    cmp       %rax,	11
    jz        L5988
    jmp       L5989
L5987:
    movq      %XMM4,	[%rbx]
    movq      %XMM0,	%XMM4
    mov       %rdx,	1
    call      pc_api.genreal
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    jmp       L5986
L5988:
    movq      %XMM4,	[%rbx]
    movq      %XMM0,	%XMM4
    mov       %rdx,	2
    call      pc_api.genreal
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    jmp       L5986
L5989:
    cmp       %rdi,	10
    jl        L5991
    cmp       %rdi,	11
    jg        L5991
    movq      %XMM4,	[%rbx]
    movq      %XMM0,	%XMM4
    mov       %rdx,	2
    call      pc_api.genreal
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    jmp       L5990
L5991:
    cmp       %rdi,	13
    jnz       L5992
    mov       %al,	[%rbx+61]
    test      %al,	%al
    jz        L5994
    movsxd    %rax,	dword ptr[%rbx+48]
    mov       %r10,	[%rbx]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      pc_api.genstring
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    jmp       L5993
L5994:
    mov       %al,	[%rbx+62]
    test      %al,	%al
    jz        L5995
    lea       %rcx,	[%rip+L8740]
    xor       %edx,	%edx
    call      cc_support.gerror
    jmp       L5993
L5995:
    mov       %rax,	[%rbx]
    mov       %rcx,	%rax
    call      pc_api.genint
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
L5993:
    jmp       L5990
L5992:
    lea       %rcx,	[%rip+L8741]
    xor       %edx,	%edx
    call      cc_support.gerror
L5990:
L5986:
L5984:
    movsxd    %rax,	dword ptr[%rbx+52]
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_name
cc_blockpcl.dx_name:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rdi,	[%rbx]
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	7
    jz        L5998
    cmp       %rax,	8
    jz        L5998
    cmp       %rax,	9
    jnz       L5999
L5998:
    test      %rsi,	%rsi
    jz        L6001
    mov       %rcx,	%rdi
    call      cc_libpcl.genmemaddr_d
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	9
    call      cc_libpcl.setmode
    jmp       L6000
L6001:
    mov       %rcx,	%rdi
    call      cc_libpcl.genmem_d
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	%rbx
    call      cc_blockpcl.widen
L6000:
    jmp       L5997
L5999:
    lea       %rcx,	[%rip+L8742]
    xor       %edx,	%edx
    call      cc_support.gerror
L5997:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_bin
cc_blockpcl.dx_bin:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    call      pc_api.pc_gen
    movsxd    %rax,	dword ptr[%rdi+52]
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_binto
cc_blockpcl.dx_binto:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
    mov       %r12,	%r9
#---------------
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      cc_blockpcl.dx_expr
    test      %r12,	%r12
    jnz       L6005
    mov       %rax,	%rsi
    cmp       %rax,	94
    jz        L6005
    cmp       %rax,	95
    jz        L6005
    call      cc_blockpcl.do_setinplace
L6005:
    test      %r12,	%r12
    jz        L6007
    mov       %rcx,	8
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	10
    mov       %rdx,	2
    mov       %r8,	3
    xor       %r9d,	%r9d
    call      pc_api.pc_genxy
L6007:
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	%rdi
    call      cc_parse.getmemmode
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    test      %r12,	%r12
    jz        L6009
    mov       %rcx,	2
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	%rdi
    call      cc_parse.getmemmode
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
L6009:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.do_assign
cc_blockpcl.do_assign:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      cc_blockpcl.do_fixwiden
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    test      %rsi,	%rsi
    jz        L6012
    mov       %rcx,	9
    xor       %edx,	%edx
    call      pc_api.pc_gen
L6012:
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	3
    jz        L6014
    cmp       %rax,	52
    jz        L6015
    cmp       %rax,	49
    jz        L6016
    jmp       L6017
L6014:
    mov       %rax,	[%rdi]
    mov       %rcx,	%rax
    call      cc_libpcl.genmem_d
    mov       %rcx,	4
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	%rdi
    call      cc_parse.getmemmode
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    jmp       L6013
L6015:
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      cc_blockpcl.dx_expr
    mov       %rcx,	5
    mov       %rdx,	1
    xor       %r8d,	%r8d
    call      pc_api.pc_genix
    mov       %rcx,	%rdi
    call      cc_parse.getmemmode
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    jmp       L6013
L6016:
    mov       %rax,	[%rdi+16]
    mov       %rcx,	%rax
    mov       %rdx,	1
    call      cc_blockpcl.dx_expr
    movsxd    %rax,	dword ptr[%rdi]
    mov       %rcx,	%rax
    call      pc_api.genint
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	9
    call      cc_libpcl.setmode
    mov       %rcx,	57
    mov       %rdx,	1
    xor       %r8d,	%r8d
    call      pc_api.pc_genix
    mov       %rcx,	1
    xor       %edx,	%edx
    call      pc_api.pc_setscaleoff
    mov       %rcx,	%rdi
    call      cc_parse.getmemmode
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    mov       %rcx,	5
    mov       %rdx,	1
    xor       %r8d,	%r8d
    call      pc_api.pc_genix
    mov       %rcx,	1
    xor       %edx,	%edx
    call      pc_api.pc_setscaleoff
    mov       %rcx,	%rdi
    call      cc_parse.getmemmode
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    jmp       L6013
L6017:
    movsxd    %rax,	dword ptr[%rdi+40]
    lea       %r10,	[%rip+cc_tables.jtagnames]
    mov       %r10,	[%r10 + %rax*8]
    lea       %rcx,	[%rip+L8743]
    mov       %rdx,	%r10
    xor       %r8d,	%r8d
    call      cc_support.gerror_s
L6013:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_ptr
cc_blockpcl.dx_ptr:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    test      %rsi,	%rsi
    jnz       L6020
    mov       %rcx,	2
    mov       %rdx,	1
    xor       %r8d,	%r8d
    call      pc_api.pc_genix
    mov       %rcx,	%rdi
    call      cc_blockpcl.widen
L6020:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_addptr
cc_blockpcl.dx_addptr:
#?>>
    .set cc_blockpcl.dx_addptr.am, 80
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
    mov       %r12,	%r9
#---------------
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	%r12
    mov       %rdx,	1
    xor       %r8d,	%r8d
    call      pc_api.pc_genix
    movsxd    %rax,	dword ptr[%rdi]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      pc_api.pc_setscaleoff
    movsxd    %rax,	dword ptr[%rbx+52]
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_addrof
cc_blockpcl.dx_addrof:
#?>>
    .set cc_blockpcl.dx_addrof.p, 24
    .set cc_blockpcl.dx_addrof.am, 40
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rdx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      cc_blockpcl.dx_expr
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_convert
cc_blockpcl.dx_convert:
#?>>
    .set cc_blockpcl.dx_convert.p, 64
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r12,	%rdx
    mov       %r13,	%r8
    mov       %r14,	%r9
#---------------
    movsxd    %rax,	dword ptr[%r12+52]
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rdi
    mov       %rbx,	[%rax + %r10*8]
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%r13
    mov       %rsi,	[%rax + %r10*8]
    mov       %rcx,	%r12
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rax,	%r14
    cmp       %rax,	1
    jz        L6025
    cmp       %rax,	2
    jz        L6026
    cmp       %rax,	3
    jz        L6027
    cmp       %rax,	4
    jz        L6027
    cmp       %rax,	5
    jz        L6028
    cmp       %rax,	6
    jz        L6028
    cmp       %rax,	7
    jz        L6029
    cmp       %rax,	8
    jz        L6029
    cmp       %rax,	9
    jz        L6030
    cmp       %rax,	10
    jz        L6031
    cmp       %rax,	11
    jz        L6032
    cmp       %rax,	12
    jz        L6032
    jmp       L6033
L6025:
    jmp       L6023
L6026:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	10
    jz        L6036
    cmp       %rax,	11
    jnz       L6035
L6036:
    lea       %rcx,	[%rip+L8744]
    xor       %edx,	%edx
    call      cc_support.gerror
L6035:
    cmp       %rsi,	%rbx
    jle       L6038
    mov       %rcx,	114
    xor       %edx,	%edx
    call      pc_api.pc_gen
    jmp       L6037
L6038:
    cmp       %rsi,	%rbx
    jl        L6040
L6039:
L6037:
    jmp       L6024
L6027:
    cmp       %rbx,	%rsi
    jz        L6023
L6042:
    mov       %rcx,	114
    xor       %edx,	%edx
    call      pc_api.pc_gen
    jmp       L6024
L6028:
    mov       %rcx,	111
    xor       %edx,	%edx
    call      pc_api.pc_gen
    jmp       L6024
L6029:
    mov       %rcx,	112
    xor       %edx,	%edx
    call      pc_api.pc_gen
    jmp       L6024
L6030:
    mov       %rcx,	115
    xor       %edx,	%edx
    call      pc_api.pc_gen
    jmp       L6024
L6031:
    mov       %rcx,	116
    xor       %edx,	%edx
    call      pc_api.pc_gen
    jmp       L6024
L6032:
#cc_blockpcl.dx_convert.dotruncate:
L6040:
    mov       %rcx,	113
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	3
    call      cc_libpcl.setmode
    mov       %rcx,	%r13
    call      cc_libpcl.setmode2
    jmp       L6023
L6033:
    lea       %rax,	[%rip+cc_tables.convnames]
    mov       %r10,	%r14
    mov       %rax,	[%rax + %r10*8]
    lea       %rcx,	[%rip+L8745]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      cc_support.gerror_s
L6024:
    mov       %rcx,	%r13
    call      cc_libpcl.setmode
    mov       %rcx,	%rdi
    call      cc_libpcl.setmode2
L6023:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.do_if
cc_blockpcl.do_if:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
    call      cc_libpcl.createfwdlabel
    mov       %rdi,	%rax
    mov       %rcx,	28
    mov       %rdx,	%rsi
    mov       %r8,	%rdi
    call      cc_blockpcl.genjumpcond
    mov       %rcx,	%r12
    call      cc_blockpcl.do_stmt
    test      %r13,	%r13
    jz        L6045
    call      cc_libpcl.createfwdlabel
    mov       %rbx,	%rax
    mov       %rcx,	%rbx
    call      cc_blockpcl.genjumpl
    mov       %rcx,	%rdi
    call      cc_libpcl.definefwdlabel
    mov       %rcx,	%r13
    call      cc_blockpcl.do_stmt
    mov       %rcx,	%rbx
    call      cc_libpcl.definefwdlabel
    jmp       L6044
L6045:
    mov       %rcx,	%rdi
    call      cc_libpcl.definefwdlabel
L6044:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.genjumpcond
cc_blockpcl.genjumpcond:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
#---------------
    mov       %rdi,	[%r13+16]
    mov       %rbx,	[%r13+24]
    movsxd    %rax,	dword ptr[%r13+40]
    sub       %rax,	24
    cmp       %rax,	15
    jae       L6049
    lea       %r10,	[%rip+L6048]
    jmp       [%r10 + %rax*8]
    .data
L6048:
    .quad     L6050
    .quad     L6055
    .quad     L6060
    .quad     L6065
    .quad     L6049
    .quad     L6067
    .quad     L6049
    .quad     L6049
    .quad     L6049
    .quad     L6066
    .quad     L6066
    .quad     L6066
    .quad     L6066
    .quad     L6066
    .quad     L6066
    .text
L6050:
    mov       %rax,	%r12
    cmp       %rax,	28
    jz        L6052
    cmp       %rax,	27
    jz        L6053
    jmp       L6054
L6052:
    mov       %rcx,	28
    mov       %rdx,	%rdi
    mov       %r8,	%r14
    call      cc_blockpcl.genjumpcond
    mov       %rcx,	28
    mov       %rdx,	%rbx
    mov       %r8,	%r14
    call      cc_blockpcl.genjumpcond
    jmp       L6051
L6053:
    call      cc_libpcl.createfwdlabel
    mov       %rsi,	%rax
    mov       %rcx,	28
    mov       %rdx,	%rdi
    mov       %r8,	%rsi
    call      cc_blockpcl.genjumpcond
    mov       %rcx,	27
    mov       %rdx,	%rbx
    mov       %r8,	%r14
    call      cc_blockpcl.genjumpcond
    mov       %rcx,	%rsi
    call      cc_libpcl.definefwdlabel
L6054:
L6051:
    jmp       L6047
L6055:
    mov       %rax,	%r12
    cmp       %rax,	28
    jz        L6057
    cmp       %rax,	27
    jz        L6058
    jmp       L6059
L6057:
    call      cc_libpcl.createfwdlabel
    mov       %rsi,	%rax
    mov       %rcx,	27
    mov       %rdx,	%rdi
    mov       %r8,	%rsi
    call      cc_blockpcl.genjumpcond
    mov       %rcx,	28
    mov       %rdx,	%rbx
    mov       %r8,	%r14
    call      cc_blockpcl.genjumpcond
    mov       %rcx,	%rsi
    call      cc_libpcl.definefwdlabel
    jmp       L6056
L6058:
    mov       %rcx,	27
    mov       %rdx,	%rdi
    mov       %r8,	%r14
    call      cc_blockpcl.genjumpcond
    mov       %rcx,	27
    mov       %rdx,	%rbx
    mov       %r8,	%r14
    call      cc_blockpcl.genjumpcond
L6059:
L6056:
    jmp       L6047
L6060:
    mov       %rax,	%r12
    cmp       %rax,	28
    jz        L6062
    cmp       %rax,	27
    jz        L6063
    jmp       L6064
L6062:
    mov       %rcx,	27
    mov       %rdx,	%rdi
    mov       %r8,	%r14
    call      cc_blockpcl.genjumpcond
    jmp       L6061
L6063:
    mov       %rcx,	28
    mov       %rdx,	%rdi
    mov       %r8,	%r14
    call      cc_blockpcl.genjumpcond
L6064:
L6061:
    jmp       L6047
L6065:
    mov       %rcx,	%r12
    mov       %rdx,	%rdi
    mov       %r8,	%r14
    call      cc_blockpcl.genjumpcond
    jmp       L6047
L6066:
    sub       %rsp,	8
    mov       %rax,	%r14
    push      %rax
    mov       %rcx,	%r12
    mov       %rdx,	%r13
    mov       %r8,	%rdi
    mov       %r9,	%rbx
    sub       %rsp,	32
    call      cc_blockpcl.gcomparejump
    add       %rsp,	48
    jmp       L6047
L6067:
    jmp       L6069
L6068:
    mov       %rcx,	%rdi
    call      cc_blockpcl.do_stmt
    mov       %rdi,	%rbx
L6069:
    test      %rdi,	%rdi
    jz        L6071
    mov       %rax,	[%rdi+8]
    mov       %rbx,	%rax
    test      %rax,	%rax
    jnz       L6068
L6071:
    mov       %rcx,	%r12
    mov       %rdx,	%rdi
    mov       %r8,	%r14
    call      cc_blockpcl.genjumpcond
    jmp       L6047
L6049:
    mov       %rcx,	%r13
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	%r14
    call      pc_api.genlabel
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	%r13
    call      cc_libpcl.setmode_u
L6047:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.gcomparejump
cc_blockpcl.gcomparejump:
#?>>
    .set cc_blockpcl.gcomparejump.lab, 88
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
    mov       %r13,	%r9
#---------------
    movsxd    %rax,	dword ptr[%rsi+40]
    mov       %rcx,	%rax
    call      cc_blockpcl.getpclcond
    mov       %rdi,	%rax
    cmp       %rbx,	28
    jnz       L6074
    mov       %rcx,	%rdi
    call      cc_blockpcl.reversecond
    mov       %rdi,	%rax
L6074:
    mov       %rcx,	%r12
    mov       %rdx,	%r13
    call      cc_blockpcl.do_fixwiden
    mov       %rcx,	%r12
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	%r13
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	[%rbp + cc_blockpcl.gcomparejump.lab]
    call      pc_api.genlabel
    mov       %rcx,	26
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %al,	%dil
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+2],	%al
    mov       %rcx,	%r12
    call      cc_libpcl.setmode_u
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.getpclcond
cc_blockpcl.getpclcond:
#?>>
#?]]
#---------------
    mov       %rax,	%rcx
    cmp       %rax,	33
    jz        L6077
    cmp       %rax,	34
    jz        L6078
    cmp       %rax,	35
    jz        L6079
    cmp       %rax,	36
    jz        L6080
    cmp       %rax,	38
    jz        L6081
    cmp       %rax,	37
    jz        L6082
    jmp       L6083
L6077:
    mov       %rax,	1
    jmp       L6075
L6078:
    mov       %rax,	2
    jmp       L6075
L6079:
    mov       %rax,	3
    jmp       L6075
L6080:
    mov       %rax,	4
    jmp       L6075
L6081:
    mov       %rax,	5
    jmp       L6075
L6082:
    mov       %rax,	6
    jmp       L6075
L6083:
L6076:
    xor       %eax,	%eax
L6075:
#---------------
    ret       
# End 
# Proc cc_blockpcl.reversecond
cc_blockpcl.reversecond:
#?>>
#?]]
#---------------
    mov       %rax,	%rcx
    cmp       %rax,	1
    jz        L6086
    cmp       %rax,	2
    jz        L6087
    cmp       %rax,	3
    jz        L6088
    cmp       %rax,	4
    jz        L6089
    cmp       %rax,	5
    jz        L6090
    cmp       %rax,	6
    jz        L6091
    jmp       L6092
L6086:
    mov       %rax,	2
    mov       %rcx,	%rax
    jmp       L6085
L6087:
    mov       %rax,	1
    mov       %rcx,	%rax
    jmp       L6085
L6088:
    mov       %rax,	5
    mov       %rcx,	%rax
    jmp       L6085
L6089:
    mov       %rax,	6
    mov       %rcx,	%rax
    jmp       L6085
L6090:
    mov       %rax,	3
    mov       %rcx,	%rax
    jmp       L6085
L6091:
    mov       %rax,	4
    mov       %rcx,	%rax
L6092:
L6085:
    mov       %rax,	%rcx
L6084:
#---------------
    ret       
# End 
# Proc cc_blockpcl.genjumpl
cc_blockpcl.genjumpl:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      pc_api.genlabel
    mov       %rcx,	24
    mov       %rdx,	%rax
    call      pc_api.pc_gen
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.do_while
cc_blockpcl.do_while:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r12,	%rcx
    mov       %r13,	%rdx
#---------------
    movsxd    %rax,	dword ptr[%r12+40]
    cmp       %rax,	1
    jnz       L6096
    mov       %rax,	[%r12]
    test      %rax,	%rax
    jz        L6096
    mov       %rcx,	%r13
    call      cc_blockpcl.do_while1
    jmp       L6094
L6096:
    call      cc_libpcl.createfwdlabel
    mov       %rbx,	%rax
    call      cc_libpcl.createfwdlabel
    mov       %rsi,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      cc_blockpcl.stacklooplabels
    mov       %rcx,	%rbx
    call      cc_blockpcl.genjumpl
    call      cc_libpcl.definelabel
    mov       %rdi,	%rax
    mov       %rcx,	%r13
    call      cc_blockpcl.do_stmt
    mov       %rcx,	%rbx
    call      cc_libpcl.definefwdlabel
    mov       %rcx,	27
    mov       %rdx,	%r12
    mov       %r8,	%rdi
    call      cc_blockpcl.genjumpcond
    mov       %rcx,	%rsi
    call      cc_libpcl.definefwdlabel
    dec       qword ptr[%rip+cc_blockpcl.loopindex]
L6094:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.do_while1
cc_blockpcl.do_while1:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
    call      cc_libpcl.createfwdlabel
    mov       %rbx,	%rax
    call      cc_libpcl.createfwdlabel
    mov       %rsi,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      cc_blockpcl.stacklooplabels
    call      cc_libpcl.definelabel
    mov       %rdi,	%rax
    mov       %rcx,	%r12
    call      cc_blockpcl.do_stmt
    mov       %rcx,	%rbx
    call      cc_libpcl.definefwdlabel
    mov       %rcx,	%rdi
    call      cc_blockpcl.genjumpl
    mov       %rcx,	%rsi
    call      cc_libpcl.definefwdlabel
    dec       qword ptr[%rip+cc_blockpcl.loopindex]
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.do_dowhile
cc_blockpcl.do_dowhile:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r12,	%rcx
    mov       %r13,	%rdx
#---------------
    call      cc_libpcl.createfwdlabel
    mov       %rbx,	%rax
    call      cc_libpcl.createfwdlabel
    mov       %rsi,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      cc_blockpcl.stacklooplabels
    call      cc_libpcl.definelabel
    mov       %rdi,	%rax
    mov       %rcx,	%r12
    call      cc_blockpcl.do_stmt
    mov       %rcx,	%rbx
    call      cc_libpcl.definefwdlabel
    mov       %rcx,	%r13
    call      cc_parse.iscondfalse
    test      %rax,	%rax
    jnz       L6100
    mov       %rcx,	27
    mov       %rdx,	%r13
    mov       %r8,	%rdi
    call      cc_blockpcl.genjumpcond
L6100:
    mov       %rcx,	%rsi
    call      cc_libpcl.definefwdlabel
    dec       qword ptr[%rip+cc_blockpcl.loopindex]
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.stacklooplabels
cc_blockpcl.stacklooplabels:
#?>>
#?]]
#---------------
    inc       qword ptr[%rip+cc_blockpcl.loopindex]
    mov       %rax,	[%rip+cc_blockpcl.loopindex]
    mov       %r10,	%rcx
    lea       %r11,	[%rip+cc_blockpcl.continuestack]
    mov       [%r11 + %rax*8-8],	%r10
    mov       %rax,	%rdx
    lea       %r10,	[%rip+cc_blockpcl.breakstack]
    mov       %r11,	[%rip+cc_blockpcl.loopindex]
    mov       [%r10 + %r11*8-8],	%rax
#---------------
    ret       
# End 
# Proc cc_blockpcl.do_return
cc_blockpcl.do_return:
#?>>
    .set cc_blockpcl.do_return.p, 24
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rdx
#---------------
    test      %rdi,	%rdi
    jz        L6104
    mov       %rax,	[%rip+cc_decls.currproc]
    movzx     %rax,	byte ptr[%rax+108]
    shr       %eax,	3
    and       %eax,	1
    test      %rax,	%rax
    jz        L6106
    mov       %al,	[%rip+pepcl.pdcc]
    test      %al,	%al
    jnz       L6106
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	32
    xor       %edx,	%edx
    call      pc_api.pc_gen
    jmp       L6105
L6106:
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	[%rip+cc_genpcl.retindex]
    call      pc_api.genlabel
    mov       %rcx,	29
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	%rdi
    call      cc_libpcl.setmode_u
L6105:
    jmp       L6103
L6104:
    mov       %rcx,	[%rip+cc_genpcl.retindex]
    call      cc_blockpcl.genjumpl
L6103:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_call
cc_blockpcl.dx_call:
#?>>
    .set cc_blockpcl.dx_call.b, 88
    .set cc_blockpcl.dx_call.res, 96
    .set cc_blockpcl.dx_call.retmode, -8
    .set cc_blockpcl.dx_call.m, -16
    .set cc_blockpcl.dx_call.nvariadics, -24
    .set cc_blockpcl.dx_call.nfixedparams, -32
    .set cc_blockpcl.dx_call.isfn, -40
    .set cc_blockpcl.dx_call.paramlist, -296
    .set cc_blockpcl.dx_call.paramconst, -328
    .set cc_blockpcl.dx_call.argattr, -360
    .set cc_blockpcl.dx_call.iparams, -368
    .set cc_blockpcl.dx_call.fparams, -376
    .set cc_blockpcl.dx_call.q, -384
    .set cc_blockpcl.dx_call.i, -392
    .set cc_blockpcl.dx_call.$T1, -400
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	440
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       [%rbp+88],	%r8
    mov       [%rbp+96],	%r9
#---------------
    movsxd    %rax,	dword ptr[%r13+52]
    mov       [%rbp + cc_blockpcl.dx_call.retmode],	%rax
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.retmode]
    test      %rax,	%rax
    jnz       L6109
    mov       %rax,	3
    mov       [%rbp + cc_blockpcl.dx_call.retmode],	%rax
L6109:
    xor       %eax,	%eax
    mov       [%rbp + cc_blockpcl.dx_call.isfn],	%rax
    movsxd    %rax,	dword ptr[%r14+40]
    cmp       %rax,	52
    jnz       L6112
L6111:
    movsxd    %rax,	dword ptr[%r14+52]
    mov       [%rbp + cc_blockpcl.dx_call.m],	%rax
    jmp       L6114
L6113:
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	[%rbp + cc_blockpcl.dx_call.m]
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       [%rbp + cc_blockpcl.dx_call.m],	%rax
L6114:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	[%rbp + cc_blockpcl.dx_call.m]
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	13
    jz        L6113
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	[%rbp + cc_blockpcl.dx_call.m]
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	0
    setnz     %al
    movzx     %eax,	%al
    mov       [%rbp + cc_blockpcl.dx_call.isfn],	%rax
    lea       %rax,	[%rip+cc_decls.ttparams]
    mov       %r10,	[%rbp + cc_blockpcl.dx_call.m]
    mov       %rdi,	[%rax + %r10*8]
    mov       %rbx,	1
    jmp       L6110
L6112:
    mov       %rax,	[%r14]
    mov       %rdi,	[%rax+80]
    xor       %rbx,	%rbx
    mov       %rax,	[%r14]
    movzx     %rax,	word ptr[%rax+102]
    cmp       %rax,	0
    setnz     %al
    movzx     %eax,	%al
    mov       [%rbp + cc_blockpcl.dx_call.isfn],	%rax
L6110:
    movsx     %rax,	word ptr[%rdi+22]
    cmp       %rax,	3
    setz      %al
    movzx     %eax,	%al
    mov       %rsi,	%rax
    movsx     %rax,	word ptr[%rdi+20]
    mov       [%rbp + cc_blockpcl.dx_call.nfixedparams],	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_blockpcl.dx_call.nvariadics],	%rax
    mov       %r12,	%rax
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.b]
    mov       [%rbp + cc_blockpcl.dx_call.q],	%rax
    jmp       L6119
L6116:
    cmp       %r12,	32
    jl        L6121
    lea       %rcx,	[%rip+L8746]
    xor       %edx,	%edx
    call      cc_support.gerror
L6121:
    inc       %r12
    mov       %rax,	%r12
    mov       %r10,	[%rbp + cc_blockpcl.dx_call.q]
    mov       [%rbp + %rax*8 + cc_blockpcl.dx_call.paramlist-8],	%r10
    xor       %eax,	%eax
    mov       [%rbp + %r12 + cc_blockpcl.dx_call.paramconst-1],	%al
    test      %rsi,	%rsi
    jz        L6123
    cmp       %r12,	[%rbp + cc_blockpcl.dx_call.nfixedparams]
    jle       L6123
    cmp       %r12,	4
    jg        L6123
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.nvariadics]
    test      %rax,	%rax
    jnz       L6123
    mov       [%rbp + cc_blockpcl.dx_call.nvariadics],	%r12
L6123:
    cmp       %r12,	[%rbp + cc_blockpcl.dx_call.nfixedparams]
    jg        L6125
    movsxd    %rax,	dword ptr[%rdi+16]
    lea       %r10,	[%rip+cc_decls.ttconst]
    mov       %r10b,	[%r10 + %rax]
    mov       [%rbp + %r12 + cc_blockpcl.dx_call.paramconst-1],	%r10b
    mov       %rdi,	[%rdi+8]
L6125:
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.q]
    mov       %rax,	[%rax+8]
    mov       [%rbp + cc_blockpcl.dx_call.q],	%rax
L6119:
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.q]
    test      %rax,	%rax
    jnz       L6116
    mov       %rcx,	131
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	%r13
    call      cc_libpcl.setmode_u
    mov       %eax,	%r12d
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+16],	%eax
    xor       %eax,	%eax
    mov       [%rbp + cc_blockpcl.dx_call.fparams],	%rax
    mov       [%rbp + cc_blockpcl.dx_call.iparams],	%rax
    mov       %rax,	1
    mov       [%rbp + cc_blockpcl.dx_call.i],	%rax
    cmp       %r12,	1
    jl        L6128
L6126:
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.i]
    mov       %rax,	[%rbp + %rax*8 + cc_blockpcl.dx_call.paramlist-8]
    mov       [%rbp + cc_blockpcl.dx_call.q],	%rax
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.q]
    movsxd    %rax,	dword ptr[%rax+52]
    cmp       %rax,	10
    jz        L6131
    cmp       %rax,	11
    jnz       L6130
L6131:
    inc       qword ptr[%rbp + cc_blockpcl.dx_call.fparams]
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.fparams]
    neg       %rax
    mov       %r10,	[%rbp + cc_blockpcl.dx_call.i]
    mov       [%rbp + %r10 + cc_blockpcl.dx_call.argattr-1],	%al
    jmp       L6129
L6130:
    inc       qword ptr[%rbp + cc_blockpcl.dx_call.iparams]
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.iparams]
    mov       %r10,	[%rbp + cc_blockpcl.dx_call.i]
    mov       [%rbp + %r10 + cc_blockpcl.dx_call.argattr-1],	%al
L6129:
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.i]
    inc       %rax
    mov       [%rbp + cc_blockpcl.dx_call.i],	%rax
    cmp       %rax,	%r12
    jle       L6126
L6128:
    mov       [%rbp + cc_blockpcl.dx_call.i],	%r12
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.i]
    cmp       %rax,	1
    jl        L6134
L6132:
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.i]
    mov       %rax,	[%rbp + %rax*8 + cc_blockpcl.dx_call.paramlist-8]
    mov       [%rbp + cc_blockpcl.dx_call.q],	%rax
    mov       %rcx,	[%rbp + cc_blockpcl.dx_call.q]
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.nvariadics]
    test      %rax,	%rax
    jz        L6136
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.i]
    cmp       %rax,	[%rbp + cc_blockpcl.dx_call.nvariadics]
    jl        L6136
    mov       %rax,	[%rip+pc_api.pccurr]
    movzx     %rax,	byte ptr[%rax+3]
    cmp       %rax,	1
    jnz       L6136
    mov       %rcx,	115
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %al,	2
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+3],	%al
    mov       %rax,	[%rip+pc_api.pccurr]
    lea       %rax,	[%rax+28]
    mov       %r10d,	1
    mov       %r15d,	[%rax]
    mov       %r11,	-256
    and       %r15d,	%r11d
    or        %r15d,	%r10d
    mov       [%rax],	%r15d
L6136:
    mov       %rcx,	132
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	[%rbp + cc_blockpcl.dx_call.q]
    call      cc_libpcl.setmode_u
    mov       %eax,	[%rbp + cc_blockpcl.dx_call.i]
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+16],	%eax
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.i]
    movsx     %rax,	byte ptr[%rbp + %rax + cc_blockpcl.dx_call.argattr-1]
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+20],	%eax
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.i]
    dec       %rax
    mov       [%rbp + cc_blockpcl.dx_call.i],	%rax
    cmp       %rax,	1
    jge       L6132
L6134:
    test      %rbx,	%rbx
    jnz       L6138
    mov       %rax,	[%r14]
    mov       %rcx,	%rax
    call      cc_libpcl.genmemaddr_d
    mov       [%rbp + cc_blockpcl.dx_call.$T1],	%rax
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.isfn]
    test      %rax,	%rax
    jz        L6140
    mov       %rax,	21
    jmp       L6139
L6140:
    mov       %rax,	18
L6139:
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + cc_blockpcl.dx_call.$T1]
    call      pc_api.pc_gen
    jmp       L6137
L6138:
    mov       %rax,	[%r14+16]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.isfn]
    test      %rax,	%rax
    jz        L6142
    mov       %rax,	22
    jmp       L6141
L6142:
    mov       %rax,	19
L6141:
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      pc_api.pc_gen
L6137:
    mov       %eax,	%r12d
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+16],	%eax
    mov       %eax,	[%rbp + cc_blockpcl.dx_call.nvariadics]
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+20],	%eax
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.isfn]
    test      %rax,	%rax
    jz        L6144
    mov       %rcx,	%r13
    call      cc_parse.getmemmode
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.res]
    test      %rax,	%rax
    jnz       L6146
    mov       %rcx,	11
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	%r13
    call      cc_parse.getmemmode
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    jmp       L6145
L6146:
    mov       %rcx,	%r13
    call      cc_blockpcl.widen
L6145:
L6144:
#---------------
    add       %rsp,	440
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.do_decl
cc_blockpcl.do_decl:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rdi,	[%rbx+72]
    mov       %al,	1
    mov       [%rbx+122],	%al
    mov       %rax,	[%rbx+56]
    test      %rax,	%rax
    jz        L6149
    mov       %rax,	[%rbx+56]
    mov       %r10b,	1
    mov       [%rax+92],	%r10b
L6149:
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	28
    jz        L6151
    movzx     %rax,	word ptr[%rbx+102]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    cmp       %r10,	17
    jnz       L6153
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	1
    jz        L6154
L6153:
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	%rbx
    call      cc_libpcl.genmem_d
    mov       %rcx,	4
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    movsxd    %rax,	dword ptr[%rdi+52]
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    jmp       L6147
L6151:
#cc_blockpcl.do_decl.copyl:
L6154:
    mov       %rax,	[%rbx+114]
    mov       %rcx,	%rax
    call      pc_api.genmem
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    movzx     %rax,	word ptr[%rbx+102]
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    mov       %rcx,	%rbx
    call      cc_libpcl.genmem_d
    mov       %rcx,	4
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    movzx     %rax,	word ptr[%rbx+102]
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
L6147:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.do_for
cc_blockpcl.do_for:
#?>>
    .set cc_blockpcl.do_for.pbody, 80
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %r15,	%rcx
    mov       [%rbp+80],	%rdx
#---------------
    mov       %rdi,	[%r15+8]
    mov       %rbx,	[%rdi+8]
    call      cc_libpcl.createfwdlabel
    mov       %r12,	%rax
    call      cc_libpcl.createfwdlabel
    mov       %r13,	%rax
    call      cc_libpcl.createfwdlabel
    mov       %r14,	%rax
    movsxd    %rax,	dword ptr[%r15+40]
    cmp       %rax,	2
    jz        L6157
    mov       %rcx,	%r15
    call      cc_blockpcl.do_stmt
L6157:
    mov       %rcx,	%r14
    call      cc_blockpcl.genjumpl
    mov       %rcx,	%r12
    mov       %rdx,	%r13
    call      cc_blockpcl.stacklooplabels
    call      cc_libpcl.definelabel
    mov       %rsi,	%rax
    mov       %rcx,	[%rbp + cc_blockpcl.do_for.pbody]
    call      cc_blockpcl.do_stmt
    mov       %rcx,	%r12
    call      cc_libpcl.definefwdlabel
    mov       %rcx,	%rbx
    call      cc_blockpcl.do_stmt
    mov       %rcx,	%r14
    call      cc_libpcl.definefwdlabel
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	2
    jz        L6159
    mov       %rcx,	27
    mov       %rdx,	%rdi
    mov       %r8,	%rsi
    call      cc_blockpcl.genjumpcond
    jmp       L6158
L6159:
    mov       %rcx,	%rsi
    call      cc_blockpcl.genjumpl
L6158:
    mov       %rcx,	%r13
    call      cc_libpcl.definefwdlabel
    dec       qword ptr[%rip+cc_blockpcl.loopindex]
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.do_preincr
cc_blockpcl.do_preincr:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      cc_blockpcl.dx_expr
    call      cc_blockpcl.do_setinplace
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	%rdi
    call      cc_parse.getmemmode
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    movsxd    %rax,	dword ptr[%rdi+52]
    mov       %rcx,	%rax
    call      cc_blockpcl.setincrstep
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.setincrstep
cc_blockpcl.setincrstep:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	1
    call      pc_api.pc_setincr
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%rdi
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L6163
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      pc_api.pc_setincr
L6163:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_preincrx
cc_blockpcl.dx_preincrx:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      cc_blockpcl.dx_expr
    call      cc_blockpcl.do_setinplace
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	71
    jnz       L6166
    mov       %rax,	86
    jmp       L6165
L6166:
    mov       %rax,	87
L6165:
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      pc_api.pc_gen
    movsxd    %rax,	dword ptr[%rbx+52]
    mov       %rcx,	%rax
    call      cc_blockpcl.setincrstep
    mov       %rcx,	%rbx
    call      cc_blockpcl.widen
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_postincrx
cc_blockpcl.dx_postincrx:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      cc_blockpcl.dx_expr
    call      cc_blockpcl.do_setinplace
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	73
    jnz       L6169
    mov       %rax,	88
    jmp       L6168
L6169:
    mov       %rax,	89
L6168:
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      pc_api.pc_gen
    movsxd    %rax,	dword ptr[%rbx+52]
    mov       %rcx,	%rax
    call      cc_blockpcl.setincrstep
    mov       %rcx,	%rbx
    call      cc_blockpcl.widen
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_dot
cc_blockpcl.dx_dot:
#?>>
    .set cc_blockpcl.dx_dot.b, 56
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r9
#---------------
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      cc_blockpcl.dx_expr
    movsxd    %rax,	dword ptr[%rdi]
    mov       %rcx,	%rax
    call      pc_api.genint
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	9
    call      cc_libpcl.setmode
    test      %rsi,	%rsi
    jnz       L6172
    mov       %rcx,	57
    mov       %rdx,	1
    xor       %r8d,	%r8d
    call      pc_api.pc_genix
    mov       %rcx,	%rdi
    call      cc_parse.getmemmode
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    mov       %rcx,	1
    xor       %edx,	%edx
    call      pc_api.pc_setscaleoff
    mov       %rcx,	2
    mov       %rdx,	1
    xor       %r8d,	%r8d
    call      pc_api.pc_genix
    mov       %rcx,	%rdi
    call      cc_blockpcl.widen
    jmp       L6171
L6172:
    mov       %rcx,	57
    mov       %rdx,	1
    xor       %r8d,	%r8d
    call      pc_api.pc_genix
    mov       %rcx,	%rdi
    call      cc_parse.getmemmode
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    mov       %rcx,	1
    xor       %edx,	%edx
    call      pc_api.pc_setscaleoff
L6171:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_eq
cc_blockpcl.dx_eq:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      cc_blockpcl.do_fixwiden
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	31
    xor       %edx,	%edx
    call      pc_api.pc_gen
    movsxd    %rax,	dword ptr[%rdi+40]
    mov       %rcx,	%rax
    call      cc_blockpcl.getpclcond
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+2],	%al
    mov       %rcx,	%rbx
    call      cc_libpcl.setmode_u
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.do_labeldef
cc_blockpcl.do_labeldef:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%rdi+88]
    cmp       %rax,	0
    jg        L6176
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rax,	[%rip+pc_api.mlabelno]
    mov       [%rdi+88],	%eax
L6176:
    mov       %rcx,	[%rdi]
    call      pc_api.gencomment
    movsxd    %rax,	dword ptr[%rdi+88]
    mov       %rcx,	%rax
    call      pc_api.genlabel
    mov       %rcx,	127
    mov       %rdx,	%rax
    call      pc_api.pc_gen
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.do_goto
cc_blockpcl.do_goto:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%rdi+88]
    test      %rax,	%rax
    jnz       L6179
    mov       %rax,	[%rdi]
    lea       %rcx,	[%rip+L8747]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      cc_support.gerror_s
    jmp       L6178
L6179:
    movsxd    %rax,	dword ptr[%rdi+88]
    cmp       %rax,	0
    jge       L6180
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rax,	[%rip+pc_api.mlabelno]
    mov       [%rdi+88],	%eax
L6180:
L6178:
    movsxd    %rax,	dword ptr[%rdi+88]
    mov       %rcx,	%rax
    call      pc_api.genlabel
    mov       %rcx,	24
    mov       %rdx,	%rax
    call      pc_api.pc_gen
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_ifx
cc_blockpcl.dx_ifx:
#?>>
    .set cc_blockpcl.dx_ifx.c, 88
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	32
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
    mov       [%rbp+88],	%r9
#---------------
    movsxd    %rax,	dword ptr[%r12+52]
    cmp       %rax,	0
    setnz     %al
    movzx     %eax,	%al
    mov       %rsi,	%rax
    call      cc_libpcl.createfwdlabel
    mov       %rdi,	%rax
    call      cc_libpcl.createfwdlabel
    mov       %rbx,	%rax
    test      %rsi,	%rsi
    jz        L6183
    mov       %rcx,	117
    xor       %edx,	%edx
    call      pc_api.pc_gen
L6183:
    mov       %rcx,	28
    mov       %rdx,	%r13
    mov       %r8,	%rdi
    call      cc_blockpcl.genjumpcond
    mov       %rcx,	%r14
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    test      %rsi,	%rsi
    jz        L6185
    mov       %rcx,	118
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	%r12
    call      cc_libpcl.setmode_u
L6185:
    mov       %rcx,	%rbx
    call      cc_blockpcl.genjumpl
    mov       %rcx,	%rdi
    call      cc_libpcl.definefwdlabel
    mov       %rcx,	[%rbp + cc_blockpcl.dx_ifx.c]
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    test      %rsi,	%rsi
    jz        L6187
    mov       %rcx,	119
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	%r12
    call      cc_libpcl.setmode_u
L6187:
    mov       %rcx,	%rbx
    call      cc_libpcl.definefwdlabel
#---------------
    add       %rsp,	32
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.do_casestmt
cc_blockpcl.do_casestmt:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    mov       %rax,	[%rip+cc_blockpcl.sw_ncases]
    test      %rax,	%rax
    jnz       L6190
    mov       %rax,	[%rsi]
    sub       %rax,	[%rip+cc_blockpcl.sw_lower]
    mov       %r10,	[%rip+cc_blockpcl.sw_labeltable]
    movsxd    %r10,	dword ptr[%r10 + %rax*4]
    mov       %rcx,	%r10
    call      pc_api.genlabel
    mov       %rcx,	127
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    jmp       L6189
L6190:
    mov       %rdi,	[%rsi]
    mov       %rbx,	1
    mov       %rax,	[%rip+cc_blockpcl.sw_ncases]
    cmp       %rax,	1
    jl        L6194
L6191:
    mov       %rax,	[%rip+cc_blockpcl.sw_valuetable]
    mov       %r10,	%rbx
    movsxd    %rax,	dword ptr[%rax + %r10*4-4]
    cmp       %rax,	%rdi
    jnz       L6196
    mov       %rax,	[%rip+cc_blockpcl.sw_labeltable]
    mov       %r10,	%rbx
    movsxd    %rax,	dword ptr[%rax + %r10*4-4]
    mov       %rcx,	%rax
    call      pc_api.genlabel
    mov       %rcx,	127
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    jmp       L6193
L6196:
    inc       %rbx
    cmp       %rbx,	[%rip+cc_blockpcl.sw_ncases]
    jle       L6191
L6194:
    lea       %rcx,	[%rip+L8748]
    xor       %edx,	%edx
    call      cc_support.gerror
L6193:
L6189:
    mov       %rcx,	%r12
    call      cc_blockpcl.do_stmt
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.do_switch
cc_blockpcl.do_switch:
#?>>
    .set cc_blockpcl.do_switch.a, 80
    .set cc_blockpcl.do_switch.b, 88
    .set cc_blockpcl.do_switch.labeltable, -2000
    .set cc_blockpcl.do_switch.valuetable, -4000
    .set cc_blockpcl.do_switch.flags, -4504
    .set cc_blockpcl.do_switch.value, -4512
    .set cc_blockpcl.do_switch.ncases, -4520
    .set cc_blockpcl.do_switch.serialsw, -4528
    .set cc_blockpcl.do_switch.i, -4536
    .set cc_blockpcl.do_switch.index, -4544
    .set cc_blockpcl.do_switch.pcase, -4552
    .set cc_blockpcl.do_switch.old_labeltable, -4560
    .set cc_blockpcl.do_switch.old_valuetable, -4568
    .set cc_blockpcl.do_switch.old_ncases, -4576
    .set cc_blockpcl.do_switch.old_lower, -4584
    .set cc_blockpcl.do_switch.old_defaultseen, -4592
    .set cc_blockpcl.do_switch.old_defaultlabel, -4600
    .set cc_blockpcl.do_switch.old_breaklabel, -4608
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	4648
    mov       %r15,	%rcx
    mov       [%rbp+80],	%rdx
    mov       [%rbp+88],	%r8
#---------------
    mov       %rax,	[%r15]
    mov       [%rbp + cc_blockpcl.do_switch.pcase],	%rax
    xor       %eax,	%eax
    mov       %r14,	%rax
    mov       [%rbp + cc_blockpcl.do_switch.ncases],	%rax
    jmp       L6199
L6198:
    inc       qword ptr[%rbp + cc_blockpcl.do_switch.ncases]
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.ncases]
    cmp       %rax,	500
    jle       L6202
    lea       %rcx,	[%rip+L8749]
    xor       %edx,	%edx
    call      cc_support.gerror
L6202:
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.pcase]
    mov       %rax,	[%rax+8]
    mov       [%rbp + cc_blockpcl.do_switch.value],	%rax
    mov       %r10,	[%rbp + cc_blockpcl.do_switch.ncases]
    mov       [%rbp + %r10*4 + cc_blockpcl.do_switch.valuetable-4],	%eax
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.ncases]
    cmp       %rax,	1
    jnz       L6204
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.value]
    mov       %r13,	%rax
    mov       %r12,	%rax
    jmp       L6203
L6204:
    mov       %rax,	%r12
    mov       %r10,	[%rbp + cc_blockpcl.do_switch.value]
    cmp       %rax,	%r10
    cmovg     %rax,	%r10
    mov       %r12,	%rax
    mov       %rax,	%r13
    mov       %r10,	[%rbp + cc_blockpcl.do_switch.value]
    cmp       %rax,	%r10
    cmovl     %rax,	%r10
    mov       %r13,	%rax
L6203:
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.pcase]
    mov       %rax,	[%rax]
    mov       [%rbp + cc_blockpcl.do_switch.pcase],	%rax
L6199:
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.pcase]
    test      %rax,	%rax
    jnz       L6198
    mov       %rax,	[%r15]
    test      %rax,	%rax
    jz        L6206
    mov       %rax,	%r13
    sub       %rax,	%r12
    inc       %rax
    mov       %r14,	%rax
    jmp       L6205
L6206:
    xor       %r14,	%r14
L6205:
    call      cc_libpcl.createfwdlabel
    mov       %rdi,	%rax
    call      cc_libpcl.createfwdlabel
    mov       %rbx,	%rax
    cmp       %r14,	500
    jg        L6209
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.ncases]
    cmp       %rax,	8
    jg        L6208
L6209:
    mov       %al,	1
    mov       [%rbp + cc_blockpcl.do_switch.serialsw],	%al
    mov       %rcx,	[%rbp + cc_blockpcl.do_switch.a]
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rax,	1
    mov       [%rbp + cc_blockpcl.do_switch.i],	%rax
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.ncases]
    cmp       %rax,	1
    jl        L6212
L6210:
    call      cc_libpcl.createfwdlabel
    mov       %r10,	[%rbp + cc_blockpcl.do_switch.i]
    mov       [%rbp + %r10*4 + cc_blockpcl.do_switch.labeltable-4],	%eax
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.i]
    movsxd    %rax,	dword ptr[%rbp + %rax*4 + cc_blockpcl.do_switch.valuetable-4]
    mov       %rcx,	%rax
    call      pc_api.genint
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	3
    call      cc_libpcl.setmode
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.i]
    movsxd    %rax,	dword ptr[%rbp + %rax*4 + cc_blockpcl.do_switch.labeltable-4]
    mov       %rcx,	%rax
    call      pc_api.genlabel
    mov       %rcx,	26
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	3
    call      cc_libpcl.setmode
    mov       %al,	1
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+2],	%al
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.i]
    cmp       %rax,	[%rbp + cc_blockpcl.do_switch.ncases]
    jge       L6214
    mov       %eax,	1
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+16],	%eax
L6214:
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.i]
    inc       %rax
    mov       [%rbp + cc_blockpcl.do_switch.i],	%rax
    cmp       %rax,	[%rbp + cc_blockpcl.do_switch.ncases]
    jle       L6210
L6212:
    mov       %rcx,	%rdi
    call      cc_blockpcl.genjumpl
    jmp       L6207
L6208:
    test      %r14,	%r14
    jnz       L6215
    mov       %rcx,	%rdi
    call      cc_blockpcl.genjumpl
    jmp       L6207
L6215:
    xor       %eax,	%eax
    mov       [%rbp + cc_blockpcl.do_switch.serialsw],	%al
    lea       %rcx,	[%rbp + cc_blockpcl.do_switch.flags]
    xor       %edx,	%edx
    mov       %r8,	%r14
    call      memset
    mov       %rax,	1
    mov       [%rbp + cc_blockpcl.do_switch.i],	%rax
    cmp       %r14,	1
    jl        L6218
L6216:
    mov       %eax,	%edi
    mov       %r10,	[%rbp + cc_blockpcl.do_switch.i]
    mov       [%rbp + %r10*4 + cc_blockpcl.do_switch.labeltable-4],	%eax
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.i]
    inc       %rax
    mov       [%rbp + cc_blockpcl.do_switch.i],	%rax
    cmp       %rax,	%r14
    jle       L6216
L6218:
    mov       %rax,	1
    mov       [%rbp + cc_blockpcl.do_switch.i],	%rax
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.ncases]
    cmp       %rax,	1
    jl        L6221
L6219:
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.i]
    movsxd    %rax,	dword ptr[%rbp + %rax*4 + cc_blockpcl.do_switch.valuetable-4]
    mov       [%rbp + cc_blockpcl.do_switch.value],	%rax
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.value]
    sub       %rax,	%r12
    inc       %rax
    mov       [%rbp + cc_blockpcl.do_switch.index],	%rax
    call      cc_libpcl.createfwdlabel
    mov       %r10,	[%rbp + cc_blockpcl.do_switch.index]
    mov       [%rbp + %r10*4 + cc_blockpcl.do_switch.labeltable-4],	%eax
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.index]
    mov       %al,	[%rbp + %rax + cc_blockpcl.do_switch.flags-1]
    test      %al,	%al
    jz        L6223
    mov       %rcx,	[%rbp + cc_blockpcl.do_switch.value]
    xor       %edx,	%edx
    call      msys.strint
    lea       %rcx,	[%rip+L8750]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      cc_support.gerror_s
L6223:
    mov       %al,	1
    mov       %r10,	[%rbp + cc_blockpcl.do_switch.index]
    mov       [%rbp + %r10 + cc_blockpcl.do_switch.flags-1],	%al
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.i]
    inc       %rax
    mov       [%rbp + cc_blockpcl.do_switch.i],	%rax
    cmp       %rax,	[%rbp + cc_blockpcl.do_switch.ncases]
    jle       L6219
L6221:
    call      cc_libpcl.createfwdlabel
    mov       %rsi,	%rax
    mov       %rcx,	[%rbp + cc_blockpcl.do_switch.a]
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	%rsi
    call      pc_api.genlabel
    mov       %rcx,	37
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	3
    call      cc_libpcl.setmode
    mov       %rax,	%r12
    add       %rax,	%r14
    dec       %rax
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      pc_api.pc_setxy
    mov       %rcx,	%rdi
    call      pc_api.genlabel
    mov       %rcx,	12
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	3
    call      cc_libpcl.setmode
    mov       %rcx,	%rsi
    call      cc_libpcl.definefwdlabel
    mov       %rax,	1
    mov       [%rbp + cc_blockpcl.do_switch.i],	%rax
    cmp       %r14,	1
    jl        L6226
L6224:
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.i]
    movsxd    %rax,	dword ptr[%rbp + %rax*4 + cc_blockpcl.do_switch.labeltable-4]
    mov       %rcx,	%rax
    call      pc_api.genlabel
    mov       %rcx,	39
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.i]
    inc       %rax
    mov       [%rbp + cc_blockpcl.do_switch.i],	%rax
    cmp       %rax,	%r14
    jle       L6224
L6226:
    mov       %rcx,	40
    xor       %edx,	%edx
    call      pc_api.pc_gen
L6207:
    mov       %rax,	[%rip+cc_blockpcl.sw_labeltable]
    mov       [%rbp + cc_blockpcl.do_switch.old_labeltable],	%rax
    mov       %rax,	[%rip+cc_blockpcl.sw_valuetable]
    mov       [%rbp + cc_blockpcl.do_switch.old_valuetable],	%rax
    mov       %rax,	[%rip+cc_blockpcl.sw_lower]
    mov       [%rbp + cc_blockpcl.do_switch.old_lower],	%rax
    mov       %rax,	[%rip+cc_blockpcl.sw_ncases]
    mov       [%rbp + cc_blockpcl.do_switch.old_ncases],	%rax
    mov       %al,	[%rip+cc_blockpcl.sw_defaultseen]
    mov       [%rbp + cc_blockpcl.do_switch.old_defaultseen],	%al
    mov       %rax,	[%rip+cc_blockpcl.sw_defaultlabel]
    mov       [%rbp + cc_blockpcl.do_switch.old_defaultlabel],	%rax
    mov       %rax,	[%rip+cc_blockpcl.sw_breaklabel]
    mov       [%rbp + cc_blockpcl.do_switch.old_breaklabel],	%rax
    lea       %rax,	[%rbp + cc_blockpcl.do_switch.labeltable]
    mov       [%rip+cc_blockpcl.sw_labeltable],	%rax
    lea       %rax,	[%rbp + cc_blockpcl.do_switch.valuetable]
    mov       [%rip+cc_blockpcl.sw_valuetable],	%rax
    mov       [%rip+cc_blockpcl.sw_lower],	%r12
    mov       %al,	[%rbp + cc_blockpcl.do_switch.serialsw]
    test      %al,	%al
    jz        L6228
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.ncases]
    jmp       L6227
L6228:
    xor       %eax,	%eax
L6227:
    mov       [%rip+cc_blockpcl.sw_ncases],	%rax
    xor       %eax,	%eax
    mov       [%rip+cc_blockpcl.sw_defaultseen],	%al
    mov       [%rip+cc_blockpcl.sw_defaultlabel],	%rdi
    mov       [%rip+cc_blockpcl.sw_breaklabel],	%rbx
    mov       %rcx,	[%rbp + cc_blockpcl.do_switch.b]
    call      cc_blockpcl.do_stmt
    mov       %al,	[%rip+cc_blockpcl.sw_defaultseen]
    test      %al,	%al
    jnz       L6230
    mov       %rcx,	%rdi
    call      cc_libpcl.definefwdlabel
L6230:
    mov       %rcx,	%rbx
    call      cc_libpcl.definefwdlabel
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.old_labeltable]
    mov       [%rip+cc_blockpcl.sw_labeltable],	%rax
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.old_valuetable]
    mov       [%rip+cc_blockpcl.sw_valuetable],	%rax
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.old_lower]
    mov       [%rip+cc_blockpcl.sw_lower],	%rax
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.old_ncases]
    mov       [%rip+cc_blockpcl.sw_ncases],	%rax
    mov       %al,	[%rbp + cc_blockpcl.do_switch.old_defaultseen]
    mov       [%rip+cc_blockpcl.sw_defaultseen],	%al
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.old_defaultlabel]
    mov       [%rip+cc_blockpcl.sw_defaultlabel],	%rax
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.old_breaklabel]
    mov       [%rip+cc_blockpcl.sw_breaklabel],	%rax
#---------------
    add       %rsp,	4648
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_andorl
cc_blockpcl.dx_andorl:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    call      cc_libpcl.createfwdlabel
    mov       %rdi,	%rax
    mov       %rcx,	117
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	28
    mov       %rdx,	%rsi
    mov       %r8,	%rdi
    call      cc_blockpcl.genjumpcond
    call      cc_libpcl.createfwdlabel
    mov       %rbx,	%rax
    mov       %rcx,	1
    call      pc_api.genint
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	3
    call      cc_libpcl.setmode
    mov       %rcx,	118
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	[%rsi+16]
    call      cc_libpcl.setmode_u
    mov       %rcx,	%rbx
    call      cc_blockpcl.genjumpl
    mov       %rcx,	%rdi
    call      cc_libpcl.definefwdlabel
    xor       %ecx,	%ecx
    call      pc_api.genint
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	3
    call      cc_libpcl.setmode
    mov       %rcx,	119
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	[%rsi+16]
    call      cc_libpcl.setmode_u
    mov       %rcx,	%rbx
    call      cc_libpcl.definefwdlabel
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_scale
cc_blockpcl.dx_scale:
#?>>
    .set cc_blockpcl.dx_scale.b, 56
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    movsxd    %rax,	dword ptr[%rbx+48]
    mov       %rdi,	%rax
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    movsxd    %rax,	dword ptr[%rbx+48]
    cmp       %rax,	0
    jl        L6234
    movsxd    %rax,	dword ptr[%rbx+48]
    mov       %rcx,	%rax
    call      pc_api.genint
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	4
    call      cc_libpcl.setmode
    mov       %rcx,	45
    xor       %edx,	%edx
    call      pc_api.pc_gen
    jmp       L6233
L6234:
    movsxd    %rax,	dword ptr[%rbx+48]
    neg       %rax
    mov       %rcx,	%rax
    call      pc_api.genint
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	4
    call      cc_libpcl.setmode
    mov       %rcx,	47
    xor       %edx,	%edx
    call      pc_api.pc_gen
L6233:
    mov       %rcx,	%rsi
    call      cc_libpcl.setmode_u
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.widen
cc_blockpcl.widen:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    movsx     %rax,	word ptr[%rbx+56]
    test      %rax,	%rax
    jnz       L6237
    movsxd    %rax,	dword ptr[%rbx+52]
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    jmp       L6235
L6237:
    mov       %rcx,	%rbx
    call      cc_parse.getmemmode
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    call      cc_libpcl.setmode
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    cmp       %rax,	4
    jge       L6239
    mov       %rax,	[%rip+pc_api.pccurr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	1
    jz        L6240
    cmp       %rax,	2
    jz        L6240
    cmp       %rax,	3
    jz        L6240
    cmp       %rax,	86
    jz        L6240
    cmp       %rax,	87
    jz        L6240
    cmp       %rax,	88
    jz        L6240
    cmp       %rax,	89
    jz        L6240
    cmp       %rax,	21
    jnz       L6239
L6240:
    mov       %rcx,	114
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rax,	%rdi
    cmp       %rax,	1
    jz        L6243
    cmp       %rax,	2
    jnz       L6242
L6243:
    mov       %rax,	3
    jmp       L6241
L6242:
    mov       %rax,	8
L6241:
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    mov       %rcx,	%rdi
    call      cc_libpcl.setmode2
L6239:
L6235:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.do_setinplace
cc_blockpcl.do_setinplace:
#?>>
#?]]
#---------------
    mov       %rax,	[%rip+pc_api.pccurr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	1
    jnz       L6246
    mov       %rax,	[%rip+pc_api.pccurr]
    movzx     %rax,	byte ptr[%rax+1]
    cmp       %rax,	2
    jnz       L6246
    mov       %eax,	1
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+16],	%eax
L6246:
#---------------
    ret       
# End 
# Proc cc_blockpcl.do_fixwiden
cc_blockpcl.do_fixwiden:
#?>>
    .set cc_blockpcl.do_fixwiden.a, 16
    .set cc_blockpcl.do_fixwiden.b, 24
#?]]
#---------------
L6247:
#---------------
    ret       
# End 
# Proc cc_blockpcl.isboolexpr
cc_blockpcl.isboolexpr:
#?>>
#?]]
#---------------
    movsxd    %rax,	dword ptr[%rcx+40]
    cmp       %rax,	26
    jz        L6250
    cmp       %rax,	24
    jz        L6250
    cmp       %rax,	25
    jz        L6250
    cmp       %rax,	33
    jz        L6250
    cmp       %rax,	34
    jz        L6250
    cmp       %rax,	35
    jz        L6250
    cmp       %rax,	36
    jz        L6250
    cmp       %rax,	38
    jz        L6250
    cmp       %rax,	37
    jnz       L6251
L6250:
    mov       %rax,	1
    jmp       L6249
L6251:
    xor       %eax,	%eax
L6249:
L6248:
#---------------
    ret       
# End 
# Proc cc_libpcl.getpsymbol
cc_libpcl.getpsymbol:
#?>>
    .set cc_libpcl.getpsymbol.str, -256
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	296
    mov       %rsi,	%rcx
#---------------
    test      %rsi,	%rsi
    jnz       L6254
    xor       %eax,	%eax
    jmp       L6252
L6254:
    mov       %rax,	[%rsi+56]
    test      %rax,	%rax
    jz        L6256
    mov       %rax,	[%rsi+56]
    jmp       L6252
L6256:
    mov       %rbx,	[%rsi]
    movzx     %rax,	byte ptr[%rsi+109]
    cmp       %rax,	8
    jz        L6259
    cmp       %rax,	9
    jnz       L6258
L6259:
    mov       %rax,	[%rsi]
    lea       %rcx,	[%rbp + cc_libpcl.getpsymbol.str]
    mov       %rdx,	%rax
    call      strcpy
    movzx     %rax,	word ptr[%rsi+96]
    cmp       %rax,	1
    jle       L6261
    lea       %rcx,	[%rbp + cc_libpcl.getpsymbol.str]
    lea       %rdx,	[%rip+L8751]
    call      strcat
    movzx     %rax,	word ptr[%rsi+96]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.strint
    lea       %rcx,	[%rbp + cc_libpcl.getpsymbol.str]
    mov       %rdx,	%rax
    call      strcat
L6261:
    jmp       L6257
L6258:
    movzx     %rax,	byte ptr[%rsi+109]
    cmp       %rax,	7
    jnz       L6262
    mov       %rax,	[%rsi+8]
    test      %rax,	%rax
    jz        L6262
    mov       %rax,	[%rsi+8]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	6
    jnz       L6262
    mov       %rax,	[%rsi+8]
    mov       %rax,	[%rax]
    lea       %rcx,	[%rbp + cc_libpcl.getpsymbol.str]
    mov       %rdx,	%rax
    call      strcpy
    lea       %rcx,	[%rbp + cc_libpcl.getpsymbol.str]
    lea       %rdx,	[%rip+L8751]
    call      strcat
    mov       %rax,	[%rsi]
    lea       %rcx,	[%rbp + cc_libpcl.getpsymbol.str]
    mov       %rdx,	%rax
    call      strcat
    movzx     %rax,	word ptr[%rsi+96]
    cmp       %rax,	1
    jle       L6264
    lea       %rcx,	[%rbp + cc_libpcl.getpsymbol.str]
    lea       %rdx,	[%rip+L8751]
    call      strcat
    movzx     %rax,	word ptr[%rsi+96]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.strint
    lea       %rcx,	[%rbp + cc_libpcl.getpsymbol.str]
    mov       %rdx,	%rax
    call      strcat
L6264:
    jmp       L6257
L6262:
    mov       %rax,	[%rsi]
    lea       %rcx,	[%rbp + cc_libpcl.getpsymbol.str]
    mov       %rdx,	%rax
    call      strcpy
L6257:
    movzx     %rax,	byte ptr[%rsi+109]
    lea       %r10,	[%rip+cc_tables.name2pid]
    movzx     %r10,	byte ptr[%r10 + %rax]
    lea       %rcx,	[%rbp + cc_libpcl.getpsymbol.str]
    mov       %rdx,	%r10
    call      pc_api.pc_makesymbol
    mov       %rdi,	%rax
    mov       [%rsi+56],	%rax
    movzx     %rax,	word ptr[%rsi+102]
    mov       %rcx,	%rax
    call      cc_lib.getpclmode
    mov       [%rdi+82],	%al
    movzx     %rax,	word ptr[%rsi+102]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r10,	[%r10 + %rax*8]
    mov       [%rdi+84],	%r10d
    mov       %rax,	[%rsi+8]
    test      %rax,	%rax
    jz        L6266
    mov       %rax,	[%rsi+8]
    mov       %rax,	[%rax+8]
    test      %rax,	%rax
    jz        L6266
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    call      cc_libpcl.getpsymbol
    mov       [%rdi+32],	%rax
L6266:
    movzx     %rax,	byte ptr[%rsi+110]
    cmp       %rax,	4
    jnz       L6268
    mov       %al,	1
    mov       [%rdi+81],	%al
L6268:
    movzx     %rax,	byte ptr[%rsi+108]
    shr       %eax,	4
    and       %eax,	1
    test      %rax,	%rax
    jz        L6270
    lea       %rax,	[%rdi+104]
    or        byte ptr[%rax],	4
L6270:
    movzx     %rax,	byte ptr[%rsi+110]
    cmp       %rax,	3
    jnz       L6272
    mov       %al,	1
    mov       [%rdi+80],	%al
    mov       %al,	1
    mov       [%rdi+72],	%al
L6272:
    mov       %al,	[%rsi+122]
    mov       [%rdi+92],	%al
    mov       %eax,	[%rsi+88]
    mov       [%rdi+100],	%eax
    movzx     %rax,	byte ptr[%rsi+109]
    cmp       %rax,	6
    jnz       L6274
    mov       %rax,	[%rsi]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8752]
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L6274
    mov       %al,	1
    mov       [%rdi+110],	%al
    lea       %r10,	[%rsi+108]
    and       byte ptr[%r10],	247
    shl       %al,	3
    or        [%r10],	%al
L6274:
    mov       %rax,	%rdi
L6252:
#---------------
    add       %rsp,	296
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_libpcl.setmode
cc_libpcl.setmode:
#?>>
    .set cc_libpcl.setmode.$T1, -8
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %rdi,	%rcx
#---------------
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    mov       [%rbp + cc_libpcl.setmode.$T1],	%rax
    mov       %rcx,	%rdi
    call      cc_lib.getpclmode
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + cc_libpcl.setmode.$T1]
    call      pc_api.pc_setmode
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc cc_libpcl.setmode2
cc_libpcl.setmode2:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      cc_lib.getpclmode
    mov       %rcx,	%rax
    call      pc_api.pc_setmode2
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_libpcl.setmode_u
cc_libpcl.setmode_u:
#?>>
    .set cc_libpcl.setmode_u.$T1, -8
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rbx,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%rbx+52]
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    mov       [%rbp + cc_libpcl.setmode_u.$T1],	%rax
    mov       %rcx,	%rdi
    call      cc_lib.getpclmode
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + cc_libpcl.setmode_u.$T1]
    call      pc_api.pc_setmode
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_libpcl.genmem_d
cc_libpcl.genmem_d:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      cc_libpcl.getpsymbol
    mov       %rcx,	%rax
    call      pc_api.genmem
L6278:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_libpcl.genmemaddr_d
cc_libpcl.genmemaddr_d:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      cc_libpcl.getpsymbol
    mov       %rcx,	%rax
    call      pc_api.genmemaddr
L6279:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_libpcl.definelabel
cc_libpcl.definelabel:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rax,	[%rip+pc_api.mlabelno]
    mov       %rcx,	%rax
    call      pc_api.genlabel
    mov       %rcx,	127
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rax,	[%rip+pc_api.mlabelno]
L6280:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_libpcl.createfwdlabel
cc_libpcl.createfwdlabel:
#?>>
#?]]
#---------------
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rax,	[%rip+pc_api.mlabelno]
L6281:
#---------------
    ret       
# End 
# Proc cc_libpcl.definefwdlabel
cc_libpcl.definefwdlabel:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      pc_api.genlabel
    mov       %rcx,	127
    mov       %rdx,	%rax
    call      pc_api.pc_gen
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lib.newstrec
cc_lib.newstrec:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rcx,	128
    call      mlib.pcm_alloc
    mov       %rdi,	%rax
    mov       %rax,	%rdi
    xor       %r10d,	%r10d
    mov       %r11,	4
L8753:
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    mov       [%rax+16],	%r10
    mov       [%rax+24],	%r10
    add       %rax,	32
    dec       %r11
    jnz       L8753
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %eax,	[%rax+16]
    mov       [%rdi+92],	%eax
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %al,	[%rax+20]
    mov       [%rdi+113],	%al
    mov       %rax,	%rdi
L6283:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lib.initcclib
cc_lib.initcclib:
#?>>
#?]]
#---------------
#---
#---------------
    ret       
# End 
# Proc cc_lib.createname
cc_lib.createname:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    call      cc_lib.allocunitrec
    mov       %rdi,	%rax
    mov       %eax,	3
    mov       [%rdi+40],	%eax
    mov       [%rdi],	%rbx
    mov       %rax,	%rdi
L6285:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createunit0
cc_lib.createunit0:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    call      cc_lib.allocunitrec
    mov       %rdi,	%rax
    mov       [%rdi+40],	%ebx
    mov       %rax,	%rdi
L6286:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createunit1
cc_lib.createunit1:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    call      cc_lib.allocunitrec
    mov       %rdi,	%rax
    mov       [%rdi+40],	%ebx
    mov       [%rdi+16],	%rsi
    mov       %rax,	%rdi
L6287:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createunit2
cc_lib.createunit2:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    call      cc_lib.allocunitrec
    mov       %rdi,	%rax
    mov       [%rdi+40],	%ebx
    mov       [%rdi+16],	%rsi
    mov       [%rdi+24],	%r12
    mov       %rax,	%rdi
L6288:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createunit3
cc_lib.createunit3:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
    mov       %r13,	%r9
#---------------
    call      cc_lib.allocunitrec
    mov       %rdi,	%rax
    mov       [%rdi+40],	%ebx
    mov       [%rdi+16],	%rsi
    mov       [%rdi+24],	%r12
    mov       [%rdi+32],	%r13
    mov       %rax,	%rdi
L6289:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createconstunit
cc_lib.createconstunit:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    call      cc_lib.allocunitrec
    mov       %rdi,	%rax
    mov       %eax,	1
    mov       [%rdi+40],	%eax
    mov       [%rdi],	%rbx
    mov       [%rdi+52],	%esi
    mov       %rax,	%rdi
L6290:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createstringconstunit
cc_lib.createstringconstunit:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    call      cc_lib.allocunitrec
    mov       %rdi,	%rax
    mov       %eax,	1
    mov       [%rdi+40],	%eax
    mov       [%rdi],	%rbx
    mov       %eax,	[%rip+cc_decls.trefchar]
    mov       [%rdi+52],	%eax
    cmp       %rsi,	-1
    jnz       L6293
    mov       %rcx,	%rbx
    call      strlen
    inc       %rax
    mov       [%rdi+48],	%eax
    jmp       L6292
L6293:
    lea       %rax,	[%rsi+1]
    mov       [%rdi+48],	%eax
L6292:
    mov       %al,	1
    mov       [%rdi+61],	%al
    mov       %rax,	%rdi
L6291:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createwstringconstunit
cc_lib.createwstringconstunit:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    call      cc_lib.allocunitrec
    mov       %rdi,	%rax
    mov       %eax,	1
    mov       [%rdi+40],	%eax
    mov       [%rdi],	%rbx
    mov       %eax,	[%rip+cc_decls.trefwchar]
    mov       [%rdi+52],	%eax
    lea       %rax,	[%rsi+1]
    mov       [%rdi+48],	%eax
    mov       %al,	1
    mov       [%rdi+62],	%al
    mov       %rax,	%rdi
L6294:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.getoptocode
cc_lib.getoptocode:
#?>>
    .set cc_lib.getoptocode.str, -24
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	64
    mov       %r12,	%rcx
#---------------
    lea       %rax,	[%rip+cc_lib.getoptocode.opctotable]
    mov       %r10,	%r12
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L6297
    mov       %rax,	%rdi
    jmp       L6295
L6297:
    lea       %rax,	[%rip+cc_tables.jtagnames]
    mov       %r10,	%r12
    mov       %rax,	[%rax + %r10*8]
    lea       %rcx,	[%rbp + cc_lib.getoptocode.str]
    mov       %rdx,	%rax
    call      strcpy
    lea       %rcx,	[%rbp + cc_lib.getoptocode.str]
    lea       %rdx,	[%rip+L8754]
    call      strcat
    xor       %rbx,	%rbx
    mov       %rax,	77
    mov       %rsi,	%rax
    cmp       %rsi,	0
    jl        L6300
L6298:
    lea       %rax,	[%rip+cc_tables.jtagnames]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8]
    mov       %rcx,	%rax
    lea       %rdx,	[%rbp + cc_lib.getoptocode.str]
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L6302
    mov       %ax,	%bx
    lea       %r10,	[%rip+cc_lib.getoptocode.opctotable]
    mov       %r11,	%r12
    mov       [%r10 + %r11*2],	%ax
    mov       %rax,	%rbx
    jmp       L6295
L6302:
    inc       %rbx
    cmp       %rbx,	%rsi
    jle       L6298
L6300:
    call      msys.m$print_startcon
    lea       %rax,	[%rip+cc_tables.jtagnames]
    mov       %r10,	%r12
    mov       %rcx,	[%rax + %r10*8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8755]
    call      cc_support.serror
    xor       %eax,	%eax
L6295:
#---------------
    add       %rsp,	64
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.getconstvalue
cc_lib.getconstvalue:
#?>>
    .set cc_lib.getconstvalue.id, 32
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    test      %rdi,	%rdi
    jz        L6305
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	1
    jnz       L6305
    mov       %rax,	[%rdi]
    jmp       L6303
L6305:
    lea       %rcx,	[%rip+L8756]
    call      cc_support.serror
    xor       %eax,	%eax
L6303:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lib.nextautotype
cc_lib.nextautotype:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    lea       %rcx,	[%rip+cc_lib.nextautotype.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8757]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    inc       qword ptr[%rip+cc_lib.autotypeno]
    mov       %rcx,	[%rip+cc_lib.autotypeno]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rax,	[%rip+cc_lib.nextautotype.str]
L6306:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_lib.createconstmode
cc_lib.createconstmode:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    lea       %rax,	[%rip+cc_decls.ttconst]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L6309
    mov       %rax,	%rbx
    jmp       L6307
L6309:
    lea       %rax,	[%rip+cc_decls.ttconsttype]
    mov       %r10,	%rbx
    mov       %ax,	[%rax + %r10*2]
    test      %ax,	%ax
    jz        L6311
    lea       %rax,	[%rip+cc_decls.ttconsttype]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    jmp       L6307
L6311:
    mov       %rcx,	%rbx
    call      cc_lib.copymode
    mov       %rdi,	%rax
    mov       %ax,	%di
    lea       %r10,	[%rip+cc_decls.ttconsttype]
    mov       %r11,	%rbx
    mov       [%r10 + %r11*2],	%ax
    mov       %al,	1
    lea       %r10,	[%rip+cc_decls.ttconst]
    mov       %r11,	%rdi
    mov       [%r10 + %r11],	%al
    mov       %ax,	%bx
    lea       %r10,	[%rip+cc_decls.ttconsttype]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*2],	%ax
    mov       %rax,	%rdi
L6307:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createrefmode
cc_lib.createrefmode:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    lea       %rax,	[%rip+cc_decls.ttreftype]
    mov       %r10,	%rbx
    mov       %ax,	[%rax + %r10*2]
    test      %ax,	%ax
    jz        L6314
    lea       %rax,	[%rip+cc_decls.ttreftype]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    lea       %r10,	[%rip+cc_decls.ttshared]
    lea       %r10,	[%r10 + %rax*4]
    inc       dword ptr[%r10]
    lea       %rax,	[%rip+cc_decls.ttreftype]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    jmp       L6312
L6314:
    mov       %rcx,	13
    call      cc_lib.createnewmode
    mov       %rdi,	%rax
    mov       %ax,	%di
    lea       %r10,	[%rip+cc_decls.ttreftype]
    mov       %r11,	%rbx
    mov       [%r10 + %r11*2],	%ax
    mov       %ax,	%bx
    lea       %r10,	[%rip+cc_decls.tttarget]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*2],	%ax
    mov       %al,	1
    lea       %r10,	[%rip+cc_decls.ttisref]
    mov       %r11,	%rdi
    mov       [%r10 + %r11],	%al
    mov       %rax,	%rdi
L6312:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createprocmode
cc_lib.createprocmode:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rcx,	14
    call      cc_lib.createnewmode
    mov       %rdi,	%rax
    mov       %rax,	%rsi
    lea       %r10,	[%rip+cc_decls.ttparams]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*8],	%rax
    mov       %ax,	%bx
    lea       %r10,	[%rip+cc_decls.tttarget]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*2],	%ax
    mov       %rax,	%rdi
L6315:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createarraymode
cc_lib.createarraymode:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rcx,	17
    call      cc_lib.createnewmode
    mov       %rdi,	%rax
    mov       %ax,	%bx
    lea       %r10,	[%rip+cc_decls.tttarget]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*2],	%ax
    mov       %rax,	%rsi
    lea       %r10,	[%rip+cc_decls.ttlength]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*8],	%rax
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8]
    mov       %r10,	%rsi
    imul      %r10,	%rax
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r11,	%rdi
    mov       [%rax + %r11*8],	%r10
    mov       %al,	1
    lea       %r10,	[%rip+cc_decls.ttisblock]
    mov       %r11,	%rdi
    mov       [%r10 + %r11],	%al
    mov       %rax,	%rdi
L6316:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createenummode
cc_lib.createenummode:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rcx,	12
    call      cc_lib.createnewmode
    mov       %rdi,	%rax
    mov       %rax,	%rbx
    lea       %r10,	[%rip+cc_decls.ttnamedef]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*8],	%rax
    mov       %rax,	%rdi
L6317:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createstructmode
cc_lib.createstructmode:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rcx,	%rsi
    call      cc_lib.createnewmode
    mov       %rdi,	%rax
    mov       %rax,	%rbx
    lea       %r10,	[%rip+cc_decls.ttnamedef]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*8],	%rax
    mov       %al,	1
    lea       %r10,	[%rip+cc_decls.ttisblock]
    mov       %r11,	%rdi
    mov       [%r10 + %r11],	%al
    mov       %rax,	%rdi
L6318:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.setnameptr
cc_lib.setnameptr:
#?>>
#?]]
#---------------
    mov       %rax,	[%rcx]
    mov       %r10,	%rcx
    mov       [%rax+72],	%r10
#---------------
    ret       
# End 
# Proc cc_lib.getautofieldname
cc_lib.getautofieldname:
#?>>
    .set cc_lib.getautofieldname.str, -32
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	72
#---------------
    lea       %rcx,	[%rbp + cc_lib.getautofieldname.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8758]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    inc       qword ptr[%rip+cc_lib.nextafindex]
    mov       %rcx,	[%rip+cc_lib.nextafindex]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + cc_lib.getautofieldname.str]
    call      mlib.pcm_copyheapstring
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    call      cc_lex.addnamestr
L6320:
#---------------
    add       %rsp,	72
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc cc_lib.convertstringc
cc_lib.convertstringc:
#?>>
    .set cc_lib.convertstringc.str, -24
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	64
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
#---------------
    cmp       %r14,	-1
    jnz       L6323
    mov       %rcx,	%r12
    call      strlen
    mov       %r14,	%rax
L6323:
    mov       %rbx,	%r13
    mov       %rsi,	%r14
    cmp       %rsi,	0
    jle       L6326
L6324:
    mov       %rax,	%r12
    inc       %r12
    movzx     %rax,	byte ptr[%rax]
    mov       %rdi,	%rax
    lea       %rax,	[%rdi-7]
    cmp       %rax,	86
    jae       L6329
    lea       %r10,	[%rip+L6328]
    jmp       [%r10 + %rax*8]
    .data
L6328:
    .quad     L6336
    .quad     L6337
    .quad     L6334
    .quad     L6332
    .quad     L6339
    .quad     L6338
    .quad     L6333
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6330
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6331
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6329
    .quad     L6335
    .text
L6330:
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	34
    mov       [%rax],	%r10b
    jmp       L6327
L6331:
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	39
    mov       [%rax],	%r10b
    jmp       L6327
L6332:
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	110
    mov       [%rax],	%r10b
    jmp       L6327
L6333:
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	114
    mov       [%rax],	%r10b
    jmp       L6327
L6334:
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	116
    mov       [%rax],	%r10b
    jmp       L6327
L6335:
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	92
    mov       [%rax],	%r10b
    jmp       L6327
L6336:
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	97
    mov       [%rax],	%r10b
    jmp       L6327
L6337:
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	98
    mov       [%rax],	%r10b
    jmp       L6327
L6338:
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	102
    mov       [%rax],	%r10b
    jmp       L6327
L6339:
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	118
    mov       [%rax],	%r10b
    jmp       L6327
L6329:
    cmp       %rdi,	32
    jl        L6342
    cmp       %rdi,	127
    jl        L6341
L6342:
    lea       %rcx,	[%rbp + cc_lib.convertstringc.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8759]
    call      msys.m$print_setfmt
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8760]
    call      msys.m$print_i64
    call      msys.m$print_end
    mov       %al,	[%rbp + cc_lib.convertstringc.str]
    mov       %r10,	%r13
    inc       %r13
    mov       [%r10],	%al
    mov       %al,	[%rbp + cc_lib.convertstringc.str+1]
    mov       %r10,	%r13
    inc       %r13
    mov       [%r10],	%al
    mov       %al,	[%rbp + cc_lib.convertstringc.str+2]
    mov       %r10,	%r13
    inc       %r13
    mov       [%r10],	%al
    mov       %al,	[%rbp + cc_lib.convertstringc.str+3]
    mov       %r10,	%r13
    inc       %r13
    mov       [%r10],	%al
    jmp       L6340
L6341:
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	%dil
    mov       [%rax],	%r10b
L6340:
L6327:
    dec       %rsi
    jnz       L6324
L6326:
    xor       %eax,	%eax
    mov       [%r13],	%al
    mov       %rax,	%r13
    sub       %rax,	%rbx
L6321:
#---------------
    add       %rsp,	64
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.getopcjname
cc_lib.getopcjname:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    lea       %rax,	[%rip+cc_tables.jtagnames]
    mov       %r10,	%rsi
    mov       %rdi,	[%rax + %r10*8]
    mov       %rcx,	%rdi
    mov       %rdx,	32
    call      strchr
    mov       %rbx,	%rax
    test      %rbx,	%rbx
    jz        L6345
    mov       %rax,	%rbx
    sub       %rax,	%rdi
    lea       %rcx,	[%rip+cc_lib.getopcjname.str]
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      memcpy
    mov       %rax,	%rbx
    sub       %rax,	%rdi
    xor       %r10d,	%r10d
    lea       %r11,	[%rip+cc_lib.getopcjname.str]
    mov       [%r11 + %rax],	%r10b
    lea       %rax,	[%rip+cc_lib.getopcjname.str]
    jmp       L6344
L6345:
    mov       %rax,	%rdi
L6344:
L6343:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.strmode
cc_lib.strmode:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    lea       %r8,	[%rip+cc_lib.strmode.str]
    call      cc_lib.istrmode
    lea       %rax,	[%rip+cc_lib.strmode.str]
L6346:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.strmode2
cc_lib.strmode2:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    lea       %r8,	[%rip+cc_lib.strmode2.str]
    call      cc_lib.istrmode
    lea       %rax,	[%rip+cc_lib.strmode2.str]
L6347:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.istrmode
cc_lib.istrmode:
#?>>
    .set cc_lib.istrmode.expand, 80
    .set cc_lib.istrmode.dest, 88
    .set cc_lib.istrmode.n, -8
    .set cc_lib.istrmode.sxx, -24
    .set cc_lib.istrmode.xx, -32
    .set cc_lib.istrmode.pm, -40
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	72
    mov       %r15,	%rcx
    mov       [%rbp+80],	%rdx
    mov       [%rbp+88],	%r8
#---------------
    lea       %rax,	[%rbp + cc_lib.istrmode.sxx]
    mov       [%rbp + cc_lib.istrmode.xx],	%rax
    cmp       %r15,	21
    jge       L6350
    mov       %rcx,	%r15
    call      cc_lib.typename
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    mov       %rdx,	%rax
    call      strcpy
    jmp       L6348
L6350:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%r15
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %r14,	%rax
    mov       %rax,	%r14
    cmp       %rax,	13
    jz        L6352
    cmp       %rax,	17
    jz        L6353
    cmp       %rax,	12
    jz        L6354
    cmp       %rax,	18
    jz        L6355
    cmp       %rax,	19
    jz        L6355
    test      %rax,	%rax
    jz        L6356
    cmp       %rax,	14
    jz        L6357
    jmp       L6358
L6352:
    lea       %rax,	[%rip+cc_decls.ttconst]
    mov       %r10,	%r15
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L6360
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    lea       %rdx,	[%rip+L8761]
    call      strcpy
    jmp       L6359
L6360:
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    lea       %rdx,	[%rip+L8762]
    call      strcpy
L6359:
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%r15
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %r13,	%rax
    cmp       %r13,	0
    jl        L6362
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%r15
    movsx     %rax,	word ptr[%rax + %r10*2]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    cmp       %r10,	18
    jnz       L6362
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%r15
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rcx,	%rax
    call      cc_lib.typename
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    mov       %rdx,	%rax
    call      strcat
    jmp       L6361
L6362:
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    call      strlen
    mov       %r10,	[%rbp + cc_lib.istrmode.dest]
    lea       %r10,	[%r10 + %rax]
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r11,	%r15
    movsx     %rax,	word ptr[%rax + %r11*2]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    mov       %r8,	%r10
    call      cc_lib.istrmode
L6361:
    jmp       L6351
L6353:
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%r15
    mov       %rax,	[%rax + %r10*8]
    test      %rax,	%rax
    jz        L6364
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8763]
    call      msys.m$print_setfmt
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%r15
    mov       %rcx,	[%rax + %r10*8]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L6363
L6364:
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    lea       %rdx,	[%rip+L8764]
    call      strcpy
L6363:
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    call      strlen
    mov       %r10,	[%rbp + cc_lib.istrmode.dest]
    lea       %r10,	[%r10 + %rax]
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r11,	%r15
    movsx     %rax,	word ptr[%rax + %r11*2]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    mov       %r8,	%r10
    call      cc_lib.istrmode
    jmp       L6351
L6354:
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    lea       %rdx,	[%rip+L8765]
    call      strcpy
    mov       %rcx,	%r15
    call      cc_lib.typename
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    mov       %rdx,	%rax
    call      strcat
    jmp       L6351
L6355:
    mov       %rax,	[%rbp + cc_lib.istrmode.expand]
    test      %rax,	%rax
    jnz       L6366
    mov       %rcx,	%r15
    call      cc_lib.typename
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    mov       %rdx,	%rax
    call      strcpy
    jmp       L6348
L6366:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%r15
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rcx,	%rax
    call      cc_lib.typename
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    mov       %rdx,	%rax
    call      strcpy
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    lea       %rdx,	[%rip+L8766]
    call      strcat
    lea       %rax,	[%rip+cc_decls.ttnamedef]
    mov       %r10,	%r15
    mov       %rdi,	[%rax + %r10*8]
    xor       %rsi,	%rsi
    mov       %rax,	[%rdi+16]
    mov       %rbx,	%rax
    jmp       L6368
L6367:
    test      %rsi,	%rsi
    jz        L6371
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    lea       %rdx,	[%rip+L8767]
    call      strcat
L6371:
    mov       %rsi,	1
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    call      strlen
    mov       %r10,	[%rbp + cc_lib.istrmode.dest]
    lea       %r10,	[%r10 + %rax]
    movzx     %rax,	word ptr[%rbx+102]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    mov       %r8,	%r10
    call      cc_lib.istrmode
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    lea       %rdx,	[%rip+L8768]
    call      strcat
    mov       %rax,	[%rbx]
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    mov       %rdx,	%rax
    call      strcat
    mov       %rbx,	[%rbx+32]
L6368:
    test      %rbx,	%rbx
    jnz       L6367
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    lea       %rdx,	[%rip+L8769]
    call      strcat
    jmp       L6351
L6356:
    mov       %rcx,	%r15
    call      cc_lib.typename
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    mov       %rdx,	%rax
    call      strcpy
    jmp       L6351
L6357:
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    lea       %rdx,	[%rip+L8770]
    call      strcpy
    lea       %rax,	[%rip+cc_decls.ttparams]
    mov       %r10,	%r15
    mov       %rax,	[%rax + %r10*8]
    mov       [%rbp + cc_lib.istrmode.pm],	%rax
    mov       %rax,	[%rbp + cc_lib.istrmode.pm]
    movsx     %rax,	word ptr[%rax+20]
    mov       [%rbp + cc_lib.istrmode.n],	%rax
    mov       %r12,	1
    mov       %rax,	[%rbp + cc_lib.istrmode.n]
    cmp       %rax,	1
    jl        L6374
L6372:
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    call      strlen
    mov       %r10,	[%rbp + cc_lib.istrmode.dest]
    lea       %r10,	[%r10 + %rax]
    mov       %rax,	[%rbp + cc_lib.istrmode.pm]
    movsxd    %rax,	dword ptr[%rax+16]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    mov       %r8,	%r10
    call      cc_lib.istrmode
    cmp       %r12,	[%rbp + cc_lib.istrmode.n]
    jz        L6376
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    lea       %rdx,	[%rip+L8771]
    call      strcat
L6376:
    mov       %rax,	[%rbp + cc_lib.istrmode.pm]
    mov       %rax,	[%rax+8]
    mov       [%rbp + cc_lib.istrmode.pm],	%rax
    inc       %r12
    cmp       %r12,	[%rbp + cc_lib.istrmode.n]
    jle       L6372
L6374:
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    lea       %rdx,	[%rip+L8772]
    call      strcat
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    call      strlen
    mov       %r10,	[%rbp + cc_lib.istrmode.dest]
    lea       %r10,	[%r10 + %rax]
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r11,	%r15
    movsx     %rax,	word ptr[%rax + %r11*2]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    mov       %r8,	%r10
    call      cc_lib.istrmode
    jmp       L6351
L6358:
    cmp       %r14,	21
    jge       L6378
    mov       %rcx,	%r15
    call      cc_lib.typename
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    mov       %rdx,	%rax
    call      strcpy
    jmp       L6348
L6378:
    call      msys.m$print_startcon
    mov       %rcx,	%r15
    call      cc_lib.typename
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8773]
    call      cc_support.mcerror
L6377:
L6351:
L6348:
#---------------
    add       %rsp,	72
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.typename
cc_lib.typename:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rdi,	%rax
    mov       %rax,	%rdi
    cmp       %rax,	18
    jz        L6381
    cmp       %rax,	19
    jz        L6381
    cmp       %rax,	17
    jz        L6382
    cmp       %rax,	12
    jz        L6383
    jmp       L6384
L6381:
    cmp       %rdi,	18
    jnz       L6386
    lea       %rax,	[%rip+L8774]
    jmp       L6385
L6386:
    lea       %rax,	[%rip+L8775]
L6385:
    lea       %rcx,	[%rip+cc_lib.typename.str]
    mov       %rdx,	%rax
    call      strcpy
    lea       %rax,	[%rip+cc_decls.ttnamedef]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8]
    test      %rax,	%rax
    jz        L6388
    lea       %rax,	[%rip+cc_decls.ttnamedef]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8]
    mov       %rax,	[%rax]
    lea       %rcx,	[%rip+cc_lib.typename.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rcx,	[%rip+cc_lib.typename.str]
    lea       %rdx,	[%rip+L8776]
    call      strcat
    lea       %rax,	[%rip+cc_decls.ttnamedef]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8]
    movzx     %rax,	word ptr[%rax+96]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.strint
    lea       %rcx,	[%rip+cc_lib.typename.str]
    mov       %rdx,	%rax
    call      strcat
L6388:
    lea       %rax,	[%rip+cc_lib.typename.str]
    jmp       L6379
L6382:
    lea       %rax,	[%rip+L8777]
    jmp       L6379
L6383:
    lea       %rax,	[%rip+cc_decls.ttnamedef]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8]
    test      %rax,	%rax
    jz        L6390
    lea       %rax,	[%rip+cc_decls.ttnamedef]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8]
    mov       %rax,	[%rax]
    jmp       L6379
L6390:
    lea       %rax,	[%rip+L8778]
    jmp       L6379
L6384:
    lea       %rax,	[%rip+cc_decls.ttconst]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L6392
    lea       %rcx,	[%rip+cc_lib.typename.str]
    lea       %rdx,	[%rip+L8779]
    call      strcpy
    lea       %rax,	[%rip+cc_tables.stdtypenames]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    lea       %rcx,	[%rip+cc_lib.typename.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rax,	[%rip+cc_lib.typename.str]
    jmp       L6379
L6392:
    lea       %rax,	[%rip+cc_tables.stdtypenames]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    jmp       L6379
L6380:
    lea       %rax,	[%rip+L8780]
L6379:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.allocunitrec
cc_lib.allocunitrec:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    inc       qword ptr[%rip+cc_decls.nunits]
    mov       %rax,	[%rip+cc_lib.remainingunits]
    dec       qword ptr[%rip+cc_lib.remainingunits]
    test      %rax,	%rax
    jz        L6395
    mov       %rdi,	[%rip+cc_lib.unitheapptr]
    add       qword ptr[%rip+cc_lib.unitheapptr],	64
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %eax,	[%rax+16]
    mov       [%rdi+44],	%eax
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+20]
    cmp       %rax,	255
    jg        L6397
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %al,	[%rax+20]
    mov       [%rdi+60],	%al
L6397:
    mov       %rax,	%rdi
    jmp       L6393
L6395:
    mov       %rcx,	3200000
    call      mlib.pcm_alloc
    mov       [%rip+cc_lib.unitheapptr],	%rax
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    mov       %r8,	3200000
    call      memset
    mov       %rax,	49999
    mov       [%rip+cc_lib.remainingunits],	%rax
    add       qword ptr[%rip+cc_lib.unitheapptr],	64
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %eax,	[%rax+16]
    mov       [%rdi+44],	%eax
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+20]
    cmp       %rax,	255
    jg        L6399
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %al,	[%rax+20]
    mov       [%rdi+60],	%al
L6399:
    mov       %rax,	%rdi
L6393:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lib.copymode
cc_lib.copymode:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	[%rip+cc_decls.ntypes]
    cmp       %rax,	80000
    jl        L6402
    lea       %rcx,	[%rip+L8781]
    call      cc_support.serror
L6402:
    inc       qword ptr[%rip+cc_decls.ntypes]
    lea       %rax,	[%rip+cc_decls.ttnamedef]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    lea       %r10,	[%rip+cc_decls.ttnamedef]
    mov       %r11,	[%rip+cc_decls.ntypes]
    mov       [%r10 + %r11*8],	%rax
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rdi
    mov       %ax,	[%rax + %r10*2]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    mov       %r11,	[%rip+cc_decls.ntypes]
    mov       [%r10 + %r11*2],	%ax
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    lea       %r10,	[%rip+cc_decls.ttlength]
    mov       %r11,	[%rip+cc_decls.ntypes]
    mov       [%r10 + %r11*8],	%rax
    lea       %rax,	[%rip+cc_decls.ttconst]
    mov       %r10,	%rdi
    mov       %al,	[%rax + %r10]
    lea       %r10,	[%rip+cc_decls.ttconst]
    mov       %r11,	[%rip+cc_decls.ntypes]
    mov       [%r10 + %r11],	%al
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r11,	[%rip+cc_decls.ntypes]
    mov       [%r10 + %r11*8],	%rax
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%rdi
    mov       %ax,	[%rax + %r10*2]
    lea       %r10,	[%rip+cc_decls.tttarget]
    mov       %r11,	[%rip+cc_decls.ntypes]
    mov       [%r10 + %r11*2],	%ax
    lea       %rax,	[%rip+cc_decls.ttparams]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    lea       %r10,	[%rip+cc_decls.ttparams]
    mov       %r11,	[%rip+cc_decls.ntypes]
    mov       [%r10 + %r11*8],	%rax
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%rdi
    mov       %al,	[%rax + %r10]
    lea       %r10,	[%rip+cc_decls.ttisref]
    mov       %r11,	[%rip+cc_decls.ntypes]
    mov       [%r10 + %r11],	%al
    lea       %rax,	[%rip+cc_decls.ttisblock]
    mov       %r10,	%rdi
    mov       %al,	[%rax + %r10]
    lea       %r10,	[%rip+cc_decls.ttisblock]
    mov       %r11,	[%rip+cc_decls.ntypes]
    mov       [%r10 + %r11],	%al
    mov       %rax,	[%rip+cc_decls.ntypes]
L6400:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createnewmode
cc_lib.createnewmode:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	[%rip+cc_decls.ntypes]
    cmp       %rax,	80000
    jl        L6405
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8782]
    call      msys.m$print_str_nf
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8783]
    call      cc_support.serror
L6405:
    inc       qword ptr[%rip+cc_decls.ntypes]
    mov       %ax,	%di
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    mov       %r11,	[%rip+cc_decls.ntypes]
    mov       [%r10 + %r11*2],	%ax
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r11,	[%rip+cc_decls.ntypes]
    mov       [%r10 + %r11*8],	%rax
    mov       %rax,	[%rip+cc_decls.ntypes]
L6403:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lib.addlistunit
cc_lib.addlistunit:
#?>>
#?]]
#---------------
    mov       %rax,	[%rcx]
    test      %rax,	%rax
    jnz       L6408
    mov       %rax,	%r8
    mov       [%rdx],	%rax
    mov       [%rcx],	%rax
    jmp       L6407
L6408:
    mov       %rax,	[%rdx]
    mov       %r10,	%r8
    mov       [%rax+8],	%r10
L6407:
    xor       %eax,	%eax
    mov       [%r8+8],	%rax
    mov       [%rdx],	%r8
#---------------
    ret       
# End 
# Proc cc_lib.addlistdef
cc_lib.addlistdef:
#?>>
#?]]
#---------------
    mov       %rax,	[%rcx]
    test      %rax,	%rax
    jnz       L6411
    mov       %rax,	%r8
    mov       [%rdx],	%rax
    mov       [%rcx],	%rax
    jmp       L6410
L6411:
    mov       %rax,	[%rdx]
    mov       %r10,	%r8
    mov       [%rax+32],	%r10
L6410:
    xor       %eax,	%eax
    mov       [%r8+32],	%rax
    mov       [%rdx],	%r8
#---------------
    ret       
# End 
# Proc cc_lib.addlistparam
cc_lib.addlistparam:
#?>>
#?]]
#---------------
    mov       %rax,	[%rcx]
    test      %rax,	%rax
    jnz       L6414
    mov       %rax,	%r8
    mov       [%rdx],	%rax
    mov       [%rcx],	%rax
    jmp       L6413
L6414:
    mov       %rax,	[%rdx]
    mov       %r10,	%r8
    mov       [%rax+8],	%r10
L6413:
    xor       %eax,	%eax
    mov       [%r8+8],	%rax
    mov       [%rdx],	%r8
#---------------
    ret       
# End 
# Proc cc_lib.checksymbol
cc_lib.checksymbol:
#?>>
    .set cc_lib.checksymbol.str, -256
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	296
    mov       %rdi,	%rcx
#---------------
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	%rdi
    jz        L6417
    lea       %rcx,	[%rbp + cc_lib.checksymbol.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8784]
    call      msys.m$print_setfmt
    lea       %rax,	[%rip+cc_tables.symbolnames]
    mov       %r10,	%rdi
    mov       %rcx,	[%rax + %r10*8-8]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    lea       %r10,	[%rip+cc_tables.symbolnames]
    mov       %r10,	[%r10 + %rax*8-8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jnz       L6419
    lea       %rcx,	[%rbp + cc_lib.checksymbol.str]
    lea       %rdx,	[%rip+L8785]
    call      strcat
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    call      cc_lib.getstname
    lea       %rcx,	[%rbp + cc_lib.checksymbol.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rcx,	[%rbp + cc_lib.checksymbol.str]
    lea       %rdx,	[%rip+L8786]
    call      strcat
L6419:
    lea       %rcx,	[%rbp + cc_lib.checksymbol.str]
    call      cc_support.serror
L6417:
#---------------
    add       %rsp,	296
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc cc_lib.skipsymbol
cc_lib.skipsymbol:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	%rdi
    jz        L6422
    mov       %rcx,	%rdi
    call      cc_lib.checksymbol
L6422:
    call      cc_lex.lex
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lib.inittypetables
cc_lib.inittypetables:
#?>>
    .set cc_lib.inittypetables.av_2, -8
    .set cc_lib.inittypetables.av_3, -16
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	56
#---------------
    xor       %rdi,	%rdi
    mov       %rax,	20
    mov       %r15,	%rax
    cmp       %r15,	0
    jl        L6426
L6424:
    mov       %ax,	%di
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*2],	%ax
    lea       %rax,	[%rip+cc_tables.stdtypewidths]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %rsi,	%rax
    mov       %rax,	%rsi
    sar       %rax,	3
    mov       %rbx,	%rax
    mov       %rax,	%rbx
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*8],	%rax
    mov       %rax,	%rdi
    cmp       %rax,	17
    jz        L6429
    cmp       %rax,	18
    jnz       L6428
L6429:
    mov       %al,	1
    lea       %r10,	[%rip+cc_decls.ttisblock]
    mov       %r11,	%rdi
    mov       [%r10 + %r11],	%al
L6428:
    inc       %rdi
    cmp       %rdi,	%r15
    jle       L6424
L6426:
    mov       %rax,	20
    mov       [%rip+cc_decls.ntypes],	%rax
    mov       %rcx,	1
    call      cc_lib.createrefmode
    mov       [%rip+cc_decls.trefchar],	%rax
    mov       %rcx,	7
    call      cc_lib.createrefmode
    mov       [%rip+cc_decls.trefwchar],	%rax
    mov       %rdi,	1
    mov       %rax,	121
    mov       [%rbp + cc_lib.inittypetables.av_2],	%rax
    mov       %rax,	[%rbp + cc_lib.inittypetables.av_2]
    cmp       %rax,	1
    jl        L6432
L6430:
    lea       %rax,	[%rip+cc_tables.dominantsetuptable]
    mov       %r10,	%rdi
    lea       %r10,	[%r10 + %r10*2]
    lea       %rax,	[%rax + %r10-3]
    movzx     %rax,	byte ptr[%rax]
    mov       %r12,	%rax
    lea       %rax,	[%rip+cc_tables.dominantsetuptable]
    mov       %r10,	%rdi
    lea       %r10,	[%r10 + %r10*2]
    lea       %rax,	[%rax + %r10-3]
    movzx     %rax,	byte ptr[%rax+1]
    mov       %r13,	%rax
    lea       %rax,	[%rip+cc_tables.dominantsetuptable]
    mov       %r10,	%rdi
    lea       %r10,	[%r10 + %r10*2]
    lea       %rax,	[%rax + %r10-3]
    movzx     %rax,	byte ptr[%rax+2]
    mov       %r14,	%rax
    lea       %rax,	[%rip+cc_tables.dominantmode]
    mov       %r10,	%r12
    shl       %r10,	5
    lea       %rax,	[%rax + %r10]
    mov       %r10b,	%r14b
    mov       %r11,	%r13
    mov       [%rax + %r11],	%r10b
    inc       %rdi
    cmp       %rdi,	[%rbp + cc_lib.inittypetables.av_2]
    jle       L6430
L6432:
    mov       %rdi,	1
    mov       %rax,	121
    mov       [%rbp + cc_lib.inittypetables.av_3],	%rax
    mov       %rax,	[%rbp + cc_lib.inittypetables.av_3]
    cmp       %rax,	1
    jl        L6435
L6433:
    lea       %rax,	[%rip+cc_tables.convsetuptable]
    mov       %r10,	%rdi
    lea       %r10,	[%r10 + %r10*2]
    lea       %rax,	[%rax + %r10-3]
    movzx     %rax,	byte ptr[%rax]
    mov       %r12,	%rax
    lea       %rax,	[%rip+cc_tables.convsetuptable]
    mov       %r10,	%rdi
    lea       %r10,	[%r10 + %r10*2]
    lea       %rax,	[%rax + %r10-3]
    movzx     %rax,	byte ptr[%rax+1]
    mov       %r13,	%rax
    lea       %rax,	[%rip+cc_tables.convsetuptable]
    mov       %r10,	%rdi
    lea       %r10,	[%r10 + %r10*2]
    lea       %rax,	[%rax + %r10-3]
    movzx     %rax,	byte ptr[%rax+2]
    mov       %r14,	%rax
    lea       %rax,	[%rip+cc_tables.conversionops]
    mov       %r10,	%r12
    shl       %r10,	4
    lea       %rax,	[%rax + %r10]
    mov       %r10b,	%r14b
    mov       %r11,	%r13
    mov       [%rax + %r11],	%r10b
    inc       %rdi
    cmp       %rdi,	[%rbp + cc_lib.inittypetables.av_3]
    jle       L6433
L6435:
#---------------
    add       %rsp,	56
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createdupldef
cc_lib.createdupldef:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
    call      cc_lib.newstrec
    mov       %rdi,	%rax
    mov       %rax,	[%r12]
    mov       [%rdi],	%rax
    mov       %al,	[%r12+106]
    mov       [%rdi+106],	%al
    mov       %al,	67
    mov       [%rdi+107],	%al
    mov       [%rdi+8],	%rsi
    mov       [%rdi+109],	%r13b
    lea       %rax,	[%rip+cc_tables.namespaces]
    mov       %r10,	%r13
    mov       %eax,	[%rax + %r10*4]
    mov       [%rdi+98],	%ax
    mov       %rax,	[%r12+40]
    mov       %rbx,	%rax
    test      %rax,	%rax
    jz        L6438
    mov       [%rbx+48],	%rdi
L6438:
    mov       [%rdi+40],	%rbx
    mov       [%rdi+48],	%r12
    mov       [%r12+40],	%rdi
    test      %rsi,	%rsi
    jz        L6440
    mov       %rax,	[%rsi+16]
    test      %rax,	%rax
    jnz       L6442
    mov       %rax,	%rdi
    mov       [%rsi+24],	%rax
    mov       [%rsi+16],	%rax
    jmp       L6441
L6442:
    mov       %rax,	[%rsi+24]
    mov       %r10,	%rdi
    mov       [%rax+32],	%r10
    mov       [%rsi+24],	%rdi
L6441:
L6440:
    mov       %rax,	%rdi
L6436:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createnewmoduledef
cc_lib.createnewmoduledef:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	3
    call      cc_lib.createdupldef
    mov       %rdi,	%rax
    mov       %rax,	%rdi
L6443:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createnewproc
cc_lib.createnewproc:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	6
    call      cc_lib.createdupldef
    mov       %rdi,	%rax
    mov       %rbx,	%rdi
    jmp       L6446
L6445:
    mov       %rax,	[%rbx+8]
    cmp       %rax,	%rsi
    jnz       L6449
    call      msys.m$print_startcon
    mov       %rcx,	[%rbx]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L8787]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rsi]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8788]
    call      cc_support.serror
L6449:
L6446:
    mov       %rax,	[%rbx+40]
    mov       %rbx,	%rax
    test      %rax,	%rax
    jnz       L6445
    mov       %rax,	%rdi
L6444:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.resolvename
cc_lib.resolvename:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
    mov       %r14,	%r9
#---------------
    movzx     %rax,	byte ptr[%r12+109]
    cmp       %rax,	1
    jle       L6452
    mov       %rax,	%r12
    jmp       L6450
L6452:
    cmp       %r13,	3
    jnz       L6454
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    call      cc_lib.resolvelabel
    jmp       L6450
L6454:
    test      %r14,	%r14
    jz        L6456
    lea       %rax,	[%rip+cc_decls.blockcounts]
    mov       %r10,	%r14
    movsxd    %rax,	dword ptr[%rax + %r10*4]
    test      %rax,	%rax
    jnz       L6456
    lea       %rax,	[%rip+cc_decls.blockowner]
    mov       %r10,	%r14
    movsxd    %rax,	dword ptr[%rax + %r10*4]
    mov       %r14,	%rax
L6456:
L6457:
    mov       %rax,	%r13
    shl       %rax,	16
    or        %rax,	%r14
    mov       %rdi,	%rax
    mov       %rbx,	%r12
    jmp       L6460
L6459:
    movzx     %rax,	byte ptr[%rsi+109]
    cmp       %rax,	6
    jnz       L6463
    mov       %rax,	[%rbx+8]
    cmp       %rax,	%rsi
    jz        L6463
    mov       %rax,	[%rbx+8]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	6
    jz        L6461
L6463:
    mov       %rax,	[%rbx+8]
    cmp       %rax,	%rsi
    jnz       L6465
    mov       %eax,	[%rbx+96]
    cmp       %rax,	%rdi
    jnz       L6465
    movzx     %rax,	byte ptr[%rbx+122]
    cmp       %rax,	255
    jge       L6467
    lea       %rax,	[%rbx+122]
    inc       byte ptr[%rax]
L6467:
    mov       %rax,	%rbx
    jmp       L6450
L6465:
L6460:
    mov       %rax,	[%rbx+40]
    mov       %rbx,	%rax
    test      %rax,	%rax
    jnz       L6459
L6461:
    test      %r14,	%r14
    jnz       L6469
    movzx     %rax,	byte ptr[%rsi+109]
    cmp       %rax,	6
    jz        L6471
    cmp       %rax,	13
    jz        L6472
    jmp       L6473
L6471:
    mov       %rsi,	[%rip+cc_decls.stmodule]
    jmp       L6457
L6472:
    mov       %rsi,	[%rsi+8]
    test      %rsi,	%rsi
    jnz       L6475
    xor       %eax,	%eax
    jmp       L6450
L6475:
    jmp       L6470
L6473:
    xor       %eax,	%eax
    jmp       L6450
L6470:
    jmp       L6468
L6469:
    lea       %rax,	[%rip+cc_decls.blockowner]
    mov       %r10,	%r14
    movsxd    %rax,	dword ptr[%rax + %r10*4]
    mov       %r14,	%rax
    test      %rax,	%rax
    jnz       L6476
    mov       %rsi,	[%rip+cc_decls.stmodule]
L6476:
L6468:
    jmp       L6457
    xor       %eax,	%eax
L6450:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.resolvelabel
cc_lib.resolvelabel:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	16
#---------------
    mov       %rdi,	%rdx
    jmp       L6479
L6478:
    movzx     %rax,	byte ptr[%rcx+109]
    cmp       %rax,	6
    jnz       L6482
    mov       %rax,	[%rdi+8]
    cmp       %rax,	%rcx
    jz        L6482
    mov       %rax,	[%rdi+8]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	6
    jz        L6480
L6482:
    mov       %rax,	[%rdi+8]
    cmp       %rax,	%rcx
    jnz       L6484
    movzx     %rax,	word ptr[%rdi+98]
    cmp       %rax,	3
    jnz       L6484
    mov       %rax,	%rdi
    jmp       L6477
L6484:
L6479:
    mov       %rax,	[%rdi+40]
    mov       %rdi,	%rax
    test      %rax,	%rax
    jnz       L6478
L6480:
    xor       %eax,	%eax
L6477:
#---------------
    add       %rsp,	16
    pop       %rdi
    ret       
# End 
# Proc cc_lib.checkdupl
cc_lib.checkdupl:
#?>>
    push      %rdi
    push      %rbx
#?]]
#---------------
    mov       %rbx,	%rdx
    mov       %rax,	%r8
    shl       %rax,	16
    or        %rax,	%r9
    mov       %rdi,	%rax
    jmp       L6487
L6486:
    mov       %rax,	[%rbx+8]
    cmp       %rax,	%rcx
    jnz       L6490
    mov       %eax,	[%rbx+96]
    cmp       %rax,	%rdi
    jnz       L6490
    mov       %rax,	%rbx
    jmp       L6485
L6490:
L6487:
    mov       %rax,	[%rbx+40]
    mov       %rbx,	%rax
    test      %rax,	%rax
    jnz       L6486
    xor       %eax,	%eax
L6485:
#---------------
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.checkdupl_inproc
cc_lib.checkdupl_inproc:
#?>>
    push      %rdi
    push      %rbx
#?]]
#---------------
    mov       %rbx,	%rdx
    mov       %rax,	%r8
    shl       %rax,	16
    or        %rax,	%r9
    mov       %rdi,	%rax
    jmp       L6493
L6492:
    mov       %eax,	[%rbx+96]
    cmp       %rax,	%rdi
    jnz       L6496
    mov       %rax,	%rbx
    jmp       L6491
L6496:
L6493:
    mov       %rax,	[%rbx+40]
    mov       %rbx,	%rax
    test      %rax,	%rax
    jz        L6497
    mov       %rax,	[%rbx+8]
    cmp       %rax,	%rcx
    jz        L6492
L6497:
    xor       %eax,	%eax
L6491:
#---------------
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.getalignment
cc_lib.getalignment:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jz        L6500
    cmp       %rax,	18
    jz        L6501
    cmp       %rax,	19
    jz        L6501
    jmp       L6502
L6500:
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rcx,	%rax
    call      cc_lib.getalignment
    jmp       L6498
L6501:
    lea       %rax,	[%rip+cc_decls.ttnamedef]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8]
    movzx     %rax,	byte ptr[%rax+112]
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L6504
    mov       %rax,	16
    jmp       L6498
L6504:
    mov       %rax,	%rdi
    jmp       L6498
L6502:
L6499:
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rbx
    mov       %rdi,	[%rax + %r10*8]
    mov       %rax,	%rdi
    cmp       %rax,	1
    jz        L6506
    cmp       %rax,	2
    jz        L6506
    cmp       %rax,	4
    jz        L6506
    cmp       %rax,	8
    jnz       L6507
L6506:
    mov       %rax,	%rdi
    jmp       L6498
L6507:
L6505:
    call      msys.m$print_startcon
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    mov       %rcx,	%rdi
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8789]
    call      cc_support.serror
    xor       %eax,	%eax
L6498:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.isexported
cc_lib.isexported:
#?>>
#?]]
#---------------
    movzx     %rax,	byte ptr[%rcx+109]
    cmp       %rax,	6
    jnz       L6510
    mov       %rax,	[%rcx+72]
    test      %rax,	%rax
    jz        L6512
    movzx     %rax,	byte ptr[%rcx+110]
    cmp       %rax,	3
    jz        L6513
    movzx     %rax,	byte ptr[%rcx+110]
    cmp       %rax,	4
    jnz       L6512
L6513:
    mov       %rax,	1
    jmp       L6508
L6512:
    jmp       L6509
L6510:
    movzx     %rax,	byte ptr[%rcx+110]
    cmp       %rax,	4
    jnz       L6515
    mov       %rax,	1
    jmp       L6508
L6515:
L6509:
    xor       %eax,	%eax
L6508:
#---------------
    ret       
# End 
# Proc cc_lib.isimported
cc_lib.isimported:
#?>>
#?]]
#---------------
    movzx     %rax,	byte ptr[%rcx+109]
    cmp       %rax,	6
    jnz       L6518
    mov       %rax,	[%rcx+72]
    test      %rax,	%rax
    jnz       L6520
    movzx     %rax,	byte ptr[%rcx+110]
    cmp       %rax,	3
    jz        L6521
    movzx     %rax,	byte ptr[%rcx+110]
    cmp       %rax,	4
    jnz       L6520
L6521:
    mov       %rax,	1
    jmp       L6516
L6520:
    jmp       L6517
L6518:
    movzx     %rax,	byte ptr[%rcx+110]
    cmp       %rax,	3
    jnz       L6523
    mov       %rax,	1
    jmp       L6516
L6523:
L6517:
    xor       %eax,	%eax
L6516:
#---------------
    ret       
# End 
# Proc cc_lib.getstname
cc_lib.getstname:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rdi+106]
    mov       %r10,	[%rdi]
    lea       %rcx,	[%rip+cc_lib.getstname.name]
    mov       %rdx,	%r10
    mov       %r8,	%rax
    call      memcpy
    movzx     %rax,	byte ptr[%rdi+106]
    xor       %r10d,	%r10d
    lea       %r11,	[%rip+cc_lib.getstname.name]
    mov       [%r11 + %rax],	%r10b
    lea       %rax,	[%rip+cc_lib.getstname.name]
L6524:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lib.isrealcc
cc_lib.isrealcc:
#?>>
#?]]
#---------------
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rcx
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rcx,	%rax
    mov       %rax,	%rcx
    cmp       %rax,	10
    jl        L6526
    cmp       %rax,	11
    jg        L6526
    mov       %rax,	1
    jmp       L6527
L6526:
    xor       %eax,	%eax
L6527:
L6525:
#---------------
    ret       
# End 
# Proc cc_lib.isintcc
cc_lib.isintcc:
#?>>
#?]]
#---------------
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rcx
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rcx,	%rax
    mov       %rax,	%rcx
    cmp       %rax,	1
    jl        L6529
    cmp       %rax,	9
    jg        L6529
    mov       %rax,	1
    jmp       L6530
L6529:
    xor       %eax,	%eax
L6530:
L6528:
#---------------
    ret       
# End 
# Proc cc_lib.writegsfile
cc_lib.writegsfile:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rcx,	%rbx
    lea       %rdx,	[%rip+L8790]
    call      fopen
    mov       %rdi,	%rax
    mov       %rcx,	%rsi
    mov       %rdx,	%rdi
    call      mlib.gs_println
    mov       %rcx,	%rdi
    call      fclose
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.pause
cc_lib.pause:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    call      msys.m$print_startcon
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    call      msys.m$print_end
    call      mnoos.os_getch
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lib.getpclmode
cc_lib.getpclmode:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	16
#---------------
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rcx
    movsx     %rax,	word ptr[%rax + %r10*2]
    lea       %r10,	[%rip+cc_tables.stdpcl]
    movzx     %r10,	byte ptr[%r10 + %rax]
    mov       %rdi,	%r10
    cmp       %rdi,	11
    jnz       L6535
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rcx
    mov       %rax,	[%rax + %r10*8]
    cmp       %rax,	8
    jz        L6537
    cmp       %rax,	4
    jz        L6538
    cmp       %rax,	2
    jz        L6539
    cmp       %rax,	1
    jz        L6540
    jmp       L6541
L6537:
    mov       %rdi,	6
    jmp       L6536
L6538:
    mov       %rdi,	5
    jmp       L6536
L6539:
    mov       %rdi,	4
    jmp       L6536
L6540:
    mov       %rdi,	3
L6541:
L6536:
L6535:
    mov       %rax,	%rdi
L6533:
#---------------
    add       %rsp,	16
    pop       %rdi
    ret       
# End 
# Proc cc_lib.addtolog
cc_lib.addtolog:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    mov       %rcx,	%rsi
    lea       %rdx,	[%rip+L8791]
    call      fopen
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L6544
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8792]
    call      msys.m$print_str_nf
    mov       %rcx,	%rsi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L6542
L6544:
L6545:
    mov       %rcx,	%rdi
    call      fgetc
    movsxd    %r10,	%eax
    mov       %rbx,	%r10
    cmp       %rbx,	-1
    jz        L6546
L6548:
    mov       %rcx,	%rbx
    mov       %rdx,	%r12
    call      fputc
    jmp       L6545
L6546:
    mov       %rcx,	%rdi
    call      fclose
L6542:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.stopcompiler
cc_support.stopcompiler:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %al,	[%rip+cc_cli.fwriteerrors]
    test      %al,	%al
    jz        L6551
    lea       %rcx,	[%rip+L8793]
    lea       %rdx,	[%rip+L8794]
    call      fopen
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    call      msys.m$print_startfile
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    mov       %rcx,	%rsi
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%rdi
    call      fclose
L6551:
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	1
    call      exit
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.mcerror
cc_support.mcerror:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8795]
    call      msys.m$print_str_nf
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	40
    call      exit
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_support.serror
cc_support.serror:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      cc_support.serror_gen
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_support.serror_gen
cc_support.serror_gen:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	[%rip+cc_decls.currproc]
    test      %rax,	%rax
    jz        L6556
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8796]
    call      msys.m$print_str_nf
    mov       %rax,	[%rip+cc_decls.currproc]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L8797]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L6555
L6556:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8798]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L6555:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8799]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %eax,	[%rax+16]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    lea       %rcx,	[%rip+L8800]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+20]
    lea       %r10,	[%rip+cc_decls.sourcefilepaths]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+20]
    lea       %r10,	[%rip+cc_decls.sourcefilenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      cc_support.showmacrolineno
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8801]
    call      msys.m$print_str_nf
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L8802]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %eax,	[%rax+16]
    lea       %r10,	[%rip+cc_decls.lx]
    movzx     %r10,	byte ptr[%r10+20]
    lea       %r11,	[%rip+cc_decls.sourcefilepaths]
    mov       %r11,	[%r11 + %r10*8]
    mov       %rcx,	%r11
    mov       %rdx,	%rax
    call      cc_support.stopcompiler
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_support.serror_ss
cc_support.serror_ss:
#?>>
    .set cc_support.serror_ss.str, -256
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	296
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    lea       %rcx,	[%rbp + cc_support.serror_ss.str]
    call      msys.m$print_startstr
    mov       %rcx,	%rdi
    call      msys.m$print_setfmt
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    mov       %rcx,	%rsi
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + cc_support.serror_ss.str]
    call      cc_support.serror_gen
#---------------
    add       %rsp,	296
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.serror_s
cc_support.serror_s:
#?>>
    .set cc_support.serror_s.str, -256
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	288
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    lea       %rcx,	[%rbp + cc_support.serror_s.str]
    call      msys.m$print_startstr
    mov       %rcx,	%rdi
    call      msys.m$print_setfmt
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + cc_support.serror_s.str]
    call      cc_support.serror_gen
#---------------
    add       %rsp,	288
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.terror_gen
cc_support.terror_gen:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	[%rip+cc_decls.currproc]
    test      %rax,	%rax
    jz        L6561
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8803]
    call      msys.m$print_str_nf
    mov       %rax,	[%rip+cc_decls.currproc]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L6561:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8804]
    call      msys.m$print_str_nf
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L8805]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %eax,	[%rax+16]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+20]
    lea       %r10,	[%rip+cc_decls.sourcefilepaths]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      cc_support.showmacrolineno
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %eax,	[%rax+16]
    lea       %r10,	[%rip+cc_decls.lx]
    movzx     %r10,	byte ptr[%r10+20]
    lea       %r11,	[%rip+cc_decls.sourcefilepaths]
    mov       %r11,	[%r11 + %r10*8]
    mov       %rcx,	%r11
    mov       %rdx,	%rax
    call      cc_support.stopcompiler
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_support.terror
cc_support.terror:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      cc_support.terror_gen
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_support.terror_s
cc_support.terror_s:
#?>>
    .set cc_support.terror_s.str, -256
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	288
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    lea       %rcx,	[%rbp + cc_support.terror_s.str]
    call      msys.m$print_startstr
    mov       %rcx,	%rdi
    call      msys.m$print_setfmt
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + cc_support.terror_s.str]
    call      cc_support.terror_gen
#---------------
    add       %rsp,	288
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.terror_ss
cc_support.terror_ss:
#?>>
    .set cc_support.terror_ss.str, -256
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	296
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    lea       %rcx,	[%rbp + cc_support.terror_ss.str]
    call      msys.m$print_startstr
    mov       %rcx,	%rdi
    call      msys.m$print_setfmt
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    mov       %rcx,	%rsi
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + cc_support.terror_ss.str]
    call      cc_support.terror_gen
#---------------
    add       %rsp,	296
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.gerror_gen
cc_support.gerror_gen:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    test      %r12,	%r12
    jz        L6567
    mov       %eax,	[%r12+44]
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%r12+60]
    mov       %rbx,	%rax
    jmp       L6566
L6567:
    mov       %rdi,	[%rip+cc_decls.clineno]
    mov       %rbx,	[%rip+cc_decls.cfileno]
L6566:
    mov       %rax,	[%rip+cc_decls.currproc]
    test      %rax,	%rax
    jz        L6569
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8806]
    call      msys.m$print_str_nf
    mov       %rax,	[%rip+cc_decls.currproc]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L8807]
    call      msys.m$print_str_nf
    call      msys.m$print_end
L6569:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8808]
    call      msys.m$print_str_nf
    mov       %rax,	%rdi
    and       %rax,	16777215
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    lea       %rcx,	[%rip+L8809]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.sourcefilepaths]
    mov       %r10,	%rbx
    mov       %rcx,	[%rax + %r10*8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8810]
    call      msys.m$print_str_nf
    mov       %rcx,	%rsi
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L8811]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rax,	[%rip+cc_decls.sourcefilepaths]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8]
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    call      cc_support.stopcompiler
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.gerror
cc_support.gerror:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      cc_support.gerror_gen
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.gerror_s
cc_support.gerror_s:
#?>>
    .set cc_support.gerror_s.str, -256
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	296
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    lea       %rcx,	[%rbp + cc_support.gerror_s.str]
    call      msys.m$print_startstr
    mov       %rcx,	%rdi
    call      msys.m$print_setfmt
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + cc_support.gerror_s.str]
    mov       %rdx,	%rsi
    call      cc_support.gerror_gen
#---------------
    add       %rsp,	296
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.nextpoweroftwo
cc_support.nextpoweroftwo:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	16
#---------------
    test      %rcx,	%rcx
    jnz       L6574
    xor       %eax,	%eax
    jmp       L6572
L6574:
    mov       %rdi,	1
    jmp       L6576
L6575:
    shl       %rdi,	1
L6576:
    cmp       %rdi,	%rcx
    jl        L6575
    mov       %rax,	%rdi
L6572:
#---------------
    add       %rsp,	16
    pop       %rdi
    ret       
# End 
# Proc cc_support.loaderror
cc_support.loaderror:
#?>>
    .set cc_support.loaderror.str, -512
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	544
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    lea       %rcx,	[%rbp + cc_support.loaderror.str]
    call      msys.m$print_startstr
    mov       %rcx,	%rdi
    call      msys.m$print_setfmt
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8812]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rbp + cc_support.loaderror.str]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8813]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	45
    call      exit
#---------------
    add       %rsp,	544
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.loadsourcefile
cc_support.loadsourcefile:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rax,	[%rip+cc_decls.nsourcefiles]
    cmp       %rax,	200
    jle       L6581
    lea       %rcx,	[%rip+L8814]
    lea       %rdx,	[%rip+L8815]
    call      cc_support.loaderror
L6581:
    inc       qword ptr[%rip+cc_decls.nsourcefiles]
    mov       %rcx,	%rbx
    call      mlib.pcm_copyheapstring
    lea       %r10,	[%rip+cc_decls.sourcefilepaths]
    mov       %r11,	[%rip+cc_decls.nsourcefiles]
    mov       [%r10 + %r11*8],	%rax
    mov       %rcx,	%rsi
    call      mlib.pcm_copyheapstring
    lea       %r10,	[%rip+cc_decls.sourcefilenames]
    mov       %r11,	[%rip+cc_decls.nsourcefiles]
    mov       [%r10 + %r11*8],	%rax
    mov       %rcx,	%rbx
    call      mlib.readfile
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L6583
    lea       %rcx,	[%rip+L8816]
    mov       %rdx,	%rbx
    call      cc_support.loaderror
L6583:
    mov       %rax,	%rdi
    lea       %r10,	[%rip+cc_decls.sourcefiletext]
    mov       %r11,	[%rip+cc_decls.nsourcefiles]
    mov       [%r10 + %r11*8],	%rax
    mov       %eax,	[%rip+mlib.rfsize]
    lea       %r10,	[%rip+cc_decls.sourcefilesizes]
    mov       %r11,	[%rip+cc_decls.nsourcefiles]
    mov       [%r10 + %r11*4],	%eax
    xor       %eax,	%eax
    mov       %r10,	[%rip+mlib.rfsize]
    mov       [%rdi + %r10],	%al
    mov       %rax,	[%rip+cc_decls.nsourcefiles]
L6579:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.splicelines
cc_support.splicelines:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    mov       %rcx,	%rsi
    call      strlen
    inc       %rax
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       %rbx,	%rax
    mov       %rdi,	%rax
    jmp       L6586
L6585:
    movzx     %rax,	byte ptr[%rsi]
    cmp       %rax,	92
    jnz       L6589
    movzx     %rax,	byte ptr[%rsi+1]
    cmp       %rax,	10
    jnz       L6589
    add       %rsi,	2
    jmp       L6588
L6589:
    movzx     %rax,	byte ptr[%rsi]
    cmp       %rax,	92
    jnz       L6590
    movzx     %rax,	byte ptr[%rsi+1]
    cmp       %rax,	13
    jnz       L6590
    movzx     %rax,	byte ptr[%rsi+2]
    cmp       %rax,	10
    jnz       L6590
    add       %rsi,	3
    jmp       L6588
L6590:
    mov       %rax,	%rsi
    inc       %rsi
    mov       %al,	[%rax]
    mov       %r10,	%rdi
    inc       %rdi
    mov       [%r10],	%al
L6588:
    xor       %eax,	%eax
    mov       [%rdi],	%al
L6586:
    mov       %al,	[%rsi]
    test      %al,	%al
    jnz       L6585
    mov       %rax,	%rbx
L6584:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.loadbuiltin
cc_support.loadbuiltin:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rax,	[%rip+cc_decls.nsourcefiles]
    cmp       %rax,	200
    jle       L6593
    lea       %rcx,	[%rip+L8817]
    lea       %rdx,	[%rip+L8818]
    call      cc_support.loaderror
L6593:
    inc       qword ptr[%rip+cc_decls.nsourcefiles]
    lea       %rax,	[%rip+L8819]
    lea       %r10,	[%rip+cc_decls.sourcefilepaths]
    mov       %r11,	[%rip+cc_decls.nsourcefiles]
    mov       [%r10 + %r11*8],	%rax
    mov       %rcx,	%rdi
    call      mlib.pcm_copyheapstring
    lea       %r10,	[%rip+cc_decls.sourcefilenames]
    mov       %r11,	[%rip+cc_decls.nsourcefiles]
    mov       [%r10 + %r11*8],	%rax
    mov       %rcx,	%rbx
    call      mlib.pcm_copyheapstring
    lea       %r10,	[%rip+cc_decls.sourcefiletext]
    mov       %r11,	[%rip+cc_decls.nsourcefiles]
    mov       [%r10 + %r11*8],	%rax
    mov       %rcx,	%rbx
    call      strlen
    lea       %r10,	[%rip+cc_decls.sourcefilesizes]
    mov       %r11,	[%rip+cc_decls.nsourcefiles]
    mov       [%r10 + %r11*4],	%eax
    mov       %rax,	[%rip+cc_decls.nsourcefiles]
L6591:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.gs_copytostr
cc_support.gs_copytostr:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %eax,	[%rdi+8]
    test      %eax,	%eax
    jz        L6596
    movsxd    %rax,	dword ptr[%rdi+8]
    mov       %r10,	[%rdi]
    mov       %rcx,	%rbx
    mov       %rdx,	%r10
    mov       %r8,	%rax
    call      memcpy
    movsxd    %rax,	dword ptr[%rdi+8]
    xor       %r10d,	%r10d
    mov       [%rbx + %rax],	%r10b
    jmp       L6595
L6596:
    xor       %eax,	%eax
    mov       [%rbx],	%al
L6595:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.gs_additem
cc_support.gs_additem:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r12,	%rcx
    mov       %r13,	%rdx
#---------------
    mov       %rdi,	[%r12]
    mov       %eax,	[%r12+8]
    test      %eax,	%eax
    jz        L6599
    movsxd    %rax,	dword ptr[%r12+8]
    lea       %r10,	[%rdi + %rax]
    sub       %r10,	1
    movzx     %r10,	byte ptr[%r10]
    mov       %rbx,	%r10
    movzx     %rax,	byte ptr[%r13]
    mov       %rsi,	%rax
    mov       %rcx,	%rbx
    call      cc_support.isalphanum
    test      %rax,	%rax
    jz        L6601
    mov       %rcx,	%rsi
    call      cc_support.isalphanum
    test      %rax,	%rax
    jz        L6601
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L8820]
    mov       %r8,	-1
    call      mlib.strbuffer_add
L6601:
L6599:
    mov       %rcx,	%r12
    mov       %rdx,	%r13
    mov       %r8,	-1
    call      mlib.strbuffer_add
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.isalphanum
cc_support.isalphanum:
#?>>
#?]]
#---------------
    cmp       %rcx,	65
    jl        L6606
    cmp       %rcx,	90
    jle       L6605
L6606:
    cmp       %rcx,	97
    jl        L6607
    cmp       %rcx,	122
    jle       L6605
L6607:
    cmp       %rcx,	48
    jl        L6604
    cmp       %rcx,	57
    jg        L6604
L6605:
    mov       %rax,	1
    jmp       L6602
L6604:
    xor       %eax,	%eax
L6602:
#---------------
    ret       
# End 
# Proc cc_support.showmacrolineno
cc_support.showmacrolineno:
#?>>
#?]]
#---------------
    mov       %rax,	[%rip+cc_decls.slineno]
    test      %rax,	%rax
    jz        L6610
L6610:
#---------------
    ret       
# End 
# Proc cc_headersx.findheader
cc_headersx.findheader:
#?>>
    .set cc_headersx.findheader.name, 16
#?]]
#---------------
    xor       %eax,	%eax
L6611:
#---------------
    ret       
# End 
# Proc cc_headersx.writeheaders
cc_headersx.writeheaders:
#?>>
#?]]
#---------------
#---
#---------------
    ret       
# End 
# Proc cc_headersx.isheaderfile
cc_headersx.isheaderfile:
#?>>
    .set cc_headersx.isheaderfile.file, 16
#?]]
#---------------
    xor       %eax,	%eax
L6613:
#---------------
    ret       
# End 
# Proc cc_show.printcode
cc_show.printcode:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rcx,	%rbx
    call      msys.m$print_startfile
    mov       %rcx,	%rsi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rax,	[%rip+cc_decls.stmodule]
    mov       %rdi,	[%rax+16]
    jmp       L6616
L6615:
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	6
    jnz       L6620
L6619:
    mov       %rax,	[%rdi+72]
    test      %rax,	%rax
    jz        L6622
    mov       %rcx,	%rbx
    call      msys.m$print_startfile
    mov       %rcx,	[%rdi]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L8821]
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rdi+110]
    lea       %r10,	[%rip+cc_tables.scopenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rax,	[%rdi+72]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    lea       %r9,	[%rip+L8822]
    call      cc_show.printunit
    mov       %rcx,	%rbx
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
L6622:
L6620:
L6618:
    mov       %rdi,	[%rdi+32]
L6616:
    test      %rdi,	%rdi
    jnz       L6615
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_show.printunit
cc_show.printunit:
#?>>
    .set cc_show.printunit.level, 80
    .set cc_show.printunit.prefix, 88
    .set cc_show.printunit.idname, -8
    .set cc_show.printunit.pc, -16
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       [%rbp+80],	%r8
    mov       [%rbp+88],	%r9
#---------------
    test      %r14,	%r14
    jnz       L6625
    jmp       L6623
L6625:
    movsxd    %rax,	dword ptr[%r14+40]
    cmp       %rax,	77
    jl        L6627
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8823]
    call      msys.m$print_str_nf
    movsxd    %rax,	dword ptr[%r14+40]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	30
    call      exit
L6627:
    mov       %eax,	[%r14+44]
    test      %eax,	%eax
    jz        L6629
    mov       %eax,	[%r14+44]
    mov       [%rip+cc_show.currlineno],	%rax
    movzx     %rax,	byte ptr[%r14+60]
    mov       [%rip+cc_show.currfileno],	%rax
L6629:
    mov       %r12,	1
    mov       %rax,	[%rbp + cc_show.printunit.level]
    cmp       %rax,	0
    jge       L6631
    mov       %r12,	-1
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L8824]
    call      msys.m$print_str_nf
    call      msys.m$print_end
L6631:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    mov       %rax,	[%rbp + cc_show.printunit.level]
    cmp       %rax,	0
    jge       L8825
    neg       %rax
L8825:
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + cc_show.printunit.prefix]
    mov       %r8,	%r14
    call      cc_show.getprefix
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
    movsxd    %rax,	dword ptr[%r14+40]
    lea       %r10,	[%rip+cc_tables.jtagnames]
    mov       %r10,	[%r10 + %rax*8]
    mov       [%rbp + cc_show.printunit.idname],	%r10
    mov       %rax,	[%rbp + cc_show.printunit.idname]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	106
    jnz       L6633
    inc       qword ptr[%rbp + cc_show.printunit.idname]
L6633:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    mov       %rcx,	[%rbp + cc_show.printunit.idname]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L8826]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    movsxd    %rax,	dword ptr[%r14+40]
    cmp       %rax,	3
    jz        L6635
    cmp       %rax,	5
    jz        L6635
    cmp       %rax,	7
    jz        L6636
    cmp       %rax,	8
    jz        L6636
    cmp       %rax,	16
    jz        L6636
    cmp       %rax,	16
    jz        L6637
    cmp       %rax,	17
    jz        L6638
    cmp       %rax,	18
    jz        L6639
    cmp       %rax,	1
    jz        L6640
    cmp       %rax,	56
    jz        L6641
    cmp       %rax,	57
    jz        L6642
    cmp       %rax,	53
    jz        L6643
    cmp       %rax,	54
    jz        L6643
    cmp       %rax,	22
    jz        L6644
    cmp       %rax,	30
    jz        L6645
    cmp       %rax,	52
    jz        L6646
    cmp       %rax,	49
    jz        L6647
    jmp       L6648
L6635:
    mov       %rdi,	[%r14]
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    mov       %rcx,	[%rdi]
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rdi+109]
    lea       %r10,	[%rip+cc_tables.namenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       %rax,	[%rdi+72]
    test      %rax,	%rax
    jz        L6650
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L8827]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       %rax,	[%rdi+72]
    movsxd    %rax,	dword ptr[%rax+40]
    lea       %r10,	[%rip+cc_tables.jtagnames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L8828]
    call      msys.m$print_str_nf
    call      msys.m$print_end
L6650:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L8829]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       %rcx,	%rdi
    call      cc_show.getdottedname
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       %rax,	[%r14+32]
    test      %rax,	%rax
    jz        L6652
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L8830]
    call      msys.m$print_str_nf
    mov       %rcx,	[%r14+32]
    call      msys.m$print_ptr_nf
    call      msys.m$print_end
L6652:
    jmp       L6634
L6636:
    mov       %rdi,	[%r14]
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    mov       %rcx,	[%rdi]
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rdi+109]
    lea       %r10,	[%rip+cc_tables.namenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rax,	[%rbp + cc_show.printunit.level]
    add       %rax,	%r12
    mov       %r10,	[%rdi+72]
    mov       %rcx,	%r13
    mov       %rdx,	%r10
    mov       %r8,	%rax
    lea       %r9,	[%rip+L8831]
    call      cc_show.printunit
    jmp       L6623
L6637:
    mov       %rdi,	[%r14]
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    mov       %rcx,	[%rdi]
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rdi+109]
    lea       %r10,	[%rip+cc_tables.namenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L6634
L6638:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    mov       %rax,	[%r14]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L6634
L6639:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L8832]
    call      msys.m$print_str_nf
    mov       %rcx,	[%r14]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L6634
L6640:
    movsxd    %rax,	dword ptr[%r14+52]
    mov       %rbx,	%rax
    cmp       %rbx,	[%rip+cc_decls.trefchar]
    jnz       L6654
    mov       %al,	[%r14+61]
    test      %al,	%al
    jz        L6657
L6656:
#cc_show.printunit.dostring:
L6658:
    movsxd    %rax,	dword ptr[%r14+48]
    cmp       %rax,	256
    jle       L6660
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L8833]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L8834]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L8835]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    movsxd    %rax,	dword ptr[%r14+48]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L6659
L6660:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L8836]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       %rcx,	[%r14]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L8837]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    movsxd    %rax,	dword ptr[%r14+48]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
L6659:
    jmp       L6653
L6654:
    cmp       %rbx,	[%rip+cc_decls.trefwchar]
    jnz       L6661
    mov       %al,	[%r14+62]
    test      %al,	%al
    jz        L6657
L6663:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L8838]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L8839]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L8840]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    movsxd    %rax,	dword ptr[%r14+48]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L6653
L6661:
    cmp       %rbx,	1
    jl        L6664
    cmp       %rbx,	4
    jg        L6664
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    mov       %rcx,	[%r14]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L6653
L6664:
    cmp       %rbx,	6
    jl        L6665
    cmp       %rbx,	9
    jg        L6665
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    mov       %rax,	[%r14]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.m$print_u64
    call      msys.m$print_end
    jmp       L6653
L6665:
    mov       %rcx,	%rbx
    call      cc_lib.isrealcc
    test      %rax,	%rax
    jz        L6666
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    movq      %XMM4,	[%r14]
    movq      %XMM0,	%XMM4
    xor       %edx,	%edx
    call      msys.m$print_r64
    call      msys.m$print_end
    jmp       L6653
L6666:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	13
    jnz       L6667
    mov       %al,	[%r14+61]
    test      %al,	%al
    jnz       L6658
L6669:
#cc_show.printunit.doref:
L6657:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    mov       %rcx,	[%r14]
    call      msys.m$print_ptr_nf
    call      msys.m$print_end
    jmp       L6653
L6667:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jnz       L6670
    mov       %al,	[%r14+61]
    test      %al,	%al
    jnz       L6658
L6672:
    lea       %rcx,	[%rip+L8841]
    call      cc_support.serror
    jmp       L6653
L6670:
    call      msys.m$print_startcon
    mov       %rcx,	%rbx
    call      cc_lib.typename
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8842]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L6653:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L8843]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       %al,	[%r14+61]
    test      %al,	%al
    jz        L6674
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L8844]
    call      msys.m$print_str_nf
    call      msys.m$print_end
L6674:
    mov       %al,	[%r14+62]
    test      %al,	%al
    jz        L6676
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L8845]
    call      msys.m$print_str_nf
    call      msys.m$print_end
L6676:
    jmp       L6634
L6641:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    movsxd    %rax,	dword ptr[%r14+48]
    lea       %r10,	[%rip+cc_tables.convnames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L8846]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    mov       %rax,	[%r14+16]
    movsxd    %rax,	dword ptr[%rax+52]
    mov       %rcx,	%rax
    call      cc_lib.typename
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L8847]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    movsx     %rax,	word ptr[%r14+58]
    mov       %rcx,	%rax
    call      cc_lib.typename
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L6634
L6642:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L8848]
    call      msys.m$print_str_nf
    movsxd    %rax,	dword ptr[%r14+48]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L6634
L6643:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L8849]
    call      msys.m$print_str_nf
    movsxd    %rax,	dword ptr[%r14]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L6634
L6644:
    mov       %rax,	[%r14]
    mov       [%rbp + cc_show.printunit.pc],	%rax
    xor       %rsi,	%rsi
    jmp       L6678
L6677:
    inc       %rsi
    mov       %rax,	[%rbp + cc_show.printunit.pc]
    mov       %rax,	[%rax]
    mov       [%rbp + cc_show.printunit.pc],	%rax
L6678:
    mov       %rax,	[%rbp + cc_show.printunit.pc]
    test      %rax,	%rax
    jnz       L6677
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    mov       %rcx,	[%r14]
    call      msys.m$print_ptr_nf
    mov       %rcx,	%rsi
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L6634
L6645:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L8850]
    call      msys.m$print_str_nf
    movsxd    %rax,	dword ptr[%r14+48]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L6634
L6646:
    jmp       L6634
L6647:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L8851]
    call      msys.m$print_str_nf
    movsxd    %rax,	dword ptr[%r14]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
L6648:
L6634:
    mov       %ax,	[%r14+56]
    test      %ax,	%ax
    jz        L6681
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L8852]
    call      msys.m$print_str_nf
    movsx     %rax,	word ptr[%r14+56]
    mov       %rcx,	%rax
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
L6681:
    mov       %eax,	[%r14+48]
    test      %eax,	%eax
    jz        L6683
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L8853]
    call      msys.m$print_str_nf
    movsxd    %rax,	dword ptr[%r14+48]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
L6683:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rax,	[%rbp + cc_show.printunit.level]
    add       %rax,	%r12
    mov       %r10,	[%r14+16]
    mov       %rcx,	%r13
    mov       %rdx,	%r10
    mov       %r8,	%rax
    lea       %r9,	[%rip+L8854]
    call      cc_show.printunitlist
    mov       %rax,	[%rbp + cc_show.printunit.level]
    add       %rax,	%r12
    mov       %r10,	[%r14+24]
    mov       %rcx,	%r13
    mov       %rdx,	%r10
    mov       %r8,	%rax
    lea       %r9,	[%rip+L8855]
    call      cc_show.printunitlist
    movsxd    %rax,	dword ptr[%r14+40]
    cmp       %rax,	6
    jz        L6685
    mov       %rax,	[%rbp + cc_show.printunit.level]
    add       %rax,	%r12
    mov       %r10,	[%r14+32]
    mov       %rcx,	%r13
    mov       %rdx,	%r10
    mov       %r8,	%rax
    lea       %r9,	[%rip+L8856]
    call      cc_show.printunitlist
L6685:
L6623:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_show.printunitlist
cc_show.printunitlist:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
    mov       %r12,	%r9
#---------------
    test      %rbx,	%rbx
    jnz       L6688
    jmp       L6686
L6688:
    jmp       L6690
L6689:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    mov       %r9,	%r12
    call      cc_show.printunit
    mov       %rbx,	[%rbx+8]
L6690:
    test      %rbx,	%rbx
    jnz       L6689
L6686:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_show.getprefix
cc_show.getprefix:
#?>>
    .set cc_show.getprefix.indentstr, -512
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	544
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
#---------------
    xor       %eax,	%eax
    mov       [%rbp + cc_show.getprefix.indentstr],	%al
    cmp       %r12,	10
    jle       L6694
    mov       %r12,	10
L6694:
    lea       %rcx,	[%rbp + cc_show.getprefix.indentstr]
    lea       %rdx,	[%rip+L8857]
    call      strcpy
    movsxd    %rax,	dword ptr[%r14+52]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      cc_lib.strmode
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    call      strlen
    mov       %rbx,	%rax
    lea       %rcx,	[%rbp + cc_show.getprefix.indentstr]
    call      strlen
    mov       %r10,	%rbx
    cmp       %r10,	%rax
    jge       L6696
    lea       %rcx,	[%rbp + cc_show.getprefix.indentstr]
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      memcpy
    jmp       L6695
L6696:
    lea       %rcx,	[%rbp + cc_show.getprefix.indentstr]
    mov       %rdx,	%rdi
    call      strcpy
L6695:
    mov       %rsi,	%r12
    cmp       %rsi,	0
    jle       L6699
L6697:
    lea       %rcx,	[%rbp + cc_show.getprefix.indentstr]
    lea       %rdx,	[%rip+L8858]
    call      strcat
    dec       %rsi
    jnz       L6697
L6699:
    call      cc_show.getlineinfok
    lea       %rcx,	[%rip+cc_show.getprefix.str]
    mov       %rdx,	%rax
    call      strcpy
    lea       %rcx,	[%rip+cc_show.getprefix.str]
    lea       %rdx,	[%rbp + cc_show.getprefix.indentstr]
    call      strcat
    lea       %rcx,	[%rip+cc_show.getprefix.str]
    mov       %rdx,	%r13
    call      strcat
    mov       %al,	[%r13]
    test      %al,	%al
    jz        L6701
    lea       %rcx,	[%rip+cc_show.getprefix.str]
    lea       %rdx,	[%rip+L8859]
    call      strcat
L6701:
    lea       %rax,	[%rip+cc_show.getprefix.str]
L6692:
#---------------
    add       %rsp,	544
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_show.getdottedname
cc_show.getdottedname:
#?>>
    .set cc_show.getdottedname.str2, -256
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	288
    mov       %rbx,	%rcx
#---------------
    mov       %rax,	[%rbx]
    lea       %rcx,	[%rip+cc_show.getdottedname.str]
    mov       %rdx,	%rax
    call      strcpy
    mov       %rdi,	[%rbx+8]
    jmp       L6704
L6703:
    lea       %rcx,	[%rbp + cc_show.getdottedname.str2]
    lea       %rdx,	[%rip+cc_show.getdottedname.str]
    call      strcpy
    mov       %rax,	[%rdi]
    lea       %rcx,	[%rip+cc_show.getdottedname.str]
    mov       %rdx,	%rax
    call      strcpy
    lea       %rcx,	[%rip+cc_show.getdottedname.str]
    lea       %rdx,	[%rip+L8860]
    call      strcat
    lea       %rcx,	[%rip+cc_show.getdottedname.str]
    lea       %rdx,	[%rbp + cc_show.getdottedname.str2]
    call      strcat
    mov       %rdi,	[%rdi+8]
L6704:
    test      %rdi,	%rdi
    jz        L6706
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	2
    jnz       L6703
L6706:
    mov       %ax,	[%rbx+96]
    test      %ax,	%ax
    jz        L6708
    lea       %rcx,	[%rbp + cc_show.getdottedname.str2]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8860]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    movzx     %rax,	word ptr[%rbx+96]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rcx,	[%rip+cc_show.getdottedname.str]
    lea       %rdx,	[%rbp + cc_show.getdottedname.str2]
    call      strcat
L6708:
    lea       %rax,	[%rip+cc_show.getdottedname.str]
L6702:
#---------------
    add       %rsp,	288
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_show.getlineinfok
cc_show.getlineinfok:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    lea       %rcx,	[%rip+cc_show.getlineinfok.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8861]
    call      msys.m$print_setfmt
    mov       %rcx,	[%rip+cc_show.currfileno]
    call      msys.m$print_i64_nf
    mov       %rcx,	[%rip+cc_show.currlineno]
    lea       %rdx,	[%rip+L8862]
    call      msys.m$print_i64
    call      msys.m$print_space
    call      msys.m$print_end
    lea       %rax,	[%rip+cc_show.getlineinfok.str]
L6709:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_show.printst
cc_show.printst:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    movzx     %rax,	byte ptr[%rsi+107]
    cmp       %rax,	67
    jz        L6712
    lea       %rcx,	[%rip+L8863]
    call      cc_support.mcerror
L6712:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      cc_show.printstrec
    mov       %rdi,	[%rsi+16]
    jmp       L6714
L6713:
    lea       %rax,	[%r12+1]
    mov       %rcx,	%rbx
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      cc_show.printst
    mov       %rdi,	[%rdi+32]
L6714:
    test      %rdi,	%rdi
    jnz       L6713
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_show.printstrec
cc_show.printstrec:
#?>>
    .set cc_show.printstrec.p, 72
    .set cc_show.printstrec.level, 80
    .set cc_show.printstrec.v, -16
    .set cc_show.printstrec.str, -272
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	304
    mov       %r14,	%rcx
    mov       [%rbp+72],	%rdx
    mov       [%rbp+80],	%r8
#---------------
    lea       %rax,	[%rbp + cc_show.printstrec.v]
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    call      mlib.gs_init
    xor       %rsi,	%rsi
    mov       %rax,	[%rbp + cc_show.printstrec.level]
    mov       %r13,	%rax
    cmp       %r13,	0
    jle       L6719
L6717:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8864]
    call      mlib.gs_str
    mov       %rax,	4
    add       %rsi,	%rax
    dec       %r13
    jnz       L6717
L6719:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8865]
    call      mlib.gs_str
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %ax,	[%rax+96]
    test      %ax,	%ax
    jz        L6721
    lea       %rcx,	[%rbp + cc_show.printstrec.str]
    call      msys.m$print_startstr
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L8866]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movzx     %rax,	word ptr[%rax+96]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    mov       %rax,	28
    sub       %rax,	%rsi
    mov       %rcx,	%rdi
    lea       %rdx,	[%rbp + cc_show.printstrec.str]
    mov       %r8,	%rax
    mov       %r9,	45
    call      mlib.gs_leftstr
    jmp       L6720
L6721:
    mov       %rax,	28
    sub       %rax,	%rsi
    mov       %r10,	[%rbp + cc_show.printstrec.p]
    mov       %r10,	[%r10]
    mov       %rcx,	%rdi
    mov       %rdx,	%r10
    mov       %r8,	%rax
    mov       %r9,	45
    call      mlib.gs_leftstr
L6720:
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movzx     %rax,	byte ptr[%rax+109]
    lea       %r10,	[%rip+cc_tables.namenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%rdi
    mov       %rdx,	%r10
    mov       %r8,	12
    mov       %r9,	46
    call      mlib.gs_leftstr
    mov       %rcx,	%rdi
    call      mlib.gs_getcol
    mov       %rbx,	%rax
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8867]
    call      mlib.gs_str
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movzx     %rax,	byte ptr[%rax+110]
    lea       %r10,	[%rip+cc_tables.scopenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%rdi
    mov       %rdx,	%r10
    call      mlib.gs_str
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8868]
    call      mlib.gs_str
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movzx     %rax,	byte ptr[%rax+108]
    shr       %eax,	4
    and       %eax,	1
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.strint
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mlib.gs_str
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8868]
    call      mlib.gs_str
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %al,	[%rax+112]
    test      %al,	%al
    jz        L6723
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8869]
    call      mlib.gs_str
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movzx     %rax,	byte ptr[%rax+112]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mlib.gs_strint
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8870]
    call      mlib.gs_str
L6723:
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movzx     %rax,	byte ptr[%rax+108]
    shr       %eax,	1
    and       %eax,	1
    test      %rax,	%rax
    jz        L6725
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8871]
    call      mlib.gs_str
L6725:
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %al,	[%rax+122]
    test      %al,	%al
    jz        L6727
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8872]
    call      mlib.gs_str
L6727:
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %al,	[%rax+111]
    test      %al,	%al
    jz        L6729
    lea       %rcx,	[%rbp + cc_show.printstrec.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8873]
    call      msys.m$print_setfmt
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movzx     %rax,	byte ptr[%rax+111]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    mov       %rcx,	%rdi
    lea       %rdx,	[%rbp + cc_show.printstrec.str]
    call      mlib.gs_str
L6729:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8874]
    call      mlib.gs_str
    lea       %rax,	[%rbx+10]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    mov       %r8,	61
    call      mlib.gs_padto
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %rax,	[%rax+8]
    test      %rax,	%rax
    jz        L6731
    lea       %rcx,	[%rbp + cc_show.printstrec.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8875]
    call      msys.m$print_setfmt
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %rax,	[%rax+8]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       %rcx,	%rdi
    lea       %rdx,	[%rbp + cc_show.printstrec.str]
    mov       %r8,	18
    mov       %r9,	32
    call      mlib.gs_leftstr
    jmp       L6730
L6731:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8876]
    mov       %r8,	18
    mov       %r9,	32
    call      mlib.gs_leftstr
L6730:
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movzx     %rax,	word ptr[%rax+102]
    test      %rax,	%rax
    jnz       L6734
L6733:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8877]
    call      mlib.gs_str
    jmp       L6732
L6734:
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movzx     %rax,	word ptr[%rax+102]
    mov       %rcx,	%rax
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mlib.gs_strsp
L6732:
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	10
    jz        L6736
    cmp       %rax,	8
    jz        L6737
    cmp       %rax,	9
    jz        L6737
    cmp       %rax,	6
    jz        L6738
    cmp       %rax,	11
    jz        L6739
    cmp       %rax,	7
    jz        L6740
    jmp       L6741
L6736:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8878]
    call      mlib.gs_str
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movsxd    %rax,	dword ptr[%rax+88]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mlib.gs_strint
    jmp       L6735
L6737:
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %rax,	[%rax+72]
    test      %rax,	%rax
    jz        L6743
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8879]
    call      mlib.gs_str
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %rax,	[%rax+72]
    mov       %rcx,	%rax
    call      cc_show.strexpr
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mlib.gs_strvar
L6743:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8880]
    call      mlib.gs_str
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movsxd    %rax,	dword ptr[%rax+88]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mlib.gs_strint
    jmp       L6735
L6738:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8881]
    call      mlib.gs_str
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movsxd    %rax,	dword ptr[%rax+88]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mlib.gs_strint
    jmp       L6735
L6739:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8882]
    call      mlib.gs_str
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movsxd    %rax,	dword ptr[%rax+88]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mlib.gs_strint
    jmp       L6735
L6740:
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %rax,	[%rax+72]
    test      %rax,	%rax
    jz        L6745
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8883]
    call      mlib.gs_str
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %rax,	[%rax+72]
    mov       %rcx,	%rax
    call      cc_show.strexpr
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mlib.gs_strvar
L6745:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8884]
    call      mlib.gs_str
L6741:
L6735:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8885]
    call      mlib.gs_str
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8886]
    call      mlib.gs_str
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %eax,	[%rax+92]
    and       %rax,	16777215
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mlib.gs_strint
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8887]
    call      mlib.gs_str
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %eax,	[%rax+92]
    sar       %rax,	24
    lea       %r10,	[%rip+cc_decls.sourcefilenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%rdi
    mov       %rdx,	%r10
    call      mlib.gs_str
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	6
    jnz       L6747
    mov       %rcx,	%rdi
    call      mlib.gs_line
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %r12,	[%rax+80]
    jmp       L6749
L6748:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8888]
    call      mlib.gs_str
    mov       %rax,	[%r12]
    test      %rax,	%rax
    jz        L6752
    mov       %rax,	[%r12]
    mov       %rax,	[%rax]
    jmp       L6751
L6752:
    lea       %rax,	[%rip+L8889]
L6751:
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    mov       %r8,	10
    mov       %r9,	45
    call      mlib.gs_leftstr
    movsx     %rax,	word ptr[%r12+22]
    lea       %r10,	[%rip+cc_tables.pmflagnames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%rdi
    mov       %rdx,	%r10
    call      mlib.gs_str
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8890]
    call      mlib.gs_str
    movsxd    %rax,	dword ptr[%r12+16]
    mov       %rcx,	%rax
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mlib.gs_str
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8891]
    call      mlib.gs_str
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %rax,	[%rax+72]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mlib.gs_strint
    mov       %rcx,	%rdi
    call      mlib.gs_line
    mov       %r12,	[%r12+8]
L6749:
    test      %r12,	%r12
    jnz       L6748
L6747:
    mov       %rcx,	%rdi
    mov       %rdx,	%r14
    call      mlib.gs_println
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %rax,	[%rax+72]
    test      %rax,	%rax
    jz        L6754
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	8
    jz        L6756
    cmp       %rax,	7
    jnz       L6757
L6756:
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %rax,	[%rax+72]
    mov       %rcx,	%r14
    mov       %rdx,	%rax
    mov       %r8,	-3
    lea       %r9,	[%rip+L8892]
    call      cc_show.printunit
L6757:
L6755:
L6754:
#---------------
    add       %rsp,	304
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_show.printstflat
cc_show.printstflat:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L8893]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    xor       %rdi,	%rdi
    mov       %rax,	[%rip+cc_decls.hstsize]
    dec       %rax
    mov       %rsi,	%rax
    cmp       %rsi,	0
    jl        L6761
L6759:
    mov       %rax,	[%rip+cc_decls.hashtable]
    mov       %r10,	%rdi
    mov       %rbx,	[%rax + %r10*8]
    mov       %rax,	[%rbx]
    test      %rax,	%rax
    jz        L6763
    movzx     %rax,	byte ptr[%rbx+107]
    cmp       %rax,	67
    jz        L6765
    cmp       %rax,	71
    jz        L6765
    cmp       %rax,	68
    jnz       L6766
L6765:
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    mov       %rcx,	%rdi
    call      msys.m$print_i64_nf
    mov       %rcx,	%rbx
    call      msys.m$print_ptr_nf
    lea       %rcx,	[%rip+L8894]
    call      msys.m$print_str_nf
    mov       %rcx,	%rbx
    call      cc_lib.getstname
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rbx+107]
    lea       %r10,	[%rip+cc_tables.symbolnames]
    mov       %r10,	[%r10 + %rax*8-8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rbx+109]
    lea       %r10,	[%rip+cc_tables.namenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rbx,	[%rbx+40]
    jmp       L6768
L6767:
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L8895]
    call      msys.m$print_str_nf
    mov       %rcx,	%rbx
    call      msys.m$print_ptr_nf
    mov       %rcx,	%rbx
    call      cc_lib.getstname
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rbx+107]
    lea       %r10,	[%rip+cc_tables.symbolnames]
    mov       %r10,	[%r10 + %rax*8-8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rbx+109]
    lea       %r10,	[%rip+cc_tables.namenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    mov       %rcx,	[%rbx+48]
    call      msys.m$print_ptr_nf
    call      msys.m$print_end
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L8896]
    call      msys.m$print_str_nf
    mov       %rax,	[%rbx+8]
    test      %rax,	%rax
    jz        L6771
    mov       %rcx,	[%rbx+8]
    call      cc_lib.getstname
    jmp       L6770
L6771:
    lea       %rax,	[%rip+L8897]
L6770:
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L8898]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rbx,	[%rbx+40]
L6768:
    test      %rbx,	%rbx
    jnz       L6767
L6766:
L6764:
L6763:
    inc       %rdi
    cmp       %rdi,	%rsi
    jle       L6759
L6761:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_show.strexpr
cc_show.strexpr:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	[%rip+cc_show.exprstr]
    call      mlib.gs_init
    mov       %rcx,	[%rip+cc_show.exprstr]
    mov       %rdx,	%rdi
    call      cc_show.jeval
    mov       %rax,	[%rip+cc_show.exprstr]
L6772:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_show.jeval
cc_show.jeval:
#?>>
    .set cc_show.jeval.str, -16000
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	16040
    mov       %r12,	%rcx
    mov       %r13,	%rdx
#---------------
    movsxd    %rax,	dword ptr[%r13+40]
    cmp       %rax,	1
    jz        L6775
    cmp       %rax,	3
    jz        L6776
    cmp       %rax,	5
    jz        L6777
    cmp       %rax,	24
    jz        L6778
    cmp       %rax,	25
    jz        L6778
    cmp       %rax,	32
    jz        L6778
    cmp       %rax,	33
    jz        L6778
    cmp       %rax,	34
    jz        L6778
    cmp       %rax,	35
    jz        L6778
    cmp       %rax,	36
    jz        L6778
    cmp       %rax,	37
    jz        L6778
    cmp       %rax,	38
    jz        L6778
    cmp       %rax,	39
    jz        L6778
    cmp       %rax,	40
    jz        L6778
    cmp       %rax,	41
    jz        L6778
    cmp       %rax,	42
    jz        L6778
    cmp       %rax,	43
    jz        L6778
    cmp       %rax,	44
    jz        L6778
    cmp       %rax,	45
    jz        L6778
    cmp       %rax,	46
    jz        L6778
    cmp       %rax,	47
    jz        L6778
    cmp       %rax,	48
    jz        L6778
    cmp       %rax,	61
    jz        L6778
    cmp       %rax,	62
    jz        L6778
    cmp       %rax,	63
    jz        L6778
    cmp       %rax,	64
    jz        L6778
    cmp       %rax,	65
    jz        L6778
    cmp       %rax,	66
    jz        L6778
    cmp       %rax,	67
    jz        L6778
    cmp       %rax,	68
    jz        L6778
    cmp       %rax,	69
    jz        L6778
    cmp       %rax,	70
    jz        L6778
    cmp       %rax,	58
    jz        L6779
    cmp       %rax,	59
    jz        L6779
    cmp       %rax,	60
    jz        L6779
    cmp       %rax,	26
    jz        L6779
    cmp       %rax,	27
    jz        L6779
    cmp       %rax,	30
    jz        L6780
    cmp       %rax,	49
    jz        L6781
    cmp       %rax,	50
    jz        L6782
    cmp       %rax,	28
    jz        L6783
    cmp       %rax,	29
    jz        L6783
    cmp       %rax,	11
    jz        L6784
    cmp       %rax,	31
    jz        L6785
    cmp       %rax,	56
    jz        L6786
    cmp       %rax,	52
    jz        L6787
    cmp       %rax,	6
    jz        L6788
    cmp       %rax,	71
    jz        L6789
    cmp       %rax,	72
    jz        L6790
    cmp       %rax,	73
    jz        L6791
    cmp       %rax,	74
    jz        L6792
    cmp       %rax,	2
    jz        L6793
    cmp       %rax,	57
    jz        L6794
    cmp       %rax,	53
    jz        L6795
    cmp       %rax,	4
    jz        L6796
    jmp       L6797
L6775:
    movsxd    %rax,	dword ptr[%r13+52]
    mov       %rsi,	%rax
    cmp       %rax,	[%rip+cc_decls.trefchar]
    jnz       L6799
    movsxd    %rax,	dword ptr[%r13+48]
    test      %rax,	%rax
    jz        L6802
L6801:
    mov       %al,	[%r13+61]
    test      %al,	%al
    jz        L6802
L6804:
    movsxd    %rax,	dword ptr[%r13+48]
    cmp       %rax,	8000
    jle       L6806
    lea       %rcx,	[%rbp + cc_show.jeval.str]
    lea       %rdx,	[%rip+L8899]
    call      strcpy
    jmp       L6805
L6806:
    mov       %rax,	[%r13]
    mov       %rcx,	%rax
    lea       %rdx,	[%rbp + cc_show.jeval.str]
    call      pc_api.convertstring
L6805:
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L8900]
    call      cc_support.gs_additem
    mov       %rcx,	%r12
    lea       %rdx,	[%rbp + cc_show.jeval.str]
    call      cc_support.gs_additem
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L8900]
    call      cc_support.gs_additem
    jmp       L6773
L6799:
    cmp       %rsi,	1
    jl        L6807
    cmp       %rsi,	4
    jg        L6807
    mov       %rax,	[%r13]
    mov       %rcx,	%rax
    lea       %rdx,	[%rbp + cc_show.jeval.str]
    call      msys.getstrint
    jmp       L6798
L6807:
    cmp       %rsi,	6
    jl        L6808
    cmp       %rsi,	9
    jg        L6808
    mov       %rax,	[%r13]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.strword
    lea       %rcx,	[%rbp + cc_show.jeval.str]
    mov       %rdx,	%rax
    call      strcpy
    jmp       L6798
L6808:
    cmp       %rsi,	11
    jz        L6810
    cmp       %rsi,	10
    jnz       L6809
L6810:
    movq      %XMM4,	[%r13]
    movq      %XMM0,	%XMM4
    xor       %edx,	%edx
    call      msys.strreal
    lea       %rcx,	[%rbp + cc_show.jeval.str]
    mov       %rdx,	%rax
    call      strcpy
    jmp       L6798
L6809:
    movsxd    %rax,	dword ptr[%r13+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    cmp       %r10,	13
    jz        L6812
    cmp       %r10,	17
    jz        L6813
    jmp       L6814
L6812:
#cc_show.jeval.doref:
L6802:
    lea       %rcx,	[%rbp + cc_show.jeval.str]
    call      msys.m$print_startstr
    mov       %rcx,	[%r13]
    call      msys.m$print_ptr_nf
    call      msys.m$print_end
    jmp       L6811
L6813:
    lea       %rcx,	[%rbp + cc_show.jeval.str]
    lea       %rdx,	[%rip+L8901]
    call      strcpy
    jmp       L6811
L6814:
    call      msys.m$print_startcon
    movsxd    %rax,	dword ptr[%r13+52]
    mov       %rcx,	%rax
    call      cc_lib.typename
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8902]
    call      mlib.abortprogram
L6811:
L6798:
    mov       %rcx,	%r12
    lea       %rdx,	[%rbp + cc_show.jeval.str]
    call      cc_support.gs_additem
    jmp       L6774
L6776:
    mov       %rax,	[%r13]
    mov       %rax,	[%rax]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_support.gs_additem
    jmp       L6774
L6777:
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L8903]
    call      mlib.gs_str
    mov       %rax,	[%r13]
    mov       %rax,	[%rax]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_support.gs_additem
    jmp       L6774
L6778:
    movsxd    %rax,	dword ptr[%r13+40]
    mov       %rcx,	%rax
    call      cc_lib.getopcjname
    lea       %rcx,	[%rbp + cc_show.jeval.str]
    mov       %rdx,	%rax
    call      strcpy
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L8904]
    call      cc_support.gs_additem
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rcx,	%r12
    lea       %rdx,	[%rbp + cc_show.jeval.str]
    call      cc_support.gs_additem
    mov       %rax,	[%r13+24]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L8905]
    call      cc_support.gs_additem
    jmp       L6774
L6779:
    movsxd    %rax,	dword ptr[%r13+40]
    mov       %rcx,	%rax
    call      cc_lib.getopcjname
    lea       %rcx,	[%rbp + cc_show.jeval.str]
    mov       %rdx,	%rax
    call      strcpy
    mov       %rcx,	%r12
    lea       %rdx,	[%rbp + cc_show.jeval.str]
    call      cc_support.gs_additem
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L8906]
    call      cc_support.gs_additem
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L8907]
    call      cc_support.gs_additem
    jmp       L6774
L6780:
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L8908]
    call      cc_support.gs_additem
    mov       %rdi,	[%r13+24]
    jmp       L6816
L6815:
    mov       %rcx,	%r12
    mov       %rdx,	%rdi
    call      cc_show.jeval
    mov       %rdi,	[%rdi+8]
    test      %rdi,	%rdi
    jz        L6819
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L8909]
    call      cc_support.gs_additem
L6819:
L6816:
    test      %rdi,	%rdi
    jnz       L6815
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L8910]
    call      cc_support.gs_additem
    jmp       L6774
L6781:
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L8911]
    call      cc_support.gs_additem
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L8912]
    call      mlib.gs_str
    jmp       L6774
L6782:
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L8913]
    call      cc_support.gs_additem
    mov       %rax,	[%r13+24]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    jmp       L6774
L6783:
    movsxd    %rax,	dword ptr[%r13+40]
    cmp       %rax,	29
    setz      %al
    movzx     %eax,	%al
    mov       %rbx,	%rax
    test      %rbx,	%rbx
    jz        L6821
    lea       %rax,	[%rip+L8914]
    jmp       L6820
L6821:
    lea       %rax,	[%rip+L8915]
L6820:
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_support.gs_additem
    mov       %rdi,	[%r13+16]
    jmp       L6823
L6822:
    mov       %rcx,	%r12
    mov       %rdx,	%rdi
    call      cc_show.jeval
    mov       %rdi,	[%rdi+8]
    test      %rdi,	%rdi
    jz        L6826
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L8916]
    call      cc_support.gs_additem
L6826:
L6823:
    test      %rdi,	%rdi
    jnz       L6822
    test      %rbx,	%rbx
    jz        L6828
    lea       %rax,	[%rip+L8917]
    jmp       L6827
L6828:
    lea       %rax,	[%rip+L8918]
L6827:
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_support.gs_additem
    jmp       L6774
L6784:
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L8919]
    call      cc_support.gs_additem
    mov       %rax,	[%r13+24]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    jmp       L6774
L6785:
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L8920]
    call      cc_support.gs_additem
    mov       %rax,	[%r13+24]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L8921]
    call      cc_support.gs_additem
    mov       %rax,	[%r13+32]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    jmp       L6774
L6786:
    movsxd    %rax,	dword ptr[%r13+52]
    mov       %rcx,	%rax
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_support.gs_additem
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L8922]
    call      cc_support.gs_additem
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L8923]
    call      cc_support.gs_additem
    jmp       L6774
L6787:
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L8924]
    call      cc_support.gs_additem
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rax,	[%r13+24]
    test      %rax,	%rax
    jz        L6830
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L8925]
    call      cc_support.gs_additem
    mov       %rax,	[%r13+24]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
L6830:
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L8926]
    call      cc_support.gs_additem
    jmp       L6774
L6788:
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L8927]
    call      cc_support.gs_additem
    jmp       L6774
L6789:
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L8928]
    call      cc_support.gs_additem
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    jmp       L6774
L6790:
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L8929]
    call      cc_support.gs_additem
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    jmp       L6774
L6791:
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L8930]
    call      cc_support.gs_additem
    jmp       L6774
L6792:
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L8931]
    call      cc_support.gs_additem
    jmp       L6774
L6793:
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L8932]
    call      mlib.gs_str
    jmp       L6774
L6794:
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L8933]
    call      mlib.gs_str
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    movsxd    %rax,	dword ptr[%r13+48]
    cmp       %rax,	0
    jle       L6832
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L8934]
    call      mlib.gs_str
    movsxd    %rax,	dword ptr[%r13+48]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      mlib.gs_strint
    jmp       L6831
L6832:
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L8935]
    call      mlib.gs_str
    movsxd    %rax,	dword ptr[%r13+48]
    neg       %rax
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      mlib.gs_strint
L6831:
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L8936]
    call      mlib.gs_str
    jmp       L6774
L6795:
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L8937]
    call      mlib.gs_str
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L8938]
    call      mlib.gs_str
    mov       %rax,	[%r13+24]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L8939]
    call      mlib.gs_str
    jmp       L6774
L6796:
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    jmp       L6774
L6797:
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L8940]
    call      mlib.gs_str
L6774:
L6773:
#---------------
    add       %rsp,	16040
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_show.printfilelist
cc_show.printfilelist:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rcx,	%rbx
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L8941]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+cc_decls.nsourcefiles]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rdi,	1
    mov       %rax,	[%rip+cc_decls.nsourcefiles]
    cmp       %rax,	1
    jl        L6836
L6834:
    mov       %rcx,	%rbx
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L8942]
    call      msys.m$print_setfmt
    mov       %rcx,	%rdi
    call      msys.m$print_i64_nf
    lea       %rax,	[%rip+cc_decls.sourcefilenames]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8943]
    call      msys.m$print_str
    lea       %rax,	[%rip+cc_decls.sourcefilepaths]
    mov       %r10,	%rdi
    mov       %rcx,	[%rax + %r10*8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    inc       %rdi
    cmp       %rdi,	[%rip+cc_decls.nsourcefiles]
    jle       L6834
L6836:
    mov       %rcx,	%rbx
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L8944]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+cc_decls.inputfile]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%rbx
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L8945]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+cc_decls.nlibfiles]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rdi,	1
    mov       %rax,	[%rip+cc_decls.nlibfiles]
    cmp       %rax,	1
    jl        L6839
L6837:
    mov       %rcx,	%rbx
    call      msys.m$print_startfile
    mov       %rcx,	%rdi
    call      msys.m$print_i64_nf
    lea       %rax,	[%rip+cc_decls.libfiles]
    mov       %r10,	%rdi
    mov       %rcx,	[%rax + %r10*8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    inc       %rdi
    cmp       %rdi,	[%rip+cc_decls.nlibfiles]
    jle       L6837
L6839:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_show.printmodelist
cc_show.printmodelist:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L8946]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+cc_decls.ntypes]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    xor       %rdi,	%rdi
    mov       %rax,	[%rip+cc_decls.ntypes]
    cmp       %rax,	0
    jl        L6843
L6841:
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8947]
    call      msys.m$print_i64
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rbx,	%rax
    lea       %rax,	[%rip+cc_decls.tttypedef]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    test      %rax,	%rax
    jz        L6845
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L8948]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L8949]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.tttypedef]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L6845:
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L8950]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L8951]
    call      msys.m$print_str_nf
    mov       %rcx,	%rbx
    call      msys.m$print_i64_nf
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L8952]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L8953]
    call      msys.m$print_str_nf
    mov       %rcx,	%rdi
    call      cc_lib.typename
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rax,	[%rip+cc_decls.ttnamedef]
    mov       %r10,	%rdi
    mov       %rsi,	[%rax + %r10*8]
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L8954]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L8955]
    call      msys.m$print_str_nf
    mov       %rcx,	%rsi
    call      msys.m$print_ptr_nf
    call      msys.m$print_space
    call      msys.m$print_end
    test      %rsi,	%rsi
    jz        L6847
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    mov       %rcx,	[%rsi]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L8956]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    movzx     %rax,	word ptr[%rsi+96]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L6846
L6847:
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L8957]
    call      msys.m$print_str_nf
    call      msys.m$print_end
L6846:
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L8958]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L8959]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rcx,	%rax
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L8960]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L8961]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rdi
    mov       %rcx,	[%rax + %r10*8]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L8962]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L8963]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%rdi
    mov       %rcx,	[%rax + %r10*8]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L8964]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L8965]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.ttisblock]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L8966]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L8967]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.ttconst]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L8968]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L8969]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.ttsigned]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L8970]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L8971]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.ttreftype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L8972]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L8973]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.ttconsttype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rcx,	%rax
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L8974]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L8975]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.ttshared]
    mov       %r10,	%rdi
    movsxd    %rax,	dword ptr[%rax + %r10*4]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
    inc       %rdi
    cmp       %rdi,	[%rip+cc_decls.ntypes]
    jle       L6841
L6843:
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msyswin.start
msyswin.start:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    call      msys.start
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc pepcl.start
pepcl.start:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    call      mc_decls.start
    call      mc_writegas.start
#---------------
    add       %rsp,	40
    ret       
# End 
    .data
$procaddr:
    .quad     mc_genmcl.px_nop
    .quad     mc_genmcl.px_dupl
    .quad     mc_genmcl.px_double
    .quad     mc_genmcl.px_opnd
    .quad     mc_genmcl.px_type
    .quad     mc_genmcl.px_comment
    .quad     mc_genmcl.px_proc
    .quad     mc_genmcl.px_endproc
    .quad     mc_genmcl.px_endprog
    .quad     mc_genmcl.px_istatic
    .quad     mc_genmcl.px_zstatic
    .quad     mc_genmcl.px_data
    .quad     mc_genmcl.px_label
    .quad     mc_genmcl.px_load
    .quad     mc_genmcl.px_store
    .quad     mc_genmcl.px_add
    .quad     mc_genmcl.px_sub
    .quad     mc_genmcl.px_mul
    .quad     mc_genmcl.px_div
    .quad     mc_genmcl.px_eval
    .quad     mc_genmcl.px_widen
    .quad     mc_genmcl.px_jump
    .quad     mc_genmcl.px_ijump
    .quad     mc_genmcl.px_neg
    .quad     mc_genmcl.px_abs
    .quad     mc_genmcl.px_bitnot
    .quad     mc_genmcl.px_not
    .quad     mc_genmcl.px_toboolt
    .quad     mc_genmcl.px_sqr
    .quad     mc_genmcl.px_sqrt
    .quad     mc_genmcl.px_jumpcc
    .quad     mc_genmcl.px_jumpt
    .quad     mc_genmcl.px_jumpf
    .quad     mc_genmcl.px_bitand
    .quad     mc_genmcl.px_bitor
    .quad     mc_genmcl.px_bitxor
    .quad     mc_genmcl.px_shl
    .quad     mc_genmcl.px_shr
    .quad     mc_genmcl.px_retproc
    .quad     mc_genmcl.px_retfn
    .quad     mc_genmcl.px_setcall
    .quad     mc_genmcl.px_setarg
    .quad     mc_genmcl.px_callp
    .quad     mc_genmcl.px_jumpret
    .quad     mc_genmcl.px_jumpretm
    .quad     mc_genmcl.px_startmx
    .quad     mc_genmcl.px_resetmx
    .quad     mc_genmcl.px_stop
    .quad     mc_genmcl.px_incrto
    .quad     mc_genmcl.px_decrto
    .quad     mc_genmcl.px_incrload
    .quad     mc_genmcl.px_decrload
    .quad     mc_genmcl.px_loadincr
    .quad     mc_genmcl.px_loaddecr
    .quad     mc_genmcl.px_forup
    .quad     mc_genmcl.px_fordown
    .quad     mc_genmcl.px_iload
    .quad     mc_genmcl.px_iloadx
    .quad     mc_genmcl.px_istore
    .quad     mc_genmcl.px_istorex
    .quad     mc_genmcl.px_storem
    .quad     mc_genmcl.px_addpx
    .quad     mc_genmcl.px_subpx
    .quad     mc_genmcl.px_to
    .quad     mc_genmcl.px_iswap
    .quad     mc_genmcl.px_swapstk
    .quad     mc_genmcl.px_labeldef
    .quad     mc_genmcl.px_addto
    .quad     mc_genmcl.px_subto
    .quad     mc_genmcl.px_multo
    .quad     mc_genmcl.px_bitandto
    .quad     mc_genmcl.px_bitorto
    .quad     mc_genmcl.px_bitxorto
    .quad     mc_genmcl.px_shlto
    .quad     mc_genmcl.px_shrto
    .quad     mc_genmcl.px_fix
    .quad     mc_genmcl.px_float
    .quad     mc_genmcl.px_idiv
    .quad     mc_genmcl.px_irem
    .quad     mc_genmcl.px_idivrem
    .quad     mc_genmcl.px_clear
    .quad     mc_genmcl.px_subp
    .quad     mc_genmcl.px_switch
    .quad     mc_genmcl.px_switchu
    .quad     mc_genmcl.px_swlabel
    .quad     mc_genmcl.px_endsw
    .quad     mc_genmcl.px_fwiden
    .quad     mc_genmcl.px_fnarrow
    .quad     mc_genmcl.px_truncate
    .quad     mc_genmcl.px_typepun
    .quad     mc_genmcl.px_unload
    .quad     mc_genmcl.px_loadbit
    .quad     mc_genmcl.px_assem
    .quad     mc_genmcl.px_sin
    .quad     mc_genmcl.px_cos
    .quad     mc_genmcl.px_tan
    .quad     mc_genmcl.px_asin
    .quad     mc_genmcl.px_acos
    .quad     mc_genmcl.px_atan
    .quad     mc_genmcl.px_log
    .quad     mc_genmcl.px_log10
    .quad     mc_genmcl.px_exp
    .quad     mc_genmcl.px_round
    .quad     mc_genmcl.px_floor
    .quad     mc_genmcl.px_ceil
    .quad     mc_genmcl.px_atan2
    .quad     mc_genmcl.px_fmod
    .quad     mc_genmcl.px_setcc
    .quad     mc_genmcl.px_min
    .quad     mc_genmcl.px_max
    .quad     mc_genmcl.px_power
    .quad     mc_genmcl.px_minto
    .quad     mc_genmcl.px_maxto
    .quad     mc_genmcl.px_negto
    .quad     mc_genmcl.px_absto
    .quad     mc_genmcl.px_addpxto
    .quad     mc_genmcl.px_subpxto
    .quad     mc_genmcl.px_divto
    .quad     mc_genmcl.px_bitnotto
    .quad     mc_genmcl.px_notto
    .quad     mc_genmcl.px_toboolto
    .quad     mc_genmcl.px_sign
    .quad     mc_genmcl.px_loadbf
    .quad     mc_genmcl.px_storebit
    .quad     mc_genmcl.px_storebf
    .quad     mc_genmcl.px_loadall
    .quad     mc_genmcl.px_setjmp
    .quad     mc_genmcl.px_longjmp
    .quad     mc_genmcl.px_initdswx
    .quad     mc_auxmcl.do_addrmode
$procname:
    .quad     L8976
    .quad     L8977
    .quad     L8978
    .quad     L8979
    .quad     L8980
    .quad     L8981
    .quad     L8982
    .quad     L8983
    .quad     L8984
    .quad     L8985
    .quad     L8986
    .quad     L8987
    .quad     L8988
    .quad     L8989
    .quad     L8990
    .quad     L8991
    .quad     L8992
    .quad     L8993
    .quad     L8994
    .quad     L8995
    .quad     L8996
    .quad     L8997
    .quad     L8998
    .quad     L8999
    .quad     L9000
    .quad     L9001
    .quad     L9002
    .quad     L9003
    .quad     L9004
    .quad     L9005
    .quad     L9006
    .quad     L9007
    .quad     L9008
    .quad     L9009
    .quad     L9010
    .quad     L9011
    .quad     L9012
    .quad     L9013
    .quad     L9014
    .quad     L9015
    .quad     L9016
    .quad     L9017
    .quad     L9018
    .quad     L9019
    .quad     L9020
    .quad     L9021
    .quad     L9022
    .quad     L9023
    .quad     L9024
    .quad     L9025
    .quad     L9026
    .quad     L9027
    .quad     L9028
    .quad     L9029
    .quad     L9030
    .quad     L9031
    .quad     L9032
    .quad     L9033
    .quad     L9034
    .quad     L9035
    .quad     L9036
    .quad     L9037
    .quad     L9038
    .quad     L9039
    .quad     L9040
    .quad     L9041
    .quad     L9042
    .quad     L9043
    .quad     L9044
    .quad     L9045
    .quad     L9046
    .quad     L9047
    .quad     L9048
    .quad     L9049
    .quad     L9050
    .quad     L9051
    .quad     L9052
    .quad     L9053
    .quad     L9054
    .quad     L9055
    .quad     L9056
    .quad     L9057
    .quad     L9058
    .quad     L9059
    .quad     L9060
    .quad     L9061
    .quad     L9062
    .quad     L9063
    .quad     L9064
    .quad     L9065
    .quad     L9066
    .quad     L9067
    .quad     L9068
    .quad     L9069
    .quad     L9070
    .quad     L9071
    .quad     L9072
    .quad     L9073
    .quad     L9074
    .quad     L9075
    .quad     L9076
    .quad     L9077
    .quad     L9078
    .quad     L9079
    .quad     L9080
    .quad     L9081
    .quad     L9082
    .quad     L9083
    .quad     L9084
    .quad     L9085
    .quad     L9086
    .quad     L9087
    .quad     L9088
    .quad     L9089
    .quad     L9090
    .quad     L9091
    .quad     L9092
    .quad     L9093
    .quad     L9094
    .quad     L9095
    .quad     L9096
    .quad     L9097
    .quad     L9098
    .quad     L9099
    .quad     L9100
    .quad     L9101
    .quad     L9102
    .quad     L9103
    .quad     L9104
    .quad     L9105
$nprocs:
    .quad     0x82
#Real Table
    .align    8
L8667:
    .quad     0x3FF0000000000000
L8574:
    .quad     0x4024000000000000
L8571:
    .quad     0x4024000000000000
L8566:
    .quad     0
L8565:
    .quad     0x4000000000000000
L8450:
    .quad     0x4000000000000000
L8407:
    .quad     0x4059000000000000
L8199:
    .quad     0x7FF0000000000000
L8197:
    .quad     0x7FF0000000000000
L8180:
    .quad     0
L8087:
    .quad     0x43E0000000000000
L8086:
    .quad     0x3FF0000000000000
L8085:
    .quad     0x43E0000000000000
L8062:
    .quad     0
L8060:
    .quad     0
#Real32 Table
    .align    16
#labneg64
L8656:
    .quad     0x8000000000000000
    .quad     0x8000000000000000
#mask63/offset64
L8569:
    .quad     0x7FFFFFFFFFFFFFFF
L8570:
    .quad     0x43E0000000000000
#String Table
    .align    8
L9105:
    .ascii    "do_addrmode"
    .byte     0
L9104:
    .ascii    "px_initdswx"
    .byte     0
L9103:
    .ascii    "px_longjmp"
    .byte     0
L9102:
    .ascii    "px_setjmp"
    .byte     0
L9101:
    .ascii    "px_loadall"
    .byte     0
L9100:
    .ascii    "px_storebf"
    .byte     0
L9099:
    .ascii    "px_storebit"
    .byte     0
L9098:
    .ascii    "px_loadbf"
    .byte     0
L9097:
    .ascii    "px_sign"
    .byte     0
L9096:
    .ascii    "px_toboolto"
    .byte     0
L9095:
    .ascii    "px_notto"
    .byte     0
L9094:
    .ascii    "px_bitnotto"
    .byte     0
L9093:
    .ascii    "px_divto"
    .byte     0
L9092:
    .ascii    "px_subpxto"
    .byte     0
L9091:
    .ascii    "px_addpxto"
    .byte     0
L9090:
    .ascii    "px_absto"
    .byte     0
L9089:
    .ascii    "px_negto"
    .byte     0
L9088:
    .ascii    "px_maxto"
    .byte     0
L9087:
    .ascii    "px_minto"
    .byte     0
L9086:
    .ascii    "px_power"
    .byte     0
L9085:
    .ascii    "px_max"
    .byte     0
L9084:
    .ascii    "px_min"
    .byte     0
L9083:
    .ascii    "px_setcc"
    .byte     0
L9082:
    .ascii    "px_fmod"
    .byte     0
L9081:
    .ascii    "px_atan2"
    .byte     0
L9080:
    .ascii    "px_ceil"
    .byte     0
L9079:
    .ascii    "px_floor"
    .byte     0
L9078:
    .ascii    "px_round"
    .byte     0
L9077:
    .ascii    "px_exp"
    .byte     0
L9076:
    .ascii    "px_log10"
    .byte     0
L9075:
    .ascii    "px_log"
    .byte     0
L9074:
    .ascii    "px_atan"
    .byte     0
L9073:
    .ascii    "px_acos"
    .byte     0
L9072:
    .ascii    "px_asin"
    .byte     0
L9071:
    .ascii    "px_tan"
    .byte     0
L9070:
    .ascii    "px_cos"
    .byte     0
L9069:
    .ascii    "px_sin"
    .byte     0
L9068:
    .ascii    "px_assem"
    .byte     0
L9067:
    .ascii    "px_loadbit"
    .byte     0
L9066:
    .ascii    "px_unload"
    .byte     0
L9065:
    .ascii    "px_typepun"
    .byte     0
L9064:
    .ascii    "px_truncate"
    .byte     0
L9063:
    .ascii    "px_fnarrow"
    .byte     0
L9062:
    .ascii    "px_fwiden"
    .byte     0
L9061:
    .ascii    "px_endsw"
    .byte     0
L9060:
    .ascii    "px_swlabel"
    .byte     0
L9059:
    .ascii    "px_switchu"
    .byte     0
L9058:
    .ascii    "px_switch"
    .byte     0
L9057:
    .ascii    "px_subp"
    .byte     0
L9056:
    .ascii    "px_clear"
    .byte     0
L9055:
    .ascii    "px_idivrem"
    .byte     0
L9054:
    .ascii    "px_irem"
    .byte     0
L9053:
    .ascii    "px_idiv"
    .byte     0
L9052:
    .ascii    "px_float"
    .byte     0
L9051:
    .ascii    "px_fix"
    .byte     0
L9050:
    .ascii    "px_shrto"
    .byte     0
L9049:
    .ascii    "px_shlto"
    .byte     0
L9048:
    .ascii    "px_bitxorto"
    .byte     0
L9047:
    .ascii    "px_bitorto"
    .byte     0
L9046:
    .ascii    "px_bitandto"
    .byte     0
L9045:
    .ascii    "px_multo"
    .byte     0
L9044:
    .ascii    "px_subto"
    .byte     0
L9043:
    .ascii    "px_addto"
    .byte     0
L9042:
    .ascii    "px_labeldef"
    .byte     0
L9041:
    .ascii    "px_swapstk"
    .byte     0
L9040:
    .ascii    "px_iswap"
    .byte     0
L9039:
    .ascii    "px_to"
    .byte     0
L9038:
    .ascii    "px_subpx"
    .byte     0
L9037:
    .ascii    "px_addpx"
    .byte     0
L9036:
    .ascii    "px_storem"
    .byte     0
L9035:
    .ascii    "px_istorex"
    .byte     0
L9034:
    .ascii    "px_istore"
    .byte     0
L9033:
    .ascii    "px_iloadx"
    .byte     0
L9032:
    .ascii    "px_iload"
    .byte     0
L9031:
    .ascii    "px_fordown"
    .byte     0
L9030:
    .ascii    "px_forup"
    .byte     0
L9029:
    .ascii    "px_loaddecr"
    .byte     0
L9028:
    .ascii    "px_loadincr"
    .byte     0
L9027:
    .ascii    "px_decrload"
    .byte     0
L9026:
    .ascii    "px_incrload"
    .byte     0
L9025:
    .ascii    "px_decrto"
    .byte     0
L9024:
    .ascii    "px_incrto"
    .byte     0
L9023:
    .ascii    "px_stop"
    .byte     0
L9022:
    .ascii    "px_resetmx"
    .byte     0
L9021:
    .ascii    "px_startmx"
    .byte     0
L9020:
    .ascii    "px_jumpretm"
    .byte     0
L9019:
    .ascii    "px_jumpret"
    .byte     0
L9018:
    .ascii    "px_callp"
    .byte     0
L9017:
    .ascii    "px_setarg"
    .byte     0
L9016:
    .ascii    "px_setcall"
    .byte     0
L9015:
    .ascii    "px_retfn"
    .byte     0
L9014:
    .ascii    "px_retproc"
    .byte     0
L9013:
    .ascii    "px_shr"
    .byte     0
L9012:
    .ascii    "px_shl"
    .byte     0
L9011:
    .ascii    "px_bitxor"
    .byte     0
L9010:
    .ascii    "px_bitor"
    .byte     0
L9009:
    .ascii    "px_bitand"
    .byte     0
L9008:
    .ascii    "px_jumpf"
    .byte     0
L9007:
    .ascii    "px_jumpt"
    .byte     0
L9006:
    .ascii    "px_jumpcc"
    .byte     0
L9005:
    .ascii    "px_sqrt"
    .byte     0
L9004:
    .ascii    "px_sqr"
    .byte     0
L9003:
    .ascii    "px_toboolt"
    .byte     0
L9002:
    .ascii    "px_not"
    .byte     0
L9001:
    .ascii    "px_bitnot"
    .byte     0
L9000:
    .ascii    "px_abs"
    .byte     0
L8999:
    .ascii    "px_neg"
    .byte     0
L8998:
    .ascii    "px_ijump"
    .byte     0
L8997:
    .ascii    "px_jump"
    .byte     0
L8996:
    .ascii    "px_widen"
    .byte     0
L8995:
    .ascii    "px_eval"
    .byte     0
L8994:
    .ascii    "px_div"
    .byte     0
L8993:
    .ascii    "px_mul"
    .byte     0
L8992:
    .ascii    "px_sub"
    .byte     0
L8991:
    .ascii    "px_add"
    .byte     0
L8990:
    .ascii    "px_store"
    .byte     0
L8989:
    .ascii    "px_load"
    .byte     0
L8988:
    .ascii    "px_label"
    .byte     0
L8987:
    .ascii    "px_data"
    .byte     0
L8986:
    .ascii    "px_zstatic"
    .byte     0
L8985:
    .ascii    "px_istatic"
    .byte     0
L8984:
    .ascii    "px_endprog"
    .byte     0
L8983:
    .ascii    "px_endproc"
    .byte     0
L8982:
    .ascii    "px_proc"
    .byte     0
L8981:
    .ascii    "px_comment"
    .byte     0
L8980:
    .ascii    "px_type"
    .byte     0
L8979:
    .ascii    "px_opnd"
    .byte     0
L8978:
    .ascii    "px_double"
    .byte     0
L8977:
    .ascii    "px_dupl"
    .byte     0
L8976:
    .ascii    "px_nop"
    .byte     0
L8975:
    .ascii    "Shared:"
    .byte     0
L8974:
    .byte     9
    .byte     0
L8973:
    .ascii    "Constver:"
    .byte     0
L8972:
    .byte     9
    .byte     0
L8971:
    .ascii    "Ref:"
    .byte     0
L8970:
    .byte     9
    .byte     0
L8969:
    .ascii    "Signed:"
    .byte     0
L8968:
    .byte     9
    .byte     0
L8967:
    .ascii    "Const:"
    .byte     0
L8966:
    .byte     9
    .byte     0
L8965:
    .ascii    "Isblock:"
    .byte     0
L8964:
    .byte     9
    .byte     0
L8963:
    .ascii    "Length:"
    .byte     0
L8962:
    .byte     9
    .byte     0
L8961:
    .ascii    "Size:"
    .byte     0
L8960:
    .byte     9
    .byte     0
L8959:
    .ascii    "Target:"
    .byte     0
L8958:
    .byte     9
    .byte     0
L8957:
    .ascii    "-"
    .byte     0
L8956:
    .ascii    "."
    .byte     0
L8955:
    .ascii    "ttnamedef:"
    .byte     0
L8954:
    .byte     9
    .byte     0
L8953:
    .ascii    "Name:"
    .byte     0
L8952:
    .byte     9
    .byte     0
L8951:
    .ascii    "Basetype:"
    .byte     0
L8950:
    .byte     9
    .byte     0
L8949:
    .ascii    "Typedef:"
    .byte     0
L8948:
    .byte     9
    .byte     0
L8947:
    .ascii    "4"
    .byte     0
L8946:
    .ascii    "PROC MODELIST"
    .byte     0
L8945:
    .byte     10
    .ascii    "Libfiles"
    .byte     0
L8944:
    .byte     10
    .ascii    "Input file:"
    .byte     0
L8943:
    .ascii    "12jl"
    .byte     0
L8942:
    .ascii    "# # (#)"
    .byte     0
L8941:
    .ascii    "Source files"
    .byte     0
L8940:
    .ascii    "<CAN'T DO JEVAL>"
    .byte     0
L8939:
    .ascii    ")"
    .byte     0
L8938:
    .ascii    "+"
    .byte     0
L8937:
    .ascii    "("
    .byte     0
L8936:
    .ascii    ")"
    .byte     0
L8935:
    .ascii    ")/"
    .byte     0
L8934:
    .ascii    ")*"
    .byte     0
L8933:
    .ascii    "scale(("
    .byte     0
L8932:
    .ascii    "<nullunit>"
    .byte     0
L8931:
    .ascii    "--"
    .byte     0
L8930:
    .ascii    "++"
    .byte     0
L8929:
    .ascii    "--"
    .byte     0
L8928:
    .ascii    "++"
    .byte     0
L8927:
    .ascii    "<JBLOCK>"
    .byte     0
L8926:
    .ascii    ")"
    .byte     0
L8925:
    .ascii    "+"
    .byte     0
L8924:
    .ascii    "*("
    .byte     0
L8923:
    .ascii    ")"
    .byte     0
L8922:
    .ascii    "("
    .byte     0
L8921:
    .ascii    ":"
    .byte     0
L8920:
    .ascii    "?"
    .byte     0
L8919:
    .ascii    "="
    .byte     0
L8918:
    .ascii    "}"
    .byte     0
L8917:
    .ascii    ")"
    .byte     0
L8916:
    .ascii    ","
    .byte     0
L8915:
    .ascii    "{"
    .byte     0
L8914:
    .ascii    "("
    .byte     0
L8913:
    .ascii    "->"
    .byte     0
L8912:
    .ascii    "???"
    .byte     0
L8911:
    .ascii    "."
    .byte     0
L8910:
    .ascii    ")"
    .byte     0
L8909:
    .ascii    ","
    .byte     0
L8908:
    .ascii    "("
    .byte     0
L8907:
    .ascii    ")"
    .byte     0
L8906:
    .ascii    "("
    .byte     0
L8905:
    .ascii    ")"
    .byte     0
L8904:
    .ascii    "("
    .byte     0
L8903:
    .ascii    "&"
    .byte     0
L8902:
    .ascii    "EVAL/C"
    .byte     0
L8901:
    .ascii    "ARRAY"
    .byte     0
L8900:
    .byte     34
    .byte     0
L8899:
    .ascii    "LONGSTR)"
    .byte     0
L8898:
    .ascii    ")"
    .byte     0
L8897:
    .ascii    "-"
    .byte     0
L8896:
    .ascii    "(From"
    .byte     0
L8895:
    .byte     9
    .byte     0
L8894:
    .ascii    ":"
    .byte     0
L8893:
    .ascii    "GLOBAL SYMBOL TABLE:"
    .byte     0
L8892:
    .ascii    "*"
    .byte     0
L8891:
    .ascii    " Code:"
    .byte     0
L8890:
    .ascii    " Mode:"
    .byte     0
L8889:
    .ascii    "Anon"
    .byte     0
L8888:
    .byte     9
    .byte     9
    .ascii    "Param: "
    .byte     0
L8887:
    .ascii    " "
    .byte     0
L8886:
    .ascii    "Lineno:"
    .byte     0
L8885:
    .ascii    " "
    .byte     0
L8884:
    .ascii    "STATIC********"
    .byte     0
L8883:
    .ascii    "="
    .byte     0
L8882:
    .ascii    "Enum:"
    .byte     0
L8881:
    .ascii    "Index:"
    .byte     0
L8880:
    .ascii    " Offset: "
    .byte     0
L8879:
    .ascii    "="
    .byte     0
L8878:
    .ascii    "Offset:"
    .byte     0
L8877:
    .ascii    "Void "
    .byte     0
L8876:
    .ascii    "()"
    .byte     0
L8875:
    .ascii    "(#)"
    .byte     0
L8874:
    .ascii    "]"
    .byte     0
L8873:
    .ascii    "Pm:# "
    .byte     0
L8872:
    .ascii    "Used "
    .byte     0
L8871:
    .ascii    "Var "
    .byte     0
L8870:
    .ascii    " "
    .byte     0
L8869:
    .ascii    "@@"
    .byte     0
L8868:
    .ascii    " "
    .byte     0
L8867:
    .ascii    "["
    .byte     0
L8866:
    .ascii    "."
    .byte     0
L8865:
    .ascii    ":"
    .byte     0
L8864:
    .ascii    "    "
    .byte     0
L8863:
    .ascii    "PRINTST not name"
    .byte     0
L8862:
    .ascii    "z5"
    .byte     0
L8861:
    .ascii    "# "
    .byte     0
L8860:
    .ascii    "."
    .byte     0
L8859:
    .ascii    " "
    .byte     0
L8858:
    .ascii    "|---"
    .byte     0
L8857:
    .ascii    "-----------------------"
    .byte     0
L8856:
    .ascii    "3"
    .byte     0
L8855:
    .ascii    "2"
    .byte     0
L8854:
    .ascii    "1"
    .byte     0
L8853:
    .ascii    " ALENGTH="
    .byte     0
L8852:
    .ascii    " Widen from:"
    .byte     0
L8851:
    .ascii    " Offset:"
    .byte     0
L8850:
    .ascii    " Aparams:"
    .byte     0
L8849:
    .ascii    "Ptrscale:"
    .byte     0
L8848:
    .ascii    "Scale:"
    .byte     0
L8847:
    .ascii    " => "
    .byte     0
L8846:
    .ascii    " "
    .byte     0
L8845:
    .ascii    "<WSTRCONST>"
    .byte     0
L8844:
    .ascii    "<STRCONST>"
    .byte     0
L8843:
    .ascii    " "
    .byte     0
L8842:
    .ascii    "PRINTUNIT BAD CONST"
    .byte     0
L8841:
    .ascii    "PRINTUNIT/CONST/aRRAY"
    .byte     0
L8840:
    .byte     34
    .ascii    " *"
    .byte     0
L8839:
    .ascii    "(WSTRING)"
    .byte     0
L8838:
    .byte     34
    .byte     0
L8837:
    .byte     34
    .ascii    " *"
    .byte     0
L8836:
    .byte     34
    .byte     0
L8835:
    .byte     34
    .ascii    " *"
    .byte     0
L8834:
    .ascii    "(LONGSTR)"
    .byte     0
L8833:
    .byte     34
    .byte     0
L8832:
    .ascii    "Value:"
    .byte     0
L8831:
    .ascii    "1"
    .byte     0
L8830:
    .ascii    " Lastcall:"
    .byte     0
L8829:
    .ascii    " "
    .byte     0
L8828:
    .ascii    "}"
    .byte     0
L8827:
    .ascii    " {"
    .byte     0
L8826:
    .ascii    ": "
    .byte     0
L8824:
    .ascii    "             "
    .byte     0
L8823:
    .ascii    "print unit: bad tag"
    .byte     0
L8822:
    .ascii    "1"
    .byte     0
L8821:
    .ascii    "="
    .byte     0
L8820:
    .ascii    " "
    .byte     0
L8819:
    .ascii    "<builtin>"
    .byte     0
L8818:
    .byte     0
L8817:
    .ascii    "Too many source files"
    .byte     0
L8816:
    .ascii    "LSF can't load "
    .byte     0
L8815:
    .byte     0
L8814:
    .ascii    "Too many source files"
    .byte     0
L8813:
    .ascii    "Stopping"
    .byte     0
L8812:
    .ascii    "Load Error:"
    .byte     0
L8811:
    .ascii    "****"
    .byte     0
L8810:
    .ascii    "**** Code Gen Error:"
    .byte     0
L8809:
    .ascii    "in file"
    .byte     0
L8808:
    .ascii    "On line"
    .byte     0
L8807:
    .ascii    " "
    .byte     0
L8806:
    .ascii    "In function"
    .byte     0
L8805:
    .ascii    "on line"
    .byte     0
L8804:
    .ascii    "Type error:"
    .byte     0
L8803:
    .byte     10
    .ascii    "In function"
    .byte     0
L8802:
    .ascii    "****"
    .byte     0
L8801:
    .ascii    "**** Syntax Error:"
    .byte     0
L8800:
    .ascii    "in file"
    .byte     0
L8799:
    .ascii    "On line"
    .byte     0
L8798:
    .ascii    "OUTSIDE PROC"
    .byte     0
L8797:
    .ascii    " "
    .byte     0
L8796:
    .byte     10
    .ascii    "In function"
    .byte     0
L8795:
    .byte     10
    .ascii    "MC Error:"
    .byte     0
L8794:
    .ascii    "w"
    .byte     0
L8793:
    .ascii    "$error.tmp"
    .byte     0
L8792:
    .ascii    "ATL ERROR"
    .byte     0
L8791:
    .ascii    "rb"
    .byte     0
L8790:
    .ascii    "w"
    .byte     0
L8789:
    .ascii    "GETALIGN SIZE NOT 1248"
    .byte     0
L8788:
    .ascii    "Dupl proc name"
    .byte     0
L8787:
    .ascii    "in"
    .byte     0
L8786:
    .byte     34
    .byte     0
L8785:
    .ascii    " "
    .byte     34
    .byte     0
L8784:
    .ascii    "# expected, not #"
    .byte     0
L8783:
    .ascii    "Too many types/cnm"
    .byte     0
L8782:
    .ascii    "STRMODE(M)="
    .byte     0
L8781:
    .ascii    "Too many types"
    .byte     0
L8780:
    .byte     0
L8779:
    .ascii    "const "
    .byte     0
L8778:
    .ascii    "<enum>"
    .byte     0
L8777:
    .ascii    "<array>"
    .byte     0
L8776:
    .ascii    "."
    .byte     0
L8775:
    .ascii    "union "
    .byte     0
L8774:
    .ascii    "struct "
    .byte     0
L8773:
    .ascii    "NEWSTRMODE"
    .byte     0
L8772:
    .ascii    ")"
    .byte     0
L8771:
    .ascii    ","
    .byte     0
L8770:
    .ascii    "proc("
    .byte     0
L8769:
    .ascii    ")"
    .byte     0
L8768:
    .ascii    " "
    .byte     0
L8767:
    .ascii    ","
    .byte     0
L8766:
    .ascii    "("
    .byte     0
L8765:
    .ascii    "enum "
    .byte     0
L8764:
    .ascii    "[]"
    .byte     0
L8763:
    .ascii    "[#]"
    .byte     0
L8762:
    .ascii    "ref "
    .byte     0
L8761:
    .ascii    "const ref "
    .byte     0
L8760:
    .ascii    "z3"
    .byte     0
L8759:
    .byte     92
    .ascii    "#o"
    .byte     0
L8758:
    .ascii    "$F"
    .byte     0
L8757:
    .ascii    "$T"
    .byte     0
L8756:
    .ascii    "GCV Not constant"
    .byte     0
L8755:
    .ascii    "Can't find -to version"
    .byte     0
L8754:
    .ascii    "to"
    .byte     0
L8752:
    .ascii    "main"
    .byte     0
L8751:
    .ascii    "."
    .byte     0
L8750:
    .ascii    "Dupl case value: #"
    .byte     0
L8749:
    .ascii    "Too many cases on one switch"
    .byte     0
L8748:
    .ascii    "case: serial switch not found"
    .byte     0
L8747:
    .ascii    "Label not defined: #"
    .byte     0
L8746:
    .ascii    "maxparams"
    .byte     0
L8745:
    .ascii    "Convert op not implem: #"
    .byte     0
L8744:
    .ascii    "Bad cast"
    .byte     0
L8743:
    .ascii    "DOASSIGN not ready: #"
    .byte     0
L8742:
    .ascii    "dxname"
    .byte     0
L8741:
    .ascii    "const?"
    .byte     0
L8740:
    .ascii    "CONST/WSTRING"
    .byte     0
L8739:
    .ascii    "DX-EXPR: can't do tag: #"
    .byte     0
L8738:
    .ascii    "2:Runtime expr in static data"
    .byte     0
L8737:
    .ascii    "*"
    .byte     0
L8736:
    .ascii    "Complex ptr expr in static data"
    .byte     0
L8735:
    .ascii    "1:Runtime or unsupported expr in static data"
    .byte     0
L8734:
    .ascii    "+"
    .byte     0
L8733:
    .ascii    "Add/Idata &frame"
    .byte     0
L8732:
    .ascii    "+"
    .byte     0
L8731:
    .ascii    ","
    .byte     0
L8730:
    .ascii    "`"
    .byte     0
L8729:
    .ascii    "Idata &frame"
    .byte     0
L8728:
    .ascii    "IDATA/SCALAR"
    .byte     0
L8727:
    .ascii    "GENIDATA/WSTRING2"
    .byte     0
L8726:
    .ascii    "$#.#.#"
    .byte     0
L8725:
    .byte     0
L8724:
    .ascii    "------------------------"
    .byte     0
L8723:
    .ascii    "main"
    .byte     0
L8722:
    .byte     0
L8721:
    .ascii    "Static fn not defined: #"
    .byte     0
L8720:
    .ascii    "1:Start of code"
    .byte     0
L8719:
    .ascii    "GenPCL:"
    .byte     0
L8718:
    .ascii    "dllexport"
    .byte     0
L8717:
    .ascii    "Generic: multiple types match"
    .byte     0
L8716:
    .ascii    "Generic: no type match"
    .byte     0
L8715:
    .ascii    "generic/default twice"
    .byte     0
L8714:
    .ascii    "Not array"
    .byte     0
L8713:
    .ascii    "*"
    .byte     0
L8712:
    .ascii    "Can't do conversion # => #"
    .byte     0
L8711:
    .ascii    "*"
    .byte     0
L8710:
    .ascii    "case not inside switch stmt"
    .byte     0
L8709:
    .ascii    "poploop?"
    .byte     0
L8708:
    .ascii    "Too many nested loop or switch"
    .byte     0
L8707:
    .ascii    "Not allowed on ptrs"
    .byte     0
L8706:
    .ascii    "-= refs don't match"
    .byte     0
L8705:
    .ascii    "ptr+=ptr"
    .byte     0
L8704:
    .ascii    "Not a field of struct # #"
    .byte     0
L8703:
    .ascii    ". -> not a struct"
    .byte     0
L8702:
    .ascii    "-> needs pointer"
    .byte     0
L8701:
    .ascii    "enum name reused #"
    .byte     0
L8700:
    .ascii    "Redefining enum #"
    .byte     0
L8699:
    .ascii    "Enum tag in use #"
    .byte     0
L8698:
    .ascii    "BAD REF[]"
    .byte     0
L8697:
    .ascii    "const to non-const pointer"
    .byte     0
L8696:
    .ascii    "Struct decl error #"
    .byte     0
L8695:
    .ascii    "Struct decl error"
    .byte     0
L8694:
    .ascii    "Can't use ss in struct"
    .byte     0
L8693:
    .ascii    "member name in use #"
    .byte     0
L8692:
    .ascii    "typedef or function inside struct"
    .byte     0
L8691:
    .ascii    "Field name expected"
    .byte     0
L8690:
    .ascii    "Redefining struct #"
    .byte     0
L8689:
    .ascii    "Prev"
    .byte     0
L8688:
    .ascii    "Struct tag in use #"
    .byte     0
L8687:
    .ascii    "ATP?"
    .byte     0
L8686:
    .ascii    "*"
    .byte     0
L8685:
    .ascii    "ATP:"
    .byte     0
L8684:
    .ascii    "Variadic param is void"
    .byte     0
L8683:
    .ascii    "Too many args"
    .byte     0
L8682:
    .ascii    "1:Too few args"
    .byte     0
L8681:
    .ascii    "ccall?"
    .byte     0
L8680:
    .ascii    "*"
    .byte     0
L8679:
    .ascii    "JTAGNAMES[P.TAG]="
    .byte     0
L8678:
    .ascii    "Not function pointer: #"
    .byte     0
L8677:
    .ascii    "value: #"
    .byte     0
L8676:
    .ascii    "*"
    .byte     0
L8675:
    .ascii    "CHECKLV/WIDEN"
    .byte     0
L8673:
    .ascii    "Invalid condition #"
    .byte     0
L8672:
    .ascii    "rem 0"
    .byte     0
L8671:
    .ascii    "div 0"
    .byte     0
L8670:
    .ascii    "EVALSUB/REF"
    .byte     0
L8668:
    .ascii    "Rem bad types"
    .byte     0
L8666:
    .ascii    "Div bad types"
    .byte     0
L8665:
    .ascii    "Mul bad types"
    .byte     0
L8664:
    .ascii    "Sub bad types"
    .byte     0
L8663:
    .ascii    "++ bad type"
    .byte     0
L8662:
    .ascii    "* not pointer"
    .byte     0
L8661:
    .ascii    "*"
    .byte     0
L8660:
    .ascii    "! bad type"
    .byte     0
L8659:
    .ascii    "abs bad type"
    .byte     0
L8657:
    .ascii    "neg bad type"
    .byte     0
L8655:
    .ascii    "; after function def"
    .byte     0
L8654:
    .ascii    "Can't define function twice #"
    .byte     0
L8653:
    .ascii    "fn: name in use #"
    .byte     0
L8652:
    .ascii    "NAME not allowed in cast type #"
    .byte     0
L8651:
    .ascii    "bad symbol in paramlist"
    .byte     0
L8650:
    .ascii    "Param name reused # #"
    .byte     0
L8649:
    .ascii    "Param type missing or misspelt"
    .byte     0
L8648:
    .ascii    "Typedef redefined or can't match types #"
    .byte     0
L8647:
    .ascii    "Typedef name in use #"
    .byte     0
L8646:
    .ascii    "Local decl error #"
    .byte     0
L8645:
    .ascii    "Nested function"
    .byte     0
L8644:
    .ascii    "Var name expected"
    .byte     0
L8643:
    .ascii    "Return value needed"
    .byte     0
L8642:
    .ascii    "Can't return value in void function"
    .byte     0
L8641:
    .ascii    "For decl error"
    .byte     0
L8640:
    .ascii    "Not allowed in for stmt"
    .byte     0
L8639:
    .ascii    "Var name expected"
    .byte     0
L8637:
    .ascii    "2:Duplicate label"
    .byte     0
L8636:
    .ascii    "continue outside loop"
    .byte     0
L8635:
    .ascii    "break outside loop/sw"
    .byte     0
L8634:
    .ascii    "{...} statement expected"
    .byte     0
L8633:
    .ascii    "Too many blocks"
    .byte     0
L8632:
    .ascii    "Too many block levels"
    .byte     0
L8631:
    .ascii    "Init str too long"
    .byte     0
L8630:
    .ascii    "Array init"
    .byte     0
L8629:
    .ascii    "{} initialiser expected"
    .byte     0
L8628:
    .ascii    "Too many struct elems"
    .byte     0
L8627:
    .ascii    "Too many array elems"
    .byte     0
L8626:
    .ascii    "init/Empty struct"
    .byte     0
L8625:
    .ascii    "init/0-size array"
    .byte     0
L8624:
    .ascii    "readconstint #"
    .byte     0
L8623:
    .ascii    "Negative array dim"
    .byte     0
L8622:
    .ascii    "ZERO LEN ARRAY"
    .byte     0
L8621:
    .ascii    "Can't do VLAs"
    .byte     0
L8620:
    .ascii    "rnt1"
    .byte     0
L8619:
    .ascii    "Can't init extern #"
    .byte     0
L8618:
    .ascii    "Can't init twice #"
    .byte     0
L8617:
    .ascii    "var: name in use #"
    .byte     0
L8616:
    .ascii    "Can't init extern #"
    .byte     0
L8615:
    .ascii    "Can't init twice #"
    .byte     0
L8614:
    .ascii    "var: redefining #"
    .byte     0
L8613:
    .ascii    "var: name in use # #"
    .byte     0
L8612:
    .ascii    "Readterm?"
    .byte     0
L8611:
    .ascii    "RT"
    .byte     0
L8610:
    .ascii    "rt/alignof"
    .byte     0
L8609:
    .ascii    "rt/compound lit"
    .byte     0
L8608:
    .ascii    "rt/&&label"
    .byte     0
L8607:
    .ascii    "char const too long"
    .byte     0
L8606:
    .ascii    "Undefined name "
    .byte     34
    .ascii    "#"
    .byte     34
    .byte     0
L8605:
    .ascii    "shift:Not an int"
    .byte     0
L8604:
    .ascii    "invalid rel operands"
    .byte     0
L8603:
    .ascii    "Comparing distinct pointers/rel"
    .byte     0
L8602:
    .ascii    "invalid == operands"
    .byte     0
L8601:
    .ascii    "U="
    .byte     0
L8600:
    .ascii    "Can't compare pointer to int2"
    .byte     0
L8599:
    .ascii    "Can't compare pointer to int"
    .byte     0
L8598:
    .ascii    "Comparing distinct pointers/eq"
    .byte     0
L8597:
    .ascii    "invalid & operands"
    .byte     0
L8596:
    .ascii    "float&float"
    .byte     0
L8595:
    .ascii    "invalid ^ operands"
    .byte     0
L8594:
    .ascii    "float^float"
    .byte     0
L8593:
    .ascii    "invalid | operands"
    .byte     0
L8592:
    .ascii    "float|float"
    .byte     0
L8591:
    .ascii    "?: incompatible types"
    .byte     0
L8590:
    .ascii    "Modifying constant?"
    .byte     0
L8589:
    .ascii    "Modifying read-only var"
    .byte     0
L8588:
    .ascii    "declspec/float"
    .byte     0
L8587:
    .ascii    "dbl decl?"
    .byte     0
L8586:
    .ascii    "char decl?"
    .byte     0
L8585:
    .ascii    "Implicit decls not allowed: #"
    .byte     0
L8584:
    .ascii    "enum?"
    .byte     0
L8583:
    .ascii    "struct?"
    .byte     0
L8582:
    .ascii    "Dual storage spec"
    .byte     0
L8581:
    .ascii    "declspec/ts #"
    .byte     0
L8580:
    .ascii    "PARSETEST"
    .byte     0
L8579:
    .ascii    "Parsing:"
    .byte     0
L8578:
    .ascii    "Decl error #"
    .byte     0
L8577:
    .ascii    "fn def after comma"
    .byte     0
L8576:
    .ascii    "Var name expected"
    .byte     0
L8575:
    .ascii    "Extra semicolon 2"
    .byte     0
L8564:
    .ascii    "Real too long"
    .byte     0
L8563:
    .ascii    "REGENHST FULL?"
    .byte     0
L8562:
    .ascii    "regenhst dupl?"
    .byte     0
L8561:
    .ascii    "mcc.h"
    .byte     0
L8560:
    .ascii    "TMLM"
    .byte     0
L8559:
    .ascii    "TMH"
    .byte     0
L8558:
    .ascii    "TMM"
    .byte     0
L8557:
    .ascii    "Str expected"
    .byte     0
L8556:
    .ascii    "link"
    .byte     0
L8555:
    .ascii    "header"
    .byte     0
L8554:
    .ascii    "module"
    .byte     0
L8553:
    .ascii    "Only pack(1) or () allowed"
    .byte     0
L8552:
    .ascii    "'(' expected"
    .byte     0
L8551:
    .ascii    "pack"
    .byte     0
L8550:
    .ascii    "2:Too many pasted tokens"
    .byte     0
L8549:
    .ascii    "PDM"
    .byte     0
L8548:
    .ascii    "???"
    .byte     0
L8547:
    .ascii    "(File not available)"
    .byte     0
L8546:
    .ascii    "z2"
    .byte     0
L8545:
    .ascii    "2"
    .byte     0
L8544:
    .ascii    "#:#:#"
    .byte     0
L8543:
    .ascii    "4"
    .byte     0
L8542:
    .ascii    "#-#-#"
    .byte     0
L8541:
    .ascii    "#if:Unexpected eof"
    .byte     0
L8540:
    .ascii    "EOL expected"
    .byte     0
L8539:
    .ascii    "Name expected"
    .byte     0
L8538:
    .ascii    "evalterm?"
    .byte     0
L8537:
    .ascii    ") expected"
    .byte     0
L8536:
    .ascii    "')' expected"
    .byte     0
L8535:
    .ascii    "sizeof2"
    .byte     0
L8534:
    .ascii    "name expected"
    .byte     0
L8533:
    .ascii    "'(' expected"
    .byte     0
L8532:
    .ascii    "')' expected"
    .byte     0
L8531:
    .ascii    "defined?"
    .byte     0
L8530:
    .ascii    "#if:div by zero"
    .byte     0
L8529:
    .ascii    ": expected"
    .byte     0
L8528:
    .ascii    "#if:eol expected"
    .byte     0
L8527:
    .ascii    "Too many pasted tokens"
    .byte     0
L8526:
    .ascii    ".*"
    .byte     0
L8525:
    .ascii    "v"
    .byte     0
L8524:
    .byte     0
L8523:
    .byte     10
    .byte     0
L8522:
    .ascii    "Too many ##"
    .byte     0
L8521:
    .ascii    "## at start"
    .byte     0
L8520:
    .ascii    "# not followed by param"
    .byte     0
L8519:
    .ascii    "# at end"
    .byte     0
L8518:
    .ascii    "Wrong # macro params"
    .byte     0
L8517:
    .ascii    "EOS in macro call"
    .byte     0
L8516:
    .ascii    "rmc: ')' expected"
    .byte     0
L8515:
    .ascii    "rmc: no '('"
    .byte     0
L8514:
    .ascii    ">"
    .byte     0
L8513:
    .ascii    "<"
    .byte     0
L8512:
    .ascii    "macro params?"
    .byte     0
L8511:
    .ascii    "')' expected"
    .byte     0
L8510:
    .ascii    "__VA_ARGS__"
    .byte     0
L8509:
    .ascii    "Dupl macro param"
    .byte     0
L8508:
    .ascii    "define: name expected"
    .byte     0
L8507:
    .ascii    "Local str too long"
    .byte     0
L8506:
    .ascii    "String not terminated"
    .byte     0
L8505:
    .ascii    "NEXTLX.LINENO="
    .byte     0
L8504:
    .ascii    "#define __attribute__(x)"
    .byte     10
    .ascii    "#define _WIN32"
    .byte     10
    .ascii    "#define WIN32"
    .byte     10
    .ascii    "#define __WIN32__"
    .byte     10
    .ascii    "#define __inline"
    .byte     10
    .ascii    "#define __dllimport(x)"
    .byte     10
    .ascii    "//#define __declspec(x)"
    .byte     10
    .ascii    "#define __stdcall"
    .byte     10
    .ascii    "#define CALLBACK $callback"
    .byte     10
    .ascii    "#define __cdecl"
    .byte     10
    .ascii    "#define EXTERN_C extern"
    .byte     10
    .ascii    "#define DECLSPEC_IMPORT"
    .byte     10
    .ascii    "#define __32BIT__"
    .byte     10
    .ascii    "#define register"
    .byte     10
    .ascii    "#define __MCCC__"
    .byte     10
    .byte     10
    .ascii    "//typedef signed char"
    .byte     9
    .byte     9
    .ascii    "i8;"
    .byte     10
    .ascii    "//typedef short"
    .byte     9
    .byte     9
    .byte     9
    .ascii    "i16;"
    .byte     10
    .ascii    "//typedef int"
    .byte     9
    .byte     9
    .byte     9
    .byte     9
    .ascii    "i32;"
    .byte     10
    .ascii    "//typedef long long int"
    .byte     9
    .ascii    "i64;"
    .byte     10
    .ascii    "//typedef unsigned char"
    .byte     9
    .byte     9
    .byte     9
    .ascii    "u8;"
    .byte     10
    .ascii    "//typedef unsigned short"
    .byte     9
    .byte     9
    .byte     9
    .ascii    "u16;"
    .byte     10
    .ascii    "//typedef unsigned int"
    .byte     9
    .byte     9
    .byte     9
    .ascii    "u32;"
    .byte     10
    .ascii    "//typedef unsigned long long int"
    .byte     9
    .ascii    "u64;"
    .byte     10
    .ascii    "//"
    .byte     10
    .ascii    "//typedef unsigned char byte;"
    .byte     10
    .ascii    "//"
    .byte     10
    .ascii    "//typedef float r32;"
    .byte     10
    .ascii    "//typedef double r64;"
    .byte     10
    .byte     10
    .byte     0
L8503:
    .ascii    "mcc.h"
    .byte     0
L8502:
    .ascii    "Too many nested includes"
    .byte     0
L8501:
    .ascii    "Can't find include file"
    .byte     0
L8500:
    .ascii    "Overflow in decimal number"
    .byte     0
L8499:
    .ascii    "18446744073709551615"
    .byte     0
L8498:
    .ascii    "-U?"
    .byte     0
L8497:
    .ascii    "-LL?"
    .byte     0
L8496:
    .ascii    "Overflow in octal number"
    .byte     0
L8495:
    .ascii    "1777777777777777777777"
    .byte     0
L8494:
    .ascii    "-U?"
    .byte     0
L8493:
    .ascii    "-LL?"
    .byte     0
L8492:
    .ascii    "Overflow in binary number"
    .byte     0
L8491:
    .ascii    "Binary fp"
    .byte     0
L8490:
    .ascii    "Binary bad digit"
    .byte     0
L8489:
    .ascii    "Overflow in hex number"
    .byte     0
L8488:
    .ascii    "-U?"
    .byte     0
L8487:
    .ascii    "-LL?"
    .byte     0
L8486:
    .ascii    "block comment eof"
    .byte     0
L8485:
    .ascii    ":##"
    .byte     0
L8484:
    .ascii    ":::"
    .byte     0
L8483:
    .ascii    "#endif missing"
    .byte     0
L8482:
    .ascii    "Directive not implemented"
    .byte     0
L8481:
    .ascii    "DIRECTIVE NOT IMPL:"
    .byte     0
L8480:
    .ascii    "ABORTING"
    .byte     0
L8479:
    .ascii    "#ERROR:"
    .byte     0
L8478:
    .ascii    "#if missing/endif"
    .byte     0
L8477:
    .ascii    "#if missing/elif/else"
    .byte     0
L8476:
    .ascii    "undef: name expected"
    .byte     0
L8475:
    .ascii    "NSOURCEFILES="
    .byte     0
L8474:
    .ascii    "FROM"
    .byte     0
L8473:
    .ascii    "INCLUDE"
    .byte     0
L8472:
    .ascii    "include?"
    .byte     0
L8471:
    .ascii    "include: > expected"
    .byte     0
L8470:
    .ascii    "Bad include file"
    .byte     0
L8469:
    .ascii    "Invalid # directive"
    .byte     0
L8468:
    .ascii    "Duplicate symbol table entry"
    .byte     0
L8467:
    .ascii    "HASHTABLE FULL"
    .byte     0
L8466:
    .ascii    "Digit out of range"
    .byte     0
L8465:
    .ascii    ".*"
    .byte     0
L8464:
    .ascii    "v"
    .byte     0
L8463:
    .ascii    ".*"
    .byte     0
L8462:
    .ascii    "v"
    .byte     0
L8461:
    .ascii    "#"
    .byte     0
L8460:
    .ascii    "'"
    .byte     0
L8459:
    .byte     34
    .byte     0
L8458:
    .ascii    " "
    .byte     0
L8457:
    .ascii    "%-18s"
    .byte     0
L8456:
    .ascii    "Line:"
    .byte     0
L8455:
    .ascii    "in:"
    .byte     0
L8454:
    .byte     10
    .ascii    "Lex error"
    .byte     0
L8453:
    .ascii    "Non-base-10 floats temporarily unavailable"
    .byte     0
L8452:
    .ascii    "p"
    .byte     0
L8451:
    .ascii    "e"
    .byte     0
L8449:
    .ascii    "Real too long"
    .byte     0
L8448:
    .ascii    "ERROR CHAR"
    .byte     0
L8447:
    .ascii    "@ SEEN"
    .byte     0
L8446:
    .ascii    "wb"
    .byte     0
L8445:
    .ascii    "#endif missing"
    .byte     0
L8444:
    .ascii    "mcc.h"
    .byte     0
L8443:
    .ascii    "CC C Compiler 7.x"
    .byte     0
L8442:
    .ascii    "C Subset Compiler for 64-bit Windows"
    .byte     10
    .byte     10
    .ascii    "Normal use:           Compiles prog.c to:"
    .byte     10
    .byte     10
    .ascii    "    cc      prog      prog.exe (default)"
    .byte     10
    .ascii    "    cc -r   prog      in-memory native code then execute"
    .byte     10
    .ascii    "    cc -i   prog      in-memory IL then interpret"
    .byte     10
    .byte     10
    .ascii    "    cc -exe prog      prog.exe"
    .byte     10
    .ascii    "    cc -dll prog      prog.dll"
    .byte     10
    .ascii    "    cc -obj prog      prog.obj"
    .byte     10
    .ascii    "    cc -s   prog      prog.asm (also -a)"
    .byte     10
    .ascii    "    cc -mx  prog      prog.mx"
    .byte     10
    .ascii    "    cc -p   prog      prog.pcl (textual IL)"
    .byte     10
    .ascii    "    cc -e   prog      prog.i   (preprocess only)"
    .byte     10
    .byte     10
    .ascii    "Other options:"
    .byte     10
    .byte     10
    .ascii    "    -incl:path        Add path to search for includes"
    .byte     10
    .ascii    "    -ext              Used std headers external to compiler"
    .byte     10
    .ascii    "    -opt              Optimise native code"
    .byte     10
    .ascii    "    -o:file           Name output file (extension can be added)"
    .byte     10
    .ascii    "    -norip            Don't use RIP address modes"
    .byte     10
    .ascii    "    -himem            Generate PIC code (automatic with -obj/-dll)"
    .byte     10
    .ascii    "    @file             Read files and options from a file"
    .byte     10
    .ascii    "    -c                Same as -obj"
    .byte     10
    .ascii    "    -s                Same as -asm"
    .byte     10
    .ascii    "    -ei               Same as -e, but when result is interpreted"
    .byte     10
    .byte     10
    .ascii    "Notes:"
    .byte     10
    .byte     10
    .ascii    "    * Compiles single module only"
    .byte     10
    .ascii    "    * For -i and -r, options"
    .byte     10
    .ascii    "    * .c extension is optional on input file"
    .byte     10
    .byte     0
L8441:
    .ascii    "Include paths"
    .byte     0
L8440:
    .ascii    "   "
    .byte     0
L8439:
    .ascii    "/"
    .byte     0
L8438:
    .byte     0
L8437:
    .ascii    "Too many include paths"
    .byte     0
L8436:
    .byte     0
L8435:
    .ascii    "-RUNP OUT OF ORDER"
    .byte     0
L8434:
    .ascii    "-help                Show all options"
    .byte     0
L8433:
    .ascii    "    "
    .byte     0
L8432:
    .ascii    "-i prog[.c]          Compile prog.c and interpret"
    .byte     0
L8431:
    .ascii    "    "
    .byte     0
L8430:
    .ascii    "-r prog[.c]          Compile prog.c and run"
    .byte     0
L8429:
    .ascii    "    "
    .byte     0
L8428:
    .ascii    "   prog[.c]          Compile prog.c to prog.exe"
    .byte     0
L8427:
    .ascii    "    "
    .byte     0
L8426:
    .ascii    "Usage:"
    .byte     0
L8425:
    .byte     0
L8424:
    .ascii    "Too many lib files"
    .byte     0
L8423:
    .byte     0
L8422:
    .ascii    "One input file only"
    .byte     0
L8421:
    .ascii    "Unknown option:"
    .byte     0
L8420:
    .ascii    ".c"
    .byte     0
L8419:
    .byte     0
L8418:
    .ascii    "cs.exe"
    .byte     0
L8417:
    .ascii    "Total:"
    .byte     0
L8416:
    .ascii    "-----------------------------"
    .byte     0
L8415:
    .ascii    "EXE:"
    .byte     0
L8414:
    .ascii    "SS:"
    .byte     0
L8413:
    .ascii    "MCL:"
    .byte     0
L8412:
    .ascii    "PCL:"
    .byte     0
L8411:
    .ascii    "Parse:"
    .byte     0
L8410:
    .ascii    "Load:"
    .byte     0
L8409:
    .ascii    "Init:"
    .byte     0
L8408:
    .ascii    "5.1jr"
    .byte     0
L8406:
    .ascii    "5"
    .byte     0
L8405:
    .ascii    "12jl"
    .byte     0
L8404:
    .ascii    "# # ms # %"
    .byte     0
L8403:
    .ascii    "Size:"
    .byte     0
L8402:
    .ascii    ":"
    .byte     0
L8401:
    .ascii    "Sourcefiles:"
    .byte     0
L8400:
    .ascii    "PROC"
    .byte     0
L8399:
    .ascii    "PROC AST"
    .byte     0
L8398:
    .ascii    ": ."
    .byte     0
L8397:
    .ascii    ":"
    .byte     0
L8396:
    .ascii    "0: Internal standard headers (disable with -ext)"
    .byte     0
L8395:
    .ascii    "Include search paths:"
    .byte     0
L8394:
    .ascii    "c:/cx/headers/"
    .byte     0
L8393:
    .byte     0
L8392:
    .ascii    "<line>"
    .byte     0
L8391:
    .ascii    "kernel32"
    .byte     0
L8390:
    .ascii    "user32"
    .byte     0
L8389:
    .ascii    "gdi32"
    .byte     0
L8388:
    .ascii    "msvcrt"
    .byte     0
L8387:
    .ascii    "mcc.log"
    .byte     0
L8386:
    .ascii    "Diagnostic outputs written to"
    .byte     0
L8385:
    .ascii    "mcc.log"
    .byte     0
L8384:
    .byte     92
    .ascii    "m"
    .byte     92
    .ascii    "scripts"
    .byte     92
    .ascii    "med.bat "
    .byte     0
L8383:
    .ascii    "PRESS KEY"
    .byte     0
L8382:
    .ascii    "cc.m"
    .byte     0
L8381:
    .ascii    "STFLAT"
    .byte     0
L8380:
    .ascii    "ST"
    .byte     0
L8379:
    .ascii    "PSYMTAB"
    .byte     0
L8378:
    .ascii    "!PROC PCL"
    .byte     0
L8377:
    .ascii    "PROC ASM"
    .byte     0
L8376:
    .ascii    "w"
    .byte     0
L8375:
    .ascii    "mcc.log"
    .byte     0
L8374:
    .ascii    "Can't load main module: #"
    .byte     0
L8373:
    .ascii    "$prog"
    .byte     0
L8372:
    .ascii    "<sourcefile0>"
    .byte     0
L8371:
    .ascii    "<dummy path>"
    .byte     0
L8370:
    .ascii    "<dummy file>"
    .byte     0
L8369:
    .ascii    "Loading:"
    .byte     0
L8368:
    .ascii    "Done."
    .byte     0
L8367:
    .ascii    "not ready"
    .byte     0
L8366:
    .ascii    "Compiling # to #"
    .byte     0
L8365:
    .ascii    "No Run"
    .byte     0
L8364:
    .byte     0
L8363:
    .ascii    "qword ptr"
    .byte     0
L8362:
    .ascii    "dword ptr"
    .byte     0
L8361:
    .ascii    "word ptr"
    .byte     0
L8360:
    .ascii    "byte ptr"
    .byte     0
L8359:
    .byte     0
L8358:
    .ascii    "%"
    .byte     0
L8357:
    .ascii    "#.$T#"
    .byte     0
L8356:
    .ascii    "T"
    .byte     0
L8355:
    .ascii    "%XMM"
    .byte     0
L8354:
    .ascii    "-"
    .byte     0
L8353:
    .byte     0
L8352:
    .ascii    "Stropnd?"
    .byte     0
L8351:
    .ascii    "L"
    .byte     0
L8350:
    .byte     34
    .byte     0
L8349:
    .ascii    "M"
    .byte     0
L8348:
    .ascii    "20.20"
    .byte     0
L8347:
    .byte     0
L8346:
    .ascii    "+"
    .byte     0
L8345:
    .byte     0
L8344:
    .ascii    "<BAD OPND>"
    .byte     0
L8343:
    .ascii    "BAD OPND"
    .byte     0
L8342:
    .ascii    "]"
    .byte     0
L8341:
    .ascii    " + "
    .byte     0
L8340:
    .ascii    "%rip+"
    .byte     0
L8339:
    .ascii    "*"
    .byte     0
L8338:
    .ascii    " + "
    .byte     0
L8337:
    .byte     0
L8336:
    .ascii    "["
    .byte     0
L8335:
    .ascii    "H"
    .byte     0
L8334:
    .ascii    "0x"
    .byte     0
L8333:
    .ascii    ","
    .byte     0
L8332:
    .ascii    ","
    .byte     9
    .byte     0
L8331:
    .ascii    " "
    .byte     0
L8330:
    .ascii    "  "
    .byte     0
L8329:
    .ascii    " "
    .byte     0
L8328:
    .ascii    ".ascii"
    .byte     0
L8327:
    .ascii    ".quad"
    .byte     0
L8326:
    .ascii    ".long"
    .byte     0
L8325:
    .ascii    ".word"
    .byte     0
L8324:
    .ascii    ".byte"
    .byte     0
L8323:
    .ascii    ".space"
    .byte     0
L8322:
    .ascii    ".align"
    .byte     0
L8321:
    .ascii    "movsxd"
    .byte     0
L8320:
    .ascii    "imul"
    .byte     0
L8319:
    .ascii    "not"
    .byte     0
L8318:
    .ascii    "xor"
    .byte     0
L8317:
    .ascii    "or"
    .byte     0
L8316:
    .ascii    "and"
    .byte     0
L8315:
    .ascii    "cmov"
    .byte     0
L8314:
    .ascii    "set"
    .byte     0
L8313:
    .ascii    "j"
    .byte     0
L8312:
    .ascii    "    .bss"
    .byte     0
L8311:
    .ascii    "    .data"
    .byte     0
L8310:
    .ascii    "    .text"
    .byte     0
L8309:
    .ascii    ", "
    .byte     0
L8308:
    .ascii    "    .set "
    .byte     0
L8307:
    .ascii    "L#:"
    .byte     0
L8306:
    .ascii    ":"
    .byte     0
L8305:
    .byte     10
    .byte     0
L8304:
    .ascii    ":"
    .byte     0
L8303:
    .byte     0
L8302:
    .ascii    "strmcl/lab"
    .byte     0
L8301:
    .ascii    "# End "
    .byte     0
L8300:
    .ascii    "# Proc "
    .byte     0
L8299:
    .byte     10
    .byte     0
L8298:
    .byte     92
    .byte     34
    .byte     34
    .byte     10
    .byte     0
L8297:
    .ascii    "    .ascii "
    .byte     34
    .ascii    " -export:"
    .byte     92
    .byte     34
    .byte     0
L8296:
    .ascii    "    .section .drectve"
    .byte     10
    .byte     0
L8295:
    .byte     10
    .byte     0
L8294:
    .ascii    "    .global "
    .byte     0
L8293:
    .byte     10
    .byte     0
L8292:
    .ascii    "    .intel_syntax prefix"
    .byte     10
    .byte     0
L8291:
    .ascii    "    .code64"
    .byte     10
    .byte     0
L8290:
    .byte     0
L8289:
    .ascii    "delmcl?"
    .byte     0
L8288:
    .ascii    " ncalldepth:"
    .byte     0
L8287:
    .ascii    " noperands:"
    .byte     0
L8286:
    .ascii    ") hwstack:"
    .byte     0
L8285:
    .ascii    "0 "
    .byte     0
L8284:
    .ascii    "1 "
    .byte     0
L8283:
    .ascii    "XWR:("
    .byte     0
L8282:
    .ascii    ") "
    .byte     0
L8281:
    .ascii    "0 "
    .byte     0
L8280:
    .ascii    "1 "
    .byte     0
L8279:
    .ascii    "WR:("
    .byte     0
L8278:
    .ascii    " "
    .byte     0
L8277:
    .ascii    ") "
    .byte     0
L8276:
    .ascii    ", "
    .byte     0
L8275:
    .ascii    ">"
    .byte     0
L8274:
    .ascii    "<"
    .byte     0
L8273:
    .ascii    "@"
    .byte     0
L8272:
    .ascii    ")"
    .byte     0
L8271:
    .ascii    "(=="
    .byte     0
L8270:
    .ascii    "T"
    .byte     0
L8269:
    .ascii    "*"
    .byte     0
L8268:
    .byte     0
L8267:
    .ascii    "W:"
    .byte     0
L8266:
    .ascii    "X:"
    .byte     0
L8265:
    .ascii    "Y:"
    .byte     0
L8264:
    .ascii    "Z:"
    .byte     0
L8263:
    .ascii    "#:("
    .byte     0
L8262:
    .ascii    "========================================#:("
    .byte     0
L8261:
    .byte     0
L8260:
    .ascii    "MSA"
    .byte     0
L8259:
    .byte     0
L8258:
    .ascii    "makeopndind"
    .byte     0
L8257:
    .byte     0
L8256:
    .ascii    "SOR1"
    .byte     0
L8255:
    .byte     0
L8254:
    .ascii    "MOVE TO REG: XREG IN USE"
    .byte     0
L8253:
    .byte     0
L8252:
    .ascii    "No more work xregs"
    .byte     0
L8251:
    .byte     0
L8250:
    .ascii    "No more work regs"
    .byte     0
L8249:
    .byte     0
L8248:
    .ascii    "poppcl/underflow"
    .byte     0
L8247:
    .byte     0
L8246:
    .ascii    "PCL stack overflow"
    .byte     0
L8245:
    .byte     0
L8244:
    .ascii    "PCL stack overflow"
    .byte     0
L8243:
    .ascii    "getopnd"
    .byte     0
L8242:
    .byte     0
L8241:
    .ascii    "Ext nametab overflow"
    .byte     0
L8240:
    .ascii    "$B#"
    .byte     0
L8239:
    .byte     0
L8238:
    .ascii    "Too many block temps"
    .byte     0
L8237:
    .ascii    "FILENAME="
    .byte     0
L8236:
    .ascii    "LINENO="
    .byte     0
L8235:
    .ascii    "AAPOS="
    .byte     0
L8234:
    .ascii    "AASEQ:"
    .byte     0
L8233:
    .ascii    "AX ERROR:"
    .byte     0
L8232:
    .ascii    "MCL Opnd not supported: # (#) [#]"
    .byte     0
L8231:
    .byte     0
L8230:
    .ascii    "2:SIZE=0"
    .byte     0
L8229:
    .byte     0
L8228:
    .ascii    "1:SIZE=0"
    .byte     0
L8227:
    .byte     0
L8226:
    .ascii    "BAD SEG CODE"
    .byte     0
L8225:
    .byte     0
L8224:
    .ascii    "CAN'T DO RODATA SEG"
    .byte     0
L8223:
    .ascii    "MCLREC>64B"
    .byte     0
L8222:
    .ascii    "__getmainargs*"
    .byte     0
L8221:
    .ascii    "$info"
    .byte     0
L8220:
    .ascii    "$env"
    .byte     0
L8219:
    .ascii    "()"
    .byte     0
L8218:
    .ascii    "High block arg not copied in"
    .byte     0
L8217:
    .ascii    "No host fn:"
    .byte     0
L8216:
    .ascii    "gethostfn?"
    .byte     0
L8215:
    .ascii    "msysc.m$power_i64"
    .byte     0
L8214:
    .ascii    "msys.m$power_i64"
    .byte     0
L8213:
    .byte     0
L8212:
    .ascii    "storebf not imm"
    .byte     0
L8211:
    .byte     0
L8210:
    .ascii    "Storebit: both vars"
    .byte     0
L8209:
    .byte     0
L8208:
    .ascii    "STOREBIT/VAR"
    .byte     0
L8207:
    .byte     0
L8206:
    .ascii    "LOADBF_VAR"
    .byte     0
L8205:
    .ascii    "mask63/offset64"
    .byte     0
L8204:
    .ascii    "labzero"
    .byte     0
L8203:
    .ascii    "labneg64"
    .byte     0
L8202:
    .ascii    "labneg32"
    .byte     0
L8201:
    .ascii    "lababs64"
    .byte     0
L8200:
    .ascii    "lababs32"
    .byte     0
L8198:
    .ascii    "Real32 Table"
    .byte     0
L8196:
    .ascii    "Real Table"
    .byte     0
L8195:
    .ascii    "String Table"
    .byte     0
L8194:
    .ascii    "ENDDATA"
    .byte     0
L8193:
    .byte     0
L8192:
    .ascii    "div/u8"
    .byte     0
L8191:
    .byte     0
L8190:
    .ascii    "Divide by zero"
    .byte     0
L8189:
    .ascii    "---------------"
    .byte     0
L8188:
    .ascii    "?]]"
    .byte     0
L8187:
    .byte     0
L8186:
    .ascii    "Threaded proc has temps"
    .byte     0
L8185:
    .byte     0
L8184:
    .ascii    "Threaded proc has locals/params"
    .byte     0
L8183:
    .byte     0
L8182:
    .ascii    "@PARAM"
    .byte     0
L8181:
    .ascii    "$1x"
    .byte     0
L8179:
    .byte     0
L8178:
    .ascii    "SUBTOREF/EXTRA"
    .byte     0
L8177:
    .ascii    "pow*"
    .byte     0
L8176:
    .byte     0
L8175:
    .ascii    "setcc/block"
    .byte     0
L8174:
    .ascii    "fmod*"
    .byte     0
L8173:
    .ascii    "atan2*"
    .byte     0
L8172:
    .ascii    "ceil*"
    .byte     0
L8171:
    .ascii    "floor*"
    .byte     0
L8170:
    .ascii    "round*"
    .byte     0
L8169:
    .ascii    "exp*"
    .byte     0
L8168:
    .ascii    "log10*"
    .byte     0
L8167:
    .ascii    "log*"
    .byte     0
L8166:
    .ascii    "atan*"
    .byte     0
L8165:
    .ascii    "acos*"
    .byte     0
L8164:
    .ascii    "asin*"
    .byte     0
L8163:
    .ascii    "tan*"
    .byte     0
L8162:
    .ascii    "cos*"
    .byte     0
L8161:
    .ascii    "sin*"
    .byte     0
L8160:
    .byte     0
L8159:
    .ascii    "No Assem handler"
    .byte     0
L8158:
    .byte     0
L8157:
    .ascii    "SUB/REF NOT POWER OF xx"
    .byte     0
L8156:
    .byte     0
L8155:
    .ascii    "float/short"
    .byte     0
L8154:
    .byte     0
L8153:
    .ascii    "multo/byte"
    .byte     0
L8152:
    .ascii    ":"
    .byte     0
L8151:
    .byte     0
L8150:
    .ascii    "swap/block"
    .byte     0
L8149:
    .byte     0
L8148:
    .ascii    "SUBREF/EXTRA"
    .byte     0
L8147:
    .ascii    "EXTRA="
    .byte     0
L8146:
    .byte     0
L8145:
    .ascii    "Storem not 16"
    .byte     0
L8144:
    .ascii    "exit*"
    .byte     0
L8143:
    .byte     0
L8142:
    .ascii    "Too many nested calls"
    .byte     0
L8141:
    .ascii    "---"
    .byte     0
L8140:
    .byte     0
L8139:
    .ascii    "JUMPCC/BLOCK"
    .byte     0
L8138:
    .byte     0
L8137:
    .ascii    "DATA/not 1248"
    .byte     0
L8136:
    .ascii    "STRPMODE(P.MODE)="
    .byte     0
L8135:
    .ascii    "P.SIZE="
    .byte     0
L8134:
    .ascii    "db/dq optype? #"
    .byte     0
L8133:
    .ascii    "PCL STACK NOT EMPTY"
    .byte     0
L8132:
    .ascii    "?>>"
    .byte     0
L8131:
    .ascii    "Unimpl: # (#)"
    .byte     0
L8130:
    .ascii    "                       "
    .byte     0
L8129:
    .ascii    "Invalid handler name:"
    .byte     0
L8128:
    .ascii    "px_"
    .byte     0
L8127:
    .ascii    "dummy diags"
    .byte     0
L8126:
    .ascii    "z2h"
    .byte     0
L8124:
    .ascii    "MCL Error: # (#) on Line: # in #, PCL:#"
    .byte     0
L8123:
    .ascii    "Proc:"
    .byte     0
L8122:
    .ascii    "?"
    .byte     0
L8121:
    .ascii    "FILENAME="
    .byte     0
L8120:
    .ascii    "LINENO="
    .byte     0
L8119:
    .ascii    "No proc"
    .byte     0
L8118:
    .ascii    "Dupl proc:"
    .byte     0
L8117:
    .ascii    "Nested proc"
    .byte     0
L8116:
    .byte     0
L8115:
    .ascii    "Too many libs"
    .byte     0
L8114:
    .ascii    "w"
    .byte     0
L8113:
    .ascii    "$error.tmp"
    .byte     0
L8112:
    .ascii    "."
    .byte     0
L8111:
    .ascii    "*"
    .byte     0
L8110:
    .ascii    "`"
    .byte     0
L8109:
    .ascii    "PCL Error:"
    .byte     0
L8108:
    .ascii    ":"
    .byte     0
L8107:
    .ascii    "PCL error:"
    .byte     0
L8106:
    .ascii    "---"
    .byte     0
L8105:
    .ascii    "mem:"
    .byte     0
L8104:
    .byte     0
L8103:
    .ascii    "dummy"
    .byte     0
L8102:
    .ascii    "w"
    .byte     0
L8101:
    .ascii    "Writing"
    .byte     0
L8100:
    .ascii    "w"
    .byte     0
L8099:
    .byte     0
L8098:
    .ascii    "Writing PST"
    .byte     0
L8097:
    .byte     0
L8096:
    .ascii    "Writing PCL"
    .byte     0
L8095:
    .ascii    "PCL start?"
    .byte     0
L8094:
    .ascii    "C:"
    .byte     92
    .ascii    "m"
    .byte     92
    .byte     34
L8093:
    .ascii    "?"
    .byte     0
L8092:
    .ascii    "wb"
    .byte     0
L8091:
    .ascii    "con"
    .byte     0
L8090:
    .ascii    "rb"
    .byte     0
L8089:
    .ascii    "con"
    .byte     0
L8088:
    .ascii    "NOOS"
    .byte     0
L8084:
    .ascii    "@file item too long"
    .byte     0
L8083:
    .ascii    "Unexpected EOF in @file"
    .byte     0
L8082:
    .ascii    "mcx"
    .byte     0
L8081:
    .ascii    "dll"
    .byte     0
L8080:
    .ascii    "Can't open"
    .byte     0
L8079:
    .byte     10
    .byte     0
L8078:
    .ascii    " "
    .byte     0
L8077:
    .byte     0
L8076:
    .ascii    "."
    .byte     0
L8075:
    .byte     0
L8074:
    .ascii    "."
    .byte     0
L8073:
    .ascii    "line too long"
    .byte     0
L8072:
    .ascii    "rb"
    .byte     0
L8071:
    .ascii    "wb"
    .byte     0
L8070:
    .ascii    "rb"
    .byte     0
L8069:
    .ascii    "ABORTING: Press key..."
    .byte     0
L8068:
    .ascii    "Realloc mem failure"
    .byte     0
L8067:
    .ascii    "Alloc mem failure"
    .byte     0
L8066:
    .ascii    "Can't alloc pc heap"
    .byte     0
L8065:
    .ascii    "pcm_alloc failure"
    .byte     0
L8064:
    .ascii    "%.*s"
    .byte     0
L8063:
    .ascii    "MCL-UNIMPL: %s"
    .byte     10
    .byte     0
L8061:
    .ascii    "%lf%n"
    .byte     0
L8059:
    .ascii    "READ CMDLINE"
    .byte     0
L8057:
    .ascii    "<mindint>"
    .byte     0
L8056:
    .ascii    "1000000000000000000000000000000000000000000000000000000000000000"
    .byte     0
L8055:
    .ascii    "8000000000000000"
    .byte     0
L8054:
    .ascii    "9223372036854775808"
    .byte     0
L8053:
    .ascii    "|"
    .byte     0
L8052:
    .ascii    "%.*s"
    .byte     0
L8051:
    .ascii    " "
    .byte     0
L8050:
    .byte     10
    .byte     0
L8049:
    .ascii    "PRTSL"
    .byte     0
L8048:
    .ascii    "<null>"
    .byte     0
L8047:
    .ascii    "%f"
    .byte     0
L8046:
    .ascii    "%llu"
    .byte     0
L8045:
    .ascii    "False"
    .byte     0
L8044:
    .ascii    "True"
    .byte     0
L8043:
    .ascii    "z8H"
    .byte     0
L8042:
    .ascii    "Too many io levels"
    .byte     10
    .byte     0
L8041:
    .ascii    "Too many params"
    .byte     10
    .byte     0
L8040:
    .ascii    "stderr"
    .byte     0
L8039:
    .ascii    "stdout"
    .byte     0
L8038:
    .ascii    "stdin"
    .byte     0
L8037:
    .ascii    "Dec"
    .byte     0
L8036:
    .ascii    "Nov"
    .byte     0
L8035:
    .ascii    "Oct"
    .byte     0
L8034:
    .ascii    "Sep"
    .byte     0
L8033:
    .ascii    "Aug"
    .byte     0
L8032:
    .ascii    "Jul"
    .byte     0
L8031:
    .ascii    "Jun"
    .byte     0
L8030:
    .ascii    "May"
    .byte     0
L8029:
    .ascii    "Apr"
    .byte     0
L8028:
    .ascii    "Mar"
    .byte     0
L8027:
    .ascii    "Feb"
    .byte     0
L8026:
    .ascii    "Jan"
    .byte     0
L8025:
    .ascii    "bool_c"
    .byte     0
L8024:
    .ascii    "truncate_c"
    .byte     0
L8023:
    .ascii    "narrow_c"
    .byte     0
L8022:
    .ascii    "fnarrow_c"
    .byte     0
L8021:
    .ascii    "fwiden_c"
    .byte     0
L8020:
    .ascii    "ufix_c"
    .byte     0
L8019:
    .ascii    "sfix_c"
    .byte     0
L8018:
    .ascii    "ufloat_c"
    .byte     0
L8017:
    .ascii    "sfloat_c"
    .byte     0
L8016:
    .ascii    "uwiden_c"
    .byte     0
L8015:
    .ascii    "swiden_c"
    .byte     0
L8014:
    .ascii    "hard_c"
    .byte     0
L8013:
    .ascii    "soft_c"
    .byte     0
L8012:
    .ascii    "no_conv"
    .byte     0
L8011:
    .ascii    "$$dummy"
    .byte     0
L8010:
    .ascii    "$longjmp"
    .byte     0
L8009:
    .ascii    "$setjmp"
    .byte     0
L8008:
    .ascii    "_Alignof"
    .byte     0
L8007:
    .ascii    "_Generic"
    .byte     0
L8006:
    .ascii    "defined"
    .byte     0
L8005:
    .ascii    "lengthof"
    .byte     0
L8004:
    .ascii    "sizeof"
    .byte     0
L8003:
    .ascii    "__declspec"
    .byte     0
L8002:
    .ascii    "__FUNCTION__"
    .byte     0
L8001:
    .ascii    "__func__"
    .byte     0
L8000:
    .ascii    "__MCCI__"
    .byte     0
L7999:
    .ascii    "__MCC__"
    .byte     0
L7998:
    .ascii    "__TIME__"
    .byte     0
L7997:
    .ascii    "__LINE__"
    .byte     0
L7996:
    .ascii    "__FILE__"
    .byte     0
L7995:
    .ascii    "__DATE__"
    .byte     0
L7994:
    .ascii    "_Bool"
    .byte     0
L7993:
    .ascii    "unsigned"
    .byte     0
L7992:
    .ascii    "signed"
    .byte     0
L7991:
    .ascii    "double"
    .byte     0
L7990:
    .ascii    "float"
    .byte     0
L7989:
    .ascii    "int"
    .byte     0
L7988:
    .ascii    "long"
    .byte     0
L7987:
    .ascii    "short"
    .byte     0
L7986:
    .ascii    "char"
    .byte     0
L7985:
    .ascii    "void"
    .byte     0
L7984:
    .ascii    "enum"
    .byte     0
L7983:
    .ascii    "_Alignas"
    .byte     0
L7982:
    .ascii    "_Noreturn"
    .byte     0
L7981:
    .ascii    "inline"
    .byte     0
L7980:
    .ascii    "_Atomic"
    .byte     0
L7979:
    .ascii    "restrict"
    .byte     0
L7978:
    .ascii    "volatile"
    .byte     0
L7977:
    .ascii    "const"
    .byte     0
L7976:
    .ascii    "typedef"
    .byte     0
L7975:
    .ascii    "extern"
    .byte     0
L7974:
    .ascii    "static"
    .byte     0
L7973:
    .ascii    "register"
    .byte     0
L7972:
    .ascii    "auto"
    .byte     0
L7971:
    .ascii    "line"
    .byte     0
L7970:
    .ascii    "pragma"
    .byte     0
L7969:
    .ascii    "error"
    .byte     0
L7968:
    .ascii    "undef"
    .byte     0
L7967:
    .ascii    "endif"
    .byte     0
L7966:
    .ascii    "ifndef"
    .byte     0
L7965:
    .ascii    "ifdef"
    .byte     0
L7964:
    .ascii    "elif"
    .byte     0
L7963:
    .ascii    "define"
    .byte     0
L7962:
    .ascii    "include"
    .byte     0
L7961:
    .ascii    "union"
    .byte     0
L7960:
    .ascii    "struct"
    .byte     0
L7959:
    .ascii    "switch"
    .byte     0
L7958:
    .ascii    "goto"
    .byte     0
L7957:
    .ascii    "continue"
    .byte     0
L7956:
    .ascii    "break"
    .byte     0
L7955:
    .ascii    "return"
    .byte     0
L7954:
    .ascii    "while"
    .byte     0
L7953:
    .ascii    "do"
    .byte     0
L7952:
    .ascii    "for"
    .byte     0
L7951:
    .ascii    "default"
    .byte     0
L7950:
    .ascii    "case"
    .byte     0
L7949:
    .ascii    "else"
    .byte     0
L7948:
    .ascii    "if"
    .byte     0
L7947:
    .ascii    "labelid"
    .byte     0
L7946:
    .ascii    "structtagid"
    .byte     0
L7945:
    .ascii    "enumtagid"
    .byte     0
L7944:
    .ascii    "enumid"
    .byte     0
L7943:
    .ascii    "fieldid"
    .byte     0
L7942:
    .ascii    "paramid"
    .byte     0
L7941:
    .ascii    "frameid"
    .byte     0
L7940:
    .ascii    "staticid"
    .byte     0
L7939:
    .ascii    "procid"
    .byte     0
L7938:
    .ascii    "typeid"
    .byte     0
L7937:
    .ascii    "extmoduleid"
    .byte     0
L7936:
    .ascii    "moduleid"
    .byte     0
L7935:
    .ascii    "programid"
    .byte     0
L7934:
    .ascii    "macroid"
    .byte     0
L7933:
    .ascii    "nullid"
    .byte     0
L7932:
    .ascii    "ns_fields"
    .byte     0
L7931:
    .ascii    "ns_labels"
    .byte     0
L7930:
    .ascii    "ns_tags"
    .byte     0
L7929:
    .ascii    "ns_general"
    .byte     0
L7928:
    .ascii    "ns_none"
    .byte     0
L7927:
    .ascii    "pragmadir"
    .byte     0
L7926:
    .ascii    "linedir"
    .byte     0
L7925:
    .ascii    "blankdir"
    .byte     0
L7924:
    .ascii    "messagedir"
    .byte     0
L7923:
    .ascii    "errordir"
    .byte     0
L7922:
    .ascii    "undefdir"
    .byte     0
L7921:
    .ascii    "ifndefdir"
    .byte     0
L7920:
    .ascii    "ifdefdir"
    .byte     0
L7919:
    .ascii    "includedir"
    .byte     0
L7918:
    .ascii    "endifdir"
    .byte     0
L7917:
    .ascii    "elsedir"
    .byte     0
L7916:
    .ascii    "elifdir"
    .byte     0
L7915:
    .ascii    "ifdir"
    .byte     0
L7914:
    .ascii    "emitdir"
    .byte     0
L7913:
    .ascii    "definedir"
    .byte     0
L7912:
    .byte     0
L7911:
    .ascii    "k"
    .byte     0
L7910:
    .byte     0
L7909:
    .ascii    "w"
    .byte     0
L7908:
    .ascii    "s"
    .byte     0
L7907:
    .ascii    "n"
    .byte     0
L7906:
    .byte     0
L7905:
    .ascii    ">>="
    .byte     0
L7904:
    .ascii    "<<="
    .byte     0
L7903:
    .ascii    "^="
    .byte     0
L7902:
    .ascii    "&="
    .byte     0
L7901:
    .ascii    "|="
    .byte     0
L7900:
    .ascii    "%="
    .byte     0
L7899:
    .ascii    "/="
    .byte     0
L7898:
    .ascii    "*="
    .byte     0
L7897:
    .ascii    "-="
    .byte     0
L7896:
    .ascii    "+="
    .byte     0
L7895:
    .ascii    ">"
    .byte     0
L7894:
    .ascii    ">="
    .byte     0
L7893:
    .ascii    "<="
    .byte     0
L7892:
    .ascii    "<"
    .byte     0
L7891:
    .ascii    "!="
    .byte     0
L7890:
    .ascii    "=="
    .byte     0
L7889:
    .ascii    "abs"
    .byte     0
L7888:
    .ascii    "--"
    .byte     0
L7887:
    .ascii    "++"
    .byte     0
L7886:
    .ascii    "!"
    .byte     0
L7885:
    .ascii    "~"
    .byte     0
L7884:
    .ascii    ">>"
    .byte     0
L7883:
    .ascii    "<<"
    .byte     0
L7882:
    .ascii    "&&"
    .byte     0
L7881:
    .ascii    "||"
    .byte     0
L7880:
    .ascii    "^"
    .byte     0
L7879:
    .ascii    "&"
    .byte     0
L7878:
    .ascii    "|"
    .byte     0
L7877:
    .ascii    "%"
    .byte     0
L7876:
    .ascii    "/"
    .byte     0
L7875:
    .ascii    "*"
    .byte     0
L7874:
    .ascii    "-"
    .byte     0
L7873:
    .ascii    "+"
    .byte     0
L7872:
    .byte     92
    .byte     0
L7871:
    .ascii    "..."
    .byte     0
L7870:
    .ascii    "~"
    .byte     0
L7869:
    .ascii    "?"
    .byte     0
L7868:
    .ascii    "}"
    .byte     0
L7867:
    .ascii    "{"
    .byte     0
L7866:
    .ascii    "]"
    .byte     0
L7865:
    .ascii    "["
    .byte     0
L7864:
    .ascii    ")"
    .byte     0
L7863:
    .ascii    "("
    .byte     0
L7862:
    .ascii    ":="
    .byte     0
L7861:
    .ascii    "="
    .byte     0
L7860:
    .ascii    ":"
    .byte     0
L7859:
    .ascii    ";"
    .byte     0
L7858:
    .ascii    ","
    .byte     0
L7857:
    .ascii    "##"
    .byte     0
L7856:
    .ascii    "#"
    .byte     0
L7855:
    .ascii    "->"
    .byte     0
L7854:
    .ascii    "."
    .byte     0
L7853:
    .byte     0
L7852:
    .ascii    "kdummysym"
    .byte     0
L7851:
    .ascii    "ksetjmpsym"
    .byte     0
L7850:
    .ascii    "kalignofsym"
    .byte     0
L7849:
    .ascii    "kgenericsym"
    .byte     0
L7848:
    .ascii    "kdefinedsym"
    .byte     0
L7847:
    .ascii    "ksizeofsym"
    .byte     0
L7846:
    .ascii    "kenumsym"
    .byte     0
L7845:
    .ascii    "kalignassym"
    .byte     0
L7844:
    .ascii    "kfnspecsym"
    .byte     0
L7843:
    .ascii    "kstdtypesym"
    .byte     0
L7842:
    .ascii    "ktypequalsym"
    .byte     0
L7841:
    .ascii    "klinkagesym"
    .byte     0
L7840:
    .ascii    "kunionsym"
    .byte     0
L7839:
    .ascii    "kstructsym"
    .byte     0
L7838:
    .ascii    "kswitchsym"
    .byte     0
L7837:
    .ascii    "kgotosym"
    .byte     0
L7836:
    .ascii    "kcontinuesym"
    .byte     0
L7835:
    .ascii    "kbreaksym"
    .byte     0
L7834:
    .ascii    "kreturnsym"
    .byte     0
L7833:
    .ascii    "kdosym"
    .byte     0
L7832:
    .ascii    "kwhilesym"
    .byte     0
L7831:
    .ascii    "kforsym"
    .byte     0
L7830:
    .ascii    "kdefaultsym"
    .byte     0
L7829:
    .ascii    "kcasesym"
    .byte     0
L7828:
    .ascii    "kelsesym"
    .byte     0
L7827:
    .ascii    "kifsym"
    .byte     0
L7826:
    .ascii    "ktypespecsym"
    .byte     0
L7825:
    .ascii    "kdeclspecsym"
    .byte     0
L7824:
    .ascii    "predefmacrosym"
    .byte     0
L7823:
    .ascii    "ksourcedirsym"
    .byte     0
L7822:
    .ascii    "namesym"
    .byte     0
L7821:
    .ascii    "placeholdersym"
    .byte     0
L7820:
    .ascii    "whitespacesym"
    .byte     0
L7819:
    .ascii    "wstringconstsym"
    .byte     0
L7818:
    .ascii    "stringconstsym"
    .byte     0
L7817:
    .ascii    "wcharconstsym"
    .byte     0
L7816:
    .ascii    "charconstsym"
    .byte     0
L7815:
    .ascii    "realconstsym"
    .byte     0
L7814:
    .ascii    "intconstsym"
    .byte     0
L7813:
    .ascii    "rawnumbersym"
    .byte     0
L7812:
    .ascii    "eofsym"
    .byte     0
L7811:
    .ascii    "eolsym"
    .byte     0
L7810:
    .ascii    "shrtosym"
    .byte     0
L7809:
    .ascii    "shltosym"
    .byte     0
L7808:
    .ascii    "ixortosym"
    .byte     0
L7807:
    .ascii    "iandtosym"
    .byte     0
L7806:
    .ascii    "iortosym"
    .byte     0
L7805:
    .ascii    "remtosym"
    .byte     0
L7804:
    .ascii    "divtosym"
    .byte     0
L7803:
    .ascii    "multosym"
    .byte     0
L7802:
    .ascii    "subtosym"
    .byte     0
L7801:
    .ascii    "addtosym"
    .byte     0
L7800:
    .ascii    "gtsym"
    .byte     0
L7799:
    .ascii    "gesym"
    .byte     0
L7798:
    .ascii    "lesym"
    .byte     0
L7797:
    .ascii    "ltsym"
    .byte     0
L7796:
    .ascii    "nesym"
    .byte     0
L7795:
    .ascii    "eqsym"
    .byte     0
L7794:
    .ascii    "abssym"
    .byte     0
L7793:
    .ascii    "decrsym"
    .byte     0
L7792:
    .ascii    "incrsym"
    .byte     0
L7791:
    .ascii    "notlsym"
    .byte     0
L7790:
    .ascii    "inotsym"
    .byte     0
L7789:
    .ascii    "shrsym"
    .byte     0
L7788:
    .ascii    "shlsym"
    .byte     0
L7787:
    .ascii    "andlsym"
    .byte     0
L7786:
    .ascii    "orlsym"
    .byte     0
L7785:
    .ascii    "ixorsym"
    .byte     0
L7784:
    .ascii    "iandsym"
    .byte     0
L7783:
    .ascii    "iorsym"
    .byte     0
L7782:
    .ascii    "remsym"
    .byte     0
L7781:
    .ascii    "divsym"
    .byte     0
L7780:
    .ascii    "mulsym"
    .byte     0
L7779:
    .ascii    "subsym"
    .byte     0
L7778:
    .ascii    "addsym"
    .byte     0
L7777:
    .ascii    "backslashsym"
    .byte     0
L7776:
    .ascii    "ellipsissym"
    .byte     0
L7775:
    .ascii    "curlsym"
    .byte     0
L7774:
    .ascii    "questionsym"
    .byte     0
L7773:
    .ascii    "rcurlysym"
    .byte     0
L7772:
    .ascii    "lcurlysym"
    .byte     0
L7771:
    .ascii    "rsqsym"
    .byte     0
L7770:
    .ascii    "lsqsym"
    .byte     0
L7769:
    .ascii    "rbracksym"
    .byte     0
L7768:
    .ascii    "lbracksym"
    .byte     0
L7767:
    .ascii    "assignsym2"
    .byte     0
L7766:
    .ascii    "assignsym"
    .byte     0
L7765:
    .ascii    "colonsym"
    .byte     0
L7764:
    .ascii    "semisym"
    .byte     0
L7763:
    .ascii    "commasym"
    .byte     0
L7762:
    .ascii    "hashhashsym"
    .byte     0
L7761:
    .ascii    "lithashsym"
    .byte     0
L7760:
    .ascii    "hashsym"
    .byte     0
L7759:
    .ascii    "lexhashsym"
    .byte     0
L7758:
    .ascii    "idotsym"
    .byte     0
L7757:
    .ascii    "dotsym"
    .byte     0
L7756:
    .ascii    "errorsym"
    .byte     0
L7755:
    .ascii    "jdummy"
    .byte     0
L7754:
    .ascii    "longjmp"
    .byte     0
L7753:
    .ascii    "setjmp"
    .byte     0
L7752:
    .ascii    "-- postdecr"
    .byte     0
L7751:
    .ascii    "++ postincr"
    .byte     0
L7750:
    .ascii    "-- preincr"
    .byte     0
L7749:
    .ascii    "++ preincr"
    .byte     0
L7748:
    .ascii    ">>="
    .byte     0
L7747:
    .ascii    "<<="
    .byte     0
L7746:
    .ascii    "^="
    .byte     0
L7745:
    .ascii    "|="
    .byte     0
L7744:
    .ascii    "&="
    .byte     0
L7743:
    .ascii    "%="
    .byte     0
L7742:
    .ascii    "/="
    .byte     0
L7741:
    .ascii    "*="
    .byte     0
L7740:
    .ascii    "-="
    .byte     0
L7739:
    .ascii    "+="
    .byte     0
L7738:
    .ascii    "~ inot"
    .byte     0
L7737:
    .ascii    "abs"
    .byte     0
L7736:
    .ascii    "- neg"
    .byte     0
L7735:
    .ascii    "jscale"
    .byte     0
L7734:
    .ascii    "jconvert"
    .byte     0
L7733:
    .ascii    "addrof &"
    .byte     0
L7732:
    .ascii    "subptr"
    .byte     0
L7731:
    .ascii    "addptr"
    .byte     0
L7730:
    .ascii    "ptr"
    .byte     0
L7729:
    .ascii    "jindex"
    .byte     0
L7728:
    .ascii    "jidot"
    .byte     0
L7727:
    .ascii    "jdot"
    .byte     0
L7726:
    .ascii    ">>"
    .byte     0
L7725:
    .ascii    "<<"
    .byte     0
L7724:
    .ascii    "^ ixor"
    .byte     0
L7723:
    .ascii    "| ior"
    .byte     0
L7722:
    .ascii    "& iand"
    .byte     0
L7721:
    .ascii    "% mod"
    .byte     0
L7720:
    .ascii    "/ div"
    .byte     0
L7719:
    .ascii    "* mul"
    .byte     0
L7718:
    .ascii    "- sub"
    .byte     0
L7717:
    .ascii    "+ add"
    .byte     0
L7716:
    .ascii    ">="
    .byte     0
L7715:
    .ascii    ">"
    .byte     0
L7714:
    .ascii    "<="
    .byte     0
L7713:
    .ascii    "<"
    .byte     0
L7712:
    .ascii    "!="
    .byte     0
L7711:
    .ascii    "=="
    .byte     0
L7710:
    .ascii    "&&"
    .byte     0
L7709:
    .ascii    "jifx"
    .byte     0
L7708:
    .ascii    "jcallfn"
    .byte     0
L7707:
    .ascii    "jexprlist"
    .byte     0
L7706:
    .ascii    "jmakelist"
    .byte     0
L7705:
    .ascii    "jistruel"
    .byte     0
L7704:
    .ascii    "! notl"
    .byte     0
L7703:
    .ascii    "|| orl"
    .byte     0
L7702:
    .ascii    "&& andl"
    .byte     0
L7701:
    .ascii    "jbreaksw"
    .byte     0
L7700:
    .ascii    "jswitch"
    .byte     0
L7699:
    .ascii    "jcontinue"
    .byte     0
L7698:
    .ascii    "jbreak"
    .byte     0
L7697:
    .ascii    "jdefaultstmt"
    .byte     0
L7696:
    .ascii    "jcasestmt"
    .byte     0
L7695:
    .ascii    "jlabelstmt"
    .byte     0
L7694:
    .ascii    "jgoto"
    .byte     0
L7693:
    .ascii    "jdowhile"
    .byte     0
L7692:
    .ascii    "jwhile"
    .byte     0
L7691:
    .ascii    "jfor"
    .byte     0
L7690:
    .ascii    "jif"
    .byte     0
L7689:
    .ascii    "jassign"
    .byte     0
L7688:
    .ascii    "jreturnx"
    .byte     0
L7687:
    .ascii    "jreturn"
    .byte     0
L7686:
    .ascii    "jdecl"
    .byte     0
L7685:
    .ascii    "jtempdecl"
    .byte     0
L7684:
    .ascii    "jblock"
    .byte     0
L7683:
    .ascii    "jfuncname"
    .byte     0
L7682:
    .ascii    "jwidenmem"
    .byte     0
L7681:
    .ascii    "jname"
    .byte     0
L7680:
    .ascii    "jnull"
    .byte     0
L7679:
    .ascii    "jconst"
    .byte     0
L7678:
    .ascii    "jnone"
    .byte     0
L7677:
    .ascii    "callback_fnspec"
    .byte     0
L7676:
    .ascii    "noreturn_fnspec"
    .byte     0
L7675:
    .ascii    "inline_fnspec"
    .byte     0
L7674:
    .ascii    "atomic_qual"
    .byte     0
L7673:
    .ascii    "restrict_qual"
    .byte     0
L7672:
    .ascii    "volatile_qual"
    .byte     0
L7671:
    .ascii    "const_qual"
    .byte     0
L7670:
    .ascii    "typedef_ss"
    .byte     0
L7669:
    .ascii    "extern_ss"
    .byte     0
L7668:
    .ascii    "register_ss"
    .byte     0
L7667:
    .ascii    "auto_ss"
    .byte     0
L7666:
    .ascii    "static_ss"
    .byte     0
L7665:
    .ascii    "none_ss"
    .byte     0
L7664:
    .ascii    "dummy_cc"
    .byte     0
L7663:
    .ascii    "callback_cc"
    .byte     0
L7662:
    .ascii    "stdcall_cc"
    .byte     0
L7661:
    .ascii    "clang_cc"
    .byte     0
L7660:
    .ascii    "own_cc"
    .byte     0
L7659:
    .ascii    "open_cc"
    .byte     0
L7658:
    .ascii    "Exp"
    .byte     0
L7657:
    .ascii    "Imp"
    .byte     0
L7656:
    .ascii    "Loc"
    .byte     0
L7655:
    .ascii    "Fn"
    .byte     0
L7654:
    .ascii    "-"
    .byte     0
L7653:
    .ascii    "pm_variadic"
    .byte     0
L7652:
    .ascii    "pm_empty"
    .byte     0
L7651:
    .ascii    "pm_notset"
    .byte     0
L7650:
    .ascii    "pm_normal"
    .byte     0
L7649:
    .ascii    "ts_atomic"
    .byte     0
L7648:
    .ascii    "ts_enum"
    .byte     0
L7647:
    .ascii    "ts_union"
    .byte     0
L7646:
    .ascii    "ts_struct"
    .byte     0
L7645:
    .ascii    "ts_user"
    .byte     0
L7644:
    .ascii    "ts_bool"
    .byte     0
L7643:
    .ascii    "ts_unsigned"
    .byte     0
L7642:
    .ascii    "ts_signed"
    .byte     0
L7641:
    .ascii    "ts_double"
    .byte     0
L7640:
    .ascii    "ts_float"
    .byte     0
L7639:
    .ascii    "ts_int"
    .byte     0
L7638:
    .ascii    "ts_long"
    .byte     0
L7637:
    .ascii    "ts_short"
    .byte     0
L7636:
    .ascii    "ts_char"
    .byte     0
L7635:
    .ascii    "ts_void"
    .byte     0
L7634:
    .ascii    "blockcat"
    .byte     0
L7633:
    .ascii    "shortcat"
    .byte     0
L7632:
    .ascii    "realcat"
    .byte     0
L7631:
    .ascii    "intcat"
    .byte     0
L7630:
    .ascii    "voidcat"
    .byte     0
L7629:
    .ascii    "tlast"
    .byte     0
L7628:
    .ascii    "notset"
    .byte     0
L7627:
    .ascii    "union"
    .byte     0
L7626:
    .ascii    "struct"
    .byte     0
L7625:
    .ascii    "array"
    .byte     0
L7624:
    .ascii    "block"
    .byte     0
L7623:
    .ascii    "label"
    .byte     0
L7622:
    .ascii    "proc"
    .byte     0
L7621:
    .ascii    "ref"
    .byte     0
L7620:
    .ascii    "enum"
    .byte     0
L7619:
    .ascii    "r64"
    .byte     0
L7618:
    .ascii    "r32"
    .byte     0
L7617:
    .ascii    "u64"
    .byte     0
L7616:
    .ascii    "u32"
    .byte     0
L7615:
    .ascii    "u16"
    .byte     0
L7614:
    .ascii    "u8"
    .byte     0
L7613:
    .ascii    "bool"
    .byte     0
L7612:
    .ascii    "i64"
    .byte     0
L7611:
    .ascii    "i32"
    .byte     0
L7610:
    .ascii    "i16"
    .byte     0
L7609:
    .ascii    "i8"
    .byte     0
L7608:
    .ascii    "void"
    .byte     0
L7607:
    .ascii    "MCC"
    .byte     0
L7606:
    .ascii    "    The 'MCC' C Compiler comprises:"
    .byte     10
    .byte     10
    .ascii    "    mcc.exe            Compiles to .asm files"
    .byte     10
    .ascii    "    aa.exe             Assembles .asm files to .obj files"
    .byte     10
    .ascii    "                       Assemblers and links .asm/.dll files to .exe"
    .byte     10
    .ascii    "    Standard headers   A minimal set inside mcc.exe"
    .byte     10
    .ascii    "    windows.h          As a standalone file"
    .byte     10
    .byte     10
    .ascii    "    Input files:"
    .byte     10
    .byte     10
    .ascii    "      prog             This is prog.c as the extension is optional"
    .byte     10
    .ascii    "      prog.c"
    .byte     10
    .ascii    "      lib.dll          Include .dll library when generating .exe"
    .byte     10
    .ascii    "      @file            Read parameters and optons from given file"
    .byte     10
    .byte     10
    .ascii    "    Options:"
    .byte     10
    .byte     10
    .ascii    "      -exe             (DEFAULT) Compile all modules to one .exe file via .asm files"
    .byte     10
    .ascii    "      -e               Preprocess each module to .i file"
    .byte     10
    .ascii    "      -s               Compile each module to .asm file"
    .byte     10
    .ascii    "      -c               Compile each module .obj via .asm"
    .byte     10
    .byte     10
    .ascii    "      -out:file        Specify output file for -exe only"
    .byte     10
    .byte     10
    .ascii    "    For .exe output, it will be named based on the first input file. Otherwise"
    .byte     10
    .ascii    "    use -out option"
    .byte     10
    .byte     10
    .ascii    "    .obj files can be linked using gcc on Windows. This option is"
    .byte     10
    .ascii    "    needed to be able to generate .dll files. However, this will not"
    .byte     10
    .ascii    "    work on newer gcc versions because mcc's generated code is not position"
    .byte     10
    .ascii    "    independent, and will only work loaded in the low 2GB of address space."
    .byte     10
    .byte     10
    .ascii    "    Libraries msvcrt.dll, gdi32.dll, user32.dll and kernel32.dll are"
    .byte     10
    .ascii    "    automatically included as search libraries for imported functions."
    .byte     10
    .byte     10
    .ascii    "    Other kinds of binary libraries or files (.a, .lib, .obj etc) are not supported."
    .byte     10
    .byte     10
    .ascii    "    Omissions, Restrictions and Bugs (highlights only as there are dozens):"
    .byte     10
    .byte     10
    .ascii    "      * No VLAs, compound literals, designated initialisers"
    .byte     10
    .ascii    "      * Restrictions on complexity of data initialisers"
    .byte     10
    .byte     0
L7605:
    .ascii    "long64"
    .byte     0
L7604:
    .ascii    "showil"
    .byte     0
L7603:
    .ascii    "options"
    .byte     0
L7602:
    .ascii    "himem"
    .byte     0
L7601:
    .ascii    "norip"
    .byte     0
L7600:
    .ascii    "shortnames"
    .byte     0
L7599:
    .ascii    "stdout"
    .byte     0
L7598:
    .ascii    "o"
    .byte     0
L7597:
    .ascii    "writeheaders"
    .byte     0
L7596:
    .ascii    "ext"
    .byte     0
L7595:
    .ascii    "help"
    .byte     0
L7594:
    .ascii    "h"
    .byte     0
L7593:
    .ascii    "ss"
    .byte     0
L7592:
    .ascii    "cs"
    .byte     0
L7591:
    .ascii    "q"
    .byte     0
L7590:
    .ascii    "vv"
    .byte     0
L7589:
    .ascii    "v"
    .byte     0
L7588:
    .ascii    "time2"
    .byte     0
L7587:
    .ascii    "time"
    .byte     0
L7586:
    .ascii    "showfiles"
    .byte     0
L7585:
    .ascii    "showtypes"
    .byte     0
L7584:
    .ascii    "showss"
    .byte     0
L7583:
    .ascii    "showmcl"
    .byte     0
L7582:
    .ascii    "showpst"
    .byte     0
L7581:
    .ascii    "showpcl"
    .byte     0
L7580:
    .ascii    "showast"
    .byte     0
L7579:
    .ascii    "showstflat"
    .byte     0
L7578:
    .ascii    "showst"
    .byte     0
L7577:
    .ascii    "includes"
    .byte     0
L7576:
    .ascii    "incl"
    .byte     0
L7575:
    .ascii    "headers"
    .byte     0
L7574:
    .ascii    "paths"
    .byte     0
L7573:
    .ascii    "noconst"
    .byte     0
L7572:
    .ascii    "no"
    .byte     0
L7571:
    .ascii    "nopeep"
    .byte     0
L7570:
    .ascii    "noregs"
    .byte     0
L7569:
    .ascii    "r"
    .byte     0
L7568:
    .ascii    "exe"
    .byte     0
L7567:
    .ascii    "dll"
    .byte     0
L7566:
    .ascii    "mx"
    .byte     0
L7565:
    .ascii    "obj"
    .byte     0
L7564:
    .ascii    "c"
    .byte     0
L7563:
    .ascii    "a"
    .byte     0
L7562:
    .ascii    "s"
    .byte     0
L7561:
    .ascii    "mcl"
    .byte     0
L7560:
    .ascii    "i"
    .byte     0
L7559:
    .ascii    "pi"
    .byte     0
L7558:
    .ascii    "p"
    .byte     0
L7557:
    .ascii    "type"
    .byte     0
L7556:
    .ascii    "parse"
    .byte     0
L7555:
    .ascii    "ei"
    .byte     0
L7554:
    .ascii    "e"
    .byte     0
L7553:
    .ascii    "load"
    .byte     0
L7552:
    .ascii    "exe"
    .byte     0
L7551:
    .ascii    "(run)"
    .byte     0
L7550:
    .ascii    "exe"
    .byte     0
L7549:
    .ascii    "dll"
    .byte     0
L7548:
    .ascii    "obj"
    .byte     0
L7547:
    .ascii    "mx"
    .byte     0
L7546:
    .ascii    "asm"
    .byte     0
L7545:
    .ascii    "(int)"
    .byte     0
L7544:
    .ascii    "pcl"
    .byte     0
L7543:
    .byte     0
L7542:
    .ascii    "i"
    .byte     0
L7541:
    .byte     0
L7540:
    .ascii    "run_pass"
    .byte     0
L7539:
    .ascii    "exe_pass"
    .byte     0
L7538:
    .ascii    "dll_pass"
    .byte     0
L7537:
    .ascii    "obj_pass"
    .byte     0
L7536:
    .ascii    "mx_pass"
    .byte     0
L7535:
    .ascii    "asm_pass"
    .byte     0
L7534:
    .ascii    "mcl_pass"
    .byte     0
L7533:
    .ascii    "runpcl_pass"
    .byte     0
L7532:
    .ascii    "pcl_pass"
    .byte     0
L7531:
    .ascii    "type_pass"
    .byte     0
L7530:
    .ascii    "parse_pass"
    .byte     0
L7529:
    .ascii    "pp_pass"
    .byte     0
L7528:
    .ascii    "load_pass"
    .byte     0
L7527:
    .ascii    "asm"
    .byte     0
L7526:
    .ascii    "rel8_rel"
    .byte     0
L7525:
    .ascii    "rel321_rel"
    .byte     0
L7524:
    .ascii    "rel32_rel"
    .byte     0
L7523:
    .ascii    "addr32nb_rel"
    .byte     0
L7522:
    .ascii    "addr32_rel"
    .byte     0
L7521:
    .ascii    "addr64_rel"
    .byte     0
L7520:
    .ascii    "abs_rel"
    .byte     0
L7519:
    .ascii    "xmm15"
    .byte     0
L7518:
    .ascii    "xmm13"
    .byte     0
L7517:
    .ascii    "xmm12"
    .byte     0
L7516:
    .ascii    "xmm11"
    .byte     0
L7515:
    .ascii    "xmm10"
    .byte     0
L7514:
    .ascii    "xmm9"
    .byte     0
L7513:
    .ascii    "xmm8"
    .byte     0
L7512:
    .ascii    "xmm7"
    .byte     0
L7511:
    .ascii    "xmm6"
    .byte     0
L7510:
    .ascii    "xmm5"
    .byte     0
L7509:
    .ascii    "xmm4"
    .byte     0
L7508:
    .ascii    "xmm3"
    .byte     0
L7507:
    .ascii    "xmm2"
    .byte     0
L7506:
    .ascii    "xmm1"
    .byte     0
L7505:
    .ascii    "xmm0"
    .byte     0
L7504:
    .ascii    "-"
    .byte     0
L7503:
    .ascii    "temp"
    .byte     0
L7502:
    .ascii    "regvar"
    .byte     0
L7501:
    .ascii    "reg"
    .byte     0
L7500:
    .ascii    "pend"
    .byte     0
L7499:
    .ascii    "a_xreg"
    .byte     0
L7498:
    .ascii    "a_cond"
    .byte     0
L7497:
    .ascii    "a_mem"
    .byte     0
L7496:
    .ascii    "a_imm"
    .byte     0
L7495:
    .ascii    "a_reg"
    .byte     0
L7494:
    .ascii    "a_none"
    .byte     0
L7493:
    .ascii    "back_ref"
    .byte     0
L7492:
    .ascii    "fwd_ref"
    .byte     0
L7491:
    .ascii    "extern_ref"
    .byte     0
L7490:
    .ascii    "impdata_seg"
    .byte     0
L7489:
    .ascii    "rodata_seg"
    .byte     0
L7488:
    .ascii    "zdata_seg"
    .byte     0
L7487:
    .ascii    "idata_seg"
    .byte     0
L7486:
    .ascii    "code_seg"
    .byte     0
L7485:
    .ascii    "no_seg"
    .byte     0
L7484:
    .ascii    "cmovg"
    .byte     0
L7483:
    .ascii    "cmovle"
    .byte     0
L7482:
    .ascii    "cmovge"
    .byte     0
L7481:
    .ascii    "cmovl"
    .byte     0
L7480:
    .ascii    "cmovnp"
    .byte     0
L7479:
    .ascii    "cmovp"
    .byte     0
L7478:
    .ascii    "cmovns"
    .byte     0
L7477:
    .ascii    "cmovs"
    .byte     0
L7476:
    .ascii    "cmova"
    .byte     0
L7475:
    .ascii    "cmovbe"
    .byte     0
L7474:
    .ascii    "cmovnz"
    .byte     0
L7473:
    .ascii    "cmovz"
    .byte     0
L7472:
    .ascii    "cmovae"
    .byte     0
L7471:
    .ascii    "cmovb"
    .byte     0
L7470:
    .ascii    "cmovno"
    .byte     0
L7469:
    .ascii    "cmovo"
    .byte     0
L7468:
    .ascii    "setg"
    .byte     0
L7467:
    .ascii    "setle"
    .byte     0
L7466:
    .ascii    "setge"
    .byte     0
L7465:
    .ascii    "setl"
    .byte     0
L7464:
    .ascii    "setnp"
    .byte     0
L7463:
    .ascii    "setp"
    .byte     0
L7462:
    .ascii    "setns"
    .byte     0
L7461:
    .ascii    "sets"
    .byte     0
L7460:
    .ascii    "seta"
    .byte     0
L7459:
    .ascii    "setbe"
    .byte     0
L7458:
    .ascii    "setnz"
    .byte     0
L7457:
    .ascii    "setz"
    .byte     0
L7456:
    .ascii    "setae"
    .byte     0
L7455:
    .ascii    "setb"
    .byte     0
L7454:
    .ascii    "setno"
    .byte     0
L7453:
    .ascii    "seto"
    .byte     0
L7452:
    .ascii    "jnc"
    .byte     0
L7451:
    .ascii    "jc"
    .byte     0
L7450:
    .ascii    "jg"
    .byte     0
L7449:
    .ascii    "jle"
    .byte     0
L7448:
    .ascii    "jge"
    .byte     0
L7447:
    .ascii    "jl"
    .byte     0
L7446:
    .ascii    "jnp"
    .byte     0
L7445:
    .ascii    "jp"
    .byte     0
L7444:
    .ascii    "jns"
    .byte     0
L7443:
    .ascii    "js"
    .byte     0
L7442:
    .ascii    "ja"
    .byte     0
L7441:
    .ascii    "jbe"
    .byte     0
L7440:
    .ascii    "jnz"
    .byte     0
L7439:
    .ascii    "jz"
    .byte     0
L7438:
    .ascii    "jae"
    .byte     0
L7437:
    .ascii    "jb"
    .byte     0
L7436:
    .ascii    "jno"
    .byte     0
L7435:
    .ascii    "jo"
    .byte     0
L7434:
    .ascii    "mmx7"
    .byte     0
L7433:
    .ascii    "mmx6"
    .byte     0
L7432:
    .ascii    "mmx5"
    .byte     0
L7431:
    .ascii    "mmx4"
    .byte     0
L7430:
    .ascii    "mmx3"
    .byte     0
L7429:
    .ascii    "mmx2"
    .byte     0
L7428:
    .ascii    "mmx1"
    .byte     0
L7427:
    .ascii    "mmx0"
    .byte     0
L7426:
    .ascii    "st7"
    .byte     0
L7425:
    .ascii    "st6"
    .byte     0
L7424:
    .ascii    "st5"
    .byte     0
L7423:
    .ascii    "st4"
    .byte     0
L7422:
    .ascii    "st3"
    .byte     0
L7421:
    .ascii    "st2"
    .byte     0
L7420:
    .ascii    "st1"
    .byte     0
L7419:
    .ascii    "st0"
    .byte     0
L7418:
    .ascii    "xmm15"
    .byte     0
L7417:
    .ascii    "xmm14"
    .byte     0
L7416:
    .ascii    "xmm13"
    .byte     0
L7415:
    .ascii    "xmm12"
    .byte     0
L7414:
    .ascii    "xmm11"
    .byte     0
L7413:
    .ascii    "xmm10"
    .byte     0
L7412:
    .ascii    "xmm9"
    .byte     0
L7411:
    .ascii    "xmm8"
    .byte     0
L7410:
    .ascii    "xmm7"
    .byte     0
L7409:
    .ascii    "xmm6"
    .byte     0
L7408:
    .ascii    "xmm5"
    .byte     0
L7407:
    .ascii    "xmm4"
    .byte     0
L7406:
    .ascii    "xmm3"
    .byte     0
L7405:
    .ascii    "xmm2"
    .byte     0
L7404:
    .ascii    "xmm1"
    .byte     0
L7403:
    .ascii    "xmm0"
    .byte     0
L7402:
    .ascii    "r15b"
    .byte     0
L7401:
    .ascii    "r14b"
    .byte     0
L7400:
    .ascii    "r13b"
    .byte     0
L7399:
    .ascii    "r12b"
    .byte     0
L7398:
    .ascii    "r11b"
    .byte     0
L7397:
    .ascii    "r10b"
    .byte     0
L7396:
    .ascii    "r9b"
    .byte     0
L7395:
    .ascii    "r8b"
    .byte     0
L7394:
    .ascii    "spl"
    .byte     0
L7393:
    .ascii    "bpl"
    .byte     0
L7392:
    .ascii    "dil"
    .byte     0
L7391:
    .ascii    "sil"
    .byte     0
L7390:
    .ascii    "dh"
    .byte     0
L7389:
    .ascii    "ch"
    .byte     0
L7388:
    .ascii    "bh"
    .byte     0
L7387:
    .ascii    "ah"
    .byte     0
L7386:
    .ascii    "dl"
    .byte     0
L7385:
    .ascii    "cl"
    .byte     0
L7384:
    .ascii    "bl"
    .byte     0
L7383:
    .ascii    "al"
    .byte     0
L7382:
    .ascii    "r15w"
    .byte     0
L7381:
    .ascii    "r14w"
    .byte     0
L7380:
    .ascii    "r13w"
    .byte     0
L7379:
    .ascii    "r12w"
    .byte     0
L7378:
    .ascii    "r11w"
    .byte     0
L7377:
    .ascii    "r10w"
    .byte     0
L7376:
    .ascii    "r9w"
    .byte     0
L7375:
    .ascii    "r8w"
    .byte     0
L7374:
    .ascii    "sp"
    .byte     0
L7373:
    .ascii    "bp"
    .byte     0
L7372:
    .ascii    "di"
    .byte     0
L7371:
    .ascii    "si"
    .byte     0
L7370:
    .ascii    "dx"
    .byte     0
L7369:
    .ascii    "cx"
    .byte     0
L7368:
    .ascii    "bx"
    .byte     0
L7367:
    .ascii    "ax"
    .byte     0
L7366:
    .ascii    "r15d"
    .byte     0
L7365:
    .ascii    "r14d"
    .byte     0
L7364:
    .ascii    "r13d"
    .byte     0
L7363:
    .ascii    "r12d"
    .byte     0
L7362:
    .ascii    "r11d"
    .byte     0
L7361:
    .ascii    "r10d"
    .byte     0
L7360:
    .ascii    "r9d"
    .byte     0
L7359:
    .ascii    "r8d"
    .byte     0
L7358:
    .ascii    "esp"
    .byte     0
L7357:
    .ascii    "ebp"
    .byte     0
L7356:
    .ascii    "edi"
    .byte     0
L7355:
    .ascii    "esi"
    .byte     0
L7354:
    .ascii    "edx"
    .byte     0
L7353:
    .ascii    "ecx"
    .byte     0
L7352:
    .ascii    "ebx"
    .byte     0
L7351:
    .ascii    "eax"
    .byte     0
L7350:
    .ascii    "r15"
    .byte     0
L7349:
    .ascii    "r14"
    .byte     0
L7348:
    .ascii    "r13"
    .byte     0
L7347:
    .ascii    "r12"
    .byte     0
L7346:
    .ascii    "r11"
    .byte     0
L7345:
    .ascii    "r10"
    .byte     0
L7344:
    .ascii    "r9"
    .byte     0
L7343:
    .ascii    "r8"
    .byte     0
L7342:
    .ascii    "rsp"
    .byte     0
L7341:
    .ascii    "rbp"
    .byte     0
L7340:
    .ascii    "rdi"
    .byte     0
L7339:
    .ascii    "rsi"
    .byte     0
L7338:
    .ascii    "rdx"
    .byte     0
L7337:
    .ascii    "rcx"
    .byte     0
L7336:
    .ascii    "rbx"
    .byte     0
L7335:
    .ascii    "rax"
    .byte     0
L7334:
    .ascii    "_b20"
    .byte     0
L7333:
    .ascii    "b19"
    .byte     0
L7332:
    .ascii    "b18"
    .byte     0
L7331:
    .ascii    "b17"
    .byte     0
L7330:
    .ascii    "b16"
    .byte     0
L7329:
    .ascii    "b15"
    .byte     0
L7328:
    .ascii    "b14"
    .byte     0
L7327:
    .ascii    "b13"
    .byte     0
L7326:
    .ascii    "b12"
    .byte     0
L7325:
    .ascii    "b11"
    .byte     0
L7324:
    .ascii    "b10"
    .byte     0
L7323:
    .ascii    "b9"
    .byte     0
L7322:
    .ascii    "b8"
    .byte     0
L7321:
    .ascii    "b7"
    .byte     0
L7320:
    .ascii    "b6"
    .byte     0
L7319:
    .ascii    "b5"
    .byte     0
L7318:
    .ascii    "b4"
    .byte     0
L7317:
    .ascii    "b3"
    .byte     0
L7316:
    .ascii    "b2"
    .byte     0
L7315:
    .ascii    "b1"
    .byte     0
L7314:
    .ascii    "b0"
    .byte     0
L7313:
    .ascii    "w15"
    .byte     0
L7312:
    .ascii    "w14"
    .byte     0
L7311:
    .ascii    "w13"
    .byte     0
L7310:
    .ascii    "w12"
    .byte     0
L7309:
    .ascii    "w11"
    .byte     0
L7308:
    .ascii    "w10"
    .byte     0
L7307:
    .ascii    "w9"
    .byte     0
L7306:
    .ascii    "w8"
    .byte     0
L7305:
    .ascii    "w7"
    .byte     0
L7304:
    .ascii    "w6"
    .byte     0
L7303:
    .ascii    "w5"
    .byte     0
L7302:
    .ascii    "w4"
    .byte     0
L7301:
    .ascii    "w3"
    .byte     0
L7300:
    .ascii    "w2"
    .byte     0
L7299:
    .ascii    "w1"
    .byte     0
L7298:
    .ascii    "w0"
    .byte     0
L7297:
    .ascii    "a15"
    .byte     0
L7296:
    .ascii    "a14"
    .byte     0
L7295:
    .ascii    "a13"
    .byte     0
L7294:
    .ascii    "a12"
    .byte     0
L7293:
    .ascii    "a11"
    .byte     0
L7292:
    .ascii    "a10"
    .byte     0
L7291:
    .ascii    "a9"
    .byte     0
L7290:
    .ascii    "a8"
    .byte     0
L7289:
    .ascii    "a7"
    .byte     0
L7288:
    .ascii    "a6"
    .byte     0
L7287:
    .ascii    "a5"
    .byte     0
L7286:
    .ascii    "a4"
    .byte     0
L7285:
    .ascii    "a3"
    .byte     0
L7284:
    .ascii    "a2"
    .byte     0
L7283:
    .ascii    "a1"
    .byte     0
L7282:
    .ascii    "a0"
    .byte     0
L7281:
    .ascii    "d15"
    .byte     0
L7280:
    .ascii    "d14"
    .byte     0
L7279:
    .ascii    "d13"
    .byte     0
L7278:
    .ascii    "d12"
    .byte     0
L7277:
    .ascii    "d11"
    .byte     0
L7276:
    .ascii    "d10"
    .byte     0
L7275:
    .ascii    "d9"
    .byte     0
L7274:
    .ascii    "d8"
    .byte     0
L7273:
    .ascii    "d7"
    .byte     0
L7272:
    .ascii    "d6"
    .byte     0
L7271:
    .ascii    "d5"
    .byte     0
L7270:
    .ascii    "d4"
    .byte     0
L7269:
    .ascii    "d3"
    .byte     0
L7268:
    .ascii    "d2"
    .byte     0
L7267:
    .ascii    "d1"
    .byte     0
L7266:
    .ascii    "d0"
    .byte     0
L7265:
    .ascii    "a"
    .byte     0
L7264:
    .ascii    "be"
    .byte     0
L7263:
    .ascii    "ae"
    .byte     0
L7262:
    .ascii    "b"
    .byte     0
L7261:
    .ascii    "g"
    .byte     0
L7260:
    .ascii    "le"
    .byte     0
L7259:
    .ascii    "ge"
    .byte     0
L7258:
    .ascii    "l"
    .byte     0
L7257:
    .ascii    "np"
    .byte     0
L7256:
    .ascii    "p"
    .byte     0
L7255:
    .ascii    "ns"
    .byte     0
L7254:
    .ascii    "s"
    .byte     0
L7253:
    .ascii    "a"
    .byte     0
L7252:
    .ascii    "be"
    .byte     0
L7251:
    .ascii    "nz"
    .byte     0
L7250:
    .ascii    "z"
    .byte     0
L7249:
    .ascii    "ae"
    .byte     0
L7248:
    .ascii    "b"
    .byte     0
L7247:
    .ascii    "no"
    .byte     0
L7246:
    .ascii    "o"
    .byte     0
L7245:
    .ascii    "fgt"
    .byte     0
L7244:
    .ascii    "fle"
    .byte     0
L7243:
    .ascii    "fge"
    .byte     0
L7242:
    .ascii    "flt"
    .byte     0
L7241:
    .ascii    "gt"
    .byte     0
L7240:
    .ascii    "le"
    .byte     0
L7239:
    .ascii    "ge"
    .byte     0
L7238:
    .ascii    "lt"
    .byte     0
L7237:
    .ascii    "np"
    .byte     0
L7236:
    .ascii    "p"
    .byte     0
L7235:
    .ascii    "ns"
    .byte     0
L7234:
    .ascii    "s"
    .byte     0
L7233:
    .ascii    "gtu"
    .byte     0
L7232:
    .ascii    "leu"
    .byte     0
L7231:
    .ascii    "ne"
    .byte     0
L7230:
    .ascii    "eq"
    .byte     0
L7229:
    .ascii    "geu"
    .byte     0
L7228:
    .ascii    "ltu"
    .byte     0
L7227:
    .ascii    "nov"
    .byte     0
L7226:
    .ascii    "ov"
    .byte     0
L7225:
    .ascii    "r19"
    .byte     0
L7224:
    .ascii    "r18"
    .byte     0
L7223:
    .ascii    "r17"
    .byte     0
L7222:
    .ascii    "r16"
    .byte     0
L7221:
    .ascii    "r15"
    .byte     0
L7220:
    .ascii    "r14"
    .byte     0
L7219:
    .ascii    "r13"
    .byte     0
L7218:
    .ascii    "r12"
    .byte     0
L7217:
    .ascii    "r11"
    .byte     0
L7216:
    .ascii    "r10"
    .byte     0
L7215:
    .ascii    "r9"
    .byte     0
L7214:
    .ascii    "r8"
    .byte     0
L7213:
    .ascii    "r7"
    .byte     0
L7212:
    .ascii    "r6"
    .byte     0
L7211:
    .ascii    "r5"
    .byte     0
L7210:
    .ascii    "r4"
    .byte     0
L7209:
    .ascii    "r3"
    .byte     0
L7208:
    .ascii    "r2"
    .byte     0
L7207:
    .ascii    "r1"
    .byte     0
L7206:
    .ascii    "r0"
    .byte     0
L7205:
    .ascii    "rnone"
    .byte     0
L7204:
    .ascii    "m_halt"
    .byte     0
L7203:
    .ascii    "m_xxxx"
    .byte     0
L7202:
    .ascii    "m_cpuid"
    .byte     0
L7201:
    .ascii    "m_fldln2"
    .byte     0
L7200:
    .ascii    "m_fldlg2"
    .byte     0
L7199:
    .ascii    "m_fld2e"
    .byte     0
L7198:
    .ascii    "m_fld2t"
    .byte     0
L7197:
    .ascii    "m_fldpi"
    .byte     0
L7196:
    .ascii    "m_fld1"
    .byte     0
L7195:
    .ascii    "m_fldz"
    .byte     0
L7194:
    .ascii    "m_finit"
    .byte     0
L7193:
    .ascii    "m_bswap"
    .byte     0
L7192:
    .ascii    "m_popcnt"
    .byte     0
L7191:
    .ascii    "m_rdtsc"
    .byte     0
L7190:
    .ascii    "m_cmpsq"
    .byte     0
L7189:
    .ascii    "m_cmpsd"
    .byte     0
L7188:
    .ascii    "m_cmpsw"
    .byte     0
L7187:
    .ascii    "m_cmpsb"
    .byte     0
L7186:
    .ascii    "m_jrcxz"
    .byte     0
L7185:
    .ascii    "m_jecxz"
    .byte     0
L7184:
    .ascii    "m_loopcx"
    .byte     0
L7183:
    .ascii    "m_loopz"
    .byte     0
L7182:
    .ascii    "m_loopnz"
    .byte     0
L7181:
    .ascii    "m_xlat"
    .byte     0
L7180:
    .ascii    "m_resq"
    .byte     0
L7179:
    .ascii    "m_resd"
    .byte     0
L7178:
    .ascii    "m_resw"
    .byte     0
L7177:
    .ascii    "m_resb"
    .byte     0
L7176:
    .ascii    "m_align"
    .byte     0
L7175:
    .ascii    "m_csegment"
    .byte     0
L7174:
    .ascii    "m_zsegment"
    .byte     0
L7173:
    .ascii    "m_isegment"
    .byte     0
L7172:
    .ascii    "m_ascii"
    .byte     0
L7171:
    .ascii    "m_dq"
    .byte     0
L7170:
    .ascii    "m_dd"
    .byte     0
L7169:
    .ascii    "m_dw"
    .byte     0
L7168:
    .ascii    "m_db"
    .byte     0
L7167:
    .ascii    "m_maxsd"
    .byte     0
L7166:
    .ascii    "m_minsd"
    .byte     0
L7165:
    .ascii    "m_maxss"
    .byte     0
L7164:
    .ascii    "m_minss"
    .byte     0
L7163:
    .ascii    "m_fchs"
    .byte     0
L7162:
    .ascii    "m_fabs"
    .byte     0
L7161:
    .ascii    "m_fpatan"
    .byte     0
L7160:
    .ascii    "m_fptan"
    .byte     0
L7159:
    .ascii    "m_fsincos"
    .byte     0
L7158:
    .ascii    "m_fcos"
    .byte     0
L7157:
    .ascii    "m_fsin"
    .byte     0
L7156:
    .ascii    "m_fsqrt"
    .byte     0
L7155:
    .ascii    "m_fdiv"
    .byte     0
L7154:
    .ascii    "m_fmul"
    .byte     0
L7153:
    .ascii    "m_fsub"
    .byte     0
L7152:
    .ascii    "m_fadd"
    .byte     0
L7151:
    .ascii    "m_fistp"
    .byte     0
L7150:
    .ascii    "m_fist"
    .byte     0
L7149:
    .ascii    "m_fild"
    .byte     0
L7148:
    .ascii    "m_fstp"
    .byte     0
L7147:
    .ascii    "m_fst"
    .byte     0
L7146:
    .ascii    "m_fld"
    .byte     0
L7145:
    .ascii    "m_pcmpistrm"
    .byte     0
L7144:
    .ascii    "m_pcmpistri"
    .byte     0
L7143:
    .ascii    "m_movdqu"
    .byte     0
L7142:
    .ascii    "m_movdqa"
    .byte     0
L7141:
    .ascii    "m_cvtss2sd"
    .byte     0
L7140:
    .ascii    "m_cvtsd2ss"
    .byte     0
L7139:
    .ascii    "m_cvtsi2sd"
    .byte     0
L7138:
    .ascii    "m_cvtsi2ss"
    .byte     0
L7137:
    .ascii    "m_cvttsd2si"
    .byte     0
L7136:
    .ascii    "m_cvttss2si"
    .byte     0
L7135:
    .ascii    "m_cvtsd2si"
    .byte     0
L7134:
    .ascii    "m_cvtss2si"
    .byte     0
L7133:
    .ascii    "m_pand"
    .byte     0
L7132:
    .ascii    "m_pxor"
    .byte     0
L7131:
    .ascii    "m_andpd"
    .byte     0
L7130:
    .ascii    "m_andps"
    .byte     0
L7129:
    .ascii    "m_xorpd"
    .byte     0
L7128:
    .ascii    "m_xorps"
    .byte     0
L7127:
    .ascii    "m_ucomisd"
    .byte     0
L7126:
    .ascii    "m_comisd"
    .byte     0
L7125:
    .ascii    "m_comiss"
    .byte     0
L7124:
    .ascii    "m_divsd"
    .byte     0
L7123:
    .ascii    "m_divss"
    .byte     0
L7122:
    .ascii    "m_mulsd"
    .byte     0
L7121:
    .ascii    "m_mulss"
    .byte     0
L7120:
    .ascii    "m_subsd"
    .byte     0
L7119:
    .ascii    "m_subss"
    .byte     0
L7118:
    .ascii    "m_addsd"
    .byte     0
L7117:
    .ascii    "m_addss"
    .byte     0
L7116:
    .ascii    "m_sqrtsd"
    .byte     0
L7115:
    .ascii    "m_sqrtss"
    .byte     0
L7114:
    .ascii    "m_shrd"
    .byte     0
L7113:
    .ascii    "m_shld"
    .byte     0
L7112:
    .ascii    "m_bsr"
    .byte     0
L7111:
    .ascii    "m_bsf"
    .byte     0
L7110:
    .ascii    "m_setcc"
    .byte     0
L7109:
    .ascii    "m_cqo"
    .byte     0
L7108:
    .ascii    "m_cdq"
    .byte     0
L7107:
    .ascii    "m_cwd"
    .byte     0
L7106:
    .ascii    "m_cbw"
    .byte     0
L7105:
    .ascii    "m_dec"
    .byte     0
L7104:
    .ascii    "m_inc"
    .byte     0
L7103:
    .ascii    "m_notx"
    .byte     0
L7102:
    .ascii    "m_neg"
    .byte     0
L7101:
    .ascii    "m_rcr"
    .byte     0
L7100:
    .ascii    "m_rcl"
    .byte     0
L7099:
    .ascii    "m_ror"
    .byte     0
L7098:
    .ascii    "m_rol"
    .byte     0
L7097:
    .ascii    "m_shr"
    .byte     0
L7096:
    .ascii    "m_sar"
    .byte     0
L7095:
    .ascii    "m_shl"
    .byte     0
L7094:
    .ascii    "m_cmp"
    .byte     0
L7093:
    .ascii    "m_test"
    .byte     0
L7092:
    .ascii    "m_xorx"
    .byte     0
L7091:
    .ascii    "m_orx"
    .byte     0
L7090:
    .ascii    "m_andx"
    .byte     0
L7089:
    .ascii    "m_div"
    .byte     0
L7088:
    .ascii    "m_idiv"
    .byte     0
L7087:
    .ascii    "m_imul3"
    .byte     0
L7086:
    .ascii    "m_imul2"
    .byte     0
L7085:
    .ascii    "m_mul"
    .byte     0
L7084:
    .ascii    "m_imul"
    .byte     0
L7083:
    .ascii    "m_sbb"
    .byte     0
L7082:
    .ascii    "m_adc"
    .byte     0
L7081:
    .ascii    "m_sub"
    .byte     0
L7080:
    .ascii    "m_add"
    .byte     0
L7079:
    .ascii    "m_xchg"
    .byte     0
L7078:
    .ascii    "m_jmpcc"
    .byte     0
L7077:
    .ascii    "m_jmp"
    .byte     0
L7076:
    .ascii    "m_retn"
    .byte     0
L7075:
    .ascii    "m_leave"
    .byte     0
L7074:
    .ascii    "m_ret"
    .byte     0
L7073:
    .ascii    "m_call"
    .byte     0
L7072:
    .ascii    "m_movsxd"
    .byte     0
L7071:
    .ascii    "m_movzx"
    .byte     0
L7070:
    .ascii    "m_movsx"
    .byte     0
L7069:
    .ascii    "m_movq"
    .byte     0
L7068:
    .ascii    "m_movd"
    .byte     0
L7067:
    .ascii    "m_cmovcc"
    .byte     0
L7066:
    .ascii    "m_lea"
    .byte     0
L7065:
    .ascii    "m_pop"
    .byte     0
L7064:
    .ascii    "m_push"
    .byte     0
L7063:
    .ascii    "m_mov"
    .byte     0
L7062:
    .ascii    "m_nop"
    .byte     0
L7061:
    .ascii    "m_labelx"
    .byte     0
L7060:
    .ascii    "m_endx"
    .byte     0
L7059:
    .ascii    "m_trace"
    .byte     0
L7058:
    .ascii    "m_definereg"
    .byte     0
L7057:
    .ascii    "m_define"
    .byte     0
L7056:
    .ascii    "m_labelname"
    .byte     0
L7055:
    .ascii    "m_comment"
    .byte     0
L7054:
    .ascii    "m_procend"
    .byte     0
L7053:
    .ascii    "m_procstart"
    .byte     0
L7052:
    .ascii    "temp_val"
    .byte     0
L7051:
    .ascii    "name_val"
    .byte     0
L7050:
    .ascii    "label_val"
    .byte     0
L7049:
    .ascii    "def_val"
    .byte     0
L7048:
    .ascii    "stringimm_val"
    .byte     0
L7047:
    .ascii    "realmem_val"
    .byte     0
L7046:
    .ascii    "realimm_val"
    .byte     0
L7045:
    .ascii    "intimm_val"
    .byte     0
L7044:
    .ascii    "no_val"
    .byte     0
L7043:
    .ascii    "Program"
    .byte     0
L7042:
    .ascii    "Misc"
    .byte     0
L7041:
    .ascii    "Export"
    .byte     0
L7040:
    .ascii    "Label"
    .byte     0
L7039:
    .ascii    "Param"
    .byte     0
L7038:
    .ascii    "Local"
    .byte     0
L7037:
    .ascii    "Static"
    .byte     0
L7036:
    .ascii    "Proc"
    .byte     0
L7035:
    .ascii    "Import"
    .byte     0
L7034:
    .ascii    "--"
    .byte     0
L7033:
    .ascii    "gt"
    .byte     0
L7032:
    .ascii    "ge"
    .byte     0
L7031:
    .ascii    "le"
    .byte     0
L7030:
    .ascii    "lt"
    .byte     0
L7029:
    .ascii    "ne"
    .byte     0
L7028:
    .ascii    "eq"
    .byte     0
L7027:
    .ascii    "xx"
    .byte     0
L7026:
    .ascii    "extproc"
    .byte     0
L7025:
    .ascii    "addlib"
    .byte     0
L7024:
    .ascii    "variadic"
    .byte     0
L7023:
    .ascii    "rettype"
    .byte     0
L7022:
    .ascii    "local"
    .byte     0
L7021:
    .ascii    "param"
    .byte     0
L7020:
    .ascii    "endprog"
    .byte     0
L7019:
    .ascii    "comment"
    .byte     0
L7018:
    .ascii    "eval"
    .byte     0
L7017:
    .ascii    "loadall"
    .byte     0
L7016:
    .ascii    "setarg"
    .byte     0
L7015:
    .ascii    "setcall"
    .byte     0
L7014:
    .ascii    "longjmp"
    .byte     0
L7013:
    .ascii    "setjmp"
    .byte     0
L7012:
    .ascii    "labeldef"
    .byte     0
L7011:
    .ascii    "label"
    .byte     0
L7010:
    .ascii    "initdswx"
    .byte     0
L7009:
    .ascii    "data"
    .byte     0
L7008:
    .ascii    "zstatic"
    .byte     0
L7007:
    .ascii    "istatic"
    .byte     0
L7006:
    .ascii    "endproc"
    .byte     0
L7005:
    .ascii    "tcproc"
    .byte     0
L7004:
    .ascii    "proc"
    .byte     0
L7003:
    .ascii    "endmx"
    .byte     0
L7002:
    .ascii    "resetmx"
    .byte     0
L7001:
    .ascii    "startmx"
    .byte     0
L7000:
    .ascii    "fnarrow"
    .byte     0
L6999:
    .ascii    "fwiden"
    .byte     0
L6998:
    .ascii    "widen"
    .byte     0
L6997:
    .ascii    "truncate"
    .byte     0
L6996:
    .ascii    "fix"
    .byte     0
L6995:
    .ascii    "float"
    .byte     0
L6994:
    .ascii    "typepun"
    .byte     0
L6993:
    .ascii    "toboolto"
    .byte     0
L6992:
    .ascii    "notto"
    .byte     0
L6991:
    .ascii    "bitnotto"
    .byte     0
L6990:
    .ascii    "absto"
    .byte     0
L6989:
    .ascii    "negto"
    .byte     0
L6988:
    .ascii    "subpxto"
    .byte     0
L6987:
    .ascii    "addpxto"
    .byte     0
L6986:
    .ascii    "maxto"
    .byte     0
L6985:
    .ascii    "minto"
    .byte     0
L6984:
    .ascii    "shrto"
    .byte     0
L6983:
    .ascii    "shlto"
    .byte     0
L6982:
    .ascii    "bitxorto"
    .byte     0
L6981:
    .ascii    "bitorto"
    .byte     0
L6980:
    .ascii    "bitandto"
    .byte     0
L6979:
    .ascii    "iremto"
    .byte     0
L6978:
    .ascii    "idivto"
    .byte     0
L6977:
    .ascii    "divto"
    .byte     0
L6976:
    .ascii    "multo"
    .byte     0
L6975:
    .ascii    "subto"
    .byte     0
L6974:
    .ascii    "addto"
    .byte     0
L6973:
    .ascii    "loaddecr"
    .byte     0
L6972:
    .ascii    "loadincr"
    .byte     0
L6971:
    .ascii    "decrload"
    .byte     0
L6970:
    .ascii    "incrload"
    .byte     0
L6969:
    .ascii    "decrto"
    .byte     0
L6968:
    .ascii    "incrto"
    .byte     0
L6967:
    .ascii    "fmod"
    .byte     0
L6966:
    .ascii    "power"
    .byte     0
L6965:
    .ascii    "atan2"
    .byte     0
L6964:
    .ascii    "sign"
    .byte     0
L6963:
    .ascii    "ceil"
    .byte     0
L6962:
    .ascii    "floor"
    .byte     0
L6961:
    .ascii    "round"
    .byte     0
L6960:
    .ascii    "exp"
    .byte     0
L6959:
    .ascii    "log10"
    .byte     0
L6958:
    .ascii    "log"
    .byte     0
L6957:
    .ascii    "atan"
    .byte     0
L6956:
    .ascii    "acos"
    .byte     0
L6955:
    .ascii    "asin"
    .byte     0
L6954:
    .ascii    "tan"
    .byte     0
L6953:
    .ascii    "cos"
    .byte     0
L6952:
    .ascii    "sin"
    .byte     0
L6951:
    .ascii    "sqrt"
    .byte     0
L6950:
    .ascii    "sqr"
    .byte     0
L6949:
    .ascii    "toboolf"
    .byte     0
L6948:
    .ascii    "toboolt"
    .byte     0
L6947:
    .ascii    "not"
    .byte     0
L6946:
    .ascii    "bitnot"
    .byte     0
L6945:
    .ascii    "abs"
    .byte     0
L6944:
    .ascii    "neg"
    .byte     0
L6943:
    .ascii    "subp"
    .byte     0
L6942:
    .ascii    "subpx"
    .byte     0
L6941:
    .ascii    "addpx"
    .byte     0
L6940:
    .ascii    "max"
    .byte     0
L6939:
    .ascii    "min"
    .byte     0
L6938:
    .ascii    "shr"
    .byte     0
L6937:
    .ascii    "shl"
    .byte     0
L6936:
    .ascii    "bitxor"
    .byte     0
L6935:
    .ascii    "bitor"
    .byte     0
L6934:
    .ascii    "bitand"
    .byte     0
L6933:
    .ascii    "idivrem"
    .byte     0
L6932:
    .ascii    "irem"
    .byte     0
L6931:
    .ascii    "idiv"
    .byte     0
L6930:
    .ascii    "div"
    .byte     0
L6929:
    .ascii    "mul"
    .byte     0
L6928:
    .ascii    "sub"
    .byte     0
L6927:
    .ascii    "add"
    .byte     0
L6926:
    .ascii    "assem"
    .byte     0
L6925:
    .ascii    "clear"
    .byte     0
L6924:
    .ascii    "endsw"
    .byte     0
L6923:
    .ascii    "swlabel"
    .byte     0
L6922:
    .ascii    "switchu"
    .byte     0
L6921:
    .ascii    "switch"
    .byte     0
L6920:
    .ascii    "iswap"
    .byte     0
L6919:
    .ascii    "fordown"
    .byte     0
L6918:
    .ascii    "forup"
    .byte     0
L6917:
    .ascii    "to"
    .byte     0
L6916:
    .ascii    "stop"
    .byte     0
L6915:
    .ascii    "setcc"
    .byte     0
L6914:
    .ascii    "jumpretm"
    .byte     0
L6913:
    .ascii    "jumpret"
    .byte     0
L6912:
    .ascii    "jumpf"
    .byte     0
L6911:
    .ascii    "jumpt"
    .byte     0
L6910:
    .ascii    "jumpcc"
    .byte     0
L6909:
    .ascii    "ijump"
    .byte     0
L6908:
    .ascii    "jump"
    .byte     0
L6907:
    .ascii    "retfn"
    .byte     0
L6906:
    .ascii    "icallf"
    .byte     0
L6905:
    .ascii    "callf"
    .byte     0
L6904:
    .ascii    "retproc"
    .byte     0
L6903:
    .ascii    "icallp"
    .byte     0
L6902:
    .ascii    "callp"
    .byte     0
L6901:
    .ascii    "storebf"
    .byte     0
L6900:
    .ascii    "storebit"
    .byte     0
L6899:
    .ascii    "loadbf"
    .byte     0
L6898:
    .ascii    "loadbit"
    .byte     0
L6897:
    .ascii    "type"
    .byte     0
L6896:
    .ascii    "opnd"
    .byte     0
L6895:
    .ascii    "unload"
    .byte     0
L6894:
    .ascii    "swapstk"
    .byte     0
L6893:
    .ascii    "double"
    .byte     0
L6892:
    .ascii    "dupl"
    .byte     0
L6891:
    .ascii    "storem"
    .byte     0
L6890:
    .ascii    "istorex"
    .byte     0
L6889:
    .ascii    "istore"
    .byte     0
L6888:
    .ascii    "store"
    .byte     0
L6887:
    .ascii    "iloadx"
    .byte     0
L6886:
    .ascii    "iload"
    .byte     0
L6885:
    .ascii    "load"
    .byte     0
L6884:
    .ascii    "nop"
    .byte     0
L6883:
    .ascii    "any_opnd"
    .byte     0
L6882:
    .ascii    "data_opnd"
    .byte     0
L6881:
    .ascii    "realimm32_opnd"
    .byte     0
L6880:
    .ascii    "realimm_opnd"
    .byte     0
L6879:
    .ascii    "assem_opnd"
    .byte     0
L6878:
    .ascii    "strimm_opnd"
    .byte     0
L6877:
    .ascii    "string_opnd"
    .byte     0
L6876:
    .ascii    "r32_opnd"
    .byte     0
L6875:
    .ascii    "real_opnd"
    .byte     0
L6874:
    .ascii    "int_opnd"
    .byte     0
L6873:
    .ascii    "label_opnd"
    .byte     0
L6872:
    .ascii    "memaddr_opnd"
    .byte     0
L6871:
    .ascii    "mem_opnd"
    .byte     0
L6870:
    .ascii    "no_opnd"
    .byte     0
L6869:
    .ascii    "$last"
    .byte     0
L6868:
    .ascii    "vec"
    .byte     0
L6867:
    .ascii    "mem"
    .byte     0
L6866:
    .ascii    "i64"
    .byte     0
L6865:
    .ascii    "i32"
    .byte     0
L6864:
    .ascii    "i16"
    .byte     0
L6863:
    .ascii    "i8"
    .byte     0
L6862:
    .ascii    "u64"
    .byte     0
L6861:
    .ascii    "u32"
    .byte     0
L6860:
    .ascii    "u16"
    .byte     0
L6859:
    .ascii    "u8"
    .byte     0
L6858:
    .ascii    "r64"
    .byte     0
L6857:
    .ascii    "r32"
    .byte     0
L6856:
    .ascii    "void"
    .byte     0
L6855:
    .ascii    "pm_extra"
    .byte     0
L6854:
    .ascii    "pm_colon"
    .byte     0
L6853:
    .ascii    "pm_libfile"
    .byte     0
L6852:
    .ascii    "pm_sourcefile"
    .byte     0
L6851:
    .ascii    "pm_option"
    .byte     0
L6850:
    .ascii    "pm_end"
    .byte     0



