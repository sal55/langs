# GAS VERSION
    .code64
    .intel_syntax prefix

    .global $cmdskip
    .global main

    .bss
    .align    8
msys.fmtparam:
    .space    8
    .align    8
msys.$cmdskip:
$cmdskip:
    .space    8
    .data
    .align    8
msys.needgap:
    .quad     0
    .align    8
msys.outdev:
    .quad     1
    .align    8
msys.outchan:
    .quad     0
    .align    8
msys.fmtstr:
    .quad     0
    .bss
    .align    8
msys.outchan_stack:
    .space    80
    .align    8
msys.outdev_stack:
    .space    80
    .align    8
msys.fmtstr_stack:
    .space    80
msys.needgap_stack:
    .space    10
    .align    8
msys.ptr_stack:
    .space    80
    .data
    .align    8
msys.niostack:
    .quad     0
msys.digits:
    .quad     0x3736353433323130
    .quad     0x4645444342413938
    .byte     0
#ENDDATA
    .align    8
msys.defaultfmt:
    .byte     0
    .byte     0
    .byte     10
    .byte     0
    .byte     32
    .byte     102
    .byte     0
    .byte     0
    .byte     0
    .byte     82
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .bss
    .align    8
msys.rd_buffer:
    .space    8
    .align    8
msys.rd_length:
    .space    8
    .align    8
msys.rd_pos:
    .space    8
    .align    8
msys.rd_lastpos:
    .space    8
    .align    8
msys.termchar:
    .space    8
    .align    8
msys.itemerror:
    .space    8
msys.printbuffer:
    .space    4096
    .align    8
msys.printptr:
    .space    8
    .align    8
msys.printlen:
    .space    8
    .align    8
msys.nsysparams:
    .space    8
    .align    8
msys.ncmdparams:
    .space    8
    .align    8
msys.nenvstrings:
    .space    8
    .align    8
msys.sysparams:
    .space    1024
    .align    8
msys.cmdparams:
    .space    8
    .align    8
msys.envstrings:
    .space    8
msys.start.startupinfo:
    .space    128
    .align    8
msys.getfmt.fmt:
    .space    16
msys.strint.str:
    .space    100
msys.strword.str:
    .space    100
msys.strreal.str:
    .space    320
    .align    8
mlib.allocupper:
    .space    2408
    .align    8
mlib.alloccode:
    .space    8
    .align    8
mlib.allocbytes:
    .space    8
    .data
    .align    8
mlib.fdebug:
    .quad     0
    .bss
    .align    8
mlib.rfsize:
    .space    8
    .align    8
mlib.maxmemory:
    .space    8
    .align    8
mlib.maxalloccode:
    .space    8
    .data
mlib.pcm_setup:
    .byte     0
    .align    8
mlib.show:
    .quad     0
    .align    8
mlib.memtotal:
    .quad     0
    .align    8
mlib.smallmemtotal:
    .quad     0
    .align    8
mlib.smallmemobjs:
    .quad     0
    .align    8
mlib.maxmemtotal:
    .quad     0
    .bss
    .align    8
mlib.memalloctable:
    .space    24
    .align    4
mlib.memallocsize:
    .space    12
    .align    8
mlib.pcheapstart:
    .space    8
    .align    8
mlib.pcheapend:
    .space    8
    .align    8
mlib.pcheapptr:
    .space    8
mlib.sizeindextable:
    .space    2049
    .align    8
mlib.freelist:
    .space    72
    .data
    .align    8
mlib.pmnames:
    .quad     L7085
    .quad     L7086
    .quad     L7087
    .quad     L7088
    .quad     L7089
    .quad     L7090
    .align    8
mlib.seed:
    .quad     0x2989881111111272
    .quad     0x1673267373358264
    .bss
    .align    8
mlib.pcm_newblock.totalheapsize:
    .space    8
    .data
    .align    4
mlib.pcm_round.allocbytes:
    .long     0
    .long     16
    .long     32
    .long     64
    .long     128
    .long     256
    .long     512
    .long     1024
    .long     2048
    .bss
mlib.changeext.newfile:
    .space    260
mlib.extractpath.str:
    .space    260
mlib.extractbasefile.str:
    .space    100
    .data
    .align    8
mlib.nextcmdparamnew.infile:
    .quad     0
    .align    8
mlib.nextcmdparamnew.filestart:
    .quad     0
    .align    8
mlib.nextcmdparamnew.fileptr:
    .quad     0
mlib.nextcmdparamnew.colonseen:
    .byte     0
    .bss
mlib.nextcmdparamnew.str:
    .space    300
mlib.readnextfileitem.str:
    .space    256
mlib.padstr.str:
    .space    256
mlib.chr.str:
    .space    8
    .data
pepcl.pc_userunpcl:
    .byte     0
pepcl.asmonly:
    .byte     1
pepcl.pdcc:
    .byte     1
    .bss
    .align    8
pc_api.pclseqno:
    .space    8
    .align    8
pc_api.stseqno:
    .space    8
    .align    8
pc_api.pcstart:
    .space    8
    .align    8
pc_api.pccurr:
    .space    8
    .align    8
pc_api.pcend:
    .space    8
    .align    8
pc_api.pcalloc:
    .space    8
pc_api.pcfixed:
    .space    1
    .align    8
pc_api.pcseqno:
    .space    8
    .align    8
pc_api.pcneedfntable:
    .space    8
    .data
    .align    8
pc_api.initpcalloc:
    .quad     0x10000
    .bss
    .align    8
pc_api.longstring:
    .space    8
    .align    8
pc_api.longstringlen:
    .space    8
    .align    8
pc_api.mlabelno:
    .space    8
pc_api.phighmem:
    .space    1
pc_api.pfullsys:
    .space    1
pc_api.fpshortnames:
    .space    1
    .align    8
pc_api.idomcl_assem:
    .space    8
    .align    8
pc_api.icheckasmlabel:
    .space    8
    .align    8
pc_api.igethostfn:
    .space    8
pc_api.strpmode.str:
    .space    32
pc_api.getfullname.str:
    .space    256
pc_api.addstr.str:
    .space    256
    .align    8
pc_decls.pinfo:
    .space    8
    .align    8
pc_decls.bspill:
    .space    8
    .align    8
pc_decls.bxspill:
    .space    8
pc_decls.r10used:
    .space    1
pc_decls.r11used:
    .space    1
pc_decls.localshadow:
    .space    1
    .align    8
pc_decls.mmpos:
    .space    8
    .align    8
pc_decls.psymboltable:
    .space    8
    .align    8
pc_decls.psymboltablex:
    .space    8
    .align    8
pc_decls.currprog:
    .space    8
    .align    8
pc_decls.currfunc:
    .space    8
    .align    8
pc_decls.blockretname:
    .space    8
    .align    8
pc_decls.entryproc:
    .space    8
    .align    8
pc_decls.sbuffer:
    .space    16
    .data
    .align    8
pc_decls.pdest:
    .quad     pc_decls.sbuffer
    .bss
    .align    8
pc_decls.plibfiles:
    .space    400
    .align    8
pc_decls.plibinst:
    .space    400
    .align    8
pc_decls.nplibfiles:
    .space    8
    .align    8
pc_decls.igetmsourceinfo:
    .space    8
pc_decls.pcldone:
    .space    1
pc_decls.mcldone:
    .space    1
pc_decls.ssdone:
    .space    1
pc_decls.objdone:
    .space    1
pc_decls.exedone:
    .space    1
pc_decls.pverbose:
    .space    1
    .align    8
pc_decls.pcmdskip:
    .space    8
    .data
    .align    8
pc_decls.assemtype:
    .quad     0x4141
    .bss
    .align    8
pc_decls.ppseqno:
    .space    8
    .data
pc_decls.fpeephole:
    .byte     1
pc_decls.fregoptim:
    .byte     1
pc_decls.fnoconst:
    .byte     0
pc_decls.fshowil:
    .byte     0
pc_decls.flong64:
    .byte     0
    .bss
    .align    8
pc_decls.pcltime:
    .space    8
    .align    8
pc_decls.mcltime:
    .space    8
    .align    8
pc_decls.sstime:
    .space    8
    .align    8
pc_decls.objtime:
    .space    8
    .align    8
pc_decls.exetime:
    .space    8
    .align    8
pc_decls.$pmodulename:
    .space    8
    .align    8
pc_decls.pclflags:
    .space    1144
    .align    8
pc_decls.pstartclock:
    .space    8
    .align    8
pc_decls.npcl:
    .space    8
    .align    8
pc_decls.npst:
    .space    8
    .align    8
pc_diags.sbuffer:
    .space    16
    .data
    .align    8
pc_diags.dest:
    .quad     pc_diags.sbuffer
    .bss
    .align    8
pc_diags.destlinestart:
    .space    8
pc_diags.stropnd.str:
    .space    512
    .align    8
pc_diags.stropnd.longstring:
    .space    8
    .align    8
pc_diags.psopnd.longstring:
    .space    8
    .data
    .align    8
pc_tables.pstdnames:
    .quad     L7091
    .quad     L7092
    .quad     L7093
    .quad     L7094
    .quad     L7095
    .quad     L7096
    .quad     L7097
    .quad     L7098
    .quad     L7099
    .quad     L7100
    .quad     L7101
    .quad     L7102
    .quad     L7103
    .quad     L7104
pc_tables.psize:
    .quad     0x108040201080400
    .byte     2
    .byte     4
    .byte     8
    .byte     0
    .byte     0
    .byte     0
#ENDDATA
pc_tables.psigned:
    .quad     0x100000000000000
    .byte     1
    .byte     1
    .byte     1
    .byte     0
    .byte     0
    .byte     0
#ENDDATA
pc_tables.pint:
    .quad     0x101010101000000
    .byte     1
    .byte     1
    .byte     1
    .byte     0
    .byte     0
    .byte     0
#ENDDATA
pc_tables.pfloat:
    .quad     0x10100
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
#ENDDATA
pc_tables.pmin:
    .quad     0x906050505020100
    .byte     9
    .byte     9
    .byte     10
    .byte     11
    .byte     12
    .byte     0
#ENDDATA
pc_tables.xxpiwrb:
    .quad     0xA06060606020100
    .byte     10
    .byte     10
    .byte     10
    .byte     0
    .byte     0
    .byte     0
#ENDDATA
    .align    8
pc_tables.opndnames:
    .quad     L7105
    .quad     L7106
    .quad     L7107
    .quad     L7108
    .quad     L7109
    .quad     L7110
    .quad     L7111
    .quad     L7112
    .quad     L7113
    .quad     L7114
    .quad     L7115
    .quad     L7116
    .quad     L7117
    .quad     L7118
    .align    8
pc_tables.pclnames:
    .quad     L7119
    .quad     L7120
    .quad     L7121
    .quad     L7122
    .quad     L7123
    .quad     L7124
    .quad     L7125
    .quad     L7126
    .quad     L7127
    .quad     L7128
    .quad     L7129
    .quad     L7130
    .quad     L7131
    .quad     L7132
    .quad     L7133
    .quad     L7134
    .quad     L7135
    .quad     L7136
    .quad     L7137
    .quad     L7138
    .quad     L7139
    .quad     L7140
    .quad     L7141
    .quad     L7142
    .quad     L7143
    .quad     L7144
    .quad     L7145
    .quad     L7146
    .quad     L7147
    .quad     L7148
    .quad     L7149
    .quad     L7150
    .quad     L7151
    .quad     L7152
    .quad     L7153
    .quad     L7154
    .quad     L7155
    .quad     L7156
    .quad     L7157
    .quad     L7158
    .quad     L7159
    .quad     L7160
    .quad     L7161
    .quad     L7162
    .quad     L7163
    .quad     L7164
    .quad     L7165
    .quad     L7166
    .quad     L7167
    .quad     L7168
    .quad     L7169
    .quad     L7170
    .quad     L7171
    .quad     L7172
    .quad     L7173
    .quad     L7174
    .quad     L7175
    .quad     L7176
    .quad     L7177
    .quad     L7178
    .quad     L7179
    .quad     L7180
    .quad     L7181
    .quad     L7182
    .quad     L7183
    .quad     L7184
    .quad     L7185
    .quad     L7186
    .quad     L7187
    .quad     L7188
    .quad     L7189
    .quad     L7190
    .quad     L7191
    .quad     L7192
    .quad     L7193
    .quad     L7194
    .quad     L7195
    .quad     L7196
    .quad     L7197
    .quad     L7198
    .quad     L7199
    .quad     L7200
    .quad     L7201
    .quad     L7202
    .quad     L7203
    .quad     L7204
    .quad     L7205
    .quad     L7206
    .quad     L7207
    .quad     L7208
    .quad     L7209
    .quad     L7210
    .quad     L7211
    .quad     L7212
    .quad     L7213
    .quad     L7214
    .quad     L7215
    .quad     L7216
    .quad     L7217
    .quad     L7218
    .quad     L7219
    .quad     L7220
    .quad     L7221
    .quad     L7222
    .quad     L7223
    .quad     L7224
    .quad     L7225
    .quad     L7226
    .quad     L7227
    .quad     L7228
    .quad     L7229
    .quad     L7230
    .quad     L7231
    .quad     L7232
    .quad     L7233
    .quad     L7234
    .quad     L7235
    .quad     L7236
    .quad     L7237
    .quad     L7238
    .quad     L7239
    .quad     L7240
    .quad     L7241
    .quad     L7242
    .quad     L7243
    .quad     L7244
    .quad     L7245
    .quad     L7246
    .quad     L7247
    .quad     L7248
    .quad     L7249
    .quad     L7250
    .quad     L7251
    .quad     L7252
    .quad     L7253
    .quad     L7254
    .quad     L7255
    .quad     L7256
    .quad     L7257
    .quad     L7258
    .quad     L7259
    .quad     L7260
    .quad     L7261
pc_tables.pclhastype:
    .quad     0x101010101010100
    .quad     0x101010101000000
    .quad     0x101010000000101
    .quad     0x101010101010100
    .quad     0x10101010100
    .quad     0x101010101000100
    .quad     0x101010101010101
    .quad     0x101010101010101
    .quad     0x101010101010202
    .quad     0x101010101010101
    .quad     0x101010101010101
    .quad     0x101010101010101
    .quad     0x101010101010101
    .quad     0x202010101010101
    .quad     0x101000202020202
    .quad     0x10101000000
    .quad     0
    .byte     0
    .byte     1
    .byte     1
    .byte     1
    .byte     0
    .byte     0
    .byte     0
#ENDDATA
pc_tables.pclextra:
    .quad     0x2000002000100
    .quad     0x20000
    .quad     0x2020002020000
    .quad     0x10000
    .quad     0x2020001010000
    .quad     0
    .quad     0
    .quad     0x1020200
    .quad     0
    .quad     0
    .quad     0x101010100000000
    .quad     0x101
    .quad     0x100000000000000
    .quad     1
    .quad     0
    .quad     0x20000000000
    .quad     0x201000000
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
#ENDDATA
pc_tables.pclhasopnd:
    .quad     0x100000D00
    .quad     0xD00000000
    .quad     0x20000020000
    .quad     0x3030303030003
    .quad     0x303030003030300
    .quad     0xD0000
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .quad     0x3000D0101000101
    .quad     2
    .byte     0
    .byte     1
    .byte     1
    .byte     0
    .byte     0
    .byte     7
    .byte     1
#ENDDATA
pc_tables.pclargs:
    .quad     0
    .quad     0x202000000000000
    .quad     0x9090009090202
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .quad     0x101010100000000
    .quad     0x101010101010101
    .quad     0x2020201
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
#ENDDATA
    .align    8
pc_tables.ccnames:
    .quad     L7262
    .quad     L7263
    .quad     L7264
    .quad     L7265
    .quad     L7266
    .quad     L7267
    .quad     L7268
    .align    8
pc_tables.idnames:
    .quad     L7269
    .quad     L7270
    .quad     L7271
    .quad     L7272
    .quad     L7273
    .quad     L7274
    .quad     L7275
    .quad     L7276
    .quad     L7277
    .quad     L7278
    .bss
    .align    8
mc_genmcl.debug:
    .space    8
    .align    8
mc_genmcl.frameoffset:
    .space    8
    .align    8
mc_genmcl.paramoffset:
    .space    8
    .align    8
mc_genmcl.framebytes:
    .space    8
    .align    8
mc_genmcl.px_handlertable:
    .space    1144
    .data
mc_genmcl.scondcodes:
    .byte     4
    .byte     5
    .byte     12
    .byte     14
    .byte     13
    .byte     15
#ENDDATA
mc_genmcl.ucondcodes:
    .byte     4
    .byte     5
    .byte     2
    .byte     6
    .byte     3
    .byte     7
#ENDDATA
mc_genmcl.inithandlers.initdone:
    .byte     0
mc_genmcl.inithandlers.dupltable:
    .ascii    "MX"
#ENDDATA
    .ascii    "A@"
#ENDDATA
    .byte     21
    .byte     18
#ENDDATA
    .byte     19
    .byte     18
#ENDDATA
    .byte     22
    .byte     18
#ENDDATA
    .ascii    "wv"
#ENDDATA
    .ascii    "yx"
#ENDDATA
    .ascii    "^/"
#ENDDATA
    .ascii    "_0"
#ENDDATA
    .bss
    .align    8
mc_auxmcl.nnn:
    .space    8
    .align    8
mc_auxmcl.nauxprocs:
    .space    8
    .align    8
mc_auxmcl.nauxnoframe:
    .space    8
    .align    8
mc_auxmcl.mclframesetup:
    .space    8
    .align    8
mc_libmcl.mclseqno:
    .space    8
    .align    8
mc_libmcl.nmclopnd:
    .space    8
    .align    8
mc_libmcl.smallinttable:
    .space    96
    .align    8
mc_libmcl.nametable:
    .space    160
    .align    8
mc_libmcl.nnametable:
    .space    8
    .align    8
mc_libmcl.mgenextname.table:
    .space    160
    .align    8
mc_libmcl.mgenextname.ntable:
    .space    8
mc_stackmcl.stropndstack.str:
    .space    512
    .align    8
mc_genss_dummy.psstime:
    .space    8
    .data
    .align    8
mc_decls.valtypenames:
    .quad     L7279
    .quad     L7280
    .quad     L7281
    .quad     L7282
    .quad     L7283
    .quad     L7284
    .quad     L7285
    .quad     L7286
    .quad     L7287
    .align    8
mc_decls.mclnames:
    .quad     L7288
    .quad     L7289
    .quad     L7290
    .quad     L7291
    .quad     L7292
    .quad     L7293
    .quad     L7294
    .quad     L7295
    .quad     L7296
    .quad     L7297
    .quad     L7298
    .quad     L7299
    .quad     L7300
    .quad     L7301
    .quad     L7302
    .quad     L7303
    .quad     L7304
    .quad     L7305
    .quad     L7306
    .quad     L7307
    .quad     L7308
    .quad     L7309
    .quad     L7310
    .quad     L7311
    .quad     L7312
    .quad     L7313
    .quad     L7314
    .quad     L7315
    .quad     L7316
    .quad     L7317
    .quad     L7318
    .quad     L7319
    .quad     L7320
    .quad     L7321
    .quad     L7322
    .quad     L7323
    .quad     L7324
    .quad     L7325
    .quad     L7326
    .quad     L7327
    .quad     L7328
    .quad     L7329
    .quad     L7330
    .quad     L7331
    .quad     L7332
    .quad     L7333
    .quad     L7334
    .quad     L7335
    .quad     L7336
    .quad     L7337
    .quad     L7338
    .quad     L7339
    .quad     L7340
    .quad     L7341
    .quad     L7342
    .quad     L7343
    .quad     L7344
    .quad     L7345
    .quad     L7346
    .quad     L7347
    .quad     L7348
    .quad     L7349
    .quad     L7350
    .quad     L7351
    .quad     L7352
    .quad     L7353
    .quad     L7354
    .quad     L7355
    .quad     L7356
    .quad     L7357
    .quad     L7358
    .quad     L7359
    .quad     L7360
    .quad     L7361
    .quad     L7362
    .quad     L7363
    .quad     L7364
    .quad     L7365
    .quad     L7366
    .quad     L7367
    .quad     L7368
    .quad     L7369
    .quad     L7370
    .quad     L7371
    .quad     L7372
    .quad     L7373
    .quad     L7374
    .quad     L7375
    .quad     L7376
    .quad     L7377
    .quad     L7378
    .quad     L7379
    .quad     L7380
    .quad     L7381
    .quad     L7382
    .quad     L7383
    .quad     L7384
    .quad     L7385
    .quad     L7386
    .quad     L7387
    .quad     L7388
    .quad     L7389
    .quad     L7390
    .quad     L7391
    .quad     L7392
    .quad     L7393
    .quad     L7394
    .quad     L7395
    .quad     L7396
    .quad     L7397
    .quad     L7398
    .quad     L7399
    .quad     L7400
    .quad     L7401
    .quad     L7402
    .quad     L7403
    .quad     L7404
    .quad     L7405
    .quad     L7406
    .quad     L7407
    .quad     L7408
    .quad     L7409
    .quad     L7410
    .quad     L7411
    .quad     L7412
    .quad     L7413
    .quad     L7414
    .quad     L7415
    .quad     L7416
    .quad     L7417
    .quad     L7418
    .quad     L7419
    .quad     L7420
    .quad     L7421
    .quad     L7422
    .quad     L7423
    .quad     L7424
    .quad     L7425
    .quad     L7426
    .quad     L7427
    .quad     L7428
    .quad     L7429
    .quad     L7430
    .quad     L7431
    .quad     L7432
    .quad     L7433
    .quad     L7434
    .quad     L7435
    .quad     L7436
    .quad     L7437
    .quad     L7438
    .quad     L7439
mc_decls.mclnopnds:
    .quad     0
    .quad     0x202020101020001
    .quad     0x100000102020202
    .quad     0x102020202020101
    .quad     0x202020101030201
    .quad     0x202020202020202
    .quad     0x101010102
    .quad     0x202020202020100
    .quad     0x202020202020202
    .quad     0x202020202020202
    .quad     0x202020202020202
    .quad     0x101010303020202
    .quad     0x10101
    .quad     0x200000000000000
    .quad     0x101010101020202
    .quad     0x101010101000000
    .quad     0x10101010100
    .quad     0x102000000
    .quad     0
#ENDDATA
mc_decls.mclcodes:
    .quad     0
    .quad     0x9000
    .quad     0xC9C3E800000000
    .quad     0x5030205000000E9
    .quad     0x601040607000004
    .quad     0x201000507040700
    .quad     0x100020303
    .quad     0x5151ACA4BDBC0000
    .quad     0x5E5E59595C5C5858
    .quad     0xEF545457572E2F00
    .quad     0xDB
    .quad     0x302006263F36600
    .quad     0xFAF9C9E9C1030200
    .quad     0x5DE0E1F3F2FBFFFE
    .quad     0x5F5D5F
    .quad     0x804020100000000
    .quad     0xE3E3E2E1E0D7
    .quad     0xE8EE000000310000
    .quad     0xF4F400EDECEAE9EB
#ENDDATA
    .align    8
mc_decls.regnames:
    .quad     L7440
    .quad     L7441
    .quad     L7442
    .quad     L7443
    .quad     L7444
    .quad     L7445
    .quad     L7446
    .quad     L7447
    .quad     L7448
    .quad     L7449
    .quad     L7450
    .quad     L7451
    .quad     L7452
    .quad     L7453
    .quad     L7454
    .quad     L7455
    .quad     L7456
    .quad     L7457
    .quad     L7458
    .quad     L7459
    .quad     L7460
mc_decls.regcodes:
    .quad     0xC0603070B0A0000
    .quad     0x5090802010F0E0D
    .byte     4
    .byte     4
    .byte     7
    .byte     5
    .byte     6
#ENDDATA
    .align    8
mc_decls.condnames:
    .quad     L7461
    .quad     L7462
    .quad     L7463
    .quad     L7464
    .quad     L7465
    .quad     L7466
    .quad     L7467
    .quad     L7468
    .quad     L7469
    .quad     L7470
    .quad     L7471
    .quad     L7472
    .quad     L7473
    .quad     L7474
    .quad     L7475
    .quad     L7476
    .quad     L7477
    .quad     L7478
    .quad     L7479
    .quad     L7480
    .align    8
mc_decls.asmcondnames:
    .quad     L7481
    .quad     L7482
    .quad     L7483
    .quad     L7484
    .quad     L7485
    .quad     L7486
    .quad     L7487
    .quad     L7488
    .quad     L7489
    .quad     L7490
    .quad     L7491
    .quad     L7492
    .quad     L7493
    .quad     L7494
    .quad     L7495
    .quad     L7496
    .quad     L7497
    .quad     L7498
    .quad     L7499
    .quad     L7500
    .align    8
mc_decls.asmrevcond:
    .quad     1
    .quad     0
    .quad     3
    .quad     2
    .quad     5
    .quad     4
    .quad     7
    .quad     6
    .quad     9
    .quad     8
    .quad     0xB
    .quad     0xA
    .quad     0xD
    .quad     0xC
    .quad     0xF
    .quad     0xE
    .quad     0x11
    .quad     0x10
    .quad     0x13
    .quad     0x12
    .align    8
mc_decls.dregnames:
    .quad     L7501
    .quad     L7502
    .quad     L7503
    .quad     L7504
    .quad     L7505
    .quad     L7506
    .quad     L7507
    .quad     L7508
    .quad     L7509
    .quad     L7510
    .quad     L7511
    .quad     L7512
    .quad     L7513
    .quad     L7514
    .quad     L7515
    .quad     L7516
    .quad     L7517
    .quad     L7518
    .quad     L7519
    .quad     L7520
    .quad     L7521
    .quad     L7522
    .quad     L7523
    .quad     L7524
    .quad     L7525
    .quad     L7526
    .quad     L7527
    .quad     L7528
    .quad     L7529
    .quad     L7530
    .quad     L7531
    .quad     L7532
    .quad     L7533
    .quad     L7534
    .quad     L7535
    .quad     L7536
    .quad     L7537
    .quad     L7538
    .quad     L7539
    .quad     L7540
    .quad     L7541
    .quad     L7542
    .quad     L7543
    .quad     L7544
    .quad     L7545
    .quad     L7546
    .quad     L7547
    .quad     L7548
    .quad     L7549
    .quad     L7550
    .quad     L7551
    .quad     L7552
    .quad     L7553
    .quad     L7554
    .quad     L7555
    .quad     L7556
    .quad     L7557
    .quad     L7558
    .quad     L7559
    .quad     L7560
    .quad     L7561
    .quad     L7562
    .quad     L7563
    .quad     L7564
    .quad     L7565
    .quad     L7566
    .quad     L7567
    .quad     L7568
    .quad     L7569
    .quad     L7570
    .quad     L7571
    .quad     L7572
    .quad     L7573
    .quad     L7574
    .quad     L7575
    .quad     L7576
    .quad     L7577
    .quad     L7578
    .quad     L7579
    .quad     L7580
    .quad     L7581
    .quad     L7582
    .quad     L7583
    .quad     L7584
    .quad     L7585
    .quad     L7586
    .quad     L7587
    .quad     L7588
    .quad     L7589
    .quad     L7590
    .quad     L7591
    .quad     L7592
    .quad     L7593
    .quad     L7594
    .quad     L7595
    .quad     L7596
    .quad     L7597
    .quad     L7598
    .quad     L7599
    .quad     L7600
    .quad     L7601
    .quad     L7602
    .quad     L7603
    .quad     L7604
    .quad     L7605
    .quad     L7606
    .quad     L7607
    .quad     L7608
    .quad     L7609
    .quad     L7610
    .quad     L7611
    .quad     L7612
    .quad     L7613
    .quad     L7614
    .quad     L7615
    .quad     L7616
    .quad     L7617
    .quad     L7618
    .quad     L7619
    .quad     L7620
    .quad     L7621
    .quad     L7622
    .quad     L7623
    .quad     L7624
    .quad     L7625
    .quad     L7626
    .quad     L7627
    .quad     L7628
    .quad     L7629
    .quad     L7630
    .quad     L7631
    .quad     L7632
    .quad     L7633
    .quad     L7634
    .quad     L7635
    .quad     L7636
    .quad     L7637
mc_decls.regsizes:
    .quad     0x808080808080808
    .quad     0x808080808080808
    .quad     0x404040404040404
    .quad     0x404040404040404
    .quad     0x202020202020202
    .quad     0x202020202020202
    .quad     0x101010101010101
    .quad     0x101010101010101
    .quad     0x808080001010101
    .quad     0x808080808080808
    .quad     0x404040808080808
    .quad     0x404040404040404
    .quad     0x202020404040404
    .quad     0x202020202020202
    .quad     0x101010202020202
    .quad     0x101010101010101
    .quad     0x101010101010101
    .byte     1
#ENDDATA
mc_decls.regindices:
    .quad     0x807060504030201
    .quad     0x100F0E0D0C0B0A09
    .quad     0x807060504030201
    .quad     0x100F0E0D0C0B0A09
    .quad     0x807060504030201
    .quad     0x100F0E0D0C0B0A09
    .quad     0x807060504030201
    .quad     0x100F0E0D0C0B0A09
    .quad     0xB05010014131211
    .quad     0x20E0D100F04060C
    .quad     0xB05010A09080703
    .quad     0x20E0D100F04060C
    .quad     0xB05010A09080703
    .quad     0x20E0D100F04060C
    .quad     0xB05010A09080703
    .quad     0xF0406141312110C
    .quad     0x9080703020E0D10
    .byte     10
#ENDDATA
    .align    8
mc_decls.xmmregnames:
    .quad     L7638
    .quad     L7639
    .quad     L7640
    .quad     L7641
    .quad     L7642
    .quad     L7643
    .quad     L7644
    .quad     L7645
    .quad     L7646
    .quad     L7647
    .quad     L7648
    .quad     L7649
    .quad     L7650
    .quad     L7651
    .quad     L7652
    .quad     L7653
    .align    8
mc_decls.fregnames:
    .quad     L7654
    .quad     L7655
    .quad     L7656
    .quad     L7657
    .quad     L7658
    .quad     L7659
    .quad     L7660
    .quad     L7661
    .align    8
mc_decls.mregnames:
    .quad     L7662
    .quad     L7663
    .quad     L7664
    .quad     L7665
    .quad     L7666
    .quad     L7667
    .quad     L7668
    .quad     L7669
    .align    8
mc_decls.jmpccnames:
    .quad     L7670
    .quad     L7671
    .quad     L7672
    .quad     L7673
    .quad     L7674
    .quad     L7675
    .quad     L7676
    .quad     L7677
    .quad     L7678
    .quad     L7679
    .quad     L7680
    .quad     L7681
    .quad     L7682
    .quad     L7683
    .quad     L7684
    .quad     L7685
    .quad     L7686
    .quad     L7687
mc_decls.jmpcccodes:
    .quad     0x706050403020100
    .quad     0xF0E0D0C0B0A0908
    .byte     2
    .byte     3
#ENDDATA
    .align    8
mc_decls.setccnames:
    .quad     L7688
    .quad     L7689
    .quad     L7690
    .quad     L7691
    .quad     L7692
    .quad     L7693
    .quad     L7694
    .quad     L7695
    .quad     L7696
    .quad     L7697
    .quad     L7698
    .quad     L7699
    .quad     L7700
    .quad     L7701
    .quad     L7702
    .quad     L7703
mc_decls.setcccodes:
    .quad     0x706050403020100
    .quad     0xF0E0D0C0B0A0908
#ENDDATA
    .align    8
mc_decls.cmovccnames:
    .quad     L7704
    .quad     L7705
    .quad     L7706
    .quad     L7707
    .quad     L7708
    .quad     L7709
    .quad     L7710
    .quad     L7711
    .quad     L7712
    .quad     L7713
    .quad     L7714
    .quad     L7715
    .quad     L7716
    .quad     L7717
    .quad     L7718
    .quad     L7719
mc_decls.cmovcccodes:
    .quad     0x706050403020100
    .quad     0xF0E0D0C0B0A0908
#ENDDATA
    .align    8
mc_decls.segmentnames:
    .quad     L7720
    .quad     L7721
    .quad     L7722
    .quad     L7723
    .quad     L7724
    .quad     L7725
    .align    8
mc_decls.reftypenames:
    .quad     L7726
    .quad     L7727
    .quad     L7728
    .align    8
mc_decls.opndnames_ma:
    .quad     L7729
    .quad     L7730
    .quad     L7731
    .quad     L7732
    .quad     L7733
    .quad     L7734
    .bss
    .align    8
mc_decls.pclopnd:
    .space    400
mc_decls.pclreg:
    .space    50
mc_decls.pclmode:
    .space    50
mc_decls.pclcount:
    .space    50
mc_decls.pclloc:
    .space    50
mc_decls.pcltempflags:
    .space    50
    .align    8
mc_decls.pcltempopnds:
    .space    400
    .align    8
mc_decls.noperands:
    .space    8
    .align    8
mc_decls.mstackdepth:
    .space    8
    .data
    .align    8
mc_decls.locnames:
    .quad     L7735
    .quad     L7736
    .quad     L7737
    .quad     L7738
    .bss
mc_decls.workregs:
    .space    16
mc_decls.workxregs:
    .space    16
    .align    8
mc_decls.nworkregs:
    .space    8
    .align    8
mc_decls.nworkxregs:
    .space    8
    .align    8
mc_decls.nregvars:
    .space    8
    .align    8
mc_decls.nxregvars:
    .space    8
    .align    8
mc_decls.maxregvars:
    .space    8
    .align    8
mc_decls.maxxregvars:
    .space    8
    .align    8
mc_decls.xregmax:
    .space    8
mc_decls.regset:
    .space    16
mc_decls.xregset:
    .space    16
mc_decls.isregvar:
    .space    16
mc_decls.isxregvar:
    .space    16
mc_decls.usedregs:
    .space    16
mc_decls.usedxregs:
    .space    16
mc_decls.noxorclear:
    .space    1
    .data
    .align    8
mc_decls.xregnames:
    .quad     L7739
    .quad     L7740
    .quad     L7741
    .quad     L7742
    .quad     L7743
    .quad     L7744
    .quad     L7745
    .quad     L7746
    .quad     L7747
    .quad     L7748
    .quad     L7749
    .quad     L7750
    .quad     L7751
    .quad     L7752
    .quad     L7753
    .quad     L7754
    .quad     L7754
    .bss
mc_decls.callalign:
    .space    16
mc_decls.callblockret:
    .space    16
    .align    4
mc_decls.callblocksize:
    .space    64
mc_decls.callargmode:
    .space    512
    .align    4
mc_decls.callargsize:
    .space    2048
    .align    8
mc_decls.ncalldepth:
    .space    8
    .align    8
mc_decls.lababs32:
    .space    8
    .align    8
mc_decls.lababs64:
    .space    8
    .align    8
mc_decls.labneg32:
    .space    8
    .align    8
mc_decls.labneg64:
    .space    8
    .align    8
mc_decls.labmask63:
    .space    8
    .align    8
mc_decls.laboffset64:
    .space    8
    .align    8
mc_decls.labzero:
    .space    8
    .data
    .align    8
mc_decls.kk0used:
    .quad     0
    .bss
    .align    8
mc_decls.mccode:
    .space    8
    .align    8
mc_decls.mccodex:
    .space    8
    .data
    .align    8
mc_decls.currsegment:
    .quad     0
    .bss
    .align    8
mc_decls.dstackopnd:
    .space    8
    .align    8
mc_decls.dframeopnd:
    .space    8
    .align    8
mc_decls.regtable:
    .space    1024
    .align    8
mc_decls.frameregtable:
    .space    1544
    .align    8
mc_decls.cstringlist:
    .space    8
    .align    8
mc_decls.vstringlist:
    .space    8
    .align    8
mc_decls.creallist:
    .space    8
    .align    8
mc_decls.cr32list:
    .space    8
    .align    8
mc_decls.currasmproc:
    .space    8
    .align    8
mc_decls.lab_funcnametable:
    .space    8
    .align    8
mc_decls.lab_funcaddrtable:
    .space    8
    .align    8
mc_decls.lab_funcnprocs:
    .space    8
    .align    8
mc_decls.ss_zdatalen:
    .space    8
    .align    8
mc_decls.ss_zdata:
    .space    8
    .align    8
mc_decls.ss_idata:
    .space    8
    .align    8
mc_decls.ss_code:
    .space    8
    .align    8
mc_decls.ss_idatarelocs:
    .space    8
    .align    8
mc_decls.ss_coderelocs:
    .space    8
    .align    8
mc_decls.ss_nidatarelocs:
    .space    8
    .align    8
mc_decls.ss_ncoderelocs:
    .space    8
    .align    8
mc_decls.ss_symboltable:
    .space    8
    .align    8
mc_decls.ss_nsymbols:
    .space    8
    .align    8
mc_decls.ss_symboltablesize:
    .space    8
    .align    8
mc_decls.labeldeftable:
    .space    8
    .align    8
mc_decls.aaseqno:
    .space    8
    .align    8
mc_decls.aapos:
    .space    8
    .data
mc_decls.regmodes:
    .quad     0x600000005000403
#ENDDATA
    .bss
mc_decls.pmode:
    .space    1
    .align    8
mc_decls.currpcl:
    .space    8
    .align    8
mc_decls.mclprocentry:
    .space    8
    .align    8
mc_decls.mce_oldmccodex:
    .space    8
    .align    8
mc_decls.mce_lastmcl:
    .space    8
    .align    8
mc_decls.mce_nextmcl:
    .space    8
    .align    8
mc_decls.mcf_oldmccodex:
    .space    8
    .align    8
mc_decls.mcf_lastmcl:
    .space    8
    .align    8
mc_decls.mcf_nextmcl:
    .space    8
mc_decls.fpcheckunusedlocals:
    .space    1
    .align    8
mc_decls.riplist:
    .space    8
    .align    8
mc_decls.blockdefs:
    .space    400
    .align    8
mc_decls.nblocktemps:
    .space    8
    .data
    .align    8
mc_decls.multregs:
    .quad     1
    .quad     2
    .quad     3
    .quad     0xB
    .quad     0xC
    .quad     0xD
    .align    8
mc_decls.multxregs:
    .quad     1
    .quad     2
    .quad     3
    .quad     4
    .quad     5
    .quad     6
    .bss
mc_decls.ploadopx:
    .space    14
mc_decls.ploadop:
    .space    14
    .data
    .align    8
mc_objdecls.relocnames:
    .quad     L7755
    .quad     L7756
    .quad     L7757
    .quad     L7758
    .quad     L7759
    .quad     L7760
    .quad     L7761
    .align    8
mc_writegas.asmext:
    .quad     L7762
    .bss
    .align    8
mc_writegas.nregnames:
    .space    1024
mc_writegas.currseg:
    .space    1
mc_writegas.strmcl.str:
    .space    512
mc_writegas.mstropnd.str:
    .space    512
mc_writegas.strvalue.str:
    .space    512
mc_writegas.getxregname.str:
    .space    32
mc_writegas.getdispname.str:
    .space    256
mc_writegas.gettempname.str:
    .space    128
mc_writegas.strreg.str:
    .space    16
    .data
    .align    8
cc_cli.passnames:
    .quad     L7763
    .quad     L7764
    .quad     L7765
    .quad     L7766
    .quad     L7767
    .quad     L7768
    .quad     L7769
    .quad     L7770
    .quad     L7771
    .quad     L7772
    .quad     L7773
    .quad     L7774
    .quad     L7775
    .align    8
cc_cli.extnames:
    .quad     L7776
    .quad     L7777
    .quad     L7778
    .quad     L7778
    .quad     L7779
    .quad     L7780
    .quad     L7781
    .quad     L7781
    .quad     L7782
    .quad     L7783
    .quad     L7784
    .quad     L7785
    .quad     L7786
    .bss
cc_cli.cc_pass:
    .space    1
cc_cli.dummy:
    .space    20
cc_cli.debugmode:
    .space    1
    .align    8
cc_cli.outfile:
    .space    8
    .data
    .align    8
cc_cli.outext:
    .quad     L7787
    .bss
    .align    8
cc_cli.cmdskip:
    .space    8
    .align    8
cc_cli.ttt:
    .space    8
    .data
cc_cli.fverbose:
    .byte     1
cc_cli.fshowincludes:
    .byte     0
cc_cli.dointheaders:
    .byte     1
cc_cli.highmem:
    .byte     1
    .bss
cc_cli.fshowst:
    .space    1
cc_cli.fshowstflat:
    .space    1
cc_cli.fshowast:
    .space    1
cc_cli.fshowpcl:
    .space    1
cc_cli.fshowpst:
    .space    1
cc_cli.fshowmcl:
    .space    1
cc_cli.fshowss:
    .space    1
cc_cli.fshowtypes:
    .space    1
cc_cli.fshowfiles:
    .space    1
cc_cli.fshowpaths:
    .space    1
cc_cli.fshowheaders:
    .space    1
cc_cli.fwriteheaders:
    .space    1
cc_cli.fshowlog:
    .space    1
cc_cli.fshowtiming:
    .space    1
cc_cli.fgendll:
    .space    1
cc_cli.fstdout:
    .space    1
cc_cli.fshortnames:
    .space    1
    .data
cc_cli.fwriteerrors:
    .byte     1
    .bss
    .align    8
cc_cli.entrypointname:
    .space    8
    .data
    .align    8
cc_cli.optionnames:
    .quad     L7788
    .quad     L7789
    .quad     L7790
    .quad     L7791
    .quad     L7792
    .quad     L7793
    .quad     L7794
    .quad     L7795
    .quad     L7796
    .quad     L7797
    .quad     L7798
    .quad     L7799
    .quad     L7800
    .quad     L7801
    .quad     L7802
    .quad     L7803
    .quad     L7804
    .quad     L7805
    .quad     L7806
    .quad     L7807
    .quad     L7808
    .quad     L7809
    .quad     L7810
    .quad     L7811
    .quad     L7812
    .quad     L7813
    .quad     L7814
    .quad     L7815
    .quad     L7816
    .quad     L7817
    .quad     L7818
    .quad     L7819
    .quad     L7820
    .quad     L7821
    .quad     L7822
    .quad     L7823
    .quad     L7824
    .quad     L7825
    .quad     L7826
    .quad     L7827
    .quad     L7828
    .quad     L7829
    .quad     L7830
    .quad     L7831
    .quad     L7832
    .quad     L7833
    .quad     L7834
    .quad     L7835
    .quad     L7836
    .quad     L7837
    .quad     L7838
    .quad     L7839
    .quad     L7840
    .align    8
cc_cli.optvars:
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     pc_decls.fregoptim
    .quad     pc_decls.fpeephole
    .quad     0
    .quad     pc_decls.fnoconst
    .quad     cc_cli.fshowpaths
    .quad     cc_cli.fshowheaders
    .quad     0
    .quad     cc_cli.fshowincludes
    .quad     cc_cli.fshowst
    .quad     cc_cli.fshowstflat
    .quad     cc_cli.fshowast
    .quad     cc_cli.fshowpcl
    .quad     cc_cli.fshowpst
    .quad     cc_cli.fshowmcl
    .quad     cc_cli.fshowss
    .quad     cc_cli.fshowtypes
    .quad     cc_cli.fshowfiles
    .quad     cc_cli.fshowtiming
    .quad     cc_cli.fshowtiming
    .quad     cc_cli.fverbose
    .quad     cc_cli.fverbose
    .quad     cc_cli.fverbose
    .quad     pc_decls.pverbose
    .quad     pc_decls.pverbose
    .quad     0
    .quad     0
    .quad     cc_cli.dointheaders
    .quad     cc_cli.fwriteheaders
    .quad     0
    .quad     cc_cli.fstdout
    .quad     cc_cli.fshortnames
    .quad     cc_cli.highmem
    .quad     cc_cli.highmem
    .quad     0
    .quad     pc_decls.fshowil
    .quad     pc_decls.flong64
cc_cli.optvalues:
    .quad     0x605050403020201
    .quad     0xC0B090A0A080807
    .quad     0x10101010000000D
    .quad     0x101010101010101
    .quad     0x100030202010101
    .quad     0x101000100000002
    .byte     0
    .byte     2
    .byte     0
    .byte     1
    .byte     1
#ENDDATA
    .align    8
cc_cli.totallines:
    .quad     0
    .align    8
cc_cli.nstringobjects:
    .quad     0
    .bss
    .align    8
cc_cli.startclock:
    .space    8
    .align    8
cc_cli.loadtime:
    .space    8
    .align    8
cc_cli.parsetime:
    .space    8
    .align    8
cc_cli.pcltime:
    .space    8
    .align    8
cc_cli.compiletime:
    .space    8
    .align    8
cc_cli.inittime:
    .space    8
    .data
    .align    8
cc_cli.showextrainfo.infotext:
    .quad     L7841
    .bss
    .align    8
cc_decls.ntypes:
    .space    8
    .align    8
cc_decls.ttnamedef:
    .space    640000
    .align    2
cc_decls.ttbasetype:
    .space    160000
    .align    8
cc_decls.ttlength:
    .space    640000
cc_decls.ttconst:
    .space    80000
    .align    2
cc_decls.tttarget:
    .space    160000
    .align    2
cc_decls.ttreftype:
    .space    160000
    .align    2
cc_decls.ttconsttype:
    .space    160000
    .align    8
cc_decls.ttsize:
    .space    640000
cc_decls.ttisref:
    .space    80000
cc_decls.ttisblock:
    .space    80000
cc_decls.ttsigned:
    .space    80000
    .align    4
cc_decls.ttshared:
    .space    320000
    .align    8
cc_decls.ttparams:
    .space    640000
    .align    8
cc_decls.tttypedef:
    .space    640000
    .align    8
cc_decls.trefchar:
    .space    8
    .align    8
cc_decls.trefwchar:
    .space    8
    .align    8
cc_decls.inputfile:
    .space    8
    .align    8
cc_decls.mainfileno:
    .space    8
    .align    8
cc_decls.libfiles:
    .space    1608
    .align    8
cc_decls.sourcefilenames:
    .space    1608
    .align    8
cc_decls.sourcefilepaths:
    .space    1608
    .align    8
cc_decls.sourcefiletext:
    .space    1608
    .align    4
cc_decls.sourcefilesizes:
    .space    804
    .align    8
cc_decls.nsourcefiles:
    .space    8
    .align    8
cc_decls.nlibfiles:
    .space    8
    .align    8
cc_decls.searchdirs:
    .space    160
    .data
    .align    8
cc_decls.nsearchdirs:
    .quad     0
    .bss
    .align    8
cc_decls.includepaths:
    .space    160
    .data
    .align    8
cc_decls.nincludepaths:
    .quad     0
    .bss
    .align    8
cc_decls.stprogram:
    .space    8
    .align    8
cc_decls.stmodule:
    .space    8
    .align    8
cc_decls.logdev:
    .space    8
    .align    8
cc_decls.nullunit:
    .space    8
    .data
    .align    8
cc_decls.clineno:
    .quad     0
    .align    8
cc_decls.cfileno:
    .quad     0
    .bss
    .align    8
cc_decls.lx:
    .space    32
    .align    8
cc_decls.nextlx:
    .space    32
    .data
    .align    8
cc_decls.debug:
    .quad     0
    .align    8
cc_decls.hstsize:
    .quad     0x10000
    .bss
    .align    8
cc_decls.hstmask:
    .space    8
    .align    8
cc_decls.hashtable:
    .space    8
    .align    4
cc_decls.blockowner:
    .space    8404
    .align    4
cc_decls.blockcounts:
    .space    8404
    .align    4
cc_decls.blockstack:
    .space    404
    .align    8
cc_decls.currblockno:
    .space    8
    .align    8
cc_decls.nextblockno:
    .space    8
    .align    8
cc_decls.blocklevel:
    .space    8
    .align    8
cc_decls.currproc:
    .space    8
    .data
    .align    8
cc_decls.dheaderfile:
    .quad     0
    .align    8
cc_decls.structpadding:
    .quad     1
    .align    8
cc_decls.callbackflag:
    .quad     0
    .bss
    .align    8
cc_decls.slineno:
    .space    8
    .align    8
cc_decls.sfileno:
    .space    8
    .data
    .align    8
cc_decls.oemname:
    .quad     L7842
    .bss
    .align    8
cc_decls.mclstr:
    .space    8
    .align    8
cc_decls.mclstrlen:
    .space    8
    .align    8
cc_decls.nunits:
    .space    8
    .align    8
cc_decls.pmodulelist:
    .space    1592
    .align    8
cc_decls.pheaderlist:
    .space    800
    .align    8
cc_decls.pliblist:
    .space    800
    .align    8
cc_decls.npmodules:
    .space    8
    .align    8
cc_decls.npheaders:
    .space    8
    .align    8
cc_decls.nplibs:
    .space    8
cc_decls.pci_target:
    .space    1
    .data
    .align    8
cc_tables.stdtypenames:
    .quad     L7843
    .quad     L7844
    .quad     L7845
    .quad     L7846
    .quad     L7847
    .quad     L7848
    .quad     L7849
    .quad     L7850
    .quad     L7851
    .quad     L7852
    .quad     L7853
    .quad     L7854
    .quad     L7855
    .quad     L7856
    .quad     L7857
    .quad     L7858
    .quad     L7859
    .quad     L7860
    .quad     L7861
    .quad     L7862
    .quad     L7863
    .quad     L7864
cc_tables.stdtypewidths:
    .quad     0x1008084020100800
    .quad     0x4040400040204020
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
#ENDDATA
cc_tables.stdsigned:
    .quad     0x101010100
    .quad     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
#ENDDATA
cc_tables.stdpcl:
    .quad     0x403030A09080700
    .quad     0x60902010605
    .byte     11
    .byte     11
    .byte     11
    .byte     11
    .byte     0
    .byte     0
#ENDDATA
cc_tables.stdsize:
    .quad     0x201010804020100
    .quad     0x8040804
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
#ENDDATA
    .align    8
cc_tables.catnames:
    .quad     L7865
    .quad     L7866
    .quad     L7867
    .quad     L7868
    .quad     L7869
    .align    8
cc_tables.typespecnames:
    .quad     L7870
    .quad     L7871
    .quad     L7872
    .quad     L7873
    .quad     L7874
    .quad     L7875
    .quad     L7876
    .quad     L7877
    .quad     L7878
    .quad     L7879
    .quad     L7880
    .quad     L7881
    .quad     L7882
    .quad     L7883
    .quad     L7884
    .align    4
cc_tables.typespectypes:
    .long     0
    .long     1
    .long     0
    .long     0
    .long     3
    .long     10
    .long     11
    .long     0
    .long     0
    .long     5
    .long     0
    .long     0
    .long     0
    .long     0
    .long     0
cc_tables.typespecsizes:
    .quad     0x8040404020100
    .byte     0
    .byte     1
    .byte     0
    .byte     0
    .byte     0
    .byte     4
    .byte     0
#ENDDATA
    .align    8
cc_tables.pmflagnames:
    .quad     L7885
    .quad     L7886
    .quad     L7887
    .quad     L7888
    .align    8
cc_tables.scopenames:
    .quad     L7889
    .quad     L7890
    .quad     L7891
    .quad     L7892
    .quad     L7893
    .align    8
cc_tables.cccnames:
    .quad     L7894
    .quad     L7895
    .quad     L7896
    .quad     L7897
    .quad     L7898
    .quad     L7899
    .align    8
cc_tables.linkagenames:
    .quad     L7900
    .quad     L7901
    .quad     L7902
    .quad     L7903
    .quad     L7904
    .quad     L7905
    .align    8
cc_tables.typequalnames:
    .quad     L7906
    .quad     L7907
    .quad     L7908
    .quad     L7909
    .align    8
cc_tables.fnspecnames:
    .quad     L7910
    .quad     L7911
    .quad     L7912
    .align    8
cc_tables.jtagnames:
    .quad     L7913
    .quad     L7914
    .quad     L7915
    .quad     L7916
    .quad     L7917
    .quad     L7918
    .quad     L7919
    .quad     L7920
    .quad     L7921
    .quad     L7922
    .quad     L7923
    .quad     L7924
    .quad     L7925
    .quad     L7926
    .quad     L7927
    .quad     L7928
    .quad     L7929
    .quad     L7930
    .quad     L7931
    .quad     L7932
    .quad     L7933
    .quad     L7934
    .quad     L7935
    .quad     L7936
    .quad     L7937
    .quad     L7938
    .quad     L7939
    .quad     L7940
    .quad     L7941
    .quad     L7942
    .quad     L7943
    .quad     L7944
    .quad     L7945
    .quad     L7946
    .quad     L7947
    .quad     L7948
    .quad     L7949
    .quad     L7950
    .quad     L7951
    .quad     L7952
    .quad     L7953
    .quad     L7954
    .quad     L7955
    .quad     L7956
    .quad     L7957
    .quad     L7958
    .quad     L7959
    .quad     L7960
    .quad     L7961
    .quad     L7962
    .quad     L7963
    .quad     L7964
    .quad     L7965
    .quad     L7966
    .quad     L7967
    .quad     L7968
    .quad     L7969
    .quad     L7970
    .quad     L7971
    .quad     L7972
    .quad     L7973
    .quad     L7974
    .quad     L7975
    .quad     L7976
    .quad     L7977
    .quad     L7978
    .quad     L7979
    .quad     L7980
    .quad     L7981
    .quad     L7982
    .quad     L7983
    .quad     L7984
    .quad     L7985
    .quad     L7986
    .quad     L7987
    .quad     L7988
    .quad     L7989
    .quad     L7990
    .align    8
cc_tables.symbolnames:
    .quad     L7991
    .quad     L7992
    .quad     L7993
    .quad     L7994
    .quad     L7995
    .quad     L7996
    .quad     L7997
    .quad     L7998
    .quad     L7999
    .quad     L8000
    .quad     L8001
    .quad     L8002
    .quad     L8003
    .quad     L8004
    .quad     L8005
    .quad     L8006
    .quad     L8007
    .quad     L8008
    .quad     L8009
    .quad     L8010
    .quad     L8011
    .quad     L8012
    .quad     L8013
    .quad     L8014
    .quad     L8015
    .quad     L8016
    .quad     L8017
    .quad     L8018
    .quad     L8019
    .quad     L8020
    .quad     L8021
    .quad     L8022
    .quad     L8023
    .quad     L8024
    .quad     L8025
    .quad     L8026
    .quad     L8027
    .quad     L8028
    .quad     L8029
    .quad     L8030
    .quad     L8031
    .quad     L8032
    .quad     L8033
    .quad     L8034
    .quad     L8035
    .quad     L8036
    .quad     L8037
    .quad     L8038
    .quad     L8039
    .quad     L8040
    .quad     L8041
    .quad     L8042
    .quad     L8043
    .quad     L8044
    .quad     L8045
    .quad     L8046
    .quad     L8047
    .quad     L8048
    .quad     L8049
    .quad     L8050
    .quad     L8051
    .quad     L8052
    .quad     L8053
    .quad     L8054
    .quad     L8055
    .quad     L8056
    .quad     L8057
    .quad     L8058
    .quad     L8059
    .quad     L8060
    .quad     L8061
    .quad     L8062
    .quad     L8063
    .quad     L8064
    .quad     L8065
    .quad     L8066
    .quad     L8067
    .quad     L8068
    .quad     L8069
    .quad     L8070
    .quad     L8071
    .quad     L8072
    .quad     L8073
    .quad     L8074
    .quad     L8075
    .quad     L8076
    .quad     L8077
    .quad     L8078
    .quad     L8079
    .quad     L8080
    .quad     L8081
    .quad     L8082
    .quad     L8083
    .quad     L8084
    .quad     L8085
    .quad     L8086
    .quad     L8087
    .align    8
cc_tables.shortsymbolnames:
    .quad     L8088
    .quad     L8089
    .quad     L8090
    .quad     L8091
    .quad     L8091
    .quad     L8091
    .quad     L8092
    .quad     L8093
    .quad     L8094
    .quad     L8095
    .quad     L8096
    .quad     L8097
    .quad     L8098
    .quad     L8099
    .quad     L8100
    .quad     L8101
    .quad     L8102
    .quad     L8103
    .quad     L8104
    .quad     L8105
    .quad     L8106
    .quad     L8107
    .quad     L8108
    .quad     L8109
    .quad     L8110
    .quad     L8111
    .quad     L8112
    .quad     L8113
    .quad     L8114
    .quad     L8115
    .quad     L8116
    .quad     L8117
    .quad     L8118
    .quad     L8119
    .quad     L8120
    .quad     L8121
    .quad     L8122
    .quad     L8123
    .quad     L8124
    .quad     L8125
    .quad     L8126
    .quad     L8127
    .quad     L8128
    .quad     L8129
    .quad     L8130
    .quad     L8131
    .quad     L8132
    .quad     L8133
    .quad     L8134
    .quad     L8135
    .quad     L8136
    .quad     L8137
    .quad     L8138
    .quad     L8139
    .quad     L8140
    .quad     L8141
    .quad     L8141
    .quad     L8142
    .quad     L8142
    .quad     L8142
    .quad     L8143
    .quad     L8143
    .quad     L8143
    .quad     L8143
    .quad     L8144
    .quad     L8145
    .quad     L8146
    .quad     L8146
    .quad     L8146
    .quad     L8146
    .quad     L8146
    .quad     L8146
    .quad     L8146
    .quad     L8146
    .quad     L8146
    .quad     L8146
    .quad     L8146
    .quad     L8146
    .quad     L8146
    .quad     L8146
    .quad     L8146
    .quad     L8146
    .quad     L8146
    .quad     L8146
    .quad     L8146
    .quad     L8146
    .quad     L8146
    .quad     L8146
    .quad     L8146
    .quad     L8146
    .quad     L8146
    .quad     L8146
    .quad     L8146
    .quad     L8146
    .quad     L8146
    .quad     L8146
    .quad     L8147
cc_tables.symboltojtag:
    .quad     0x323100
    .quad     0xB0B0000
    .quad     0x2827000000000000
    .quad     0x18192E2C2D2B2A29
    .quad     0x213B48471A3C302F
    .quad     0x3F3E3D2526242322
    .quad     0x46454442434140
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .byte     0
#ENDDATA
    .align    8
cc_tables.sourcedirnames:
    .quad     L8148
    .quad     L8149
    .quad     L8150
    .quad     L8151
    .quad     L8152
    .quad     L8153
    .quad     L8154
    .quad     L8155
    .quad     L8156
    .quad     L8157
    .quad     L8158
    .quad     L8159
    .quad     L8160
    .quad     L8161
    .quad     L8162
    .align    8
cc_tables.namespacenames:
    .quad     L8163
    .quad     L8164
    .quad     L8165
    .quad     L8166
    .quad     L8167
    .align    8
cc_tables.namenames:
    .quad     L8168
    .quad     L8169
    .quad     L8170
    .quad     L8171
    .quad     L8172
    .quad     L8173
    .quad     L8174
    .quad     L8175
    .quad     L8176
    .quad     L8177
    .quad     L8178
    .quad     L8179
    .quad     L8180
    .quad     L8181
    .quad     L8182
    .align    4
cc_tables.namespaces:
    .long     0
    .long     0
    .long     0
    .long     0
    .long     0
    .long     1
    .long     1
    .long     1
    .long     1
    .long     1
    .long     4
    .long     1
    .long     2
    .long     2
    .long     3
cc_tables.name2pid:
    .quad     0x302000000000000
    .byte     4
    .byte     5
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     6
#ENDDATA
    .align    8
cc_tables.stnames:
    .quad     L8183
    .quad     L8184
    .quad     L8185
    .quad     L8186
    .quad     L8187
    .quad     L8188
    .quad     L8189
    .quad     L8190
    .quad     L8191
    .quad     L8192
    .quad     L8193
    .quad     L8194
    .quad     L8195
    .quad     L8196
    .quad     L8197
    .quad     L8198
    .quad     L8199
    .quad     L8200
    .quad     L8201
    .quad     L8202
    .quad     L8203
    .quad     L8204
    .quad     L8205
    .quad     L8206
    .quad     L8207
    .quad     L8208
    .quad     L8209
    .quad     L8210
    .quad     L8211
    .quad     L8212
    .quad     L8213
    .quad     L8214
    .quad     L8215
    .quad     L8216
    .quad     L8217
    .quad     L8218
    .quad     L8219
    .quad     L8220
    .quad     L8221
    .quad     L8222
    .quad     L8223
    .quad     L8224
    .quad     L8225
    .quad     L8226
    .quad     L8227
    .quad     L8228
    .quad     L8229
    .quad     L8230
    .quad     L8231
    .quad     L8232
    .quad     L8233
    .quad     L8234
    .quad     L8235
    .quad     L8236
    .quad     L8237
    .quad     L8238
    .quad     L8239
    .quad     L8240
    .quad     L8241
    .quad     L8242
    .quad     L8243
    .quad     L8244
    .quad     L8245
    .quad     L8246
    .align    4
cc_tables.stsymbols:
    .long     72
    .long     73
    .long     74
    .long     75
    .long     76
    .long     78
    .long     77
    .long     79
    .long     80
    .long     81
    .long     82
    .long     83
    .long     84
    .long     85
    .long     68
    .long     68
    .long     68
    .long     68
    .long     68
    .long     68
    .long     68
    .long     68
    .long     68
    .long     68
    .long     86
    .long     86
    .long     86
    .long     86
    .long     86
    .long     87
    .long     87
    .long     87
    .long     87
    .long     89
    .long     89
    .long     90
    .long     91
    .long     71
    .long     71
    .long     71
    .long     71
    .long     71
    .long     71
    .long     71
    .long     71
    .long     71
    .long     71
    .long     69
    .long     69
    .long     69
    .long     69
    .long     69
    .long     69
    .long     69
    .long     69
    .long     70
    .long     92
    .long     92
    .long     93
    .long     94
    .long     95
    .long     96
    .long     96
    .long     0
    .align    4
cc_tables.stsubcodes:
    .long     12
    .long     0
    .long     0
    .long     0
    .long     0
    .long     0
    .long     0
    .long     0
    .long     0
    .long     0
    .long     0
    .long     0
    .long     0
    .long     0
    .long     7
    .long     1
    .long     4
    .long     8
    .long     9
    .long     6
    .long     10
    .long     11
    .long     15
    .long     14
    .long     2
    .long     3
    .long     1
    .long     4
    .long     5
    .long     1
    .long     2
    .long     3
    .long     4
    .long     1
    .long     2
    .long     0
    .long     0
    .long     1
    .long     2
    .long     3
    .long     4
    .long     5
    .long     6
    .long     7
    .long     8
    .long     9
    .long     10
    .long     1
    .long     3
    .long     4
    .long     2
    .long     7
    .long     8
    .long     5
    .long     5
    .long     0
    .long     0
    .long     1
    .long     0
    .long     0
    .long     0
    .long     75
    .long     76
    .long     0
    .align    8
cc_tables.convnames:
    .quad     L8247
    .quad     L8248
    .quad     L8249
    .quad     L8250
    .quad     L8251
    .quad     L8252
    .quad     L8253
    .quad     L8254
    .quad     L8255
    .quad     L8256
    .quad     L8257
    .quad     L8258
    .quad     L8259
    .quad     L8260
    .bss
cc_tables.dominantmode:
    .space    1024
cc_tables.conversionops:
    .space    256
    .data
cc_tables.dominantsetuptable:
    .byte     1
    .byte     1
    .byte     3
#ENDDATA
    .byte     1
    .byte     2
    .byte     3
#ENDDATA
    .byte     1
    .byte     3
    .byte     3
#ENDDATA
    .byte     1
    .byte     4
    .byte     4
#ENDDATA
    .byte     1
    .byte     5
    .byte     3
#ENDDATA
    .byte     1
    .byte     6
    .byte     3
#ENDDATA
    .byte     1
    .byte     7
    .byte     3
#ENDDATA
    .byte     1
    .byte     8
    .byte     3
#ENDDATA
    .byte     1
    .byte     9
    .byte     4
#ENDDATA
    .byte     1
    .byte     10
    .byte     10
#ENDDATA
    .byte     1
    .byte     11
    .byte     11
#ENDDATA
    .byte     2
    .byte     1
    .byte     3
#ENDDATA
    .byte     2
    .byte     2
    .byte     3
#ENDDATA
    .byte     2
    .byte     3
    .byte     3
#ENDDATA
    .byte     2
    .byte     4
    .byte     4
#ENDDATA
    .byte     2
    .byte     5
    .byte     3
#ENDDATA
    .byte     2
    .byte     6
    .byte     3
#ENDDATA
    .byte     2
    .byte     7
    .byte     3
#ENDDATA
    .byte     2
    .byte     8
    .byte     3
#ENDDATA
    .byte     2
    .byte     9
    .byte     4
#ENDDATA
    .byte     2
    .byte     10
    .byte     10
#ENDDATA
    .byte     2
    .byte     11
    .byte     11
#ENDDATA
    .byte     3
    .byte     1
    .byte     3
#ENDDATA
    .byte     3
    .byte     2
    .byte     3
#ENDDATA
    .byte     3
    .byte     3
    .byte     3
#ENDDATA
    .byte     3
    .byte     4
    .byte     4
#ENDDATA
    .byte     3
    .byte     5
    .byte     3
#ENDDATA
    .byte     3
    .byte     6
    .byte     3
#ENDDATA
    .byte     3
    .byte     7
    .byte     3
#ENDDATA
    .byte     3
    .byte     8
    .byte     8
#ENDDATA
    .byte     3
    .byte     9
    .byte     4
#ENDDATA
    .byte     3
    .byte     10
    .byte     10
#ENDDATA
    .byte     3
    .byte     11
    .byte     11
#ENDDATA
    .byte     4
    .byte     1
    .byte     4
#ENDDATA
    .byte     4
    .byte     2
    .byte     4
#ENDDATA
    .byte     4
    .byte     3
    .byte     4
#ENDDATA
    .byte     4
    .byte     4
    .byte     4
#ENDDATA
    .byte     4
    .byte     5
    .byte     4
#ENDDATA
    .byte     4
    .byte     6
    .byte     4
#ENDDATA
    .byte     4
    .byte     7
    .byte     4
#ENDDATA
    .byte     4
    .byte     8
    .byte     4
#ENDDATA
    .byte     4
    .byte     9
    .byte     9
#ENDDATA
    .byte     4
    .byte     10
    .byte     10
#ENDDATA
    .byte     4
    .byte     11
    .byte     11
#ENDDATA
    .byte     5
    .byte     1
    .byte     3
#ENDDATA
    .byte     5
    .byte     2
    .byte     3
#ENDDATA
    .byte     5
    .byte     3
    .byte     3
#ENDDATA
    .byte     5
    .byte     4
    .byte     4
#ENDDATA
    .byte     5
    .byte     5
    .byte     8
#ENDDATA
    .byte     5
    .byte     6
    .byte     8
#ENDDATA
    .byte     5
    .byte     7
    .byte     8
#ENDDATA
    .byte     5
    .byte     8
    .byte     8
#ENDDATA
    .byte     5
    .byte     9
    .byte     9
#ENDDATA
    .byte     5
    .byte     10
    .byte     10
#ENDDATA
    .byte     5
    .byte     11
    .byte     11
#ENDDATA
    .byte     6
    .byte     1
    .byte     3
#ENDDATA
    .byte     6
    .byte     2
    .byte     3
#ENDDATA
    .byte     6
    .byte     3
    .byte     3
#ENDDATA
    .byte     6
    .byte     4
    .byte     4
#ENDDATA
    .byte     6
    .byte     5
    .byte     0
#ENDDATA
    .byte     6
    .byte     6
    .byte     8
#ENDDATA
    .byte     6
    .byte     7
    .byte     8
#ENDDATA
    .byte     6
    .byte     8
    .byte     8
#ENDDATA
    .byte     6
    .byte     9
    .byte     9
#ENDDATA
    .byte     6
    .byte     10
    .byte     10
#ENDDATA
    .byte     6
    .byte     11
    .byte     11
#ENDDATA
    .byte     7
    .byte     1
    .byte     3
#ENDDATA
    .byte     7
    .byte     2
    .byte     3
#ENDDATA
    .byte     7
    .byte     3
    .byte     3
#ENDDATA
    .byte     7
    .byte     4
    .byte     4
#ENDDATA
    .byte     7
    .byte     5
    .byte     8
#ENDDATA
    .byte     7
    .byte     6
    .byte     8
#ENDDATA
    .byte     7
    .byte     7
    .byte     8
#ENDDATA
    .byte     7
    .byte     8
    .byte     8
#ENDDATA
    .byte     7
    .byte     9
    .byte     9
#ENDDATA
    .byte     7
    .byte     10
    .byte     10
#ENDDATA
    .byte     7
    .byte     11
    .byte     11
#ENDDATA
    .byte     8
    .byte     1
    .byte     3
#ENDDATA
    .byte     8
    .byte     2
    .byte     3
#ENDDATA
    .byte     8
    .byte     3
    .byte     8
#ENDDATA
    .byte     8
    .byte     4
    .byte     4
#ENDDATA
    .byte     8
    .byte     5
    .byte     8
#ENDDATA
    .byte     8
    .byte     6
    .byte     8
#ENDDATA
    .byte     8
    .byte     7
    .byte     8
#ENDDATA
    .byte     8
    .byte     8
    .byte     8
#ENDDATA
    .byte     8
    .byte     9
    .byte     9
#ENDDATA
    .byte     8
    .byte     10
    .byte     10
#ENDDATA
    .byte     8
    .byte     11
    .byte     11
#ENDDATA
    .byte     9
    .byte     1
    .byte     9
#ENDDATA
    .byte     9
    .byte     2
    .byte     9
#ENDDATA
    .byte     9
    .byte     3
    .byte     9
#ENDDATA
    .byte     9
    .byte     4
    .byte     9
#ENDDATA
    .byte     9
    .byte     5
    .byte     9
#ENDDATA
    .byte     9
    .byte     6
    .byte     9
#ENDDATA
    .byte     9
    .byte     7
    .byte     9
#ENDDATA
    .byte     9
    .byte     8
    .byte     9
#ENDDATA
    .byte     9
    .byte     9
    .byte     9
#ENDDATA
    .byte     9
    .byte     10
    .byte     10
#ENDDATA
    .byte     9
    .byte     11
    .byte     11
#ENDDATA
    .byte     10
    .byte     1
    .byte     11
#ENDDATA
    .byte     10
    .byte     2
    .byte     11
#ENDDATA
    .byte     10
    .byte     3
    .byte     11
#ENDDATA
    .byte     10
    .byte     4
    .byte     11
#ENDDATA
    .byte     10
    .byte     5
    .byte     11
#ENDDATA
    .byte     10
    .byte     6
    .byte     11
#ENDDATA
    .byte     10
    .byte     7
    .byte     11
#ENDDATA
    .byte     10
    .byte     8
    .byte     11
#ENDDATA
    .byte     10
    .byte     9
    .byte     11
#ENDDATA
    .byte     10
    .byte     10
    .byte     10
#ENDDATA
    .byte     10
    .byte     11
    .byte     11
#ENDDATA
    .byte     11
    .byte     1
    .byte     11
#ENDDATA
    .byte     11
    .byte     2
    .byte     11
#ENDDATA
    .byte     11
    .byte     3
    .byte     11
#ENDDATA
    .byte     11
    .byte     4
    .byte     11
#ENDDATA
    .byte     11
    .byte     5
    .byte     11
#ENDDATA
    .byte     11
    .byte     6
    .byte     11
#ENDDATA
    .byte     11
    .byte     7
    .byte     11
#ENDDATA
    .byte     11
    .byte     8
    .byte     11
#ENDDATA
    .byte     11
    .byte     9
    .byte     11
#ENDDATA
    .byte     11
    .byte     10
    .byte     11
#ENDDATA
    .byte     11
    .byte     11
    .byte     11
#ENDDATA
cc_tables.convsetuptable:
    .byte     1
    .byte     1
    .byte     3
#ENDDATA
    .byte     1
    .byte     2
    .byte     3
#ENDDATA
    .byte     1
    .byte     3
    .byte     3
#ENDDATA
    .byte     1
    .byte     4
    .byte     3
#ENDDATA
    .byte     1
    .byte     5
    .byte     13
#ENDDATA
    .byte     1
    .byte     6
    .byte     1
#ENDDATA
    .byte     1
    .byte     7
    .byte     3
#ENDDATA
    .byte     1
    .byte     8
    .byte     3
#ENDDATA
    .byte     1
    .byte     9
    .byte     3
#ENDDATA
    .byte     1
    .byte     10
    .byte     5
#ENDDATA
    .byte     1
    .byte     11
    .byte     5
#ENDDATA
    .byte     2
    .byte     1
    .byte     12
#ENDDATA
    .byte     2
    .byte     2
    .byte     0
#ENDDATA
    .byte     2
    .byte     3
    .byte     3
#ENDDATA
    .byte     2
    .byte     4
    .byte     3
#ENDDATA
    .byte     2
    .byte     5
    .byte     13
#ENDDATA
    .byte     2
    .byte     6
    .byte     12
#ENDDATA
    .byte     2
    .byte     7
    .byte     1
#ENDDATA
    .byte     2
    .byte     8
    .byte     3
#ENDDATA
    .byte     2
    .byte     9
    .byte     3
#ENDDATA
    .byte     2
    .byte     10
    .byte     5
#ENDDATA
    .byte     2
    .byte     11
    .byte     5
#ENDDATA
    .byte     3
    .byte     1
    .byte     12
#ENDDATA
    .byte     3
    .byte     2
    .byte     12
#ENDDATA
    .byte     3
    .byte     3
    .byte     0
#ENDDATA
    .byte     3
    .byte     4
    .byte     3
#ENDDATA
    .byte     3
    .byte     5
    .byte     13
#ENDDATA
    .byte     3
    .byte     6
    .byte     12
#ENDDATA
    .byte     3
    .byte     7
    .byte     12
#ENDDATA
    .byte     3
    .byte     8
    .byte     1
#ENDDATA
    .byte     3
    .byte     9
    .byte     3
#ENDDATA
    .byte     3
    .byte     10
    .byte     5
#ENDDATA
    .byte     3
    .byte     11
    .byte     5
#ENDDATA
    .byte     4
    .byte     1
    .byte     12
#ENDDATA
    .byte     4
    .byte     2
    .byte     12
#ENDDATA
    .byte     4
    .byte     3
    .byte     12
#ENDDATA
    .byte     4
    .byte     4
    .byte     0
#ENDDATA
    .byte     4
    .byte     5
    .byte     13
#ENDDATA
    .byte     4
    .byte     6
    .byte     12
#ENDDATA
    .byte     4
    .byte     7
    .byte     12
#ENDDATA
    .byte     4
    .byte     8
    .byte     12
#ENDDATA
    .byte     4
    .byte     9
    .byte     1
#ENDDATA
    .byte     4
    .byte     10
    .byte     5
#ENDDATA
    .byte     4
    .byte     11
    .byte     5
#ENDDATA
    .byte     5
    .byte     1
    .byte     1
#ENDDATA
    .byte     5
    .byte     2
    .byte     4
#ENDDATA
    .byte     5
    .byte     3
    .byte     4
#ENDDATA
    .byte     5
    .byte     4
    .byte     4
#ENDDATA
    .byte     5
    .byte     5
    .byte     0
#ENDDATA
    .byte     5
    .byte     6
    .byte     1
#ENDDATA
    .byte     5
    .byte     7
    .byte     4
#ENDDATA
    .byte     5
    .byte     8
    .byte     4
#ENDDATA
    .byte     5
    .byte     9
    .byte     4
#ENDDATA
    .byte     5
    .byte     10
    .byte     6
#ENDDATA
    .byte     5
    .byte     11
    .byte     6
#ENDDATA
    .byte     6
    .byte     1
    .byte     1
#ENDDATA
    .byte     6
    .byte     2
    .byte     4
#ENDDATA
    .byte     6
    .byte     3
    .byte     4
#ENDDATA
    .byte     6
    .byte     4
    .byte     4
#ENDDATA
    .byte     6
    .byte     5
    .byte     13
#ENDDATA
    .byte     6
    .byte     6
    .byte     1
#ENDDATA
    .byte     6
    .byte     7
    .byte     4
#ENDDATA
    .byte     6
    .byte     8
    .byte     4
#ENDDATA
    .byte     6
    .byte     9
    .byte     4
#ENDDATA
    .byte     6
    .byte     10
    .byte     6
#ENDDATA
    .byte     6
    .byte     11
    .byte     6
#ENDDATA
    .byte     7
    .byte     1
    .byte     12
#ENDDATA
    .byte     7
    .byte     2
    .byte     1
#ENDDATA
    .byte     7
    .byte     3
    .byte     4
#ENDDATA
    .byte     7
    .byte     4
    .byte     4
#ENDDATA
    .byte     7
    .byte     5
    .byte     13
#ENDDATA
    .byte     7
    .byte     6
    .byte     12
#ENDDATA
    .byte     7
    .byte     7
    .byte     0
#ENDDATA
    .byte     7
    .byte     8
    .byte     4
#ENDDATA
    .byte     7
    .byte     9
    .byte     4
#ENDDATA
    .byte     7
    .byte     10
    .byte     6
#ENDDATA
    .byte     7
    .byte     11
    .byte     6
#ENDDATA
    .byte     8
    .byte     1
    .byte     12
#ENDDATA
    .byte     8
    .byte     2
    .byte     12
#ENDDATA
    .byte     8
    .byte     3
    .byte     1
#ENDDATA
    .byte     8
    .byte     4
    .byte     4
#ENDDATA
    .byte     8
    .byte     5
    .byte     13
#ENDDATA
    .byte     8
    .byte     6
    .byte     12
#ENDDATA
    .byte     8
    .byte     7
    .byte     12
#ENDDATA
    .byte     8
    .byte     8
    .byte     0
#ENDDATA
    .byte     8
    .byte     9
    .byte     4
#ENDDATA
    .byte     8
    .byte     10
    .byte     6
#ENDDATA
    .byte     8
    .byte     11
    .byte     6
#ENDDATA
    .byte     9
    .byte     1
    .byte     12
#ENDDATA
    .byte     9
    .byte     2
    .byte     12
#ENDDATA
    .byte     9
    .byte     3
    .byte     12
#ENDDATA
    .byte     9
    .byte     4
    .byte     1
#ENDDATA
    .byte     9
    .byte     5
    .byte     13
#ENDDATA
    .byte     9
    .byte     6
    .byte     12
#ENDDATA
    .byte     9
    .byte     7
    .byte     12
#ENDDATA
    .byte     9
    .byte     8
    .byte     12
#ENDDATA
    .byte     9
    .byte     9
    .byte     0
#ENDDATA
    .byte     9
    .byte     10
    .byte     6
#ENDDATA
    .byte     9
    .byte     11
    .byte     6
#ENDDATA
    .byte     10
    .byte     1
    .byte     7
#ENDDATA
    .byte     10
    .byte     2
    .byte     7
#ENDDATA
    .byte     10
    .byte     3
    .byte     7
#ENDDATA
    .byte     10
    .byte     4
    .byte     7
#ENDDATA
    .byte     10
    .byte     5
    .byte     8
#ENDDATA
    .byte     10
    .byte     6
    .byte     8
#ENDDATA
    .byte     10
    .byte     7
    .byte     8
#ENDDATA
    .byte     10
    .byte     8
    .byte     8
#ENDDATA
    .byte     10
    .byte     9
    .byte     8
#ENDDATA
    .byte     10
    .byte     10
    .byte     0
#ENDDATA
    .byte     10
    .byte     11
    .byte     9
#ENDDATA
    .byte     11
    .byte     1
    .byte     7
#ENDDATA
    .byte     11
    .byte     2
    .byte     7
#ENDDATA
    .byte     11
    .byte     3
    .byte     7
#ENDDATA
    .byte     11
    .byte     4
    .byte     7
#ENDDATA
    .byte     11
    .byte     5
    .byte     8
#ENDDATA
    .byte     11
    .byte     6
    .byte     8
#ENDDATA
    .byte     11
    .byte     7
    .byte     8
#ENDDATA
    .byte     11
    .byte     8
    .byte     8
#ENDDATA
    .byte     11
    .byte     9
    .byte     8
#ENDDATA
    .byte     11
    .byte     10
    .byte     10
#ENDDATA
    .byte     11
    .byte     11
    .byte     0
#ENDDATA
    .align    8
cc_tables.badexprs:
    .quad     1
    .quad     3
    .quad     0x1F
    .quad     0x18
    .quad     0x19
    .quad     0x1A
    .quad     0x1B
    .quad     0x1D
    .quad     0x20
    .quad     0x21
    .quad     0x22
    .quad     0x23
    .quad     0x24
    .quad     0x26
    .quad     0x25
    .quad     0x27
    .quad     0x28
    .quad     0x29
    .quad     0x2A
    .quad     0x2B
    .quad     0x2C
    .quad     0x2D
    .quad     0x2E
    .quad     0x2F
    .quad     0x30
    .quad     0x31
    .quad     0x32
    .quad     0x33
    .quad     0x34
    .quad     0x35
    .quad     0x36
    .quad     0x3A
    .quad     0x3B
    .quad     0x3C
    .align    8
cc_lex.tkptr:
    .quad     0
    .align    8
cc_lex.dowhitespace:
    .quad     0
    .bss
    .align    8
cc_lex.nincludes:
    .space    8
    .align    8
cc_lex.normaltkx:
    .space    32
    .data
    .align    8
cc_lex.normaltk:
    .quad     cc_lex.normaltkx
    .align    8
cc_lex.noexpand:
    .quad     0
    .bss
    .align    8
cc_lex.lx_stack:
    .space    480
    .align    8
cc_lex.lx_stackindex:
    .space    8
    .data
    .align    8
cc_lex.ifcondlevel:
    .quad     0
    .bss
    .align    8
cc_lex.headerpathlist:
    .space    160
cc_lex.headerpath:
    .space    300
    .align    8
cc_lex.lxstart:
    .space    8
    .align    8
cc_lex.lxsptr:
    .space    8
    .align    8
cc_lex.lxhashvalue:
    .space    8
    .align    8
cc_lex.lxsvalue:
    .space    8
cc_lex.alphamap:
    .space    256
cc_lex.digitmap:
    .space    256
cc_lex.commentmap:
    .space    256
cc_lex.linecommentmap:
    .space    256
cc_lex.spacemap:
    .space    256
    .align    8
cc_lex.destcopy:
    .space    8
    .align    8
cc_lex.pastedtokenlist:
    .space    696000
    .data
    .align    8
cc_lex.npastedtokens:
    .quad     0
    .align    8
cc_lex.isincludefile:
    .quad     0
    .align    8
cc_lex.firstsymbol:
    .quad     1
    .bss
    .align    8
cc_lex.reallxsptr:
    .space    8
    .align    8
cc_lex.nhstsymbols:
    .space    8
    .align    8
cc_lex.hstthreshold:
    .space    8
    .align    8
cc_lex.lex_preprocess_only.sbuffer:
    .space    16
    .data
    .align    8
cc_lex.lex_preprocess_only.dest:
    .quad     cc_lex.lex_preprocess_only.sbuffer
    .bss
cc_lex.getsourcefile.filespec:
    .space    300
    .data
    .align    8
cc_lex.lexm.doreset:
    .quad     0
    .align    8
cc_lex.lasttoken:
    .quad     0
    .bss
    .align    8
cc_lex.showtoken.buffer:
    .space    16
    .data
    .align    8
cc_lex.showtoken.dest:
    .quad     cc_lex.showtoken.buffer
    .bss
    .align    8
cc_lex.stringify.buffer:
    .space    16
    .data
    .align    8
cc_lex.stringify.deststr:
    .quad     cc_lex.stringify.buffer
    .align    8
cc_lex.expandpredefmacro.monthnames:
    .quad     L8261
    .quad     L8262
    .quad     L8263
    .quad     L8264
    .quad     L8265
    .quad     L8266
    .quad     L8267
    .quad     L8268
    .quad     L8269
    .quad     L8270
    .quad     L8271
    .quad     L8272
    .align    8
cc_lex.issimpleconstmacro.specialnames:
    .quad     L8273
    .quad     L8274
    .quad     L8275
    .bss
    .align    8
cc_parse.ist_symptr:
    .space    8
cc_parse.looptypestack:
    .space    64
    .align    8
cc_parse.loopindex:
    .space    8
    .align    8
cc_parse.casevaluestack:
    .space    512
    .data
cc_parse.ingeneric:
    .byte     0
    .bss
    .align    8
cc_genpcl.retindex:
    .space    8
    .align    8
cc_genpcl.initstaticsindex:
    .space    8
    .align    8
cc_genpcl.loopstack:
    .space    1600
    .align    8
cc_genpcl.loopindex:
    .space    8
    .align    8
cc_genpcl.zero_unit:
    .space    64
    .data
    .align    8
cc_genpcl.pzero:
    .quad     cc_genpcl.zero_unit
    .bss
    .align    8
cc_genpcl.nvarlocals:
    .space    8
    .align    8
cc_genpcl.nvarparams:
    .space    8
    .align    8
cc_blockpcl.continuestack:
    .space    512
    .align    8
cc_blockpcl.breakstack:
    .space    512
    .align    8
cc_blockpcl.loopindex:
    .space    8
    .align    8
cc_blockpcl.sw_labeltable:
    .space    8
    .align    8
cc_blockpcl.sw_valuetable:
    .space    8
    .align    8
cc_blockpcl.sw_lower:
    .space    8
    .align    8
cc_blockpcl.sw_ncases:
    .space    8
cc_blockpcl.sw_defaultseen:
    .space    1
    .align    8
cc_blockpcl.sw_defaultlabel:
    .space    8
    .align    8
cc_blockpcl.sw_breaklabel:
    .space    8
    .data
    .align    8
cc_lib.autotypeno:
    .quad     0
    .align    8
cc_lib.nextafindex:
    .quad     0
    .align    8
cc_lib.unitheapptr:
    .quad     0
    .align    8
cc_lib.remainingunits:
    .quad     0
    .bss
    .align    2
cc_lib.getoptocode.opctotable:
    .space    156
cc_lib.nextautotype.str:
    .space    32
cc_lib.getopcjname.str:
    .space    20
cc_lib.strmode.str:
    .space    16384
cc_lib.strmode2.str:
    .space    16384
cc_lib.typename.str:
    .space    300
cc_lib.getstname.name:
    .space    256
    .data
cc_support.bytemasks:
    .quad     0x8040201008040201
#ENDDATA
    .align    8
cc_headers.builtinheaders:
    .quad     1
    .align    8
cc_headers.h_assert:
    .quad     L8276
    .align    8
cc_headers.h_ctype:
    .quad     L8277
    .align    8
cc_headers.h_errno:
    .quad     L8278
    .align    8
cc_headers.h_fenv:
    .quad     L8279
    .align    8
cc_headers.h_float:
    .quad     L8280
    .align    8
cc_headers.h_inttypes:
    .quad     L8281
    .align    8
cc_headers.h_stdint:
    .quad     L8282
    .align    8
cc_headers.h_limits:
    .quad     L8283
    .align    8
cc_headers.h_locale:
    .quad     L8284
    .align    8
cc_headers.h__ansi:
    .quad     L8285
    .align    8
cc_headers.h_math:
    .quad     L8286
    .align    8
cc_headers.h_setjmp:
    .quad     L8287
    .align    8
cc_headers.h_signal:
    .quad     L8288
    .align    8
cc_headers.h_stdarg:
    .quad     L8289
    .align    8
cc_headers.h_stdbool:
    .quad     L8290
    .align    8
cc_headers.h_stddef:
    .quad     L8291
    .align    8
cc_headers.h_stdio:
    .quad     L8292
    .align    8
cc_headers.h_stdlib:
    .quad     L8293
    .align    8
cc_headers.h__syslist:
    .quad     L8294
    .align    8
cc_headers.h_string:
    .quad     L8295
    .align    8
cc_headers.h_time:
    .quad     L8296
    .align    8
cc_headers.h_utime:
    .quad     L8297
    .align    8
cc_headers.h_unistd:
    .quad     L8298
    .align    8
cc_headers.h_safelib:
    .quad     L8299
    .align    8
cc_headers.h_wchar:
    .quad     L8300
    .align    8
cc_headers.h_wctype:
    .quad     L8301
    .align    8
cc_headers.h_systypes:
    .quad     L8302
    .align    8
cc_headers.h_sysstat:
    .quad     L8303
    .align    8
cc_headers.h_systimeb:
    .quad     L8304
    .align    8
cc_headers.h_sysutime:
    .quad     L8305
    .align    8
cc_headers.h_memory:
    .quad     L8306
    .align    8
cc_headers.h_fcntl:
    .quad     L8307
    .align    8
cc_headers.h_io:
    .quad     L8308
    .align    8
cc_headers.h_direct:
    .quad     L8309
    .align    8
cc_headers.h_process:
    .quad     L8310
    .align    8
cc_headers.h_malloc:
    .quad     L8311
    .align    8
cc_headers.h_conio:
    .quad     L8312
    .align    8
cc_headers.h_winsock2:
    .quad     L8313
    .align    8
cc_headers.h__mingw:
    .quad     L8314
    .align    8
cc_headers.h_windowsx:
    .quad     L8315
    .align    8
cc_headers.stdhdrnames:
    .quad     L8316
    .quad     L8317
    .quad     L8318
    .quad     L8319
    .quad     L8320
    .quad     L8321
    .quad     L8322
    .quad     L8323
    .quad     L8324
    .quad     L8325
    .quad     L8326
    .quad     L8327
    .quad     L8328
    .quad     L8329
    .quad     L8330
    .quad     L8331
    .quad     L8332
    .quad     L8333
    .quad     L8334
    .quad     L8335
    .quad     L8336
    .quad     L8337
    .quad     L8338
    .quad     L8339
    .quad     L8340
    .quad     L8341
    .quad     L8342
    .quad     L8343
    .quad     L8344
    .quad     L8345
    .quad     L8346
    .quad     L8347
    .quad     L8348
    .quad     L8349
    .quad     L8350
    .quad     L8351
    .quad     L8352
    .quad     L8353
    .quad     L8354
    .quad     L8355
    .align    8
cc_headers.stdhdrtext:
    .quad     cc_headers.h_assert
    .quad     cc_headers.h_ctype
    .quad     cc_headers.h_errno
    .quad     cc_headers.h_fenv
    .quad     cc_headers.h_float
    .quad     cc_headers.h_inttypes
    .quad     cc_headers.h_stdint
    .quad     cc_headers.h_limits
    .quad     cc_headers.h_locale
    .quad     cc_headers.h__ansi
    .quad     cc_headers.h_math
    .quad     cc_headers.h_setjmp
    .quad     cc_headers.h_signal
    .quad     cc_headers.h_stdarg
    .quad     cc_headers.h_stdbool
    .quad     cc_headers.h_stddef
    .quad     cc_headers.h_stdio
    .quad     cc_headers.h_stdlib
    .quad     cc_headers.h__syslist
    .quad     cc_headers.h_string
    .quad     cc_headers.h_time
    .quad     cc_headers.h_utime
    .quad     cc_headers.h_unistd
    .quad     cc_headers.h_safelib
    .quad     cc_headers.h_wchar
    .quad     cc_headers.h_wctype
    .quad     cc_headers.h_systypes
    .quad     cc_headers.h_sysstat
    .quad     cc_headers.h_systimeb
    .quad     cc_headers.h_sysutime
    .quad     cc_headers.h_malloc
    .quad     cc_headers.h_fcntl
    .quad     cc_headers.h_io
    .quad     cc_headers.h_direct
    .quad     cc_headers.h_process
    .quad     cc_headers.h_memory
    .quad     cc_headers.h_conio
    .quad     cc_headers.h_winsock2
    .quad     cc_headers.h__mingw
    .quad     cc_headers.h_windowsx
    .bss
    .align    8
cc_show.currfileno:
    .space    8
    .align    8
cc_show.currlineno:
    .space    8
    .align    8
cc_show.sbuffer:
    .space    16
    .data
    .align    8
cc_show.dest:
    .quad     cc_show.sbuffer
    .bss
    .align    8
cc_show.destlinestart:
    .space    8
    .align    8
cc_show.exprstrvar:
    .space    16
    .data
    .align    8
cc_show.exprstr:
    .quad     cc_show.exprstrvar
    .bss
cc_show.getprefix.str:
    .space    512
cc_show.getdottedname.str:
    .space    256
cc_show.getlineinfok.str:
    .space    40
    .text
# Proc msys.start
msys.start:
#?>>
    .set msys.start.nargs, -8
    .set msys.start.args, -16
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
#---------------
    sub       %rsp,	8
    lea       %rax,	[%rip+msys.start.startupinfo]
    push      %rax
    lea       %rcx,	[%rbp + msys.start.nargs]
    lea       %rdx,	[%rbp + msys.start.args]
    lea       %r8,	[%rip+msys.envstrings]
    xor       %r9d,	%r9d
    sub       %rsp,	32
    call      __getmainargs
    add       %rsp,	48
    movsxd    %r10,	%eax
    mov       %rbx,	%r10
    movsxd    %rax,	dword ptr[%rbp + msys.start.nargs]
    mov       [%rip+msys.nsysparams],	%rax
    mov       %rax,	[%rip+msys.nsysparams]
    cmp       %rax,	128
    jle       L3
    lea       %rcx,	[%rip+L8356]
    call      printf
    mov       %rcx,	50
    call      exit
L3:
    movsxd    %rax,	dword ptr[%rbp + msys.start.nargs]
    mov       %rdi,	%rax
    mov       %r12,	1
    cmp       %rdi,	1
    jl        L6
L4:
    mov       %rax,	[%rbp + msys.start.args]
    mov       %r10,	%r12
    mov       %rax,	[%rax + %r10*8-8]
    lea       %r10,	[%rip+msys.sysparams]
    mov       %r11,	%r12
    mov       [%r10 + %r11*8-8],	%rax
    inc       %r12
    cmp       %r12,	%rdi
    jle       L4
L6:
    mov       %rax,	[%rip+msys.$cmdskip]
    inc       %rax
    mov       %r10,	[%rip+msys.nsysparams]
    sub       %r10,	%rax
    mov       [%rip+msys.ncmdparams],	%r10
    lea       %rax,	[%rip+msys.sysparams]
    mov       %r10,	[%rip+msys.$cmdskip]
    lea       %rax,	[%rax + %r10*8]
    mov       [%rip+msys.cmdparams],	%rax
    mov       %rsi,	1
    xor       %eax,	%eax
    mov       [%rip+msys.nenvstrings],	%rax
    jmp       L8
L7:
    inc       qword ptr[%rip+msys.nenvstrings]
    inc       %rsi
L8:
    mov       %rax,	[%rip+msys.envstrings]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8-8]
    test      %rax,	%rax
    jnz       L7
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.pushio
msys.pushio:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    mov       %rax,	[%rip+msys.niostack]
    cmp       %rax,	10
    jl        L12
    lea       %rcx,	[%rip+L8357]
    call      printf
    mov       %rcx,	53
    call      exit
L12:
    inc       qword ptr[%rip+msys.niostack]
    mov       %rax,	[%rip+msys.outchan]
    lea       %r10,	[%rip+msys.outchan_stack]
    mov       %r11,	[%rip+msys.niostack]
    mov       [%r10 + %r11*8-8],	%rax
    mov       %rax,	[%rip+msys.outdev]
    lea       %r10,	[%rip+msys.outdev_stack]
    mov       %r11,	[%rip+msys.niostack]
    mov       [%r10 + %r11*8-8],	%rax
    mov       %rax,	[%rip+msys.fmtstr]
    lea       %r10,	[%rip+msys.fmtstr_stack]
    mov       %r11,	[%rip+msys.niostack]
    mov       [%r10 + %r11*8-8],	%rax
    mov       %al,	[%rip+msys.needgap]
    lea       %r10,	[%rip+msys.needgap_stack]
    mov       %r11,	[%rip+msys.niostack]
    mov       [%r10 + %r11-1],	%al
    xor       %eax,	%eax
    mov       [%rip+msys.needgap],	%rax
    xor       %eax,	%eax
    mov       [%rip+msys.fmtstr],	%rax
    xor       %eax,	%eax
    mov       [%rip+msys.outchan],	%rax
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc msys.m$print_startfile
msys.m$print_startfile:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    call      msys.pushio
    mov       [%rip+msys.outchan],	%rdi
    test      %rdi,	%rdi
    jz        L15
    mov       %rax,	2
    mov       [%rip+msys.outdev],	%rax
    jmp       L14
L15:
    mov       %rax,	1
    mov       [%rip+msys.outdev],	%rax
L14:
    call      msys.resetprintbuffer
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_startstr
msys.m$print_startstr:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    call      msys.pushio
    mov       %rax,	%rbx
    lea       %r10,	[%rip+msys.ptr_stack]
    mov       %r11,	[%rip+msys.niostack]
    mov       [%r10 + %r11*8-8],	%rax
    lea       %rax,	[%rip+msys.ptr_stack]
    mov       %r10,	[%rip+msys.niostack]
    lea       %rax,	[%rax + %r10*8-8]
    mov       %rdi,	%rax
    mov       [%rip+msys.outchan],	%rdi
    mov       %rax,	3
    mov       [%rip+msys.outdev],	%rax
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_startptr
msys.m$print_startptr:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    call      msys.pushio
    mov       [%rip+msys.outchan],	%rdi
    mov       %rax,	3
    mov       [%rip+msys.outdev],	%rax
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_startcon
msys.m$print_startcon:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    call      msys.pushio
    mov       %rax,	1
    mov       [%rip+msys.outdev],	%rax
    call      msys.resetprintbuffer
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc msys.m$print_setfmt
msys.m$print_setfmt:
#?>>
#?]]
#---------------
    mov       [%rip+msys.fmtstr],	%rcx
#---------------
    ret       
# End 
# Proc msys.m$print_end
msys.m$print_end:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    xor       %eax,	%eax
    mov       [%rip+msys.needgap],	%rax
    mov       %rcx,	1
    call      msys.nextfmtchars
    mov       %rax,	[%rip+msys.niostack]
    cmp       %rax,	1
    jnz       L22
    mov       %rax,	[%rip+msys.outdev]
    cmp       %rax,	1
    jz        L23
    cmp       %rax,	2
    jnz       L22
L23:
    call      msys.dumpprintbuffer
L22:
    mov       %rax,	[%rip+msys.niostack]
    test      %rax,	%rax
    jz        L20
L25:
    lea       %rax,	[%rip+msys.outchan_stack]
    mov       %r10,	[%rip+msys.niostack]
    mov       %rax,	[%rax + %r10*8-8]
    mov       [%rip+msys.outchan],	%rax
    lea       %rax,	[%rip+msys.outdev_stack]
    mov       %r10,	[%rip+msys.niostack]
    mov       %rax,	[%rax + %r10*8-8]
    mov       [%rip+msys.outdev],	%rax
    lea       %rax,	[%rip+msys.fmtstr_stack]
    mov       %r10,	[%rip+msys.niostack]
    mov       %rax,	[%rax + %r10*8-8]
    mov       [%rip+msys.fmtstr],	%rax
    lea       %rax,	[%rip+msys.needgap_stack]
    mov       %r10,	[%rip+msys.niostack]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       [%rip+msys.needgap],	%rax
    dec       qword ptr[%rip+msys.niostack]
L20:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc msys.m$print_ptr
msys.m$print_ptr:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    test      %rbx,	%rbx
    jnz       L28
    lea       %rax,	[%rip+L8358]
    mov       %rbx,	%rax
L28:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      msys.m$print_u64
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_ptr_nf
msys.m$print_ptr_nf:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      msys.m$print_ptr
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_i64
msys.m$print_i64:
#?>>
    .set msys.m$print_i64.s, -40
    .set msys.m$print_i64.fmt, -56
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	88
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    xor       %ecx,	%ecx
    call      msys.nextfmtchars
    test      %rsi,	%rsi
    jnz       L32
    cmp       %rbx,	0
    jl        L34
    mov       %rcx,	%rbx
    lea       %rdx,	[%rbp + msys.m$print_i64.s]
    mov       %r8,	10
    xor       %r9d,	%r9d
    call      msys.u64tostr
    mov       %rdi,	%rax
    jmp       L33
L34:
    mov       %rax,	%rbx
    mov       %r10,	-9223372036854775808
    cmp       %rax,	%r10
    jnz       L35
    lea       %rax,	[%rip+msys.defaultfmt]
    lea       %r10,	[%rbp + msys.m$print_i64.fmt]
    movdqu    %XMM4,	[%rax]
    movdqu    [%r10],	%XMM4
    jmp       L36
L35:
    mov       %al,	45
    mov       [%rbp + msys.m$print_i64.s],	%al
    lea       %rax,	[%rbp + msys.m$print_i64.s+1]
    mov       %r10,	%rbx
    neg       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    mov       %r8,	10
    xor       %r9d,	%r9d
    call      msys.u64tostr
    inc       %rax
    mov       %rdi,	%rax
L33:
    lea       %rcx,	[%rbp + msys.m$print_i64.s]
    mov       %rdx,	%rdi
    call      msys.printstr_n
    jmp       L31
L32:
    mov       %rcx,	%rsi
    mov       %rdx,	-1
    lea       %r8,	[%rbp + msys.m$print_i64.fmt]
    call      msys.strtofmt
    movzx     %rax,	byte ptr[%rbp + msys.m$print_i64.fmt+14]
    cmp       %rax,	86
    jnz       L38
    mov       [%rip+msys.fmtparam],	%rbx
    xor       %eax,	%eax
    mov       [%rip+msys.needgap],	%rax
    jmp       L37
L38:
#msys.m$print_i64.dofmt:
L36:
    mov       %rcx,	%rbx
    lea       %rdx,	[%rbp + msys.m$print_i64.fmt]
    call      msys.tostr_i64
L37:
L31:
    mov       %rax,	1
    mov       [%rip+msys.needgap],	%rax
#---------------
    add       %rsp,	88
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_i64_nf
msys.m$print_i64_nf:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      msys.m$print_i64
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_bool
msys.m$print_bool:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    test      %rdi,	%rdi
    jz        L42
    lea       %rcx,	[%rip+L8359]
    mov       %rdx,	%rbx
    call      msys.m$print_str
    jmp       L41
L42:
    lea       %rcx,	[%rip+L8360]
    mov       %rdx,	%rbx
    call      msys.m$print_str
L41:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_u64
msys.m$print_u64:
#?>>
    .set msys.m$print_u64.s, -40
    .set msys.m$print_u64.fmt, -56
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	96
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    xor       %ecx,	%ecx
    call      msys.nextfmtchars
    test      %rbx,	%rbx
    jnz       L45
    lea       %rcx,	[%rbp + msys.m$print_u64.s]
    lea       %rdx,	[%rip+L8361]
    mov       %r8,	%rdi
    call      sprintf
    lea       %rcx,	[%rbp + msys.m$print_u64.s]
    call      msys.printstr
    jmp       L44
L45:
    mov       %rcx,	%rbx
    mov       %rdx,	-1
    lea       %r8,	[%rbp + msys.m$print_u64.fmt]
    call      msys.strtofmt
    mov       %rcx,	%rdi
    lea       %rdx,	[%rbp + msys.m$print_u64.fmt]
    call      msys.tostr_u64
L44:
    mov       %rax,	1
    mov       [%rip+msys.needgap],	%rax
#---------------
    add       %rsp,	96
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_r64
msys.m$print_r64:
#?>>
    .set msys.m$print_r64.s, -360
    .set msys.m$print_r64.fmt, -376
    push      %rdi
    movq      %rax,	%XMM15
    push      %rax
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	416
    movq      %XMM15,	%XMM0
    mov       %rdi,	%rdx
#---------------
    xor       %ecx,	%ecx
    call      msys.nextfmtchars
    test      %rdi,	%rdi
    jnz       L48
    lea       %rcx,	[%rbp + msys.m$print_r64.s]
    lea       %rdx,	[%rip+L8362]
    movq      %XMM2,	%XMM15
    movq      %r8,	%XMM2
    call      sprintf
    lea       %rcx,	[%rbp + msys.m$print_r64.s]
    call      msys.printstr
    jmp       L47
L48:
    mov       %rcx,	%rdi
    mov       %rdx,	-1
    lea       %r8,	[%rbp + msys.m$print_r64.fmt]
    call      msys.strtofmt
    movq      %XMM0,	%XMM15
    lea       %rdx,	[%rbp + msys.m$print_r64.fmt]
    call      msys.tostr_r64
L47:
    mov       %rax,	1
    mov       [%rip+msys.needgap],	%rax
#---------------
    add       %rsp,	416
    pop       %rbp
    pop       %rcx
    movq      %XMM15,	%rcx
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_r32
msys.m$print_r32:
#?>>
    .set msys.m$print_r32.s, -360
    .set msys.m$print_r32.fmt, -376
    push      %rdi
    movq      %rax,	%XMM15
    push      %rax
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	416
    movq      %XMM15,	%XMM0
    mov       %rdi,	%rdx
#---------------
    xor       %ecx,	%ecx
    call      msys.nextfmtchars
    test      %rdi,	%rdi
    jnz       L51
    movq      %XMM4,	%XMM15
    cvtss2sd  %XMM4,	%XMM4
    lea       %rcx,	[%rbp + msys.m$print_r32.s]
    lea       %rdx,	[%rip+L8362]
    movq      %XMM2,	%XMM4
    movq      %r8,	%XMM2
    call      sprintf
    lea       %rcx,	[%rbp + msys.m$print_r32.s]
    call      msys.printstr
    jmp       L50
L51:
    mov       %rcx,	%rdi
    mov       %rdx,	-1
    lea       %r8,	[%rbp + msys.m$print_r32.fmt]
    call      msys.strtofmt
    movq      %XMM4,	%XMM15
    cvtss2sd  %XMM4,	%XMM4
    movq      %XMM0,	%XMM4
    lea       %rdx,	[%rbp + msys.m$print_r32.fmt]
    call      msys.tostr_r64
L50:
    mov       %rax,	1
    mov       [%rip+msys.needgap],	%rax
#---------------
    add       %rsp,	416
    pop       %rbp
    pop       %rcx
    movq      %XMM15,	%rcx
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_c8
msys.m$print_c8:
#?>>
    .set msys.m$print_c8.a, 40
    .set msys.m$print_c8.s, -32
    .set msys.m$print_c8.fmt, -48
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	88
    mov       [%rbp+40],	%rcx
    mov       %rsi,	%rdx
#---------------
    xor       %bl,	%bl
    xor       %ecx,	%ecx
    call      msys.nextfmtchars
    test      %rsi,	%rsi
    jz        L54
    mov       %rcx,	%rsi
    mov       %rdx,	-1
    lea       %r8,	[%rbp + msys.m$print_c8.fmt]
    call      msys.strtofmt
    mov       %bl,	[%rbp + msys.m$print_c8.fmt+12]
L54:
    movzx     %rax,	%bl
    cmp       %rax,	77
    jnz       L56
    lea       %rcx,	[%rbp + msys.m$print_c8.a]
    mov       %rdx,	8
    lea       %r8,	[%rbp + msys.m$print_c8.s]
    lea       %r9,	[%rbp + msys.m$print_c8.fmt]
    call      msys.domultichar
    mov       %rdi,	%rax
    jmp       L55
L56:
    mov       %rax,	[%rbp + msys.m$print_c8.a]
    mov       [%rbp + msys.m$print_c8.s],	%rax
    xor       %eax,	%eax
    mov       [%rbp + msys.m$print_c8.s+8],	%al
    lea       %rcx,	[%rbp + msys.m$print_c8.s]
    call      msys.getutfsize
    mov       %rdi,	%rax
L55:
    lea       %rcx,	[%rbp + msys.m$print_c8.s]
    mov       %rdx,	%rdi
    call      msys.printstr_n
    mov       %rax,	1
    mov       [%rip+msys.needgap],	%rax
#---------------
    add       %rsp,	88
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_str
msys.m$print_str:
#?>>
    .set msys.m$print_str.fmt, -16
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    xor       %ecx,	%ecx
    call      msys.nextfmtchars
    test      %rdi,	%rdi
    jnz       L59
    lea       %rcx,	[%rip+L8363]
    call      msys.printstr
    jmp       L57
L59:
    test      %rbx,	%rbx
    jnz       L61
    mov       %rcx,	%rdi
    call      msys.printstr
    jmp       L60
L61:
    mov       %rcx,	%rbx
    mov       %rdx,	-1
    lea       %r8,	[%rbp + msys.m$print_str.fmt]
    call      msys.strtofmt
    mov       %rcx,	%rdi
    mov       %rdx,	-1
    lea       %r8,	[%rbp + msys.m$print_str.fmt]
    call      msys.tostr_str
L60:
    mov       %rax,	1
    mov       [%rip+msys.needgap],	%rax
L57:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_strn
msys.m$print_strn:
#?>>
    .set msys.m$print_strn.fmt, -16
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	56
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    xor       %ecx,	%ecx
    call      msys.nextfmtchars
    test      %rdi,	%rdi
    jnz       L64
    lea       %rcx,	[%rip+L8363]
    call      msys.printstr
    jmp       L62
L64:
    test      %rsi,	%rsi
    jnz       L66
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      msys.printstr_n
    jmp       L65
L66:
    mov       %rcx,	%rsi
    mov       %rdx,	-1
    lea       %r8,	[%rbp + msys.m$print_strn.fmt]
    call      msys.strtofmt
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    lea       %r8,	[%rbp + msys.m$print_strn.fmt]
    call      msys.tostr_str
L65:
    mov       %rax,	1
    mov       [%rip+msys.needgap],	%rax
L62:
#---------------
    add       %rsp,	56
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_str_nf
msys.m$print_str_nf:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      msys.m$print_str
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_strsl
msys.m$print_strsl:
#?>>
    .set msys.m$print_strsl.s, 16
    .set msys.m$print_strsl.fmtstyle, 24
#?]]
    sub       %rsp,	40
#---------------
    lea       %rcx,	[%rip+L8364]
    call      mlib.abortprogram
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc msys.m$print_newline
msys.m$print_newline:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    xor       %eax,	%eax
    mov       [%rip+msys.needgap],	%rax
    mov       %rcx,	1
    call      msys.nextfmtchars
    lea       %rcx,	[%rip+L8365]
    call      msys.printstr
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc msys.m$print_nogap
msys.m$print_nogap:
#?>>
#?]]
#---------------
    xor       %eax,	%eax
    mov       [%rip+msys.needgap],	%rax
#---------------
    ret       
# End 
# Proc msys.m$print_space
msys.m$print_space:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    xor       %eax,	%eax
    mov       [%rip+msys.needgap],	%rax
    lea       %rcx,	[%rip+L8366]
    call      msys.printstr
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc msys.printstr
msys.printstr:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      strlen
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      msys.printstr_n
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc msys.printstr_n
msys.printstr_n:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      msys.dumpstr
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.printstrn_app
msys.printstrn_app:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    test      %rbx,	%rbx
    jz        L76
    test      %rsi,	%rsi
    jnz       L78
    lea       %rcx,	[%rip+L8367]
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      printf
    jmp       L77
L78:
    mov       %rcx,	%rsi
    lea       %rdx,	[%rip+L8367]
    mov       %r8,	%rbx
    mov       %r9,	%rdi
    call      fprintf
L77:
L76:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.printchar
msys.printchar:
#?>>
    .set msys.printchar.str, -8
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %rdi,	%rcx
#---------------
    mov       [%rbp + msys.printchar.str],	%dil
    xor       %eax,	%eax
    mov       [%rbp + msys.printchar.str+1],	%al
    lea       %rcx,	[%rbp + msys.printchar.str]
    mov       %rdx,	1
    call      msys.printstr_n
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc msys.nextfmtchars
msys.nextfmtchars:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
    mov       %rax,	[%rip+msys.fmtstr]
    test      %rax,	%rax
    jnz       L82
    mov       %rax,	[%rip+msys.needgap]
    test      %rax,	%rax
    jz        L84
    mov       %rcx,	32
    call      msys.printchar
L84:
    xor       %eax,	%eax
    mov       [%rip+msys.needgap],	%rax
    jmp       L80
L82:
    mov       %rbx,	[%rip+msys.fmtstr]
    xor       %rsi,	%rsi
L85:
    mov       %rax,	[%rip+msys.fmtstr]
    mov       %dil,	[%rax]
    movzx     %rax,	%dil
    cmp       %rax,	35
    jz        L88
    test      %rax,	%rax
    jz        L89
    cmp       %rax,	126
    jz        L90
    jmp       L91
L88:
    test      %r12,	%r12
    jz        L93
    jmp       L94
L93:
    inc       qword ptr[%rip+msys.fmtstr]
    test      %rsi,	%rsi
    jz        L96
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      msys.printstr_n
L96:
    jmp       L80
L89:
    test      %rsi,	%rsi
    jz        L98
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      msys.printstr_n
    jmp       L97
L98:
    test      %r12,	%r12
    jnz       L99
    lea       %rcx,	[%rip+L8368]
    mov       %rdx,	1
    call      msys.printstr_n
L99:
L97:
    jmp       L80
L90:
    test      %rsi,	%rsi
    jz        L101
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      msys.printstr_n
    xor       %rsi,	%rsi
L101:
    inc       qword ptr[%rip+msys.fmtstr]
    mov       %rax,	[%rip+msys.fmtstr]
    mov       %dil,	[%rax]
    test      %dil,	%dil
    jz        L103
    inc       qword ptr[%rip+msys.fmtstr]
    movzx     %rax,	%dil
    mov       %rcx,	%rax
    call      msys.printchar
L103:
    mov       %rbx,	[%rip+msys.fmtstr]
    jmp       L87
L91:
#msys.nextfmtchars.skip:
L94:
    inc       %rsi
    inc       qword ptr[%rip+msys.fmtstr]
L87:
    jmp       L85
L80:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.strtofmt
msys.strtofmt:
#?>>
    .set msys.strtofmt.str, -104
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	136
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       %r15,	%r8
#---------------
    lea       %rax,	[%rip+msys.defaultfmt]
    movdqu    %XMM4,	[%rax]
    movdqu    [%r15],	%XMM4
    test      %r13,	%r13
    jnz       L106
    jmp       L104
L106:
    cmp       %r14,	-1
    jnz       L108
    mov       %rcx,	%r13
    call      strlen
    mov       %r14,	%rax
L108:
    lea       %rcx,	[%rbp + msys.strtofmt.str]
    mov       %rdx,	%r13
    mov       %r8,	%r14
    call      memcpy
    xor       %eax,	%eax
    mov       [%rbp + %r14 + msys.strtofmt.str],	%al
    lea       %rax,	[%rbp + msys.strtofmt.str]
    mov       %r13,	%rax
    xor       %sil,	%sil
    jmp       L110
L109:
    movzx     %rax,	byte ptr[%r13]
    mov       %rdi,	%rax
    inc       %r13
    cmp       %rdi,	65
    jnz       L113
    mov       %al,	65
    mov       [%r15+8],	%al
    jmp       L112
L113:
    cmp       %rdi,	97
    jnz       L114
    mov       %al,	97
    mov       [%r15+8],	%al
    jmp       L112
L114:
    mov       %rcx,	%rdi
    call      toupper
    movsxd    %r10,	%eax
    sub       %r10,	66
    cmp       %r10,	25
    jae       L117
    lea       %rax,	[%rip+L116]
    jmp       [%rax + %r10*8]
    .data
L116:
    .quad     L118
    .quad     L147
    .quad     L146
    .quad     L143
    .quad     L144
    .quad     L145
    .quad     L119
    .quad     L117
    .quad     L129
    .quad     L117
    .quad     L117
    .quad     L148
    .quad     L151
    .quad     L120
    .quad     L136
    .quad     L128
    .quad     L117
    .quad     L133
    .quad     L139
    .quad     L142
    .quad     L149
    .quad     L117
    .quad     L121
    .quad     L150
    .quad     L132
    .text
L118:
    mov       %al,	2
    mov       [%r15+2],	%al
    jmp       L115
L119:
    mov       %al,	16
    mov       [%r15+2],	%al
    jmp       L115
L120:
    mov       %al,	8
    mov       [%r15+2],	%al
    jmp       L115
L121:
    xor       %rbx,	%rbx
L122:
    movzx     %rax,	byte ptr[%r13]
    mov       %rdi,	%rax
    mov       %rax,	%rdi
    cmp       %rax,	48
    jl        L125
    cmp       %rax,	57
    jg        L125
    mov       %rax,	%rbx
    shl       %rax,	1
    lea       %rax,	[%rax + %rax*4]
    add       %rax,	%rdi
    sub       %rax,	48
    mov       %rbx,	%rax
    inc       %r13
    jmp       L124
L125:
    jmp       L123
L124:
    jmp       L122
L123:
    mov       %rax,	%rbx
    cmp       %rax,	2
    jl        L127
    cmp       %rax,	16
    jg        L127
    mov       [%r15+2],	%bl
L127:
    jmp       L115
L128:
    mov       %al,	34
    mov       [%r15+3],	%al
    jmp       L115
L129:
    movzx     %rax,	byte ptr[%r13]
    mov       %rcx,	%rax
    call      toupper
    mov       [%r15+9],	%al
    mov       %al,	[%r13]
    test      %al,	%al
    jz        L131
    inc       %r13
L131:
    jmp       L115
L132:
    mov       %al,	48
    mov       [%r15+4],	%al
    jmp       L115
L133:
    mov       %al,	[%r13]
    mov       [%r15+7],	%al
    mov       %al,	[%r13]
    test      %al,	%al
    jz        L135
    inc       %r13
L135:
    jmp       L115
L136:
    mov       %al,	[%r13]
    mov       [%r15+4],	%al
    mov       %al,	[%r13]
    test      %al,	%al
    jz        L138
    inc       %r13
L138:
    jmp       L115
L139:
    mov       %al,	[%r13]
    mov       [%r15+10],	%al
    mov       %al,	[%r13]
    test      %al,	%al
    jz        L141
    inc       %r13
L141:
    jmp       L115
L142:
    mov       %al,	87
    mov       [%r15+11],	%al
    jmp       L115
L143:
    mov       %al,	101
    mov       [%r15+5],	%al
    jmp       L115
L144:
    mov       %al,	102
    mov       [%r15+5],	%al
    jmp       L115
L145:
    mov       %al,	103
    mov       [%r15+5],	%al
    jmp       L115
L146:
    mov       %al,	68
    mov       [%r15+13],	%al
    jmp       L115
L147:
    mov       %al,	67
    mov       [%r15+12],	%al
    jmp       L115
L148:
    mov       %al,	77
    mov       [%r15+12],	%al
    jmp       L115
L149:
    mov       %al,	86
    mov       [%r15+14],	%al
    jmp       L115
L150:
    lea       %rax,	[%r15+15]
    or        byte ptr[%rax],	1
    jmp       L115
L151:
    lea       %rax,	[%r15+15]
    or        byte ptr[%rax],	2
    jmp       L115
L117:
    mov       %rax,	%rdi
    cmp       %rax,	46
    jz        L153
    cmp       %rax,	44
    jz        L154
    cmp       %rax,	95
    jz        L154
    cmp       %rax,	43
    jz        L155
    cmp       %rax,	126
    jz        L156
    cmp       %rax,	42
    jz        L157
    jmp       L158
L153:
    mov       %sil,	1
    jmp       L152
L154:
    mov       [%r15+7],	%dil
    jmp       L152
L155:
    mov       %al,	43
    mov       [%r15+6],	%al
    jmp       L152
L156:
    mov       %al,	126
    mov       [%r15+3],	%al
    jmp       L152
L157:
    mov       %r12,	[%rip+msys.fmtparam]
    jmp       L159
L158:
    cmp       %rdi,	48
    jl        L161
    cmp       %rdi,	57
    jg        L161
    lea       %rax,	[%rdi-48]
    mov       %r12,	%rax
L162:
    movzx     %rax,	byte ptr[%r13]
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%r13]
    test      %rax,	%rax
    jz        L163
L165:
    cmp       %rdi,	48
    jl        L167
    cmp       %rdi,	57
    jg        L167
    inc       %r13
    mov       %rax,	%r12
    shl       %rax,	1
    lea       %rax,	[%rax + %rax*4]
    add       %rax,	%rdi
    sub       %rax,	48
    mov       %r12,	%rax
    jmp       L166
L167:
    jmp       L163
L166:
    jmp       L162
L163:
#msys.strtofmt.gotwidth:
L159:
    test      %sil,	%sil
    jnz       L169
    mov       [%r15],	%r12b
    mov       %sil,	1
    jmp       L168
L169:
    mov       [%r15+1],	%r12b
L168:
L161:
L152:
L115:
L112:
L110:
    mov       %al,	[%r13]
    test      %al,	%al
    jnz       L109
L104:
#---------------
    add       %rsp,	136
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.domultichar
msys.domultichar:
#?>>
    .set msys.domultichar.fmt, 88
    .set msys.domultichar.str, -24
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	64
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
    mov       [%rbp+88],	%r9
#---------------
    lea       %rax,	[%rbp + msys.domultichar.str]
    mov       %rdi,	%rax
    mov       %rbx,	%r13
    mov       %rsi,	%r13
    cmp       %rsi,	0
    jle       L173
L171:
    movzx     %rax,	byte ptr[%r12]
    test      %rax,	%rax
    jz        L173
L175:
    mov       %al,	[%r12]
    mov       [%rdi],	%al
    inc       %rdi
    inc       %r12
    dec       %rsi
    jnz       L171
L173:
    xor       %eax,	%eax
    mov       [%rdi],	%al
    lea       %rcx,	[%rbp + msys.domultichar.str]
    call      strlen
    lea       %rcx,	[%rbp + msys.domultichar.str]
    mov       %rdx,	%r14
    mov       %r8,	%rax
    mov       %r9,	[%rbp + msys.domultichar.fmt]
    call      msys.expandstr
L170:
#---------------
    add       %rsp,	64
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.expandstr
msys.expandstr:
#?>>
    .set msys.expandstr.n, 80
    .set msys.expandstr.fmt, 88
    .set msys.expandstr.av_2, -8
    .set msys.expandstr.av_3, -16
    .set msys.expandstr.av_4, -24
    .set msys.expandstr.av_5, -32
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	64
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       [%rbp+80],	%r8
    mov       [%rbp+88],	%r9
#---------------
    mov       %rax,	[%rbp + msys.expandstr.fmt]
    movzx     %rax,	byte ptr[%rax]
    mov       %rbx,	%rax
    test      %rbx,	%rbx
    jz        L179
    cmp       %rbx,	[%rbp + msys.expandstr.n]
    jg        L178
L179:
    mov       %rcx,	%r14
    mov       %rdx,	%r13
    mov       %r8,	[%rbp + msys.expandstr.n]
    call      strncpy
    xor       %eax,	%eax
    mov       %r10,	[%rbp + msys.expandstr.n]
    mov       [%r14 + %r10],	%al
    mov       %rax,	[%rbp + msys.expandstr.n]
    jmp       L176
L178:
    mov       %rax,	[%rbp + msys.expandstr.fmt]
    movzx     %rax,	byte ptr[%rax+9]
    cmp       %rax,	76
    jnz       L181
    mov       %rcx,	%r14
    mov       %rdx,	%r13
    mov       %r8,	[%rbp + msys.expandstr.n]
    call      strncpy
    mov       %rax,	[%rbp + msys.expandstr.n]
    add       %r14,	%rax
    mov       %rdi,	1
    mov       %rax,	%rbx
    sub       %rax,	[%rbp + msys.expandstr.n]
    mov       %r12,	%rax
    cmp       %r12,	1
    jl        L184
L182:
    mov       %rax,	[%rbp + msys.expandstr.fmt]
    mov       %al,	[%rax+4]
    mov       [%r14],	%al
    inc       %r14
    inc       %rdi
    cmp       %rdi,	%r12
    jle       L182
L184:
    xor       %eax,	%eax
    mov       [%r14],	%al
    jmp       L180
L181:
    mov       %rax,	[%rbp + msys.expandstr.fmt]
    movzx     %rax,	byte ptr[%rax+9]
    cmp       %rax,	82
    jnz       L185
    mov       %rax,	[%rbp + msys.expandstr.fmt]
    movzx     %rax,	byte ptr[%rax+4]
    cmp       %rax,	48
    jnz       L187
    mov       %rax,	[%rbp + msys.expandstr.fmt]
    mov       %al,	[%rax+2]
    test      %al,	%al
    jz        L187
    movzx     %rax,	byte ptr[%r13]
    cmp       %rax,	45
    jz        L188
    movzx     %rax,	byte ptr[%r13]
    cmp       %rax,	43
    jnz       L187
L188:
    mov       %al,	[%r13]
    mov       [%r14],	%al
    inc       %r14
    mov       %rax,	%rbx
    sub       %rax,	[%rbp + msys.expandstr.n]
    mov       [%rbp + msys.expandstr.av_2],	%rax
    mov       %rax,	[%rbp + msys.expandstr.av_2]
    cmp       %rax,	0
    jle       L191
L189:
    mov       %rax,	[%rbp + msys.expandstr.fmt]
    mov       %al,	[%rax+4]
    mov       [%r14],	%al
    inc       %r14
    dec       qword ptr[%rbp + msys.expandstr.av_2]
    jnz       L189
L191:
    mov       %rax,	[%rbp + msys.expandstr.n]
    dec       %rax
    lea       %r10,	[%r13+1]
    mov       %rcx,	%r14
    mov       %rdx,	%r10
    mov       %r8,	%rax
    call      strncpy
    mov       %rax,	[%rbp + msys.expandstr.n]
    lea       %r10,	[%r14 + %rax]
    sub       %r10,	1
    xor       %eax,	%eax
    mov       [%r10],	%al
    jmp       L186
L187:
    mov       %rax,	%rbx
    sub       %rax,	[%rbp + msys.expandstr.n]
    mov       [%rbp + msys.expandstr.av_3],	%rax
    mov       %rax,	[%rbp + msys.expandstr.av_3]
    cmp       %rax,	0
    jle       L194
L192:
    mov       %rax,	[%rbp + msys.expandstr.fmt]
    mov       %al,	[%rax+4]
    mov       [%r14],	%al
    inc       %r14
    dec       qword ptr[%rbp + msys.expandstr.av_3]
    jnz       L192
L194:
    mov       %rcx,	%r14
    mov       %rdx,	%r13
    mov       %r8,	[%rbp + msys.expandstr.n]
    call      strncpy
    xor       %eax,	%eax
    mov       %r10,	[%rbp + msys.expandstr.n]
    mov       [%r14 + %r10],	%al
L186:
    jmp       L180
L185:
    mov       %rax,	%rbx
    sub       %rax,	[%rbp + msys.expandstr.n]
    inc       %rax
    sar       %rax,	1
    mov       %rsi,	%rax
    mov       [%rbp + msys.expandstr.av_4],	%rsi
    mov       %rax,	[%rbp + msys.expandstr.av_4]
    cmp       %rax,	0
    jle       L197
L195:
    mov       %rax,	[%rbp + msys.expandstr.fmt]
    mov       %al,	[%rax+4]
    mov       [%r14],	%al
    inc       %r14
    dec       qword ptr[%rbp + msys.expandstr.av_4]
    jnz       L195
L197:
    mov       %rcx,	%r14
    mov       %rdx,	%r13
    mov       %r8,	[%rbp + msys.expandstr.n]
    call      strncpy
    mov       %rax,	[%rbp + msys.expandstr.n]
    add       %r14,	%rax
    mov       %rax,	%rbx
    sub       %rax,	[%rbp + msys.expandstr.n]
    sub       %rax,	%rsi
    mov       [%rbp + msys.expandstr.av_5],	%rax
    mov       %rax,	[%rbp + msys.expandstr.av_5]
    cmp       %rax,	0
    jle       L200
L198:
    mov       %rax,	[%rbp + msys.expandstr.fmt]
    mov       %al,	[%rax+4]
    mov       [%r14],	%al
    inc       %r14
    dec       qword ptr[%rbp + msys.expandstr.av_5]
    jnz       L198
L200:
    xor       %eax,	%eax
    mov       [%r14],	%al
L180:
    mov       %rax,	%rbx
L176:
#---------------
    add       %rsp,	64
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.u64tostr
msys.u64tostr:
#?>>
    .set msys.u64tostr.t, -360
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	368
#---------------
    xor       %rbx,	%rbx
    xor       %eax,	%eax
    mov       %r12,	%rax
    cmp       %r8,	10
    jnz       L203
    mov       %rax,	3
    jmp       L202
L203:
    mov       %rax,	4
L202:
    mov       %r13,	%rax
L204:
    mov       %rax,	%rcx
    mov       %r10,	%r8
    push      %rdx
    xor       %edx,	%edx
    div       %r10
    xchg      %rax,	%rdx
    pop       %rdx
    mov       %rdi,	%rax
    mov       %rax,	%rcx
    mov       %r10,	%r8
    push      %rdx
    xor       %edx,	%edx
    div       %r10
    pop       %rdx
    mov       %rcx,	%rax
    lea       %rax,	[%rip+msys.digits]
    mov       %r10,	%rdi
    mov       %al,	[%rax + %r10]
    inc       %rbx
    mov       %r10,	%rbx
    mov       [%rbp + %r10 + msys.u64tostr.t],	%al
    inc       %r12
    test      %r9,	%r9
    jz        L208
    test      %rcx,	%rcx
    jz        L208
    cmp       %r12,	%r13
    jnz       L208
    inc       %rbx
    mov       %rax,	%rbx
    mov       %r10b,	%r9b
    mov       [%rbp + %rax + msys.u64tostr.t],	%r10b
    xor       %r12,	%r12
L208:
    test      %rcx,	%rcx
    jnz       L204
    mov       %rsi,	%rbx
    mov       %r14,	%rdx
    jmp       L210
L209:
    mov       %rax,	%rbx
    dec       %rbx
    mov       %al,	[%rbp + %rax + msys.u64tostr.t]
    mov       [%rdx],	%al
    inc       %rdx
L210:
    test      %rbx,	%rbx
    jnz       L209
    xor       %eax,	%eax
    mov       [%rdx],	%al
    mov       %rax,	%rsi
L201:
#---------------
    add       %rsp,	368
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.i64tostrfmt
msys.i64tostrfmt:
#?>>
    .set msys.i64tostrfmt.str, -360
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	392
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
    xor       %rbx,	%rbx
    mov       %al,	[%r13+11]
    test      %al,	%al
    jz        L214
    mov       %rbx,	1
L214:
    mov       %rax,	%rsi
    mov       %r10,	-9223372036854775808
    cmp       %rax,	%r10
    jnz       L216
    test      %rbx,	%rbx
    jnz       L216
    mov       %al,	45
    mov       [%rbp + msys.i64tostrfmt.str],	%al
    movzx     %rax,	byte ptr[%r13+7]
    movzx     %r10,	byte ptr[%r13+2]
    lea       %r11,	[%rbp + msys.i64tostrfmt.str+1]
    mov       %rcx,	%r11
    mov       %rdx,	%r10
    mov       %r8,	%rax
    call      msys.i64mintostr
    inc       %rax
    mov       %rdi,	%rax
    jmp       L215
L216:
    test      %rbx,	%rbx
    jnz       L220
    cmp       %rsi,	0
    jl        L219
L220:
    mov       %al,	[%r13+6]
    test      %al,	%al
    jz        L218
L219:
    cmp       %rsi,	0
    jge       L222
    mov       %rax,	%rsi
    neg       %rax
    mov       %rsi,	%rax
    mov       %al,	45
    mov       [%rbp + msys.i64tostrfmt.str],	%al
    jmp       L221
L222:
    mov       %al,	43
    mov       [%rbp + msys.i64tostrfmt.str],	%al
L221:
    movzx     %rax,	byte ptr[%r13+7]
    movzx     %r10,	byte ptr[%r13+2]
    lea       %r11,	[%rbp + msys.i64tostrfmt.str+1]
    mov       %rcx,	%rsi
    mov       %rdx,	%r11
    mov       %r8,	%r10
    mov       %r9,	%rax
    call      msys.u64tostr
    inc       %rax
    mov       %rdi,	%rax
    jmp       L217
L218:
    movzx     %rax,	byte ptr[%r13+7]
    movzx     %r10,	byte ptr[%r13+2]
    mov       %rcx,	%rsi
    lea       %rdx,	[%rbp + msys.i64tostrfmt.str]
    mov       %r8,	%r10
    mov       %r9,	%rax
    call      msys.u64tostr
    mov       %rdi,	%rax
L217:
L215:
    mov       %al,	[%r13+10]
    test      %al,	%al
    jz        L224
    mov       %al,	[%r13+10]
    mov       [%rbp + %rdi + msys.i64tostrfmt.str],	%al
    inc       %rdi
    mov       %rax,	%rdi
    xor       %r10d,	%r10d
    mov       [%rbp + %rax + msys.i64tostrfmt.str],	%r10b
L224:
    movzx     %rax,	byte ptr[%r13+2]
    cmp       %rax,	10
    jg        L227
    mov       %al,	[%r13+10]
    test      %al,	%al
    jz        L226
L227:
    movzx     %rax,	byte ptr[%r13+8]
    cmp       %rax,	97
    jnz       L226
    lea       %rcx,	[%rbp + msys.i64tostrfmt.str]
    call      mlib.convlcstring
L226:
    lea       %rcx,	[%rbp + msys.i64tostrfmt.str]
    mov       %rdx,	%r12
    mov       %r8,	%rdi
    mov       %r9,	%r13
    call      msys.expandstr
L212:
#---------------
    add       %rsp,	392
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.u64tostrfmt
msys.u64tostrfmt:
#?>>
    .set msys.u64tostrfmt.str, -360
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	400
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    movzx     %rax,	byte ptr[%r12+7]
    movzx     %r10,	byte ptr[%r12+2]
    mov       %rcx,	%rbx
    lea       %rdx,	[%rbp + msys.u64tostrfmt.str]
    mov       %r8,	%r10
    mov       %r9,	%rax
    call      msys.u64tostr
    mov       %rdi,	%rax
    mov       %al,	[%r12+10]
    test      %al,	%al
    jz        L230
    mov       %al,	[%r12+10]
    mov       [%rbp + %rdi + msys.u64tostrfmt.str],	%al
    inc       %rdi
    mov       %rax,	%rdi
    xor       %r10d,	%r10d
    mov       [%rbp + %rax + msys.u64tostrfmt.str],	%r10b
L230:
    movzx     %rax,	byte ptr[%r12+2]
    cmp       %rax,	10
    jg        L233
    mov       %al,	[%r12+10]
    test      %al,	%al
    jz        L232
    movzx     %rax,	byte ptr[%r12+8]
    cmp       %rax,	97
    jnz       L232
L233:
L232:
    lea       %rcx,	[%rbp + msys.u64tostrfmt.str]
    mov       %rdx,	%rsi
    mov       %r8,	%rdi
    mov       %r9,	%r12
    call      msys.expandstr
L228:
#---------------
    add       %rsp,	400
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.i64mintostr
msys.i64mintostr:
#?>>
    .set msys.i64mintostr.t, -360
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	392
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       %r15,	%r8
#---------------
    mov       %rax,	%r14
    cmp       %rax,	10
    jz        L236
    cmp       %rax,	16
    jz        L237
    cmp       %rax,	2
    jz        L238
    jmp       L239
L236:
    lea       %rax,	[%rbp + msys.i64mintostr.t]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8369]
    call      strcpy
    mov       %rbx,	3
    jmp       L235
L237:
    lea       %rax,	[%rbp + msys.i64mintostr.t]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8370]
    call      strcpy
    mov       %rbx,	1
    jmp       L235
L238:
    lea       %rax,	[%rbp + msys.i64mintostr.t]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8371]
    call      strcpy
    mov       %rbx,	7
    jmp       L235
L239:
    lea       %rax,	[%rbp + msys.i64mintostr.t]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8372]
    call      strcpy
L235:
    lea       %rax,	[%rbp + msys.i64mintostr.t]
    mov       %rcx,	%rax
    call      strlen
    mov       %rdi,	%rax
    mov       %rax,	%rdi
    add       %r13,	%rax
    test      %r15,	%r15
    jz        L241
    mov       %rax,	%rbx
    add       %r13,	%rax
L241:
    xor       %eax,	%eax
    mov       [%r13],	%al
    xor       %rsi,	%rsi
    mov       %rax,	%r14
    cmp       %rax,	10
    jnz       L243
    mov       %rax,	3
    jmp       L242
L243:
    mov       %rax,	4
L242:
    mov       %r12,	%rax
    jmp       L245
L244:
    dec       %r13
    mov       %rax,	%rdi
    dec       %rdi
    mov       %al,	[%rbp + %rax + msys.i64mintostr.t-1]
    mov       [%r13],	%al
    test      %r15,	%r15
    jz        L248
    test      %rdi,	%rdi
    jz        L248
    inc       %rsi
    cmp       %rsi,	%r12
    jnz       L248
    dec       %r13
    mov       [%r13],	%r15b
    xor       %rsi,	%rsi
L248:
L245:
    test      %rdi,	%rdi
    jnz       L244
    mov       %rcx,	%r13
    call      strlen
L234:
#---------------
    add       %rsp,	392
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.strtostrfmt
msys.strtostrfmt:
#?>>
    .set msys.strtostrfmt.n, 80
    .set msys.strtostrfmt.fmt, 88
    .set msys.strtostrfmt.str, -256
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	288
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       [%rbp+80],	%r8
    mov       [%rbp+88],	%r9
#---------------
    xor       %r12,	%r12
    mov       %rax,	[%rbp + msys.strtostrfmt.fmt]
    mov       %al,	[%rax+3]
    test      %al,	%al
    jnz       L252
    mov       %rax,	[%rbp + msys.strtostrfmt.fmt]
    mov       %al,	[%rax+8]
    test      %al,	%al
    jz        L251
L252:
    mov       %rax,	[%rbp + msys.strtostrfmt.n]
    cmp       %rax,	256
    jge       L254
    lea       %rax,	[%rbp + msys.strtostrfmt.str]
    mov       %rdi,	%rax
    jmp       L253
L254:
    mov       %rax,	[%rbp + msys.strtostrfmt.n]
    add       %rax,	3
    mov       %r12,	%rax
    mov       %rcx,	%r12
    call      mlib.pcm_alloc
    mov       %rdi,	%rax
L253:
    mov       %rax,	[%rbp + msys.strtostrfmt.fmt]
    mov       %al,	[%rax+3]
    test      %al,	%al
    jz        L256
    mov       %rbx,	%rdi
    mov       %rax,	[%rbp + msys.strtostrfmt.fmt]
    mov       %al,	[%rax+3]
    mov       [%rbx],	%al
    inc       %rbx
    mov       %rax,	[%rbp + msys.strtostrfmt.n]
    test      %rax,	%rax
    jz        L258
    mov       %rcx,	%rbx
    mov       %rdx,	%r13
    call      strcpy
    mov       %rax,	[%rbp + msys.strtostrfmt.n]
    add       %rbx,	%rax
L258:
    mov       %rax,	[%rbp + msys.strtostrfmt.fmt]
    mov       %al,	[%rax+3]
    mov       [%rbx],	%al
    inc       %rbx
    xor       %eax,	%eax
    mov       [%rbx],	%al
    mov       %rax,	2
    add       [%rbp + msys.strtostrfmt.n],	%rax
    jmp       L255
L256:
    mov       %rcx,	%rdi
    mov       %rdx,	%r13
    mov       %r8,	[%rbp + msys.strtostrfmt.n]
    call      memcpy
L255:
    mov       %rax,	[%rbp + msys.strtostrfmt.fmt]
    movzx     %rax,	byte ptr[%rax+8]
    cmp       %rax,	97
    jz        L260
    cmp       %rax,	65
    jz        L261
    jmp       L262
L260:
    mov       %rcx,	%rdi
    call      mlib.convlcstring
    jmp       L259
L261:
    mov       %rcx,	%rdi
    call      mlib.convucstring
L262:
L259:
    mov       %r13,	%rdi
L251:
    mov       %rax,	[%rbp + msys.strtostrfmt.fmt]
    movzx     %rax,	byte ptr[%rax]
    mov       %rsi,	%rax
    cmp       %rsi,	[%rbp + msys.strtostrfmt.n]
    jle       L264
    mov       %rcx,	%r13
    mov       %rdx,	%r14
    mov       %r8,	[%rbp + msys.strtostrfmt.n]
    mov       %r9,	[%rbp + msys.strtostrfmt.fmt]
    call      msys.expandstr
    mov       [%rbp + msys.strtostrfmt.n],	%rax
    jmp       L263
L264:
    mov       %rcx,	%r14
    mov       %rdx,	%r13
    mov       %r8,	[%rbp + msys.strtostrfmt.n]
    call      memcpy
L263:
    test      %r12,	%r12
    jz        L266
    mov       %rcx,	%rdi
    mov       %rdx,	%r12
    call      mlib.pcm_free
L266:
    mov       %rax,	[%rbp + msys.strtostrfmt.n]
L249:
#---------------
    add       %rsp,	288
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.tostr_i64
msys.tostr_i64:
#?>>
    .set msys.tostr_i64.a, 32
    .set msys.tostr_i64.str, -360
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	400
    mov       [%rbp+32],	%rcx
    mov       %rbx,	%rdx
#---------------
    movzx     %rax,	byte ptr[%rbx+12]
    test      %rax,	%rax
    jz        L269
    cmp       %rax,	77
    jz        L270
    jmp       L271
L269:
    mov       %rcx,	[%rbp + msys.tostr_i64.a]
    lea       %rdx,	[%rbp + msys.tostr_i64.str]
    mov       %r8,	%rbx
    call      msys.i64tostrfmt
    mov       %rdi,	%rax
    jmp       L268
L270:
    lea       %rcx,	[%rbp + msys.tostr_i64.a]
    mov       %rdx,	8
    lea       %r8,	[%rbp + msys.tostr_i64.str]
    mov       %r9,	%rbx
    call      msys.domultichar
    mov       %rdi,	%rax
    jmp       L268
L271:
    mov       %rcx,	[%rbp + msys.tostr_i64.a]
    xor       %edx,	%edx
    call      msys.m$print_c8
    jmp       L267
L268:
    lea       %rcx,	[%rbp + msys.tostr_i64.str]
    mov       %rdx,	%rdi
    call      msys.printstr_n
L267:
#---------------
    add       %rsp,	400
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.tostr_u64
msys.tostr_u64:
#?>>
    .set msys.tostr_u64.a, 32
    .set msys.tostr_u64.str, -360
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	400
    mov       [%rbp+32],	%rcx
    mov       %rbx,	%rdx
#---------------
    movzx     %rax,	byte ptr[%rbx+12]
    cmp       %rax,	77
    jz        L274
    cmp       %rax,	67
    jz        L275
    jmp       L276
L274:
    lea       %rcx,	[%rbp + msys.tostr_u64.a]
    mov       %rdx,	8
    lea       %r8,	[%rbp + msys.tostr_u64.str]
    mov       %r9,	%rbx
    call      msys.domultichar
    mov       %rdi,	%rax
    jmp       L273
L275:
    mov       %rcx,	[%rbp + msys.tostr_u64.a]
    xor       %edx,	%edx
    call      msys.m$print_c8
    jmp       L272
L276:
    mov       %rcx,	[%rbp + msys.tostr_u64.a]
    lea       %rdx,	[%rbp + msys.tostr_u64.str]
    mov       %r8,	%rbx
    call      msys.u64tostrfmt
    mov       %rdi,	%rax
L273:
    lea       %rcx,	[%rbp + msys.tostr_u64.str]
    mov       %rdx,	%rdi
    call      msys.printstr_n
L272:
#---------------
    add       %rsp,	400
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.tostr_r64
msys.tostr_r64:
#?>>
    .set msys.tostr_r64.str, -360
    .set msys.tostr_r64.str2, -720
    .set msys.tostr_r64.cfmt, -736
    push      %rdi
    push      %rbx
    movq      %rax,	%XMM15
    push      %rax
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	776
    movq      %XMM15,	%XMM0
    mov       %rbx,	%rdx
#---------------
    mov       %al,	37
    mov       [%rbp + msys.tostr_r64.cfmt],	%al
    mov       %al,	[%rbx+1]
    test      %al,	%al
    jz        L279
    mov       %al,	46
    mov       [%rbp + msys.tostr_r64.cfmt+1],	%al
    mov       %al,	42
    mov       [%rbp + msys.tostr_r64.cfmt+2],	%al
    mov       %al,	[%rbx+5]
    mov       [%rbp + msys.tostr_r64.cfmt+3],	%al
    xor       %eax,	%eax
    mov       [%rbp + msys.tostr_r64.cfmt+4],	%al
    movsx     %rax,	byte ptr[%rbx+1]
    lea       %rcx,	[%rbp + msys.tostr_r64.str]
    lea       %rdx,	[%rbp + msys.tostr_r64.cfmt]
    mov       %r8,	%rax
    movq      %XMM3,	%XMM15
    movq      %r9,	%XMM3
    call      sprintf
    jmp       L278
L279:
    mov       %al,	[%rbx+5]
    mov       [%rbp + msys.tostr_r64.cfmt+1],	%al
    xor       %eax,	%eax
    mov       [%rbp + msys.tostr_r64.cfmt+2],	%al
    lea       %rcx,	[%rbp + msys.tostr_r64.str]
    lea       %rdx,	[%rbp + msys.tostr_r64.cfmt]
    movq      %XMM2,	%XMM15
    movq      %r8,	%XMM2
    call      sprintf
L278:
    lea       %rcx,	[%rbp + msys.tostr_r64.str]
    call      strlen
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rbx]
    mov       %r10,	%rdi
    cmp       %r10,	%rax
    jge       L281
    lea       %rcx,	[%rbp + msys.tostr_r64.str]
    lea       %rdx,	[%rbp + msys.tostr_r64.str2]
    mov       %r8,	%rdi
    mov       %r9,	%rbx
    call      msys.expandstr
    mov       %rdi,	%rax
    lea       %rcx,	[%rbp + msys.tostr_r64.str]
    lea       %rdx,	[%rbp + msys.tostr_r64.str2]
    call      strcpy
L281:
    lea       %rcx,	[%rbp + msys.tostr_r64.str]
    mov       %rdx,	%rdi
    call      msys.printstr_n
#---------------
    add       %rsp,	776
    pop       %rbp
    pop       %rcx
    movq      %XMM15,	%rcx
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.tostr_str
msys.tostr_str:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
#---------------
    cmp       %r13,	-1
    jnz       L284
    mov       %rcx,	%r12
    call      strlen
    mov       %r13,	%rax
L284:
    mov       %rdi,	%r13
    mov       %al,	[%r14+3]
    test      %al,	%al
    jnz       L287
    movzx     %rax,	byte ptr[%r14]
    cmp       %rax,	%rdi
    jg        L287
    mov       %al,	[%r14+8]
    test      %al,	%al
    jnz       L287
    mov       %al,	[%r14+1]
    test      %al,	%al
    jz        L286
L287:
    mov       %al,	[%r14+3]
    test      %al,	%al
    jz        L289
    mov       %rax,	2
    add       %rdi,	%rax
L289:
    movzx     %rax,	byte ptr[%r14]
    cmp       %rax,	%rdi
    jle       L291
    movzx     %rax,	byte ptr[%r14]
    mov       %rdi,	%rax
L291:
    lea       %rax,	[%rdi+1]
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       %rsi,	%rax
    mov       %rcx,	%r12
    mov       %rdx,	%rsi
    mov       %r8,	%r13
    mov       %r9,	%r14
    call      msys.strtostrfmt
    mov       %rbx,	%rax
    mov       %al,	[%r14+1]
    test      %al,	%al
    jz        L293
    movsx     %rax,	byte ptr[%r14+1]
    cmp       %rbx,	%rax
    jle       L8373
    mov       %rbx,	%rax
L8373:
L293:
    mov       %rcx,	%rsi
    mov       %rdx,	%rbx
    call      msys.printstr_n
    lea       %rax,	[%rdi+1]
    mov       %rcx,	%rsi
    mov       %rdx,	%rax
    call      mlib.pcm_free
    jmp       L285
L286:
    mov       %rcx,	%r12
    mov       %rdx,	%r13
    call      msys.printstr_n
L285:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.getfmt
msys.getfmt:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    test      %rdi,	%rdi
    jz        L296
    mov       %rcx,	%rdi
    mov       %rdx,	-1
    lea       %r8,	[%rip+msys.getfmt.fmt]
    call      msys.strtofmt
    lea       %rax,	[%rip+msys.getfmt.fmt]
    jmp       L295
L296:
    lea       %rax,	[%rip+msys.defaultfmt]
L295:
L294:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc msys.strint
msys.strint:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    lea       %rcx,	[%rip+msys.strint.str]
    call      msys.m$print_startstr
    mov       %rcx,	%rsi
    call      msys.getfmt
    mov       %r10,	%rax
    mov       %rdi,	%r10
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      msys.tostr_i64
    call      msys.m$print_end
    lea       %rcx,	[%rip+msys.strint.str]
    mov       %rdx,	%rdi
    call      msys.getstr
L297:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.getstrint
msys.getstrint:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rbx
    call      msys.m$print_startstr
    xor       %ecx,	%ecx
    call      msys.getfmt
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      msys.tostr_i64
    call      msys.m$print_end
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.strword
msys.strword:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    lea       %rcx,	[%rip+msys.strword.str]
    call      msys.m$print_startstr
    mov       %rcx,	%rsi
    call      msys.getfmt
    mov       %r10,	%rax
    mov       %rdi,	%r10
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      msys.tostr_u64
    call      msys.m$print_end
    lea       %rcx,	[%rip+msys.strword.str]
    mov       %rdx,	%rdi
    call      msys.getstr
L299:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.strreal
msys.strreal:
#?>>
    push      %rdi
    push      %rbx
    movq      %rax,	%XMM15
    push      %rax
#?]]
    sub       %rsp,	48
    movq      %XMM15,	%XMM0
    mov       %rbx,	%rdx
#---------------
    lea       %rcx,	[%rip+msys.strreal.str]
    call      msys.m$print_startstr
    mov       %rcx,	%rbx
    call      msys.getfmt
    mov       %r10,	%rax
    mov       %rdi,	%r10
    movq      %XMM0,	%XMM15
    mov       %rdx,	%rax
    call      msys.tostr_r64
    call      msys.m$print_end
    lea       %rcx,	[%rip+msys.strreal.str]
    mov       %rdx,	%rdi
    call      msys.getstr
L300:
#---------------
    add       %rsp,	48
    pop       %rcx
    movq      %XMM15,	%rcx
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.getstr
msys.getstr:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %al,	[%rbx+13]
    test      %al,	%al
    jz        L303
    mov       %rcx,	%rdi
    call      mlib.pcm_copyheapstring
    jmp       L302
L303:
    mov       %rax,	%rdi
L302:
L301:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.initreadbuffer
msys.initreadbuffer:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    mov       %rax,	[%rip+msys.rd_buffer]
    test      %rax,	%rax
    jnz       L304
L306:
    mov       %rcx,	16384
    call      mlib.pcm_alloc
    mov       [%rip+msys.rd_buffer],	%rax
    xor       %eax,	%eax
    mov       %r10,	[%rip+msys.rd_buffer]
    mov       [%r10],	%al
    mov       %rax,	[%rip+msys.rd_buffer]
    mov       [%rip+msys.rd_lastpos],	%rax
    mov       [%rip+msys.rd_pos],	%rax
L304:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc msys.m$read_conline
msys.m$read_conline:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    call      msys.initreadbuffer
    xor       %ecx,	%ecx
    mov       %rdx,	[%rip+msys.rd_buffer]
    mov       %r8,	16384
    call      mlib.readlinen
    mov       %rcx,	[%rip+msys.rd_buffer]
    call      strlen
    mov       [%rip+msys.rd_length],	%rax
    mov       %rax,	[%rip+msys.rd_buffer]
    mov       [%rip+msys.rd_pos],	%rax
    xor       %eax,	%eax
    mov       [%rip+msys.rd_lastpos],	%rax
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc msys.m$read_fileline
msys.m$read_fileline:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    call      msys.initreadbuffer
    cmp       %rdi,	1
    jnz       L310
    lea       %rcx,	[%rip+L8374]
    call      mlib.abortprogram
    jmp       L308
L310:
    mov       %rcx,	%rdi
    mov       %rdx,	[%rip+msys.rd_buffer]
    mov       %r8,	16384
    call      mlib.readlinen
    mov       %rcx,	[%rip+msys.rd_buffer]
    call      strlen
    mov       [%rip+msys.rd_length],	%rax
    mov       %rax,	[%rip+msys.rd_buffer]
    mov       [%rip+msys.rd_pos],	%rax
    xor       %eax,	%eax
    mov       [%rip+msys.rd_lastpos],	%rax
L308:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc msys.m$read_strline
msys.m$read_strline:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    call      msys.initreadbuffer
    mov       %rcx,	%rbx
    call      strlen
    mov       %rdi,	%rax
    cmp       %rdi,	16384
    jge       L313
    mov       %rcx,	[%rip+msys.rd_buffer]
    mov       %rdx,	%rbx
    call      strcpy
    jmp       L312
L313:
    mov       %rcx,	[%rip+msys.rd_buffer]
    mov       %rdx,	%rbx
    mov       %r8,	16383
    call      memcpy
    mov       %rax,	[%rip+msys.rd_buffer]
    lea       %rax,	[%rax+16384]
    sub       %rax,	1
    xor       %r10d,	%r10d
    mov       [%rax],	%r10b
L312:
    mov       [%rip+msys.rd_length],	%rdi
    mov       %rax,	[%rip+msys.rd_buffer]
    mov       [%rip+msys.rd_pos],	%rax
    xor       %eax,	%eax
    mov       [%rip+msys.rd_lastpos],	%rax
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.readitem
msys.readitem:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r14,	%rcx
#---------------
    mov       %rax,	[%rip+msys.rd_buffer]
    test      %rax,	%rax
    jnz       L316
    call      msys.initreadbuffer
L316:
    mov       %rbx,	[%rip+msys.rd_pos]
    jmp       L318
L317:
    inc       %rbx
L318:
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	32
    jz        L317
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	9
    jz        L317
    mov       %rsi,	%rbx
    mov       %rax,	%rbx
    mov       [%rip+msys.rd_pos],	%rax
    mov       [%rip+msys.rd_lastpos],	%rax
    movzx     %rax,	byte ptr[%rbx]
    test      %rax,	%rax
    jnz       L321
    xor       %eax,	%eax
    mov       [%rip+msys.termchar],	%rax
    xor       %eax,	%eax
    mov       [%r14],	%rax
    mov       %rax,	%rbx
    jmp       L314
L321:
    xor       %r12b,	%r12b
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	34
    jnz       L323
    mov       %r12b,	34
    inc       %rbx
    jmp       L322
L323:
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	39
    jnz       L324
    mov       %r12b,	39
    inc       %rbx
L324:
L322:
    mov       %rax,	%rbx
    mov       %rsi,	%rax
    mov       %rdi,	%rax
    jmp       L326
L325:
    mov       %rax,	%rbx
    inc       %rbx
    mov       %r13b,	[%rax]
    movzx     %rax,	%r13b
    cmp       %rax,	32
    jz        L329
    cmp       %rax,	9
    jz        L329
    cmp       %rax,	44
    jz        L329
    cmp       %rax,	61
    jnz       L330
L329:
    test      %r12b,	%r12b
    jnz       L333
    cmp       %rdi,	%rbx
    jnz       L332
L333:
    jmp       L334
L332:
    movzx     %rax,	%r13b
    mov       [%rip+msys.termchar],	%rax
    jmp       L327
L330:
#msys.readitem.normalchar:
L334:
    movzx     %rax,	%r13b
    movzx     %r10,	%r12b
    cmp       %rax,	%r10
    jnz       L336
    movzx     %rax,	byte ptr[%rbx]
    movzx     %r10,	%r12b
    cmp       %rax,	%r10
    jnz       L338
    mov       [%rdi],	%r13b
    inc       %rbx
    inc       %rdi
    jmp       L337
L338:
    movzx     %rax,	byte ptr[%rbx]
    mov       [%rip+msys.termchar],	%rax
    mov       %rax,	[%rip+msys.termchar]
    cmp       %rax,	44
    jz        L341
    cmp       %rax,	61
    jnz       L340
L341:
    inc       %rbx
    movzx     %rax,	byte ptr[%rbx]
    mov       [%rip+msys.termchar],	%rax
L340:
    jmp       L327
L337:
    jmp       L335
L336:
    mov       [%rdi],	%r13b
    inc       %rdi
L335:
L328:
L326:
    mov       %al,	[%rbx]
    test      %al,	%al
    jnz       L325
L327:
    movzx     %rax,	byte ptr[%rbx]
    test      %rax,	%rax
    jnz       L343
    xor       %eax,	%eax
    mov       [%rip+msys.termchar],	%rax
L343:
    mov       %rax,	%rdi
    sub       %rax,	%rsi
    mov       [%r14],	%rax
    mov       [%rip+msys.rd_pos],	%rbx
    mov       %rax,	%rsi
L314:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.strtoint
msys.strtoint:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       %r15,	%r8
#---------------
    xor       %eax,	%eax
    mov       [%rip+msys.itemerror],	%rax
    cmp       %r14,	-1
    jnz       L346
    mov       %rcx,	%r13
    call      strlen
    mov       %r14,	%rax
L346:
    xor       %dil,	%dil
    mov       %rax,	%r14
    test      %rax,	%rax
    jz        L348
    movzx     %rax,	byte ptr[%r13]
    cmp       %rax,	45
    jnz       L348
    mov       %dil,	1
    inc       %r13
    dec       %r14
    jmp       L347
L348:
    test      %r14,	%r14
    jz        L349
    movzx     %rax,	byte ptr[%r13]
    cmp       %rax,	43
    jnz       L349
    inc       %r13
    dec       %r14
L349:
L347:
    xor       %rbx,	%rbx
    jmp       L351
L350:
    mov       %rax,	%r13
    inc       %r13
    movzx     %rax,	byte ptr[%rax]
    mov       %rsi,	%rax
    dec       %r14
    mov       %rax,	%rsi
    cmp       %rax,	65
    jl        L354
    cmp       %rax,	70
    jg        L354
    lea       %rax,	[%rsi-65]
    add       %rax,	10
    mov       %r12,	%rax
    jmp       L353
L354:
    mov       %rax,	%rsi
    cmp       %rax,	97
    jl        L355
    cmp       %rax,	102
    jg        L355
    lea       %rax,	[%rsi-97]
    add       %rax,	10
    mov       %r12,	%rax
    jmp       L353
L355:
    mov       %rax,	%rsi
    cmp       %rax,	48
    jl        L356
    cmp       %rax,	57
    jg        L356
    lea       %rax,	[%rsi-48]
    mov       %r12,	%rax
    jmp       L353
L356:
    mov       %rax,	%rsi
    cmp       %rax,	95
    jz        L358
    cmp       %rax,	39
    jnz       L357
L358:
    jmp       L351
L357:
    mov       %rax,	1
    mov       [%rip+msys.itemerror],	%rax
    jmp       L352
L353:
    cmp       %r12,	%r15
    jb        L360
    mov       %rax,	1
    mov       [%rip+msys.itemerror],	%rax
    jmp       L352
L360:
    mov       %rax,	%rbx
    mov       %r10,	%r15
    imul      %rax,	%r10
    add       %rax,	%r12
    mov       %rbx,	%rax
L351:
    test      %r14,	%r14
    jnz       L350
L352:
    test      %dil,	%dil
    jz        L362
    mov       %rax,	%rbx
    neg       %rax
    jmp       L361
L362:
    mov       %rax,	%rbx
L361:
L344:
#---------------
    add       %rsp,	48
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.m$read_i64
msys.m$read_i64:
#?>>
    .set msys.m$read_i64.length, -8
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rbx,	%rcx
#---------------
    mov       %rcx,	%rbx
    call      toupper
    movsxd    %r10,	%eax
    mov       %rbx,	%r10
    mov       %rax,	%rbx
    cmp       %rax,	67
    jz        L365
    cmp       %rax,	84
    jz        L366
    cmp       %rax,	69
    jz        L367
    jmp       L368
L365:
    mov       %rax,	[%rip+msys.rd_pos]
    mov       [%rip+msys.rd_lastpos],	%rax
    mov       %rax,	[%rip+msys.rd_pos]
    mov       %al,	[%rax]
    test      %al,	%al
    jz        L370
    mov       %rax,	[%rip+msys.rd_pos]
    inc       qword ptr[%rip+msys.rd_pos]
    movzx     %rax,	byte ptr[%rax]
    jmp       L363
L370:
    xor       %eax,	%eax
    jmp       L363
L369:
    jmp       L364
L366:
    mov       %rax,	[%rip+msys.termchar]
    jmp       L363
L367:
    mov       %rax,	[%rip+msys.itemerror]
    jmp       L363
L368:
L364:
    lea       %rcx,	[%rbp + msys.m$read_i64.length]
    call      msys.readitem
    mov       %rdi,	%rax
    mov       %rax,	%rbx
    test      %rax,	%rax
    jz        L372
    cmp       %rax,	73
    jz        L372
    cmp       %rax,	66
    jz        L373
    cmp       %rax,	72
    jz        L374
    jmp       L375
L372:
    mov       %rcx,	%rdi
    mov       %rdx,	[%rbp + msys.m$read_i64.length]
    mov       %r8,	10
    call      msys.strtoint
    jmp       L363
L373:
    mov       %rcx,	%rdi
    mov       %rdx,	[%rbp + msys.m$read_i64.length]
    mov       %r8,	2
    call      msys.strtoint
    jmp       L363
L374:
    mov       %rcx,	%rdi
    mov       %rdx,	[%rbp + msys.m$read_i64.length]
    mov       %r8,	16
    call      msys.strtoint
    jmp       L363
L375:
L371:
    xor       %eax,	%eax
L363:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.m$read_r64
msys.m$read_r64:
#?>>
    .set msys.m$read_r64.fmt, 24
    .set msys.m$read_r64.str, -512
    .set msys.m$read_r64.length, -520
    .set msys.m$read_r64.numlength, -528
    .set msys.m$read_r64.x, -536
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	568
#---------------
    lea       %rcx,	[%rbp + msys.m$read_r64.length]
    call      msys.readitem
    mov       %rdi,	%rax
    mov       %rax,	[%rbp + msys.m$read_r64.length]
    test      %rax,	%rax
    jz        L379
    mov       %rax,	[%rbp + msys.m$read_r64.length]
    cmp       %rax,	512
    jl        L378
L379:
    movq      %XMM0,	[%rip+L8375]
    jmp       L376
L378:
    lea       %rcx,	[%rbp + msys.m$read_r64.str]
    mov       %rdx,	%rdi
    mov       %r8,	[%rbp + msys.m$read_r64.length]
    call      memcpy
    xor       %eax,	%eax
    mov       %r10,	[%rbp + msys.m$read_r64.length]
    mov       [%rbp + %r10 + msys.m$read_r64.str],	%al
    xor       %eax,	%eax
    mov       [%rip+msys.itemerror],	%rax
    lea       %rcx,	[%rbp + msys.m$read_r64.str]
    lea       %rdx,	[%rip+L8376]
    lea       %r8,	[%rbp + msys.m$read_r64.x]
    lea       %r9,	[%rbp + msys.m$read_r64.numlength]
    call      sscanf
    movsxd    %r10,	%eax
    test      %r10,	%r10
    jz        L382
    movsxd    %rax,	dword ptr[%rbp + msys.m$read_r64.numlength]
    cmp       %rax,	[%rbp + msys.m$read_r64.length]
    jz        L381
L382:
    movq      %XMM4,	[%rip+L8377]
    movq      [%rbp + msys.m$read_r64.x],	%XMM4
    mov       %rax,	1
    mov       [%rip+msys.itemerror],	%rax
L381:
    movq      %XMM0,	[%rbp + msys.m$read_r64.x]
L376:
#---------------
    add       %rsp,	568
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc msys.m$read_str
msys.m$read_str:
#?>>
    .set msys.m$read_str.length, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    xor       %eax,	%eax
    mov       [%rip+msys.itemerror],	%rax
    mov       %rax,	%r12
    cmp       %rax,	76
    jz        L386
    cmp       %rax,	108
    jnz       L385
L386:
    mov       %rdi,	[%rip+msys.rd_pos]
    mov       %rax,	[%rip+msys.rd_buffer]
    mov       %r10,	[%rip+msys.rd_length]
    lea       %rax,	[%rax + %r10]
    sub       %rax,	[%rip+msys.rd_pos]
    mov       [%rbp + msys.m$read_str.length],	%rax
    jmp       L384
L385:
    lea       %rcx,	[%rbp + msys.m$read_str.length]
    call      msys.readitem
    mov       %rdi,	%rax
    mov       %rax,	%r12
    cmp       %rax,	78
    jz        L389
    cmp       %rax,	110
    jnz       L388
L389:
    mov       %rcx,	%rdi
    mov       %rdx,	[%rbp + msys.m$read_str.length]
    call      mlib.iconvlcn
L388:
L384:
    cmp       %rsi,	0
    jle       L391
    mov       %rax,	[%rbp + msys.m$read_str.length]
    cmp       %rax,	%rsi
    jl        L393
    lea       %rax,	[%rsi-1]
    mov       [%rbp + msys.m$read_str.length],	%rax
    mov       %rax,	1
    mov       [%rip+msys.itemerror],	%rax
L393:
L391:
    mov       %rcx,	%rbx
    mov       %rdx,	%rdi
    mov       %r8,	[%rbp + msys.m$read_str.length]
    call      memcpy
    xor       %eax,	%eax
    mov       %r10,	[%rbp + msys.m$read_str.length]
    mov       [%rbx + %r10],	%al
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.readstr
msys.readstr:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rsi
    mov       %r8,	%rbx
    call      msys.m$read_str
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.rereadln
msys.rereadln:
#?>>
#?]]
#---------------
    mov       %rax,	[%rip+msys.rd_buffer]
    mov       [%rip+msys.rd_pos],	%rax
    mov       %rax,	[%rip+msys.rd_pos]
    mov       [%rip+msys.rd_lastpos],	%rax
#---------------
    ret       
# End 
# Proc msys.reread
msys.reread:
#?>>
#?]]
#---------------
    mov       %rax,	[%rip+msys.rd_lastpos]
    mov       [%rip+msys.rd_pos],	%rax
#---------------
    ret       
# End 
# Proc msys.valint
msys.valint:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r12,	%rcx
    mov       %r13,	%rdx
#---------------
    call      msys.initreadbuffer
    mov       %rdi,	[%rip+msys.rd_pos]
    mov       %rbx,	[%rip+msys.rd_lastpos]
    mov       [%rip+msys.rd_pos],	%r12
    mov       %rcx,	%r13
    call      msys.m$read_i64
    mov       %rsi,	%rax
    mov       [%rip+msys.rd_pos],	%rdi
    mov       [%rip+msys.rd_lastpos],	%rbx
    mov       %rax,	%rsi
L397:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.valreal
msys.valreal:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    movq      %rax,	%XMM15
    push      %rax
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
#---------------
    call      msys.initreadbuffer
    mov       %rdi,	[%rip+msys.rd_pos]
    mov       %rbx,	[%rip+msys.rd_lastpos]
    mov       [%rip+msys.rd_pos],	%rsi
    xor       %ecx,	%ecx
    call      msys.m$read_r64
    movq      %XMM15,	%XMM0
    mov       [%rip+msys.rd_pos],	%rdi
    mov       [%rip+msys.rd_lastpos],	%rbx
    movq      %XMM0,	%XMM15
L398:
#---------------
    add       %rsp,	40
    pop       %rcx
    movq      %XMM15,	%rcx
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.mclunimpl
msys.mclunimpl:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    lea       %rcx,	[%rip+L8378]
    mov       %rdx,	%rdi
    call      printf
    mov       %rcx,	1
    call      exit
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc msys.dumpstr
msys.dumpstr:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    mov       %rax,	[%rip+msys.outdev]
    cmp       %rax,	3
    jnz       L402
    mov       %rdi,	[%rip+msys.outchan]
    test      %rsi,	%rsi
    jz        L404
    mov       %rax,	[%rdi]
    mov       %rcx,	%rax
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      memcpy
    mov       %rax,	%rdi
    mov       %r10,	%rsi
    add       [%rax],	%r10
L404:
    mov       %rax,	[%rdi]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10b
    jmp       L400
L402:
    test      %rsi,	%rsi
    jnz       L406
    jmp       L400
L406:
    test      %r12,	%r12
    jz        L408
    cmp       %rsi,	2
    jl        L408
    mov       %rax,	[%rip+msys.outdev]
    cmp       %rax,	1
    jnz       L408
    dec       qword ptr[%rip+msys.printptr]
    mov       %rax,	[%rip+msys.printptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	10
    jnz       L410
    mov       %rax,	[%rip+msys.printptr]
    sub       %rax,	1
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	13
    jnz       L412
    mov       %rax,	[%rip+msys.printptr]
    sub       %rax,	1
    xor       %r10d,	%r10d
    mov       [%rax],	%r10b
    jmp       L411
L412:
    xor       %eax,	%eax
    mov       %r10,	[%rip+msys.printptr]
    mov       [%r10],	%al
L411:
    lea       %rcx,	[%rip+msys.printbuffer]
    call      puts
    jmp       L400
L410:
L408:
    mov       %rax,	[%rip+msys.outdev]
    cmp       %rax,	1
    jz        L414
    cmp       %rax,	2
    jz        L415
    jmp       L416
L414:
    lea       %rcx,	[%rip+L8379]
    mov       %rdx,	%rsi
    mov       %r8,	%rbx
    call      printf
    jmp       L413
L415:
    mov       %rcx,	[%rip+msys.outchan]
    lea       %rdx,	[%rip+L8379]
    mov       %r8,	%rsi
    mov       %r9,	%rbx
    call      fprintf
L416:
L413:
L400:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.dumpprintbuffer
msys.dumpprintbuffer:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    mov       %rax,	[%rip+msys.printlen]
    test      %rax,	%rax
    jz        L419
    lea       %rcx,	[%rip+msys.printbuffer]
    mov       %rdx,	[%rip+msys.printlen]
    mov       %r8,	1
    call      msys.dumpstr
L419:
    call      msys.resetprintbuffer
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc msys.resetprintbuffer
msys.resetprintbuffer:
#?>>
#?]]
#---------------
    lea       %rax,	[%rip+msys.printbuffer]
    mov       [%rip+msys.printptr],	%rax
    xor       %eax,	%eax
    mov       [%rip+msys.printlen],	%rax
#---------------
    ret       
# End 
# Proc msys.addtobuffer
msys.addtobuffer:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rax,	[%rip+msys.printlen]
    add       %rax,	%rbx
    cmp       %rax,	4088
    jl        L423
    call      msys.dumpprintbuffer
L423:
    cmp       %rbx,	4096
    jge       L425
    mov       %rcx,	[%rip+msys.printptr]
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      memcpy
    mov       %rax,	%rbx
    add       [%rip+msys.printptr],	%rax
    mov       %rax,	%rbx
    add       [%rip+msys.printlen],	%rax
    jmp       L421
L425:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      msys.dumpstr
L421:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.m$power_i64
msys.m$power_i64:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    cmp       %rbx,	0
    jge       L428
    xor       %eax,	%eax
    jmp       L427
L428:
    test      %rbx,	%rbx
    jnz       L429
    mov       %rax,	1
    jmp       L427
L429:
    cmp       %rbx,	1
    jnz       L430
    mov       %rax,	%rdi
    jmp       L427
L430:
    mov       %rax,	%rbx
    and       %rax,	1
    jnz       L431
    mov       %rax,	%rbx
    sar       %rax,	1
    mov       %r10,	%rdi
    imul      %r10,	%r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      msys.m$power_i64
    jmp       L427
L431:
    lea       %rax,	[%rbx-1]
    sar       %rax,	1
    mov       %r10,	%rdi
    imul      %r10,	%r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      msys.m$power_i64
    mov       %r10,	%rdi
    imul      %rax,	%r10
L427:
L426:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.getutfsize
msys.getutfsize:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	16
#---------------
    mov       %rax,	%rcx
    inc       %rcx
    movzx     %rax,	byte ptr[%rax]
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L434
    xor       %eax,	%eax
    jmp       L433
L434:
    mov       %eax,	%edi
    shr       %eax,	7
    and       %eax,	1
    test      %rax,	%rax
    jnz       L435
    mov       %rax,	1
    jmp       L433
L435:
    mov       %rax,	%rdi
    shr       %rax,	5
    and       %rax,	7
    cmp       %rax,	6
    jnz       L436
    mov       %rax,	2
    jmp       L433
L436:
    mov       %rax,	%rdi
    shr       %rax,	4
    and       %rax,	15
    cmp       %rax,	14
    jnz       L437
    mov       %rax,	3
    jmp       L433
L437:
    mov       %rax,	%rdi
    shr       %rax,	3
    and       %rax,	31
    cmp       %rax,	30
    jnz       L438
    mov       %rax,	4
    jmp       L433
L438:
    mov       %rax,	1
L433:
L432:
#---------------
    add       %rsp,	16
    pop       %rdi
    ret       
# End 
# Proc mlib.pcm_alloc
mlib.pcm_alloc:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %al,	[%rip+mlib.pcm_setup]
    test      %al,	%al
    jnz       L441
    call      mlib.pcm_init
L441:
    cmp       %rbx,	2048
    jle       L443
    mov       %rcx,	%rbx
    call      mlib.pcm_getac
    mov       [%rip+mlib.alloccode],	%rax
    lea       %rax,	[%rip+mlib.allocupper]
    mov       %r10,	[%rip+mlib.alloccode]
    mov       %rax,	[%rax + %r10*8]
    mov       [%rip+mlib.allocbytes],	%rax
    mov       %rcx,	[%rip+mlib.allocbytes]
    call      mlib.allocmem
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L445
    lea       %rcx,	[%rip+L8380]
    call      mlib.abortprogram
L445:
    mov       %rax,	%rdi
    jmp       L439
L443:
    lea       %rax,	[%rip+mlib.sizeindextable]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       [%rip+mlib.alloccode],	%rax
    lea       %rax,	[%rip+mlib.allocupper]
    mov       %r10,	[%rip+mlib.alloccode]
    mov       %rax,	[%rax + %r10*8]
    mov       [%rip+mlib.allocbytes],	%rax
    lea       %rax,	[%rip+mlib.freelist]
    mov       %r10,	[%rip+mlib.alloccode]
    mov       %rax,	[%rax + %r10*8]
    mov       %rdi,	%rax
    test      %rax,	%rax
    jz        L447
    lea       %rax,	[%rip+mlib.freelist]
    mov       %r10,	[%rip+mlib.alloccode]
    mov       %rax,	[%rax + %r10*8]
    mov       %rax,	[%rax]
    lea       %r10,	[%rip+mlib.freelist]
    mov       %r11,	[%rip+mlib.alloccode]
    mov       [%r10 + %r11*8],	%rax
    mov       %rax,	%rdi
    jmp       L439
L447:
    mov       %rdi,	[%rip+mlib.pcheapptr]
    mov       %rax,	[%rip+mlib.allocbytes]
    add       [%rip+mlib.pcheapptr],	%rax
    mov       %rax,	[%rip+mlib.pcheapptr]
    cmp       %rax,	[%rip+mlib.pcheapend]
    jb        L449
    mov       %rcx,	[%rip+mlib.allocbytes]
    call      mlib.pcm_newblock
    mov       %rdi,	%rax
    mov       %rax,	%rdi
    jmp       L439
L449:
    mov       %rax,	%rdi
L439:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.pcm_free
mlib.pcm_free:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    test      %rsi,	%rsi
    jz        L453
    test      %rbx,	%rbx
    jnz       L452
L453:
    jmp       L450
L452:
    cmp       %rsi,	2048
    jle       L455
    mov       %rcx,	%rbx
    call      free
    jmp       L454
L455:
    lea       %rax,	[%rip+mlib.sizeindextable]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %rdi,	%rax
    lea       %rax,	[%rip+mlib.freelist]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    mov       [%rbx],	%rax
    mov       %rax,	%rbx
    lea       %r10,	[%rip+mlib.freelist]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*8],	%rax
L454:
L450:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.pcm_freeac
mlib.pcm_freeac:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    lea       %rax,	[%rip+mlib.allocupper]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mlib.pcm_free
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.pcm_clearmem
mlib.pcm_clearmem:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    mov       %r8,	%rbx
    call      memset
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.pcm_init
mlib.pcm_init:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
#---------------
    xor       %eax,	%eax
    mov       [%rip+mlib.alloccode],	%rax
    mov       %al,	[%rip+mlib.pcm_setup]
    test      %al,	%al
    jnz       L458
L460:
    xor       %ecx,	%ecx
    call      mlib.pcm_newblock
    mov       %r13,	1
L461:
    mov       %rdi,	1
    mov       %rbx,	16
    jmp       L465
L464:
    mov       %rax,	%rbx
    shl       %rax,	1
    mov       %rbx,	%rax
    inc       %rdi
L465:
    cmp       %r13,	%rbx
    jg        L464
    mov       %al,	%dil
    lea       %r10,	[%rip+mlib.sizeindextable]
    mov       %r11,	%r13
    mov       [%r10 + %r11],	%al
    inc       %r13
    cmp       %r13,	2048
    jle       L461
    mov       %rax,	16
    lea       %r10,	[%rip+mlib.allocupper]
    mov       [%r10+8],	%rax
    mov       %rsi,	16
    mov       %r13,	2
L467:
    mov       %rax,	%rsi
    shl       %rax,	1
    mov       %rsi,	%rax
    mov       %rax,	%rsi
    lea       %r10,	[%rip+mlib.allocupper]
    mov       %r11,	%r13
    mov       [%r10 + %r11*8],	%rax
    cmp       %rsi,	33554432
    jl        L471
    mov       %rbx,	%r13
    jmp       L469
L471:
    inc       %r13
    cmp       %r13,	27
    jle       L467
L469:
    lea       %rax,	[%rbx+1]
    mov       %r13,	%rax
    mov       %r12,	300
    cmp       %r13,	%r12
    jg        L474
L472:
    mov       %rax,	33554432
    add       %rsi,	%rax
    mov       %rax,	%rsi
    mov       %r10,	8589934592
    cmp       %rax,	%r10
    jge       L476
    mov       %rax,	%rsi
    lea       %r10,	[%rip+mlib.allocupper]
    mov       %r11,	%r13
    mov       [%r10 + %r11*8],	%rax
    mov       [%rip+mlib.maxmemory],	%rsi
    jmp       L475
L476:
    lea       %rax,	[%r13-1]
    mov       [%rip+mlib.maxalloccode],	%rax
    jmp       L474
L475:
    inc       %r13
    cmp       %r13,	%r12
    jle       L472
L474:
    mov       %al,	1
    mov       [%rip+mlib.pcm_setup],	%al
L458:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.pcm_getac
mlib.pcm_getac:
#?>>
#?]]
#---------------
    cmp       %rcx,	2048
    jg        L479
    lea       %rax,	[%rip+mlib.sizeindextable]
    mov       %r10,	%rcx
    movzx     %rax,	byte ptr[%rax + %r10]
    jmp       L477
L479:
    lea       %rax,	[%rcx+255]
    sar       %rax,	8
    mov       %rcx,	%rax
    cmp       %rcx,	2048
    jg        L481
    lea       %rax,	[%rip+mlib.sizeindextable]
    mov       %r10,	%rcx
    movzx     %rax,	byte ptr[%rax + %r10]
    add       %rax,	8
    jmp       L477
L481:
    lea       %rax,	[%rcx+63]
    sar       %rax,	6
    mov       %rcx,	%rax
    cmp       %rcx,	2048
    jg        L483
    lea       %rax,	[%rip+mlib.sizeindextable]
    mov       %r10,	%rcx
    movzx     %rax,	byte ptr[%rax + %r10]
    add       %rax,	14
    jmp       L477
L483:
    lea       %rax,	[%rcx-2048]
    add       %rax,	2047
    sar       %rax,	11
    add       %rax,	22
    mov       %rcx,	%rax
    mov       %rax,	%rcx
L477:
#---------------
    ret       
# End 
# Proc mlib.pcm_newblock
mlib.pcm_newblock:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rax,	2097152
    add       [%rip+mlib.pcm_newblock.totalheapsize],	%rax
    xor       %eax,	%eax
    mov       [%rip+mlib.alloccode],	%rax
    mov       %rcx,	2097152
    call      mlib.allocmem
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L486
    lea       %rcx,	[%rip+L8381]
    call      mlib.abortprogram
L486:
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    mov       %r8,	2097152
    call      memset
    mov       [%rip+mlib.pcheapptr],	%rdi
    lea       %rax,	[%rdi+2097152]
    mov       [%rip+mlib.pcheapend],	%rax
    mov       %rax,	[%rip+mlib.pcheapstart]
    test      %rax,	%rax
    jnz       L488
    mov       [%rip+mlib.pcheapstart],	%rdi
L488:
    mov       %rax,	%rbx
    add       [%rip+mlib.pcheapptr],	%rax
    mov       %rax,	%rdi
L484:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.pcm_round
mlib.pcm_round:
#?>>
#?]]
#---------------
    cmp       %rcx,	2048
    jle       L491
    mov       %rax,	%rcx
    jmp       L490
L491:
    lea       %rax,	[%rip+mlib.sizeindextable]
    mov       %r10,	%rcx
    movzx     %rax,	byte ptr[%rax + %r10]
    lea       %r10,	[%rip+mlib.pcm_round.allocbytes]
    movsxd    %r10,	dword ptr[%r10 + %rax*4]
    mov       %rax,	%r10
L490:
L489:
#---------------
    ret       
# End 
# Proc mlib.pcm_allocz
mlib.pcm_allocz:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rcx,	%rbx
    call      mlib.pcm_alloc
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    mov       %r8,	%rbx
    call      memset
    mov       %rax,	%rdi
L492:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.pcm_copyheapstring
mlib.pcm_copyheapstring:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    test      %rsi,	%rsi
    jnz       L495
    xor       %eax,	%eax
    jmp       L493
L495:
    mov       %rcx,	%rsi
    call      strlen
    inc       %rax
    mov       %rbx,	%rax
    mov       %rcx,	%rbx
    call      mlib.pcm_alloc
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	%rsi
    mov       %r8,	%rbx
    call      memcpy
    mov       %rax,	%rdi
L493:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.pcm_copyheapstringn
mlib.pcm_copyheapstringn:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    test      %rbx,	%rbx
    jnz       L498
    xor       %eax,	%eax
    jmp       L496
L498:
    lea       %rax,	[%rsi+1]
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      memcpy
    xor       %eax,	%eax
    mov       [%rdi + %rsi],	%al
    mov       %rax,	%rdi
L496:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.pcm_copyheapblock
mlib.pcm_copyheapblock:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    test      %rsi,	%rsi
    jnz       L501
    xor       %eax,	%eax
    jmp       L499
L501:
    mov       %rcx,	%rsi
    call      mlib.pcm_alloc
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      memcpy
    mov       %rax,	%rdi
L499:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.allocmem
mlib.allocmem:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rcx,	%rbx
    call      malloc
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L504
    mov       %rax,	%rdi
    jmp       L502
L504:
    call      msys.m$print_startcon
    mov       %rcx,	%rbx
    call      msys.m$print_i64_nf
    mov       %rcx,	[%rip+mlib.memtotal]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8382]
    call      mlib.abortprogram
    xor       %eax,	%eax
L502:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.reallocmem
mlib.reallocmem:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      realloc
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L507
    mov       %rax,	%rdi
    jmp       L505
L507:
    call      msys.m$print_startcon
    mov       %rcx,	%rbx
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8383]
    call      mlib.abortprogram
    xor       %eax,	%eax
L505:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.abortprogram
mlib.abortprogram:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    call      msys.m$print_startcon
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8384]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       %rcx,	5
    call      exit
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mlib.getfilesize
mlib.getfilesize:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    mov       %rcx,	%rsi
    call      ftell
    mov       %edi,	%eax
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    mov       %r8,	2
    call      fseek
    mov       %rcx,	%rsi
    call      ftell
    mov       %ebx,	%eax
    mov       %eax,	%edi
    mov       %rcx,	%rsi
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      fseek
    mov       %eax,	%ebx
L509:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.readrandom
mlib.readrandom:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
    mov       %r13,	%r9
#---------------
    mov       %rcx,	%rbx
    mov       %rdx,	%r12
    xor       %r8d,	%r8d
    call      fseek
    mov       %rcx,	%rsi
    mov       %rdx,	1
    mov       %r8,	%r13
    mov       %r9,	%rbx
    call      fread
    mov       %rdi,	%rax
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.writerandom
mlib.writerandom:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
    mov       %r12,	%r9
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rsi
    xor       %r8d,	%r8d
    call      fseek
    mov       %rcx,	%rbx
    mov       %rdx,	1
    mov       %r8,	%r12
    mov       %r9,	%rdi
    call      fwrite
L511:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.setfilepos
mlib.setfilepos:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      fseek
    movsxd    %r10,	%eax
    mov       %rax,	%r10
L512:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.getfilepos
mlib.getfilepos:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      ftell
    movsxd    %r10,	%eax
    mov       %rax,	%r10
L513:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mlib.readfile
mlib.readfile:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
#---------------
    mov       %rcx,	%r13
    lea       %rdx,	[%rip+L8385]
    call      fopen
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L516
    xor       %eax,	%eax
    jmp       L514
L516:
    mov       %rcx,	%rdi
    call      mlib.getfilesize
    mov       %rbx,	%rax
    mov       [%rip+mlib.rfsize],	%rax
    lea       %rax,	[%rbx+2]
    mov       %rcx,	%rax
    call      malloc
    mov       %rsi,	%rax
    test      %rsi,	%rsi
    jnz       L518
    xor       %eax,	%eax
    jmp       L514
L518:
    mov       %rcx,	%rdi
    mov       %rdx,	%rsi
    xor       %r8d,	%r8d
    mov       %r9,	%rbx
    call      mlib.readrandom
    lea       %rax,	[%rsi + %rbx]
    mov       %r12,	%rax
    xor       %eax,	%eax
    mov       [%r12],	%ax
    mov       %rcx,	%rdi
    call      fclose
    mov       %rax,	%rsi
L514:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.writefile
mlib.writefile:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
    mov       %rcx,	%rsi
    lea       %rdx,	[%rip+L8386]
    call      fopen
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L521
    xor       %eax,	%eax
    jmp       L519
L521:
    mov       %rcx,	%rdi
    mov       %rdx,	%r12
    xor       %r8d,	%r8d
    mov       %r9,	%r13
    call      mlib.writerandom
    mov       %rbx,	%rax
    mov       %rcx,	%rdi
    call      fclose
    mov       %rax,	%rbx
L519:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.checkfile
mlib.checkfile:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rcx,	%rbx
    lea       %rdx,	[%rip+L8387]
    call      fopen
    mov       %rdi,	%rax
    test      %rax,	%rax
    jz        L524
    mov       %rcx,	%rdi
    call      fclose
    mov       %rax,	1
    jmp       L522
L524:
    xor       %eax,	%eax
L522:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.readlinen
mlib.readlinen:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       %r15,	%r8
#---------------
    test      %r13,	%r13
    jnz       L527
    call      mnoos.os_getstdin
    mov       %r13,	%rax
L527:
    test      %r13,	%r13
    jnz       L529
    xor       %rsi,	%rsi
    mov       %rax,	%r14
    mov       %rbx,	%rax
L530:
    call      getchar
    movsxd    %r10,	%eax
    mov       %rdi,	%r10
    cmp       %rdi,	13
    jz        L534
    cmp       %rdi,	10
    jz        L534
    cmp       %rdi,	-1
    jnz       L533
L534:
    xor       %eax,	%eax
    mov       [%rbx],	%al
    jmp       L525
L533:
    mov       %rax,	%rbx
    inc       %rbx
    mov       %r10b,	%dil
    mov       [%rax],	%r10b
    inc       %rsi
    lea       %rax,	[%r15-2]
    mov       %r10,	%rsi
    cmp       %r10,	%rax
    jl        L536
    xor       %eax,	%eax
    mov       [%rbx],	%al
    jmp       L525
L536:
    jmp       L530
L529:
    xor       %eax,	%eax
    mov       [%r14],	%al
    lea       %rax,	[%r15-2]
    mov       %rcx,	%r14
    mov       %rdx,	%rax
    mov       %r8,	%r13
    call      fgets
    test      %rax,	%rax
    jz        L525
L538:
    mov       %rcx,	%r14
    call      strlen
    mov       %rsi,	%rax
    test      %rsi,	%rsi
    jnz       L540
    jmp       L525
L540:
    lea       %rax,	[%r14 + %rsi]
    sub       %rax,	1
    mov       %rbx,	%rax
    xor       %r12b,	%r12b
    jmp       L542
L541:
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	13
    jz        L546
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	10
    jnz       L545
L546:
    mov       %r12b,	1
L545:
    mov       %rax,	%rbx
    dec       %rbx
    xor       %r10d,	%r10d
    mov       [%rax],	%r10b
L542:
    cmp       %rbx,	%r14
    jb        L547
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	13
    jz        L541
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	10
    jz        L541
L547:
    test      %r12b,	%r12b
    jnz       L549
    lea       %rax,	[%rsi+4]
    cmp       %rax,	%r15
    jle       L549
    call      msys.m$print_startcon
    mov       %rcx,	%r15
    call      msys.m$print_i64_nf
    mov       %rcx,	%rsi
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8388]
    call      mlib.abortprogram
L549:
L525:
#---------------
    add       %rsp,	48
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.iconvlcn
mlib.iconvlcn:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rdi,	%rsi
    cmp       %rdi,	0
    jle       L553
L551:
    movzx     %rax,	byte ptr[%rbx]
    mov       %rcx,	%rax
    call      tolower
    mov       [%rbx],	%al
    inc       %rbx
    dec       %rdi
    jnz       L551
L553:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.iconvucn
mlib.iconvucn:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rdi,	%rsi
    cmp       %rdi,	0
    jle       L557
L555:
    movzx     %rax,	byte ptr[%rbx]
    mov       %rcx,	%rax
    call      toupper
    mov       [%rbx],	%al
    inc       %rbx
    dec       %rdi
    jnz       L555
L557:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.convlcstring
mlib.convlcstring:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rdi,	%rbx
    jmp       L560
L559:
    movzx     %rax,	byte ptr[%rbx]
    mov       %rcx,	%rax
    call      tolower
    mov       [%rbx],	%al
    inc       %rbx
L560:
    mov       %al,	[%rbx]
    test      %al,	%al
    jnz       L559
    mov       %rax,	%rdi
L558:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.convucstring
mlib.convucstring:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rdi,	%rbx
    jmp       L564
L563:
    movzx     %rax,	byte ptr[%rbx]
    mov       %rcx,	%rax
    call      toupper
    mov       [%rbx],	%al
    inc       %rbx
L564:
    mov       %al,	[%rbx]
    test      %al,	%al
    jnz       L563
    mov       %rax,	%rdi
L562:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.changeext
mlib.changeext:
#?>>
    .set mlib.changeext.newext2, -32
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	64
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    lea       %rax,	[%rip+mlib.changeext.newfile]
    mov       %rcx,	%rax
    mov       %rdx,	%rsi
    call      strcpy
    movzx     %rax,	byte ptr[%r12]
    test      %rax,	%rax
    jz        L568
    cmp       %rax,	46
    jz        L569
    jmp       L570
L568:
    xor       %eax,	%eax
    mov       [%rbp + mlib.changeext.newext2],	%al
    xor       %eax,	%eax
    mov       [%rbp + mlib.changeext.newext2+1],	%al
    jmp       L567
L569:
    lea       %rax,	[%rbp + mlib.changeext.newext2]
    mov       %rcx,	%rax
    mov       %rdx,	%r12
    call      strcpy
    jmp       L567
L570:
    lea       %rax,	[%rbp + mlib.changeext.newext2]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8389]
    call      strcpy
    lea       %rax,	[%rbp + mlib.changeext.newext2]
    mov       %rcx,	%rax
    mov       %rdx,	%r12
    call      strcat
L567:
    mov       %rcx,	%rsi
    mov       %rdx,	1
    call      mlib.extractext
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rdi]
    test      %rax,	%rax
    jz        L572
    cmp       %rax,	46
    jz        L573
    jmp       L574
L572:
    lea       %rax,	[%rbp + mlib.changeext.newext2]
    lea       %r10,	[%rip+mlib.changeext.newfile]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      strcat
    jmp       L571
L573:
    lea       %rax,	[%rbp + mlib.changeext.newext2+1]
    lea       %r10,	[%rip+mlib.changeext.newfile]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      strcat
    jmp       L571
L574:
    mov       %rax,	%rdi
    sub       %rax,	%rsi
    sub       %rax,	2
    mov       %rbx,	%rax
    lea       %rax,	[%rbp + mlib.changeext.newext2]
    lea       %r10,	[%rip+mlib.changeext.newfile]
    mov       %r11,	%rbx
    lea       %r10,	[%r10 + %r11+1]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      strcpy
L571:
    lea       %rax,	[%rip+mlib.changeext.newfile]
L566:
#---------------
    add       %rsp,	64
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.extractext
mlib.extractext:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    mov       %rcx,	%rsi
    call      mlib.extractfile
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rdi]
    test      %rax,	%rax
    jnz       L577
    lea       %rax,	[%rip+L8390]
    jmp       L575
L577:
    mov       %rcx,	%rdi
    call      strlen
    lea       %r10,	[%rdi + %rax]
    sub       %r10,	1
    mov       %rbx,	%r10
    jmp       L579
L578:
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	46
    jnz       L582
    movzx     %rax,	byte ptr[%rbx+1]
    test      %rax,	%rax
    jnz       L584
    test      %r12,	%r12
    jz        L586
    lea       %rax,	[%rip+L8391]
    jmp       L585
L586:
    lea       %rax,	[%rip+L8392]
L585:
    jmp       L575
L584:
    lea       %rax,	[%rbx+1]
    jmp       L575
L582:
    dec       %rbx
L579:
    cmp       %rbx,	%rdi
    jae       L578
    lea       %rax,	[%rip+L8392]
L575:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.extractpath
mlib.extractpath:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    mov       %rcx,	%rsi
    call      strlen
    lea       %r10,	[%rsi + %rax]
    sub       %r10,	1
    mov       %rdi,	%r10
    jmp       L589
L588:
    movzx     %rax,	byte ptr[%rdi]
    cmp       %rax,	92
    jz        L592
    cmp       %rax,	47
    jz        L592
    cmp       %rax,	58
    jnz       L593
L592:
    mov       %rax,	%rdi
    sub       %rax,	%rsi
    inc       %rax
    mov       %rbx,	%rax
    lea       %rcx,	[%rip+mlib.extractpath.str]
    mov       %rdx,	%rsi
    mov       %r8,	%rbx
    call      memcpy
    xor       %eax,	%eax
    lea       %r10,	[%rip+mlib.extractpath.str]
    mov       %r11,	%rbx
    mov       [%r10 + %r11],	%al
    lea       %rax,	[%rip+mlib.extractpath.str]
    jmp       L587
L593:
L591:
    dec       %rdi
L589:
    cmp       %rdi,	%rsi
    jae       L588
    lea       %rax,	[%rip+L8392]
L587:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.extractfile
mlib.extractfile:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rcx,	%rbx
    call      mlib.extractpath
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rdi]
    test      %rax,	%rax
    jnz       L596
    mov       %rax,	%rbx
    jmp       L594
L596:
    mov       %rcx,	%rdi
    call      strlen
    lea       %r10,	[%rbx + %rax]
    mov       %rax,	%r10
L594:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.extractbasefile
mlib.extractbasefile:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
#---------------
    mov       %rcx,	%r13
    call      mlib.extractfile
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    call      strlen
    mov       %r12,	%rax
    test      %r12,	%r12
    jnz       L599
    lea       %rax,	[%rip+L8392]
    jmp       L597
L599:
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      mlib.extractext
    mov       %rbx,	%rax
    mov       %al,	[%rbx]
    test      %al,	%al
    jz        L601
    mov       %rcx,	%rbx
    call      strlen
    mov       %r10,	%r12
    sub       %r10,	%rax
    dec       %r10
    mov       %rsi,	%r10
    lea       %rcx,	[%rip+mlib.extractbasefile.str]
    mov       %rdx,	%rdi
    mov       %r8,	%rsi
    call      memcpy
    xor       %eax,	%eax
    lea       %r10,	[%rip+mlib.extractbasefile.str]
    mov       %r11,	%rsi
    mov       [%r10 + %r11],	%al
    lea       %rax,	[%rip+mlib.extractbasefile.str]
    jmp       L597
L601:
    lea       %rax,	[%rdi + %r12]
    sub       %rax,	1
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	46
    jnz       L603
    lea       %rax,	[%r12-1]
    lea       %rcx,	[%rip+mlib.extractbasefile.str]
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      memcpy
    xor       %eax,	%eax
    lea       %r10,	[%rip+mlib.extractbasefile.str]
    mov       %r11,	%r12
    mov       [%r10 + %r11-1],	%al
    lea       %rax,	[%rip+mlib.extractbasefile.str]
    jmp       L597
L603:
    mov       %rax,	%rdi
L597:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.addext
mlib.addext:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      mlib.extractext
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rdi]
    test      %rax,	%rax
    jnz       L606
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      mlib.changeext
    jmp       L604
L606:
    mov       %rax,	%rbx
L604:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.pcm_alloc32
mlib.pcm_alloc32:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rax,	32
    mov       [%rip+mlib.allocbytes],	%rax
    lea       %rax,	[%rip+mlib.freelist]
    mov       %rax,	[%rax+16]
    mov       %rdi,	%rax
    test      %rax,	%rax
    jz        L609
    lea       %rax,	[%rip+mlib.freelist]
    mov       %rax,	[%rax+16]
    mov       %rax,	[%rax]
    lea       %r10,	[%rip+mlib.freelist]
    mov       [%r10+16],	%rax
    mov       %rax,	%rdi
    jmp       L607
L609:
    mov       %rcx,	32
    call      mlib.pcm_alloc
L607:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mlib.pcm_free32
mlib.pcm_free32:
#?>>
#?]]
#---------------
    lea       %rax,	[%rip+mlib.freelist]
    mov       %rax,	[%rax+16]
    mov       [%rcx],	%rax
    mov       %rax,	%rcx
    lea       %r10,	[%rip+mlib.freelist]
    mov       [%r10+16],	%rax
#---------------
    ret       
# End 
# Proc mlib.outbyte
mlib.outbyte:
#?>>
    .set mlib.outbyte.x, 32
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       [%rbp+32],	%rdx
#---------------
    lea       %rcx,	[%rbp + mlib.outbyte.x]
    mov       %rdx,	1
    mov       %r8,	1
    mov       %r9,	%rdi
    call      fwrite
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc mlib.outu16
mlib.outu16:
#?>>
    .set mlib.outu16.x, 32
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       [%rbp+32],	%rdx
#---------------
    lea       %rcx,	[%rbp + mlib.outu16.x]
    mov       %rdx,	2
    mov       %r8,	1
    mov       %r9,	%rdi
    call      fwrite
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc mlib.outu32
mlib.outu32:
#?>>
    .set mlib.outu32.x, 32
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       [%rbp+32],	%rdx
#---------------
    lea       %rcx,	[%rbp + mlib.outu32.x]
    mov       %rdx,	4
    mov       %r8,	1
    mov       %r9,	%rdi
    call      fwrite
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc mlib.outu64
mlib.outu64:
#?>>
    .set mlib.outu64.x, 32
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       [%rbp+32],	%rdx
#---------------
    lea       %rcx,	[%rbp + mlib.outu64.x]
    mov       %rdx,	8
    mov       %r8,	1
    mov       %r9,	%rdi
    call      fwrite
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc mlib.outstring
mlib.outstring:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rbx
    call      strlen
    inc       %rax
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    mov       %r8,	1
    mov       %r9,	%rdi
    call      fwrite
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.outblock
mlib.outblock:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	1
    mov       %r9,	%rdi
    call      fwrite
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.myeof
mlib.myeof:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rcx,	%rbx
    call      fgetc
    movsxd    %r10,	%eax
    mov       %rdi,	%r10
    cmp       %rdi,	-1
    jnz       L619
    mov       %rax,	1
    jmp       L617
L619:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      ungetc
    xor       %eax,	%eax
L617:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.strbuffer_add
mlib.strbuffer_add:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
#---------------
    cmp       %r14,	-1
    jnz       L622
    mov       %rcx,	%r13
    call      strlen
    mov       %r14,	%rax
L622:
    movsxd    %rax,	dword ptr[%r12+8]
    mov       %rbx,	%rax
    test      %rbx,	%rbx
    jnz       L624
    lea       %rax,	[%r14+1]
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       [%r12],	%rax
    mov       %eax,	[%rip+mlib.allocbytes]
    mov       [%r12+12],	%eax
    mov       [%r12+8],	%r14d
    mov       %rax,	[%r12]
    mov       %rcx,	%rax
    mov       %rdx,	%r13
    mov       %r8,	%r14
    call      memcpy
    mov       %rax,	[%r12]
    xor       %r10d,	%r10d
    mov       %r11,	%r14
    mov       [%rax + %r11],	%r10b
    jmp       L620
L624:
    mov       %rax,	%rbx
    add       %rax,	%r14
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+1]
    movsxd    %r10,	dword ptr[%r12+12]
    cmp       %rax,	%r10
    jle       L626
    lea       %rax,	[%rdi+1]
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       %rsi,	%rax
    mov       %rax,	[%r12]
    mov       %rcx,	%rsi
    mov       %rdx,	%rax
    mov       %r8,	%rbx
    call      memcpy
    mov       [%r12],	%rsi
    mov       %eax,	[%rip+mlib.allocbytes]
    mov       [%r12+12],	%eax
L626:
    mov       %rax,	[%r12]
    mov       %r10,	%rbx
    lea       %rax,	[%rax + %r10]
    mov       %rcx,	%rax
    mov       %rdx,	%r13
    mov       %r8,	%r14
    call      memcpy
    mov       %rax,	[%r12]
    xor       %r10d,	%r10d
    mov       %r11,	%rdi
    mov       [%rax + %r11],	%r10b
    mov       [%r12+8],	%edi
L620:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.gs_init
mlib.gs_init:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	16
    call      mlib.pcm_clearmem
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mlib.gs_free
mlib.gs_free:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %eax,	[%rdi+12]
    test      %eax,	%eax
    jz        L630
    movsxd    %rax,	dword ptr[%rdi+12]
    mov       %r10,	[%rdi]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mlib.pcm_free
L630:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mlib.gs_str
mlib.gs_str:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	-1
    call      mlib.strbuffer_add
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.gs_char
mlib.gs_char:
#?>>
    .set mlib.gs_char.s, -16
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       [%rbp + mlib.gs_char.s],	%bl
    xor       %eax,	%eax
    mov       [%rbp + mlib.gs_char.s+1],	%al
    mov       %rcx,	%rdi
    lea       %rdx,	[%rbp + mlib.gs_char.s]
    mov       %r8,	1
    call      mlib.strbuffer_add
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.gs_strn
mlib.gs_strn:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      mlib.strbuffer_add
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.gs_strvar
mlib.gs_strvar:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rax,	[%rbx]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    mov       %r8,	-1
    call      mlib.strbuffer_add
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.gs_strint
mlib.gs_strint:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      msys.strint
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    mov       %r8,	-1
    call      mlib.strbuffer_add
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.gs_strln
mlib.gs_strln:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mlib.gs_str
    mov       %rcx,	%rdi
    call      mlib.gs_line
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.gs_strsp
mlib.gs_strsp:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mlib.gs_str
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8393]
    call      mlib.gs_str
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.gs_line
mlib.gs_line:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8394]
    mov       %r8,	-1
    call      mlib.strbuffer_add
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mlib.gs_getcol
mlib.gs_getcol:
#?>>
#?]]
#---------------
    movsxd    %rax,	dword ptr[%rcx+8]
L639:
#---------------
    ret       
# End 
# Proc mlib.gs_leftstr
mlib.gs_leftstr:
#?>>
    .set mlib.gs_leftstr.w, 80
    .set mlib.gs_leftstr.padch, 88
    .set mlib.gs_leftstr.str, -2560
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	2592
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       [%rbp+80],	%r8
    mov       [%rbp+88],	%r9
#---------------
    movsxd    %rax,	dword ptr[%r13+8]
    mov       %rdi,	%rax
    lea       %rcx,	[%rbp + mlib.gs_leftstr.str]
    mov       %rdx,	%r14
    call      strcpy
    mov       %rcx,	%r14
    call      strlen
    mov       %r12,	%rax
    mov       %rax,	[%rbp + mlib.gs_leftstr.w]
    sub       %rax,	%r12
    mov       %rsi,	%rax
    cmp       %rsi,	0
    jle       L642
    mov       %rbx,	1
    cmp       %rsi,	1
    jl        L645
L643:
    mov       %rax,	%r12
    add       %rax,	%rbx
    mov       %r10b,	[%rbp + mlib.gs_leftstr.padch]
    mov       [%rbp + %rax + mlib.gs_leftstr.str-1],	%r10b
    inc       %rbx
    cmp       %rbx,	%rsi
    jle       L643
L645:
    mov       %rax,	%r12
    add       %rax,	%rsi
    xor       %r10d,	%r10d
    mov       [%rbp + %rax + mlib.gs_leftstr.str],	%r10b
L642:
    mov       %rcx,	%r13
    lea       %rdx,	[%rbp + mlib.gs_leftstr.str]
    call      mlib.gs_str
#---------------
    add       %rsp,	2592
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.gs_leftint
mlib.gs_leftint:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
    mov       %r12,	%r9
#---------------
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      msys.strint
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    mov       %r8,	%rsi
    mov       %r9,	%r12
    call      mlib.gs_leftstr
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.gs_padto
mlib.gs_padto:
#?>>
    .set mlib.gs_padto.str, -2560
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	2600
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
    movsxd    %rax,	dword ptr[%rsi+8]
    mov       %r10,	%r12
    sub       %r10,	%rax
    mov       %rdi,	%r10
    cmp       %rdi,	0
    jle       L647
L649:
    mov       %rbx,	1
    cmp       %rdi,	1
    jl        L652
L650:
    mov       [%rbp + %rbx + mlib.gs_padto.str-1],	%r13b
    inc       %rbx
    cmp       %rbx,	%rdi
    jle       L650
L652:
    xor       %eax,	%eax
    mov       [%rbp + %rdi + mlib.gs_padto.str],	%al
    mov       %rcx,	%rsi
    lea       %rdx,	[%rbp + mlib.gs_padto.str]
    call      mlib.gs_str
L647:
#---------------
    add       %rsp,	2600
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.gs_println
mlib.gs_println:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    movsxd    %rax,	dword ptr[%rdi+8]
    test      %rax,	%rax
    jz        L653
L655:
    mov       %rax,	[%rdi]
    movsxd    %r10,	dword ptr[%rdi+8]
    xor       %r11d,	%r11d
    mov       [%rax + %r10],	%r11b
    test      %rbx,	%rbx
    jnz       L657
    call      msys.m$print_startcon
    mov       %rcx,	[%rdi]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L656
L657:
    mov       %rcx,	%rbx
    call      msys.m$print_startfile
    mov       %rcx,	[%rdi]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L656:
L653:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.nextcmdparamnew
mlib.nextcmdparamnew:
#?>>
    .set mlib.nextcmdparamnew.defext, 88
    .set mlib.nextcmdparamnew.item, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
    mov       [%rbp+88],	%r9
#---------------
#mlib.nextcmdparamnew.reenter:
L659:
    xor       %eax,	%eax
    mov       [%r14],	%rax
    xor       %eax,	%eax
    mov       [%r13],	%rax
    mov       %rax,	[%rip+mlib.nextcmdparamnew.infile]
    test      %rax,	%rax
    jz        L661
    lea       %rcx,	[%rip+mlib.nextcmdparamnew.fileptr]
    lea       %rdx,	[%rbp + mlib.nextcmdparamnew.item]
    call      mlib.readnextfileitem
    test      %rax,	%rax
    jnz       L663
    mov       %rcx,	[%rip+mlib.nextcmdparamnew.filestart]
    call      free
    xor       %eax,	%eax
    mov       [%rip+mlib.nextcmdparamnew.infile],	%rax
    jmp       L659
L663:
    jmp       L660
L661:
    mov       %rax,	[%r12]
    cmp       %rax,	[%rip+msys.ncmdparams]
    jle       L665
    xor       %eax,	%eax
    jmp       L658
L665:
    mov       %rax,	[%r12]
    mov       %r10,	[%rip+msys.cmdparams]
    mov       %r10,	[%r10 + %rax*8]
    mov       [%rbp + mlib.nextcmdparamnew.item],	%r10
    mov       %rax,	%r12
    inc       qword ptr[%rax]
    mov       %rcx,	[%rbp + mlib.nextcmdparamnew.item]
    call      strlen
    mov       %rsi,	%rax
    mov       %rax,	[%rbp + mlib.nextcmdparamnew.item]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	64
    jnz       L667
    mov       %rax,	[%rbp + mlib.nextcmdparamnew.item]
    lea       %rax,	[%rax+1]
    mov       %rcx,	%rax
    call      mlib.readfile
    mov       [%rip+mlib.nextcmdparamnew.fileptr],	%rax
    mov       [%rip+mlib.nextcmdparamnew.filestart],	%rax
    mov       %rax,	[%rip+mlib.nextcmdparamnew.filestart]
    test      %rax,	%rax
    jnz       L669
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8395]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rbp + mlib.nextcmdparamnew.item]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	7
    call      exit
L669:
    mov       %rax,	1
    mov       [%rip+mlib.nextcmdparamnew.infile],	%rax
    jmp       L659
L667:
    mov       %rax,	[%rbp + mlib.nextcmdparamnew.item]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	58
    jnz       L671
    mov       %al,	1
    mov       [%rip+mlib.nextcmdparamnew.colonseen],	%al
    mov       %rax,	4
    jmp       L658
L671:
L660:
    xor       %eax,	%eax
    mov       [%r14],	%rax
    mov       %rax,	[%rbp + mlib.nextcmdparamnew.item]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	45
    jnz       L673
    mov       %al,	[%rip+mlib.nextcmdparamnew.colonseen]
    test      %al,	%al
    jz        L675
    xor       %eax,	%eax
    jmp       L674
L675:
    mov       %rax,	1
L674:
    mov       %r10,	[%rbp + mlib.nextcmdparamnew.item]
    lea       %r10,	[%r10 + %rax]
    mov       [%r13],	%r10
    mov       %rcx,	[%rbp + mlib.nextcmdparamnew.item]
    mov       %rdx,	58
    call      strchr
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L677
    mov       %rcx,	[%rbp + mlib.nextcmdparamnew.item]
    mov       %rdx,	61
    call      strchr
    mov       %rdi,	%rax
L677:
    test      %rdi,	%rdi
    jz        L679
    lea       %rax,	[%rdi+1]
    mov       [%r14],	%rax
    xor       %eax,	%eax
    mov       [%rdi],	%al
L679:
    mov       %al,	[%rip+mlib.nextcmdparamnew.colonseen]
    test      %al,	%al
    jz        L681
    mov       %rax,	5
    jmp       L680
L681:
    mov       %rax,	1
L680:
    jmp       L658
L673:
    mov       %rcx,	[%rbp + mlib.nextcmdparamnew.item]
    xor       %edx,	%edx
    call      mlib.extractext
    mov       %rbx,	%rax
    mov       %rax,	[%rbp + mlib.nextcmdparamnew.item]
    mov       [%r13],	%rax
    movzx     %rax,	byte ptr[%rbx]
    test      %rax,	%rax
    jnz       L683
    mov       %rax,	[%r13]
    lea       %rcx,	[%rip+mlib.nextcmdparamnew.str]
    mov       %rdx,	%rax
    call      strcpy
    mov       %rax,	[%rbp + mlib.nextcmdparamnew.defext]
    test      %rax,	%rax
    jz        L685
    mov       %al,	[%rip+mlib.nextcmdparamnew.colonseen]
    test      %al,	%al
    jnz       L685
    lea       %rcx,	[%rip+mlib.nextcmdparamnew.str]
    mov       %rdx,	[%rbp + mlib.nextcmdparamnew.defext]
    call      mlib.addext
    mov       [%r13],	%rax
L685:
    jmp       L682
L683:
    mov       %rcx,	%rbx
    lea       %rdx,	[%rip+L8396]
    call      mlib.eqstring
    test      %rax,	%rax
    jnz       L687
    mov       %rcx,	%rbx
    lea       %rdx,	[%rip+L8397]
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L686
L687:
    mov       %al,	[%rip+mlib.nextcmdparamnew.colonseen]
    test      %al,	%al
    jz        L689
    mov       %rax,	5
    jmp       L688
L689:
    mov       %rax,	3
L688:
    jmp       L658
L686:
L682:
    mov       %al,	[%rip+mlib.nextcmdparamnew.colonseen]
    test      %al,	%al
    jz        L691
    mov       %rax,	5
    jmp       L690
L691:
    mov       %rax,	2
L690:
L658:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.readnextfileitem
mlib.readnextfileitem:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r13,	%rcx
    mov       %r14,	%rdx
#---------------
    mov       %rdi,	[%r13]
#mlib.readnextfileitem.reenter:
L693:
L694:
    movzx     %rax,	byte ptr[%rdi]
    cmp       %rax,	32
    jz        L697
    cmp       %rax,	9
    jz        L697
    cmp       %rax,	13
    jz        L697
    cmp       %rax,	10
    jz        L697
    cmp       %rax,	26
    jz        L698
    test      %rax,	%rax
    jz        L698
    jmp       L699
L697:
    inc       %rdi
    jmp       L696
L698:
    xor       %eax,	%eax
    jmp       L692
L699:
    jmp       L695
L696:
    jmp       L694
L695:
    movzx     %rax,	byte ptr[%rdi]
    cmp       %rax,	33
    jz        L701
    cmp       %rax,	35
    jnz       L702
L701:
    inc       %rdi
L703:
    mov       %rax,	%rdi
    inc       %rdi
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	10
    jz        L705
    cmp       %rax,	26
    jz        L706
    test      %rax,	%rax
    jz        L706
    jmp       L707
L705:
    jmp       L693
L706:
    lea       %rax,	[%rdi-1]
    mov       [%r13],	%rax
    xor       %eax,	%eax
    jmp       L692
L707:
    jmp       L703
L702:
L700:
    movzx     %rax,	byte ptr[%rdi]
    cmp       %rax,	34
    jnz       L710
L709:
    inc       %rdi
    mov       %rbx,	%rdi
L711:
    movzx     %rax,	byte ptr[%rdi]
    test      %rax,	%rax
    jz        L714
    cmp       %rax,	26
    jz        L714
    cmp       %rax,	34
    jz        L715
    jmp       L716
L714:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8398]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	8
    call      exit
    jmp       L713
L715:
    mov       %rax,	%rdi
    inc       %rdi
    mov       %rsi,	%rax
    movzx     %rax,	byte ptr[%rdi]
    cmp       %rax,	44
    jnz       L718
    inc       %rdi
L718:
    jmp       L712
L716:
L713:
    inc       %rdi
    jmp       L711
L712:
    jmp       L708
L710:
    mov       %rbx,	%rdi
L719:
    movzx     %rax,	byte ptr[%rdi]
    test      %rax,	%rax
    jz        L722
    cmp       %rax,	26
    jz        L722
    cmp       %rax,	32
    jz        L723
    cmp       %rax,	9
    jz        L723
    cmp       %rax,	44
    jz        L723
    cmp       %rax,	13
    jz        L723
    cmp       %rax,	10
    jz        L723
    jmp       L724
L722:
    mov       %rsi,	%rdi
    jmp       L720
L723:
    mov       %rax,	%rdi
    inc       %rdi
    mov       %rsi,	%rax
    jmp       L720
L724:
L721:
    inc       %rdi
    jmp       L719
L720:
L708:
    mov       %rax,	%rsi
    sub       %rax,	%rbx
    mov       %r12,	%rax
    cmp       %r12,	256
    jl        L726
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8399]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	9
    call      exit
L726:
    lea       %rcx,	[%rip+mlib.readnextfileitem.str]
    mov       %rdx,	%rbx
    mov       %r8,	%r12
    call      memcpy
    xor       %eax,	%eax
    lea       %r10,	[%rip+mlib.readnextfileitem.str]
    mov       %r11,	%r12
    mov       [%r10 + %r11],	%al
    lea       %rax,	[%rip+mlib.readnextfileitem.str]
    mov       [%r14],	%rax
    mov       [%r13],	%rdi
    mov       %rax,	1
L692:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.ipadstr
mlib.ipadstr:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
    mov       %rcx,	%rsi
    call      strlen
    mov       %rdi,	%rax
    mov       %rax,	%r12
    sub       %rax,	%rdi
    mov       %rbx,	%rax
    cmp       %rbx,	0
    jle       L730
L728:
    mov       %rcx,	%rsi
    mov       %rdx,	%r13
    call      strcat
    dec       %rbx
    jnz       L728
L730:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.padstr
mlib.padstr:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    lea       %rcx,	[%rip+mlib.padstr.str]
    mov       %rdx,	%rdi
    call      strcpy
    lea       %rcx,	[%rip+mlib.padstr.str]
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      mlib.ipadstr
    lea       %rax,	[%rip+mlib.padstr.str]
L731:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.chr
mlib.chr:
#?>>
#?]]
#---------------
    mov       %al,	%cl
    lea       %r10,	[%rip+mlib.chr.str]
    mov       [%r10],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+mlib.chr.str]
    mov       [%r10+1],	%al
    lea       %rax,	[%rip+mlib.chr.str]
L732:
#---------------
    ret       
# End 
# Proc mlib.cmpstring
mlib.cmpstring:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      strcmp
    movsxd    %r10,	%eax
    mov       %rdi,	%r10
    cmp       %r10,	0
    jge       L735
    mov       %rax,	-1
    jmp       L734
L735:
    cmp       %rdi,	0
    jle       L736
    mov       %rax,	1
    jmp       L734
L736:
    xor       %eax,	%eax
L734:
L733:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.cmpstringn
mlib.cmpstringn:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      strncmp
    movsxd    %r10,	%eax
    mov       %rdi,	%r10
    cmp       %r10,	0
    jge       L739
    mov       %rax,	-1
    jmp       L738
L739:
    cmp       %rdi,	0
    jle       L740
    mov       %rax,	1
    jmp       L738
L740:
    xor       %eax,	%eax
L738:
L737:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.eqstring
mlib.eqstring:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      strcmp
    movsxd    %r10,	%eax
    cmp       %r10,	0
    setz      %r10b
    movzx     %r10d,	%r10b
    mov       %rax,	%r10
L741:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.cmpbytes
mlib.cmpbytes:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      memcmp
    movsxd    %r10,	%eax
    mov       %rdi,	%r10
    cmp       %r10,	0
    jge       L744
    mov       %rax,	-1
    jmp       L743
L744:
    cmp       %rdi,	0
    jle       L745
    mov       %rax,	1
    jmp       L743
L745:
    xor       %eax,	%eax
L743:
L742:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.eqbytes
mlib.eqbytes:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      memcmp
    movsxd    %r10,	%eax
    cmp       %r10,	0
    setz      %r10b
    movzx     %r10d,	%r10b
    mov       %rax,	%r10
L746:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.mseed
mlib.mseed:
#?>>
#?]]
#---------------
    mov       %rax,	%rcx
    lea       %r10,	[%rip+mlib.seed]
    mov       [%r10],	%rax
    test      %rdx,	%rdx
    jz        L749
    mov       %rax,	%rdx
    lea       %r10,	[%rip+mlib.seed]
    mov       [%r10+8],	%rax
    jmp       L748
L749:
    lea       %rax,	[%rip+mlib.seed]
    lea       %rax,	[%rax+8]
    mov       %r10,	%rcx
    xor       [%rax],	%r10
L748:
#---------------
    ret       
# End 
# Proc mlib.mrandom
mlib.mrandom:
#?>>
    push      %rdi
    push      %rbx
#?]]
#---------------
    lea       %rax,	[%rip+mlib.seed]
    mov       %rdi,	[%rax]
    lea       %rax,	[%rip+mlib.seed]
    mov       %rbx,	[%rax+8]
    mov       %rax,	%rbx
    lea       %r10,	[%rip+mlib.seed]
    mov       [%r10],	%rax
    mov       %rax,	%rdi
    shl       %rax,	23
    xor       %rdi,	%rax
    mov       %rax,	%rdi
    xor       %rax,	%rbx
    mov       %r10,	%rdi
    sar       %r10,	17
    xor       %rax,	%r10
    mov       %r10,	%rbx
    sar       %r10,	26
    xor       %rax,	%r10
    lea       %r10,	[%rip+mlib.seed]
    mov       [%r10+8],	%rax
    lea       %rax,	[%rip+mlib.seed]
    mov       %rax,	[%rax+8]
    add       %rax,	%rbx
L750:
#---------------
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.mrandomp
mlib.mrandomp:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    call      mlib.mrandom
    mov       %r10,	9223372036854775807
    and       %rax,	%r10
L751:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mlib.mrandomint
mlib.mrandomint:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    call      mlib.mrandomp
    mov       %r10,	%rdi
    cqo       
    idiv      %r10
    xchg      %rax,	%rdx
L752:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mlib.mrandomrange
mlib.mrandomrange:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rax,	%rsi
    sub       %rax,	%rbx
    inc       %rax
    mov       %rdi,	%rax
    cmp       %rdi,	0
    jg        L755
    xor       %eax,	%eax
    jmp       L753
L755:
    call      mlib.mrandomp
    mov       %r10,	%rdi
    cqo       
    idiv      %r10
    xchg      %rax,	%rdx
    add       %rax,	%rbx
L753:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.mrandomreal
mlib.mrandomreal:
#?>>
    movq      %rax,	%XMM15
    push      %rax
#?]]
    sub       %rsp,	48
#---------------
L757:
    call      mlib.mrandomp
    cvtsi2sd  %XMM4,	%rax
    divsd     %XMM4,	[%rip+L8400]
    movq      %XMM15,	%XMM4
    movq      %XMM4,	%XMM15
    comisd    %XMM4,	[%rip+L8401]
    jz        L757
    movq      %XMM0,	%XMM15
L756:
#---------------
    add       %rsp,	48
    pop       %rcx
    movq      %XMM15,	%rcx
    ret       
# End 
# Proc mlib.mrandomreal1
mlib.mrandomreal1:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    call      mlib.mrandomp
    cvtsi2sd  %XMM4,	%rax
    divsd     %XMM4,	[%rip+L8402]
    movq      %XMM0,	%XMM4
L760:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mlib.readline
mlib.readline:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    call      msys.m$read_conline
    mov       %rax,	[%rip+msys.rd_buffer]
L761:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mlib.findfunction
mlib.findfunction:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    mov       %rbx,	1
    mov       %rdi,	[%rip+$nprocs]
    cmp       %rdi,	1
    jl        L765
L763:
    lea       %rax,	[%rip+$procname]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rcx,	%rax
    mov       %rdx,	%rsi
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L767
    lea       %rax,	[%rip+$procaddr]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8-8]
    jmp       L762
L767:
    inc       %rbx
    cmp       %rbx,	%rdi
    jle       L763
L765:
    xor       %eax,	%eax
L762:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.roundtoblock
mlib.roundtoblock:
#?>>
#?]]
#---------------
    lea       %rax,	[%rdx-1]
    mov       %r10,	%rcx
    and       %r10,	%rax
    test      %r10,	%r10
    jnz       L770
    mov       %rax,	%rcx
    jmp       L768
L770:
    lea       %rax,	[%rdx-1]
    mov       %r10,	%rcx
    and       %r10,	%rax
    mov       %rax,	%rdx
    sub       %rax,	%r10
    mov       %r10,	%rcx
    add       %r10,	%rax
    mov       %rax,	%r10
L768:
#---------------
    ret       
# End 
# Proc mlib.pcm_allocnfz
mlib.pcm_allocnfz:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rax,	%rbx
    and       %rax,	7
    jz        L773
    mov       %rax,	%rbx
    and       %rax,	7
    mov       %r10,	8
    sub       %r10,	%rax
    mov       %rax,	%rbx
    add       %rax,	%r10
    mov       %rbx,	%rax
L773:
    mov       %rdi,	[%rip+mlib.pcheapptr]
    mov       %rax,	%rbx
    add       [%rip+mlib.pcheapptr],	%rax
    mov       %rax,	[%rip+mlib.pcheapptr]
    cmp       %rax,	[%rip+mlib.pcheapend]
    jb        L775
    mov       %rcx,	%rbx
    call      mlib.pcm_newblock
    mov       %rdi,	%rax
L775:
    mov       %rax,	%rdi
L771:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mnoos.os_init
mnoos.os_init:
#?>>
#?]]
#---------------
#---
#---------------
    ret       
# End 
# Proc mnoos.os_execwait
mnoos.os_execwait:
#?>>
    .set mnoos.os_execwait.cmdline, 16
    .set mnoos.os_execwait.newconsole, 24
    .set mnoos.os_execwait.workdir, 32
#?]]
#---------------
    xor       %eax,	%eax
L777:
#---------------
    ret       
# End 
# Proc mnoos.os_execcmd
mnoos.os_execcmd:
#?>>
    .set mnoos.os_execcmd.cmdline, 16
    .set mnoos.os_execcmd.newconsole, 24
#?]]
#---------------
    xor       %eax,	%eax
L778:
#---------------
    ret       
# End 
# Proc mnoos.os_getch
mnoos.os_getch:
#?>>
#?]]
#---------------
    xor       %eax,	%eax
L779:
#---------------
    ret       
# End 
# Proc mnoos.os_kbhit
mnoos.os_kbhit:
#?>>
#?]]
#---------------
    xor       %eax,	%eax
L780:
#---------------
    ret       
# End 
# Proc mnoos.os_getdllinst
mnoos.os_getdllinst:
#?>>
    .set mnoos.os_getdllinst.name, 16
#?]]
#---------------
    xor       %eax,	%eax
L781:
#---------------
    ret       
# End 
# Proc mnoos.os_getdllprocaddr
mnoos.os_getdllprocaddr:
#?>>
    .set mnoos.os_getdllprocaddr.hinst, 16
    .set mnoos.os_getdllprocaddr.name, 24
#?]]
#---------------
    xor       %eax,	%eax
L782:
#---------------
    ret       
# End 
# Proc mnoos.os_initwindows
mnoos.os_initwindows:
#?>>
#?]]
#---------------
#---
#---------------
    ret       
# End 
# Proc mnoos.os_gxregisterclass
mnoos.os_gxregisterclass:
#?>>
    .set mnoos.os_gxregisterclass.classname, 16
#?]]
#---------------
#---
#---------------
    ret       
# End 
# Proc mnoos.os_setmesshandler
mnoos.os_setmesshandler:
#?>>
    .set mnoos.os_setmesshandler.addr, 16
#?]]
#---------------
#---
#---------------
    ret       
# End 
# Proc mnoos.os_getchx
mnoos.os_getchx:
#?>>
#?]]
#---------------
    mov       %rax,	27
L786:
#---------------
    ret       
# End 
# Proc mnoos.os_getos
mnoos.os_getos:
#?>>
#?]]
#---------------
    lea       %rax,	[%rip+L8403]
L787:
#---------------
    ret       
# End 
# Proc mnoos.os_gethostsize
mnoos.os_gethostsize:
#?>>
#?]]
#---------------
    mov       %rax,	64
L788:
#---------------
    ret       
# End 
# Proc mnoos.os_shellexec
mnoos.os_shellexec:
#?>>
    .set mnoos.os_shellexec.opc, 24
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rdx
#---------------
    mov       %rcx,	%rdi
    call      system
    movsxd    %r10,	%eax
    mov       %rax,	%r10
L789:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mnoos.os_sleep
mnoos.os_sleep:
#?>>
    .set mnoos.os_sleep.a, 16
#?]]
#---------------
#---
#---------------
    ret       
# End 
# Proc mnoos.os_getstdin
mnoos.os_getstdin:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    lea       %rcx,	[%rip+L8404]
    lea       %rdx,	[%rip+L8405]
    call      fopen
L791:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mnoos.os_getstdout
mnoos.os_getstdout:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    lea       %rcx,	[%rip+L8406]
    lea       %rdx,	[%rip+L8407]
    call      fopen
L792:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mnoos.os_gethostname
mnoos.os_gethostname:
#?>>
#?]]
#---------------
    lea       %rax,	[%rip+L8408]
L793:
#---------------
    ret       
# End 
# Proc mnoos.os_getmpath
mnoos.os_getmpath:
#?>>
#?]]
#---------------
    lea       %rax,	[%rip+L8409]
L794:
#---------------
    ret       
# End 
# Proc mnoos.os_clock
mnoos.os_clock:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    call      clock
    movsxd    %r10,	%eax
    mov       %rax,	%r10
L795:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mnoos.os_ticks
mnoos.os_ticks:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    call      clock
    movsxd    %r10,	%eax
    mov       %rax,	%r10
L796:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mnoos.os_iswindows
mnoos.os_iswindows:
#?>>
#?]]
#---------------
    mov       %rax,	1
L797:
#---------------
    ret       
# End 
# Proc mnoos.os_getsystime
mnoos.os_getsystime:
#?>>
    .set mnoos.os_getsystime.$1, 16
#?]]
#---------------
#---
#---------------
    ret       
# End 
# Proc mnoos.os_peek
mnoos.os_peek:
#?>>
#?]]
#---------------
#---
#---------------
    ret       
# End 
# Proc mnoos.os_allocexecmem
mnoos.os_allocexecmem:
#?>>
    .set mnoos.os_allocexecmem.n, 16
#?]]
#---------------
    xor       %eax,	%eax
L800:
#---------------
    ret       
# End 
# Proc mnoos.dirlist
mnoos.dirlist:
#?>>
    .set mnoos.dirlist.filespec, 16
    .set mnoos.dirlist.dest, 24
    .set mnoos.dirlist.capacity, 32
    .set mnoos.dirlist.t, 40
#?]]
#---------------
    xor       %eax,	%eax
L801:
#---------------
    ret       
# End 
# Proc mnoos.os_hpcounter
mnoos.os_hpcounter:
#?>>
#?]]
#---------------
    xor       %eax,	%eax
L802:
#---------------
    ret       
# End 
# Proc mnoos.os_hpfreq
mnoos.os_hpfreq:
#?>>
#?]]
#---------------
    xor       %eax,	%eax
L803:
#---------------
    ret       
# End 
# Proc mwindll.os_calldllfunction
mwindll.os_calldllfunction:
#?>>
    .set mwindll.os_calldllfunction.fnaddr, 16
    .set mwindll.os_calldllfunction.retcode, 24
    .set mwindll.os_calldllfunction.nargs, 32
    .set mwindll.os_calldllfunction.args, 40
    .set mwindll.os_calldllfunction.argcodes, 48
    .set mwindll.os_calldllfunction.a, -8
    .set mwindll.os_calldllfunction.x, -16
    .set mwindll.os_calldllfunction.nextra, -24
    .set mwindll.os_calldllfunction.pushedbytes, -32
    .set mwindll.os_calldllfunction.av_1, -40
    .set mwindll.os_calldllfunction.i, -48
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	80
    mov       [%rbp+16],	%rcx
    mov       [%rbp+24],	%rdx
    mov       [%rbp+32],	%r8
    mov       [%rbp+40],	%r9
#---------------
    xor       %eax,	%eax
    mov       [%rbp + mwindll.os_calldllfunction.nextra],	%rax
    mov       %rax,	[%rbp + mwindll.os_calldllfunction.nargs]
    cmp       %rax,	4
    jge       L806
    mov       %rax,	4
    sub       %rax,	[%rbp + mwindll.os_calldllfunction.nargs]
    mov       [%rbp + mwindll.os_calldllfunction.nextra],	%rax
    jmp       L805
L806:
    mov       %eax,	[%rbp + mwindll.os_calldllfunction.nargs]
    and       %eax,	1
    test      %rax,	%rax
    jz        L807
    mov       %rax,	1
    mov       [%rbp + mwindll.os_calldllfunction.nextra],	%rax
L807:
L805:
    mov       %rax,	[%rbp + mwindll.os_calldllfunction.nextra]
    add       %rax,	[%rbp + mwindll.os_calldllfunction.nargs]
    shl       %rax,	3
    mov       [%rbp + mwindll.os_calldllfunction.pushedbytes],	%rax
    mov       %rax,	[%rbp + mwindll.os_calldllfunction.nextra]
    mov       [%rbp + mwindll.os_calldllfunction.av_1],	%rax
    mov       %rax,	[%rbp + mwindll.os_calldllfunction.av_1]
    cmp       %rax,	0
    jle       L810
L808:
    push      0
    dec       qword ptr[%rbp + mwindll.os_calldllfunction.av_1]
    jnz       L808
L810:
    mov       %rax,	[%rbp + mwindll.os_calldllfunction.nargs]
    mov       [%rbp + mwindll.os_calldllfunction.i],	%rax
    mov       %rax,	[%rbp + mwindll.os_calldllfunction.i]
    cmp       %rax,	1
    jl        L813
L811:
    mov       %rax,	[%rbp + mwindll.os_calldllfunction.args]
    mov       %r10,	[%rbp + mwindll.os_calldllfunction.i]
    mov       %rax,	[%rax + %r10*8-8]
    mov       [%rbp + mwindll.os_calldllfunction.a],	%rax
    push      qword ptr[%rbp + mwindll.os_calldllfunction.a]
    mov       %rax,	[%rbp + mwindll.os_calldllfunction.i]
    dec       %rax
    mov       [%rbp + mwindll.os_calldllfunction.i],	%rax
    cmp       %rax,	1
    jge       L811
L813:
    mov       %rcx,	[%rsp]
    movq      %XMM0,	[%rsp]
    mov       %rdx,	[%rsp+8]
    movq      %XMM1,	[%rsp+8]
    mov       %r8,	[%rsp+16]
    movq      %XMM2,	[%rsp+16]
    mov       %r9,	[%rsp+24]
    movq      %XMM3,	[%rsp+24]
    mov       %rax,	[%rbp + mwindll.os_calldllfunction.retcode]
    cmp       %rax,	73
    jnz       L815
    mov       %rax,	[%rbp + mwindll.os_calldllfunction.fnaddr]
    call      %rax
    mov       [%rbp + mwindll.os_calldllfunction.a],	%rax
    add       %rsp,	[%rbp + mwindll.os_calldllfunction.pushedbytes]
    mov       %rax,	[%rbp + mwindll.os_calldllfunction.a]
    jmp       L814
L815:
    mov       %rax,	[%rbp + mwindll.os_calldllfunction.fnaddr]
    call      %rax
    movq      [%rbp + mwindll.os_calldllfunction.x],	%XMM0
    add       %rsp,	[%rbp + mwindll.os_calldllfunction.pushedbytes]
    movq      %XMM4,	[%rbp + mwindll.os_calldllfunction.x]
    movq      %rax,	%XMM4
L814:
L804:
#---------------
    add       %rsp,	80
    pop       %rbp
    ret       
# End 
# Proc pc_api.pcl_start
pc_api.pcl_start:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %al,	[%rip+pc_decls.pcldone]
    test      %al,	%al
    jz        L818
    lea       %rcx,	[%rip+L8410]
    call      pc_api.pclerror
L818:
    test      %rdi,	%rdi
    jz        L820
    mov       %rcx,	%rdi
    mov       %rdx,	9
    call      pc_api.pc_makesymbol
    mov       [%rip+pc_decls.currprog],	%rax
L820:
    mov       %rax,	[%rip+pc_api.initpcalloc]
    mov       [%rip+pc_api.pcalloc],	%rax
    test      %rbx,	%rbx
    jz        L822
    mov       %rax,	%rbx
    lea       %rax,	[%rax + %rax*8]
    sar       %rax,	3
    mov       %rbx,	%rax
    jmp       L824
L823:
    mov       %rax,	[%rip+pc_api.pcalloc]
    shl       %rax,	1
    mov       [%rip+pc_api.pcalloc],	%rax
L824:
    mov       %rax,	[%rip+pc_api.pcalloc]
    cmp       %rax,	%rbx
    jl        L823
L822:
    mov       %rax,	[%rip+pc_api.pcalloc]
    shl       %rax,	5
    mov       %rcx,	%rax
    call      mlib.pcm_allocz
    mov       [%rip+pc_api.pcstart],	%rax
    mov       %rax,	[%rip+pc_api.pcstart]
    mov       %r10,	[%rip+pc_api.pcalloc]
    shl       %r10,	5
    lea       %rax,	[%rax + %r10]
    sub       %rax,	256
    mov       [%rip+pc_api.pcend],	%rax
    mov       %rax,	[%rip+pc_api.pcstart]
    sub       %rax,	32
    mov       [%rip+pc_api.pccurr],	%rax
    xor       %eax,	%eax
    mov       [%rip+pc_api.pcfixed],	%al
    xor       %eax,	%eax
    mov       [%rip+pc_api.pcseqno],	%rax
    xor       %eax,	%eax
    mov       [%rip+pc_api.pcneedfntable],	%rax
    xor       %eax,	%eax
    mov       [%rip+pc_api.mlabelno],	%rax
    mov       %rax,	[%rip+pc_decls.currprog]
L816:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pcl_end
pc_api.pcl_end:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    mov       %rax,	[%rip+pc_api.pccurr]
    cmp       %rax,	[%rip+pc_api.pccurr]
    jb        L828
    mov       %rax,	[%rip+pc_api.pccurr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	136
    jz        L828
    mov       %rcx,	136
    xor       %edx,	%edx
    call      pc_api.pc_gen
L828:
    mov       %al,	1
    mov       [%rip+pc_decls.pcldone],	%al
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc pc_api.pcl_writepcl
pc_api.pcl_writepcl:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    call      pc_diags.writeallpcl
    mov       %rdi,	%rax
    test      %rbx,	%rbx
    jz        L831
    mov       %al,	[%rip+pc_decls.pverbose]
    test      %al,	%al
    jz        L833
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8411]
    call      msys.m$print_str_nf
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L833:
    movsxd    %rax,	dword ptr[%rdi+8]
    mov       %r10,	[%rdi]
    mov       %rcx,	%rbx
    mov       %rdx,	%r10
    mov       %r8,	%rax
    call      mlib.writefile
    lea       %rax,	[%rip+L8412]
    jmp       L830
L831:
    mov       %rax,	[%rdi]
L830:
L829:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pcl_writepst
pc_api.pcl_writepst:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    call      pc_diags.writepst
    mov       %rdi,	%rax
    test      %rbx,	%rbx
    jz        L836
    mov       %al,	[%rip+pc_decls.pverbose]
    test      %al,	%al
    jz        L838
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8413]
    call      msys.m$print_str_nf
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L838:
    movsxd    %rax,	dword ptr[%rdi+8]
    mov       %r10,	[%rdi]
    mov       %rcx,	%rbx
    mov       %rdx,	%r10
    mov       %r8,	%rax
    call      mlib.writefile
    lea       %rax,	[%rip+L8414]
    jmp       L835
L836:
    mov       %rax,	[%rdi]
L835:
L834:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pcl_genmcl
pc_api.pcl_genmcl:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    xor       %ecx,	%ecx
    call      mc_genmcl.genmcl
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc pc_api.pcl_genss
pc_api.pcl_genss:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    xor       %ecx,	%ecx
    call      mc_genmcl.genmcl
    mov       %rcx,	%rdi
    call      mc_genss_dummy.genss
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc pc_api.pcl_writess
pc_api.pcl_writess:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    xor       %ecx,	%ecx
    call      mc_genmcl.genmcl
    mov       %rcx,	%r12
    call      mc_genss_dummy.genss
    mov       %rax,	%r12
    test      %rax,	%rax
    setz      %al
    movzx     %eax,	%al
    mov       %rcx,	%rax
    call      mc_writess_dummy.writessdata
    mov       %rdi,	%rax
    test      %rsi,	%rsi
    jz        L843
    mov       %rcx,	%rsi
    lea       %rdx,	[%rip+L8415]
    call      fopen
    mov       %rbx,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mlib.gs_println
    mov       %rcx,	%rbx
    call      fclose
    mov       %rcx,	%rdi
    call      mlib.gs_free
    xor       %eax,	%eax
    jmp       L842
L843:
    mov       %rax,	[%rdi]
L842:
L841:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pcl_writeasm
pc_api.pcl_writeasm:
#?>>
    .set pc_api.pcl_writeasm.atype, 48
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    mov       %rax,	[%rip+pc_decls.assemtype]
    cmp       %rax,	1297301838
    jnz       L846
    mov       %al,	2
    mov       [%rip+pc_api.phighmem],	%al
L846:
    xor       %ecx,	%ecx
    call      mc_genmcl.genmcl
    call      mc_writegas.getassemstr
    mov       %rdi,	%rax
    test      %rsi,	%rsi
    jz        L848
    mov       %al,	[%rip+pc_decls.pverbose]
    test      %al,	%al
    jz        L850
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8416]
    call      msys.m$print_str_nf
    mov       %rcx,	%rsi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L850:
    mov       %rcx,	%rsi
    lea       %rdx,	[%rip+L8417]
    call      fopen
    mov       %rbx,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mlib.gs_println
    mov       %rcx,	%rbx
    call      fclose
    mov       %rcx,	%rdi
    call      mlib.gs_free
    xor       %eax,	%eax
    jmp       L847
L848:
    mov       %rax,	[%rdi]
L847:
L844:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pcl_writeobj
pc_api.pcl_writeobj:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    xor       %ecx,	%ecx
    call      mc_genmcl.genmcl
    mov       %rcx,	1
    call      mc_genss_dummy.genss
    call      mnoos.os_clock
    mov       %rdi,	%rax
    mov       %rcx,	%rbx
    call      mc_writeobj_dummy.writecoff
    call      mnoos.os_clock
    sub       %rax,	%rdi
    mov       [%rip+pc_decls.objtime],	%rax
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pcl_writedll
pc_api.pcl_writedll:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %al,	2
    mov       [%rip+pc_api.phighmem],	%al
    xor       %ecx,	%ecx
    call      mc_genmcl.genmcl
    xor       %ecx,	%ecx
    call      mc_genss_dummy.genss
    call      mnoos.os_clock
    mov       %rdi,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      mc_writeexe_dummy.writeexe
    call      mnoos.os_clock
    sub       %rax,	%rdi
    mov       [%rip+pc_decls.exetime],	%rax
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pcl_writeexe
pc_api.pcl_writeexe:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    xor       %ecx,	%ecx
    call      mc_genmcl.genmcl
    xor       %ecx,	%ecx
    call      mc_genss_dummy.genss
    call      mnoos.os_clock
    mov       %rdi,	%rax
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      mc_writeexe_dummy.writeexe
    call      mnoos.os_clock
    sub       %rax,	%rdi
    mov       [%rip+pc_decls.exetime],	%rax
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pcl_writemx
pc_api.pcl_writemx:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    xor       %ecx,	%ecx
    call      mc_genmcl.genmcl
    xor       %ecx,	%ecx
    call      mc_genss_dummy.genss
    mov       %rcx,	%rdi
    call      mx_run_dummy.writemcx
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc pc_api.pcl_exec
pc_api.pcl_exec:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    xor       %ecx,	%ecx
    call      mc_genmcl.genmcl
    xor       %ecx,	%ecx
    call      mc_genss_dummy.genss
    lea       %rcx,	[%rip+L8418]
    mov       %rdx,	[%rip+pc_decls.pcmdskip]
    call      mx_run_dummy.runlibfile
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc pc_api.pcl_setflags
pc_api.pcl_setflags:
#?>>
#?]]
#---------------
    cmp       %rcx,	0
    jl        L858
    mov       [%rip+pc_api.phighmem],	%cl
L858:
    cmp       %rdx,	0
    jl        L860
    mov       [%rip+pc_decls.pverbose],	%dl
L860:
    cmp       %r8,	0
    jl        L862
    mov       [%rip+pc_api.fpshortnames],	%r8b
L862:
#---------------
    ret       
# End 
# Proc pc_api.extendpclblock
pc_api.extendpclblock:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rax,	[%rip+pc_api.pcalloc]
    shl       %rax,	1
    mov       %rdi,	%rax
    mov       %rax,	[%rip+pc_api.pccurr]
    sub       %rax,	[%rip+pc_api.pcstart]
    shr       %rax,	5
    inc       %rax
    mov       %rbx,	%rax
    mov       %rax,	32
    mov       %r10,	%rdi
    imul      %rax,	%r10
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       %rsi,	%rax
    mov       %rax,	%rbx
    shl       %rax,	5
    mov       %rcx,	%rsi
    mov       %rdx,	[%rip+pc_api.pcstart]
    mov       %r8,	%rax
    call      memcpy
    mov       %rax,	%rdi
    sub       %rax,	%rbx
    shl       %rax,	5
    mov       %r10,	%rbx
    shl       %r10,	5
    lea       %r11,	[%rsi + %r10]
    mov       %rcx,	%r11
    mov       %rdx,	%rax
    call      mlib.pcm_clearmem
    mov       %rax,	[%rip+pc_api.pccurr]
    sub       %rax,	[%rip+pc_api.pcstart]
    shr       %rax,	5
    shl       %rax,	5
    lea       %r10,	[%rsi + %rax]
    mov       [%rip+pc_api.pccurr],	%r10
    mov       %rax,	%rdi
    shl       %rax,	5
    lea       %r10,	[%rsi + %rax]
    sub       %r10,	256
    mov       [%rip+pc_api.pcend],	%r10
    mov       %rax,	[%rip+pc_api.pcalloc]
    shl       %rax,	5
    mov       %rcx,	[%rip+pc_api.pcstart]
    mov       %rdx,	%rax
    call      mlib.pcm_free
    mov       [%rip+pc_api.pcstart],	%rsi
    mov       [%rip+pc_api.pcalloc],	%rdi
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.newpcl
pc_api.newpcl:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    mov       %rax,	[%rip+pc_api.pccurr]
    cmp       %rax,	[%rip+pc_api.pcend]
    jb        L866
    call      pc_api.extendpclblock
L866:
    add       qword ptr[%rip+pc_api.pccurr],	32
    mov       %eax,	[%rip+pc_decls.mmpos]
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+24],	%eax
    inc       qword ptr[%rip+pc_api.pclseqno]
    mov       %rax,	[%rip+pc_api.pclseqno]
    mov       %r10,	[%rip+pc_api.pccurr]
    lea       %r10,	[%r10+28]
    mov       %r9d,	[%r10]
    mov       %r11,	-4294967041
    shl       %eax,	8
    and       %r9d,	%r11d
    or        %r9d,	%eax
    mov       [%r10],	%r9d
    inc       qword ptr[%rip+pc_decls.npcl]
    mov       %rax,	[%rip+pc_api.pccurr]
L864:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc pc_api.pc_gen
pc_api.pc_gen:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    test      %rbx,	%rbx
    jnz       L869
    call      pc_api.newpcl
    mov       %rbx,	%rax
L869:
    mov       [%rbx],	%dil
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pc_genix
pc_api.pc_genix:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    call      pc_api.newpcl
    mov       %rdi,	%rax
    mov       [%rdi],	%bl
    mov       [%rdi+16],	%esi
    mov       [%rdi+20],	%r12d
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pc_genx
pc_api.pc_genx:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    test      %rsi,	%rsi
    jnz       L873
    call      pc_api.newpcl
    mov       %rsi,	%rax
L873:
    mov       [%rsi],	%dil
    mov       [%rsi+16],	%ebx
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pc_genxy
pc_api.pc_genxy:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
    mov       %r12,	%r9
#---------------
    test      %r12,	%r12
    jnz       L876
    call      pc_api.newpcl
    mov       %r12,	%rax
L876:
    mov       [%r12],	%dil
    mov       [%r12+16],	%ebx
    mov       [%r12+20],	%esi
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pc_gencond
pc_api.pc_gencond:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    test      %rsi,	%rsi
    jnz       L879
    call      pc_api.newpcl
    mov       %rsi,	%rax
L879:
    mov       [%rsi],	%dil
    mov       [%rsi+2],	%bl
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.genint
pc_api.genint:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    call      pc_api.newpcl
    mov       %rdi,	%rax
    mov       [%rdi+8],	%rbx
    mov       %al,	4
    mov       [%rdi+1],	%al
    mov       %rax,	%rdi
L880:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.genreal
pc_api.genreal:
#?>>
    push      %rdi
    push      %rbx
    movq      %rax,	%XMM15
    push      %rax
#?]]
    sub       %rsp,	48
    movq      %XMM15,	%XMM0
    mov       %rbx,	%rdx
#---------------
    call      pc_api.newpcl
    mov       %rdi,	%rax
    movq      %XMM4,	%XMM15
    movq      [%rdi+8],	%XMM4
    cmp       %rbx,	2
    jnz       L883
    mov       %rax,	5
    jmp       L882
L883:
    mov       %rax,	6
L882:
    mov       [%rdi+1],	%al
    mov       %rax,	%rdi
L881:
#---------------
    add       %rsp,	48
    pop       %rcx
    movq      %XMM15,	%rcx
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.genrealimm
pc_api.genrealimm:
#?>>
    push      %rdi
    push      %rbx
    movq      %rax,	%XMM15
    push      %rax
#?]]
    sub       %rsp,	48
    movq      %XMM15,	%XMM0
    mov       %rbx,	%rdx
#---------------
    call      pc_api.newpcl
    mov       %rdi,	%rax
    movq      %XMM4,	%XMM15
    movq      [%rdi+8],	%XMM4
    cmp       %rbx,	2
    jnz       L886
    mov       %rax,	10
    jmp       L885
L886:
    mov       %rax,	11
L885:
    mov       [%rdi+1],	%al
    mov       %rax,	%rdi
L884:
#---------------
    add       %rsp,	48
    pop       %rcx
    movq      %XMM15,	%rcx
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.genstring
pc_api.genstring:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    call      pc_api.newpcl
    mov       %rdi,	%rax
    cmp       %rsi,	0
    jge       L889
    mov       %rcx,	%rbx
    call      strlen
    inc       %rax
    mov       %rsi,	%rax
L889:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      mlib.pcm_copyheapstringn
    mov       [%rdi+8],	%rax
    mov       %al,	7
    mov       [%rdi+1],	%al
    mov       [%rdi+16],	%esi
    mov       %rax,	%rdi
L887:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.genpcstrimm
pc_api.genpcstrimm:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    call      pc_api.newpcl
    mov       %rdi,	%rax
    mov       %rcx,	%rbx
    call      mlib.pcm_copyheapstring
    mov       [%rdi+8],	%rax
    mov       %al,	8
    mov       [%rdi+1],	%al
    mov       %rax,	%rdi
L890:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.genlabel
pc_api.genlabel:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    call      pc_api.newpcl
    mov       %rdi,	%rax
    mov       [%rdi+8],	%rbx
    mov       %al,	3
    mov       [%rdi+1],	%al
    mov       %rax,	%rdi
L891:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.genmem
pc_api.genmem:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    call      pc_api.newpcl
    mov       %rdi,	%rax
    mov       [%rdi+8],	%rbx
    mov       %al,	1
    mov       [%rdi+1],	%al
    mov       %rax,	%rdi
L892:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.genmemaddr
pc_api.genmemaddr:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    call      pc_api.newpcl
    mov       %rdi,	%rax
    mov       [%rdi+8],	%rbx
    mov       %al,	2
    mov       [%rdi+1],	%al
    mov       %rax,	%rdi
L893:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.gendata
pc_api.gendata:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    call      pc_api.newpcl
    mov       %rdi,	%rax
    mov       [%rdi+8],	%rbx
    mov       %al,	12
    mov       [%rdi+1],	%al
    mov       %al,	11
    mov       [%rdi+3],	%al
    mov       [%rdi+4],	%esi
    mov       %rax,	%rdi
L894:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.gencomment
pc_api.gencomment:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %al,	[%rip+pc_decls.fregoptim]
    test      %al,	%al
    jnz       L898
    mov       %al,	[%rip+pc_decls.fpeephole]
    test      %al,	%al
    jz        L897
L898:
    jmp       L895
L897:
    mov       %rcx,	%rdi
    call      pc_api.genpcstrimm
    mov       %rcx,	135
    mov       %rdx,	%rax
    call      pc_api.pc_gen
L895:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc pc_api.genname
pc_api.genname:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	8
    call      pc_api.pc_makesymbol
    mov       %rcx,	%rax
    call      pc_api.genmem
L899:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc pc_api.gennameaddr
pc_api.gennameaddr:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	8
    call      pc_api.pc_makesymbol
    mov       %rcx,	%rax
    call      pc_api.genmemaddr
L900:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc pc_api.genassem
pc_api.genassem:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    call      pc_api.newpcl
    mov       %rdi,	%rax
    mov       [%rdi+8],	%rbx
    mov       %al,	9
    mov       [%rdi+1],	%al
    mov       %rax,	%rdi
L901:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.strpmode
pc_api.strpmode:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    lea       %rcx,	[%rip+pc_api.strpmode.str]
    lea       %rdx,	[%rip+L8419]
    call      strcpy
    mov       %rax,	%rdi
    cmp       %rax,	11
    jz        L904
    test      %rax,	%rax
    jz        L905
    jmp       L906
L904:
    lea       %rcx,	[%rip+pc_api.strpmode.str]
    lea       %rdx,	[%rip+L8420]
    call      strcpy
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      msys.strint
    lea       %rcx,	[%rip+pc_api.strpmode.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rax,	[%rip+pc_api.strpmode.str]
    jmp       L903
L905:
    lea       %rax,	[%rip+L8421]
    jmp       L903
L906:
    lea       %rax,	[%rip+pc_tables.pstdnames]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
L903:
L902:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pc_setmode
pc_api.pc_setmode:
#?>>
#?]]
#---------------
    mov       %al,	%cl
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+3],	%al
    test      %rdx,	%rdx
    jz        L909
    mov       %eax,	%edx
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+4],	%eax
    jmp       L908
L909:
    mov       %rax,	[%rip+pc_api.pccurr]
    movzx     %rax,	byte ptr[%rax+3]
    lea       %r10,	[%rip+pc_tables.psize]
    movzx     %r10,	byte ptr[%r10 + %rax]
    mov       %rax,	[%rip+pc_api.pccurr]
    mov       [%rax+4],	%r10d
L908:
    mov       %rax,	[%rip+pc_api.pccurr]
    movzx     %rax,	byte ptr[%rax]
    lea       %r10,	[%rip+pc_tables.pclhastype]
    movzx     %r10,	byte ptr[%r10 + %rax]
    cmp       %r10,	2
    jnz       L911
    mov       %rax,	[%rip+pc_api.pccurr]
    movzx     %rax,	byte ptr[%rax+3]
    mov       %r10,	[%rip+pc_api.pccurr]
    lea       %r10,	[%r10+28]
    mov       %r9d,	[%r10]
    mov       %r11,	-256
    and       %r9d,	%r11d
    or        %r9d,	%eax
    mov       [%r10],	%r9d
L911:
#---------------
    ret       
# End 
# Proc pc_api.pc_setmode2
pc_api.pc_setmode2:
#?>>
#?]]
#---------------
    mov       %rax,	[%rip+pc_api.pccurr]
    lea       %rax,	[%rax+28]
    mov       %r10d,	%ecx
    mov       %r9d,	[%rax]
    mov       %r11,	-256
    and       %r9d,	%r11d
    or        %r9d,	%r10d
    mov       [%rax],	%r9d
#---------------
    ret       
# End 
# Proc pc_api.pc_setxy
pc_api.pc_setxy:
#?>>
#?]]
#---------------
    mov       %eax,	%ecx
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+16],	%eax
    mov       %eax,	%edx
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+20],	%eax
#---------------
    ret       
# End 
# Proc pc_api.pc_setscaleoff
pc_api.pc_setscaleoff:
#?>>
#?]]
#---------------
    mov       %eax,	%ecx
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+16],	%eax
    mov       %eax,	%edx
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+20],	%eax
#---------------
    ret       
# End 
# Proc pc_api.pc_setoffset
pc_api.pc_setoffset:
#?>>
#?]]
#---------------
    mov       %eax,	%ecx
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+20],	%eax
#---------------
    ret       
# End 
# Proc pc_api.pc_addoffset
pc_api.pc_addoffset:
#?>>
#?]]
#---------------
    mov       %rax,	[%rip+pc_api.pccurr]
    lea       %rax,	[%rax+20]
    mov       %r10d,	%ecx
    add       [%rax],	%r10d
#---------------
    ret       
# End 
# Proc pc_api.pc_setincr
pc_api.pc_setincr:
#?>>
#?]]
#---------------
    mov       %eax,	%ecx
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+16],	%eax
#---------------
    ret       
# End 
# Proc pc_api.pc_setnargs
pc_api.pc_setnargs:
#?>>
#?]]
#---------------
    mov       %eax,	%ecx
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+16],	%eax
#---------------
    ret       
# End 
# Proc pc_api.pc_setnvariadics
pc_api.pc_setnvariadics:
#?>>
#?]]
#---------------
    mov       %eax,	%ecx
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+20],	%eax
#---------------
    ret       
# End 
# Proc pc_api.pc_setalign
pc_api.pc_setalign:
#?>>
#?]]
#---------------
    mov       %eax,	%ecx
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+16],	%eax
#---------------
    ret       
# End 
# Proc pc_api.perror
pc_api.perror:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      pc_api.perror_s
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc pc_api.perror_s
pc_api.perror_s:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8422]
    call      msys.m$print_str_nf
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    call      msys.m$print_end
    test      %rbx,	%rbx
    jz        L924
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8423]
    call      msys.m$print_str_nf
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    call      msys.m$print_end
L924:
    mov       %rcx,	1
    call      exit
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.getbasename
pc_api.getbasename:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rcx,	%rbx
    call      strlen
    lea       %r10,	[%rbx + %rax]
    sub       %r10,	1
    mov       %rdi,	%r10
    jmp       L927
L926:
    dec       %rdi
L927:
    cmp       %rdi,	%rbx
    jbe       L929
    lea       %rax,	[%rdi-1]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	46
    jnz       L926
L929:
    mov       %rax,	%rdi
L925:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pclerror
pc_api.pclerror:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8424]
    call      msys.m$print_str_nf
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	1
    call      exit
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc pc_api.pc_addsymbol
pc_api.pc_addsymbol:
#?>>
#?]]
#---------------
    mov       %rax,	[%rip+pc_decls.psymboltable]
    test      %rax,	%rax
    jnz       L933
    mov       %rax,	%rcx
    mov       [%rip+pc_decls.psymboltablex],	%rax
    mov       [%rip+pc_decls.psymboltable],	%rax
    jmp       L932
L933:
    mov       %rax,	%rcx
    mov       %r10,	[%rip+pc_decls.psymboltablex]
    mov       [%r10+8],	%rax
    mov       [%rip+pc_decls.psymboltablex],	%rcx
L932:
#---------------
    ret       
# End 
# Proc pc_api.pc_makesymbol
pc_api.pc_makesymbol:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    inc       qword ptr[%rip+pc_decls.npst]
    mov       %rcx,	128
    call      mlib.pcm_allocnfz
    mov       %rdi,	%rax
    mov       %rcx,	%rbx
    call      mlib.pcm_copyheapstring
    mov       [%rdi],	%rax
    inc       qword ptr[%rip+pc_api.stseqno]
    mov       %rax,	[%rip+pc_api.stseqno]
    mov       [%rdi+120],	%eax
    mov       %rax,	%rsi
    cmp       %rax,	1
    jz        L936
    cmp       %rax,	7
    jz        L937
    jmp       L938
L936:
    mov       %al,	1
    mov       [%rdi+80],	%al
    jmp       L935
L937:
    mov       %al,	1
    mov       [%rdi+81],	%al
    mov       %rsi,	2
L938:
L935:
    mov       [%rdi+72],	%sil
    mov       %rax,	%rsi
    cmp       %rax,	4
    jz        L941
    cmp       %rax,	5
    jnz       L940
L941:
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       [%rdi+32],	%rax
    jmp       L939
L940:
    test      %rsi,	%rsi
    jz        L942
    mov       %rcx,	%rdi
    call      pc_api.pc_addsymbol
L942:
L939:
    mov       %rax,	%rdi
L934:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.getfullname
pc_api.getfullname:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    xor       %rdi,	%rdi
    mov       %rax,	%rsi
    mov       %rbx,	%rax
    xor       %eax,	%eax
    lea       %r10,	[%rip+pc_api.getfullname.str]
    mov       [%r10],	%al
    test      %r12,	%r12
    jz        L945
    lea       %rcx,	[%rip+pc_api.getfullname.str]
    lea       %rdx,	[%rip+L8425]
    call      strcpy
L945:
    mov       %al,	[%rsi+80]
    test      %al,	%al
    jz        L947
    test      %r12,	%r12
    jz        L949
    mov       %rax,	[%rsi]
    lea       %rcx,	[%rip+pc_api.getfullname.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rcx,	[%rip+pc_api.getfullname.str]
    lea       %rdx,	[%rip+L8426]
    call      strcat
    jmp       L948
L949:
    mov       %rax,	[%rsi]
    lea       %rcx,	[%rip+pc_api.getfullname.str]
    mov       %rdx,	%rax
    call      strcat
L948:
    lea       %rax,	[%rip+pc_api.getfullname.str]
    jmp       L943
L947:
    movzx     %rax,	byte ptr[%rsi+72]
    cmp       %rax,	4
    jz        L952
    cmp       %rax,	5
    jnz       L951
L952:
    mov       %rax,	[%rsi+32]
    mov       %rax,	[%rax]
    lea       %rcx,	[%rip+pc_api.getfullname.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rcx,	[%rip+pc_api.getfullname.str]
    lea       %rdx,	[%rip+L8427]
    call      strcat
    mov       %rax,	[%rsi]
    lea       %rcx,	[%rip+pc_api.getfullname.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rax,	[%rip+pc_api.getfullname.str]
    jmp       L943
L951:
    test      %r12,	%r12
    jz        L954
    mov       %rax,	[%rsi]
    lea       %rcx,	[%rip+pc_api.getfullname.str]
    mov       %rdx,	%rax
    call      strcat
    jmp       L953
L954:
    mov       %rax,	[%rsi]
L953:
L943:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pcerrorstop
pc_api.pcerrorstop:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    lea       %rcx,	[%rip+L8428]
    lea       %rdx,	[%rip+L8429]
    call      fopen
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    call      msys.m$print_startfile
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    mov       %rcx,	%rsi
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%rdi
    call      fclose
    mov       %rcx,	1
    call      exit
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pc_addplib
pc_api.pc_addplib:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	[%rip+pc_decls.nplibfiles]
    cmp       %rax,	50
    jl        L958
    lea       %rcx,	[%rip+L8430]
    call      pc_api.perror
L958:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8431]
    call      mlib.changeext
    mov       %rcx,	%rax
    call      mlib.pcm_copyheapstring
    inc       qword ptr[%rip+pc_decls.nplibfiles]
    mov       %r10,	[%rip+pc_decls.nplibfiles]
    lea       %r11,	[%rip+pc_decls.plibfiles]
    mov       [%r11 + %r10*8-8],	%rax
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc pc_api.pc_defproc
pc_api.pc_defproc:
#?>>
    .set pc_api.pc_defproc.$T1, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
    mov       %r12,	%r9
#---------------
    mov       %rax,	[%rip+pc_decls.currfunc]
    test      %rax,	%rax
    jz        L961
    lea       %rcx,	[%rip+L8432]
    call      pc_api.pclerror
L961:
    mov       %rcx,	%rdi
    call      pc_api.genmem
    mov       [%rbp + pc_api.pc_defproc.$T1],	%rax
    test      %r12,	%r12
    jz        L963
    mov       %rax,	121
    jmp       L962
L963:
    mov       %rax,	120
L962:
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + pc_api.pc_defproc.$T1]
    call      pc_api.pc_gen
    test      %rbx,	%rbx
    jnz       L965
    movzx     %rax,	byte ptr[%rdi+82]
    mov       %rbx,	%rax
L965:
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      pc_api.pc_setmode
    mov       %rax,	[%rdi+56]
    test      %rax,	%rax
    jz        L967
    mov       %rax,	[%rdi]
    lea       %rcx,	[%rip+L8433]
    mov       %rdx,	%rax
    call      pc_api.addstr
    mov       %rcx,	%rax
    call      pc_api.pclerror
L967:
    mov       %rax,	[%rip+pc_api.pccurr]
    mov       [%rdi+56],	%rax
    mov       %rax,	[%rip+pc_decls.entryproc]
    test      %rax,	%rax
    jnz       L969
    test      %rsi,	%rsi
    jz        L969
    mov       [%rip+pc_decls.entryproc],	%rdi
    mov       %al,	1
    mov       [%rdi+83],	%al
L969:
    mov       [%rip+pc_decls.currfunc],	%rdi
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pc_setimport
pc_api.pc_setimport:
#?>>
#?]]
#---------------
    mov       [%rip+pc_decls.currfunc],	%rcx
#---------------
    ret       
# End 
# Proc pc_api.pc_addparam
pc_api.pc_addparam:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    mov       %rdi,	[%rip+pc_decls.currfunc]
    test      %rdi,	%rdi
    jnz       L973
    lea       %rcx,	[%rip+L8434]
    call      pc_api.pclerror
L973:
    mov       %rbx,	[%rdi+16]
    test      %rbx,	%rbx
    jnz       L975
    mov       [%rdi+16],	%rsi
    jmp       L974
L975:
    jmp       L977
L976:
    mov       %rbx,	[%rbx+16]
L977:
    mov       %rax,	[%rbx+16]
    test      %rax,	%rax
    jnz       L976
    mov       [%rbx+16],	%rsi
L974:
    mov       %rax,	[%rsi+32]
    test      %rax,	%rax
    jnz       L980
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       [%rsi+32],	%rax
L980:
    mov       %rax,	[%rip+pc_decls.currfunc]
    lea       %rax,	[%rax+112]
    inc       byte ptr[%rax]
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pc_addlocal
pc_api.pc_addlocal:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    mov       %rdi,	[%rip+pc_decls.currfunc]
    test      %rdi,	%rdi
    jnz       L983
    lea       %rcx,	[%rip+L8434]
    call      pc_api.pclerror
L983:
    mov       %rbx,	[%rdi+24]
    test      %rbx,	%rbx
    jnz       L985
    mov       [%rdi+24],	%rsi
    jmp       L984
L985:
    jmp       L987
L986:
    mov       %rbx,	[%rbx+24]
L987:
    mov       %rax,	[%rbx+24]
    test      %rax,	%rax
    jnz       L986
    mov       [%rbx+24],	%rsi
L984:
    mov       %rax,	[%rsi+32]
    test      %rax,	%rax
    jnz       L990
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       [%rsi+32],	%rax
L990:
    mov       %rax,	[%rip+pc_decls.currfunc]
    lea       %rax,	[%rax+114]
    inc       word ptr[%rax]
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pc_endproc
pc_api.pc_endproc:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    mov       %rax,	[%rip+pc_decls.currfunc]
    test      %rax,	%rax
    jnz       L993
    lea       %rcx,	[%rip+L8434]
    call      pc_api.pclerror
L993:
    mov       %rcx,	122
    xor       %edx,	%edx
    call      pc_api.pc_gen
    xor       %eax,	%eax
    mov       [%rip+pc_decls.currfunc],	%rax
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc pc_api.addstr
pc_api.addstr:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    lea       %rcx,	[%rip+pc_api.addstr.str]
    mov       %rdx,	%rdi
    call      strcpy
    lea       %rcx,	[%rip+pc_api.addstr.str]
    mov       %rdx,	%rbx
    call      strcat
    lea       %rax,	[%rip+pc_api.addstr.str]
L994:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.merror
pc_api.merror:
#?>>
    .set pc_api.merror.filename, -8
    .set pc_api.merror.sourceline, -16
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	56
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rax,	[%rip+pc_decls.igetmsourceinfo]
    test      %rax,	%rax
    jz        L997
    mov       %rcx,	[%rip+pc_decls.mmpos]
    lea       %rdx,	[%rbp + pc_api.merror.filename]
    lea       %r8,	[%rbp + pc_api.merror.sourceline]
    mov       %rax,	[%rip+pc_decls.igetmsourceinfo]
    call      %rax
    mov       %rdi,	%rax
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8435]
    call      msys.m$print_str_nf
    mov       %rcx,	%rdi
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8436]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rbp + pc_api.merror.filename]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L996
L997:
    xor       %rdi,	%rdi
    lea       %rax,	[%rip+L8437]
    mov       [%rbp + pc_api.merror.filename],	%rax
L996:
    mov       %rax,	[%rip+pc_decls.currfunc]
    test      %rax,	%rax
    jz        L999
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8438]
    call      msys.m$print_str_nf
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L999:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8439]
    call      msys.m$print_setfmt
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    mov       %rcx,	%rsi
    call      msys.m$print_str_nf
    mov       %rcx,	%rdi
    call      msys.m$print_i64_nf
    mov       %rcx,	[%rbp + pc_api.merror.filename]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+pc_decls.ppseqno]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	[%rbp + pc_api.merror.filename]
    mov       %rdx,	%rdi
    call      pc_api.pcerrorstop
#---------------
    add       %rsp,	56
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pc_duplpst
pc_api.pc_duplpst:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rcx,	128
    call      mlib.pcm_allocnfz
    mov       %rdi,	%rax
    mov       %rax,	%rbx
    push      %rdi
    mov       %r11,	16
L8440:
    mov       %r10,	[%rax]
    mov       [%rdi],	%r10
    add       %rdi,	8
    add       %rax,	8
    dec       %r11
    jnz       L8440
    pop       %rdi
    inc       qword ptr[%rip+pc_api.stseqno]
    mov       %rax,	[%rip+pc_api.stseqno]
    mov       [%rdi+120],	%eax
    xor       %eax,	%eax
    mov       [%rdi+8],	%rax
    mov       %rax,	%rdi
L1000:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pcl_cmdskip
pc_api.pcl_cmdskip:
#?>>
    .set pc_api.pcl_cmdskip.dcmdskip, 24
#?]]
#---------------
    mov       [%rip+pc_decls.pcmdskip],	%rcx
#---------------
    ret       
# End 
# Proc pc_api.convertstring
pc_api.convertstring:
#?>>
    .set pc_api.convertstring.str, -16
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    mov       %rbx,	%r12
    jmp       L1004
L1003:
    mov       %rax,	%rdi
    cmp       %rax,	34
    jz        L1007
    cmp       %rax,	10
    jz        L1008
    cmp       %rax,	13
    jz        L1009
    cmp       %rax,	9
    jz        L1010
    cmp       %rax,	92
    jz        L1011
    cmp       %rax,	7
    jz        L1012
    cmp       %rax,	8
    jz        L1012
    cmp       %rax,	26
    jz        L1012
    cmp       %rax,	27
    jz        L1012
    jmp       L1013
L1007:
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	34
    mov       [%rax],	%r10b
    jmp       L1006
L1008:
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	110
    mov       [%rax],	%r10b
    jmp       L1006
L1009:
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	114
    mov       [%rax],	%r10b
    jmp       L1006
L1010:
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	116
    mov       [%rax],	%r10b
    jmp       L1006
L1011:
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	92
    mov       [%rax],	%r10b
    jmp       L1006
L1012:
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	60
    mov       [%rax],	%r10b
    mov       %rax,	%rdi
    mov       %r10,	10
    cqo       
    idiv      %r10
    add       %rax,	48
    mov       %r10,	%r12
    inc       %r12
    mov       [%r10],	%al
    mov       %rax,	%rdi
    mov       %r10,	10
    cqo       
    idiv      %r10
    xchg      %rax,	%rdx
    add       %rax,	48
    mov       %r10,	%r12
    inc       %r12
    mov       [%r10],	%al
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	62
    mov       [%rax],	%r10b
    jmp       L1006
L1013:
    mov       %rax,	%rdi
    cmp       %rax,	32
    jl        L1015
    cmp       %rax,	126
    jg        L1015
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	%dil
    mov       [%rax],	%r10b
    jmp       L1014
L1015:
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	120
    mov       [%rax],	%r10b
    lea       %rcx,	[%rbp + pc_api.convertstring.str]
    call      msys.m$print_startstr
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8441]
    call      msys.m$print_i64
    call      msys.m$print_end
    mov       %al,	[%rbp + pc_api.convertstring.str]
    mov       %r10,	%r12
    inc       %r12
    mov       [%r10],	%al
    mov       %al,	[%rbp + pc_api.convertstring.str+1]
    mov       %r10,	%r12
    inc       %r12
    mov       [%r10],	%al
L1014:
L1006:
L1004:
    mov       %rax,	%rsi
    inc       %rsi
    movzx     %rax,	byte ptr[%rax]
    mov       %rdi,	%rax
    test      %rax,	%rax
    jnz       L1003
    xor       %eax,	%eax
    mov       [%r12],	%al
    mov       %rax,	%r12
    sub       %rax,	%rbx
L1002:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_diags.strpcl
pc_diags.strpcl:
#?>>
    .set pc_diags.strpcl.p, 64
    .set pc_diags.strpcl.str, -256
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	288
    mov       [%rbp+64],	%rcx
#---------------
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    movzx     %rax,	byte ptr[%rax]
    mov       %rdi,	%rax
    mov       %rax,	%rdi
    cmp       %rax,	127
    jz        L1018
    cmp       %rax,	128
    jz        L1019
    cmp       %rax,	135
    jz        L1020
    cmp       %rax,	120
    jz        L1021
    cmp       %rax,	121
    jz        L1021
    cmp       %rax,	122
    jz        L1022
    cmp       %rax,	136
    jz        L1023
    cmp       %rax,	125
    jz        L1024
    cmp       %rax,	123
    jz        L1025
    cmp       %rax,	124
    jz        L1025
    jmp       L1026
L1018:
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    mov       %rax,	[%rax+8]
    mov       %rcx,	%rax
    mov       %rdx,	1
    call      pc_diags.strlabel
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    mov       %eax,	[%rax+16]
    test      %eax,	%eax
    jz        L1028
    lea       %rcx,	[%rip+L8442]
    call      pc_diags.psstr
L1028:
    jmp       L1016
L1019:
    lea       %rcx,	[%rip+L8443]
    call      pc_diags.psstr
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    mov       %rax,	[%rax+8]
    mov       %rcx,	[%rax]
    call      pc_diags.psstr
    lea       %rcx,	[%rip+L8444]
    call      pc_diags.psstr
    jmp       L1016
L1020:
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    mov       %rax,	[%rax+8]
    mov       %al,	[%rax]
    test      %al,	%al
    jz        L1030
    lea       %rcx,	[%rip+L8445]
    call      pc_diags.psstr
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    mov       %rcx,	[%rax+8]
    call      pc_diags.psstr
    jmp       L1029
L1030:
    lea       %rcx,	[%rip+L8446]
    call      pc_diags.psstr
L1029:
    jmp       L1016
L1021:
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    mov       %r13,	[%rax+8]
    cmp       %rdi,	121
    jnz       L1032
    lea       %rcx,	[%rip+L8447]
    call      pc_diags.psstr
    jmp       L1031
L1032:
    lea       %rcx,	[%rip+L8448]
    call      pc_diags.psstr
L1031:
    lea       %rcx,	[%rip+L8449]
    call      pc_diags.psstr
    mov       %rcx,	%r13
    call      pc_diags.psname
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    mov       %rax,	[%rax+8]
    mov       %al,	[%rax+81]
    test      %al,	%al
    jz        L1034
    lea       %rax,	[%rip+L8450]
    jmp       L1033
L1034:
    lea       %rax,	[%rip+L8451]
L1033:
    mov       %rcx,	%rax
    call      pc_diags.psstr
    mov       %al,	[%r13+83]
    test      %al,	%al
    jz        L1036
    lea       %rcx,	[%rip+L8451]
    call      pc_diags.psstr
L1036:
    call      pc_diags.psline
    mov       %r14,	[%r13+16]
    jmp       L1040
L1037:
    lea       %rcx,	[%rip+L8452]
    call      pc_diags.psstr
    mov       %eax,	[%r14+84]
    movzx     %r10,	byte ptr[%r14+82]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      pc_api.strpmode
    mov       %rcx,	%rax
    call      pc_diags.psstr
    lea       %rcx,	[%rip+L8453]
    call      pc_diags.psstr
    mov       %rcx,	[%r14]
    call      pc_diags.psstr
    call      pc_diags.psline
    mov       %r14,	[%r14+16]
L1040:
    test      %r14,	%r14
    jnz       L1037
    mov       %r14,	[%r13+24]
    jmp       L1044
L1041:
    lea       %rcx,	[%rip+L8454]
    call      pc_diags.psstr
    mov       %eax,	[%r14+84]
    movzx     %r10,	byte ptr[%r14+82]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      pc_api.strpmode
    mov       %rcx,	%rax
    call      pc_diags.psstr
    lea       %rcx,	[%rip+L8455]
    call      pc_diags.psstr
    mov       %rcx,	[%r14]
    call      pc_diags.psstr
    call      pc_diags.psline
    mov       %r14,	[%r14+24]
L1044:
    test      %r14,	%r14
    jnz       L1041
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    mov       %al,	[%rax+3]
    test      %al,	%al
    jz        L1046
    lea       %rcx,	[%rip+L8456]
    call      pc_diags.psstr
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    movzx     %rax,	byte ptr[%rax+3]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      pc_api.strpmode
    mov       %rcx,	%rax
    call      pc_diags.psstr
    call      pc_diags.psline
L1046:
    mov       %al,	[%r13+113]
    test      %al,	%al
    jz        L1048
    lea       %rcx,	[%rip+L8457]
    call      pc_diags.psstrline
L1048:
    jmp       L1016
L1022:
    lea       %rcx,	[%rip+L8458]
    call      pc_diags.psstr
    call      pc_diags.psline
    jmp       L1016
L1023:
    lea       %rcx,	[%rip+L8459]
    call      pc_diags.psstr
    jmp       L1016
L1024:
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    movzx     %rax,	byte ptr[%rax+3]
    cmp       %rax,	11
    jnz       L1050
    mov       %rcx,	[%rbp + pc_diags.strpcl.p]
    call      pc_diags.psdata
    jmp       L1016
L1050:
    jmp       L1017
L1025:
    jmp       L1051
L1026:
L1017:
    lea       %rcx,	[%rip+L8460]
    call      pc_diags.psstr
#pc_diags.strpcl.skiptab:
L1051:
    mov       %rax,	%rdi
    cmp       %rax,	26
    jz        L1053
    cmp       %rax,	31
    jz        L1054
    jmp       L1055
L1053:
    lea       %rcx,	[%rbp + pc_diags.strpcl.str]
    lea       %rdx,	[%rip+L8461]
    call      strcpy
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    movzx     %rax,	byte ptr[%rax+2]
    lea       %r10,	[%rip+pc_tables.ccnames]
    mov       %r10,	[%r10 + %rax*8]
    lea       %rcx,	[%rbp + pc_diags.strpcl.str]
    mov       %rdx,	%r10
    call      strcat
    jmp       L1052
L1054:
    lea       %rcx,	[%rbp + pc_diags.strpcl.str]
    lea       %rdx,	[%rip+L8462]
    call      strcpy
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    movzx     %rax,	byte ptr[%rax+2]
    lea       %r10,	[%rip+pc_tables.ccnames]
    mov       %r10,	[%r10 + %rax*8]
    lea       %rcx,	[%rbp + pc_diags.strpcl.str]
    mov       %rdx,	%r10
    call      strcat
    jmp       L1052
L1055:
    lea       %rax,	[%rip+pc_tables.pclnames]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    lea       %rcx,	[%rbp + pc_diags.strpcl.str]
    mov       %rdx,	%rax
    call      strcpy
L1052:
    mov       %rcx,	[%rip+pc_diags.dest]
    lea       %rdx,	[%rbp + pc_diags.strpcl.str]
    mov       %r8,	9
    mov       %r9,	32
    call      mlib.gs_leftstr
    xor       %eax,	%eax
    mov       [%rbp + pc_diags.strpcl.str],	%al
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    mov       %al,	[%rax+3]
    test      %al,	%al
    jz        L1057
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    mov       %eax,	[%rax+4]
    mov       %r10,	[%rbp + pc_diags.strpcl.p]
    movzx     %r10,	byte ptr[%r10+3]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      pc_api.strpmode
    lea       %rcx,	[%rbp + pc_diags.strpcl.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rax,	[%rip+pc_tables.pclhastype]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10]
    cmp       %rax,	2
    jnz       L1059
    lea       %rcx,	[%rbp + pc_diags.strpcl.str]
    lea       %rdx,	[%rip+L8463]
    call      strcat
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    movsxd    %rax,	dword ptr[%rax+28]
    and       %rax,	255
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      pc_api.strpmode
    lea       %rcx,	[%rbp + pc_diags.strpcl.str]
    mov       %rdx,	%rax
    call      strcat
L1059:
    lea       %rcx,	[%rbp + pc_diags.strpcl.str]
    lea       %rdx,	[%rip+L8464]
    call      strcat
L1057:
    mov       %rcx,	[%rip+pc_diags.dest]
    lea       %rdx,	[%rbp + pc_diags.strpcl.str]
    mov       %r8,	4
    mov       %r9,	32
    call      mlib.gs_leftstr
    xor       %eax,	%eax
    mov       [%rbp + pc_diags.strpcl.str],	%al
    lea       %rax,	[%rip+pc_tables.pclextra]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %rbx,	%rax
    test      %rbx,	%rbx
    jz        L1061
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    movsxd    %rax,	dword ptr[%rax+16]
    mov       %rsi,	%rax
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    movsxd    %rax,	dword ptr[%rax+20]
    mov       %r12,	%rax
    test      %rsi,	%rsi
    jnz       L1064
    cmp       %rbx,	2
    jnz       L1063
L1064:
    lea       %rcx,	[%rbp + pc_diags.strpcl.str]
    lea       %rdx,	[%rip+L8465]
    call      strcat
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    movsxd    %rax,	dword ptr[%rax+16]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.strint
    lea       %rcx,	[%rbp + pc_diags.strpcl.str]
    mov       %rdx,	%rax
    call      strcat
L1063:
    cmp       %rbx,	2
    jnz       L1066
    test      %r12,	%r12
    jz        L1066
    lea       %rcx,	[%rbp + pc_diags.strpcl.str]
    lea       %rdx,	[%rip+L8465]
    call      strcat
    mov       %rcx,	%r12
    xor       %edx,	%edx
    call      msys.strint
    lea       %rcx,	[%rbp + pc_diags.strpcl.str]
    mov       %rdx,	%rax
    call      strcat
L1066:
    lea       %rcx,	[%rbp + pc_diags.strpcl.str]
    lea       %rdx,	[%rip+L8466]
    call      strcat
L1061:
    mov       %rcx,	[%rip+pc_diags.dest]
    lea       %rdx,	[%rbp + pc_diags.strpcl.str]
    mov       %r8,	5
    mov       %r9,	32
    call      mlib.gs_leftstr
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    movzx     %rax,	byte ptr[%rax+1]
    test      %rax,	%rax
    jz        L1068
    lea       %rcx,	[%rip+L8466]
    call      pc_diags.psstr
    mov       %rcx,	[%rbp + pc_diags.strpcl.p]
    call      pc_diags.psopnd
L1068:
    mov       %rcx,	40
    call      pc_diags.pstabto
L1016:
#---------------
    add       %rsp,	288
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_diags.stropnd
pc_diags.stropnd:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    test      %rsi,	%rsi
    jnz       L1071
    lea       %rax,	[%rip+L8467]
    jmp       L1069
L1071:
    xor       %eax,	%eax
    lea       %r10,	[%rip+pc_diags.stropnd.str]
    mov       [%r10],	%al
    movzx     %rax,	byte ptr[%rsi+1]
    cmp       %rax,	4
    jz        L1073
    cmp       %rax,	5
    jz        L1074
    cmp       %rax,	10
    jz        L1074
    cmp       %rax,	11
    jz        L1074
    cmp       %rax,	6
    jz        L1074
    cmp       %rax,	7
    jz        L1075
    cmp       %rax,	1
    jz        L1076
    cmp       %rax,	2
    jz        L1077
    cmp       %rax,	3
    jz        L1078
    test      %rax,	%rax
    jz        L1079
    cmp       %rax,	9
    jz        L1080
    cmp       %rax,	12
    jz        L1081
    jmp       L1082
L1073:
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.strint
    jmp       L1069
L1074:
    movq      %XMM4,	[%rsi+8]
    comisd    %XMM4,	[%rip+L8468]
    jnz       L1084
    lea       %rcx,	[%rip+pc_diags.stropnd.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8469]
    call      msys.m$print_setfmt
    call      msys.m$print_end
    jmp       L1083
L1084:
    lea       %rcx,	[%rip+pc_diags.stropnd.str]
    call      msys.m$print_startstr
    movq      %XMM4,	[%rsi+8]
    movq      %XMM0,	%XMM4
    lea       %rdx,	[%rip+L8470]
    call      msys.m$print_r64
    call      msys.m$print_end
L1083:
    jmp       L1072
L1075:
    mov       %eax,	[%rsi+16]
    mov       %rdi,	%rax
    cmp       %rdi,	256
    jge       L1086
    lea       %rcx,	[%rip+pc_diags.stropnd.str]
    lea       %rdx,	[%rip+L8471]
    call      strcpy
    lea       %rax,	[%rip+pc_diags.stropnd.str]
    lea       %rax,	[%rax+1]
    mov       %r10,	[%rsi+8]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      pc_api.convertstring
    lea       %rcx,	[%rip+pc_diags.stropnd.str]
    lea       %rdx,	[%rip+L8471]
    call      strcat
    lea       %rcx,	[%rip+pc_diags.stropnd.str]
    lea       %rdx,	[%rip+L8472]
    call      strcat
    mov       %eax,	[%rsi+16]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.strint
    lea       %rcx,	[%rip+pc_diags.stropnd.str]
    mov       %rdx,	%rax
    call      strcat
    jmp       L1085
L1086:
    mov       %rax,	[%rip+pc_diags.stropnd.longstring]
    test      %rax,	%rax
    jz        L1088
    mov       %rcx,	[%rip+pc_diags.stropnd.longstring]
    mov       %rdx,	[%rip+pc_api.longstringlen]
    call      mlib.pcm_free
L1088:
    mov       %rax,	%rdi
    shl       %rax,	1
    mov       [%rip+pc_api.longstringlen],	%rax
    mov       %rcx,	[%rip+pc_api.longstringlen]
    call      mlib.pcm_alloc
    mov       [%rip+pc_diags.stropnd.longstring],	%rax
    mov       %al,	34
    mov       %r10,	[%rip+pc_diags.stropnd.longstring]
    mov       [%r10],	%al
    mov       %rax,	[%rip+pc_diags.stropnd.longstring]
    lea       %rax,	[%rax+1]
    mov       %r10,	[%rsi+8]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      pc_api.convertstring
    mov       %rdi,	%rax
    mov       %al,	34
    mov       %r10,	[%rip+pc_diags.stropnd.longstring]
    mov       %r11,	%rdi
    mov       [%r10 + %r11+1],	%al
    xor       %eax,	%eax
    mov       %r10,	[%rip+pc_diags.stropnd.longstring]
    mov       %r11,	%rdi
    mov       [%r10 + %r11+2],	%al
    mov       %rax,	[%rip+pc_diags.stropnd.longstring]
    jmp       L1069
L1085:
    jmp       L1072
L1076:
    mov       %rbx,	[%rsi+8]
    mov       %rax,	[%rsi+8]
    mov       %rax,	[%rax]
    lea       %rcx,	[%rip+pc_diags.stropnd.str]
    mov       %rdx,	%rax
    call      strcat
    movzx     %rax,	byte ptr[%rsi]
    cmp       %rax,	123
    jz        L1091
    cmp       %rax,	124
    jnz       L1090
L1091:
    lea       %rcx,	[%rip+pc_diags.stropnd.str]
    lea       %rdx,	[%rip+L8473]
    call      strcat
    mov       %al,	[%rbx+81]
    test      %al,	%al
    jz        L1093
    lea       %rcx,	[%rip+pc_diags.stropnd.str]
    lea       %rdx,	[%rip+L8473]
    call      strcat
L1093:
L1090:
    jmp       L1072
L1077:
    lea       %rcx,	[%rip+pc_diags.stropnd.str]
    lea       %rdx,	[%rip+L8474]
    call      strcpy
    jmp       L1076
L1078:
    lea       %rcx,	[%rip+pc_diags.stropnd.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8475]
    call      msys.m$print_setfmt
    lea       %rcx,	[%rip+L8476]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rsi+8]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L1072
L1079:
    lea       %rax,	[%rip+L8477]
    jmp       L1069
L1080:
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.strint
    jmp       L1069
L1081:
    lea       %rcx,	[%rip+pc_diags.stropnd.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8478]
    call      msys.m$print_setfmt
    mov       %eax,	[%rsi+4]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    mov       %rcx,	[%rsi+8]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L1072
L1082:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8479]
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rsi+1]
    lea       %r10,	[%rip+pc_tables.opndnames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rax,	[%rip+L8480]
    jmp       L1069
L1072:
    lea       %rax,	[%rip+pc_diags.stropnd.str]
L1069:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_diags.psopnd
pc_diags.psopnd:
#?>>
    .set pc_diags.psopnd.str, -512
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	552
    mov       %rsi,	%rcx
#---------------
    test      %rsi,	%rsi
    jnz       L1096
    jmp       L1094
L1096:
    movzx     %rax,	byte ptr[%rsi+1]
    cmp       %rax,	4
    jz        L1098
    cmp       %rax,	5
    jz        L1099
    cmp       %rax,	10
    jz        L1099
    cmp       %rax,	11
    jz        L1099
    cmp       %rax,	6
    jz        L1099
    cmp       %rax,	7
    jz        L1100
    cmp       %rax,	1
    jz        L1101
    cmp       %rax,	2
    jz        L1102
    cmp       %rax,	3
    jz        L1103
    test      %rax,	%rax
    jz        L1104
    cmp       %rax,	9
    jz        L1105
    cmp       %rax,	12
    jz        L1106
    jmp       L1107
L1098:
    mov       %rcx,	[%rsi+8]
    call      pc_diags.psint
    jmp       L1097
L1099:
    movq      %XMM4,	[%rsi+8]
    comisd    %XMM4,	[%rip+L8481]
    jnz       L1109
    lea       %rcx,	[%rbp + pc_diags.psopnd.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8482]
    call      msys.m$print_setfmt
    call      msys.m$print_end
    jmp       L1108
L1109:
    lea       %rcx,	[%rbp + pc_diags.psopnd.str]
    call      msys.m$print_startstr
    movq      %XMM4,	[%rsi+8]
    movq      %XMM0,	%XMM4
    lea       %rdx,	[%rip+L8483]
    call      msys.m$print_r64
    call      msys.m$print_end
L1108:
    lea       %rcx,	[%rbp + pc_diags.psopnd.str]
    call      pc_diags.psstr
    jmp       L1097
L1100:
    mov       %eax,	[%rsi+16]
    mov       %rdi,	%rax
    cmp       %rdi,	256
    jge       L1111
    lea       %rcx,	[%rip+L8484]
    call      pc_diags.psstr
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    lea       %rdx,	[%rbp + pc_diags.psopnd.str]
    mov       %r8,	%rdi
    call      pc_diags.newconvertstring
    lea       %rcx,	[%rbp + pc_diags.psopnd.str]
    call      pc_diags.psstr
    lea       %rcx,	[%rip+L8485]
    call      pc_diags.psstr
    mov       %eax,	[%rsi+16]
    mov       %rcx,	%rax
    call      pc_diags.psint
    jmp       L1110
L1111:
    mov       %rax,	[%rip+pc_diags.psopnd.longstring]
    test      %rax,	%rax
    jz        L1113
    mov       %rcx,	[%rip+pc_diags.psopnd.longstring]
    mov       %rdx,	[%rip+pc_api.longstringlen]
    call      mlib.pcm_free
L1113:
    mov       %rax,	%rdi
    shl       %rax,	1
    mov       [%rip+pc_api.longstringlen],	%rax
    mov       %rcx,	[%rip+pc_api.longstringlen]
    call      mlib.pcm_alloc
    mov       [%rip+pc_diags.psopnd.longstring],	%rax
    mov       %al,	34
    mov       %r10,	[%rip+pc_diags.psopnd.longstring]
    mov       [%r10],	%al
    mov       %rax,	[%rip+pc_diags.psopnd.longstring]
    lea       %rax,	[%rax+1]
    mov       %r10,	[%rsi+8]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      pc_api.convertstring
    mov       %rdi,	%rax
    mov       %al,	34
    mov       %r10,	[%rip+pc_diags.psopnd.longstring]
    mov       %r11,	%rdi
    mov       [%r10 + %r11+1],	%al
    xor       %eax,	%eax
    mov       %r10,	[%rip+pc_diags.psopnd.longstring]
    mov       %r11,	%rdi
    mov       [%r10 + %r11+2],	%al
    mov       %rcx,	[%rip+pc_diags.psopnd.longstring]
    call      pc_diags.psstr
L1110:
    jmp       L1097
L1101:
    mov       %rbx,	[%rsi+8]
    mov       %rax,	[%rsi+8]
    mov       %rcx,	[%rax]
    call      pc_diags.psstr
    movzx     %rax,	byte ptr[%rsi]
    cmp       %rax,	123
    jz        L1116
    cmp       %rax,	124
    jnz       L1115
L1116:
    lea       %rcx,	[%rip+L8486]
    call      pc_diags.psstr
    mov       %al,	[%rbx+81]
    test      %al,	%al
    jz        L1118
    lea       %rcx,	[%rip+L8486]
    call      pc_diags.psstr
L1118:
L1115:
    jmp       L1097
L1102:
    lea       %rcx,	[%rip+L8487]
    call      pc_diags.psstr
    jmp       L1101
L1103:
    lea       %rcx,	[%rbp + pc_diags.psopnd.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8488]
    call      msys.m$print_setfmt
    lea       %rcx,	[%rip+L8489]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rsi+8]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + pc_diags.psopnd.str]
    call      pc_diags.psstr
    jmp       L1097
L1104:
    jmp       L1094
L1105:
    mov       %rcx,	[%rsi+8]
    call      pc_diags.psint
    jmp       L1097
L1106:
    lea       %rcx,	[%rbp + pc_diags.psopnd.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8490]
    call      msys.m$print_setfmt
    mov       %eax,	[%rsi+4]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    mov       %rcx,	[%rsi+8]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + pc_diags.psopnd.str]
    call      pc_diags.psstr
    jmp       L1097
L1107:
    lea       %rcx,	[%rip+L8491]
    call      pc_diags.psstr
L1097:
L1094:
#---------------
    add       %rsp,	552
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_diags.strpclstr
pc_diags.strpclstr:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	[%rip+pc_diags.dest]
    call      mlib.gs_free
    mov       %rcx,	[%rip+pc_diags.dest]
    call      mlib.gs_init
    xor       %eax,	%eax
    mov       [%rip+pc_diags.destlinestart],	%rax
    mov       %rcx,	%rdi
    call      pc_diags.strpcl
    mov       %rcx,	[%rip+pc_diags.dest]
    xor       %edx,	%edx
    call      mlib.gs_char
    mov       %rax,	[%rip+pc_diags.dest]
    movsxd    %rax,	dword ptr[%rax+8]
    cmp       %rax,	%rbx
    jl        L1121
    lea       %rax,	[%rip+L8492]
    jmp       L1119
L1121:
    mov       %rax,	[%rip+pc_diags.dest]
    mov       %rax,	[%rax]
L1119:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_diags.writepcl
pc_diags.writepcl:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      pc_diags.strpcl
    movzx     %rax,	byte ptr[%rdi]
    cmp       %rax,	120
    jnz       L1125
L1124:
    jmp       L1123
L1125:
    mov       %rcx,	[%rip+pc_diags.dest]
    call      mlib.gs_line
L1123:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc pc_diags.writeallpcl
pc_diags.writeallpcl:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rcx,	[%rip+pc_diags.dest]
    call      mlib.gs_init
    mov       %rax,	[%rip+pc_diags.dest]
    movsxd    %rax,	dword ptr[%rax+8]
    mov       [%rip+pc_diags.destlinestart],	%rax
    mov       %rcx,	[%rip+pc_diags.dest]
    lea       %rdx,	[%rip+L8493]
    call      mlib.gs_strln
    mov       %rsi,	1
    mov       %rax,	[%rip+pc_decls.nplibfiles]
    cmp       %rax,	1
    jl        L1129
L1127:
    lea       %rcx,	[%rip+L8494]
    call      pc_diags.psstr
    lea       %rax,	[%rip+pc_decls.plibfiles]
    mov       %r10,	%rsi
    mov       %rcx,	[%rax + %r10*8-8]
    call      pc_diags.psstr
    lea       %rcx,	[%rip+L8495]
    call      pc_diags.psstr
    call      pc_diags.psline
    inc       %rsi
    cmp       %rsi,	[%rip+pc_decls.nplibfiles]
    jle       L1127
L1129:
    mov       %rax,	[%rip+pc_decls.nplibfiles]
    test      %rax,	%rax
    jz        L1131
    call      pc_diags.psline
L1131:
    mov       %rbx,	[%rip+pc_decls.psymboltable]
    jmp       L1135
L1132:
    movzx     %rax,	byte ptr[%rbx+72]
    cmp       %rax,	1
    jnz       L1137
    lea       %rcx,	[%rip+L8496]
    call      pc_diags.psstr
    mov       %rcx,	[%rbx]
    call      pc_diags.psstr
    mov       %al,	[%rbx+113]
    test      %al,	%al
    jz        L1139
    lea       %rcx,	[%rip+L8497]
    call      pc_diags.psstr
L1139:
    call      pc_diags.psline
L1137:
    mov       %rbx,	[%rbx+8]
L1135:
    test      %rbx,	%rbx
    jnz       L1132
    mov       %rdi,	[%rip+pc_api.pcstart]
    jmp       L1141
L1140:
    mov       %rcx,	%rdi
    call      pc_diags.writepcl
    mov       %rax,	[%rip+pc_diags.dest]
    movsxd    %rax,	dword ptr[%rax+8]
    mov       [%rip+pc_diags.destlinestart],	%rax
    add       %rdi,	32
L1141:
    cmp       %rdi,	[%rip+pc_api.pccurr]
    jbe       L1140
    call      pc_diags.psline
    mov       %rax,	[%rip+pc_api.longstring]
    test      %rax,	%rax
    jz        L1144
    mov       %rcx,	[%rip+pc_api.longstring]
    mov       %rdx,	[%rip+pc_api.longstringlen]
    call      mlib.pcm_free
L1144:
    mov       %rax,	[%rip+pc_diags.dest]
L1126:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_diags.psstr
pc_diags.psstr:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	[%rip+pc_diags.dest]
    mov       %rdx,	%rdi
    call      mlib.gs_str
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc pc_diags.psstrx
pc_diags.psstrx:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	[%rip+pc_diags.dest]
    mov       %rdx,	%rdi
    call      mlib.gs_str
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc pc_diags.psstrline
pc_diags.psstrline:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	[%rip+pc_diags.dest]
    mov       %rdx,	%rdi
    call      mlib.gs_str
    mov       %rcx,	[%rip+pc_diags.dest]
    call      mlib.gs_line
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc pc_diags.psline
pc_diags.psline:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    mov       %rcx,	[%rip+pc_diags.dest]
    lea       %rdx,	[%rip+L8498]
    call      mlib.gs_str
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc pc_diags.psint
pc_diags.psint:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      msys.strint
    mov       %rcx,	[%rip+pc_diags.dest]
    mov       %rdx,	%rax
    call      mlib.gs_str
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc pc_diags.psname
pc_diags.psname:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	[%rdi]
    mov       %rcx,	[%rip+pc_diags.dest]
    mov       %rdx,	%rax
    call      mlib.gs_str
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc pc_diags.pstabto
pc_diags.pstabto:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rax,	[%rip+pc_diags.dest]
    movsxd    %rax,	dword ptr[%rax+8]
    sub       %rax,	[%rip+pc_diags.destlinestart]
    mov       %rdi,	%rax
    jmp       L1153
L1152:
    lea       %rcx,	[%rip+L8499]
    call      pc_diags.psstr
    inc       %rdi
L1153:
    cmp       %rbx,	%rdi
    jg        L1152
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_diags.strlabel
pc_diags.strlabel:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    lea       %rcx,	[%rip+L8500]
    call      pc_diags.psstr
    mov       %rcx,	%rdi
    call      pc_diags.psint
    test      %rbx,	%rbx
    jz        L1157
    lea       %rcx,	[%rip+L8501]
    call      pc_diags.psstr
L1157:
    lea       %rcx,	[%rip+L8502]
    call      pc_diags.psstr
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_diags.psdata
pc_diags.psdata:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
#---------------
    mov       %eax,	[%r13+4]
    mov       %rdi,	%rax
    mov       %rsi,	[%r13+8]
    test      %rdi,	%rdi
    jnz       L1160
    jmp       L1158
L1160:
    jmp       L1162
L1161:
    mov       %rbx,	%rdi
    cmp       %rbx,	20
    jl        L1165
    mov       %rbx,	20
L1165:
    mov       %rax,	%rbx
    sub       %rdi,	%rax
    lea       %rcx,	[%rip+L8503]
    call      pc_diags.psstr
    mov       %rcx,	%rbx
    call      pc_diags.psint
    lea       %rcx,	[%rip+L8504]
    call      pc_diags.psstr
    cmp       %rbx,	10
    jge       L1167
    lea       %rcx,	[%rip+L8505]
    call      pc_diags.psstr
L1167:
    mov       %r12,	%rbx
    cmp       %r12,	0
    jle       L1170
L1168:
    movzx     %rax,	byte ptr[%rsi]
    mov       %rcx,	%rax
    call      pc_diags.psint
    lea       %rcx,	[%rip+L8505]
    call      pc_diags.psstr
    inc       %rsi
    dec       %r12
    jnz       L1168
L1170:
    test      %rdi,	%rdi
    jz        L1172
    call      pc_diags.psline
L1172:
L1162:
    cmp       %rdi,	0
    jg        L1161
L1158:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_diags.writepst
pc_diags.writepst:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
#---------------
    xor       %dil,	%dil
    xor       %eax,	%eax
    mov       %rbx,	%rax
    mov       %rcx,	[%rip+pc_diags.dest]
    call      mlib.gs_init
    lea       %rcx,	[%rip+L8506]
    call      pc_diags.psstrline
    call      pc_diags.psline
    mov       %r12,	[%rip+pc_decls.psymboltable]
    jmp       L1177
L1174:
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L8507]
    call      msys.strint
    mov       %rcx,	%rax
    call      pc_diags.psstr
    lea       %rcx,	[%rip+L8508]
    call      pc_diags.psstr
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L8509]
    call      pc_diags.writepsymbol
    movzx     %rax,	byte ptr[%r12+72]
    cmp       %rax,	2
    jz        L1180
    cmp       %rax,	1
    jnz       L1179
L1180:
    mov       %r13,	[%r12+16]
    xor       %rsi,	%rsi
    jmp       L1184
L1181:
    lea       %rcx,	[%rip+L8510]
    call      pc_diags.psstr
    mov       %rcx,	%r13
    lea       %rdx,	[%rip+L8511]
    call      pc_diags.writepsymbol
    mov       %r13,	[%r13+16]
L1184:
    test      %r13,	%r13
    jnz       L1181
    mov       %r13,	[%r12+24]
    xor       %rsi,	%rsi
    jmp       L1188
L1185:
    lea       %rcx,	[%rip+L8512]
    call      pc_diags.psstr
    mov       %rcx,	%r13
    lea       %rdx,	[%rip+L8513]
    call      pc_diags.writepsymbol
    mov       %r13,	[%r13+24]
L1188:
    test      %r13,	%r13
    jnz       L1185
L1179:
    call      pc_diags.psline
    mov       %r12,	[%r12+8]
L1177:
    test      %r12,	%r12
    jnz       L1174
    call      pc_diags.psline
    mov       %rax,	[%rip+pc_diags.dest]
L1173:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_diags.writepsymbol
pc_diags.writepsymbol:
#?>>
    .set pc_diags.writepsymbol.str, -256
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	288
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    xor       %dil,	%dil
    lea       %rcx,	[%rbp + pc_diags.writepsymbol.str]
    call      msys.m$print_startstr
    mov       %eax,	[%rsi+120]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8514]
    call      msys.m$print_i64
    movzx     %rax,	byte ptr[%rsi+72]
    lea       %r10,	[%rip+pc_tables.idnames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + pc_diags.writepsymbol.str]
    call      pc_diags.psstr
    movzx     %rax,	byte ptr[%rsi+72]
    lea       %r10,	[%rip+pc_tables.idnames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      strlen
    mov       %r10,	8
    sub       %r10,	%rax
    mov       %rbx,	%r10
    cmp       %rbx,	0
    jle       L1192
L1190:
    lea       %rcx,	[%rip+L8515]
    call      pc_diags.psstr
    dec       %rbx
    jnz       L1190
L1192:
    xor       %eax,	%eax
    mov       [%rbp + pc_diags.writepsymbol.str],	%al
    lea       %rcx,	[%rbp + pc_diags.writepsymbol.str]
    call      msys.m$print_startstr
    mov       %rax,	[%rsi]
    mov       %rcx,	%rax
    mov       %rdx,	%r12
    call      msys.m$print_str
    call      msys.m$print_end
    lea       %rcx,	[%rbp + pc_diags.writepsymbol.str]
    call      pc_diags.psstr
    mov       %eax,	[%rsi+84]
    movzx     %r10,	byte ptr[%rsi+82]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      pc_api.strpmode
    mov       %rcx,	%rax
    call      pc_diags.psstr
    movzx     %rax,	byte ptr[%rsi+72]
    cmp       %rax,	2
    jnz       L1194
    lea       %rcx,	[%rip+L8516]
    call      pc_diags.psstr
    movzx     %rax,	byte ptr[%rsi+112]
    mov       %rcx,	%rax
    call      pc_diags.psint
    lea       %rcx,	[%rip+L8517]
    call      pc_diags.psstr
    movsx     %rax,	word ptr[%rsi+114]
    mov       %rcx,	%rax
    call      pc_diags.psint
L1194:
    mov       %al,	[%rsi+81]
    test      %al,	%al
    jz        L1196
    lea       %rcx,	[%rip+L8518]
    call      pc_diags.psstr
L1196:
    mov       %al,	[%rsi+80]
    test      %al,	%al
    jz        L1198
    lea       %rcx,	[%rip+L8519]
    call      pc_diags.psstr
L1198:
    mov       %al,	[%rsi+107]
    test      %al,	%al
    jz        L1200
    lea       %rcx,	[%rip+L8520]
    call      pc_diags.psstr
    movzx     %rax,	byte ptr[%rsi+107]
    mov       %rcx,	%rax
    call      pc_diags.psint
L1200:
    mov       %al,	[%rsi+108]
    test      %al,	%al
    jz        L1202
    lea       %rcx,	[%rip+L8521]
    call      pc_diags.psstr
L1202:
    mov       %al,	[%rsi+95]
    test      %al,	%al
    jz        L1204
    lea       %rcx,	[%rip+L8522]
    call      pc_diags.psstr
L1204:
    mov       %al,	[%rsi+83]
    test      %al,	%al
    jz        L1206
    lea       %rcx,	[%rip+L8523]
    call      pc_diags.psstr
L1206:
    movzx     %rax,	byte ptr[%rsi+72]
    cmp       %rax,	2
    jnz       L1208
    lea       %rcx,	[%rip+L8524]
    call      pc_diags.psstr
    mov       %rax,	[%rsi+56]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8525]
    call      msys.strint
    mov       %rcx,	%rax
    call      pc_diags.psstr
L1208:
    mov       %rax,	[%rsi+32]
    test      %rax,	%rax
    jz        L1210
    lea       %rcx,	[%rip+L8526]
    call      pc_diags.psstr
    mov       %rax,	[%rsi+32]
    mov       %eax,	[%rax+120]
    mov       %rcx,	%rax
    call      pc_diags.psint
    lea       %rcx,	[%rip+L8527]
    call      pc_diags.psstr
    mov       %rax,	[%rsi+32]
    mov       %rcx,	[%rax]
    call      pc_diags.psstr
    lea       %rcx,	[%rip+L8528]
    call      pc_diags.psstr
L1210:
    xor       %eax,	%eax
    test      %ax,	%ax
    jz        L1212
    movzx     %rax,	byte ptr[%rsi+72]
    cmp       %rax,	3
    jnz       L1212
    mov       %rax,	[%rsi+56]
    test      %rax,	%rax
    jz        L1212
    lea       %rcx,	[%rip+L8529]
    call      pc_diags.psstr
    mov       %rax,	[%rsi+56]
    mov       %rcx,	[%rax]
    call      pc_diags.psstr
    lea       %rcx,	[%rip+L8530]
    call      pc_diags.psstr
    mov       %rax,	[%rsi+24]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8531]
    call      msys.strint
    mov       %rcx,	%rax
    call      pc_diags.psstr
    lea       %rcx,	[%rip+L8532]
    call      pc_diags.psstr
L1212:
    xor       %eax,	%eax
    test      %ax,	%ax
    jz        L1214
    movzx     %rax,	byte ptr[%rsi+72]
    cmp       %rax,	2
    jnz       L1214
    movzx     %rax,	byte ptr[%rsi+104]
    shr       %eax,	1
    and       %eax,	1
    test      %rax,	%rax
    jz        L1214
    lea       %rcx,	[%rip+L8533]
    call      pc_diags.psstr
L1214:
    call      pc_diags.psline
#---------------
    add       %rsp,	288
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_diags.showprocinfo
pc_diags.showprocinfo:
#?>>
    .set pc_diags.showprocinfo.str, -256
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	296
    mov       %rsi,	%rcx
#---------------
    mov       %rdi,	[%rsi+48]
    test      %rdi,	%rdi
    jnz       L1217
    jmp       L1215
L1217:
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8534]
    call      msys.m$print_setfmt
    mov       %rcx,	[%rsi]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8535]
    call      msys.m$print_setfmt
    movzx     %rax,	byte ptr[%rdi+1]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8536]
    call      msys.m$print_setfmt
    movzx     %rax,	byte ptr[%rdi+2]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8537]
    call      msys.m$print_setfmt
    movzx     %rax,	byte ptr[%rdi+3]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8538]
    call      msys.m$print_setfmt
    movzx     %rax,	byte ptr[%rdi+4]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8539]
    call      msys.m$print_setfmt
    movzx     %rax,	byte ptr[%rdi+5]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8540]
    call      msys.m$print_setfmt
    movzx     %rax,	byte ptr[%rdi+6]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8541]
    call      msys.m$print_setfmt
    movzx     %rax,	byte ptr[%rdi+7]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    call      pc_diags.psline
    mov       %rbx,	[%rsi+16]
    jmp       L1221
L1218:
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8542]
    call      msys.m$print_setfmt
    mov       %rcx,	[%rbx]
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rbx+92]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    movzx     %rax,	byte ptr[%rbx+88]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    mov       %rbx,	[%rbx+16]
L1221:
    test      %rbx,	%rbx
    jnz       L1218
    mov       %rbx,	[%rsi+24]
    jmp       L1225
L1222:
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8543]
    call      msys.m$print_setfmt
    mov       %rcx,	[%rbx]
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rbx+92]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    movzx     %rax,	byte ptr[%rbx+88]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    mov       %rbx,	[%rbx+24]
L1225:
    test      %rbx,	%rbx
    jnz       L1222
    call      pc_diags.psline
L1215:
#---------------
    add       %rsp,	296
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_diags.newconvertstring
pc_diags.newconvertstring:
#?>>
    .set pc_diags.newconvertstring.str, -16
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
#---------------
    mov       %rbx,	%r13
    mov       %rsi,	%r14
    cmp       %rsi,	0
    jle       L1229
L1227:
    mov       %rax,	%r12
    inc       %r12
    movzx     %rax,	byte ptr[%rax]
    mov       %rdi,	%rax
    cmp       %rax,	34
    jz        L1231
    cmp       %rax,	10
    jz        L1232
    cmp       %rax,	13
    jz        L1233
    cmp       %rax,	9
    jz        L1234
    cmp       %rax,	92
    jz        L1235
    jmp       L1236
L1231:
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	34
    mov       [%rax],	%r10b
    jmp       L1230
L1232:
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	110
    mov       [%rax],	%r10b
    jmp       L1230
L1233:
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	114
    mov       [%rax],	%r10b
    jmp       L1230
L1234:
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	116
    mov       [%rax],	%r10b
    jmp       L1230
L1235:
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	92
    mov       [%rax],	%r10b
    jmp       L1230
L1236:
    mov       %rax,	%rdi
    cmp       %rax,	32
    jl        L1238
    cmp       %rax,	126
    jg        L1238
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	%dil
    mov       [%rax],	%r10b
    jmp       L1237
L1238:
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	92
    mov       [%rax],	%r10b
    lea       %rcx,	[%rbp + pc_diags.newconvertstring.str]
    call      msys.m$print_startstr
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8544]
    call      msys.m$print_i64
    call      msys.m$print_end
    mov       %al,	[%rbp + pc_diags.newconvertstring.str]
    mov       %r10,	%r13
    inc       %r13
    mov       [%r10],	%al
    mov       %al,	[%rbp + pc_diags.newconvertstring.str+1]
    mov       %r10,	%r13
    inc       %r13
    mov       [%r10],	%al
    mov       %al,	[%rbp + pc_diags.newconvertstring.str+2]
    mov       %r10,	%r13
    inc       %r13
    mov       [%r10],	%al
L1237:
L1230:
    dec       %rsi
    jnz       L1227
L1229:
    xor       %eax,	%eax
    mov       [%r13],	%al
    mov       %rax,	%r13
    sub       %rax,	%rbx
L1226:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_reduce.pcl_reducetest
pc_reduce.pcl_reducetest:
#?>>
    .set pc_reduce.pcl_reducetest.pcproc, -8
    .set pc_reduce.pcl_reducetest.labelmap, -16
    .set pc_reduce.pcl_reducetest.pdef, -24
    .set pc_reduce.pcl_reducetest.callstack, -152
    .set pc_reduce.pcl_reducetest.ncall, -160
    .set pc_reduce.pcl_reducetest.nprocs, -168
    .set pc_reduce.pcl_reducetest.nleaf, -176
    .set pc_reduce.pcl_reducetest.nallparams, -184
    .set pc_reduce.pcl_reducetest.nalllocals, -192
    .set pc_reduce.pcl_reducetest.av_1, -200
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	232
#---------------
    xor       %eax,	%eax
    mov       [%rbp + pc_reduce.pcl_reducetest.nprocs],	%rax
    xor       %eax,	%eax
    mov       [%rbp + pc_reduce.pcl_reducetest.nleaf],	%rax
    xor       %eax,	%eax
    mov       [%rbp + pc_reduce.pcl_reducetest.nallparams],	%rax
    xor       %eax,	%eax
    mov       [%rbp + pc_reduce.pcl_reducetest.nalllocals],	%rax
    mov       %rax,	[%rip+pc_api.pccurr]
    sub       %rax,	[%rip+pc_api.pcstart]
    shr       %rax,	5
    inc       %rax
    mov       %rdi,	%rax
    mov       %r13,	[%rip+pc_api.pcstart]
    mov       %rax,	[%rip+pc_api.mlabelno]
    shl       %rax,	1
    mov       %rcx,	%rax
    call      mlib.pcm_allocz
    mov       [%rbp + pc_reduce.pcl_reducetest.labelmap],	%rax
    jmp       L1243
L1240:
    movzx     %rax,	byte ptr[%r13]
    cmp       %rax,	127
    jz        L1245
    cmp       %rax,	42
    jz        L1246
    jmp       L1247
L1245:
    jmp       L1244
L1246:
    mov       %rax,	[%rip+pc_api.icheckasmlabel]
    test      %rax,	%rax
    jz        L1249
    mov       %rax,	[%r13+8]
    mov       %rcx,	%rax
    mov       %r10,	[%rip+pc_api.icheckasmlabel]
    call      %r10
    mov       %rsi,	%rax
    test      %rsi,	%rsi
    jz        L1251
    mov       %rax,	[%rbp + pc_reduce.pcl_reducetest.labelmap]
    mov       %r10,	%rsi
    lea       %rax,	[%rax + %r10*2-2]
    inc       word ptr[%rax]
L1251:
L1249:
    jmp       L1244
L1247:
    movzx     %rax,	byte ptr[%r13+1]
    cmp       %rax,	3
    jnz       L1253
    mov       %rax,	[%r13+8]
    mov       %r10,	[%rbp + pc_reduce.pcl_reducetest.labelmap]
    lea       %r10,	[%r10 + %rax*2-2]
    inc       word ptr[%r10]
L1253:
L1244:
    add       %r13,	32
L1243:
    cmp       %r13,	[%rip+pc_api.pccurr]
    jbe       L1240
#pc_reduce.pcl_reducetest.skip:
    mov       %r13,	[%rip+pc_api.pcstart]
    mov       %rax,	[%rip+pc_api.pcstart]
    sub       %rax,	32
    mov       %r14,	%rax
    xor       %rbx,	%rbx
    mov       %rax,	%rdi
    mov       [%rbp + pc_reduce.pcl_reducetest.av_1],	%rax
    mov       %rax,	[%rbp + pc_reduce.pcl_reducetest.av_1]
    cmp       %rax,	0
    jle       L1257
L1255:
    lea       %rax,	[%r13+32]
    mov       %r15,	%rax
    movzx     %rax,	byte ptr[%r13]
    lea       %r10,	[%rip+pc_tables.pclargs]
    movzx     %r10,	byte ptr[%r10 + %rax]
    mov       %r12,	%r10
    test      %r10,	%r10
    jz        L1259
    cmp       %r12,	9
    jnz       L1261
    movsxd    %rax,	dword ptr[%r13+16]
    mov       %r12,	%rax
L1261:
    mov       %rax,	[%rip+pc_decls.pinfo]
    movzx     %rax,	byte ptr[%rax+4]
    mov       %r10,	%r12
    cmp       %rax,	%r10
    cmovl     %rax,	%r10
    mov       %r10,	[%rip+pc_decls.pinfo]
    mov       [%r10+4],	%al
L1259:
    movzx     %rax,	byte ptr[%r13+3]
    cmp       %rax,	11
    jnz       L1263
    mov       %rax,	[%rip+pc_decls.pinfo]
    test      %rax,	%rax
    jz        L1263
    mov       %eax,	[%r13+4]
    cmp       %rax,	16
    jz        L1263
    mov       %al,	1
    mov       %r10,	[%rip+pc_decls.pinfo]
    mov       [%r10+7],	%al
L1263:
    movzx     %rax,	byte ptr[%r13]
    cmp       %rax,	135
    jz        L1265
    cmp       %rax,	127
    jz        L1266
    cmp       %rax,	120
    jz        L1267
    cmp       %rax,	121
    jz        L1267
    cmp       %rax,	18
    jz        L1268
    cmp       %rax,	21
    jz        L1268
    cmp       %rax,	19
    jz        L1268
    cmp       %rax,	22
    jz        L1268
    cmp       %rax,	131
    jz        L1269
    cmp       %rax,	122
    jz        L1270
    cmp       %rax,	42
    jz        L1271
    cmp       %rax,	2
    jz        L1272
    cmp       %rax,	5
    jz        L1272
    cmp       %rax,	114
    jz        L1273
    cmp       %rax,	113
    jz        L1274
    cmp       %rax,	1
    jz        L1275
    jmp       L1276
L1265:
    jmp       L1264
L1266:
    mov       %rax,	[%r13+8]
    mov       %r10,	[%rbp + pc_reduce.pcl_reducetest.labelmap]
    mov       %r10w,	[%r10 + %rax*2-2]
    test      %r10w,	%r10w
    jz        L1278
    jmp       L1276
L1278:
    jmp       L1264
L1267:
    inc       qword ptr[%rbp + pc_reduce.pcl_reducetest.nprocs]
    mov       %rax,	[%r13+8]
    mov       [%rbp + pc_reduce.pcl_reducetest.pdef],	%rax
    lea       %rax,	[%r14+32]
    mov       %r10,	[%rbp + pc_reduce.pcl_reducetest.pdef]
    mov       [%r10+56],	%rax
    mov       %rcx,	8
    call      mlib.pcm_alloc
    mov       [%rip+pc_decls.pinfo],	%rax
    mov       %rax,	[%rip+pc_decls.pinfo]
    mov       %r10,	[%rbp + pc_reduce.pcl_reducetest.pdef]
    mov       [%r10+48],	%rax
    mov       %al,	1
    mov       %r10,	[%rip+pc_decls.pinfo]
    mov       [%r10+3],	%al
    mov       %rax,	[%rbp + pc_reduce.pcl_reducetest.pdef]
    mov       %al,	[%rax+112]
    mov       %r10,	[%rip+pc_decls.pinfo]
    mov       [%r10+1],	%al
    mov       %rax,	[%rbp + pc_reduce.pcl_reducetest.pdef]
    mov       %ax,	[%rax+114]
    mov       %r10,	[%rip+pc_decls.pinfo]
    mov       [%r10+2],	%al
    mov       %rax,	[%rbp + pc_reduce.pcl_reducetest.pdef]
    movzx     %rax,	byte ptr[%rax+112]
    add       [%rbp + pc_reduce.pcl_reducetest.nallparams],	%rax
    mov       %rax,	[%rbp + pc_reduce.pcl_reducetest.pdef]
    movsx     %rax,	word ptr[%rax+114]
    add       [%rbp + pc_reduce.pcl_reducetest.nalllocals],	%rax
    xor       %eax,	%eax
    mov       [%rbp + pc_reduce.pcl_reducetest.ncall],	%rax
    lea       %rax,	[%r14+32]
    mov       [%rbp + pc_reduce.pcl_reducetest.pcproc],	%rax
    jmp       L1276
    jmp       L1264
L1268:
    xor       %eax,	%eax
    mov       %r10,	[%rip+pc_decls.pinfo]
    mov       [%r10+3],	%al
    dec       qword ptr[%rbp + pc_reduce.pcl_reducetest.ncall]
    jmp       L1276
    jmp       L1264
L1269:
    add       %r14,	32
    mov       %rax,	%r13
    mov       %r10,	[%rax]
    mov       [%r14],	%r10
    mov       %r10,	[%rax+8]
    mov       [%r14+8],	%r10
    mov       %r10,	[%rax+16]
    mov       [%r14+16],	%r10
    mov       %r10,	[%rax+24]
    mov       [%r14+24],	%r10
    inc       %rbx
    mov       %rax,	%rbx
    lea       %r10,	[%r14+28]
    mov       %r8d,	[%r10]
    mov       %r11,	-4294967041
    shl       %eax,	8
    and       %r8d,	%r11d
    or        %r8d,	%eax
    mov       [%r10],	%r8d
    inc       qword ptr[%rbp + pc_reduce.pcl_reducetest.ncall]
    mov       %rax,	[%rbp + pc_reduce.pcl_reducetest.ncall]
    mov       %r10,	%r14
    mov       [%rbp + %rax*8 + pc_reduce.pcl_reducetest.callstack-8],	%r10
    jmp       L1264
L1270:
    mov       %rax,	[%rip+pc_decls.pinfo]
    mov       %al,	[%rax+3]
    test      %al,	%al
    jz        L1280
    inc       qword ptr[%rbp + pc_reduce.pcl_reducetest.nleaf]
L1280:
    xor       %eax,	%eax
    mov       [%rip+pc_decls.pinfo],	%rax
    jmp       L1276
    jmp       L1264
L1271:
    mov       %al,	1
    mov       %r10,	[%rip+pc_decls.pinfo]
    mov       [%r10+5],	%al
    jmp       L1276
    jmp       L1264
L1272:
    movzx     %rax,	byte ptr[%r14]
    cmp       %rax,	57
    jnz       L1282
    movzx     %rax,	byte ptr[%r13+3]
    cmp       %rax,	11
    jz        L1282
    mov       %al,	[%r13+3]
    mov       [%r14+3],	%al
    movzx     %rax,	byte ptr[%r13]
    cmp       %rax,	2
    jnz       L1284
    mov       %rax,	3
    jmp       L1283
L1284:
    mov       %rax,	6
L1283:
    mov       [%r14],	%al
    jmp       L1281
L1282:
    jmp       L1276
L1281:
    jmp       L1264
L1273:
    movzx     %rax,	byte ptr[%r15]
    cmp       %rax,	113
    jnz       L1286
    movsxd    %rax,	dword ptr[%r13+28]
    and       %rax,	255
    movsxd    %r10,	dword ptr[%r15+28]
    and       %r10,	255
    cmp       %rax,	%r10
    jnz       L1286
    add       %r13,	32
    jmp       L1285
L1286:
    movzx     %rax,	byte ptr[%r15]
    cmp       %rax,	28
    jz        L1288
    cmp       %rax,	27
    jnz       L1287
L1288:
    movsxd    %rax,	dword ptr[%r13+28]
    and       %rax,	255
    mov       [%r15+3],	%al
    jmp       L1285
L1287:
    jmp       L1276
L1285:
    jmp       L1264
L1274:
    movzx     %rax,	byte ptr[%r14]
    cmp       %rax,	1
    jz        L1291
    cmp       %rax,	2
    jz        L1291
    cmp       %rax,	3
    jnz       L1290
L1291:
    movzx     %rax,	byte ptr[%r14+3]
    movsxd    %r10,	dword ptr[%r13+28]
    and       %r10,	255
    cmp       %rax,	%r10
    jz        L1289
L1290:
    jmp       L1276
L1289:
    jmp       L1264
L1275:
    movzx     %rax,	byte ptr[%r13+1]
    cmp       %rax,	4
    jnz       L1293
    movzx     %rax,	byte ptr[%r15]
    movzx     %r10,	byte ptr[%r14]
    cmp       %r10,	%rax
    jnz       L1294
    cmp       %r10,	57
    jnz       L1294
    mov       %rax,	1
    jmp       L1295
L1294:
    xor       %eax,	%eax
L1295:
    test      %rax,	%rax
    setnz     %al
    movzx     %eax,	%al
    test      %ax,	%ax
    jz        L1293
    mov       %rax,	[%r13+8]
    movsxd    %r10,	dword ptr[%r15+16]
    imul      %rax,	%r10
    movsxd    %r10,	dword ptr[%r15+20]
    add       %rax,	%r10
    lea       %r10,	[%r14+20]
    add       [%r10],	%eax
    add       %r13,	32
    jmp       L1292
L1293:
    movzx     %rax,	byte ptr[%r15]
    cmp       %rax,	11
    jnz       L1296
    add       %r13,	32
    jmp       L1292
L1296:
    jmp       L1276
L1292:
    jmp       L1264
L1276:
    add       %r14,	32
    mov       %rax,	%r13
    mov       %r10,	[%rax]
    mov       [%r14],	%r10
    mov       %r10,	[%rax+8]
    mov       [%r14+8],	%r10
    mov       %r10,	[%rax+16]
    mov       [%r14+16],	%r10
    mov       %r10,	[%rax+24]
    mov       [%r14+24],	%r10
    inc       %rbx
    mov       %rax,	%rbx
    lea       %r10,	[%r14+28]
    mov       %r8d,	[%r10]
    mov       %r11,	-4294967041
    shl       %eax,	8
    and       %r8d,	%r11d
    or        %r8d,	%eax
    mov       [%r10],	%r8d
    movzx     %rax,	byte ptr[%r14+1]
    cmp       %rax,	2
    jnz       L1298
    movzx     %rax,	byte ptr[%r14]
    cmp       %rax,	1
    jnz       L1301
    mov       %eax,	[%r14+16]
    test      %eax,	%eax
    jnz       L1300
L1301:
    mov       %rax,	[%r14+8]
    mov       %r10b,	1
    mov       [%rax+88],	%r10b
L1300:
L1298:
L1264:
    add       %r13,	32
    dec       qword ptr[%rbp + pc_reduce.pcl_reducetest.av_1]
    jnz       L1255
L1257:
    mov       [%rip+pc_api.pccurr],	%r14
    mov       %rcx,	[%rbp + pc_reduce.pcl_reducetest.labelmap]
    mov       %rdx,	[%rip+pc_api.mlabelno]
    call      mlib.pcm_free
#---------------
    add       %rsp,	232
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_run_dummy.pcl_runpcl
pc_run_dummy.pcl_runpcl:
#?>>
#?]]
#---------------
#---
#---------------
    ret       
# End 
# Proc mc_genmcl.genmcl
mc_genmcl.genmcl:
#?>>
    .set mc_genmcl.genmcl.dummy, 32
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
    mov       %al,	[%rip+pc_decls.mcldone]
    test      %al,	%al
    jnz       L1303
L1305:
    call      mnoos.os_clock
    mov       %rdi,	%rax
    call      mc_genmcl.inithandlers
    xor       %ecx,	%ecx
    call      mc_libmcl.mclinit
    mov       %rax,	[%rip+pc_api.pcstart]
    mov       [%rip+mc_decls.currpcl],	%rax
    xor       %rbx,	%rbx
L1306:
    mov       %rcx,	[%rip+mc_decls.currpcl]
    call      mc_genmcl.convertpcl
    xor       %eax,	%eax
    test      %ax,	%ax
    jz        L1310
    mov       %rax,	[%rip+mc_decls.currpcl]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	127
    jz        L1310
    cmp       %rax,	135
    jz        L1310
    cmp       %rax,	120
    jz        L1310
    cmp       %rax,	121
    jz        L1310
    cmp       %rax,	20
    jz        L1310
    cmp       %rax,	122
    jz        L1310
    call      mc_stackmcl.showopndstack
L1310:
    add       qword ptr[%rip+mc_decls.currpcl],	32
    mov       %rax,	[%rip+mc_decls.currpcl]
    cmp       %rax,	[%rip+pc_api.pccurr]
    ja        L1311
    mov       %rax,	[%rip+mc_decls.currpcl]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	136
    jnz       L1306
L1311:
    call      mc_auxmcl.genrealtable
    call      mc_auxmcl.genabsneg
    call      mc_auxmcl.genstringtable
    mov       %rcx,	8
    xor       %edx,	%edx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	8
    xor       %edx,	%edx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %al,	[%rip+pc_decls.fpeephole]
    test      %al,	%al
    jz        L1313
    call      mc_optim.peephole
L1313:
    mov       %al,	1
    mov       [%rip+pc_decls.mcldone],	%al
    call      mnoos.os_clock
    sub       %rax,	%rdi
    mov       [%rip+pc_decls.mcltime],	%rax
L1303:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.convertpcl
mc_genmcl.convertpcl:
#?>>
    .set mc_genmcl.convertpcl.oldregset, -16
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	56
    mov       %rsi,	%rcx
#---------------
    mov       %al,	[%rip+pc_decls.fshowil]
    test      %al,	%al
    jz        L1316
    mov       %rcx,	%rsi
    call      mc_genmcl.doshowpcl
L1316:
    mov       %al,	[%rsi+3]
    mov       [%rip+mc_decls.pmode],	%al
    mov       [%rip+mc_decls.currpcl],	%rsi
    mov       %eax,	[%rsi+24]
    mov       [%rip+pc_decls.mmpos],	%rax
    movsxd    %rax,	dword ptr[%rsi+28]
    shr       %rax,	8
    and       %rax,	16777215
    mov       [%rip+pc_decls.ppseqno],	%rax
    movzx     %rax,	byte ptr[%rsi]
    lea       %r10,	[%rip+mc_genmcl.px_handlertable]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%rsi
    call      %r10
    lea       %rax,	[%rip+mc_decls.regset]
    lea       %r10,	[%rbp + mc_genmcl.convertpcl.oldregset]
    movdqu    %XMM4,	[%rax]
    movdqu    [%r10],	%XMM4
    lea       %rax,	[%rip+mc_decls.regset]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    lea       %rax,	[%rip+mc_decls.xregset]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    mov       %rbx,	1
    mov       %rax,	[%rip+mc_decls.noperands]
    cmp       %rax,	1
    jl        L1319
L1317:
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L1321
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	2
    jg        L1323
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.xregset]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    jmp       L1322
L1323:
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.regset]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
L1322:
L1321:
    inc       %rbx
    cmp       %rbx,	[%rip+mc_decls.noperands]
    jle       L1317
L1319:
    mov       %rax,	[%rbp + mc_genmcl.convertpcl.oldregset]
    lea       %r10,	[%rip+mc_decls.regset]
    mov       %r10,	[%r10]
    lea       %r11,	[%rip+mc_decls.isregvar]
    mov       %r11,	[%r11]
    or        %r10,	%r11
    mov       %r11,	72340172838076673
    xor       %r10,	%r11
    and       %rax,	%r10
    mov       %r10,	[%rip+mc_decls.mccodex]
    lea       %r10,	[%r10+48]
    or        [%r10],	%rax
    mov       %rax,	[%rbp + mc_genmcl.convertpcl.oldregset+8]
    lea       %r10,	[%rip+mc_decls.regset]
    mov       %r10,	[%r10+8]
    lea       %r11,	[%rip+mc_decls.isregvar]
    mov       %r11,	[%r11+8]
    or        %r10,	%r11
    mov       %r11,	72340172838076673
    xor       %r10,	%r11
    and       %rax,	%r10
    mov       %r10,	[%rip+mc_decls.mccodex]
    lea       %r10,	[%r10+56]
    or        [%r10],	%rax
#---------------
    add       %rsp,	56
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.inithandlers
mc_genmcl.inithandlers:
#?>>
    .set mc_genmcl.inithandlers.k, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
#---------------
    mov       %al,	[%rip+mc_genmcl.inithandlers.initdone]
    test      %al,	%al
    jnz       L1324
L1326:
    mov       %rsi,	[%rip+$nprocs]
    mov       %r15,	1
    cmp       %rsi,	1
    jl        L1329
L1327:
    lea       %rax,	[%rip+$procname]
    mov       %r10,	%r15
    mov       %rdi,	[%rax + %r10*8-8]
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8545]
    mov       %r8,	3
    call      mlib.eqbytes
    test      %rax,	%rax
    jz        L1331
    xor       %eax,	%eax
    mov       [%rbp + mc_genmcl.inithandlers.k],	%rax
    mov       %r12,	142
    cmp       %r12,	0
    jl        L1335
L1332:
    lea       %rax,	[%rip+pc_tables.pclnames]
    mov       %r10,	[%rbp + mc_genmcl.inithandlers.k]
    mov       %rbx,	[%rax + %r10*8]
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	107
    jnz       L1337
    inc       %rbx
L1337:
    lea       %rax,	[%rdi+3]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L1339
    lea       %rax,	[%rip+$procaddr]
    mov       %r10,	%r15
    mov       %rax,	[%rax + %r10*8-8]
    lea       %r10,	[%rip+mc_genmcl.px_handlertable]
    mov       %r11,	[%rbp + mc_genmcl.inithandlers.k]
    mov       [%r10 + %r11*8],	%rax
    jmp       L1334
L1339:
    mov       %rax,	[%rbp + mc_genmcl.inithandlers.k]
    inc       %rax
    mov       [%rbp + mc_genmcl.inithandlers.k],	%rax
    cmp       %rax,	%r12
    jle       L1332
L1335:
    lea       %rcx,	[%rip+L8546]
    mov       %rdx,	%rdi
    call      pc_api.merror
L1334:
L1331:
    inc       %r15
    cmp       %r15,	%rsi
    jle       L1327
L1329:
    mov       %r15,	1
    mov       %r13,	9
    cmp       %r13,	1
    jl        L1342
L1340:
    lea       %rax,	[%rip+mc_genmcl.inithandlers.dupltable]
    mov       %r10,	%r15
    lea       %rax,	[%rax + %r10*2-2]
    movzx     %rax,	byte ptr[%rax+1]
    lea       %r10,	[%rip+mc_genmcl.px_handlertable]
    mov       %r10,	[%r10 + %rax*8]
    lea       %rax,	[%rip+mc_genmcl.inithandlers.dupltable]
    mov       %r11,	%r15
    lea       %rax,	[%rax + %r11*2-2]
    movzx     %rax,	byte ptr[%rax]
    lea       %r11,	[%rip+mc_genmcl.px_handlertable]
    mov       [%r11 + %rax*8],	%r10
    inc       %r15
    cmp       %r15,	%r13
    jle       L1340
L1342:
    xor       %r15,	%r15
    mov       %rax,	142
    mov       %r14,	%rax
    cmp       %r14,	0
    jl        L1345
L1343:
    lea       %rax,	[%rip+mc_genmcl.px_handlertable]
    mov       %r10,	%r15
    mov       %rax,	[%rax + %r10*8]
    test      %rax,	%rax
    jnz       L1347
    lea       %rax,	[%rip+mc_genmcl.unimpl]
    lea       %r10,	[%rip+mc_genmcl.px_handlertable]
    mov       %r11,	%r15
    mov       [%r10 + %r11*8],	%rax
L1347:
    inc       %r15
    cmp       %r15,	%r14
    jle       L1343
L1345:
    mov       %al,	1
    mov       [%rip+mc_genmcl.inithandlers.initdone],	%al
L1324:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.doshowpcl
mc_genmcl.doshowpcl:
#?>>
    .set mc_genmcl.doshowpcl.str, -1256
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	1288
    mov       %rdi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rdi]
    cmp       %rax,	120
    jz        L1350
    cmp       %rax,	121
    jz        L1350
    cmp       %rax,	122
    jz        L1350
    cmp       %rax,	123
    jz        L1350
    cmp       %rax,	124
    jz        L1350
    cmp       %rax,	125
    jnz       L1351
L1350:
    jmp       L1349
L1351:
    lea       %rcx,	[%rbp + mc_genmcl.doshowpcl.str]
    lea       %rdx,	[%rip+L8547]
    call      strcpy
    mov       %rcx,	%rdi
    mov       %rdx,	1256
    call      pc_diags.strpclstr
    lea       %rcx,	[%rbp + mc_genmcl.doshowpcl.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rcx,	[%rbp + mc_genmcl.doshowpcl.str]
    call      mlib.pcm_copyheapstring
    mov       %rcx,	%rax
    call      mc_libmcl.mgencomment
L1349:
#---------------
    add       %rsp,	1288
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.unimpl
mc_genmcl.unimpl:
#?>>
    .set mc_genmcl.unimpl.str, -104
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	136
    mov       %rdi,	%rcx
#---------------
    lea       %rcx,	[%rbp + mc_genmcl.unimpl.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8548]
    call      msys.m$print_setfmt
    movzx     %rax,	byte ptr[%rdi]
    lea       %r10,	[%rip+pc_tables.pclnames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      pc_api.strpmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       %rcx,	[%rbp + mc_genmcl.unimpl.str]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rbp + mc_genmcl.unimpl.str]
    call      mlib.pcm_copyheapstring
    mov       %rcx,	%rax
    call      mc_libmcl.mgencomment
#---------------
    add       %rsp,	136
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_nop
mc_genmcl.px_nop:
#?>>
    .set mc_genmcl.px_nop.p, 16
#?]]
#---------------
#---
#---------------
    ret       
# End 
# Proc mc_genmcl.px_dupl
mc_genmcl.px_dupl:
#?>>
    .set mc_genmcl.px_dupl.p, 16
#?]]
    sub       %rsp,	40
#---------------
    call      mc_stackmcl.duplpcl
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_genmcl.px_double
mc_genmcl.px_double:
#?>>
    .set mc_genmcl.px_double.p, 16
#?]]
    sub       %rsp,	40
#---------------
    mov       %rax,	[%rip+mc_decls.ncalldepth]
    test      %rax,	%rax
    jz        L1357
    call      mc_stackmcl.duplpcl
    jmp       L1356
L1357:
    lea       %rax,	[%rip+mc_decls.pclcount]
    mov       %r10,	[%rip+mc_decls.noperands]
    lea       %rax,	[%rax + %r10-1]
    inc       byte ptr[%rax]
L1356:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_genmcl.px_opnd
mc_genmcl.px_opnd:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      mc_genmcl.unimpl
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_type
mc_genmcl.px_type:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      mc_genmcl.unimpl
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_comment
mc_genmcl.px_comment:
#?>>
    .set mc_genmcl.px_comment.p, 16
#?]]
#---------------
#---
#---------------
    ret       
# End 
# Proc mc_genmcl.px_proc
mc_genmcl.px_proc:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	[%rdi+8]
    mov       [%rip+pc_decls.currfunc],	%rax
    mov       %rcx,	67
    mov       %rdx,	1
    call      mc_libmcl.setsegment
    mov       %rcx,	[%rip+pc_decls.currfunc]
    call      mc_libmcl.mgenmemaddr
    mov       %rcx,	1
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	[%rip+pc_decls.currfunc]
    call      mc_libmcl.mgenmemaddr
    mov       %rcx,	4
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	[%rip+pc_decls.currfunc]
    call      mc_auxmcl.initproc
    lea       %rcx,	[%rip+L8549]
    call      mc_libmcl.mgencomment
    mov       %rax,	[%rip+mc_decls.mccodex]
    mov       [%rip+mc_decls.mclprocentry],	%rax
    mov       %rax,	[%rip+pc_decls.currfunc]
    movzx     %rax,	byte ptr[%rax+112]
    cmp       %rax,	2
    jnz       L1363
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %al,	[%rax+83]
    test      %al,	%al
    jz        L1363
    mov       %al,	[%rip+pepcl.pdcc]
    test      %al,	%al
    jnz       L1363
    call      mc_auxmcl.fixmain
L1363:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_endproc
mc_genmcl.px_endproc:
#?>>
    .set mc_genmcl.px_endproc.p, 16
#?]]
    sub       %rsp,	40
#---------------
    mov       %rax,	[%rip+mc_decls.noperands]
    test      %rax,	%rax
    jz        L1366
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8550]
    call      msys.m$print_str_nf
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8550]
    call      mc_libmcl.mgencomment
L1366:
    mov       %rcx,	2
    xor       %edx,	%edx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_genmcl.px_endprog
mc_genmcl.px_endprog:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      mc_genmcl.unimpl
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_istatic
mc_genmcl.px_istatic:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%rdi+16]
    mov       %rcx,	73
    mov       %rdx,	%rax
    call      mc_libmcl.setsegment
    mov       %rax,	[%rdi+8]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenmemaddr
    mov       %rcx,	4
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_zstatic
mc_genmcl.px_zstatic:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rdi,	[%rbx+8]
    movsxd    %rax,	dword ptr[%rbx+16]
    mov       %rcx,	90
    mov       %rdx,	%rax
    call      mc_libmcl.setsegment
    mov       %rcx,	%rdi
    call      mc_libmcl.mgenmemaddr
    mov       %rcx,	4
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %eax,	[%rbx+4]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	125
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_data
mc_genmcl.px_data:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rsi+3]
    cmp       %rax,	11
    jnz       L1372
    mov       %rcx,	%rsi
    call      mc_auxmcl.do_blockdata
    jmp       L1370
L1372:
    movzx     %rax,	byte ptr[%rsi+1]
    cmp       %rax,	4
    jz        L1374
    cmp       %rax,	10
    jz        L1375
    cmp       %rax,	11
    jz        L1376
    cmp       %rax,	6
    jz        L1377
    cmp       %rax,	7
    jz        L1378
    cmp       %rax,	2
    jz        L1379
    cmp       %rax,	3
    jz        L1380
    jmp       L1381
L1374:
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rdi,	%rax
    jmp       L1373
L1375:
    movq      %XMM4,	[%rsi+8]
    movq      %XMM0,	%XMM4
    mov       %rdx,	2
    call      mc_libmcl.mgenrealimm
    mov       %rdi,	%rax
    jmp       L1373
L1376:
    movq      %XMM4,	[%rsi+8]
    movq      %XMM0,	%XMM4
    mov       %rdx,	1
    call      mc_libmcl.mgenrealimm
    mov       %rdi,	%rax
    jmp       L1373
L1377:
    movq      %XMM4,	[%rsi+8]
    movq      %XMM0,	%XMM4
    mov       %rdx,	1
    call      mc_libmcl.mgenrealimm
    mov       %rdi,	%rax
    jmp       L1373
L1378:
    mov       %eax,	[%rsi+16]
    mov       %r10,	[%rsi+8]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_libmcl.getstringindex
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %rdi,	%rax
    jmp       L1373
L1379:
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenmemaddr
    mov       %rdi,	%rax
    mov       %eax,	[%rsi+20]
    mov       [%rdi+12],	%eax
    jmp       L1373
L1380:
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %rdi,	%rax
    jmp       L1373
L1381:
    movzx     %rax,	byte ptr[%rsi+1]
    lea       %r10,	[%rip+pc_tables.opndnames]
    mov       %r10,	[%r10 + %rax*8]
    lea       %rcx,	[%rip+L8551]
    mov       %rdx,	%r10
    call      pc_api.merror
L1373:
    mov       %eax,	[%rsi+4]
    cmp       %rax,	1
    jz        L1383
    cmp       %rax,	2
    jz        L1384
    cmp       %rax,	4
    jz        L1385
    cmp       %rax,	8
    jz        L1386
    jmp       L1387
L1383:
    mov       %rbx,	116
    jmp       L1382
L1384:
    mov       %rbx,	117
    jmp       L1382
L1385:
    mov       %rbx,	118
    jmp       L1382
L1386:
    mov       %rbx,	119
    jmp       L1382
L1387:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8552]
    call      msys.m$print_str_nf
    mov       %eax,	[%rsi+4]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    lea       %rcx,	[%rip+L8553]
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rsi+3]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      pc_api.strpmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8554]
    lea       %rdx,	[%rip+L8555]
    call      pc_api.merror
L1382:
    mov       %rcx,	%rbx
    mov       %rdx,	%rdi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L1370:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_label
mc_genmcl.px_label:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	[%rdi+8]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_load
mc_genmcl.px_load:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      mc_stackmcl.pushpcl
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_store
mc_genmcl.px_store:
#?>>
    .set mc_genmcl.px_store.$T1, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %r12,	%rcx
#---------------
    movzx     %rax,	byte ptr[%r12+3]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%r12+3]
    cmp       %rax,	11
    jz        L1392
    movzx     %rax,	byte ptr[%r12+3]
    mov       %r10,	[%r12+8]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_libmcl.mgenmem
    mov       %rdi,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    jmp       L1391
L1392:
    mov       %rcx,	6
    call      mc_stackmcl.getworkregm
    mov       %rdi,	%rax
    mov       %rsi,	[%r12+8]
    mov       %rcx,	%rsi
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       [%rbp + mc_genmcl.px_store.$T1],	%rax
    movzx     %rax,	byte ptr[%rsi+72]
    cmp       %rax,	5
    jnz       L1394
    mov       %rax,	11
    jmp       L1393
L1394:
    mov       %rax,	14
L1393:
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    mov       %r8,	[%rbp + mc_genmcl.px_store.$T1]
    call      mc_libmcl.genmc
    mov       %rcx,	%rdi
    mov       %rdx,	6
    call      mc_stackmcl.makeopndind
    mov       %rdi,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	6
    call      mc_stackmcl.makeopndind
    mov       %rbx,	%rax
    mov       %eax,	[%r12+4]
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    mov       %r9,	1
    call      mc_auxmcl.copyblock
L1391:
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_add
mc_genmcl.px_add:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rsi+3]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rsi+3]
    cmp       %rax,	2
    jle       L1397
    mov       %rcx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.isimmload
    test      %rax,	%rax
    jz        L1399
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	[%rip+mc_decls.noperands]
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rax,	[%rax+8]
    cmp       %rax,	1
    jnz       L1399
    mov       %rcx,	52
    mov       %rdx,	%rdi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L1398
L1399:
    movzx     %rax,	byte ptr[%rsi+3]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    mov       %rcx,	28
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L1398:
    jmp       L1396
L1397:
    movzx     %rax,	byte ptr[%rsi+3]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rsi+3]
    dec       %rax
    mov       %r10,	65
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L1396:
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_sub
mc_genmcl.px_sub:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rsi+3]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rsi+3]
    cmp       %rax,	2
    jle       L1402
    mov       %rcx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.isimmload
    test      %rax,	%rax
    jz        L1404
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	[%rip+mc_decls.noperands]
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rax,	[%rax+8]
    cmp       %rax,	1
    jnz       L1404
    mov       %rcx,	53
    mov       %rdx,	%rdi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L1403
L1404:
    movzx     %rax,	byte ptr[%rsi+3]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    mov       %rcx,	29
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L1403:
    jmp       L1401
L1402:
    movzx     %rax,	byte ptr[%rsi+3]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rsi+3]
    dec       %rax
    mov       %r10,	67
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L1401:
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_mul
mc_genmcl.px_mul:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rsi+3]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rsi+3]
    cmp       %rax,	2
    jle       L1407
    mov       %rcx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.isimmload
    test      %rax,	%rax
    jz        L1409
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	[%rip+mc_decls.noperands]
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rax,	[%rax+8]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mc_auxmcl.mulimm
    jmp       L1408
L1409:
    movzx     %rax,	byte ptr[%rsi+3]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    mov       %rcx,	34
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L1408:
    jmp       L1406
L1407:
    movzx     %rax,	byte ptr[%rsi+3]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rsi+3]
    dec       %rax
    mov       %r10,	69
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L1406:
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_div
mc_genmcl.px_div:
#?>>
    .set mc_genmcl.px_div.p, 32
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    dec       %rax
    mov       %r10,	71
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_eval
mc_genmcl.px_eval:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rdi+3]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_widen
mc_genmcl.px_widen:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	6
    jnz       L1414
    movsxd    %rax,	dword ptr[%rsi+28]
    and       %rax,	255
    cmp       %rax,	5
    jnz       L1414
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	5
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    mov       %rax,	[%rip+mc_decls.mccodex]
    movzx     %rax,	byte ptr[%rax+33]
    cmp       %rax,	11
    jz        L1416
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
L1416:
    jmp       L1413
L1414:
    movsxd    %rax,	dword ptr[%rsi+28]
    and       %rax,	255
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rax
    call      mc_stackmcl.getworkregm
    mov       %rdi,	%rax
    movsxd    %rax,	dword ptr[%rsi+28]
    and       %rax,	255
    lea       %r10,	[%rip+pc_tables.psigned]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1418
    mov       %rax,	18
    jmp       L1417
L1418:
    mov       %rax,	19
L1417:
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    movzx     %r10,	byte ptr[%rdi+10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_stackmcl.setnewzz
L1413:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_jump
mc_genmcl.px_jump:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    mov       %rdi,	[%rsi+8]
    lea       %rax,	[%rsi+32]
    mov       %rbx,	%rax
    jmp       L1421
L1420:
    add       %rbx,	32
L1421:
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	135
    jz        L1420
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	127
    jz        L1424
    cmp       %rax,	24
    jz        L1425
    jmp       L1426
L1424:
    mov       %rax,	[%rbx+8]
    cmp       %rax,	%rdi
    jz        L1419
L1428:
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	127
    jnz       L1430
    mov       %rax,	[%rbx+8]
    cmp       %rax,	%rdi
    jz        L1419
L1430:
    jmp       L1423
L1425:
    xor       %eax,	%eax
    mov       [%rbx],	%al
L1426:
L1423:
    mov       %rcx,	%rdi
    call      mc_libmcl.mgenlabel
    mov       %rcx,	25
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L1419:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_ijump
mc_genmcl.px_ijump:
#?>>
    .set mc_genmcl.px_ijump.p, 16
#?]]
    sub       %rsp,	40
#---------------
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rcx,	25
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_genmcl.px_neg
mc_genmcl.px_neg:
#?>>
    .set mc_genmcl.px_neg.p, 24
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jle       L1434
    mov       %rcx,	50
    mov       %rdx,	%rdi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L1433
L1434:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mc_auxmcl.do_negreal
L1433:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_abs
mc_genmcl.px_abs:
#?>>
    .set mc_genmcl.px_abs.p, 32
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jle       L1437
    xor       %ecx,	%ecx
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	42
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rax,	[%rip+pc_api.mlabelno]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %r10,	%rax
    mov       %rbx,	%r10
    mov       %rcx,	26
    mov       %rdx,	13
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    mov       %rcx,	50
    mov       %rdx,	%rdi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	9
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L1436
L1437:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mc_auxmcl.do_absreal
L1436:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_bitnot
mc_genmcl.px_bitnot:
#?>>
    .set mc_genmcl.px_bitnot.p, 24
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    mov       %rcx,	51
    mov       %rdx,	%rdi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_not
mc_genmcl.px_not:
#?>>
    .set mc_genmcl.px_not.p, 24
    .set mc_genmcl.px_not.$T1, -8
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    mov       %rcx,	1
    mov       %rdx,	3
    call      mc_libmcl.mgenint
    mov       [%rbp + mc_genmcl.px_not.$T1],	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      mc_libmcl.changeopndsize
    mov       %rcx,	40
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_genmcl.px_not.$T1]
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_toboolt
mc_genmcl.px_toboolt:
#?>>
    .set mc_genmcl.px_toboolt.$T2, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %r13,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%r13+28]
    and       %rax,	255
    mov       %r12b,	%al
    movzx     %rax,	%r12b
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	%r12b
    cmp       %rax,	2
    jg        L1442
    movzx     %rax,	%r12b
    mov       %rcx,	%rax
    call      mc_stackmcl.getworkregm
    mov       %rbx,	%rax
    mov       %rcx,	3
    call      mc_stackmcl.getworkregm
    mov       %rsi,	%rax
    movzx     %rax,	%r12b
    dec       %rax
    mov       %r10,	76
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rbx
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    movzx     %rax,	%r12b
    dec       %rax
    mov       %r10,	73
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%r13]
    cmp       %rax,	64
    jnz       L1444
    mov       %rax,	5
    jmp       L1443
L1444:
    mov       %rax,	4
L1443:
    mov       %rcx,	58
    mov       %rdx,	%rax
    mov       %r8,	%rsi
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    mov       %rcx,	%rsi
    mov       %rdx,	4
    call      mc_libmcl.changeopndsize
    mov       %rcx,	19
    mov       %rdx,	%rax
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    movzx     %r10,	byte ptr[%rsi+10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_stackmcl.setnewzz
    jmp       L1441
L1442:
    mov       %rcx,	41
    mov       %rdx,	%rdi
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      mc_libmcl.changeopndsize
    mov       %r10,	%rax
    mov       %rbx,	%r10
    mov       [%rbp + mc_genmcl.px_toboolt.$T2],	%rax
    movzx     %rax,	byte ptr[%r13]
    cmp       %rax,	64
    jnz       L1446
    mov       %rax,	5
    jmp       L1445
L1446:
    mov       %rax,	4
L1445:
    mov       %rcx,	58
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_genmcl.px_toboolt.$T2]
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    mov       %rcx,	%rdi
    mov       %rdx,	4
    call      mc_libmcl.changeopndsize
    mov       %rcx,	19
    mov       %rdx,	%rax
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    mov       %al,	[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+mc_decls.pclmode]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11-3],	%al
L1441:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_sqr
mc_genmcl.px_sqr:
#?>>
    .set mc_genmcl.px_sqr.p, 24
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jle       L1449
    mov       %rcx,	34
    mov       %rdx,	%rdi
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    jmp       L1448
L1449:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    dec       %rax
    mov       %r10,	69
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rdi
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
L1448:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_sqrt
mc_genmcl.px_sqrt:
#?>>
    .set mc_genmcl.px_sqrt.p, 24
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    dec       %rax
    mov       %r10,	63
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rdi
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_jumpcc
mc_genmcl.px_jumpcc:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
#---------------
    movzx     %rax,	byte ptr[%r13+2]
    lea       %r10,	[%rip+mc_genmcl.ucondcodes]
    movzx     %r10,	byte ptr[%r10 + %rax-1]
    mov       %rdi,	%r10
    mov       %rax,	[%r13+8]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %r12,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	11
    jnz       L1453
    lea       %rcx,	[%rip+L8556]
    lea       %rdx,	[%rip+L8557]
    call      pc_api.merror
    jmp       L1452
L1453:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jle       L1455
    mov       %rcx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.isimmload
    test      %rax,	%rax
    jz        L1457
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	[%rip+mc_decls.noperands]
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rax,	[%rax+8]
    test      %rax,	%rax
    jnz       L1457
    movzx     %rax,	byte ptr[%r13+2]
    cmp       %rax,	1
    jz        L1458
    cmp       %rax,	2
    jnz       L1457
L1458:
    mov       %rcx,	41
    mov       %rdx,	%rbx
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    jmp       L1456
L1457:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rsi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.psigned]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1460
    movzx     %rax,	byte ptr[%r13+2]
    lea       %r10,	[%rip+mc_genmcl.scondcodes]
    movzx     %r10,	byte ptr[%r10 + %rax-1]
    mov       %rdi,	%r10
L1460:
    mov       %rcx,	42
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
L1456:
    jmp       L1454
L1455:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rsi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    dec       %rax
    mov       %r10,	73
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
L1454:
    mov       %rcx,	26
    mov       %rdx,	%rdi
    mov       %r8,	%r12
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    call      mc_stackmcl.poppcl
    mov       %eax,	[%r13+16]
    test      %eax,	%eax
    jnz       L1462
    call      mc_stackmcl.poppcl
L1462:
L1452:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_jumpt
mc_genmcl.px_jumpt:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	5
    call      mc_auxmcl.do_jumptruefalse
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_jumpf
mc_genmcl.px_jumpf:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	4
    call      mc_auxmcl.do_jumptruefalse
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_bitand
mc_genmcl.px_bitand:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	38
    call      mc_auxmcl.do_bitwise
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_bitor
mc_genmcl.px_bitor:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	39
    call      mc_auxmcl.do_bitwise
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_bitxor
mc_genmcl.px_bitxor:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	40
    call      mc_auxmcl.do_bitwise
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_shl
mc_genmcl.px_shl:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	43
    call      mc_auxmcl.do_shift
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_shr
mc_genmcl.px_shr:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.psigned]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1471
    mov       %rax,	44
    jmp       L1470
L1471:
    mov       %rax,	45
L1470:
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mc_auxmcl.do_shift
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_retproc
mc_genmcl.px_retproc:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	[%rip+mc_decls.mclprocentry]
    cmp       %rax,	[%rip+mc_decls.mccodex]
    jnz       L1474
    lea       %rcx,	[%rip+L8558]
    call      mc_libmcl.mgencomment
L1474:
    mov       %rcx,	%rdi
    call      mc_auxmcl.do_procentry
    call      mc_auxmcl.do_procexit
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_retfn
mc_genmcl.px_retfn:
#?>>
    .set mc_genmcl.px_retfn.$T1, -8
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %rsi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	11
    jnz       L1477
    mov       %rcx,	1
    mov       %rdx,	10
    xor       %r8d,	%r8d
    call      mc_libmcl.mgenireg
    mov       %rbx,	%rax
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.regset]
    mov       [%r10],	%al
    mov       %rcx,	6
    call      mc_stackmcl.getworkregm
    mov       %rdi,	%rax
    mov       %rcx,	[%rip+pc_decls.blockretname]
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rdi+10]
    mov       %rcx,	%rax
    mov       %rdx,	10
    xor       %r8d,	%r8d
    call      mc_libmcl.mgenireg
    mov       %rdi,	%rax
    mov       %eax,	[%rsi+4]
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    mov       %r9,	1
    call      mc_auxmcl.copyblock
    mov       %rcx,	[%rip+pc_decls.blockretname]
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       [%rbp + mc_genmcl.px_retfn.$T1],	%rax
    mov       %rcx,	1
    mov       %rdx,	6
    call      mc_libmcl.mgenreg
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_genmcl.px_retfn.$T1]
    call      mc_libmcl.genmc
L1477:
    mov       %rcx,	%rsi
    call      mc_genmcl.px_retproc
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_setcall
mc_genmcl.px_setcall:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    xor       %ecx,	%ecx
    call      mc_stackmcl.saveopnds
    mov       %rax,	[%rip+mc_decls.ncalldepth]
    cmp       %rax,	16
    jl        L1480
    lea       %rcx,	[%rip+L8559]
    lea       %rdx,	[%rip+L8560]
    call      pc_api.merror
L1480:
    inc       qword ptr[%rip+mc_decls.ncalldepth]
    movsxd    %rax,	dword ptr[%rdi+16]
    cmp       %rax,	4
    jg        L1482
    mov       %eax,	[%rip+mc_decls.mstackdepth]
    and       %eax,	1
    lea       %r10,	[%rip+mc_decls.callalign]
    mov       %r11,	[%rip+mc_decls.ncalldepth]
    mov       [%r10 + %r11-1],	%al
    jmp       L1481
L1482:
    movsxd    %rax,	dword ptr[%rdi+16]
    and       %eax,	1
    mov       %r10d,	[%rip+mc_decls.mstackdepth]
    and       %r10d,	1
    xor       %rax,	%r10
    lea       %r10,	[%rip+mc_decls.callalign]
    mov       %r11,	[%rip+mc_decls.ncalldepth]
    mov       [%r10 + %r11-1],	%al
L1481:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	11
    setz      %al
    movzx     %eax,	%al
    lea       %r10,	[%rip+mc_decls.callblockret]
    mov       %r11,	[%rip+mc_decls.ncalldepth]
    mov       [%r10 + %r11-1],	%al
    mov       %eax,	[%rdi+4]
    lea       %r10,	[%rip+mc_decls.callblocksize]
    mov       %r11,	[%rip+mc_decls.ncalldepth]
    mov       [%r10 + %r11*4-4],	%eax
    lea       %rax,	[%rip+mc_decls.callalign]
    mov       %r10,	[%rip+mc_decls.ncalldepth]
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L1484
    mov       %rcx,	1
    call      mc_libmcl.pushslots
L1484:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_setarg
mc_genmcl.px_setarg:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%rbx+16]
    lea       %r10,	[%rip+mc_decls.callblockret]
    mov       %r11,	[%rip+mc_decls.ncalldepth]
    movzx     %r10,	byte ptr[%r10 + %r11-1]
    add       %rax,	%r10
    mov       %rdi,	%rax
    lea       %rax,	[%rip+mc_decls.callargmode]
    mov       %r10,	[%rip+mc_decls.ncalldepth]
    shl       %r10,	5
    lea       %rax,	[%rax + %r10-32]
    mov       %r10b,	[%rip+mc_decls.pmode]
    mov       %r11,	%rdi
    mov       [%rax + %r11-1],	%r10b
    mov       %eax,	[%rbx+4]
    lea       %r10,	[%rip+mc_decls.callargsize]
    mov       %r11,	[%rip+mc_decls.ncalldepth]
    shl       %r11,	7
    lea       %r10,	[%r10 + %r11-128]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*4-4],	%eax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	11
    jnz       L1487
    mov       %al,	6
    lea       %r10,	[%rip+mc_decls.pclmode]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11-1],	%al
    jmp       L1486
L1487:
    mov       %al,	[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+mc_decls.pclmode]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11-1],	%al
L1486:
    cmp       %rdi,	4
    jle       L1489
    mov       %eax,	[%rbx+4]
    movzx     %r10,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%r10
    mov       %r8,	%rax
    call      mc_stackmcl.pushopnd
    jmp       L1488
L1489:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	11
    jnz       L1490
    mov       %eax,	[%rbx+4]
    lea       %r10,	[%rip+mc_decls.callargsize]
    mov       %r11,	[%rip+mc_decls.ncalldepth]
    shl       %r11,	7
    lea       %r10,	[%r10 + %r11-128]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*4-4],	%eax
L1490:
L1488:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_callp
mc_genmcl.px_callp:
#?>>
    .set mc_genmcl.px_callp.p, 64
    .set mc_genmcl.px_callp.av_1, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       [%rbp+64],	%rcx
#---------------
    xor       %r12,	%r12
    xor       %eax,	%eax
    mov       %r13,	%rax
    lea       %rax,	[%rip+mc_decls.callblockret]
    mov       %r10,	[%rip+mc_decls.ncalldepth]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %r14,	%rax
    mov       %rax,	[%rbp + mc_genmcl.px_callp.p]
    movsxd    %rax,	dword ptr[%rax+16]
    add       %rax,	%r14
    mov       %rdi,	%rax
    mov       %rax,	%rdi
    mov       %r10,	4
    cmp       %rax,	%r10
    cmovg     %rax,	%r10
    mov       %rbx,	%rax
    mov       %rax,	[%rbp + mc_genmcl.px_callp.p]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	19
    jz        L1494
    cmp       %rax,	22
    jnz       L1493
L1494:
    mov       %r12,	1
L1493:
    mov       %rax,	[%rbp + mc_genmcl.px_callp.p]
    movsxd    %rax,	dword ptr[%rax+20]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    mov       %r8,	%r12
    xor       %r9d,	%r9d
    call      mc_auxmcl.do_pushlowargs
    xor       %rsi,	%rsi
    mov       %rax,	%rdi
    cmp       %rax,	4
    jg        L1496
    mov       %rax,	[%rip+mc_decls.mstackdepth]
    test      %rax,	%rax
    jz        L1498
    mov       %rax,	4
    add       %rsi,	%rax
    mov       %rcx,	4
    call      mc_libmcl.pushslots
    lea       %rax,	[%rip+mc_decls.callalign]
    mov       %r10,	[%rip+mc_decls.ncalldepth]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    add       %rsi,	%rax
    jmp       L1497
L1498:
    mov       %al,	1
    mov       [%rip+pc_decls.localshadow],	%al
L1497:
    jmp       L1495
L1496:
    lea       %rax,	[%rip+mc_decls.callalign]
    mov       %r10,	[%rip+mc_decls.ncalldepth]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %r10,	%rdi
    add       %r10,	%rax
    mov       %rsi,	%r10
    mov       %rcx,	4
    call      mc_libmcl.pushslots
L1495:
    test      %r12,	%r12
    jz        L1500
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rcx,	21
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    jmp       L1499
L1500:
    mov       %rax,	[%rbp + mc_genmcl.px_callp.p]
    mov       %rax,	[%rax+8]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenmemaddr
    mov       %rcx,	21
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L1499:
    mov       %rax,	%rbx
    sub       %rax,	%r14
    mov       [%rbp + mc_genmcl.px_callp.av_1],	%rax
    mov       %rax,	[%rbp + mc_genmcl.px_callp.av_1]
    cmp       %rax,	0
    jle       L1503
L1501:
    call      mc_stackmcl.poppcl
    dec       qword ptr[%rbp + mc_genmcl.px_callp.av_1]
    jnz       L1501
L1503:
    test      %rsi,	%rsi
    jz        L1505
    mov       %rcx,	%rsi
    call      mc_libmcl.popslots
L1505:
    mov       %al,	[%rip+mc_decls.pmode]
    test      %al,	%al
    jz        L1507
    mov       %rcx,	[%rbp + mc_genmcl.px_callp.p]
    call      mc_auxmcl.do_getretvalue
L1507:
    dec       qword ptr[%rip+mc_decls.ncalldepth]
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_jumpret
mc_genmcl.px_jumpret:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %al,	[%rip+mc_decls.pmode]
    test      %al,	%al
    jz        L1510
    mov       %rax,	[%rip+mc_decls.noperands]
    test      %rax,	%rax
    jz        L1512
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    mov       %r8,	1
    call      mc_stackmcl.loadparam
    call      mc_stackmcl.poppcl
L1512:
L1510:
    mov       %rcx,	%rdi
    call      mc_genmcl.px_jump
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_jumpretm
mc_genmcl.px_jumpretm:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%r13+16]
    mov       %r10,	[%rip+mc_decls.noperands]
    sub       %r10,	%rax
    inc       %r10
    mov       %rdi,	%r10
    movsxd    %rax,	dword ptr[%r13+16]
    mov       %rsi,	%rax
    cmp       %rsi,	0
    jle       L1516
L1514:
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    inc       %rdi
    dec       %rsi
    jnz       L1514
L1516:
    mov       %rbx,	1
    movsxd    %rax,	dword ptr[%r13+16]
    mov       %r12,	%rax
    cmp       %r12,	0
    jle       L1519
L1517:
    cmp       %rbx,	4
    jnz       L1521
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	2
    jle       L1521
    mov       %rbx,	11
L1521:
    mov       %rcx,	%rbx
    call      mc_stackmcl.movetoreg
    call      mc_stackmcl.poppcl
    inc       %rbx
    dec       %r12
    jnz       L1517
L1519:
    mov       %rcx,	%r13
    call      mc_genmcl.px_jump
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_startmx
mc_genmcl.px_startmx:
#?>>
    .set mc_genmcl.px_startmx.p, 16
#?]]
    sub       %rsp,	40
#---------------
    xor       %ecx,	%ecx
    call      mc_stackmcl.saveopnds
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_genmcl.px_resetmx
mc_genmcl.px_resetmx:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	1
    call      mc_stackmcl.movetoreg
    movzx     %rax,	byte ptr[%rdi]
    cmp       %rax,	118
    jnz       L1525
    call      mc_stackmcl.poppcl
L1525:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_stop
mc_genmcl.px_stop:
#?>>
    .set mc_genmcl.px_stop.p, 16
#?]]
    sub       %rsp,	40
#---------------
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	6
    mov       %r8,	11
    call      mc_stackmcl.loadparam
    lea       %rcx,	[%rip+L8561]
    call      mc_libmcl.mgenextname
    mov       %rcx,	21
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %al,	1
    mov       [%rip+pc_decls.localshadow],	%al
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_genmcl.px_incrto
mc_genmcl.px_incrto:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	52
    mov       %r8,	28
    call      mc_auxmcl.do_incr
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_decrto
mc_genmcl.px_decrto:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	53
    mov       %r8,	29
    call      mc_auxmcl.do_incr
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_incrload
mc_genmcl.px_incrload:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	52
    mov       %r8,	28
    call      mc_auxmcl.do_incrload
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_decrload
mc_genmcl.px_decrload:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	53
    mov       %r8,	29
    call      mc_auxmcl.do_incrload
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_loadincr
mc_genmcl.px_loadincr:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	52
    mov       %r8,	28
    call      mc_auxmcl.do_loadincr
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_loaddecr
mc_genmcl.px_loaddecr:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	53
    mov       %r8,	29
    call      mc_auxmcl.do_loadincr
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_forup
mc_genmcl.px_forup:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	52
    mov       %r8,	28
    mov       %r9,	14
    call      mc_auxmcl.do_for
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_fordown
mc_genmcl.px_fordown:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	53
    mov       %r8,	29
    mov       %r9,	13
    call      mc_auxmcl.do_for
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_iload
mc_genmcl.px_iload:
#?>>
    .set mc_genmcl.px_iload.p, 40
    .set mc_genmcl.px_iload.$T1, -8
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	11
    jz        L1537
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	2
    jnz       L1539
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	[%rip+mc_decls.noperands]
    movzx     %r10,	byte ptr[%r10 + %r11-1]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.mgenireg
    mov       %rbx,	%rax
    jmp       L1538
L1539:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rbx,	%rax
L1538:
    mov       %rax,	[%rip+mc_decls.currpcl]
    lea       %rax,	[%rax+32]
    mov       %rsi,	%rax
    movzx     %rax,	byte ptr[%rsi]
    cmp       %rax,	114
    jnz       L1541
    movzx     %rax,	byte ptr[%rsi+3]
    mov       [%rbp + mc_genmcl.px_iload.$T1],	%rax
    movzx     %rax,	byte ptr[%rsi+3]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      mc_genmcl.getsharereg
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_genmcl.px_iload.$T1]
    call      mc_stackmcl.getworkreg_rm
    mov       %rdi,	%rax
    movsxd    %rax,	dword ptr[%rsi+28]
    and       %rax,	255
    lea       %r10,	[%rip+mc_decls.ploadop]
    movzx     %r10,	byte ptr[%r10 + %rax]
    mov       %rcx,	%r10
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rsi+3]
    movzx     %r10,	byte ptr[%rdi+10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_stackmcl.setnewzz
    mov       [%rip+mc_decls.currpcl],	%rsi
    jmp       L1540
L1541:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       [%rbp + mc_genmcl.px_iload.$T1],	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      mc_genmcl.getsharereg
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_genmcl.px_iload.$T1]
    call      mc_stackmcl.getworkreg_rm
    mov       %rdi,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    movzx     %r10,	byte ptr[%rdi+10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_stackmcl.setnewzz
L1540:
    jmp       L1536
L1537:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind_simp
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rbx+10]
    mov       %rcx,	%rax
    mov       %rdx,	6
    call      mc_stackmcl.getworkreg_rm
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mc_auxmcl.dolea
L1536:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.getsharereg
mc_genmcl.getsharereg:
#?>>
    push      %rdi
    push      %rbx
#?]]
#---------------
    mov       %dil,	[%rcx+10]
    mov       %bl,	[%rcx+11]
    cmp       %rdx,	2
    jg        L1544
    xor       %eax,	%eax
    jmp       L1542
L1544:
    test      %dil,	%dil
    jz        L1546
    movzx     %rax,	%dil
    lea       %r10,	[%rip+mc_decls.workregs]
    mov       %r10b,	[%r10 + %rax-1]
    test      %r10b,	%r10b
    jnz       L1547
    movzx     %rax,	%dil
    cmp       %rax,	11
    jl        L1546
    cmp       %rax,	14
    jg        L1546
L1547:
    movzx     %rax,	%dil
    jmp       L1542
L1546:
    test      %bl,	%bl
    jz        L1548
    movzx     %rax,	%bl
    lea       %r10,	[%rip+mc_decls.workregs]
    mov       %r10b,	[%r10 + %rax-1]
    test      %r10b,	%r10b
    jnz       L1549
    movzx     %rax,	%dil
    cmp       %rax,	11
    jl        L1548
    cmp       %rax,	14
    jg        L1548
L1549:
    movzx     %rax,	%bl
    jmp       L1542
L1548:
L1545:
    xor       %eax,	%eax
L1542:
#---------------
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_iloadx
mc_genmcl.px_iloadx:
#?>>
    .set mc_genmcl.px_iloadx.$T1, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %r12,	%rcx
#---------------
    mov       %rcx,	%r12
    call      mc_auxmcl.do_addrmode
    mov       %rsi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	11
    jnz       L1552
    movzx     %rax,	byte ptr[%rsi+10]
    mov       %rcx,	%rax
    mov       %rdx,	6
    call      mc_stackmcl.getworkreg_rm
    mov       %rbx,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      mc_auxmcl.dolea
    call      mc_stackmcl.poppcl
    movzx     %rax,	byte ptr[%rbx+10]
    mov       %rcx,	%rax
    mov       %rdx,	6
    call      mc_stackmcl.setnewzz
    jmp       L1551
L1552:
    mov       %rax,	[%rip+mc_decls.currpcl]
    lea       %rax,	[%rax+32]
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rdi]
    cmp       %rax,	114
    jnz       L1554
    movzx     %rax,	byte ptr[%rdi+3]
    mov       [%rbp + mc_genmcl.px_iloadx.$T1],	%rax
    movzx     %rax,	byte ptr[%rdi+3]
    mov       %rcx,	%rsi
    mov       %rdx,	%rax
    call      mc_genmcl.getsharereg
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_genmcl.px_iloadx.$T1]
    call      mc_stackmcl.getworkreg_rm
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%rdi+28]
    and       %rax,	255
    lea       %r10,	[%rip+mc_decls.ploadop]
    movzx     %r10,	byte ptr[%r10 + %rax]
    mov       %rcx,	%r10
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    movzx     %rax,	byte ptr[%rdi+3]
    movzx     %r10,	byte ptr[%rbx+10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_stackmcl.setnewzz
    mov       [%rip+mc_decls.currpcl],	%rdi
    jmp       L1553
L1554:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       [%rbp + mc_genmcl.px_iloadx.$T1],	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rsi
    mov       %rdx,	%rax
    call      mc_genmcl.getsharereg
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_genmcl.px_iloadx.$T1]
    call      mc_stackmcl.getworkreg_rm
    mov       %rbx,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    movzx     %r10,	byte ptr[%rbx+10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_stackmcl.setnewzz
L1553:
L1551:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_istore
mc_genmcl.px_istore:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	2
    jnz       L1557
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	[%rip+mc_decls.noperands]
    movzx     %r10,	byte ptr[%r10 + %r11-1]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.mgenireg
    mov       %rbx,	%rax
    jmp       L1556
L1557:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rbx,	%rax
L1556:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	11
    jnz       L1559
    mov       %rcx,	%rbx
    call      mc_stackmcl.makesimpleaddr
    mov       %rbx,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	6
    call      mc_stackmcl.makeopndind
    mov       %rdi,	%rax
    mov       %eax,	[%rsi+4]
    mov       %rcx,	%rbx
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    mov       %r9,	1
    call      mc_auxmcl.copyblock
    jmp       L1558
L1559:
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
L1558:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_istorex
mc_genmcl.px_istorex:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    sub       %r10,	2
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    mov       %rcx,	%rsi
    call      mc_auxmcl.do_addrmode
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	11
    jnz       L1562
    mov       %rcx,	%rbx
    call      mc_stackmcl.makesimpleaddr
    mov       %rbx,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	6
    call      mc_stackmcl.makeopndind
    mov       %rdi,	%rax
    mov       %eax,	[%rsi+4]
    mov       %rcx,	%rbx
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    mov       %r9,	1
    call      mc_auxmcl.copyblock
    jmp       L1561
L1562:
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
L1561:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_storem
mc_genmcl.px_storem:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
    mov       %eax,	[%r12+4]
    cmp       %rax,	16
    jz        L1565
    lea       %rcx,	[%rip+L8562]
    lea       %rdx,	[%rip+L8563]
    call      pc_api.merror
L1565:
    mov       %rcx,	16
    call      mc_libmcl.newblocktemp
    mov       %rsi,	%rax
    mov       %rcx,	%rsi
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       %rbx,	%rax
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	8
    xor       %r8d,	%r8d
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rdi+10]
    mov       %rcx,	%rax
    mov       %rdx,	6
    call      mc_libmcl.mgenreg
    mov       %rcx,	14
    mov       %rdx,	%rax
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rdi+10]
    mov       %rcx,	%rax
    mov       %rdx,	6
    call      mc_stackmcl.setnewzz
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_addpx
mc_genmcl.px_addpx:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    mov       %rcx,	%rsi
    call      mc_auxmcl.do_addrmode
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rbx+10]
    mov       %rcx,	%rax
    mov       %rdx,	6
    call      mc_stackmcl.getworkreg_rm
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mc_auxmcl.dolea
    call      mc_stackmcl.poppcl
    movzx     %rax,	byte ptr[%rdi+10]
    mov       %rcx,	%rax
    mov       %rdx,	6
    call      mc_stackmcl.setnewzz
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_subpx
mc_genmcl.px_subpx:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r14,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%r14+16]
    mov       %rdi,	%rax
    movsxd    %rax,	dword ptr[%r14+20]
    mov       %rbx,	%rax
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rsi,	%rax
    mov       %rcx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.isimmload
    mov       %r13,	%rax
    test      %rax,	%rax
    jz        L1569
    mov       %rax,	[%r13+8]
    mov       %r10,	%rdi
    imul      %rax,	%r10
    add       %rax,	%rbx
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	29
    mov       %rdx,	%rsi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L1568
L1569:
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %r12,	%rax
    mov       %rcx,	%r12
    mov       %rdx,	%rdi
    call      mc_auxmcl.scaleindex
    mov       %rdi,	%rax
    cmp       %rdi,	1
    jle       L1571
    mov       %rcx,	%r12
    mov       %rdx,	%rdi
    call      mc_auxmcl.mulimm
L1571:
    mov       %rcx,	29
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      mc_libmcl.genmc
    test      %rbx,	%rbx
    jz        L1573
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8564]
    call      msys.m$print_str_nf
    mov       %rcx,	%rbx
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8565]
    lea       %rdx,	[%rip+L8566]
    call      pc_api.merror
L1573:
L1568:
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_to
mc_genmcl.px_to:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    lea       %rax,	[%rsi+32]
    mov       [%rip+mc_decls.currpcl],	%rax
    mov       %rdi,	%rax
    mov       %rax,	[%rdi+8]
    mov       %rcx,	%rax
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       %rbx,	%rax
    mov       %rcx,	53
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %rcx,	26
    mov       %rdx,	5
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_iswap
mc_genmcl.px_iswap:
#?>>
    .set mc_genmcl.px_iswap.p, 48
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rsi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %r12,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rax
    call      mc_stackmcl.getworkregm
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rax
    call      mc_stackmcl.getworkregm
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	11
    jz        L1577
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%r12
    call      mc_libmcl.genmc
    mov       %rcx,	11
    mov       %rdx,	%r12
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rcx,	11
    mov       %rdx,	%rsi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    jmp       L1576
L1577:
    lea       %rcx,	[%rip+L8567]
    lea       %rdx,	[%rip+L8568]
    call      pc_api.merror
L1576:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_swapstk
mc_genmcl.px_swapstk:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%rdi+20]
    mov       %r10,	[%rip+mc_decls.noperands]
    sub       %r10,	%rax
    inc       %r10
    movsxd    %rax,	dword ptr[%rdi+16]
    mov       %r11,	[%rip+mc_decls.noperands]
    sub       %r11,	%rax
    inc       %r11
    mov       %rcx,	%r11
    mov       %rdx,	%r10
    call      mc_stackmcl.swapopnds
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_labeldef
mc_genmcl.px_labeldef:
#?>>
    .set mc_genmcl.px_labeldef.str, -104
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	136
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	[%rdi+8]
    mov       %rax,	[%rax]
    lea       %rcx,	[%rbp + mc_genmcl.px_labeldef.str]
    mov       %rdx,	%rax
    call      strcpy
    lea       %rcx,	[%rbp + mc_genmcl.px_labeldef.str]
    lea       %rdx,	[%rip+L8569]
    call      strcat
    lea       %rcx,	[%rbp + mc_genmcl.px_labeldef.str]
    call      mc_libmcl.mgencomment
#---------------
    add       %rsp,	136
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_addto
mc_genmcl.px_addto:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	28
    mov       %r8,	65
    call      mc_auxmcl.do_binto
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_subto
mc_genmcl.px_subto:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	29
    mov       %r8,	67
    call      mc_auxmcl.do_binto
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_multo
mc_genmcl.px_multo:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jg        L1584
    mov       %rcx,	%r13
    mov       %rdx,	69
    call      mc_auxmcl.do_binto_float
    jmp       L1582
L1584:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.psize]
    movzx     %r10,	byte ptr[%r10 + %rax]
    cmp       %r10,	1
    jnz       L1586
    lea       %rcx,	[%rip+L8570]
    lea       %rdx,	[%rip+L8571]
    call      pc_api.merror
L1586:
    mov       %rcx,	10
    xor       %edx,	%edx
    call      mc_stackmcl.pushpcl_reg
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    sub       %r10,	2
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rsi,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rsi
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rax,	[%rip+mc_decls.noperands]
    sub       %rax,	2
    mov       %rcx,	%rax
    call      mc_stackmcl.isimmload
    mov       %r12,	%rax
    test      %rax,	%rax
    jz        L1588
    mov       %rax,	[%r12+8]
    mov       %rcx,	%rsi
    mov       %rdx,	%rax
    call      mc_auxmcl.mulimm
    jmp       L1587
L1588:
    mov       %rcx,	34
    mov       %rdx,	%rsi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L1587:
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
L1582:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_bitandto
mc_genmcl.px_bitandto:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	38
    xor       %r8d,	%r8d
    call      mc_auxmcl.do_binto
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_bitorto
mc_genmcl.px_bitorto:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	39
    xor       %r8d,	%r8d
    call      mc_auxmcl.do_binto
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_bitxorto
mc_genmcl.px_bitxorto:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	40
    xor       %r8d,	%r8d
    call      mc_auxmcl.do_binto
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_shlto
mc_genmcl.px_shlto:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	43
    call      mc_auxmcl.do_shiftnto
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_shrto
mc_genmcl.px_shrto:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.psigned]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1595
    mov       %rax,	44
    jmp       L1594
L1595:
    mov       %rax,	45
L1594:
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mc_auxmcl.do_shiftnto
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_fix
mc_genmcl.px_fix:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%rsi+28]
    and       %rax,	255
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      mc_stackmcl.pushpcl_reg
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.pmin]
    movzx     %r10,	byte ptr[%r10 + %rax]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%r10
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%rsi+28]
    and       %rax,	255
    dec       %rax
    mov       %r10,	84
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    call      mc_stackmcl.poppcl
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    movzx     %r10,	byte ptr[%rbx+10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_stackmcl.setnewzz
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_float
mc_genmcl.px_float:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r14,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%r14+28]
    and       %rax,	255
    mov       %r13b,	%al
    movzx     %rax,	%r13b
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	%r13b
    lea       %r10,	[%rip+pc_tables.psize]
    movzx     %r10,	byte ptr[%r10 + %rax]
    cmp       %r10,	4
    jge       L1599
    lea       %rcx,	[%rip+L8572]
    lea       %rdx,	[%rip+L8573]
    call      pc_api.merror
L1599:
    movzx     %rax,	%r13b
    lea       %r10,	[%rip+pc_tables.psigned]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1601
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      mc_stackmcl.pushpcl_reg
    movzx     %rax,	byte ptr[%r14+3]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    dec       %rax
    mov       %r10,	86
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    jmp       L1600
L1601:
    movzx     %rax,	%r13b
    cmp       %rax,	6
    jnz       L1602
    mov       %rcx,	2
    xor       %edx,	%edx
    call      mc_stackmcl.pushpcl_reg
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	2
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    call      mc_libmcl.mcreatefwdlabel
    mov       %rsi,	%rax
    call      mc_libmcl.mcreatefwdlabel
    mov       %r12,	%rax
    xor       %ecx,	%ecx
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	42
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	%rsi
    call      mc_libmcl.mgenlabel
    mov       %rcx,	26
    mov       %rdx,	12
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    mov       %rcx,	87
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rcx,	%r12
    call      mc_libmcl.mgenlabel
    mov       %rcx,	25
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	%rsi
    call      mc_libmcl.mdefinefwdlabel
    mov       %rax,	[%rip+mc_decls.labmask63]
    test      %rax,	%rax
    jnz       L1604
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rax,	[%rip+pc_api.mlabelno]
    mov       [%rip+mc_decls.labmask63],	%rax
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rax,	[%rip+pc_api.mlabelno]
    mov       [%rip+mc_decls.laboffset64],	%rax
L1604:
    mov       %rcx,	[%rip+mc_decls.labmask63]
    call      mc_libmcl.mgenlabelmem
    mov       %rcx,	38
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	87
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rcx,	[%rip+mc_decls.laboffset64]
    call      mc_libmcl.mgenlabelmem
    mov       %rcx,	66
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	%r12
    call      mc_libmcl.mdefinefwdlabel
#mc_genmcl.px_float.reduce:
L1605:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	1
    jnz       L1607
    mov       %rcx,	%rbx
    mov       %rdx,	4
    call      mc_libmcl.changeopndsize
    mov       %rcx,	88
    mov       %rdx,	%rax
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.pclmode]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11-1],	%al
L1607:
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    jmp       L1600
L1602:
    mov       %rcx,	2
    xor       %edx,	%edx
    call      mc_stackmcl.pushpcl_reg
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	2
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	8
    call      mc_libmcl.changeopndsize
    mov       %rdi,	%rax
    mov       %rcx,	87
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    jmp       L1605
L1600:
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_idiv
mc_genmcl.px_idiv:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.psigned]
    movzx     %r10,	byte ptr[%r10 + %rax]
    mov       %rcx,	%rdi
    mov       %rdx,	%r10
    mov       %r8,	1
    call      mc_auxmcl.do_divrem
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_irem
mc_genmcl.px_irem:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.psigned]
    movzx     %r10,	byte ptr[%r10 + %rax]
    mov       %rcx,	%rdi
    mov       %rdx,	%r10
    xor       %r8d,	%r8d
    call      mc_auxmcl.do_divrem
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_idivrem
mc_genmcl.px_idivrem:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.psigned]
    movzx     %r10,	byte ptr[%r10 + %rax]
    mov       %rcx,	%rdi
    mov       %rdx,	%r10
    mov       %r8,	2
    call      mc_auxmcl.do_divrem
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_clear
mc_genmcl.px_clear:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	6
    call      mc_stackmcl.getopnd_ind_simp
    mov       %rdi,	%rax
    mov       %eax,	[%rbx+4]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mc_auxmcl.clearblock
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_subp
mc_genmcl.px_subp:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    mov       %rcx,	29
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    movsxd    %rax,	dword ptr[%r12+16]
    cmp       %rax,	1
    jle       L1614
    movsxd    %rax,	dword ptr[%r12+16]
    mov       %rcx,	%rax
    call      mc_libmcl.ispoweroftwo
    mov       %rsi,	%rax
    test      %rsi,	%rsi
    jz        L1616
    mov       %rcx,	%rsi
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	45
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L1615
L1616:
    call      msys.m$print_startcon
    movsxd    %rax,	dword ptr[%r12+16]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8574]
    lea       %rdx,	[%rip+L8575]
    call      pc_api.merror
L1615:
L1614:
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_switch
mc_genmcl.px_switch:
#?>>
    .set mc_genmcl.px_switch.p, 64
    .set mc_genmcl.px_switch.bx, -8
    .set mc_genmcl.px_switch.ax2, -16
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       [%rbp+64],	%rcx
#---------------
    mov       %rax,	[%rbp + mc_genmcl.px_switch.p]
    movsxd    %rax,	dword ptr[%rax+16]
    mov       %rdi,	%rax
    mov       %rax,	[%rbp + mc_genmcl.px_switch.p]
    movsxd    %rax,	dword ptr[%rax+20]
    mov       %rbx,	%rax
    mov       %rax,	[%rbp + mc_genmcl.px_switch.p]
    mov       %rsi,	[%rax+8]
    mov       %rax,	[%rbp + mc_genmcl.px_switch.p]
    lea       %rax,	[%rax+32]
    mov       [%rip+mc_decls.currpcl],	%rax
    mov       %rax,	[%rip+mc_decls.currpcl]
    mov       %r12,	[%rax+8]
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %r14,	%rax
    mov       %rax,	[%rbp + mc_genmcl.px_switch.p]
    mov       %eax,	[%rax+4]
    cmp       %rax,	8
    jge       L1619
    mov       %rcx,	%r14
    mov       %rdx,	8
    call      mc_libmcl.changeopndsize
    mov       %r10,	%rax
    mov       [%rbp + mc_genmcl.px_switch.ax2],	%r10
    mov       %rcx,	18
    mov       %rdx,	%rax
    mov       %r8,	%r14
    call      mc_libmcl.genmc
    mov       %r14,	[%rbp + mc_genmcl.px_switch.ax2]
L1619:
    test      %rdi,	%rdi
    jz        L1621
    mov       %rcx,	%rdi
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	29
    mov       %rdx,	%r14
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L1621:
    mov       %rax,	%rbx
    sub       %rax,	%rdi
    inc       %rax
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	42
    mov       %rdx,	%r14
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	%r12
    call      mc_libmcl.mgenlabel
    mov       %rcx,	26
    mov       %rdx,	3
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    movzx     %rax,	byte ptr[%rip+pc_api.phighmem]
    cmp       %rax,	2
    jnz       L1623
    call      mc_stackmcl.getworkireg
    mov       %r13,	%rax
    mov       %rcx,	%r13
    mov       %rdx,	6
    call      mc_libmcl.mgenreg
    mov       [%rbp + mc_genmcl.px_switch.bx],	%rax
    mov       %rcx,	%rsi
    call      mc_libmcl.mgenlabelmem
    mov       %rcx,	14
    mov       %rdx,	[%rbp + mc_genmcl.px_switch.bx]
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    sub       %rsp,	8
    push      0
    push      0
    push      0
    movzx     %rax,	byte ptr[%r14+10]
    mov       %rcx,	%r13
    mov       %rdx,	%rax
    mov       %r8,	8
    xor       %r9d,	%r9d
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rcx,	25
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L1622
L1623:
    sub       %rsp,	8
    push      0
    mov       %rax,	%rsi
    push      %rax
    push      0
    movzx     %rax,	byte ptr[%r14+10]
    xor       %ecx,	%ecx
    mov       %rdx,	%rax
    mov       %r8,	8
    xor       %r9d,	%r9d
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rcx,	25
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L1622:
    call      mc_stackmcl.poppcl
    mov       %rcx,	73
    mov       %rdx,	1
    call      mc_libmcl.setsegment
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_switchu
mc_genmcl.px_switchu:
#?>>
    .set mc_genmcl.px_switchu.p, 64
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	32
    mov       [%rbp+64],	%rcx
#---------------
    mov       %rax,	[%rbp + mc_genmcl.px_switchu.p]
    movsxd    %rax,	dword ptr[%rax+16]
    mov       %rdi,	%rax
    mov       %rax,	[%rbp + mc_genmcl.px_switchu.p]
    movsxd    %rax,	dword ptr[%rax+20]
    mov       %rbx,	%rax
    mov       %rax,	[%rbp + mc_genmcl.px_switchu.p]
    mov       %rsi,	[%rax+8]
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %r13,	%rax
    movzx     %rax,	byte ptr[%rip+pc_api.phighmem]
    cmp       %rax,	2
    jnz       L1626
    call      mc_stackmcl.getworkireg
    mov       %r12,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      mc_libmcl.mgenreg
    mov       %r14,	%rax
    mov       %rcx,	%rsi
    call      mc_libmcl.mgenlabelmem
    mov       %rcx,	14
    mov       %rdx,	%r14
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    sub       %rsp,	8
    push      0
    push      0
    push      0
    mov       %rax,	%rdi
    neg       %rax
    shl       %rax,	3
    movzx     %r10,	byte ptr[%r13+10]
    mov       %rcx,	%r12
    mov       %rdx,	%r10
    mov       %r8,	8
    mov       %r9,	%rax
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rcx,	25
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L1625
L1626:
    sub       %rsp,	8
    push      0
    mov       %rax,	%rsi
    push      %rax
    push      0
    mov       %rax,	%rdi
    neg       %rax
    shl       %rax,	3
    movzx     %r10,	byte ptr[%r13+10]
    xor       %ecx,	%ecx
    mov       %rdx,	%r10
    mov       %r8,	8
    mov       %r9,	%rax
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rcx,	25
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L1625:
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	32
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_swlabel
mc_genmcl.px_swlabel:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	[%rdi+8]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %rcx,	119
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_endsw
mc_genmcl.px_endsw:
#?>>
    .set mc_genmcl.px_endsw.p, 16
#?]]
    sub       %rsp,	40
#---------------
    mov       %rcx,	67
    mov       %rdx,	1
    call      mc_libmcl.setsegment
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_genmcl.px_fwiden
mc_genmcl.px_fwiden:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%rbx+28]
    and       %rax,	255
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	8
    call      mc_libmcl.changeopndsize
    mov       %rcx,	89
    mov       %rdx,	%rax
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %al,	2
    lea       %r10,	[%rip+mc_decls.pclmode]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11-1],	%al
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_fnarrow
mc_genmcl.px_fnarrow:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%rbx+28]
    and       %rax,	255
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	4
    call      mc_libmcl.changeopndsize
    mov       %rcx,	88
    mov       %rdx,	%rax
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.pclmode]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11-1],	%al
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_truncate
mc_genmcl.px_truncate:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%rsi+28]
    and       %rax,	255
    mov       %bl,	%al
    movzx     %rax,	%bl
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    mov       %eax,	[%rsi+4]
    movzx     %r10,	%bl
    lea       %r11,	[%rip+pc_tables.psize]
    movzx     %r11,	byte ptr[%r11 + %r10]
    cmp       %rax,	%r11
    jz        L1633
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.psize]
    movzx     %r10,	byte ptr[%r10 + %rax]
    mov       %rcx,	%rdi
    mov       %rdx,	%r10
    call      mc_libmcl.changeopndsize
    movzx     %r10,	%bl
    lea       %r11,	[%rip+mc_decls.ploadop]
    movzx     %r11,	byte ptr[%r11 + %r10]
    mov       %rcx,	%r11
    mov       %rdx,	%rax
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
L1633:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_typepun
mc_genmcl.px_typepun:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%rsi+28]
    and       %rax,	255
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rax
    call      mc_stackmcl.getworkregm
    mov       %rdi,	%rax
    movzx     %rax,	word ptr[%rdi+8]
    and       %rax,	31
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      mc_libmcl.changeopndsize
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    movzx     %r10,	byte ptr[%rdi+10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_stackmcl.setnewzz
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_unload
mc_genmcl.px_unload:
#?>>
    .set mc_genmcl.px_unload.p, 16
#?]]
    sub       %rsp,	40
#---------------
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_genmcl.px_loadbit
mc_genmcl.px_loadbit:
#?>>
    .set mc_genmcl.px_loadbit.p, 48
    .set mc_genmcl.px_loadbit.$T1, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
#---------------
    mov       %rcx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.isimmload
    mov       %rbx,	%rax
    test      %rax,	%rax
    jz        L1638
    mov       %rsi,	[%rbx+8]
    mov       %rax,	%rsi
    cmp       %rax,	0
    jl        L1640
    cmp       %rax,	31
    jg        L1640
    mov       %rax,	5
    jmp       L1639
L1640:
    mov       %rax,	6
L1639:
    mov       %r12,	%rax
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	%r12
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    test      %rsi,	%rsi
    jz        L1642
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    call      mc_libmcl.mgenint
    mov       %rcx,	45
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    cmp       %rsi,	63
    jz        L1645
L1644:
L1642:
    jmp       L1637
L1638:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    mov       %al,	[%rip+pc_decls.r10used]
    test      %al,	%al
    jz        L1647
    mov       %rcx,	11
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	12
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L1647:
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	3
    mov       %r8,	11
    call      mc_stackmcl.loadparam
    mov       %rcx,	45
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %al,	[%rip+pc_decls.r10used]
    test      %al,	%al
    jz        L1649
    mov       %rcx,	11
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	13
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L1649:
L1637:
    mov       %rcx,	1
    mov       %rdx,	5
    call      mc_libmcl.mgenint
    mov       [%rbp + mc_genmcl.px_loadbit.$T1],	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	4
    call      mc_libmcl.changeopndsize
    mov       %rcx,	38
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_genmcl.px_loadbit.$T1]
    call      mc_libmcl.genmc
#mc_genmcl.px_loadbit.skip:
L1645:
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_assem
mc_genmcl.px_assem:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	[%rip+pc_api.idomcl_assem]
    test      %rax,	%rax
    jz        L1652
    mov       %rax,	[%rdi+8]
    mov       %rcx,	%rax
    mov       %r10,	[%rip+pc_api.idomcl_assem]
    call      %r10
    jmp       L1651
L1652:
    lea       %rcx,	[%rip+L8576]
    lea       %rdx,	[%rip+L8577]
    call      pc_api.merror
L1651:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_sin
mc_genmcl.px_sin:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8578]
    mov       %r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_cos
mc_genmcl.px_cos:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8579]
    mov       %r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_tan
mc_genmcl.px_tan:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8580]
    mov       %r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_asin
mc_genmcl.px_asin:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8581]
    mov       %r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_acos
mc_genmcl.px_acos:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8582]
    mov       %r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_atan
mc_genmcl.px_atan:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8583]
    mov       %r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_log
mc_genmcl.px_log:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8584]
    mov       %r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_log10
mc_genmcl.px_log10:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8585]
    mov       %r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_exp
mc_genmcl.px_exp:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8586]
    mov       %r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_round
mc_genmcl.px_round:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8587]
    mov       %r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_floor
mc_genmcl.px_floor:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8588]
    mov       %r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_ceil
mc_genmcl.px_ceil:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8589]
    mov       %r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_atan2
mc_genmcl.px_atan2:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8590]
    mov       %r8,	2
    call      mc_auxmcl.do_maths
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_fmod
mc_genmcl.px_fmod:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8591]
    mov       %r8,	2
    call      mc_auxmcl.do_maths
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_setcc
mc_genmcl.px_setcc:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rsi,	%rax
    movzx     %rax,	byte ptr[%r13+2]
    lea       %r10,	[%rip+mc_genmcl.ucondcodes]
    movzx     %r10,	byte ptr[%r10 + %rax-1]
    mov       %rdi,	%r10
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	11
    jnz       L1669
    lea       %rcx,	[%rip+L8592]
    lea       %rdx,	[%rip+L8593]
    call      pc_api.merror
    jmp       L1668
L1669:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jle       L1670
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.psigned]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1672
    movzx     %rax,	byte ptr[%r13+2]
    lea       %r10,	[%rip+mc_genmcl.scondcodes]
    movzx     %r10,	byte ptr[%r10 + %rax-1]
    mov       %rdi,	%r10
L1672:
    mov       %rcx,	42
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      mc_libmcl.changeopndsize
    mov       %r12,	%rax
    jmp       L1668
L1670:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    dec       %rax
    mov       %r10,	73
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
    mov       %rcx,	3
    call      mc_stackmcl.getworkregm
    mov       %r12,	%rax
    movzx     %rax,	byte ptr[%r12+10]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_stackmcl.setnewzz
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
L1668:
    mov       %rcx,	58
    mov       %rdx,	%rdi
    mov       %r8,	%r12
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    mov       %rcx,	%r12
    mov       %rdx,	4
    call      mc_libmcl.changeopndsize
    mov       %rcx,	19
    mov       %rdx,	%rax
    mov       %r8,	%r12
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_min
mc_genmcl.px_min:
#?>>
    .set mc_genmcl.px_min.p, 16
#?]]
    sub       %rsp,	40
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jle       L1675
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.psigned]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1677
    mov       %rax,	15
    jmp       L1676
L1677:
    mov       %rax,	7
L1676:
    mov       %rcx,	%rax
    call      mc_auxmcl.do_max_int
    jmp       L1674
L1675:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    dec       %rax
    mov       %r10,	112
    add       %r10,	%rax
    mov       %rcx,	%r10
    call      mc_auxmcl.do_max_float
L1674:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_genmcl.px_max
mc_genmcl.px_max:
#?>>
    .set mc_genmcl.px_max.p, 16
#?]]
    sub       %rsp,	40
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jle       L1680
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.psigned]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1682
    mov       %rax,	12
    jmp       L1681
L1682:
    mov       %rax,	2
L1681:
    mov       %rcx,	%rax
    call      mc_auxmcl.do_max_int
    jmp       L1679
L1680:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    dec       %rax
    mov       %r10,	113
    add       %r10,	%rax
    mov       %rcx,	%r10
    call      mc_auxmcl.do_max_float
L1679:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_genmcl.px_power
mc_genmcl.px_power:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jle       L1685
    mov       %rcx,	82
    call      mc_auxmcl.gethostfn
    mov       %rdi,	%rax
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    mov       %rcx,	%rbx
    mov       %rdx,	%rdi
    mov       %r8,	2
    call      mc_auxmcl.do_host
    jmp       L1684
L1685:
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    mov       %rcx,	%rbx
    lea       %rdx,	[%rip+L8594]
    mov       %r8,	2
    call      mc_auxmcl.do_maths
L1684:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_minto
mc_genmcl.px_minto:
#?>>
    .set mc_genmcl.px_minto.p, 16
    .set mc_genmcl.px_minto.$T1, -8
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jle       L1688
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       [%rbp + mc_genmcl.px_minto.$T1],	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.psigned]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1690
    mov       %rax,	14
    jmp       L1689
L1690:
    mov       %rax,	6
L1689:
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_genmcl.px_minto.$T1]
    call      mc_auxmcl.do_maxto_int
    jmp       L1687
L1688:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	6
    mov       %rdx,	%rax
    call      mc_auxmcl.do_maxto_real
L1687:
#---------------
    add       %rsp,	48
    pop       %rbp
    ret       
# End 
# Proc mc_genmcl.px_maxto
mc_genmcl.px_maxto:
#?>>
    .set mc_genmcl.px_maxto.p, 16
    .set mc_genmcl.px_maxto.$T1, -8
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jle       L1693
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       [%rbp + mc_genmcl.px_maxto.$T1],	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.psigned]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1695
    mov       %rax,	13
    jmp       L1694
L1695:
    mov       %rax,	3
L1694:
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_genmcl.px_maxto.$T1]
    call      mc_auxmcl.do_maxto_int
    jmp       L1692
L1693:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	3
    mov       %rdx,	%rax
    call      mc_auxmcl.do_maxto_real
L1692:
#---------------
    add       %rsp,	48
    pop       %rbp
    ret       
# End 
# Proc mc_genmcl.px_negto
mc_genmcl.px_negto:
#?>>
    .set mc_genmcl.px_negto.p, 32
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jle       L1698
    mov       %rcx,	50
    mov       %rdx,	%rdi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L1697
L1698:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rax
    call      mc_stackmcl.getworkregm
    mov       %rbx,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      mc_auxmcl.do_negreal
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L1697:
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_absto
mc_genmcl.px_absto:
#?>>
    .set mc_genmcl.px_absto.p, 40
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rax
    call      mc_stackmcl.getworkregm
    mov       %rbx,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jle       L1701
    xor       %ecx,	%ecx
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	42
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rax,	[%rip+pc_api.mlabelno]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %r10,	%rax
    mov       %rsi,	%r10
    mov       %rcx,	26
    mov       %rdx,	13
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    mov       %rcx,	50
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	9
    mov       %rdx,	%rsi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L1700
L1701:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      mc_auxmcl.do_absreal
L1700:
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_addpxto
mc_genmcl.px_addpxto:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    call      mc_stackmcl.isimmload
    mov       %rsi,	%rax
    test      %rax,	%rax
    jz        L1704
    mov       %rax,	[%rsi+8]
    movsxd    %r10,	dword ptr[%r12+16]
    imul      %rax,	%r10
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	28
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L1703
L1704:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%r12+16]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      mc_auxmcl.mulimm
    mov       %rcx,	28
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L1703:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_subpxto
mc_genmcl.px_subpxto:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    call      mc_stackmcl.isimmload
    mov       %rsi,	%rax
    test      %rax,	%rax
    jz        L1707
    mov       %rax,	[%rsi+8]
    movsxd    %r10,	dword ptr[%r12+16]
    imul      %rax,	%r10
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	29
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L1706
L1707:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%r12+16]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      mc_auxmcl.mulimm
    mov       %rcx,	29
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    mov       %eax,	[%r12+20]
    test      %eax,	%eax
    jz        L1709
    lea       %rcx,	[%rip+L8595]
    lea       %rdx,	[%rip+L8596]
    call      pc_api.merror
L1709:
L1706:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_divto
mc_genmcl.px_divto:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	71
    call      mc_auxmcl.do_binto_float
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_bitnotto
mc_genmcl.px_bitnotto:
#?>>
    .set mc_genmcl.px_bitnotto.p, 24
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    mov       %rcx,	51
    mov       %rdx,	%rdi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_notto
mc_genmcl.px_notto:
#?>>
    .set mc_genmcl.px_notto.p, 24
    .set mc_genmcl.px_notto.$T1, -8
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
#---------------
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	3
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    mov       %rcx,	1
    mov       %rdx,	3
    call      mc_libmcl.mgenint
    mov       [%rbp + mc_genmcl.px_notto.$T1],	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      mc_libmcl.changeopndsize
    mov       %rcx,	40
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_genmcl.px_notto.$T1]
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_toboolto
mc_genmcl.px_toboolto:
#?>>
    .set mc_genmcl.px_toboolto.p, 40
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	3
    call      mc_stackmcl.getopnd_ind
    mov       %rsi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rax
    call      mc_stackmcl.getworkregm
    mov       %rdi,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
    mov       %rcx,	41
    mov       %rdx,	%rdi
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      mc_libmcl.changeopndsize
    mov       %r10,	%rax
    mov       %rbx,	%r10
    mov       %rcx,	58
    mov       %rdx,	5
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    mov       %rcx,	%rdi
    mov       %rdx,	4
    call      mc_libmcl.changeopndsize
    mov       %rcx,	19
    mov       %rdx,	%rax
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    mov       %rcx,	11
    mov       %rdx,	%rsi
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_sign
mc_genmcl.px_sign:
#?>>
    .set mc_genmcl.px_sign.p, 64
    .set mc_genmcl.px_sign.ltop, -8
    .set mc_genmcl.px_sign.$T1, -16
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    mov       %rcx,	10
    call      mc_stackmcl.getworkregm
    mov       %rbx,	%rax
    mov       %rcx,	%rbx
    call      mc_libmcl.clearreg
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jg        L1716
    mov       %r14b,	7
    mov       %al,	2
    mov       [%rbp + mc_genmcl.px_sign.ltop],	%al
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    movq      %XMM0,	[%rip+L8597]
    mov       %rdx,	%rax
    call      mc_libmcl.mgenrealmem
    movzx     %r10,	byte ptr[%rip+mc_decls.pmode]
    dec       %r10
    mov       %r11,	73
    add       %r11,	%r10
    mov       %rcx,	%r11
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L1715
L1716:
    mov       %r14b,	15
    mov       %al,	12
    mov       [%rbp + mc_genmcl.px_sign.ltop],	%al
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    xor       %ecx,	%ecx
    mov       %rdx,	%rax
    call      mc_libmcl.mgenint
    mov       %rcx,	42
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L1715:
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rax,	[%rip+pc_api.mlabelno]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %r10,	%rax
    mov       %rsi,	%r10
    movzx     %r10,	%r14b
    mov       %rcx,	26
    mov       %rdx,	%r10
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rax,	[%rip+pc_api.mlabelno]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %r10,	%rax
    mov       %r12,	%r10
    movzx     %r10,	byte ptr[%rbp + mc_genmcl.px_sign.ltop]
    mov       %rcx,	26
    mov       %rdx,	%r10
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rax,	[%rip+pc_api.mlabelno]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %r10,	%rax
    mov       %r13,	%r10
    mov       %rcx,	25
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	9
    mov       %rdx,	%rsi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	1
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       [%rbp + mc_genmcl.px_sign.$T1],	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      mc_libmcl.changeopndsize
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_genmcl.px_sign.$T1]
    call      mc_libmcl.genmc
    mov       %rcx,	25
    mov       %rdx,	%r13
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	9
    mov       %rdx,	%r12
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	53
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	9
    mov       %rdx,	%r13
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rbx+10]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_stackmcl.setnewzz
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_loadbf
mc_genmcl.px_loadbf:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    call      mc_stackmcl.isimmload
    mov       %rdi,	%rax
    mov       %rcx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.isimmload
    mov       %rbx,	%rax
    test      %rdi,	%rdi
    jz        L1719
    test      %rbx,	%rbx
    jz        L1719
    mov       %rax,	[%rbx+8]
    mov       %r10,	[%rdi+8]
    mov       %rcx,	%rsi
    mov       %rdx,	%r10
    mov       %r8,	%rax
    call      mc_auxmcl.do_loadbf_const
    jmp       L1718
L1719:
    mov       %rcx,	%rsi
    call      mc_auxmcl.do_loadbf_var
L1718:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_storebit
mc_genmcl.px_storebit:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      mc_auxmcl.do_storebit
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_storebf
mc_genmcl.px_storebf:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      mc_auxmcl.do_storebf
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_loadall
mc_genmcl.px_loadall:
#?>>
    .set mc_genmcl.px_loadall.p, 16
#?]]
    sub       %rsp,	40
#---------------
    call      mc_stackmcl.checkallloaded
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_genmcl.px_setjmp
mc_genmcl.px_setjmp:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
    call      mc_libmcl.mcreatefwdlabel
    mov       %rsi,	%rax
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	6
    call      mc_stackmcl.getopnd_ind
    mov       %rbx,	%rax
    mov       %rcx,	6
    xor       %edx,	%edx
    call      mc_stackmcl.pushpcl_reg
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rdi,	%rax
    mov       %rcx,	%rsi
    call      mc_libmcl.mgenlabel
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rcx,	%rbx
    mov       %rdx,	8
    xor       %r8d,	%r8d
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	[%rip+mc_decls.dstackopnd]
    call      mc_libmcl.genmc
    mov       %rcx,	%rbx
    mov       %rdx,	16
    xor       %r8d,	%r8d
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	[%rip+mc_decls.dframeopnd]
    call      mc_libmcl.genmc
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    call      mc_stackmcl.poppcl
    mov       %rcx,	%rdi
    call      mc_libmcl.clearreg
    mov       %rcx,	%r12
    call      mc_stackmcl.freeworkregs
    mov       %rcx,	1
    call      mc_stackmcl.movetoreg
    mov       %rcx,	%rsi
    call      mc_libmcl.mdefinefwdlabel
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_longjmp
mc_genmcl.px_longjmp:
#?>>
    .set mc_genmcl.px_longjmp.p, 40
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	6
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	8
    xor       %r8d,	%r8d
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	[%rip+mc_decls.dstackopnd]
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	%rdi
    mov       %rdx,	16
    xor       %r8d,	%r8d
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	[%rip+mc_decls.dframeopnd]
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	6
    xor       %edx,	%edx
    call      mc_stackmcl.pushpcl_reg
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rsi,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rsi
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rax,	[%rip+mc_decls.noperands]
    sub       %rax,	2
    mov       %rcx,	%rax
    mov       %rdx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    call      mc_stackmcl.poppcl
    mov       %rcx,	1
    call      mc_stackmcl.swapopndregs
    mov       %rcx,	25
    mov       %rdx,	%rsi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_initdswx
mc_genmcl.px_initdswx:
#?>>
    .set mc_genmcl.px_initdswx.p, 16
#?]]
#---------------
#---
#---------------
    ret       
# End 
# Proc mc_auxmcl.allocregvars
mc_auxmcl.allocregvars:
#?>>
    .set mc_auxmcl.allocregvars.params, -32
    .set mc_auxmcl.allocregvars.xparams, -64
    .set mc_auxmcl.allocregvars.leafparams, -96
    .set mc_auxmcl.allocregvars.xleafparams, -128
    .set mc_auxmcl.allocregvars.leafparamno, -136
    .set mc_auxmcl.allocregvars.xleafparamno, -144
    .set mc_auxmcl.allocregvars.locals, -400
    .set mc_auxmcl.allocregvars.xlocals, -656
    .set mc_auxmcl.allocregvars.reg, -664
    .set mc_auxmcl.allocregvars.nl, -672
    .set mc_auxmcl.allocregvars.np, -680
    .set mc_auxmcl.allocregvars.nlx, -688
    .set mc_auxmcl.allocregvars.npx, -696
    .set mc_auxmcl.allocregvars.d, -704
    .set mc_auxmcl.allocregvars.i, -712
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	712
#---------------
    xor       %rdi,	%rdi
    xor       %eax,	%eax
    mov       %rbx,	%rax
    xor       %rsi,	%rsi
    xor       %eax,	%eax
    mov       %r12,	%rax
    xor       %r13,	%r13
    xor       %eax,	%eax
    mov       %r14,	%rax
    mov       %rax,	[%rip+mc_decls.maxregvars]
    add       %rax,	[%rip+mc_decls.maxxregvars]
    test      %rax,	%rax
    jz        L1726
L1728:
    test      %rcx,	%rcx
    jnz       L1730
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %rax,	[%rax+16]
    mov       [%rbp + mc_auxmcl.allocregvars.d],	%rax
    xor       %r15,	%r15
    jmp       L1734
L1731:
    inc       %r15
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       %al,	[%rax+92]
    test      %al,	%al
    jz        L1736
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       %al,	[%rax+91]
    test      %al,	%al
    jnz       L1736
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       %al,	[%rax+88]
    test      %al,	%al
    jnz       L1736
    cmp       %r15,	4
    jg        L1736
    test      %rdx,	%rdx
    jnz       L1738
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    movzx     %rax,	byte ptr[%rax+82]
    lea       %r10,	[%rip+pc_tables.pint]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1740
    cmp       %rdi,	4
    jge       L1742
    inc       %rdi
    mov       %rax,	%rdi
    mov       %r10,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       [%rbp + %rax*8 + mc_auxmcl.allocregvars.params-8],	%r10
L1742:
    jmp       L1739
L1740:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    movzx     %rax,	byte ptr[%rax+82]
    lea       %r10,	[%rip+pc_tables.pfloat]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1743
    cmp       %rbx,	4
    jge       L1745
    inc       %rbx
    mov       %rax,	%rbx
    mov       %r10,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       [%rbp + %rax*8 + mc_auxmcl.allocregvars.xparams-8],	%r10
L1745:
L1743:
L1739:
    jmp       L1737
L1738:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    movzx     %rax,	byte ptr[%rax+82]
    lea       %r10,	[%rip+pc_tables.pint]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1747
    cmp       %rsi,	4
    jge       L1749
    inc       %rsi
    mov       %rax,	%rsi
    mov       %r10,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       [%rbp + %rax*8 + mc_auxmcl.allocregvars.leafparams-8],	%r10
    mov       [%rbp + %rsi + mc_auxmcl.allocregvars.leafparamno-1],	%r15b
L1749:
    jmp       L1746
L1747:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    movzx     %rax,	byte ptr[%rax+82]
    lea       %r10,	[%rip+pc_tables.pfloat]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1750
    cmp       %r12,	4
    jge       L1752
    inc       %r12
    mov       %rax,	%r12
    mov       %r10,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       [%rbp + %rax*8 + mc_auxmcl.allocregvars.xleafparams-8],	%r10
    mov       [%rbp + %r12 + mc_auxmcl.allocregvars.xleafparamno-1],	%r15b
L1752:
L1750:
L1746:
L1737:
L1736:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       %rax,	[%rax+16]
    mov       [%rbp + mc_auxmcl.allocregvars.d],	%rax
L1734:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    test      %rax,	%rax
    jnz       L1731
L1730:
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %rax,	[%rax+24]
    mov       [%rbp + mc_auxmcl.allocregvars.d],	%rax
    jmp       L1756
L1753:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       %al,	[%rax+92]
    test      %al,	%al
    jz        L1758
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       %al,	[%rax+91]
    test      %al,	%al
    jnz       L1758
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       %al,	[%rax+88]
    test      %al,	%al
    jnz       L1758
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    movzx     %rax,	byte ptr[%rax+82]
    lea       %r10,	[%rip+pc_tables.pint]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1760
    cmp       %r13,	32
    jge       L1762
    inc       %r13
    mov       %rax,	%r13
    mov       %r10,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       [%rbp + %rax*8 + mc_auxmcl.allocregvars.locals-8],	%r10
L1762:
    jmp       L1759
L1760:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    movzx     %rax,	byte ptr[%rax+82]
    lea       %r10,	[%rip+pc_tables.pfloat]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1763
    cmp       %r14,	32
    jge       L1763
    inc       %r14
    mov       %rax,	%r14
    mov       %r10,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       [%rbp + %rax*8 + mc_auxmcl.allocregvars.xlocals-8],	%r10
L1763:
L1759:
L1758:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       %rax,	[%rax+24]
    mov       [%rbp + mc_auxmcl.allocregvars.d],	%rax
L1756:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    test      %rax,	%rax
    jnz       L1753
    test      %r13,	%r13
    jnz       L1765
    mov       %rax,	[%rip+mc_decls.maxregvars]
    mov       %r10,	%rdi
    cmp       %rax,	%r10
    cmovg     %rax,	%r10
    mov       [%rbp + mc_auxmcl.allocregvars.np],	%rax
    xor       %eax,	%eax
    mov       [%rbp + mc_auxmcl.allocregvars.nl],	%rax
    jmp       L1764
L1765:
    test      %rdi,	%rdi
    jnz       L1766
    mov       %rax,	[%rip+mc_decls.maxregvars]
    mov       %r10,	%r13
    cmp       %rax,	%r10
    cmovg     %rax,	%r10
    mov       [%rbp + mc_auxmcl.allocregvars.nl],	%rax
    xor       %eax,	%eax
    mov       [%rbp + mc_auxmcl.allocregvars.np],	%rax
    jmp       L1764
L1766:
    mov       [%rbp + mc_auxmcl.allocregvars.nl],	%r13
    mov       [%rbp + mc_auxmcl.allocregvars.np],	%rdi
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.np]
    add       %rax,	[%rbp + mc_auxmcl.allocregvars.nl]
    sub       %rax,	[%rip+mc_decls.maxregvars]
    mov       %r15,	%rax
    cmp       %r15,	0
    jle       L1768
    dec       qword ptr[%rbp + mc_auxmcl.allocregvars.np]
    dec       %r15
    cmp       %r15,	0
    jle       L1770
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.np]
    cmp       %rax,	0
    jle       L1770
    dec       qword ptr[%rbp + mc_auxmcl.allocregvars.np]
    dec       %r15
L1770:
    cmp       %r15,	0
    jle       L1772
    mov       %rax,	%r15
    sub       [%rbp + mc_auxmcl.allocregvars.nl],	%rax
L1772:
L1768:
L1764:
    mov       %rax,	4
    mov       [%rbp + mc_auxmcl.allocregvars.reg],	%rax
    mov       %rax,	1
    mov       [%rbp + mc_auxmcl.allocregvars.i],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.nl]
    cmp       %rax,	1
    jl        L1775
L1773:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.i]
    mov       %rax,	[%rbp + %rax*8 + mc_auxmcl.allocregvars.locals-8]
    mov       [%rbp + mc_auxmcl.allocregvars.d],	%rax
    mov       %al,	[%rbp + mc_auxmcl.allocregvars.reg]
    mov       %r10,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       [%r10+90],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.isregvar]
    mov       %r11,	[%rbp + mc_auxmcl.allocregvars.reg]
    mov       [%r10 + %r11-1],	%al
    inc       qword ptr[%rbp + mc_auxmcl.allocregvars.reg]
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.i]
    inc       %rax
    mov       [%rbp + mc_auxmcl.allocregvars.i],	%rax
    cmp       %rax,	[%rbp + mc_auxmcl.allocregvars.nl]
    jle       L1773
L1775:
    mov       %rax,	1
    mov       [%rbp + mc_auxmcl.allocregvars.i],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.np]
    cmp       %rax,	1
    jl        L1778
L1776:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.i]
    mov       %rax,	[%rbp + %rax*8 + mc_auxmcl.allocregvars.params-8]
    mov       [%rbp + mc_auxmcl.allocregvars.d],	%rax
    mov       %al,	[%rbp + mc_auxmcl.allocregvars.reg]
    mov       %r10,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       [%r10+90],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.isregvar]
    mov       %r11,	[%rbp + mc_auxmcl.allocregvars.reg]
    mov       [%r10 + %r11-1],	%al
    inc       qword ptr[%rbp + mc_auxmcl.allocregvars.reg]
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.i]
    inc       %rax
    mov       [%rbp + mc_auxmcl.allocregvars.i],	%rax
    cmp       %rax,	[%rbp + mc_auxmcl.allocregvars.np]
    jle       L1776
L1778:
    mov       %rax,	1
    mov       [%rbp + mc_auxmcl.allocregvars.i],	%rax
    cmp       %rsi,	1
    jl        L1781
L1779:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.i]
    mov       %rax,	[%rbp + %rax*8 + mc_auxmcl.allocregvars.leafparams-8]
    mov       [%rbp + mc_auxmcl.allocregvars.d],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.i]
    movzx     %rax,	byte ptr[%rbp + %rax + mc_auxmcl.allocregvars.leafparamno-1]
    add       %rax,	11
    dec       %rax
    mov       [%rbp + mc_auxmcl.allocregvars.reg],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.reg]
    cmp       %rax,	11
    jnz       L1783
    mov       %al,	1
    mov       [%rip+pc_decls.r10used],	%al
L1783:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.reg]
    cmp       %rax,	12
    jnz       L1785
    mov       %al,	1
    mov       [%rip+pc_decls.r11used],	%al
L1785:
    mov       %al,	[%rbp + mc_auxmcl.allocregvars.reg]
    mov       %r10,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       [%r10+90],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.isregvar]
    mov       %r11,	[%rbp + mc_auxmcl.allocregvars.reg]
    mov       [%r10 + %r11-1],	%al
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.i]
    inc       %rax
    mov       [%rbp + mc_auxmcl.allocregvars.i],	%rax
    cmp       %rax,	%rsi
    jle       L1779
L1781:
    test      %r14,	%r14
    jnz       L1787
    mov       %rax,	[%rip+mc_decls.maxxregvars]
    mov       %r10,	%rbx
    cmp       %rax,	%r10
    cmovg     %rax,	%r10
    mov       [%rbp + mc_auxmcl.allocregvars.npx],	%rax
    xor       %eax,	%eax
    mov       [%rbp + mc_auxmcl.allocregvars.nlx],	%rax
    jmp       L1786
L1787:
    test      %rbx,	%rbx
    jnz       L1788
    mov       %rax,	[%rip+mc_decls.maxxregvars]
    mov       %r10,	%r14
    cmp       %rax,	%r10
    cmovg     %rax,	%r10
    mov       [%rbp + mc_auxmcl.allocregvars.nlx],	%rax
    xor       %eax,	%eax
    mov       [%rbp + mc_auxmcl.allocregvars.npx],	%rax
    jmp       L1786
L1788:
    mov       [%rbp + mc_auxmcl.allocregvars.nlx],	%r14
    mov       [%rbp + mc_auxmcl.allocregvars.npx],	%rbx
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.npx]
    add       %rax,	[%rbp + mc_auxmcl.allocregvars.nlx]
    sub       %rax,	[%rip+mc_decls.maxregvars]
    mov       %r15,	%rax
    cmp       %r15,	0
    jle       L1790
    dec       qword ptr[%rbp + mc_auxmcl.allocregvars.npx]
    dec       %r15
    cmp       %r15,	0
    jle       L1792
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.npx]
    cmp       %rax,	0
    jle       L1792
    dec       qword ptr[%rbp + mc_auxmcl.allocregvars.npx]
    dec       %r15
L1792:
    cmp       %r15,	0
    jle       L1794
    mov       %rax,	%r15
    sub       [%rbp + mc_auxmcl.allocregvars.nlx],	%rax
L1794:
L1790:
L1786:
    mov       %rax,	16
    mov       [%rbp + mc_auxmcl.allocregvars.reg],	%rax
    mov       %rax,	1
    mov       [%rbp + mc_auxmcl.allocregvars.i],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.nlx]
    cmp       %rax,	1
    jl        L1797
L1795:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.i]
    mov       %rax,	[%rbp + %rax*8 + mc_auxmcl.allocregvars.xlocals-8]
    mov       [%rbp + mc_auxmcl.allocregvars.d],	%rax
    mov       %al,	[%rbp + mc_auxmcl.allocregvars.reg]
    mov       %r10,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       [%r10+90],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.isxregvar]
    mov       %r11,	[%rbp + mc_auxmcl.allocregvars.reg]
    mov       [%r10 + %r11-1],	%al
    dec       qword ptr[%rbp + mc_auxmcl.allocregvars.reg]
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.i]
    inc       %rax
    mov       [%rbp + mc_auxmcl.allocregvars.i],	%rax
    cmp       %rax,	[%rbp + mc_auxmcl.allocregvars.nlx]
    jle       L1795
L1797:
    mov       %rax,	1
    mov       [%rbp + mc_auxmcl.allocregvars.i],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.npx]
    cmp       %rax,	1
    jl        L1800
L1798:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.i]
    mov       %rax,	[%rbp + %rax*8 + mc_auxmcl.allocregvars.xparams-8]
    mov       [%rbp + mc_auxmcl.allocregvars.d],	%rax
    mov       %al,	[%rbp + mc_auxmcl.allocregvars.reg]
    mov       %r10,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       [%r10+90],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.isxregvar]
    mov       %r11,	[%rbp + mc_auxmcl.allocregvars.reg]
    mov       [%r10 + %r11-1],	%al
    dec       qword ptr[%rbp + mc_auxmcl.allocregvars.reg]
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.i]
    inc       %rax
    mov       [%rbp + mc_auxmcl.allocregvars.i],	%rax
    cmp       %rax,	[%rbp + mc_auxmcl.allocregvars.npx]
    jle       L1798
L1800:
    mov       %rax,	1
    mov       [%rbp + mc_auxmcl.allocregvars.i],	%rax
    cmp       %r12,	1
    jl        L1803
L1801:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.i]
    mov       %rax,	[%rbp + %rax*8 + mc_auxmcl.allocregvars.xleafparams-8]
    mov       [%rbp + mc_auxmcl.allocregvars.d],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.i]
    movzx     %rax,	byte ptr[%rbp + %rax + mc_auxmcl.allocregvars.xleafparamno-1]
    inc       %rax
    dec       %rax
    mov       [%rbp + mc_auxmcl.allocregvars.reg],	%rax
    mov       %al,	[%rbp + mc_auxmcl.allocregvars.reg]
    mov       %r10,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       [%r10+90],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.isxregvar]
    mov       %r11,	[%rbp + mc_auxmcl.allocregvars.reg]
    mov       [%r10 + %r11-1],	%al
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.i]
    inc       %rax
    mov       [%rbp + mc_auxmcl.allocregvars.i],	%rax
    cmp       %rax,	%r12
    jle       L1801
L1803:
L1726:
#---------------
    add       %rsp,	712
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.initproc
mc_auxmcl.initproc:
#?>>
    .set mc_auxmcl.initproc.$T1, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %r15,	%rcx
#---------------
    lea       %rax,	[%rip+mc_decls.regset]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    lea       %rax,	[%rip+mc_decls.xregset]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    lea       %rax,	[%rip+mc_decls.workregs]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    lea       %rax,	[%rip+mc_decls.workxregs]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    lea       %rax,	[%rip+mc_decls.isregvar]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    lea       %rax,	[%rip+mc_decls.isxregvar]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    mov       %rax,	3
    mov       [%rip+mc_decls.nworkregs],	%rax
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.workregs]
    mov       [%r10],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.workregs]
    mov       [%r10+1],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.workregs]
    mov       [%r10+2],	%al
    mov       %rax,	2
    mov       [%rip+mc_decls.nworkxregs],	%rax
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.workxregs]
    mov       [%r10+4],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.workxregs]
    mov       [%r10+5],	%al
    xor       %eax,	%eax
    mov       [%rip+mc_decls.maxxregvars],	%rax
    mov       [%rip+mc_decls.maxregvars],	%rax
    xor       %r12,	%r12
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %rax,	[%rax+48]
    mov       [%rip+pc_decls.pinfo],	%rax
    mov       %rax,	[%rip+pc_decls.pinfo]
    test      %rax,	%rax
    jnz       L1806
    mov       %rax,	10
    mov       [%rip+mc_decls.nworkregs],	%rax
    mov       %rax,	12
    mov       [%rip+mc_decls.nworkxregs],	%rax
    mov       %rsi,	4
L1807:
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.workregs]
    mov       %r11,	%rsi
    mov       [%r10 + %r11-1],	%al
    inc       %rsi
    cmp       %rsi,	10
    jle       L1807
    mov       %rsi,	7
L1810:
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.workxregs]
    mov       %r11,	%rsi
    mov       [%r10 + %r11-1],	%al
    inc       %rsi
    cmp       %rsi,	16
    jle       L1810
    jmp       L1805
L1806:
    mov       %rax,	[%rip+pc_decls.currfunc]
    movzx     %rax,	byte ptr[%rax+112]
    mov       %r10,	[%rip+pc_decls.pinfo]
    movzx     %r10,	byte ptr[%r10+4]
    cmp       %rax,	%r10
    cmovl     %rax,	%r10
    mov       %r10,	4
    cmp       %r10,	%rax
    cmovg     %r10,	%rax
    mov       %r12,	%r10
    mov       %rax,	4
    mov       [%rip+mc_decls.nworkregs],	%rax
    mov       %rax,	[%rip+pc_decls.pinfo]
    mov       %al,	[%rax+7]
    test      %al,	%al
    jz        L1814
    inc       qword ptr[%rip+mc_decls.nworkregs]
L1814:
    mov       %rax,	5
    mov       [%rip+mc_decls.nworkxregs],	%rax
    mov       %rax,	[%rip+mc_decls.nworkregs]
    sub       %rax,	3
    mov       %rbx,	%rax
    cmp       %r12,	3
    jg        L1816
    test      %rbx,	%rbx
    jz        L1816
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.workregs]
    mov       [%r10+13],	%al
    dec       %rbx
    cmp       %r12,	2
    jg        L1818
    test      %rbx,	%rbx
    jz        L1818
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.workregs]
    mov       [%r10+12],	%al
    dec       %rbx
L1818:
L1816:
    mov       %rsi,	10
    mov       %r13,	%rbx
    cmp       %r13,	0
    jle       L1821
L1819:
    mov       %rax,	%rsi
    dec       %rsi
    mov       %r10b,	1
    lea       %r11,	[%rip+mc_decls.workregs]
    mov       [%r11 + %rax-1],	%r10b
    dec       %r13
    jnz       L1819
L1821:
    mov       %rsi,	7
    mov       %rax,	[%rip+mc_decls.nworkxregs]
    sub       %rax,	2
    mov       %r14,	%rax
    cmp       %r14,	0
    jle       L1824
L1822:
    mov       %rax,	%rsi
    inc       %rsi
    mov       %r10b,	1
    lea       %r11,	[%rip+mc_decls.workxregs]
    mov       [%r11 + %rax-1],	%r10b
    dec       %r14
    jnz       L1822
L1824:
L1805:
    mov       %rsi,	4
L1825:
    lea       %rax,	[%rip+mc_decls.workregs]
    mov       %r10,	%rsi
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jnz       L1829
    inc       qword ptr[%rip+mc_decls.maxregvars]
L1829:
    inc       %rsi
    cmp       %rsi,	10
    jle       L1825
    mov       %rsi,	7
L1830:
    lea       %rax,	[%rip+mc_decls.workxregs]
    mov       %r10,	%rsi
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jnz       L1834
    inc       qword ptr[%rip+mc_decls.maxxregvars]
L1834:
    inc       %rsi
    cmp       %rsi,	16
    jle       L1830
    lea       %rax,	[%rip+mc_decls.usedregs]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    lea       %rax,	[%rip+mc_decls.usedxregs]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    lea       %rax,	[%rip+mc_decls.pcltempflags]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    mov       [%rax+16],	%r10
    mov       [%rax+24],	%r10
    mov       [%rax+32],	%r10
    mov       [%rax+40],	%r10
    mov       [%rax+48],	%r10w
    xor       %eax,	%eax
    mov       [%rip+pc_decls.r11used],	%al
    mov       [%rip+pc_decls.r10used],	%al
    xor       %eax,	%eax
    mov       [%rip+mc_decls.mstackdepth],	%rax
    xor       %eax,	%eax
    mov       [%rip+mc_decls.noperands],	%rax
    xor       %eax,	%eax
    mov       [%rip+mc_genmcl.framebytes],	%rax
    mov       [%rip+mc_genmcl.paramoffset],	%rax
    mov       [%rip+mc_genmcl.frameoffset],	%rax
    xor       %eax,	%eax
    mov       [%rip+pc_decls.localshadow],	%al
    xor       %eax,	%eax
    mov       [%rip+mc_decls.nblocktemps],	%rax
    movzx     %rax,	byte ptr[%r15+82]
    cmp       %rax,	11
    jnz       L1836
    lea       %rcx,	[%rip+L8598]
    mov       %rdx,	8
    call      pc_api.pc_makesymbol
    mov       %rdi,	%rax
    mov       %al,	[%r15+82]
    mov       [%rdi+82],	%al
    mov       %al,	1
    mov       [%rdi+92],	%al
    mov       %al,	5
    mov       [%rdi+72],	%al
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %rax,	[%rax+16]
    mov       [%rdi+16],	%rax
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       [%rdi+32],	%rax
    mov       %rax,	%rdi
    mov       %r10,	[%rip+pc_decls.currfunc]
    mov       [%r10+16],	%rax
    mov       [%rip+pc_decls.blockretname],	%rdi
L1836:
    mov       %al,	[%rip+pc_decls.fregoptim]
    test      %al,	%al
    jz        L1839
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %rax,	[%rax+48]
    test      %rax,	%rax
    jnz       L1838
L1839:
    jmp       L1804
L1838:
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %rax,	[%rax+48]
    mov       %al,	[%rax+5]
    test      %al,	%al
    jnz       L1804
L1841:
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %rax,	[%rax+48]
    movzx     %rax,	byte ptr[%rax+3]
    mov       [%rbp + mc_auxmcl.initproc.$T1],	%rax
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %al,	[%rax+110]
    test      %al,	%al
    jnz       L1842
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %al,	[%rax+113]
    test      %al,	%al
    jz        L1843
L1842:
    mov       %rax,	1
    jmp       L1844
L1843:
    xor       %eax,	%eax
L1844:
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_auxmcl.initproc.$T1]
    call      mc_auxmcl.allocregvars
L1804:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_procentry
mc_auxmcl.do_procentry:
#?>>
    .set mc_auxmcl.do_procentry.p, 72
    .set mc_auxmcl.do_procentry.ff, -8
    .set mc_auxmcl.do_procentry.r, -16
    .set mc_auxmcl.do_procentry.i, -24
    .set mc_auxmcl.do_procentry.$T1, -32
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	72
#---------------
    mov       %rcx,	[%rip+mc_decls.mclprocentry]
    call      mc_auxmcl.setmclentry
    xor       %eax,	%eax
    mov       [%rip+pc_decls.bxspill],	%rax
    mov       [%rip+pc_decls.bspill],	%rax
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %rax,	[%rax+48]
    test      %rax,	%rax
    jz        L1848
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %rax,	[%rax+48]
    mov       %al,	[%rax+5]
    test      %al,	%al
    jnz       L1847
L1848:
    mov       %rax,	4
    mov       [%rbp + mc_auxmcl.do_procentry.r],	%rax
L1849:
    lea       %rax,	[%rip+mc_decls.usedregs]
    mov       %r10,	[%rbp + mc_auxmcl.do_procentry.r]
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jnz       L1854
    lea       %rax,	[%rip+mc_decls.isregvar]
    mov       %r10,	[%rbp + mc_auxmcl.do_procentry.r]
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L1853
L1854:
    inc       qword ptr[%rip+pc_decls.bspill]
L1853:
    mov       %rax,	[%rbp + mc_auxmcl.do_procentry.r]
    inc       %rax
    mov       [%rbp + mc_auxmcl.do_procentry.r],	%rax
    cmp       %rax,	10
    jle       L1849
    mov       %rax,	7
    mov       [%rbp + mc_auxmcl.do_procentry.r],	%rax
L1855:
    lea       %rax,	[%rip+mc_decls.usedxregs]
    mov       %r10,	[%rbp + mc_auxmcl.do_procentry.r]
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jnz       L1860
    lea       %rax,	[%rip+mc_decls.isxregvar]
    mov       %r10,	[%rbp + mc_auxmcl.do_procentry.r]
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L1859
L1860:
    inc       qword ptr[%rip+pc_decls.bxspill]
L1859:
    mov       %rax,	[%rbp + mc_auxmcl.do_procentry.r]
    inc       %rax
    mov       [%rbp + mc_auxmcl.do_procentry.r],	%rax
    cmp       %rax,	16
    jle       L1855
L1847:
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %r14,	[%rax+16]
    jmp       L1864
L1861:
    mov       %al,	[%r14+91]
    test      %al,	%al
    jz        L1866
    lea       %rcx,	[%rip+L8599]
    lea       %rdx,	[%rip+L8600]
    call      pc_api.merror
L1866:
    mov       %al,	[%r14+90]
    test      %al,	%al
    jnz       L1868
    mov       %rax,	[%rip+mc_genmcl.paramoffset]
    add       %rax,	16
    mov       %r10,	[%rip+pc_decls.bspill]
    add       %r10,	[%rip+pc_decls.bxspill]
    shl       %r10,	3
    add       %rax,	%r10
    mov       [%r14+76],	%eax
    movsxd    %rax,	dword ptr[%r14+76]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       [%rbp + mc_auxmcl.do_procentry.$T1],	%rax
    mov       %rcx,	%r14
    call      mc_writegas.getdispname
    mov       %rcx,	%rax
    call      mc_libmcl.mgenname
    mov       %rcx,	5
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.do_procentry.$T1]
    call      mc_libmcl.genmc
    jmp       L1867
L1868:
    movzx     %rax,	byte ptr[%r14+90]
    mov       %r15,	%rax
    lea       %rax,	[%rip+mc_decls.usedregs]
    movzx     %rax,	byte ptr[%rax+14]
    mov       [%rbp + mc_auxmcl.do_procentry.ff],	%rax
    xor       %eax,	%eax
    mov       [%r14+90],	%al
    movzx     %rax,	byte ptr[%r14+82]
    mov       %rcx,	%r15
    mov       %rdx,	%rax
    call      mc_libmcl.mgenreg
    mov       [%rbp + mc_auxmcl.do_procentry.$T1],	%rax
    mov       %rcx,	%r14
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       %rcx,	6
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.do_procentry.$T1]
    call      mc_libmcl.genmc
    mov       [%r14+90],	%r15b
    mov       %al,	[%rbp + mc_auxmcl.do_procentry.ff]
    lea       %r10,	[%rip+mc_decls.usedregs]
    mov       [%r10+14],	%al
L1867:
    mov       %rax,	8
    add       [%rip+mc_genmcl.paramoffset],	%rax
    mov       %r14,	[%r14+16]
L1864:
    test      %r14,	%r14
    jnz       L1861
    mov       %rax,	[%rip+pc_decls.currfunc]
    movzx     %rax,	byte ptr[%rax+82]
    mov       %rdi,	%rax
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %r14,	[%rax+24]
    jmp       L1872
L1869:
    movzx     %rax,	byte ptr[%r14+82]
    lea       %r10,	[%rip+pc_tables.psize]
    movzx     %r10,	byte ptr[%r10 + %rax]
    mov       %r12,	%r10
    movzx     %rax,	byte ptr[%r14+82]
    cmp       %rax,	11
    jnz       L1874
    mov       %eax,	[%r14+84]
    mov       %r12,	%rax
L1874:
    mov       %al,	[%r14+92]
    test      %al,	%al
    jz        L1870
L1876:
    mov       %al,	[%r14+91]
    test      %al,	%al
    jz        L1878
    mov       %rsi,	1
    jmp       L1877
L1878:
    mov       %al,	[%r14+90]
    test      %al,	%al
    jz        L1879
    movzx     %rax,	byte ptr[%r14+90]
    mov       %r15,	%rax
    lea       %rax,	[%rip+mc_decls.usedregs]
    movzx     %rax,	byte ptr[%rax+14]
    mov       [%rbp + mc_auxmcl.do_procentry.ff],	%rax
    xor       %eax,	%eax
    mov       [%r14+90],	%al
    movzx     %rax,	byte ptr[%r14+82]
    mov       %rcx,	%r15
    mov       %rdx,	%rax
    call      mc_libmcl.mgenreg
    mov       [%rbp + mc_auxmcl.do_procentry.$T1],	%rax
    mov       %rcx,	%r14
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       %rcx,	6
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.do_procentry.$T1]
    call      mc_libmcl.genmc
    mov       [%r14+90],	%r15b
    mov       %al,	[%rbp + mc_auxmcl.do_procentry.ff]
    lea       %r10,	[%rip+mc_decls.usedregs]
    mov       [%r10+14],	%al
    jmp       L1877
L1879:
    mov       %rcx,	%r12
    call      mc_libmcl.roundsizetg
    sub       [%rip+mc_genmcl.frameoffset],	%rax
    mov       %eax,	[%rip+mc_genmcl.frameoffset]
    mov       [%r14+76],	%eax
    movsxd    %rax,	dword ptr[%r14+76]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       [%rbp + mc_auxmcl.do_procentry.$T1],	%rax
    mov       %rcx,	%r14
    call      mc_writegas.getdispname
    mov       %rcx,	%rax
    call      mc_libmcl.mgenname
    mov       %rcx,	5
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.do_procentry.$T1]
    call      mc_libmcl.genmc
L1877:
L1870:
    mov       %r14,	[%r14+24]
L1872:
    test      %r14,	%r14
    jnz       L1869
    xor       %rbx,	%rbx
    mov       %rax,	1
    mov       [%rbp + mc_auxmcl.do_procentry.i],	%rax
L1880:
    lea       %rax,	[%rip+mc_decls.pcltempflags]
    mov       %r10,	[%rbp + mc_auxmcl.do_procentry.i]
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L1884
    inc       %rbx
    mov       %rax,	8
    sub       [%rip+mc_genmcl.frameoffset],	%rax
    lea       %rax,	[%rip+mc_decls.pcltempopnds]
    mov       %r10,	[%rbp + mc_auxmcl.do_procentry.i]
    mov       %r13,	[%rax + %r10*8-8]
    mov       %eax,	[%rip+mc_genmcl.frameoffset]
    mov       [%r13+12],	%eax
    movsxd    %rax,	dword ptr[%r13+12]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       [%rbp + mc_auxmcl.do_procentry.$T1],	%rax
    mov       %rcx,	[%rip+pc_decls.currfunc]
    mov       %rdx,	[%rbp + mc_auxmcl.do_procentry.i]
    call      mc_writegas.gettempname
    mov       %rcx,	%rax
    call      mc_libmcl.mgenname
    mov       %rcx,	5
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.do_procentry.$T1]
    call      mc_libmcl.genmc
L1884:
    mov       %rax,	[%rbp + mc_auxmcl.do_procentry.i]
    inc       %rax
    mov       [%rbp + mc_auxmcl.do_procentry.i],	%rax
    cmp       %rax,	50
    jle       L1880
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %al,	[%rax+108]
    test      %al,	%al
    jz        L1886
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %ax,	[%rax+114]
    test      %ax,	%ax
    jnz       L1889
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %al,	[%rax+112]
    test      %al,	%al
    jz        L1888
L1889:
    lea       %rcx,	[%rip+L8601]
    lea       %rdx,	[%rip+L8602]
    call      pc_api.merror
L1888:
    test      %rbx,	%rbx
    jz        L1891
    lea       %rcx,	[%rip+L8603]
    lea       %rdx,	[%rip+L8604]
    call      pc_api.merror
L1891:
    call      mc_auxmcl.resetmclentry
    jmp       L1845
L1886:
    mov       %rax,	[%rip+mc_genmcl.frameoffset]
    neg       %rax
    mov       [%rip+mc_genmcl.framebytes],	%rax
    mov       %rax,	[%rip+pc_decls.bspill]
    add       %rax,	[%rip+pc_decls.bxspill]
    and       %eax,	1
    test      %rax,	%rax
    jz        L1893
    mov       %rax,	[%rip+mc_genmcl.framebytes]
    and       %rax,	8
    jnz       L1895
    mov       %rax,	8
    add       [%rip+mc_genmcl.framebytes],	%rax
L1895:
    jmp       L1892
L1893:
    mov       %rax,	[%rip+mc_genmcl.framebytes]
    and       %rax,	8
    jz        L1897
    mov       %rax,	8
    add       [%rip+mc_genmcl.framebytes],	%rax
L1897:
L1892:
    mov       %al,	[%rip+pc_decls.localshadow]
    test      %al,	%al
    jz        L1899
    mov       %rax,	32
    add       [%rip+mc_genmcl.framebytes],	%rax
L1899:
    mov       %rax,	[%rip+pc_decls.bspill]
    test      %rax,	%rax
    jz        L1901
    mov       %rax,	4
    mov       [%rbp + mc_auxmcl.do_procentry.r],	%rax
L1902:
    lea       %rax,	[%rip+mc_decls.usedregs]
    mov       %r10,	[%rbp + mc_auxmcl.do_procentry.r]
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jnz       L1907
    lea       %rax,	[%rip+mc_decls.isregvar]
    mov       %r10,	[%rbp + mc_auxmcl.do_procentry.r]
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L1906
L1907:
    mov       %rcx,	[%rbp + mc_auxmcl.do_procentry.r]
    mov       %rdx,	6
    call      mc_libmcl.mgenreg
    mov       %rcx,	12
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L1906:
    mov       %rax,	[%rbp + mc_auxmcl.do_procentry.r]
    inc       %rax
    mov       [%rbp + mc_auxmcl.do_procentry.r],	%rax
    cmp       %rax,	10
    jle       L1902
L1901:
    mov       %rax,	[%rip+pc_decls.bxspill]
    test      %rax,	%rax
    jz        L1909
    mov       %rcx,	1
    mov       %rdx,	6
    call      mc_libmcl.mgenreg
    mov       %r13,	%rax
    mov       %rax,	7
    mov       [%rbp + mc_auxmcl.do_procentry.r],	%rax
L1910:
    lea       %rax,	[%rip+mc_decls.usedxregs]
    mov       %r10,	[%rbp + mc_auxmcl.do_procentry.r]
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jnz       L1915
    lea       %rax,	[%rip+mc_decls.isxregvar]
    mov       %r10,	[%rbp + mc_auxmcl.do_procentry.r]
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L1914
L1915:
    mov       %rcx,	[%rbp + mc_auxmcl.do_procentry.r]
    mov       %rdx,	8
    call      mc_libmcl.mgenxreg
    mov       %rcx,	17
    mov       %rdx,	%r13
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	12
    mov       %rdx,	%r13
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L1914:
    mov       %rax,	[%rbp + mc_auxmcl.do_procentry.r]
    inc       %rax
    mov       [%rbp + mc_auxmcl.do_procentry.r],	%rax
    cmp       %rax,	16
    jle       L1910
L1909:
    lea       %rcx,	[%rip+L8605]
    call      mc_libmcl.mgencomment
    mov       %rax,	[%rip+mc_decls.mccodex]
    mov       [%rip+mc_auxmcl.mclframesetup],	%rax
    call      mc_auxmcl.spillparams
    lea       %rcx,	[%rip+L8606]
    call      mc_libmcl.mgencomment
    call      mc_auxmcl.resetmclentry
L1845:
#---------------
    add       %rsp,	72
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_procexit
mc_auxmcl.do_procexit:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
    lea       %rcx,	[%rip+L8606]
    call      mc_libmcl.mgencomment
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %al,	[%rax+108]
    test      %al,	%al
    jz        L1918
    mov       %rcx,	22
    xor       %edx,	%edx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L1916
L1918:
    mov       %rcx,	[%rip+mc_auxmcl.mclframesetup]
    call      mc_auxmcl.setmclentryf
    mov       %rax,	[%rip+mc_genmcl.framebytes]
    test      %rax,	%rax
    jnz       L1921
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %al,	[%rax+112]
    test      %al,	%al
    jnz       L1921
    lea       %rax,	[%rip+mc_decls.usedregs]
    mov       %al,	[%rax+14]
    test      %al,	%al
    jz        L1920
L1921:
    lea       %rax,	[%rip+mc_decls.usedregs]
    mov       %al,	[%rax+14]
    test      %al,	%al
    jz        L1923
    mov       %rcx,	12
    mov       %rdx,	[%rip+mc_decls.dframeopnd]
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	11
    mov       %rdx,	[%rip+mc_decls.dframeopnd]
    mov       %r8,	[%rip+mc_decls.dstackopnd]
    call      mc_libmcl.genmc
    mov       %rcx,	[%rip+mc_genmcl.framebytes]
    call      mc_libmcl.pushstack
    jmp       L1922
L1923:
    mov       %rax,	[%rip+mc_genmcl.framebytes]
    test      %rax,	%rax
    jz        L1925
    mov       %rax,	[%rip+mc_genmcl.framebytes]
    add       %rax,	8
    mov       %rcx,	%rax
    call      mc_libmcl.pushstack
L1925:
L1922:
L1920:
    call      mc_auxmcl.resetmclentryf
    mov       %rax,	[%rip+mc_genmcl.framebytes]
    test      %rax,	%rax
    jnz       L1928
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %al,	[%rax+112]
    test      %al,	%al
    jnz       L1928
    lea       %rax,	[%rip+mc_decls.usedregs]
    mov       %al,	[%rax+14]
    test      %al,	%al
    jz        L1927
L1928:
    lea       %rax,	[%rip+mc_decls.usedregs]
    mov       %al,	[%rax+14]
    test      %al,	%al
    jz        L1930
    mov       %rcx,	[%rip+mc_genmcl.framebytes]
    call      mc_libmcl.popstack
    mov       %rcx,	13
    mov       %rdx,	[%rip+mc_decls.dframeopnd]
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L1929
L1930:
    mov       %rax,	[%rip+mc_genmcl.framebytes]
    test      %rax,	%rax
    jz        L1932
    mov       %rax,	[%rip+mc_genmcl.framebytes]
    add       %rax,	8
    mov       %rcx,	%rax
    call      mc_libmcl.popstack
L1932:
L1929:
L1927:
    mov       %rax,	[%rip+pc_decls.bxspill]
    test      %rax,	%rax
    jz        L1934
    mov       %rcx,	11
    mov       %rdx,	6
    call      mc_libmcl.mgenreg
    mov       %rdi,	%rax
    mov       %rbx,	16
L1935:
    lea       %rax,	[%rip+mc_decls.usedxregs]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L1939
    mov       %rcx,	13
    mov       %rdx,	%rdi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	%rbx
    mov       %rdx,	8
    call      mc_libmcl.mgenxreg
    mov       %rcx,	17
    mov       %rdx,	%rax
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
L1939:
    dec       %rbx
    cmp       %rbx,	7
    jge       L1935
L1934:
    mov       %rax,	[%rip+pc_decls.bspill]
    test      %rax,	%rax
    jz        L1941
    mov       %rbx,	10
L1942:
    lea       %rax,	[%rip+mc_decls.usedregs]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L1946
    mov       %rcx,	%rbx
    mov       %rdx,	6
    call      mc_libmcl.mgenreg
    mov       %rcx,	13
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L1946:
    dec       %rbx
    cmp       %rbx,	4
    jge       L1942
L1941:
    mov       %rcx,	22
    xor       %edx,	%edx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L1916:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.spillparams
mc_auxmcl.spillparams:
#?>>
    .set mc_auxmcl.spillparams.$T1, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
#---------------
    mov       %rsi,	16
    xor       %r12,	%r12
    xor       %eax,	%eax
    mov       %r12,	%rax
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %rdi,	[%rax+16]
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %al,	[%rax+113]
    test      %al,	%al
    jz        L1949
    movsxd    %rax,	dword ptr[%rdi+76]
    mov       %r13,	%rax
    mov       %rax,	[%rip+pc_decls.currfunc]
    movzx     %rax,	byte ptr[%rax+112]
    mov       %r14,	%rax
    cmp       %r14,	3
    jg        L1952
L1950:
    sub       %rsp,	8
    push      0
    push      0
    push      8
    mov       %rax,	%r14
    shl       %rax,	3
    add       %rax,	%r13
    mov       %rcx,	15
    xor       %edx,	%edx
    mov       %r8,	1
    mov       %r9,	%rax
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rbx,	%rax
    lea       %rax,	[%r14+11]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    inc       %r14
    cmp       %r14,	3
    jle       L1950
L1952:
L1949:
    jmp       L1956
L1953:
    cmp       %r12,	3
    jg        L1955
L1958:
    mov       %al,	[%rdi+92]
    test      %al,	%al
    jz        L1960
    mov       %al,	[%rdi+90]
    test      %al,	%al
    jnz       L1962
    sub       %rsp,	8
    push      0
    push      0
    push      8
    movsxd    %rax,	dword ptr[%rdi+76]
    mov       %rcx,	15
    xor       %edx,	%edx
    mov       %r8,	1
    mov       %r9,	%rax
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rdi+82]
    cmp       %rax,	2
    jz        L1964
    cmp       %rax,	1
    jz        L1965
    jmp       L1966
L1964:
    lea       %rax,	[%r12+1]
    mov       %rcx,	%rax
    mov       %rdx,	8
    call      mc_libmcl.mgenxreg
    mov       %rcx,	17
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L1963
L1965:
    lea       %rax,	[%r12+1]
    mov       %rcx,	%rax
    mov       %rdx,	8
    call      mc_libmcl.mgenxreg
    mov       [%rbp + mc_auxmcl.spillparams.$T1],	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	4
    call      mc_libmcl.changeopndsize
    mov       %rcx,	16
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.spillparams.$T1]
    call      mc_libmcl.genmc
    jmp       L1963
L1966:
    lea       %rax,	[%r12+11]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L1963:
    jmp       L1961
L1962:
    mov       %al,	[%rdi+90]
    test      %al,	%al
    jz        L1967
    movzx     %rax,	byte ptr[%rdi+82]
    cmp       %rax,	2
    jg        L1969
    movzx     %rax,	byte ptr[%rdi+90]
    cmp       %rax,	5
    jl        L1971
    movzx     %rax,	byte ptr[%rdi+82]
    lea       %r10,	[%r12+1]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_libmcl.mgenxreg
    mov       [%rbp + mc_auxmcl.spillparams.$T1],	%rax
    movzx     %rax,	byte ptr[%rdi+90]
    mov       %rcx,	%rax
    mov       %rdx,	8
    call      mc_libmcl.mgenxreg
    mov       %rcx,	17
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.spillparams.$T1]
    call      mc_libmcl.genmc
L1971:
    jmp       L1968
L1969:
    movzx     %rax,	byte ptr[%rdi+90]
    cmp       %rax,	10
    jg        L1972
    movzx     %rax,	byte ptr[%rdi+82]
    lea       %r10,	[%r12+11]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_libmcl.mgenreg
    mov       [%rbp + mc_auxmcl.spillparams.$T1],	%rax
    movzx     %rax,	byte ptr[%rdi+82]
    movzx     %r10,	byte ptr[%rdi+90]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_libmcl.mgenreg
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.spillparams.$T1]
    call      mc_libmcl.genmc
L1972:
L1968:
L1967:
L1961:
L1960:
    mov       %rax,	8
    add       %rsi,	%rax
    inc       %r12
    mov       %rdi,	[%rdi+16]
L1956:
    test      %rdi,	%rdi
    jnz       L1953
L1955:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_jumptruefalse
mc_auxmcl.do_jumptruefalse:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jle       L1975
    mov       %rcx,	41
    mov       %rdx,	%rdi
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    jmp       L1974
L1975:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rax
    call      mc_stackmcl.getworkregm
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    dec       %rax
    mov       %r10,	76
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rbx
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    dec       %rax
    mov       %r10,	73
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L1974:
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %rcx,	26
    mov       %rdx,	%r12
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_bitwise
mc_auxmcl.do_bitwise:
#?>>
    .set mc_auxmcl.do_bitwise.p, 40
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rdx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    mov       %rcx,	%rsi
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_shift
mc_auxmcl.do_shift:
#?>>
    .set mc_auxmcl.do_shift.p, 48
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rdx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	[%rip+mc_decls.noperands]
    mov       %rsi,	[%rax + %r10*8-8]
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    test      %rax,	%rax
    jnz       L1979
    movzx     %rax,	byte ptr[%rsi+1]
    cmp       %rax,	4
    jnz       L1979
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	%r12
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L1978
L1979:
    mov       %al,	[%rip+pc_decls.r10used]
    test      %al,	%al
    jz        L1981
    mov       %rcx,	11
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	12
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L1981:
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	3
    mov       %r8,	11
    call      mc_stackmcl.loadparam
    mov       %rbx,	%rax
    mov       %rcx,	%r12
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    mov       %al,	[%rip+pc_decls.r10used]
    test      %al,	%al
    jz        L1983
    mov       %rcx,	11
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	13
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L1983:
L1978:
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.setmclentry
mc_auxmcl.setmclentry:
#?>>
#?]]
#---------------
    mov       %rax,	[%rip+mc_decls.mccodex]
    mov       [%rip+mc_decls.mce_oldmccodex],	%rax
    mov       [%rip+mc_decls.mccodex],	%rcx
    mov       %rax,	[%rcx]
    mov       [%rip+mc_decls.mce_lastmcl],	%rax
    mov       %rax,	[%rcx+8]
    mov       [%rip+mc_decls.mce_nextmcl],	%rax
#---------------
    ret       
# End 
# Proc mc_auxmcl.resetmclentry
mc_auxmcl.resetmclentry:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	16
#---------------
    mov       %rax,	[%rip+mc_decls.mce_lastmcl]
    mov       %r10,	[%rip+mc_decls.mccodex]
    mov       [%r10],	%rax
    mov       %rax,	[%rip+mc_decls.mce_nextmcl]
    mov       %r10,	[%rip+mc_decls.mccodex]
    mov       [%r10+8],	%rax
    mov       %rdi,	[%rip+mc_decls.mccodex]
    mov       %rax,	[%rip+mc_decls.mce_oldmccodex]
    mov       [%rip+mc_decls.mccodex],	%rax
    mov       %rax,	%rdi
L1985:
#---------------
    add       %rsp,	16
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.setmclentryf
mc_auxmcl.setmclentryf:
#?>>
#?]]
#---------------
    mov       %rax,	[%rip+mc_decls.mccodex]
    mov       [%rip+mc_decls.mcf_oldmccodex],	%rax
    mov       [%rip+mc_decls.mccodex],	%rcx
    mov       %rax,	[%rcx]
    mov       [%rip+mc_decls.mcf_lastmcl],	%rax
    mov       %rax,	[%rcx+8]
    mov       [%rip+mc_decls.mcf_nextmcl],	%rax
#---------------
    ret       
# End 
# Proc mc_auxmcl.resetmclentryf
mc_auxmcl.resetmclentryf:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	16
#---------------
    mov       %rax,	[%rip+mc_decls.mcf_lastmcl]
    mov       %r10,	[%rip+mc_decls.mccodex]
    mov       [%r10],	%rax
    mov       %rax,	[%rip+mc_decls.mcf_nextmcl]
    mov       %r10,	[%rip+mc_decls.mccodex]
    mov       [%r10+8],	%rax
    mov       %rdi,	[%rip+mc_decls.mccodex]
    mov       %rax,	[%rip+mc_decls.mcf_oldmccodex]
    mov       [%rip+mc_decls.mccodex],	%rax
    mov       %rax,	%rdi
L1987:
#---------------
    add       %rsp,	16
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_pushlowargs
mc_auxmcl.do_pushlowargs:
#?>>
    .set mc_auxmcl.do_pushlowargs.isptr, 72
    .set mc_auxmcl.do_pushlowargs.pstack, 80
    .set mc_auxmcl.do_pushlowargs.nextireg, -8
    .set mc_auxmcl.do_pushlowargs.nextxreg, -16
    .set mc_auxmcl.do_pushlowargs.mode, -24
    .set mc_auxmcl.do_pushlowargs.imode, -32
    .set mc_auxmcl.do_pushlowargs.blockret, -40
    .set mc_auxmcl.do_pushlowargs.dblock, -48
    .set mc_auxmcl.do_pushlowargs.av_1, -56
    .set mc_auxmcl.do_pushlowargs.i, -64
    .set mc_auxmcl.do_pushlowargs.$T1, -72
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	104
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       [%rbp+72],	%r8
    mov       [%rbp+80],	%r9
#---------------
    test      %r12,	%r12
    jnz       L1990
    jmp       L1988
L1990:
    mov       %rax,	[%rbp + mc_auxmcl.do_pushlowargs.pstack]
    test      %rax,	%rax
    jz        L1992
    xor       %eax,	%eax
    mov       [%rbp + mc_auxmcl.do_pushlowargs.blockret],	%rax
    jmp       L1991
L1992:
    lea       %rax,	[%rip+mc_decls.callblockret]
    mov       %r10,	[%rip+mc_decls.ncalldepth]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       [%rbp + mc_auxmcl.do_pushlowargs.blockret],	%rax
L1991:
    mov       %rax,	11
    mov       [%rbp + mc_auxmcl.do_pushlowargs.nextireg],	%rax
    mov       %rax,	1
    mov       [%rbp + mc_auxmcl.do_pushlowargs.nextxreg],	%rax
    xor       %rsi,	%rsi
    mov       %rax,	[%rip+mc_decls.noperands]
    mov       [%rbp + mc_auxmcl.do_pushlowargs.i],	%rax
    mov       %rax,	[%rip+mc_decls.noperands]
    sub       %rax,	%r12
    inc       %rax
    mov       [%rbp + mc_auxmcl.do_pushlowargs.av_1],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.do_pushlowargs.i]
    cmp       %rax,	[%rbp + mc_auxmcl.do_pushlowargs.av_1]
    jl        L1995
L1993:
    inc       %rsi
    cmp       %rsi,	1
    jnz       L1997
    mov       %rax,	[%rbp + mc_auxmcl.do_pushlowargs.blockret]
    test      %rax,	%rax
    jz        L1997
    lea       %rax,	[%rip+mc_decls.callblocksize]
    mov       %r10,	[%rip+mc_decls.ncalldepth]
    mov       %eax,	[%rax + %r10*4-4]
    mov       %rcx,	%rax
    call      mc_libmcl.newblocktemp
    mov       [%rbp + mc_auxmcl.do_pushlowargs.dblock],	%rax
    mov       %al,	1
    mov       %r10,	[%rbp + mc_auxmcl.do_pushlowargs.dblock]
    mov       [%r10+92],	%al
    mov       %rcx,	[%rbp + mc_auxmcl.do_pushlowargs.dblock]
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       [%rbp + mc_auxmcl.do_pushlowargs.$T1],	%rax
    mov       %rcx,	11
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	14
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.do_pushlowargs.$T1]
    call      mc_libmcl.genmc
    jmp       L1996
L1997:
    mov       %rax,	[%rbp + mc_auxmcl.do_pushlowargs.i]
    sub       %rax,	[%rbp + mc_auxmcl.do_pushlowargs.isptr]
    add       %rax,	[%rbp + mc_auxmcl.do_pushlowargs.blockret]
    mov       %rbx,	%rax
    mov       %rax,	[%rbp + mc_auxmcl.do_pushlowargs.pstack]
    test      %rax,	%rax
    jz        L1999
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       [%rbp + mc_auxmcl.do_pushlowargs.mode],	%rax
    jmp       L1998
L1999:
    lea       %rax,	[%rip+mc_decls.callargmode]
    mov       %r10,	[%rip+mc_decls.ncalldepth]
    shl       %r10,	5
    lea       %rax,	[%rax + %r10-32]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       [%rbp + mc_auxmcl.do_pushlowargs.mode],	%rax
L1998:
    mov       %rax,	[%rbp + mc_auxmcl.do_pushlowargs.mode]
    cmp       %rax,	11
    jz        L2001
    cmp       %rax,	2
    jz        L2002
    cmp       %rax,	1
    jz        L2002
    jmp       L2003
L2001:
    mov       %rcx,	%rbx
    mov       %rdx,	[%rbp + mc_auxmcl.do_pushlowargs.mode]
    mov       %r8,	[%rbp + mc_auxmcl.do_pushlowargs.nextireg]
    call      mc_stackmcl.loadparam
    mov       %rdi,	%rax
    lea       %rax,	[%rip+mc_decls.callargsize]
    mov       %r10,	[%rip+mc_decls.ncalldepth]
    shl       %r10,	7
    lea       %rax,	[%rax + %r10-128]
    mov       %r10,	%rsi
    mov       %eax,	[%rax + %r10*4-4]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    mov       %r8,	%rsi
    call      mc_auxmcl.copyblockarg
    jmp       L2000
L2002:
    mov       %rcx,	%rbx
    mov       %rdx,	[%rbp + mc_auxmcl.do_pushlowargs.mode]
    mov       %r8,	[%rbp + mc_auxmcl.do_pushlowargs.nextxreg]
    call      mc_stackmcl.loadparam
    test      %r13,	%r13
    jz        L2005
    cmp       %rsi,	%r13
    jl        L2005
    mov       %rax,	[%rbp + mc_auxmcl.do_pushlowargs.mode]
    cmp       %rax,	1
    jnz       L2007
    mov       %rax,	5
    jmp       L2006
L2007:
    mov       %rax,	6
L2006:
    mov       [%rbp + mc_auxmcl.do_pushlowargs.imode],	%rax
    mov       %rcx,	[%rbp + mc_auxmcl.do_pushlowargs.nextxreg]
    mov       %rdx,	[%rbp + mc_auxmcl.do_pushlowargs.mode]
    call      mc_libmcl.mgenreg
    mov       [%rbp + mc_auxmcl.do_pushlowargs.$T1],	%rax
    mov       %rcx,	[%rbp + mc_auxmcl.do_pushlowargs.nextireg]
    mov       %rdx,	[%rbp + mc_auxmcl.do_pushlowargs.imode]
    call      mc_libmcl.mgenreg
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.do_pushlowargs.$T1]
    call      mc_libmcl.genmc
L2005:
    jmp       L2000
L2003:
#mc_auxmcl.do_pushlowargs.doint:
    mov       %rcx,	%rbx
    mov       %rdx,	[%rbp + mc_auxmcl.do_pushlowargs.mode]
    mov       %r8,	[%rbp + mc_auxmcl.do_pushlowargs.nextireg]
    call      mc_stackmcl.loadparam
L2000:
L1996:
    inc       qword ptr[%rbp + mc_auxmcl.do_pushlowargs.nextireg]
    inc       qword ptr[%rbp + mc_auxmcl.do_pushlowargs.nextxreg]
    mov       %rax,	[%rbp + mc_auxmcl.do_pushlowargs.i]
    dec       %rax
    mov       [%rbp + mc_auxmcl.do_pushlowargs.i],	%rax
    cmp       %rax,	[%rbp + mc_auxmcl.do_pushlowargs.av_1]
    jge       L1993
L1995:
L1988:
#---------------
    add       %rsp,	104
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_getretvalue
mc_auxmcl.do_getretvalue:
#?>>
    .set mc_auxmcl.do_getretvalue.modes, -80
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	112
    mov       %r12,	%rcx
#---------------
    lea       %rax,	[%r12+32]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	13
    jnz       L2011
    xor       %rbx,	%rbx
    jmp       L2013
L2012:
    movzx     %rax,	byte ptr[%r12+3]
    inc       %rbx
    mov       %r10,	%rbx
    mov       [%rbp + %r10*8 + mc_auxmcl.do_getretvalue.modes-8],	%rax
L2013:
    add       %r12,	32
    mov       %rax,	%r12
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	13
    jz        L2012
    lea       %rax,	[%r12-32]
    mov       [%rip+mc_decls.currpcl],	%rax
    mov       %rdi,	%rbx
    cmp       %rdi,	1
    jl        L2017
L2015:
    mov       %rsi,	[%rbp + %rdi*8 + mc_auxmcl.do_getretvalue.modes-8]
    cmp       %rsi,	2
    jg        L2019
    lea       %rax,	[%rip+mc_decls.multxregs]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    jmp       L2018
L2019:
    lea       %rax,	[%rip+mc_decls.multregs]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
L2018:
    mov       %rcx,	%rsi
    mov       %rdx,	%rax
    call      mc_stackmcl.pushpcl_reg
    dec       %rdi
    cmp       %rdi,	1
    jge       L2015
L2017:
    jmp       L2010
L2011:
    mov       %al,	[%r12+3]
    test      %al,	%al
    jz        L2020
    movzx     %rax,	byte ptr[%r12+3]
    mov       %rcx,	%rax
    mov       %rdx,	1
    call      mc_stackmcl.pushpcl_reg
L2020:
L2010:
#---------------
    add       %rsp,	112
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.ismemaddr
mc_auxmcl.ismemaddr:
#?>>
#?]]
#---------------
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rcx
    movzx     %rax,	byte ptr[%rax + %r10-1]
    test      %rax,	%rax
    jnz       L2023
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	%rcx
    mov       %rax,	[%rax + %r10*8-8]
    movzx     %rax,	byte ptr[%rax+1]
    cmp       %rax,	2
    jnz       L2023
    mov       %rax,	1
    jmp       L2021
L2023:
    xor       %eax,	%eax
L2021:
#---------------
    ret       
# End 
# Proc mc_auxmcl.do_incr
mc_auxmcl.do_incr:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    movzx     %rax,	byte ptr[%rbx+3]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    movsxd    %rax,	dword ptr[%rbx+16]
    cmp       %rax,	1
    jnz       L2026
    mov       %rcx,	%rsi
    mov       %rdx,	%rdi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L2025
L2026:
    movsxd    %rax,	dword ptr[%rbx+16]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	%r12
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2025:
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_incrload
mc_auxmcl.do_incrload:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	[%rip+mc_decls.noperands]
    movzx     %r10,	byte ptr[%r10 + %r11-1]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_stackmcl.getworkreg_rm
    mov       %rdi,	%rax
    movsxd    %rax,	dword ptr[%rsi+16]
    cmp       %rax,	1
    jnz       L2029
    mov       %rcx,	%r12
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L2028
L2029:
    movsxd    %rax,	dword ptr[%rsi+16]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	%r13
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2028:
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.pclloc]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11-1],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+mc_decls.pclopnd]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11*8-8],	%rax
    mov       %al,	[%rdi+10]
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11-1],	%al
    mov       %al,	[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+mc_decls.pclmode]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11-1],	%al
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_loadincr
mc_auxmcl.do_loadincr:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      mc_stackmcl.pushpcl_reg
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rdi,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    movsxd    %rax,	dword ptr[%rsi+16]
    cmp       %rax,	1
    jnz       L2032
    mov       %rcx,	%r12
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L2031
L2032:
    movsxd    %rax,	dword ptr[%rsi+16]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	%r13
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2031:
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_for
mc_auxmcl.do_for:
#?>>
    .set mc_auxmcl.do_for.addop, 80
    .set mc_auxmcl.do_for.cond, 88
    .set mc_auxmcl.do_for.mx, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       [%rbp+80],	%r8
    mov       [%rbp+88],	%r9
#---------------
    lea       %rax,	[%r13+32]
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+32]
    mov       [%rip+mc_decls.currpcl],	%rax
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rdi+8]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_libmcl.mgenmem
    mov       [%rbp + mc_auxmcl.do_for.mx],	%rax
    mov       %rax,	[%rdi+8]
    mov       %al,	[%rax+90]
    test      %al,	%al
    jz        L2035
    movsxd    %rax,	dword ptr[%r13+16]
    cmp       %rax,	1
    jnz       L2037
    mov       %rcx,	%r14
    mov       %rdx,	[%rbp + mc_auxmcl.do_for.mx]
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L2036
L2037:
    movsxd    %rax,	dword ptr[%r13+16]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	[%rbp + mc_auxmcl.do_for.addop]
    mov       %rdx,	[%rbp + mc_auxmcl.do_for.mx]
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2036:
    mov       %rsi,	[%rbp + mc_auxmcl.do_for.mx]
    jmp       L2034
L2035:
    call      mc_stackmcl.getworkireg
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rsi,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rsi
    mov       %r8,	[%rbp + mc_auxmcl.do_for.mx]
    call      mc_libmcl.genmc
    movsxd    %rax,	dword ptr[%r13+16]
    cmp       %rax,	1
    jnz       L2039
    mov       %rcx,	%r14
    mov       %rdx,	%rsi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L2038
L2039:
    movsxd    %rax,	dword ptr[%r13+16]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	[%rbp + mc_auxmcl.do_for.addop]
    mov       %rdx,	%rsi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2038:
    mov       %rcx,	11
    mov       %rdx,	[%rbp + mc_auxmcl.do_for.mx]
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
L2034:
    movzx     %rax,	byte ptr[%rbx+1]
    cmp       %rax,	4
    jnz       L2041
    mov       %rax,	[%rbx+8]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %r12,	%rax
    jmp       L2040
L2041:
    mov       %rax,	[%rbx+8]
    mov       %rcx,	%rax
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       %r12,	%rax
L2040:
    mov       %rcx,	42
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      mc_libmcl.genmc
    mov       %rax,	[%r13+8]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %rcx,	26
    mov       %rdx,	[%rbp + mc_auxmcl.do_for.cond]
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.scaleindex
mc_auxmcl.scaleindex:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rax,	%rbx
    cmp       %rax,	1
    jz        L2045
    cmp       %rax,	2
    jz        L2045
    cmp       %rax,	4
    jz        L2045
    cmp       %rax,	8
    jnz       L2044
L2045:
    mov       %rax,	%rbx
    jmp       L2042
L2044:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mc_auxmcl.mulimm
    mov       %rax,	1
L2042:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.mulimm
mc_auxmcl.mulimm:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r12,	%rcx
    mov       %r13,	%rdx
#---------------
    mov       %rax,	%r13
    test      %rax,	%rax
    jz        L2048
    cmp       %rax,	1
    jz        L2049
    cmp       %rax,	-1
    jz        L2050
    jmp       L2051
L2048:
    mov       %rcx,	%r12
    call      mc_libmcl.clearreg
    jmp       L2046
L2049:
    jmp       L2046
L2050:
    mov       %rcx,	50
    mov       %rdx,	%r12
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L2046
L2051:
L2047:
    xor       %rdi,	%rdi
    mov       %rax,	%r13
    mov       %rbx,	%rax
    jmp       L2053
L2052:
    sar       %rbx,	1
    inc       %rdi
L2053:
    mov       %eax,	%ebx
    and       %eax,	1
    test      %rax,	%rax
    jz        L2052
    test      %rdi,	%rdi
    jz        L2056
    mov       %rcx,	%rdi
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	43
    mov       %rdx,	%r12
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2056:
    mov       %rax,	%rbx
    cmp       %rax,	1
    jz        L2058
    cmp       %rax,	3
    jz        L2059
    cmp       %rax,	5
    jz        L2059
    cmp       %rax,	9
    jz        L2059
    jmp       L2060
L2058:
    jmp       L2046
L2059:
    sub       %rsp,	8
    push      0
    push      0
    push      0
    lea       %rax,	[%rbx-1]
    movzx     %r10,	byte ptr[%r12+10]
    movzx     %r11,	byte ptr[%r12+10]
    mov       %rcx,	%r11
    mov       %rdx,	%r10
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rcx,	14
    mov       %rdx,	%r12
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L2057
L2060:
    test      %rdi,	%rdi
    jz        L2062
    mov       %al,	34
    mov       %r10,	[%rip+mc_decls.mccodex]
    mov       [%r10+33],	%al
    mov       %rcx,	%r13
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %r10,	[%rip+mc_decls.mccodex]
    mov       [%r10+24],	%rax
    jmp       L2061
L2062:
    movzx     %rax,	word ptr[%r12+8]
    and       %rax,	31
    cmp       %rax,	4
    jnz       L2064
    mov       %rax,	9
    jmp       L2063
L2064:
    mov       %rax,	10
L2063:
    mov       %rcx,	%rax
    call      mc_stackmcl.getworkregm
    mov       %rsi,	%rax
    mov       %rcx,	%r13
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	11
    mov       %rdx,	%rsi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	34
    mov       %rdx,	%r12
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
L2061:
L2057:
L2046:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_addrmode
mc_auxmcl.do_addrmode:
#?>>
    .set mc_auxmcl.do_addrmode.p, 72
    .set mc_auxmcl.do_addrmode.scale, -8
    .set mc_auxmcl.do_addrmode.regix, -16
    .set mc_auxmcl.do_addrmode.d, -24
    .set mc_auxmcl.do_addrmode.q, -32
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	72
    mov       [%rbp+72],	%rcx
#---------------
    mov       %rax,	[%rbp + mc_auxmcl.do_addrmode.p]
    movsxd    %rax,	dword ptr[%rax+16]
    mov       [%rbp + mc_auxmcl.do_addrmode.scale],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.do_addrmode.p]
    movsxd    %rax,	dword ptr[%rax+20]
    mov       %r12,	%rax
    mov       %rcx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.isimmload
    mov       [%rbp + mc_auxmcl.do_addrmode.q],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.do_addrmode.q]
    test      %rax,	%rax
    jz        L2067
    mov       %rax,	[%rbp + mc_auxmcl.do_addrmode.q]
    mov       %rax,	[%rax+8]
    mov       %r10,	[%rbp + mc_auxmcl.do_addrmode.scale]
    imul      %rax,	%r10
    add       %rax,	%r12
    mov       %r13,	%rax
L2067:
    xor       %rdi,	%rdi
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-2]
    cmp       %rax,	2
    jnz       L2069
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	2
    jnz       L2071
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %r14,	%rax
    mov       %rcx,	%r14
    lea       %rdx,	[%rbp + mc_auxmcl.do_addrmode.scale]
    mov       %r8,	[%rip+mc_decls.noperands]
    call      mc_auxmcl.scaleregvar
    mov       [%rbp + mc_auxmcl.do_addrmode.regix],	%rax
    sub       %rsp,	8
    push      0
    push      0
    push      0
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-2]
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_auxmcl.do_addrmode.regix]
    mov       %r8,	[%rbp + mc_auxmcl.do_addrmode.scale]
    mov       %r9,	%r12
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rdi,	%rax
    jmp       L2070
L2071:
    mov       %rax,	[%rbp + mc_auxmcl.do_addrmode.q]
    test      %rax,	%rax
    jz        L2072
    sub       %rsp,	8
    push      0
    push      0
    push      0
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-2]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    mov       %r8,	1
    mov       %r9,	%r13
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rdi,	%rax
    jmp       L2070
L2072:
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %r10,	%rax
    mov       %rsi,	%r10
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_auxmcl.do_addrmode.scale]
    call      mc_auxmcl.scaleindex
    mov       [%rbp + mc_auxmcl.do_addrmode.scale],	%rax
    sub       %rsp,	8
    push      0
    push      0
    push      0
    movzx     %rax,	byte ptr[%rsi+10]
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	[%rip+mc_decls.noperands]
    movzx     %r10,	byte ptr[%r10 + %r11-2]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.do_addrmode.scale]
    mov       %r9,	%r12
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rdi,	%rax
L2070:
    jmp       L2068
L2069:
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    call      mc_auxmcl.ismemaddr
    test      %rax,	%rax
    jz        L2073
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	[%rip+mc_decls.noperands]
    mov       %rax,	[%rax + %r10*8-16]
    mov       %rax,	[%rax+8]
    mov       [%rbp + mc_auxmcl.do_addrmode.d],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.do_addrmode.d]
    movzx     %rax,	byte ptr[%rax+72]
    cmp       %rax,	3
    jnz       L2077
    movzx     %rax,	byte ptr[%rip+pc_api.phighmem]
    cmp       %rax,	2
    jz        L2076
L2077:
    mov       %rax,	[%rbp + mc_auxmcl.do_addrmode.d]
    movzx     %rax,	byte ptr[%rax+72]
    cmp       %rax,	5
    jnz       L2075
    mov       %rax,	[%rbp + mc_auxmcl.do_addrmode.d]
    movzx     %rax,	byte ptr[%rax+82]
    cmp       %rax,	11
    jnz       L2075
L2076:
    jmp       L2078
L2075:
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	2
    jnz       L2080
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %r14,	%rax
    mov       %rcx,	%r14
    lea       %rdx,	[%rbp + mc_auxmcl.do_addrmode.scale]
    mov       %r8,	[%rip+mc_decls.noperands]
    call      mc_auxmcl.scaleregvar
    mov       [%rbp + mc_auxmcl.do_addrmode.regix],	%rax
    sub       %rsp,	8
    push      qword ptr[%rbp + mc_auxmcl.do_addrmode.d]
    push      0
    push      0
    xor       %ecx,	%ecx
    mov       %rdx,	[%rbp + mc_auxmcl.do_addrmode.regix]
    mov       %r8,	[%rbp + mc_auxmcl.do_addrmode.scale]
    mov       %r9,	%r12
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rdi,	%rax
    jmp       L2079
L2080:
    mov       %rax,	[%rbp + mc_auxmcl.do_addrmode.q]
    test      %rax,	%rax
    jz        L2081
    sub       %rsp,	8
    push      qword ptr[%rbp + mc_auxmcl.do_addrmode.d]
    push      0
    push      0
    xor       %ecx,	%ecx
    xor       %edx,	%edx
    mov       %r8,	1
    mov       %r9,	%r13
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rdi,	%rax
    jmp       L2079
L2081:
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	10
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %r10,	%rax
    mov       %rsi,	%r10
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_auxmcl.do_addrmode.scale]
    call      mc_auxmcl.scaleindex
    mov       [%rbp + mc_auxmcl.do_addrmode.scale],	%rax
    sub       %rsp,	8
    push      qword ptr[%rbp + mc_auxmcl.do_addrmode.d]
    push      0
    push      0
    movzx     %rax,	byte ptr[%rsi+10]
    xor       %ecx,	%ecx
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.do_addrmode.scale]
    mov       %r9,	%r12
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rdi,	%rax
L2079:
    jmp       L2068
L2073:
#mc_auxmcl.do_addrmode.skip:
L2078:
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	1
    jnz       L2083
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %r14,	%rax
    mov       %rcx,	%r14
    lea       %rdx,	[%rbp + mc_auxmcl.do_addrmode.scale]
    mov       %r8,	[%rip+mc_decls.noperands]
    call      mc_auxmcl.scaleregvar
    mov       [%rbp + mc_auxmcl.do_addrmode.regix],	%rax
    sub       %rsp,	8
    push      0
    push      0
    push      0
    movzx     %rax,	byte ptr[%rbx+10]
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_auxmcl.do_addrmode.regix]
    mov       %r8,	[%rbp + mc_auxmcl.do_addrmode.scale]
    mov       %r9,	%r12
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rdi,	%rax
    jmp       L2082
L2083:
    mov       %rax,	[%rbp + mc_auxmcl.do_addrmode.q]
    test      %rax,	%rax
    jz        L2084
    sub       %rsp,	8
    push      0
    push      0
    push      0
    movzx     %rax,	byte ptr[%rbx+10]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    mov       %r8,	1
    mov       %r9,	%r13
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rdi,	%rax
    jmp       L2082
L2084:
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %r10,	%rax
    mov       %rsi,	%r10
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_auxmcl.do_addrmode.scale]
    call      mc_auxmcl.scaleindex
    mov       [%rbp + mc_auxmcl.do_addrmode.scale],	%rax
    sub       %rsp,	8
    push      0
    push      0
    push      0
    movzx     %rax,	byte ptr[%rsi+10]
    movzx     %r10,	byte ptr[%rbx+10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.do_addrmode.scale]
    mov       %r9,	%r12
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rdi,	%rax
L2082:
L2068:
    mov       %rax,	[%rbp + mc_auxmcl.do_addrmode.p]
    movzx     %rax,	byte ptr[%rax+3]
    lea       %r10,	[%rip+pc_tables.psize]
    movzx     %r10,	byte ptr[%r10 + %rax]
    lea       %rax,	[%rdi+8]
    mov       %r15w,	[%rax]
    mov       %r11,	-32
    and       %r15w,	%r11w
    or        %r15w,	%r10w
    mov       [%rax],	%r15w
    mov       %rax,	%rdi
L2065:
#---------------
    add       %rsp,	72
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.scaleregvar
mc_auxmcl.scaleregvar:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
    mov       %rax,	[%r12]
    cmp       %rax,	1
    jz        L2088
    cmp       %rax,	2
    jz        L2088
    cmp       %rax,	4
    jz        L2088
    cmp       %rax,	8
    jnz       L2087
L2088:
    mov       %rax,	%rsi
    jmp       L2085
L2087:
    call      mc_stackmcl.getworkireg
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rbx,	%rax
    mov       %rax,	[%r12]
    cmp       %rax,	16
    jnz       L2090
    sub       %rsp,	8
    push      0
    push      0
    push      0
    mov       %rcx,	%rsi
    mov       %rdx,	%rsi
    mov       %r8,	1
    xor       %r9d,	%r9d
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rcx,	14
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rax,	8
    mov       [%r12],	%rax
    jmp       L2089
L2090:
    mov       %rcx,	%rsi
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rax,	[%r12]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      mc_auxmcl.mulimm
    mov       %rax,	1
    mov       [%r12],	%rax
L2089:
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.pclloc]
    mov       %r11,	%r13
    mov       [%r10 + %r11-1],	%al
    mov       %al,	%dil
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	%r13
    mov       [%r10 + %r11-1],	%al
    mov       %al,	10
    lea       %r10,	[%rip+mc_decls.pclmode]
    mov       %r11,	%r13
    mov       [%r10 + %r11-1],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+mc_decls.pclopnd]
    mov       %r11,	%r13
    mov       [%r10 + %r11*8-8],	%rax
    mov       %rax,	%rdi
L2085:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.dolea
mc_auxmcl.dolea:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    movzx     %rax,	byte ptr[%rbx+11]
    movzx     %r10,	word ptr[%rbx+8]
    shr       %r10,	12
    and       %r10,	15
    cmp       %r10,	%rax
    jnz       L2095
    movsxd    %rax,	dword ptr[%rbx+12]
    cmp       %rax,	%r10
    jnz       L2095
    test      %rax,	%rax
    jnz       L2095
    mov       %rax,	1
    jmp       L2096
L2095:
    xor       %eax,	%eax
L2096:
    test      %rax,	%rax
    setnz     %al
    movzx     %eax,	%al
    test      %ax,	%ax
    jz        L2094
    movzx     %rax,	byte ptr[%rbx+10]
    movzx     %r10,	byte ptr[%rdi+10]
    cmp       %rax,	%r10
    jz        L2093
L2094:
    mov       %rcx,	14
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L2093:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_binto
mc_auxmcl.do_binto:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jg        L2099
    mov       %rcx,	%rsi
    mov       %rdx,	%r13
    call      mc_auxmcl.do_binto_float
    jmp       L2097
L2099:
    movzx     %rax,	byte ptr[%rsi+3]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rsi+3]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    mov       %rcx,	%r12
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
L2097:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_binto_float
mc_auxmcl.do_binto_float:
#?>>
    .set mc_auxmcl.do_binto_float.p, 48
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rdx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      mc_stackmcl.pushpcl_reg
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    sub       %r10,	2
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rsi,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rsi
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    dec       %rax
    mov       %r10,	%r12
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rsi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_shiftnto
mc_auxmcl.do_shiftnto:
#?>>
    .set mc_auxmcl.do_shiftnto.p, 40
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rdx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-2]
    test      %rax,	%rax
    jnz       L2103
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	[%rip+mc_decls.noperands]
    mov       %rax,	[%rax + %r10*8-16]
    movzx     %rax,	byte ptr[%rax+1]
    cmp       %rax,	4
    jnz       L2103
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	[%rip+mc_decls.noperands]
    mov       %rax,	[%rax + %r10*8-16]
    mov       %rax,	[%rax+8]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	%rsi
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L2102
L2103:
    mov       %al,	[%rip+pc_decls.r10used]
    test      %al,	%al
    jz        L2105
    mov       %rcx,	11
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	12
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L2105:
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	3
    mov       %r8,	11
    call      mc_stackmcl.loadparam
    mov       %rbx,	%rax
    mov       %rcx,	%rsi
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    mov       %al,	[%rip+pc_decls.r10used]
    test      %al,	%al
    jz        L2107
    mov       %rcx,	11
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	13
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L2107:
L2102:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_divrem
mc_auxmcl.do_divrem:
#?>>
    .set mc_auxmcl.do_divrem.issigned, 80
    .set mc_auxmcl.do_divrem.isdiv, 88
    .set mc_auxmcl.do_divrem.shifts, -8
    .set mc_auxmcl.do_divrem.fdivto, -16
    .set mc_auxmcl.do_divrem.locyy, -24
    .set mc_auxmcl.do_divrem.loczz, -32
    .set mc_auxmcl.do_divrem.$T1, -40
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	72
    mov       %r15,	%rcx
    mov       [%rbp+80],	%rdx
    mov       [%rbp+88],	%r8
#---------------
    xor       %eax,	%eax
    mov       [%rbp + mc_auxmcl.do_divrem.fdivto],	%al
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       [%rbp + mc_auxmcl.do_divrem.locyy],	%rax
    mov       %rax,	[%rip+mc_decls.noperands]
    mov       [%rbp + mc_auxmcl.do_divrem.loczz],	%rax
    movzx     %rax,	byte ptr[%r15]
    cmp       %rax,	94
    jz        L2111
    cmp       %rax,	95
    jnz       L2110
L2111:
    mov       %rax,	[%rbp + mc_auxmcl.do_divrem.locyy]
    mov       %r10,	[%rbp + mc_auxmcl.do_divrem.loczz]
    mov       [%rbp + mc_auxmcl.do_divrem.loczz],	%rax
    mov       [%rbp + mc_auxmcl.do_divrem.locyy],	%r10
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rbp + mc_auxmcl.do_divrem.locyy]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    mov       %al,	1
    mov       [%rbp + mc_auxmcl.do_divrem.fdivto],	%al
    mov       %rcx,	%rdi
    mov       %rdx,	8
    call      mc_libmcl.changeopndsize
    mov       %rcx,	12
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mc_stackmcl.makeopndind
    mov       %rsi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    movzx     %r10,	byte ptr[%rdi+10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_libmcl.mgenreg
    mov       %rdi,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
    jmp       L2109
L2110:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rbp + mc_auxmcl.do_divrem.locyy]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
L2109:
    mov       %rcx,	[%rbp + mc_auxmcl.do_divrem.loczz]
    call      mc_stackmcl.isimmload
    mov       %r12,	%rax
    test      %r12,	%r12
    jz        L2113
    mov       %rax,	[%rbp + mc_auxmcl.do_divrem.isdiv]
    cmp       %rax,	1
    jnz       L2113
    mov       %r14,	[%r12+8]
    mov       %rax,	%r14
    test      %rax,	%rax
    jz        L2115
    cmp       %rax,	1
    jz        L2116
    jmp       L2117
L2115:
    lea       %rcx,	[%rip+L8607]
    lea       %rdx,	[%rip+L8608]
    call      pc_api.merror
    jmp       L2114
L2116:
    call      mc_stackmcl.poppcl
    jmp       L2108
L2117:
    mov       %rcx,	%r14
    call      mc_libmcl.ispoweroftwo
    mov       [%rbp + mc_auxmcl.do_divrem.shifts],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.do_divrem.shifts]
    test      %rax,	%rax
    jz        L2119
    mov       %al,	[%rbp + mc_auxmcl.do_divrem.fdivto]
    test      %al,	%al
    jnz       L2119
    mov       %rcx,	[%rbp + mc_auxmcl.do_divrem.shifts]
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       [%rbp + mc_auxmcl.do_divrem.$T1],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.do_divrem.issigned]
    test      %rax,	%rax
    jz        L2121
    mov       %rax,	44
    jmp       L2120
L2121:
    mov       %rax,	45
L2120:
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    mov       %r8,	[%rbp + mc_auxmcl.do_divrem.$T1]
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    jmp       L2108
L2119:
L2114:
L2113:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rbp + mc_auxmcl.do_divrem.loczz]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    call      mc_auxmcl.saverdx
    mov       %rcx,	[%rbp + mc_auxmcl.do_divrem.locyy]
    mov       %rdx,	[%rbp + mc_auxmcl.do_divrem.loczz]
    call      mc_auxmcl.fixdivopnds
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rbp + mc_auxmcl.do_divrem.loczz]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    mov       %rax,	[%rbp + mc_auxmcl.do_divrem.issigned]
    test      %rax,	%rax
    jz        L2123
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.psize]
    movzx     %r10,	byte ptr[%r10 + %rax]
    cmp       %r10,	8
    jz        L2125
    cmp       %r10,	4
    jz        L2126
    cmp       %r10,	2
    jz        L2127
    jmp       L2128
L2125:
    mov       %rax,	57
    jmp       L2124
L2126:
    mov       %rax,	56
    jmp       L2124
L2127:
    mov       %rax,	55
    jmp       L2124
L2128:
    lea       %rcx,	[%rip+L8609]
    lea       %rdx,	[%rip+L8610]
    call      pc_api.merror
    xor       %eax,	%eax
L2124:
    mov       %r13,	%rax
    mov       %rcx,	%r13
    xor       %edx,	%edx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %r13,	36
    jmp       L2122
L2123:
    mov       %rcx,	12
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	%rax
    call      mc_libmcl.clearreg
    mov       %r13,	37
L2122:
    mov       %rcx,	%r13
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rax,	[%rbp + mc_auxmcl.do_divrem.isdiv]
    test      %rax,	%rax
    jz        L2130
    cmp       %rax,	2
    jz        L2131
    jmp       L2132
L2130:
    mov       %rcx,	12
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       [%rbp + mc_auxmcl.do_divrem.$T1],	%rax
    mov       %rcx,	1
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	27
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.do_divrem.$T1]
    call      mc_libmcl.genmc
    jmp       L2129
L2131:
    mov       %rcx,	12
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	27
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	2
    call      mc_stackmcl.swapopndregs
    mov       %rcx,	[%rbp + mc_auxmcl.do_divrem.locyy]
    mov       %rdx,	[%rbp + mc_auxmcl.do_divrem.loczz]
    call      mc_stackmcl.swapopnds
L2132:
L2129:
    call      mc_auxmcl.restorerdx
    mov       %al,	[%rbp + mc_auxmcl.do_divrem.fdivto]
    test      %al,	%al
    jz        L2134
    mov       %rcx,	6
    call      mc_stackmcl.getworkregm
    mov       %rbx,	%rax
    mov       %rcx,	13
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rbp + mc_auxmcl.do_divrem.locyy]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       [%rbp + mc_auxmcl.do_divrem.$T1],	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      mc_stackmcl.makeopndind
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.do_divrem.$T1]
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
L2134:
    mov       %rax,	[%rbp + mc_auxmcl.do_divrem.isdiv]
    cmp       %rax,	2
    jz        L2136
    call      mc_stackmcl.poppcl
L2136:
L2108:
#---------------
    add       %rsp,	72
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.fixdivopnds
mc_auxmcl.fixdivopnds:
#?>>
    .set mc_auxmcl.fixdivopnds.$T1, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %r14,	%rcx
    mov       %r15,	%rdx
#---------------
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%r14
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rdi,	%rax
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%r15
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rbx,	%rax
    cmp       %rdi,	1
    jz        L2137
L2139:
    mov       %rcx,	%r14
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %r12,	%rax
    mov       %rcx,	%r15
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %r13,	%rax
    cmp       %rbx,	1
    jnz       L2141
    mov       %rcx,	27
    mov       %rdx,	%r12
    mov       %r8,	%r13
    call      mc_libmcl.genmc
    mov       %rcx,	%r14
    mov       %rdx,	%r15
    call      mc_stackmcl.swapopnds
    jmp       L2137
L2141:
    lea       %rax,	[%rip+mc_decls.regset]
    movzx     %rax,	byte ptr[%rax]
    test      %rax,	%rax
    jnz       L2143
    mov       %rcx,	1
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	27
    mov       %rdx,	%rax
    mov       %r8,	%r12
    call      mc_libmcl.genmc
    xor       %eax,	%eax
    lea       %r10,	[%rip+mc_decls.regset]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	%r14
    mov       [%r10 + %r11-1],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.regset]
    mov       [%r10],	%al
    jmp       L2137
L2143:
    mov       %rsi,	[%rip+mc_decls.noperands]
    cmp       %rsi,	1
    jl        L2147
L2144:
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	1
    jnz       L2149
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	1
    jz        L2146
L2149:
    dec       %rsi
    cmp       %rsi,	1
    jge       L2144
L2147:
    jmp       L2137
L2146:
    mov       %rcx,	%r14
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       [%rbp + mc_auxmcl.fixdivopnds.$T1],	%rax
    mov       %rcx,	1
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	27
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.fixdivopnds.$T1]
    call      mc_libmcl.genmc
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%r14
    lea       %rax,	[%rax + %r10-1]
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	%rsi
    lea       %r10,	[%r10 + %r11-1]
    mov       %r11b,	[%rax]
    mov       %r9b,	[%r10]
    mov       [%r10],	%r11b
    mov       [%rax],	%r9b
L2137:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.saverdx
mc_auxmcl.saverdx:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    mov       %al,	[%rip+pc_decls.r11used]
    test      %al,	%al
    jz        L2152
    mov       %rcx,	12
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	12
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L2152:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_auxmcl.restorerdx
mc_auxmcl.restorerdx:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    mov       %al,	[%rip+pc_decls.r11used]
    test      %al,	%al
    jz        L2155
    mov       %rcx,	12
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	13
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L2155:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_auxmcl.clearblock
mc_auxmcl.clearblock:
#?>>
    .set mc_auxmcl.clearblock.ax, 64
    .set mc_auxmcl.clearblock.n, 72
    .set mc_auxmcl.clearblock.countreg, -8
    .set mc_auxmcl.clearblock.av_1, -16
    .set mc_auxmcl.clearblock.i, -24
    .set mc_auxmcl.clearblock.$T1, -32
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	64
    mov       [%rbp+64],	%rcx
    mov       [%rbp+72],	%rdx
#---------------
    mov       %rax,	[%rbp + mc_auxmcl.clearblock.n]
    mov       %r10,	8
    cqo       
    idiv      %r10
    xchg      %rax,	%rdx
    mov       %r13,	%rax
    mov       %rax,	%r13
    sub       [%rbp + mc_auxmcl.clearblock.n],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.clearblock.n]
    sar       %rax,	3
    mov       %rsi,	%rax
    mov       %rcx,	6
    call      mc_stackmcl.getworkregm
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    call      mc_libmcl.clearreg
    xor       %r14,	%r14
    mov       %rax,	%rsi
    cmp       %rax,	1
    jl        L2158
    cmp       %rax,	8
    jg        L2158
    mov       %rcx,	[%rbp + mc_auxmcl.clearblock.ax]
    mov       %rdx,	8
    call      mc_libmcl.changeopndsize
    mov       [%rbp + mc_auxmcl.clearblock.ax],	%rax
    mov       [%rbp + mc_auxmcl.clearblock.av_1],	%rsi
    mov       %rax,	[%rbp + mc_auxmcl.clearblock.av_1]
    cmp       %rax,	0
    jle       L2161
L2159:
    mov       %rcx,	[%rbp + mc_auxmcl.clearblock.ax]
    mov       %rdx,	%r14
    xor       %r8d,	%r8d
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rax,	8
    add       %r14,	%rax
    dec       qword ptr[%rbp + mc_auxmcl.clearblock.av_1]
    jnz       L2159
L2161:
    jmp       L2157
L2158:
    test      %rsi,	%rsi
    jz        L2162
    mov       %rax,	%rsi
    and       %rax,	3
    jz        L2164
    call      mc_stackmcl.getworkireg
    mov       %r10,	%rax
    mov       [%rbp + mc_auxmcl.clearblock.countreg],	%r10
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rbx,	%rax
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %r12,	[%rip+pc_api.mlabelno]
    mov       %rcx,	[%rbp + mc_auxmcl.clearblock.ax]
    call      mc_stackmcl.makesimpleaddr
    mov       [%rbp + mc_auxmcl.clearblock.ax],	%rax
    mov       %rcx,	%rsi
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	%r12
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	11
    mov       %rdx,	[%rbp + mc_auxmcl.clearblock.ax]
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rcx,	8
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       [%rbp + mc_auxmcl.clearblock.$T1],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.clearblock.ax]
    movzx     %rax,	byte ptr[%rax+10]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	28
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.clearblock.$T1]
    call      mc_libmcl.genmc
    mov       %rcx,	53
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	%r12
    call      mc_libmcl.mgenlabel
    mov       %rcx,	26
    mov       %rdx,	5
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    xor       %r14,	%r14
    jmp       L2163
L2164:
    call      mc_stackmcl.getworkireg
    mov       %r10,	%rax
    mov       [%rbp + mc_auxmcl.clearblock.countreg],	%r10
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rbx,	%rax
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %r12,	[%rip+pc_api.mlabelno]
    mov       %rcx,	[%rbp + mc_auxmcl.clearblock.ax]
    call      mc_stackmcl.makesimpleaddr
    mov       [%rbp + mc_auxmcl.clearblock.ax],	%rax
    mov       %rax,	%rsi
    sar       %rax,	2
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	%r12
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rax,	1
    mov       [%rbp + mc_auxmcl.clearblock.i],	%rax
L2165:
    mov       %rcx,	[%rbp + mc_auxmcl.clearblock.ax]
    mov       %rdx,	%r14
    xor       %r8d,	%r8d
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rax,	8
    add       %r14,	%rax
    mov       %rax,	[%rbp + mc_auxmcl.clearblock.i]
    inc       %rax
    mov       [%rbp + mc_auxmcl.clearblock.i],	%rax
    cmp       %rax,	4
    jle       L2165
    mov       %rcx,	32
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       [%rbp + mc_auxmcl.clearblock.$T1],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.clearblock.ax]
    movzx     %rax,	byte ptr[%rax+10]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	28
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.clearblock.$T1]
    call      mc_libmcl.genmc
    mov       %rcx,	53
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	%r12
    call      mc_libmcl.mgenlabel
    mov       %rcx,	26
    mov       %rdx,	5
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    xor       %r14,	%r14
L2163:
L2162:
L2157:
    test      %r13,	%r13
    jz        L2169
    mov       [%rbp + mc_auxmcl.clearblock.n],	%r13
    mov       %rax,	[%rbp + mc_auxmcl.clearblock.n]
    cmp       %rax,	4
    jl        L2171
    mov       %rcx,	%rdi
    mov       %rdx,	4
    call      mc_libmcl.changeopndsize
    mov       %rdi,	%rax
    mov       %rcx,	[%rbp + mc_auxmcl.clearblock.ax]
    mov       %rdx,	%r14
    mov       %r8,	4
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rax,	4
    sub       [%rbp + mc_auxmcl.clearblock.n],	%rax
    mov       %rax,	4
    add       %r14,	%rax
L2171:
    mov       %rax,	[%rbp + mc_auxmcl.clearblock.n]
    cmp       %rax,	2
    jl        L2173
    mov       %rcx,	%rdi
    mov       %rdx,	2
    call      mc_libmcl.changeopndsize
    mov       %rdi,	%rax
    mov       %rcx,	[%rbp + mc_auxmcl.clearblock.ax]
    mov       %rdx,	%r14
    mov       %r8,	2
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rax,	2
    sub       [%rbp + mc_auxmcl.clearblock.n],	%rax
    mov       %rax,	2
    add       %r14,	%rax
L2173:
    mov       %rax,	[%rbp + mc_auxmcl.clearblock.n]
    cmp       %rax,	1
    jnz       L2175
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      mc_libmcl.changeopndsize
    mov       %rdi,	%rax
    mov       %rcx,	[%rbp + mc_auxmcl.clearblock.ax]
    mov       %rdx,	%r14
    mov       %r8,	1
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
L2175:
L2169:
#---------------
    add       %rsp,	64
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_blockdata
mc_auxmcl.do_blockdata:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r14,	%rcx
#---------------
    mov       %eax,	[%r14+4]
    mov       %rbx,	%rax
    test      %rbx,	%rbx
    jnz       L2178
    jmp       L2176
L2178:
    mov       %rax,	%rbx
    sar       %rax,	3
    mov       %rsi,	%rax
    mov       %rdi,	[%r14+8]
    mov       %r13,	%rsi
    cmp       %r13,	0
    jle       L2181
L2179:
    mov       %rax,	%rdi
    add       %rdi,	8
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	119
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    dec       %r13
    jnz       L2179
L2181:
    mov       %rax,	%rsi
    shl       %rax,	3
    mov       %r10,	%rbx
    sub       %r10,	%rax
    mov       %r12,	%r10
    test      %r12,	%r12
    jz        L2183
    mov       %rcx,	%rdi
    mov       %rdx,	%r12
    mov       %r8,	66
    call      mc_auxmcl.genstring_db
L2183:
    lea       %rcx,	[%rip+L8611]
    call      mc_libmcl.mgencomment
L2176:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.copyblock
mc_auxmcl.copyblock:
#?>>
    .set mc_auxmcl.copyblock.n, 88
    .set mc_auxmcl.copyblock.savedest, 96
    .set mc_auxmcl.copyblock.oddbytes, -8
    .set mc_auxmcl.copyblock.offset, -16
    .set mc_auxmcl.copyblock.axreg, -24
    .set mc_auxmcl.copyblock.saved, -32
    .set mc_auxmcl.copyblock.av_1, -40
    .set mc_auxmcl.copyblock.$T1, -48
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	88
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       [%rbp+88],	%r8
    mov       [%rbp+96],	%r9
#---------------
    xor       %eax,	%eax
    mov       [%rbp + mc_auxmcl.copyblock.saved],	%al
    mov       %rax,	[%rbp + mc_auxmcl.copyblock.n]
    cmp       %rax,	16
    jnz       L2186
    mov       %rcx,	2
    call      mc_stackmcl.getworkregm
    mov       %rdi,	%rax
    mov       %rcx,	91
    mov       %rdx,	%rdi
    mov       %r8,	%r14
    call      mc_libmcl.genmc
    mov       %rcx,	91
    mov       %rdx,	%r13
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    jmp       L2184
L2186:
    mov       %rax,	[%rbp + mc_auxmcl.copyblock.n]
    mov       %r10,	8
    cqo       
    idiv      %r10
    xchg      %rax,	%rdx
    mov       [%rbp + mc_auxmcl.copyblock.oddbytes],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.copyblock.oddbytes]
    sub       [%rbp + mc_auxmcl.copyblock.n],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.copyblock.n]
    sar       %rax,	3
    mov       %rsi,	%rax
    mov       %rcx,	6
    call      mc_stackmcl.getworkregm
    mov       %rdi,	%rax
    xor       %eax,	%eax
    mov       [%rbp + mc_auxmcl.copyblock.offset],	%rax
    mov       %rax,	%rsi
    cmp       %rax,	1
    jl        L2188
    cmp       %rax,	4
    jg        L2188
    mov       %rcx,	%r13
    mov       %rdx,	8
    call      mc_libmcl.changeopndsize
    mov       %r13,	%rax
    mov       %rcx,	%r14
    mov       %rdx,	8
    call      mc_libmcl.changeopndsize
    mov       %r14,	%rax
    mov       [%rbp + mc_auxmcl.copyblock.av_1],	%rsi
    mov       %rax,	[%rbp + mc_auxmcl.copyblock.av_1]
    cmp       %rax,	0
    jle       L2191
L2189:
    mov       %rcx,	%r14
    mov       %rdx,	[%rbp + mc_auxmcl.copyblock.offset]
    xor       %r8d,	%r8d
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + mc_auxmcl.copyblock.offset]
    xor       %r8d,	%r8d
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rax,	8
    add       [%rbp + mc_auxmcl.copyblock.offset],	%rax
    dec       qword ptr[%rbp + mc_auxmcl.copyblock.av_1]
    jnz       L2189
L2191:
    jmp       L2187
L2188:
    test      %rsi,	%rsi
    jz        L2192
    mov       %rcx,	6
    call      mc_stackmcl.getworkregm
    mov       %rbx,	%rax
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %r12,	[%rip+pc_api.mlabelno]
    mov       %rax,	[%rbp + mc_auxmcl.copyblock.savedest]
    test      %rax,	%rax
    jz        L2194
    movzx     %rax,	byte ptr[%r13+10]
    mov       [%rbp + mc_auxmcl.copyblock.axreg],	%rax
    mov       %rcx,	[%rbp + mc_auxmcl.copyblock.axreg]
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	12
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %al,	1
    mov       [%rbp + mc_auxmcl.copyblock.saved],	%al
L2194:
    mov       %rcx,	%r13
    call      mc_stackmcl.makesimpleaddr
    mov       %r13,	%rax
    mov       %rcx,	%r14
    call      mc_stackmcl.makesimpleaddr
    mov       %r14,	%rax
    lea       %rax,	[%r13+8]
    mov       %r10w,	8
    mov       %r15w,	[%rax]
    mov       %r11,	-32
    and       %r15w,	%r11w
    or        %r15w,	%r10w
    mov       [%rax],	%r15w
    mov       %rcx,	%rsi
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	%r12
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%r14
    call      mc_libmcl.genmc
    mov       %rcx,	11
    mov       %rdx,	%r13
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rcx,	8
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       [%rbp + mc_auxmcl.copyblock.$T1],	%rax
    movzx     %rax,	byte ptr[%r13+10]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	28
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.copyblock.$T1]
    call      mc_libmcl.genmc
    mov       %rcx,	8
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       [%rbp + mc_auxmcl.copyblock.$T1],	%rax
    movzx     %rax,	byte ptr[%r14+10]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	28
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.copyblock.$T1]
    call      mc_libmcl.genmc
    mov       %rcx,	53
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	%r12
    call      mc_libmcl.mgenlabel
    mov       %rcx,	26
    mov       %rdx,	5
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    xor       %eax,	%eax
    mov       [%rbp + mc_auxmcl.copyblock.offset],	%rax
L2192:
L2187:
    mov       %rax,	[%rbp + mc_auxmcl.copyblock.oddbytes]
    test      %rax,	%rax
    jz        L2196
    mov       %rax,	[%rbp + mc_auxmcl.copyblock.oddbytes]
    mov       [%rbp + mc_auxmcl.copyblock.n],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.copyblock.n]
    cmp       %rax,	4
    jl        L2198
    mov       %rcx,	%rdi
    mov       %rdx,	4
    call      mc_libmcl.changeopndsize
    mov       %rdi,	%rax
    mov       %rcx,	%r14
    mov       %rdx,	[%rbp + mc_auxmcl.copyblock.offset]
    mov       %r8,	4
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + mc_auxmcl.copyblock.offset]
    mov       %r8,	4
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rax,	4
    sub       [%rbp + mc_auxmcl.copyblock.n],	%rax
    mov       %rax,	4
    add       [%rbp + mc_auxmcl.copyblock.offset],	%rax
L2198:
    mov       %rax,	[%rbp + mc_auxmcl.copyblock.n]
    cmp       %rax,	2
    jl        L2200
    mov       %rcx,	%rdi
    mov       %rdx,	2
    call      mc_libmcl.changeopndsize
    mov       %rdi,	%rax
    mov       %rcx,	%r14
    mov       %rdx,	[%rbp + mc_auxmcl.copyblock.offset]
    mov       %r8,	2
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + mc_auxmcl.copyblock.offset]
    mov       %r8,	2
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rax,	2
    sub       [%rbp + mc_auxmcl.copyblock.n],	%rax
    mov       %rax,	2
    add       [%rbp + mc_auxmcl.copyblock.offset],	%rax
L2200:
    mov       %rax,	[%rbp + mc_auxmcl.copyblock.n]
    cmp       %rax,	1
    jnz       L2202
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      mc_libmcl.changeopndsize
    mov       %rdi,	%rax
    mov       %rcx,	%r14
    mov       %rdx,	[%rbp + mc_auxmcl.copyblock.offset]
    mov       %r8,	1
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + mc_auxmcl.copyblock.offset]
    mov       %r8,	1
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
L2202:
L2196:
    mov       %al,	[%rbp + mc_auxmcl.copyblock.saved]
    test      %al,	%al
    jz        L2204
    mov       %rcx,	[%rbp + mc_auxmcl.copyblock.axreg]
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	13
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L2204:
L2184:
#---------------
    add       %rsp,	88
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.genstringtable
mc_auxmcl.genstringtable:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rax,	[%rip+mc_decls.cstringlist]
    test      %rax,	%rax
    jz        L2205
L2207:
    lea       %rcx,	[%rip+L8612]
    call      mc_libmcl.mgencomment
    mov       %rcx,	73
    mov       %rdx,	8
    call      mc_libmcl.setsegment
    mov       %rax,	[%rip+mc_decls.kk0used]
    test      %rax,	%rax
    jz        L2209
    mov       %rcx,	[%rip+mc_decls.kk0used]
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    xor       %ecx,	%ecx
    call      mc_auxmcl.gendb
L2209:
    mov       %rdi,	[%rip+mc_decls.cstringlist]
    jmp       L2213
L2210:
    mov       %rax,	[%rdi+16]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rax,	[%rdi+24]
    mov       %r10,	[%rdi]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    mov       %r8,	1
    call      mc_auxmcl.genstring_db
    mov       %rdi,	[%rdi+8]
L2213:
    test      %rdi,	%rdi
    jnz       L2210
L2205:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.genstring_db
mc_auxmcl.genstring_db:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       %r15,	%r8
#---------------
    cmp       %r14,	-1
    jnz       L2216
    mov       %rcx,	%r13
    call      strlen
    mov       %r14,	%rax
L2216:
    test      %r14,	%r14
    jnz       L2218
    xor       %ecx,	%ecx
    call      mc_auxmcl.gendb
    jmp       L2214
L2218:
    xor       %rbx,	%rbx
    mov       %rax,	%r14
    mov       %r12,	%rax
    cmp       %r12,	0
    jle       L2221
L2219:
    mov       %rax,	%r13
    inc       %r13
    movzx     %rax,	byte ptr[%rax]
    mov       %rdi,	%rax
    cmp       %rdi,	32
    jl        L2224
    cmp       %rdi,	127
    jge       L2224
    mov       %rax,	%rdi
    cmp       %rax,	34
    jz        L2225
    cmp       %rax,	92
    jnz       L2223
L2225:
L2224:
    test      %rbx,	%rbx
    jz        L2227
    mov       %rcx,	%rsi
    mov       %rdx,	%rbx
    call      mc_auxmcl.gendbstring
    xor       %rbx,	%rbx
L2227:
    mov       %rcx,	%rdi
    call      mc_auxmcl.gendb
    jmp       L2222
L2223:
    test      %rbx,	%rbx
    jnz       L2229
    mov       %rbx,	1
    lea       %rax,	[%r13-1]
    mov       %rsi,	%rax
    jmp       L2228
L2229:
    inc       %rbx
L2228:
L2222:
    dec       %r12
    jnz       L2219
L2221:
    test      %rbx,	%rbx
    jz        L2231
    mov       %rcx,	%rsi
    mov       %rdx,	%rbx
    call      mc_auxmcl.gendbstring
L2231:
    test      %r15,	%r15
    jnz       L2233
    xor       %ecx,	%ecx
    call      mc_auxmcl.gendb
L2233:
L2214:
#---------------
    add       %rsp,	48
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.gendb
mc_auxmcl.gendb:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	116
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.gendbstring
mc_auxmcl.gendbstring:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mc_libmcl.mgenstring
    mov       %rcx,	120
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.gendq
mc_auxmcl.gendq:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	119
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.genrealtable
mc_auxmcl.genrealtable:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rax,	[%rip+mc_decls.creallist]
    test      %rax,	%rax
    jnz       L2239
    mov       %rax,	[%rip+mc_decls.cr32list]
    test      %rax,	%rax
    jz        L2237
L2239:
    lea       %rcx,	[%rip+L8613]
    call      mc_libmcl.mgencomment
    mov       %rcx,	73
    mov       %rdx,	8
    call      mc_libmcl.setsegment
    mov       %rdi,	[%rip+mc_decls.creallist]
    jmp       L2243
L2240:
    mov       %rax,	[%rdi+16]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    movq      %XMM4,	[%rdi]
    comisd    %XMM4,	[%rip+L8614]
    jnz       L2245
    movq      %XMM4,	[%rdi]
    movq      %rax,	%XMM4
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	119
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L2244
L2245:
    movq      %XMM4,	[%rdi]
    movq      %rax,	%XMM4
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	119
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L2244:
    mov       %rdi,	[%rdi+8]
L2243:
    test      %rdi,	%rdi
    jnz       L2240
    lea       %rcx,	[%rip+L8615]
    call      mc_libmcl.mgencomment
    mov       %rdi,	[%rip+mc_decls.cr32list]
    jmp       L2249
L2246:
    mov       %rax,	[%rdi+16]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    movq      %XMM4,	[%rdi]
    comisd    %XMM4,	[%rip+L8616]
    jnz       L2251
    movq      %XMM4,	[%rdi]
    cvtsd2ss  %XMM4,	%XMM4
    movd      %eax,	%XMM4
    mov       %ecx,	%eax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	118
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L2250
L2251:
    movq      %XMM4,	[%rdi]
    movq      %XMM0,	%XMM4
    mov       %rdx,	1
    call      mc_libmcl.mgenrealimm
    mov       %rcx,	118
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L2250:
    mov       %rdi,	[%rdi+8]
L2249:
    test      %rdi,	%rdi
    jnz       L2246
L2237:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.genabsneg
mc_auxmcl.genabsneg:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    mov       %rax,	[%rip+mc_decls.lababs32]
    add       %rax,	[%rip+mc_decls.lababs64]
    add       %rax,	[%rip+mc_decls.labneg32]
    add       %rax,	[%rip+mc_decls.labneg64]
    test      %rax,	%rax
    jz        L2254
    mov       %rcx,	73
    mov       %rdx,	16
    call      mc_libmcl.setsegment
L2254:
    mov       %rax,	[%rip+mc_decls.lababs32]
    test      %rax,	%rax
    jz        L2256
    lea       %rcx,	[%rip+L8617]
    call      mc_libmcl.mgencomment
    mov       %rcx,	[%rip+mc_decls.lababs32]
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	9223372034707292159
    call      mc_auxmcl.gendq
    mov       %rcx,	9223372034707292159
    call      mc_auxmcl.gendq
L2256:
    mov       %rax,	[%rip+mc_decls.lababs64]
    test      %rax,	%rax
    jz        L2258
    lea       %rcx,	[%rip+L8618]
    call      mc_libmcl.mgencomment
    mov       %rcx,	[%rip+mc_decls.lababs64]
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	9223372036854775807
    call      mc_auxmcl.gendq
    mov       %rcx,	9223372036854775807
    call      mc_auxmcl.gendq
L2258:
    mov       %rax,	[%rip+mc_decls.labneg32]
    test      %rax,	%rax
    jz        L2260
    lea       %rcx,	[%rip+L8619]
    call      mc_libmcl.mgencomment
    mov       %rcx,	[%rip+mc_decls.labneg32]
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	-9223372034707292160
    call      mc_auxmcl.gendq
    mov       %rcx,	-9223372034707292160
    call      mc_auxmcl.gendq
L2260:
    mov       %rax,	[%rip+mc_decls.labneg64]
    test      %rax,	%rax
    jz        L2262
    lea       %rcx,	[%rip+L8620]
    call      mc_libmcl.mgencomment
    mov       %rcx,	[%rip+mc_decls.labneg64]
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	-9223372036854775808
    call      mc_auxmcl.gendq
    mov       %rcx,	-9223372036854775808
    call      mc_auxmcl.gendq
L2262:
    mov       %rax,	[%rip+mc_decls.labzero]
    test      %rax,	%rax
    jz        L2264
    lea       %rcx,	[%rip+L8621]
    call      mc_libmcl.mgencomment
    mov       %rcx,	[%rip+mc_decls.labzero]
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    xor       %ecx,	%ecx
    call      mc_auxmcl.gendq
L2264:
    mov       %rax,	[%rip+mc_decls.labmask63]
    test      %rax,	%rax
    jz        L2266
    lea       %rcx,	[%rip+L8622]
    call      mc_libmcl.mgencomment
    mov       %rcx,	[%rip+mc_decls.labmask63]
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	9223372036854775807
    call      mc_auxmcl.gendq
    mov       %rcx,	[%rip+mc_decls.laboffset64]
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	4890909195324358656
    call      mc_auxmcl.gendq
L2266:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_auxmcl.do_maths
mc_auxmcl.do_maths:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    mov       %r9,	%rsi
    call      mc_auxmcl.do_callrts
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_host
mc_auxmcl.do_host:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    mov       %r8,	%rbx
    mov       %r9,	%rsi
    call      mc_auxmcl.do_callrts
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_callrts
mc_auxmcl.do_callrts:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
    mov       %r14,	%r9
#---------------
    mov       %rcx,	%r14
    call      mc_stackmcl.saveopnds
    xor       %rdi,	%rdi
    mov       %eax,	[%rip+mc_decls.mstackdepth]
    and       %eax,	1
    test      %rax,	%rax
    jz        L2271
    mov       %rcx,	1
    call      mc_libmcl.pushslots
    mov       %rdi,	1
L2271:
    mov       %rcx,	%r14
    xor       %edx,	%edx
    xor       %r8d,	%r8d
    mov       %r9,	1
    call      mc_auxmcl.do_pushlowargs
    mov       %rax,	[%rip+mc_decls.mstackdepth]
    test      %rax,	%rax
    jz        L2273
    mov       %rax,	4
    add       %rdi,	%rax
    mov       %rcx,	4
    call      mc_libmcl.pushslots
    jmp       L2272
L2273:
    mov       %al,	1
    mov       [%rip+pc_decls.localshadow],	%al
L2272:
    test      %r12,	%r12
    jz        L2275
    mov       %rcx,	%r12
    call      mc_libmcl.mgenextname
    mov       %rcx,	21
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L2274
L2275:
    mov       %rcx,	%r13
    call      mc_libmcl.mgenmemaddr
    mov       %rcx,	21
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L2274:
    mov       %rbx,	%r14
    cmp       %rbx,	0
    jle       L2278
L2276:
    call      mc_stackmcl.poppcl
    dec       %rbx
    jnz       L2276
L2278:
    test      %rdi,	%rdi
    jz        L2280
    mov       %rcx,	%rdi
    call      mc_libmcl.popslots
L2280:
    mov       %rcx,	%rsi
    call      mc_auxmcl.do_getretvalue
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_max_int
mc_auxmcl.do_max_int:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    mov       %rcx,	42
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    mov       %rcx,	15
    mov       %rdx,	%rsi
    mov       %r8,	%rdi
    mov       %r9,	%rbx
    call      mc_libmcl.genmc_cond
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_max_float
mc_auxmcl.do_max_float:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    mov       %rcx,	%rsi
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_maxto_int
mc_auxmcl.do_maxto_int:
#?>>
    .set mc_auxmcl.do_maxto_int.mode, 64
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    mov       %rcx,	42
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %r12,	[%rip+pc_api.mlabelno]
    mov       %rcx,	%r12
    call      mc_libmcl.mgenlabel
    mov       %r10,	%rax
    mov       %rsi,	%r10
    mov       %rcx,	26
    mov       %rdx,	%r13
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    mov       %rcx,	9
    mov       %rdx,	%rsi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_maxto_real
mc_auxmcl.do_maxto_real:
#?>>
    .set mc_auxmcl.do_maxto_real.mode, 72
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	32
    mov       %r14,	%rcx
    mov       [%rbp+72],	%rdx
#---------------
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	[%rbp + mc_auxmcl.do_maxto_real.mode]
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_auxmcl.do_maxto_real.mode]
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rsi,	%rax
    mov       %rcx,	[%rbp + mc_auxmcl.do_maxto_real.mode]
    xor       %edx,	%edx
    call      mc_stackmcl.pushpcl_reg
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rax,	[%rbp + mc_auxmcl.do_maxto_real.mode]
    dec       %rax
    mov       %r10,	73
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %r13,	[%rip+pc_api.mlabelno]
    mov       %rcx,	%r13
    call      mc_libmcl.mgenlabel
    mov       %r10,	%rax
    mov       %r12,	%r10
    mov       %rcx,	26
    mov       %rdx,	%r14
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
    mov       %rcx,	9
    mov       %rdx,	%r12
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	32
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_negreal
mc_auxmcl.do_negreal:
#?>>
    .set mc_auxmcl.do_negreal.mode, 32
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    dec       %rax
    test      %rax,	%rax
    jz        L2287
    mov       %rax,	[%rip+mc_decls.labneg64]
    test      %rax,	%rax
    jnz       L2289
    call      mc_libmcl.mcreatefwdlabel
    mov       [%rip+mc_decls.labneg64],	%rax
L2289:
    mov       %rcx,	[%rip+mc_decls.labneg64]
    call      mc_libmcl.mgenlabelmem
    mov       %rcx,	77
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L2286
L2287:
    mov       %rax,	[%rip+mc_decls.labneg32]
    test      %rax,	%rax
    jnz       L2291
    call      mc_libmcl.mcreatefwdlabel
    mov       [%rip+mc_decls.labneg32],	%rax
L2291:
    mov       %rcx,	[%rip+mc_decls.labneg32]
    call      mc_libmcl.mgenlabelmem
    mov       %rcx,	76
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2286:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_absreal
mc_auxmcl.do_absreal:
#?>>
    .set mc_auxmcl.do_absreal.mode, 32
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    dec       %rax
    test      %rax,	%rax
    jz        L2294
    mov       %rax,	[%rip+mc_decls.lababs64]
    test      %rax,	%rax
    jnz       L2296
    call      mc_libmcl.mcreatefwdlabel
    mov       [%rip+mc_decls.lababs64],	%rax
L2296:
    mov       %rcx,	[%rip+mc_decls.lababs64]
    call      mc_libmcl.mgenlabelmem
    mov       %rcx,	79
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L2293
L2294:
    mov       %rax,	[%rip+mc_decls.lababs32]
    test      %rax,	%rax
    jnz       L2298
    call      mc_libmcl.mcreatefwdlabel
    mov       [%rip+mc_decls.lababs32],	%rax
L2298:
    mov       %rcx,	[%rip+mc_decls.lababs32]
    call      mc_libmcl.mgenlabelmem
    mov       %rcx,	78
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2293:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_loadbf_const
mc_auxmcl.do_loadbf_const:
#?>>
    .set mc_auxmcl.do_loadbf_const.p, 56
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    sub       %r10,	2
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    cmp       %r13,	63
    jnz       L2301
    mov       %rcx,	%r12
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	44
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L2300
L2301:
    test      %r12,	%r12
    jz        L2303
    mov       %rcx,	%r12
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	45
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2303:
    mov       %rax,	%r13
    sub       %rax,	%r12
    inc       %rax
    mov       %r10,	-1
    mov       %cl,	%al
    shl       %r10,	%cl
    not       %r10
    mov       %rsi,	%r10
    cmp       %rsi,	2147483647
    ja        L2305
    mov       %rcx,	%rsi
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	38
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L2304
L2305:
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    mov       %rcx,	%rsi
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	38
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L2304:
L2300:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_loadbf_var
mc_auxmcl.do_loadbf_var:
#?>>
    .set mc_auxmcl.do_loadbf_var.p, 16
#?]]
    sub       %rsp,	40
#---------------
    lea       %rcx,	[%rip+L8623]
    lea       %rdx,	[%rip+L8624]
    call      pc_api.merror
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_auxmcl.do_storebit
mc_auxmcl.do_storebit:
#?>>
    .set mc_auxmcl.do_storebit.p, 72
    .set mc_auxmcl.do_storebit.offset, -8
    .set mc_auxmcl.do_storebit.mask1s, -16
    .set mc_auxmcl.do_storebit.mask0s, -24
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	56
#---------------
    mov       %rcx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.isimmload
    mov       %r13,	%rax
    mov       %rax,	[%rip+mc_decls.noperands]
    sub       %rax,	2
    mov       %rcx,	%rax
    call      mc_stackmcl.isimmload
    mov       %r14,	%rax
    test      %r13,	%r13
    jz        L2309
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	3
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    mov       %r15,	[%r13+8]
    mov       %rax,	%r15
    sar       %rax,	3
    mov       [%rbp + mc_auxmcl.do_storebit.offset],	%rax
    mov       %rax,	7
    and       %r15,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	[%rbp + mc_auxmcl.do_storebit.offset]
    xor       %r8d,	%r8d
    call      mc_libmcl.applyoffset
    mov       %rdi,	%rax
    mov       %rax,	1
    mov       %cl,	%r15b
    shl       %rax,	%cl
    mov       [%rbp + mc_auxmcl.do_storebit.mask0s],	%al
    mov       %rax,	1
    mov       %cl,	%r15b
    shl       %rax,	%cl
    not       %rax
    mov       [%rbp + mc_auxmcl.do_storebit.mask1s],	%al
    test      %r14,	%r14
    jz        L2311
    mov       %rax,	[%r14+8]
    test      %rax,	%rax
    jnz       L2313
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    movzx     %r10,	byte ptr[%rbp + mc_auxmcl.do_storebit.mask1s]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_libmcl.mgenint
    mov       %rcx,	38
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L2312
L2313:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    movzx     %r10,	byte ptr[%rbp + mc_auxmcl.do_storebit.mask0s]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_libmcl.mgenint
    mov       %rcx,	39
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2312:
    jmp       L2310
L2311:
    mov       %rax,	[%rip+mc_decls.noperands]
    sub       %rax,	2
    mov       %rcx,	%rax
    mov       %rdx,	3
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    movzx     %r10,	byte ptr[%rbp + mc_auxmcl.do_storebit.mask1s]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_libmcl.mgenint
    mov       %rcx,	38
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    test      %r15,	%r15
    jz        L2315
    mov       %rcx,	%r15
    mov       %rdx,	3
    call      mc_libmcl.mgenint
    mov       %rcx,	43
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2315:
    mov       %rcx,	39
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L2310:
    jmp       L2308
L2309:
    test      %r14,	%r14
    jz        L2316
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    test      %r13,	%r13
    jnz       L2318
    mov       %rcx,	6
    call      mc_stackmcl.getworkregm
    mov       %rbx,	%rax
    mov       %rcx,	1
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	11
    mov       %rdx,	6
    call      mc_libmcl.mgenreg
    mov       %rsi,	%rax
    mov       %al,	[%rip+pc_decls.r10used]
    test      %al,	%al
    jz        L2320
    mov       %rcx,	12
    mov       %rdx,	%rsi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L2320:
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	10
    mov       %r8,	11
    call      mc_stackmcl.loadparam
    mov       %r12,	%rax
    mov       %rcx,	%rsi
    mov       %rdx,	1
    call      mc_libmcl.changeopndsize
    mov       %rcx,	43
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %al,	[%rip+pc_decls.r10used]
    test      %al,	%al
    jz        L2322
    mov       %rcx,	13
    mov       %rdx,	%rsi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L2322:
    mov       %rax,	[%r14+8]
    test      %rax,	%rax
    jnz       L2324
    mov       %rcx,	51
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	38
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    jmp       L2323
L2324:
    mov       %rcx,	39
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L2323:
    jmp       L2317
L2318:
    lea       %rcx,	[%rip+L8625]
    lea       %rdx,	[%rip+L8626]
    call      pc_api.merror
L2317:
    jmp       L2308
L2316:
    lea       %rcx,	[%rip+L8627]
    lea       %rdx,	[%rip+L8628]
    call      pc_api.merror
L2308:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	56
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_storebf
mc_auxmcl.do_storebf:
#?>>
    .set mc_auxmcl.do_storebf.p, 72
    .set mc_auxmcl.do_storebf.r, -8
    .set mc_auxmcl.do_storebf.mask, -16
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	56
    mov       [%rbp+72],	%rcx
#---------------
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    call      mc_stackmcl.isimmload
    mov       %r15,	%rax
    mov       %rcx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.isimmload
    mov       [%rbp + mc_auxmcl.do_storebf.r],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.do_storebf.r]
    cmp       %rax,	%r15
    jnz       L2327
    test      %rax,	%rax
    jnz       L2327
    lea       %rcx,	[%rip+L8629]
    lea       %rdx,	[%rip+L8630]
    call      pc_api.merror
L2327:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    sub       %r10,	3
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %r12,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    sub       %r10,	2
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    mov       %r13,	[%r15+8]
    mov       %rax,	[%rbp + mc_auxmcl.do_storebf.r]
    mov       %r14,	[%rax+8]
    mov       %rcx,	6
    call      mc_stackmcl.getworkregm
    mov       %rsi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rax
    call      mc_stackmcl.getworkregm
    mov       %rbx,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rax,	%r14
    sub       %rax,	%r13
    inc       %rax
    mov       %r10,	-1
    mov       %cl,	%al
    shl       %r10,	%cl
    not       %r10
    mov       %cl,	%r13b
    shl       %r10,	%cl
    not       %r10
    mov       [%rbp + mc_auxmcl.do_storebf.mask],	%r10
    mov       %rcx,	[%rbp + mc_auxmcl.do_storebf.mask]
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	11
    mov       %rdx,	%rsi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    test      %r13,	%r13
    jz        L2329
    mov       %rcx,	%r13
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	43
    mov       %rdx,	%r12
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2329:
    mov       %rax,	[%rbp + mc_auxmcl.do_storebf.p]
    mov       %eax,	[%rax+4]
    mov       %rcx,	%rsi
    mov       %rdx,	%rax
    call      mc_libmcl.changeopndsize
    mov       %rcx,	38
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	39
    mov       %rdx,	%rbx
    mov       %r8,	%r12
    call      mc_libmcl.genmc
    mov       %rax,	[%rbp + mc_auxmcl.do_storebf.p]
    mov       %eax,	[%rax+4]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      mc_libmcl.changeopndsize
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	56
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.gethostfn
mc_auxmcl.gethostfn:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
#---------------
    mov       %rax,	[%rip+pc_api.igethostfn]
    test      %rax,	%rax
    jnz       L2332
    cmp       %r13,	82
    jnz       L2335
L2334:
    lea       %rax,	[%rip+L8631]
    mov       %rbx,	%rax
    lea       %rax,	[%rip+L8632]
    mov       %rsi,	%rax
    jmp       L2333
L2335:
    xor       %rbx,	%rbx
L2333:
    test      %rbx,	%rbx
    jz        L2337
    mov       %r12,	[%rip+pc_decls.psymboltable]
    jmp       L2341
L2338:
    mov       %rax,	[%r12]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      mlib.eqstring
    test      %rax,	%rax
    jnz       L2344
    mov       %rax,	[%r12]
    mov       %rcx,	%rsi
    mov       %rdx,	%rax
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L2343
L2344:
    mov       %rax,	%r12
    jmp       L2330
L2343:
    mov       %r12,	[%r12+8]
L2341:
    test      %r12,	%r12
    jnz       L2338
L2337:
    lea       %rax,	[%rip+pc_tables.pclnames]
    mov       %r10,	%r13
    mov       %rax,	[%rax + %r10*8]
    lea       %rcx,	[%rip+L8633]
    mov       %rdx,	%rax
    call      pc_api.merror
L2332:
    mov       %rcx,	%r13
    mov       %rax,	[%rip+pc_api.igethostfn]
    call      %rax
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L2346
    lea       %rax,	[%rip+pc_tables.pclnames]
    mov       %r10,	%r13
    mov       %rax,	[%rax + %r10*8]
    lea       %rcx,	[%rip+L8634]
    mov       %rdx,	%rax
    call      pc_api.merror
L2346:
    mov       %rax,	%rdi
L2330:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.copyblockarg
mc_auxmcl.copyblockarg:
#?>>
    .set mc_auxmcl.copyblockarg.argno, 72
    .set mc_auxmcl.copyblockarg.$T3, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %r12,	%rcx
    mov       %r13,	%rdx
#---------------
    test      %r12,	%r12
    jnz       L2349
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8635]
    call      msys.m$print_str_nf
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L8636]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L2347
L2349:
    mov       %rcx,	%r13
    call      mc_libmcl.newblocktemp
    mov       %rdi,	%rax
    mov       %al,	1
    mov       [%rdi+92],	%al
    test      %r12,	%r12
    jz        L2351
    mov       %rcx,	6
    call      mc_stackmcl.getworkregm
    mov       %rsi,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      mc_libmcl.genmc
    jmp       L2350
L2351:
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	11
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rsi,	%rax
L2350:
    mov       %rcx,	6
    call      mc_stackmcl.getworkregm
    mov       %rbx,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       %rcx,	14
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rsi+10]
    mov       %rcx,	%rax
    mov       %rdx,	10
    xor       %r8d,	%r8d
    call      mc_libmcl.mgenireg
    mov       [%rbp + mc_auxmcl.copyblockarg.$T3],	%rax
    movzx     %rax,	byte ptr[%rbx+10]
    mov       %rcx,	%rax
    mov       %rdx,	10
    xor       %r8d,	%r8d
    call      mc_libmcl.mgenireg
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_auxmcl.copyblockarg.$T3]
    mov       %r8,	%r13
    mov       %r9,	1
    call      mc_auxmcl.copyblock
    test      %r12,	%r12
    jz        L2353
    mov       %rcx,	%rdi
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       %rcx,	14
    mov       %rdx,	%r12
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2353:
    xor       %ecx,	%ecx
    call      mc_stackmcl.freeworkregs
L2347:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.fixmain
mc_auxmcl.fixmain:
#?>>
    .set mc_auxmcl.fixmain.$T1, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
#---------------
    mov       %rdi,	[%rip+pc_decls.currfunc]
    mov       %rbx,	[%rdi+16]
    mov       %rsi,	[%rbx+16]
    lea       %rcx,	[%rip+L8637]
    mov       %rdx,	3
    call      pc_api.pc_makesymbol
    mov       %r12,	%rax
    mov       %al,	6
    mov       [%r12+82],	%al
    mov       %eax,	8
    mov       [%r12+84],	%eax
    lea       %rcx,	[%rip+L8638]
    mov       %rdx,	3
    call      pc_api.pc_makesymbol
    mov       %r13,	%rax
    mov       %al,	11
    mov       [%r13+82],	%al
    mov       %eax,	128
    mov       [%r13+84],	%eax
    mov       %rcx,	90
    mov       %rdx,	8
    call      mc_libmcl.setsegment
    mov       %rcx,	%r13
    call      mc_libmcl.mgenmemaddr
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	128
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	125
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	%r12
    call      mc_libmcl.mgenmemaddr
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	8
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	125
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	67
    mov       %rdx,	1
    call      mc_libmcl.setsegment
    mov       %rcx,	%r12
    call      pc_api.pc_addlocal
    mov       %rcx,	%r13
    call      pc_api.pc_addlocal
    xor       %eax,	%eax
    mov       [%rdi+16],	%rax
    mov       [%rsi+16],	%rax
    mov       [%rbx+16],	%rax
    xor       %eax,	%eax
    mov       [%rdi+112],	%al
    mov       %al,	4
    mov       [%rbx+72],	%al
    mov       %al,	1
    mov       [%rbx+92],	%al
    mov       %al,	4
    mov       [%rsi+72],	%al
    mov       %al,	4
    mov       [%rsi+92],	%al
    mov       %rcx,	%rsi
    call      pc_api.pc_addlocal
    mov       %rcx,	%rbx
    call      pc_api.pc_addlocal
    mov       %rcx,	1
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %r10,	%rax
    mov       %r14,	%r10
    mov       %rcx,	12
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	%r13
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       %rcx,	14
    mov       %rdx,	%r14
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %al,	1
    mov       [%r13+88],	%al
    mov       %rcx,	12
    mov       %rdx,	%r14
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	32
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	29
    mov       %rdx,	[%rip+mc_decls.dstackopnd]
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	%rbx
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       [%rbp + mc_auxmcl.fixmain.$T1],	%rax
    mov       %rcx,	11
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	14
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.fixmain.$T1]
    call      mc_libmcl.genmc
    mov       %al,	1
    mov       [%rbx+88],	%al
    mov       %rcx,	%rsi
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       [%rbp + mc_auxmcl.fixmain.$T1],	%rax
    mov       %rcx,	12
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	14
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.fixmain.$T1]
    call      mc_libmcl.genmc
    mov       %al,	1
    mov       [%rsi+88],	%al
    mov       %rcx,	%r12
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       [%rbp + mc_auxmcl.fixmain.$T1],	%rax
    mov       %rcx,	13
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	14
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.fixmain.$T1]
    call      mc_libmcl.genmc
    mov       %al,	1
    mov       [%r12+88],	%al
    mov       %rcx,	14
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	%rax
    call      mc_libmcl.clearreg
    lea       %rcx,	[%rip+L8639]
    call      mc_libmcl.mgenextname
    mov       %rcx,	21
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	48
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	29
    mov       %rdx,	[%rip+mc_decls.dstackopnd]
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rax,	[%rip+pc_decls.pcmdskip]
    test      %rax,	%rax
    jz        L2356
    mov       %rcx,	[%rip+pc_decls.pcmdskip]
    mov       %rdx,	9
    call      mc_libmcl.mgenint
    mov       [%rbp + mc_auxmcl.fixmain.$T1],	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       %rcx,	29
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.fixmain.$T1]
    call      mc_libmcl.genmc
    mov       %rax,	[%rip+pc_decls.pcmdskip]
    shl       %rax,	3
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       [%rbp + mc_auxmcl.fixmain.$T1],	%rax
    mov       %rcx,	%rsi
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       %rcx,	28
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.fixmain.$T1]
    call      mc_libmcl.genmc
L2356:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mclinit
mc_libmcl.mclinit:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r14,	%rcx
#---------------
    mov       %rax,	64
    cmp       %rax,	64
    jle       L2359
    lea       %rcx,	[%rip+L8640]
    call      mlib.abortprogram
L2359:
    mov       %rbx,	1
L2360:
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      mc_libmcl.mgenreg0
    lea       %r10,	[%rip+mc_decls.regtable]
    mov       %r11,	%rbx
    shl       %r11,	6
    lea       %r10,	[%r10 + %r11-64]
    mov       [%r10],	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	2
    call      mc_libmcl.mgenreg0
    lea       %r10,	[%rip+mc_decls.regtable]
    mov       %r11,	%rbx
    shl       %r11,	6
    lea       %r10,	[%r10 + %r11-64]
    mov       [%r10+8],	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	4
    call      mc_libmcl.mgenreg0
    lea       %r10,	[%rip+mc_decls.regtable]
    mov       %r11,	%rbx
    shl       %r11,	6
    lea       %r10,	[%r10 + %r11-64]
    mov       [%r10+24],	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	8
    call      mc_libmcl.mgenreg0
    lea       %r10,	[%rip+mc_decls.regtable]
    mov       %r11,	%rbx
    shl       %r11,	6
    lea       %r10,	[%r10 + %r11-64]
    mov       [%r10+56],	%rax
    inc       %rbx
    cmp       %rbx,	16
    jle       L2360
    mov       %r13,	-128
    mov       %rsi,	64
    cmp       %rsi,	-128
    jl        L2365
L2363:
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	3
    mov       %r8w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r8w,	%r11w
    or        %r8w,	%r10w
    mov       [%rax],	%r8w
    mov       %al,	15
    mov       [%rdi+10],	%al
    lea       %rax,	[%rdi+8]
    mov       %r10w,	8
    mov       %r8w,	[%rax]
    mov       %r11,	-32
    and       %r8w,	%r11w
    or        %r8w,	%r10w
    mov       [%rax],	%r8w
    mov       [%rdi+12],	%r13d
    mov       %rax,	%rdi
    lea       %r10,	[%rip+mc_decls.frameregtable]
    mov       %r11,	%r13
    mov       [%r10 + %r11*8+1024],	%rax
    inc       %r13
    cmp       %r13,	%rsi
    jle       L2363
L2365:
    mov       %rcx,	15
    mov       %rdx,	6
    call      mc_libmcl.mgenreg
    mov       [%rip+mc_decls.dframeopnd],	%rax
    mov       %rcx,	16
    mov       %rdx,	6
    call      mc_libmcl.mgenreg
    mov       [%rip+mc_decls.dstackopnd],	%rax
    call      mc_libmcl.initmcdest
    mov       %rcx,	67
    mov       %rdx,	1
    call      mc_libmcl.setsegment
    xor       %eax,	%eax
    mov       [%rip+mc_decls.lab_funcnametable],	%rax
    xor       %eax,	%eax
    mov       [%rip+mc_decls.lab_funcaddrtable],	%rax
    mov       %r13,	-1
    mov       %r12,	10
    cmp       %r12,	-1
    jl        L2368
L2366:
    mov       %rcx,	%r13
    mov       %rdx,	8
    call      mc_libmcl.mgenint0
    lea       %r10,	[%rip+mc_libmcl.smallinttable]
    mov       %r11,	%r13
    mov       [%r10 + %r11*8+8],	%rax
    inc       %r13
    cmp       %r13,	%r12
    jle       L2366
L2368:
    test      %r14,	%r14
    jz        L2370
    mov       %al,	1
    mov       [%rip+pc_decls.mcldone],	%al
L2370:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.initmcdest
mc_libmcl.initmcdest:
#?>>
#?]]
#---------------
    xor       %eax,	%eax
    mov       [%rip+mc_decls.mccodex],	%rax
    mov       [%rip+mc_decls.mccode],	%rax
#---------------
    ret       
# End 
# Proc mc_libmcl.genmc
mc_libmcl.genmc:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
    mov       %rcx,	64
    call      mlib.pcm_allocnfz
    mov       %rdi,	%rax
    mov       [%rdi+33],	%sil
    inc       qword ptr[%rip+mc_libmcl.mclseqno]
    mov       %rax,	[%rip+mc_libmcl.mclseqno]
    mov       [%rdi+36],	%eax
    mov       %eax,	[%rip+pc_decls.mmpos]
    mov       [%rdi+40],	%eax
    mov       [%rdi+16],	%r12
    mov       [%rdi+24],	%r13
    mov       %rax,	%rsi
    cmp       %rax,	14
    jz        L2374
    cmp       %rax,	9
    jz        L2375
    cmp       %rax,	11
    jz        L2376
    jmp       L2377
L2374:
    test      %r13,	%r13
    jz        L2379
    movzx     %rax,	word ptr[%r13+8]
    shr       %rax,	12
    and       %rax,	15
    cmp       %rax,	5
    jnz       L2379
    mov       %rax,	[%r13]
    mov       %r10b,	1
    mov       [%rax+88],	%r10b
L2379:
    jmp       L2373
L2375:
    mov       %rbx,	[%r12]
    jmp       L2373
L2376:
    movzx     %rax,	word ptr[%r12+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	5
    jz        L2382
    test      %r13,	%r13
    jz        L2381
    movzx     %rax,	word ptr[%r13+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	5
    jnz       L2381
L2382:
    movzx     %rax,	word ptr[%r12+8]
    and       %rax,	31
    cmp       %rax,	8
    jnz       L2384
    mov       %rax,	17
    jmp       L2383
L2384:
    mov       %rax,	16
L2383:
    mov       [%rdi+33],	%al
L2381:
L2377:
L2373:
    mov       %rax,	[%rip+mc_decls.mccode]
    test      %rax,	%rax
    jz        L2386
    mov       %rax,	[%rip+mc_decls.mccodex]
    mov       [%rdi],	%rax
    mov       %rax,	%rdi
    mov       %r10,	[%rip+mc_decls.mccodex]
    mov       [%r10+8],	%rax
    mov       [%rip+mc_decls.mccodex],	%rdi
    jmp       L2385
L2386:
    mov       %rax,	%rdi
    mov       [%rip+mc_decls.mccodex],	%rax
    mov       [%rip+mc_decls.mccode],	%rax
L2385:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.genmc_cond
mc_libmcl.genmc_cond:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
    mov       %r12,	%r9
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      mc_libmcl.genmc
    mov       %al,	%bl
    mov       %r10,	[%rip+mc_decls.mccodex]
    mov       [%r10+34],	%al
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.genmc_str
mc_libmcl.genmc_str:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rbx
    mov       %rdx,	-1
    call      mc_libmcl.mgenstring
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.newmclopnd
mc_libmcl.newmclopnd:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rcx,	16
    call      mlib.pcm_allocnfz
    mov       %rdi,	%rax
    inc       qword ptr[%rip+mc_libmcl.nmclopnd]
    mov       %rax,	%rdi
L2389:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.duplopnd
mc_libmcl.duplopnd:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rcx,	16
    call      mlib.pcm_allocnfz
    mov       %rdi,	%rax
    mov       %rax,	%rbx
    movdqu    %XMM4,	[%rax]
    movdqu    [%rdi],	%XMM4
    mov       %rax,	%rdi
L2390:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenindex
mc_libmcl.mgenindex:
#?>>
    .set mc_libmcl.mgenindex.size, 96
    .set mc_libmcl.mgenindex.labno, 104
    .set mc_libmcl.mgenindex.def, 112
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	32
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
    mov       %r13,	%r9
#---------------
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	3
    mov       %r15w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r15w,	%r11w
    or        %r15w,	%r10w
    mov       [%rax],	%r15w
    mov       [%rdi+10],	%bl
    cmp       %rbx,	15
    jz        L2394
    cmp       %rsi,	15
    jnz       L2393
L2394:
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.usedregs]
    mov       [%r10+14],	%al
L2393:
    mov       [%rdi+11],	%sil
    lea       %rax,	[%rdi+8]
    mov       %r10w,	%r12w
    mov       %r15w,	[%rax]
    mov       %r11,	-481
    shl       %r10w,	5
    and       %r15w,	%r11w
    or        %r15w,	%r10w
    mov       [%rax],	%r15w
    lea       %rax,	[%rdi+8]
    mov       %r10w,	[%rbp + mc_libmcl.mgenindex.size]
    mov       %r15w,	[%rax]
    mov       %r11,	-32
    and       %r15w,	%r11w
    or        %r15w,	%r10w
    mov       [%rax],	%r15w
    mov       [%rdi+12],	%r13d
    mov       %rax,	[%rbp + mc_libmcl.mgenindex.labno]
    test      %rax,	%rax
    jz        L2396
    mov       %rax,	[%rbp + mc_libmcl.mgenindex.labno]
    mov       [%rdi],	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	6
    mov       %r15w,	[%rax]
    mov       %r11,	-61441
    shl       %r10w,	12
    and       %r15w,	%r11w
    or        %r15w,	%r10w
    mov       [%rax],	%r15w
    jmp       L2395
L2396:
    mov       %rax,	[%rbp + mc_libmcl.mgenindex.def]
    test      %rax,	%rax
    jz        L2397
    mov       %rax,	[%rbp + mc_libmcl.mgenindex.def]
    mov       [%rdi],	%rax
    mov       %rax,	[%rbp + mc_libmcl.mgenindex.def]
    lea       %rax,	[%rax+89]
    inc       byte ptr[%rax]
    lea       %rax,	[%rdi+8]
    mov       %r10w,	5
    mov       %r15w,	[%rax]
    mov       %r11,	-61441
    shl       %r10w,	12
    and       %r15w,	%r11w
    or        %r15w,	%r10w
    mov       [%rax],	%r15w
    mov       %rax,	[%rbp + mc_libmcl.mgenindex.def]
    movzx     %rax,	byte ptr[%rax+72]
    cmp       %rax,	4
    jz        L2400
    cmp       %rax,	5
    jnz       L2399
L2400:
    mov       %al,	15
    mov       [%rdi+10],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.usedregs]
    mov       [%r10+14],	%al
L2399:
L2397:
L2395:
    mov       %rax,	%rdi
L2391:
#---------------
    add       %rsp,	32
    pop       %rbp
    pop       %r15
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgencomment
mc_libmcl.mgencomment:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	3
    mov       %rdx,	%rdi
    call      mc_libmcl.genmc_str
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenstring
mc_libmcl.mgenstring:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	2
    mov       %r9w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    cmp       %rsi,	0
    jge       L2404
    mov       %rcx,	%rbx
    call      strlen
    mov       %rsi,	%rax
L2404:
    lea       %rax,	[%rsi+1]
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       [%rdi],	%rax
    mov       %rax,	[%rdi]
    mov       %rcx,	%rax
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      memcpy
    mov       %rax,	[%rdi]
    xor       %r10d,	%r10d
    mov       %r11,	%rsi
    mov       [%rax + %r11],	%r10b
    lea       %rax,	[%rdi+8]
    mov       %r10w,	4
    mov       %r9w,	[%rax]
    mov       %r11,	-61441
    shl       %r10w,	12
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    lea       %rax,	[%rdi+8]
    mov       %r10w,	8
    mov       %r9w,	[%rax]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       %rax,	%rdi
L2402:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenname
mc_libmcl.mgenname:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	2
    mov       %r9w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       %rcx,	%rbx
    call      mlib.pcm_copyheapstring
    mov       [%rdi],	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	7
    mov       %r9w,	[%rax]
    mov       %r11,	-61441
    shl       %r10w,	12
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    lea       %rax,	[%rdi+8]
    mov       %r10w,	8
    mov       %r9w,	[%rax]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       %rax,	%rdi
L2405:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.setsegment
mc_libmcl.setsegment:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    cmp       %rsi,	[%rip+mc_decls.currsegment]
    jz        L2408
    mov       %rax,	%rsi
    cmp       %rax,	73
    jz        L2410
    cmp       %rax,	90
    jz        L2411
    cmp       %rax,	67
    jz        L2412
    cmp       %rax,	82
    jz        L2413
    jmp       L2414
L2410:
    mov       %rdi,	121
    jmp       L2409
L2411:
    mov       %rdi,	122
    jmp       L2409
L2412:
    mov       %rdi,	123
    jmp       L2409
L2413:
    lea       %rcx,	[%rip+L8641]
    lea       %rdx,	[%rip+L8642]
    call      pc_api.merror
    jmp       L2409
L2414:
    lea       %rcx,	[%rip+L8643]
    lea       %rdx,	[%rip+L8644]
    call      pc_api.merror
L2409:
    mov       %rax,	[%rip+mc_decls.mccodex]
    test      %rax,	%rax
    jz        L2416
    mov       %rax,	[%rip+mc_decls.mccodex]
    movzx     %rax,	byte ptr[%rax+33]
    cmp       %rax,	121
    jz        L2417
    cmp       %rax,	122
    jz        L2417
    cmp       %rax,	123
    jnz       L2416
L2417:
    mov       %al,	%dil
    mov       %r10,	[%rip+mc_decls.mccodex]
    mov       [%r10+33],	%al
    jmp       L2415
L2416:
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L2415:
    mov       [%rip+mc_decls.currsegment],	%rsi
L2408:
    cmp       %r12,	1
    jle       L2419
    mov       %rax,	[%rip+mc_decls.mccodex]
    movzx     %rax,	byte ptr[%rax+33]
    cmp       %rax,	124
    jnz       L2421
    mov       %rax,	[%rip+mc_decls.mccodex]
    mov       %rax,	[%rax+16]
    mov       %rbx,	[%rax]
    cmp       %rbx,	%r12
    jge       L2406
L2423:
L2421:
    mov       %rcx,	%r12
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	124
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L2419:
L2406:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.changeopndsize
mc_libmcl.changeopndsize:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    movzx     %rax,	word ptr[%rbx+8]
    and       %rax,	31
    cmp       %rax,	%rsi
    jz        L2426
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jnz       L2428
    movzx     %rax,	byte ptr[%rbx+10]
    lea       %r10,	[%rip+mc_decls.regtable]
    mov       %r11,	%rax
    shl       %r11,	6
    lea       %r10,	[%r10 + %r11-64]
    mov       %rax,	%rsi
    mov       %r10,	[%r10 + %rax*8-8]
    mov       %rdi,	%r10
    jmp       L2427
L2428:
    mov       %rcx,	%rbx
    call      mc_libmcl.duplopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	%si
    mov       %r8w,	[%rax]
    mov       %r11,	-32
    and       %r8w,	%r11w
    or        %r8w,	%r10w
    mov       [%rax],	%r8w
L2427:
    mov       %rax,	%rdi
    jmp       L2424
L2426:
    mov       %rax,	%rbx
L2424:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.applyoffset
mc_libmcl.applyoffset:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    test      %rsi,	%rsi
    jnz       L2431
    test      %r12,	%r12
    jnz       L2431
    mov       %rax,	%rbx
    jmp       L2429
L2431:
    mov       %rcx,	%rbx
    call      mc_libmcl.duplopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+12]
    mov       %r10d,	%esi
    add       [%rax],	%r10d
    test      %r12,	%r12
    jz        L2433
    lea       %rax,	[%rdi+8]
    mov       %r10w,	%r12w
    mov       %r9w,	[%rax]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
L2433:
    mov       %rax,	%rdi
L2429:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenint
mc_libmcl.mgenint:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    lea       %rax,	[%rip+pc_tables.psize]
    mov       %r10,	%r12
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %rbx,	%rax
    mov       %rax,	%rsi
    cmp       %rax,	-1
    jl        L2436
    cmp       %rax,	10
    jg        L2436
    cmp       %rbx,	8
    jnz       L2436
    lea       %rax,	[%rip+mc_libmcl.smallinttable]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8+8]
    jmp       L2434
L2436:
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	2
    mov       %r9w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       [%rdi],	%rsi
    lea       %rax,	[%rdi+8]
    mov       %r10w,	1
    mov       %r9w,	[%rax]
    mov       %r11,	-61441
    shl       %r10w,	12
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    lea       %rax,	[%rdi+8]
    mov       %r10w,	%bx
    mov       %r9w,	[%rax]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       %rax,	%rdi
L2434:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenint0
mc_libmcl.mgenint0:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	2
    mov       %r9w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       [%rdi],	%rbx
    lea       %rax,	[%rdi+8]
    mov       %r10w,	1
    mov       %r9w,	[%rax]
    mov       %r11,	-61441
    shl       %r10w,	12
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    lea       %rax,	[%rdi+8]
    mov       %r10w,	%si
    mov       %r9w,	[%rax]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       %rax,	%rdi
L2437:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenrealmem
mc_libmcl.mgenrealmem:
#?>>
    push      %rdi
    push      %rbx
    movq      %rax,	%XMM15
    push      %rax
#?]]
    sub       %rsp,	48
    movq      %XMM15,	%XMM0
    mov       %rbx,	%rdx
#---------------
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	3
    mov       %r9w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    lea       %rax,	[%rbx-1]
    test      %rax,	%rax
    jz        L2440
    movq      %XMM0,	%XMM15
    call      mc_libmcl.getrealindex
    mov       [%rdi],	%rax
    jmp       L2439
L2440:
    movq      %XMM0,	%XMM15
    call      mc_libmcl.getr32index
    mov       [%rdi],	%rax
L2439:
    lea       %rax,	[%rdi+8]
    mov       %r10w,	6
    mov       %r9w,	[%rax]
    mov       %r11,	-61441
    shl       %r10w,	12
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    lea       %rax,	[%rip+pc_tables.psize]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10]
    lea       %r10,	[%rdi+8]
    mov       %r9w,	[%r10]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%ax
    mov       [%r10],	%r9w
    mov       %rax,	%rdi
L2438:
#---------------
    add       %rsp,	48
    pop       %rcx
    movq      %XMM15,	%rcx
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenrealimm
mc_libmcl.mgenrealimm:
#?>>
    push      %rdi
    push      %rbx
    movq      %rax,	%XMM15
    push      %rax
#?]]
    sub       %rsp,	48
    movq      %XMM15,	%XMM0
    mov       %rbx,	%rdx
#---------------
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	2
    mov       %r9w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    movq      %XMM4,	%XMM15
    movq      [%rdi],	%XMM4
    lea       %rax,	[%rdi+8]
    mov       %r10w,	2
    mov       %r9w,	[%rax]
    mov       %r11,	-61441
    shl       %r10w,	12
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    lea       %rax,	[%rip+pc_tables.psize]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10]
    lea       %r10,	[%rdi+8]
    mov       %r9w,	[%r10]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%ax
    mov       [%r10],	%r9w
    mov       %rax,	%rdi
L2441:
#---------------
    add       %rsp,	48
    pop       %rcx
    movq      %XMM15,	%rcx
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenlabel
mc_libmcl.mgenlabel:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	2
    mov       %r9w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    test      %rbx,	%rbx
    jnz       L2444
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rbx,	[%rip+pc_api.mlabelno]
L2444:
    mov       [%rdi],	%rbx
    lea       %rax,	[%rdi+8]
    mov       %r10w,	6
    mov       %r9w,	[%rax]
    mov       %r11,	-61441
    shl       %r10w,	12
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       %rax,	%rdi
L2442:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenlabelmem
mc_libmcl.mgenlabelmem:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rcx,	%rbx
    call      mc_libmcl.mgenlabel
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	3
    mov       %r9w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       %rax,	%rdi
L2445:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenmem
mc_libmcl.mgenmem:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    mov       %al,	[%rsi+90]
    test      %al,	%al
    jz        L2448
    movzx     %rax,	byte ptr[%rsi+82]
    lea       %r10,	[%rip+pc_tables.pfloat]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L2450
    mov       %rcx,	%rsi
    call      mc_libmcl.mgenxregvar
    jmp       L2446
L2450:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    call      mc_libmcl.mgenregvar
    jmp       L2446
L2449:
L2448:
    xor       %rbx,	%rbx
    movzx     %rax,	byte ptr[%rsi+72]
    cmp       %rax,	4
    jz        L2453
    cmp       %rax,	5
    jnz       L2452
L2453:
    mov       %rbx,	15
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.usedregs]
    mov       [%r10+14],	%al
L2452:
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	3
    mov       %r9w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       [%rdi+10],	%bl
    mov       [%rdi],	%rsi
    lea       %rax,	[%rsi+89]
    inc       byte ptr[%rax]
    lea       %rax,	[%rdi+8]
    mov       %r10w,	5
    mov       %r9w,	[%rax]
    mov       %r11,	-61441
    shl       %r10w,	12
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    test      %r12,	%r12
    jz        L2455
    lea       %rax,	[%rip+pc_tables.psize]
    mov       %r10,	%r12
    movzx     %rax,	byte ptr[%rax + %r10]
    lea       %r10,	[%rdi+8]
    mov       %r9w,	[%r10]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%ax
    mov       [%r10],	%r9w
    jmp       L2454
L2455:
    mov       %eax,	[%rsi+84]
    mov       %r10,	8
    cmp       %rax,	%r10
    cmova     %rax,	%r10
    lea       %r10,	[%rdi+8]
    mov       %r9w,	[%r10]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%ax
    mov       [%r10],	%r9w
L2454:
    mov       %rax,	%rdi
L2446:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenmemaddr
mc_libmcl.mgenmemaddr:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %al,	1
    mov       [%rbx+88],	%al
    lea       %rax,	[%rbx+89]
    inc       byte ptr[%rax]
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	2
    mov       %r9w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       [%rdi],	%rbx
    lea       %rax,	[%rbx+89]
    inc       byte ptr[%rax]
    lea       %rax,	[%rdi+8]
    mov       %r10w,	5
    mov       %r9w,	[%rax]
    mov       %r11,	-61441
    shl       %r10w,	12
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    lea       %rax,	[%rdi+8]
    mov       %r10w,	8
    mov       %r9w,	[%rax]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       %rax,	%rdi
L2456:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenreg0
mc_libmcl.mgenreg0:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	1
    mov       %r9w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       [%rdi+10],	%bl
    lea       %rax,	[%rdi+8]
    mov       %r10w,	%si
    mov       %r9w,	[%rax]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    test      %rsi,	%rsi
    jnz       L2459
    lea       %rcx,	[%rip+L8645]
    lea       %rdx,	[%rip+L8646]
    call      pc_api.merror
L2459:
    mov       %rax,	%rdi
L2457:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenxreg
mc_libmcl.mgenxreg:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	5
    mov       %r9w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       [%rdi+10],	%bl
    lea       %rax,	[%rdi+8]
    mov       %r10w,	%si
    mov       %r9w,	[%rax]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    test      %rsi,	%rsi
    jnz       L2462
    lea       %rcx,	[%rip+L8647]
    lea       %rdx,	[%rip+L8648]
    call      pc_api.merror
L2462:
    mov       %rax,	%rdi
L2460:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenreg
mc_libmcl.mgenreg:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    lea       %rax,	[%rip+pc_tables.psize]
    mov       %r10,	%r12
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %rbx,	%rax
    cmp       %r12,	2
    jg        L2465
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	5
    mov       %r8w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r8w,	%r11w
    or        %r8w,	%r10w
    mov       [%rax],	%r8w
    mov       [%rdi+10],	%sil
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.usedxregs]
    mov       %r11,	%rsi
    mov       [%r10 + %r11-1],	%al
    lea       %rax,	[%rip+pc_tables.psize]
    mov       %r10,	%r12
    movzx     %rax,	byte ptr[%rax + %r10]
    lea       %r10,	[%rdi+8]
    mov       %r8w,	[%r10]
    mov       %r11,	-32
    and       %r8w,	%r11w
    or        %r8w,	%ax
    mov       [%r10],	%r8w
    mov       %rax,	%rdi
    jmp       L2464
L2465:
    test      %rbx,	%rbx
    jnz       L2467
    mov       %rbx,	8
L2467:
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.usedregs]
    mov       %r11,	%rsi
    mov       [%r10 + %r11-1],	%al
    mov       %rax,	%rsi
    cmp       %rax,	11
    jl        L2469
    cmp       %rax,	14
    jg        L2469
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.regset]
    mov       %r11,	%rsi
    mov       [%r10 + %r11-1],	%al
L2469:
    lea       %rax,	[%rip+mc_decls.regtable]
    mov       %r10,	%rsi
    shl       %r10,	6
    lea       %rax,	[%rax + %r10-64]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8-8]
    jmp       L2463
    mov       %rcx,	%rsi
    mov       %rdx,	%rbx
    call      mc_libmcl.mgenreg0
L2464:
L2463:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenregi
mc_libmcl.mgenregi:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    lea       %rax,	[%rip+mc_decls.regtable]
    mov       %r10,	%rdi
    shl       %r10,	6
    lea       %rax,	[%rax + %r10-64]
    lea       %r10,	[%rip+pc_tables.psize]
    mov       %r11,	%rbx
    movzx     %r10,	byte ptr[%r10 + %r11]
    mov       %rax,	[%rax + %r10*8-8]
    jmp       L2470
    lea       %rax,	[%rip+pc_tables.psize]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mc_libmcl.mgenreg0
L2470:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenireg
mc_libmcl.mgenireg:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	3
    mov       %r9w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       [%rdi+10],	%bl
    lea       %rax,	[%rip+pc_tables.psize]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10]
    lea       %r10,	[%rdi+8]
    mov       %r9w,	[%r10]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%ax
    mov       [%r10],	%r9w
    mov       [%rdi+12],	%r12d
    mov       %rax,	%rdi
L2471:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgentemp
mc_libmcl.mgentemp:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    lea       %rax,	[%rip+mc_decls.pcltempflags]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L2474
    lea       %rax,	[%rip+pc_tables.psize]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10]
    lea       %r10,	[%rip+mc_decls.pcltempopnds]
    mov       %r11,	%rbx
    mov       %r10,	[%r10 + %r11*8-8]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_libmcl.changeopndsize
    jmp       L2472
L2474:
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	3
    mov       %r9w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       %al,	15
    mov       [%rdi+10],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.usedregs]
    mov       [%r10+14],	%al
    lea       %rax,	[%rdi+8]
    mov       %r10w,	8
    mov       %r9w,	[%rax]
    mov       %r11,	-61441
    shl       %r10w,	12
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    lea       %rax,	[%rip+pc_tables.psize]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10]
    lea       %r10,	[%rdi+8]
    mov       %r9w,	[%r10]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%ax
    mov       [%r10],	%r9w
    mov       [%rdi],	%rbx
    mov       %rax,	%rdi
    lea       %r10,	[%rip+mc_decls.pcltempopnds]
    mov       %r11,	%rbx
    mov       [%r10 + %r11*8-8],	%rax
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.pcltempflags]
    mov       %r11,	%rbx
    mov       [%r10 + %r11-1],	%al
    mov       %rax,	%rdi
L2472:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.roundsizetg
mc_libmcl.roundsizetg:
#?>>
#?]]
#---------------
    mov       %rax,	%rcx
    and       %rax,	7
    jnz       L2477
    mov       %rax,	%rcx
    jmp       L2475
L2477:
    mov       %rax,	%rcx
    and       %rax,	7
    mov       %r10,	8
    sub       %r10,	%rax
    mov       %rax,	%rcx
    add       %rax,	%r10
L2475:
#---------------
    ret       
# End 
# Proc mc_libmcl.merroropnd
mc_libmcl.merroropnd:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8649]
    call      msys.m$print_setfmt
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+pc_tables.opndnames]
    mov       %r10,	%rbx
    mov       %rcx,	[%rax + %r10*8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	1
    call      exit
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mcreatefwdlabel
mc_libmcl.mcreatefwdlabel:
#?>>
#?]]
#---------------
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rax,	[%rip+pc_api.mlabelno]
L2479:
#---------------
    ret       
# End 
# Proc mc_libmcl.mdefinefwdlabel
mc_libmcl.mdefinefwdlabel:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenextname
mc_libmcl.mgenextname:
#?>>
    .set mc_libmcl.mgenextname.str, -64
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	96
    mov       %rbx,	%rcx
#---------------
    lea       %rcx,	[%rbp + mc_libmcl.mgenextname.str]
    mov       %rdx,	%rbx
    call      strcpy
    mov       %rcx,	%rbx
    call      strlen
    xor       %r10d,	%r10d
    mov       [%rbp + %rax + mc_libmcl.mgenextname.str-1],	%r10b
    lea       %rcx,	[%rbp + mc_libmcl.mgenextname.str]
    call      mc_libmcl.findnamesym
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L2483
    mov       %rcx,	128
    call      mlib.pcm_allocnfz
    mov       %rdi,	%rax
    lea       %rcx,	[%rbp + mc_libmcl.mgenextname.str]
    call      mlib.pcm_copyheapstring
    mov       [%rdi],	%rax
    mov       %al,	1
    mov       [%rdi+72],	%al
    mov       %al,	1
    mov       [%rdi+80],	%al
    mov       %rcx,	%rdi
    call      mc_libmcl.addnamesym
L2483:
    mov       %rcx,	%rdi
    call      mc_libmcl.mgenmemaddr
L2481:
#---------------
    add       %rsp,	96
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenregvar
mc_libmcl.mgenregvar:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    movzx     %rax,	byte ptr[%rbx+90]
    mov       %rcx,	%rax
    mov       %rdx,	%rsi
    call      mc_libmcl.mgenreg
    mov       %rdi,	%rax
    mov       %rax,	%rdi
L2484:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenxregvar
mc_libmcl.mgenxregvar:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rbx+90]
    mov       %rcx,	%rax
    mov       %rdx,	8
    call      mc_libmcl.mgenxreg
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rbx+90]
    mov       %r10b,	1
    lea       %r11,	[%rip+mc_decls.isxregvar]
    mov       [%r11 + %rax-1],	%r10b
    mov       %rax,	%rdi
L2485:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.getprimreg
mc_libmcl.getprimreg:
#?>>
#?]]
#---------------
    mov       %al,	[%rcx+10]
    test      %al,	%al
    jz        L2488
    movzx     %rax,	byte ptr[%rcx+10]
    jmp       L2487
L2488:
    movzx     %rax,	byte ptr[%rcx+11]
L2487:
L2486:
#---------------
    ret       
# End 
# Proc mc_libmcl.pushslots
mc_libmcl.pushslots:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	%rdi
    shl       %rax,	3
    mov       %rcx,	%rax
    call      mc_libmcl.pushstack
    mov       %rax,	%rdi
    add       [%rip+mc_decls.mstackdepth],	%rax
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.popslots
mc_libmcl.popslots:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	%rdi
    shl       %rax,	3
    mov       %rcx,	%rax
    call      mc_libmcl.popstack
    mov       %rax,	%rdi
    sub       [%rip+mc_decls.mstackdepth],	%rax
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.pushstack
mc_libmcl.pushstack:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    test      %rdi,	%rdi
    jz        L2493
    mov       %rcx,	%rdi
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	29
    mov       %rdx,	[%rip+mc_decls.dstackopnd]
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2493:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.popstack
mc_libmcl.popstack:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    test      %rdi,	%rdi
    jz        L2496
    mov       %rcx,	%rdi
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	28
    mov       %rdx,	[%rip+mc_decls.dstackopnd]
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2496:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.getstringindex
mc_libmcl.getstringindex:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    test      %rdi,	%rdi
    jnz       L2499
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rax,	[%rip+pc_api.mlabelno]
    mov       [%rip+mc_decls.kk0used],	%rax
    mov       %rax,	[%rip+mc_decls.kk0used]
    jmp       L2497
L2499:
    mov       %rax,	[%rip+mc_decls.cstringlist]
    test      %rax,	%rax
    jz        L2501
    mov       %rax,	[%rip+mc_decls.cstringlist]
    mov       %rax,	[%rax+24]
    mov       %r10,	%rbx
    cmp       %r10,	%rax
    jnz       L2501
    mov       %rax,	[%rip+mc_decls.cstringlist]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mlib.eqbytes
    test      %rax,	%rax
    jz        L2501
    mov       %rax,	[%rip+mc_decls.cstringlist]
    mov       %rax,	[%rax+16]
    jmp       L2497
L2501:
    lea       %rcx,	[%rip+mc_decls.cstringlist]
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.addconst
L2497:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.addconst
mc_libmcl.addconst:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    mov       %rcx,	32
    call      mlib.pcm_allocnfz
    mov       %rdi,	%rax
    mov       [%rdi],	%rsi
    mov       [%rdi+24],	%r12
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rax,	[%rip+pc_api.mlabelno]
    mov       [%rdi+16],	%rax
    mov       %rax,	[%rbx]
    mov       [%rdi+8],	%rax
    mov       [%rbx],	%rdi
    mov       %rax,	[%rip+pc_api.mlabelno]
L2502:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.getrealindex
mc_libmcl.getrealindex:
#?>>
    movq      %rax,	%XMM15
    push      %rax
#?]]
    sub       %rsp,	48
    movq      %XMM15,	%XMM0
#---------------
    movq      %XMM4,	%XMM15
    movq      %rax,	%XMM4
    lea       %rcx,	[%rip+mc_decls.creallist]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.addconst
L2503:
#---------------
    add       %rsp,	48
    pop       %rcx
    movq      %XMM15,	%rcx
    ret       
# End 
# Proc mc_libmcl.getr32index
mc_libmcl.getr32index:
#?>>
    movq      %rax,	%XMM15
    push      %rax
#?]]
    sub       %rsp,	48
    movq      %XMM15,	%XMM0
#---------------
    movq      %XMM4,	%XMM15
    movq      %rax,	%XMM4
    lea       %rcx,	[%rip+mc_decls.cr32list]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.addconst
L2504:
#---------------
    add       %rsp,	48
    pop       %rcx
    movq      %XMM15,	%rcx
    ret       
# End 
# Proc mc_libmcl.ispoweroftwo
mc_libmcl.ispoweroftwo:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	16
#---------------
    mov       %rdi,	1
    xor       %rbx,	%rbx
    mov       %rax,	60
    mov       %rsi,	%rax
L2506:
    inc       %rbx
    mov       %rax,	%rdi
    shl       %rax,	1
    mov       %rdi,	%rax
    cmp       %rdi,	%rcx
    jnz       L2510
    mov       %rax,	%rbx
    jmp       L2505
L2510:
    dec       %rsi
    jnz       L2506
    xor       %eax,	%eax
L2505:
#---------------
    add       %rsp,	16
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.axerror
mc_libmcl.axerror:
#?>>
    .set mc_libmcl.axerror.filename, -8
    .set mc_libmcl.axerror.sourceline, -16
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rbx,	%rcx
#---------------
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8650]
    call      msys.m$print_str_nf
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L8651]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+mc_decls.aaseqno]
    call      msys.m$print_i64_nf
    lea       %rcx,	[%rip+L8652]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+mc_decls.aapos]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rax,	[%rip+pc_decls.igetmsourceinfo]
    test      %rax,	%rax
    jz        L2513
    mov       %rcx,	[%rip+pc_decls.mmpos]
    lea       %rdx,	[%rbp + mc_libmcl.axerror.filename]
    lea       %r8,	[%rbp + mc_libmcl.axerror.sourceline]
    mov       %rax,	[%rip+pc_decls.igetmsourceinfo]
    call      %rax
    mov       %rdi,	%rax
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8653]
    call      msys.m$print_str_nf
    mov       %rcx,	%rdi
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8654]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rbp + mc_libmcl.axerror.filename]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L2513:
    mov       %rcx,	1
    call      exit
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.newblocktemp
mc_libmcl.newblocktemp:
#?>>
    .set mc_libmcl.newblocktemp.str, -16
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rbx,	%rcx
#---------------
    mov       %rax,	[%rip+mc_decls.nblocktemps]
    cmp       %rax,	50
    jle       L2516
    lea       %rcx,	[%rip+L8655]
    lea       %rdx,	[%rip+L8656]
    call      pc_api.merror
L2516:
    inc       qword ptr[%rip+mc_decls.nblocktemps]
    lea       %rcx,	[%rbp + mc_libmcl.newblocktemp.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8657]
    call      msys.m$print_setfmt
    mov       %rcx,	[%rip+mc_decls.nblocktemps]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + mc_libmcl.newblocktemp.str]
    mov       %rdx,	8
    call      pc_api.pc_makesymbol
    mov       %rdi,	%rax
    mov       %al,	11
    mov       [%rdi+82],	%al
    mov       [%rdi+84],	%ebx
    mov       %al,	1
    mov       [%rdi+92],	%al
    mov       %al,	4
    mov       [%rdi+72],	%al
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %rax,	[%rax+24]
    mov       [%rdi+24],	%rax
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       [%rdi+32],	%rax
    mov       %rax,	%rdi
    mov       %r10,	[%rip+pc_decls.currfunc]
    mov       [%r10+24],	%rax
    mov       %rax,	%rdi
    lea       %r10,	[%rip+mc_decls.blockdefs]
    mov       %r11,	[%rip+mc_decls.nblocktemps]
    mov       [%r10 + %r11*8-8],	%rax
    mov       %rax,	%rdi
L2514:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.findnamesym
mc_libmcl.findnamesym:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rdi,	1
    mov       %rax,	[%rip+mc_libmcl.nnametable]
    cmp       %rax,	1
    jl        L2520
L2518:
    lea       %rax,	[%rip+mc_libmcl.nametable]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rax,	[%rax]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L2522
    lea       %rax,	[%rip+mc_libmcl.nametable]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    jmp       L2517
L2522:
    inc       %rdi
    cmp       %rdi,	[%rip+mc_libmcl.nnametable]
    jle       L2518
L2520:
    xor       %eax,	%eax
L2517:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.addnamesym
mc_libmcl.addnamesym:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	[%rip+mc_libmcl.nnametable]
    cmp       %rax,	20
    jge       L2525
    inc       qword ptr[%rip+mc_libmcl.nnametable]
    mov       %rax,	[%rip+mc_libmcl.nnametable]
    mov       %r10,	%rdi
    lea       %r11,	[%rip+mc_libmcl.nametable]
    mov       [%r11 + %rax*8-8],	%r10
    jmp       L2524
L2525:
    lea       %rcx,	[%rip+L8658]
    lea       %rdx,	[%rip+L8659]
    call      pc_api.merror
L2524:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.clearreg
mc_libmcl.clearreg:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    movzx     %rax,	word ptr[%rdi+8]
    and       %rax,	31
    cmp       %rax,	8
    jnz       L2528
    mov       %rcx,	%rdi
    mov       %rdx,	4
    call      mc_libmcl.changeopndsize
    mov       %rdi,	%rax
L2528:
    mov       %rcx,	40
    mov       %rdx,	%rdi
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.getopnd
mc_stackmcl.getopnd:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       %r15,	%r8
#---------------
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	%r13
    mov       %rsi,	[%rax + %r10*8-8]
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%r13
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	1
    jz        L2531
    cmp       %rax,	2
    jz        L2531
    cmp       %rax,	3
    jz        L2532
    jmp       L2533
L2531:
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%r13
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rcx,	%rax
    mov       %rdx,	%r14
    call      mc_libmcl.mgenreg
    jmp       L2529
L2532:
    mov       %rcx,	%r13
    mov       %rdx,	%r14
    call      mc_libmcl.mgentemp
    mov       %rbx,	%rax
    mov       %rax,	%rbx
    jmp       L2529
L2533:
L2530:
    movzx     %rax,	byte ptr[%rsi+1]
    cmp       %rax,	1
    jz        L2535
    cmp       %rax,	2
    jz        L2536
    cmp       %rax,	4
    jz        L2537
    cmp       %rax,	5
    jz        L2538
    cmp       %rax,	6
    jz        L2538
    cmp       %rax,	7
    jz        L2539
    cmp       %rax,	3
    jz        L2540
    jmp       L2541
L2535:
    mov       %r12,	[%rsi+8]
    cmp       %r14,	11
    jnz       L2543
    movzx     %rax,	byte ptr[%r12+72]
    cmp       %rax,	5
    jz        L2543
    mov       %r14,	6
    jmp       L2536
L2543:
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    mov       %rdx,	%r14
    call      mc_libmcl.mgenmem
    mov       %rdi,	%rax
L2542:
    jmp       L2534
L2536:
    mov       %r12,	[%rsi+8]
    movzx     %rax,	byte ptr[%r12+72]
    cmp       %rax,	5
    jnz       L2545
    movzx     %rax,	byte ptr[%r12+82]
    cmp       %rax,	11
    jnz       L2545
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    mov       %rdx,	%r14
    call      mc_libmcl.mgenmem
    mov       %rdi,	%rax
    jmp       L2544
L2545:
    mov       %rcx,	%r15
    mov       %rdx,	%r14
    call      mc_stackmcl.getworkreg_rm
    mov       %rdi,	%rax
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    mov       %rdx,	%r14
    call      mc_libmcl.mgenmem
    mov       %rcx,	14
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2544:
    jmp       L2534
L2537:
    lea       %rax,	[%rip+pc_tables.psize]
    mov       %r10,	%r14
    movzx     %rax,	byte ptr[%rax + %r10]
    cmp       %rax,	2
    jz        L2547
    cmp       %rax,	4
    jz        L2548
    jmp       L2549
L2547:
    lea       %rax,	[%rsi+8]
    mov       %r10,	65535
    and       [%rax],	%r10
    jmp       L2546
L2548:
    lea       %rax,	[%rsi+8]
    mov       %r10,	4294967295
    and       [%rax],	%r10
L2549:
L2546:
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    mov       %rdx,	%r14
    call      mc_libmcl.mgenint
    mov       %rbx,	%rax
    mov       %rax,	[%rsi+8]
    cmp       %rax,	-2147483648
    jl        L2551
    cmp       %rax,	2147483647
    jg        L2551
    mov       %rdi,	%rbx
    jmp       L2550
L2551:
    mov       %rcx,	%r15
    mov       %rdx,	%r14
    call      mc_stackmcl.getworkreg_rm
    mov       %rdi,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L2550:
    jmp       L2534
L2538:
    movq      %XMM4,	[%rsi+8]
    movq      %XMM0,	%XMM4
    mov       %rdx,	%r14
    call      mc_libmcl.mgenrealmem
    mov       %rdi,	%rax
    jmp       L2534
L2539:
    mov       %rcx,	%r15
    mov       %rdx,	%r14
    call      mc_stackmcl.getworkreg_rm
    mov       %rdi,	%rax
    mov       %eax,	[%rsi+16]
    mov       %r10,	[%rsi+8]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_libmcl.getstringindex
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabelmem
    mov       %rcx,	14
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L2534
L2540:
    mov       %rcx,	%r15
    mov       %rdx,	%r14
    call      mc_stackmcl.getworkreg_rm
    mov       %rdi,	%rax
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabelmem
    mov       %rcx,	14
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L2534
L2541:
#mc_stackmcl.getopnd.error:
    movzx     %rax,	byte ptr[%rsi+1]
    lea       %r10,	[%rip+pc_tables.opndnames]
    mov       %r10,	[%r10 + %rax*8]
    lea       %rcx,	[%rip+L8660]
    mov       %rdx,	%r10
    call      pc_api.merror
L2534:
    mov       %rax,	%rdi
L2529:
#---------------
    add       %rsp,	48
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.loadopnd
mc_stackmcl.loadopnd:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      mc_stackmcl.getopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	2
    jnz       L2555
    test      %r12,	%r12
    jnz       L2557
    mov       %rcx,	%rsi
    call      mc_stackmcl.getworkreg
    mov       %r12,	%rax
L2557:
L2555:
    mov       %rcx,	%rdi
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      mc_stackmcl.loadtoreg
    mov       %rdi,	%rax
    xor       %eax,	%eax
    lea       %r10,	[%rip+mc_decls.pclopnd]
    mov       %r11,	%rbx
    mov       [%r10 + %r11*8-8],	%rax
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.pclloc]
    mov       %r11,	%rbx
    mov       [%r10 + %r11-1],	%al
    mov       %al,	[%rdi+10]
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	%rbx
    mov       [%r10 + %r11-1],	%al
    mov       %rax,	%rdi
L2553:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.loadparam
mc_stackmcl.loadparam:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      mc_stackmcl.getopnd
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      mc_stackmcl.loadtoreg_m
    mov       %rdi,	%rax
    mov       %rax,	%rdi
L2558:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.pushopnd
mc_stackmcl.pushopnd:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
#---------------
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	%r12
    mov       %rsi,	[%rax + %r10*8-8]
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%r12
    movzx     %rax,	byte ptr[%rax + %r10-1]
    test      %rax,	%rax
    jnz       L2561
    movzx     %rax,	byte ptr[%rsi+1]
    cmp       %rax,	1
    jz        L2563
    cmp       %rax,	4
    jz        L2564
    cmp       %rax,	5
    jz        L2565
    jmp       L2566
L2563:
    cmp       %r14,	8
    jnz       L2568
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rsi+8]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_libmcl.mgenmem
    mov       %rdi,	%rax
    jmp       L2569
L2568:
    jmp       L2562
L2564:
    mov       %rax,	[%rsi+8]
    cmp       %rax,	-2147483648
    jl        L2571
    cmp       %rax,	2147483647
    jg        L2571
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rdi,	%rax
    jmp       L2569
L2571:
    jmp       L2562
L2565:
    movq      %XMM4,	[%rsi+8]
    movq      %XMM0,	%XMM4
    mov       %rdx,	2
    call      mc_libmcl.mgenrealmem
    mov       %rdi,	%rax
    jmp       L2569
L2566:
L2562:
L2561:
    mov       %rcx,	%r12
    mov       %rdx,	%r13
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    cmp       %r13,	11
    jnz       L2573
    mov       %rcx,	%rdi
    mov       %rdx,	%r14
    mov       %r8,	%r12
    call      mc_auxmcl.copyblockarg
    mov       %r13,	6
L2573:
    movzx     %rax,	word ptr[%rdi+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	5
    jnz       L2575
    mov       %rbx,	%rdi
    cmp       %r13,	4
    jnz       L2577
    mov       %rax,	5
    jmp       L2576
L2577:
    mov       %rax,	6
L2576:
    mov       %rcx,	%rax
    call      mc_stackmcl.getworkregm
    mov       %rdi,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L2575:
#mc_stackmcl.pushopnd.pushit:
L2569:
    mov       %rcx,	%rdi
    mov       %rdx,	8
    call      mc_libmcl.changeopndsize
    mov       %rcx,	12
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    inc       qword ptr[%rip+mc_decls.mstackdepth]
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.loadtoreg
mc_stackmcl.loadtoreg:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jz        L2581
    cmp       %rax,	5
    jnz       L2580
L2581:
    test      %r12,	%r12
    jz        L2584
    movzx     %rax,	byte ptr[%rbx+10]
    cmp       %rax,	%r12
    jnz       L2583
L2584:
    mov       %rax,	%rbx
    jmp       L2578
L2583:
L2580:
    mov       %rcx,	%r12
    mov       %rdx,	%rsi
    call      mc_stackmcl.getworkreg_rm
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mc_stackmcl.loadtoreg_common
    mov       %rax,	%rdi
L2578:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.loadtoreg_m
mc_stackmcl.loadtoreg_m:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jz        L2588
    cmp       %rax,	5
    jnz       L2587
L2588:
    movzx     %rax,	byte ptr[%rbx+10]
    cmp       %rax,	%r12
    jnz       L2590
    mov       %rax,	%rbx
    jmp       L2585
L2590:
L2587:
    mov       %rcx,	%r12
    mov       %rdx,	%rsi
    call      mc_libmcl.mgenreg
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mc_stackmcl.loadtoreg_common
    mov       %rax,	%rdi
L2585:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.loadtoreg_common
mc_stackmcl.loadtoreg_common:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	2
    jnz       L2593
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	12
    and       %rax,	15
    cmp       %rax,	1
    jnz       L2593
    mov       %rax,	[%rbx]
    test      %rax,	%rax
    jnz       L2593
    mov       %rcx,	%rdi
    mov       %rdx,	4
    call      mc_libmcl.changeopndsize
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    call      mc_libmcl.clearreg
    jmp       L2592
L2593:
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L2592:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.pushpcl
mc_stackmcl.pushpcl:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rax,	[%rip+mc_decls.noperands]
    cmp       %rax,	50
    jl        L2596
    lea       %rcx,	[%rip+L8661]
    lea       %rdx,	[%rip+L8662]
    call      pc_api.merror
L2596:
    inc       qword ptr[%rip+mc_decls.noperands]
    mov       %rdi,	[%rip+mc_decls.noperands]
    xor       %eax,	%eax
    lea       %r10,	[%rip+mc_decls.pclloc]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    mov       %rax,	%rbx
    lea       %r10,	[%rip+mc_decls.pclopnd]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*8-8],	%rax
    xor       %eax,	%eax
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.pclcount]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    mov       %al,	[%rbx+3]
    lea       %r10,	[%rip+mc_decls.pclmode]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    movzx     %rax,	byte ptr[%rbx+1]
    cmp       %rax,	1
    jnz       L2598
    mov       %rax,	[%rbx+8]
    mov       %al,	[%rax+90]
    test      %al,	%al
    jz        L2598
    mov       %rax,	[%rbx+8]
    mov       %al,	[%rax+90]
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    mov       %al,	2
    lea       %r10,	[%rip+mc_decls.pclloc]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
L2598:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.pushpcl_reg
mc_stackmcl.pushpcl_reg:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rax,	[%rip+mc_decls.noperands]
    cmp       %rax,	50
    jl        L2601
    lea       %rcx,	[%rip+L8663]
    lea       %rdx,	[%rip+L8664]
    call      pc_api.merror
L2601:
    test      %rsi,	%rsi
    jnz       L2603
    mov       %rcx,	%rbx
    call      mc_stackmcl.getworkreg
    mov       %rsi,	%rax
L2603:
    inc       qword ptr[%rip+mc_decls.noperands]
    mov       %rdi,	[%rip+mc_decls.noperands]
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.pclloc]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+mc_decls.pclopnd]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*8-8],	%rax
    mov       %al,	%sil
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.pclcount]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    mov       %al,	%bl
    lea       %r10,	[%rip+mc_decls.pclmode]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    cmp       %rbx,	2
    jg        L2605
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.xregset]
    mov       %r11,	%rsi
    mov       [%r10 + %r11-1],	%al
    jmp       L2604
L2605:
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.regset]
    mov       %r11,	%rsi
    mov       [%r10 + %r11-1],	%al
L2604:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.poppcl
mc_stackmcl.poppcl:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rdi,	[%rip+mc_decls.noperands]
    cmp       %rdi,	0
    jg        L2608
    lea       %rcx,	[%rip+L8665]
    lea       %rdx,	[%rip+L8666]
    call      pc_api.merror
L2608:
    lea       %rax,	[%rip+mc_decls.pclcount]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	1
    jle       L2610
    lea       %rax,	[%rip+mc_decls.pclcount]
    mov       %r10,	%rdi
    lea       %rax,	[%rax + %r10-1]
    dec       byte ptr[%rax]
    jmp       L2606
L2610:
    dec       qword ptr[%rip+mc_decls.noperands]
L2606:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.duplpcl
mc_stackmcl.duplpcl:
#?>>
    .set mc_stackmcl.duplpcl.$T1, -8
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
#---------------
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rdi,	%rax
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rdi
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      mc_stackmcl.pushpcl_reg
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       [%rbp + mc_stackmcl.duplpcl.$T1],	%rax
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rdi
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_stackmcl.duplpcl.$T1]
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.getworkireg
mc_stackmcl.getworkireg:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
    mov       %rbx,	10
L2613:
    mov       %rdi,	1
L2616:
    lea       %rax,	[%rip+mc_decls.workregs]
    mov       %r10,	%rdi
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L2620
    lea       %rax,	[%rip+mc_decls.regset]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    test      %rax,	%rax
    jnz       L2620
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.regset]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    mov       %rax,	%rdi
    jmp       L2612
L2620:
    inc       %rdi
    cmp       %rdi,	14
    jle       L2616
    call      mc_stackmcl.savenextopnd
    dec       %rbx
    jnz       L2613
    lea       %rcx,	[%rip+L8667]
    lea       %rdx,	[%rip+L8668]
    call      pc_api.merror
    xor       %eax,	%eax
L2612:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.getworkxreg
mc_stackmcl.getworkxreg:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rdi,	5
L2622:
    lea       %rax,	[%rip+mc_decls.workxregs]
    mov       %r10,	%rdi
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L2626
    lea       %rax,	[%rip+mc_decls.xregset]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    test      %rax,	%rax
    jnz       L2626
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.xregset]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    mov       %rax,	%rdi
    jmp       L2621
L2626:
    inc       %rdi
    cmp       %rdi,	16
    jle       L2622
    lea       %rcx,	[%rip+L8669]
    lea       %rdx,	[%rip+L8670]
    call      pc_api.merror
    xor       %eax,	%eax
L2621:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.getworkregm
mc_stackmcl.getworkregm:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      mc_stackmcl.getworkreg
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    call      mc_libmcl.mgenreg
L2627:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.getworkreg
mc_stackmcl.getworkreg:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    cmp       %rdi,	2
    jg        L2630
    call      mc_stackmcl.getworkxreg
    jmp       L2629
L2630:
    call      mc_stackmcl.getworkireg
L2629:
L2628:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.getworkreg_rm
mc_stackmcl.getworkreg_rm:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rax,	%rdi
    test      %rax,	%rax
    jz        L2634
    cmp       %rax,	15
    jnz       L2633
L2634:
    mov       %rcx,	%rbx
    call      mc_stackmcl.getworkregm
    jmp       L2631
L2633:
    cmp       %rbx,	2
    jle       L2638
    lea       %rax,	[%rip+mc_decls.isregvar]
    mov       %r10,	%rdi
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jnz       L2637
L2638:
    lea       %rax,	[%rip+mc_decls.isxregvar]
    mov       %r10,	%rdi
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L2636
L2637:
    mov       %rcx,	%rbx
    call      mc_stackmcl.getworkregm
    jmp       L2631
L2636:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mc_libmcl.mgenreg
L2631:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.saveopnd
mc_stackmcl.saveopnd:
#?>>
    .set mc_stackmcl.saveopnd.$T1, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	1
    jnz       L2639
L2641:
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rdi,	%rax
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rbx,	%rax
    cmp       %rbx,	2
    jle       L2643
    test      %r12,	%r12
    jnz       L2646
    mov       %rax,	%rdi
    cmp       %rax,	4
    jl        L2647
    cmp       %rax,	10
    jle       L2645
L2647:
L2646:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mc_libmcl.mgenreg
    mov       [%rbp + mc_stackmcl.saveopnd.$T1],	%rax
    mov       %rcx,	%rsi
    mov       %rdx,	%rbx
    call      mc_libmcl.mgentemp
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_stackmcl.saveopnd.$T1]
    call      mc_libmcl.genmc
L2645:
    xor       %eax,	%eax
    lea       %r10,	[%rip+mc_decls.regset]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    jmp       L2642
L2643:
    test      %r12,	%r12
    jnz       L2650
    mov       %rax,	%rdi
    cmp       %rax,	1
    jl        L2649
    cmp       %rax,	6
    jg        L2649
L2650:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mc_libmcl.mgenxreg
    mov       [%rbp + mc_stackmcl.saveopnd.$T1],	%rax
    mov       %rcx,	%rsi
    mov       %rdx,	%rbx
    call      mc_libmcl.mgentemp
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_stackmcl.saveopnd.$T1]
    call      mc_libmcl.genmc
L2649:
    xor       %eax,	%eax
    lea       %r10,	[%rip+mc_decls.xregset]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
L2642:
    mov       %al,	3
    lea       %r10,	[%rip+mc_decls.pclloc]
    mov       %r11,	%rsi
    mov       [%r10 + %r11-1],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	%rsi
    mov       [%r10 + %r11-1],	%al
L2639:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.saveopnds
mc_stackmcl.saveopnds:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    mov       %rbx,	1
    mov       %rax,	[%rip+mc_decls.noperands]
    sub       %rax,	%rsi
    mov       %rdi,	%rax
    cmp       %rdi,	1
    jl        L2654
L2652:
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      mc_stackmcl.saveopnd
    inc       %rbx
    cmp       %rbx,	%rdi
    jle       L2652
L2654:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.savenextopnd
mc_stackmcl.savenextopnd:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rdi,	1
    mov       %rax,	[%rip+mc_decls.noperands]
    cmp       %rax,	1
    jl        L2658
L2656:
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	1
    jnz       L2660
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	2
    jle       L2660
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      mc_stackmcl.saveopnd
    jmp       L2655
L2660:
    inc       %rdi
    cmp       %rdi,	[%rip+mc_decls.noperands]
    jle       L2656
L2658:
L2655:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.savenextxopnd
mc_stackmcl.savenextxopnd:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rdi,	1
    mov       %rax,	[%rip+mc_decls.noperands]
    cmp       %rax,	1
    jl        L2664
L2662:
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	1
    jnz       L2666
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	2
    jg        L2666
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      mc_stackmcl.saveopnd
    jmp       L2661
L2666:
    inc       %rdi
    cmp       %rdi,	[%rip+mc_decls.noperands]
    jle       L2662
L2664:
L2661:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.movetoreg
mc_stackmcl.movetoreg:
#?>>
    .set mc_stackmcl.movetoreg.$T1, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %r12,	%rcx
#---------------
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rbx,	%rax
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
#mc_stackmcl.movetoreg.retry:
L2668:
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rdi,	%rax
    cmp       %rdi,	%r12
    jz        L2667
L2670:
    cmp       %rbx,	2
    jg        L2672
    lea       %rax,	[%rip+mc_decls.xregset]
    mov       %r10,	%r12
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L2674
    lea       %rcx,	[%rip+L8671]
    lea       %rdx,	[%rip+L8672]
    call      pc_api.merror
L2674:
    jmp       L2671
L2672:
    lea       %rax,	[%rip+mc_decls.regset]
    mov       %r10,	%r12
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L2676
    mov       %rsi,	1
    mov       %rax,	[%rip+mc_decls.noperands]
    cmp       %rax,	1
    jl        L2679
L2677:
    cmp       %rbx,	2
    jle       L2681
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	%r12
    jnz       L2681
    mov       %rcx,	%rsi
    mov       %rdx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    mov       %rcx,	%r12
    mov       %rdx,	6
    call      mc_libmcl.mgenreg
    mov       [%rbp + mc_stackmcl.movetoreg.$T1],	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	6
    call      mc_libmcl.mgenreg
    mov       %rcx,	27
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_stackmcl.movetoreg.$T1]
    call      mc_libmcl.genmc
    jmp       L2668
L2681:
    inc       %rsi
    cmp       %rsi,	[%rip+mc_decls.noperands]
    jle       L2677
L2679:
L2676:
L2671:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mc_libmcl.mgenreg
    mov       [%rbp + mc_stackmcl.movetoreg.$T1],	%rax
    mov       %rcx,	%r12
    mov       %rdx,	%rbx
    call      mc_libmcl.mgenreg
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_stackmcl.movetoreg.$T1]
    call      mc_libmcl.genmc
    mov       %al,	%r12b
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11-1],	%al
    cmp       %rbx,	2
    jg        L2683
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.xregset]
    mov       %r11,	%r12
    mov       [%r10 + %r11-1],	%al
    jmp       L2682
L2683:
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.regset]
    mov       %r11,	%r12
    mov       [%r10 + %r11-1],	%al
L2682:
L2667:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.getopnd_ind
mc_stackmcl.getopnd_ind:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    test      %rax,	%rax
    jnz       L2686
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	%rsi
    mov       %rdi,	[%rax + %r10*8-8]
    movzx     %rax,	byte ptr[%rdi+1]
    cmp       %rax,	2
    jnz       L2688
    mov       %rbx,	[%rdi+8]
    movzx     %rax,	byte ptr[%rbx+72]
    cmp       %rax,	5
    jnz       L2691
    movzx     %rax,	byte ptr[%rbx+82]
    cmp       %rax,	11
    jz        L2690
L2691:
    mov       %rax,	[%rdi+8]
    mov       %rcx,	%rax
    mov       %rdx,	%r12
    call      mc_libmcl.mgenmem
    jmp       L2684
L2690:
L2688:
L2686:
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	1
    jz        L2693
    mov       %rcx,	%rsi
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
L2693:
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rcx,	%rax
    mov       %rdx,	%r12
    xor       %r8d,	%r8d
    call      mc_libmcl.mgenireg
L2684:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.getopnd_ind_simp
mc_stackmcl.getopnd_ind_simp:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	1
    jz        L2696
    mov       %rcx,	%rdi
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
L2696:
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rcx,	%rax
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_libmcl.mgenireg
L2694:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.swapopnds
mc_stackmcl.swapopnds:
#?>>
#?]]
#---------------
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	%rcx
    lea       %rax,	[%rax + %r10*8-8]
    lea       %r10,	[%rip+mc_decls.pclopnd]
    mov       %r11,	%rdx
    lea       %r10,	[%r10 + %r11*8-8]
    mov       %r11,	[%rax]
    mov       %r9,	[%r10]
    mov       [%r10],	%r11
    mov       [%rax],	%r9
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rcx
    lea       %rax,	[%rax + %r10-1]
    lea       %r10,	[%rip+mc_decls.pclloc]
    mov       %r11,	%rdx
    lea       %r10,	[%r10 + %r11-1]
    mov       %r11b,	[%rax]
    mov       %r9b,	[%r10]
    mov       [%r10],	%r11b
    mov       [%rax],	%r9b
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%rcx
    lea       %rax,	[%rax + %r10-1]
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	%rdx
    lea       %r10,	[%r10 + %r11-1]
    mov       %r11b,	[%rax]
    mov       %r9b,	[%r10]
    mov       [%r10],	%r11b
    mov       [%rax],	%r9b
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	%rcx
    lea       %rax,	[%rax + %r10-1]
    lea       %r10,	[%rip+mc_decls.pclmode]
    mov       %r11,	%rdx
    lea       %r10,	[%r10 + %r11-1]
    mov       %r11b,	[%rax]
    mov       %r9b,	[%r10]
    mov       [%r10],	%r11b
    mov       [%rax],	%r9b
    lea       %rax,	[%rip+mc_decls.pclcount]
    mov       %r10,	%rcx
    lea       %rax,	[%rax + %r10-1]
    lea       %r10,	[%rip+mc_decls.pclcount]
    mov       %r11,	%rdx
    lea       %r10,	[%r10 + %r11-1]
    mov       %r11b,	[%rax]
    mov       %r9b,	[%r10]
    mov       [%r10],	%r11b
    mov       [%rax],	%r9b
#---------------
    ret       
# End 
# Proc mc_stackmcl.isimmload
mc_stackmcl.isimmload:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	16
#---------------
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	%rcx
    mov       %rdi,	[%rax + %r10*8-8]
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rcx
    movzx     %rax,	byte ptr[%rax + %r10-1]
    test      %rax,	%rax
    jnz       L2700
    movzx     %rax,	byte ptr[%rdi]
    cmp       %rax,	1
    jnz       L2700
    movzx     %rax,	byte ptr[%rdi+1]
    cmp       %rax,	4
    jnz       L2700
    mov       %rax,	%rdi
    jmp       L2699
L2700:
    xor       %eax,	%eax
L2699:
L2698:
#---------------
    add       %rsp,	16
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.setnewzz
mc_stackmcl.setnewzz:
#?>>
#?]]
#---------------
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.pclloc]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11-1],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+mc_decls.pclopnd]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11*8-8],	%rax
    mov       %al,	%cl
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11-1],	%al
    mov       %al,	%dl
    lea       %r10,	[%rip+mc_decls.pclmode]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11-1],	%al
#---------------
    ret       
# End 
# Proc mc_stackmcl.freeworkregs
mc_stackmcl.freeworkregs:
#?>>
    .set mc_stackmcl.freeworkregs.p, 32
    push      %rdi
    push      %rbx
#?]]
#---------------
    lea       %rax,	[%rip+mc_decls.regset]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    lea       %rax,	[%rip+mc_decls.xregset]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    mov       %rbx,	1
    mov       %rax,	[%rip+mc_decls.noperands]
    cmp       %rax,	1
    jl        L2705
L2703:
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rdi,	%rax
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L2707
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	2
    jg        L2709
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.xregset]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    jmp       L2708
L2709:
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.regset]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
L2708:
L2707:
    inc       %rbx
    cmp       %rbx,	[%rip+mc_decls.noperands]
    jle       L2703
L2705:
#---------------
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.swapopndregs
mc_stackmcl.swapopndregs:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	2
    jg        L2712
    lea       %rcx,	[%rip+L8673]
    lea       %rdx,	[%rip+L8674]
    call      pc_api.merror
L2712:
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rdi,	%rax
    cmp       %rdi,	%rsi
    jz        L2710
L2714:
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rbx,	%rax
    cmp       %rbx,	1
    jl        L2718
L2715:
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	1
    jnz       L2720
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	%rsi
    jnz       L2720
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	[%rip+mc_decls.noperands]
    lea       %rax,	[%rax + %r10-1]
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	%rbx
    lea       %r10,	[%r10 + %r11-1]
    mov       %r11b,	[%rax]
    mov       %r9b,	[%r10]
    mov       [%r10],	%r11b
    mov       [%rax],	%r9b
    jmp       L2710
L2720:
    dec       %rbx
    cmp       %rbx,	1
    jge       L2715
L2718:
    xor       %eax,	%eax
    lea       %r10,	[%rip+mc_decls.regset]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    mov       %al,	%sil
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11-1],	%al
L2710:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.makeopndind
mc_stackmcl.makeopndind:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    movzx     %rax,	word ptr[%rdi+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jz        L2723
    lea       %rcx,	[%rip+L8675]
    lea       %rdx,	[%rip+L8676]
    call      pc_api.merror
L2723:
    movzx     %rax,	byte ptr[%rdi+10]
    mov       %rcx,	%rax
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_libmcl.mgenireg
L2721:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.makesimpleaddr
mc_stackmcl.makesimpleaddr:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
#---------------
    movzx     %rax,	byte ptr[%r13+10]
    mov       %rsi,	%rax
    movzx     %rax,	byte ptr[%r13+11]
    mov       %r12,	%rax
    cmp       %rsi,	15
    jnz       L2726
    xor       %rsi,	%rsi
L2726:
    movzx     %rax,	word ptr[%r13+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	3
    jz        L2728
    lea       %rcx,	[%rip+L8677]
    lea       %rdx,	[%rip+L8678]
    call      pc_api.merror
L2728:
    test      %rsi,	%rsi
    jnz       L2730
    test      %r12,	%r12
    jnz       L2730
    call      mc_stackmcl.getworkireg
    mov       %rbx,	%rax
    jmp       L2729
L2730:
    test      %rsi,	%rsi
    jz        L2731
    mov       %rax,	%r13
    jmp       L2724
L2731:
    test      %r12,	%r12
    jz        L2732
    mov       %rbx,	%r12
    jmp       L2729
L2732:
    mov       %rbx,	%r12
L2729:
    mov       %rcx,	%rbx
    mov       %rdx,	10
    xor       %r8d,	%r8d
    call      mc_libmcl.mgenireg
    mov       %rdi,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	14
    mov       %rdx,	%rax
    mov       %r8,	%r13
    call      mc_libmcl.genmc
    mov       %rax,	%rdi
L2724:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.checkallloaded
mc_stackmcl.checkallloaded:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rdi,	1
    mov       %rax,	[%rip+mc_decls.noperands]
    cmp       %rax,	1
    jl        L2736
L2734:
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    test      %rax,	%rax
    jnz       L2738
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    movzx     %rax,	byte ptr[%rax+1]
    cmp       %rax,	1
    jnz       L2738
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    movzx     %rax,	byte ptr[%rax+3]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
L2738:
    inc       %rdi
    cmp       %rdi,	[%rip+mc_decls.noperands]
    jle       L2734
L2736:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.stropndstack
mc_stackmcl.stropndstack:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
    lea       %rax,	[%rip+mc_stackmcl.stropndstack.str]
    mov       %rdi,	%rax
    test      %r12,	%r12
    jz        L2741
    mov       %rcx,	%rdi
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8679]
    call      msys.m$print_setfmt
    mov       %rcx,	[%rip+mc_decls.noperands]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L2740
L2741:
    mov       %rcx,	%rdi
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8680]
    call      msys.m$print_setfmt
    mov       %rcx,	[%rip+mc_decls.noperands]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
L2740:
    mov       %rbx,	1
    mov       %rax,	[%rip+mc_decls.noperands]
    cmp       %rax,	1
    jl        L2744
L2742:
    mov       %rax,	[%rip+mc_decls.noperands]
    sub       %rax,	%rbx
    inc       %rax
    sub       %rax,	1
    cmp       %rax,	4
    jae       L2747
    lea       %r10,	[%rip+L2746]
    jmp       [%r10 + %rax*8]
    .data
L2746:
    .quad     L2748
    .quad     L2749
    .quad     L2750
    .quad     L2751
    .text
L2748:
    lea       %rax,	[%rip+L8681]
    jmp       L2745
L2749:
    lea       %rax,	[%rip+L8682]
    jmp       L2745
L2750:
    lea       %rax,	[%rip+L8683]
    jmp       L2745
L2751:
    lea       %rax,	[%rip+L8684]
    jmp       L2745
L2747:
    lea       %rax,	[%rip+L8685]
L2745:
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      strcat
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	1
    jz        L2753
    cmp       %rax,	2
    jz        L2753
    cmp       %rax,	3
    jz        L2754
    jmp       L2755
L2753:
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	2
    jg        L2757
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10-1]
    lea       %r10,	[%rip+mc_decls.xregnames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%rdi
    mov       %rdx,	%r10
    call      strcat
    jmp       L2756
L2757:
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10-1]
    lea       %r10,	[%rip+mc_decls.regnames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%rdi
    mov       %rdx,	%r10
    call      strcat
L2756:
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	2
    jnz       L2759
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8686]
    call      strcat
L2759:
    jmp       L2752
L2754:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8687]
    call      strcat
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      msys.strint
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      strcat
    jmp       L2752
L2755:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8688]
    call      strcat
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8689]
    call      strcat
L2752:
    lea       %rax,	[%rip+mc_decls.pclcount]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	1
    jle       L2761
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8690]
    call      strcat
L2761:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8691]
    call      strcat
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10-1]
    lea       %r10,	[%rip+pc_tables.pstdnames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%rdi
    mov       %rdx,	%r10
    call      strcat
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8692]
    call      strcat
    cmp       %rbx,	[%rip+mc_decls.noperands]
    jge       L2763
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8693]
    call      strcat
L2763:
    inc       %rbx
    cmp       %rbx,	[%rip+mc_decls.noperands]
    jle       L2742
L2744:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8694]
    call      strcat
    lea       %rcx,	[%rip+mc_stackmcl.stropndstack.str]
    mov       %rdx,	50
    lea       %r8,	[%rip+L8695]
    call      mlib.ipadstr
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8696]
    call      strcat
    mov       %rsi,	1
L2764:
    lea       %rax,	[%rip+mc_decls.regset]
    mov       %r10,	%rsi
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L2768
    lea       %rax,	[%rip+L8697]
    jmp       L2767
L2768:
    lea       %rax,	[%rip+L8698]
L2767:
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      strcat
    inc       %rsi
    cmp       %rsi,	10
    jle       L2764
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8699]
    call      strcat
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8700]
    call      strcat
    mov       %rsi,	1
    mov       %rax,	[%rip+mc_decls.xregmax]
    cmp       %rax,	1
    jl        L2771
L2769:
    lea       %rax,	[%rip+mc_decls.xregset]
    mov       %r10,	%rsi
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L2773
    lea       %rax,	[%rip+L8701]
    jmp       L2772
L2773:
    lea       %rax,	[%rip+L8702]
L2772:
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      strcat
    inc       %rsi
    cmp       %rsi,	[%rip+mc_decls.xregmax]
    jle       L2769
L2771:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8703]
    call      strcat
    mov       %rcx,	[%rip+mc_decls.mstackdepth]
    xor       %edx,	%edx
    call      msys.strint
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      strcat
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8704]
    call      strcat
    mov       %rcx,	[%rip+mc_decls.noperands]
    xor       %edx,	%edx
    call      msys.strint
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      strcat
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8705]
    call      strcat
    mov       %rcx,	[%rip+mc_decls.ncalldepth]
    xor       %edx,	%edx
    call      msys.strint
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      strcat
    mov       %rax,	%rdi
L2739:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.showopndstack
mc_stackmcl.showopndstack:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    mov       %rcx,	1
    call      mc_stackmcl.stropndstack
    mov       %rcx,	%rax
    call      mc_libmcl.mgencomment
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_optim.peephole
mc_optim.peephole:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
    mov       %al,	[%rip+pc_decls.fpeephole]
    test      %al,	%al
    jz        L2775
L2777:
    mov       %rax,	[%rip+mc_decls.mccode]
    mov       %rdi,	[%rax+8]
    jmp       L2781
L2778:
    mov       %rbx,	[%rdi+8]
    mov       %rsi,	[%rbx+8]
    movzx     %rax,	byte ptr[%rdi+33]
    cmp       %rax,	8
    jz        L2783
    cmp       %rax,	11
    jz        L2784
    cmp       %rax,	38
    jz        L2785
    cmp       %rax,	40
    jz        L2786
    cmp       %rax,	26
    jz        L2787
    jmp       L2788
L2783:
    jmp       L2780
L2784:
    movzx     %rax,	byte ptr[%rbx+33]
    cmp       %rax,	11
    jz        L2790
    cmp       %rax,	41
    jz        L2791
    cmp       %rax,	42
    jz        L2792
    cmp       %rax,	28
    jz        L2793
    cmp       %rax,	29
    jz        L2793
    cmp       %rax,	52
    jz        L2794
    cmp       %rax,	53
    jz        L2794
    cmp       %rax,	25
    jz        L2795
    jmp       L2796
L2790:
    mov       %rax,	[%rdi+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg0
    test      %rax,	%rax
    jz        L2798
    mov       %rax,	[%rdi+16]
    mov       %r10,	[%rbx+24]
    cmp       %rax,	%r10
    jnz       L2798
    mov       %rcx,	%rbx
    call      mc_optim.endr0
    test      %rax,	%rax
    jz        L2798
    mov       %rax,	[%rbx+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg10
    test      %rax,	%rax
    jnz       L2799
L2800:
    mov       %rax,	[%rbx+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg
    test      %rax,	%rax
    jnz       L2802
    mov       %rax,	[%rdi+24]
    mov       %rcx,	%rax
    call      mc_optim.isreg
    test      %rax,	%rax
    jz        L2801
L2802:
    mov       %rax,	[%rbx+16]
    mov       [%rdi+16],	%rax
    mov       %rcx,	%rbx
    call      mc_optim.deletemcl
L2801:
L2799:
    jmp       L2797
L2798:
    mov       %rax,	[%rdi+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg0
    test      %rax,	%rax
    jz        L2803
    mov       %rax,	[%rdi+16]
    mov       %r10,	[%rbx+24]
    cmp       %rax,	%r10
    jnz       L2803
    mov       %rax,	[%rbx+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg10
    test      %rax,	%rax
    jz        L2803
    movzx     %rax,	byte ptr[%rsi+33]
    cmp       %rax,	21
    jnz       L2803
    mov       %rcx,	%rsi
    call      mc_optim.endr0
    test      %rax,	%rax
    jz        L2803
    mov       %rax,	[%rbx+16]
    mov       [%rdi+16],	%rax
    mov       %rcx,	%rbx
    call      mc_optim.deletemcl
L2803:
L2797:
    jmp       L2789
L2791:
    mov       %rax,	[%rdi+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg0
    test      %rax,	%rax
    jz        L2805
    mov       %rax,	[%rdi+16]
    mov       %r10,	[%rbx+16]
    cmp       %r10,	%rax
    jnz       L2806
    mov       %rax,	[%rbx+24]
    cmp       %r10,	%rax
    jnz       L2806
    mov       %rax,	1
    jmp       L2807
L2806:
    xor       %eax,	%eax
L2807:
    test      %rax,	%rax
    setnz     %al
    movzx     %eax,	%al
    test      %ax,	%ax
    jz        L2805
    mov       %rax,	[%rdi+24]
    mov       %rcx,	%rax
    call      mc_optim.isreg
    test      %rax,	%rax
    jz        L2805
    mov       %rcx,	%rsi
    call      mc_optim.endr0
    test      %rax,	%rax
    jz        L2805
    mov       %al,	41
    mov       [%rdi+33],	%al
    mov       %rax,	[%rdi+24]
    mov       [%rdi+16],	%rax
    mov       %rcx,	%rbx
    call      mc_optim.deletemcl
    mov       %rdi,	%rax
L2805:
    jmp       L2789
L2792:
    mov       %rax,	[%rdi+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg0
    test      %rax,	%rax
    jz        L2809
    mov       %rax,	[%rdi+16]
    mov       %r10,	[%rbx+16]
    cmp       %rax,	%r10
    jnz       L2809
    mov       %rax,	[%rdi+24]
    mov       %rcx,	%rax
    call      mc_optim.isreg
    test      %rax,	%rax
    jz        L2809
    mov       %rcx,	%rsi
    call      mc_optim.endr0
    test      %rax,	%rax
    jz        L2809
    mov       %al,	42
    mov       [%rdi+33],	%al
    mov       %rax,	[%rdi+24]
    mov       [%rdi+16],	%rax
    mov       %rax,	[%rbx+24]
    mov       [%rdi+24],	%rax
    mov       %rcx,	%rbx
    call      mc_optim.deletemcl
L2809:
    jmp       L2789
L2793:
    mov       %rax,	[%rdi+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg
    test      %rax,	%rax
    jz        L2811
    mov       %rax,	[%rdi+16]
    mov       %r10,	[%rbx+16]
    cmp       %rax,	%r10
    jnz       L2811
    mov       %rax,	[%rdi+24]
    mov       %rcx,	%rax
    call      mc_optim.isreg
    test      %rax,	%rax
    jz        L2811
    mov       %rax,	[%rbx+24]
    mov       %rcx,	%rax
    call      mc_optim.isconst
    test      %rax,	%rax
    jz        L2811
    mov       %al,	14
    mov       [%rdi+33],	%al
    sub       %rsp,	8
    push      0
    push      0
    push      0
    movzx     %rax,	byte ptr[%rbx+33]
    cmp       %rax,	28
    jnz       L2813
    mov       %rax,	[%rbx+24]
    mov       %rax,	[%rax]
    jmp       L2812
L2813:
    mov       %rax,	[%rbx+24]
    mov       %rax,	[%rax]
    neg       %rax
L2812:
    mov       %r10,	[%rdi+24]
    movzx     %r10,	byte ptr[%r10+10]
    mov       %rcx,	%r10
    xor       %edx,	%edx
    mov       %r8,	1
    mov       %r9,	%rax
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       [%rdi+24],	%rax
    mov       %rcx,	%rbx
    call      mc_optim.deletemcl
L2811:
    jmp       L2789
L2794:
    mov       %rax,	[%rdi+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg
    test      %rax,	%rax
    jz        L2815
    mov       %rax,	[%rdi+16]
    mov       %r10,	[%rbx+16]
    cmp       %rax,	%r10
    jnz       L2815
    mov       %rax,	[%rdi+24]
    mov       %rcx,	%rax
    call      mc_optim.isreg
    test      %rax,	%rax
    jz        L2815
    mov       %al,	14
    mov       [%rdi+33],	%al
    sub       %rsp,	8
    push      0
    push      0
    push      0
    movzx     %rax,	byte ptr[%rbx+33]
    cmp       %rax,	52
    jnz       L2817
    mov       %rax,	1
    jmp       L2816
L2817:
    mov       %rax,	-1
L2816:
    mov       %r10,	[%rdi+24]
    movzx     %r10,	byte ptr[%r10+10]
    mov       %rcx,	%r10
    xor       %edx,	%edx
    mov       %r8,	1
    mov       %r9,	%rax
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       [%rdi+24],	%rax
    mov       %rcx,	%rbx
    call      mc_optim.deletemcl
L2815:
    jmp       L2789
L2795:
    mov       %rax,	[%rdi+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg0
    test      %rax,	%rax
    jz        L2819
    mov       %rax,	[%rbx+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg0
    test      %rax,	%rax
    jz        L2819
    mov       %al,	25
    mov       [%rdi+33],	%al
    mov       %rax,	[%rdi+24]
    mov       [%rdi+16],	%rax
    xor       %eax,	%eax
    mov       [%rdi+24],	%rax
    mov       %rcx,	%rbx
    call      mc_optim.deletemcl
L2819:
L2796:
L2789:
    jmp       L2782
L2785:
    movzx     %rax,	byte ptr[%rbx+33]
    cmp       %rax,	41
    jnz       L2821
    mov       %rax,	[%rdi+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg0
    test      %rax,	%rax
    jz        L2823
    mov       %rax,	[%rdi+16]
    mov       %r10,	[%rbx+16]
    cmp       %r10,	%rax
    jnz       L2824
    mov       %rax,	[%rbx+24]
    cmp       %r10,	%rax
    jnz       L2824
    mov       %rax,	1
    jmp       L2825
L2824:
    xor       %eax,	%eax
L2825:
    test      %rax,	%rax
    setnz     %al
    movzx     %eax,	%al
    test      %ax,	%ax
    jz        L2823
    mov       %rcx,	%rsi
    call      mc_optim.endr0
    test      %rax,	%rax
    jz        L2823
    mov       %rcx,	%rbx
    call      mc_optim.deletemcl
    mov       %rdi,	%rax
L2823:
L2821:
    jmp       L2782
L2786:
    movzx     %rax,	byte ptr[%rbx+33]
    cmp       %rax,	11
    jnz       L2827
    mov       %rax,	[%rdi+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg0
    test      %rax,	%rax
    jz        L2829
    mov       %rax,	[%rdi+16]
    mov       %r10,	[%rdi+24]
    cmp       %rax,	%r10
    jnz       L2829
    mov       %rax,	[%rbx+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg
    test      %rax,	%rax
    jz        L2829
    mov       %rax,	[%rbx+24]
    mov       %rcx,	%rax
    call      mc_optim.isreg0
    test      %rax,	%rax
    jz        L2829
    mov       %rcx,	%rbx
    call      mc_optim.endr0
    test      %rax,	%rax
    jz        L2829
    mov       %rax,	[%rbx+16]
    mov       [%rdi+24],	%rax
    mov       [%rdi+16],	%rax
    mov       %rcx,	%rbx
    call      mc_optim.deletemcl
    mov       %rdi,	%rax
L2829:
L2827:
    jmp       L2782
L2787:
    movzx     %rax,	byte ptr[%rbx+33]
    cmp       %rax,	25
    jnz       L2831
    movzx     %rax,	byte ptr[%rsi+33]
    cmp       %rax,	9
    jnz       L2831
    mov       %rax,	[%rdi+16]
    mov       %rax,	[%rax]
    mov       %r10,	[%rsi+16]
    mov       %r10,	[%r10]
    cmp       %rax,	%r10
    jnz       L2831
    mov       %rcx,	%rdi
    call      mc_optim.endr0
    test      %rax,	%rax
    jz        L2831
    movzx     %rax,	byte ptr[%rdi+34]
    lea       %r10,	[%rip+mc_decls.asmrevcond]
    mov       %r10,	[%r10 + %rax*8]
    mov       [%rdi+34],	%r10b
    mov       %rax,	[%rbx+16]
    mov       [%rdi+16],	%rax
    mov       %rcx,	%rbx
    call      mc_optim.deletemcl
    mov       %rdi,	%rax
L2831:
L2788:
L2782:
    mov       %rdi,	[%rdi+8]
L2781:
    test      %rdi,	%rdi
    jnz       L2778
L2780:
L2775:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_optim.isreg
mc_optim.isreg:
#?>>
#?]]
#---------------
    movzx     %rax,	word ptr[%rcx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    setz      %al
    movzx     %eax,	%al
L2832:
#---------------
    ret       
# End 
# Proc mc_optim.isreg0
mc_optim.isreg0:
#?>>
#?]]
#---------------
    test      %rcx,	%rcx
    jnz       L2835
    xor       %eax,	%eax
    jmp       L2833
L2835:
    movzx     %rax,	word ptr[%rcx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jnz       L2837
    movzx     %rax,	byte ptr[%rcx+10]
    cmp       %rax,	1
    jnz       L2837
    mov       %rax,	1
    jmp       L2833
L2837:
    xor       %eax,	%eax
L2833:
#---------------
    ret       
# End 
# Proc mc_optim.isreg10
mc_optim.isreg10:
#?>>
#?]]
#---------------
    test      %rcx,	%rcx
    jnz       L2840
    xor       %eax,	%eax
    jmp       L2838
L2840:
    movzx     %rax,	word ptr[%rcx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jnz       L2842
    movzx     %rax,	byte ptr[%rcx+10]
    cmp       %rax,	11
    jnz       L2842
    mov       %rax,	1
    jmp       L2838
L2842:
    xor       %eax,	%eax
L2838:
#---------------
    ret       
# End 
# Proc mc_optim.isreg00
mc_optim.isreg00:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	[%rdi+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg
    test      %rax,	%rax
    jz        L2845
    mov       %rax,	[%rdi+16]
    mov       %r10,	[%rdi+24]
    cmp       %rax,	%r10
    jnz       L2845
    mov       %rax,	1
    jmp       L2843
L2845:
    xor       %eax,	%eax
L2843:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_optim.isconst
mc_optim.isconst:
#?>>
#?]]
#---------------
    test      %rcx,	%rcx
    jnz       L2848
    xor       %eax,	%eax
    jmp       L2846
L2848:
    movzx     %rax,	word ptr[%rcx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	2
    jnz       L2850
    movzx     %rax,	word ptr[%rcx+8]
    shr       %rax,	12
    and       %rax,	15
    cmp       %rax,	1
    jnz       L2850
    mov       %rax,	1
    jmp       L2846
L2850:
    xor       %eax,	%eax
L2846:
#---------------
    ret       
# End 
# Proc mc_optim.sameoperand
mc_optim.sameoperand:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	16
    call      memcmp
    movsxd    %r10,	%eax
    cmp       %r10,	0
    setz      %r10b
    movzx     %r10d,	%r10b
    mov       %rax,	%r10
L2851:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_optim.sameregopnd
mc_optim.sameregopnd:
#?>>
#?]]
#---------------
    movzx     %rax,	word ptr[%rcx+8]
    shr       %rax,	9
    and       %rax,	7
    movzx     %r10,	word ptr[%rdx+8]
    shr       %r10,	9
    and       %r10,	7
    cmp       %r10,	%rax
    jnz       L2855
    cmp       %r10,	1
    jz        L2854
L2855:
    xor       %eax,	%eax
    jmp       L2852
L2854:
    movzx     %rax,	byte ptr[%rcx+10]
    movzx     %r10,	byte ptr[%rdx+10]
    cmp       %rax,	%r10
    setz      %al
    movzx     %eax,	%al
L2852:
#---------------
    ret       
# End 
# Proc mc_optim.deletemcl
mc_optim.deletemcl:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    mov       %rdi,	[%rsi]
    mov       %rbx,	[%rsi+8]
    test      %rdi,	%rdi
    jz        L2859
    test      %rbx,	%rbx
    jnz       L2858
L2859:
    lea       %rcx,	[%rip+L8706]
    lea       %rdx,	[%rip+L8707]
    call      pc_api.merror
L2858:
    mov       [%rdi+8],	%rbx
    mov       [%rbx],	%rdi
    mov       %rax,	%rbx
L2856:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_optim.endr0
mc_optim.endr0:
#?>>
#?]]
#---------------
    lea       %rax,	[%rcx+48]
    movzx     %rax,	byte ptr[%rax]
L2860:
#---------------
    ret       
# End 
# Proc mc_genss_dummy.genss
mc_genss_dummy.genss:
#?>>
    .set mc_genss_dummy.genss.obj, 16
#?]]
#---------------
#---
#---------------
    ret       
# End 
# Proc mc_decls.start
mc_decls.start:
#?>>
    push      %rdi
    push      %rbx
#?]]
#---------------
    xor       %rbx,	%rbx
    mov       %rax,	13
    mov       %rdi,	%rax
    cmp       %rdi,	0
    jl        L2865
L2863:
    mov       %al,	10
    lea       %r10,	[%rip+mc_decls.ploadop]
    mov       %r11,	%rbx
    mov       [%r10 + %r11],	%al
    inc       %rbx
    cmp       %rbx,	%rdi
    jle       L2863
L2865:
    mov       %al,	19
    lea       %r10,	[%rip+mc_decls.ploadop]
    mov       [%r10+5],	%al
    lea       %r10,	[%rip+mc_decls.ploadop]
    mov       [%r10+4],	%al
    lea       %r10,	[%rip+mc_decls.ploadop]
    mov       [%r10+3],	%al
    mov       %al,	18
    lea       %r10,	[%rip+mc_decls.ploadop]
    mov       [%r10+9],	%al
    lea       %r10,	[%rip+mc_decls.ploadop]
    mov       [%r10+8],	%al
    lea       %r10,	[%rip+mc_decls.ploadop]
    mov       [%r10+7],	%al
    mov       %al,	16
    lea       %r10,	[%rip+mc_decls.ploadop]
    mov       [%r10+1],	%al
    mov       %al,	17
    lea       %r10,	[%rip+mc_decls.ploadop]
    mov       [%r10+2],	%al
    mov       %al,	11
    lea       %r10,	[%rip+mc_decls.ploadop]
    mov       [%r10+10],	%al
    lea       %r10,	[%rip+mc_decls.ploadop]
    mov       [%r10+6],	%al
#---------------
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writegas.getassemstr
mc_writegas.getassemstr:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
#---------------
    mov       %rcx,	[%rip+pc_decls.pdest]
    call      mlib.gs_init
    lea       %rcx,	[%rip+L8708]
    call      mc_writegas.asmstr
    lea       %rcx,	[%rip+L8709]
    call      mc_writegas.asmstr
    lea       %rcx,	[%rip+L8710]
    call      mc_writegas.asmstr
    mov       %rdi,	[%rip+pc_decls.psymboltable]
    jmp       L2870
L2867:
    mov       %al,	[%rdi+81]
    test      %al,	%al
    jz        L2872
    lea       %rcx,	[%rip+L8711]
    call      mc_writegas.asmstr
    mov       %rax,	[%rdi]
    mov       %rcx,	%rax
    call      pc_api.getbasename
    mov       %rcx,	%rax
    call      mc_writegas.asmstr
    lea       %rcx,	[%rip+L8712]
    call      mc_writegas.asmstr
L2872:
    mov       %rdi,	[%rdi+8]
L2870:
    test      %rdi,	%rdi
    jnz       L2867
    lea       %rcx,	[%rip+L8712]
    call      mc_writegas.asmstr
    mov       %rbx,	[%rip+mc_decls.mccode]
    mov       %rsi,	1
    jmp       L2874
L2873:
    mov       %rcx,	%rsi
    mov       %rdx,	%rbx
    call      mc_writegas.writemcl
    inc       %rsi
    mov       %rbx,	[%rbx+8]
L2874:
    test      %rbx,	%rbx
    jnz       L2873
    mov       %r12b,	1
    mov       %rdi,	[%rip+pc_decls.psymboltable]
    jmp       L2879
L2876:
    movzx     %rax,	byte ptr[%rdi+104]
    shr       %eax,	2
    and       %eax,	1
    test      %rax,	%rax
    jz        L2881
    test      %r12b,	%r12b
    jz        L2883
    xor       %r12b,	%r12b
    lea       %rcx,	[%rip+L8713]
    call      mc_writegas.asmstr
L2883:
    lea       %rcx,	[%rip+L8714]
    call      mc_writegas.asmstr
    mov       %rcx,	[%rdi]
    call      mc_writegas.asmstr
    lea       %rcx,	[%rip+L8715]
    call      mc_writegas.asmstr
L2881:
    mov       %rdi,	[%rdi+8]
L2879:
    test      %rdi,	%rdi
    jnz       L2876
    lea       %rcx,	[%rip+L8716]
    call      mc_writegas.asmstr
    mov       %rax,	[%rip+pc_decls.pdest]
L2866:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writegas.writemcl
mc_writegas.writemcl:
#?>>
    .set mc_writegas.writemcl.index, 24
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rdx
#---------------
    movzx     %rax,	byte ptr[%rdi+33]
    cmp       %rax,	6
    jnz       L2887
L2886:
    jmp       L2885
L2887:
    mov       %rcx,	%rdi
    call      mc_writegas.strmcl
    mov       %rcx,	[%rip+pc_decls.pdest]
    call      mlib.gs_line
L2885:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_writegas.start
mc_writegas.start:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	16
#---------------
    mov       %rax,	5456199
    mov       [%rip+pc_decls.assemtype],	%rax
    mov       %rsi,	1
L2889:
    mov       %rax,	%rsi
    cmp       %rax,	1
    jz        L2894
    cmp       %rax,	2
    jz        L2894
    cmp       %rax,	4
    jz        L2894
    cmp       %rax,	8
    jnz       L2893
L2894:
    mov       %r12,	1
L2895:
    xor       %dil,	%dil
    mov       %rax,	1
    mov       %r13,	%rax
    mov       %rbx,	137
    cmp       %rbx,	1
    jl        L2900
L2898:
    test      %dil,	%dil
    jz        L2902
    lea       %rax,	[%rip+mc_decls.regsizes]
    mov       %r10,	%r13
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	%rsi
    jnz       L2904
    lea       %rax,	[%rip+mc_decls.regindices]
    mov       %r10,	%r13
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	%r12
    jnz       L2904
    lea       %rax,	[%rip+mc_decls.dregnames]
    mov       %r10,	%r13
    mov       %rax,	[%rax + %r10*8-8]
    lea       %r10,	[%rip+mc_writegas.nregnames]
    mov       %r11,	%rsi
    shl       %r11,	7
    lea       %r10,	[%r10 + %r11-128]
    mov       %r11,	%r12
    mov       [%r10 + %r11*8-8],	%rax
L2904:
    jmp       L2901
L2902:
    lea       %rax,	[%rip+mc_decls.regsizes]
    mov       %r10,	%r13
    movzx     %rax,	byte ptr[%rax + %r10-1]
    test      %rax,	%rax
    jnz       L2905
    mov       %dil,	1
L2905:
L2901:
    inc       %r13
    cmp       %r13,	%rbx
    jle       L2898
L2900:
    inc       %r12
    cmp       %r12,	16
    jle       L2895
L2893:
    inc       %rsi
    cmp       %rsi,	8
    jle       L2889
#---------------
    add       %rsp,	16
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writegas.strmcl
mc_writegas.strmcl:
#?>>
    .set mc_writegas.strmcl.mcl, 72
    .set mc_writegas.strmcl.opcname, -128
    .set mc_writegas.strmcl.$T1, -136
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	168
    mov       [%rbp+72],	%rcx
#---------------
    mov       %rax,	[%rbp + mc_writegas.strmcl.mcl]
    movzx     %rax,	byte ptr[%rax+33]
    mov       %rsi,	%rax
    mov       %rax,	[%rbp + mc_writegas.strmcl.mcl]
    movzx     %rax,	byte ptr[%rax+34]
    mov       %r12,	%rax
    mov       %rax,	[%rbp + mc_writegas.strmcl.mcl]
    mov       %rdi,	[%rax+16]
    mov       %rax,	[%rbp + mc_writegas.strmcl.mcl]
    mov       %rbx,	[%rax+24]
    xor       %r14,	%r14
    mov       %rax,	%rsi
    cmp       %rax,	1
    jz        L2908
    cmp       %rax,	2
    jz        L2909
    cmp       %rax,	3
    jz        L2910
    cmp       %rax,	4
    jz        L2911
    cmp       %rax,	9
    jz        L2912
    cmp       %rax,	5
    jz        L2913
    cmp       %rax,	123
    jz        L2914
    cmp       %rax,	121
    jz        L2915
    cmp       %rax,	122
    jz        L2916
    jmp       L2917
L2908:
    lea       %rcx,	[%rip+L8717]
    call      mc_writegas.asmstr
    mov       %rax,	[%rdi]
    mov       %rcx,	[%rax]
    call      mc_writegas.asmstr
    mov       %rax,	[%rdi]
    mov       [%rip+mc_decls.currasmproc],	%rax
    jmp       L2906
L2909:
    lea       %rcx,	[%rip+L8718]
    call      mc_writegas.asmstr
    xor       %eax,	%eax
    mov       [%rip+mc_decls.currasmproc],	%rax
    jmp       L2906
L2910:
    mov       %rcx,	8227
    call      mc_writegas.asmchar
    mov       %rcx,	[%rdi]
    call      mc_writegas.asmstr
    jmp       L2906
L2911:
    mov       %r15,	[%rdi]
    movzx     %rax,	word ptr[%rdi+8]
    shr       %rax,	12
    and       %rax,	15
    cmp       %rax,	5
    jz        L2919
    cmp       %rax,	4
    jz        L2920
    jmp       L2921
L2919:
    mov       %rcx,	%r15
    call      mc_writegas.getdispname
    mov       %rcx,	%rax
    call      mc_writegas.asmstr
    jmp       L2918
L2920:
    mov       %rcx,	[%rdi]
    call      mc_writegas.asmstr
    jmp       L2906
L2921:
    lea       %rcx,	[%rip+L8719]
    lea       %rdx,	[%rip+L8720]
    call      pc_api.merror
L2918:
    lea       %rcx,	[%rip+L8721]
    call      mc_writegas.asmstr
    mov       %al,	[%r15+81]
    test      %al,	%al
    jz        L2923
    mov       %rax,	[%r15]
    mov       [%rbp + mc_writegas.strmcl.$T1],	%rax
    mov       %rax,	[%r15]
    mov       %rcx,	%rax
    call      pc_api.getbasename
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_writegas.strmcl.$T1]
    call      mlib.eqstring
    test      %rax,	%rax
    jnz       L2924
L2925:
    lea       %rcx,	[%rip+L8722]
    call      mc_writegas.asmstr
    mov       %rax,	[%r15]
    mov       %rcx,	%rax
    call      pc_api.getbasename
    mov       %rcx,	%rax
    call      mc_writegas.asmstr
    lea       %rcx,	[%rip+L8723]
    call      mc_writegas.asmstr
L2924:
L2923:
    jmp       L2906
L2912:
    movzx     %rax,	word ptr[%rdi+8]
    shr       %rax,	12
    and       %rax,	15
    cmp       %rax,	6
    jnz       L2927
    lea       %rcx,	[%rip+mc_writegas.strmcl.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8724]
    call      msys.m$print_setfmt
    mov       %rcx,	[%rdi]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L2926
L2927:
    jmp       L2911
L2926:
    lea       %rcx,	[%rip+mc_writegas.strmcl.str]
    call      mc_writegas.asmstr
    jmp       L2906
L2913:
    lea       %rcx,	[%rip+L8725]
    call      mc_writegas.asmstr
    mov       %rcx,	[%rdi]
    call      mc_writegas.asmstr
    lea       %rcx,	[%rip+L8726]
    call      mc_writegas.asmstr
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    xor       %r8d,	%r8d
    call      mc_writegas.asmopnd
    jmp       L2906
    jmp       L2907
L2914:
    lea       %rcx,	[%rip+L8727]
    call      mc_writegas.asmstr
    mov       %al,	1
    mov       [%rip+mc_writegas.currseg],	%al
    jmp       L2906
L2915:
    lea       %rcx,	[%rip+L8728]
    call      mc_writegas.asmstr
    mov       %al,	2
    mov       [%rip+mc_writegas.currseg],	%al
    jmp       L2906
L2916:
    lea       %rcx,	[%rip+L8729]
    call      mc_writegas.asmstr
    mov       %al,	3
    mov       [%rip+mc_writegas.currseg],	%al
    jmp       L2906
L2917:
L2907:
    mov       %rax,	%rsi
    cmp       %rax,	26
    jz        L2929
    cmp       %rax,	58
    jz        L2930
    cmp       %rax,	15
    jz        L2931
    cmp       %rax,	38
    jz        L2932
    cmp       %rax,	39
    jz        L2933
    cmp       %rax,	40
    jz        L2934
    cmp       %rax,	51
    jz        L2935
    cmp       %rax,	34
    jz        L2936
    cmp       %rax,	19
    jz        L2937
    cmp       %rax,	18
    jz        L2938
    cmp       %rax,	16
    jz        L2939
    cmp       %rax,	11
    jz        L2940
    cmp       %rax,	124
    jz        L2941
    cmp       %rax,	125
    jz        L2942
    cmp       %rax,	116
    jz        L2943
    cmp       %rax,	117
    jz        L2944
    cmp       %rax,	118
    jz        L2945
    cmp       %rax,	119
    jz        L2946
    cmp       %rax,	120
    jz        L2947
    cmp       %rax,	8
    jz        L2948
    jmp       L2949
L2929:
    lea       %rcx,	[%rbp + mc_writegas.strmcl.opcname]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8730]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rax,	[%rip+mc_decls.asmcondnames]
    mov       %r10,	%r12
    mov       %rcx,	[%rax + %r10*8]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L2928
L2930:
    lea       %rcx,	[%rbp + mc_writegas.strmcl.opcname]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8731]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rax,	[%rip+mc_decls.asmcondnames]
    mov       %r10,	%r12
    mov       %rcx,	[%rax + %r10*8]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L2928
L2931:
    lea       %rcx,	[%rbp + mc_writegas.strmcl.opcname]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8732]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rax,	[%rip+mc_decls.asmcondnames]
    mov       %r10,	%r12
    mov       %rcx,	[%rax + %r10*8]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L2928
L2932:
    lea       %rcx,	[%rbp + mc_writegas.strmcl.opcname]
    lea       %rdx,	[%rip+L8733]
    call      strcpy
    jmp       L2928
L2933:
    lea       %rcx,	[%rbp + mc_writegas.strmcl.opcname]
    lea       %rdx,	[%rip+L8734]
    call      strcpy
    jmp       L2928
L2934:
    lea       %rcx,	[%rbp + mc_writegas.strmcl.opcname]
    lea       %rdx,	[%rip+L8735]
    call      strcpy
    jmp       L2928
L2935:
    lea       %rcx,	[%rbp + mc_writegas.strmcl.opcname]
    lea       %rdx,	[%rip+L8736]
    call      strcpy
    jmp       L2928
L2936:
    lea       %rcx,	[%rbp + mc_writegas.strmcl.opcname]
    lea       %rdx,	[%rip+L8737]
    call      strcpy
    jmp       L2928
L2937:
    movzx     %rax,	word ptr[%rdi+8]
    and       %rax,	31
    cmp       %rax,	8
    jnz       L2951
    movzx     %rax,	word ptr[%rbx+8]
    and       %rax,	31
    cmp       %rax,	4
    jnz       L2951
    mov       %rcx,	%rdi
    mov       %rdx,	4
    call      mc_libmcl.changeopndsize
    mov       %rdi,	%rax
    mov       %r10,	[%rbp + mc_writegas.strmcl.mcl]
    mov       [%r10+16],	%rax
    mov       %rsi,	11
L2951:
    jmp       L2949
    jmp       L2928
L2938:
    movzx     %rax,	word ptr[%rdi+8]
    and       %rax,	31
    cmp       %rax,	8
    jnz       L2953
    movzx     %rax,	word ptr[%rbx+8]
    and       %rax,	31
    cmp       %rax,	4
    jnz       L2953
    lea       %rcx,	[%rbp + mc_writegas.strmcl.opcname]
    lea       %rdx,	[%rip+L8738]
    call      strcpy
    jmp       L2952
L2953:
    jmp       L2949
L2952:
    jmp       L2928
L2939:
    movzx     %rax,	word ptr[%rdi+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	5
    jnz       L2955
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	5
    jnz       L2955
    mov       %rsi,	17
L2955:
    jmp       L2949
    jmp       L2928
L2940:
    movzx     %rax,	word ptr[%rdi+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jnz       L2957
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	2
    jnz       L2957
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	12
    and       %rax,	15
    cmp       %rax,	1
    jnz       L2957
    mov       %rax,	[%rbx]
    cmp       %rax,	-2147483648
    jl        L2958
    cmp       %rax,	2147483647
    jle       L2957
L2958:
    mov       %al,	17
    mov       %r10,	[%rbp + mc_writegas.strmcl.mcl]
    mov       [%r10+33],	%al
L2957:
    jmp       L2949
    jmp       L2928
L2941:
    lea       %rcx,	[%rbp + mc_writegas.strmcl.opcname]
    lea       %rdx,	[%rip+L8739]
    call      strcpy
    jmp       L2928
L2942:
    lea       %rcx,	[%rbp + mc_writegas.strmcl.opcname]
    lea       %rdx,	[%rip+L8740]
    call      strcpy
    jmp       L2928
L2943:
    lea       %rcx,	[%rbp + mc_writegas.strmcl.opcname]
    lea       %rdx,	[%rip+L8741]
    call      strcpy
    jmp       L2928
L2944:
    lea       %rcx,	[%rbp + mc_writegas.strmcl.opcname]
    lea       %rdx,	[%rip+L8742]
    call      strcpy
    jmp       L2928
L2945:
    lea       %rcx,	[%rbp + mc_writegas.strmcl.opcname]
    lea       %rdx,	[%rip+L8743]
    call      strcpy
    jmp       L2928
L2946:
    lea       %rcx,	[%rbp + mc_writegas.strmcl.opcname]
    lea       %rdx,	[%rip+L8744]
    call      strcpy
    jmp       L2928
L2947:
    lea       %rcx,	[%rbp + mc_writegas.strmcl.opcname]
    lea       %rdx,	[%rip+L8745]
    call      strcpy
    jmp       L2928
L2948:
    jmp       L2906
L2949:
    cmp       %rsi,	152
    jle       L2960
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    call      msys.strint
    lea       %rcx,	[%rbp + mc_writegas.strmcl.opcname]
    mov       %rdx,	%rax
    call      strcpy
    jmp       L2959
L2960:
    lea       %rax,	[%rip+mc_decls.mclnames]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8-8]
    lea       %rax,	[%rax+2]
    lea       %rcx,	[%rbp + mc_writegas.strmcl.opcname]
    mov       %rdx,	%rax
    call      strcpy
L2959:
L2928:
    lea       %rcx,	[%rbp + mc_writegas.strmcl.opcname]
    mov       %rdx,	10
    lea       %r8,	[%rip+L8746]
    call      mlib.ipadstr
    lea       %rcx,	[%rip+mc_writegas.strmcl.str]
    lea       %rdx,	[%rip+L8747]
    call      strcpy
    lea       %rcx,	[%rip+mc_writegas.strmcl.str]
    mov       %rdx,	4
    lea       %r8,	[%rip+L8748]
    call      mlib.ipadstr
    lea       %rcx,	[%rip+mc_writegas.strmcl.str]
    lea       %rdx,	[%rbp + mc_writegas.strmcl.opcname]
    call      strcat
    lea       %rcx,	[%rip+mc_writegas.strmcl.str]
    call      mc_writegas.asmstr
    test      %rdi,	%rdi
    jz        L2962
    test      %rbx,	%rbx
    jz        L2962
    mov       %rcx,	%rsi
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_writegas.needsizeprefix
    mov       %r13,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	%r13
    xor       %r8d,	%r8d
    call      mc_writegas.asmopnd
    lea       %rcx,	[%rip+L8749]
    call      mc_writegas.asmstr
    mov       %rcx,	%rbx
    mov       %rdx,	%r13
    xor       %r8d,	%r8d
    call      mc_writegas.asmopnd
    mov       %rax,	[%rbp + mc_writegas.strmcl.mcl]
    mov       %al,	[%rax+32]
    test      %al,	%al
    jz        L2964
    lea       %rcx,	[%rip+L8750]
    call      mc_writegas.asmstr
    mov       %rax,	[%rbp + mc_writegas.strmcl.mcl]
    movzx     %rax,	byte ptr[%rax+32]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.strint
    mov       %rcx,	%rax
    call      mc_writegas.asmstr
L2964:
    jmp       L2961
L2962:
    test      %rdi,	%rdi
    jz        L2965
    movzx     %rax,	word ptr[%rdi+8]
    shr       %rax,	9
    and       %rax,	7
    jz        L2965
    cmp       %rsi,	21
    jnz       L2967
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    mov       %r8,	%rsi
    call      mc_writegas.asmopnd
    jmp       L2966
L2967:
    mov       %rcx,	%rdi
    mov       %rdx,	1
    mov       %r8,	%rsi
    call      mc_writegas.asmopnd
L2966:
L2965:
L2961:
L2906:
#---------------
    add       %rsp,	168
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writegas.strmclstr
mc_writegas.strmclstr:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	[%rip+pc_decls.pdest]
    call      mlib.gs_init
    mov       %rcx,	%rdi
    call      mc_writegas.strmcl
    mov       %rax,	[%rip+pc_decls.pdest]
    mov       %rax,	[%rax]
L2968:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_writegas.mstropnd
mc_writegas.mstropnd:
#?>>
    .set mc_writegas.mstropnd.str2, -128
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	168
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
    xor       %eax,	%eax
    lea       %r10,	[%rip+mc_writegas.mstropnd.str]
    mov       [%r10],	%al
    movzx     %rax,	word ptr[%rsi+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jz        L2971
    cmp       %rax,	2
    jz        L2972
    cmp       %rax,	3
    jz        L2973
    cmp       %rax,	5
    jz        L2974
    jmp       L2975
L2971:
    movzx     %rax,	word ptr[%rsi+8]
    and       %rax,	31
    movzx     %r10,	byte ptr[%rsi+10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_writegas.strreg
    jmp       L2969
L2972:
    cmp       %r13,	119
    jnz       L2977
    movzx     %rax,	word ptr[%rsi+8]
    shr       %rax,	12
    and       %rax,	15
    cmp       %rax,	1
    jnz       L2977
    mov       %rax,	[%rsi]
    cmp       %rax,	0
    jl        L2979
    cmp       %rax,	9
    jg        L2979
    mov       %rax,	[%rsi]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.strint
    lea       %rcx,	[%rip+mc_writegas.mstropnd.str]
    mov       %rdx,	%rax
    call      strcat
    jmp       L2978
L2979:
    lea       %rcx,	[%rip+mc_writegas.mstropnd.str]
    lea       %rdx,	[%rip+L8751]
    call      strcat
    mov       %rax,	[%rsi]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8752]
    call      msys.strword
    lea       %rcx,	[%rip+mc_writegas.mstropnd.str]
    mov       %rdx,	%rax
    call      strcat
L2978:
    jmp       L2976
L2977:
    mov       %rcx,	%rsi
    call      mc_writegas.strvalue
    lea       %rcx,	[%rip+mc_writegas.mstropnd.str]
    mov       %rdx,	%rax
    call      strcpy
L2976:
    jmp       L2970
L2973:
    movzx     %rax,	word ptr[%rsi+8]
    and       %rax,	31
    mov       %rcx,	%rax
    mov       %rdx,	%r12
    call      mc_writegas.getsizeprefix
    lea       %rcx,	[%rip+mc_writegas.mstropnd.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rcx,	[%rip+mc_writegas.mstropnd.str]
    lea       %rdx,	[%rip+L8753]
    call      strcat
    lea       %rax,	[%rip+L8754]
    mov       %rdi,	%rax
    mov       %al,	[%rsi+10]
    test      %al,	%al
    jz        L2981
    movzx     %rax,	byte ptr[%rsi+10]
    mov       %rcx,	%rax
    mov       %rdx,	8
    call      mc_writegas.strreg
    lea       %rcx,	[%rip+mc_writegas.mstropnd.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rax,	[%rip+L8755]
    mov       %rdi,	%rax
L2981:
    mov       %al,	[%rsi+11]
    test      %al,	%al
    jz        L2983
    lea       %rcx,	[%rip+mc_writegas.mstropnd.str]
    mov       %rdx,	%rdi
    call      strcat
    movzx     %rax,	byte ptr[%rsi+11]
    mov       %rcx,	%rax
    mov       %rdx,	8
    call      mc_writegas.strreg
    lea       %rcx,	[%rip+mc_writegas.mstropnd.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rax,	[%rip+L8755]
    mov       %rdi,	%rax
    movzx     %rax,	word ptr[%rsi+8]
    shr       %rax,	5
    and       %rax,	15
    cmp       %rax,	1
    jle       L2985
    lea       %rcx,	[%rip+mc_writegas.mstropnd.str]
    lea       %rdx,	[%rip+L8756]
    call      strcat
    movzx     %rax,	word ptr[%rsi+8]
    shr       %rax,	5
    and       %rax,	15
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.strint
    lea       %rcx,	[%rip+mc_writegas.mstropnd.str]
    mov       %rdx,	%rax
    call      strcat
L2985:
L2983:
    movzx     %rax,	word ptr[%rsi+8]
    shr       %rax,	12
    and       %rax,	15
    cmp       %rax,	5
    jz        L2988
    cmp       %rax,	6
    jz        L2988
    cmp       %rax,	8
    jnz       L2987
L2988:
    movzx     %rax,	byte ptr[%rsi+10]
    movzx     %r10,	byte ptr[%rsi+11]
    cmp       %r10,	%rax
    jnz       L2991
    test      %r10,	%r10
    jnz       L2991
    mov       %rax,	1
    jmp       L2992
L2991:
    xor       %eax,	%eax
L2992:
    test      %rax,	%rax
    setnz     %al
    movzx     %eax,	%al
    test      %ax,	%ax
    jz        L2990
    mov       %al,	[%rip+pc_api.phighmem]
    test      %al,	%al
    jz        L2990
    lea       %rcx,	[%rip+mc_writegas.mstropnd.str]
    lea       %rdx,	[%rip+L8757]
    call      strcat
L2990:
    mov       %al,	[%rdi]
    test      %al,	%al
    jz        L2994
    lea       %rcx,	[%rip+mc_writegas.mstropnd.str]
    mov       %rdx,	%rdi
    call      strcat
L2994:
    mov       %rcx,	%rsi
    call      mc_writegas.strvalue
    lea       %rcx,	[%rip+mc_writegas.mstropnd.str]
    mov       %rdx,	%rax
    call      strcat
    jmp       L2986
L2987:
    movsxd    %rax,	dword ptr[%rsi+12]
    mov       %rbx,	%rax
    test      %rax,	%rax
    jz        L2995
    lea       %rcx,	[%rbp + mc_writegas.mstropnd.str2]
    call      msys.m$print_startstr
    mov       %rcx,	%rbx
    lea       %rdx,	[%rip+L8758]
    call      msys.m$print_i64
    call      msys.m$print_end
    lea       %rcx,	[%rip+mc_writegas.mstropnd.str]
    lea       %rdx,	[%rbp + mc_writegas.mstropnd.str2]
    call      strcat
L2995:
L2986:
    lea       %rcx,	[%rip+mc_writegas.mstropnd.str]
    lea       %rdx,	[%rip+L8759]
    call      strcat
    jmp       L2970
L2974:
    movzx     %rax,	word ptr[%rsi+8]
    and       %rax,	31
    movzx     %r10,	byte ptr[%rsi+10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_writegas.strxreg
    jmp       L2969
L2975:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8760]
    call      msys.m$print_str_nf
    movzx     %rax,	word ptr[%rsi+8]
    shr       %rax,	9
    and       %rax,	7
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.m$print_u64
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rax,	[%rip+L8761]
    jmp       L2969
L2970:
    lea       %rax,	[%rip+mc_writegas.mstropnd.str]
L2969:
#---------------
    add       %rsp,	168
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writegas.strvalue
mc_writegas.strvalue:
#?>>
    .set mc_writegas.strvalue.str2, -128
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	160
    mov       %r12,	%rcx
#---------------
    mov       %rdi,	[%r12]
    mov       %rbx,	[%r12]
    lea       %rcx,	[%rip+mc_writegas.strvalue.str]
    lea       %rdx,	[%rip+L8762]
    call      strcpy
    movzx     %rax,	word ptr[%r12+8]
    shr       %rax,	12
    and       %rax,	15
    cmp       %rax,	5
    jz        L2998
    cmp       %rax,	1
    jz        L2999
    cmp       %rax,	2
    jz        L3000
    cmp       %rax,	3
    jz        L3001
    cmp       %rax,	4
    jz        L3002
    cmp       %rax,	7
    jz        L3003
    cmp       %rax,	6
    jz        L3004
    cmp       %rax,	8
    jz        L3005
    jmp       L3006
L2998:
    mov       %rcx,	%rdi
    call      mc_writegas.getdispname
    lea       %rcx,	[%rip+mc_writegas.strvalue.str]
    mov       %rdx,	%rax
    call      strcat
#mc_writegas.strvalue.addoffset:
L3007:
    movsxd    %rax,	dword ptr[%r12+12]
    mov       %rsi,	%rax
    test      %rax,	%rax
    jz        L3009
    lea       %rcx,	[%rbp + mc_writegas.strvalue.str2]
    call      msys.m$print_startstr
    cmp       %rsi,	0
    jle       L3011
    lea       %rax,	[%rip+L8763]
    jmp       L3010
L3011:
    lea       %rax,	[%rip+L8764]
L3010:
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       %rcx,	%rsi
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rcx,	[%rip+mc_writegas.strvalue.str]
    lea       %rdx,	[%rbp + mc_writegas.strvalue.str2]
    call      strcat
L3009:
    jmp       L2997
L2999:
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      msys.strint
    lea       %rcx,	[%rip+mc_writegas.strvalue.str]
    mov       %rdx,	%rax
    call      strcat
    jmp       L2997
L3000:
    lea       %rcx,	[%rip+mc_writegas.strvalue.str]
    call      msys.m$print_startstr
    movq      %XMM4,	[%r12]
    movq      %XMM0,	%XMM4
    lea       %rdx,	[%rip+L8765]
    call      msys.m$print_r64
    call      msys.m$print_end
    jmp       L2997
L3001:
    lea       %rcx,	[%rip+mc_writegas.strvalue.str]
    lea       %rdx,	[%rip+L8766]
    call      strcat
    movq      %XMM4,	[%r12]
    movq      %XMM0,	%XMM4
    xor       %edx,	%edx
    call      msys.strreal
    lea       %rcx,	[%rip+mc_writegas.strvalue.str]
    mov       %rdx,	%rax
    call      strcat
    jmp       L2997
L3002:
    lea       %rcx,	[%rip+mc_writegas.strvalue.str]
    lea       %rdx,	[%rip+L8767]
    call      strcat
    mov       %rax,	[%r12]
    lea       %rcx,	[%rip+mc_writegas.strvalue.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rcx,	[%rip+mc_writegas.strvalue.str]
    lea       %rdx,	[%rip+L8767]
    call      strcat
    jmp       L2997
L3003:
    mov       %rax,	[%r12]
    lea       %rcx,	[%rip+mc_writegas.strvalue.str]
    mov       %rdx,	%rax
    call      strcat
    jmp       L2997
L3004:
    lea       %rcx,	[%rip+mc_writegas.strvalue.str]
    lea       %rdx,	[%rip+L8768]
    call      strcat
    mov       %rax,	[%r12]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.strint
    lea       %rcx,	[%rip+mc_writegas.strvalue.str]
    mov       %rdx,	%rax
    call      strcat
    jmp       L3007
L3005:
    mov       %rax,	[%r12]
    mov       %rcx,	[%rip+mc_decls.currasmproc]
    mov       %rdx,	%rax
    call      mc_writegas.gettempname
    jmp       L2996
L3006:
    lea       %rcx,	[%rip+L8769]
    lea       %rdx,	[%rip+L8770]
    call      pc_api.merror
L2997:
    lea       %rax,	[%rip+mc_writegas.strvalue.str]
L2996:
#---------------
    add       %rsp,	160
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writegas.asmopnd
mc_writegas.asmopnd:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      mc_writegas.mstropnd
    mov       %rcx,	%rax
    call      mc_writegas.asmstr
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writegas.getxregname
mc_writegas.getxregname:
#?>>
    .set mc_writegas.getxregname.size, 32
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    test      %rdi,	%rdi
    jnz       L3015
    lea       %rax,	[%rip+L8771]
    jmp       L3013
L3015:
    lea       %rcx,	[%rip+mc_writegas.getxregname.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8772]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rax,	[%rdi-1]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rax,	[%rip+mc_writegas.getxregname.str]
L3013:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_writegas.asmstr
mc_writegas.asmstr:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	[%rip+pc_decls.pdest]
    mov       %rdx,	%rdi
    call      mlib.gs_str
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_writegas.asmchar
mc_writegas.asmchar:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	[%rip+pc_decls.pdest]
    mov       %rdx,	%rdi
    call      mlib.gs_char
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_writegas.getdispname
mc_writegas.getdispname:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      pc_api.getfullname
L3018:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_writegas.gettempname
mc_writegas.gettempname:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %al,	[%rip+pc_api.fpshortnames]
    test      %al,	%al
    jz        L3021
    lea       %rcx,	[%rip+mc_writegas.gettempname.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8773]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       %rcx,	%rbx
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L3020
L3021:
    lea       %rcx,	[%rip+mc_writegas.gettempname.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8774]
    call      msys.m$print_setfmt
    mov       %rcx,	%rdi
    call      mc_writegas.getdispname
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    mov       %rcx,	%rbx
    call      msys.m$print_i64_nf
    call      msys.m$print_end
L3020:
    lea       %rax,	[%rip+mc_writegas.gettempname.str]
L3019:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writegas.strreg
mc_writegas.strreg:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    lea       %rcx,	[%rip+mc_writegas.strreg.str]
    lea       %rdx,	[%rip+L8775]
    call      strcpy
    lea       %rax,	[%rip+mc_writegas.nregnames]
    mov       %r10,	%rbx
    shl       %r10,	7
    lea       %rax,	[%rax + %r10-128]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    lea       %rcx,	[%rip+mc_writegas.strreg.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rax,	[%rip+mc_writegas.strreg.str]
L3022:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writegas.strxreg
mc_writegas.strxreg:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      mc_writegas.checkregvar
    mov       %rdi,	%rax
    cmp       %rsi,	8
    jnz       L3025
    test      %rdi,	%rdi
    jz        L3025
    mov       %rcx,	%rdi
    call      mc_writegas.getdispname
    jmp       L3024
L3025:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      mc_writegas.getxregname
L3024:
L3023:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writegas.needsizeprefix
mc_writegas.needsizeprefix:
#?>>
#?]]
#---------------
    mov       %rax,	%rcx
    cmp       %rax,	18
    jz        L3028
    cmp       %rax,	19
    jz        L3028
    cmp       %rax,	86
    jz        L3028
    cmp       %rax,	87
    jz        L3028
    cmp       %rax,	82
    jz        L3029
    cmp       %rax,	83
    jz        L3029
    cmp       %rax,	84
    jz        L3029
    cmp       %rax,	85
    jz        L3029
    cmp       %rax,	43
    jz        L3030
    cmp       %rax,	45
    jz        L3030
    cmp       %rax,	44
    jz        L3030
    jmp       L3031
L3028:
    mov       %rax,	1
    jmp       L3026
L3029:
    mov       %rax,	1
    jmp       L3026
L3030:
    movzx     %rax,	word ptr[%rdx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	3
    jnz       L3033
    mov       %rax,	1
    jmp       L3026
L3033:
    xor       %eax,	%eax
    jmp       L3026
L3031:
L3027:
    movzx     %rax,	word ptr[%rdx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jz        L3036
    movzx     %rax,	word ptr[%rdx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	5
    jz        L3036
    movzx     %rax,	word ptr[%r8+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jz        L3036
    movzx     %rax,	word ptr[%r8+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	5
    jnz       L3035
L3036:
    xor       %eax,	%eax
    jmp       L3026
L3035:
    mov       %rax,	1
L3026:
#---------------
    ret       
# End 
# Proc mc_writegas.getsizeprefix
mc_writegas.getsizeprefix:
#?>>
#?]]
#---------------
    test      %rdx,	%rdx
    jnz       L3039
    lea       %rax,	[%rip+L8776]
    jmp       L3037
L3039:
    mov       %rax,	%rcx
    cmp       %rax,	1
    jz        L3041
    cmp       %rax,	2
    jz        L3042
    cmp       %rax,	4
    jz        L3043
    cmp       %rax,	8
    jz        L3044
    jmp       L3045
L3041:
    lea       %rax,	[%rip+L8777]
    jmp       L3037
L3042:
    lea       %rax,	[%rip+L8778]
    jmp       L3037
L3043:
    lea       %rax,	[%rip+L8779]
    jmp       L3037
L3044:
    lea       %rax,	[%rip+L8780]
    jmp       L3037
L3045:
L3040:
    lea       %rax,	[%rip+L8781]
L3037:
#---------------
    ret       
# End 
# Proc mc_writegas.checkregvar
mc_writegas.checkregvar:
#?>>
    .set mc_writegas.checkregvar.reg, 16
    .set mc_writegas.checkregvar.ispfloat, 24
#?]]
#---------------
    xor       %eax,	%eax
L3046:
#---------------
    ret       
# End 
# Proc mc_writeexe_dummy.genexe
mc_writeexe_dummy.genexe:
#?>>
    .set mc_writeexe_dummy.genexe.entrypoint, 16
    .set mc_writeexe_dummy.genexe.outfile, 24
    .set mc_writeexe_dummy.genexe.dodll, 32
#?]]
#---------------
#---
#---------------
    ret       
# End 
# Proc mc_writeexe_dummy.writeexe
mc_writeexe_dummy.writeexe:
#?>>
    .set mc_writeexe_dummy.writeexe.outfile, 16
    .set mc_writeexe_dummy.writeexe.dodll, 24
#?]]
#---------------
#---
#---------------
    ret       
# End 
# Proc mc_writeobj_dummy.writecoff
mc_writeobj_dummy.writecoff:
#?>>
    .set mc_writeobj_dummy.writecoff.outfile, 16
#?]]
#---------------
#---
#---------------
    ret       
# End 
# Proc mc_writess_dummy.writessdata
mc_writess_dummy.writessdata:
#?>>
    .set mc_writess_dummy.writessdata.fexe, 16
#?]]
#---------------
    xor       %eax,	%eax
L3050:
#---------------
    ret       
# End 
# Proc mx_run_dummy.runlibfile
mx_run_dummy.runlibfile:
#?>>
    .set mx_run_dummy.runlibfile.filename, 16
    .set mx_run_dummy.runlibfile.cmdskip, 24
#?]]
    sub       %rsp,	40
#---------------
    lea       %rcx,	[%rip+L8782]
    call      mlib.abortprogram
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mx_run_dummy.writemcx
mx_run_dummy.writemcx:
#?>>
    .set mx_run_dummy.writemcx.filename, 16
#?]]
#---------------
#---
#---------------
    ret       
# End 
# Proc cc_cli.main
cc_cli.main:
main:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    call      msyswin.start
    call      pepcl.start
    call      mnoos.os_clock
    mov       [%rip+cc_cli.startclock],	%rax
    mov       %rax,	[%rip+cc_cli.startclock]
    mov       [%rip+pc_decls.pstartclock],	%rax
    call      cc_cli.starttiming
    call      cc_cli.initdata
    call      cc_cli.getinputoptions
    call      cc_cli.initsearchdirs
    movzx     %rax,	byte ptr[%rip+cc_cli.fverbose]
    cmp       %rax,	3
    jnz       L3055
    call      cc_cli.showsearchdirs
L3055:
    call      cc_cli.initlogfile
    call      cc_cli.gettiming
    mov       [%rip+cc_cli.inittime],	%rax
    mov       %al,	[%rip+cc_cli.fverbose]
    test      %al,	%al
    jz        L3057
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8783]
    call      msys.m$print_setfmt
    mov       %rcx,	[%rip+cc_decls.inputfile]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+cc_cli.outfile]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L3057:
    mov       %rcx,	[%rip+cc_decls.inputfile]
    call      mlib.extractbasefile
    mov       %rcx,	%rax
    call      mlib.pcm_copyheapstring
    mov       [%rip+pc_decls.$pmodulename],	%rax
    call      cc_cli.do_loadmodule
    call      cc_cli.do_preprocess
    call      cc_cli.do_parsemodule
    call      cc_cli.do_genpcl
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	6
    jz        L3059
    cmp       %rax,	7
    jz        L3060
    cmp       %rax,	8
    jz        L3061
    cmp       %rax,	10
    jz        L3062
    cmp       %rax,	11
    jz        L3063
    cmp       %rax,	12
    jz        L3064
    cmp       %rax,	9
    jz        L3065
    cmp       %rax,	13
    jz        L3066
    jmp       L3067
L3059:
    call      pc_run_dummy.pcl_runpcl
    jmp       L3058
L3060:
    call      cc_cli.do_genmcl
    jmp       L3058
L3061:
    call      cc_cli.do_asm
    jmp       L3058
L3062:
    call      cc_cli.do_obj
    jmp       L3058
L3063:
    call      cc_cli.do_dll
    jmp       L3058
L3064:
    call      cc_cli.do_exe
    jmp       L3058
L3065:
    call      cc_cli.do_mx
    jmp       L3058
L3066:
    call      cc_cli.do_run
    jmp       L3058
L3067:
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	7
    jl        L3069
    call      msys.m$print_startcon
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    lea       %r10,	[%rip+cc_cli.passnames]
    mov       %r10,	[%r10 + %rax*8-8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L8784]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L3069:
L3058:
    movzx     %rax,	byte ptr[%rip+cc_cli.fverbose]
    cmp       %rax,	2
    jl        L3071
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8785]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L3071:
    mov       %al,	[%rip+cc_cli.fshowtiming]
    test      %al,	%al
    jz        L3073
    call      cc_cli.showtiming
L3073:
    call      cc_cli.closelogfile
    xor       %ecx,	%ecx
    call      exit
    xor       %ecx,	%ecx
    call      exit
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.do_preprocess
cc_cli.do_preprocess:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	2
    jnz       L3076
    movzx     %rax,	byte ptr[%rip+cc_cli.fstdout]
    mov       %rcx,	[%rip+cc_decls.inputfile]
    mov       %rdx,	[%rip+cc_cli.outfile]
    mov       %r8,	%rax
    call      cc_lex.lex_preprocess_only
    xor       %ecx,	%ecx
    call      exit
L3076:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.do_loadmodule
cc_cli.do_loadmodule:
#?>>
    .set cc_cli.do_loadmodule.path, -304
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	336
#---------------
    movzx     %rax,	byte ptr[%rip+cc_cli.fverbose]
    cmp       %rax,	3
    jnz       L3079
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8786]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+cc_decls.inputfile]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L3079:
    call      cc_cli.starttiming
    lea       %rax,	[%rip+L8787]
    lea       %r10,	[%rip+cc_decls.sourcefilenames]
    mov       [%r10],	%rax
    lea       %rax,	[%rip+L8788]
    lea       %r10,	[%rip+cc_decls.sourcefilepaths]
    mov       [%r10],	%rax
    lea       %rax,	[%rip+L8789]
    lea       %r10,	[%rip+cc_decls.sourcefiletext]
    mov       [%r10],	%rax
    lea       %rax,	[%rip+cc_decls.sourcefiletext]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    call      strlen
    lea       %r10,	[%rip+cc_decls.sourcefilesizes]
    mov       [%r10],	%eax
    lea       %rcx,	[%rip+L8790]
    call      cc_lex.addnamestr
    xor       %ecx,	%ecx
    mov       %rdx,	%rax
    mov       %r8,	2
    call      cc_lib.createdupldef
    mov       [%rip+cc_decls.stprogram],	%rax
    mov       %rcx,	[%rip+cc_decls.inputfile]
    call      mlib.checkfile
    test      %rax,	%rax
    jnz       L3081
    lea       %rcx,	[%rip+L8791]
    mov       %rdx,	[%rip+cc_decls.inputfile]
    call      cc_support.loaderror
L3081:
    mov       %rcx,	[%rip+cc_decls.inputfile]
    mov       %rdx,	[%rip+cc_decls.inputfile]
    call      cc_support.loadsourcefile
    mov       [%rip+cc_decls.mainfileno],	%rax
    mov       %rcx,	[%rip+cc_decls.inputfile]
    call      mlib.extractbasefile
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    call      cc_lex.addnamestr
    mov       %rcx,	[%rip+cc_decls.stprogram]
    mov       %rdx,	%rax
    mov       %r8,	3
    call      cc_lib.createdupldef
    mov       [%rip+cc_decls.stmodule],	%rax
    mov       %rcx,	[%rip+cc_decls.inputfile]
    call      mlib.extractpath
    lea       %rcx,	[%rbp + cc_cli.do_loadmodule.path]
    mov       %rdx,	%rax
    call      strcpy
    mov       %al,	[%rbp + cc_cli.do_loadmodule.path]
    test      %al,	%al
    jz        L3083
    inc       qword ptr[%rip+cc_decls.nsearchdirs]
    mov       %rbx,	[%rip+cc_decls.nsearchdirs]
    cmp       %rbx,	2
    jl        L3086
L3084:
    lea       %rax,	[%rip+cc_decls.searchdirs]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8-16]
    lea       %r10,	[%rip+cc_decls.searchdirs]
    mov       %r11,	%rbx
    mov       [%r10 + %r11*8-8],	%rax
    dec       %rbx
    cmp       %rbx,	2
    jge       L3084
L3086:
    lea       %rcx,	[%rbp + cc_cli.do_loadmodule.path]
    call      mlib.pcm_copyheapstring
    lea       %r10,	[%rip+cc_decls.searchdirs]
    mov       [%r10],	%rax
L3083:
    call      cc_cli.gettiming
    mov       [%rip+cc_cli.loadtime],	%rax
#---------------
    add       %rsp,	336
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_cli.do_parsemodule
cc_cli.do_parsemodule:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    call      cc_cli.starttiming
    call      cc_parse.parsemodule
    call      cc_cli.gettiming
    mov       %rdi,	%rax
    mov       [%rip+cc_cli.parsetime],	%rax
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_cli.do_genpcl
cc_cli.do_genpcl:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	5
    jl        L3088
L3090:
    call      cc_cli.starttiming
    call      cc_genpcl.codegen_pcl
    call      cc_cli.gettiming
    mov       [%rip+cc_cli.pcltime],	%rax
    mov       %al,	[%rip+pc_decls.fregoptim]
    test      %al,	%al
    jnz       L3093
    mov       %al,	[%rip+pc_decls.fpeephole]
    test      %al,	%al
    jz        L3092
L3093:
    call      pc_reduce.pcl_reducetest
L3092:
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	5
    jnz       L3095
    mov       %rcx,	[%rip+cc_cli.outfile]
    call      pc_api.pcl_writepcl
L3095:
L3088:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.do_genmcl
cc_cli.do_genmcl:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	7
    jl        L3096
L3098:
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	7
    jnz       L3100
    mov       %rcx,	[%rip+cc_cli.outfile]
    mov       %rdx,	16705
    call      pc_api.pcl_writeasm
L3100:
L3096:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.do_asm
cc_cli.do_asm:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	8
    jl        L3101
L3103:
    mov       %rcx,	[%rip+cc_cli.outfile]
    mov       %rdx,	16705
    call      pc_api.pcl_writeasm
L3101:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.do_obj
cc_cli.do_obj:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	10
    jnz       L3104
L3106:
    mov       %rcx,	[%rip+cc_cli.outfile]
    call      pc_api.pcl_writeobj
L3104:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.do_dll
cc_cli.do_dll:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	11
    jnz       L3107
L3109:
    mov       %rcx,	[%rip+cc_cli.outfile]
    call      pc_api.pcl_writedll
L3107:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.do_exe
cc_cli.do_exe:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	12
    jnz       L3110
L3112:
    mov       %rcx,	[%rip+cc_cli.outfile]
    call      pc_api.pcl_writeexe
L3110:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.do_mx
cc_cli.do_mx:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	9
    jnz       L3113
L3115:
    mov       %rcx,	[%rip+cc_cli.outfile]
    call      pc_api.pcl_writemx
L3113:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.do_run
cc_cli.do_run:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	13
    jnz       L3116
L3118:
    call      pc_api.pcl_exec
L3116:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.initlogfile
cc_cli.initlogfile:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    movzx     %rax,	byte ptr[%rip+cc_cli.debugmode]
    cmp       %rax,	2
    jl        L3121
    lea       %rcx,	[%rip+L8792]
    call      remove
    lea       %rcx,	[%rip+L8792]
    lea       %rdx,	[%rip+L8793]
    call      fopen
    mov       [%rip+cc_decls.logdev],	%rax
L3121:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.closelogfile
cc_cli.closelogfile:
#?>>
    .set cc_cli.closelogfile.str, -104
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	144
#---------------
    movzx     %rax,	byte ptr[%rip+cc_cli.debugmode]
    cmp       %rax,	2
    jl        L3122
L3124:
    mov       %al,	[%rip+cc_cli.fshowmcl]
    test      %al,	%al
    jz        L3126
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	7
    jl        L3126
    mov       %rcx,	[%rip+cc_decls.logdev]
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L8794]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	[%rip+cc_decls.logdev]
    call      msys.m$print_startfile
    xor       %ecx,	%ecx
    mov       %rdx,	16705
    call      pc_api.pcl_writeasm
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L3126:
    mov       %al,	[%rip+cc_cli.fshowpcl]
    test      %al,	%al
    jz        L3128
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	5
    jl        L3128
    mov       %rcx,	[%rip+cc_decls.logdev]
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L8795]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	[%rip+cc_decls.logdev]
    call      msys.m$print_startfile
    xor       %ecx,	%ecx
    call      pc_api.pcl_writepcl
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %al,	[%rip+cc_cli.fshowpst]
    test      %al,	%al
    jz        L3130
    lea       %rcx,	[%rip+L8796]
    call      pc_api.pcl_writepst
    lea       %rcx,	[%rip+L8796]
    mov       %rdx,	[%rip+cc_decls.logdev]
    call      cc_lib.addtolog
L3130:
L3128:
    call      cc_cli.showast
    mov       %al,	[%rip+cc_cli.fshowst]
    test      %al,	%al
    jz        L3132
    lea       %rcx,	[%rip+L8797]
    call      cc_cli.showst
L3132:
    mov       %al,	[%rip+cc_cli.fshowstflat]
    test      %al,	%al
    jz        L3134
    lea       %rcx,	[%rip+L8798]
    call      cc_cli.showstflat
L3134:
    mov       %al,	[%rip+cc_cli.fshowtypes]
    test      %al,	%al
    jz        L3136
    mov       %rcx,	[%rip+cc_decls.logdev]
    call      cc_show.printmodelist
L3136:
    mov       %rcx,	[%rip+cc_decls.logdev]
    call      fclose
    lea       %rcx,	[%rip+L8799]
    call      mlib.checkfile
    test      %rax,	%rax
    jz        L3138
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8800]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      mnoos.os_getch
    cmp       %rax,	27
    jnz       L3140
    xor       %ecx,	%ecx
    call      exit
L3140:
    lea       %rcx,	[%rbp + cc_cli.closelogfile.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8801]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L8802]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + cc_cli.closelogfile.str]
    xor       %edx,	%edx
    xor       %r8d,	%r8d
    call      mnoos.os_execwait
    jmp       L3137
L3138:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8803]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L8804]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L3137:
L3122:
#---------------
    add       %rsp,	144
    pop       %rbp
    ret       
# End 
# Proc cc_cli.initdata
cc_cli.initdata:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    call      mlib.pcm_init
    call      cc_lex.lexsetup
    call      cc_lib.inittypetables
    call      cc_lib.initcclib
    xor       %eax,	%eax
    mov       [%rip+cc_decls.nlibfiles],	%rax
    inc       qword ptr[%rip+cc_decls.nlibfiles]
    mov       %rax,	[%rip+cc_decls.nlibfiles]
    lea       %r10,	[%rip+L8805]
    lea       %r11,	[%rip+cc_decls.libfiles]
    mov       [%r11 + %rax*8],	%r10
    inc       qword ptr[%rip+cc_decls.nlibfiles]
    mov       %rax,	[%rip+cc_decls.nlibfiles]
    lea       %r10,	[%rip+L8806]
    lea       %r11,	[%rip+cc_decls.libfiles]
    mov       [%r11 + %rax*8],	%r10
    inc       qword ptr[%rip+cc_decls.nlibfiles]
    mov       %rax,	[%rip+cc_decls.nlibfiles]
    lea       %r10,	[%rip+L8807]
    lea       %r11,	[%rip+cc_decls.libfiles]
    mov       [%r11 + %rax*8],	%r10
    inc       qword ptr[%rip+cc_decls.nlibfiles]
    mov       %rax,	[%rip+cc_decls.nlibfiles]
    lea       %r10,	[%rip+L8808]
    lea       %r11,	[%rip+cc_decls.libfiles]
    mov       [%r11 + %rax*8],	%r10
    lea       %rax,	[%rip+cc_cli.cgetsourceinfo]
    mov       [%rip+pc_decls.igetmsourceinfo],	%rax
    mov       %al,	[%rip+pepcl.pdcc]
    test      %al,	%al
    jz        L3143
    mov       %al,	2
    mov       [%rip+cc_cli.highmem],	%al
L3143:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.cgetsourceinfo
cc_cli.cgetsourceinfo:
#?>>
#?]]
#---------------
    mov       %rax,	%rcx
    shr       %rax,	24
    and       %rax,	511
    lea       %r10,	[%rip+cc_decls.sourcefilenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       [%rdx],	%r10
    lea       %rax,	[%rip+L8809]
    mov       [%r8],	%rax
    mov       %rax,	%rcx
    and       %rax,	16777215
L3144:
#---------------
    ret       
# End 
# Proc cc_cli.initsearchdirs
cc_cli.initsearchdirs:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    inc       qword ptr[%rip+cc_decls.nsearchdirs]
    mov       %rax,	[%rip+cc_decls.nsearchdirs]
    lea       %r10,	[%rip+L8810]
    lea       %r11,	[%rip+cc_decls.searchdirs]
    mov       [%r11 + %rax*8-8],	%r10
    inc       qword ptr[%rip+cc_decls.nsearchdirs]
    mov       %rax,	[%rip+cc_decls.nsearchdirs]
    lea       %r10,	[%rip+L8811]
    lea       %r11,	[%rip+cc_decls.searchdirs]
    mov       [%r11 + %rax*8-8],	%r10
    call      mnoos.os_gethostname
    mov       %rcx,	%rax
    call      mlib.extractpath
    mov       %rcx,	%rax
    call      mlib.pcm_copyheapstring
    inc       qword ptr[%rip+cc_decls.nsearchdirs]
    mov       %r10,	[%rip+cc_decls.nsearchdirs]
    lea       %r11,	[%rip+cc_decls.searchdirs]
    mov       [%r11 + %r10*8-8],	%rax
    mov       %rdi,	1
    mov       %rax,	[%rip+cc_decls.nincludepaths]
    cmp       %rax,	1
    jl        L3148
L3146:
    lea       %rax,	[%rip+cc_decls.includepaths]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    mov       %al,	[%rax]
    test      %al,	%al
    jz        L3150
    lea       %rax,	[%rip+cc_decls.includepaths]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    inc       qword ptr[%rip+cc_decls.nsearchdirs]
    mov       %r10,	[%rip+cc_decls.nsearchdirs]
    lea       %r11,	[%rip+cc_decls.searchdirs]
    mov       [%r11 + %r10*8-8],	%rax
L3150:
    inc       %rdi
    cmp       %rdi,	[%rip+cc_decls.nincludepaths]
    jle       L3146
L3148:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_cli.showsearchdirs
cc_cli.showsearchdirs:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8812]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %al,	[%rip+cc_cli.dointheaders]
    test      %al,	%al
    jz        L3153
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8813]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L3153:
    mov       %rdi,	1
    mov       %rax,	[%rip+cc_decls.nsearchdirs]
    cmp       %rax,	1
    jl        L3156
L3154:
    lea       %rax,	[%rip+cc_decls.searchdirs]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    mov       %al,	[%rax]
    test      %al,	%al
    jz        L3158
    call      msys.m$print_startcon
    mov       %rcx,	%rdi
    call      msys.m$print_i64_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L8814]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.searchdirs]
    mov       %r10,	%rdi
    mov       %rcx,	[%rax + %r10*8-8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L3157
L3158:
    call      msys.m$print_startcon
    mov       %rcx,	%rdi
    call      msys.m$print_i64_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L8815]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L3157:
    inc       %rdi
    cmp       %rdi,	[%rip+cc_decls.nsearchdirs]
    jle       L3154
L3156:
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_cli.showast
cc_cli.showast:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    mov       %al,	[%rip+cc_cli.fshowast]
    test      %al,	%al
    jz        L3161
    mov       %rcx,	[%rip+cc_decls.logdev]
    lea       %rdx,	[%rip+L8816]
    call      cc_show.printcode
    mov       %rcx,	[%rip+cc_decls.logdev]
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
L3161:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.showstflat
cc_cli.showstflat:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	[%rip+cc_decls.logdev]
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L8817]
    call      msys.m$print_str_nf
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	[%rip+cc_decls.logdev]
    call      cc_show.printstflat
    mov       %rcx,	[%rip+cc_decls.logdev]
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_cli.showst
cc_cli.showst:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	[%rip+cc_decls.logdev]
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L8817]
    call      msys.m$print_str_nf
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	[%rip+cc_decls.logdev]
    mov       %rdx,	[%rip+cc_decls.stmodule]
    xor       %r8d,	%r8d
    call      cc_show.printst
    mov       %rcx,	[%rip+cc_decls.logdev]
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_cli.showfiles
cc_cli.showfiles:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8818]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rdi,	1
    mov       %rax,	[%rip+cc_decls.nsourcefiles]
    cmp       %rax,	1
    jl        L3167
L3165:
    call      msys.m$print_startcon
    mov       %rcx,	%rdi
    call      msys.m$print_i64_nf
    lea       %rcx,	[%rip+L8819]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.sourcefilepaths]
    mov       %r10,	%rdi
    mov       %rcx,	[%rax + %r10*8]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.sourcefilenames]
    mov       %r10,	%rdi
    mov       %rcx,	[%rax + %r10*8]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L8820]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.sourcefilesizes]
    mov       %r10,	%rdi
    movsxd    %rax,	dword ptr[%rax + %r10*4]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    inc       %rdi
    cmp       %rdi,	[%rip+cc_decls.nsourcefiles]
    jle       L3165
L3167:
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_cli.showtime
cc_cli.showtime:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8821]
    call      msys.m$print_setfmt
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8822]
    call      msys.m$print_str
    mov       %rcx,	%rbx
    lea       %rdx,	[%rip+L8823]
    call      msys.m$print_i64
    mov       %rax,	%rbx
    cvtsi2sd  %XMM4,	%rax
    mulsd     %XMM4,	[%rip+L8824]
    mov       %rax,	[%rip+cc_cli.compiletime]
    cvtsi2sd  %XMM5,	%rax
    divsd     %XMM4,	%XMM5
    movq      %XMM0,	%XMM4
    lea       %rdx,	[%rip+L8825]
    call      msys.m$print_r64
    call      msys.m$print_newline
    call      msys.m$print_end
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_cli.showtiming
cc_cli.showtiming:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    call      mnoos.os_clock
    sub       %rax,	[%rip+cc_cli.startclock]
    mov       [%rip+cc_cli.compiletime],	%rax
    lea       %rcx,	[%rip+L8826]
    mov       %rdx,	[%rip+cc_cli.inittime]
    call      cc_cli.showtime
    lea       %rcx,	[%rip+L8827]
    mov       %rdx,	[%rip+cc_cli.loadtime]
    call      cc_cli.showtime
    lea       %rcx,	[%rip+L8828]
    mov       %rdx,	[%rip+cc_cli.parsetime]
    call      cc_cli.showtime
    lea       %rcx,	[%rip+L8829]
    mov       %rdx,	[%rip+cc_cli.pcltime]
    call      cc_cli.showtime
    lea       %rcx,	[%rip+L8830]
    mov       %rdx,	[%rip+pc_decls.mcltime]
    call      cc_cli.showtime
    lea       %rcx,	[%rip+L8831]
    mov       %rdx,	[%rip+pc_decls.sstime]
    call      cc_cli.showtime
    lea       %rcx,	[%rip+L8832]
    mov       %rdx,	[%rip+pc_decls.exetime]
    call      cc_cli.showtime
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8833]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8834]
    mov       %rdx,	[%rip+cc_cli.compiletime]
    call      cc_cli.showtime
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.getinputoptions
cc_cli.getinputoptions:
#?>>
    .set cc_cli.getinputoptions.paramno, -8
    .set cc_cli.getinputoptions.name, -16
    .set cc_cli.getinputoptions.value, -24
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	64
#---------------
    mov       %rax,	1
    mov       [%rbp + cc_cli.getinputoptions.paramno],	%rax
    xor       %rsi,	%rsi
    mov       %al,	[%rip+pepcl.pc_userunpcl]
    test      %al,	%al
    jz        L3172
    mov       %al,	6
    mov       [%rip+cc_cli.cc_pass],	%al
    xor       %eax,	%eax
    mov       [%rip+cc_cli.fverbose],	%al
L3172:
    call      mnoos.os_gethostname
    mov       %rcx,	%rax
    call      mlib.extractfile
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8835]
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L3174
    xor       %eax,	%eax
    mov       [%rip+cc_cli.fverbose],	%al
    mov       %rcx,	17
    lea       %rdx,	[%rip+L8836]
    call      cc_cli.do_option
L3174:
L3175:
    lea       %rcx,	[%rbp + cc_cli.getinputoptions.paramno]
    lea       %rdx,	[%rbp + cc_cli.getinputoptions.name]
    lea       %r8,	[%rbp + cc_cli.getinputoptions.value]
    lea       %r9,	[%rip+L8837]
    call      mlib.nextcmdparamnew
    mov       %rdi,	%rax
    mov       %rax,	%rdi
    cmp       %rax,	1
    jz        L3178
    cmp       %rax,	2
    jz        L3179
    cmp       %rax,	3
    jz        L3180
    test      %rax,	%rax
    jz        L3181
    jmp       L3182
L3178:
    mov       %rcx,	[%rbp + cc_cli.getinputoptions.name]
    call      mlib.convlcstring
    mov       %rbx,	1
    mov       %r12,	53
    cmp       %r12,	1
    jl        L3186
L3183:
    lea       %rax,	[%rip+cc_cli.optionnames]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rcx,	[%rbp + cc_cli.getinputoptions.name]
    mov       %rdx,	%rax
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L3188
    mov       %rcx,	%rbx
    mov       %rdx,	[%rbp + cc_cli.getinputoptions.value]
    call      cc_cli.do_option
    jmp       L3185
L3188:
    inc       %rbx
    cmp       %rbx,	%r12
    jle       L3183
L3186:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8838]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rbp + cc_cli.getinputoptions.name]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	1
    call      exit
L3185:
    jmp       L3177
L3179:
    mov       %rax,	[%rip+cc_decls.inputfile]
    test      %rax,	%rax
    jz        L3190
    lea       %rcx,	[%rip+L8839]
    lea       %rdx,	[%rip+L8840]
    call      cc_support.loaderror
L3190:
    mov       %rcx,	[%rbp + cc_cli.getinputoptions.name]
    call      mlib.pcm_copyheapstring
    mov       [%rip+cc_decls.inputfile],	%rax
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	13
    jz        L3193
    cmp       %rax,	6
    jnz       L3192
L3193:
    mov       %rax,	[%rbp + cc_cli.getinputoptions.paramno]
    dec       %rax
    add       %rax,	[%rip+msys.$cmdskip]
    mov       [%rip+cc_cli.cmdskip],	%rax
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	6
    setz      %al
    movzx     %eax,	%al
    mov       [%rip+cc_decls.pci_target],	%al
    jmp       L3176
L3192:
    jmp       L3177
L3180:
    mov       %rax,	[%rip+cc_decls.nlibfiles]
    cmp       %rax,	200
    jl        L3195
    lea       %rcx,	[%rip+L8841]
    lea       %rdx,	[%rip+L8842]
    call      cc_support.loaderror
L3195:
    mov       %rcx,	[%rbp + cc_cli.getinputoptions.name]
    call      mlib.pcm_copyheapstring
    inc       qword ptr[%rip+cc_decls.nlibfiles]
    mov       %r10,	[%rip+cc_decls.nlibfiles]
    lea       %r11,	[%rip+cc_decls.libfiles]
    mov       [%r11 + %r10*8],	%rax
    jmp       L3177
L3181:
    jmp       L3176
L3182:
L3177:
    jmp       L3175
L3176:
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    test      %rax,	%rax
    jnz       L3197
    mov       %al,	12
    mov       [%rip+cc_cli.cc_pass],	%al
    mov       %al,	[%rip+pepcl.asmonly]
    test      %al,	%al
    jz        L3199
    mov       %al,	8
    mov       [%rip+cc_cli.cc_pass],	%al
L3199:
L3197:
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	11
    jz        L3202
    cmp       %rax,	10
    jnz       L3201
L3202:
    mov       %al,	2
    mov       [%rip+cc_cli.highmem],	%al
    jmp       L3200
L3201:
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	9
    jz        L3204
    cmp       %rax,	13
    jnz       L3203
L3204:
    xor       %eax,	%eax
    mov       [%rip+cc_cli.highmem],	%al
L3203:
L3200:
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    lea       %r10,	[%rip+cc_cli.extnames]
    mov       %r10,	[%r10 + %rax*8-8]
    mov       [%rip+cc_cli.outext],	%r10
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	7
    jz        L3207
    cmp       %rax,	8
    jnz       L3206
L3207:
    mov       %rax,	[%rip+mc_writegas.asmext]
    mov       [%rip+cc_cli.outext],	%rax
L3206:
    mov       %rax,	[%rip+cc_decls.inputfile]
    test      %rax,	%rax
    jnz       L3209
    mov       %al,	[%rip+cc_cli.fwriteheaders]
    test      %al,	%al
    jnz       L3209
    call      cc_cli.showcaption
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8843]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8844]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       %rax,	[%rip+msys.cmdparams]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L8845]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8846]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       %rax,	[%rip+msys.cmdparams]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L8847]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8848]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       %rax,	[%rip+msys.cmdparams]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L8849]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8850]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       %rax,	[%rip+msys.cmdparams]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L8851]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	1
    call      exit
L3209:
    mov       %al,	[%rip+cc_cli.fwriteheaders]
    test      %al,	%al
    jz        L3211
    call      cc_headers.writeheaders
    mov       %rcx,	20
    call      exit
L3211:
    mov       %rax,	[%rip+cc_cli.outfile]
    test      %rax,	%rax
    jnz       L3213
    mov       %rcx,	[%rip+cc_decls.inputfile]
    mov       %rdx,	[%rip+cc_cli.outext]
    call      mlib.changeext
    mov       %rcx,	%rax
    call      mlib.pcm_copyheapstring
    mov       [%rip+cc_cli.outfile],	%rax
L3213:
    movzx     %rax,	byte ptr[%rip+cc_cli.fshortnames]
    movzx     %r10,	byte ptr[%rip+cc_cli.highmem]
    mov       %rcx,	%r10
    mov       %rdx,	-1
    mov       %r8,	%rax
    call      pc_api.pcl_setflags
    mov       %rcx,	[%rip+cc_cli.cmdskip]
    xor       %edx,	%edx
    call      pc_api.pcl_cmdskip
#---------------
    add       %rsp,	64
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_cli.do_option
cc_cli.do_option:
#?>>
    .set cc_cli.do_option.str, -304
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	336
    mov       %r13,	%rcx
    mov       %r14,	%rdx
#---------------
    lea       %rax,	[%rip+cc_cli.optvars]
    mov       %r10,	%r13
    mov       %rbx,	[%rax + %r10*8-8]
    test      %rbx,	%rbx
    jz        L3216
    lea       %rax,	[%rip+cc_cli.optvalues]
    mov       %r10,	%r13
    mov       %al,	[%rax + %r10-1]
    mov       [%rbx],	%al
    mov       %rax,	%r13
    cmp       %rax,	1
    jl        L3218
    cmp       %rax,	9
    jg        L3218
    mov       %al,	1
    or        [%rip+cc_cli.debugmode],	%al
L3218:
    mov       %rax,	%r13
    cmp       %rax,	26
    jl        L3220
    cmp       %rax,	34
    jg        L3220
    mov       %al,	2
    or        [%rip+cc_cli.debugmode],	%al
L3220:
    cmp       %r13,	8
    jnz       L3222
    mov       %rax,	[%rip+cc_decls.inputfile]
    test      %rax,	%rax
    jz        L3222
    lea       %rcx,	[%rip+L8852]
    lea       %rdx,	[%rip+L8853]
    call      cc_support.loaderror
L3222:
    mov       %rax,	%r13
    cmp       %rax,	3
    jz        L3225
    cmp       %rax,	7
    jnz       L3224
L3225:
    mov       %al,	1
    mov       [%rip+cc_decls.pci_target],	%al
L3224:
    jmp       L3214
L3216:
    mov       %rax,	%r13
    cmp       %rax,	24
    jz        L3227
    cmp       %rax,	42
    jz        L3228
    cmp       %rax,	43
    jz        L3228
    cmp       %rax,	46
    jz        L3229
    cmp       %rax,	20
    jz        L3230
    cmp       %rax,	51
    jz        L3231
    jmp       L3232
L3227:
    mov       %rax,	[%rip+cc_decls.nincludepaths]
    cmp       %rax,	20
    jle       L3234
    lea       %rcx,	[%rip+L8854]
    lea       %rdx,	[%rip+L8855]
    call      cc_support.loaderror
L3234:
    mov       %rcx,	%r14
    call      strlen
    mov       %rdi,	%rax
    lea       %rax,	[%r14 + %rdi]
    sub       %rax,	1
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	92
    jz        L3236
    cmp       %rax,	47
    jnz       L3237
L3236:
    jmp       L3235
L3237:
    lea       %rcx,	[%rbp + cc_cli.do_option.str]
    mov       %rdx,	%r14
    call      strcpy
    lea       %rcx,	[%rbp + cc_cli.do_option.str]
    lea       %rdx,	[%rip+L8856]
    call      strcat
    lea       %rax,	[%rbp + cc_cli.do_option.str]
    mov       %r14,	%rax
L3235:
    mov       %rcx,	%r14
    call      mlib.pcm_copyheapstring
    inc       qword ptr[%rip+cc_decls.nincludepaths]
    mov       %r10,	[%rip+cc_decls.nincludepaths]
    lea       %r11,	[%rip+cc_decls.includepaths]
    mov       [%r11 + %r10*8-8],	%rax
    jmp       L3226
L3228:
    call      cc_cli.showhelp
    jmp       L3226
L3229:
    mov       %rcx,	%r14
    mov       %rdx,	[%rip+cc_cli.outext]
    call      mlib.addext
    mov       %rcx,	%rax
    call      mlib.pcm_copyheapstring
    mov       [%rip+cc_cli.outfile],	%rax
    jmp       L3226
L3230:
    xor       %eax,	%eax
    mov       [%rip+pc_decls.fpeephole],	%al
    mov       [%rip+pc_decls.fregoptim],	%al
    jmp       L3226
L3231:
    mov       %r12,	1
    mov       %rsi,	53
    cmp       %rsi,	1
    jl        L3240
L3238:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8857]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_cli.optionnames]
    mov       %r10,	%r12
    mov       %rcx,	[%rax + %r10*8-8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    inc       %r12
    cmp       %r12,	%rsi
    jle       L3238
L3240:
L3232:
L3226:
L3214:
#---------------
    add       %rsp,	336
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_cli.showincludepaths
cc_cli.showincludepaths:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8858]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+cc_decls.nincludepaths]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rdi,	1
    mov       %rax,	[%rip+cc_decls.nincludepaths]
    cmp       %rax,	1
    jl        L3244
L3242:
    call      msys.m$print_startcon
    mov       %rcx,	%rdi
    call      msys.m$print_i64_nf
    lea       %rax,	[%rip+cc_decls.includepaths]
    mov       %r10,	%rdi
    mov       %rcx,	[%rax + %r10*8-8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    inc       %rdi
    cmp       %rdi,	[%rip+cc_decls.nincludepaths]
    jle       L3242
L3244:
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_cli.showhelp
cc_cli.showhelp:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    call      cc_cli.showcaption
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8859]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	23
    call      exit
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.showextrainfo
cc_cli.showextrainfo:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    call      msys.m$print_startcon
    mov       %rcx,	[%rip+cc_cli.showextrainfo.infotext]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	24
    call      exit
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.showcaption
cc_cli.showcaption:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8860]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.starttiming
cc_cli.starttiming:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    call      mnoos.os_clock
    mov       [%rip+cc_cli.ttt],	%rax
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.gettiming
cc_cli.gettiming:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    call      mnoos.os_clock
    sub       %rax,	[%rip+cc_cli.ttt]
L3249:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_lex.lex_preprocess_only
cc_lex.lex_preprocess_only:
#?>>
    .set cc_lex.lex_preprocess_only.outfile, 80
    .set cc_lex.lex_preprocess_only.toconsole, 88
    .set cc_lex.lex_preprocess_only.hashtot, -8
    .set cc_lex.lex_preprocess_only.symtot, -16
    .set cc_lex.lex_preprocess_only.f, -24
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	56
    mov       %r15,	%rcx
    mov       [%rbp+80],	%rdx
    mov       [%rbp+88],	%r8
#---------------
    mov       %rax,	1
    mov       [%rip+cc_lex.dowhitespace],	%rax
    mov       %rcx,	%r15
    mov       %rdx,	%r15
    call      cc_support.loadsourcefile
    mov       %r12,	%rax
    lea       %rax,	[%rip+cc_decls.sourcefiletext]
    mov       %r10,	%r12
    mov       %rdi,	[%rax + %r10*8]
    lea       %rax,	[%rip+cc_decls.sourcefilesizes]
    mov       %r10,	%r12
    movsxd    %rax,	dword ptr[%rax + %r10*4]
    mov       %r13,	%rax
    xor       %eax,	%eax
    mov       %rbx,	%rax
    mov       %rsi,	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.lex_preprocess_only.symtot],	%rax
    mov       [%rbp + cc_lex.lex_preprocess_only.hashtot],	%rax
    call      mnoos.os_clock
    mov       %r14,	%rax
    mov       %rax,	[%rip+cc_lex.lex_preprocess_only.dest]
    mov       [%rip+cc_lex.destcopy],	%rax
    mov       %rcx,	[%rip+cc_lex.lex_preprocess_only.dest]
    call      mlib.gs_init
    mov       [%rip+cc_lex.lxsptr],	%rdi
    mov       %rax,	[%rip+cc_lex.lxsptr]
    mov       [%rip+cc_lex.lxstart],	%rax
    mov       %eax,	1
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+16],	%eax
    mov       %rcx,	1
    call      cc_lex.setfileno
    xor       %eax,	%eax
    mov       [%rip+cc_lex.ifcondlevel],	%rax
    lea       %rcx,	[%rip+L8861]
    mov       %rdx,	1
    call      cc_lex.stacksourcefile
    mov       %al,	56
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L3251:
    call      cc_lex.lexm
    inc       %rbx
    lea       %rcx,	[%rip+cc_decls.nextlx]
    mov       %rdx,	[%rip+cc_lex.lex_preprocess_only.dest]
    xor       %r8d,	%r8d
    call      cc_lex.emittoken
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	57
    jnz       L3251
    mov       %rax,	[%rip+cc_lex.ifcondlevel]
    test      %rax,	%rax
    jz        L3255
    lea       %rcx,	[%rip+L8862]
    call      cc_lex.lxerror
L3255:
    lea       %rax,	[%rip+cc_lex.showtokens]
    test      %rax,	%rax
    jz        L3257
    mov       %rax,	[%rbp + cc_lex.lex_preprocess_only.toconsole]
    test      %rax,	%rax
    jz        L3259
    mov       %rcx,	[%rip+cc_lex.lex_preprocess_only.dest]
    xor       %edx,	%edx
    call      mlib.gs_println
    jmp       L3258
L3259:
    mov       %rcx,	[%rbp + cc_lex.lex_preprocess_only.outfile]
    lea       %rdx,	[%rip+L8863]
    call      fopen
    mov       [%rbp + cc_lex.lex_preprocess_only.f],	%rax
    mov       %rcx,	[%rip+cc_lex.lex_preprocess_only.dest]
    mov       %rdx,	[%rbp + cc_lex.lex_preprocess_only.f]
    call      mlib.gs_println
    mov       %rcx,	[%rbp + cc_lex.lex_preprocess_only.f]
    call      fclose
L3258:
L3257:
#---------------
    add       %rsp,	56
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.lexreadtoken
cc_lex.lexreadtoken:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+23],	%al
    jmp       L3262
L3261:
    inc       qword ptr[%rip+cc_lex.lxsptr]
L3262:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	32
    jz        L3261
    cmp       %rax,	9
    jz        L3261
L3264:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	240
    jae       L3267
    lea       %r10,	[%rip+L3266]
    jmp       [%r10 + %rax*8]
    .data
L3266:
    .quad     L3401
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3386
    .quad     L3387
    .quad     L3267
    .quad     L3405
    .quad     L3395
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3386
    .quad     L3396
    .quad     L3385
    .quad     L3294
    .quad     L3268
    .quad     L3358
    .quad     L3379
    .quad     L3384
    .quad     L3324
    .quad     L3325
    .quad     L3349
    .quad     L3338
    .quad     L3318
    .quad     L3343
    .quad     L3310
    .quad     L3352
    .quad     L3285
    .quad     L3281
    .quad     L3281
    .quad     L3281
    .quad     L3281
    .quad     L3281
    .quad     L3281
    .quad     L3281
    .quad     L3281
    .quad     L3281
    .quad     L3320
    .quad     L3319
    .quad     L3365
    .quad     L3361
    .quad     L3372
    .quad     L3336
    .quad     L3400
    .quad     L3268
    .quad     L3268
    .quad     L3268
    .quad     L3268
    .quad     L3268
    .quad     L3268
    .quad     L3268
    .quad     L3268
    .quad     L3268
    .quad     L3268
    .quad     L3268
    .quad     L3268
    .quad     L3268
    .quad     L3268
    .quad     L3268
    .quad     L3268
    .quad     L3268
    .quad     L3268
    .quad     L3268
    .quad     L3268
    .quad     L3268
    .quad     L3268
    .quad     L3268
    .quad     L3268
    .quad     L3268
    .quad     L3268
    .quad     L3326
    .quad     L3298
    .quad     L3327
    .quad     L3333
    .quad     L3268
    .quad     L3267
    .quad     L3268
    .quad     L3268
    .quad     L3268
    .quad     L3268
    .quad     L3268
    .quad     L3268
    .quad     L3268
    .quad     L3268
    .quad     L3268
    .quad     L3268
    .quad     L3268
    .quad     L3268
    .quad     L3268
    .quad     L3268
    .quad     L3268
    .quad     L3268
    .quad     L3268
    .quad     L3268
    .quad     L3268
    .quad     L3268
    .quad     L3268
    .quad     L3268
    .quad     L3268
    .quad     L3268
    .quad     L3268
    .quad     L3268
    .quad     L3308
    .quad     L3328
    .quad     L3309
    .quad     L3337
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3267
    .quad     L3406
    .text
L3268:
#cc_lex.lexreadtoken.doname:
L3269:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	1
    mov       [%rip+cc_lex.lxsvalue],	%rax
    mov       %rax,	[%rip+cc_lex.lxsvalue]
    movzx     %rax,	byte ptr[%rax]
    mov       %rbx,	%rax
    jmp       L3271
L3270:
    mov       %rax,	%rbx
    shl       %rax,	4
    sub       %rax,	%rbx
    add       %rax,	%rdi
    mov       %rbx,	%rax
L3271:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    mov       %rdi,	%rax
    lea       %r10,	[%rip+cc_lex.alphamap]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jnz       L3270
    dec       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	67
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	[%rip+cc_lex.lxsvalue]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
    mov       %rax,	%rdi
    cmp       %rax,	39
    jz        L3274
    cmp       %rax,	34
    jnz       L3275
L3274:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+24]
    cmp       %rax,	1
    jnz       L3277
    mov       %rax,	[%rip+cc_lex.lxsvalue]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	108
    jz        L3279
    cmp       %rax,	76
    jz        L3279
    cmp       %rax,	117
    jz        L3279
    cmp       %rax,	85
    jnz       L3280
L3279:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      cc_lex.lxreadstring
    jmp       L3260
L3280:
L3278:
L3277:
L3275:
L3273:
    mov       %rax,	%rbx
    shl       %rax,	5
    sub       %rax,	%rbx
    mov       [%rip+cc_lex.lxhashvalue],	%rax
    call      cc_lex.lookup
    jmp       L3260
L3281:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	32
    jz        L3283
    cmp       %rax,	41
    jz        L3283
    cmp       %rax,	13
    jz        L3283
    cmp       %rax,	44
    jz        L3283
    cmp       %rax,	59
    jnz       L3284
L3283:
    mov       %al,	59
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    mov       %al,	3
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	1
    movzx     %rax,	byte ptr[%rax]
    sub       %rax,	48
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10],	%rax
    mov       %eax,	1
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	1
    sub       %rax,	[%rip+cc_lex.lxstart]
    mov       %rcx,	%rax
    call      cc_lex.setnumberoffset
    jmp       L3282
L3284:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	1
    mov       %rcx,	%rax
    call      cc_lex.readdecimal
L3282:
    jmp       L3260
L3285:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    sub       %rax,	10
    cmp       %rax,	116
    jae       L3288
    lea       %r10,	[%rip+L3287]
    jmp       [%r10 + %rax*8]
    .data
L3287:
    .quad     L3293
    .quad     L3288
    .quad     L3288
    .quad     L3293
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3293
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3293
    .quad     L3288
    .quad     L3288
    .quad     L3293
    .quad     L3288
    .quad     L3288
    .quad     L3293
    .quad     L3288
    .quad     L3291
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3293
    .quad     L3293
    .quad     L3288
    .quad     L3293
    .quad     L3288
    .quad     L3293
    .quad     L3288
    .quad     L3288
    .quad     L3290
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3292
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3292
    .quad     L3288
    .quad     L3288
    .quad     L3289
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3293
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3290
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3292
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3292
    .quad     L3288
    .quad     L3288
    .quad     L3289
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3288
    .quad     L3293
    .text
L3289:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	2
    mov       %rcx,	%rax
    call      cc_lex.readhex
    jmp       L3260
L3290:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	2
    mov       %rcx,	%rax
    call      cc_lex.readbinary
    jmp       L3260
L3291:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	1
    mov       %r10,	[%rip+cc_lex.lxsptr]
    sub       %r10,	1
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    mov       %r8,	1
    mov       %r9,	10
    call      cc_lex.readrealnumber
    jmp       L3260
L3292:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	1
    mov       %rcx,	%rax
    call      cc_lex.readdecimal
    jmp       L3260
L3293:
    mov       %al,	59
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    mov       %al,	3
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10],	%rax
    mov       %eax,	1
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	1
    sub       %rax,	[%rip+cc_lex.lxstart]
    mov       %rcx,	%rax
    call      cc_lex.setnumberoffset
    jmp       L3260
L3288:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	1
    mov       %rcx,	%rax
    call      cc_lex.readoctal
    jmp       L3260
L3286:
    jmp       L3264
L3294:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	56
    jnz       L3296
    mov       %al,	4
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3260
L3296:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	35
    jnz       L3297
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	7
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3260
L3297:
    mov       %al,	5
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3260
L3295:
    jmp       L3264
L3298:
L3299:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	13
    jz        L3301
    cmp       %rax,	10
    jz        L3301
    cmp       %rax,	32
    jz        L3302
    cmp       %rax,	9
    jz        L3302
    jmp       L3303
L3301:
    jmp       L3300
L3302:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L3299
L3303:
    mov       %al,	22
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3260
L3300:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	1
    mov       %r10b,	32
    mov       [%rax],	%r10b
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %rax,	[%rax+16]
    inc       dword ptr[%rax]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	13
    jz        L3305
    cmp       %rax,	10
    jz        L3306
    jmp       L3307
L3305:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %r10b,	32
    mov       [%rax],	%r10b
    jmp       L3304
L3306:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %r10b,	32
    mov       [%rax],	%r10b
L3307:
L3304:
    jmp       L3264
L3308:
    mov       %al,	17
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3260
L3309:
    mov       %al,	18
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3260
L3310:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    sub       %rax,	46
    cmp       %rax,	12
    jae       L3313
    lea       %r10,	[%rip+L3312]
    jmp       [%r10 + %rax*8]
    .data
L3312:
    .quad     L3314
    .quad     L3313
    .quad     L3317
    .quad     L3317
    .quad     L3317
    .quad     L3317
    .quad     L3317
    .quad     L3317
    .quad     L3317
    .quad     L3317
    .quad     L3317
    .quad     L3317
    .text
L3314:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	46
    jnz       L3316
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	21
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3315
L3316:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	2
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3260
L3315:
    jmp       L3260
L3317:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rcx,	[%rip+cc_lex.lxsptr]
    mov       %rdx,	[%rip+cc_lex.lxsptr]
    xor       %r8d,	%r8d
    mov       %r9,	10
    call      cc_lex.readrealnumber
    jmp       L3260
L3313:
    mov       %al,	2
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3260
L3311:
    jmp       L3264
L3318:
    mov       %al,	8
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3260
L3319:
    mov       %al,	9
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3260
L3320:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	61
    jnz       L3323
L3322:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	11
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3321
L3323:
    mov       %al,	10
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L3321:
    jmp       L3260
L3324:
    mov       %al,	13
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3260
L3325:
    mov       %al,	14
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3260
L3326:
    mov       %al,	15
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3260
L3327:
    mov       %al,	16
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3260
L3328:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	124
    jz        L3330
    cmp       %rax,	61
    jz        L3331
    jmp       L3332
L3330:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	31
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3329
L3331:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	51
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3329
L3332:
    mov       %al,	28
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L3329:
    jmp       L3260
L3333:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	61
    jnz       L3335
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	53
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3334
L3335:
    mov       %al,	30
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L3334:
    jmp       L3260
L3336:
    mov       %al,	19
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3260
L3337:
    mov       %al,	35
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3260
L3338:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	43
    jz        L3340
    cmp       %rax,	61
    jz        L3341
    jmp       L3342
L3340:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	37
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3339
L3341:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	46
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3339
L3342:
    mov       %al,	23
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L3339:
    jmp       L3260
L3343:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	45
    jz        L3345
    cmp       %rax,	62
    jz        L3346
    cmp       %rax,	61
    jz        L3347
    jmp       L3348
L3345:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	38
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3344
L3346:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	3
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3344
L3347:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	47
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3344
L3348:
    mov       %al,	24
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L3344:
    jmp       L3260
L3349:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	61
    jnz       L3351
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	48
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3350
L3351:
    mov       %al,	25
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L3350:
    jmp       L3260
L3352:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	47
    jz        L3354
    cmp       %rax,	42
    jz        L3355
    cmp       %rax,	61
    jz        L3356
    jmp       L3357
L3354:
    call      cc_lex.readlinecomment
    mov       %al,	56
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
    jmp       L3260
L3355:
    call      cc_lex.readblockcomment
    jmp       L3353
L3356:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	49
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3260
L3357:
    mov       %al,	26
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3260
L3353:
    jmp       L3264
L3358:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	61
    jnz       L3360
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	50
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3359
L3360:
    mov       %al,	27
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L3359:
    jmp       L3260
L3361:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	61
    jnz       L3364
L3363:
    mov       %al,	40
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    inc       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L3362
L3364:
    mov       %al,	11
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L3362:
    jmp       L3260
L3365:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	61
    jz        L3367
    cmp       %rax,	60
    jz        L3368
    jmp       L3369
L3367:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	43
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3366
L3368:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	61
    jnz       L3371
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	54
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3370
L3371:
    mov       %al,	33
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L3370:
    jmp       L3366
L3369:
    mov       %al,	42
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L3366:
    jmp       L3260
L3372:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	61
    jz        L3374
    cmp       %rax,	62
    jz        L3375
    jmp       L3376
L3374:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	44
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3373
L3375:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	61
    jnz       L3378
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	55
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3377
L3378:
    mov       %al,	34
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L3377:
    jmp       L3373
L3376:
    mov       %al,	45
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L3373:
    jmp       L3260
L3379:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	38
    jz        L3381
    cmp       %rax,	61
    jz        L3382
    jmp       L3383
L3381:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	32
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3380
L3382:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	52
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3380
L3383:
    mov       %al,	29
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L3380:
    jmp       L3260
L3384:
    mov       %rcx,	39
    xor       %edx,	%edx
    call      cc_lex.lxreadstring
    jmp       L3260
L3385:
    mov       %rcx,	34
    xor       %edx,	%edx
    call      cc_lex.lxreadstring
    jmp       L3260
L3386:
    jmp       L3264
L3387:
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %rax,	[%rax+16]
    inc       dword ptr[%rax]
    mov       %al,	56
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
    mov       %rax,	[%rip+cc_lex.dowhitespace]
    test      %rax,	%rax
    jz        L3389
    mov       %rax,	[%rip+cc_lex.lxsptr]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10],	%rax
L3390:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    sub       %rax,	9
    cmp       %rax,	24
    jae       L3393
    lea       %r10,	[%rip+L3392]
    jmp       [%r10 + %rax*8]
    .data
L3392:
    .quad     L3394
    .quad     L3393
    .quad     L3393
    .quad     L3393
    .quad     L3393
    .quad     L3393
    .quad     L3393
    .quad     L3393
    .quad     L3393
    .quad     L3393
    .quad     L3393
    .quad     L3393
    .quad     L3393
    .quad     L3393
    .quad     L3393
    .quad     L3393
    .quad     L3393
    .quad     L3393
    .quad     L3393
    .quad     L3393
    .quad     L3393
    .quad     L3393
    .quad     L3393
    .quad     L3394
    .text
L3394:
    jmp       L3390
L3393:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L3391
L3391:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    mov       %r10,	[%rip+cc_lex.lxsptr]
    sub       %r10,	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       [%rax+24],	%r10d
L3389:
    jmp       L3260
L3395:
    jmp       L3264
L3396:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	61
    jnz       L3399
L3398:
    mov       %al,	41
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    inc       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L3397
L3399:
    mov       %al,	36
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L3397:
    jmp       L3260
L3400:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8864]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %eax,	[%rax+16]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+20]
    lea       %r10,	[%rip+cc_decls.sourcefilenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+cc_lex.lx_stackindex]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L3264
L3401:
#cc_lex.lexreadtoken.doeof:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lx_stackindex]
    test      %rax,	%rax
    jz        L3404
    call      cc_lex.unstacksourcefile
    mov       %al,	56
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3403
L3404:
    mov       %al,	57
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L3403:
    jmp       L3260
L3405:
    jmp       L3264
L3406:
    add       qword ptr[%rip+cc_lex.lxsptr],	2
    jmp       L3264
L3267:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	1
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	128
    jl        L3408
    cmp       %rax,	255
    jle       L3269
L3408:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8865]
    call      msys.m$print_str_nf
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	1
    movzx     %rax,	byte ptr[%rax]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.m$print_c8
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	1
    movzx     %rax,	byte ptr[%rax]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    mov       %rcx,	[%rip+cc_lex.lx_stackindex]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8865]
    call      cc_lex.lxerror
    mov       %al,	1
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3260
L3260:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.readrealnumber
cc_lex.readrealnumber:
#?>>
    .set cc_lex.readrealnumber.intlen, 104
    .set cc_lex.readrealnumber.base, 112
    .set cc_lex.readrealnumber.badexpon, -8
    .set cc_lex.readrealnumber.realstr, -520
    .set cc_lex.readrealnumber.rs, -528
    .set cc_lex.readrealnumber.expstr, -560
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    movq      %rax,	%XMM13
    push      %rax
    movq      %rax,	%XMM14
    push      %rax
    movq      %rax,	%XMM15
    push      %rax
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	600
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       [%rbp+104],	%r8
    mov       [%rbp+112],	%r9
#---------------
    mov       %rax,	[%rbp + cc_lex.readrealnumber.base]
    cmp       %rax,	10
    jz        L3411
    mov       %rcx,	%r13
    mov       %rdx,	%r14
    mov       %r8,	[%rbp + cc_lex.readrealnumber.intlen]
    mov       %r9,	[%rbp + cc_lex.readrealnumber.base]
    call      cc_lex.old_readrealnumber
    jmp       L3409
L3411:
    xor       %rdi,	%rdi
    xor       %eax,	%eax
    mov       %rbx,	%rax
    xor       %rsi,	%rsi
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	46
    jnz       L3413
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rdi,	[%rip+cc_lex.lxsptr]
    mov       %rcx,	[%rbp + cc_lex.readrealnumber.base]
    call      cc_lex.scannumber
    sub       %rax,	%rdi
    mov       %rbx,	%rax
L3413:
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.readrealnumber.badexpon],	%rax
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	101
    jz        L3415
    cmp       %rax,	69
    jz        L3415
    cmp       %rax,	112
    jz        L3416
    cmp       %rax,	80
    jz        L3416
    jmp       L3417
L3415:
    mov       %rax,	[%rbp + cc_lex.readrealnumber.base]
    cmp       %rax,	16
    jz        L3419
    inc       qword ptr[%rip+cc_lex.lxsptr]
    lea       %rcx,	[%rbp + cc_lex.readrealnumber.badexpon]
    call      cc_lex.readexponent
    mov       %rsi,	%rax
L3419:
    jmp       L3414
L3416:
    mov       %rax,	[%rbp + cc_lex.readrealnumber.base]
    cmp       %rax,	16
    jnz       L3421
    inc       qword ptr[%rip+cc_lex.lxsptr]
    lea       %rcx,	[%rbp + cc_lex.readrealnumber.badexpon]
    call      cc_lex.readexponent
    mov       %rsi,	%rax
L3421:
L3417:
L3414:
    mov       %rax,	[%rbp + cc_lex.readrealnumber.badexpon]
    test      %rax,	%rax
    jz        L3423
    dec       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rcx,	%r13
    call      cc_lex.readalphanumeric
    jmp       L3409
L3423:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	102
    jz        L3425
    cmp       %rax,	70
    jz        L3425
    cmp       %rax,	108
    jz        L3425
    cmp       %rax,	76
    jnz       L3426
L3425:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L3424
L3426:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    lea       %r10,	[%rip+cc_lex.alphamap]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L3428
    mov       %rcx,	%r13
    call      cc_lex.readalphanumeric
    jmp       L3409
L3428:
L3424:
    mov       %rax,	[%rbp + cc_lex.readrealnumber.base]
    cmp       %rax,	16
    jnz       L3430
    mov       %al,	48
    mov       [%rbp + cc_lex.readrealnumber.realstr],	%al
    mov       %al,	120
    mov       [%rbp + cc_lex.readrealnumber.realstr+1],	%al
    lea       %rax,	[%rbp + cc_lex.readrealnumber.realstr+2]
    mov       [%rbp + cc_lex.readrealnumber.rs],	%rax
    mov       %r12,	2
    jmp       L3429
L3430:
    lea       %rax,	[%rbp + cc_lex.readrealnumber.realstr]
    mov       [%rbp + cc_lex.readrealnumber.rs],	%rax
    xor       %r12,	%r12
L3429:
    mov       %rax,	[%rbp + cc_lex.readrealnumber.intlen]
    add       %rax,	%rbx
    cmp       %rax,	500
    jle       L3432
    lea       %rcx,	[%rip+L8866]
    call      cc_lex.lxerror
L3432:
    mov       %rax,	[%rbp + cc_lex.readrealnumber.intlen]
    test      %rax,	%rax
    jz        L3434
    mov       %rcx,	[%rbp + cc_lex.readrealnumber.rs]
    mov       %rdx,	%r14
    mov       %r8,	[%rbp + cc_lex.readrealnumber.intlen]
    call      memcpy
L3434:
    test      %rbx,	%rbx
    jz        L3436
    mov       %rax,	[%rbp + cc_lex.readrealnumber.rs]
    mov       %r10,	[%rbp + cc_lex.readrealnumber.intlen]
    lea       %rax,	[%rax + %r10]
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      memcpy
L3436:
    mov       %rax,	[%rbp + cc_lex.readrealnumber.base]
    cvtsi2sd  %XMM4,	%rax
    movq      %XMM15,	%XMM4
    movq      %XMM13,	%XMM4
    mov       %rax,	[%rbp + cc_lex.readrealnumber.base]
    cmp       %rax,	10
    jnz       L3438
    mov       %rax,	%rbx
    sub       %rsi,	%rax
    jmp       L3437
L3438:
    mov       %rax,	%rbx
    shl       %rax,	2
    sub       %rsi,	%rax
    movq      %XMM4,	[%rip+L8867]
    movq      %XMM13,	%XMM4
L3437:
    mov       %rax,	%r12
    add       %rax,	[%rbp + cc_lex.readrealnumber.intlen]
    add       %rax,	%rbx
    xor       %r10d,	%r10d
    mov       [%rbp + %rax + cc_lex.readrealnumber.realstr],	%r10b
    lea       %rcx,	[%rbp + cc_lex.readrealnumber.expstr]
    call      msys.m$print_startstr
    mov       %rax,	[%rbp + cc_lex.readrealnumber.base]
    cmp       %rax,	10
    jnz       L3440
    lea       %rax,	[%rip+L8868]
    jmp       L3439
L3440:
    lea       %rax,	[%rip+L8869]
L3439:
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       %rcx,	%rsi
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + cc_lex.readrealnumber.realstr]
    lea       %rdx,	[%rbp + cc_lex.readrealnumber.expstr]
    call      strcat
    mov       %rax,	[%rbp + cc_lex.readrealnumber.base]
    cmp       %rax,	10
    jz        L3442
    lea       %rcx,	[%rip+L8870]
    call      cc_lex.lxerror
L3442:
    lea       %rcx,	[%rbp + cc_lex.readrealnumber.realstr]
    xor       %edx,	%edx
    call      strtod
    movq      %XMM14,	%XMM0
    mov       %al,	60
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    mov       %al,	11
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    movq      %XMM4,	%XMM14
    lea       %rax,	[%rip+cc_decls.nextlx]
    movq      [%rax],	%XMM4
    mov       %rax,	%r14
    sub       %rax,	[%rip+cc_lex.lxstart]
    mov       %rcx,	%rax
    call      cc_lex.setnumberoffset
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	%r14
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
L3409:
#---------------
    add       %rsp,	600
    pop       %rbp
    pop       %rcx
    movq      %XMM15,	%rcx
    pop       %rcx
    movq      %XMM14,	%rcx
    pop       %rcx
    movq      %XMM13,	%rcx
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.readexponent
cc_lex.readexponent:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    sub       %rsp,	48
    mov       %r15,	%rcx
#---------------
    xor       %rsi,	%rsi
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	43
    jz        L3445
    cmp       %rax,	45
    jz        L3446
    jmp       L3447
L3445:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L3444
L3446:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rsi,	1
L3447:
L3444:
    mov       %rdi,	[%rip+cc_lex.lxsptr]
    mov       %rcx,	10
    call      cc_lex.scannumber
    sub       %rax,	%rdi
    mov       %rbx,	%rax
    test      %rbx,	%rbx
    jnz       L3449
    mov       %rax,	1
    mov       [%r15],	%rax
    xor       %eax,	%eax
    jmp       L3443
L3449:
    xor       %r13,	%r13
    mov       %rax,	%rbx
    mov       %r14,	%rax
    cmp       %r14,	0
    jle       L3452
L3450:
    mov       %rax,	%rdi
    inc       %rdi
    movzx     %rax,	byte ptr[%rax]
    mov       %r12,	%rax
    mov       %rax,	%r13
    shl       %rax,	1
    lea       %rax,	[%rax + %rax*4]
    add       %rax,	%r12
    sub       %rax,	48
    mov       %r13,	%rax
    dec       %r14
    jnz       L3450
L3452:
    test      %rsi,	%rsi
    jz        L3454
    mov       %rax,	%r13
    neg       %rax
    jmp       L3453
L3454:
    mov       %rax,	%r13
L3453:
L3443:
#---------------
    add       %rsp,	48
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.lxerror
cc_lex.lxerror:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8871]
    call      msys.m$print_str_nf
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L8872]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    call      cc_lex.getfileno
    lea       %r10,	[%rip+cc_decls.sourcefilepaths]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L8873]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %eax,	[%rax+16]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	11
    call      exit
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lex.printsymbol
cc_lex.printsymbol:
#?>>
    .set cc_lex.printsymbol.l, -32
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	72
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	%rdi
    lea       %r10,	[%rbp + cc_lex.printsymbol.l]
    mov       %r11,	[%rax]
    mov       [%r10],	%r11
    mov       %r11,	[%rax+8]
    mov       [%r10+8],	%r11
    mov       %r11,	[%rax+16]
    mov       [%r10+16],	%r11
    mov       %r11,	[%rax+24]
    mov       [%r10+24],	%r11
    movzx     %rax,	byte ptr[%rbp + cc_lex.printsymbol.l+21]
    lea       %r10,	[%rip+cc_tables.symbolnames]
    mov       %r10,	[%r10 + %rax*8-8]
    lea       %rcx,	[%rip+L8874]
    mov       %rdx,	%r10
    call      printf
    movzx     %rax,	byte ptr[%rbp + cc_lex.printsymbol.l+21]
    cmp       %rax,	67
    jz        L3458
    cmp       %rax,	59
    jz        L3459
    cmp       %rax,	60
    jz        L3460
    cmp       %rax,	63
    jz        L3461
    cmp       %rax,	61
    jz        L3462
    jmp       L3463
L3458:
    mov       %rax,	[%rbp + cc_lex.printsymbol.l]
    movzx     %rax,	byte ptr[%rax+106]
    mov       %r10,	[%rbp + cc_lex.printsymbol.l]
    mov       %r10,	[%r10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      cc_lex.printstrn
    jmp       L3457
L3459:
    call      msys.m$print_startcon
    mov       %rcx,	[%rbp + cc_lex.printsymbol.l]
    call      msys.m$print_i64_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L8875]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      cc_lex.shownumberstr
    jmp       L3457
L3460:
    call      msys.m$print_startcon
    movq      %XMM4,	[%rbp + cc_lex.printsymbol.l]
    movq      %XMM0,	%XMM4
    xor       %edx,	%edx
    call      msys.m$print_r64
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L8875]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      cc_lex.shownumberstr
    jmp       L3457
L3461:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8876]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    movsxd    %rax,	dword ptr[%rbp + cc_lex.printsymbol.l+24]
    mov       %r10,	[%rbp + cc_lex.printsymbol.l]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      cc_lex.printstrn
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8876]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L3457
L3462:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8877]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    movsxd    %rax,	dword ptr[%rbp + cc_lex.printsymbol.l+24]
    mov       %r10,	[%rbp + cc_lex.printsymbol.l]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      cc_lex.printstrn
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8877]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L3457
L3463:
    mov       %al,	[%rbp + cc_lex.printsymbol.l+22]
    test      %al,	%al
    jz        L3465
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8878]
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rbp + cc_lex.printsymbol.l+22]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
L3465:
L3457:
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
#---------------
    add       %rsp,	72
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc cc_lex.lexsetup
cc_lex.lexsetup:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    call      cc_lex.inithashtable
    call      cc_lex.fillhashtable
    xor       %rdi,	%rdi
L3467:
    lea       %rax,	[%rdi-36]
    cmp       %rax,	220
    jae       L3472
    lea       %r10,	[%rip+L3471]
    jmp       [%r10 + %rax*8]
    .data
L3471:
    .quad     L3473
    .quad     L3472
    .quad     L3472
    .quad     L3472
    .quad     L3472
    .quad     L3472
    .quad     L3472
    .quad     L3472
    .quad     L3472
    .quad     L3472
    .quad     L3472
    .quad     L3472
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3472
    .quad     L3472
    .quad     L3472
    .quad     L3472
    .quad     L3472
    .quad     L3472
    .quad     L3472
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3472
    .quad     L3472
    .quad     L3472
    .quad     L3472
    .quad     L3473
    .quad     L3472
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3472
    .quad     L3472
    .quad     L3472
    .quad     L3472
    .quad     L3472
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .quad     L3473
    .text
L3473:
    mov       %al,	1
    lea       %r10,	[%rip+cc_lex.alphamap]
    mov       %r11,	%rdi
    mov       [%r10 + %r11],	%al
L3472:
L3470:
    lea       %rax,	[%rdi-48]
    cmp       %rax,	10
    jae       L3476
    lea       %r10,	[%rip+L3475]
    jmp       [%r10 + %rax*8]
    .data
L3475:
    .quad     L3477
    .quad     L3477
    .quad     L3477
    .quad     L3477
    .quad     L3477
    .quad     L3477
    .quad     L3477
    .quad     L3477
    .quad     L3477
    .quad     L3477
    .text
L3477:
    mov       %al,	1
    lea       %r10,	[%rip+cc_lex.digitmap]
    mov       %r11,	%rdi
    mov       [%r10 + %r11],	%al
L3476:
L3474:
    mov       %al,	1
    lea       %r10,	[%rip+cc_lex.commentmap]
    mov       %r11,	%rdi
    mov       [%r10 + %r11],	%al
    mov       %al,	1
    lea       %r10,	[%rip+cc_lex.linecommentmap]
    mov       %r11,	%rdi
    mov       [%r10 + %r11],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_lex.spacemap]
    mov       %r11,	%rdi
    mov       [%r10 + %r11],	%al
    inc       %rdi
    cmp       %rdi,	255
    jle       L3467
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_lex.commentmap]
    mov       [%r10+42],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_lex.commentmap]
    mov       [%r10],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_lex.commentmap]
    mov       [%r10+10],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_lex.linecommentmap]
    mov       [%r10],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_lex.linecommentmap]
    mov       [%r10+92],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_lex.linecommentmap]
    mov       [%r10+10],	%al
    mov       %al,	1
    lea       %r10,	[%rip+cc_lex.spacemap]
    mov       [%r10+32],	%al
    mov       %al,	1
    lea       %r10,	[%rip+cc_lex.spacemap]
    mov       [%r10+9],	%al
    mov       %al,	56
    lea       %r10,	[%rip+cc_lex.normaltkx]
    mov       [%r10+21],	%al
    xor       %eax,	%eax
    mov       [%rip+cc_lex.npastedtokens],	%rax
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lex.printstrn
cc_lex.printstrn:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    test      %rbx,	%rbx
    jz        L3480
    test      %rsi,	%rsi
    jnz       L3482
    call      msys.m$print_startcon
    mov       %rcx,	%rbx
    lea       %rdx,	[%rip+L8879]
    call      msys.m$print_i64
    call      msys.m$print_nogap
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8880]
    call      msys.m$print_str
    call      msys.m$print_end
    jmp       L3481
L3482:
    mov       %rcx,	%rsi
    call      msys.m$print_startfile
    mov       %rcx,	%rbx
    lea       %rdx,	[%rip+L8881]
    call      msys.m$print_i64
    call      msys.m$print_nogap
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8882]
    call      msys.m$print_str
    call      msys.m$print_end
L3481:
L3480:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.scannumber
cc_lex.scannumber:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    mov       %rdi,	[%rip+cc_lex.lxsptr]
L3484:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    mov       %rbx,	%rax
    sub       %rax,	39
    cmp       %rax,	64
    jae       L3487
    lea       %r10,	[%rip+L3486]
    jmp       [%r10 + %rax*8]
    .data
L3486:
    .quad     L3494
    .quad     L3487
    .quad     L3487
    .quad     L3487
    .quad     L3487
    .quad     L3487
    .quad     L3487
    .quad     L3487
    .quad     L3487
    .quad     L3488
    .quad     L3488
    .quad     L3488
    .quad     L3488
    .quad     L3488
    .quad     L3488
    .quad     L3488
    .quad     L3488
    .quad     L3488
    .quad     L3488
    .quad     L3487
    .quad     L3487
    .quad     L3487
    .quad     L3487
    .quad     L3487
    .quad     L3487
    .quad     L3487
    .quad     L3491
    .quad     L3491
    .quad     L3491
    .quad     L3491
    .quad     L3491
    .quad     L3491
    .quad     L3487
    .quad     L3487
    .quad     L3487
    .quad     L3487
    .quad     L3487
    .quad     L3487
    .quad     L3487
    .quad     L3487
    .quad     L3487
    .quad     L3487
    .quad     L3487
    .quad     L3487
    .quad     L3487
    .quad     L3487
    .quad     L3487
    .quad     L3487
    .quad     L3487
    .quad     L3487
    .quad     L3487
    .quad     L3487
    .quad     L3487
    .quad     L3487
    .quad     L3487
    .quad     L3487
    .quad     L3494
    .quad     L3494
    .quad     L3491
    .quad     L3491
    .quad     L3491
    .quad     L3491
    .quad     L3491
    .quad     L3491
    .text
L3488:
    mov       %rax,	%rdi
    inc       %rdi
    mov       %r10b,	%bl
    mov       [%rax],	%r10b
    mov       %rax,	48
    add       %rax,	%rsi
    mov       %r10,	%rbx
    cmp       %r10,	%rax
    jl        L3490
    lea       %rcx,	[%rip+L8883]
    call      cc_lex.lxerror
L3490:
    jmp       L3484
L3491:
    cmp       %rsi,	16
    jnz       L3493
    mov       %rax,	%rdi
    inc       %rdi
    mov       %r10b,	%bl
    mov       [%rax],	%r10b
    jmp       L3492
L3493:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L3485
L3492:
    jmp       L3484
L3494:
    jmp       L3484
L3487:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L3485
L3485:
    mov       %rax,	%rdi
L3483:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.lookup
cc_lex.lookup:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
#cc_lex.lookup.retry:
L3496:
    mov       %rax,	[%rip+cc_lex.lxhashvalue]
    and       %rax,	[%rip+cc_decls.hstmask]
    mov       %rdi,	%rax
    xor       %rbx,	%rbx
L3497:
    mov       %rax,	[%rip+cc_decls.hashtable]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10],	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    movzx     %rax,	byte ptr[%rax+106]
    mov       %rsi,	%rax
    test      %rsi,	%rsi
    jnz       L3500
    jmp       L3498
L3500:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+24]
    mov       %r10,	%rsi
    cmp       %r10,	%rax
    jnz       L3502
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    mov       %rdx,	[%rip+cc_lex.lxsvalue]
    mov       %r8,	%rsi
    call      memcmp
    movsxd    %r10,	%eax
    test      %r10,	%r10
    jnz       L3504
    mov       %rax,	1
    jmp       L3495
L3504:
L3502:
    inc       %rdi
    cmp       %rdi,	[%rip+cc_decls.hstsize]
    jl        L3506
    test      %rbx,	%rbx
    jz        L3508
    lea       %rcx,	[%rip+L8884]
    call      mlib.abortprogram
L3508:
    mov       %rbx,	1
    xor       %rdi,	%rdi
L3506:
    jmp       L3497
L3498:
    mov       %rax,	[%rip+cc_lex.nhstsymbols]
    cmp       %rax,	[%rip+cc_lex.hstthreshold]
    jl        L3510
    call      cc_lex.newhashtable
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+24]
    mov       %rcx,	[%rip+cc_lex.lxsvalue]
    mov       %rdx,	%rax
    call      cc_lex.gethashvalue
    mov       [%rip+cc_lex.lxhashvalue],	%rax
    jmp       L3496
L3510:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+24]
    mov       %rcx,	[%rip+cc_lex.lxsvalue]
    mov       %rdx,	%rax
    call      mlib.pcm_copyheapstringn
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       %r10,	[%r10]
    mov       [%r10],	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %eax,	[%rax+24]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       %r10,	[%r10]
    mov       [%r10+106],	%al
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    mov       %r10b,	67
    mov       [%rax+107],	%r10b
    inc       qword ptr[%rip+cc_lex.nhstsymbols]
    xor       %eax,	%eax
L3495:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.gethashvalue
cc_lex.gethashvalue:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    cmp       %r12,	-1
    jnz       L3513
    mov       %rcx,	%rsi
    call      strlen
    mov       %r12,	%rax
L3513:
    xor       %rdi,	%rdi
    mov       %rax,	%r12
    mov       %rbx,	%rax
    cmp       %rbx,	0
    jle       L3516
L3514:
    mov       %rax,	%rdi
    shl       %rax,	4
    sub       %rax,	%rdi
    mov       %r10,	%rsi
    inc       %rsi
    movzx     %r10,	byte ptr[%r10]
    add       %rax,	%r10
    mov       %rdi,	%rax
    dec       %rbx
    jnz       L3514
L3516:
    mov       %rax,	%rdi
    shl       %rax,	5
    sub       %rax,	%rdi
L3511:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.inithashtable
cc_lex.inithashtable:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rax,	[%rip+cc_decls.hstsize]
    shl       %rax,	3
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       [%rip+cc_decls.hashtable],	%rax
    mov       %rax,	[%rip+cc_decls.hstsize]
    dec       %rax
    mov       [%rip+cc_decls.hstmask],	%rax
    xor       %rdi,	%rdi
    mov       %rax,	[%rip+cc_decls.hstmask]
    cmp       %rax,	0
    jl        L3520
L3518:
    mov       %rcx,	128
    call      mlib.pcm_allocz
    mov       %r10,	[%rip+cc_decls.hashtable]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*8],	%rax
    inc       %rdi
    cmp       %rdi,	[%rip+cc_decls.hstmask]
    jle       L3518
L3520:
    xor       %eax,	%eax
    mov       [%rip+cc_lex.nhstsymbols],	%rax
    mov       %rax,	6
    mov       %r10,	[%rip+cc_decls.hstsize]
    imul      %rax,	%r10
    mov       %r10,	10
    cqo       
    idiv      %r10
    mov       [%rip+cc_lex.hstthreshold],	%rax
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lex.fillhashtable
cc_lex.fillhashtable:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
    mov       %rdi,	1
    mov       %rbx,	64
    cmp       %rbx,	1
    jl        L3524
L3522:
    lea       %rax,	[%rip+cc_tables.stnames]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    mov       [%rip+cc_lex.lxsvalue],	%rax
    lea       %rax,	[%rip+cc_tables.stsymbols]
    mov       %r10,	%rdi
    movsxd    %rax,	dword ptr[%rax + %r10*4-4]
    cmp       %rax,	68
    jnz       L3526
    mov       %rcx,	[%rip+cc_lex.lxsvalue]
    call      mlib.pcm_copyheapstring
    mov       [%rip+cc_lex.lxsvalue],	%rax
L3526:
    mov       %rcx,	[%rip+cc_lex.lxsvalue]
    call      strlen
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+24]
    mov       %rcx,	[%rip+cc_lex.lxsvalue]
    mov       %rdx,	%rax
    call      cc_lex.gethashvalue
    mov       [%rip+cc_lex.lxhashvalue],	%rax
    call      cc_lex.lookup
    test      %rax,	%rax
    jz        L3528
    call      msys.m$print_startcon
    lea       %rax,	[%rip+cc_tables.stnames]
    mov       %r10,	%rdi
    mov       %rcx,	[%rax + %r10*8-8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8885]
    call      mlib.abortprogram
L3528:
    lea       %rax,	[%rip+cc_tables.stsymbols]
    mov       %r10,	%rdi
    mov       %eax,	[%rax + %r10*4-4]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       %r10,	[%r10]
    mov       [%r10+107],	%al
    lea       %rax,	[%rip+cc_tables.stsubcodes]
    mov       %r10,	%rdi
    mov       %eax,	[%rax + %r10*4-4]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       %r10,	[%r10]
    mov       [%r10+100],	%ax
    inc       %rdi
    cmp       %rdi,	%rbx
    jle       L3522
L3524:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.dolexdirective
cc_lex.dolexdirective:
#?>>
    .set cc_lex.dolexdirective.dir, -8
    .set cc_lex.dolexdirective.length, -16
    .set cc_lex.dolexdirective.allowmacros, -24
    .set cc_lex.dolexdirective.filename, -328
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	360
#---------------
    mov       %rsi,	[%rip+cc_lex.lxsptr]
    call      cc_lex.getlexdirective
    mov       [%rbp + cc_lex.dolexdirective.dir],	%rax
    mov       %rax,	[%rbp + cc_lex.dolexdirective.dir]
    test      %rax,	%rax
    jnz       L3531
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	%rsi
    mov       %rcx,	%rsi
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      cc_lex.printstrn
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8886]
    call      cc_lex.lxerror
L3531:
    mov       %rax,	[%rbp + cc_lex.dolexdirective.dir]
    cmp       %rax,	7
    jz        L3533
    cmp       %rax,	1
    jz        L3534
    cmp       %rax,	10
    jz        L3535
    cmp       %rax,	8
    jz        L3536
    cmp       %rax,	9
    jz        L3537
    cmp       %rax,	3
    jz        L3538
    cmp       %rax,	4
    jz        L3539
    cmp       %rax,	5
    jz        L3539
    cmp       %rax,	6
    jz        L3540
    cmp       %rax,	13
    jz        L3541
    cmp       %rax,	14
    jz        L3542
    cmp       %rax,	11
    jz        L3543
    cmp       %rax,	15
    jz        L3544
    jmp       L3545
L3533:
    mov       %rax,	1
    mov       [%rip+cc_lex.isincludefile],	%rax
    jmp       L3547
L3546:
    inc       qword ptr[%rip+cc_lex.lxsptr]
L3547:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	32
    jz        L3546
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	9
    jz        L3546
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	60
    setnz     %al
    movzx     %eax,	%al
    mov       [%rbp + cc_lex.dolexdirective.allowmacros],	%rax
    call      cc_lex.lexm
    xor       %eax,	%eax
    mov       [%rip+cc_lex.isincludefile],	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	42
    jnz       L3550
    mov       %r15,	1
    lea       %rax,	[%rbp + cc_lex.dolexdirective.filename]
    mov       %rbx,	%rax
    mov       %rax,	[%rbp + cc_lex.dolexdirective.allowmacros]
    test      %rax,	%rax
    jz        L3552
L3553:
    call      cc_lex.lexm
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	57
    jz        L3556
    cmp       %rax,	56
    jz        L3556
    cmp       %rax,	45
    jz        L3557
    jmp       L3558
L3556:
    lea       %rcx,	[%rip+L8887]
    call      cc_lex.lxerror
    jmp       L3555
L3557:
    jmp       L3554
L3558:
    lea       %rcx,	[%rip+cc_decls.nextlx]
    lea       %rdx,	[%rbp + cc_lex.dolexdirective.length]
    call      cc_lex.strtoken
    mov       %r12,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	%r12
    mov       %r8,	[%rbp + cc_lex.dolexdirective.length]
    call      memcpy
    mov       %rax,	[%rbp + cc_lex.dolexdirective.length]
    add       %rbx,	%rax
L3555:
    jmp       L3553
L3554:
    jmp       L3551
L3552:
L3559:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    mov       %r14,	%rax
    mov       %rax,	%r14
    cmp       %rax,	62
    jz        L3562
    cmp       %rax,	10
    jz        L3563
    test      %rax,	%rax
    jz        L3563
    jmp       L3564
L3562:
    jmp       L3560
L3563:
    lea       %rcx,	[%rip+L8888]
    call      cc_lex.lxerror
    jmp       L3561
L3564:
    mov       %rax,	%rbx
    inc       %rbx
    mov       %r10b,	%r14b
    mov       [%rax],	%r10b
L3561:
    jmp       L3559
L3560:
L3551:
    xor       %eax,	%eax
    mov       [%rbx],	%al
    jmp       L3549
L3550:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	63
    jnz       L3565
    xor       %r15,	%r15
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    lea       %rcx,	[%rbp + cc_lex.dolexdirective.filename]
    mov       %rdx,	%rax
    call      strcpy
    jmp       L3549
L3565:
    lea       %rcx,	[%rip+L8889]
    call      cc_lex.lxerror
L3549:
    call      cc_lex.lexm
    mov       %al,	[%rip+cc_cli.fshowincludes]
    test      %al,	%al
    jz        L3567
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8890]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rbp + cc_lex.dolexdirective.filename]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L8891]
    call      msys.m$print_str_nf
    call      cc_lex.getfileno
    lea       %r10,	[%rip+cc_decls.sourcefilepaths]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %eax,	[%rax+16]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    lea       %rcx,	[%rip+L8892]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+cc_decls.nsourcefiles]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L3567:
    inc       qword ptr[%rip+cc_lex.nincludes]
    lea       %rcx,	[%rbp + cc_lex.dolexdirective.filename]
    mov       %rdx,	%r15
    call      cc_lex.stacksourcefile
    jmp       L3532
L3534:
    call      cc_lex.dodefine
    jmp       L3532
L3535:
    call      cc_lex.lexreadtoken
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L3569
    lea       %rcx,	[%rip+L8893]
    call      cc_lex.lxerror
L3569:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rdi,	[%rax]
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	1
    jnz       L3570
L3571:
    xor       %eax,	%eax
    mov       [%rdi+109],	%al
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    mov       %al,	[%rax+88]
    mov       [%rdi+107],	%al
    xor       %eax,	%eax
    mov       [%rdi+80],	%rax
    lea       %rax,	[%rdi+108]
    and       byte ptr[%rax],	251
L3570:
    jmp       L3532
L3536:
    call      cc_lex.getifdef
    mov       %r13,	%rax
    jmp       L3572
L3537:
    call      cc_lex.getifdef
    test      %rax,	%rax
    setz      %al
    movzx     %eax,	%al
    mov       %r13,	%rax
    jmp       L3572
L3538:
    call      cc_lex.getifexpr
    mov       %r13,	%rax
#cc_lex.dolexdirective.doif:
L3572:
    inc       qword ptr[%rip+cc_lex.ifcondlevel]
    test      %r13,	%r13
    jz        L3574
    xor       %eax,	%eax
    jmp       L3529
L3574:
#cc_lex.dolexdirective.doskipcode:
L3575:
    call      cc_lex.skipcode
    mov       [%rbp + cc_lex.dolexdirective.dir],	%rax
    mov       %rax,	[%rbp + cc_lex.dolexdirective.dir]
    cmp       %rax,	4
    jz        L3577
    cmp       %rax,	5
    jz        L3578
    cmp       %rax,	6
    jz        L3579
    jmp       L3580
L3577:
    call      cc_lex.getifexpr
    mov       %r13,	%rax
    test      %r13,	%r13
    jz        L3582
    xor       %eax,	%eax
    jmp       L3529
L3582:
    jmp       L3575
L3578:
    jmp       L3576
L3579:
    dec       qword ptr[%rip+cc_lex.ifcondlevel]
L3580:
L3576:
L3573:
    jmp       L3532
L3539:
    mov       %rax,	[%rip+cc_lex.ifcondlevel]
    test      %rax,	%rax
    jnz       L3584
    lea       %rcx,	[%rip+L8894]
    call      cc_lex.lxerror
L3584:
L3585:
    call      cc_lex.skipcode
    mov       [%rbp + cc_lex.dolexdirective.dir],	%rax
    mov       %rax,	[%rbp + cc_lex.dolexdirective.dir]
    cmp       %rax,	6
    jnz       L3585
    dec       qword ptr[%rip+cc_lex.ifcondlevel]
    jmp       L3532
L3540:
    mov       %rax,	[%rip+cc_lex.ifcondlevel]
    test      %rax,	%rax
    jnz       L3589
    lea       %rcx,	[%rip+L8895]
    call      cc_lex.lxerror
L3589:
    dec       qword ptr[%rip+cc_lex.ifcondlevel]
    jmp       L3532
L3541:
    jmp       L3532
L3542:
L3590:
    call      cc_lex.lexreadtoken
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	56
    jnz       L3590
    jmp       L3532
L3543:
    call      cc_lex.lexm
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8896]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       %rcx,	[%rip+cc_decls.nextlx]
    call      cc_lex.showtoken
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8897]
    call      cc_lex.lxerror
    jmp       L3532
L3544:
    call      cc_lex.dopragmadir
    jmp       L3532
L3545:
#cc_lex.dolexdirective.skip:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8898]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_tables.sourcedirnames]
    mov       %r10,	[%rbp + cc_lex.dolexdirective.dir]
    mov       %rcx,	[%rax + %r10*8-8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       [%rip+cc_lex.lxsptr],	%rsi
    mov       %al,	4
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    mov       %rax,	1
    jmp       L3529
    lea       %rcx,	[%rip+L8899]
    call      cc_lex.lxerror
L3532:
    xor       %eax,	%eax
L3529:
#---------------
    add       %rsp,	360
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.getlexdirective
cc_lex.getlexdirective:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    call      cc_lex.lexreadtoken
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L3596
    cmp       %rax,	56
    jz        L3597
    cmp       %rax,	59
    jz        L3598
    jmp       L3599
L3596:
    jmp       L3595
L3597:
    mov       %rax,	13
    jmp       L3594
L3598:
L3600:
    call      cc_lex.lexreadtoken
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	56
    jz        L3603
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	57
    jnz       L3600
L3603:
    mov       %rax,	13
    jmp       L3594
L3599:
    xor       %eax,	%eax
    jmp       L3594
L3595:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    movzx     %rax,	byte ptr[%rax+107]
    cmp       %rax,	68
    jz        L3605
    cmp       %rax,	72
    jz        L3606
    cmp       %rax,	73
    jz        L3607
    cmp       %rax,	56
    jz        L3608
    jmp       L3609
L3605:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    movsx     %rax,	word ptr[%rax+100]
    jmp       L3594
L3606:
    mov       %rax,	3
    jmp       L3594
L3607:
    mov       %rax,	5
    jmp       L3594
L3608:
    mov       %rax,	13
    jmp       L3594
L3609:
L3604:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rdi,	[%rax]
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	1
    jnz       L3611
    movzx     %rax,	byte ptr[%rdi+88]
    cmp       %rax,	68
    jnz       L3613
    movsx     %rax,	word ptr[%rdi+100]
    jmp       L3594
L3613:
L3611:
    xor       %eax,	%eax
L3594:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lex.startlex
cc_lex.startlex:
#?>>
    .set cc_lex.startlex.caption, 24
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rdx
#---------------
    xor       %eax,	%eax
    mov       [%rip+cc_lex.ifcondlevel],	%rax
    xor       %eax,	%eax
    mov       [%rip+cc_lex.lx_stackindex],	%rax
    xor       %eax,	%eax
    mov       [%rip+cc_lex.noexpand],	%rax
    lea       %rax,	[%rip+cc_lex.normaltkx]
    mov       [%rip+cc_lex.normaltk],	%rax
    xor       %eax,	%eax
    mov       [%rip+cc_lex.lx_stackindex],	%rax
    xor       %eax,	%eax
    mov       [%rip+cc_lex.ifcondlevel],	%rax
    mov       %rax,	1
    mov       [%rip+cc_lex.firstsymbol],	%rax
    xor       %eax,	%eax
    mov       [%rip+cc_lex.npastedtokens],	%rax
    xor       %eax,	%eax
    mov       [%rip+cc_lex.isincludefile],	%rax
    xor       %eax,	%eax
    mov       [%rip+cc_lex.tkptr],	%rax
    lea       %rax,	[%rip+cc_decls.sourcefiletext]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    mov       [%rip+cc_lex.lxsptr],	%rax
    mov       [%rip+cc_lex.lxstart],	%rax
    mov       %rcx,	%rdi
    call      cc_lex.setfileno
    mov       %eax,	1
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+16],	%eax
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+28],	%eax
    mov       %al,	56
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    call      cc_lex.lex
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lex.endlex
cc_lex.endlex:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    mov       %rax,	[%rip+cc_lex.ifcondlevel]
    test      %rax,	%rax
    jz        L3617
    call      msys.m$print_startcon
    mov       %rcx,	[%rip+cc_lex.ifcondlevel]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8900]
    call      cc_lex.lxerror
L3617:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_lex.ps
cc_lex.ps:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    call      msys.m$print_startcon
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L8901]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       %rcx,	[%rip+cc_decls.lx]
    call      cc_lex.printsymbol
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lex.psnext
cc_lex.psnext:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    call      msys.m$print_startcon
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L8902]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       %rcx,	[%rip+cc_decls.nextlx]
    call      cc_lex.printsymbol
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lex.gethashtablesize
cc_lex.gethashtablesize:
#?>>
    push      %rdi
    push      %rbx
#?]]
#---------------
    xor       %rbx,	%rbx
    xor       %eax,	%eax
    mov       %rdi,	%rax
    mov       %rax,	[%rip+cc_decls.hstmask]
    cmp       %rax,	0
    jl        L3623
L3621:
    mov       %rax,	[%rip+cc_decls.hashtable]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    mov       %rax,	[%rax]
    test      %rax,	%rax
    jz        L3625
    inc       %rbx
L3625:
    inc       %rdi
    cmp       %rdi,	[%rip+cc_decls.hstmask]
    jle       L3621
L3623:
    mov       %rax,	%rbx
L3620:
#---------------
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.readlinecomment
cc_lex.readlinecomment:
#?>>
#?]]
#---------------
L3627:
L3629:
L3630:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    lea       %r10,	[%rip+cc_lex.linecommentmap]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jnz       L3629
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	10
    jz        L3633
    test      %rax,	%rax
    jz        L3634
    cmp       %rax,	92
    jz        L3635
    jmp       L3636
L3633:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L3628
L3634:
    jmp       L3628
L3635:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	13
    jz        L3638
    cmp       %rax,	10
    jz        L3639
    jmp       L3640
L3638:
    add       qword ptr[%rip+cc_lex.lxsptr],	2
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %rax,	[%rax+16]
    inc       dword ptr[%rax]
    jmp       L3637
L3639:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %rax,	[%rax+16]
    inc       dword ptr[%rax]
L3640:
L3637:
L3636:
L3632:
    jmp       L3627
L3628:
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %rax,	[%rax+16]
    inc       dword ptr[%rax]
#---------------
    ret       
# End 
# Proc cc_lex.readblockcomment
cc_lex.readblockcomment:
#?>>
#?]]
    sub       %rsp,	40
#---------------
L3642:
L3644:
L3645:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    lea       %r10,	[%rip+cc_lex.commentmap]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jnz       L3644
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	10
    jz        L3648
    test      %rax,	%rax
    jz        L3649
    cmp       %rax,	42
    jz        L3650
    jmp       L3651
L3648:
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %rax,	[%rax+16]
    inc       dword ptr[%rax]
    jmp       L3647
L3649:
    lea       %rcx,	[%rip+L8903]
    call      cc_lex.lxerror
    jmp       L3647
L3650:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax+1]
    cmp       %rax,	47
    jnz       L3653
    add       qword ptr[%rip+cc_lex.lxsptr],	2
    jmp       L3643
L3653:
L3651:
L3647:
    jmp       L3642
L3643:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_lex.readhex
cc_lex.readhex:
#?>>
    .set cc_lex.readhex.pstart, 64
    .set cc_lex.readhex.p, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       [%rbp+64],	%rcx
#---------------
    xor       %rdi,	%rdi
    mov       %rax,	[%rip+cc_lex.lxsptr]
    mov       [%rbp + cc_lex.readhex.p],	%rax
    mov       %r12,	1
    xor       %eax,	%eax
    mov       %r14,	%rax
    mov       %r13,	%rax
    xor       %rsi,	%rsi
L3655:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    mov       %rbx,	%rax
    sub       %rax,	46
    cmp       %rax,	72
    jae       L3658
    lea       %r10,	[%rip+L3657]
    jmp       [%r10 + %rax*8]
    .data
L3657:
    .quad     L3665
    .quad     L3658
    .quad     L3660
    .quad     L3659
    .quad     L3659
    .quad     L3659
    .quad     L3659
    .quad     L3659
    .quad     L3659
    .quad     L3659
    .quad     L3659
    .quad     L3659
    .quad     L3658
    .quad     L3658
    .quad     L3658
    .quad     L3658
    .quad     L3658
    .quad     L3658
    .quad     L3658
    .quad     L3663
    .quad     L3663
    .quad     L3663
    .quad     L3663
    .quad     L3663
    .quad     L3663
    .quad     L3658
    .quad     L3658
    .quad     L3658
    .quad     L3658
    .quad     L3658
    .quad     L3666
    .quad     L3658
    .quad     L3658
    .quad     L3658
    .quad     L3665
    .quad     L3658
    .quad     L3658
    .quad     L3658
    .quad     L3658
    .quad     L3669
    .quad     L3658
    .quad     L3658
    .quad     L3658
    .quad     L3658
    .quad     L3658
    .quad     L3658
    .quad     L3658
    .quad     L3658
    .quad     L3658
    .quad     L3658
    .quad     L3658
    .quad     L3664
    .quad     L3664
    .quad     L3664
    .quad     L3664
    .quad     L3664
    .quad     L3664
    .quad     L3658
    .quad     L3658
    .quad     L3658
    .quad     L3658
    .quad     L3658
    .quad     L3666
    .quad     L3658
    .quad     L3658
    .quad     L3658
    .quad     L3665
    .quad     L3658
    .quad     L3658
    .quad     L3658
    .quad     L3658
    .quad     L3669
    .text
L3659:
    xor       %r12,	%r12
    mov       %rax,	%rdi
    shl       %rax,	4
    lea       %r10,	[%rbx-48]
    add       %rax,	%r10
    mov       %rdi,	%rax
    inc       %rsi
    jmp       L3655
L3660:
    test      %r12,	%r12
    jz        L3662
    inc       qword ptr[%rbp + cc_lex.readhex.p]
    jmp       L3661
L3662:
    inc       %rsi
    mov       %rax,	%rdi
    shl       %rax,	4
    mov       %rdi,	%rax
L3661:
    jmp       L3655
L3663:
    xor       %r12,	%r12
    inc       %rsi
    mov       %rax,	%rdi
    shl       %rax,	4
    lea       %r10,	[%rbx-65]
    add       %r10,	10
    add       %rax,	%r10
    mov       %rdi,	%rax
    jmp       L3655
L3664:
    xor       %r12,	%r12
    inc       %rsi
    mov       %rax,	%rdi
    shl       %rax,	4
    lea       %r10,	[%rbx-97]
    add       %r10,	10
    add       %rax,	%r10
    mov       %rdi,	%rax
    jmp       L3655
L3665:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	[%rbp + cc_lex.readhex.p]
    mov       %rcx,	[%rbp + cc_lex.readhex.pstart]
    mov       %rdx,	[%rbp + cc_lex.readhex.p]
    mov       %r8,	%rax
    mov       %r9,	16
    call      cc_lex.readrealnumber
    jmp       L3654
L3666:
    inc       %r13
    cmp       %r13,	2
    jle       L3668
    lea       %rcx,	[%rip+L8904]
    call      cc_lex.lxerror
L3668:
    jmp       L3655
L3669:
    test      %r14,	%r14
    jz        L3671
    lea       %rcx,	[%rip+L8905]
    call      cc_lex.lxerror
L3671:
    mov       %r14,	1
    jmp       L3655
L3658:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L3656
L3656:
    mov       %rax,	[%rbp + cc_lex.readhex.pstart]
    sub       %rax,	[%rip+cc_lex.lxstart]
    mov       %rcx,	%rax
    call      cc_lex.setnumberoffset
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	[%rbp + cc_lex.readhex.pstart]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
    cmp       %rsi,	16
    jle       L3673
    lea       %rcx,	[%rip+L8906]
    call      cc_lex.lxerror
L3673:
    mov       %al,	59
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    mov       %rax,	%rdi
    mov       %r10,	9223372036854775807
    cmp       %rax,	%r10
    jbe       L3675
    mov       %al,	9
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    jmp       L3674
L3675:
    mov       %rax,	%rdi
    mov       %r10,	4294967295
    cmp       %rax,	%r10
    jbe       L3676
    mov       %al,	4
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    jmp       L3674
L3676:
    cmp       %rdi,	2147483647
    jbe       L3677
    mov       %al,	8
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    jmp       L3674
L3677:
    mov       %al,	3
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
L3674:
    mov       %rax,	%rdi
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10],	%rax
    cmp       %r13,	2
    jz        L3680
    cmp       %r13,	1
    jnz       L3679
    mov       %al,	[%rip+pc_decls.flong64]
    test      %al,	%al
    jz        L3679
L3680:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+22]
    cmp       %rax,	8
    jz        L3682
    cmp       %rax,	3
    jz        L3683
    jmp       L3684
L3682:
    mov       %al,	9
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    jmp       L3681
L3683:
    mov       %al,	4
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
L3684:
L3681:
L3679:
    test      %r14,	%r14
    jz        L3686
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+22]
    cmp       %rax,	3
    jz        L3688
    cmp       %rax,	4
    jz        L3689
    jmp       L3690
L3688:
    mov       %al,	8
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    jmp       L3687
L3689:
    mov       %al,	9
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
L3690:
L3687:
L3686:
    call      cc_lex.checknumbersuffix
L3654:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.readbinary
cc_lex.readbinary:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    sub       %rsp,	48
    mov       %r15,	%rcx
#---------------
    xor       %rdi,	%rdi
    mov       %rax,	[%rip+cc_lex.lxsptr]
    mov       %r13,	%rax
    mov       %r12,	1
L3692:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    mov       %rbx,	%rax
    sub       %rax,	46
    cmp       %rax,	12
    jae       L3695
    lea       %r10,	[%rip+L3694]
    jmp       [%r10 + %rax*8]
    .data
L3694:
    .quad     L3701
    .quad     L3695
    .quad     L3697
    .quad     L3696
    .quad     L3700
    .quad     L3700
    .quad     L3700
    .quad     L3700
    .quad     L3700
    .quad     L3700
    .quad     L3700
    .quad     L3700
    .text
L3696:
    xor       %r12,	%r12
    jmp       L3692
L3697:
    test      %r12,	%r12
    jz        L3699
    inc       %r13
L3699:
    jmp       L3692
L3700:
    lea       %rcx,	[%rip+L8907]
    call      cc_lex.lxerror
    jmp       L3692
L3701:
    lea       %rcx,	[%rip+L8908]
    call      cc_lex.lxerror
    jmp       L3692
L3695:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L3693
L3693:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	%r13
    mov       %rsi,	%rax
    mov       %rax,	%r15
    sub       %rax,	[%rip+cc_lex.lxstart]
    mov       %rcx,	%rax
    call      cc_lex.setnumberoffset
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	%r15
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
    cmp       %rsi,	64
    jle       L3703
    lea       %rcx,	[%rip+L8909]
    call      cc_lex.lxerror
L3703:
    mov       %r14,	%rsi
    cmp       %r14,	0
    jle       L3706
L3704:
    mov       %rax,	%rdi
    shl       %rax,	1
    mov       %r10,	%r13
    inc       %r13
    movzx     %r10,	byte ptr[%r10]
    add       %rax,	%r10
    sub       %rax,	48
    mov       %rdi,	%rax
    dec       %r14
    jnz       L3704
L3706:
    mov       %al,	59
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    mov       %al,	3
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    cmp       %rdi,	2147483647
    jb        L3708
    mov       %al,	4
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
L3708:
    mov       %rax,	%rdi
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10],	%rax
    call      cc_lex.checknumbersuffix
#---------------
    add       %rsp,	48
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.readoctal
cc_lex.readoctal:
#?>>
    .set cc_lex.readoctal.pstart, 64
    .set cc_lex.readoctal.usigned, -8
    .set cc_lex.readoctal.p, -16
    .set cc_lex.readoctal.av_1, -24
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	64
    mov       [%rbp+64],	%rcx
#---------------
    xor       %rdi,	%rdi
    mov       %rax,	[%rip+cc_lex.lxsptr]
    mov       [%rbp + cc_lex.readoctal.p],	%rax
    mov       %r13,	1
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.readoctal.usigned],	%rax
    mov       %r14,	%rax
    xor       %rsi,	%rsi
L3710:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    mov       %rbx,	%rax
    sub       %rax,	46
    cmp       %rax,	72
    jae       L3713
    lea       %r10,	[%rip+L3712]
    jmp       [%r10 + %rax*8]
    .data
L3712:
    .quad     L3718
    .quad     L3713
    .quad     L3715
    .quad     L3714
    .quad     L3714
    .quad     L3714
    .quad     L3714
    .quad     L3714
    .quad     L3714
    .quad     L3714
    .quad     L3713
    .quad     L3713
    .quad     L3713
    .quad     L3713
    .quad     L3713
    .quad     L3713
    .quad     L3713
    .quad     L3713
    .quad     L3713
    .quad     L3713
    .quad     L3713
    .quad     L3713
    .quad     L3713
    .quad     L3713
    .quad     L3713
    .quad     L3713
    .quad     L3713
    .quad     L3713
    .quad     L3713
    .quad     L3713
    .quad     L3719
    .quad     L3713
    .quad     L3713
    .quad     L3713
    .quad     L3713
    .quad     L3713
    .quad     L3713
    .quad     L3713
    .quad     L3713
    .quad     L3722
    .quad     L3713
    .quad     L3713
    .quad     L3713
    .quad     L3713
    .quad     L3713
    .quad     L3713
    .quad     L3713
    .quad     L3713
    .quad     L3713
    .quad     L3713
    .quad     L3713
    .quad     L3713
    .quad     L3713
    .quad     L3713
    .quad     L3713
    .quad     L3713
    .quad     L3713
    .quad     L3713
    .quad     L3713
    .quad     L3713
    .quad     L3713
    .quad     L3713
    .quad     L3719
    .quad     L3713
    .quad     L3713
    .quad     L3713
    .quad     L3713
    .quad     L3713
    .quad     L3713
    .quad     L3713
    .quad     L3713
    .quad     L3722
    .text
L3714:
    xor       %r13,	%r13
    inc       %rsi
    jmp       L3710
L3715:
    test      %r13,	%r13
    jz        L3717
    inc       qword ptr[%rbp + cc_lex.readoctal.p]
    jmp       L3716
L3717:
    inc       %rsi
L3716:
    jmp       L3710
L3718:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	[%rbp + cc_lex.readoctal.p]
    mov       %rcx,	[%rbp + cc_lex.readoctal.pstart]
    mov       %rdx,	[%rbp + cc_lex.readoctal.p]
    mov       %r8,	%rax
    mov       %r9,	10
    call      cc_lex.readrealnumber
    jmp       L3709
L3719:
    inc       %r14
    cmp       %r14,	2
    jle       L3721
    lea       %rcx,	[%rip+L8910]
    call      cc_lex.lxerror
L3721:
    jmp       L3710
L3722:
    mov       %rax,	[%rbp + cc_lex.readoctal.usigned]
    test      %rax,	%rax
    jz        L3724
    lea       %rcx,	[%rip+L8911]
    call      cc_lex.lxerror
L3724:
    mov       %rax,	1
    mov       [%rbp + cc_lex.readoctal.usigned],	%rax
    jmp       L3710
L3713:
    lea       %rax,	[%rip+cc_lex.alphamap]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L3726
#cc_lex.readoctal.doalpha:
    mov       %rcx,	[%rbp + cc_lex.readoctal.pstart]
    call      cc_lex.readalphanumeric
    jmp       L3709
L3726:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L3711
L3711:
    mov       %rax,	[%rbp + cc_lex.readoctal.pstart]
    sub       %rax,	[%rip+cc_lex.lxstart]
    mov       %rcx,	%rax
    call      cc_lex.setnumberoffset
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	[%rbp + cc_lex.readoctal.pstart]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
    cmp       %rsi,	22
    jg        L3730
    cmp       %rsi,	22
    jnz       L3729
    mov       %rcx,	[%rbp + cc_lex.readoctal.p]
    lea       %rdx,	[%rip+L8912]
    mov       %r8,	22
    call      mlib.cmpstringn
    mov       %r12,	%rax
    cmp       %rax,	0
    jle       L3729
L3730:
    lea       %rcx,	[%rip+L8913]
    call      cc_lex.lxerror
L3729:
    mov       [%rbp + cc_lex.readoctal.av_1],	%rsi
    mov       %rax,	[%rbp + cc_lex.readoctal.av_1]
    cmp       %rax,	0
    jle       L3733
L3731:
    mov       %rax,	%rdi
    shl       %rax,	3
    mov       %r10,	[%rbp + cc_lex.readoctal.p]
    inc       qword ptr[%rbp + cc_lex.readoctal.p]
    movzx     %r10,	byte ptr[%r10]
    add       %rax,	%r10
    sub       %rax,	48
    mov       %rdi,	%rax
    dec       qword ptr[%rbp + cc_lex.readoctal.av_1]
    jnz       L3731
L3733:
    mov       %al,	59
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    mov       %al,	3
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    cmp       %rdi,	2147483647
    jb        L3735
    mov       %al,	4
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
L3735:
    mov       %rax,	%rdi
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10],	%rax
    call      cc_lex.checknumbersuffix
L3709:
#---------------
    add       %rsp,	64
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.readdecimal
cc_lex.readdecimal:
#?>>
    .set cc_lex.readdecimal.pstart, 64
    .set cc_lex.readdecimal.p, -8
    .set cc_lex.readdecimal.av_1, -16
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       [%rbp+64],	%rcx
#---------------
    xor       %rdi,	%rdi
    xor       %eax,	%eax
    mov       %r14b,	%al
    mov       %r13b,	%al
    dec       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    mov       [%rbp + cc_lex.readdecimal.p],	%rax
L3737:
L3738:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    lea       %r10,	[%rip+cc_lex.digitmap]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jnz       L3737
    jmp       L3741
L3740:
    inc       qword ptr[%rbp + cc_lex.readdecimal.p]
L3741:
    mov       %rax,	[%rbp + cc_lex.readdecimal.p]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	48
    jz        L3740
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	[%rbp + cc_lex.readdecimal.p]
    mov       %rsi,	%rax
L3743:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    mov       %rbx,	%rax
    sub       %rax,	46
    cmp       %rax,	72
    jae       L3746
    lea       %r10,	[%rip+L3745]
    jmp       [%r10 + %rax*8]
    .data
L3745:
    .quad     L3747
    .quad     L3746
    .quad     L3746
    .quad     L3746
    .quad     L3746
    .quad     L3746
    .quad     L3746
    .quad     L3746
    .quad     L3746
    .quad     L3746
    .quad     L3746
    .quad     L3746
    .quad     L3746
    .quad     L3746
    .quad     L3746
    .quad     L3746
    .quad     L3746
    .quad     L3746
    .quad     L3746
    .quad     L3746
    .quad     L3746
    .quad     L3746
    .quad     L3746
    .quad     L3747
    .quad     L3746
    .quad     L3746
    .quad     L3746
    .quad     L3746
    .quad     L3746
    .quad     L3746
    .quad     L3748
    .quad     L3746
    .quad     L3746
    .quad     L3746
    .quad     L3746
    .quad     L3746
    .quad     L3746
    .quad     L3746
    .quad     L3746
    .quad     L3751
    .quad     L3746
    .quad     L3746
    .quad     L3746
    .quad     L3746
    .quad     L3746
    .quad     L3746
    .quad     L3746
    .quad     L3746
    .quad     L3746
    .quad     L3746
    .quad     L3746
    .quad     L3746
    .quad     L3746
    .quad     L3746
    .quad     L3746
    .quad     L3747
    .quad     L3746
    .quad     L3746
    .quad     L3746
    .quad     L3746
    .quad     L3746
    .quad     L3746
    .quad     L3748
    .quad     L3746
    .quad     L3746
    .quad     L3746
    .quad     L3746
    .quad     L3746
    .quad     L3746
    .quad     L3746
    .quad     L3746
    .quad     L3751
    .text
L3747:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	[%rbp + cc_lex.readdecimal.p]
    mov       %rcx,	[%rbp + cc_lex.readdecimal.pstart]
    mov       %rdx,	[%rbp + cc_lex.readdecimal.p]
    mov       %r8,	%rax
    mov       %r9,	10
    call      cc_lex.readrealnumber
    jmp       L3736
L3748:
    inc       %r13b
    movzx     %rax,	%r13b
    cmp       %rax,	2
    jle       L3750
    lea       %rcx,	[%rip+L8914]
    call      cc_lex.lxerror
L3750:
    jmp       L3743
L3751:
    test      %r14b,	%r14b
    jz        L3753
    lea       %rcx,	[%rip+L8915]
    call      cc_lex.lxerror
L3753:
    mov       %r14b,	1
    jmp       L3743
L3746:
    lea       %rax,	[%rip+cc_lex.alphamap]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L3755
    mov       %rcx,	[%rbp + cc_lex.readdecimal.pstart]
    call      cc_lex.readalphanumeric
    jmp       L3736
L3755:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L3744
L3744:
    mov       %rax,	[%rbp + cc_lex.readdecimal.pstart]
    sub       %rax,	[%rip+cc_lex.lxstart]
    mov       %rcx,	%rax
    call      cc_lex.setnumberoffset
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	[%rbp + cc_lex.readdecimal.pstart]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
    cmp       %rsi,	20
    jg        L3758
    cmp       %rsi,	20
    jnz       L3757
    mov       %rcx,	[%rbp + cc_lex.readdecimal.p]
    lea       %rdx,	[%rip+L8916]
    mov       %r8,	20
    call      mlib.cmpstringn
    mov       %r12,	%rax
    cmp       %rax,	0
    jle       L3757
L3758:
    lea       %rcx,	[%rip+L8917]
    call      cc_lex.lxerror
L3757:
    mov       [%rbp + cc_lex.readdecimal.av_1],	%rsi
    mov       %rax,	[%rbp + cc_lex.readdecimal.av_1]
    cmp       %rax,	0
    jle       L3761
L3759:
    mov       %rax,	%rdi
    shl       %rax,	1
    lea       %rax,	[%rax + %rax*4]
    mov       %r10,	[%rbp + cc_lex.readdecimal.p]
    inc       qword ptr[%rbp + cc_lex.readdecimal.p]
    movzx     %r10,	byte ptr[%r10]
    sub       %r10,	48
    add       %rax,	%r10
    mov       %rdi,	%rax
    dec       qword ptr[%rbp + cc_lex.readdecimal.av_1]
    jnz       L3759
L3761:
    mov       %al,	59
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    movzx     %rax,	%r13b
    test      %rax,	%rax
    jz        L3763
    cmp       %rax,	1
    jz        L3764
    cmp       %rax,	2
    jz        L3765
    jmp       L3766
L3763:
    cmp       %rdi,	2147483647
    jl        L3768
    mov       %al,	4
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    jmp       L3767
L3768:
    mov       %al,	3
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
L3767:
    test      %r14b,	%r14b
    jz        L3770
    mov       %rax,	%rdi
    mov       %r10,	4294967295
    cmp       %rax,	%r10
    jb        L3772
    mov       %al,	9
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    jmp       L3771
L3772:
    mov       %al,	8
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
L3771:
    jmp       L3769
L3770:
    cmp       %rdi,	2147483647
    jb        L3774
    mov       %al,	4
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
L3774:
L3769:
    jmp       L3762
L3764:
    mov       %al,	[%rip+pc_decls.flong64]
    test      %al,	%al
    jnz       L3765
L3776:
    test      %r14b,	%r14b
    jz        L3778
    mov       %rax,	%rdi
    mov       %r10,	4294967295
    cmp       %rax,	%r10
    jb        L3780
    mov       %al,	9
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    jmp       L3779
L3780:
    mov       %al,	8
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
L3779:
    jmp       L3777
L3778:
    cmp       %rdi,	2147483647
    jb        L3782
    mov       %al,	4
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    jmp       L3781
L3782:
    mov       %al,	3
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
L3781:
L3777:
    jmp       L3762
L3765:
    test      %r14b,	%r14b
    jz        L3784
    mov       %al,	9
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    jmp       L3783
L3784:
    mov       %al,	4
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
L3783:
L3766:
L3762:
    mov       %rax,	%rdi
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10],	%rax
L3736:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.checknumbersuffix
cc_lex.checknumbersuffix:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	16
#---------------
L3786:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    mov       %dil,	%al
    sub       %rax,	76
    cmp       %rax,	42
    jae       L3789
    lea       %r10,	[%rip+L3788]
    jmp       [%r10 + %rax*8]
    .data
L3788:
    .quad     L3790
    .quad     L3789
    .quad     L3789
    .quad     L3789
    .quad     L3789
    .quad     L3789
    .quad     L3789
    .quad     L3789
    .quad     L3789
    .quad     L3790
    .quad     L3789
    .quad     L3789
    .quad     L3789
    .quad     L3789
    .quad     L3789
    .quad     L3789
    .quad     L3789
    .quad     L3789
    .quad     L3789
    .quad     L3789
    .quad     L3789
    .quad     L3789
    .quad     L3789
    .quad     L3789
    .quad     L3789
    .quad     L3789
    .quad     L3789
    .quad     L3789
    .quad     L3789
    .quad     L3789
    .quad     L3789
    .quad     L3789
    .quad     L3790
    .quad     L3789
    .quad     L3789
    .quad     L3789
    .quad     L3789
    .quad     L3789
    .quad     L3789
    .quad     L3789
    .quad     L3789
    .quad     L3790
    .text
L3790:
    jmp       L3786
L3789:
    movzx     %rax,	%dil
    lea       %r10,	[%rip+cc_lex.alphamap]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L3792
L3792:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L3787
L3787:
    mov       %rax,	3
L3785:
#---------------
    add       %rsp,	16
    pop       %rdi
    ret       
# End 
# Proc cc_lex.stacksourcefile
cc_lex.stacksourcefile:
#?>>
    .set cc_lex.stacksourcefile.info, -24
    .set cc_lex.stacksourcefile.fullpath, -528
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	568
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      cc_lex.getsourcefile
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L3795
    call      msys.m$print_startcon
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    mov       %rcx,	%rbx
    call      strlen
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8918]
    call      cc_lex.lxerror
L3795:
    mov       %rax,	[%rip+cc_lex.lx_stackindex]
    cmp       %rax,	20
    jl        L3797
    lea       %rcx,	[%rip+L8919]
    call      cc_lex.lxerror
L3797:
    inc       qword ptr[%rip+cc_lex.lx_stackindex]
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.stacksourcefile.fullpath],	%al
    mov       %rax,	[%rip+cc_lex.lx_stackindex]
    cmp       %rax,	1
    jle       L3799
    lea       %rax,	[%rip+cc_lex.headerpathlist]
    mov       %r10,	[%rip+cc_lex.lx_stackindex]
    mov       %rax,	[%rax + %r10*8-16]
    lea       %rcx,	[%rbp + cc_lex.stacksourcefile.fullpath]
    mov       %rdx,	%rax
    call      strcpy
L3799:
    lea       %rax,	[%rip+cc_lex.headerpath]
    mov       %al,	[%rax]
    test      %al,	%al
    jz        L3801
    lea       %rcx,	[%rip+cc_lex.headerpath]
    call      mlib.pcm_copyheapstring
    lea       %rcx,	[%rbp + cc_lex.stacksourcefile.fullpath]
    mov       %rdx,	%rax
    call      strcat
L3801:
    lea       %rcx,	[%rbp + cc_lex.stacksourcefile.fullpath]
    call      mlib.pcm_copyheapstring
    lea       %r10,	[%rip+cc_lex.headerpathlist]
    mov       %r11,	[%rip+cc_lex.lx_stackindex]
    mov       [%r10 + %r11*8-8],	%rax
    mov       %rax,	[%rip+cc_lex.lxstart]
    mov       [%rbp + cc_lex.stacksourcefile.info],	%rax
    mov       %rax,	[%rip+cc_lex.lxsptr]
    mov       [%rbp + cc_lex.stacksourcefile.info+8],	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %eax,	[%rax+16]
    mov       [%rbp + cc_lex.stacksourcefile.info+16],	%eax
    call      cc_lex.getfileno
    mov       [%rbp + cc_lex.stacksourcefile.info+20],	%eax
    lea       %rax,	[%rbp + cc_lex.stacksourcefile.info]
    lea       %r10,	[%rip+cc_lex.lx_stack]
    mov       %r11,	[%rip+cc_lex.lx_stackindex]
    shl       %r11,	3
    lea       %r11,	[%r11 + %r11*2]
    mov       %r8,	[%rax]
    mov       [%r10 + %r11-24],	%r8
    mov       %r8,	[%rax+8]
    mov       [%r10 + %r11-16],	%r8
    mov       %r8,	[%rax+16]
    mov       [%r10 + %r11-8],	%r8
    lea       %rax,	[%rip+cc_decls.sourcefiletext]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    mov       [%rip+cc_lex.lxsptr],	%rax
    mov       [%rip+cc_lex.lxstart],	%rax
    mov       %rcx,	%rdi
    call      cc_lex.setfileno
    mov       %eax,	1
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+16],	%eax
#---------------
    add       %rsp,	568
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.unstacksourcefile
cc_lex.unstacksourcefile:
#?>>
    .set cc_lex.unstacksourcefile.info, -24
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	56
#---------------
    lea       %rax,	[%rip+cc_lex.headerpathlist]
    mov       %r10,	[%rip+cc_lex.lx_stackindex]
    mov       %rdi,	[%rax + %r10*8-8]
    mov       %rcx,	%rdi
    call      strlen
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mlib.pcm_free
    mov       %rax,	[%rip+cc_lex.lx_stackindex]
    dec       qword ptr[%rip+cc_lex.lx_stackindex]
    lea       %r10,	[%rip+cc_lex.lx_stack]
    mov       %r11,	%rax
    shl       %r11,	3
    lea       %r11,	[%r11 + %r11*2]
    lea       %r10,	[%r10 + %r11-24]
    lea       %rax,	[%rbp + cc_lex.unstacksourcefile.info]
    mov       %r11,	[%r10]
    mov       [%rax],	%r11
    mov       %r11,	[%r10+8]
    mov       [%rax+8],	%r11
    mov       %r11,	[%r10+16]
    mov       [%rax+16],	%r11
    mov       %rax,	[%rbp + cc_lex.unstacksourcefile.info]
    mov       [%rip+cc_lex.lxstart],	%rax
    mov       %rax,	[%rbp + cc_lex.unstacksourcefile.info+8]
    mov       [%rip+cc_lex.lxsptr],	%rax
    mov       %eax,	[%rbp + cc_lex.unstacksourcefile.info+16]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+16],	%eax
    movsxd    %rax,	dword ptr[%rbp + cc_lex.unstacksourcefile.info+20]
    mov       %rcx,	%rax
    call      cc_lex.setfileno
#---------------
    add       %rsp,	56
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc cc_lex.getsourcefile
cc_lex.getsourcefile:
#?>>
    .set cc_lex.getsourcefile.syshdr, 48
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_lex.headerpath]
    mov       [%r10],	%al
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    mov       %rdx,	%rsi
    call      strcpy
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    call      mlib.convlcstring
    mov       %rbx,	1
    mov       %rax,	[%rip+cc_decls.nsourcefiles]
    cmp       %rax,	1
    jl        L3806
L3804:
    lea       %rax,	[%rip+cc_decls.sourcefilenames]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8]
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    mov       %rdx,	%rax
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L3808
    mov       %rax,	%rbx
    jmp       L3803
L3808:
    inc       %rbx
    cmp       %rbx,	[%rip+cc_decls.nsourcefiles]
    jle       L3804
L3806:
    mov       %al,	[%rip+cc_cli.dointheaders]
    test      %al,	%al
    jz        L3810
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    call      cc_headers.findheader
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L3812
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    mov       %rdx,	%rdi
    call      cc_support.loadbuiltin
    jmp       L3803
L3812:
L3810:
    mov       %rcx,	%rsi
    lea       %rdx,	[%rip+L8920]
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L3814
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    lea       %rdx,	[%rip+L8921]
    call      cc_support.loadbuiltin
    jmp       L3803
L3814:
    mov       %rcx,	%rsi
    call      mlib.extractpath
    lea       %rcx,	[%rip+cc_lex.headerpath]
    mov       %rdx,	%rax
    call      strcpy
    lea       %rax,	[%rip+cc_lex.headerpath]
    mov       %al,	[%rax]
    test      %al,	%al
    jz        L3816
    lea       %rax,	[%rip+cc_lex.headerpath]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	47
    jz        L3819
    lea       %rax,	[%rip+cc_lex.headerpath]
    movzx     %rax,	byte ptr[%rax+1]
    cmp       %rax,	58
    jnz       L3818
    lea       %rax,	[%rip+cc_lex.headerpath]
    movzx     %rax,	byte ptr[%rax+2]
    cmp       %rax,	47
    jnz       L3818
L3819:
    mov       %rcx,	%rsi
    call      mlib.checkfile
    test      %rax,	%rax
    jz        L3821
    mov       %rcx,	%rsi
    mov       %rdx,	%rsi
    call      cc_support.loadsourcefile
    jmp       L3803
L3821:
    xor       %eax,	%eax
    jmp       L3803
L3818:
L3816:
    mov       %rbx,	[%rip+cc_lex.lx_stackindex]
    cmp       %rbx,	1
    jl        L3824
L3822:
    lea       %rax,	[%rip+cc_lex.headerpathlist]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8-8]
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    mov       %rdx,	%rax
    call      strcpy
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    mov       %rdx,	%rsi
    call      strcat
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    call      mlib.checkfile
    test      %rax,	%rax
    jz        L3826
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    mov       %rdx,	%rsi
    call      cc_support.loadsourcefile
    jmp       L3803
L3826:
    dec       %rbx
    cmp       %rbx,	1
    jge       L3822
L3824:
    mov       %rbx,	1
    mov       %rax,	[%rip+cc_decls.nsearchdirs]
    cmp       %rax,	1
    jl        L3829
L3827:
    lea       %rax,	[%rip+cc_decls.searchdirs]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8-8]
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    mov       %rdx,	%rax
    call      strcpy
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    mov       %rdx,	%rsi
    call      strcat
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    call      mlib.checkfile
    test      %rax,	%rax
    jz        L3831
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    call      mlib.extractpath
    lea       %rcx,	[%rip+cc_lex.headerpath]
    mov       %rdx,	%rax
    call      strcpy
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    mov       %rdx,	%rsi
    call      cc_support.loadsourcefile
    jmp       L3803
L3831:
    inc       %rbx
    cmp       %rbx,	[%rip+cc_decls.nsearchdirs]
    jle       L3827
L3829:
    xor       %eax,	%eax
L3803:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.lex
cc_lex.lex:
#?>>
#?]]
    sub       %rsp,	40
#---------------
#cc_lex.lex.reenter:
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %r10,	[%rip+cc_decls.lx]
    mov       %r11,	[%rax]
    mov       [%r10],	%r11
    mov       %r11,	[%rax+8]
    mov       [%r10+8],	%r11
    mov       %r11,	[%rax+16]
    mov       [%r10+16],	%r11
    mov       %r11,	[%rax+24]
    mov       [%r10+24],	%r11
    call      cc_lex.lexm
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jnz       L3835
    mov       %rax,	[%rip+cc_lex.lx_stackindex]
    test      %rax,	%rax
    jnz       L3835
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       %rax,	[%rax]
    lea       %r10,	[%rip+cc_decls.lx]
    movsxd    %r10,	dword ptr[%r10+24]
    xor       %r11d,	%r11d
    mov       [%rax + %r10],	%r11b
L3835:
L3836:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L3838
    cmp       %rax,	56
    jz        L3839
    jmp       L3840
L3838:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    mov       %al,	[%rax+107]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	68
    jnz       L3842
    mov       %al,	67
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L3842:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    mov       %ax,	[%rax+100]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    jmp       L3832
L3839:
    call      cc_lex.lexm
    jmp       L3836
L3840:
    jmp       L3832
L3832:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_lex.shownumberstr
cc_lex.shownumberstr:
#?>>
    .set cc_lex.shownumberstr.$T1, -8
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rcx,	%rbx
    call      cc_lex.getfilenox
    test      %rax,	%rax
    jz        L3845
    mov       %rcx,	%rbx
    call      cc_lex.getfilenox
    lea       %r10,	[%rip+cc_decls.sourcefiletext]
    mov       %r10,	[%r10 + %rax*8]
    mov       [%rbp + cc_lex.shownumberstr.$T1],	%r10
    mov       %rcx,	%rbx
    call      cc_lex.getnumberoffsetx
    mov       %r10,	[%rbp + cc_lex.shownumberstr.$T1]
    lea       %r10,	[%r10 + %rax]
    mov       %rdi,	%r10
    jmp       L3844
L3845:
    movsx     %rax,	word ptr[%rbx+28]
    lea       %r10,	[%rip+cc_lex.pastedtokenlist]
    mov       %r10,	[%r10 + %rax*8-8]
    mov       %rdi,	%r10
L3844:
    movsxd    %rax,	dword ptr[%rbx+24]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    mov       %r8,	%rsi
    call      cc_lex.printstrn
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.addnamestr
cc_lex.addnamestr:
#?>>
    .set cc_lex.addnamestr.oldlx, -32
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	64
    mov       %rbx,	%rcx
#---------------
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %r10,	[%rbp + cc_lex.addnamestr.oldlx]
    mov       %r11,	[%rax]
    mov       [%r10],	%r11
    mov       %r11,	[%rax+8]
    mov       [%r10+8],	%r11
    mov       %r11,	[%rax+16]
    mov       [%r10+16],	%r11
    mov       %r11,	[%rax+24]
    mov       [%r10+24],	%r11
    mov       %rcx,	%rbx
    call      strlen
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+24]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      cc_lex.gethashvalue
    mov       [%rip+cc_lex.lxhashvalue],	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+24]
    inc       %rax
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       [%rip+cc_lex.lxsvalue],	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+24]
    inc       %rax
    mov       %rcx,	[%rip+cc_lex.lxsvalue]
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      memcpy
    call      cc_lex.lookup
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rdi,	[%rax]
    lea       %rax,	[%rbp + cc_lex.addnamestr.oldlx]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       %r11,	[%rax]
    mov       [%r10],	%r11
    mov       %r11,	[%rax+8]
    mov       [%r10+8],	%r11
    mov       %r11,	[%rax+16]
    mov       [%r10+16],	%r11
    mov       %r11,	[%rax+24]
    mov       [%r10+24],	%r11
    mov       %rax,	%rdi
L3846:
#---------------
    add       %rsp,	64
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.lxreadstring
cc_lex.lxreadstring:
#?>>
    .set cc_lex.lxreadstring.termchar, 72
    .set cc_lex.lxreadstring.fwide, 80
    .set cc_lex.lxreadstring.str, -2048
    .set cc_lex.lxreadstring.useheap, -2056
    .set cc_lex.lxreadstring.av_1, -2064
    .set cc_lex.lxreadstring.av_2, -2072
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	2104
    mov       [%rbp+72],	%rcx
    mov       [%rbp+80],	%rdx
#---------------
    mov       %rax,	[%rbp + cc_lex.lxreadstring.termchar]
    cmp       %rax,	34
    jnz       L3849
    mov       %rax,	[%rbp + cc_lex.lxreadstring.fwide]
    test      %rax,	%rax
    jz        L3851
    mov       %rax,	64
    jmp       L3850
L3851:
    mov       %rax,	63
L3850:
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3848
L3849:
    mov       %al,	61
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L3848:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10],	%rax
    mov       %rax,	[%rip+cc_lex.lx_stackindex]
    test      %rax,	%rax
    jnz       L3853
    mov       %rax,	[%rbp + cc_lex.lxreadstring.fwide]
    test      %rax,	%rax
    jnz       L3853
    mov       %rdi,	[%rip+cc_lex.lxsptr]
    mov       %rbx,	%rdi
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.lxreadstring.useheap],	%rax
    jmp       L3852
L3853:
    lea       %rax,	[%rbp + cc_lex.lxreadstring.str]
    mov       %rdi,	%rax
    mov       %rbx,	%rdi
    mov       %rax,	1
    mov       [%rbp + cc_lex.lxreadstring.useheap],	%rax
L3852:
    xor       %r15,	%r15
L3854:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    mov       %r13,	%rax
    cmp       %rax,	92
    jz        L3857
    cmp       %rax,	34
    jz        L3858
    cmp       %rax,	39
    jz        L3858
    test      %rax,	%rax
    jz        L3859
    jmp       L3860
L3857:
    mov       %rax,	[%rip+cc_lex.isincludefile]
    test      %rax,	%rax
    jz        L3862
    mov       %r13,	47
    jmp       L3863
L3862:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    mov       %r13,	%rax
#cc_lex.lxreadstring.reenter:
    lea       %rax,	[%r13-10]
    cmp       %rax,	111
    jae       L3867
    lea       %r10,	[%rip+L3866]
    jmp       [%r10 + %rax*8]
    .data
L3866:
    .quad     L3897
    .quad     L3867
    .quad     L3867
    .quad     L3894
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3891
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3893
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3884
    .quad     L3884
    .quad     L3884
    .quad     L3884
    .quad     L3884
    .quad     L3884
    .quad     L3884
    .quad     L3884
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3892
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3868
    .quad     L3869
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3870
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3871
    .quad     L3867
    .quad     L3867
    .quad     L3867
    .quad     L3872
    .quad     L3867
    .quad     L3873
    .quad     L3867
    .quad     L3874
    .quad     L3867
    .quad     L3875
    .text
L3868:
    mov       %r13,	7
    jmp       L3865
L3869:
    mov       %r13,	8
    jmp       L3865
L3870:
    mov       %r13,	12
    jmp       L3865
L3871:
    mov       %r13,	10
    jmp       L3865
L3872:
    mov       %r13,	13
    jmp       L3865
L3873:
    mov       %r13,	9
    jmp       L3865
L3874:
    mov       %r13,	11
    jmp       L3865
L3875:
    xor       %r13,	%r13
L3876:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    mov       %r14,	%rax
    sub       %rax,	48
    cmp       %rax,	55
    jae       L3880
    lea       %r10,	[%rip+L3879]
    jmp       [%r10 + %rax*8]
    .data
L3879:
    .quad     L3883
    .quad     L3883
    .quad     L3883
    .quad     L3883
    .quad     L3883
    .quad     L3883
    .quad     L3883
    .quad     L3883
    .quad     L3883
    .quad     L3883
    .quad     L3880
    .quad     L3880
    .quad     L3880
    .quad     L3880
    .quad     L3880
    .quad     L3880
    .quad     L3880
    .quad     L3881
    .quad     L3881
    .quad     L3881
    .quad     L3881
    .quad     L3881
    .quad     L3881
    .quad     L3880
    .quad     L3880
    .quad     L3880
    .quad     L3880
    .quad     L3880
    .quad     L3880
    .quad     L3880
    .quad     L3880
    .quad     L3880
    .quad     L3880
    .quad     L3880
    .quad     L3880
    .quad     L3880
    .quad     L3880
    .quad     L3880
    .quad     L3880
    .quad     L3880
    .quad     L3880
    .quad     L3880
    .quad     L3880
    .quad     L3880
    .quad     L3880
    .quad     L3880
    .quad     L3880
    .quad     L3880
    .quad     L3880
    .quad     L3882
    .quad     L3882
    .quad     L3882
    .quad     L3882
    .quad     L3882
    .quad     L3882
    .text
L3881:
    mov       %rax,	%r13
    shl       %rax,	4
    add       %rax,	%r14
    sub       %rax,	65
    add       %rax,	10
    mov       %r13,	%rax
    jmp       L3878
L3882:
    mov       %rax,	%r13
    shl       %rax,	4
    add       %rax,	%r14
    sub       %rax,	97
    add       %rax,	10
    mov       %r13,	%rax
    jmp       L3878
L3883:
    mov       %rax,	%r13
    shl       %rax,	4
    add       %rax,	%r14
    sub       %rax,	48
    mov       %r13,	%rax
    jmp       L3878
L3880:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L3877
L3878:
    jmp       L3876
L3877:
    jmp       L3865
L3884:
    mov       %rax,	48
    sub       %r13,	%rax
    mov       %rax,	2
    mov       [%rbp + cc_lex.lxreadstring.av_1],	%rax
L3885:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    mov       %r14,	%rax
    cmp       %rax,	48
    jz        L3889
    cmp       %rax,	49
    jz        L3889
    cmp       %rax,	50
    jz        L3889
    cmp       %rax,	51
    jz        L3889
    cmp       %rax,	52
    jz        L3889
    cmp       %rax,	53
    jz        L3889
    cmp       %rax,	54
    jz        L3889
    cmp       %rax,	55
    jnz       L3890
L3889:
    mov       %rax,	%r13
    shl       %rax,	3
    add       %rax,	%r14
    sub       %rax,	48
    mov       %r13,	%rax
    jmp       L3888
L3890:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L3887
L3888:
    dec       qword ptr[%rbp + cc_lex.lxreadstring.av_1]
    jnz       L3885
L3887:
    jmp       L3865
L3891:
    mov       %r13,	34
    jmp       L3865
L3892:
    mov       %r13,	92
    jmp       L3865
L3893:
    mov       %r13,	39
    jmp       L3865
L3894:
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %rax,	[%rax+16]
    inc       dword ptr[%rax]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	10
    jnz       L3896
    inc       qword ptr[%rip+cc_lex.lxsptr]
L3896:
    jmp       L3854
L3897:
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %rax,	[%rax+16]
    inc       dword ptr[%rax]
    jmp       L3854
L3867:
L3865:
    jmp       L3856
L3858:
    cmp       %r13,	[%rbp + cc_lex.lxreadstring.termchar]
    jz        L3855
L3899:
    jmp       L3856
L3859:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8922]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %eax,	[%rax+16]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8923]
    call      cc_lex.lxerror
L3860:
L3856:
#cc_lex.lxreadstring.normalchar:
L3863:
    mov       %rax,	[%rbp + cc_lex.lxreadstring.useheap]
    test      %rax,	%rax
    jnz       L3901
    mov       %rax,	%rdi
    inc       %rdi
    mov       %r10b,	%r13b
    mov       [%rax],	%r10b
    jmp       L3900
L3901:
    inc       %r15
    cmp       %r15,	2048
    jge       L3902
    mov       %rax,	%rdi
    inc       %rdi
    mov       %r10b,	%r13b
    mov       [%rax],	%r10b
    jmp       L3900
L3902:
    lea       %rcx,	[%rip+L8924]
    call      cc_lex.lxerror
L3900:
    jmp       L3854
L3855:
    xor       %eax,	%eax
    mov       [%rdi],	%al
    mov       %rax,	[%rbp + cc_lex.lxreadstring.fwide]
    test      %rax,	%rax
    jz        L3904
    mov       %rax,	%r15
    shl       %rax,	1
    add       %rax,	2
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       %rsi,	%rax
    mov       %r12,	%rax
    mov       [%rbp + cc_lex.lxreadstring.av_2],	%r15
    mov       %rax,	[%rbp + cc_lex.lxreadstring.av_2]
    cmp       %rax,	0
    jle       L3907
L3905:
    mov       %rax,	%rbx
    inc       %rbx
    movzx     %rax,	byte ptr[%rax]
    mov       %r10,	%rsi
    add       %rsi,	2
    mov       [%r10],	%ax
    dec       qword ptr[%rbp + cc_lex.lxreadstring.av_2]
    jnz       L3905
L3907:
    xor       %eax,	%eax
    mov       [%rsi],	%ax
    mov       %rax,	%r12
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10],	%rax
    jmp       L3903
L3904:
    mov       %rax,	[%rbp + cc_lex.lxreadstring.useheap]
    test      %rax,	%rax
    jz        L3908
    mov       %eax,	%r15d
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
    lea       %rax,	[%r15+1]
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10],	%rax
    lea       %rax,	[%r15+1]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       %r10,	[%r10]
    mov       %rcx,	%r10
    lea       %rdx,	[%rbp + cc_lex.lxreadstring.str]
    mov       %r8,	%rax
    call      memcpy
    jmp       L3903
L3908:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    mov       %r10,	%rdi
    sub       %r10,	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       [%rax+24],	%r10d
L3903:
#---------------
    add       %rsp,	2104
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.addlisttoken
cc_lex.addlisttoken:
#?>>
#?]]
#---------------
    mov       %rax,	[%rcx]
    test      %rax,	%rax
    jnz       L3911
    mov       %rax,	%r8
    mov       [%rdx],	%rax
    mov       [%rcx],	%rax
    jmp       L3910
L3911:
    mov       %rax,	[%rdx]
    mov       %r10,	%r8
    mov       [%rax+8],	%r10
L3910:
    xor       %eax,	%eax
    mov       [%r8+8],	%rax
    mov       [%rdx],	%r8
#---------------
    ret       
# End 
# Proc cc_lex.addlisttoken_copy
cc_lex.addlisttoken_copy:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    call      cc_lex.alloctoken
    mov       %rdi,	%rax
    mov       %rax,	%r12
    mov       %r10,	[%rax]
    mov       [%rdi],	%r10
    mov       %r10,	[%rax+8]
    mov       [%rdi+8],	%r10
    mov       %r10,	[%rax+16]
    mov       [%rdi+16],	%r10
    mov       %r10,	[%rax+24]
    mov       [%rdi+24],	%r10
    xor       %eax,	%eax
    mov       [%rdi+8],	%rax
    mov       %rax,	[%rbx]
    test      %rax,	%rax
    jnz       L3914
    mov       %rax,	%rdi
    mov       [%rsi],	%rax
    mov       [%rbx],	%rax
    jmp       L3913
L3914:
    mov       %rax,	[%rsi]
    mov       %r10,	%rdi
    mov       [%rax+8],	%r10
L3913:
    xor       %eax,	%eax
    mov       [%rdi+8],	%rax
    mov       [%rsi],	%rdi
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.addlist_nextlx
cc_lex.addlist_nextlx:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    call      cc_lex.alloctoken
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %r10,	[%rax]
    mov       [%rdi],	%r10
    mov       %r10,	[%rax+8]
    mov       [%rdi+8],	%r10
    mov       %r10,	[%rax+16]
    mov       [%rdi+16],	%r10
    mov       %r10,	[%rax+24]
    mov       [%rdi+24],	%r10
    xor       %eax,	%eax
    mov       [%rdi+8],	%rax
    mov       %rax,	[%rbx]
    test      %rax,	%rax
    jnz       L3917
    mov       %rax,	%rdi
    mov       [%rsi],	%rax
    mov       [%rbx],	%rax
    jmp       L3916
L3917:
    mov       %rax,	[%rsi]
    mov       %r10,	%rdi
    mov       [%rax+8],	%r10
L3916:
    xor       %eax,	%eax
    mov       [%rdi+8],	%rax
    mov       [%rsi],	%rdi
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.addlisttoken_seq
cc_lex.addlisttoken_seq:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    jmp       L3920
L3919:
    call      cc_lex.alloctoken
    mov       %rdi,	%rax
    mov       %rax,	%r12
    mov       %r10,	[%rax]
    mov       [%rdi],	%r10
    mov       %r10,	[%rax+8]
    mov       [%rdi+8],	%r10
    mov       %r10,	[%rax+16]
    mov       [%rdi+16],	%r10
    mov       %r10,	[%rax+24]
    mov       [%rdi+24],	%r10
    mov       %rax,	[%rbx]
    test      %rax,	%rax
    jnz       L3923
    mov       %rax,	%rdi
    mov       [%rsi],	%rax
    mov       [%rbx],	%rax
    jmp       L3922
L3923:
    mov       %rax,	[%rsi]
    mov       %r10,	%rdi
    mov       [%rax+8],	%r10
L3922:
    xor       %eax,	%eax
    mov       [%rdi+8],	%rax
    mov       [%rsi],	%rdi
    mov       %r12,	[%r12+8]
L3920:
    test      %r12,	%r12
    jnz       L3919
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.addlistmparam
cc_lex.addlistmparam:
#?>>
#?]]
#---------------
    mov       %rax,	[%rcx]
    test      %rax,	%rax
    jnz       L3926
    mov       %rax,	%r8
    mov       [%rdx],	%rax
    mov       [%rcx],	%rax
    jmp       L3925
L3926:
    mov       %rax,	[%rdx]
    mov       %r10,	%r8
    mov       [%rax+8],	%r10
L3925:
    mov       [%rdx],	%r8
#---------------
    ret       
# End 
# Proc cc_lex.dodefine
cc_lex.dodefine:
#?>>
    .set cc_lex.dodefine.stlist, -8
    .set cc_lex.dodefine.stlistx, -16
    .set cc_lex.dodefine.tklist, -24
    .set cc_lex.dodefine.tklistx, -32
    .set cc_lex.dodefine.ntokens, -40
    .set cc_lex.dodefine.paramno, -48
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	80
#---------------
    call      cc_lex.lexreadtoken
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L3929
    lea       %rcx,	[%rip+L8925]
    call      cc_lex.lxerror
L3929:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rsi,	[%rax]
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %eax,	[%rax+16]
    mov       [%rsi+92],	%eax
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %al,	[%rax+20]
    mov       [%rsi+113],	%al
    mov       %al,	[%rsi+107]
    mov       [%rsi+88],	%al
    mov       %al,	67
    mov       [%rsi+107],	%al
    mov       %al,	1
    mov       [%rsi+109],	%al
    xor       %r14,	%r14
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	40
    jnz       L3931
    inc       qword ptr[%rip+cc_lex.lxsptr]
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.dodefine.stlistx],	%rax
    mov       [%rbp + cc_lex.dodefine.stlist],	%rax
    lea       %rax,	[%rsi+108]
    or        byte ptr[%rax],	4
    call      cc_lex.lexreadtoken
L3932:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L3935
    cmp       %rax,	14
    jz        L3936
    cmp       %rax,	21
    jz        L3937
    jmp       L3938
L3935:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %r12,	[%rax]
    mov       %rdi,	[%rbp + cc_lex.dodefine.stlist]
    jmp       L3940
L3939:
    mov       %rax,	[%rdi]
    cmp       %rax,	%r12
    jnz       L3943
    lea       %rcx,	[%rip+L8926]
    call      cc_lex.lxerror
L3943:
    mov       %rdi,	[%rdi+8]
L3940:
    test      %rdi,	%rdi
    jnz       L3939
    mov       %rcx,	16
    call      mlib.pcm_alloc
    mov       %rbx,	%rax
    mov       [%rbx],	%r12
    xor       %eax,	%eax
    mov       [%rbx+8],	%rax
    lea       %rcx,	[%rbp + cc_lex.dodefine.stlist]
    lea       %rdx,	[%rbp + cc_lex.dodefine.stlistx]
    mov       %r8,	%rbx
    call      cc_lex.addlistmparam
    inc       %r14
    call      cc_lex.lexreadtoken
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jnz       L3945
    call      cc_lex.lexreadtoken
L3945:
    jmp       L3934
L3936:
    jmp       L3933
L3937:
    lea       %rcx,	[%rip+L8927]
    call      cc_lex.addnamestr
    mov       %r12,	%rax
    lea       %rax,	[%rsi+108]
    or        byte ptr[%rax],	2
    call      cc_lex.lexreadtoken
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	14
    jz        L3947
    lea       %rcx,	[%rip+L8928]
    call      cc_lex.lxerror
L3947:
    mov       %rcx,	16
    call      mlib.pcm_alloc
    mov       %rbx,	%rax
    mov       [%rbx],	%r12
    xor       %eax,	%eax
    mov       [%rbx+8],	%rax
    lea       %rcx,	[%rbp + cc_lex.dodefine.stlist]
    lea       %rdx,	[%rbp + cc_lex.dodefine.stlistx]
    mov       %r8,	%rbx
    call      cc_lex.addlistmparam
    inc       %r14
    jmp       L3933
L3938:
    lea       %rcx,	[%rip+L8929]
    call      cc_lex.lxerror
L3934:
    jmp       L3932
L3933:
    mov       %rax,	[%rbp + cc_lex.dodefine.stlist]
    mov       [%rsi+80],	%rax
L3931:
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.dodefine.tklistx],	%rax
    mov       [%rbp + cc_lex.dodefine.tklist],	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.dodefine.ntokens],	%rax
L3948:
    call      cc_lex.lexreadtoken
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	56
    jz        L3951
    cmp       %rax,	57
    jz        L3951
    cmp       %rax,	67
    jz        L3952
    jmp       L3953
L3951:
    jmp       L3949
L3952:
    mov       %rdi,	[%rsi+80]
    mov       %rax,	1
    mov       [%rbp + cc_lex.dodefine.paramno],	%rax
    jmp       L3955
L3954:
    mov       %rax,	[%rdi]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       %r10,	[%r10]
    cmp       %rax,	%r10
    jnz       L3958
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %rax,	[%rax+23]
    mov       %r10b,	2
    or        [%rax],	%r10b
    mov       %ax,	[%rbp + cc_lex.dodefine.paramno]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+28],	%ax
    jmp       L3956
L3958:
    mov       %rdi,	[%rdi+8]
    inc       qword ptr[%rbp + cc_lex.dodefine.paramno]
L3955:
    test      %rdi,	%rdi
    jnz       L3954
L3956:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    cmp       %rax,	%rsi
    jnz       L3960
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %rax,	[%rax+23]
    mov       %r10b,	1
    or        [%rax],	%r10b
L3960:
L3953:
L3950:
    inc       qword ptr[%rbp + cc_lex.dodefine.ntokens]
    call      cc_lex.alloctoken
    mov       %r13,	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %r10,	[%rax]
    mov       [%r13],	%r10
    mov       %r10,	[%rax+8]
    mov       [%r13+8],	%r10
    mov       %r10,	[%rax+16]
    mov       [%r13+16],	%r10
    mov       %r10,	[%rax+24]
    mov       [%r13+24],	%r10
    lea       %rcx,	[%rbp + cc_lex.dodefine.tklist]
    lea       %rdx,	[%rbp + cc_lex.dodefine.tklistx]
    mov       %r8,	%r13
    call      cc_lex.addlisttoken
    jmp       L3948
L3949:
    mov       %rax,	[%rbp + cc_lex.dodefine.tklist]
    mov       [%rsi+72],	%rax
    mov       [%rsi+111],	%r14b
#---------------
    add       %rsp,	80
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.readalphanumeric
cc_lex.readalphanumeric:
#?>>
#?]]
#---------------
L3962:
L3963:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    lea       %r10,	[%rip+cc_lex.alphamap]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jnz       L3962
    dec       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	%rcx
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10],	%rax
    mov       %al,	58
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	%rcx
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
#---------------
    ret       
# End 
# Proc cc_lex.inmacrostack
cc_lex.inmacrostack:
#?>>
#?]]
#---------------
    jmp       L3967
L3966:
    mov       %rax,	[%rdx]
    cmp       %rax,	%rcx
    jnz       L3970
    mov       %rax,	1
    jmp       L3965
L3970:
    mov       %rdx,	[%rdx+8]
L3967:
    test      %rdx,	%rdx
    jnz       L3966
    xor       %eax,	%eax
L3965:
#---------------
    ret       
# End 
# Proc cc_lex.showtokens
cc_lex.showtokens:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    call      msys.m$print_startcon
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L8930]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L3973
L3972:
    mov       %rcx,	%rbx
    call      cc_lex.showtoken
    mov       %rbx,	[%rbx+8]
L3973:
    test      %rbx,	%rbx
    jnz       L3972
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8931]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.lexa
cc_lex.lexa:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	[%rdi]
    cmp       %rax,	[%rip+cc_lex.normaltk]
    jnz       L3977
    call      cc_lex.lexreadtoken
    jmp       L3975
L3977:
    mov       %rax,	[%rdi]
    test      %rax,	%rax
    jnz       L3979
    mov       %al,	57
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3975
L3979:
    mov       %rax,	[%rdi]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       %r11,	[%rax]
    mov       [%r10],	%r11
    mov       %r11,	[%rax+8]
    mov       [%r10+8],	%r11
    mov       %r11,	[%rax+16]
    mov       [%r10+16],	%r11
    mov       %r11,	[%rax+24]
    mov       [%r10+24],	%r11
    mov       %rax,	[%rdi]
    mov       %rax,	[%rax+8]
    mov       [%rdi],	%rax
L3975:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lex.lexm
cc_lex.lexm:
#?>>
    .set cc_lex.lexm.newlineno, -8
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
#---------------
L3981:
    mov       %rax,	[%rip+cc_lex.tkptr]
    test      %rax,	%rax
    jz        L3984
    mov       %rax,	[%rip+cc_lex.tkptr]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       %r11,	[%rax]
    mov       [%r10],	%r11
    mov       %r11,	[%rax+8]
    mov       [%r10+8],	%r11
    mov       %r11,	[%rax+16]
    mov       [%r10+16],	%r11
    mov       %r11,	[%rax+24]
    mov       [%r10+24],	%r11
    mov       %rax,	[%rip+cc_lex.tkptr]
    mov       %rax,	[%rax+8]
    mov       [%rip+cc_lex.tkptr],	%rax
    mov       %rax,	[%rip+cc_lex.tkptr]
    test      %rax,	%rax
    jnz       L3986
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jnz       L3988
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	1
    jnz       L3988
    call      cc_lex.peeklb
    test      %rax,	%rax
    jz        L3988
    mov       %rcx,	[%rip+cc_decls.sfileno]
    call      cc_lex.setfileno
    mov       %eax,	[%rip+cc_decls.slineno]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+16],	%eax
    xor       %eax,	%eax
    mov       [%rip+cc_lex.lexm.doreset],	%rax
    jmp       L3989
L3988:
    mov       %rax,	1
    mov       [%rip+cc_lex.lexm.doreset],	%rax
L3986:
    jmp       L3980
L3984:
    mov       %rax,	[%rip+cc_lex.lexm.doreset]
    test      %rax,	%rax
    jz        L3991
    mov       %rcx,	[%rip+cc_decls.sfileno]
    call      cc_lex.setfileno
    mov       %eax,	[%rip+cc_decls.slineno]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+16],	%eax
    xor       %eax,	%eax
    mov       [%rip+cc_lex.lexm.doreset],	%rax
L3991:
    mov       %rax,	[%rip+cc_lex.firstsymbol]
    test      %rax,	%rax
    jz        L3993
    xor       %eax,	%eax
    mov       [%rip+cc_lex.firstsymbol],	%rax
    call      cc_lex.dospecialinclude
L3993:
    call      cc_lex.lexreadtoken
#cc_lex.lexm.test1:
L3989:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	4
    jz        L3995
    cmp       %rax,	67
    jz        L3996
    jmp       L3997
L3995:
    call      cc_lex.dolexdirective
    test      %rax,	%rax
    jnz       L3980
L3999:
    jmp       L3981
L3996:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rdi,	[%rax]
    movzx     %rax,	byte ptr[%rdi+107]
    cmp       %rax,	69
    jnz       L4002
L4001:
    call      cc_lex.getfileno
    mov       [%rip+cc_decls.sfileno],	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %eax,	[%rax+16]
    mov       [%rip+cc_decls.slineno],	%rax
    movsx     %rax,	word ptr[%rdi+100]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+cc_decls.nextlx]
    mov       %r8,	[%rip+cc_decls.slineno]
    call      cc_lex.expandpredefmacro
    mov       %rax,	1
    mov       [%rip+cc_lex.lexm.doreset],	%rax
    jmp       L3980
L4002:
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	1
    jnz       L4005
    mov       %rax,	[%rip+cc_lex.noexpand]
    test      %rax,	%rax
    jz        L4004
L4005:
    jmp       L3980
L4004:
L4000:
    jmp       L3994
L3997:
    jmp       L3980
L3994:
    call      cc_lex.getfileno
    mov       [%rip+cc_decls.sfileno],	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %eax,	[%rax+16]
    mov       [%rip+cc_decls.slineno],	%rax
    movzx     %rax,	byte ptr[%rdi+108]
    shr       %eax,	2
    and       %eax,	1
    test      %rax,	%rax
    jz        L4007
    call      cc_lex.peeklb
    test      %rax,	%rax
    jz        L3980
L4009:
    sub       %rsp,	8
    lea       %rax,	[%rbp + cc_lex.lexm.newlineno]
    push      %rax
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    lea       %r8,	[%rip+cc_lex.normaltk]
    mov       %r9,	1
    sub       %rsp,	32
    call      cc_lex.expandfnmacro
    add       %rsp,	48
    mov       [%rip+cc_lex.tkptr],	%rax
    mov       %rax,	[%rbp + cc_lex.lexm.newlineno]
    mov       [%rip+cc_decls.slineno],	%rax
    jmp       L4006
L4007:
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    lea       %r8,	[%rip+cc_lex.normaltk]
    mov       %r9,	1
    call      cc_lex.expandobjmacro
    mov       [%rip+cc_lex.tkptr],	%rax
L4006:
    mov       %rax,	[%rip+cc_lex.tkptr]
    test      %rax,	%rax
    jnz       L4011
    mov       %rax,	1
    mov       [%rip+cc_lex.lexm.doreset],	%rax
L4011:
    jmp       L3981
L3980:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc cc_lex.peeklb
cc_lex.peeklb:
#?>>
#?]]
#---------------
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	40
    jz        L4015
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	32
    jnz       L4014
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax+1]
    cmp       %rax,	40
    jnz       L4014
L4015:
    mov       %rax,	1
    jmp       L4012
L4014:
    xor       %eax,	%eax
L4012:
#---------------
    ret       
# End 
# Proc cc_lex.peektk
cc_lex.peektk:
#?>>
#?]]
#---------------
    mov       %rax,	[%rcx+8]
    mov       %rcx,	%rax
    test      %rcx,	%rcx
    jnz       L4018
    xor       %eax,	%eax
    jmp       L4016
L4018:
    movzx     %rax,	byte ptr[%rcx+21]
    cmp       %rax,	13
    jnz       L4020
    mov       %rax,	1
    jmp       L4016
L4020:
    xor       %eax,	%eax
L4016:
#---------------
    ret       
# End 
# Proc cc_lex.expandobjmacro
cc_lex.expandobjmacro:
#?>>
    .set cc_lex.expandobjmacro.m, 64
    .set cc_lex.expandobjmacro.macrostack, 72
    .set cc_lex.expandobjmacro.tksource, 80
    .set cc_lex.expandobjmacro.frombaselevel, 88
    .set cc_lex.expandobjmacro.newmacro, -32
    .set cc_lex.expandobjmacro.expanded, -40
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	80
    mov       [%rbp+64],	%rcx
    mov       [%rbp+72],	%rdx
#---------------
    mov       %rax,	[%rbp + cc_lex.expandobjmacro.m]
    mov       %rax,	[%rax+72]
    mov       %rdi,	%rax
    mov       %rbx,	%rax
    xor       %eax,	%eax
    mov       %r13,	%rax
    mov       %r12,	%rax
    jmp       L4023
L4022:
    movzx     %rax,	byte ptr[%rbx+21]
    cmp       %rax,	67
    jnz       L4026
    mov       %r14,	[%rbx]
    movzx     %rax,	byte ptr[%r14+109]
    cmp       %rax,	1
    jz        L4029
    movzx     %rax,	byte ptr[%r14+107]
    cmp       %rax,	69
    jnz       L4028
L4029:
    mov       %r12,	1
    jmp       L4024
L4028:
    jmp       L4025
L4026:
    movzx     %rax,	byte ptr[%rbx+21]
    cmp       %rax,	7
    jnz       L4030
    mov       %rax,	1
    mov       %r13,	%rax
    mov       %r12,	%rax
    jmp       L4024
L4030:
L4025:
    mov       %rbx,	[%rbx+8]
L4023:
    test      %rbx,	%rbx
    jnz       L4022
L4024:
    test      %r12,	%r12
    jnz       L4032
    mov       %rax,	%rdi
    jmp       L4021
L4032:
    mov       %rax,	[%rbp + cc_lex.expandobjmacro.m]
    mov       [%rbp + cc_lex.expandobjmacro.newmacro],	%rax
    mov       %rax,	[%rbp + cc_lex.expandobjmacro.macrostack]
    mov       [%rbp + cc_lex.expandobjmacro.newmacro+8],	%rax
    test      %r13,	%r13
    jz        L4034
    sub       %rsp,	8
    push      0
    mov       %rcx,	[%rbp + cc_lex.expandobjmacro.m]
    xor       %edx,	%edx
    xor       %r8d,	%r8d
    xor       %r9d,	%r9d
    sub       %rsp,	32
    call      cc_lex.substituteargs
    add       %rsp,	48
    mov       %rsi,	%rax
    jmp       L4033
L4034:
    mov       %rax,	[%rbp + cc_lex.expandobjmacro.m]
    mov       %rsi,	[%rax+72]
L4033:
    mov       %rcx,	%rsi
    lea       %rdx,	[%rbp + cc_lex.expandobjmacro.newmacro]
    lea       %r8,	[%rbp + cc_lex.expandobjmacro.expanded]
    call      cc_lex.scantokenseq
    mov       %rdi,	%rax
    mov       %rax,	%rdi
L4021:
#---------------
    add       %rsp,	80
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.expandfnmacro
cc_lex.expandfnmacro:
#?>>
    .set cc_lex.expandfnmacro.frombaselevel, 88
    .set cc_lex.expandfnmacro.endlineno, 96
    .set cc_lex.expandfnmacro.args, -1600
    .set cc_lex.expandfnmacro.expargs, -3200
    .set cc_lex.expandfnmacro.newmacro, -3232
    .set cc_lex.expandfnmacro.expanded, -3240
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	3280
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
    mov       [%rbp+88],	%r9
#---------------
    mov       %rcx,	%r12
    lea       %rdx,	[%rbp + cc_lex.expandfnmacro.args]
    mov       %r8,	%r14
    call      cc_lex.readmacrocall
    mov       %rbx,	%rax
    mov       %rax,	[%rbp + cc_lex.expandfnmacro.frombaselevel]
    test      %rax,	%rax
    jz        L4037
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %eax,	[%rax+16]
    mov       %r10,	[%rbp + cc_lex.expandfnmacro.endlineno]
    mov       [%r10],	%rax
L4037:
    mov       %rsi,	1
    cmp       %rbx,	1
    jl        L4040
L4038:
    xor       %eax,	%eax
    mov       [%rbp + %rsi*8 + cc_lex.expandfnmacro.expargs-8],	%rax
    inc       %rsi
    cmp       %rsi,	%rbx
    jle       L4038
L4040:
    sub       %rsp,	8
    mov       %rax,	%r13
    push      %rax
    mov       %rcx,	%r12
    lea       %rdx,	[%rbp + cc_lex.expandfnmacro.args]
    lea       %r8,	[%rbp + cc_lex.expandfnmacro.expargs]
    mov       %r9,	%rbx
    sub       %rsp,	32
    call      cc_lex.substituteargs
    add       %rsp,	48
    mov       %rdi,	%rax
    mov       [%rbp + cc_lex.expandfnmacro.newmacro],	%r12
    mov       [%rbp + cc_lex.expandfnmacro.newmacro+8],	%r13
    mov       %rcx,	%rdi
    lea       %rdx,	[%rbp + cc_lex.expandfnmacro.newmacro]
    lea       %r8,	[%rbp + cc_lex.expandfnmacro.expanded]
    call      cc_lex.scantokenseq
    mov       %rdi,	%rax
    mov       %rax,	%rdi
L4035:
#---------------
    add       %rsp,	3280
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.scantokenseq
cc_lex.scantokenseq:
#?>>
    .set cc_lex.scantokenseq.tk, 64
    .set cc_lex.scantokenseq.expanded, 80
    .set cc_lex.scantokenseq.newtk, -8
    .set cc_lex.scantokenseq.newtkx, -16
    .set cc_lex.scantokenseq.dummy, -24
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	64
    mov       [%rbp+64],	%rcx
    mov       %r14,	%rdx
    mov       [%rbp+80],	%r8
#---------------
#cc_lex.scantokenseq.reenter:
L4042:
    xor       %eax,	%eax
    mov       %r10,	[%rbp + cc_lex.scantokenseq.expanded]
    mov       [%r10],	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.scantokenseq.newtkx],	%rax
    mov       [%rbp + cc_lex.scantokenseq.newtk],	%rax
    xor       %r12,	%r12
    mov       %rax,	1
    mov       %r13,	%rax
    mov       %rbx,	[%rbp + cc_lex.scantokenseq.tk]
    jmp       L4044
L4043:
    mov       %rax,	[%rbp + cc_lex.scantokenseq.tk]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jnz       L4048
L4047:
    mov       %rax,	[%rbp + cc_lex.scantokenseq.tk]
    mov       %rax,	[%rax]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	1
    jz        L4051
    mov       %rax,	[%rbp + cc_lex.scantokenseq.tk]
    mov       %rax,	[%rax]
    movzx     %rax,	byte ptr[%rax+107]
    cmp       %rax,	69
    jnz       L4050
L4051:
    xor       %r13,	%r13
    jmp       L4045
L4050:
L4048:
L4046:
    mov       %rax,	[%rbp + cc_lex.scantokenseq.tk]
    test      %rax,	%rax
    jz        L4045
L4053:
    mov       %rax,	[%rbp + cc_lex.scantokenseq.tk]
    mov       %rax,	[%rax+8]
    mov       [%rbp + cc_lex.scantokenseq.tk],	%rax
L4044:
    mov       %rax,	[%rbp + cc_lex.scantokenseq.tk]
    test      %rax,	%rax
    jnz       L4043
L4045:
    test      %r13,	%r13
    jz        L4055
    mov       %rax,	%rbx
    jmp       L4041
L4055:
    mov       [%rbp + cc_lex.scantokenseq.tk],	%rbx
    jmp       L4057
L4056:
    mov       %rax,	[%rbp + cc_lex.scantokenseq.tk]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jnz       L4061
L4060:
    mov       %rax,	[%rbp + cc_lex.scantokenseq.tk]
    mov       %rsi,	[%rax]
    movzx     %rax,	byte ptr[%rsi+109]
    cmp       %rax,	1
    jnz       L4063
    test      %r12,	%r12
    jnz       L4063
    mov       %rax,	[%rbp + cc_lex.scantokenseq.tk]
    movzx     %rax,	byte ptr[%rax+23]
    and       %rax,	4
    jnz       L4066
    mov       %rax,	[%rip+cc_lex.noexpand]
    test      %rax,	%rax
    jz        L4065
L4066:
    jmp       L4067
L4065:
    mov       %rcx,	%rsi
    mov       %rdx,	%r14
    call      cc_lex.inmacrostack
    test      %rax,	%rax
    jz        L4069
    lea       %rcx,	[%rbp + cc_lex.scantokenseq.newtk]
    lea       %rdx,	[%rbp + cc_lex.scantokenseq.newtkx]
    mov       %r8,	[%rbp + cc_lex.scantokenseq.tk]
    call      cc_lex.addlisttoken_copy
    mov       %rax,	[%rbp + cc_lex.scantokenseq.newtkx]
    lea       %rax,	[%rax+23]
    mov       %r10b,	4
    or        [%rax],	%r10b
    jmp       L4070
L4069:
    xor       %r13,	%r13
    movzx     %rax,	byte ptr[%rsi+108]
    shr       %eax,	2
    and       %eax,	1
    test      %rax,	%rax
    jz        L4072
    mov       %rcx,	[%rbp + cc_lex.scantokenseq.tk]
    call      cc_lex.peektk
    test      %rax,	%rax
    jz        L4067
L4074:
    lea       %rcx,	[%rbp + cc_lex.scantokenseq.tk]
    call      cc_lex.lexa
    sub       %rsp,	8
    lea       %rax,	[%rbp + cc_lex.scantokenseq.dummy]
    push      %rax
    mov       %rcx,	%rsi
    mov       %rdx,	%r14
    lea       %r8,	[%rbp + cc_lex.scantokenseq.tk]
    mov       %r9,	1
    sub       %rsp,	32
    call      cc_lex.expandfnmacro
    add       %rsp,	48
    mov       %rdi,	%rax
    lea       %rcx,	[%rbp + cc_lex.scantokenseq.newtk]
    lea       %rdx,	[%rbp + cc_lex.scantokenseq.newtkx]
    mov       %r8,	%rdi
    call      cc_lex.addlisttoken_seq
    mov       %rax,	1
    mov       %r10,	[%rbp + cc_lex.scantokenseq.expanded]
    mov       [%r10],	%rax
    jmp       L4057
L4072:
    mov       %rcx,	%rsi
    mov       %rdx,	%r14
    lea       %r8,	[%rbp + cc_lex.scantokenseq.tk]
    xor       %r9d,	%r9d
    call      cc_lex.expandobjmacro
    mov       %rdi,	%rax
    mov       %rax,	1
    mov       %r10,	[%rbp + cc_lex.scantokenseq.expanded]
    mov       [%r10],	%rax
    lea       %rcx,	[%rbp + cc_lex.scantokenseq.newtk]
    lea       %rdx,	[%rbp + cc_lex.scantokenseq.newtkx]
    mov       %r8,	%rdi
    call      cc_lex.addlisttoken_seq
L4071:
    jmp       L4062
L4063:
    movzx     %rax,	byte ptr[%rsi+107]
    cmp       %rax,	93
    jnz       L4075
    mov       %r12,	1
    jmp       L4067
L4075:
    movzx     %rax,	byte ptr[%rsi+107]
    cmp       %rax,	69
    jnz       L4076
    call      cc_lex.alloctokenz
    mov       %rdi,	%rax
    movsx     %rax,	word ptr[%rsi+100]
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    mov       %r8,	[%rip+cc_decls.slineno]
    call      cc_lex.expandpredefmacro
    lea       %rcx,	[%rbp + cc_lex.scantokenseq.newtk]
    lea       %rdx,	[%rbp + cc_lex.scantokenseq.newtkx]
    mov       %r8,	%rdi
    call      cc_lex.addlisttoken_copy
    jmp       L4077
L4076:
    xor       %r12,	%r12
    jmp       L4067
L4062:
    jmp       L4059
L4061:
#cc_lex.scantokenseq.simpletoken:
L4067:
    lea       %rcx,	[%rbp + cc_lex.scantokenseq.newtk]
    lea       %rdx,	[%rbp + cc_lex.scantokenseq.newtkx]
    mov       %r8,	[%rbp + cc_lex.scantokenseq.tk]
    call      cc_lex.addlisttoken_copy
L4059:
#cc_lex.scantokenseq.skip:
L4070:
    mov       %rax,	[%rbp + cc_lex.scantokenseq.tk]
    test      %rax,	%rax
    jz        L4058
L4079:
#cc_lex.scantokenseq.skip2:
L4077:
    mov       %rax,	[%rbp + cc_lex.scantokenseq.tk]
    mov       %rax,	[%rax+8]
    mov       [%rbp + cc_lex.scantokenseq.tk],	%rax
L4057:
    mov       %rax,	[%rbp + cc_lex.scantokenseq.tk]
    test      %rax,	%rax
    jnz       L4056
L4058:
    mov       %rax,	[%rbp + cc_lex.scantokenseq.expanded]
    mov       %rax,	[%rax]
    test      %rax,	%rax
    jz        L4081
    mov       %rax,	[%rbp + cc_lex.scantokenseq.newtk]
    mov       [%rbp + cc_lex.scantokenseq.tk],	%rax
    jmp       L4042
L4081:
    mov       %rax,	[%rbp + cc_lex.scantokenseq.newtk]
L4041:
#---------------
    add       %rsp,	64
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.readmacrocall
cc_lex.readmacrocall:
#?>>
    .set cc_lex.readmacrocall.args, 80
    .set cc_lex.readmacrocall.tksource, 88
    .set cc_lex.readmacrocall.tklist, -8
    .set cc_lex.readmacrocall.tklistx, -16
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	56
    mov       %r15,	%rcx
    mov       [%rbp+80],	%rdx
    mov       [%rbp+88],	%r8
#---------------
    mov       %rcx,	[%rbp + cc_lex.readmacrocall.tksource]
    call      cc_lex.lexa
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	13
    jz        L4084
    lea       %rcx,	[%rip+L8932]
    call      cc_lex.lxerror
L4084:
    movzx     %rax,	byte ptr[%r15+111]
    mov       %rdi,	%rax
    xor       %r12,	%r12
    mov       %rax,	%rdi
    test      %rax,	%rax
    jnz       L4086
    mov       %rcx,	[%rbp + cc_lex.readmacrocall.tksource]
    call      cc_lex.lexa
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	14
    jz        L4088
    lea       %rcx,	[%rip+L8933]
    call      cc_lex.lxerror
L4088:
    xor       %eax,	%eax
    jmp       L4082
L4086:
    mov       %rsi,	1
    mov       %rbx,	1
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.readmacrocall.tklistx],	%rax
    mov       [%rbp + cc_lex.readmacrocall.tklist],	%rax
    movzx     %rax,	byte ptr[%r15+108]
    shr       %eax,	1
    and       %eax,	1
    mov       %r13,	%rax
    xor       %r14,	%r14
L4089:
    cmp       %rsi,	%rdi
    jnz       L4092
    test      %r13,	%r13
    jz        L4092
    mov       %r14,	1
L4092:
    mov       %rcx,	[%rbp + cc_lex.readmacrocall.tksource]
    call      cc_lex.lexa
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jz        L4094
    cmp       %rax,	57
    jz        L4095
    cmp       %rax,	13
    jz        L4096
    cmp       %rax,	14
    jz        L4097
    jmp       L4098
L4094:
    cmp       %rbx,	1
    jnz       L4100
    test      %r14,	%r14
    jnz       L4100
    mov       %rax,	[%rbp + cc_lex.readmacrocall.tklist]
    test      %rax,	%rax
    jnz       L4102
    call      cc_lex.alloctokenz
    mov       [%rbp + cc_lex.readmacrocall.tklist],	%rax
    call      cc_lex.getfileno
    mov       %rcx,	[%rbp + cc_lex.readmacrocall.tklist]
    mov       %rdx,	%rax
    call      cc_lex.setfilenox
    mov       %al,	66
    mov       %r10,	[%rbp + cc_lex.readmacrocall.tklist]
    mov       [%r10+21],	%al
L4102:
    mov       %rax,	[%rbp + cc_lex.readmacrocall.tklist]
    mov       %r10,	[%rbp + cc_lex.readmacrocall.args]
    mov       %r11,	%rsi
    mov       [%r10 + %r11*8-8],	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.readmacrocall.tklistx],	%rax
    mov       [%rbp + cc_lex.readmacrocall.tklist],	%rax
    inc       %rsi
    jmp       L4099
L4100:
    jmp       L4103
L4099:
    jmp       L4093
L4095:
    lea       %rcx,	[%rip+L8934]
    call      cc_lex.lxerror
    jmp       L4093
L4096:
    inc       %rbx
    jmp       L4103
L4097:
    cmp       %rbx,	1
    jle       L4105
    dec       %rbx
    lea       %rcx,	[%rbp + cc_lex.readmacrocall.tklist]
    lea       %rdx,	[%rbp + cc_lex.readmacrocall.tklistx]
    call      cc_lex.addlist_nextlx
    jmp       L4104
L4105:
    mov       %rax,	[%rbp + cc_lex.readmacrocall.tklist]
    test      %rax,	%rax
    jnz       L4107
    call      cc_lex.alloctokenz
    mov       [%rbp + cc_lex.readmacrocall.tklist],	%rax
    call      cc_lex.getfileno
    mov       %rcx,	[%rbp + cc_lex.readmacrocall.tklist]
    mov       %rdx,	%rax
    call      cc_lex.setfilenox
    mov       %al,	66
    mov       %r10,	[%rbp + cc_lex.readmacrocall.tklist]
    mov       [%r10+21],	%al
L4107:
    mov       %rax,	[%rbp + cc_lex.readmacrocall.tklist]
    mov       %r10,	[%rbp + cc_lex.readmacrocall.args]
    mov       %r11,	%rsi
    mov       [%r10 + %r11*8-8],	%rax
    jmp       L4090
L4104:
    jmp       L4093
L4098:
#cc_lex.readmacrocall.addtoken:
L4103:
    lea       %rcx,	[%rbp + cc_lex.readmacrocall.tklist]
    lea       %rdx,	[%rbp + cc_lex.readmacrocall.tklistx]
    call      cc_lex.addlist_nextlx
L4093:
    jmp       L4089
L4090:
    cmp       %rsi,	%rdi
    jz        L4109
    lea       %rax,	[%rsi+1]
    cmp       %rax,	%rdi
    jnz       L4111
    test      %r13,	%r13
    jz        L4111
    xor       %eax,	%eax
    mov       %r10,	[%rbp + cc_lex.readmacrocall.args]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*8-8],	%rax
    jmp       L4110
L4111:
    lea       %rcx,	[%rip+L8935]
    call      cc_lex.lxerror
L4110:
L4109:
    mov       %rax,	%rdi
L4082:
#---------------
    add       %rsp,	56
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.substituteargs
cc_lex.substituteargs:
#?>>
    .set cc_lex.substituteargs.expargs, 80
    .set cc_lex.substituteargs.nargs, 88
    .set cc_lex.substituteargs.macrostack, 96
    .set cc_lex.substituteargs.newtk, -8
    .set cc_lex.substituteargs.newtkx, -16
    .set cc_lex.substituteargs.niltk, -24
    .set cc_lex.substituteargs.tkexp, -32
    .set cc_lex.substituteargs.tk, -64
    .set cc_lex.substituteargs.n, -72
    .set cc_lex.substituteargs.i, -80
    .set cc_lex.substituteargs.expanded, -88
    .set cc_lex.substituteargs.hhpoints, -2088
    .set cc_lex.substituteargs.nhashhash, -2096
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	2128
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       [%rbp+80],	%r8
    mov       [%rbp+88],	%r9
#---------------
    mov       %rdi,	[%r13+80]
    mov       %rax,	[%r13+72]
    mov       %rsi,	%rax
    mov       %rbx,	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.substituteargs.newtkx],	%rax
    mov       [%rbp + cc_lex.substituteargs.newtk],	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.substituteargs.nhashhash],	%rax
    xor       %r12,	%r12
    jmp       L4114
L4113:
    movzx     %rax,	byte ptr[%rbx+21]
    cmp       %rax,	5
    jz        L4117
    cmp       %rax,	7
    jz        L4118
    jmp       L4119
L4117:
    mov       %rax,	[%rbp + cc_lex.substituteargs.nargs]
    test      %rax,	%rax
    jz        L4121
    mov       %rbx,	[%rbx+8]
    test      %rbx,	%rbx
    jnz       L4123
    lea       %rcx,	[%rip+L8936]
    call      cc_lex.lxerror
L4123:
    movzx     %rax,	byte ptr[%rbx+23]
    and       %rax,	2
    jnz       L4125
    lea       %rcx,	[%rip+L8937]
    call      cc_lex.lxerror
L4125:
    movsx     %rax,	word ptr[%rbx+28]
    mov       [%rbp + cc_lex.substituteargs.n],	%rax
    mov       %rax,	[%rbp + cc_lex.substituteargs.n]
    mov       %rax,	[%r14 + %rax*8-8]
    mov       %rcx,	%rax
    lea       %rdx,	[%rbp + cc_lex.substituteargs.tk]
    call      cc_lex.stringify
    lea       %rcx,	[%rbp + cc_lex.substituteargs.newtk]
    lea       %rdx,	[%rbp + cc_lex.substituteargs.newtkx]
    lea       %r8,	[%rbp + cc_lex.substituteargs.tk]
    call      cc_lex.addlisttoken_copy
    jmp       L4120
L4121:
    lea       %rcx,	[%rbp + cc_lex.substituteargs.newtk]
    lea       %rdx,	[%rbp + cc_lex.substituteargs.newtkx]
    mov       %r8,	%rbx
    call      cc_lex.addlisttoken
    mov       %al,	6
    mov       %r10,	[%rbp + cc_lex.substituteargs.newtkx]
    mov       [%r10+21],	%al
L4120:
    jmp       L4116
L4118:
    cmp       %rbx,	%rsi
    jnz       L4127
    lea       %rcx,	[%rip+L8938]
    call      cc_lex.lxerror
L4127:
    mov       %rax,	[%rbp + cc_lex.substituteargs.nhashhash]
    cmp       %rax,	250
    jl        L4129
    lea       %rcx,	[%rip+L8939]
    call      cc_lex.lxerror
L4129:
    inc       qword ptr[%rbp + cc_lex.substituteargs.nhashhash]
    mov       %rax,	[%rbp + cc_lex.substituteargs.nhashhash]
    mov       %r10,	[%rbp + cc_lex.substituteargs.newtkx]
    mov       [%rbp + %rax*8 + cc_lex.substituteargs.hhpoints-8],	%r10
    jmp       L4116
L4119:
    movzx     %rax,	byte ptr[%rbx+21]
    cmp       %rax,	67
    jnz       L4131
    movzx     %rax,	byte ptr[%rbx+23]
    and       %rax,	2
    jz        L4131
    mov       %rax,	[%rbp + cc_lex.substituteargs.nargs]
    test      %rax,	%rax
    jz        L4131
    movsx     %rax,	word ptr[%rbx+28]
    mov       [%rbp + cc_lex.substituteargs.n],	%rax
    mov       %rax,	[%rbx+8]
    test      %rax,	%rax
    jz        L4135
    mov       %rax,	[%rbx+8]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	7
    jz        L4134
L4135:
    test      %r12,	%r12
    jz        L4133
    movzx     %rax,	byte ptr[%r12+21]
    cmp       %rax,	7
    jnz       L4133
L4134:
    mov       %rax,	[%rbp + cc_lex.substituteargs.n]
    mov       %rax,	[%r14 + %rax*8-8]
    lea       %rcx,	[%rbp + cc_lex.substituteargs.newtk]
    lea       %rdx,	[%rbp + cc_lex.substituteargs.newtkx]
    mov       %r8,	%rax
    call      cc_lex.addlisttoken_seq
    jmp       L4132
L4133:
    mov       %rax,	[%rbp + cc_lex.substituteargs.expargs]
    mov       %r10,	[%rbp + cc_lex.substituteargs.n]
    mov       %rax,	[%rax + %r10*8-8]
    mov       [%rbp + cc_lex.substituteargs.tkexp],	%rax
    mov       %rax,	[%rbp + cc_lex.substituteargs.tkexp]
    test      %rax,	%rax
    jnz       L4137
    mov       %rax,	[%rbp + cc_lex.substituteargs.n]
    mov       %rax,	[%r14 + %rax*8-8]
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + cc_lex.substituteargs.macrostack]
    lea       %r8,	[%rbp + cc_lex.substituteargs.expanded]
    call      cc_lex.scantokenseq
    mov       %r10,	[%rbp + cc_lex.substituteargs.expargs]
    mov       %r11,	[%rbp + cc_lex.substituteargs.n]
    mov       [%r10 + %r11*8-8],	%rax
    mov       [%rbp + cc_lex.substituteargs.tkexp],	%rax
L4137:
    lea       %rcx,	[%rbp + cc_lex.substituteargs.newtk]
    lea       %rdx,	[%rbp + cc_lex.substituteargs.newtkx]
    mov       %r8,	[%rbp + cc_lex.substituteargs.tkexp]
    call      cc_lex.addlisttoken_seq
L4132:
    jmp       L4130
L4131:
#cc_lex.substituteargs.doother:
    lea       %rcx,	[%rbp + cc_lex.substituteargs.newtk]
    lea       %rdx,	[%rbp + cc_lex.substituteargs.newtkx]
    mov       %r8,	%rbx
    call      cc_lex.addlisttoken_copy
L4130:
L4116:
    mov       %r12,	%rbx
    mov       %rbx,	[%rbx+8]
L4114:
    test      %rbx,	%rbx
    jnz       L4113
    mov       %rax,	[%rbp + cc_lex.substituteargs.nhashhash]
    test      %rax,	%rax
    jz        L4140
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.substituteargs.niltk],	%rax
    mov       %rax,	1
    mov       [%rbp + cc_lex.substituteargs.i],	%rax
    mov       %rax,	[%rbp + cc_lex.substituteargs.nhashhash]
    cmp       %rax,	1
    jl        L4143
L4141:
    mov       %rax,	[%rbp + cc_lex.substituteargs.i]
    cmp       %rax,	[%rbp + cc_lex.substituteargs.nhashhash]
    jge       L4145
    mov       %rax,	[%rbp + cc_lex.substituteargs.i]
    lea       %r10,	[%rbp + %rax*8 + cc_lex.substituteargs.hhpoints]
    mov       %rax,	%r10
    jmp       L4144
L4145:
    lea       %rax,	[%rbp + cc_lex.substituteargs.niltk]
L4144:
    mov       %r10,	[%rbp + cc_lex.substituteargs.i]
    mov       %r10,	[%rbp + %r10*8 + cc_lex.substituteargs.hhpoints-8]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      cc_lex.pastetokens
    mov       %rax,	[%rbp + cc_lex.substituteargs.i]
    inc       %rax
    mov       [%rbp + cc_lex.substituteargs.i],	%rax
    cmp       %rax,	[%rbp + cc_lex.substituteargs.nhashhash]
    jle       L4141
L4143:
L4140:
    mov       %rax,	[%rbp + cc_lex.substituteargs.newtk]
L4112:
#---------------
    add       %rsp,	2128
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.strtoken
cc_lex.strtoken:
#?>>
    .set cc_lex.strtoken.l, -32
    .set cc_lex.strtoken.$T1, -40
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	80
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    mov       %rax,	%rsi
    lea       %r10,	[%rbp + cc_lex.strtoken.l]
    mov       %r11,	[%rax]
    mov       [%r10],	%r11
    mov       %r11,	[%rax+8]
    mov       [%r10+8],	%r11
    mov       %r11,	[%rax+16]
    mov       [%r10+16],	%r11
    mov       %r11,	[%rax+24]
    mov       [%r10+24],	%r11
    movzx     %rax,	byte ptr[%rbp + cc_lex.strtoken.l+21]
    cmp       %rax,	67
    jz        L4148
    cmp       %rax,	59
    jz        L4149
    cmp       %rax,	60
    jz        L4149
    cmp       %rax,	58
    jz        L4150
    cmp       %rax,	63
    jz        L4151
    cmp       %rax,	64
    jz        L4151
    cmp       %rax,	61
    jz        L4152
    cmp       %rax,	56
    jz        L4153
    cmp       %rax,	57
    jz        L4154
    cmp       %rax,	71
    jz        L4155
    cmp       %rax,	87
    jz        L4155
    cmp       %rax,	86
    jz        L4155
    cmp       %rax,	89
    jz        L4155
    jmp       L4156
L4148:
#cc_lex.strtoken.doname:
L4157:
    mov       %rax,	[%rbp + cc_lex.strtoken.l]
    movzx     %rax,	byte ptr[%rax+106]
    mov       [%r12],	%rax
    mov       %rax,	[%rbp + cc_lex.strtoken.l]
    mov       %rax,	[%rax]
    jmp       L4146
L4149:
    movsxd    %rax,	dword ptr[%rbp + cc_lex.strtoken.l+24]
    mov       [%r12],	%rax
    lea       %rcx,	[%rbp + cc_lex.strtoken.l]
    call      cc_lex.getfilenox
    test      %rax,	%rax
    jz        L4159
    lea       %rcx,	[%rbp + cc_lex.strtoken.l]
    call      cc_lex.getfilenox
    lea       %r10,	[%rip+cc_decls.sourcefiletext]
    mov       %r10,	[%r10 + %rax*8]
    mov       [%rbp + cc_lex.strtoken.$T1],	%r10
    lea       %rcx,	[%rbp + cc_lex.strtoken.l]
    call      cc_lex.getnumberoffsetx
    mov       %r10,	[%rbp + cc_lex.strtoken.$T1]
    lea       %r10,	[%r10 + %rax]
    mov       %rax,	%r10
    jmp       L4146
L4159:
    movsx     %rax,	word ptr[%rbp + cc_lex.strtoken.l+28]
    lea       %r10,	[%rip+cc_lex.pastedtokenlist]
    mov       %r10,	[%r10 + %rax*8-8]
    mov       %rax,	%r10
    jmp       L4146
L4158:
    jmp       L4147
L4150:
    movsxd    %rax,	dword ptr[%rbp + cc_lex.strtoken.l+24]
    mov       [%r12],	%rax
    mov       %rax,	[%rbp + cc_lex.strtoken.l]
    jmp       L4146
L4151:
    movsxd    %rax,	dword ptr[%rbp + cc_lex.strtoken.l+24]
    mov       %r10,	[%rbp + cc_lex.strtoken.l]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    mov       %r8,	%r12
    mov       %r9,	34
    call      cc_lex.strstring
    mov       %rbx,	%rax
    mov       %rax,	%rbx
    jmp       L4146
L4152:
    movsxd    %rax,	dword ptr[%rbp + cc_lex.strtoken.l+24]
    mov       %r10,	[%rbp + cc_lex.strtoken.l]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    mov       %r8,	%r12
    mov       %r9,	39
    call      cc_lex.strstring
    mov       %rbx,	%rax
    mov       %rax,	%rbx
    jmp       L4146
L4153:
    mov       %rax,	[%rip+cc_lex.dowhitespace]
    test      %rax,	%rax
    jz        L4161
    movsxd    %rax,	dword ptr[%rbp + cc_lex.strtoken.l+24]
    inc       %rax
    mov       [%r12],	%rax
    mov       %rax,	[%r12]
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       %rbx,	%rax
    mov       %al,	10
    mov       [%rbx],	%al
    movsxd    %rax,	dword ptr[%rbp + cc_lex.strtoken.l+24]
    mov       %r10,	[%rbp + cc_lex.strtoken.l]
    lea       %r11,	[%rbx+1]
    mov       %rcx,	%r11
    mov       %rdx,	%r10
    mov       %r8,	%rax
    call      memcpy
    jmp       L4160
L4161:
    mov       %rax,	1
    mov       [%r12],	%rax
    lea       %rax,	[%rip+L8940]
    jmp       L4146
L4160:
    mov       %rax,	%rbx
    jmp       L4146
L4154:
    xor       %eax,	%eax
    mov       [%r12],	%rax
    lea       %rax,	[%rip+L8941]
    jmp       L4146
L4155:
    jmp       L4157
L4156:
    movzx     %rax,	byte ptr[%rbp + cc_lex.strtoken.l+21]
    lea       %r10,	[%rip+cc_tables.shortsymbolnames]
    mov       %r10,	[%r10 + %rax*8-8]
    mov       %rdi,	%r10
    mov       %rcx,	%rdi
    call      strlen
    mov       [%r12],	%rax
    test      %rax,	%rax
    jz        L4163
    movzx     %rax,	byte ptr[%rdi]
    cmp       %rax,	107
    jz        L4165
    mov       %rax,	%rdi
    jmp       L4146
L4165:
    movzx     %rax,	byte ptr[%rbp + cc_lex.strtoken.l+21]
    lea       %r10,	[%rip+cc_tables.symbolnames]
    mov       %r10,	[%r10 + %rax*8-8]
    lea       %r10,	[%r10+1]
    mov       %rcx,	%r10
    call      strlen
    mov       [%r12],	%rax
    movzx     %rax,	byte ptr[%rbp + cc_lex.strtoken.l+21]
    lea       %r10,	[%rip+cc_tables.symbolnames]
    mov       %r10,	[%r10 + %rax*8-8]
    lea       %r10,	[%r10+1]
    mov       %rax,	%r10
    jmp       L4146
L4164:
    jmp       L4162
L4163:
    lea       %rax,	[%rip+L8941]
    jmp       L4146
L4162:
L4147:
    lea       %rax,	[%rip+L8941]
L4146:
#---------------
    add       %rsp,	80
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.strstring
cc_lex.strstring:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
    mov       %r14,	%r9
#---------------
    mov       %rax,	%r12
    shl       %rax,	1
    add       %rax,	4
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       %rbx,	%rax
    mov       %rdi,	%rax
    test      %r14,	%r14
    jz        L4168
    mov       [%rbx],	%r14b
    inc       %rbx
L4168:
    mov       %rcx,	%rsi
    mov       %rdx,	%rbx
    mov       %r8,	%r12
    call      cc_lib.convertstringc
    mov       %rcx,	%rdi
    call      strlen
    mov       [%r13],	%rax
    test      %r14,	%r14
    jz        L4170
    mov       %rax,	[%r13]
    mov       %r10b,	%r14b
    mov       [%rdi + %rax],	%r10b
    mov       %rax,	%r13
    inc       qword ptr[%rax]
L4170:
    mov       %rax,	%rdi
L4166:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.emittoken
cc_lex.emittoken:
#?>>
    .set cc_lex.emittoken.length, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    movzx     %rax,	byte ptr[%rbx+21]
    cmp       %rax,	56
    jnz       L4173
    mov       %rax,	[%rip+cc_lex.lasttoken]
    cmp       %rax,	56
    jz        L4171
L4173:
    mov       %rcx,	%rbx
    lea       %rdx,	[%rbp + cc_lex.emittoken.length]
    call      cc_lex.strtoken
    mov       %rdi,	%rax
    test      %r12,	%r12
    jnz       L4176
    movzx     %rax,	byte ptr[%rbx+21]
    mov       %rcx,	[%rip+cc_lex.lasttoken]
    mov       %rdx,	%rax
    call      cc_lex.needspace
    test      %rax,	%rax
    jz        L4175
L4176:
    mov       %rcx,	%rsi
    mov       %rdx,	32
    call      mlib.gs_char
L4175:
    mov       %rcx,	%rsi
    mov       %rdx,	%rdi
    mov       %r8,	[%rbp + cc_lex.emittoken.length]
    call      mlib.gs_strn
    movzx     %rax,	byte ptr[%rbx+21]
    mov       [%rip+cc_lex.lasttoken],	%rax
L4171:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.showtoken
cc_lex.showtoken:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	[%rip+cc_lex.showtoken.dest]
    call      mlib.gs_init
    mov       %rcx,	%rdi
    mov       %rdx,	[%rip+cc_lex.showtoken.dest]
    xor       %r8d,	%r8d
    call      cc_lex.emittoken
    call      msys.m$print_startcon
    mov       %rax,	[%rip+cc_lex.showtoken.dest]
    movsxd    %rax,	dword ptr[%rax+8]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8942]
    call      msys.m$print_i64
    call      msys.m$print_nogap
    mov       %rax,	[%rip+cc_lex.showtoken.dest]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8943]
    call      msys.m$print_str
    call      msys.m$print_end
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lex.stringify
cc_lex.stringify:
#?>>
    .set cc_lex.stringify.length, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    mov       %al,	63
    mov       [%r12+21],	%al
    xor       %eax,	%eax
    mov       [%r12+8],	%rax
    mov       %rax,	[%rsi+8]
    test      %rax,	%rax
    jnz       L4180
    mov       %rcx,	%rsi
    lea       %rdx,	[%rbp + cc_lex.stringify.length]
    call      cc_lex.strtoken
    mov       %rdi,	%rax
    mov       %eax,	[%rbp + cc_lex.stringify.length]
    mov       [%r12+24],	%eax
    mov       [%r12],	%rdi
    jmp       L4178
L4180:
    mov       %rcx,	[%rip+cc_lex.stringify.deststr]
    call      mlib.gs_init
    xor       %eax,	%eax
    mov       [%rip+cc_lex.lasttoken],	%rax
    xor       %rbx,	%rbx
    jmp       L4182
L4181:
    mov       %rcx,	%rsi
    mov       %rdx,	[%rip+cc_lex.stringify.deststr]
    mov       %r8,	%rbx
    call      cc_lex.emittoken
    mov       %rbx,	1
    mov       %rsi,	[%rsi+8]
L4182:
    test      %rsi,	%rsi
    jnz       L4181
    mov       %eax,	[%rbp + cc_lex.stringify.length]
    mov       [%r12+24],	%eax
    mov       %rax,	[%rip+cc_lex.stringify.deststr]
    mov       %rax,	[%rax]
    mov       [%r12],	%rax
    mov       %rax,	[%rip+cc_lex.stringify.deststr]
    mov       %eax,	[%rax+8]
    mov       [%r12+24],	%eax
L4178:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.pastetokens
cc_lex.pastetokens:
#?>>
    .set cc_lex.pastetokens.tk, 64
    .set cc_lex.pastetokens.tknext, 72
    .set cc_lex.pastetokens.length1, -8
    .set cc_lex.pastetokens.length2, -16
    .set cc_lex.pastetokens.oldtoken, -48
    .set cc_lex.pastetokens.token, -80
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	112
    mov       [%rbp+64],	%rcx
    mov       [%rbp+72],	%rdx
#---------------
    mov       %rax,	[%rbp + cc_lex.pastetokens.tk]
    mov       %rdi,	[%rax+8]
    mov       %rax,	[%rbp + cc_lex.pastetokens.tknext]
    mov       %rax,	[%rax]
    mov       %r10,	%rdi
    cmp       %r10,	%rax
    jnz       L4186
    mov       %rax,	[%rbp + cc_lex.pastetokens.tk]
    mov       %r10,	[%rbp + cc_lex.pastetokens.tknext]
    mov       [%r10],	%rax
L4186:
    mov       %rax,	[%rdi+8]
    mov       %r10,	[%rbp + cc_lex.pastetokens.tk]
    mov       [%r10+8],	%rax
    mov       %rax,	[%rbp + cc_lex.pastetokens.tk]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	66
    jnz       L4188
    movzx     %rax,	byte ptr[%rdi+21]
    cmp       %rax,	66
    jz        L4189
L4190:
    mov       %rax,	%rdi
    mov       %r10,	[%rbp + cc_lex.pastetokens.tk]
    mov       %r11,	[%rax]
    mov       [%r10],	%r11
    mov       %r11,	[%rax+8]
    mov       [%r10+8],	%r11
    mov       %r11,	[%rax+16]
    mov       [%r10+16],	%r11
    mov       %r11,	[%rax+24]
    mov       [%r10+24],	%r11
L4189:
    jmp       L4187
L4188:
    movzx     %rax,	byte ptr[%rdi+21]
    cmp       %rax,	66
    jz        L4187
L4191:
    mov       %rcx,	[%rbp + cc_lex.pastetokens.tk]
    lea       %rdx,	[%rbp + cc_lex.pastetokens.length1]
    call      cc_lex.strtoken
    mov       %rbx,	%rax
    mov       %rcx,	%rdi
    lea       %rdx,	[%rbp + cc_lex.pastetokens.length2]
    call      cc_lex.strtoken
    mov       %rsi,	%rax
    mov       %rax,	[%rbp + cc_lex.pastetokens.length1]
    add       %rax,	[%rbp + cc_lex.pastetokens.length2]
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       %r12,	%rax
    mov       %rcx,	%r12
    mov       %rdx,	%rbx
    mov       %r8,	[%rbp + cc_lex.pastetokens.length1]
    call      memcpy
    mov       %rax,	[%rbp + cc_lex.pastetokens.length1]
    lea       %r10,	[%r12 + %rax]
    mov       %rcx,	%r10
    mov       %rdx,	%rsi
    mov       %r8,	[%rbp + cc_lex.pastetokens.length2]
    call      memcpy
    mov       %rax,	[%rbp + cc_lex.pastetokens.length1]
    lea       %r10,	[%r12 + %rax]
    xor       %eax,	%eax
    mov       %r11,	[%rbp + cc_lex.pastetokens.length2]
    mov       [%r10 + %r11],	%al
    mov       %rax,	[%rip+cc_lex.npastedtokens]
    cmp       %rax,	87000
    jl        L4193
    lea       %rcx,	[%rip+L8944]
    call      cc_lex.lxerror
L4193:
    inc       qword ptr[%rip+cc_lex.npastedtokens]
    mov       %rax,	[%rip+cc_lex.npastedtokens]
    mov       %r10,	%r12
    lea       %r11,	[%rip+cc_lex.pastedtokenlist]
    mov       [%r11 + %rax*8-8],	%r10
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %r10,	[%rbp + cc_lex.pastetokens.oldtoken]
    mov       %r11,	[%rax]
    mov       [%r10],	%r11
    mov       %r11,	[%rax+8]
    mov       [%r10+8],	%r11
    mov       %r11,	[%rax+16]
    mov       [%r10+16],	%r11
    mov       %r11,	[%rax+24]
    mov       [%r10+24],	%r11
    mov       %r13,	[%rip+cc_lex.lxsptr]
    mov       %r14,	[%rip+cc_lex.lx_stackindex]
    mov       [%rip+cc_lex.lxsptr],	%r12
    xor       %eax,	%eax
    mov       [%rip+cc_lex.lx_stackindex],	%rax
    xor       %ecx,	%ecx
    call      cc_lex.setfileno
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+16],	%eax
    call      cc_lex.lexreadtoken
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %r10,	[%rbp + cc_lex.pastetokens.token]
    mov       %r11,	[%rax]
    mov       [%r10],	%r11
    mov       %r11,	[%rax+8]
    mov       [%r10+8],	%r11
    mov       %r11,	[%rax+16]
    mov       [%r10+16],	%r11
    mov       %r11,	[%rax+24]
    mov       [%r10+24],	%r11
    call      cc_lex.lexreadtoken
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	57
    jz        L4195
L4195:
    lea       %rax,	[%rbp + cc_lex.pastetokens.oldtoken]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       %r11,	[%rax]
    mov       [%r10],	%r11
    mov       %r11,	[%rax+8]
    mov       [%r10+8],	%r11
    mov       %r11,	[%rax+16]
    mov       [%r10+16],	%r11
    mov       %r11,	[%rax+24]
    mov       [%r10+24],	%r11
    mov       [%rip+cc_lex.lxsptr],	%r13
    mov       [%rip+cc_lex.lx_stackindex],	%r14
    mov       %rax,	[%rbp + cc_lex.pastetokens.tk]
    mov       %rax,	[%rax+8]
    mov       [%rbp + cc_lex.pastetokens.token+8],	%rax
    lea       %rcx,	[%rbp + cc_lex.pastetokens.token]
    xor       %edx,	%edx
    call      cc_lex.setfilenox
    mov       %ax,	[%rip+cc_lex.npastedtokens]
    mov       [%rbp + cc_lex.pastetokens.token+28],	%ax
    lea       %rax,	[%rbp + cc_lex.pastetokens.token+23]
    mov       %r10b,	8
    or        [%rax],	%r10b
    lea       %rax,	[%rbp + cc_lex.pastetokens.token]
    mov       %r10,	[%rbp + cc_lex.pastetokens.tk]
    mov       %r11,	[%rax]
    mov       [%r10],	%r11
    mov       %r11,	[%rax+8]
    mov       [%r10+8],	%r11
    mov       %r11,	[%rax+16]
    mov       [%r10+16],	%r11
    mov       %r11,	[%rax+24]
    mov       [%r10+24],	%r11
L4187:
#---------------
    add       %rsp,	112
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.getifexpr
cc_lex.getifexpr:
#?>>
    .set cc_lex.getifexpr.sx, -8
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
#---------------
    call      cc_lex.lexm
    lea       %rcx,	[%rbp + cc_lex.getifexpr.sx]
    call      cc_lex.evalcondexpr
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	56
    jz        L4198
    lea       %rcx,	[%rip+L8945]
    call      cc_lex.lxerror
L4198:
    mov       %rax,	%rdi
    cmp       %rax,	0
    setnz     %al
    movzx     %eax,	%al
L4196:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc cc_lex.evalcondexpr
cc_lex.evalcondexpr:
#?>>
    .set cc_lex.evalcondexpr.sy, -8
    .set cc_lex.evalcondexpr.sz, -16
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %r12,	%rcx
#---------------
    mov       %rcx,	%r12
    call      cc_lex.evalorexpr
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	19
    jnz       L4201
    call      cc_lex.lexm
    lea       %rcx,	[%rbp + cc_lex.evalcondexpr.sy]
    call      cc_lex.evalcondexpr
    mov       %rbx,	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	10
    jz        L4203
    lea       %rcx,	[%rip+L8946]
    call      cc_lex.lxerror
L4203:
    call      cc_lex.lexm
    lea       %rcx,	[%rbp + cc_lex.evalcondexpr.sz]
    call      cc_lex.evalcondexpr
    mov       %rsi,	%rax
    test      %rdi,	%rdi
    jz        L4205
    mov       %rax,	[%rbp + cc_lex.evalcondexpr.sy]
    mov       [%r12],	%rax
    mov       %rdi,	%rbx
    jmp       L4204
L4205:
    mov       %rax,	[%rbp + cc_lex.evalcondexpr.sz]
    mov       [%r12],	%rax
    mov       %rdi,	%rsi
L4204:
L4201:
    mov       %rax,	%rdi
L4199:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.evalorexpr
cc_lex.evalorexpr:
#?>>
    .set cc_lex.evalorexpr.sy, -8
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %rsi,	%rcx
#---------------
    mov       %rcx,	%rsi
    call      cc_lex.evalandexpr
    mov       %rdi,	%rax
    jmp       L4208
L4207:
    call      cc_lex.lexm
    lea       %rcx,	[%rbp + cc_lex.evalorexpr.sy]
    call      cc_lex.evalandexpr
    mov       %rbx,	%rax
    test      %rdi,	%rdi
    jnz       L4212
    test      %rbx,	%rbx
    jz        L4211
L4212:
    mov       %rax,	1
    jmp       L4210
L4211:
    xor       %eax,	%eax
L4210:
    mov       %rdi,	%rax
L4208:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	31
    jz        L4207
    mov       %rax,	%rdi
L4206:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.evalandexpr
cc_lex.evalandexpr:
#?>>
    .set cc_lex.evalandexpr.sy, -8
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %rsi,	%rcx
#---------------
    mov       %rcx,	%rsi
    call      cc_lex.evaliorexpr
    mov       %rdi,	%rax
    jmp       L4215
L4214:
    call      cc_lex.lexm
    lea       %rcx,	[%rbp + cc_lex.evalandexpr.sy]
    call      cc_lex.evaliorexpr
    mov       %rbx,	%rax
    test      %rdi,	%rdi
    jz        L4218
    test      %rbx,	%rbx
    jz        L4218
    mov       %rax,	1
    jmp       L4217
L4218:
    xor       %eax,	%eax
L4217:
    mov       %rdi,	%rax
L4215:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	32
    jz        L4214
    mov       %rax,	%rdi
L4213:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.evaliorexpr
cc_lex.evaliorexpr:
#?>>
    .set cc_lex.evaliorexpr.sy, -8
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rbx,	%rcx
#---------------
    mov       %rcx,	%rbx
    call      cc_lex.evalixorexpr
    mov       %rdi,	%rax
    jmp       L4221
L4220:
    call      cc_lex.lexm
    lea       %rcx,	[%rbp + cc_lex.evaliorexpr.sy]
    call      cc_lex.evalixorexpr
    or        %rdi,	%rax
L4221:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	28
    jz        L4220
    mov       %rax,	%rdi
L4219:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.evalixorexpr
cc_lex.evalixorexpr:
#?>>
    .set cc_lex.evalixorexpr.sy, -8
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rbx,	%rcx
#---------------
    mov       %rcx,	%rbx
    call      cc_lex.evaliandexpr
    mov       %rdi,	%rax
    jmp       L4225
L4224:
    call      cc_lex.lexm
    lea       %rcx,	[%rbp + cc_lex.evalixorexpr.sy]
    call      cc_lex.evaliandexpr
    xor       %rdi,	%rax
L4225:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	30
    jz        L4224
    mov       %rax,	%rdi
L4223:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.evaliandexpr
cc_lex.evaliandexpr:
#?>>
    .set cc_lex.evaliandexpr.sy, -8
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rbx,	%rcx
#---------------
    mov       %rcx,	%rbx
    call      cc_lex.evaleqexpr
    mov       %rdi,	%rax
    jmp       L4229
L4228:
    call      cc_lex.lexm
    lea       %rcx,	[%rbp + cc_lex.evaliandexpr.sy]
    call      cc_lex.evaleqexpr
    and       %rdi,	%rax
L4229:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	29
    jz        L4228
    mov       %rax,	%rdi
L4227:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.evaleqexpr
cc_lex.evaleqexpr:
#?>>
    .set cc_lex.evaleqexpr.sy, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %r12,	%rcx
#---------------
    mov       %rcx,	%r12
    call      cc_lex.evalcmpexpr
    mov       %rdi,	%rax
    jmp       L4233
L4232:
    call      cc_lex.lexm
    lea       %rcx,	[%rbp + cc_lex.evaleqexpr.sy]
    call      cc_lex.evalcmpexpr
    mov       %rbx,	%rax
    mov       %rax,	%rsi
    cmp       %rax,	40
    jz        L4236
    cmp       %rax,	41
    jz        L4237
    jmp       L4238
L4236:
    mov       %rax,	%rdi
    cmp       %rax,	%rbx
    setz      %al
    movzx     %eax,	%al
    mov       %rdi,	%rax
    jmp       L4235
L4237:
    mov       %rax,	%rdi
    cmp       %rax,	%rbx
    setnz     %al
    movzx     %eax,	%al
    mov       %rdi,	%rax
L4238:
L4235:
L4233:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %rsi,	%rax
    cmp       %rax,	40
    jz        L4232
    cmp       %rsi,	41
    jz        L4232
    mov       %rax,	%rdi
L4231:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.evalcmpexpr
cc_lex.evalcmpexpr:
#?>>
    .set cc_lex.evalcmpexpr.sy, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %r12,	%rcx
#---------------
    mov       %rcx,	%r12
    call      cc_lex.evalshiftexpr
    mov       %rdi,	%rax
    jmp       L4241
L4240:
    call      cc_lex.lexm
    lea       %rcx,	[%rbp + cc_lex.evalcmpexpr.sy]
    call      cc_lex.evalshiftexpr
    mov       %rbx,	%rax
    mov       %rax,	%rsi
    cmp       %rax,	42
    jz        L4244
    cmp       %rax,	43
    jz        L4245
    cmp       %rax,	44
    jz        L4246
    cmp       %rax,	45
    jz        L4247
    jmp       L4248
L4244:
    mov       %rax,	%rdi
    cmp       %rax,	%rbx
    setl      %al
    movzx     %eax,	%al
    mov       %rdi,	%rax
    jmp       L4243
L4245:
    mov       %rax,	%rdi
    cmp       %rax,	%rbx
    setle     %al
    movzx     %eax,	%al
    mov       %rdi,	%rax
    jmp       L4243
L4246:
    mov       %rax,	%rdi
    cmp       %rax,	%rbx
    setge     %al
    movzx     %eax,	%al
    mov       %rdi,	%rax
    jmp       L4243
L4247:
    mov       %rax,	%rdi
    cmp       %rax,	%rbx
    setg      %al
    movzx     %eax,	%al
    mov       %rdi,	%rax
L4248:
L4243:
L4241:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %rsi,	%rax
    cmp       %rax,	42
    jz        L4240
    cmp       %rsi,	43
    jz        L4240
    cmp       %rsi,	44
    jz        L4240
    cmp       %rsi,	45
    jz        L4240
    mov       %rax,	%rdi
L4239:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.evalshiftexpr
cc_lex.evalshiftexpr:
#?>>
    .set cc_lex.evalshiftexpr.sy, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %r12,	%rcx
#---------------
    mov       %rcx,	%r12
    call      cc_lex.evaladdexpr
    mov       %rdi,	%rax
    jmp       L4251
L4250:
    call      cc_lex.lexm
    lea       %rcx,	[%rbp + cc_lex.evalshiftexpr.sy]
    call      cc_lex.evaladdexpr
    mov       %rbx,	%rax
    mov       %rax,	%rsi
    cmp       %rax,	34
    jz        L4254
    cmp       %rax,	33
    jz        L4255
    jmp       L4256
L4254:
    mov       %rax,	%rdi
    mov       %cl,	%bl
    sar       %rax,	%cl
    mov       %rdi,	%rax
    jmp       L4253
L4255:
    mov       %rax,	%rdi
    mov       %cl,	%bl
    shl       %rax,	%cl
    mov       %rdi,	%rax
L4256:
L4253:
L4251:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %rsi,	%rax
    cmp       %rax,	33
    jz        L4250
    cmp       %rsi,	34
    jz        L4250
    mov       %rax,	%rdi
L4249:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.evaladdexpr
cc_lex.evaladdexpr:
#?>>
    .set cc_lex.evaladdexpr.sy, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %r12,	%rcx
#---------------
    mov       %rcx,	%r12
    call      cc_lex.evalmulexpr
    mov       %rdi,	%rax
    jmp       L4259
L4258:
    call      cc_lex.lexm
    lea       %rcx,	[%rbp + cc_lex.evaladdexpr.sy]
    call      cc_lex.evalmulexpr
    mov       %rbx,	%rax
    mov       %rax,	%rsi
    cmp       %rax,	23
    jz        L4262
    cmp       %rax,	24
    jz        L4263
    jmp       L4264
L4262:
    mov       %rax,	%rbx
    add       %rdi,	%rax
    jmp       L4261
L4263:
    mov       %rax,	%rbx
    sub       %rdi,	%rax
L4264:
L4261:
L4259:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %rsi,	%rax
    cmp       %rax,	23
    jz        L4258
    cmp       %rsi,	24
    jz        L4258
    mov       %rax,	%rdi
L4257:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.evalmulexpr
cc_lex.evalmulexpr:
#?>>
    .set cc_lex.evalmulexpr.sy, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %r12,	%rcx
#---------------
    mov       %rcx,	%r12
    call      cc_lex.evalunaryexpr
    mov       %rdi,	%rax
    jmp       L4267
L4266:
    call      cc_lex.lexm
    lea       %rcx,	[%rbp + cc_lex.evalmulexpr.sy]
    call      cc_lex.evalunaryexpr
    mov       %rbx,	%rax
    test      %rbx,	%rbx
    jnz       L4270
    cmp       %rsi,	25
    jz        L4270
    lea       %rcx,	[%rip+L8947]
    call      cc_lex.lxerror
L4270:
    mov       %rax,	%rsi
    cmp       %rax,	25
    jz        L4272
    cmp       %rax,	26
    jz        L4273
    cmp       %rax,	27
    jz        L4274
    jmp       L4275
L4272:
    mov       %rax,	%rdi
    imul      %rax,	%rbx
    mov       %rdi,	%rax
    jmp       L4271
L4273:
    mov       %rax,	%rdi
    mov       %r10,	%rbx
    cqo       
    idiv      %r10
    mov       %rdi,	%rax
    jmp       L4271
L4274:
    mov       %rax,	%rdi
    mov       %r10,	%rbx
    cqo       
    idiv      %r10
    xchg      %rax,	%rdx
    mov       %rdi,	%rax
L4275:
L4271:
L4267:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %rsi,	%rax
    cmp       %rax,	25
    jz        L4266
    cmp       %rsi,	26
    jz        L4266
    cmp       %rsi,	27
    jz        L4266
    mov       %rax,	%rdi
L4265:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.evalunaryexpr
cc_lex.evalunaryexpr:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	23
    jz        L4278
    cmp       %rax,	24
    jz        L4278
    cmp       %rax,	36
    jz        L4278
    cmp       %rax,	35
    jnz       L4279
L4278:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %rbx,	%rax
    call      cc_lex.lexm
    mov       %rcx,	%rsi
    call      cc_lex.evalunaryexpr
    mov       %rdi,	%rax
    mov       %rax,	%rbx
    cmp       %rax,	23
    jz        L4281
    cmp       %rax,	24
    jz        L4282
    cmp       %rax,	36
    jz        L4283
    cmp       %rax,	35
    jz        L4284
    jmp       L4285
L4281:
    mov       %rax,	%rdi
    jmp       L4276
L4282:
    mov       %rax,	%rdi
    neg       %rax
    jmp       L4276
L4283:
    mov       %rax,	%rdi
    test      %rax,	%rax
    setz      %al
    movzx     %eax,	%al
    jmp       L4276
L4284:
    mov       %rax,	%rdi
    not       %rax
    jmp       L4276
L4285:
L4280:
L4279:
L4277:
    mov       %rcx,	%rsi
    call      cc_lex.evalterm
L4276:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.evalterm
cc_lex.evalterm:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    mov       %rax,	1
    mov       [%rsi],	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L4288
    cmp       %rax,	59
    jz        L4289
    cmp       %rax,	61
    jz        L4290
    cmp       %rax,	13
    jz        L4291
    jmp       L4292
L4288:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    movzx     %rax,	byte ptr[%rax+107]
    cmp       %rax,	93
    jz        L4294
    cmp       %rax,	92
    jz        L4295
    jmp       L4296
L4294:
    mov       %rax,	1
    mov       [%rip+cc_lex.noexpand],	%rax
    xor       %rbx,	%rbx
    call      cc_lex.lexm
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	13
    jnz       L4298
    mov       %rbx,	1
    call      cc_lex.lexm
L4298:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L4300
    lea       %rcx,	[%rip+L8948]
    call      cc_lex.lxerror
L4300:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	1
    setz      %al
    movzx     %eax,	%al
    mov       %rdi,	%rax
    call      cc_lex.lexm
    test      %rbx,	%rbx
    jz        L4302
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	14
    jz        L4304
    lea       %rcx,	[%rip+L8949]
    call      cc_lex.lxerror
L4304:
    call      cc_lex.lexm
L4302:
    xor       %eax,	%eax
    mov       [%rip+cc_lex.noexpand],	%rax
    jmp       L4293
L4295:
    call      cc_lex.lexm
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	13
    jz        L4306
    lea       %rcx,	[%rip+L8950]
    call      cc_lex.lxerror
L4306:
    call      cc_lex.lexm
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L4308
    lea       %rcx,	[%rip+L8951]
    call      cc_lex.lxerror
L4308:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    movzx     %rax,	byte ptr[%rax+107]
    cmp       %rax,	71
    jnz       L4311
L4310:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    movsx     %rax,	word ptr[%rax+100]
    lea       %r10,	[%rip+cc_tables.typespecsizes]
    movzx     %r10,	byte ptr[%r10 + %rax-1]
    mov       %rdi,	%r10
    jmp       L4309
L4311:
    lea       %rcx,	[%rip+L8952]
    call      cc_lex.lxerror
L4309:
    call      cc_lex.lexm
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	14
    jz        L4313
    lea       %rcx,	[%rip+L8953]
    call      cc_lex.lxerror
L4313:
    call      cc_lex.lexm
    jmp       L4293
L4296:
    call      cc_lex.lexm
    xor       %eax,	%eax
    jmp       L4286
L4293:
    jmp       L4287
L4289:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rdi,	[%rax]
    call      cc_lex.lexm
    jmp       L4287
L4290:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+24]
    test      %rax,	%rax
    jnz       L4315
    xor       %rdi,	%rdi
    jmp       L4314
L4315:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    movzx     %rax,	byte ptr[%rax]
    mov       %rdi,	%rax
L4314:
    call      cc_lex.lexm
    jmp       L4287
L4291:
    call      cc_lex.lexm
    mov       %rcx,	%rsi
    call      cc_lex.evalcondexpr
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	14
    jz        L4317
    lea       %rcx,	[%rip+L8954]
    call      cc_lex.lxerror
L4317:
    call      cc_lex.lexm
    jmp       L4287
L4292:
    lea       %rcx,	[%rip+cc_decls.nextlx]
    call      cc_lex.printsymbol
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+24]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       %r10,	[%r10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      cc_lex.printstrn
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8955]
    call      cc_lex.lxerror
L4287:
    mov       %rax,	%rdi
L4286:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.getifdef
cc_lex.getifdef:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
    mov       %rax,	1
    mov       [%rip+cc_lex.noexpand],	%rax
    call      cc_lex.lexreadtoken
    xor       %eax,	%eax
    mov       [%rip+cc_lex.noexpand],	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L4320
    lea       %rcx,	[%rip+L8956]
    call      cc_lex.lxerror
L4320:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rbx,	[%rax]
    xor       %rdi,	%rdi
    movzx     %rax,	byte ptr[%rbx+109]
    cmp       %rax,	1
    jnz       L4322
    mov       %rdi,	1
    jmp       L4321
L4322:
    movzx     %rax,	byte ptr[%rbx+107]
    cmp       %rax,	69
    jnz       L4323
    mov       %rdi,	1
L4323:
L4321:
    call      cc_lex.lexreadtoken
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	56
    jz        L4325
    lea       %rcx,	[%rip+L8957]
    call      cc_lex.lxerror
L4325:
    mov       %rax,	%rdi
L4318:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.skipcode
cc_lex.skipcode:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
    xor       %rdi,	%rdi
L4327:
    call      cc_lex.fastreadtoken
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	4
    jz        L4330
    cmp       %rax,	57
    jz        L4331
    jmp       L4332
L4330:
    call      cc_lex.getlexdirective
    mov       %rbx,	%rax
    mov       %rax,	%rbx
    cmp       %rax,	3
    jz        L4334
    cmp       %rax,	8
    jz        L4334
    cmp       %rax,	9
    jz        L4334
    cmp       %rax,	4
    jz        L4335
    cmp       %rax,	5
    jz        L4335
    cmp       %rax,	6
    jz        L4336
    jmp       L4337
L4334:
    inc       %rdi
    jmp       L4333
L4335:
    test      %rdi,	%rdi
    jnz       L4339
    mov       %rax,	%rbx
    jmp       L4326
L4339:
    jmp       L4333
L4336:
    test      %rdi,	%rdi
    jnz       L4341
    mov       %rax,	%rbx
    jmp       L4326
L4341:
    dec       %rdi
L4337:
L4333:
    jmp       L4329
L4331:
    lea       %rcx,	[%rip+L8958]
    call      cc_lex.lxerror
L4332:
L4329:
    jmp       L4327
    xor       %eax,	%eax
L4326:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.freetokens
cc_lex.freetokens:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	16
#---------------
    jmp       L4344
L4343:
    mov       %rdi,	[%rcx+8]
    mov       %rax,	%rdi
    mov       %rcx,	%rax
L4344:
    test      %rcx,	%rcx
    jnz       L4343
#---------------
    add       %rsp,	16
    pop       %rdi
    ret       
# End 
# Proc cc_lex.fastreadtoken
cc_lex.fastreadtoken:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
L4347:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    mov       %rdi,	%rax
    cmp       %rax,	48
    jae       L4350
    lea       %r10,	[%rip+L4349]
    jmp       [%r10 + %rax*8]
    .data
L4349:
    .quad     L4372
    .quad     L4350
    .quad     L4350
    .quad     L4350
    .quad     L4350
    .quad     L4350
    .quad     L4350
    .quad     L4350
    .quad     L4350
    .quad     L4350
    .quad     L4371
    .quad     L4350
    .quad     L4375
    .quad     L4370
    .quad     L4350
    .quad     L4350
    .quad     L4350
    .quad     L4350
    .quad     L4350
    .quad     L4350
    .quad     L4350
    .quad     L4350
    .quad     L4350
    .quad     L4350
    .quad     L4350
    .quad     L4350
    .quad     L4350
    .quad     L4350
    .quad     L4350
    .quad     L4350
    .quad     L4350
    .quad     L4350
    .quad     L4350
    .quad     L4350
    .quad     L4369
    .quad     L4351
    .quad     L4350
    .quad     L4350
    .quad     L4350
    .quad     L4368
    .quad     L4350
    .quad     L4350
    .quad     L4350
    .quad     L4350
    .quad     L4350
    .quad     L4350
    .quad     L4350
    .quad     L4363
    .text
L4351:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	2
    mov       %rsi,	%rax
    xor       %rbx,	%rbx
    jmp       L4353
L4352:
    movzx     %rax,	byte ptr[%rsi]
    cmp       %rax,	10
    jz        L4356
    cmp       %rax,	9
    jz        L4357
    cmp       %rax,	32
    jz        L4357
    jmp       L4358
L4356:
    mov       %rbx,	1
    jmp       L4354
L4357:
    jmp       L4355
L4358:
    jmp       L4354
L4355:
    dec       %rsi
L4353:
    cmp       %rsi,	[%rip+cc_lex.lxstart]
    jae       L4352
L4354:
    test      %rbx,	%rbx
    jnz       L4361
    cmp       %rsi,	[%rip+cc_lex.lxstart]
    jae       L4360
L4361:
    mov       %al,	4
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L4346
L4360:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	35
    jnz       L4362
    inc       qword ptr[%rip+cc_lex.lxsptr]
L4362:
L4359:
    jmp       L4347
L4363:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	47
    jz        L4365
    cmp       %rax,	42
    jz        L4366
    jmp       L4367
L4365:
    call      cc_lex.readlinecomment
    jmp       L4364
L4366:
    call      cc_lex.readblockcomment
L4367:
L4364:
    jmp       L4347
L4368:
    mov       %rcx,	39
    xor       %edx,	%edx
    call      cc_lex.lxreadstring
    jmp       L4347
L4369:
    mov       %rcx,	34
    xor       %edx,	%edx
    call      cc_lex.lxreadstring
    jmp       L4347
L4370:
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %rax,	[%rax+16]
    inc       dword ptr[%rax]
    mov       %al,	56
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
    inc       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L4347
L4371:
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %rax,	[%rax+16]
    inc       dword ptr[%rax]
    mov       %al,	56
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
    jmp       L4347
L4372:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lx_stackindex]
    test      %rax,	%rax
    jz        L4374
    call      cc_lex.unstacksourcefile
    jmp       L4373
L4374:
    mov       %al,	57
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L4346
L4373:
    jmp       L4347
L4375:
    jmp       L4347
L4350:
    jmp       L4347
L4346:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.alloctoken
cc_lex.alloctoken:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rcx,	32
    call      mlib.pcm_alloc
    mov       %rdi,	%rax
    mov       %rax,	%rdi
L4376:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lex.alloctokenz
cc_lex.alloctokenz:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rcx,	32
    call      mlib.pcm_alloc
    mov       %rdi,	%rax
    xor       %eax,	%eax
    mov       [%rdi+8],	%rax
    mov       %rax,	%rdi
L4377:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lex.expandpredefmacro
cc_lex.expandpredefmacro:
#?>>
    .set cc_lex.expandpredefmacro.str, -256
    .set cc_lex.expandpredefmacro.tm, -272
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	312
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
    mov       %rax,	[%rip+cc_lex.noexpand]
    test      %rax,	%rax
    jnz       L4378
L4380:
    mov       %rax,	%rsi
    cmp       %rax,	1
    jz        L4382
    cmp       %rax,	2
    jz        L4383
    cmp       %rax,	3
    jz        L4384
    cmp       %rax,	5
    jz        L4385
    cmp       %rax,	4
    jz        L4386
    cmp       %rax,	9
    jz        L4387
    cmp       %rax,	7
    jz        L4388
    cmp       %rax,	8
    jz        L4389
    jmp       L4390
L4382:
    lea       %rcx,	[%rbp + cc_lex.expandpredefmacro.tm]
    call      mnoos.os_getsystime
    lea       %rcx,	[%rbp + cc_lex.expandpredefmacro.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8959]
    call      msys.m$print_setfmt
    movzx     %rax,	word ptr[%rbp + cc_lex.expandpredefmacro.tm+6]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    movzx     %rax,	word ptr[%rbp + cc_lex.expandpredefmacro.tm+2]
    lea       %r10,	[%rip+cc_lex.expandpredefmacro.monthnames]
    mov       %r10,	[%r10 + %rax*8-8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    movzx     %rax,	word ptr[%rbp + cc_lex.expandpredefmacro.tm]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8960]
    call      msys.m$print_i64
    call      msys.m$print_end
    mov       %al,	63
    mov       [%r12+21],	%al
    lea       %rcx,	[%rbp + cc_lex.expandpredefmacro.str]
    call      mlib.pcm_copyheapstring
    mov       [%r12],	%rax
    jmp       L4381
L4383:
    lea       %rcx,	[%rbp + cc_lex.expandpredefmacro.tm]
    call      mnoos.os_getsystime
    lea       %rcx,	[%rbp + cc_lex.expandpredefmacro.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8961]
    call      msys.m$print_setfmt
    movzx     %rax,	word ptr[%rbp + cc_lex.expandpredefmacro.tm+8]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8962]
    call      msys.m$print_i64
    movzx     %rax,	word ptr[%rbp + cc_lex.expandpredefmacro.tm+10]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8963]
    call      msys.m$print_i64
    movzx     %rax,	word ptr[%rbp + cc_lex.expandpredefmacro.tm+12]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8963]
    call      msys.m$print_i64
    call      msys.m$print_end
    mov       %al,	63
    mov       [%r12+21],	%al
    lea       %rcx,	[%rbp + cc_lex.expandpredefmacro.str]
    call      mlib.pcm_copyheapstring
    mov       [%r12],	%rax
    jmp       L4381
L4384:
    mov       %al,	63
    mov       [%r12+21],	%al
    mov       %rcx,	%r12
    call      cc_lex.getfilenox
    mov       %rbx,	%rax
    test      %rbx,	%rbx
    jnz       L4392
    mov       %rbx,	[%rip+cc_decls.sfileno]
L4392:
    mov       %rax,	[%rip+cc_decls.sfileno]
    test      %rax,	%rax
    jz        L4394
    lea       %rax,	[%rip+cc_decls.sourcefilenames]
    mov       %r10,	[%rip+cc_decls.sfileno]
    mov       %rax,	[%rax + %r10*8]
    mov       [%r12],	%rax
    jmp       L4393
L4394:
    lea       %rax,	[%rip+L8964]
    mov       [%r12],	%rax
L4393:
    jmp       L4381
L4385:
    mov       %al,	63
    mov       [%r12+21],	%al
    mov       %rax,	[%rip+cc_decls.currproc]
    test      %rax,	%rax
    jz        L4396
    mov       %rax,	[%rip+cc_decls.currproc]
    mov       %rax,	[%rax]
    mov       [%r12],	%rax
    jmp       L4395
L4396:
    lea       %rax,	[%rip+L8965]
    mov       [%r12],	%rax
L4395:
    jmp       L4381
L4386:
    mov       %al,	59
    mov       [%r12+21],	%al
    mov       [%r12],	%r13
    jmp       L4381
L4387:
    mov       %al,	59
    mov       [%r12+21],	%al
    mov       %rax,	1
    mov       [%r12],	%rax
    jmp       L4381
L4388:
    mov       %al,	59
    mov       [%r12+21],	%al
    mov       %rax,	1
    mov       [%r12],	%rax
    jmp       L4381
L4389:
    mov       %al,	59
    mov       [%r12+21],	%al
    movzx     %rax,	byte ptr[%rip+cc_decls.pci_target]
    mov       [%r12],	%rax
    jmp       L4381
L4390:
    call      msys.m$print_startcon
    mov       %rcx,	%rsi
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8966]
    call      cc_lex.lxerror
L4381:
    movzx     %rax,	byte ptr[%r12+21]
    cmp       %rax,	63
    jnz       L4398
    mov       %rax,	[%r12]
    mov       %rcx,	%rax
    call      strlen
    mov       [%r12+24],	%eax
    mov       %al,	[%rip+cc_decls.trefchar]
    mov       [%r12+22],	%al
    jmp       L4397
L4398:
    mov       %al,	3
    mov       [%r12+22],	%al
    mov       %rcx,	16
    call      mlib.pcm_alloc
    mov       %rdi,	%rax
    mov       %rax,	[%r12]
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    call      msys.getstrint
    mov       %rcx,	%rdi
    call      strlen
    mov       [%r12+24],	%eax
    mov       %rax,	[%rip+cc_lex.npastedtokens]
    cmp       %rax,	87000
    jl        L4400
    lea       %rcx,	[%rip+L8967]
    call      cc_lex.lxerror
L4400:
    inc       qword ptr[%rip+cc_lex.npastedtokens]
    mov       %rax,	[%rip+cc_lex.npastedtokens]
    mov       %r10,	%rdi
    lea       %r11,	[%rip+cc_lex.pastedtokenlist]
    mov       [%r11 + %rax*8-8],	%r10
    mov       %rcx,	%r12
    xor       %edx,	%edx
    call      cc_lex.setfilenox
    mov       %ax,	[%rip+cc_lex.npastedtokens]
    mov       [%r12+28],	%ax
L4397:
L4378:
#---------------
    add       %rsp,	312
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.dopragmadir
cc_lex.dopragmadir:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    call      cc_lex.lexm
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jnz       L4403
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8968]
    mov       %r8,	4
    call      memcmp
    movsxd    %r10,	%eax
    test      %r10,	%r10
    jnz       L4405
    call      cc_lex.lexm
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	13
    jz        L4407
    lea       %rcx,	[%rip+L8969]
    call      cc_lex.lxerror
L4407:
    call      cc_lex.lexm
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	59
    jnz       L4409
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    cmp       %rax,	1
    jnz       L4412
L4411:
    xor       %eax,	%eax
    mov       [%rip+cc_decls.structpadding],	%rax
    jmp       L4410
L4412:
    jmp       L4413
    lea       %rcx,	[%rip+L8970]
    call      cc_lex.lxerror
L4410:
    call      cc_lex.lexm
    jmp       L4408
L4409:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	14
    jnz       L4414
    mov       %rax,	1
    mov       [%rip+cc_decls.structpadding],	%rax
L4414:
L4408:
    jmp       L4404
L4405:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8971]
    mov       %r8,	6
    call      memcmp
    movsxd    %r10,	%eax
    test      %r10,	%r10
    jnz       L4415
    mov       %rcx,	77
    call      cc_lex.addbuildinfo
    jmp       L4404
L4415:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8972]
    mov       %r8,	6
    call      memcmp
    movsxd    %r10,	%eax
    test      %r10,	%r10
    jnz       L4416
    mov       %rcx,	72
    call      cc_lex.addbuildinfo
    jmp       L4404
L4416:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8973]
    mov       %r8,	4
    call      memcmp
    movsxd    %r10,	%eax
    test      %r10,	%r10
    jnz       L4417
    mov       %rcx,	76
    call      cc_lex.addbuildinfo
L4417:
L4404:
L4403:
#cc_lex.dopragmadir.finish:
L4413:
    jmp       L4419
L4418:
    call      cc_lex.lexm
L4419:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	56
    jz        L4421
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	57
    jnz       L4418
L4421:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_lex.addbuildinfo
cc_lex.addbuildinfo:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    call      cc_lex.lexm
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	63
    jz        L4424
    lea       %rcx,	[%rip+L8974]
    call      cc_lex.lxerror
L4424:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    call      mlib.pcm_copyheapstring
    mov       %rdi,	%rax
    mov       %rax,	%rbx
    cmp       %rax,	77
    jz        L4426
    cmp       %rax,	72
    jz        L4427
    cmp       %rax,	76
    jz        L4428
    jmp       L4429
L4426:
    mov       %rax,	[%rip+cc_decls.npmodules]
    cmp       %rax,	199
    jl        L4431
    lea       %rcx,	[%rip+L8975]
    call      cc_lex.lxerror
L4431:
    inc       qword ptr[%rip+cc_decls.npmodules]
    mov       %rax,	[%rip+cc_decls.npmodules]
    mov       %r10,	%rdi
    lea       %r11,	[%rip+cc_decls.pmodulelist]
    mov       [%r11 + %rax*8-8],	%r10
    jmp       L4425
L4427:
    mov       %rax,	[%rip+cc_decls.npheaders]
    cmp       %rax,	100
    jl        L4433
    lea       %rcx,	[%rip+L8976]
    call      cc_lex.lxerror
L4433:
    inc       qword ptr[%rip+cc_decls.npheaders]
    mov       %rax,	[%rip+cc_decls.npheaders]
    mov       %r10,	%rdi
    lea       %r11,	[%rip+cc_decls.pheaderlist]
    mov       [%r11 + %rax*8-8],	%r10
    jmp       L4425
L4428:
    mov       %rax,	[%rip+cc_decls.nplibs]
    cmp       %rax,	100
    jl        L4435
    lea       %rcx,	[%rip+L8977]
    call      cc_lex.lxerror
L4435:
    inc       qword ptr[%rip+cc_decls.nplibs]
    mov       %rax,	[%rip+cc_decls.nplibs]
    mov       %r10,	%rdi
    lea       %r11,	[%rip+cc_decls.pliblist]
    mov       [%r11 + %rax*8-8],	%r10
L4429:
L4425:
    call      cc_lex.lexm
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.needspace
cc_lex.needspace:
#?>>
    push      %rdi
    push      %rbx
#?]]
#---------------
    test      %rcx,	%rcx
    jnz       L4438
    xor       %eax,	%eax
    jmp       L4436
L4438:
    lea       %rax,	[%rip+cc_tables.shortsymbolnames]
    mov       %r10,	%rcx
    mov       %rdi,	[%rax + %r10*8-8]
    lea       %rax,	[%rip+cc_tables.shortsymbolnames]
    mov       %r10,	%rdx
    mov       %rbx,	[%rax + %r10*8-8]
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	110
    jz        L4440
    cmp       %rax,	107
    jz        L4440
    cmp       %rax,	45
    jz        L4441
    cmp       %rax,	43
    jz        L4441
    jmp       L4442
L4440:
    movzx     %rax,	byte ptr[%rdi]
    cmp       %rax,	110
    jz        L4444
    cmp       %rax,	107
    jnz       L4445
L4444:
    mov       %rax,	1
    jmp       L4436
L4445:
L4443:
    jmp       L4439
L4441:
    movzx     %rax,	byte ptr[%rdi]
    cmp       %rax,	45
    jz        L4447
    cmp       %rax,	43
    jnz       L4448
L4447:
    mov       %rax,	1
    jmp       L4436
L4448:
L4446:
L4442:
L4439:
    xor       %eax,	%eax
L4436:
#---------------
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.dospecialinclude
cc_lex.dospecialinclude:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    lea       %rcx,	[%rip+L8978]
    mov       %rdx,	1
    call      cc_lex.stacksourcefile
    mov       %rax,	[%rip+cc_decls.dheaderfile]
    test      %rax,	%rax
    jz        L4451
    mov       %rcx,	[%rip+cc_decls.dheaderfile]
    mov       %rdx,	1
    call      cc_lex.stacksourcefile
L4451:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_lex.setnumberoffset
cc_lex.setnumberoffset:
#?>>
#?]]
#---------------
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+28]
    mov       %r10,	4278190080
    and       %rax,	%r10
    mov       %r10,	%rcx
    and       %r10,	16777215
    or        %rax,	%r10
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+28],	%eax
#---------------
    ret       
# End 
# Proc cc_lex.setfileno
cc_lex.setfileno:
#?>>
#?]]
#---------------
    mov       %rax,	%rcx
    and       %rax,	255
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+20],	%al
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+28]
    and       %rax,	16777215
    mov       %r10,	%rcx
    and       %r10,	65280
    shl       %r10,	16
    or        %rax,	%r10
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+28],	%eax
#---------------
    ret       
# End 
# Proc cc_lex.setfilenox
cc_lex.setfilenox:
#?>>
#?]]
#---------------
    mov       %rax,	%rdx
    and       %rax,	255
    mov       [%rcx+20],	%al
    movsxd    %rax,	dword ptr[%rcx+28]
    and       %rax,	16777215
    mov       %r10,	%rdx
    and       %r10,	65280
    shl       %r10,	16
    or        %rax,	%r10
    mov       [%rcx+28],	%eax
#---------------
    ret       
# End 
# Proc cc_lex.getfileno
cc_lex.getfileno:
#?>>
#?]]
#---------------
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+28]
    sar       %rax,	24
    shl       %rax,	8
    lea       %r10,	[%rip+cc_decls.nextlx]
    movzx     %r10,	byte ptr[%r10+20]
    or        %rax,	%r10
L4455:
#---------------
    ret       
# End 
# Proc cc_lex.getfilenox
cc_lex.getfilenox:
#?>>
#?]]
#---------------
    movsxd    %rax,	dword ptr[%rcx+28]
    sar       %rax,	24
    shl       %rax,	8
    movzx     %r10,	byte ptr[%rcx+20]
    or        %rax,	%r10
L4456:
#---------------
    ret       
# End 
# Proc cc_lex.getnumberoffsetx
cc_lex.getnumberoffsetx:
#?>>
#?]]
#---------------
    movsxd    %rax,	dword ptr[%rcx+28]
    and       %rax,	16777215
L4457:
#---------------
    ret       
# End 
# Proc cc_lex.freehashtable
cc_lex.freehashtable:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
#---------------
    xor       %r12,	%r12
    mov       %rax,	[%rip+cc_decls.hstmask]
    cmp       %rax,	0
    jl        L4461
L4459:
    mov       %rax,	[%rip+cc_decls.hashtable]
    mov       %r10,	%r12
    mov       %rdi,	[%rax + %r10*8]
    mov       %rax,	[%rdi]
    test      %rax,	%rax
    jz        L4463
    movzx     %rax,	byte ptr[%rdi+107]
    cmp       %rax,	67
    jnz       L4463
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	1
    jnz       L4465
    mov       %rcx,	[%rdi+72]
    call      cc_lex.freetokens
L4465:
    mov       %rsi,	[%rdi+40]
    jmp       L4467
L4466:
    mov       %rbx,	[%rsi+40]
    mov       %rcx,	%rsi
    mov       %rdx,	128
    call      mlib.pcm_free
    mov       %rsi,	%rbx
L4467:
    test      %rsi,	%rsi
    jnz       L4466
    mov       %rax,	[%rip+cc_decls.hashtable]
    mov       %r10,	%r12
    mov       %rax,	[%rax + %r10*8]
    mov       %rcx,	%rax
    mov       %rdx,	128
    call      mlib.pcm_clearmem
    jmp       L4462
L4463:
    mov       %rax,	[%rdi]
    test      %rax,	%rax
    jz        L4469
    xor       %eax,	%eax
    mov       [%rdi+40],	%rax
L4469:
L4462:
    inc       %r12
    cmp       %r12,	[%rip+cc_decls.hstmask]
    jle       L4459
L4461:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.regenlookup
cc_lex.regenlookup:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
#---------------
    movzx     %rax,	byte ptr[%r13+106]
    mov       %r10,	[%r13]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      cc_lex.gethashvalue
    and       %rax,	[%rip+cc_decls.hstmask]
    mov       %rdi,	%rax
    xor       %rbx,	%rbx
L4471:
    mov       %rax,	[%rip+cc_decls.hashtable]
    mov       %r10,	%rdi
    mov       %r12,	[%rax + %r10*8]
    movzx     %rax,	byte ptr[%r12+106]
    mov       %rsi,	%rax
    test      %rsi,	%rsi
    jnz       L4474
    mov       %rax,	[%rip+cc_decls.hashtable]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    mov       %rcx,	%rax
    mov       %rdx,	128
    call      mlib.pcm_free
    mov       %rax,	%r13
    mov       %r10,	[%rip+cc_decls.hashtable]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*8],	%rax
    inc       qword ptr[%rip+cc_lex.nhstsymbols]
    jmp       L4470
L4474:
    movzx     %rax,	byte ptr[%r13+106]
    mov       %r10,	%rsi
    cmp       %r10,	%rax
    jnz       L4476
    mov       %rax,	[%r13]
    mov       %r10,	[%r12]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    mov       %r8,	%rsi
    call      memcmp
    movsxd    %r10,	%eax
    test      %r10,	%r10
    jnz       L4478
    lea       %rcx,	[%rip+L8979]
    call      cc_lex.lxerror
L4478:
L4476:
    inc       %rdi
    cmp       %rdi,	[%rip+cc_decls.hstsize]
    jl        L4480
    test      %rbx,	%rbx
    jz        L4482
    lea       %rcx,	[%rip+L8980]
    call      mlib.abortprogram
L4482:
    mov       %rbx,	1
    xor       %rdi,	%rdi
L4480:
    jmp       L4471
L4470:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.newhashtable
cc_lex.newhashtable:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
#---------------
    mov       %rdi,	[%rip+cc_decls.hashtable]
    mov       %rbx,	[%rip+cc_decls.hstsize]
    mov       %rax,	[%rip+cc_decls.hstsize]
    shl       %rax,	1
    mov       [%rip+cc_decls.hstsize],	%rax
    mov       %rax,	[%rip+cc_decls.hstsize]
    dec       %rax
    mov       [%rip+cc_decls.hstmask],	%rax
    xor       %eax,	%eax
    mov       [%rip+cc_lex.nhstsymbols],	%rax
    mov       %rax,	6
    mov       %r10,	[%rip+cc_decls.hstsize]
    imul      %rax,	%r10
    mov       %r10,	10
    cqo       
    idiv      %r10
    mov       [%rip+cc_lex.hstthreshold],	%rax
    mov       %rax,	[%rip+cc_decls.hstsize]
    shl       %rax,	3
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       [%rip+cc_decls.hashtable],	%rax
    xor       %r13,	%r13
    mov       %rax,	[%rip+cc_decls.hstmask]
    cmp       %rax,	0
    jl        L4486
L4484:
    mov       %rcx,	128
    call      mlib.pcm_allocz
    mov       %r10,	[%rip+cc_decls.hashtable]
    mov       %r11,	%r13
    mov       [%r10 + %r11*8],	%rax
    inc       %r13
    cmp       %r13,	[%rip+cc_decls.hstmask]
    jle       L4484
L4486:
    xor       %r13,	%r13
    mov       %rax,	%rbx
    dec       %rax
    mov       %r12,	%rax
    cmp       %r12,	0
    jl        L4489
L4487:
    mov       %rsi,	[%rdi + %r13*8]
    mov       %rax,	[%rsi]
    test      %rax,	%rax
    jz        L4491
    mov       %rcx,	%rsi
    call      cc_lex.regenlookup
L4491:
    inc       %r13
    cmp       %r13,	%r12
    jle       L4487
L4489:
    mov       %rax,	%rbx
    shl       %rax,	3
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mlib.pcm_free
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.old_readrealnumber
cc_lex.old_readrealnumber:
#?>>
    .set cc_lex.old_readrealnumber.intlen, 104
    .set cc_lex.old_readrealnumber.base, 112
    .set cc_lex.old_readrealnumber.c, -8
    .set cc_lex.old_readrealnumber.badexpon, -16
    .set cc_lex.old_readrealnumber.realstr, -520
    .set cc_lex.old_readrealnumber.av_1, -528
    .set cc_lex.old_readrealnumber.av_2, -536
    .set cc_lex.old_readrealnumber.av_3, -544
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    movq      %rax,	%XMM13
    push      %rax
    movq      %rax,	%XMM14
    push      %rax
    movq      %rax,	%XMM15
    push      %rax
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	584
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       [%rbp+104],	%r8
    mov       [%rbp+112],	%r9
#---------------
    xor       %rdi,	%rdi
    xor       %eax,	%eax
    mov       %rbx,	%rax
    xor       %rsi,	%rsi
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	46
    jnz       L4494
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rdi,	[%rip+cc_lex.lxsptr]
    mov       %rcx,	[%rbp + cc_lex.old_readrealnumber.base]
    call      cc_lex.scannumber
    sub       %rax,	%rdi
    mov       %rbx,	%rax
L4494:
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.old_readrealnumber.badexpon],	%rax
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	101
    jz        L4496
    cmp       %rax,	69
    jz        L4496
    cmp       %rax,	112
    jz        L4497
    cmp       %rax,	80
    jz        L4497
    jmp       L4498
L4496:
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.base]
    cmp       %rax,	16
    jz        L4500
    inc       qword ptr[%rip+cc_lex.lxsptr]
    lea       %rcx,	[%rbp + cc_lex.old_readrealnumber.badexpon]
    call      cc_lex.readexponent
    mov       %rsi,	%rax
L4500:
    jmp       L4495
L4497:
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.base]
    cmp       %rax,	16
    jnz       L4502
    inc       qword ptr[%rip+cc_lex.lxsptr]
    lea       %rcx,	[%rbp + cc_lex.old_readrealnumber.badexpon]
    call      cc_lex.readexponent
    mov       %rsi,	%rax
L4502:
L4498:
L4495:
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.badexpon]
    test      %rax,	%rax
    jz        L4504
    dec       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rcx,	%r13
    call      cc_lex.readalphanumeric
    jmp       L4492
L4504:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	102
    jz        L4506
    cmp       %rax,	70
    jz        L4506
    cmp       %rax,	108
    jz        L4506
    cmp       %rax,	76
    jnz       L4507
L4506:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L4505
L4507:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    lea       %r10,	[%rip+cc_lex.alphamap]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L4509
    mov       %rcx,	%r13
    call      cc_lex.readalphanumeric
    jmp       L4492
L4509:
L4505:
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.intlen]
    add       %rax,	%rbx
    cmp       %rax,	500
    jle       L4511
    lea       %rcx,	[%rip+L8981]
    call      cc_lex.lxerror
L4511:
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.intlen]
    test      %rax,	%rax
    jz        L4513
    lea       %rcx,	[%rbp + cc_lex.old_readrealnumber.realstr]
    mov       %rdx,	%r14
    mov       %r8,	[%rbp + cc_lex.old_readrealnumber.intlen]
    call      memcpy
L4513:
    test      %rbx,	%rbx
    jz        L4515
    lea       %rax,	[%rbp + cc_lex.old_readrealnumber.realstr]
    mov       %r10,	[%rbp + cc_lex.old_readrealnumber.intlen]
    lea       %rax,	[%rax + %r10]
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      memcpy
L4515:
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.base]
    cvtsi2sd  %XMM4,	%rax
    movq      %XMM15,	%XMM4
    movq      %XMM13,	%XMM4
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.base]
    cmp       %rax,	10
    jnz       L4517
    mov       %rax,	%rbx
    sub       %rsi,	%rax
    jmp       L4516
L4517:
    mov       %rax,	%rbx
    shl       %rax,	2
    sub       %rsi,	%rax
    movq      %XMM4,	[%rip+L8982]
    movq      %XMM13,	%XMM4
L4516:
    movq      %XMM4,	[%rip+L8983]
    movq      %XMM14,	%XMM4
    mov       %r12,	1
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.intlen]
    add       %rax,	%rbx
    mov       [%rbp + cc_lex.old_readrealnumber.av_1],	%rax
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.av_1]
    cmp       %rax,	1
    jl        L4520
L4518:
    movzx     %rax,	byte ptr[%rbp + %r12 + cc_lex.old_readrealnumber.realstr-1]
    mov       [%rbp + cc_lex.old_readrealnumber.c],	%rax
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.c]
    cmp       %rax,	48
    jl        L4522
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.c]
    cmp       %rax,	57
    jg        L4522
    movq      %XMM4,	%XMM14
    mulsd     %XMM4,	%XMM15
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.c]
    sub       %rax,	48
    cvtsi2sd  %XMM5,	%rax
    addsd     %XMM4,	%XMM5
    movq      %XMM14,	%XMM4
    jmp       L4521
L4522:
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.c]
    cmp       %rax,	97
    jle       L4523
    movq      %XMM4,	%XMM14
    mulsd     %XMM4,	%XMM15
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.c]
    cvtsi2sd  %XMM5,	%rax
    addsd     %XMM4,	%XMM5
    mov       %rax,	97
    cmp       %rax,	0
    jl        L8984
    cvtsi2sd  %XMM5,	%rax
    jmp       L8985
L8984:
    and       %rax,	[%rip+L8986]
    cvtsi2sd  %XMM5,	%rax
    addsd     %XMM5,	[%rip+L8987]
L8985:
    subsd     %XMM4,	%XMM5
    addsd     %XMM4,	[%rip+L8988]
    movq      %XMM14,	%XMM4
    jmp       L4521
L4523:
    movq      %XMM4,	%XMM14
    mulsd     %XMM4,	%XMM15
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.c]
    cvtsi2sd  %XMM5,	%rax
    addsd     %XMM4,	%XMM5
    mov       %rax,	65
    cmp       %rax,	0
    jl        L8989
    cvtsi2sd  %XMM5,	%rax
    jmp       L8990
L8989:
    and       %rax,	[%rip+L8986]
    cvtsi2sd  %XMM5,	%rax
    addsd     %XMM5,	[%rip+L8987]
L8990:
    subsd     %XMM4,	%XMM5
    addsd     %XMM4,	[%rip+L8991]
    movq      %XMM14,	%XMM4
L4521:
    inc       %r12
    cmp       %r12,	[%rbp + cc_lex.old_readrealnumber.av_1]
    jle       L4518
L4520:
    cmp       %rsi,	0
    jl        L4525
    mov       [%rbp + cc_lex.old_readrealnumber.av_2],	%rsi
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.av_2]
    cmp       %rax,	0
    jle       L4528
L4526:
    movq      %XMM4,	%XMM14
    mulsd     %XMM4,	%XMM13
    movq      %XMM14,	%XMM4
    dec       qword ptr[%rbp + cc_lex.old_readrealnumber.av_2]
    jnz       L4526
L4528:
    jmp       L4524
L4525:
    mov       %rax,	%rsi
    neg       %rax
    mov       [%rbp + cc_lex.old_readrealnumber.av_3],	%rax
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.av_3]
    cmp       %rax,	0
    jle       L4531
L4529:
    movq      %XMM4,	%XMM14
    divsd     %XMM4,	%XMM13
    movq      %XMM14,	%XMM4
    dec       qword ptr[%rbp + cc_lex.old_readrealnumber.av_3]
    jnz       L4529
L4531:
L4524:
    mov       %al,	60
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    mov       %al,	11
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    movq      %XMM4,	%XMM14
    lea       %rax,	[%rip+cc_decls.nextlx]
    movq      [%rax],	%XMM4
    mov       %rax,	%r14
    sub       %rax,	[%rip+cc_lex.lxstart]
    mov       %rcx,	%rax
    call      cc_lex.setnumberoffset
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	%r14
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
L4492:
#---------------
    add       %rsp,	584
    pop       %rbp
    pop       %rcx
    movq      %XMM15,	%rcx
    pop       %rcx
    movq      %XMM14,	%rcx
    pop       %rcx
    movq      %XMM13,	%rcx
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.issimpleconstmacro
cc_lex.issimpleconstmacro:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
    mov       %rsi,	1
    mov       %rbx,	3
    cmp       %rbx,	1
    jl        L4535
L4533:
    mov       %rax,	[%r12]
    lea       %r10,	[%rip+cc_lex.issimpleconstmacro.specialnames]
    mov       %r11,	%rsi
    mov       %r10,	[%r10 + %r11*8-8]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L4537
    mov       %rax,	2
    jmp       L4532
L4537:
    inc       %rsi
    cmp       %rsi,	%rbx
    jle       L4533
L4535:
    mov       %rdi,	[%r12+72]
    test      %rdi,	%rdi
    jz        L4539
    mov       %rax,	[%rdi+8]
    test      %rax,	%rax
    jnz       L4539
    movzx     %rax,	byte ptr[%rdi+21]
    cmp       %rax,	59
    jz        L4542
    movzx     %rax,	byte ptr[%rdi+21]
    cmp       %rax,	60
    jnz       L4541
L4542:
    mov       %rax,	1
    jmp       L4532
L4541:
L4539:
    xor       %eax,	%eax
L4532:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readmodule
cc_parse.readmodule:
#?>>
    .set cc_parse.readmodule.linkage, -8
    .set cc_parse.readmodule.wasdef, -16
    .set cc_parse.readmodule.d, -24
    .set cc_parse.readmodule.pm, -32
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	64
#---------------
    jmp       L4545
L4544:
    xor       %r12,	%r12
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	9
    jnz       L4549
L4548:
    lea       %rcx,	[%rip+L8992]
    call      cc_support.serror
L4549:
L4547:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %r13,	%rax
    xor       %r14,	%r14
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	70
    jnz       L4551
    call      cc_parse.readdllexport
    mov       %r14,	%rax
L4551:
    mov       %rcx,	[%rip+cc_decls.stmodule]
    lea       %rdx,	[%rbp + cc_parse.readmodule.linkage]
    call      cc_parse.readdeclspec
    mov       %rbx,	%rax
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	70
    jnz       L4553
    call      cc_parse.readdllexport
    mov       %r14,	%rax
L4553:
    xor       %rsi,	%rsi
L4554:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L4556
    cmp       %rax,	25
    jz        L4556
    cmp       %rax,	13
    jnz       L4557
L4556:
    inc       %r12
    mov       %rcx,	[%rip+cc_decls.stmodule]
    lea       %rdx,	[%rbp + cc_parse.readmodule.d]
    mov       %r8,	%rbx
    lea       %r9,	[%rbp + cc_parse.readmodule.pm]
    call      cc_parse.readtype
    mov       %rdi,	%rax
    mov       %rax,	[%rbp + cc_parse.readmodule.d]
    test      %rax,	%rax
    jnz       L4559
    lea       %rcx,	[%rip+L8993]
    call      cc_support.serror
L4559:
    mov       %rax,	[%rbp + cc_parse.readmodule.linkage]
    cmp       %rax,	5
    jnz       L4561
    mov       %rax,	[%rbp + cc_parse.readmodule.pm]
    test      %rax,	%rax
    jz        L4563
    mov       %rcx,	%rdi
    mov       %rdx,	[%rbp + cc_parse.readmodule.pm]
    call      cc_lib.createprocmode
    mov       %rdi,	%rax
L4563:
    mov       %rcx,	[%rip+cc_decls.stmodule]
    mov       %rdx,	[%rbp + cc_parse.readmodule.d]
    mov       %r8,	%rdi
    call      cc_parse.createtypedef
    mov       [%rbp + cc_parse.readmodule.d],	%rax
    jmp       L4560
L4561:
    mov       %rax,	[%rbp + cc_parse.readmodule.pm]
    test      %rax,	%rax
    jz        L4564
#cc_parse.readmodule.readfn:
L4565:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	17
    jnz       L4567
    test      %rsi,	%rsi
    jz        L4567
    lea       %rcx,	[%rip+L8994]
    call      cc_support.serror
L4567:
    mov       %rax,	%r14
    push      %rax
    lea       %rax,	[%rbp + cc_parse.readmodule.wasdef]
    push      %rax
    mov       %rcx,	[%rbp + cc_parse.readmodule.d]
    mov       %rdx,	%rdi
    mov       %r8,	[%rbp + cc_parse.readmodule.linkage]
    mov       %r9,	[%rbp + cc_parse.readmodule.pm]
    sub       %rsp,	32
    call      cc_parse.readfunction
    add       %rsp,	48
    mov       [%rbp + cc_parse.readmodule.d],	%rax
    mov       %rax,	[%rbp + cc_parse.readmodule.wasdef]
    test      %rax,	%rax
    jnz       L4555
L4569:
    jmp       L4560
L4564:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	14
    jnz       L4570
    lea       %rax,	[%rip+cc_decls.ttparams]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    mov       [%rbp + cc_parse.readmodule.pm],	%rax
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rdi,	%rax
    jmp       L4565
L4570:
    mov       %rcx,	[%rbp + cc_parse.readmodule.d]
    mov       %rdx,	%rdi
    mov       %r8,	[%rbp + cc_parse.readmodule.linkage]
    call      cc_parse.readmodulevar
    mov       [%rbp + cc_parse.readmodule.d],	%rax
L4560:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jnz       L4573
L4572:
    mov       %rsi,	1
    call      cc_lex.lex
    jmp       L4571
L4573:
    mov       %rcx,	9
    call      cc_lib.skipsymbol
    jmp       L4555
L4571:
    jmp       L4554
L4557:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	12
    jz        L4575
    cmp       %rax,	18
    jz        L4575
    cmp       %rax,	19
    jz        L4575
    cmp       %rax,	3
    jz        L4576
    jmp       L4577
L4575:
    mov       %rcx,	9
    call      cc_lib.skipsymbol
    jmp       L4555
L4576:
    mov       %rcx,	9
    call      cc_lib.skipsymbol
    jmp       L4555
L4577:
    mov       %rcx,	%rbx
    call      cc_lib.typename
    lea       %rcx,	[%rip+L8995]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L4574:
    jmp       L4554
L4555:
L4545:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	57
    jnz       L4544
#---------------
    add       %rsp,	64
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.parsemodule
cc_parse.parsemodule:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    movzx     %rax,	byte ptr[%rip+cc_cli.fverbose]
    cmp       %rax,	3
    jnz       L4580
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8996]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+cc_decls.inputfile]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L4580:
    xor       %eax,	%eax
    mov       [%rip+cc_parse.ingeneric],	%al
    mov       [%rip+cc_parse.loopindex],	%rax
    xor       %eax,	%eax
    mov       [%rip+cc_parse.ist_symptr],	%rax
    lea       %rcx,	[%rip+cc_parse.casevaluestack]
    xor       %edx,	%edx
    mov       %r8,	512
    call      memset
    lea       %rcx,	[%rip+L8997]
    mov       %rdx,	[%rip+cc_decls.mainfileno]
    call      cc_lex.startlex
    mov       %rdi,	[%rip+cc_decls.stmodule]
    xor       %eax,	%eax
    mov       [%rip+cc_decls.currproc],	%rax
    xor       %eax,	%eax
    mov       [%rip+cc_parse.loopindex],	%rax
    call      cc_lex.lex
    call      cc_parse.readmodule
    call      cc_lex.endlex
    mov       %rax,	1
L4578:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readdeclspec
cc_parse.readdeclspec:
#?>>
    .set cc_parse.readdeclspec.d, -16
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %r13,	%rcx
    mov       %r14,	%rdx
#---------------
    lea       %rcx,	[%rbp + cc_parse.readdeclspec.d]
    xor       %edx,	%edx
    mov       %r8,	15
    call      memset
    mov       %eax,	20
    mov       [%rbp + cc_parse.readdeclspec.d],	%eax
    xor       %eax,	%eax
    mov       %rbx,	%rax
    mov       %r12,	%rax
L4582:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    sub       %rax,	67
    cmp       %rax,	25
    jae       L4585
    lea       %r10,	[%rip+L4584]
    jmp       [%r10 + %rax*8]
    .data
L4584:
    .quad     L4635
    .quad     L4585
    .quad     L4585
    .quad     L4585
    .quad     L4587
    .quad     L4585
    .quad     L4585
    .quad     L4585
    .quad     L4585
    .quad     L4585
    .quad     L4585
    .quad     L4585
    .quad     L4585
    .quad     L4585
    .quad     L4585
    .quad     L4585
    .quad     L4585
    .quad     L4629
    .quad     L4629
    .quad     L4622
    .quad     L4614
    .quad     L4586
    .quad     L4625
    .quad     L4585
    .quad     L4632
    .text
L4586:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+22]
    mov       [%rbp + cc_parse.readdeclspec.d],	%eax
    call      cc_lex.lex
    jmp       L4582
L4587:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+22]
    sub       %rax,	1
    cmp       %rax,	10
    jae       L4590
    lea       %r10,	[%rip+L4589]
    jmp       [%r10 + %rax*8]
    .data
L4589:
    .quad     L4591
    .quad     L4591
    .quad     L4597
    .quad     L4601
    .quad     L4591
    .quad     L4591
    .quad     L4591
    .quad     L4606
    .quad     L4610
    .quad     L4591
    .text
L4591:
    movsxd    %rax,	dword ptr[%rbp + cc_parse.readdeclspec.d]
    cmp       %rax,	20
    jz        L4593
    test      %r12,	%r12
    jz        L4595
    mov       %rcx,	9
    call      cc_lib.checksymbol
    jmp       L4594
L4595:
    jmp       L4596
L4594:
L4593:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+22]
    lea       %r10,	[%rip+cc_tables.typespectypes]
    mov       %r10d,	[%r10 + %rax*4-4]
    mov       [%rbp + cc_parse.readdeclspec.d],	%r10d
    jmp       L4588
L4597:
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+9]
    test      %al,	%al
    jnz       L4600
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+10]
    test      %al,	%al
    jnz       L4600
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+11]
    test      %al,	%al
    jz        L4599
L4600:
    jmp       L4596
L4599:
    mov       %rax,	1
    mov       %rbx,	%rax
    mov       [%rbp + cc_parse.readdeclspec.d+9],	%al
    jmp       L4588
L4601:
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+11]
    test      %al,	%al
    jnz       L4604
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+9]
    test      %al,	%al
    jz        L4603
L4604:
    jmp       L4596
L4603:
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+10]
    test      %al,	%al
    jz        L4605
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readdeclspec.d+10],	%al
    mov       %al,	1
    mov       [%rbp + cc_parse.readdeclspec.d+11],	%al
    jmp       L4602
L4605:
    mov       %al,	1
    mov       [%rbp + cc_parse.readdeclspec.d+10],	%al
L4602:
    mov       %rbx,	1
    jmp       L4588
L4606:
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+12]
    test      %al,	%al
    jnz       L4609
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+13]
    test      %al,	%al
    jz        L4608
L4609:
    jmp       L4596
L4608:
    mov       %rax,	1
    mov       %rbx,	%rax
    mov       [%rbp + cc_parse.readdeclspec.d+12],	%al
    jmp       L4588
L4610:
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+12]
    test      %al,	%al
    jnz       L4613
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+13]
    test      %al,	%al
    jz        L4612
L4613:
    jmp       L4596
L4612:
    mov       %rax,	1
    mov       %rbx,	%rax
    mov       [%rbp + cc_parse.readdeclspec.d+13],	%al
    jmp       L4588
L4590:
#cc_parse.readdeclspec.tserror:
L4596:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+22]
    lea       %r10,	[%rip+cc_tables.typespecnames]
    mov       %r10,	[%r10 + %rax*8-8]
    lea       %rcx,	[%rip+L8998]
    mov       %rdx,	%r10
    call      cc_support.serror_s
L4588:
    call      cc_lex.lex
    jmp       L4582
L4614:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+22]
    cmp       %rax,	1
    jz        L4616
    cmp       %rax,	2
    jz        L4617
    cmp       %rax,	3
    jz        L4618
    jmp       L4619
L4616:
    mov       %al,	[%rip+pc_decls.fnoconst]
    test      %al,	%al
    jnz       L4621
    mov       %al,	1
    mov       [%rbp + cc_parse.readdeclspec.d+4],	%al
L4621:
    jmp       L4615
L4617:
    mov       %al,	1
    mov       [%rbp + cc_parse.readdeclspec.d+5],	%al
    jmp       L4615
L4618:
    mov       %al,	1
    mov       [%rbp + cc_parse.readdeclspec.d+6],	%al
L4619:
L4615:
    call      cc_lex.lex
    jmp       L4582
L4622:
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+7]
    test      %al,	%al
    jz        L4624
    lea       %rcx,	[%rip+L8999]
    call      cc_support.serror
L4624:
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %al,	[%rax+22]
    mov       [%rbp + cc_parse.readdeclspec.d+7],	%al
    call      cc_lex.lex
    jmp       L4582
L4625:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+22]
    cmp       %rax,	1
    jnz       L4628
L4627:
    mov       %al,	1
    mov       [%rbp + cc_parse.readdeclspec.d+8],	%al
L4628:
L4626:
    call      cc_lex.lex
    jmp       L4582
L4629:
    movsxd    %rax,	dword ptr[%rbp + cc_parse.readdeclspec.d]
    cmp       %rax,	20
    jz        L4631
    lea       %rcx,	[%rip+L9000]
    call      cc_support.serror
L4631:
    mov       %rcx,	%r13
    call      cc_parse.readstructdecl
    mov       [%rbp + cc_parse.readdeclspec.d],	%eax
    mov       %al,	1
    mov       [%rbp + cc_parse.readdeclspec.d+14],	%al
    mov       %r12,	1
    jmp       L4582
L4632:
    movsxd    %rax,	dword ptr[%rbp + cc_parse.readdeclspec.d]
    cmp       %rax,	20
    jz        L4634
    lea       %rcx,	[%rip+L9001]
    call      cc_support.serror
L4634:
    mov       %rcx,	%r13
    call      cc_parse.readenumdecl
    mov       %eax,	3
    mov       [%rbp + cc_parse.readdeclspec.d],	%eax
    mov       %al,	1
    mov       [%rbp + cc_parse.readdeclspec.d+14],	%al
    jmp       L4582
L4635:
    movsxd    %rax,	dword ptr[%rbp + cc_parse.readdeclspec.d]
    cmp       %rax,	20
    jnz       L4637
    mov       %rcx,	%r13
    call      cc_parse.isusertype
    mov       %rsi,	%rax
    cmp       %rax,	20
    jz        L4637
    test      %rbx,	%rbx
    jz        L4639
    mov       %eax,	3
    mov       [%rbp + cc_parse.readdeclspec.d],	%eax
    jmp       L4583
L4639:
    mov       [%rbp + cc_parse.readdeclspec.d],	%esi
    mov       %al,	1
    mov       [%rbp + cc_parse.readdeclspec.d+14],	%al
    call      cc_lex.lex
    jmp       L4636
L4637:
    movsxd    %rax,	dword ptr[%rbp + cc_parse.readdeclspec.d]
    cmp       %rax,	20
    jnz       L4641
    test      %rbx,	%rbx
    jnz       L4641
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       %rax,	[%rax]
    lea       %rcx,	[%rip+L9002]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L4641:
    movsxd    %rax,	dword ptr[%rbp + cc_parse.readdeclspec.d]
    cmp       %rax,	20
    jnz       L4643
    mov       %eax,	3
    mov       [%rbp + cc_parse.readdeclspec.d],	%eax
L4643:
    jmp       L4583
L4636:
    jmp       L4582
L4585:
    jmp       L4583
L4583:
    movsxd    %rax,	dword ptr[%rbp + cc_parse.readdeclspec.d]
    cmp       %rax,	20
    jz        L4645
    movsxd    %rax,	dword ptr[%rbp + cc_parse.readdeclspec.d]
    jmp       L4644
L4645:
    mov       %rax,	3
L4644:
    mov       %rdi,	%rax
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+14]
    test      %al,	%al
    jnz       L4647
    mov       %rax,	%rdi
    cmp       %rax,	3
    jz        L4649
    cmp       %rax,	1
    jz        L4650
    cmp       %rax,	11
    jz        L4651
    jmp       L4652
L4649:
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+9]
    test      %al,	%al
    jz        L4654
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+13]
    test      %al,	%al
    jz        L4656
    mov       %rax,	7
    jmp       L4655
L4656:
    mov       %rax,	2
L4655:
    mov       %rdi,	%rax
    jmp       L4653
L4654:
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+10]
    test      %al,	%al
    jz        L4657
    mov       %al,	[%rip+pc_decls.flong64]
    test      %al,	%al
    jz        L4659
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+13]
    test      %al,	%al
    jz        L4661
    mov       %rax,	9
    jmp       L4660
L4661:
    mov       %rax,	4
L4660:
    mov       %rdi,	%rax
    jmp       L4658
L4659:
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+13]
    test      %al,	%al
    jz        L4663
    mov       %rax,	8
    jmp       L4662
L4663:
    mov       %rax,	3
L4662:
    mov       %rdi,	%rax
L4658:
    jmp       L4653
L4657:
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+11]
    test      %al,	%al
    jz        L4664
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+13]
    test      %al,	%al
    jz        L4666
    mov       %rax,	9
    jmp       L4665
L4666:
    mov       %rax,	4
L4665:
    mov       %rdi,	%rax
    jmp       L4653
L4664:
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+13]
    test      %al,	%al
    jz        L4667
    mov       %rdi,	8
L4667:
L4653:
    jmp       L4648
L4650:
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+9]
    test      %al,	%al
    jnz       L4670
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+10]
    test      %al,	%al
    jnz       L4670
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+11]
    test      %al,	%al
    jz        L4669
L4670:
    lea       %rcx,	[%rip+L9003]
    call      cc_support.serror
L4669:
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+13]
    test      %al,	%al
    jz        L4672
    mov       %rax,	6
    jmp       L4671
L4672:
    mov       %rax,	1
L4671:
    mov       %rdi,	%rax
    jmp       L4648
L4651:
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+9]
    test      %al,	%al
    jnz       L4675
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+11]
    test      %al,	%al
    jnz       L4675
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+12]
    test      %al,	%al
    jnz       L4675
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+13]
    test      %al,	%al
    jz        L4674
L4675:
    lea       %rcx,	[%rip+L9004]
    call      cc_support.serror
L4674:
    jmp       L4648
L4652:
    test      %rbx,	%rbx
    jz        L4677
    lea       %rcx,	[%rip+L9005]
    call      cc_support.serror
L4677:
L4648:
L4647:
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+4]
    test      %al,	%al
    jz        L4679
    mov       %rcx,	%rdi
    call      cc_lib.createconstmode
    mov       %rdi,	%rax
L4679:
    movzx     %rax,	byte ptr[%rbp + cc_parse.readdeclspec.d+7]
    mov       [%r14],	%rax
    mov       %rax,	%rdi
L4581:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.istypestarter
cc_parse.istypestarter:
#?>>
    .set cc_parse.istypestarter.$T3, -8
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
#---------------
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	71
    jz        L4682
    cmp       %rax,	88
    jz        L4682
    cmp       %rax,	87
    jz        L4683
    cmp       %rax,	67
    jz        L4684
    cmp       %rax,	84
    jz        L4685
    cmp       %rax,	85
    jz        L4685
    cmp       %rax,	91
    jz        L4685
    jmp       L4686
L4682:
    mov       %rax,	1
    jmp       L4680
L4683:
    mov       %rax,	1
    jmp       L4680
L4684:
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       [%rbp + cc_parse.istypestarter.$T3],	%rax
    mov       %rax,	[%rip+cc_decls.currproc]
    test      %rax,	%rax
    jz        L4688
    mov       %rax,	[%rip+cc_decls.currproc]
    jmp       L4687
L4688:
    mov       %rax,	[%rip+cc_decls.stmodule]
L4687:
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + cc_parse.istypestarter.$T3]
    mov       %r8,	1
    mov       %r9,	[%rip+cc_decls.currblockno]
    call      cc_lib.resolvename
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L4690
    mov       %rax,	%rdi
    lea       %r10,	[%rip+cc_decls.lx]
    mov       [%r10],	%rax
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	5
    setz      %al
    movzx     %eax,	%al
    jmp       L4680
L4690:
    jmp       L4681
L4685:
    mov       %rax,	1
    jmp       L4680
L4686:
L4681:
    xor       %eax,	%eax
L4680:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc cc_parse.istypestarter_next
cc_parse.istypestarter_next:
#?>>
    .set cc_parse.istypestarter_next.$T3, -8
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
#---------------
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	71
    jz        L4693
    cmp       %rax,	88
    jz        L4693
    cmp       %rax,	87
    jz        L4694
    cmp       %rax,	67
    jz        L4695
    cmp       %rax,	84
    jz        L4696
    cmp       %rax,	85
    jz        L4696
    cmp       %rax,	91
    jz        L4696
    jmp       L4697
L4693:
    mov       %rax,	1
    jmp       L4691
L4694:
    mov       %rax,	1
    jmp       L4691
L4695:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    mov       [%rbp + cc_parse.istypestarter_next.$T3],	%rax
    mov       %rax,	[%rip+cc_decls.currproc]
    test      %rax,	%rax
    jz        L4699
    mov       %rax,	[%rip+cc_decls.currproc]
    jmp       L4698
L4699:
    mov       %rax,	[%rip+cc_decls.stmodule]
L4698:
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + cc_parse.istypestarter_next.$T3]
    mov       %r8,	1
    mov       %r9,	[%rip+cc_decls.currblockno]
    call      cc_lib.resolvename
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L4701
    mov       %rax,	%rdi
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10],	%rax
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	5
    setz      %al
    movzx     %eax,	%al
    jmp       L4691
L4701:
    jmp       L4692
L4696:
    mov       %rax,	1
    jmp       L4691
L4697:
L4692:
    xor       %eax,	%eax
L4691:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readexpression
cc_parse.readexpression:
#?>>
    .set cc_parse.readexpression.ulist, -8
    .set cc_parse.readexpression.ulistx, -16
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	56
#---------------
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	9
    jz        L4704
    cmp       %rax,	14
    jnz       L4705
L4704:
    call      cc_parse.readterm
    jmp       L4702
L4705:
L4703:
    call      cc_parse.readassignexpr
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jnz       L4707
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readexpression.ulistx],	%rax
    mov       [%rbp + cc_parse.readexpression.ulist],	%rax
L4708:
    lea       %rcx,	[%rbp + cc_parse.readexpression.ulist]
    lea       %rdx,	[%rbp + cc_parse.readexpression.ulistx]
    mov       %r8,	%rdi
    call      cc_lib.addlistunit
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jnz       L4709
L4711:
    call      cc_lex.lex
    call      cc_parse.readassignexpr
    mov       %rdi,	%rax
    jmp       L4708
L4709:
    mov       %rcx,	29
    mov       %rdx,	[%rbp + cc_parse.readexpression.ulist]
    call      cc_lib.createunit1
    mov       %rdi,	%rax
    mov       %rax,	[%rbp + cc_parse.readexpression.ulistx]
    test      %rax,	%rax
    jz        L4713
    mov       %rax,	[%rbp + cc_parse.readexpression.ulistx]
    mov       %eax,	[%rax+52]
    mov       [%rdi+52],	%eax
L4713:
    mov       %rax,	%rdi
    jmp       L4702
L4707:
    mov       %rax,	%rdi
L4702:
#---------------
    add       %rsp,	56
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readassignexpr
cc_parse.readassignexpr:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
#---------------
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jz        L4716
    cmp       %rax,	9
    jz        L4716
    cmp       %rax,	14
    jz        L4716
    cmp       %rax,	11
    jz        L4717
    jmp       L4718
L4716:
    call      cc_parse.readterm
    jmp       L4714
L4717:
    call      cc_parse.readterm
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %r12,	%rax
    jmp       L4719
L4718:
L4715:
    call      cc_parse.readcondexpr
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %r12,	%rax
    sub       %rax,	11
    cmp       %rax,	45
    jae       L4722
    lea       %r10,	[%rip+L4721]
    jmp       [%r10 + %rax*8]
    .data
L4721:
    .quad     L4723
    .quad     L4722
    .quad     L4722
    .quad     L4722
    .quad     L4722
    .quad     L4722
    .quad     L4722
    .quad     L4722
    .quad     L4722
    .quad     L4722
    .quad     L4722
    .quad     L4722
    .quad     L4722
    .quad     L4722
    .quad     L4722
    .quad     L4722
    .quad     L4722
    .quad     L4722
    .quad     L4722
    .quad     L4722
    .quad     L4722
    .quad     L4722
    .quad     L4722
    .quad     L4722
    .quad     L4722
    .quad     L4722
    .quad     L4722
    .quad     L4722
    .quad     L4722
    .quad     L4722
    .quad     L4722
    .quad     L4722
    .quad     L4722
    .quad     L4722
    .quad     L4722
    .quad     L4723
    .quad     L4723
    .quad     L4723
    .quad     L4723
    .quad     L4723
    .quad     L4723
    .quad     L4723
    .quad     L4723
    .quad     L4723
    .quad     L4723
    .text
L4723:
#cc_parse.readassignexpr.gotp:
L4719:
    call      cc_lex.lex
    movsxd    %rax,	dword ptr[%rdi+52]
    mov       %r13,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      cc_parse.checklvalue
    call      cc_parse.readassignexpr
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%rdi+52]
    lea       %r10,	[%rip+cc_decls.ttisref]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L4725
    mov       %rcx,	%r12
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      cc_parse.createassignopref
    jmp       L4714
L4725:
    mov       %rcx,	%rbx
    mov       %rdx,	%r13
    call      cc_parse.coercemode
    mov       %rbx,	%rax
    lea       %rax,	[%rip+cc_decls.ttconst]
    mov       %r10,	%r13
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L4727
    lea       %rcx,	[%rip+L9006]
    call      cc_support.terror
L4727:
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	52
    jnz       L4729
    mov       %rax,	[%rdi+16]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L4729
    lea       %rcx,	[%rip+L9007]
    call      cc_support.terror
L4729:
    lea       %rax,	[%rip+cc_tables.symboltojtag]
    mov       %r10,	%r12
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      cc_lib.createunit2
    mov       %rsi,	%rax
    mov       [%rsi+52],	%r13d
    mov       %rax,	%rsi
    jmp       L4714
L4722:
L4720:
    mov       %rax,	%rdi
L4714:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readcondexpr
cc_parse.readcondexpr:
#?>>
    .set cc_parse.readcondexpr.u, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
#---------------
    call      cc_parse.readorlexpr
    mov       %rsi,	%rax
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	19
    jnz       L4732
    mov       %rcx,	%rsi
    call      cc_parse.coercecond
    call      cc_lex.lex
    call      cc_parse.readexpression
    mov       %rdi,	%rax
    mov       %rcx,	10
    call      cc_lib.skipsymbol
    call      cc_parse.readcondexpr
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%rdi+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %r12,	%r10
    lea       %rax,	[%rip+cc_tables.dominantmode]
    mov       %r11,	%r10
    shl       %r11,	5
    lea       %rax,	[%rax + %r11]
    movsxd    %r10,	dword ptr[%rbx+52]
    lea       %r11,	[%rip+cc_decls.ttbasetype]
    movsx     %r11,	word ptr[%r11 + %r10*2]
    mov       %r13,	%r11
    movzx     %rax,	byte ptr[%rax + %r11]
    mov       [%rbp + cc_parse.readcondexpr.u],	%rax
    test      %rax,	%rax
    jz        L4734
    mov       %rcx,	%rdi
    mov       %rdx,	[%rbp + cc_parse.readcondexpr.u]
    call      cc_parse.coercemode
    mov       %rdi,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	[%rbp + cc_parse.readcondexpr.u]
    call      cc_parse.coercemode
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%rsi+40]
    cmp       %rax,	1
    jnz       L4736
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	1
    jnz       L4736
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L4736
    mov       %rax,	[%rsi]
    test      %rax,	%rax
    jz        L4738
    mov       %rax,	%rdi
    jmp       L4737
L4738:
    mov       %rax,	%rbx
L4737:
    jmp       L4730
L4736:
    jmp       L4733
L4734:
    cmp       %r12,	13
    jnz       L4739
    cmp       %r13,	13
    jnz       L4739
    movsxd    %rax,	dword ptr[%rdi+52]
    mov       [%rbp + cc_parse.readcondexpr.u],	%rax
    jmp       L4733
L4739:
    cmp       %r12,	13
    jnz       L4740
    cmp       %r13,	3
    jnz       L4740
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L4740
    mov       %rax,	[%rbx]
    test      %rax,	%rax
    jnz       L4740
    movsxd    %rax,	dword ptr[%rdi+52]
    mov       [%rbp + cc_parse.readcondexpr.u],	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	[%rbp + cc_parse.readcondexpr.u]
    call      cc_parse.coercemode
    jmp       L4733
L4740:
    cmp       %r12,	3
    jnz       L4741
    cmp       %r13,	13
    jnz       L4741
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	1
    jnz       L4741
    mov       %rax,	[%rdi]
    test      %rax,	%rax
    jnz       L4741
    movsxd    %rax,	dword ptr[%rbx+52]
    mov       [%rbp + cc_parse.readcondexpr.u],	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	[%rbp + cc_parse.readcondexpr.u]
    call      cc_parse.coercemode
    jmp       L4733
L4741:
    cmp       %r12,	18
    jnz       L4742
    cmp       %r13,	18
    jnz       L4742
    movsxd    %rax,	dword ptr[%rdi+52]
    mov       [%rbp + cc_parse.readcondexpr.u],	%rax
    jmp       L4733
L4742:
    cmp       %r12,	19
    jnz       L4743
    cmp       %r13,	19
    jnz       L4743
    movsxd    %rax,	dword ptr[%rdi+52]
    mov       [%rbp + cc_parse.readcondexpr.u],	%rax
    jmp       L4733
L4743:
    mov       %rax,	%r13
    cmp       %rax,	%r12
    jnz       L4744
    test      %rax,	%rax
    jnz       L4744
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readcondexpr.u],	%rax
    jmp       L4733
L4744:
    call      msys.m$print_startcon
    movsxd    %rax,	dword ptr[%rdi+52]
    mov       %rcx,	%rax
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    movsxd    %rax,	dword ptr[%rbx+52]
    mov       %rcx,	%rax
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L9008]
    call      cc_support.terror
L4733:
    mov       %rcx,	31
    mov       %rdx,	%rsi
    mov       %r8,	%rdi
    mov       %r9,	%rbx
    call      cc_lib.createunit3
    mov       %rsi,	%rax
    mov       %eax,	[%rbp + cc_parse.readcondexpr.u]
    mov       [%rsi+52],	%eax
L4732:
    mov       %rax,	%rsi
L4730:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readorlexpr
cc_parse.readorlexpr:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
    call      cc_parse.readandlexpr
    mov       %rdi,	%rax
    jmp       L4747
L4746:
    call      cc_lex.lex
    call      cc_parse.readandlexpr
    mov       %rbx,	%rax
    mov       %rcx,	%rdi
    call      cc_parse.coercecond
    mov       %rcx,	%rbx
    call      cc_parse.coercecond
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	1
    jnz       L4750
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L4750
    mov       %rax,	[%rdi]
    test      %rax,	%rax
    jnz       L4753
    mov       %rax,	[%rbx]
    test      %rax,	%rax
    jz        L4752
L4753:
    mov       %rax,	1
    jmp       L4751
L4752:
    xor       %eax,	%eax
L4751:
    mov       [%rdi],	%rax
    jmp       L4747
L4750:
    mov       %rcx,	25
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       %eax,	3
    mov       [%rdi+52],	%eax
L4747:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	31
    jz        L4746
    mov       %rax,	%rdi
L4745:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readandlexpr
cc_parse.readandlexpr:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
    call      cc_parse.readiorexpr
    mov       %rdi,	%rax
    jmp       L4756
L4755:
    call      cc_lex.lex
    call      cc_parse.readiorexpr
    mov       %rbx,	%rax
    mov       %rcx,	%rdi
    call      cc_parse.coercecond
    mov       %rcx,	%rbx
    call      cc_parse.coercecond
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	1
    jnz       L4759
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L4759
    mov       %rax,	[%rdi]
    test      %rax,	%rax
    jz        L4761
    mov       %rax,	[%rbx]
    test      %rax,	%rax
    jz        L4761
    mov       %rax,	1
    jmp       L4760
L4761:
    xor       %eax,	%eax
L4760:
    mov       [%rdi],	%rax
    jmp       L4756
L4759:
    mov       %rcx,	24
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       %eax,	3
    mov       [%rdi+52],	%eax
L4756:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	32
    jz        L4755
    mov       %rax,	%rdi
L4754:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readiorexpr
cc_parse.readiorexpr:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
    call      cc_parse.readixorexpr
    mov       %rdi,	%rax
    jmp       L4764
L4763:
    call      cc_lex.lex
    call      cc_parse.readixorexpr
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%rdi+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    lea       %rax,	[%rip+cc_tables.dominantmode]
    mov       %r11,	%r10
    shl       %r11,	5
    lea       %rax,	[%rax + %r11]
    movsxd    %r10,	dword ptr[%rbx+52]
    lea       %r11,	[%rip+cc_decls.ttbasetype]
    movsx     %r11,	word ptr[%r11 + %r10*2]
    movzx     %rax,	byte ptr[%rax + %r11]
    mov       %rsi,	%rax
    test      %rax,	%rax
    jz        L4767
    cmp       %rsi,	10
    jl        L4769
    lea       %rcx,	[%rip+L9009]
    call      cc_support.terror
L4769:
    mov       %rcx,	%rdi
    mov       %rdx,	%rsi
    call      cc_parse.coercemode
    mov       %rdi,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      cc_parse.coercemode
    mov       %rbx,	%rax
    jmp       L4766
L4767:
    lea       %rcx,	[%rip+L9010]
    call      cc_support.terror
L4766:
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	1
    jnz       L4771
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L4771
    mov       %rax,	%rsi
    cmp       %rax,	3
    jz        L4773
    cmp       %rax,	4
    jz        L4773
    cmp       %rax,	8
    jz        L4773
    cmp       %rax,	9
    jnz       L4774
L4773:
    mov       %rax,	[%rbx]
    mov       %r10,	%rdi
    or        [%r10],	%rax
    jmp       L4764
L4774:
L4772:
L4771:
    mov       %rcx,	45
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%esi
L4764:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	28
    jz        L4763
    mov       %rax,	%rdi
L4762:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readixorexpr
cc_parse.readixorexpr:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
    call      cc_parse.readiandexpr
    mov       %rdi,	%rax
    jmp       L4777
L4776:
    call      cc_lex.lex
    call      cc_parse.readiandexpr
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%rdi+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    lea       %rax,	[%rip+cc_tables.dominantmode]
    mov       %r11,	%r10
    shl       %r11,	5
    lea       %rax,	[%rax + %r11]
    movsxd    %r10,	dword ptr[%rbx+52]
    lea       %r11,	[%rip+cc_decls.ttbasetype]
    movsx     %r11,	word ptr[%r11 + %r10*2]
    movzx     %rax,	byte ptr[%rax + %r11]
    mov       %rsi,	%rax
    test      %rax,	%rax
    jz        L4780
    cmp       %rsi,	10
    jl        L4782
    lea       %rcx,	[%rip+L9011]
    call      cc_support.terror
L4782:
    mov       %rcx,	%rdi
    mov       %rdx,	%rsi
    call      cc_parse.coercemode
    mov       %rdi,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      cc_parse.coercemode
    mov       %rbx,	%rax
    jmp       L4779
L4780:
    lea       %rcx,	[%rip+L9012]
    call      cc_support.terror
L4779:
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	1
    jnz       L4784
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L4784
    mov       %rax,	%rsi
    cmp       %rax,	3
    jz        L4786
    cmp       %rax,	4
    jz        L4786
    cmp       %rax,	8
    jz        L4786
    cmp       %rax,	9
    jnz       L4787
L4786:
    mov       %rax,	[%rbx]
    mov       %r10,	%rdi
    xor       [%r10],	%rax
    jmp       L4777
L4787:
L4785:
L4784:
    mov       %rcx,	46
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%esi
L4777:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	30
    jz        L4776
    mov       %rax,	%rdi
L4775:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readiandexpr
cc_parse.readiandexpr:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
    call      cc_parse.readeqexpr
    mov       %rdi,	%rax
    jmp       L4790
L4789:
    call      cc_lex.lex
    call      cc_parse.readeqexpr
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%rdi+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    lea       %rax,	[%rip+cc_tables.dominantmode]
    mov       %r11,	%r10
    shl       %r11,	5
    lea       %rax,	[%rax + %r11]
    movsxd    %r10,	dword ptr[%rbx+52]
    lea       %r11,	[%rip+cc_decls.ttbasetype]
    movsx     %r11,	word ptr[%r11 + %r10*2]
    movzx     %rax,	byte ptr[%rax + %r11]
    mov       %rsi,	%rax
    test      %rax,	%rax
    jz        L4793
    cmp       %rsi,	10
    jl        L4795
    lea       %rcx,	[%rip+L9013]
    call      cc_support.terror
L4795:
    mov       %rcx,	%rdi
    mov       %rdx,	%rsi
    call      cc_parse.coercemode
    mov       %rdi,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      cc_parse.coercemode
    mov       %rbx,	%rax
    jmp       L4792
L4793:
    call      msys.m$print_startcon
    movsxd    %rax,	dword ptr[%rdi+52]
    mov       %rcx,	%rax
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    movsxd    %rax,	dword ptr[%rbx+52]
    mov       %rcx,	%rax
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L9014]
    call      cc_support.terror
L4792:
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	1
    jnz       L4797
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L4797
    mov       %rax,	%rsi
    cmp       %rax,	3
    jz        L4799
    cmp       %rax,	4
    jz        L4799
    cmp       %rax,	8
    jz        L4799
    cmp       %rax,	9
    jnz       L4800
L4799:
    mov       %rax,	[%rbx]
    mov       %r10,	%rdi
    and       [%r10],	%rax
    jmp       L4790
L4800:
L4798:
L4797:
    mov       %rcx,	44
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%esi
L4790:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	29
    jz        L4789
    mov       %rax,	%rdi
L4788:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readeqexpr
cc_parse.readeqexpr:
#?>>
    .set cc_parse.readeqexpr.ss, -8
    .set cc_parse.readeqexpr.tt, -16
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
#---------------
    call      cc_parse.readrelexpr
    mov       %rdi,	%rax
    jmp       L4803
L4802:
    call      cc_lex.lex
    call      cc_parse.readrelexpr
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%rdi+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %r12,	%r10
    lea       %rax,	[%rip+cc_tables.dominantmode]
    mov       %r11,	%r10
    shl       %r11,	5
    lea       %rax,	[%rax + %r11]
    movsxd    %r10,	dword ptr[%rbx+52]
    lea       %r11,	[%rip+cc_decls.ttbasetype]
    movsx     %r11,	word ptr[%r11 + %r10*2]
    mov       %r13,	%r11
    movzx     %rax,	byte ptr[%rax + %r11]
    mov       %r14,	%rax
    test      %rax,	%rax
    jz        L4806
    mov       %rcx,	%rdi
    mov       %rdx,	%r14
    call      cc_parse.coercemode
    mov       %rdi,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	%r14
    call      cc_parse.coercemode
    mov       %rbx,	%rax
    jmp       L4805
L4806:
    cmp       %r12,	13
    jnz       L4807
    cmp       %r13,	13
    jnz       L4807
    movsxd    %rax,	dword ptr[%rdi+52]
    lea       %r10,	[%rip+cc_decls.tttarget]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       [%rbp + cc_parse.readeqexpr.ss],	%r10
    movsxd    %rax,	dword ptr[%rbx+52]
    lea       %r11,	[%rip+cc_decls.tttarget]
    movsx     %r11,	word ptr[%r11 + %rax*2]
    mov       [%rbp + cc_parse.readeqexpr.tt],	%r11
    cmp       %r10,	%r11
    jz        L4809
    mov       %rax,	[%rbp + cc_parse.readeqexpr.ss]
    test      %rax,	%rax
    jz        L4811
    mov       %rax,	[%rbp + cc_parse.readeqexpr.tt]
    test      %rax,	%rax
    jz        L4811
    movsxd    %rax,	dword ptr[%rbx+52]
    movsxd    %r10,	dword ptr[%rdi+52]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    mov       %r8,	1
    call      cc_parse.checkpointertypes
    test      %rax,	%rax
    jnz       L4813
    lea       %rcx,	[%rip+L9015]
    call      cc_support.terror
L4813:
L4811:
L4809:
    jmp       L4805
L4807:
    cmp       %r12,	13
    jnz       L4814
    cmp       %r13,	3
    jnz       L4814
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L4817
    mov       %rax,	[%rbx]
    test      %rax,	%rax
    jz        L4816
L4817:
    lea       %rcx,	[%rip+L9016]
    call      cc_support.terror
L4816:
    jmp       L4805
L4814:
    cmp       %r12,	3
    jnz       L4818
    cmp       %r13,	13
    jnz       L4818
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	1
    jnz       L4821
    mov       %rax,	[%rdi]
    test      %rax,	%rax
    jz        L4820
L4821:
    lea       %rcx,	[%rip+L9017]
    call      cc_support.terror
L4820:
    jmp       L4805
L4818:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L9018]
    call      msys.m$print_str_nf
    mov       %rcx,	%r14
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L9019]
    call      cc_support.terror
L4805:
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	1
    jnz       L4823
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L4823
    mov       %rax,	%r14
    cmp       %rax,	3
    jz        L4825
    cmp       %rax,	4
    jz        L4825
    cmp       %rax,	8
    jz        L4825
    cmp       %rax,	9
    jz        L4825
    test      %rax,	%rax
    jnz       L4826
L4825:
    cmp       %rsi,	40
    jnz       L4828
    mov       %rax,	[%rdi]
    mov       %r10,	[%rbx]
    cmp       %rax,	%r10
    setz      %al
    movzx     %eax,	%al
    mov       [%rdi],	%rax
    jmp       L4827
L4828:
    mov       %rax,	[%rdi]
    mov       %r10,	[%rbx]
    cmp       %rax,	%r10
    setnz     %al
    movzx     %eax,	%al
    mov       [%rdi],	%rax
L4827:
    jmp       L4803
L4826:
L4824:
L4823:
    lea       %rax,	[%rip+cc_tables.symboltojtag]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       %eax,	3
    mov       [%rdi+52],	%eax
L4803:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %rsi,	%rax
    cmp       %rax,	40
    jz        L4802
    cmp       %rsi,	41
    jz        L4802
    mov       %rax,	%rdi
L4801:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readrelexpr
cc_parse.readrelexpr:
#?>>
    .set cc_parse.readrelexpr.a, -8
    .set cc_parse.readrelexpr.b, -16
    .set cc_parse.readrelexpr.c, -24
    .set cc_parse.readrelexpr.aa, -32
    .set cc_parse.readrelexpr.bb, -40
    .set cc_parse.readrelexpr.cc, -48
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	80
#---------------
    call      cc_parse.readshiftexpr
    mov       %rdi,	%rax
    jmp       L4831
L4830:
    call      cc_lex.lex
    call      cc_parse.readshiftexpr
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%rdi+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %r12,	%r10
    lea       %rax,	[%rip+cc_tables.dominantmode]
    mov       %r11,	%r10
    shl       %r11,	5
    lea       %rax,	[%rax + %r11]
    movsxd    %r10,	dword ptr[%rbx+52]
    lea       %r11,	[%rip+cc_decls.ttbasetype]
    movsx     %r11,	word ptr[%r11 + %r10*2]
    mov       %r13,	%r11
    movzx     %rax,	byte ptr[%rax + %r11]
    mov       %r14,	%rax
    test      %rax,	%rax
    jz        L4834
    mov       %rcx,	%rdi
    mov       %rdx,	%r14
    call      cc_parse.coercemode
    mov       %rdi,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	%r14
    call      cc_parse.coercemode
    mov       %rbx,	%rax
    jmp       L4833
L4834:
    cmp       %r12,	13
    jnz       L4835
    cmp       %r13,	13
    jnz       L4835
    movsxd    %rax,	dword ptr[%rbx+52]
    movsxd    %r10,	dword ptr[%rdi+52]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    mov       %r8,	1
    call      cc_parse.checkpointertypes
    test      %rax,	%rax
    jnz       L4837
    lea       %rcx,	[%rip+L9020]
    call      cc_support.terror
L4837:
    jmp       L4833
L4835:
    lea       %rcx,	[%rip+L9021]
    call      cc_support.terror
L4833:
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	1
    jnz       L4839
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L4839
    mov       %rax,	[%rdi]
    mov       [%rbp + cc_parse.readrelexpr.a],	%rax
    mov       %rax,	[%rbx]
    mov       [%rbp + cc_parse.readrelexpr.b],	%rax
    mov       %rax,	%r14
    cmp       %rax,	3
    jz        L4841
    cmp       %rax,	4
    jz        L4841
    cmp       %rax,	8
    jz        L4842
    cmp       %rax,	9
    jz        L4842
    jmp       L4843
L4841:
    mov       %rax,	%rsi
    cmp       %rax,	42
    jz        L4845
    cmp       %rax,	43
    jz        L4846
    cmp       %rax,	44
    jz        L4847
    jmp       L4848
L4845:
    mov       %rax,	[%rbp + cc_parse.readrelexpr.a]
    cmp       %rax,	[%rbp + cc_parse.readrelexpr.b]
    setl      %al
    movzx     %eax,	%al
    mov       [%rbp + cc_parse.readrelexpr.c],	%rax
    jmp       L4844
L4846:
    mov       %rax,	[%rbp + cc_parse.readrelexpr.a]
    cmp       %rax,	[%rbp + cc_parse.readrelexpr.b]
    setle     %al
    movzx     %eax,	%al
    mov       [%rbp + cc_parse.readrelexpr.c],	%rax
    jmp       L4844
L4847:
    mov       %rax,	[%rbp + cc_parse.readrelexpr.a]
    cmp       %rax,	[%rbp + cc_parse.readrelexpr.b]
    setge     %al
    movzx     %eax,	%al
    mov       [%rbp + cc_parse.readrelexpr.c],	%rax
    jmp       L4844
L4848:
    mov       %rax,	[%rbp + cc_parse.readrelexpr.a]
    cmp       %rax,	[%rbp + cc_parse.readrelexpr.b]
    setg      %al
    movzx     %eax,	%al
    mov       [%rbp + cc_parse.readrelexpr.c],	%rax
L4844:
    mov       %rax,	[%rbp + cc_parse.readrelexpr.c]
    mov       [%rdi],	%rax
    jmp       L4831
L4842:
    mov       %rax,	[%rdi]
    mov       [%rbp + cc_parse.readrelexpr.aa],	%rax
    mov       %rax,	[%rbx]
    mov       [%rbp + cc_parse.readrelexpr.bb],	%rax
    mov       %rax,	%rsi
    cmp       %rax,	42
    jz        L4850
    cmp       %rax,	43
    jz        L4851
    cmp       %rax,	44
    jz        L4852
    jmp       L4853
L4850:
    mov       %rax,	[%rbp + cc_parse.readrelexpr.aa]
    cmp       %rax,	[%rbp + cc_parse.readrelexpr.bb]
    setb      %al
    movzx     %eax,	%al
    mov       [%rbp + cc_parse.readrelexpr.cc],	%rax
    jmp       L4849
L4851:
    mov       %rax,	[%rbp + cc_parse.readrelexpr.aa]
    cmp       %rax,	[%rbp + cc_parse.readrelexpr.bb]
    setbe     %al
    movzx     %eax,	%al
    mov       [%rbp + cc_parse.readrelexpr.cc],	%rax
    jmp       L4849
L4852:
    mov       %rax,	[%rbp + cc_parse.readrelexpr.aa]
    cmp       %rax,	[%rbp + cc_parse.readrelexpr.bb]
    setae     %al
    movzx     %eax,	%al
    mov       [%rbp + cc_parse.readrelexpr.cc],	%rax
    jmp       L4849
L4853:
    mov       %rax,	[%rbp + cc_parse.readrelexpr.aa]
    cmp       %rax,	[%rbp + cc_parse.readrelexpr.bb]
    seta      %al
    movzx     %eax,	%al
    mov       [%rbp + cc_parse.readrelexpr.cc],	%rax
L4849:
    mov       %rax,	[%rbp + cc_parse.readrelexpr.cc]
    mov       [%rdi],	%rax
    jmp       L4831
L4843:
L4840:
L4839:
    lea       %rax,	[%rip+cc_tables.symboltojtag]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       %eax,	3
    mov       [%rdi+52],	%eax
L4831:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %rsi,	%rax
    cmp       %rax,	42
    jz        L4830
    cmp       %rsi,	43
    jz        L4830
    cmp       %rsi,	44
    jz        L4830
    cmp       %rsi,	45
    jz        L4830
    mov       %rax,	%rdi
L4829:
#---------------
    add       %rsp,	80
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readshiftexpr
cc_parse.readshiftexpr:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
#---------------
    call      cc_parse.readaddexpr
    mov       %rdi,	%rax
    jmp       L4856
L4855:
    call      cc_lex.lex
    call      cc_parse.readaddexpr
    mov       %rbx,	%rax
    mov       %rcx,	%rdi
    call      cc_parse.coercebasetype
    movsxd    %rax,	dword ptr[%rdi+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %r12,	%r10
    cmp       %r10,	1
    jl        L4860
    cmp       %r12,	9
    jle       L4859
L4860:
    lea       %rcx,	[%rip+L9022]
    call      cc_support.terror
L4859:
    mov       %rcx,	%rbx
    mov       %rdx,	3
    call      cc_parse.coercemode
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	1
    jnz       L4862
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L4862
    mov       %rax,	%r12
    cmp       %rax,	3
    jz        L4864
    cmp       %rax,	4
    jz        L4864
    cmp       %rax,	8
    jz        L4865
    cmp       %rax,	9
    jz        L4865
    jmp       L4866
L4864:
    cmp       %rsi,	33
    jnz       L4868
    mov       %rax,	[%rdi]
    mov       %r10,	[%rbx]
    mov       %cl,	%r10b
    shl       %rax,	%cl
    mov       [%rdi],	%rax
    jmp       L4867
L4868:
    mov       %rax,	[%rdi]
    mov       %r10,	[%rbx]
    mov       %cl,	%r10b
    sar       %rax,	%cl
    mov       [%rdi],	%rax
L4867:
    jmp       L4856
L4865:
    cmp       %rsi,	33
    jnz       L4870
    mov       %rax,	[%rdi]
    mov       %r10,	[%rbx]
    mov       %cl,	%r10b
    shl       %rax,	%cl
    mov       [%rdi],	%rax
    jmp       L4869
L4870:
    mov       %rax,	[%rdi]
    mov       %r10,	[%rbx]
    mov       %cl,	%r10b
    shr       %rax,	%cl
    mov       [%rdi],	%rax
L4869:
    jmp       L4856
L4866:
L4863:
L4862:
    cmp       %rsi,	33
    jnz       L4872
    mov       %rax,	47
    jmp       L4871
L4872:
    mov       %rax,	48
L4871:
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%r12d
L4856:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %rsi,	%rax
    cmp       %rax,	33
    jz        L4855
    cmp       %rsi,	34
    jz        L4855
    mov       %rax,	%rdi
L4854:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readaddexpr
cc_parse.readaddexpr:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
    call      cc_parse.readmulexpr
    mov       %rdi,	%rax
    jmp       L4875
L4874:
    call      cc_lex.lex
    call      cc_parse.readmulexpr
    mov       %rbx,	%rax
    cmp       %rsi,	23
    jnz       L4878
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      cc_parse.createaddop
    mov       %rdi,	%rax
    jmp       L4877
L4878:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      cc_parse.createsubop
    mov       %rdi,	%rax
L4877:
L4875:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %rsi,	%rax
    cmp       %rax,	23
    jz        L4874
    cmp       %rsi,	24
    jz        L4874
    mov       %rax,	%rdi
L4873:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readmulexpr
cc_parse.readmulexpr:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
    call      cc_parse.readterm
    mov       %rdi,	%rax
    jmp       L4881
L4880:
    call      cc_lex.lex
    call      cc_parse.readterm
    mov       %rbx,	%rax
    mov       %rax,	%rsi
    cmp       %rax,	25
    jz        L4884
    cmp       %rax,	26
    jz        L4885
    cmp       %rax,	27
    jz        L4886
    jmp       L4887
L4884:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      cc_parse.createmulop
    mov       %rdi,	%rax
    jmp       L4883
L4885:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      cc_parse.createdivop
    mov       %rdi,	%rax
    jmp       L4883
L4886:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      cc_parse.createremop
    mov       %rdi,	%rax
L4887:
L4883:
L4881:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %rsi,	%rax
    cmp       %rax,	25
    jz        L4880
    cmp       %rsi,	26
    jz        L4880
    cmp       %rsi,	27
    jz        L4880
    mov       %rax,	%rdi
L4879:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readterm
cc_parse.readterm:
#?>>
    .set cc_parse.readterm.slength, -8
    .set cc_parse.readterm.fwide, -16
    .set cc_parse.readterm.tag, -24
    .set cc_parse.readterm.pbyte, -32
    .set cc_parse.readterm.a, -40
    .set cc_parse.readterm.d, -48
    .set cc_parse.readterm.ss, -56
    .set cc_parse.readterm.s, -64
    .set cc_parse.readterm.pm, -72
    .set cc_parse.readterm.av_1, -80
    .set cc_parse.readterm.$T3, -88
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	120
#---------------
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    sub       %rax,	13
    cmp       %rax,	84
    jae       L4891
    lea       %r10,	[%rip+L4890]
    jmp       [%r10 + %rax*8]
    .data
L4890:
    .quad     L4938
    .quad     L4891
    .quad     L4891
    .quad     L4891
    .quad     L4891
    .quad     L4891
    .quad     L4891
    .quad     L4891
    .quad     L4891
    .quad     L4891
    .quad     L4925
    .quad     L4926
    .quad     L4935
    .quad     L4891
    .quad     L4891
    .quad     L4891
    .quad     L4931
    .quad     L4891
    .quad     L4891
    .quad     L4934
    .quad     L4891
    .quad     L4891
    .quad     L4930
    .quad     L4927
    .quad     L4936
    .quad     L4936
    .quad     L4937
    .quad     L4891
    .quad     L4891
    .quad     L4891
    .quad     L4891
    .quad     L4891
    .quad     L4891
    .quad     L4891
    .quad     L4891
    .quad     L4891
    .quad     L4891
    .quad     L4891
    .quad     L4891
    .quad     L4891
    .quad     L4891
    .quad     L4891
    .quad     L4891
    .quad     L4891
    .quad     L4891
    .quad     L4891
    .quad     L4892
    .quad     L4892
    .quad     L4917
    .quad     L4891
    .quad     L4911
    .quad     L4911
    .quad     L4891
    .quad     L4891
    .quad     L4893
    .quad     L4891
    .quad     L4891
    .quad     L4891
    .quad     L4891
    .quad     L4891
    .quad     L4891
    .quad     L4891
    .quad     L4891
    .quad     L4891
    .quad     L4891
    .quad     L4891
    .quad     L4891
    .quad     L4891
    .quad     L4891
    .quad     L4891
    .quad     L4891
    .quad     L4891
    .quad     L4891
    .quad     L4891
    .quad     L4891
    .quad     L4891
    .quad     L4891
    .quad     L4891
    .quad     L4891
    .quad     L4943
    .quad     L4891
    .quad     L4954
    .quad     L4955
    .quad     L4956
    .text
L4892:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+22]
    lea       %r10,	[%rip+cc_decls.lx]
    mov       %r10,	[%r10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      cc_lib.createconstunit
    mov       %rdi,	%rax
    call      cc_lex.lex
    jmp       L4889
L4893:
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	1
    jg        L4895
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       [%rbp + cc_parse.readterm.$T3],	%rax
    mov       %rax,	[%rip+cc_decls.currproc]
    test      %rax,	%rax
    jz        L4897
    mov       %rax,	[%rip+cc_decls.currproc]
    jmp       L4896
L4897:
    mov       %rax,	[%rip+cc_decls.stmodule]
L4896:
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + cc_parse.readterm.$T3]
    mov       %r8,	1
    mov       %r9,	[%rip+cc_decls.currblockno]
    call      cc_lib.resolvename
    mov       [%rbp + cc_parse.readterm.d],	%rax
    mov       %rax,	[%rbp + cc_parse.readterm.d]
    test      %rax,	%rax
    jnz       L4899
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    call      cc_lib.getstname
    lea       %rcx,	[%rip+L9023]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L4899:
    jmp       L4894
L4895:
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       [%rbp + cc_parse.readterm.d],	%rax
L4894:
    mov       %rax,	[%rbp + cc_parse.readterm.d]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	11
    jz        L4901
    cmp       %rax,	6
    jz        L4902
    jmp       L4903
L4901:
    mov       %rax,	[%rbp + cc_parse.readterm.d]
    movsxd    %rax,	dword ptr[%rax+88]
    mov       %rcx,	%rax
    mov       %rdx,	3
    call      cc_lib.createconstunit
    mov       %rdi,	%rax
    jmp       L4900
L4902:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	13
    jz        L4905
    mov       %rcx,	5
    call      cc_lib.createunit0
    mov       %rdi,	%rax
    mov       %rax,	[%rbp + cc_parse.readterm.d]
    mov       [%rdi],	%rax
    mov       %rax,	[%rbp + cc_parse.readterm.d]
    mov       %rax,	[%rax+80]
    mov       %r10,	[%rbp + cc_parse.readterm.d]
    movzx     %r10,	word ptr[%r10+102]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      cc_lib.createprocmode
    mov       %rcx,	%rax
    call      cc_lib.createrefmode
    mov       [%rdi+52],	%eax
    jmp       L4904
L4905:
    jmp       L4906
L4904:
    jmp       L4900
L4903:
#cc_parse.readterm.doname:
L4906:
    mov       %rcx,	[%rbp + cc_parse.readterm.d]
    call      cc_lib.createname
    mov       %rdi,	%rax
    mov       %rax,	[%rbp + cc_parse.readterm.d]
    movzx     %rax,	word ptr[%rax+102]
    mov       %rsi,	%rax
    mov       [%rdi+52],	%eax
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rsi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jnz       L4908
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8]
    mov       [%rdi+48],	%eax
    mov       %rcx,	%rdi
    call      cc_parse.createaddrofop
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%rsi
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rcx,	%rax
    call      cc_lib.createrefmode
    mov       [%rdi+52],	%eax
    jmp       L4907
L4908:
    mov       %rax,	[%rbp + cc_parse.readterm.d]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	6
    jz        L4909
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8]
    cmp       %rax,	4
    jge       L4909
    mov       %rcx,	%rdi
    call      cc_parse.fixmemopnd
    jmp       L4907
L4909:
    mov       %rax,	[%rbp + cc_parse.readterm.d]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	9
    jnz       L4910
L4910:
L4907:
L4900:
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %eax,	[%rax+16]
    mov       [%rdi+44],	%eax
    call      cc_lex.lex
    jmp       L4889
L4911:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	64
    setz      %al
    movzx     %eax,	%al
    mov       [%rbp + cc_parse.readterm.fwide],	%rax
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       [%rbp + cc_parse.readterm.s],	%rax
    lea       %rax,	[%rip+cc_decls.lx]
    movsxd    %rax,	dword ptr[%rax+24]
    mov       [%rbp + cc_parse.readterm.slength],	%rax
    jmp       L4913
L4912:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+24]
    mov       %r10,	[%rbp + cc_parse.readterm.slength]
    add       %r10,	%rax
    mov       %r14,	%r10
    lea       %rax,	[%r14+1]
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       [%rbp + cc_parse.readterm.ss],	%rax
    mov       %rcx,	[%rbp + cc_parse.readterm.ss]
    mov       %rdx,	[%rbp + cc_parse.readterm.s]
    mov       %r8,	[%rbp + cc_parse.readterm.slength]
    call      memcpy
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+24]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       %r10,	[%r10]
    mov       %r11,	[%rbp + cc_parse.readterm.ss]
    mov       %r15,	[%rbp + cc_parse.readterm.slength]
    lea       %r11,	[%r11 + %r15]
    mov       %rcx,	%r11
    mov       %rdx,	%r10
    mov       %r8,	%rax
    call      memcpy
    xor       %eax,	%eax
    mov       %r10,	[%rbp + cc_parse.readterm.ss]
    mov       %r11,	%r14
    mov       [%r10 + %r11],	%al
    mov       %rax,	[%rbp + cc_parse.readterm.ss]
    mov       [%rbp + cc_parse.readterm.s],	%rax
    mov       [%rbp + cc_parse.readterm.slength],	%r14
    call      cc_lex.lex
L4913:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	63
    jz        L4912
    mov       %rax,	[%rbp + cc_parse.readterm.fwide]
    test      %rax,	%rax
    jz        L4916
    mov       %rcx,	[%rbp + cc_parse.readterm.s]
    mov       %rdx,	[%rbp + cc_parse.readterm.slength]
    call      cc_lib.createwstringconstunit
    mov       %rdi,	%rax
    mov       %eax,	[%rbp + cc_parse.readterm.slength]
    mov       [%rdi+48],	%eax
    mov       %eax,	[%rip+cc_decls.trefwchar]
    mov       [%rdi+52],	%eax
    jmp       L4915
L4916:
    mov       %rcx,	[%rbp + cc_parse.readterm.s]
    mov       %rdx,	[%rbp + cc_parse.readterm.slength]
    call      cc_lib.createstringconstunit
    mov       %rdi,	%rax
    mov       %eax,	[%rip+cc_decls.trefchar]
    mov       [%rdi+52],	%eax
L4915:
    call      cc_lex.lex
    jmp       L4889
L4917:
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readterm.a],	%rax
    xor       %r13,	%r13
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       [%rbp + cc_parse.readterm.pbyte],	%rax
    lea       %rax,	[%rip+cc_decls.lx]
    movsxd    %rax,	dword ptr[%rax+24]
    cmp       %rax,	8
    jle       L4919
    lea       %rcx,	[%rip+L9024]
    call      cc_support.serror
L4919:
    lea       %rax,	[%rip+cc_decls.lx]
    movsxd    %rax,	dword ptr[%rax+24]
    mov       [%rbp + cc_parse.readterm.av_1],	%rax
    mov       %rax,	[%rbp + cc_parse.readterm.av_1]
    cmp       %rax,	0
    jle       L4922
L4920:
    mov       %rax,	[%rbp + cc_parse.readterm.pbyte]
    movzx     %rax,	byte ptr[%rax]
    mov       %cl,	%r13b
    shl       %rax,	%cl
    mov       %r10,	[%rbp + cc_parse.readterm.a]
    or        %r10,	%rax
    mov       [%rbp + cc_parse.readterm.a],	%r10
    mov       %rax,	8
    add       %r13,	%rax
    inc       qword ptr[%rbp + cc_parse.readterm.pbyte]
    dec       qword ptr[%rbp + cc_parse.readterm.av_1]
    jnz       L4920
L4922:
    lea       %rax,	[%rip+cc_decls.lx]
    movsxd    %rax,	dword ptr[%rax+24]
    cmp       %rax,	4
    jg        L4924
    mov       %rax,	3
    jmp       L4923
L4924:
    mov       %rax,	4
L4923:
    mov       %rcx,	[%rbp + cc_parse.readterm.a]
    mov       %rdx,	%rax
    call      cc_lib.createconstunit
    mov       %rdi,	%rax
    call      cc_lex.lex
    jmp       L4889
L4925:
    call      cc_lex.lex
    call      cc_parse.readterm
    mov       %rdi,	%rax
    jmp       L4889
L4926:
    call      cc_lex.lex
    call      cc_parse.readterm
    mov       %rcx,	%rax
    call      cc_parse.createnegop
    mov       %rdi,	%rax
    jmp       L4889
L4927:
    call      cc_lex.lex
    call      cc_parse.readterm
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    call      cc_parse.coercecond
    mov       %rcx,	26
    mov       %rdx,	%rdi
    call      cc_lib.createunit1
    mov       %rdi,	%rax
    mov       %eax,	3
    mov       [%rdi+52],	%eax
    mov       %rax,	[%rdi+16]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	26
    jnz       L4929
    mov       %rax,	[%rdi+16]
    mov       %rax,	[%rax+16]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	26
    jnz       L4929
    mov       %rax,	[%rdi+16]
    mov       %rax,	[%rax+16]
    mov       %rax,	[%rax+16]
    mov       [%rdi+16],	%rax
L4929:
    jmp       L4889
L4930:
    call      cc_lex.lex
    call      cc_parse.readterm
    mov       %rcx,	%rax
    call      cc_parse.createinotop
    mov       %rdi,	%rax
    jmp       L4889
L4931:
    call      cc_lex.lex
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	25
    jnz       L4933
    call      cc_lex.lex
    call      cc_parse.readterm
    mov       %rdi,	%rax
    jmp       L4932
L4933:
    call      cc_parse.readterm
    mov       %rcx,	%rax
    call      cc_parse.createaddrofop
    mov       %rdi,	%rax
L4932:
    jmp       L4889
L4934:
    lea       %rcx,	[%rip+L9025]
    call      cc_support.serror
    jmp       L4889
L4935:
    call      cc_lex.lex
    call      cc_parse.readterm
    mov       %rcx,	%rax
    call      cc_parse.createptrop
    mov       %rdi,	%rax
    jmp       L4889
L4936:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    lea       %r10,	[%rip+cc_tables.symboltojtag]
    movzx     %r10,	byte ptr[%r10 + %rax-1]
    mov       %r12,	%r10
    call      cc_lex.lex
    call      cc_parse.readterm
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_parse.createincrop
    mov       %rdi,	%rax
    jmp       L4889
L4937:
    call      cc_lex.lex
    mov       %rcx,	13
    call      cc_lib.skipsymbol
    call      cc_parse.readexpression
    mov       %rcx,	%rax
    call      cc_parse.createabsop
    mov       %rdi,	%rax
    mov       %rcx,	14
    call      cc_lib.skipsymbol
    jmp       L4889
L4938:
    call      cc_lex.lex
    call      cc_parse.istypestarter
    test      %rax,	%rax
    jz        L4940
    sub       %rsp,	8
    push      0
    lea       %rcx,	[%rbp + cc_parse.readterm.d]
    xor       %edx,	%edx
    lea       %r8,	[%rbp + cc_parse.readterm.pm]
    xor       %r9d,	%r9d
    sub       %rsp,	32
    call      cc_parse.readcasttype
    add       %rsp,	48
    mov       %rsi,	%rax
    mov       %rcx,	14
    call      cc_lib.skipsymbol
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	17
    jnz       L4942
    lea       %rcx,	[%rip+L9026]
    call      cc_support.serror
    jmp       L4941
L4942:
    call      cc_parse.readterm
    mov       %rcx,	%rax
    mov       %rdx,	%rsi
    mov       %r8,	1
    xor       %r9d,	%r9d
    call      cc_parse.docast
    mov       %rdi,	%rax
L4941:
    jmp       L4939
L4940:
    call      cc_parse.readexpression
    mov       %rdi,	%rax
    mov       %rcx,	14
    call      cc_lib.skipsymbol
L4939:
    jmp       L4889
L4943:
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %al,	[%rax+22]
    test      %al,	%al
    jz        L4945
    call      cc_lex.lex
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	13
    jnz       L4947
    call      cc_lex.lex
    call      cc_parse.istypestarter
    test      %rax,	%rax
    jz        L4949
    sub       %rsp,	8
    push      0
    lea       %rcx,	[%rbp + cc_parse.readterm.d]
    xor       %edx,	%edx
    lea       %r8,	[%rbp + cc_parse.readterm.pm]
    xor       %r9d,	%r9d
    sub       %rsp,	32
    call      cc_parse.readcasttype
    add       %rsp,	48
    mov       %rsi,	%rax
    mov       %rcx,	14
    call      cc_lib.skipsymbol
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8]
    mov       %rcx,	%rax
    mov       %rdx,	9
    call      cc_lib.createconstunit
    mov       %rdi,	%rax
    jmp       L4948
L4949:
    call      cc_parse.readexpression
    mov       %rdi,	%rax
    mov       %rcx,	14
    call      cc_lib.skipsymbol
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      cc_parse.createsizeofop
    mov       %rdi,	%rax
L4948:
    jmp       L4946
L4947:
    call      cc_parse.readterm
    mov       %rcx,	%rax
    mov       %rdx,	1
    call      cc_parse.createsizeofop
    mov       %rdi,	%rax
L4946:
    jmp       L4944
L4945:
    call      cc_lex.lex
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	13
    jnz       L4951
    call      cc_parse.istypestarter_next
    test      %rax,	%rax
    jz        L4953
    call      cc_lex.lex
    sub       %rsp,	8
    push      0
    lea       %rcx,	[%rbp + cc_parse.readterm.d]
    xor       %edx,	%edx
    lea       %r8,	[%rbp + cc_parse.readterm.pm]
    xor       %r9d,	%r9d
    sub       %rsp,	32
    call      cc_parse.readcasttype
    add       %rsp,	48
    mov       %rsi,	%rax
    mov       %rcx,	14
    call      cc_lib.skipsymbol
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8]
    mov       %rcx,	%rax
    mov       %rdx,	9
    call      cc_lib.createconstunit
    mov       %rdi,	%rax
    jmp       L4952
L4953:
    call      cc_parse.readterm
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      cc_parse.createsizeofop
    mov       %rdi,	%rax
L4952:
    jmp       L4950
L4951:
    call      cc_parse.readterm
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      cc_parse.createsizeofop
    mov       %rdi,	%rax
L4950:
L4944:
    jmp       L4889
L4954:
    call      cc_parse.readgeneric
    mov       %rdi,	%rax
    jmp       L4889
L4955:
    lea       %rcx,	[%rip+L9027]
    call      cc_support.serror
    jmp       L4889
L4956:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+22]
    mov       [%rbp + cc_parse.readterm.tag],	%rax
    call      cc_lex.lex
    mov       %rcx,	13
    call      cc_lib.checksymbol
    call      cc_lex.lex
    call      cc_parse.readassignexpr
    mov       %rdi,	%rax
    mov       %rax,	[%rbp + cc_parse.readterm.tag]
    cmp       %rax,	76
    jnz       L4958
    mov       %rcx,	8
    call      cc_lib.checksymbol
    call      cc_lex.lex
    call      cc_parse.readassignexpr
    mov       %rbx,	%rax
    jmp       L4957
L4958:
    xor       %rbx,	%rbx
L4957:
    mov       %rcx,	[%rbp + cc_parse.readterm.tag]
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       %eax,	3
    mov       [%rdi+52],	%eax
    mov       %rcx,	14
    call      cc_lib.checksymbol
    call      cc_lex.lex
    jmp       L4889
L4891:
    lea       %rcx,	[%rip+L9028]
    call      cc_lex.ps
    lea       %rcx,	[%rip+L9029]
    call      cc_support.serror
L4889:
L4959:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    sub       %rax,	2
    cmp       %rax,	37
    jae       L4962
    lea       %r10,	[%rip+L4961]
    jmp       [%r10 + %rax*8]
    .data
L4961:
    .quad     L4964
    .quad     L4964
    .quad     L4962
    .quad     L4962
    .quad     L4962
    .quad     L4962
    .quad     L4962
    .quad     L4962
    .quad     L4962
    .quad     L4962
    .quad     L4962
    .quad     L4965
    .quad     L4962
    .quad     L4963
    .quad     L4962
    .quad     L4962
    .quad     L4962
    .quad     L4962
    .quad     L4962
    .quad     L4962
    .quad     L4962
    .quad     L4962
    .quad     L4962
    .quad     L4962
    .quad     L4962
    .quad     L4962
    .quad     L4962
    .quad     L4962
    .quad     L4962
    .quad     L4962
    .quad     L4962
    .quad     L4962
    .quad     L4962
    .quad     L4962
    .quad     L4962
    .quad     L4968
    .quad     L4969
    .text
L4963:
    call      cc_lex.lex
    call      cc_parse.readexpression
    mov       %rbx,	%rax
    mov       %rcx,	16
    call      cc_lib.skipsymbol
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      cc_parse.createindexop
    mov       %rdi,	%rax
    jmp       L4959
L4964:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    lea       %r10,	[%rip+cc_tables.symboltojtag]
    movzx     %r10,	byte ptr[%r10 + %rax-1]
    mov       %r12,	%r10
    call      cc_lex.lex
    mov       %rcx,	67
    call      cc_lib.checksymbol
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       [%rbp + cc_parse.readterm.d],	%rax
    call      cc_lex.lex
    mov       %rcx,	%r12
    mov       %rdx,	%rdi
    mov       %r8,	[%rbp + cc_parse.readterm.d]
    call      cc_parse.createdotop
    mov       %rdi,	%rax
    jmp       L4959
L4965:
    call      cc_lex.lex
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	14
    jnz       L4967
    xor       %rbx,	%rbx
    call      cc_lex.lex
    jmp       L4966
L4967:
    xor       %ecx,	%ecx
    call      cc_parse.readexprlist
    mov       %rbx,	%rax
    mov       %rcx,	14
    call      cc_lib.skipsymbol
L4966:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      cc_parse.createcall
    mov       %rdi,	%rax
    jmp       L4959
L4968:
    call      cc_lex.lex
    mov       %rcx,	73
    mov       %rdx,	%rdi
    call      cc_parse.createincrop
    mov       %rdi,	%rax
    jmp       L4959
L4969:
    call      cc_lex.lex
    mov       %rcx,	74
    mov       %rdx,	%rdi
    call      cc_parse.createincrop
    mov       %rdi,	%rax
    jmp       L4959
L4962:
    jmp       L4960
L4960:
    mov       %rax,	%rdi
L4888:
#---------------
    add       %rsp,	120
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readexprlist
cc_parse.readexprlist:
#?>>
    .set cc_parse.readexprlist.ulist, -8
    .set cc_parse.readexprlist.ulistx, -16
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	56
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	%rdi
    mov       [%rbp + cc_parse.readexprlist.ulistx],	%rax
    mov       [%rbp + cc_parse.readexprlist.ulist],	%rax
L4971:
    call      cc_parse.readassignexpr
    mov       %rdi,	%rax
    lea       %rcx,	[%rbp + cc_parse.readexprlist.ulist]
    lea       %rdx,	[%rbp + cc_parse.readexprlist.ulistx]
    mov       %r8,	%rdi
    call      cc_lib.addlistunit
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jnz       L4972
L4974:
    call      cc_lex.lex
    jmp       L4971
L4972:
    mov       %rax,	[%rbp + cc_parse.readexprlist.ulist]
L4970:
#---------------
    add       %rsp,	56
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readmodulevar
cc_parse.readmodulevar:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
#---------------
    mov       %rcx,	[%rip+cc_decls.stmodule]
    mov       %rdx,	%r12
    mov       %r8,	1
    xor       %r9d,	%r9d
    call      cc_lib.checkdupl
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L4977
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	7
    jz        L4979
    movzx     %rax,	byte ptr[%rdi+109]
    lea       %r10,	[%rip+cc_tables.namenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rax,	[%rdi]
    lea       %rcx,	[%rip+L9030]
    mov       %rdx,	%rax
    mov       %r8,	%r10
    call      cc_support.serror_ss
L4979:
    movzx     %rax,	word ptr[%rdi+102]
    mov       %rsi,	%rax
    cmp       %rsi,	%r13
    jz        L4981
    mov       %rcx,	%rsi
    mov       %rdx,	%r13
    call      cc_parse.comparemode
    test      %rax,	%rax
    jnz       L4983
#cc_parse.readmodulevar.redef:
L4984:
    mov       %rax,	[%rdi]
    lea       %rcx,	[%rip+L9031]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L4983:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rsi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jnz       L4987
L4986:
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8]
    test      %rax,	%rax
    jnz       L4989
    mov       [%rdi+102],	%r13w
    jmp       L4988
L4989:
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%r13
    mov       %rax,	[%rax + %r10*8]
    test      %rax,	%rax
    jz        L4990
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8]
    lea       %r10,	[%rip+cc_decls.ttlength]
    mov       %r11,	%r13
    mov       %r10,	[%r10 + %r11*8]
    cmp       %rax,	%r10
    jnz       L4984
L4990:
L4988:
L4987:
L4985:
L4981:
    mov       %r12,	%rdi
    movzx     %rax,	byte ptr[%r12+110]
    mov       %rbx,	%rax
    cmp       %rbx,	2
    jnz       L4994
    test      %r14,	%r14
    jz        L4993
L4994:
    cmp       %rbx,	4
    jnz       L4995
    cmp       %r14,	1
    jz        L4993
L4995:
    cmp       %rbx,	3
    jnz       L4992
    cmp       %r14,	1
    jnz       L4992
L4993:
    jmp       L4991
L4992:
    cmp       %rbx,	3
    jnz       L4996
    test      %r14,	%r14
    jnz       L4996
    mov       %rbx,	4
L4996:
L4991:
    jmp       L4976
L4977:
    mov       %rcx,	[%rip+cc_decls.stmodule]
    mov       %rdx,	%r12
    mov       %r8,	7
    call      cc_lib.createdupldef
    mov       %r12,	%rax
    mov       [%r12+102],	%r13w
    mov       %rax,	%r14
    cmp       %rax,	1
    jz        L4998
    cmp       %rax,	4
    jz        L4999
    jmp       L5000
L4998:
    mov       %rbx,	2
    jmp       L4997
L4999:
    mov       %rbx,	3
    jmp       L4997
L5000:
    mov       %rbx,	4
L4997:
L4976:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	11
    jnz       L5002
    mov       %rax,	[%r12+72]
    test      %rax,	%rax
    jz        L5004
    mov       %rax,	[%r12]
    lea       %rcx,	[%rip+L9032]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L5004:
    cmp       %rbx,	3
    jnz       L5006
    mov       %rax,	[%r12]
    lea       %rcx,	[%rip+L9033]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L5006:
    call      cc_lex.lex
    movzx     %rax,	word ptr[%r12+102]
    mov       %rcx,	[%rip+cc_decls.stmodule]
    mov       %rdx,	%rax
    call      cc_parse.readinitexpr
    mov       [%r12+72],	%rax
L5002:
    mov       [%r12+110],	%bl
    mov       %rax,	%r12
L4975:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readframevar
cc_parse.readframevar:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
#---------------
    mov       %rcx,	[%rip+cc_decls.currproc]
    mov       %rdx,	%r12
    mov       %r8,	1
    mov       %r9,	[%rip+cc_decls.currblockno]
    call      cc_lib.checkdupl_inproc
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L5009
    mov       %rax,	[%rdi]
    lea       %rcx,	[%rip+L9034]
    mov       %rdx,	%rax
    call      cc_support.serror_s
    mov       %r12,	%rdi
    movzx     %rax,	byte ptr[%r12+110]
    mov       %rbx,	%rax
    cmp       %rbx,	2
    jnz       L5013
    test      %r14,	%r14
    jz        L5012
L5013:
    cmp       %rbx,	4
    jnz       L5014
    cmp       %r14,	1
    jz        L5012
L5014:
    cmp       %rbx,	3
    jnz       L5011
    cmp       %r14,	1
    jnz       L5011
L5012:
    jmp       L5010
L5011:
    cmp       %rbx,	3
    jnz       L5015
    test      %r14,	%r14
    jnz       L5015
    mov       %rbx,	4
L5015:
L5010:
    jmp       L5008
L5009:
    mov       %rsi,	8
    mov       %rbx,	1
    mov       %rax,	%r14
    cmp       %rax,	1
    jz        L5017
    cmp       %rax,	4
    jz        L5018
    jmp       L5019
L5017:
    mov       %rsi,	7
    jmp       L5016
L5018:
    mov       %rbx,	3
    mov       %rsi,	7
L5019:
L5016:
    mov       %rcx,	[%rip+cc_decls.currproc]
    mov       %rdx,	%r12
    mov       %r8,	%rsi
    call      cc_lib.createdupldef
    mov       %r12,	%rax
    mov       [%r12+102],	%r13w
    mov       %ax,	[%rip+cc_decls.currblockno]
    mov       [%r12+96],	%ax
    mov       %eax,	1
    lea       %r10,	[%rip+cc_decls.blockcounts]
    mov       %r11,	[%rip+cc_decls.currblockno]
    mov       [%r10 + %r11*4],	%eax
L5008:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	11
    jnz       L5021
    mov       %rax,	[%r12+72]
    test      %rax,	%rax
    jz        L5023
    mov       %rax,	[%r12]
    lea       %rcx,	[%rip+L9035]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L5023:
    cmp       %rbx,	3
    jnz       L5025
    mov       %rax,	[%r12]
    lea       %rcx,	[%rip+L9036]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L5025:
    call      cc_lex.lex
    movzx     %rax,	word ptr[%r12+102]
    mov       %rcx,	[%rip+cc_decls.currproc]
    mov       %rdx,	%rax
    call      cc_parse.readinitexpr
    mov       [%r12+72],	%rax
L5021:
    mov       [%r12+110],	%bl
    mov       %rax,	%r12
L5007:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readtype
cc_parse.readtype:
#?>>
    .set cc_parse.readtype.modtype, -256
    .set cc_parse.readtype.modvalue, -512
    .set cc_parse.readtype.nmodifiers, -520
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	560
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
    mov       %r14,	%r9
#---------------
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readtype.nmodifiers],	%rax
    xor       %eax,	%eax
    mov       [%r14],	%rax
    sub       %rsp,	8
    lea       %rax,	[%rbp + cc_parse.readtype.nmodifiers]
    push      %rax
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    lea       %r8,	[%rbp + cc_parse.readtype.modtype]
    lea       %r9,	[%rbp + cc_parse.readtype.modvalue]
    sub       %rsp,	32
    call      cc_parse.readnamedtype
    add       %rsp,	48
    mov       %rbx,	[%rbp + cc_parse.readtype.nmodifiers]
    cmp       %rbx,	1
    jl        L5029
L5027:
    mov       %rax,	[%rbp + %rbx*8 + cc_parse.readtype.modtype-8]
    cmp       %rax,	65
    jz        L5031
    cmp       %rax,	82
    jz        L5032
    cmp       %rax,	67
    jz        L5033
    cmp       %rax,	70
    jz        L5034
    jmp       L5035
L5031:
    mov       %rax,	[%rbp + %rbx*8 + cc_parse.readtype.modvalue-8]
    mov       %rcx,	%r13
    mov       %rdx,	%rax
    call      cc_lib.createarraymode
    mov       %r13,	%rax
    jmp       L5030
L5032:
    mov       %rcx,	%r13
    call      cc_lib.createrefmode
    mov       %r13,	%rax
    jmp       L5030
L5033:
    mov       %rcx,	%r13
    call      cc_lib.createconstmode
    mov       %r13,	%rax
    jmp       L5030
L5034:
    mov       %rdi,	[%rbp + %rbx*8 + cc_parse.readtype.modvalue-8]
    cmp       %rbx,	1
    jnz       L5037
    mov       [%r14],	%rdi
    jmp       L5036
L5037:
    mov       %rcx,	%r13
    mov       %rdx,	%rdi
    call      cc_lib.createprocmode
    mov       %r13,	%rax
L5036:
L5035:
L5030:
    dec       %rbx
    cmp       %rbx,	1
    jge       L5027
L5029:
    mov       %rax,	%r13
L5026:
#---------------
    add       %rsp,	560
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readnamedtype
cc_parse.readnamedtype:
#?>>
    .set cc_parse.readnamedtype.modvalue, 88
    .set cc_parse.readnamedtype.nmodifiers, 96
    .set cc_parse.readnamedtype.fconst, -256
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	288
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
    mov       [%rbp+88],	%r9
#---------------
    xor       %eax,	%eax
    mov       [%r13],	%rax
    xor       %rbx,	%rbx
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	89
    jnz       L5040
    call      cc_lex.lex
L5040:
    jmp       L5042
L5041:
    inc       %rbx
    xor       %eax,	%eax
    mov       [%rbp + %rbx*8 + cc_parse.readnamedtype.fconst-8],	%rax
    call      cc_lex.lex
    jmp       L5045
L5044:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+22]
    cmp       %rax,	1
    jz        L5048
    cmp       %rax,	2
    jz        L5049
    cmp       %rax,	3
    jz        L5049
    jmp       L5050
L5048:
    mov       %rax,	1
    mov       [%rbp + %rbx*8 + cc_parse.readnamedtype.fconst-8],	%rax
    jmp       L5047
L5049:
    jmp       L5047
L5050:
    lea       %rcx,	[%rip+L9037]
    call      cc_support.serror
L5047:
    call      cc_lex.lex
L5045:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	87
    jz        L5044
L5042:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	25
    jz        L5041
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L5052
    cmp       %rax,	13
    jz        L5053
    jmp       L5054
L5052:
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       [%r13],	%rax
    call      cc_lex.lex
    jmp       L5051
L5053:
    call      cc_lex.lex
    sub       %rsp,	8
    push      qword ptr[%rbp + cc_parse.readnamedtype.nmodifiers]
    mov       %rcx,	%r12
    mov       %rdx,	%r13
    mov       %r8,	%r14
    mov       %r9,	[%rbp + cc_parse.readnamedtype.modvalue]
    sub       %rsp,	32
    call      cc_parse.readnamedtype
    add       %rsp,	48
    mov       %rcx,	14
    call      cc_lib.skipsymbol
L5054:
L5051:
L5055:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	15
    jz        L5057
    cmp       %rax,	13
    jz        L5058
    jmp       L5059
L5057:
    call      cc_lex.lex
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	16
    jnz       L5061
    xor       %rdi,	%rdi
    jmp       L5060
L5061:
    call      cc_parse.readassignexpr
    mov       %rsi,	%rax
    movsxd    %rax,	dword ptr[%rsi+40]
    cmp       %rax,	1
    jnz       L5063
    mov       %rdi,	[%rsi]
    jmp       L5062
L5063:
    lea       %rcx,	[%rip+L9038]
    call      cc_support.serror
L5062:
    mov       %rcx,	16
    call      cc_lib.checksymbol
    test      %rdi,	%rdi
    jnz       L5065
    lea       %rcx,	[%rip+L9039]
    call      cc_support.serror
L5065:
L5060:
    cmp       %rdi,	0
    jge       L5067
    lea       %rcx,	[%rip+L9040]
    call      cc_support.terror
L5067:
    call      cc_lex.lex
    mov       %rax,	[%rbp + cc_parse.readnamedtype.nmodifiers]
    inc       qword ptr[%rax]
    mov       %rax,	[%rax]
    mov       %r10,	65
    mov       [%r14 + %rax*8-8],	%r10
    mov       %rax,	[%rbp + cc_parse.readnamedtype.nmodifiers]
    mov       %rax,	[%rax]
    mov       %r10,	%rdi
    mov       %r11,	[%rbp + cc_parse.readnamedtype.modvalue]
    mov       [%r11 + %rax*8-8],	%r10
    jmp       L5055
L5058:
    call      cc_lex.lex
    mov       %rax,	[%rbp + cc_parse.readnamedtype.nmodifiers]
    inc       qword ptr[%rax]
    mov       %rax,	[%rax]
    mov       %r10,	70
    mov       [%r14 + %rax*8-8],	%r10
    mov       %rcx,	%r12
    call      cc_parse.readparams
    mov       %r10,	[%rbp + cc_parse.readnamedtype.nmodifiers]
    mov       %r10,	[%r10]
    mov       %r11,	[%rbp + cc_parse.readnamedtype.modvalue]
    mov       [%r11 + %r10*8-8],	%rax
    jmp       L5055
L5059:
    jmp       L5056
L5056:
    jmp       L5069
L5068:
    mov       %rax,	[%rbp + %rbx*8 + cc_parse.readnamedtype.fconst-8]
    test      %rax,	%rax
    jz        L5072
    mov       %rax,	[%rbp + cc_parse.readnamedtype.nmodifiers]
    inc       qword ptr[%rax]
    mov       %rax,	[%rax]
    mov       %r10,	67
    mov       [%r14 + %rax*8-8],	%r10
L5072:
    mov       %rax,	[%rbp + cc_parse.readnamedtype.nmodifiers]
    inc       qword ptr[%rax]
    mov       %rax,	[%rax]
    mov       %r10,	82
    mov       [%r14 + %rax*8-8],	%r10
    dec       %rbx
L5069:
    test      %rbx,	%rbx
    jnz       L5068
#---------------
    add       %rsp,	288
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readconstintexpr
cc_parse.readconstintexpr:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    call      cc_parse.readassignexpr
    mov       %rdi,	%rax
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	1
    jnz       L5076
L5075:
    mov       %rax,	[%rdi]
    jmp       L5073
L5076:
    movsxd    %rax,	dword ptr[%rdi+40]
    lea       %r10,	[%rip+cc_tables.jtagnames]
    mov       %r10,	[%r10 + %rax*8]
    lea       %rcx,	[%rip+L9041]
    mov       %rdx,	%r10
    call      cc_support.serror_s
L5074:
    xor       %eax,	%eax
L5073:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readinitexpr
cc_parse.readinitexpr:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	1
    call      cc_parse.readinitexpr2
    mov       %rdi,	%rax
    mov       %rax,	%rdi
L5077:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readinitexpr2
cc_parse.readinitexpr2:
#?>>
    .set cc_parse.readinitexpr2.m, 80
    .set cc_parse.readinitexpr2.istop, 88
    .set cc_parse.readinitexpr2.ulist, -8
    .set cc_parse.readinitexpr2.ulistx, -16
    .set cc_parse.readinitexpr2.d, -24
    .set cc_parse.readinitexpr2.e, -32
    .set cc_parse.readinitexpr2.braces, -40
    .set cc_parse.readinitexpr2.newstr, -48
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	88
    mov       %r15,	%rcx
    mov       [%rbp+80],	%rdx
    mov       [%rbp+88],	%r8
#---------------
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	[%rbp + cc_parse.readinitexpr2.m]
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rbx,	%rax
    xor       %r14,	%r14
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	17
    jnz       L5080
    call      cc_lex.lex
    xor       %r14,	%r14
    mov       %rax,	%rbx
    cmp       %rax,	17
    jz        L5082
    cmp       %rax,	18
    jz        L5083
    cmp       %rax,	19
    jz        L5083
    jmp       L5084
L5082:
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	[%rbp + cc_parse.readinitexpr2.m]
    mov       %r13,	[%rax + %r10*8]
    mov       %rax,	[%rbp + cc_parse.readinitexpr2.istop]
    test      %rax,	%rax
    jnz       L5086
    test      %r13,	%r13
    jnz       L5086
    lea       %rcx,	[%rip+L9042]
    call      cc_support.terror
L5086:
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	[%rbp + cc_parse.readinitexpr2.m]
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rsi,	%rax
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rsi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	1
    jnz       L5088
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	63
    jnz       L5088
    mov       %rax,	1
    mov       [%rbp + cc_parse.readinitexpr2.braces],	%rax
    jmp       L5089
L5088:
    jmp       L5081
L5083:
    lea       %rax,	[%rip+cc_decls.ttnamedef]
    mov       %r10,	[%rbp + cc_parse.readinitexpr2.m]
    mov       %rax,	[%rax + %r10*8]
    mov       [%rbp + cc_parse.readinitexpr2.d],	%rax
    mov       %rax,	[%rbp + cc_parse.readinitexpr2.d]
    mov       %rax,	[%rax+16]
    mov       [%rbp + cc_parse.readinitexpr2.e],	%rax
    mov       %rax,	[%rbp + cc_parse.readinitexpr2.e]
    test      %rax,	%rax
    jnz       L5091
    lea       %rcx,	[%rip+L9043]
    call      cc_support.terror
L5091:
    mov       %rax,	[%rbp + cc_parse.readinitexpr2.e]
    movzx     %rax,	word ptr[%rax+102]
    mov       %rsi,	%rax
    jmp       L5081
L5084:
    call      cc_parse.readassignexpr
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	[%rbp + cc_parse.readinitexpr2.m]
    call      cc_parse.coercemode
    mov       %rdi,	%rax
    mov       %rcx,	18
    call      cc_lib.skipsymbol
    mov       %rax,	%rdi
    jmp       L5078
L5081:
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readinitexpr2.ulistx],	%rax
    mov       [%rbp + cc_parse.readinitexpr2.ulist],	%rax
L5092:
    mov       %rcx,	%r15
    mov       %rdx,	%rsi
    xor       %r8d,	%r8d
    call      cc_parse.readinitexpr2
    mov       %rdi,	%rax
    inc       %r14
    mov       %rax,	%rbx
    cmp       %rax,	17
    jz        L5095
    cmp       %rax,	18
    jz        L5096
    cmp       %rax,	19
    jz        L5097
    jmp       L5098
L5095:
    test      %r13,	%r13
    jz        L5100
    cmp       %r14,	%r13
    jle       L5100
    lea       %rcx,	[%rip+L9044]
    call      cc_support.terror
L5100:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rsi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jnz       L5102
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%rsi
    movsx     %rax,	word ptr[%rax + %r10*2]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    cmp       %r10,	1
    jnz       L5102
    movsxd    %rax,	dword ptr[%rdi+52]
    cmp       %rax,	[%rip+cc_decls.trefchar]
    jz        L5101
L5102:
    mov       %rcx,	%rdi
    mov       %rdx,	%rsi
    call      cc_parse.coercemode
    mov       %rdi,	%rax
L5101:
    jmp       L5094
L5096:
    mov       %rax,	[%rbp + cc_parse.readinitexpr2.e]
    movzx     %rax,	word ptr[%rax+102]
    mov       %r12,	%rax
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%r12
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jnz       L5104
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%r12
    movsx     %rax,	word ptr[%rax + %r10*2]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    cmp       %r10,	6
    jnz       L5104
    movsxd    %rax,	dword ptr[%rdi+52]
    cmp       %rax,	[%rip+cc_decls.trefchar]
    jz        L5103
L5104:
    mov       %rcx,	%rdi
    mov       %rdx,	%r12
    call      cc_parse.coercemode
    mov       %rdi,	%rax
L5103:
    mov       %rax,	[%rbp + cc_parse.readinitexpr2.e]
    mov       %rax,	[%rax+32]
    mov       [%rbp + cc_parse.readinitexpr2.e],	%rax
    mov       %rax,	[%rbp + cc_parse.readinitexpr2.e]
    test      %rax,	%rax
    jnz       L5106
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jnz       L5108
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	18
    jz        L5108
    lea       %rcx,	[%rip+L9045]
    call      cc_support.terror
L5108:
    jmp       L5105
L5106:
    mov       %rax,	[%rbp + cc_parse.readinitexpr2.e]
    movzx     %rax,	word ptr[%rax+102]
    mov       %rsi,	%rax
L5105:
    jmp       L5094
L5097:
    mov       %rcx,	%rdi
    mov       %rdx,	%rsi
    call      cc_parse.coercemode
    mov       %rdi,	%rax
    mov       %rax,	%rdi
    mov       [%rbp + cc_parse.readinitexpr2.ulistx],	%rax
    mov       [%rbp + cc_parse.readinitexpr2.ulist],	%rax
    jmp       L5109
L5098:
L5094:
    lea       %rcx,	[%rbp + cc_parse.readinitexpr2.ulist]
    lea       %rdx,	[%rbp + cc_parse.readinitexpr2.ulistx]
    mov       %r8,	%rdi
    call      cc_lib.addlistunit
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jnz       L5093
L5111:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	18
    jnz       L5113
    call      cc_lex.lex
    jmp       L5093
L5113:
    call      cc_lex.lex
    jmp       L5092
L5093:
    cmp       %rbx,	17
    jnz       L5115
    test      %r13,	%r13
    jnz       L5115
    mov       %rax,	%r14
    lea       %r10,	[%rip+cc_decls.ttlength]
    mov       %r11,	[%rbp + cc_parse.readinitexpr2.m]
    mov       [%r10 + %r11*8],	%rax
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8]
    mov       %r10,	%r14
    imul      %r10,	%rax
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r11,	[%rbp + cc_parse.readinitexpr2.m]
    mov       [%rax + %r11*8],	%r10
L5115:
#cc_parse.readinitexpr2.donestruct:
L5109:
    mov       %rcx,	18
    call      cc_lib.skipsymbol
    mov       %rcx,	28
    mov       %rdx,	[%rbp + cc_parse.readinitexpr2.ulist]
    call      cc_lib.createunit1
    mov       %rdi,	%rax
    mov       [%rdi+48],	%r14d
    mov       %eax,	[%rbp + cc_parse.readinitexpr2.m]
    mov       [%rdi+52],	%eax
    jmp       L5079
L5080:
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readinitexpr2.braces],	%rax
    cmp       %rbx,	17
    jnz       L5118
L5117:
#cc_parse.readinitexpr2.doarraystring:
L5089:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	63
    jz        L5120
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	64
    jz        L5120
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	[%rbp + cc_parse.readinitexpr2.m]
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	1
    jz        L5120
    lea       %rcx,	[%rip+L9046]
    call      cc_support.terror
L5120:
    call      cc_parse.readassignexpr
    mov       %rdi,	%rax
    movsxd    %rax,	dword ptr[%rdi+52]
    cmp       %rax,	[%rip+cc_decls.trefchar]
    jz        L5122
    cmp       %rax,	[%rip+cc_decls.trefwchar]
    jz        L5123
    jmp       L5124
L5122:
    jmp       L5121
L5123:
    jmp       L5121
L5124:
    lea       %rcx,	[%rip+L9047]
    call      cc_support.terror
L5121:
    mov       %eax,	[%rbp + cc_parse.readinitexpr2.m]
    mov       [%rdi+52],	%eax
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	[%rbp + cc_parse.readinitexpr2.m]
    mov       %rax,	[%rax + %r10*8]
    mov       %r13,	%rax
    test      %rax,	%rax
    jnz       L5126
    movsxd    %rax,	dword ptr[%rdi+48]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r11,	[%rbp + cc_parse.readinitexpr2.m]
    mov       [%r10 + %r11*8],	%rax
    lea       %r10,	[%rip+cc_decls.ttlength]
    mov       %r11,	[%rbp + cc_parse.readinitexpr2.m]
    mov       [%r10 + %r11*8],	%rax
    jmp       L5125
L5126:
    movsxd    %rax,	dword ptr[%rdi+48]
    cmp       %rax,	%r13
    jle       L5128
    movsxd    %rax,	dword ptr[%rdi+48]
    lea       %r10,	[%r13+1]
    cmp       %rax,	%r10
    jz        L5128
    lea       %rcx,	[%rip+L9048]
    call      cc_support.terror
L5128:
    movsxd    %rax,	dword ptr[%rdi+48]
    cmp       %rax,	%r13
    jge       L5130
    mov       %rcx,	%r13
    call      mlib.pcm_allocz
    mov       [%rbp + cc_parse.readinitexpr2.newstr],	%rax
    movsxd    %rax,	dword ptr[%rdi+48]
    mov       %r10,	[%rdi]
    mov       %rcx,	[%rbp + cc_parse.readinitexpr2.newstr]
    mov       %rdx,	%r10
    mov       %r8,	%rax
    call      memcpy
    mov       %rax,	[%rbp + cc_parse.readinitexpr2.newstr]
    mov       [%rdi],	%rax
L5130:
    mov       [%rdi+48],	%r13d
L5125:
    mov       %rax,	[%rbp + cc_parse.readinitexpr2.braces]
    test      %rax,	%rax
    jz        L5132
    mov       %rcx,	18
    call      cc_lib.skipsymbol
L5132:
    mov       %rax,	%rdi
    jmp       L5078
L5118:
L5116:
    call      cc_parse.readassignexpr
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	[%rbp + cc_parse.readinitexpr2.m]
    call      cc_parse.coercemode
    mov       %rdi,	%rax
L5079:
    mov       %rax,	%rdi
L5078:
#---------------
    add       %rsp,	88
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.pushblock
cc_parse.pushblock:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
    mov       %rax,	[%rip+cc_decls.blocklevel]
    cmp       %rax,	100
    jl        L5135
    lea       %rcx,	[%rip+L9049]
    call      cc_support.serror
L5135:
    mov       %rax,	[%rip+cc_decls.nextblockno]
    cmp       %rax,	2100
    jl        L5137
    lea       %rcx,	[%rip+L9050]
    call      cc_support.serror
L5137:
    inc       qword ptr[%rip+cc_decls.blocklevel]
    inc       qword ptr[%rip+cc_decls.nextblockno]
    mov       %rdi,	[%rip+cc_decls.currblockno]
    mov       %rbx,	[%rip+cc_decls.blocklevel]
    jmp       L5139
L5138:
    dec       %rbx
    lea       %rax,	[%rip+cc_decls.blockstack]
    mov       %r10,	%rbx
    movsxd    %rax,	dword ptr[%rax + %r10*4]
    mov       %rdi,	%rax
L5139:
    test      %rbx,	%rbx
    jz        L5141
    lea       %rax,	[%rip+cc_decls.blockstack]
    mov       %r10,	%rbx
    movsxd    %rax,	dword ptr[%rax + %r10*4]
    lea       %r10,	[%rip+cc_decls.blockcounts]
    movsxd    %r10,	dword ptr[%r10 + %rax*4]
    test      %r10,	%r10
    jz        L5138
L5141:
    mov       %eax,	%edi
    lea       %r10,	[%rip+cc_decls.blockowner]
    mov       %r11,	[%rip+cc_decls.nextblockno]
    mov       [%r10 + %r11*4],	%eax
    mov       %eax,	[%rip+cc_decls.nextblockno]
    lea       %r10,	[%rip+cc_decls.blockstack]
    mov       %r11,	[%rip+cc_decls.blocklevel]
    mov       [%r10 + %r11*4],	%eax
    mov       [%rip+cc_decls.currblockno],	%rax
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_decls.blockcounts]
    mov       %r11,	[%rip+cc_decls.currblockno]
    mov       [%r10 + %r11*4],	%eax
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.popblock
cc_parse.popblock:
#?>>
#?]]
#---------------
    dec       qword ptr[%rip+cc_decls.blocklevel]
    mov       %rax,	[%rip+cc_decls.blocklevel]
    lea       %r10,	[%rip+cc_decls.blockstack]
    movsxd    %r10,	dword ptr[%r10 + %rax*4]
    mov       [%rip+cc_decls.currblockno],	%r10
#---------------
    ret       
# End 
# Proc cc_parse.readcompoundstmt
cc_parse.readcompoundstmt:
#?>>
    .set cc_parse.readcompoundstmt.ulist, -8
    .set cc_parse.readcompoundstmt.ulistx, -16
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	56
    mov       %rsi,	%rcx
#---------------
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readcompoundstmt.ulistx],	%rax
    mov       [%rbp + cc_parse.readcompoundstmt.ulist],	%rax
    call      cc_lex.lex
    call      cc_parse.pushblock
    test      %rsi,	%rsi
    jz        L5145
    mov       %eax,	1
    lea       %r10,	[%rip+cc_decls.blockcounts]
    mov       [%r10+4],	%eax
L5145:
    jmp       L5147
L5146:
    call      cc_parse.readstatement
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L5150
    jmp       L5147
L5150:
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	7
    jnz       L5152
L5153:
    mov       %rbx,	[%rdi+8]
    mov       %rax,	[%rdi]
    mov       %rax,	[%rax+72]
    test      %rax,	%rax
    jz        L5157
    mov       %rax,	[%rdi]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	7
    jz        L5157
    mov       %eax,	8
    mov       [%rdi+40],	%eax
    xor       %eax,	%eax
    mov       [%rdi+8],	%rax
    lea       %rcx,	[%rbp + cc_parse.readcompoundstmt.ulist]
    lea       %rdx,	[%rbp + cc_parse.readcompoundstmt.ulistx]
    mov       %r8,	%rdi
    call      cc_lib.addlistunit
L5157:
    mov       %rdi,	%rbx
    test      %rdi,	%rdi
    jnz       L5153
    jmp       L5151
L5152:
    lea       %rcx,	[%rbp + cc_parse.readcompoundstmt.ulist]
    lea       %rdx,	[%rbp + cc_parse.readcompoundstmt.ulistx]
    mov       %r8,	%rdi
    call      cc_lib.addlistunit
L5151:
L5147:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	18
    jnz       L5146
    call      cc_lex.lex
    call      cc_parse.popblock
    mov       %rcx,	6
    mov       %rdx,	[%rbp + cc_parse.readcompoundstmt.ulist]
    xor       %r8d,	%r8d
    mov       %r9,	[%rbp + cc_parse.readcompoundstmt.ulistx]
    call      cc_lib.createunit3
L5143:
#---------------
    add       %rsp,	56
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readblock
cc_parse.readblock:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    call      cc_parse.readstatement
    jmp       L5158
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	72
    jnz       L5160
    test      %rdi,	%rdi
    jz        L5160
    call      cc_parse.readstatement
    jmp       L5158
L5160:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	17
    jz        L5162
    lea       %rcx,	[%rip+L9051]
    call      cc_support.serror
L5162:
    xor       %ecx,	%ecx
    call      cc_parse.readcompoundstmt
L5158:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readstatement
cc_parse.readstatement:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    sub       %rax,	9
    cmp       %rax,	83
    jae       L5166
    lea       %r10,	[%rip+L5165]
    jmp       [%r10 + %rax*8]
    .data
L5165:
    .quad     L5189
    .quad     L5166
    .quad     L5166
    .quad     L5166
    .quad     L5166
    .quad     L5166
    .quad     L5166
    .quad     L5166
    .quad     L5173
    .quad     L5166
    .quad     L5166
    .quad     L5166
    .quad     L5166
    .quad     L5166
    .quad     L5166
    .quad     L5166
    .quad     L5166
    .quad     L5166
    .quad     L5166
    .quad     L5166
    .quad     L5166
    .quad     L5166
    .quad     L5166
    .quad     L5166
    .quad     L5166
    .quad     L5166
    .quad     L5166
    .quad     L5166
    .quad     L5166
    .quad     L5166
    .quad     L5166
    .quad     L5166
    .quad     L5166
    .quad     L5166
    .quad     L5166
    .quad     L5166
    .quad     L5166
    .quad     L5166
    .quad     L5166
    .quad     L5166
    .quad     L5166
    .quad     L5166
    .quad     L5166
    .quad     L5166
    .quad     L5166
    .quad     L5166
    .quad     L5166
    .quad     L5166
    .quad     L5166
    .quad     L5166
    .quad     L5166
    .quad     L5166
    .quad     L5166
    .quad     L5166
    .quad     L5166
    .quad     L5166
    .quad     L5166
    .quad     L5166
    .quad     L5190
    .quad     L5166
    .quad     L5166
    .quad     L5166
    .quad     L5206
    .quad     L5167
    .quad     L5166
    .quad     L5187
    .quad     L5188
    .quad     L5168
    .quad     L5169
    .quad     L5170
    .quad     L5171
    .quad     L5175
    .quad     L5180
    .quad     L5174
    .quad     L5172
    .quad     L5206
    .quad     L5206
    .quad     L5206
    .quad     L5206
    .quad     L5206
    .quad     L5206
    .quad     L5166
    .quad     L5206
    .text
L5167:
    call      cc_parse.readifstmt
    jmp       L5163
L5168:
    call      cc_parse.readforstmt
    jmp       L5163
L5169:
    call      cc_parse.readwhilestmt
    jmp       L5163
L5170:
    call      cc_parse.readdostmt
    jmp       L5163
L5171:
    call      cc_parse.readreturnstmt
    jmp       L5163
L5172:
    call      cc_parse.readswitchstmt
    jmp       L5163
L5173:
    xor       %ecx,	%ecx
    call      cc_parse.readcompoundstmt
    jmp       L5163
L5174:
    call      cc_parse.readgotostmt
    jmp       L5163
L5175:
    mov       %rax,	[%rip+cc_parse.loopindex]
    test      %rax,	%rax
    jz        L5177
    lea       %rax,	[%rip+cc_parse.looptypestack]
    mov       %r10,	[%rip+cc_parse.loopindex]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	76
    jnz       L5179
    mov       %rcx,	20
    call      cc_lib.createunit0
    mov       %rdi,	%rax
    call      cc_lex.lex
    jmp       L5178
L5179:
    mov       %rcx,	23
    call      cc_lib.createunit0
    mov       %rdi,	%rax
    call      cc_lex.lex
L5178:
    jmp       L5176
L5177:
    lea       %rcx,	[%rip+L9052]
    call      cc_support.serror
L5176:
    jmp       L5164
L5180:
    mov       %rsi,	[%rip+cc_parse.loopindex]
    jmp       L5182
L5181:
    dec       %rsi
L5182:
    test      %rsi,	%rsi
    jz        L5184
    lea       %rax,	[%rip+cc_parse.looptypestack]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	76
    jnz       L5181
L5184:
    test      %rsi,	%rsi
    jnz       L5186
    lea       %rcx,	[%rip+L9053]
    call      cc_support.serror
L5186:
    mov       %rcx,	21
    call      cc_lib.createunit0
    mov       %rdi,	%rax
    call      cc_lex.lex
    jmp       L5164
L5187:
    call      cc_parse.readcaselabel
    jmp       L5163
L5188:
    call      cc_lex.lex
    mov       %rcx,	10
    call      cc_lib.skipsymbol
    call      cc_parse.readstatement
    mov       %rcx,	19
    mov       %rdx,	%rax
    call      cc_lib.createunit1
    jmp       L5163
L5189:
    call      cc_lex.lex
    xor       %eax,	%eax
    jmp       L5163
L5190:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	10
    jnz       L5192
    mov       %rcx,	17
    xor       %edx,	%edx
    call      cc_lib.createunit1
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       %rcx,	[%rip+cc_decls.currproc]
    mov       %rdx,	%rax
    mov       %r8,	3
    xor       %r9d,	%r9d
    call      cc_lib.resolvename
    mov       %rbx,	%rax
    test      %rbx,	%rbx
    jz        L5194
    movsxd    %rax,	dword ptr[%rbx+88]
    cmp       %rax,	-1
    jnz       L5196
    call      msys.m$print_startcon
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L9054]
    call      cc_support.terror
L5196:
    jmp       L5193
L5194:
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       %rcx,	[%rip+cc_decls.currproc]
    mov       %rdx,	%rax
    mov       %r8,	14
    call      cc_lib.createdupldef
    mov       %rbx,	%rax
    xor       %eax,	%eax
    mov       [%rbx+102],	%ax
L5193:
    mov       %eax,	4294967295
    mov       [%rbx+88],	%eax
    mov       [%rdi],	%rbx
    call      cc_lex.lex
    call      cc_lex.lex
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	18
    jz        L5197
L5198:
    call      cc_parse.istypestarter
    test      %rax,	%rax
    jnz       L5200
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	86
    jnz       L5199
L5200:
    jmp       L5197
L5199:
    call      cc_parse.readstatement
    mov       [%rdi+16],	%rax
L5197:
    mov       %rax,	%rdi
    jmp       L5163
L5192:
    xor       %eax,	%eax
    mov       [%rip+cc_parse.ist_symptr],	%rax
    mov       %rcx,	[%rip+cc_decls.currproc]
    call      cc_parse.isusertype
    cmp       %rax,	20
    jnz       L5203
L5202:
    mov       %rax,	[%rip+cc_parse.ist_symptr]
    test      %rax,	%rax
    jz        L5205
    mov       %rax,	[%rip+cc_parse.ist_symptr]
    lea       %r10,	[%rip+cc_decls.lx]
    mov       [%r10],	%rax
L5205:
    call      cc_parse.readexpression
    mov       %rdi,	%rax
L5191:
    jmp       L5164
L5206:
#cc_parse.readstatement.doreaddecl:
L5203:
    call      cc_parse.readlocaldecl
    jmp       L5163
L5166:
    call      cc_parse.readexpression
    mov       %rdi,	%rax
L5164:
    mov       %rcx,	9
    call      cc_lib.skipsymbol
    mov       %rax,	%rdi
L5163:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readifstmt
cc_parse.readifstmt:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
#---------------
    call      cc_lex.lex
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %eax,	[%rax+16]
    mov       %r13,	%rax
    call      cc_parse.readcond
    mov       %rbx,	%rax
    mov       %rcx,	%rbx
    call      cc_parse.coercecond
    xor       %ecx,	%ecx
    call      cc_parse.readblock
    mov       %rsi,	%rax
    xor       %r12,	%r12
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	73
    jnz       L5209
    call      cc_lex.lex
    mov       %rcx,	1
    call      cc_parse.readblock
    mov       %r12,	%rax
L5209:
    mov       %rcx,	12
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    mov       %r9,	%r12
    call      cc_lib.createunit3
    mov       %rdi,	%rax
    mov       [%rdi+44],	%r13d
    mov       %rcx,	%rbx
    call      cc_parse.iscondtrue
    test      %rax,	%rax
    jz        L5211
    test      %rsi,	%rsi
    jnz       L5213
    mov       %rcx,	6
    call      cc_lib.createunit0
    mov       %rsi,	%rax
L5213:
    mov       %rcx,	%rdi
    mov       %rdx,	%rsi
    call      cc_parse.deleteunit
    jmp       L5210
L5211:
    mov       %rcx,	%rbx
    call      cc_parse.iscondfalse
    test      %rax,	%rax
    jz        L5214
    test      %r12,	%r12
    jnz       L5216
    mov       %rcx,	6
    call      cc_lib.createunit0
    mov       %r12,	%rax
L5216:
    mov       %rcx,	%rdi
    mov       %rdx,	%r12
    call      cc_parse.deleteunit
L5214:
L5210:
    mov       %rax,	%rdi
L5207:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.iscondtrue
cc_parse.iscondtrue:
#?>>
#?]]
#---------------
    movsxd    %rax,	dword ptr[%rcx+40]
    cmp       %rax,	1
    jnz       L5218
    mov       %rax,	[%rcx]
    test      %rax,	%rax
    jz        L5218
    mov       %rax,	1
    jmp       L5219
L5218:
    xor       %eax,	%eax
L5219:
L5217:
#---------------
    ret       
# End 
# Proc cc_parse.iscondfalse
cc_parse.iscondfalse:
#?>>
#?]]
#---------------
    movsxd    %rax,	dword ptr[%rcx+40]
    cmp       %rax,	1
    jnz       L5221
    mov       %rax,	[%rcx]
    test      %rax,	%rax
    jnz       L5221
    mov       %rax,	1
    jmp       L5222
L5221:
    xor       %eax,	%eax
L5222:
L5220:
#---------------
    ret       
# End 
# Proc cc_parse.deleteunit
cc_parse.deleteunit:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	16
#---------------
    mov       %rdi,	[%rcx+8]
    mov       %rax,	%rdx
    push      %rcx
    mov       %r11,	8
L9055:
    mov       %r10,	[%rax]
    mov       [%rcx],	%r10
    add       %rcx,	8
    add       %rax,	8
    dec       %r11
    jnz       L9055
    pop       %rcx
    mov       [%rcx+8],	%rdi
#---------------
    add       %rsp,	16
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readforstmt
cc_parse.readforstmt:
#?>>
    .set cc_parse.readforstmt.ulist, -8
    .set cc_parse.readforstmt.ulistx, -16
    .set cc_parse.readforstmt.linkage, -24
    .set cc_parse.readforstmt.m, -32
    .set cc_parse.readforstmt.mbase, -40
    .set cc_parse.readforstmt.pm, -48
    .set cc_parse.readforstmt.d, -56
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	96
#---------------
    call      cc_lex.lex
    mov       %rcx,	13
    call      cc_lib.skipsymbol
    xor       %r14,	%r14
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	9
    jz        L5226
    call      cc_parse.istypestarter
    test      %rax,	%rax
    jz        L5228
    mov       %r14,	1
    call      cc_parse.pushblock
    mov       %rcx,	[%rip+cc_decls.currproc]
    lea       %rdx,	[%rbp + cc_parse.readforstmt.linkage]
    call      cc_parse.readdeclspec
    mov       [%rbp + cc_parse.readforstmt.mbase],	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readforstmt.ulistx],	%rax
    mov       [%rbp + cc_parse.readforstmt.ulist],	%rax
L5229:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L5231
    cmp       %rax,	25
    jz        L5231
    cmp       %rax,	13
    jnz       L5232
L5231:
    mov       %rcx,	[%rip+cc_decls.currproc]
    lea       %rdx,	[%rbp + cc_parse.readforstmt.d]
    mov       %r8,	[%rbp + cc_parse.readforstmt.mbase]
    lea       %r9,	[%rbp + cc_parse.readforstmt.pm]
    call      cc_parse.readtype
    mov       [%rbp + cc_parse.readforstmt.m],	%rax
    mov       %rax,	[%rbp + cc_parse.readforstmt.d]
    test      %rax,	%rax
    jnz       L5234
    lea       %rcx,	[%rip+L9056]
    call      cc_support.serror
L5234:
    mov       %rax,	[%rbp + cc_parse.readforstmt.linkage]
    cmp       %rax,	5
    jz        L5237
    mov       %rax,	[%rbp + cc_parse.readforstmt.pm]
    test      %rax,	%rax
    jz        L5236
L5237:
    lea       %rcx,	[%rip+L9057]
    call      cc_support.serror
L5236:
    mov       %rcx,	[%rbp + cc_parse.readforstmt.d]
    mov       %rdx,	[%rbp + cc_parse.readforstmt.m]
    mov       %r8,	[%rbp + cc_parse.readforstmt.linkage]
    call      cc_parse.readframevar
    mov       [%rbp + cc_parse.readforstmt.d],	%rax
    mov       %rax,	[%rbp + cc_parse.readforstmt.d]
    mov       %rax,	[%rax+72]
    test      %rax,	%rax
    jz        L5239
    mov       %rcx,	8
    call      cc_lib.createunit0
    mov       %r13,	%rax
    mov       %rax,	[%rbp + cc_parse.readforstmt.d]
    mov       [%r13],	%rax
    lea       %rcx,	[%rbp + cc_parse.readforstmt.ulist]
    lea       %rdx,	[%rbp + cc_parse.readforstmt.ulistx]
    mov       %r8,	%r13
    call      cc_lib.addlistunit
L5239:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jnz       L5242
L5241:
    call      cc_lex.lex
    jmp       L5240
L5242:
    jmp       L5230
L5240:
    jmp       L5229
L5232:
    lea       %rcx,	[%rip+L9058]
    call      cc_support.serror
    jmp       L5229
L5230:
    mov       %rcx,	6
    mov       %rdx,	[%rbp + cc_parse.readforstmt.ulist]
    xor       %r8d,	%r8d
    mov       %r9,	[%rbp + cc_parse.readforstmt.ulistx]
    call      cc_lib.createunit3
    mov       %rdi,	%rax
    jmp       L5227
L5228:
    call      cc_parse.readexpression
    mov       %rdi,	%rax
L5227:
    jmp       L5225
L5226:
    mov       %rcx,	2
    call      cc_lib.createunit0
    mov       %rdi,	%rax
L5225:
    mov       %rcx,	9
    call      cc_lib.skipsymbol
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	9
    jz        L5244
    call      cc_parse.readexpression
    mov       %rbx,	%rax
    mov       %rcx,	%rbx
    call      cc_parse.coercecond
    jmp       L5243
L5244:
    mov       %rcx,	2
    call      cc_lib.createunit0
    mov       %rbx,	%rax
L5243:
    mov       %rcx,	9
    call      cc_lib.skipsymbol
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	14
    jz        L5246
    call      cc_parse.readexprstmt
    mov       %rsi,	%rax
    jmp       L5245
L5246:
    xor       %rsi,	%rsi
L5245:
    mov       %rcx,	14
    call      cc_lib.skipsymbol
    mov       %rcx,	76
    call      cc_parse.pushloop
    xor       %ecx,	%ecx
    call      cc_parse.readblock
    mov       %r12,	%rax
    call      cc_parse.poploop
    test      %r14,	%r14
    jz        L5248
    call      cc_parse.popblock
L5248:
    mov       [%rdi+8],	%rbx
    mov       [%rbx+8],	%rsi
    mov       %rcx,	13
    mov       %rdx,	%rdi
    mov       %r8,	%r12
    call      cc_lib.createunit2
L5224:
#---------------
    add       %rsp,	96
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readwhilestmt
cc_parse.readwhilestmt:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
    call      cc_lex.lex
    call      cc_parse.readcond
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    call      cc_parse.coercecond
    mov       %rcx,	76
    call      cc_parse.pushloop
    xor       %ecx,	%ecx
    call      cc_parse.readblock
    mov       %rbx,	%rax
    call      cc_parse.poploop
    mov       %rcx,	14
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      cc_lib.createunit2
L5249:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readdostmt
cc_parse.readdostmt:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
    call      cc_lex.lex
    mov       %rcx,	76
    call      cc_parse.pushloop
    xor       %ecx,	%ecx
    call      cc_parse.readblock
    mov       %rdi,	%rax
    call      cc_parse.poploop
    mov       %rcx,	77
    call      cc_lib.skipsymbol
    call      cc_parse.readcond
    mov       %rbx,	%rax
    mov       %rcx,	%rbx
    call      cc_parse.coercecond
    mov       %rcx,	9
    call      cc_lib.skipsymbol
    mov       %rcx,	15
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      cc_lib.createunit2
L5250:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readreturnstmt
cc_parse.readreturnstmt:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    call      cc_lex.lex
    xor       %rdi,	%rdi
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	9
    jz        L5253
    mov       %rax,	[%rip+cc_decls.currproc]
    movzx     %rax,	word ptr[%rax+102]
    test      %rax,	%rax
    jnz       L5255
    lea       %rcx,	[%rip+L9059]
    call      cc_support.terror
L5255:
    call      cc_parse.readexpression
    mov       %rdi,	%rax
    mov       %rax,	[%rip+cc_decls.currproc]
    movzx     %rax,	word ptr[%rax+102]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      cc_parse.coercemode
    mov       %rdi,	%rax
    mov       %rcx,	9
    call      cc_lib.checksymbol
    jmp       L5252
L5253:
    mov       %rax,	[%rip+cc_decls.currproc]
    movzx     %rax,	word ptr[%rax+102]
    test      %rax,	%rax
    jz        L5256
    lea       %rcx,	[%rip+L9060]
    call      cc_support.terror
L5256:
L5252:
    call      cc_lex.lex
    mov       %rcx,	9
    mov       %rdx,	%rdi
    call      cc_lib.createunit1
L5251:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readgotostmt
cc_parse.readgotostmt:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
    call      cc_lex.lex
    mov       %rcx,	67
    call      cc_lib.checksymbol
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       %rcx,	[%rip+cc_decls.currproc]
    mov       %rdx,	%rax
    mov       %r8,	3
    xor       %r9d,	%r9d
    call      cc_lib.resolvename
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L5259
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       %rcx,	[%rip+cc_decls.currproc]
    mov       %rdx,	%rax
    mov       %r8,	14
    call      cc_lib.createdupldef
    mov       %rdi,	%rax
    xor       %eax,	%eax
    mov       [%rdi+102],	%ax
L5259:
    mov       %rcx,	16
    xor       %edx,	%edx
    call      cc_lib.createunit1
    mov       %rbx,	%rax
    mov       [%rbx],	%rdi
    call      cc_lex.lex
    mov       %rcx,	9
    call      cc_lib.skipsymbol
    mov       %rax,	%rbx
L5257:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readswitchstmt
cc_parse.readswitchstmt:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
    call      cc_lex.lex
    call      cc_parse.readcond
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	3
    call      cc_parse.coercemode
    mov       %rcx,	83
    call      cc_parse.pushloop
    xor       %ecx,	%ecx
    call      cc_parse.readblock
    mov       %rbx,	%rax
    mov       %rcx,	22
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      cc_lib.createunit2
    mov       %rsi,	%rax
    lea       %rax,	[%rip+cc_parse.casevaluestack]
    mov       %r10,	[%rip+cc_parse.loopindex]
    mov       %rax,	[%rax + %r10*8-8]
    mov       [%rsi],	%rax
    call      cc_parse.poploop
    mov       %rax,	%rsi
L5260:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readcaselabel
cc_parse.readcaselabel:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
    call      cc_lex.lex
    call      cc_parse.readconstintexpr
    mov       %rbx,	%rax
    mov       %rcx,	10
    call      cc_lib.skipsymbol
    call      cc_parse.readstatement
    mov       %rcx,	18
    mov       %rdx,	%rax
    call      cc_lib.createunit1
    mov       %rdi,	%rax
    mov       [%rdi],	%rbx
    mov       %rcx,	%rbx
    call      cc_parse.addcasevalue
    mov       %rax,	%rdi
L5261:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readexprstmt
cc_parse.readexprstmt:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    call      cc_parse.readexpression
L5262:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_parse.readcond
cc_parse.readcond:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rcx,	13
    call      cc_lib.skipsymbol
    call      cc_parse.readexpression
    mov       %rdi,	%rax
    mov       %rcx,	14
    call      cc_lib.skipsymbol
    mov       %rax,	%rdi
L5263:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_parse.isusertype
cc_parse.isusertype:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    mov       %r8,	1
    mov       %r9,	[%rip+cc_decls.currblockno]
    call      cc_lib.resolvename
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L5266
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	5
    jnz       L5268
    movzx     %rax,	word ptr[%rdi+102]
    jmp       L5264
L5268:
    mov       [%rip+cc_parse.ist_symptr],	%rdi
L5266:
    mov       %rax,	20
L5264:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readlocaldecl
cc_parse.readlocaldecl:
#?>>
    .set cc_parse.readlocaldecl.linkage, -8
    .set cc_parse.readlocaldecl.wasdef, -16
    .set cc_parse.readlocaldecl.d, -24
    .set cc_parse.readlocaldecl.ulist, -32
    .set cc_parse.readlocaldecl.ulistx, -40
    .set cc_parse.readlocaldecl.pm, -48
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	88
#---------------
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readlocaldecl.ulistx],	%rax
    mov       [%rbp + cc_parse.readlocaldecl.ulist],	%rax
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %r12,	%rax
    mov       %rcx,	[%rip+cc_decls.currproc]
    lea       %rdx,	[%rbp + cc_parse.readlocaldecl.linkage]
    call      cc_parse.readdeclspec
    mov       %rbx,	%rax
    xor       %rsi,	%rsi
L5270:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L5272
    cmp       %rax,	25
    jz        L5272
    cmp       %rax,	13
    jnz       L5273
L5272:
    inc       %rsi
    mov       %rcx,	[%rip+cc_decls.currproc]
    lea       %rdx,	[%rbp + cc_parse.readlocaldecl.d]
    mov       %r8,	%rbx
    lea       %r9,	[%rbp + cc_parse.readlocaldecl.pm]
    call      cc_parse.readtype
    mov       %rdi,	%rax
    mov       %rax,	[%rbp + cc_parse.readlocaldecl.d]
    test      %rax,	%rax
    jnz       L5275
    lea       %rcx,	[%rip+L9061]
    call      cc_support.serror
L5275:
    mov       %rax,	[%rbp + cc_parse.readlocaldecl.linkage]
    cmp       %rax,	5
    jnz       L5277
    mov       %rcx,	[%rip+cc_decls.currproc]
    mov       %rdx,	[%rbp + cc_parse.readlocaldecl.d]
    mov       %r8,	%rdi
    call      cc_parse.createtypedef
    mov       [%rbp + cc_parse.readlocaldecl.d],	%rax
    jmp       L5276
L5277:
    mov       %rax,	[%rbp + cc_parse.readlocaldecl.pm]
    test      %rax,	%rax
    jz        L5278
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	17
    jnz       L5280
    lea       %rcx,	[%rip+L9062]
    call      cc_support.serror
L5280:
    push      0
    lea       %rax,	[%rbp + cc_parse.readlocaldecl.wasdef]
    push      %rax
    mov       %rcx,	[%rbp + cc_parse.readlocaldecl.d]
    mov       %rdx,	%rdi
    mov       %r8,	[%rbp + cc_parse.readlocaldecl.linkage]
    mov       %r9,	[%rbp + cc_parse.readlocaldecl.pm]
    sub       %rsp,	32
    call      cc_parse.readfunction
    add       %rsp,	48
    mov       [%rbp + cc_parse.readlocaldecl.d],	%rax
    jmp       L5276
L5278:
    mov       %rcx,	[%rbp + cc_parse.readlocaldecl.d]
    mov       %rdx,	%rdi
    mov       %r8,	[%rbp + cc_parse.readlocaldecl.linkage]
    call      cc_parse.readframevar
    mov       [%rbp + cc_parse.readlocaldecl.d],	%rax
    mov       %rcx,	7
    call      cc_lib.createunit0
    mov       %r13,	%rax
    mov       %rax,	[%rbp + cc_parse.readlocaldecl.d]
    mov       [%r13],	%rax
    lea       %rcx,	[%rbp + cc_parse.readlocaldecl.ulist]
    lea       %rdx,	[%rbp + cc_parse.readlocaldecl.ulistx]
    mov       %r8,	%r13
    call      cc_lib.addlistunit
L5276:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jnz       L5283
L5282:
    call      cc_lex.lex
    jmp       L5281
L5283:
    mov       %rcx,	9
    call      cc_lib.skipsymbol
    jmp       L5271
L5281:
    jmp       L5270
L5273:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	12
    jz        L5285
    cmp       %rax,	18
    jz        L5285
    cmp       %rax,	19
    jz        L5285
    cmp       %rax,	3
    jz        L5286
    jmp       L5287
L5285:
    mov       %rcx,	9
    call      cc_lib.skipsymbol
    jmp       L5271
L5286:
    mov       %rcx,	9
    call      cc_lib.skipsymbol
    jmp       L5271
L5287:
    mov       %rcx,	%rdi
    call      cc_lib.typename
    lea       %rcx,	[%rip+L9063]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L5284:
    jmp       L5270
L5271:
    mov       %rax,	[%rbp + cc_parse.readlocaldecl.ulist]
L5269:
#---------------
    add       %rsp,	88
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createtypedef
cc_parse.createtypedef:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	1
    mov       %r9,	[%rip+cc_decls.currblockno]
    call      cc_lib.checkdupl
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L5290
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	5
    jz        L5292
    mov       %rax,	[%rdi]
    lea       %rcx,	[%rip+L9064]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L5292:
    movzx     %rax,	word ptr[%rdi+102]
    cmp       %rax,	%r12
    jz        L5294
    movzx     %rax,	word ptr[%rdi+102]
    mov       %rcx,	%rax
    mov       %rdx,	%r12
    call      cc_parse.comparemode
    test      %rax,	%rax
    jnz       L5296
    mov       %rax,	[%rdi]
    lea       %rcx,	[%rip+L9065]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L5296:
L5294:
    mov       %rax,	%rdi
    jmp       L5288
L5290:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	5
    call      cc_lib.createdupldef
    mov       %rdi,	%rax
    mov       [%rdi+102],	%r12w
    mov       %rax,	%rdi
    lea       %r10,	[%rip+cc_decls.tttypedef]
    mov       %r11,	%r12
    mov       [%r10 + %r11*8],	%rax
    mov       %ax,	[%rip+cc_decls.currblockno]
    mov       [%rdi+96],	%ax
    mov       %eax,	1
    lea       %r10,	[%rip+cc_decls.blockcounts]
    mov       %r11,	[%rip+cc_decls.currblockno]
    mov       [%r10 + %r11*4],	%eax
    mov       %rax,	%rdi
L5288:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readparams
cc_parse.readparams:
#?>>
    .set cc_parse.readparams.owner, 64
    .set cc_parse.readparams.ulist, -8
    .set cc_parse.readparams.ulistx, -16
    .set cc_parse.readparams.pm, -24
    .set cc_parse.readparams.lastbasetype, -32
    .set cc_parse.readparams.d, -40
    .set cc_parse.readparams.names, -48
    .set cc_parse.readparams.nonames, -56
    .set cc_parse.readparams.reported, -64
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	96
#---------------
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readparams.d],	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readparams.ulistx],	%rax
    mov       [%rbp + cc_parse.readparams.ulist],	%rax
    xor       %eax,	%eax
    mov       %r14,	%rax
    mov       %rsi,	%rax
    mov       %r12,	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readparams.lastbasetype],	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readparams.names],	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readparams.nonames],	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readparams.reported],	%rax
    jmp       L5299
L5298:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	21
    jnz       L5302
    mov       %r12,	1
    call      cc_lex.lex
    jmp       L5300
L5302:
    call      cc_parse.istypestarter
    test      %rax,	%rax
    jz        L5304
    sub       %rsp,	8
    lea       %rax,	[%rbp + cc_parse.readparams.lastbasetype]
    push      %rax
    lea       %rcx,	[%rbp + cc_parse.readparams.d]
    mov       %rdx,	1
    lea       %r8,	[%rbp + cc_parse.readparams.pm]
    xor       %r9d,	%r9d
    sub       %rsp,	32
    call      cc_parse.readcasttype
    add       %rsp,	48
    mov       %rbx,	%rax
    mov       %rax,	[%rbp + cc_parse.readparams.pm]
    test      %rax,	%rax
    jz        L5306
    mov       %rcx,	%rbx
    mov       %rdx,	[%rbp + cc_parse.readparams.pm]
    call      cc_lib.createprocmode
    mov       %rcx,	%rax
    call      cc_lib.createrefmode
    mov       %rbx,	%rax
L5306:
    jmp       L5303
L5304:
    mov       %rax,	[%rbp + cc_parse.readparams.lastbasetype]
    test      %rax,	%rax
    jnz       L5308
    lea       %rcx,	[%rip+L9066]
    call      cc_support.serror
L5308:
    sub       %rsp,	8
    push      0
    lea       %rcx,	[%rbp + cc_parse.readparams.d]
    mov       %rdx,	1
    lea       %r8,	[%rbp + cc_parse.readparams.pm]
    mov       %r9,	[%rbp + cc_parse.readparams.lastbasetype]
    sub       %rsp,	32
    call      cc_parse.readcasttype
    add       %rsp,	48
    mov       %rbx,	%rax
L5303:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jz        L5310
    cmp       %rax,	14
    jz        L5311
    jmp       L5312
L5310:
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rcx,	%rax
    call      cc_lib.createrefmode
    mov       %rbx,	%rax
    jmp       L5309
L5311:
    lea       %rax,	[%rip+cc_decls.ttparams]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      cc_lib.createprocmode
    mov       %rcx,	%rax
    call      cc_lib.createrefmode
    mov       %rbx,	%rax
L5312:
L5309:
    mov       %rcx,	24
    call      mlib.pcm_allocz
    mov       [%rbp + cc_parse.readparams.pm],	%rax
    mov       %rax,	[%rbp + cc_parse.readparams.d]
    mov       %r10,	[%rbp + cc_parse.readparams.pm]
    mov       [%r10],	%rax
    mov       %eax,	%ebx
    mov       %r10,	[%rbp + cc_parse.readparams.pm]
    mov       [%r10+16],	%eax
    inc       %rsi
    mov       %rax,	[%rbp + cc_parse.readparams.d]
    test      %rax,	%rax
    jz        L5314
    mov       %rax,	1
    mov       [%rbp + cc_parse.readparams.names],	%rax
    jmp       L5313
L5314:
    mov       %rax,	1
    mov       [%rbp + cc_parse.readparams.nonames],	%rax
L5313:
    mov       %rax,	[%rbp + cc_parse.readparams.names]
    test      %rax,	%rax
    jz        L5316
    mov       %rax,	[%rbp + cc_parse.readparams.nonames]
    test      %rax,	%rax
    jz        L5316
    mov       %rax,	[%rbp + cc_parse.readparams.reported]
    test      %rax,	%rax
    jnz       L5316
    mov       %rax,	1
    mov       [%rbp + cc_parse.readparams.reported],	%rax
L5316:
    mov       %rax,	[%rbp + cc_parse.readparams.d]
    test      %rax,	%rax
    jz        L5318
    inc       %r14
    mov       %rdi,	[%rbp + cc_parse.readparams.ulist]
    jmp       L5320
L5319:
    mov       %rax,	[%rdi]
    cmp       %rax,	[%rbp + cc_parse.readparams.d]
    jnz       L5323
    mov       %rax,	[%rbp + cc_parse.readparams.d]
    movzx     %rax,	byte ptr[%rax+109]
    lea       %r10,	[%rip+cc_tables.namenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rax,	[%rbp + cc_parse.readparams.d]
    mov       %rax,	[%rax]
    lea       %rcx,	[%rip+L9067]
    mov       %rdx,	%rax
    mov       %r8,	%r10
    call      cc_support.serror_ss
L5323:
    mov       %rdi,	[%rdi+8]
L5320:
    test      %rdi,	%rdi
    jnz       L5319
L5318:
    lea       %rcx,	[%rbp + cc_parse.readparams.ulist]
    lea       %rdx,	[%rbp + cc_parse.readparams.ulistx]
    mov       %r8,	[%rbp + cc_parse.readparams.pm]
    call      cc_lib.addlistparam
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jz        L5325
    cmp       %rax,	21
    jz        L5326
    cmp       %rax,	14
    jz        L5326
    jmp       L5327
L5325:
    call      cc_lex.lex
    jmp       L5324
L5326:
    jmp       L5324
L5327:
    lea       %rcx,	[%rip+L9068]
    call      cc_support.serror
L5324:
L5299:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	14
    jnz       L5298
L5300:
    xor       %r13,	%r13
    mov       %rcx,	14
    call      cc_lib.skipsymbol
    test      %r12,	%r12
    jz        L5329
    mov       %r13,	3
    jmp       L5328
L5329:
    test      %rsi,	%rsi
    jnz       L5330
    mov       %r13,	1
    jmp       L5328
L5330:
    cmp       %rsi,	1
    jnz       L5331
    test      %rbx,	%rbx
    jnz       L5331
    mov       %r13,	2
    xor       %rsi,	%rsi
    xor       %eax,	%eax
    mov       %r10,	[%rbp + cc_parse.readparams.ulist]
    mov       [%r10+16],	%eax
L5331:
L5328:
    mov       %rax,	[%rbp + cc_parse.readparams.ulist]
    test      %rax,	%rax
    jnz       L5333
    mov       %rcx,	24
    call      mlib.pcm_allocz
    mov       [%rbp + cc_parse.readparams.ulist],	%rax
L5333:
    mov       %ax,	%si
    mov       %r10,	[%rbp + cc_parse.readparams.ulist]
    mov       [%r10+20],	%ax
    mov       %ax,	%r13w
    mov       %r10,	[%rbp + cc_parse.readparams.ulist]
    mov       [%r10+22],	%ax
    mov       %rax,	[%rbp + cc_parse.readparams.ulist]
L5297:
#---------------
    add       %rsp,	96
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readcasttype
cc_parse.readcasttype:
#?>>
    .set cc_parse.readcasttype.mbase, 88
    .set cc_parse.readcasttype.linkage, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
    mov       %r13,	%r9
#---------------
    mov       %rax,	[%rip+cc_decls.currproc]
    test      %rax,	%rax
    jz        L5336
    mov       %rax,	[%rip+cc_decls.currproc]
    jmp       L5335
L5336:
    mov       %rax,	[%rip+cc_decls.stmodule]
L5335:
    mov       %rdi,	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readcasttype.linkage],	%rax
    xor       %eax,	%eax
    mov       [%rbx],	%rax
    test      %r13,	%r13
    jnz       L5338
    mov       %rcx,	%rdi
    lea       %rdx,	[%rbp + cc_parse.readcasttype.linkage]
    call      cc_parse.readdeclspec
    mov       %r13,	%rax
    mov       %rax,	[%rbp + cc_parse.readcasttype.mbase]
    test      %rax,	%rax
    jz        L5340
    mov       %rax,	%r13
    mov       %r10,	[%rbp + cc_parse.readcasttype.mbase]
    mov       [%r10],	%rax
L5340:
L5338:
    xor       %eax,	%eax
    mov       [%r12],	%rax
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L5342
    cmp       %rax,	25
    jz        L5342
    cmp       %rax,	13
    jz        L5342
    cmp       %rax,	15
    jnz       L5343
L5342:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	%r13
    mov       %r9,	%r12
    call      cc_parse.readtype
    mov       %r13,	%rax
    mov       %rax,	[%rbx]
    test      %rax,	%rax
    jz        L5345
    test      %rsi,	%rsi
    jnz       L5345
    mov       %rax,	[%rbx]
    mov       %rax,	[%rax]
    lea       %rcx,	[%rip+L9069]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L5345:
L5343:
L5341:
    mov       %rax,	%r13
L5334:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readfunction
cc_parse.readfunction:
#?>>
    .set cc_parse.readfunction.pm, 88
    .set cc_parse.readfunction.wasdef, 96
    .set cc_parse.readfunction.exported, 104
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	32
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
    mov       [%rbp+88],	%r9
#---------------
    mov       %rbx,	[%rip+cc_decls.stmodule]
    xor       %eax,	%eax
    mov       %r10,	[%rbp + cc_parse.readfunction.wasdef]
    mov       [%r10],	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	%r12
    mov       %r8,	1
    xor       %r9d,	%r9d
    call      cc_lib.checkdupl
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L5348
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	6
    jz        L5350
    mov       %rax,	[%r12]
    lea       %rcx,	[%rip+L9070]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L5350:
    mov       %r12,	%rdi
    movzx     %rax,	byte ptr[%r12+110]
    mov       %rsi,	%rax
    cmp       %rsi,	3
    jnz       L5352
    test      %r14,	%r14
    jnz       L5352
    mov       %rsi,	4
    jmp       L5351
L5352:
    cmp       %r14,	1
    jnz       L5353
    mov       %rsi,	2
L5353:
L5351:
    jmp       L5347
L5348:
    mov       %rcx,	%rbx
    mov       %rdx,	%r12
    mov       %r8,	6
    call      cc_lib.createdupldef
    mov       %r12,	%rax
    mov       [%r12+102],	%r13w
    mov       %rax,	%r14
    cmp       %rax,	1
    jz        L5355
    cmp       %rax,	4
    jz        L5356
    jmp       L5357
L5355:
    mov       %rsi,	2
    jmp       L5354
L5356:
    mov       %rsi,	3
    jmp       L5354
L5357:
    mov       %rsi,	4
L5354:
L5347:
    mov       %rax,	[%rbp + cc_parse.readfunction.pm]
    mov       [%r12+80],	%rax
    mov       [%r12+110],	%sil
    mov       %rax,	[%rbp + cc_parse.readfunction.exported]
    test      %rax,	%rax
    jz        L5359
    lea       %rax,	[%r12+108]
    or        byte ptr[%rax],	16
L5359:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	17
    jnz       L5361
    mov       %rax,	1
    mov       %r10,	[%rbp + cc_parse.readfunction.wasdef]
    mov       [%r10],	%rax
    mov       %rax,	[%r12+72]
    test      %rax,	%rax
    jz        L5363
    mov       %rax,	[%r12]
    lea       %rcx,	[%rip+L9071]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L5363:
    cmp       %rsi,	3
    jnz       L5365
    mov       %al,	4
    mov       [%r12+110],	%al
L5365:
    mov       %rcx,	%r12
    call      cc_parse.readfunctionbody
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	9
    jnz       L5367
    lea       %rcx,	[%rip+L9072]
    call      cc_support.serror
L5367:
L5361:
    mov       %rax,	%r12
L5346:
#---------------
    add       %rsp,	32
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readfunctionbody
cc_parse.readfunctionbody:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r14,	%rcx
#---------------
    mov       [%rip+cc_decls.currproc],	%r14
    xor       %eax,	%eax
    mov       [%rip+cc_decls.currblockno],	%rax
    mov       [%rip+cc_decls.nextblockno],	%rax
    xor       %r12,	%r12
    mov       %rax,	[%r14+80]
    mov       %rsi,	%rax
    movsx     %rax,	word ptr[%rsi+20]
    mov       %r13,	%rax
    cmp       %r13,	0
    jle       L5371
L5369:
    mov       %rax,	[%rsi]
    test      %rax,	%rax
    jz        L5372
L5373:
    mov       %rax,	[%rsi]
    mov       %rcx,	%r14
    mov       %rdx,	%rax
    mov       %r8,	9
    call      cc_lib.createdupldef
    mov       %rdi,	%rax
    mov       %rax,	[%rdi]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	36
    jnz       L5375
    mov       %al,	1
    mov       [%rdi+122],	%al
L5375:
    mov       %ax,	1
    mov       [%rdi+96],	%ax
    mov       %eax,	[%rsi+16]
    mov       [%rdi+102],	%ax
L5372:
    mov       %rsi,	[%rsi+8]
    mov       %r12,	1
    dec       %r13
    jnz       L5369
L5371:
    mov       %rcx,	%r12
    call      cc_parse.readcompoundstmt
    mov       %rbx,	%rax
    mov       %rax,	%rbx
    mov       %r10,	[%rip+cc_decls.currproc]
    mov       [%r10+72],	%rax
    xor       %eax,	%eax
    mov       [%rip+cc_decls.currproc],	%rax
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createnegop
cc_parse.createnegop:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%rsi+52]
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%rsi+40]
    cmp       %rax,	1
    jnz       L5378
    mov       %rax,	%rbx
    cmp       %rax,	3
    jz        L5380
    cmp       %rax,	4
    jz        L5380
    cmp       %rax,	9
    jz        L5380
    cmp       %rax,	8
    jz        L5381
    cmp       %rax,	11
    jz        L5382
    jmp       L5383
L5380:
    mov       %rax,	[%rsi]
    neg       %rax
    mov       [%rsi],	%rax
    mov       %rax,	%rsi
    jmp       L5376
L5381:
    mov       %rax,	[%rsi]
    neg       %rax
    mov       %r10,	4294967295
    and       %rax,	%r10
    mov       [%rsi],	%rax
    mov       %rax,	%rsi
    jmp       L5376
L5382:
    movq      %XMM4,	[%rsi]
    xorpd     %XMM4,	[%rip+L9073]
    movq      [%rsi],	%XMM4
    mov       %rax,	%rsi
    jmp       L5376
L5383:
L5379:
L5378:
#cc_parse.createnegop.retry:
L5384:
    cmp       %rbx,	1
    jl        L5386
    cmp       %rbx,	11
    jg        L5386
    mov       %rcx,	%rsi
    call      cc_parse.coercebasetype
    mov       %rcx,	58
    mov       %rdx,	%rsi
    call      cc_lib.createunit1
    mov       %rdi,	%rax
    jmp       L5385
L5386:
    lea       %rax,	[%rip+cc_decls.ttconst]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5387
    lea       %rax,	[%rip+cc_decls.ttconsttype]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rbx,	%rax
    jmp       L5384
L5387:
    call      msys.m$print_startcon
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L9074]
    call      cc_support.terror
L5385:
    mov       %eax,	[%rsi+52]
    mov       [%rdi+52],	%eax
    mov       %rax,	%rdi
L5376:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createabsop
cc_parse.createabsop:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%rsi+52]
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%rsi+40]
    cmp       %rax,	1
    jnz       L5390
    mov       %rax,	%rbx
    cmp       %rax,	3
    jz        L5392
    cmp       %rax,	4
    jnz       L5393
L5392:
    mov       %rax,	[%rsi]
    cmp       %rax,	0
    jge       L9075
    neg       %rax
L9075:
    mov       [%rsi],	%rax
    mov       %rax,	%rsi
    jmp       L5388
L5393:
L5391:
L5390:
    mov       %rcx,	%rbx
    call      cc_lib.isintcc
    test      %rax,	%rax
    jz        L5395
    mov       %rcx,	%rsi
    call      cc_parse.coercebasetype
    mov       %rcx,	59
    mov       %rdx,	%rsi
    call      cc_lib.createunit1
    mov       %rdi,	%rax
    jmp       L5394
L5395:
    lea       %rcx,	[%rip+L9076]
    call      cc_support.terror
L5394:
    mov       %eax,	[%rsi+52]
    mov       [%rdi+52],	%eax
    mov       %rax,	%rdi
L5388:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createinotop
cc_parse.createinotop:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%rsi+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rbx,	%r10
    movsxd    %rax,	dword ptr[%rsi+40]
    cmp       %rax,	1
    jnz       L5398
    mov       %rax,	%rbx
    cmp       %rax,	3
    jz        L5400
    cmp       %rax,	4
    jz        L5400
    cmp       %rax,	8
    jz        L5400
    cmp       %rax,	9
    jnz       L5401
L5400:
    mov       %rax,	[%rsi]
    not       %rax
    mov       [%rsi],	%rax
    mov       %rax,	%rsi
    jmp       L5396
L5401:
L5399:
L5398:
    mov       %rcx,	%rbx
    call      cc_lib.isintcc
    test      %rax,	%rax
    jz        L5403
    mov       %rcx,	%rsi
    call      cc_parse.coercebasetype
    mov       %rcx,	60
    mov       %rdx,	%rsi
    call      cc_lib.createunit1
    mov       %rdi,	%rax
    jmp       L5402
L5403:
    call      msys.m$print_startcon
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L9077]
    call      cc_support.terror
L5402:
    mov       %eax,	[%rsi+52]
    mov       [%rdi+52],	%eax
    mov       %rax,	%rdi
L5396:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createptrop
cc_parse.createptrop:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%r12+52]
    mov       %rbx,	%rax
    lea       %r10,	[%rip+cc_decls.ttisref]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jnz       L5406
    xor       %ecx,	%ecx
    mov       %rdx,	%r12
    xor       %r8d,	%r8d
    lea       %r9,	[%rip+L9078]
    call      cc_show.printunit
    lea       %rcx,	[%rip+L9079]
    call      cc_support.terror
L5406:
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rsi,	%rax
    movsxd    %rax,	dword ptr[%r12+40]
    cmp       %rax,	55
    jnz       L5409
L5408:
    mov       %rdi,	[%r12+16]
    movsxd    %rax,	dword ptr[%r12+52]
    lea       %r10,	[%rip+cc_decls.tttarget]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       [%rdi+52],	%r10d
    mov       %rcx,	%rdi
    call      cc_parse.fixmemopnd
    mov       %rax,	%rdi
    jmp       L5404
L5409:
L5407:
    mov       %rcx,	52
    mov       %rdx,	%r12
    call      cc_lib.createunit1
    mov       %rdi,	%rax
    mov       [%rdi+52],	%esi
    mov       %rcx,	%rdi
    call      cc_parse.arraytopointer
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    call      cc_parse.fixmemopnd
    mov       %rax,	%rdi
L5404:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createincrop
cc_parse.createincrop:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    movsxd    %rax,	dword ptr[%r12+52]
    mov       %rbx,	%rax
    mov       %rcx,	%r12
    mov       %rdx,	1
    call      cc_parse.checklvalue
    mov       %rcx,	%rbx
    call      cc_lib.isintcc
    test      %rax,	%rax
    jz        L5413
    cmp       %rbx,	5
    jnz       L5412
L5413:
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jnz       L5412
    lea       %rcx,	[%rip+L9080]
    call      cc_support.terror
L5412:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    call      cc_lib.createunit1
    mov       %rdi,	%rax
    mov       %eax,	[%r12+52]
    mov       [%rdi+52],	%eax
    mov       %rax,	%rdi
L5410:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createaddrofop
cc_parse.createaddrofop:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
    xor       %rsi,	%rsi
#cc_parse.createaddrofop.restartx:
L5415:
    movsxd    %rax,	dword ptr[%r12+52]
    mov       %rbx,	%rax
    mov       %ax,	[%r12+56]
    test      %ax,	%ax
    jz        L5417
    movsx     %rax,	word ptr[%r12+56]
    mov       %rbx,	%rax
L5417:
    movsxd    %rax,	dword ptr[%r12+40]
    cmp       %rax,	3
    jz        L5419
    cmp       %rax,	55
    jz        L5420
    cmp       %rax,	49
    jz        L5421
    cmp       %rax,	53
    jz        L5422
    cmp       %rax,	4
    jz        L5423
    cmp       %rax,	5
    jz        L5424
    jmp       L5425
L5419:
    mov       %rax,	[%r12]
    lea       %rax,	[%rax+108]
    or        byte ptr[%rax],	1
    mov       %eax,	[%r12+48]
    test      %eax,	%eax
    jz        L5427
    mov       %rax,	[%r12]
    movzx     %rax,	word ptr[%rax+102]
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%r12+48]
    mov       %rsi,	%rax
L5427:
    jmp       L5418
L5420:
    mov       %rax,	[%r12+16]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	3
    jnz       L5429
    mov       %rax,	[%r12+16]
    mov       %eax,	[%rax+48]
    test      %eax,	%eax
    jz        L5429
    mov       %rax,	[%r12+16]
    mov       %rax,	[%rax]
    movzx     %rax,	word ptr[%rax+102]
    mov       %rcx,	%rax
    call      cc_lib.createrefmode
    mov       [%r12+52],	%eax
    mov       %rax,	[%r12+16]
    mov       %eax,	[%rax+48]
    mov       [%r12+48],	%eax
    mov       %rax,	%r12
    jmp       L5414
L5429:
    jmp       L5418
L5421:
    mov       %rdi,	[%r12+16]
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	52
    jnz       L5431
    mov       %rax,	[%rdi+16]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5431
    movsxd    %rax,	dword ptr[%r12]
    mov       %r10,	[%rdi+16]
    mov       %r10,	[%r10]
    add       %rax,	%r10
    mov       %rcx,	%rax
    mov       %rdx,	3
    call      cc_lib.createconstunit
    mov       %r12,	%rax
    mov       %rax,	%r12
    jmp       L5414
L5431:
    jmp       L5432
L5422:
    mov       %eax,	[%r12+48]
    test      %eax,	%eax
    jz        L5434
    movsxd    %rax,	dword ptr[%r12+48]
    movsxd    %r10,	dword ptr[%r12+52]
    lea       %r11,	[%rip+cc_decls.tttarget]
    movsx     %r11,	word ptr[%r11 + %r10*2]
    mov       %rcx,	%r11
    mov       %rdx,	%rax
    call      cc_lib.createarraymode
    mov       %rcx,	%rax
    call      cc_lib.createrefmode
    mov       [%r12+52],	%eax
    mov       %rax,	%r12
    jmp       L5414
L5434:
    jmp       L5418
L5423:
    mov       %r12,	[%r12+16]
    jmp       L5415
L5424:
    mov       %rax,	%r12
    jmp       L5414
L5425:
#cc_parse.createaddrofop.cad1:
L5432:
    mov       %rcx,	%r12
    xor       %edx,	%edx
    call      cc_parse.checklvalue
L5418:
    mov       %rcx,	55
    mov       %rdx,	%r12
    call      cc_lib.createunit1
    mov       %r12,	%rax
    mov       %rcx,	%rbx
    call      cc_lib.createrefmode
    mov       [%r12+52],	%eax
    mov       [%r12+48],	%esi
    mov       %rax,	%r12
L5414:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createaddop
cc_parse.createaddop:
#?>>
    .set cc_parse.createaddop.x, 56
    .set cc_parse.createaddop.y, 64
    .set cc_parse.createaddop.elemsize, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       [%rbp+56],	%rcx
    mov       [%rbp+64],	%rdx
#---------------
    mov       %rcx,	[%rbp + cc_parse.createaddop.x]
    call      cc_parse.getmemmode
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rbx,	%r10
    mov       %rcx,	[%rbp + cc_parse.createaddop.y]
    call      cc_parse.getmemmode
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rsi,	%r10
    mov       %r13,	39
    lea       %rax,	[%rip+cc_tables.dominantmode]
    mov       %r10,	%rbx
    shl       %r10,	5
    lea       %rax,	[%rax + %r10]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %r12,	%rax
    test      %rax,	%rax
    jz        L5437
    mov       %rcx,	[%rbp + cc_parse.createaddop.x]
    mov       %rdx,	%r12
    call      cc_parse.coercemode
    mov       [%rbp + cc_parse.createaddop.x],	%rax
    mov       %rcx,	[%rbp + cc_parse.createaddop.y]
    mov       %rdx,	%r12
    call      cc_parse.coercemode
    mov       [%rbp + cc_parse.createaddop.y],	%rax
    jmp       L5436
L5437:
    cmp       %rbx,	13
    jnz       L5438
#cc_parse.createaddop.doaddref:
L5439:
    mov       %rax,	[%rbp + cc_parse.createaddop.x]
    movsxd    %rax,	dword ptr[%rax+52]
    mov       %r12,	%rax
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%r12
    movsx     %rax,	word ptr[%rax + %r10*2]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r10,	[%r10 + %rax*8]
    mov       [%rbp + cc_parse.createaddop.elemsize],	%r10
    mov       %rax,	[%rbp + cc_parse.createaddop.x]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5441
    mov       %rax,	[%rbp + cc_parse.createaddop.y]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5441
    mov       %rax,	[%rbp + cc_parse.createaddop.y]
    mov       %rax,	[%rax]
    mov       %r10,	[%rbp + cc_parse.createaddop.elemsize]
    imul      %rax,	%r10
    mov       %r10,	[%rbp + cc_parse.createaddop.x]
    add       [%r10],	%rax
    mov       %rax,	[%rbp + cc_parse.createaddop.x]
    jmp       L5435
L5441:
    mov       %rcx,	[%rbp + cc_parse.createaddop.y]
    mov       %rdx,	4
    call      cc_parse.coercemode
    mov       [%rbp + cc_parse.createaddop.y],	%rax
    mov       %rcx,	53
    mov       %rdx,	[%rbp + cc_parse.createaddop.x]
    mov       %r8,	[%rbp + cc_parse.createaddop.y]
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%r12d
    mov       %eax,	[%rbp + cc_parse.createaddop.elemsize]
    mov       [%rdi],	%eax
    mov       %rax,	%rdi
    jmp       L5435
L5438:
    cmp       %rsi,	13
    jnz       L5442
    mov       %rax,	[%rbp + cc_parse.createaddop.x]
    mov       %r10,	[%rbp + cc_parse.createaddop.y]
    mov       [%rbp + cc_parse.createaddop.y],	%rax
    mov       [%rbp + cc_parse.createaddop.x],	%r10
    jmp       L5439
    lea       %rcx,	[%rip+L9081]
    call      cc_support.terror
L5442:
L5436:
    mov       %rax,	[%rbp + cc_parse.createaddop.x]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5444
    mov       %rax,	[%rbp + cc_parse.createaddop.y]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5446
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + cc_parse.createaddop.x]
    mov       %r8,	[%rbp + cc_parse.createaddop.y]
    mov       %r9,	%r12
    call      cc_parse.eval_add
    jmp       L5435
L5446:
    mov       %rax,	[%rbp + cc_parse.createaddop.x]
    mov       %r10,	[%rbp + cc_parse.createaddop.y]
    mov       [%rbp + cc_parse.createaddop.y],	%rax
    mov       [%rbp + cc_parse.createaddop.x],	%r10
L5445:
    mov       %rax,	[%rbp + cc_parse.createaddop.y]
    mov       %rax,	[%rax]
    test      %rax,	%rax
    jnz       L5448
    mov       %rax,	[%rbp + cc_parse.createaddop.x]
    jmp       L5435
L5448:
L5444:
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + cc_parse.createaddop.x]
    mov       %r8,	[%rbp + cc_parse.createaddop.y]
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%r12d
    mov       %rax,	%rdi
L5435:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createsubop
cc_parse.createsubop:
#?>>
    .set cc_parse.createsubop.x, 56
    .set cc_parse.createsubop.y, 64
    .set cc_parse.createsubop.elemsize, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       [%rbp+56],	%rcx
    mov       [%rbp+64],	%rdx
#---------------
    mov       %rcx,	[%rbp + cc_parse.createsubop.x]
    call      cc_parse.getmemmode
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rbx,	%r10
    mov       %rcx,	[%rbp + cc_parse.createsubop.y]
    call      cc_parse.getmemmode
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rsi,	%r10
    mov       %r13,	40
    lea       %rax,	[%rip+cc_tables.dominantmode]
    mov       %r10,	%rbx
    shl       %r10,	5
    lea       %rax,	[%rax + %r10]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %r12,	%rax
    test      %rax,	%rax
    jz        L5451
    mov       %rcx,	[%rbp + cc_parse.createsubop.x]
    mov       %rdx,	%r12
    call      cc_parse.coercemode
    mov       [%rbp + cc_parse.createsubop.x],	%rax
    mov       %rcx,	[%rbp + cc_parse.createsubop.y]
    mov       %rdx,	%r12
    call      cc_parse.coercemode
    mov       [%rbp + cc_parse.createsubop.y],	%rax
    jmp       L5450
L5451:
    cmp       %rbx,	13
    jnz       L5452
    cmp       %rsi,	13
    jz        L5454
    mov       %rax,	[%rbp + cc_parse.createsubop.x]
    movsxd    %rax,	dword ptr[%rax+52]
    mov       %r12,	%rax
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%r12
    movsx     %rax,	word ptr[%rax + %r10*2]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r10,	[%r10 + %rax*8]
    mov       [%rbp + cc_parse.createsubop.elemsize],	%r10
    mov       %rcx,	[%rbp + cc_parse.createsubop.y]
    mov       %rdx,	4
    call      cc_parse.coercemode
    mov       [%rbp + cc_parse.createsubop.y],	%rax
    mov       %rcx,	54
    mov       %rdx,	[%rbp + cc_parse.createsubop.x]
    mov       %r8,	[%rbp + cc_parse.createsubop.y]
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%r12d
    mov       %eax,	[%rbp + cc_parse.createsubop.elemsize]
    mov       [%rdi],	%eax
    mov       %rax,	%rdi
    jmp       L5449
L5454:
    mov       %rax,	[%rbp + cc_parse.createsubop.x]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5456
    mov       %rax,	[%rbp + cc_parse.createsubop.y]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5456
    mov       %rax,	[%rbp + cc_parse.createsubop.y]
    mov       %rax,	[%rax]
    mov       %r10,	[%rbp + cc_parse.createsubop.x]
    movsxd    %r10,	dword ptr[%r10+52]
    lea       %r11,	[%rip+cc_decls.tttarget]
    movsx     %r11,	word ptr[%r11 + %r10*2]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r10,	[%r10 + %r11*8]
    cqo       
    idiv      %r10
    mov       %r10,	[%rbp + cc_parse.createsubop.x]
    sub       [%r10],	%rax
    mov       %eax,	3
    mov       %r10,	[%rbp + cc_parse.createsubop.x]
    mov       [%r10+52],	%eax
    mov       %rax,	[%rbp + cc_parse.createsubop.x]
    jmp       L5449
L5456:
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + cc_parse.createsubop.x]
    mov       %r8,	[%rbp + cc_parse.createsubop.y]
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       %eax,	4
    mov       [%rdi+52],	%eax
    mov       %rax,	[%rbp + cc_parse.createsubop.x]
    movsxd    %rax,	dword ptr[%rax+52]
    lea       %r10,	[%rip+cc_decls.tttarget]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rcx,	%rdi
    mov       %rdx,	%r10
    call      cc_parse.divunit
    mov       %rdi,	%rax
    mov       %eax,	4
    mov       [%rdi+52],	%eax
    mov       %rax,	%rdi
    jmp       L5449
L5455:
L5453:
    mov       %rax,	[%rbp + cc_parse.createsubop.x]
    movsxd    %rax,	dword ptr[%rax+52]
    lea       %r10,	[%rip+cc_decls.tttarget]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rcx,	[%rbp + cc_parse.createsubop.y]
    mov       %rdx,	%r10
    call      cc_parse.mulunit
    mov       [%rbp + cc_parse.createsubop.y],	%rax
    jmp       L5450
L5452:
    lea       %rcx,	[%rip+L9081]
    call      cc_support.terror
L5450:
    mov       %rax,	[%rbp + cc_parse.createsubop.x]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5458
    mov       %rax,	[%rbp + cc_parse.createsubop.y]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5458
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + cc_parse.createsubop.x]
    mov       %r8,	[%rbp + cc_parse.createsubop.y]
    mov       %r9,	%r12
    call      cc_parse.eval_sub
    jmp       L5449
L5458:
    mov       %rax,	[%rbp + cc_parse.createsubop.y]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5460
    mov       %rax,	[%rbp + cc_parse.createsubop.y]
    mov       %rax,	[%rax]
    test      %rax,	%rax
    jnz       L5460
L5460:
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + cc_parse.createsubop.x]
    mov       %r8,	[%rbp + cc_parse.createsubop.y]
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%r12d
    mov       %rax,	%rdi
L5449:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createmulop
cc_parse.createmulop:
#?>>
    .set cc_parse.createmulop.x, 56
    .set cc_parse.createmulop.y, 64
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       [%rbp+56],	%rcx
    mov       [%rbp+64],	%rdx
#---------------
    mov       %rcx,	[%rbp + cc_parse.createmulop.x]
    call      cc_parse.getmemmode
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rbx,	%r10
    mov       %rcx,	[%rbp + cc_parse.createmulop.y]
    call      cc_parse.getmemmode
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rsi,	%r10
    mov       %r13,	41
    lea       %rax,	[%rip+cc_tables.dominantmode]
    mov       %r10,	%rbx
    shl       %r10,	5
    lea       %rax,	[%rax + %r10]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %r12,	%rax
    test      %rax,	%rax
    jz        L5463
    mov       %rcx,	[%rbp + cc_parse.createmulop.x]
    mov       %rdx,	%r12
    call      cc_parse.coercemode
    mov       [%rbp + cc_parse.createmulop.x],	%rax
    mov       %rcx,	[%rbp + cc_parse.createmulop.y]
    mov       %rdx,	%r12
    call      cc_parse.coercemode
    mov       [%rbp + cc_parse.createmulop.y],	%rax
    jmp       L5462
L5463:
    lea       %rcx,	[%rip+L9082]
    call      cc_support.terror
L5462:
    mov       %rax,	[%rbp + cc_parse.createmulop.x]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5465
    mov       %rax,	[%rbp + cc_parse.createmulop.y]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5467
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + cc_parse.createmulop.x]
    mov       %r8,	[%rbp + cc_parse.createmulop.y]
    mov       %r9,	%r12
    call      cc_parse.eval_mul
    jmp       L5461
L5467:
    mov       %rax,	[%rbp + cc_parse.createmulop.x]
    mov       %r10,	[%rbp + cc_parse.createmulop.y]
    mov       [%rbp + cc_parse.createmulop.y],	%rax
    mov       [%rbp + cc_parse.createmulop.x],	%r10
L5466:
L5465:
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + cc_parse.createmulop.x]
    mov       %r8,	[%rbp + cc_parse.createmulop.y]
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%r12d
    mov       %rax,	%rdi
L5461:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createdivop
cc_parse.createdivop:
#?>>
    .set cc_parse.createdivop.x, 56
    .set cc_parse.createdivop.y, 64
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       [%rbp+56],	%rcx
    mov       [%rbp+64],	%rdx
#---------------
    mov       %rcx,	[%rbp + cc_parse.createdivop.x]
    call      cc_parse.getmemmode
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rbx,	%r10
    mov       %rcx,	[%rbp + cc_parse.createdivop.y]
    call      cc_parse.getmemmode
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rsi,	%r10
    mov       %r13,	42
    lea       %rax,	[%rip+cc_tables.dominantmode]
    mov       %r10,	%rbx
    shl       %r10,	5
    lea       %rax,	[%rax + %r10]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %r12,	%rax
    test      %rax,	%rax
    jz        L5470
    mov       %rcx,	[%rbp + cc_parse.createdivop.x]
    mov       %rdx,	%r12
    call      cc_parse.coercemode
    mov       [%rbp + cc_parse.createdivop.x],	%rax
    mov       %rcx,	[%rbp + cc_parse.createdivop.y]
    mov       %rdx,	%r12
    call      cc_parse.coercemode
    mov       [%rbp + cc_parse.createdivop.y],	%rax
    jmp       L5469
L5470:
    lea       %rcx,	[%rip+L9083]
    call      cc_support.terror
L5469:
    mov       %rax,	[%rbp + cc_parse.createdivop.x]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5472
    mov       %rax,	[%rbp + cc_parse.createdivop.y]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5472
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + cc_parse.createdivop.x]
    mov       %r8,	[%rbp + cc_parse.createdivop.y]
    mov       %r9,	%r12
    call      cc_parse.eval_div
    jmp       L5468
L5472:
    mov       %rax,	[%rbp + cc_parse.createdivop.y]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5473
    cmp       %r12,	11
    jnz       L5473
    mov       %r13,	41
    mov       %rax,	[%rbp + cc_parse.createdivop.y]
    movq      %XMM4,	[%rax]
    movq      %XMM5,	[%rip+L9084]
    divsd     %XMM5,	%XMM4
    mov       %rax,	[%rbp + cc_parse.createdivop.y]
    movq      [%rax],	%XMM5
L5473:
L5471:
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + cc_parse.createdivop.x]
    mov       %r8,	[%rbp + cc_parse.createdivop.y]
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%r12d
    mov       %rax,	%rdi
L5468:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createremop
cc_parse.createremop:
#?>>
    .set cc_parse.createremop.x, 56
    .set cc_parse.createremop.y, 64
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       [%rbp+56],	%rcx
    mov       [%rbp+64],	%rdx
#---------------
    mov       %rax,	[%rbp + cc_parse.createremop.x]
    movsxd    %rax,	dword ptr[%rax+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rbx,	%r10
    mov       %rax,	[%rbp + cc_parse.createremop.y]
    movsxd    %rax,	dword ptr[%rax+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rsi,	%r10
    mov       %r13,	43
    lea       %rax,	[%rip+cc_tables.dominantmode]
    mov       %r10,	%rbx
    shl       %r10,	5
    lea       %rax,	[%rax + %r10]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %r12,	%rax
    test      %rax,	%rax
    jz        L5476
    cmp       %r12,	11
    jz        L5479
    cmp       %r12,	10
    jnz       L5478
L5479:
    mov       %r12,	3
L5478:
    mov       %rcx,	[%rbp + cc_parse.createremop.x]
    mov       %rdx,	%r12
    call      cc_parse.coercemode
    mov       [%rbp + cc_parse.createremop.x],	%rax
    mov       %rcx,	[%rbp + cc_parse.createremop.y]
    mov       %rdx,	%r12
    call      cc_parse.coercemode
    mov       [%rbp + cc_parse.createremop.y],	%rax
    jmp       L5475
L5476:
    lea       %rcx,	[%rip+L9085]
    call      cc_support.terror
L5475:
    mov       %rax,	[%rbp + cc_parse.createremop.x]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5481
    mov       %rax,	[%rbp + cc_parse.createremop.y]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5481
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + cc_parse.createremop.x]
    mov       %r8,	[%rbp + cc_parse.createremop.y]
    mov       %r9,	%r12
    call      cc_parse.eval_rem
    jmp       L5474
L5481:
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + cc_parse.createremop.x]
    mov       %r8,	[%rbp + cc_parse.createremop.y]
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%r12d
    mov       %rax,	%rdi
L5474:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.insertunit
cc_parse.insertunit:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    xor       %ecx,	%ecx
    call      cc_lib.createunit0
    mov       %rdi,	%rax
    mov       %rax,	%rbx
    push      %rdi
    mov       %r11,	8
L9086:
    mov       %r10,	[%rax]
    mov       [%rdi],	%r10
    add       %rdi,	8
    add       %rax,	8
    dec       %r11
    jnz       L9086
    pop       %rdi
    mov       [%rbx+40],	%esi
    mov       [%rbx+16],	%rdi
    xor       %eax,	%eax
    mov       [%rbx+32],	%rax
    mov       [%rbx+24],	%rax
    mov       %eax,	[%rdi+44]
    mov       [%rbx+44],	%eax
    mov       %rax,	[%rdi+8]
    mov       [%rbx+8],	%rax
    xor       %eax,	%eax
    mov       [%rbx+56],	%ax
    xor       %eax,	%eax
    mov       [%rdi+8],	%rax
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.eval_add
cc_parse.eval_add:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
    mov       %r13,	%r9
#---------------
    mov       %rax,	%r13
    cmp       %rax,	3
    jz        L5485
    cmp       %rax,	4
    jz        L5485
    cmp       %rax,	8
    jz        L5485
    cmp       %rax,	9
    jz        L5485
    cmp       %rax,	11
    jz        L5486
    jmp       L5487
L5485:
    mov       %rax,	[%r12]
    mov       %r10,	%rsi
    add       [%r10],	%rax
    mov       %rax,	%rsi
    jmp       L5483
L5486:
    movq      %XMM4,	[%r12]
    mov       %rax,	%rsi
    movq      %XMM5,	[%rax]
    addsd     %XMM5,	%XMM4
    movq      [%rax],	%XMM5
    mov       %rax,	%rsi
    jmp       L5483
L5487:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%r13
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	13
    jnz       L5489
    mov       %rax,	[%r12]
    lea       %r10,	[%rip+cc_decls.tttarget]
    mov       %r11,	%r13
    movsx     %r10,	word ptr[%r10 + %r11*2]
    lea       %r11,	[%rip+cc_decls.ttsize]
    mov       %r11,	[%r11 + %r10*8]
    imul      %rax,	%r11
    mov       %r10,	%rsi
    add       [%r10],	%rax
    mov       %rax,	%rsi
    jmp       L5483
L5489:
L5484:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%r13d
    mov       %rax,	%rdi
L5483:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.eval_sub
cc_parse.eval_sub:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
    mov       %r13,	%r9
#---------------
    mov       %rax,	%r13
    cmp       %rax,	3
    jz        L5492
    cmp       %rax,	4
    jz        L5492
    cmp       %rax,	8
    jz        L5492
    cmp       %rax,	9
    jz        L5492
    cmp       %rax,	11
    jz        L5493
    jmp       L5494
L5492:
    mov       %rax,	[%r12]
    mov       %r10,	%rsi
    sub       [%r10],	%rax
    mov       %rax,	%rsi
    jmp       L5490
L5493:
    movq      %XMM4,	[%r12]
    mov       %rax,	%rsi
    movq      %XMM5,	[%rax]
    subsd     %XMM5,	%XMM4
    movq      [%rax],	%XMM5
    mov       %rax,	%rsi
    jmp       L5490
L5494:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%r13
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	13
    jnz       L5496
    movsxd    %rax,	dword ptr[%r12+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    cmp       %r10,	13
    jnz       L5498
    lea       %rcx,	[%rip+L9087]
    call      cc_support.terror
L5498:
    mov       %rax,	%rsi
    jmp       L5490
L5496:
L5491:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%r13d
    mov       %rax,	%rdi
L5490:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.eval_mul
cc_parse.eval_mul:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
    mov       %r13,	%r9
#---------------
    mov       %rax,	%r13
    cmp       %rax,	3
    jz        L5501
    cmp       %rax,	4
    jz        L5501
    cmp       %rax,	2
    jz        L5501
    cmp       %rax,	1
    jz        L5501
    cmp       %rax,	8
    jz        L5502
    cmp       %rax,	9
    jz        L5502
    cmp       %rax,	7
    jz        L5502
    cmp       %rax,	6
    jz        L5502
    cmp       %rax,	11
    jz        L5503
    jmp       L5504
L5501:
    mov       %rax,	[%r12]
    mov       %r11,	%rsi
    mov       %r10,	[%r11]
    imul      %r10,	%rax
    mov       [%r11],	%r10
    mov       %rax,	%rsi
    jmp       L5499
L5502:
    mov       %rax,	[%rsi]
    mov       %r10,	[%r12]
    imul      %rax,	%r10
    mov       [%rsi],	%rax
    mov       %rax,	%rsi
    jmp       L5499
L5503:
    movq      %XMM4,	[%r12]
    mov       %rax,	%rsi
    movq      %XMM5,	[%rax]
    mulsd     %XMM5,	%XMM4
    movq      [%rax],	%XMM5
    mov       %rax,	%rsi
    jmp       L5499
L5504:
L5500:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%r13d
    mov       %rax,	%rdi
L5499:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.eval_div
cc_parse.eval_div:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
    mov       %r13,	%r9
#---------------
    mov       %rax,	%r13
    cmp       %rax,	3
    jz        L5507
    cmp       %rax,	4
    jz        L5507
    cmp       %rax,	8
    jz        L5508
    cmp       %rax,	9
    jz        L5508
    cmp       %rax,	11
    jz        L5509
    jmp       L5510
L5507:
    mov       %rax,	[%r12]
    test      %rax,	%rax
    jnz       L5512
    lea       %rcx,	[%rip+L9088]
    call      cc_support.serror
L5512:
    mov       %rax,	[%rsi]
    mov       %r10,	[%r12]
    cqo       
    idiv      %r10
    mov       [%rsi],	%rax
    mov       %rax,	%rsi
    jmp       L5505
L5508:
    mov       %rax,	[%r12]
    test      %rax,	%rax
    jnz       L5514
    lea       %rcx,	[%rip+L9088]
    call      cc_support.serror
L5514:
    mov       %rax,	[%rsi]
    mov       %r10,	[%r12]
    xor       %edx,	%edx
    div       %r10
    mov       [%rsi],	%rax
    mov       %rax,	%rsi
    jmp       L5505
L5509:
    movq      %XMM4,	[%r12]
    mov       %rax,	%rsi
    movq      %XMM5,	[%rax]
    divsd     %XMM5,	%XMM4
    movq      [%rax],	%XMM5
    mov       %rax,	%rsi
    jmp       L5505
L5510:
L5506:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%r13d
    mov       %rax,	%rdi
L5505:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.eval_rem
cc_parse.eval_rem:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
    mov       %r13,	%r9
#---------------
    mov       %rax,	%r13
    cmp       %rax,	3
    jz        L5517
    cmp       %rax,	4
    jnz       L5518
L5517:
    mov       %rax,	[%r12]
    test      %rax,	%rax
    jnz       L5520
    lea       %rcx,	[%rip+L9089]
    call      cc_support.serror
L5520:
    mov       %rax,	[%rsi]
    mov       %r10,	[%r12]
    cqo       
    idiv      %r10
    xchg      %rax,	%rdx
    mov       [%rsi],	%rax
    mov       %rax,	%rsi
    jmp       L5515
L5518:
L5516:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%r13d
    mov       %rax,	%rdi
L5515:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.eval_convert
cc_parse.eval_convert:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	16
#---------------
    cmp       %r8,	1
    jnz       L5523
#cc_parse.eval_convert.dosoft:
L5524:
    mov       [%rcx+52],	%edx
    mov       %rax,	1
    jmp       L5521
L5523:
    movsxd    %rax,	dword ptr[%rcx+52]
    mov       %rdi,	%rax
    cmp       %rdi,	%rdx
    jnz       L5526
    mov       %rax,	1
    jmp       L5521
L5526:
    mov       %rax,	%rdi
    cmp       %rax,	3
    jz        L5528
    cmp       %rax,	2
    jz        L5528
    cmp       %rax,	1
    jz        L5528
    cmp       %rax,	4
    jz        L5528
    cmp       %rax,	8
    jz        L5529
    cmp       %rax,	6
    jz        L5529
    cmp       %rax,	7
    jz        L5529
    cmp       %rax,	9
    jz        L5529
    cmp       %rax,	11
    jz        L5530
    jmp       L5531
L5528:
    mov       %rax,	%rdx
    cmp       %rax,	11
    jz        L5533
    cmp       %rax,	10
    jz        L5533
    cmp       %rax,	9
    jz        L5534
    cmp       %rax,	4
    jz        L5534
    cmp       %rax,	8
    jz        L5534
    cmp       %rax,	3
    jz        L5534
    cmp       %rax,	2
    jz        L5534
    cmp       %rax,	1
    jz        L5534
    cmp       %rax,	6
    jz        L5534
    cmp       %rax,	7
    jz        L5534
    jmp       L5535
L5533:
    mov       %rax,	[%rcx]
    cvtsi2sd  %XMM4,	%rax
    movq      [%rcx],	%XMM4
    mov       [%rcx+52],	%edx
    mov       %rax,	1
    jmp       L5521
L5534:
#cc_parse.eval_convert.dotrunc:
L5536:
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rdx
    mov       %rax,	[%rax + %r10*8]
    cmp       %rax,	1
    jz        L5538
    cmp       %rax,	2
    jz        L5539
    cmp       %rax,	4
    jz        L5540
    jmp       L5541
L5538:
    mov       %rax,	%rcx
    mov       %r10,	255
    and       [%rax],	%r10
    lea       %rax,	[%rip+cc_tables.stdsigned]
    mov       %r10,	%rdx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5543
    mov       %rax,	[%rcx]
    movsx     %rax,	%al
    mov       [%rcx],	%rax
L5543:
    jmp       L5537
L5539:
    mov       %rax,	%rcx
    mov       %r10,	65535
    and       [%rax],	%r10
    lea       %rax,	[%rip+cc_tables.stdsigned]
    mov       %r10,	%rdx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5545
    mov       %rax,	[%rcx]
    movsx     %rax,	%ax
    mov       [%rcx],	%rax
L5545:
    jmp       L5537
L5540:
    mov       %rax,	[%rcx]
    mov       %r10,	4294967295
    and       %rax,	%r10
    mov       [%rcx],	%rax
    lea       %rax,	[%rip+cc_tables.stdsigned]
    mov       %r10,	%rdx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5547
    mov       %rax,	[%rcx]
    movsxd    %rax,	%eax
    mov       [%rcx],	%rax
L5547:
L5541:
L5537:
    jmp       L5524
L5535:
L5532:
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%rdx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5549
    mov       [%rcx+52],	%edx
    mov       %rax,	1
    jmp       L5521
L5549:
    jmp       L5527
L5529:
    mov       %rax,	%rdx
    cmp       %rax,	11
    jz        L5551
    cmp       %rax,	10
    jz        L5551
    cmp       %rax,	9
    jz        L5552
    cmp       %rax,	4
    jz        L5552
    cmp       %rax,	3
    jz        L5552
    cmp       %rax,	8
    jz        L5552
    cmp       %rax,	9
    jz        L5552
    cmp       %rax,	7
    jz        L5552
    cmp       %rax,	1
    jz        L5552
    cmp       %rax,	6
    jz        L5552
    cmp       %rax,	2
    jz        L5552
    jmp       L5553
L5551:
    xor       %eax,	%eax
    jmp       L5521
    mov       [%rcx+52],	%edx
    mov       %rax,	1
    jmp       L5521
L5552:
    jmp       L5536
L5553:
L5550:
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%rdx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5555
    mov       [%rcx+52],	%edx
    mov       %rax,	1
    jmp       L5521
L5555:
    jmp       L5527
L5530:
    mov       %rax,	%rdx
    cmp       %rax,	3
    jz        L5557
    cmp       %rax,	4
    jz        L5557
    cmp       %rax,	8
    jz        L5558
    cmp       %rax,	9
    jz        L5558
    cmp       %rax,	10
    jz        L5559
    jmp       L5560
L5557:
    movq      %XMM4,	[%rcx]
    cvttsd2si %rax,	%XMM4
    mov       [%rcx],	%rax
    mov       [%rcx+52],	%edx
    mov       %rax,	1
    jmp       L5521
L5558:
    movq      %XMM4,	[%rcx]
    cvttsd2si %rax,	%XMM4
    mov       [%rcx],	%rax
    mov       [%rcx+52],	%edx
    mov       %rax,	1
    jmp       L5521
L5559:
    mov       %eax,	10
    mov       [%rcx+52],	%eax
    mov       %rax,	1
    jmp       L5521
L5560:
L5556:
    jmp       L5527
L5531:
    movsxd    %rax,	dword ptr[%rcx+52]
    lea       %r10,	[%rip+cc_decls.ttisref]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L5562
    mov       %al,	[%rcx+61]
    test      %al,	%al
    jnz       L5564
    mov       %rax,	%rdx
    cmp       %rax,	3
    jz        L5566
    cmp       %rax,	4
    jz        L5566
    cmp       %rax,	8
    jz        L5566
    cmp       %rax,	9
    jnz       L5567
L5566:
    mov       [%rcx+52],	%edx
    mov       %rax,	1
    jmp       L5521
L5567:
L5565:
L5564:
L5562:
L5527:
    xor       %eax,	%eax
L5521:
#---------------
    add       %rsp,	16
    pop       %rdi
    ret       
# End 
# Proc cc_parse.coercecond
cc_parse.coercecond:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%rbx+52]
    mov       %rdi,	%rax
    cmp       %rax,	3
    jz        L5568
L5570:
#cc_parse.coercecond.retry:
L5571:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	10
    jz        L5573
    cmp       %rax,	11
    jz        L5573
    cmp       %rax,	13
    jnz       L5574
L5573:
    jmp       L5575
L5574:
    mov       %rcx,	%rdi
    call      cc_lib.isintcc
    test      %rax,	%rax
    jz        L5577
#cc_parse.coercecond.doint:
L5575:
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L5579
    mov       %rax,	[%rbx]
    test      %rax,	%rax
    jz        L5579
    mov       %rax,	1
    mov       [%rbx],	%rax
    jmp       L5578
L5579:
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L5580
    mov       %rax,	[%rbx]
    test      %rax,	%rax
    jnz       L5580
    xor       %eax,	%eax
    mov       [%rbx],	%rax
    jmp       L5578
L5580:
    mov       %rcx,	%rbx
    mov       %rdx,	27
    call      cc_parse.insertunit
L5578:
    jmp       L5576
L5577:
    lea       %rax,	[%rip+cc_decls.ttconst]
    mov       %r10,	%rdi
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5581
    lea       %rax,	[%rip+cc_decls.ttconsttype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rdi,	%rax
    jmp       L5571
L5581:
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      cc_lib.strmode
    lea       %rcx,	[%rip+L9090]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L5576:
L5572:
    mov       %eax,	3
    mov       [%rbx+52],	%eax
L5568:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.coercebasetype
cc_parse.coercebasetype:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%rbx+52]
    mov       %rdi,	%rax
    cmp       %rax,	1
    jl        L5584
    cmp       %rdi,	2
    jg        L5584
    mov       %rcx,	%rbx
    mov       %rdx,	3
    call      cc_parse.coercemode
    mov       %rbx,	%rax
    jmp       L5583
L5584:
    cmp       %rdi,	5
    jl        L5585
    cmp       %rdi,	7
    jg        L5585
    mov       %rcx,	%rbx
    mov       %rdx,	8
    call      cc_parse.coercemode
    mov       %rbx,	%rax
L5585:
L5583:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.checklvalue
cc_parse.checklvalue:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	3
    jz        L5588
    cmp       %rax,	52
    jz        L5589
    cmp       %rax,	5
    jz        L5590
    cmp       %rax,	4
    jz        L5591
    cmp       %rax,	49
    jz        L5592
    cmp       %rax,	1
    jz        L5593
    cmp       %rax,	56
    jz        L5594
    jmp       L5595
L5588:
    jmp       L5587
L5589:
    jmp       L5587
L5590:
    test      %rbx,	%rbx
    jz        L5597
    jmp       L5598
L5597:
    jmp       L5587
L5591:
    mov       %rax,	[%rdi+16]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	3
    jz        L5600
    cmp       %rax,	52
    jz        L5600
    cmp       %rax,	49
    jnz       L5601
L5600:
    mov       %rax,	[%rdi+16]
    push      %rdi
    mov       %r11,	8
L9091:
    mov       %r10,	[%rax]
    mov       [%rdi],	%r10
    add       %rdi,	8
    add       %rax,	8
    dec       %r11
    jnz       L9091
    pop       %rdi
    jmp       L5599
L5601:
    lea       %rcx,	[%rip+L9092]
    call      cc_support.terror
L5599:
    jmp       L5587
L5592:
    jmp       L5587
L5593:
    movsxd    %rax,	dword ptr[%rdi+52]
    lea       %r10,	[%rip+cc_decls.ttisref]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jnz       L5603
    jmp       L5598
L5603:
    jmp       L5587
L5594:
    test      %rbx,	%rbx
    jz        L5605
    jmp       L5598
L5605:
    jmp       L5587
L5595:
#cc_parse.checklvalue.notlv:
L5598:
    xor       %ecx,	%ecx
    mov       %rdx,	%rdi
    xor       %r8d,	%r8d
    lea       %r9,	[%rip+L9093]
    call      cc_show.printunit
    movsxd    %rax,	dword ptr[%rdi+40]
    lea       %r10,	[%rip+cc_tables.jtagnames]
    mov       %r10,	[%r10 + %rax*8]
    lea       %rcx,	[%rip+L9094]
    mov       %rdx,	%r10
    call      cc_support.terror_s
L5587:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createcall
cc_parse.createcall:
#?>>
    .set cc_parse.createcall.p, 64
    .set cc_parse.createcall.q, 72
    .set cc_parse.createcall.aparams, -8
    .set cc_parse.createcall.retmode, -16
    .set cc_parse.createcall.mproc, -24
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	64
    mov       [%rbp+64],	%rcx
    mov       [%rbp+72],	%rdx
#---------------
    xor       %rsi,	%rsi
    mov       %rax,	[%rbp + cc_parse.createcall.p]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	52
    jz        L5608
    cmp       %rax,	3
    jz        L5609
    cmp       %rax,	5
    jz        L5609
    cmp       %rax,	49
    jz        L5610
    cmp       %rax,	30
    jz        L5610
    cmp       %rax,	31
    jz        L5610
    cmp       %rax,	56
    jz        L5610
    cmp       %rax,	29
    jz        L5610
    jmp       L5611
L5608:
#cc_parse.createcall.doptr:
L5612:
    mov       %rax,	[%rbp + cc_parse.createcall.p]
    movsxd    %rax,	dword ptr[%rax+52]
    mov       [%rbp + cc_parse.createcall.mproc],	%rax
    jmp       L5614
L5613:
    mov       %rcx,	52
    mov       %rdx,	[%rbp + cc_parse.createcall.p]
    call      cc_lib.createunit1
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	[%rbp + cc_parse.createcall.mproc]
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       [%rbp + cc_parse.createcall.mproc],	%rax
    mov       %eax,	[%rbp + cc_parse.createcall.mproc]
    mov       [%rdi+52],	%eax
    mov       [%rbp + cc_parse.createcall.p],	%rdi
L5614:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	[%rbp + cc_parse.createcall.mproc]
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	13
    jz        L5613
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	[%rbp + cc_parse.createcall.mproc]
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	14
    jz        L5617
    mov       %rcx,	[%rbp + cc_parse.createcall.mproc]
    call      cc_lib.typename
    lea       %rcx,	[%rip+L9095]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L5617:
    lea       %rax,	[%rip+cc_decls.ttparams]
    mov       %r10,	[%rbp + cc_parse.createcall.mproc]
    mov       %r12,	[%rax + %r10*8]
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	[%rbp + cc_parse.createcall.mproc]
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       [%rbp + cc_parse.createcall.retmode],	%rax
    jmp       L5607
L5609:
    mov       %rax,	[%rbp + cc_parse.createcall.p]
    mov       %rsi,	[%rax]
    movzx     %rax,	byte ptr[%rsi+109]
    cmp       %rax,	6
    jnz       L5619
    mov       %r12,	[%rsi+80]
    movzx     %rax,	word ptr[%rsi+102]
    mov       [%rbp + cc_parse.createcall.retmode],	%rax
    jmp       L5618
L5619:
    jmp       L5612
L5618:
    jmp       L5607
L5610:
    mov       %rcx,	52
    mov       %rdx,	[%rbp + cc_parse.createcall.p]
    call      cc_lib.createunit1
    mov       %rdi,	%rax
    mov       %rax,	[%rbp + cc_parse.createcall.p]
    movsxd    %rax,	dword ptr[%rax+52]
    lea       %r10,	[%rip+cc_decls.tttarget]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       [%rdi+52],	%r10d
    mov       [%rbp + cc_parse.createcall.p],	%rdi
    jmp       L5612
L5611:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L9096]
    call      msys.m$print_str_nf
    mov       %rax,	[%rbp + cc_parse.createcall.p]
    movsxd    %rax,	dword ptr[%rax+40]
    lea       %r10,	[%rip+cc_tables.jtagnames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    xor       %ecx,	%ecx
    mov       %rdx,	[%rbp + cc_parse.createcall.p]
    xor       %r8d,	%r8d
    lea       %r9,	[%rip+L9097]
    call      cc_show.printunit
    lea       %rcx,	[%rip+L9098]
    call      cc_support.serror
L5607:
    movsx     %rax,	word ptr[%r12+20]
    mov       %r14,	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.createcall.aparams],	%rax
    mov       %rbx,	[%rbp + cc_parse.createcall.q]
    jmp       L5621
L5620:
    inc       qword ptr[%rbp + cc_parse.createcall.aparams]
    mov       %rbx,	[%rbx+8]
L5621:
    test      %rbx,	%rbx
    jnz       L5620
    mov       %rax,	[%rbp + cc_parse.createcall.aparams]
    cmp       %rax,	%r14
    jge       L5624
    lea       %rcx,	[%rip+L9099]
    call      cc_support.terror
    jmp       L5623
L5624:
    mov       %rax,	[%rbp + cc_parse.createcall.aparams]
    cmp       %rax,	%r14
    jle       L5625
    movsx     %rax,	word ptr[%r12+22]
    cmp       %rax,	3
    jz        L5625
    movsx     %rax,	word ptr[%r12+22]
    cmp       %rax,	1
    jz        L5625
    movsx     %rax,	word ptr[%r12+22]
    cmp       %rax,	1
    jz        L5627
    call      msys.m$print_startcon
    mov       %rcx,	[%rbp + cc_parse.createcall.aparams]
    call      msys.m$print_i64_nf
    mov       %rcx,	%r14
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L9100]
    call      cc_support.terror
L5627:
L5625:
L5623:
    mov       %rbx,	[%rbp + cc_parse.createcall.q]
    mov       %r13,	1
    mov       %rax,	[%rbp + cc_parse.createcall.aparams]
    cmp       %rax,	1
    jl        L5630
L5628:
    cmp       %r13,	%r14
    jg        L5632
    movsxd    %rax,	dword ptr[%r12+16]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      cc_parse.coercemode_inplace
    mov       %r12,	[%r12+8]
    jmp       L5631
L5632:
    movsxd    %rax,	dword ptr[%rbx+52]
    test      %rax,	%rax
    jnz       L5634
    lea       %rcx,	[%rip+L9101]
    call      cc_support.terror
L5634:
    mov       %rcx,	%rbx
    call      cc_parse.coercebasetype
L5631:
    mov       %rbx,	[%rbx+8]
    inc       %r13
    cmp       %r13,	[%rbp + cc_parse.createcall.aparams]
    jle       L5628
L5630:
    mov       %rcx,	30
    mov       %rdx,	[%rbp + cc_parse.createcall.p]
    mov       %r8,	[%rbp + cc_parse.createcall.q]
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       %eax,	[%rbp + cc_parse.createcall.retmode]
    mov       [%rdi+52],	%eax
    mov       %rcx,	%rdi
    call      cc_parse.fixmemopnd
    mov       %eax,	[%rbp + cc_parse.createcall.aparams]
    mov       [%rdi+48],	%eax
    mov       %rax,	%rdi
L5606:
#---------------
    add       %rsp,	64
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.arraytopointer
cc_parse.arraytopointer:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r14,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%r14+52]
    mov       %rsi,	%rax
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%rsi
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %r12,	%rax
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rsi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jnz       L5637
    mov       %rcx,	%r12
    call      cc_lib.createrefmode
    mov       %r13,	%rax
    movsxd    %rax,	dword ptr[%r14+40]
    cmp       %rax,	52
    jz        L5639
    cmp       %rax,	49
    jz        L5640
    jmp       L5641
L5639:
    mov       %r14,	[%r14+16]
    jmp       L5638
L5640:
    movsxd    %rax,	dword ptr[%r14]
    mov       %rbx,	%rax
    mov       %eax,	53
    mov       [%r14+40],	%eax
    mov       %eax,	1
    mov       [%r14],	%eax
    mov       %rax,	[%r14+16]
    mov       %rcx,	55
    mov       %rdx,	%rax
    call      cc_lib.createunit1
    mov       %rdi,	%rax
    mov       [%rdi+52],	%r13d
    mov       [%r14+16],	%rdi
    mov       %rcx,	%rbx
    mov       %rdx,	3
    call      cc_lib.createconstunit
    mov       [%r14+24],	%rax
    jmp       L5638
L5641:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L9102]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    xor       %ecx,	%ecx
    mov       %rdx,	%r14
    xor       %r8d,	%r8d
    lea       %r9,	[%rip+L9103]
    call      cc_show.printunit
    lea       %rcx,	[%rip+L9104]
    call      cc_support.terror
L5638:
    mov       [%r14+52],	%r13d
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8]
    mov       [%r14+48],	%eax
L5637:
    mov       %rax,	%r14
L5635:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createindexop
cc_parse.createindexop:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      cc_parse.createaddop
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    call      cc_parse.createptrop
L5642:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readstructdecl
cc_parse.readstructdecl:
#?>>
    .set cc_parse.readstructdecl.owner, 64
    .set cc_parse.readstructdecl.d, -8
    .set cc_parse.readstructdecl.ulist, -16
    .set cc_parse.readstructdecl.ulistx, -24
    .set cc_parse.readstructdecl.linkage, -32
    .set cc_parse.readstructdecl.offset, -40
    .set cc_parse.readstructdecl.recsize, -48
    .set cc_parse.readstructdecl.maxsize, -56
    .set cc_parse.readstructdecl.maxalignment, -64
    .set cc_parse.readstructdecl.alignment, -72
    .set cc_parse.readstructdecl.size, -80
    .set cc_parse.readstructdecl.pm, -88
    .set cc_parse.readstructdecl.fieldlist, -96
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	128
#---------------
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	85
    setz      %al
    movzx     %eax,	%al
    mov       %r12,	%rax
    call      cc_lex.lex
    mov       %rax,	[%rip+cc_decls.currproc]
    test      %rax,	%rax
    jz        L5645
    mov       %rax,	[%rip+cc_decls.currproc]
    jmp       L5644
L5645:
    mov       %rax,	[%rip+cc_decls.stmodule]
L5644:
    mov       %rsi,	%rax
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	17
    jnz       L5647
    call      cc_lib.nextautotype
    mov       %rcx,	%rax
    call      cc_lex.addnamestr
    mov       [%rbp + cc_parse.readstructdecl.d],	%rax
    jmp       L5646
L5647:
    mov       %rcx,	67
    call      cc_lib.checksymbol
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       [%rbp + cc_parse.readstructdecl.d],	%rax
    call      cc_lex.lex
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	17
    jz        L5649
    mov       %rcx,	%rsi
    mov       %rdx,	[%rbp + cc_parse.readstructdecl.d]
    mov       %r8,	2
    mov       %r9,	[%rip+cc_decls.currblockno]
    call      cc_lib.resolvename
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L5651
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	13
    jz        L5653
    mov       %rax,	[%rdi]
    lea       %rcx,	[%rip+L9105]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L5653:
    movzx     %rax,	word ptr[%rdi+102]
    jmp       L5643
L5651:
    mov       %rcx,	%rsi
    mov       %rdx,	[%rbp + cc_parse.readstructdecl.d]
    mov       %r8,	13
    call      cc_lib.createdupldef
    mov       %rdi,	%rax
    test      %r12,	%r12
    jz        L5655
    mov       %rax,	19
    jmp       L5654
L5655:
    mov       %rax,	18
L5654:
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      cc_lib.createstructmode
    mov       [%rdi+102],	%ax
    mov       %ax,	[%rip+cc_decls.currblockno]
    mov       [%rdi+96],	%ax
    mov       %eax,	1
    lea       %r10,	[%rip+cc_decls.blockcounts]
    mov       %r11,	[%rip+cc_decls.currblockno]
    mov       [%r10 + %r11*4],	%eax
    movzx     %rax,	word ptr[%rdi+102]
    jmp       L5643
L5649:
L5646:
    mov       %rcx,	%rsi
    mov       %rdx,	[%rbp + cc_parse.readstructdecl.d]
    mov       %r8,	2
    mov       %r9,	[%rip+cc_decls.currblockno]
    call      cc_lib.checkdupl
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L5657
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	13
    jz        L5659
    mov       %rax,	[%rdi]
    lea       %rcx,	[%rip+L9105]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L5659:
    mov       %rax,	[%rdi+16]
    test      %rax,	%rax
    jz        L5661
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L9106]
    call      msys.m$print_str_nf
    mov       %eax,	[%rdi+92]
    and       %rax,	1677215
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    mov       %eax,	[%rdi+92]
    sar       %rax,	24
    lea       %r10,	[%rip+cc_decls.sourcefilenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    mov       %eax,	[%rdi+92]
    sar       %rax,	24
    lea       %r10,	[%rip+cc_decls.sourcefilepaths]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rax,	[%rdi]
    lea       %rcx,	[%rip+L9107]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L5661:
    jmp       L5656
L5657:
    mov       %rcx,	%rsi
    mov       %rdx,	[%rbp + cc_parse.readstructdecl.d]
    mov       %r8,	13
    call      cc_lib.createdupldef
    mov       %rdi,	%rax
    test      %r12,	%r12
    jz        L5663
    mov       %rax,	19
    jmp       L5662
L5663:
    mov       %rax,	18
L5662:
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      cc_lib.createstructmode
    mov       [%rdi+102],	%ax
    mov       %ax,	[%rip+cc_decls.currblockno]
    mov       [%rdi+96],	%ax
    mov       %eax,	1
    lea       %r10,	[%rip+cc_decls.blockcounts]
    mov       %r11,	[%rip+cc_decls.currblockno]
    mov       [%r10 + %r11*4],	%eax
L5656:
    call      cc_lex.lex
    mov       %rbx,	%rdi
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readstructdecl.ulistx],	%rax
    mov       [%rbp + cc_parse.readstructdecl.ulist],	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readstructdecl.recsize],	%rax
    mov       [%rbp + cc_parse.readstructdecl.maxsize],	%rax
    mov       [%rbp + cc_parse.readstructdecl.offset],	%rax
    mov       %rax,	1
    mov       [%rbp + cc_parse.readstructdecl.maxalignment],	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readstructdecl.fieldlist],	%rax
    mov       %r14,	-1
    jmp       L5665
L5664:
    mov       %rcx,	%rbx
    lea       %rdx,	[%rbp + cc_parse.readstructdecl.linkage]
    call      cc_parse.readdeclspec
    mov       %r13,	%rax
L5667:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L5669
    cmp       %rax,	25
    jz        L5669
    cmp       %rax,	13
    jz        L5669
    cmp       %rax,	10
    jz        L5670
    jmp       L5671
L5669:
    mov       %rcx,	%rbx
    lea       %rdx,	[%rbp + cc_parse.readstructdecl.d]
    mov       %r8,	%r13
    lea       %r9,	[%rbp + cc_parse.readstructdecl.pm]
    call      cc_parse.readtype
    mov       %r14,	%rax
    mov       %rax,	[%rbp + cc_parse.readstructdecl.d]
    test      %rax,	%rax
    jnz       L5673
    lea       %rcx,	[%rip+L9108]
    call      cc_support.serror
L5673:
    mov       %rax,	[%rbp + cc_parse.readstructdecl.linkage]
    cmp       %rax,	5
    jz        L5676
    mov       %rax,	[%rbp + cc_parse.readstructdecl.pm]
    test      %rax,	%rax
    jz        L5675
L5676:
    lea       %rcx,	[%rip+L9109]
    call      cc_support.serror
L5675:
    mov       %rcx,	%rbx
    mov       %rdx,	[%rbp + cc_parse.readstructdecl.d]
    mov       %r8,	4
    xor       %r9d,	%r9d
    call      cc_lib.checkdupl
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L5678
    mov       %rax,	[%rdi]
    lea       %rcx,	[%rip+L9110]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L5678:
    mov       %rax,	[%rbp + cc_parse.readstructdecl.linkage]
    test      %rax,	%rax
    jz        L5680
    lea       %rcx,	[%rip+L9111]
    call      cc_support.serror
L5680:
#cc_parse.readstructdecl.addanonfield:
L5681:
    xor       %ecx,	%ecx
    mov       %rdx,	[%rbp + cc_parse.readstructdecl.d]
    mov       %r8,	10
    call      cc_lib.createdupldef
    mov       [%rbp + cc_parse.readstructdecl.d],	%rax
    mov       %ax,	%r14w
    mov       %r10,	[%rbp + cc_parse.readstructdecl.d]
    mov       [%r10+102],	%ax
    lea       %rcx,	[%rbp + cc_parse.readstructdecl.ulist]
    lea       %rdx,	[%rbp + cc_parse.readstructdecl.ulistx]
    mov       %r8,	[%rbp + cc_parse.readstructdecl.d]
    call      cc_lib.addlistdef
    mov       %rax,	[%rbp + cc_parse.readstructdecl.ulist]
    mov       [%rbx+16],	%rax
    mov       %rax,	[%rbp + cc_parse.readstructdecl.ulistx]
    mov       [%rbx+24],	%rax
    mov       %rax,	%rbx
    mov       %r10,	[%rbp + cc_parse.readstructdecl.d]
    mov       [%r10+8],	%rax
    mov       %rcx,	%r14
    call      cc_lib.getalignment
    mov       [%rbp + cc_parse.readstructdecl.alignment],	%rax
    mov       %rax,	[%rbp + cc_parse.readstructdecl.alignment]
    cmp       %rax,	[%rbp + cc_parse.readstructdecl.maxalignment]
    jle       L5683
    mov       %rax,	[%rbp + cc_parse.readstructdecl.alignment]
    mov       [%rbp + cc_parse.readstructdecl.maxalignment],	%rax
L5683:
    mov       %rcx,	[%rbp + cc_parse.readstructdecl.offset]
    mov       %rdx,	[%rbp + cc_parse.readstructdecl.alignment]
    call      cc_parse.roundoffset
    mov       %r10,	[%rbp + cc_parse.readstructdecl.d]
    mov       [%r10+88],	%eax
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%r14
    mov       %rax,	[%rax + %r10*8]
    mov       [%rbp + cc_parse.readstructdecl.size],	%rax
    mov       %rax,	[%rbp + cc_parse.readstructdecl.d]
    movsxd    %rax,	dword ptr[%rax+88]
    sub       %rax,	[%rbp + cc_parse.readstructdecl.offset]
    add       [%rbp + cc_parse.readstructdecl.recsize],	%rax
    mov       %rax,	[%rbp + cc_parse.readstructdecl.d]
    movsxd    %rax,	dword ptr[%rax+88]
    mov       [%rbp + cc_parse.readstructdecl.offset],	%rax
    lea       %rcx,	[%rbp + cc_parse.readstructdecl.fieldlist]
    mov       %rdx,	[%rbp + cc_parse.readstructdecl.d]
    mov       %r8,	[%rbp + cc_parse.readstructdecl.offset]
    call      cc_parse.addnewfield
    test      %r12,	%r12
    jz        L5685
    mov       %rax,	[%rbp + cc_parse.readstructdecl.maxsize]
    mov       %r10,	[%rbp + cc_parse.readstructdecl.size]
    cmp       %rax,	%r10
    cmovl     %rax,	%r10
    mov       [%rbp + cc_parse.readstructdecl.maxsize],	%rax
    jmp       L5684
L5685:
    mov       %rax,	[%rbp + cc_parse.readstructdecl.size]
    add       [%rbp + cc_parse.readstructdecl.offset],	%rax
    mov       %rax,	[%rbp + cc_parse.readstructdecl.size]
    add       [%rbp + cc_parse.readstructdecl.recsize],	%rax
L5684:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	10
    jnz       L5687
    call      cc_lex.lex
    call      cc_parse.readassignexpr
L5687:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jnz       L5690
L5689:
    call      cc_lex.lex
    jmp       L5688
L5690:
    mov       %rcx,	9
    call      cc_lib.skipsymbol
    jmp       L5668
L5688:
    jmp       L5667
L5670:
    call      cc_lex.lex
    call      cc_parse.readassignexpr
    mov       %rcx,	9
    call      cc_lib.skipsymbol
    jmp       L5668
L5671:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%r13
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	18
    jz        L5692
    cmp       %rax,	19
    jnz       L5693
L5692:
    call      cc_lib.getautofieldname
    mov       [%rbp + cc_parse.readstructdecl.d],	%rax
    mov       %r14,	%r13
    jmp       L5681
L5693:
    cmp       %r14,	-1
    jnz       L5695
    lea       %rcx,	[%rip+L9112]
    call      cc_support.serror
    jmp       L5694
L5695:
    mov       %rcx,	%r14
    call      cc_lib.typename
    lea       %rcx,	[%rip+L9113]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L5694:
L5691:
    jmp       L5667
L5668:
L5665:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	18
    jnz       L5664
    mov       %rcx,	18
    call      cc_lib.skipsymbol
    mov       %rax,	[%rbp + cc_parse.readstructdecl.fieldlist]
    mov       [%rbx+64],	%rax
    test      %r12,	%r12
    jz        L5697
    mov       %rax,	[%rbp + cc_parse.readstructdecl.maxsize]
    jmp       L5696
L5697:
    mov       %rax,	[%rbp + cc_parse.readstructdecl.recsize]
L5696:
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + cc_parse.readstructdecl.maxalignment]
    call      cc_parse.roundoffset
    movzx     %r10,	word ptr[%rbx+102]
    lea       %r11,	[%rip+cc_decls.ttsize]
    mov       [%r11 + %r10*8],	%rax
    mov       %al,	[%rbp + cc_parse.readstructdecl.maxalignment]
    mov       [%rbx+112],	%al
    movzx     %rax,	word ptr[%rbx+102]
    mov       %r14,	%rax
    lea       %rax,	[%rip+cc_decls.ttconsttype]
    mov       %r10,	%r14
    mov       %ax,	[%rax + %r10*2]
    test      %ax,	%ax
    jz        L5699
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%r14
    mov       %rax,	[%rax + %r10*8]
    lea       %r10,	[%rip+cc_decls.ttconsttype]
    mov       %r11,	%r14
    movsx     %r10,	word ptr[%r10 + %r11*2]
    lea       %r11,	[%rip+cc_decls.ttsize]
    mov       [%r11 + %r10*8],	%rax
L5699:
    movzx     %rax,	word ptr[%rbx+102]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r10,	[%r10 + %rax*8]
    cmp       %r10,	1
    jz        L5702
    cmp       %r10,	2
    jz        L5702
    cmp       %r10,	4
    jz        L5702
    cmp       %r10,	8
    jnz       L5701
L5702:
    movzx     %rax,	word ptr[%rbx+102]
    xor       %r10d,	%r10d
    lea       %r11,	[%rip+cc_decls.ttisblock]
    mov       [%r11 + %rax],	%r10b
L5701:
    movzx     %rax,	word ptr[%rbx+102]
L5643:
#---------------
    add       %rsp,	128
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.checkpointertypes
cc_parse.checkpointertypes:
#?>>
    .set cc_parse.checkpointertypes.t, 80
    .set cc_parse.checkpointertypes.hard, 88
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %r15,	%rcx
    mov       [%rbp+80],	%rdx
    mov       [%rbp+88],	%r8
#---------------
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%r15
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	[%rbp + cc_parse.checkpointertypes.t]
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rbx,	%rax
    xor       %r13,	%r13
    xor       %eax,	%eax
    mov       %r14,	%rax
    lea       %rax,	[%rip+cc_decls.ttconst]
    mov       %r10,	%rdi
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5705
    lea       %rax,	[%rip+cc_decls.ttconsttype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rdi,	%rax
    mov       %r13,	1
L5705:
    lea       %rax,	[%rip+cc_decls.ttconst]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5707
    lea       %rax,	[%rip+cc_decls.ttconsttype]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rbx,	%rax
    mov       %r14,	1
L5707:
    mov       %rax,	[%rbp + cc_parse.checkpointertypes.hard]
    test      %rax,	%rax
    jnz       L5709
    test      %r13,	%r13
    jz        L5709
    test      %r14,	%r14
    jnz       L5709
    call      msys.m$print_startcon
    mov       %rcx,	%r15
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    mov       %rcx,	[%rbp + cc_parse.checkpointertypes.t]
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L9114]
    call      cc_support.terror
L5709:
    cmp       %rdi,	%rbx
    jnz       L5711
    mov       %rax,	1
    jmp       L5703
L5711:
    mov       %r15,	%rdi
    mov       [%rbp + cc_parse.checkpointertypes.t],	%rbx
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%r15
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rsi,	%rax
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	[%rbp + cc_parse.checkpointertypes.t]
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %r12,	%rax
    mov       %rax,	%rsi
    cmp       %rax,	1
    jl        L5713
    cmp       %rax,	9
    jg        L5713
    mov       %rax,	%r12
    cmp       %rax,	1
    jl        L5713
    cmp       %rax,	9
    jg        L5713
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r11,	%r12
    mov       %r10,	[%r10 + %r11*8]
    cmp       %rax,	%r10
    jnz       L5715
    mov       %rax,	1
    jmp       L5703
L5715:
L5713:
    test      %rsi,	%rsi
    jz        L5718
    test      %r12,	%r12
    jnz       L5717
L5718:
    mov       %rax,	1
    jmp       L5703
L5717:
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%r15
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5720
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	[%rbp + cc_parse.checkpointertypes.t]
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5720
    mov       %rcx,	%r15
    mov       %rdx,	[%rbp + cc_parse.checkpointertypes.t]
    mov       %r8,	[%rbp + cc_parse.checkpointertypes.hard]
    call      cc_parse.checkpointertypes
    jmp       L5703
L5720:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%r15
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jnz       L5721
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	[%rbp + cc_parse.checkpointertypes.t]
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jnz       L5721
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%r15
    mov       %rax,	[%rax + %r10*8]
    lea       %r10,	[%rip+cc_decls.ttlength]
    mov       %r11,	[%rbp + cc_parse.checkpointertypes.t]
    mov       %r10,	[%r10 + %r11*8]
    cmp       %rax,	%r10
    jz        L5723
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%r15
    mov       %rax,	[%rax + %r10*8]
    test      %rax,	%rax
    jz        L5725
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	[%rbp + cc_parse.checkpointertypes.t]
    mov       %rax,	[%rax + %r10*8]
    test      %rax,	%rax
    jz        L5725
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L9115]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rax,	1
    jmp       L5703
    xor       %eax,	%eax
    jmp       L5703
L5725:
L5723:
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%r15
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	[%rbp + cc_parse.checkpointertypes.t]
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rbx,	%rax
    cmp       %rdi,	%rbx
    jnz       L5727
    mov       %rax,	1
    jmp       L5703
L5727:
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%rdi
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5729
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5729
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	[%rbp + cc_parse.checkpointertypes.hard]
    call      cc_parse.checkpointertypes
    jmp       L5703
L5729:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jnz       L5731
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jnz       L5731
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	[%rbp + cc_parse.checkpointertypes.hard]
    call      cc_parse.checkpointertypes
    jmp       L5703
L5731:
    jmp       L5719
L5721:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%r15
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	14
    jnz       L5732
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	[%rbp + cc_parse.checkpointertypes.t]
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	14
    jnz       L5732
    mov       %rax,	1
    jmp       L5703
L5732:
L5719:
    xor       %eax,	%eax
L5703:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.comparemode
cc_parse.comparemode:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    cmp       %rdi,	%rbx
    jnz       L5735
    mov       %rax,	1
    jmp       L5733
L5735:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jnz       L5737
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jnz       L5737
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    lea       %r10,	[%rip+cc_decls.tttarget]
    mov       %r11,	%rdi
    movsx     %r10,	word ptr[%r10 + %r11*2]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      cc_parse.comparemode
    test      %rax,	%rax
    jnz       L5739
    xor       %eax,	%eax
    jmp       L5733
L5739:
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    test      %rax,	%rax
    jz        L5742
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8]
    test      %rax,	%rax
    jz        L5742
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    lea       %r10,	[%rip+cc_decls.ttlength]
    mov       %r11,	%rbx
    mov       %r10,	[%r10 + %r11*8]
    cmp       %rax,	%r10
    jnz       L5741
L5742:
    mov       %rax,	1
    jmp       L5733
L5741:
L5737:
    xor       %eax,	%eax
L5733:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readenumdecl
cc_parse.readenumdecl:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    call      cc_lex.lex
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	17
    jnz       L5745
    mov       %rcx,	%rsi
    call      cc_parse.readenumnames
    mov       %rax,	12
    jmp       L5743
L5745:
    mov       %rcx,	67
    call      cc_lib.checksymbol
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rdi,	[%rax]
    call      cc_lex.lex
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	17
    jz        L5747
    mov       %rcx,	%rsi
    mov       %rdx,	%rdi
    mov       %r8,	2
    mov       %r9,	[%rip+cc_decls.currblockno]
    call      cc_lib.checkdupl
    mov       %rbx,	%rax
    test      %rbx,	%rbx
    jz        L5749
    movzx     %rax,	byte ptr[%rbx+109]
    cmp       %rax,	12
    jz        L5751
    mov       %rax,	[%rbx]
    lea       %rcx,	[%rip+L9116]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L5751:
L5749:
    mov       %rcx,	%rsi
    mov       %rdx,	%rdi
    mov       %r8,	12
    call      cc_lib.createdupldef
    mov       %rbx,	%rax
    mov       %rcx,	%rbx
    call      cc_lib.createenummode
    mov       [%rbx+102],	%ax
    mov       %ax,	[%rip+cc_decls.currblockno]
    mov       [%rbx+96],	%ax
    mov       %eax,	1
    lea       %r10,	[%rip+cc_decls.blockcounts]
    mov       %r11,	[%rip+cc_decls.currblockno]
    mov       [%r10 + %r11*4],	%eax
    movzx     %rax,	word ptr[%rbx+102]
    jmp       L5743
L5747:
    mov       %rcx,	%rsi
    mov       %rdx,	%rdi
    mov       %r8,	2
    mov       %r9,	[%rip+cc_decls.currblockno]
    call      cc_lib.checkdupl
    mov       %rbx,	%rax
    test      %rbx,	%rbx
    jz        L5753
    movzx     %rax,	byte ptr[%rbx+109]
    cmp       %rax,	12
    jz        L5755
    mov       %rax,	[%rbx]
    lea       %rcx,	[%rip+L9116]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L5755:
    mov       %rax,	[%rbx+16]
    test      %rax,	%rax
    jz        L5757
    mov       %rax,	[%rbx]
    lea       %rcx,	[%rip+L9117]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L5757:
    jmp       L5752
L5753:
    mov       %rcx,	%rsi
    mov       %rdx,	%rdi
    mov       %r8,	12
    call      cc_lib.createdupldef
    mov       %rbx,	%rax
    mov       %rcx,	%rbx
    call      cc_lib.createenummode
    mov       [%rbx+102],	%ax
    mov       %ax,	[%rip+cc_decls.currblockno]
    mov       [%rbx+96],	%ax
    mov       %eax,	1
    lea       %r10,	[%rip+cc_decls.blockcounts]
    mov       %r11,	[%rip+cc_decls.currblockno]
    mov       [%r10 + %r11*4],	%eax
L5752:
    mov       %rcx,	%rsi
    call      cc_parse.readenumnames
    movzx     %rax,	word ptr[%rbx+102]
    mov       %r10,	%rbx
    lea       %r11,	[%rip+cc_decls.ttnamedef]
    mov       [%r11 + %rax*8],	%r10
    movzx     %rax,	word ptr[%rbx+102]
L5743:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readenumnames
cc_parse.readenumnames:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
#---------------
    xor       %eax,	%eax
    mov       %rsi,	%rax
    mov       %rbx,	%rax
    xor       %r12,	%r12
    call      cc_lex.lex
    movzx     %rax,	byte ptr[%r13+109]
    cmp       %rax,	6
    jz        L5760
    cmp       %rax,	3
    jnz       L5761
L5760:
    jmp       L5759
L5761:
    mov       %rax,	[%rip+cc_decls.currproc]
    test      %rax,	%rax
    jz        L5763
    mov       %rax,	[%rip+cc_decls.currproc]
    jmp       L5762
L5763:
    mov       %rax,	[%rip+cc_decls.stmodule]
L5762:
    mov       %r13,	%rax
L5759:
    jmp       L5765
L5764:
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       %rcx,	%r13
    mov       %rdx,	%rax
    mov       %r8,	1
    mov       %r9,	[%rip+cc_decls.currblockno]
    call      cc_lib.checkdupl
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L5768
    mov       %rax,	[%rdi]
    lea       %rcx,	[%rip+L9118]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L5768:
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       %rcx,	%r13
    mov       %rdx,	%rax
    mov       %r8,	11
    call      cc_lib.createdupldef
    mov       %rdi,	%rax
    call      cc_lex.lex
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	11
    jnz       L5770
    call      cc_lex.lex
    call      cc_parse.readconstintexpr
    mov       %r12,	%rax
L5770:
    mov       [%rdi+88],	%r12d
    mov       %ax,	[%rip+cc_decls.currblockno]
    mov       [%rdi+96],	%ax
    mov       %eax,	1
    lea       %r10,	[%rip+cc_decls.blockcounts]
    mov       %r11,	[%rip+cc_decls.currblockno]
    mov       [%r10 + %r11*4],	%eax
    inc       %r12
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jnz       L5772
    call      cc_lex.lex
L5772:
L5765:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L5764
    mov       %rcx,	18
    call      cc_lib.skipsymbol
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createdotop
cc_parse.createdotop:
#?>>
    .set cc_parse.createdotop.p, 80
    .set cc_parse.createdotop.d, 88
    .set cc_parse.createdotop.fl, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %r15,	%rcx
    mov       [%rbp+80],	%rdx
    mov       [%rbp+88],	%r8
#---------------
    mov       %rax,	[%rbp + cc_parse.createdotop.p]
    movsxd    %rax,	dword ptr[%rax+52]
    mov       %r13,	%rax
    cmp       %r15,	50
    jnz       L5775
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%r13
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jnz       L5777
    lea       %rcx,	[%rip+L9119]
    call      cc_support.serror
L5777:
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%r13
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %r13,	%rax
L5775:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%r13
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	18
    jz        L5779
    cmp       %rax,	19
    jnz       L5780
L5779:
    jmp       L5778
L5780:
    lea       %rcx,	[%rip+L9120]
    call      cc_support.serror
L5778:
    lea       %rax,	[%rip+cc_decls.ttnamedef]
    mov       %r10,	%r13
    mov       %rsi,	[%rax + %r10*8]
    mov       %rbx,	[%rbp + cc_parse.createdotop.d]
    jmp       L5782
L5781:
    mov       %rax,	[%rbx+8]
    cmp       %rax,	%rsi
    jnz       L5785
    movsxd    %rax,	dword ptr[%rbx+88]
    mov       %r14,	%rax
    jmp       L5783
L5785:
L5782:
    mov       %rax,	[%rbx+40]
    mov       %rbx,	%rax
    test      %rax,	%rax
    jnz       L5781
L5783:
    test      %rbx,	%rbx
    jnz       L5787
    mov       %r12,	[%rbp + cc_parse.createdotop.d]
    jmp       L5789
L5788:
    mov       %r12,	[%r12+48]
L5789:
    mov       %rax,	[%r12+48]
    test      %rax,	%rax
    jnz       L5788
    mov       %rax,	[%rsi+64]
    mov       [%rbp + cc_parse.createdotop.fl],	%rax
    jmp       L5792
L5791:
    mov       %rax,	[%rbp + cc_parse.createdotop.fl]
    mov       %rax,	[%rax+8]
    cmp       %rax,	%r12
    jnz       L5795
    mov       %rax,	[%rbp + cc_parse.createdotop.fl]
    mov       %rbx,	[%rax]
    mov       %rax,	[%rbp + cc_parse.createdotop.fl]
    mov       %r14,	[%rax+24]
    jmp       L5793
L5795:
    mov       %rax,	[%rbp + cc_parse.createdotop.fl]
    mov       %rax,	[%rax+16]
    mov       [%rbp + cc_parse.createdotop.fl],	%rax
L5792:
    mov       %rax,	[%rbp + cc_parse.createdotop.fl]
    test      %rax,	%rax
    jnz       L5791
L5793:
L5787:
    test      %rbx,	%rbx
    jnz       L5797
    mov       %rcx,	%r13
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %r10,	[%rbp + cc_parse.createdotop.d]
    mov       %r10,	[%r10]
    lea       %rcx,	[%rip+L9121]
    mov       %rdx,	%r10
    mov       %r8,	%rax
    call      cc_support.terror_ss
L5797:
    mov       %rcx,	%r14
    mov       %rdx,	3
    call      cc_lib.createconstunit
    mov       %rdi,	%rax
    cmp       %r15,	50
    jnz       L5799
    mov       %rcx,	[%rbp + cc_parse.createdotop.p]
    call      cc_parse.createptrop
    mov       [%rbp + cc_parse.createdotop.p],	%rax
L5799:
    mov       %rcx,	49
    mov       %rdx,	[%rbp + cc_parse.createdotop.p]
    call      cc_lib.createunit1
    mov       [%rbp + cc_parse.createdotop.p],	%rax
    mov       %eax,	%r14d
    mov       %r10,	[%rbp + cc_parse.createdotop.p]
    mov       [%r10],	%eax
    movzx     %rax,	word ptr[%rbx+102]
    mov       %r10,	[%rbp + cc_parse.createdotop.p]
    mov       [%r10+52],	%eax
    mov       %rcx,	[%rbp + cc_parse.createdotop.p]
    call      cc_parse.arraytopointer
    mov       [%rbp + cc_parse.createdotop.p],	%rax
    mov       %rcx,	[%rbp + cc_parse.createdotop.p]
    call      cc_parse.fixmemopnd
    mov       %rax,	[%rbp + cc_parse.createdotop.p]
L5773:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.mulunit
cc_parse.mulunit:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8]
    mov       %rdi,	%rax
    cmp       %rax,	1
    jz        L5802
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L5804
    mov       %rax,	[%rbx]
    mov       %r10,	%rdi
    imul      %rax,	%r10
    mov       [%rbx],	%rax
    jmp       L5803
L5804:
    mov       %rcx,	57
    mov       %rdx,	%rbx
    call      cc_lib.createunit1
    mov       %rbx,	%rax
    mov       [%rbx+48],	%edi
    mov       %eax,	4
    mov       [%rbx+52],	%eax
L5803:
L5802:
    mov       %rax,	%rbx
L5800:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.divunit
cc_parse.divunit:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8]
    mov       %rdi,	%rax
    cmp       %rax,	1
    jz        L5807
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L5809
    mov       %rax,	[%rbx]
    mov       %r10,	%rdi
    cqo       
    idiv      %r10
    mov       [%rbx],	%rax
    jmp       L5808
L5809:
    mov       %rcx,	57
    mov       %rdx,	%rbx
    call      cc_lib.createunit1
    mov       %rbx,	%rax
    mov       %rax,	%rdi
    neg       %rax
    mov       [%rbx+48],	%eax
    mov       %eax,	4
    mov       [%rbx+52],	%eax
L5808:
L5807:
    mov       %rax,	%rbx
L5805:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createassignopref
cc_parse.createassignopref:
#?>>
    .set cc_parse.createassignopref.q, 88
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %r14,	%rcx
    mov       %r15,	%rdx
    mov       [%rbp+88],	%r8
#---------------
    movsxd    %rax,	dword ptr[%r15+52]
    mov       %rsi,	%rax
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %r12,	%rax
    mov       %rax,	[%rbp + cc_parse.createassignopref.q]
    movsxd    %rax,	dword ptr[%rax+52]
    mov       %rbx,	%rax
    mov       %rax,	%r14
    cmp       %rax,	11
    jz        L5812
    cmp       %rax,	46
    jz        L5813
    cmp       %rax,	47
    jz        L5814
    jmp       L5815
L5812:
    mov       %rcx,	[%rbp + cc_parse.createassignopref.q]
    mov       %rdx,	%rdi
    call      cc_parse.coercemode
    mov       [%rbp + cc_parse.createassignopref.q],	%rax
    mov       %rcx,	11
    mov       %rdx,	%r15
    mov       %r8,	[%rbp + cc_parse.createassignopref.q]
    call      cc_lib.createunit2
    mov       %r13,	%rax
    jmp       L5811
L5813:
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5817
    lea       %rcx,	[%rip+L9122]
    call      cc_support.serror
L5817:
    mov       %rcx,	[%rbp + cc_parse.createassignopref.q]
    mov       %rdx,	4
    call      cc_parse.coercemode
    mov       [%rbp + cc_parse.createassignopref.q],	%rax
    mov       %rcx,	[%rbp + cc_parse.createassignopref.q]
    mov       %rdx,	%r12
    call      cc_parse.mulunit
    mov       %rcx,	61
    mov       %rdx,	%r15
    mov       %r8,	%rax
    call      cc_lib.createunit2
    mov       %r13,	%rax
    jmp       L5811
L5814:
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5819
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      cc_parse.comparemode
    test      %rax,	%rax
    jnz       L5821
    lea       %rcx,	[%rip+L9123]
    call      cc_support.serror
L5821:
    mov       %rcx,	40
    mov       %rdx,	%r15
    mov       %r8,	[%rbp + cc_parse.createassignopref.q]
    call      cc_lib.createunit2
    mov       %rcx,	%rax
    mov       %rdx,	%r12
    call      cc_parse.divunit
    mov       %r13,	%rax
    mov       %rsi,	3
    jmp       L5818
L5819:
    mov       %rcx,	[%rbp + cc_parse.createassignopref.q]
    mov       %rdx,	%r12
    call      cc_parse.mulunit
    mov       %rcx,	62
    mov       %rdx,	%r15
    mov       %r8,	%rax
    call      cc_lib.createunit2
    mov       %r13,	%rax
L5818:
    jmp       L5811
L5815:
    lea       %rcx,	[%rip+L9124]
    call      cc_support.serror
L5811:
    mov       [%r13+52],	%esi
    mov       %rax,	%r13
L5810:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.addnewfield
cc_parse.addnewfield:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
    mov       %rax,	[%r12]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	36
    jz        L5824
    mov       %rcx,	32
    call      mlib.pcm_allocz
    mov       %rbx,	%rax
    mov       [%rbx],	%r12
    jmp       L5826
L5825:
    mov       %r12,	[%r12+48]
L5826:
    mov       %rax,	[%r12+48]
    test      %rax,	%rax
    jnz       L5825
    mov       [%rbx+8],	%r12
    mov       [%rbx+24],	%r13
    mov       %rax,	[%rsi]
    mov       [%rbx+16],	%rax
    mov       [%rsi],	%rbx
    jmp       L5823
L5824:
    movzx     %rax,	word ptr[%r12+102]
    lea       %r10,	[%rip+cc_decls.ttnamedef]
    mov       %r10,	[%r10 + %rax*8]
    mov       %r10,	[%r10+16]
    mov       %rdi,	%r10
    jmp       L5829
L5828:
    movsxd    %rax,	dword ptr[%rdi+88]
    mov       %r10,	%r13
    add       %r10,	%rax
    mov       %rcx,	%rsi
    mov       %rdx,	%rdi
    mov       %r8,	%r10
    call      cc_parse.addnewfield
    mov       %rdi,	[%rdi+32]
L5829:
    test      %rdi,	%rdi
    jnz       L5828
L5823:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.pushloop
cc_parse.pushloop:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	[%rip+cc_parse.loopindex]
    cmp       %rax,	64
    jl        L5833
    lea       %rcx,	[%rip+L9125]
    call      cc_support.serror
L5833:
    inc       qword ptr[%rip+cc_parse.loopindex]
    mov       %al,	%dil
    lea       %r10,	[%rip+cc_parse.looptypestack]
    mov       %r11,	[%rip+cc_parse.loopindex]
    mov       [%r10 + %r11-1],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_parse.casevaluestack]
    mov       %r11,	[%rip+cc_parse.loopindex]
    mov       [%r10 + %r11*8-8],	%rax
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_parse.poploop
cc_parse.poploop:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    mov       %rax,	[%rip+cc_parse.loopindex]
    test      %rax,	%rax
    jz        L5836
    dec       qword ptr[%rip+cc_parse.loopindex]
    jmp       L5835
L5836:
    lea       %rcx,	[%rip+L9126]
    call      cc_support.serror
L5835:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_parse.addcasevalue
cc_parse.addcasevalue:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    mov       %rbx,	[%rip+cc_parse.loopindex]
    jmp       L5839
L5838:
    dec       %rbx
L5839:
    test      %rbx,	%rbx
    jz        L5841
    lea       %rax,	[%rip+cc_parse.looptypestack]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	83
    jnz       L5838
L5841:
    test      %rbx,	%rbx
    jnz       L5843
    lea       %rcx,	[%rip+L9127]
    call      cc_support.serror
L5843:
    mov       %rcx,	16
    call      mlib.pcm_alloc
    mov       %rdi,	%rax
    mov       [%rdi+8],	%rsi
    lea       %rax,	[%rip+cc_parse.casevaluestack]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8-8]
    mov       [%rdi],	%rax
    mov       %rax,	%rdi
    lea       %r10,	[%rip+cc_parse.casevaluestack]
    mov       %r11,	%rbx
    mov       [%r10 + %r11*8-8],	%rax
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.roundoffset
cc_parse.roundoffset:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	16
#---------------
    mov       %rax,	[%rip+cc_decls.structpadding]
    test      %rax,	%rax
    jz        L5846
    cmp       %rdx,	1
    jnz       L5848
    mov       %rax,	%rcx
    jmp       L5844
L5848:
    lea       %rax,	[%rdx-1]
    mov       %rdi,	%rax
    jmp       L5850
L5849:
    inc       %rcx
L5850:
    mov       %rax,	%rcx
    and       %rax,	%rdi
    jnz       L5849
L5846:
    mov       %rax,	%rcx
L5844:
#---------------
    add       %rsp,	16
    pop       %rdi
    ret       
# End 
# Proc cc_parse.fixmemopnd
cc_parse.fixmemopnd:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	16
#---------------
    mov       %al,	[%rip+cc_parse.ingeneric]
    test      %al,	%al
    jnz       L5852
L5854:
    movsxd    %rax,	dword ptr[%rcx+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rdi,	%r10
    cmp       %r10,	1
    jz        L5856
    cmp       %r10,	2
    jz        L5856
    cmp       %r10,	6
    jz        L5856
    cmp       %r10,	7
    jz        L5856
    cmp       %r10,	5
    jz        L5856
    jmp       L5857
L5856:
    mov       [%rcx+56],	%di
    mov       %eax,	3
    mov       [%rcx+52],	%eax
L5857:
L5855:
L5852:
#---------------
    add       %rsp,	16
    pop       %rdi
    ret       
# End 
# Proc cc_parse.docast
cc_parse.docast:
#?>>
    .set cc_parse.docast.inplace, 88
    .set cc_parse.docast.$T1, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
    mov       [%rbp+88],	%r9
#---------------
    movsxd    %rax,	dword ptr[%r12+52]
    mov       %rbx,	%rax
#cc_parse.docast.retry:
L5859:
    cmp       %rbx,	%r13
    jnz       L5861
    mov       %rax,	%r12
    jmp       L5858
L5861:
    xor       %rsi,	%rsi
    mov       %rax,	%rbx
    cmp       %rax,	16
    jge       L5863
    cmp       %r13,	16
    jge       L5863
    lea       %rax,	[%rip+cc_tables.conversionops]
    mov       %r10,	%rbx
    shl       %r10,	4
    lea       %rax,	[%rax + %r10]
    mov       %r10,	%r13
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %rsi,	%rax
    jmp       L5862
L5863:
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5864
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%r13
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5864
    mov       %rcx,	%rbx
    mov       %rdx,	%r13
    mov       %r8,	%r14
    call      cc_parse.checkpointertypes
    test      %rax,	%rax
    jz        L5866
    mov       [%r12+52],	%r13d
    mov       %rax,	%r12
    jmp       L5858
L5866:
    jmp       L5862
L5864:
    lea       %rax,	[%rip+cc_decls.ttconst]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5867
    lea       %rax,	[%rip+cc_decls.ttconsttype]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rbx,	%rax
    jmp       L5859
L5867:
    lea       %rax,	[%rip+cc_decls.ttconst]
    mov       %r10,	%r13
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5868
    lea       %rax,	[%rip+cc_decls.ttconsttype]
    mov       %r10,	%r13
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %r13,	%rax
    jmp       L5859
L5868:
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%r13
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5869
    mov       %rcx,	%rbx
    call      cc_lib.isintcc
    test      %rax,	%rax
    jz        L5869
    movsxd    %rax,	dword ptr[%r12+40]
    cmp       %rax,	1
    jnz       L5869
    mov       %rax,	[%r12]
    test      %rax,	%rax
    jnz       L5869
    mov       %rsi,	1
L5869:
L5862:
    test      %rsi,	%rsi
    jnz       L5871
    test      %r14,	%r14
    jnz       L5873
    call      msys.m$print_startcon
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    mov       %rcx,	%r13
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    xor       %ecx,	%ecx
    mov       %rdx,	%r12
    xor       %r8d,	%r8d
    lea       %r9,	[%rip+L9128]
    call      cc_show.printunit
    mov       %rcx,	%r13
    call      cc_lib.typename
    mov       [%rbp + cc_parse.docast.$T1],	%rax
    mov       %rcx,	%rbx
    call      cc_lib.typename
    lea       %rcx,	[%rip+L9129]
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + cc_parse.docast.$T1]
    call      cc_support.terror_ss
L5873:
    mov       %rsi,	2
L5871:
    movsxd    %rax,	dword ptr[%r12+40]
    cmp       %rax,	1
    jz        L5875
    cmp       %rax,	5
    jz        L5876
    cmp       %rax,	39
    jz        L5877
    jmp       L5878
L5875:
    mov       %rcx,	%r12
    mov       %rdx,	%r13
    mov       %r8,	%rsi
    call      cc_parse.eval_convert
    test      %rax,	%rax
    jz        L5880
    mov       %rax,	%r12
    jmp       L5858
L5880:
    jmp       L5874
L5876:
    mov       [%r12+52],	%r13d
    mov       %rax,	%r12
    jmp       L5858
L5877:
    mov       %rax,	[%r12+16]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5882
    mov       %rax,	[%r12+24]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5882
    mov       %rax,	[%r12+16]
    mov       %rax,	[%rax]
    mov       %r10,	[%r12+24]
    mov       %r10,	[%r10]
    add       %rax,	%r10
    mov       [%r12],	%rax
    mov       [%r12+52],	%r13d
    mov       %eax,	1
    mov       [%r12+40],	%eax
    mov       %rax,	%r12
    jmp       L5858
L5882:
L5878:
L5874:
    mov       %rax,	[%rbp + cc_parse.docast.inplace]
    test      %rax,	%rax
    jz        L5884
    mov       %rcx,	%r12
    mov       %rdx,	56
    call      cc_parse.insertunit
    mov       [%r12+58],	%r13w
    mov       %rcx,	%r13
    call      cc_parse.getpromotedtype
    mov       [%r12+52],	%eax
    mov       [%r12+48],	%esi
    xor       %eax,	%eax
    jmp       L5858
L5884:
    mov       %rcx,	56
    mov       %rdx,	%r12
    call      cc_lib.createunit1
    mov       %rdi,	%rax
    mov       [%rdi+48],	%esi
    mov       [%rdi+58],	%r13w
    mov       %rcx,	%r13
    call      cc_parse.getpromotedtype
    mov       [%rdi+52],	%eax
L5883:
    mov       %rax,	%rdi
L5858:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.coercemode
cc_parse.coercemode:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    movsxd    %rax,	dword ptr[%rdi+52]
    cmp       %rax,	%rbx
    jnz       L5887
    mov       %rax,	%rdi
    jmp       L5885
L5887:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    mov       %r9,	1
    call      cc_parse.docast
    mov       %rax,	%rdi
L5885:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.coercemode_inplace
cc_parse.coercemode_inplace:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    movsxd    %rax,	dword ptr[%rdi+52]
    cmp       %rax,	%rbx
    jz        L5888
L5890:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    mov       %r9,	1
    call      cc_parse.docast
L5888:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createsizeofop
cc_parse.createsizeofop:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r12,	%rcx
    mov       %r13,	%rdx
#---------------
    test      %r13,	%r13
    jz        L5893
    movsxd    %rax,	dword ptr[%r12+40]
    cmp       %rax,	53
    jz        L5893
    cmp       %rax,	55
    jz        L5893
    xor       %ecx,	%ecx
    mov       %rdx,	%r12
    xor       %r8d,	%r8d
    lea       %r9,	[%rip+L9130]
    call      cc_show.printunit
    lea       %rcx,	[%rip+L9131]
    call      cc_support.serror
L5893:
    mov       %rcx,	%r12
    call      cc_parse.getmemmode
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%r12+40]
    cmp       %rax,	3
    jz        L5895
    cmp       %rax,	1
    jz        L5896
    cmp       %rax,	52
    jz        L5897
    cmp       %rax,	53
    jz        L5898
    cmp       %rax,	55
    jz        L5899
    cmp       %rax,	4
    jz        L5900
    jmp       L5901
L5895:
    mov       %eax,	[%r12+48]
    test      %eax,	%eax
    jz        L5903
    mov       %rax,	[%r12]
    movzx     %rax,	word ptr[%rax+102]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r10,	[%r10 + %rax*8]
    movsxd    %rax,	dword ptr[%r12+48]
    xchg      %r10,	%rax
    cqo       
    idiv      %r10
    mov       %rsi,	%rax
    jmp       L5902
L5903:
    mov       %rax,	[%r12]
    movzx     %rax,	word ptr[%rax+102]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rsi,	%r10
L5902:
    jmp       L5894
L5896:
    mov       %rax,	%rbx
    cmp       %rax,	[%rip+cc_decls.trefchar]
    jz        L5905
    cmp       %rax,	[%rip+cc_decls.trefwchar]
    jz        L5906
    jmp       L5907
L5905:
    movsxd    %rax,	dword ptr[%r12+48]
    mov       %rsi,	%rax
    jmp       L5904
L5906:
    movsxd    %rax,	dword ptr[%r12+48]
    shl       %rax,	1
    mov       %rsi,	%rax
    jmp       L5904
L5907:
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rbx
    mov       %rsi,	[%rax + %r10*8]
L5904:
    jmp       L5894
L5897:
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5909
    mov       %eax,	[%r12+48]
    test      %eax,	%eax
    jz        L5909
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r10,	[%r10 + %rax*8]
    movsxd    %rax,	dword ptr[%r12+48]
    imul      %r10,	%rax
    mov       %rsi,	%r10
    jmp       L5908
L5909:
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rbx
    mov       %rsi,	[%rax + %r10*8]
L5908:
    jmp       L5894
L5898:
    mov       %eax,	[%r12+48]
    test      %eax,	%eax
    jz        L5911
    test      %r13,	%r13
    jz        L5913
    movsxd    %rax,	dword ptr[%r12+48]
    mov       %rsi,	%rax
    jmp       L5912
L5913:
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r10,	[%r10 + %rax*8]
    movsxd    %rax,	dword ptr[%r12+48]
    imul      %r10,	%rax
    mov       %rsi,	%r10
L5912:
    jmp       L5910
L5911:
    jmp       L5914
L5910:
    jmp       L5894
L5899:
    mov       %rax,	[%r12+16]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	3
    jnz       L5916
    mov       %rax,	[%r12+16]
    mov       %eax,	[%rax+48]
    test      %eax,	%eax
    jz        L5916
    test      %r13,	%r13
    jz        L5918
    mov       %rax,	[%r12+16]
    movsxd    %rax,	dword ptr[%rax+48]
    mov       %rsi,	%rax
    jmp       L5917
L5918:
    mov       %rax,	[%r12+16]
    mov       %rax,	[%rax]
    movzx     %rax,	word ptr[%rax+102]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rsi,	%r10
L5917:
    jmp       L5915
L5916:
    mov       %rsi,	8
L5915:
    jmp       L5894
L5900:
    mov       %rax,	[%r12+16]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      cc_parse.createsizeofop
    jmp       L5891
L5901:
#cc_parse.createsizeofop.cad1:
L5914:
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rbx
    mov       %rsi,	[%rax + %r10*8]
L5894:
    mov       %rcx,	%rsi
    mov       %rdx,	9
    call      cc_lib.createconstunit
    mov       %rdi,	%rax
    mov       %rax,	%rdi
L5891:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readgeneric
cc_parse.readgeneric:
#?>>
    .set cc_parse.readgeneric.pm, -8
    .set cc_parse.readgeneric.oldingeneric, -16
    .set cc_parse.readgeneric.count, -24
    .set cc_parse.readgeneric.d, -32
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	64
#---------------
    call      cc_lex.lex
    mov       %rcx,	13
    call      cc_lib.checksymbol
    call      cc_lex.lex
    movzx     %rax,	byte ptr[%rip+cc_parse.ingeneric]
    mov       [%rbp + cc_parse.readgeneric.oldingeneric],	%rax
    mov       %al,	1
    mov       [%rip+cc_parse.ingeneric],	%al
    call      cc_parse.readassignexpr
    mov       %rdi,	%rax
    mov       %al,	[%rbp + cc_parse.readgeneric.oldingeneric]
    mov       [%rip+cc_parse.ingeneric],	%al
    movsxd    %rax,	dword ptr[%rdi+52]
    mov       %r12,	%rax
    xor       %rbx,	%rbx
    xor       %eax,	%eax
    mov       %r14,	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readgeneric.count],	%rax
    mov       %rcx,	8
    call      cc_lib.checksymbol
L5920:
    call      cc_lex.lex
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	75
    jnz       L5924
    test      %r14,	%r14
    jz        L5926
    lea       %rcx,	[%rip+L9132]
    call      cc_support.serror
L5926:
    mov       %r14,	1
    mov       %rax,	[%rbp + cc_parse.readgeneric.count]
    test      %rax,	%rax
    jnz       L5928
    mov       %r13,	-1
    jmp       L5927
L5928:
    mov       %r13,	-2
L5927:
    call      cc_lex.lex
    jmp       L5923
L5924:
    sub       %rsp,	8
    push      0
    lea       %rcx,	[%rbp + cc_parse.readgeneric.d]
    xor       %edx,	%edx
    lea       %r8,	[%rbp + cc_parse.readgeneric.pm]
    xor       %r9d,	%r9d
    sub       %rsp,	32
    call      cc_parse.readcasttype
    add       %rsp,	48
    mov       %r13,	%rax
L5923:
    mov       %rcx,	10
    call      cc_lib.checksymbol
    call      cc_lex.lex
    call      cc_parse.readassignexpr
    mov       %rsi,	%rax
    cmp       %r13,	-1
    jz        L5931
    cmp       %r13,	%r12
    jnz       L5930
L5931:
    mov       %rbx,	%rsi
    inc       qword ptr[%rbp + cc_parse.readgeneric.count]
L5930:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jz        L5920
    mov       %rcx,	14
    call      cc_lib.checksymbol
    call      cc_lex.lex
    test      %rbx,	%rbx
    jnz       L5933
    lea       %rcx,	[%rip+L9133]
    call      cc_support.serror
L5933:
    mov       %rax,	[%rbp + cc_parse.readgeneric.count]
    cmp       %rax,	1
    jle       L5935
    lea       %rcx,	[%rip+L9134]
    call      cc_support.serror
L5935:
    mov       %rax,	%rbx
L5919:
#---------------
    add       %rsp,	64
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.getmemmode
cc_parse.getmemmode:
#?>>
#?]]
#---------------
    mov       %ax,	[%rcx+56]
    test      %ax,	%ax
    jz        L5938
    movsx     %rax,	word ptr[%rcx+56]
    jmp       L5937
L5938:
    movsxd    %rax,	dword ptr[%rcx+52]
L5937:
L5936:
#---------------
    ret       
# End 
# Proc cc_parse.getpromotedtype
cc_parse.getpromotedtype:
#?>>
#?]]
#---------------
    test      %rcx,	%rcx
    jnz       L5941
    xor       %eax,	%eax
    jmp       L5939
L5941:
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rcx
    mov       %rax,	[%rax + %r10*8]
    cmp       %rax,	4
    jge       L5943
    mov       %rax,	3
    jmp       L5939
L5943:
    mov       %rax,	%rcx
L5939:
#---------------
    ret       
# End 
# Proc cc_parse.readdllexport
cc_parse.readdllexport:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    xor       %rdi,	%rdi
    call      cc_lex.lex
    mov       %rcx,	13
    call      cc_lib.checksymbol
    call      cc_lex.lex
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jnz       L5946
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L9135]
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L5946
    mov       %rdi,	1
L5946:
    call      cc_lex.lex
    mov       %rcx,	14
    call      cc_lib.checksymbol
    call      cc_lex.lex
    mov       %rax,	%rdi
L5944:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_genpcl.codegen_pcl
cc_genpcl.codegen_pcl:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
    movzx     %rax,	byte ptr[%rip+cc_cli.fverbose]
    cmp       %rax,	3
    jnz       L5949
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L9136]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+cc_decls.inputfile]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L5949:
    xor       %ecx,	%ecx
    mov       %rdx,	[%rip+cc_decls.nunits]
    call      pc_api.pcl_start
    call      cc_genpcl.dolibs
    lea       %rcx,	[%rip+L9137]
    call      pc_api.gencomment
    mov       %rax,	[%rip+cc_decls.stmodule]
    mov       %rdi,	[%rax+16]
    jmp       L5951
L5950:
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	7
    jz        L5954
    cmp       %rax,	6
    jz        L5955
    jmp       L5956
L5954:
    mov       %rcx,	%rdi
    call      cc_genpcl.dostaticvar
    jmp       L5953
L5955:
    movzx     %rax,	byte ptr[%rdi+110]
    cmp       %rax,	4
    jz        L5958
    cmp       %rax,	2
    jz        L5959
    jmp       L5960
L5958:
    mov       %rax,	[%rdi+72]
    test      %rax,	%rax
    jnz       L5962
    mov       %al,	3
    mov       [%rdi+110],	%al
L5962:
    jmp       L5957
L5959:
    mov       %rax,	[%rdi+72]
    test      %rax,	%rax
    jnz       L5964
    mov       %rax,	[%rdi]
    lea       %rcx,	[%rip+L9138]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      cc_support.gerror_s
L5964:
L5960:
L5957:
    mov       %rbx,	[%rdi+16]
    jmp       L5966
L5965:
    movzx     %rax,	byte ptr[%rbx+109]
    cmp       %rax,	7
    jz        L5969
    cmp       %rax,	8
    jz        L5970
    jmp       L5971
L5969:
    mov       %rcx,	%rbx
    call      cc_genpcl.dostaticvar
    jmp       L5968
L5970:
    mov       %rax,	[%rbx+72]
    test      %rax,	%rax
    jz        L5973
    mov       %rax,	[%rbx+72]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	28
    jz        L5976
    movzx     %rax,	word ptr[%rbx+102]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    cmp       %r10,	17
    jnz       L5975
    mov       %rax,	[%rbx+72]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5975
L5976:
    mov       %rcx,	%rbx
    call      cc_genpcl.dostaticvar
L5975:
L5973:
L5971:
L5968:
    mov       %rbx,	[%rbx+32]
L5966:
    test      %rbx,	%rbx
    jnz       L5965
L5956:
L5953:
    mov       %rdi,	[%rdi+32]
L5951:
    test      %rdi,	%rdi
    jnz       L5950
    lea       %rcx,	[%rip+L9139]
    call      pc_api.gencomment
    mov       %rax,	[%rip+cc_decls.stmodule]
    mov       %rdi,	[%rax+16]
    jmp       L5978
L5977:
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	6
    jnz       L5982
L5981:
    mov       %rax,	[%rdi+72]
    test      %rax,	%rax
    jz        L5984
    mov       %rcx,	%rdi
    call      cc_genpcl.genprocdef
L5984:
L5982:
L5980:
    mov       %rdi,	[%rdi+32]
L5978:
    test      %rdi,	%rdi
    jnz       L5977
    call      pc_api.pcl_end
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_genpcl.genprocdef
cc_genpcl.genprocdef:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
    xor       %rsi,	%rsi
    mov       %rax,	[%r12]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L9140]
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L5987
    mov       %rsi,	1
    lea       %rax,	[%r12+108]
    or        byte ptr[%rax],	8
L5987:
    mov       [%rip+cc_decls.currproc],	%r12
    mov       %rcx,	%r12
    call      cc_libpcl.getpsymbol
    mov       %r10,	%rax
    mov       %rbx,	%r10
    mov       %rcx,	%rax
    xor       %edx,	%edx
    mov       %r8,	%rsi
    xor       %r9d,	%r9d
    call      pc_api.pc_defproc
    mov       %rax,	[%r12+80]
    movsx     %rax,	word ptr[%rax+22]
    cmp       %rax,	3
    setz      %al
    movzx     %eax,	%al
    mov       [%rbx+113],	%al
    mov       %rdi,	[%r12+16]
    jmp       L5991
L5988:
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	9
    jz        L5993
    cmp       %rax,	8
    jz        L5994
    jmp       L5995
L5993:
    mov       %rcx,	%rdi
    call      cc_libpcl.getpsymbol
    mov       %rcx,	%rax
    call      pc_api.pc_addparam
    jmp       L5992
L5994:
    mov       %rcx,	%rdi
    call      cc_libpcl.getpsymbol
    mov       %rcx,	%rax
    call      pc_api.pc_addlocal
L5995:
L5992:
    mov       %rdi,	[%rdi+32]
L5991:
    test      %rdi,	%rdi
    jnz       L5988
    call      cc_libpcl.createfwdlabel
    mov       [%rip+cc_genpcl.retindex],	%rax
    lea       %rcx,	[%rip+L9141]
    call      pc_api.gencomment
    mov       %rcx,	[%r12+72]
    call      cc_blockpcl.do_stmt
    lea       %rcx,	[%rip+L9141]
    call      pc_api.gencomment
    test      %rsi,	%rsi
    jz        L5997
    mov       %al,	[%rip+pepcl.pdcc]
    test      %al,	%al
    jz        L5997
    xor       %ecx,	%ecx
    call      pc_api.genint
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	3
    call      cc_libpcl.setmode
    mov       %rcx,	[%rip+cc_genpcl.retindex]
    call      pc_api.genlabel
    mov       %rcx,	29
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	3
    call      cc_libpcl.setmode
L5997:
    mov       %rcx,	[%rip+cc_genpcl.retindex]
    call      cc_libpcl.definefwdlabel
    test      %rsi,	%rsi
    jz        L5999
    mov       %al,	[%rip+pepcl.pdcc]
    test      %al,	%al
    jnz       L5999
    xor       %ecx,	%ecx
    call      pc_api.genint
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	3
    call      cc_libpcl.setmode
    mov       %rcx,	32
    xor       %edx,	%edx
    call      pc_api.pc_gen
L5999:
    movzx     %rax,	word ptr[%r12+102]
    test      %rax,	%rax
    jz        L6001
    mov       %rax,	23
    jmp       L6000
L6001:
    mov       %rax,	20
L6000:
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      pc_api.pc_gen
    movzx     %rax,	word ptr[%r12+102]
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    call      pc_api.pc_endproc
    lea       %rcx,	[%rip+L9142]
    call      pc_api.gencomment
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_genpcl.dostaticvar
cc_genpcl.dostaticvar:
#?>>
    .set cc_genpcl.dostaticvar.str, -256
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	288
    mov       %r12,	%rcx
#---------------
    movzx     %rax,	byte ptr[%r12+110]
    cmp       %rax,	3
    jz        L6002
L6004:
    movzx     %rax,	word ptr[%r12+102]
    mov       %rcx,	%rax
    call      cc_lib.getalignment
    mov       %rdi,	%rax
    mov       %rax,	[%r12+72]
    test      %rax,	%rax
    jz        L6006
    movzx     %rax,	byte ptr[%r12+109]
    cmp       %rax,	8
    jnz       L6008
    lea       %rcx,	[%rbp + cc_genpcl.dostaticvar.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L9143]
    call      msys.m$print_setfmt
    mov       %rax,	[%r12+8]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    mov       %rcx,	[%r12]
    call      msys.m$print_str_nf
    movzx     %rax,	word ptr[%r12+96]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + cc_genpcl.dostaticvar.str]
    call      cc_lex.addnamestr
    xor       %ecx,	%ecx
    mov       %rdx,	%rax
    mov       %r8,	7
    call      cc_lib.createdupldef
    mov       %rbx,	%rax
    mov       %rcx,	%rbx
    call      cc_libpcl.getpsymbol
    mov       %rsi,	%rax
    mov       [%r12+114],	%rsi
    mov       %rcx,	%rsi
    call      pc_api.genmem
    mov       %rcx,	123
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    jmp       L6007
L6008:
    mov       %rcx,	%r12
    call      cc_libpcl.genmem_d
    mov       %rcx,	123
    mov       %rdx,	%rax
    call      pc_api.pc_gen
L6007:
    movzx     %rax,	word ptr[%r12+102]
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    mov       %rcx,	%rdi
    call      pc_api.pc_setalign
    mov       %rax,	[%r12+72]
    mov       %rcx,	%rax
    mov       %rdx,	1
    mov       %r8,	1
    xor       %r9d,	%r9d
    call      cc_genpcl.genidata
    jmp       L6005
L6006:
    mov       %rcx,	%r12
    call      cc_libpcl.genmem_d
    mov       %rcx,	124
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    movzx     %rax,	word ptr[%r12+102]
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    mov       %rcx,	%rdi
    call      pc_api.pc_setalign
L6005:
L6002:
#---------------
    add       %rsp,	288
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_genpcl.genidata
cc_genpcl.genidata:
#?>>
    .set cc_genpcl.genidata.p, 64
    .set cc_genpcl.genidata.doterm, 72
    .set cc_genpcl.genidata.am, 80
    .set cc_genpcl.genidata.offset, 88
    .set cc_genpcl.genidata.size, -8
    .set cc_genpcl.genidata.padding, -16
    .set cc_genpcl.genidata.isunion, -24
    .set cc_genpcl.genidata.q, -32
    .set cc_genpcl.genidata.a, -40
    .set cc_genpcl.genidata.b, -48
    .set cc_genpcl.genidata.d, -56
    .set cc_genpcl.genidata.sx, -64
    .set cc_genpcl.genidata.str, -320
    .set cc_genpcl.genidata.str2, -336
    .set cc_genpcl.genidata.av_1, -344
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	384
    mov       [%rbp+64],	%rcx
    mov       [%rbp+88],	%r9
#---------------
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    movsxd    %rax,	dword ptr[%rax+52]
    mov       %rdi,	%rax
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    mov       %rax,	[%rax+16]
    mov       [%rbp + cc_genpcl.genidata.a],	%rax
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    mov       %rax,	[%rax+24]
    mov       [%rbp + cc_genpcl.genidata.b],	%rax
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	28
    jz        L6011
    cmp       %rax,	1
    jz        L6012
    cmp       %rax,	3
    jz        L6013
    cmp       %rax,	5
    jz        L6013
    cmp       %rax,	39
    jz        L6014
    cmp       %rax,	55
    jz        L6015
    cmp       %rax,	53
    jz        L6016
    cmp       %rax,	54
    jz        L6016
    cmp       %rax,	56
    jz        L6017
    jmp       L6018
L6011:
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    movsxd    %rax,	dword ptr[%rax+48]
    mov       %rsi,	%rax
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jnz       L6020
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%rdi
    mov       %rbx,	[%rax + %r10*8]
    mov       %rax,	[%rbp + cc_genpcl.genidata.a]
    mov       [%rbp + cc_genpcl.genidata.q],	%rax
    mov       %r12,	1
    cmp       %rsi,	1
    jl        L6023
L6021:
    mov       %rcx,	[%rbp + cc_genpcl.genidata.q]
    mov       %rdx,	1
    mov       %r8,	1
    xor       %r9d,	%r9d
    call      cc_genpcl.genidata
    mov       %rax,	[%rbp + cc_genpcl.genidata.q]
    mov       %rax,	[%rax+8]
    mov       [%rbp + cc_genpcl.genidata.q],	%rax
    inc       %r12
    cmp       %r12,	%rsi
    jle       L6021
L6023:
    cmp       %rsi,	%rbx
    jge       L6025
    mov       %rax,	%rbx
    sub       %rax,	%rsi
    lea       %r10,	[%rip+cc_decls.tttarget]
    mov       %r11,	%rdi
    movsx     %r10,	word ptr[%r10 + %r11*2]
    lea       %r11,	[%rip+cc_decls.ttsize]
    mov       %r11,	[%r11 + %r10*8]
    imul      %rax,	%r11
    mov       %rcx,	%rax
    call      cc_genpcl.doresb
L6025:
    jmp       L6019
L6020:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	19
    setz      %al
    movzx     %eax,	%al
    mov       [%rbp + cc_genpcl.genidata.isunion],	%rax
    lea       %rax,	[%rip+cc_decls.ttnamedef]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    mov       %rax,	[%rax+16]
    mov       [%rbp + cc_genpcl.genidata.d],	%rax
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    mov       [%rbp + cc_genpcl.genidata.size],	%rax
    xor       %eax,	%eax
    mov       %r14,	%rax
    mov       %r13,	%rax
    mov       %rax,	[%rbp + cc_genpcl.genidata.a]
    mov       [%rbp + cc_genpcl.genidata.q],	%rax
    mov       %r12,	1
    cmp       %rsi,	1
    jl        L6028
L6026:
    mov       %rcx,	[%rbp + cc_genpcl.genidata.q]
    xor       %edx,	%edx
    mov       %r8,	1
    xor       %r9d,	%r9d
    call      cc_genpcl.genidata
    mov       %rax,	[%rbp + cc_genpcl.genidata.q]
    movsxd    %rax,	dword ptr[%rax+52]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r10,	[%r10 + %rax*8]
    add       %r13,	%r10
    mov       %rax,	[%rbp + cc_genpcl.genidata.d]
    mov       %rax,	[%rax+32]
    mov       [%rbp + cc_genpcl.genidata.d],	%rax
    mov       %rax,	[%rbp + cc_genpcl.genidata.d]
    test      %rax,	%rax
    jz        L6030
    mov       %rax,	[%rbp + cc_genpcl.genidata.isunion]
    test      %rax,	%rax
    jnz       L6030
    mov       %rax,	[%rbp + cc_genpcl.genidata.d]
    movsxd    %rax,	dword ptr[%rax+88]
    mov       %r14,	%rax
    jmp       L6029
L6030:
    mov       %r14,	[%rbp + cc_genpcl.genidata.size]
L6029:
    mov       %rax,	%r14
    sub       %rax,	%r13
    mov       [%rbp + cc_genpcl.genidata.padding],	%rax
    mov       %rax,	[%rbp + cc_genpcl.genidata.padding]
    cmp       %rax,	0
    jle       L6032
    mov       %rax,	%r14
    sub       %rax,	%r13
    mov       %rcx,	%rax
    call      cc_genpcl.doresb
    mov       %r13,	%r14
L6032:
    mov       %rax,	[%rbp + cc_genpcl.genidata.q]
    mov       %rax,	[%rax+8]
    mov       [%rbp + cc_genpcl.genidata.q],	%rax
    inc       %r12
    cmp       %r12,	%rsi
    jle       L6026
L6028:
    cmp       %r14,	[%rbp + cc_genpcl.genidata.size]
    jge       L6034
    mov       %rax,	[%rbp + cc_genpcl.genidata.size]
    sub       %rax,	%r14
    mov       %rcx,	%rax
    call      cc_genpcl.doresb
L6034:
L6019:
    jmp       L6009
L6012:
    mov       %rcx,	%rdi
    call      cc_lib.isintcc
    test      %rax,	%rax
    jnz       L6037
    mov       %rcx,	%rdi
    call      cc_lib.isrealcc
    test      %rax,	%rax
    jz        L6036
L6037:
    cmp       %rdi,	10
    jnz       L6039
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    movq      %XMM4,	[%rax]
    cvtsd2ss  %XMM4,	%XMM4
    movd      [%rbp + cc_genpcl.genidata.sx],	%XMM4
    mov       %eax,	[%rbp + cc_genpcl.genidata.sx]
    mov       %rcx,	%rax
    call      pc_api.genint
    mov       %rcx,	125
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    jmp       L6038
L6039:
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    call      pc_api.genint
    mov       %rcx,	125
    mov       %rdx,	%rax
    call      pc_api.pc_gen
L6038:
    mov       %rcx,	%rdi
    call      cc_libpcl.setmode
    jmp       L6035
L6036:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	13
    jnz       L6040
    xor       %eax,	%eax
    mov       [%rbp + cc_genpcl.genidata.padding],	%rax
#cc_genpcl.genidata.doref:
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    mov       %rax,	[%rax]
    test      %rax,	%rax
    jnz       L6043
    xor       %ecx,	%ecx
    call      pc_api.genint
    mov       %rcx,	125
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    jmp       L6042
L6043:
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    mov       %al,	[%rax+61]
    test      %al,	%al
    jz        L6044
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    movsxd    %rax,	dword ptr[%rax+48]
    mov       %r10,	[%rbp + cc_genpcl.genidata.p]
    mov       %r10,	[%r10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      pc_api.genstring
    mov       %rcx,	125
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    jmp       L6042
L6044:
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    mov       %al,	[%rax+62]
    test      %al,	%al
    jz        L6045
    lea       %rcx,	[%rip+L9144]
    xor       %edx,	%edx
    call      cc_support.gerror
    mov       %rcx,	[%rbp + cc_genpcl.genidata.padding]
    call      cc_genpcl.doresb
    jmp       L6042
L6045:
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    call      pc_api.genint
    mov       %rcx,	125
    mov       %rdx,	%rax
    call      pc_api.pc_gen
L6042:
    mov       %rcx,	%rdi
    call      cc_libpcl.setmode
    jmp       L6035
L6040:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jnz       L6046
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    mov       %r10,	[%rbp + cc_genpcl.genidata.p]
    movsxd    %r10,	dword ptr[%r10+48]
    sub       %rax,	%r10
    lea       %r10,	[%rip+cc_decls.tttarget]
    mov       %r11,	%rdi
    movsx     %r10,	word ptr[%r10 + %r11*2]
    lea       %r11,	[%rip+cc_decls.ttsize]
    mov       %r11,	[%r11 + %r10*8]
    imul      %rax,	%r11
    mov       [%rbp + cc_genpcl.genidata.padding],	%rax
    mov       %r12,	1
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    movsxd    %rax,	dword ptr[%rax+48]
    mov       [%rbp + cc_genpcl.genidata.av_1],	%rax
    mov       %rax,	[%rbp + cc_genpcl.genidata.av_1]
    cmp       %rax,	1
    jl        L6049
L6047:
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    mov       %rax,	[%rax]
    mov       %r10,	%r12
    lea       %rax,	[%rax + %r10]
    sub       %rax,	1
    movzx     %rax,	byte ptr[%rax]
    mov       %rcx,	%rax
    call      pc_api.genint
    mov       %rcx,	125
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	6
    call      cc_libpcl.setmode
    inc       %r12
    cmp       %r12,	[%rbp + cc_genpcl.genidata.av_1]
    jle       L6047
L6049:
    mov       %rcx,	[%rbp + cc_genpcl.genidata.padding]
    call      cc_genpcl.doresb
    jmp       L6035
L6046:
    call      msys.m$print_startcon
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L9145]
    xor       %edx,	%edx
    call      cc_support.gerror
L6035:
    jmp       L6009
L6013:
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    mov       %rax,	[%rax]
    mov       [%rbp + cc_genpcl.genidata.d],	%rax
    mov       %rax,	[%rbp + cc_genpcl.genidata.d]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	7
    jz        L6051
    cmp       %rax,	6
    jnz       L6052
L6051:
    mov       %rcx,	[%rbp + cc_genpcl.genidata.d]
    call      cc_libpcl.genmemaddr_d
    mov       %rcx,	125
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %eax,	1
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+16],	%eax
    mov       %eax,	[%rbp + cc_genpcl.genidata.offset]
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+20],	%eax
    mov       %rcx,	9
    call      cc_libpcl.setmode
    jmp       L6050
L6052:
    lea       %rcx,	[%rip+L9146]
    mov       %rdx,	[%rbp + cc_genpcl.genidata.p]
    call      cc_support.gerror
L6050:
    jmp       L6009
L6014:
    mov       %rax,	[%rbp + cc_genpcl.genidata.a]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	3
    jnz       L6054
    mov       %rax,	[%rbp + cc_genpcl.genidata.b]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L6054
    mov       %rax,	[%rbp + cc_genpcl.genidata.a]
    mov       %rax,	[%rax]
    mov       [%rbp + cc_genpcl.genidata.d],	%rax
    mov       %rax,	[%rbp + cc_genpcl.genidata.d]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	7
    jnz       L6057
L6056:
    lea       %rcx,	[%rbp + cc_genpcl.genidata.str]
    lea       %rdx,	[%rip+L9147]
    call      strcpy
    mov       %rax,	[%rbp + cc_genpcl.genidata.d]
    movzx     %rax,	byte ptr[%rax+110]
    cmp       %rax,	1
    jnz       L6059
    mov       %rax,	[%rip+cc_decls.currproc]
    mov       %rax,	[%rax]
    lea       %rcx,	[%rbp + cc_genpcl.genidata.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rcx,	[%rbp + cc_genpcl.genidata.str]
    lea       %rdx,	[%rip+L9148]
    call      strcat
L6059:
    mov       %rax,	[%rbp + cc_genpcl.genidata.d]
    mov       %rax,	[%rax]
    lea       %rcx,	[%rbp + cc_genpcl.genidata.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rcx,	[%rbp + cc_genpcl.genidata.str]
    lea       %rdx,	[%rip+L9149]
    call      strcat
    mov       %rax,	[%rbp + cc_genpcl.genidata.b]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    lea       %rdx,	[%rbp + cc_genpcl.genidata.str2]
    call      msys.getstrint
    lea       %rcx,	[%rbp + cc_genpcl.genidata.str]
    lea       %rdx,	[%rbp + cc_genpcl.genidata.str2]
    call      strcat
    lea       %rcx,	[%rbp + cc_genpcl.genidata.str]
    call      pc_api.genname
    mov       %rcx,	125
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    jmp       L6055
L6057:
    lea       %rcx,	[%rip+L9150]
    xor       %edx,	%edx
    call      cc_support.gerror
L6055:
    jmp       L6053
L6054:
    mov       %rax,	[%rbp + cc_genpcl.genidata.a]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L6060
    mov       %rax,	[%rbp + cc_genpcl.genidata.b]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L6060
    mov       %rax,	[%rbp + cc_genpcl.genidata.a]
    movsxd    %rax,	dword ptr[%rax+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    cmp       %r10,	13
    jnz       L6060
    lea       %rcx,	[%rbp + cc_genpcl.genidata.str]
    call      msys.m$print_startstr
    mov       %rax,	[%rbp + cc_genpcl.genidata.a]
    mov       %rcx,	[%rax]
    call      msys.m$print_i64_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L9151]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       %rax,	[%rbp + cc_genpcl.genidata.b]
    mov       %rcx,	[%rax]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + cc_genpcl.genidata.str]
    call      pc_api.genname
    mov       %rcx,	125
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    jmp       L6053
L6060:
    lea       %rcx,	[%rip+L9152]
    xor       %edx,	%edx
    call      cc_support.gerror
L6053:
    jmp       L6009
L6015:
    mov       %rax,	[%rbp + cc_genpcl.genidata.a]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	52
    jnz       L6062
    mov       %rax,	[%rbp + cc_genpcl.genidata.a]
    mov       %rax,	[%rax+16]
    mov       %rcx,	%rax
    mov       %rdx,	1
    mov       %r8,	1
    mov       %r9,	[%rbp + cc_genpcl.genidata.offset]
    call      cc_genpcl.genidata
    jmp       L6061
L6062:
    mov       %rcx,	[%rbp + cc_genpcl.genidata.a]
    mov       %rdx,	1
    xor       %r8d,	%r8d
    mov       %r9,	[%rbp + cc_genpcl.genidata.offset]
    call      cc_genpcl.genidata
L6061:
    jmp       L6010
L6016:
    mov       %rax,	[%rbp + cc_genpcl.genidata.b]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jz        L6064
    lea       %rcx,	[%rip+L9153]
    xor       %edx,	%edx
    call      cc_support.gerror
L6064:
    mov       %rax,	[%rbp + cc_genpcl.genidata.b]
    mov       %rax,	[%rax]
    mov       %r10,	[%rbp + cc_genpcl.genidata.p]
    movsxd    %r10,	dword ptr[%r10]
    imul      %rax,	%r10
    add       %rax,	[%rbp + cc_genpcl.genidata.offset]
    mov       %rcx,	[%rbp + cc_genpcl.genidata.a]
    mov       %rdx,	1
    mov       %r8,	1
    mov       %r9,	%rax
    call      cc_genpcl.genidata
    jmp       L6010
L6017:
    mov       %rcx,	[%rbp + cc_genpcl.genidata.a]
    mov       %rdx,	1
    mov       %r8,	1
    mov       %r9,	[%rbp + cc_genpcl.genidata.offset]
    call      cc_genpcl.genidata
    jmp       L6010
L6018:
    xor       %ecx,	%ecx
    mov       %rdx,	[%rbp + cc_genpcl.genidata.p]
    xor       %r8d,	%r8d
    lea       %r9,	[%rip+L9154]
    call      cc_show.printunit
    lea       %rcx,	[%rip+L9155]
    mov       %rdx,	[%rbp + cc_genpcl.genidata.p]
    call      cc_support.gerror
L6010:
L6009:
#---------------
    add       %rsp,	384
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_genpcl.doresb
cc_genpcl.doresb:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    jmp       L6067
L6066:
    xor       %ecx,	%ecx
    call      pc_api.genint
    mov       %rcx,	125
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rax,	8
    sub       %rbx,	%rax
    mov       %rcx,	9
    call      cc_libpcl.setmode
L6067:
    cmp       %rbx,	8
    jge       L6066
    mov       %rdi,	%rbx
    cmp       %rdi,	0
    jle       L6071
L6069:
    xor       %ecx,	%ecx
    call      pc_api.genint
    mov       %rcx,	125
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	6
    call      cc_libpcl.setmode
    dec       %rdi
    jnz       L6069
L6071:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_genpcl.pushint
cc_genpcl.pushint:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      pc_api.genint
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_genpcl.dolibs
cc_genpcl.dolibs:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rdi,	1
    mov       %rax,	[%rip+cc_decls.nlibfiles]
    cmp       %rax,	1
    jl        L6076
L6074:
    lea       %rax,	[%rip+cc_decls.libfiles]
    mov       %r10,	%rdi
    mov       %rcx,	[%rax + %r10*8]
    call      pc_api.pc_addplib
    inc       %rdi
    cmp       %rdi,	[%rip+cc_decls.nlibfiles]
    jle       L6074
L6076:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.do_stmt
cc_blockpcl.do_stmt:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
    test      %r12,	%r12
    jnz       L6079
    jmp       L6077
L6079:
    mov       %rdi,	[%rip+cc_decls.clineno]
    mov       %eax,	[%r12+44]
    mov       [%rip+cc_decls.clineno],	%rax
    movzx     %rax,	byte ptr[%r12+60]
    mov       [%rip+cc_decls.cfileno],	%rax
    mov       %rax,	[%rip+cc_decls.cfileno]
    shl       %rax,	24
    add       %rax,	[%rip+cc_decls.clineno]
    mov       [%rip+pc_decls.mmpos],	%rax
    mov       %rbx,	[%r12+16]
    mov       %rsi,	[%r12+24]
    movsxd    %rax,	dword ptr[%r12+40]
    sub       %rax,	6
    cmp       %rax,	69
    jae       L6082
    lea       %r10,	[%rip+L6081]
    jmp       [%r10 + %rax*8]
    .data
L6081:
    .quad     L6083
    .quad     L6082
    .quad     L6087
    .quad     L6089
    .quad     L6082
    .quad     L6090
    .quad     L6091
    .quad     L6092
    .quad     L6093
    .quad     L6094
    .quad     L6095
    .quad     L6096
    .quad     L6097
    .quad     L6098
    .quad     L6100
    .quad     L6101
    .quad     L6102
    .quad     L6099
    .quad     L6082
    .quad     L6082
    .quad     L6082
    .quad     L6082
    .quad     L6082
    .quad     L6117
    .quad     L6088
    .quad     L6091
    .quad     L6082
    .quad     L6082
    .quad     L6082
    .quad     L6082
    .quad     L6082
    .quad     L6082
    .quad     L6082
    .quad     L6082
    .quad     L6082
    .quad     L6082
    .quad     L6082
    .quad     L6082
    .quad     L6082
    .quad     L6082
    .quad     L6082
    .quad     L6082
    .quad     L6082
    .quad     L6082
    .quad     L6082
    .quad     L6082
    .quad     L6082
    .quad     L6082
    .quad     L6082
    .quad     L6082
    .quad     L6082
    .quad     L6082
    .quad     L6082
    .quad     L6082
    .quad     L6082
    .quad     L6103
    .quad     L6104
    .quad     L6105
    .quad     L6106
    .quad     L6109
    .quad     L6110
    .quad     L6111
    .quad     L6112
    .quad     L6113
    .quad     L6114
    .quad     L6115
    .quad     L6116
    .quad     L6115
    .quad     L6116
    .text
L6083:
    jmp       L6085
L6084:
    mov       %rcx,	%rbx
    call      cc_blockpcl.do_stmt
    mov       %rbx,	[%rbx+8]
L6085:
    test      %rbx,	%rbx
    jnz       L6084
    jmp       L6080
L6087:
    mov       %rcx,	[%r12]
    call      cc_blockpcl.do_decl
    jmp       L6080
L6088:
    mov       %rcx,	%r12
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    xor       %r9d,	%r9d
    call      cc_blockpcl.dx_call
    jmp       L6080
L6089:
    mov       %rcx,	%r12
    mov       %rdx,	%rbx
    call      cc_blockpcl.do_return
    jmp       L6080
L6090:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    xor       %r8d,	%r8d
    call      cc_blockpcl.do_assign
    jmp       L6080
L6091:
    mov       %rax,	[%r12+32]
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	%rax
    call      cc_blockpcl.do_if
    jmp       L6080
L6092:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      cc_blockpcl.do_for
    jmp       L6080
L6093:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      cc_blockpcl.do_while
    jmp       L6080
L6094:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      cc_blockpcl.do_dowhile
    jmp       L6080
L6095:
    mov       %rcx,	[%r12]
    call      cc_blockpcl.do_goto
    jmp       L6080
L6096:
    mov       %rcx,	[%r12]
    call      cc_blockpcl.do_labeldef
    mov       %rcx,	%rbx
    call      cc_blockpcl.do_stmt
    jmp       L6080
L6097:
    mov       %rcx,	%r12
    mov       %rdx,	%rbx
    call      cc_blockpcl.do_casestmt
    jmp       L6080
L6098:
    mov       %al,	1
    mov       [%rip+cc_blockpcl.sw_defaultseen],	%al
    mov       %rcx,	[%rip+cc_blockpcl.sw_defaultlabel]
    call      pc_api.genlabel
    mov       %rcx,	127
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	%rbx
    call      cc_blockpcl.do_stmt
    jmp       L6080
L6099:
    mov       %rcx,	[%rip+cc_blockpcl.sw_breaklabel]
    call      cc_blockpcl.genjumpl
    jmp       L6080
L6100:
    lea       %rax,	[%rip+cc_blockpcl.breakstack]
    mov       %r10,	[%rip+cc_blockpcl.loopindex]
    mov       %rcx,	[%rax + %r10*8-8]
    call      cc_blockpcl.genjumpl
    jmp       L6080
L6101:
    lea       %rax,	[%rip+cc_blockpcl.continuestack]
    mov       %r10,	[%rip+cc_blockpcl.loopindex]
    mov       %rcx,	[%rax + %r10*8-8]
    call      cc_blockpcl.genjumpl
    jmp       L6080
L6102:
    mov       %rcx,	%r12
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      cc_blockpcl.do_switch
    jmp       L6080
L6103:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	90
    xor       %r9d,	%r9d
    call      cc_blockpcl.dx_binto
    jmp       L6080
L6104:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	91
    xor       %r9d,	%r9d
    call      cc_blockpcl.dx_binto
    jmp       L6080
L6105:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	92
    xor       %r9d,	%r9d
    call      cc_blockpcl.dx_binto
    jmp       L6080
L6106:
    movsxd    %rax,	dword ptr[%rbx+52]
    mov       %rcx,	%rax
    call      cc_lib.isrealcc
    test      %rax,	%rax
    jz        L6108
    mov       %rax,	93
    jmp       L6107
L6108:
    mov       %rax,	94
L6107:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      cc_blockpcl.dx_binto
    jmp       L6080
L6109:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	95
    xor       %r9d,	%r9d
    call      cc_blockpcl.dx_binto
    jmp       L6080
L6110:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	96
    xor       %r9d,	%r9d
    call      cc_blockpcl.dx_binto
    jmp       L6080
L6111:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	97
    xor       %r9d,	%r9d
    call      cc_blockpcl.dx_binto
    jmp       L6080
L6112:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	98
    xor       %r9d,	%r9d
    call      cc_blockpcl.dx_binto
    jmp       L6080
L6113:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	99
    xor       %r9d,	%r9d
    call      cc_blockpcl.dx_binto
    jmp       L6080
L6114:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	100
    xor       %r9d,	%r9d
    call      cc_blockpcl.dx_binto
    jmp       L6080
L6115:
    mov       %rcx,	%rbx
    mov       %rdx,	84
    call      cc_blockpcl.do_preincr
    jmp       L6080
L6116:
    mov       %rcx,	%rbx
    mov       %rdx,	85
    call      cc_blockpcl.do_preincr
    jmp       L6080
L6117:
    jmp       L6119
L6118:
    mov       %rcx,	%rbx
    call      cc_blockpcl.do_stmt
    mov       %rbx,	[%rbx+8]
L6119:
    test      %rbx,	%rbx
    jnz       L6118
    jmp       L6080
L6082:
    mov       %rcx,	%r12
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	11
    xor       %edx,	%edx
    call      pc_api.pc_gen
    test      %rbx,	%rbx
    jz        L6122
    mov       %rax,	%rbx
    jmp       L6121
L6122:
    mov       %rax,	%r12
L6121:
    mov       %rcx,	%rax
    call      cc_libpcl.setmode_u
L6080:
L6077:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_expr
cc_blockpcl.dx_expr:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r13,	%rcx
    mov       %r14,	%rdx
#---------------
    test      %r13,	%r13
    jnz       L6125
    jmp       L6123
L6125:
    mov       %rdi,	[%rip+cc_decls.clineno]
    mov       %eax,	[%r13+44]
    mov       [%rip+cc_decls.clineno],	%rax
    movzx     %rax,	byte ptr[%r13+60]
    mov       [%rip+cc_decls.cfileno],	%rax
    mov       %rsi,	[%r13+16]
    mov       %r12,	[%r13+24]
    movsxd    %rax,	dword ptr[%r13+52]
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%r13+40]
    sub       %rax,	1
    cmp       %rax,	76
    jae       L6128
    lea       %r10,	[%rip+L6127]
    jmp       [%r10 + %rax*8]
    .data
L6127:
    .quad     L6129
    .quad     L6128
    .quad     L6130
    .quad     L6131
    .quad     L6132
    .quad     L6128
    .quad     L6128
    .quad     L6128
    .quad     L6128
    .quad     L6128
    .quad     L6133
    .quad     L6128
    .quad     L6128
    .quad     L6128
    .quad     L6128
    .quad     L6128
    .quad     L6128
    .quad     L6128
    .quad     L6128
    .quad     L6128
    .quad     L6128
    .quad     L6128
    .quad     L6128
    .quad     L6134
    .quad     L6134
    .quad     L6135
    .quad     L6142
    .quad     L6128
    .quad     L6145
    .quad     L6156
    .quad     L6157
    .quad     L6128
    .quad     L6158
    .quad     L6158
    .quad     L6158
    .quad     L6158
    .quad     L6158
    .quad     L6158
    .quad     L6159
    .quad     L6162
    .quad     L6163
    .quad     L6164
    .quad     L6167
    .quad     L6168
    .quad     L6169
    .quad     L6170
    .quad     L6171
    .quad     L6172
    .quad     L6195
    .quad     L6128
    .quad     L6128
    .quad     L6173
    .quad     L6174
    .quad     L6175
    .quad     L6194
    .quad     L6176
    .quad     L6179
    .quad     L6180
    .quad     L6128
    .quad     L6181
    .quad     L6184
    .quad     L6185
    .quad     L6186
    .quad     L6187
    .quad     L6188
    .quad     L6189
    .quad     L6190
    .quad     L6191
    .quad     L6192
    .quad     L6193
    .quad     L6182
    .quad     L6182
    .quad     L6183
    .quad     L6183
    .quad     L6196
    .quad     L6197
    .text
L6129:
    mov       %rcx,	%r13
    call      cc_blockpcl.dx_const
    jmp       L6126
L6130:
    mov       %rcx,	%r13
    mov       %rdx,	%r14
    call      cc_blockpcl.dx_name
    jmp       L6126
L6131:
    mov       %rcx,	%rsi
    mov       %rdx,	%r14
    call      cc_blockpcl.dx_expr
    jmp       L6126
L6132:
    mov       %rax,	[%r13]
    mov       %rcx,	%rax
    call      cc_libpcl.genmemaddr_d
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	9
    call      cc_libpcl.setmode
    jmp       L6126
L6133:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	1
    call      cc_blockpcl.do_assign
    jmp       L6126
L6134:
    mov       %rcx,	%r13
    call      cc_blockpcl.dx_andorl
    jmp       L6126
L6135:
    movsxd    %rax,	dword ptr[%rsi+40]
    cmp       %rax,	26
    jnz       L6137
    mov       %rax,	[%rsi+16]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rax,	[%rsi+16]
    mov       %rcx,	%rax
    call      cc_blockpcl.isboolexpr
    test      %rax,	%rax
    jnz       L6139
    mov       %rcx,	64
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	8
    call      cc_libpcl.setmode
    mov       %rax,	[%rsi+16]
    movsxd    %rax,	dword ptr[%rax+52]
    mov       %rcx,	%rax
    call      cc_libpcl.setmode2
L6139:
    jmp       L6136
L6137:
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	%rsi
    call      cc_blockpcl.isboolexpr
    test      %rax,	%rax
    jnz       L6141
    mov       %rcx,	65
    xor       %edx,	%edx
    call      pc_api.pc_gen
    jmp       L6140
L6141:
    mov       %rcx,	63
    xor       %edx,	%edx
    call      pc_api.pc_gen
L6140:
    mov       %rcx,	%rsi
    call      cc_libpcl.setmode_u
L6136:
    jmp       L6126
L6142:
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	%rsi
    call      cc_blockpcl.isboolexpr
    test      %rax,	%rax
    jnz       L6144
    mov       %rcx,	64
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	8
    call      cc_libpcl.setmode
    movsxd    %rax,	dword ptr[%rsi+52]
    mov       %rcx,	%rax
    call      cc_libpcl.setmode2
L6144:
    jmp       L6126
L6145:
    jmp       L6149
L6146:
    mov       %r12,	[%rsi+8]
    test      %r12,	%r12
    jz        L6151
    movsxd    %rax,	dword ptr[%rsi+40]
    cmp       %rax,	11
    jz        L6152
    cmp       %rax,	56
    jz        L6152
    cmp       %rax,	31
    jnz       L6151
L6152:
    mov       %rcx,	%rsi
    call      cc_blockpcl.do_stmt
    jmp       L6150
L6151:
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    test      %r12,	%r12
    jz        L6154
    movsxd    %rax,	dword ptr[%rsi+52]
    test      %rax,	%rax
    jnz       L6155
    movsxd    %rax,	dword ptr[%rsi+40]
    cmp       %rax,	56
    jnz       L6154
L6155:
    mov       %rcx,	134
    xor       %edx,	%edx
    call      pc_api.pc_gen
L6154:
L6150:
    mov       %rsi,	%r12
L6149:
    test      %rsi,	%rsi
    jnz       L6146
    jmp       L6126
L6156:
    mov       %rcx,	%r13
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    mov       %r9,	1
    call      cc_blockpcl.dx_call
    jmp       L6126
L6157:
    mov       %rax,	[%r13+32]
    mov       %rcx,	%r13
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    mov       %r9,	%rax
    call      cc_blockpcl.dx_ifx
    jmp       L6126
L6158:
    mov       %rcx,	%r13
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      cc_blockpcl.dx_eq
    jmp       L6126
L6159:
    movsxd    %rax,	dword ptr[%rsi+52]
    lea       %r10,	[%rip+cc_decls.ttisref]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L6161
    movsxd    %rax,	dword ptr[%r12+52]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r10,	[%r10 + %rax*8]
    cmp       %r10,	4
    jg        L6161
    mov       %eax,	9
    mov       [%r12+52],	%eax
L6161:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	43
    call      cc_blockpcl.dx_bin
    jmp       L6126
L6162:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	44
    call      cc_blockpcl.dx_bin
    jmp       L6126
L6163:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	45
    call      cc_blockpcl.dx_bin
    jmp       L6126
L6164:
    movsxd    %rax,	dword ptr[%rsi+52]
    mov       %rcx,	%rax
    call      cc_lib.isrealcc
    test      %rax,	%rax
    jz        L6166
    mov       %rax,	46
    jmp       L6165
L6166:
    mov       %rax,	47
L6165:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	%rax
    call      cc_blockpcl.dx_bin
    jmp       L6126
L6167:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	48
    call      cc_blockpcl.dx_bin
    jmp       L6126
L6168:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	50
    call      cc_blockpcl.dx_bin
    jmp       L6126
L6169:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	51
    call      cc_blockpcl.dx_bin
    jmp       L6126
L6170:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	52
    call      cc_blockpcl.dx_bin
    jmp       L6126
L6171:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	53
    call      cc_blockpcl.dx_bin
    jmp       L6126
L6172:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	54
    call      cc_blockpcl.dx_bin
    jmp       L6126
L6173:
    mov       %rcx,	%r13
    mov       %rdx,	%rsi
    mov       %r8,	%r14
    call      cc_blockpcl.dx_ptr
    jmp       L6126
L6174:
    sub       %rsp,	8
    mov       %rax,	%r14
    push      %rax
    mov       %rcx,	%r13
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    mov       %r9,	57
    sub       %rsp,	32
    call      cc_blockpcl.dx_addptr
    add       %rsp,	48
    jmp       L6126
L6175:
    sub       %rsp,	8
    mov       %rax,	%r14
    push      %rax
    mov       %rcx,	%r13
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    mov       %r9,	58
    sub       %rsp,	32
    call      cc_blockpcl.dx_addptr
    add       %rsp,	48
    jmp       L6126
L6176:
    movsx     %rax,	word ptr[%r13+58]
    test      %rax,	%rax
    jnz       L6178
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    jmp       L6177
L6178:
    movsxd    %rax,	dword ptr[%r13+48]
    movsx     %r10,	word ptr[%r13+58]
    mov       %rcx,	%r13
    mov       %rdx,	%rsi
    mov       %r8,	%r10
    mov       %r9,	%rax
    call      cc_blockpcl.dx_convert
L6177:
    jmp       L6126
L6179:
    mov       %rcx,	%r13
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      cc_blockpcl.dx_scale
    jmp       L6126
L6180:
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	60
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	%rsi
    call      cc_libpcl.setmode_u
    jmp       L6126
L6181:
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	62
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	%rsi
    call      cc_libpcl.setmode_u
    jmp       L6126
L6182:
    mov       %rcx,	%r13
    mov       %rdx,	%rsi
    call      cc_blockpcl.dx_preincrx
    jmp       L6126
L6183:
    mov       %rcx,	%r13
    mov       %rdx,	%rsi
    call      cc_blockpcl.dx_postincrx
    jmp       L6126
L6184:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	90
    mov       %r9,	1
    call      cc_blockpcl.dx_binto
    jmp       L6126
L6185:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	91
    mov       %r9,	1
    call      cc_blockpcl.dx_binto
    jmp       L6126
L6186:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	92
    mov       %r9,	1
    call      cc_blockpcl.dx_binto
    jmp       L6126
L6187:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	93
    mov       %r9,	1
    call      cc_blockpcl.dx_binto
    jmp       L6126
L6188:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	95
    mov       %r9,	1
    call      cc_blockpcl.dx_binto
    jmp       L6126
L6189:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	96
    mov       %r9,	1
    call      cc_blockpcl.dx_binto
    jmp       L6126
L6190:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	97
    mov       %r9,	1
    call      cc_blockpcl.dx_binto
    jmp       L6126
L6191:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	98
    mov       %r9,	1
    call      cc_blockpcl.dx_binto
    jmp       L6126
L6192:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	99
    mov       %r9,	1
    call      cc_blockpcl.dx_binto
    jmp       L6126
L6193:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	100
    mov       %r9,	1
    call      cc_blockpcl.dx_binto
    jmp       L6126
L6194:
    mov       %rcx,	%r13
    mov       %rdx,	%rsi
    mov       %r8,	%r14
    call      cc_blockpcl.dx_addrof
    jmp       L6126
L6195:
    mov       %rcx,	%r13
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    mov       %r9,	%r14
    call      cc_blockpcl.dx_dot
    jmp       L6126
L6196:
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	129
    xor       %edx,	%edx
    call      pc_api.pc_gen
    jmp       L6126
L6197:
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	%r12
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	130
    xor       %edx,	%edx
    call      pc_api.pc_gen
    jmp       L6126
L6128:
    movsxd    %rax,	dword ptr[%r13+40]
    lea       %r10,	[%rip+cc_tables.jtagnames]
    mov       %r10,	[%r10 + %rax*8]
    lea       %rcx,	[%rip+L9156]
    mov       %rdx,	%r10
    xor       %r8d,	%r8d
    call      cc_support.gerror_s
L6126:
    mov       [%rip+cc_decls.clineno],	%rdi
L6123:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_const
cc_blockpcl.dx_const:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%rbx+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rdi,	%r10
    mov       %rax,	%rdi
    cmp       %rax,	1
    jl        L6200
    cmp       %rax,	9
    jg        L6200
    mov       %rax,	[%rbx]
    mov       %rcx,	%rax
    call      pc_api.genint
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    jmp       L6199
L6200:
    mov       %rax,	%rdi
    cmp       %rax,	10
    jz        L6202
    cmp       %rax,	11
    jz        L6203
    jmp       L6204
L6202:
    movq      %XMM4,	[%rbx]
    movq      %XMM0,	%XMM4
    mov       %rdx,	1
    call      pc_api.genreal
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    jmp       L6201
L6203:
    movq      %XMM4,	[%rbx]
    movq      %XMM0,	%XMM4
    mov       %rdx,	2
    call      pc_api.genreal
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    jmp       L6201
L6204:
    cmp       %rdi,	10
    jl        L6206
    cmp       %rdi,	11
    jg        L6206
    movq      %XMM4,	[%rbx]
    movq      %XMM0,	%XMM4
    mov       %rdx,	2
    call      pc_api.genreal
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    jmp       L6205
L6206:
    cmp       %rdi,	13
    jnz       L6207
    mov       %al,	[%rbx+61]
    test      %al,	%al
    jz        L6209
    movsxd    %rax,	dword ptr[%rbx+48]
    mov       %r10,	[%rbx]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      pc_api.genstring
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    jmp       L6208
L6209:
    mov       %al,	[%rbx+62]
    test      %al,	%al
    jz        L6210
    lea       %rcx,	[%rip+L9157]
    xor       %edx,	%edx
    call      cc_support.gerror
    jmp       L6208
L6210:
    mov       %rax,	[%rbx]
    mov       %rcx,	%rax
    call      pc_api.genint
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
L6208:
    jmp       L6205
L6207:
    lea       %rcx,	[%rip+L9158]
    xor       %edx,	%edx
    call      cc_support.gerror
L6205:
L6201:
L6199:
    movsxd    %rax,	dword ptr[%rbx+52]
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_name
cc_blockpcl.dx_name:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rdi,	[%rbx]
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	7
    jz        L6213
    cmp       %rax,	8
    jz        L6213
    cmp       %rax,	9
    jnz       L6214
L6213:
    test      %rsi,	%rsi
    jz        L6216
    mov       %rcx,	%rdi
    call      cc_libpcl.genmemaddr_d
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	9
    call      cc_libpcl.setmode
    jmp       L6215
L6216:
    mov       %rcx,	%rdi
    call      cc_libpcl.genmem_d
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	%rbx
    call      cc_blockpcl.widen
L6215:
    jmp       L6212
L6214:
    lea       %rcx,	[%rip+L9159]
    xor       %edx,	%edx
    call      cc_support.gerror
L6212:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_bin
cc_blockpcl.dx_bin:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    call      pc_api.pc_gen
    movsxd    %rax,	dword ptr[%rdi+52]
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_binto
cc_blockpcl.dx_binto:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
    mov       %r12,	%r9
#---------------
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      cc_blockpcl.dx_expr
    test      %r12,	%r12
    jnz       L6220
    mov       %rax,	%rsi
    cmp       %rax,	94
    jz        L6220
    cmp       %rax,	95
    jz        L6220
    call      cc_blockpcl.do_setinplace
L6220:
    test      %r12,	%r12
    jz        L6222
    mov       %rcx,	8
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	10
    mov       %rdx,	2
    mov       %r8,	3
    xor       %r9d,	%r9d
    call      pc_api.pc_genxy
L6222:
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	%rdi
    call      cc_parse.getmemmode
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    test      %r12,	%r12
    jz        L6224
    mov       %rcx,	2
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	%rdi
    call      cc_parse.getmemmode
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
L6224:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.do_assign
cc_blockpcl.do_assign:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      cc_blockpcl.do_fixwiden
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    test      %rsi,	%rsi
    jz        L6227
    mov       %rcx,	9
    xor       %edx,	%edx
    call      pc_api.pc_gen
L6227:
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	3
    jz        L6229
    cmp       %rax,	52
    jz        L6230
    cmp       %rax,	49
    jz        L6231
    jmp       L6232
L6229:
    mov       %rax,	[%rdi]
    mov       %rcx,	%rax
    call      cc_libpcl.genmem_d
    mov       %rcx,	4
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	%rdi
    call      cc_parse.getmemmode
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    jmp       L6228
L6230:
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      cc_blockpcl.dx_expr
    mov       %rcx,	5
    mov       %rdx,	1
    xor       %r8d,	%r8d
    call      pc_api.pc_genix
    mov       %rcx,	%rdi
    call      cc_parse.getmemmode
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    jmp       L6228
L6231:
    mov       %rax,	[%rdi+16]
    mov       %rcx,	%rax
    mov       %rdx,	1
    call      cc_blockpcl.dx_expr
    movsxd    %rax,	dword ptr[%rdi]
    mov       %rcx,	%rax
    call      pc_api.genint
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	9
    call      cc_libpcl.setmode
    mov       %rcx,	57
    mov       %rdx,	1
    xor       %r8d,	%r8d
    call      pc_api.pc_genix
    mov       %rcx,	1
    xor       %edx,	%edx
    call      pc_api.pc_setscaleoff
    mov       %rcx,	%rdi
    call      cc_parse.getmemmode
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    mov       %rcx,	5
    mov       %rdx,	1
    xor       %r8d,	%r8d
    call      pc_api.pc_genix
    mov       %rcx,	1
    xor       %edx,	%edx
    call      pc_api.pc_setscaleoff
    mov       %rcx,	%rdi
    call      cc_parse.getmemmode
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    jmp       L6228
L6232:
    movsxd    %rax,	dword ptr[%rdi+40]
    lea       %r10,	[%rip+cc_tables.jtagnames]
    mov       %r10,	[%r10 + %rax*8]
    lea       %rcx,	[%rip+L9160]
    mov       %rdx,	%r10
    xor       %r8d,	%r8d
    call      cc_support.gerror_s
L6228:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_ptr
cc_blockpcl.dx_ptr:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    test      %rsi,	%rsi
    jnz       L6235
    mov       %rcx,	2
    mov       %rdx,	1
    xor       %r8d,	%r8d
    call      pc_api.pc_genix
    mov       %rcx,	%rdi
    call      cc_blockpcl.widen
L6235:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_addptr
cc_blockpcl.dx_addptr:
#?>>
    .set cc_blockpcl.dx_addptr.am, 80
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
    mov       %r12,	%r9
#---------------
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	%r12
    mov       %rdx,	1
    xor       %r8d,	%r8d
    call      pc_api.pc_genix
    movsxd    %rax,	dword ptr[%rdi]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      pc_api.pc_setscaleoff
    movsxd    %rax,	dword ptr[%rbx+52]
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_addrof
cc_blockpcl.dx_addrof:
#?>>
    .set cc_blockpcl.dx_addrof.p, 24
    .set cc_blockpcl.dx_addrof.am, 40
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rdx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      cc_blockpcl.dx_expr
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_convert
cc_blockpcl.dx_convert:
#?>>
    .set cc_blockpcl.dx_convert.p, 64
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r12,	%rdx
    mov       %r13,	%r8
    mov       %r14,	%r9
#---------------
    movsxd    %rax,	dword ptr[%r12+52]
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rdi
    mov       %rbx,	[%rax + %r10*8]
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%r13
    mov       %rsi,	[%rax + %r10*8]
    mov       %rcx,	%r12
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rax,	%r14
    cmp       %rax,	1
    jz        L6240
    cmp       %rax,	2
    jz        L6241
    cmp       %rax,	3
    jz        L6242
    cmp       %rax,	4
    jz        L6242
    cmp       %rax,	5
    jz        L6243
    cmp       %rax,	6
    jz        L6243
    cmp       %rax,	7
    jz        L6244
    cmp       %rax,	8
    jz        L6244
    cmp       %rax,	9
    jz        L6245
    cmp       %rax,	10
    jz        L6246
    cmp       %rax,	11
    jz        L6247
    cmp       %rax,	12
    jz        L6247
    jmp       L6248
L6240:
    jmp       L6238
L6241:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	10
    jz        L6251
    cmp       %rax,	11
    jnz       L6250
L6251:
    lea       %rcx,	[%rip+L9161]
    xor       %edx,	%edx
    call      cc_support.gerror
L6250:
    cmp       %rsi,	%rbx
    jle       L6253
    mov       %rcx,	114
    xor       %edx,	%edx
    call      pc_api.pc_gen
    jmp       L6252
L6253:
    cmp       %rsi,	%rbx
    jl        L6255
L6254:
L6252:
    jmp       L6239
L6242:
    cmp       %rbx,	%rsi
    jz        L6238
L6257:
    mov       %rcx,	114
    xor       %edx,	%edx
    call      pc_api.pc_gen
    jmp       L6239
L6243:
    mov       %rcx,	111
    xor       %edx,	%edx
    call      pc_api.pc_gen
    jmp       L6239
L6244:
    mov       %rcx,	112
    xor       %edx,	%edx
    call      pc_api.pc_gen
    jmp       L6239
L6245:
    mov       %rcx,	115
    xor       %edx,	%edx
    call      pc_api.pc_gen
    jmp       L6239
L6246:
    mov       %rcx,	116
    xor       %edx,	%edx
    call      pc_api.pc_gen
    jmp       L6239
L6247:
#cc_blockpcl.dx_convert.dotruncate:
L6255:
    mov       %rcx,	113
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	3
    call      cc_libpcl.setmode
    mov       %rcx,	%r13
    call      cc_libpcl.setmode2
    jmp       L6238
L6248:
    lea       %rax,	[%rip+cc_tables.convnames]
    mov       %r10,	%r14
    mov       %rax,	[%rax + %r10*8]
    lea       %rcx,	[%rip+L9162]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      cc_support.gerror_s
L6239:
    mov       %rcx,	%r13
    call      cc_libpcl.setmode
    mov       %rcx,	%rdi
    call      cc_libpcl.setmode2
L6238:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.do_if
cc_blockpcl.do_if:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
    call      cc_libpcl.createfwdlabel
    mov       %rdi,	%rax
    mov       %rcx,	28
    mov       %rdx,	%rsi
    mov       %r8,	%rdi
    call      cc_blockpcl.genjumpcond
    mov       %rcx,	%r12
    call      cc_blockpcl.do_stmt
    test      %r13,	%r13
    jz        L6260
    call      cc_libpcl.createfwdlabel
    mov       %rbx,	%rax
    mov       %rcx,	%rbx
    call      cc_blockpcl.genjumpl
    mov       %rcx,	%rdi
    call      cc_libpcl.definefwdlabel
    mov       %rcx,	%r13
    call      cc_blockpcl.do_stmt
    mov       %rcx,	%rbx
    call      cc_libpcl.definefwdlabel
    jmp       L6259
L6260:
    mov       %rcx,	%rdi
    call      cc_libpcl.definefwdlabel
L6259:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.genjumpcond
cc_blockpcl.genjumpcond:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
#---------------
    mov       %rdi,	[%r13+16]
    mov       %rbx,	[%r13+24]
    movsxd    %rax,	dword ptr[%r13+40]
    sub       %rax,	24
    cmp       %rax,	15
    jae       L6264
    lea       %r10,	[%rip+L6263]
    jmp       [%r10 + %rax*8]
    .data
L6263:
    .quad     L6265
    .quad     L6270
    .quad     L6275
    .quad     L6280
    .quad     L6264
    .quad     L6282
    .quad     L6264
    .quad     L6264
    .quad     L6264
    .quad     L6281
    .quad     L6281
    .quad     L6281
    .quad     L6281
    .quad     L6281
    .quad     L6281
    .text
L6265:
    mov       %rax,	%r12
    cmp       %rax,	28
    jz        L6267
    cmp       %rax,	27
    jz        L6268
    jmp       L6269
L6267:
    mov       %rcx,	28
    mov       %rdx,	%rdi
    mov       %r8,	%r14
    call      cc_blockpcl.genjumpcond
    mov       %rcx,	28
    mov       %rdx,	%rbx
    mov       %r8,	%r14
    call      cc_blockpcl.genjumpcond
    jmp       L6266
L6268:
    call      cc_libpcl.createfwdlabel
    mov       %rsi,	%rax
    mov       %rcx,	28
    mov       %rdx,	%rdi
    mov       %r8,	%rsi
    call      cc_blockpcl.genjumpcond
    mov       %rcx,	27
    mov       %rdx,	%rbx
    mov       %r8,	%r14
    call      cc_blockpcl.genjumpcond
    mov       %rcx,	%rsi
    call      cc_libpcl.definefwdlabel
L6269:
L6266:
    jmp       L6262
L6270:
    mov       %rax,	%r12
    cmp       %rax,	28
    jz        L6272
    cmp       %rax,	27
    jz        L6273
    jmp       L6274
L6272:
    call      cc_libpcl.createfwdlabel
    mov       %rsi,	%rax
    mov       %rcx,	27
    mov       %rdx,	%rdi
    mov       %r8,	%rsi
    call      cc_blockpcl.genjumpcond
    mov       %rcx,	28
    mov       %rdx,	%rbx
    mov       %r8,	%r14
    call      cc_blockpcl.genjumpcond
    mov       %rcx,	%rsi
    call      cc_libpcl.definefwdlabel
    jmp       L6271
L6273:
    mov       %rcx,	27
    mov       %rdx,	%rdi
    mov       %r8,	%r14
    call      cc_blockpcl.genjumpcond
    mov       %rcx,	27
    mov       %rdx,	%rbx
    mov       %r8,	%r14
    call      cc_blockpcl.genjumpcond
L6274:
L6271:
    jmp       L6262
L6275:
    mov       %rax,	%r12
    cmp       %rax,	28
    jz        L6277
    cmp       %rax,	27
    jz        L6278
    jmp       L6279
L6277:
    mov       %rcx,	27
    mov       %rdx,	%rdi
    mov       %r8,	%r14
    call      cc_blockpcl.genjumpcond
    jmp       L6276
L6278:
    mov       %rcx,	28
    mov       %rdx,	%rdi
    mov       %r8,	%r14
    call      cc_blockpcl.genjumpcond
L6279:
L6276:
    jmp       L6262
L6280:
    mov       %rcx,	%r12
    mov       %rdx,	%rdi
    mov       %r8,	%r14
    call      cc_blockpcl.genjumpcond
    jmp       L6262
L6281:
    sub       %rsp,	8
    mov       %rax,	%r14
    push      %rax
    mov       %rcx,	%r12
    mov       %rdx,	%r13
    mov       %r8,	%rdi
    mov       %r9,	%rbx
    sub       %rsp,	32
    call      cc_blockpcl.gcomparejump
    add       %rsp,	48
    jmp       L6262
L6282:
    jmp       L6284
L6283:
    mov       %rcx,	%rdi
    call      cc_blockpcl.do_stmt
    mov       %rdi,	%rbx
L6284:
    test      %rdi,	%rdi
    jz        L6286
    mov       %rax,	[%rdi+8]
    mov       %rbx,	%rax
    test      %rax,	%rax
    jnz       L6283
L6286:
    mov       %rcx,	%r12
    mov       %rdx,	%rdi
    mov       %r8,	%r14
    call      cc_blockpcl.genjumpcond
    jmp       L6262
L6264:
    mov       %rcx,	%r13
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	%r14
    call      pc_api.genlabel
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	%r13
    call      cc_libpcl.setmode_u
L6262:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.gcomparejump
cc_blockpcl.gcomparejump:
#?>>
    .set cc_blockpcl.gcomparejump.lab, 88
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
    mov       %r13,	%r9
#---------------
    movsxd    %rax,	dword ptr[%rsi+40]
    mov       %rcx,	%rax
    call      cc_blockpcl.getpclcond
    mov       %rdi,	%rax
    cmp       %rbx,	28
    jnz       L6289
    mov       %rcx,	%rdi
    call      cc_blockpcl.reversecond
    mov       %rdi,	%rax
L6289:
    mov       %rcx,	%r12
    mov       %rdx,	%r13
    call      cc_blockpcl.do_fixwiden
    mov       %rcx,	%r12
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	%r13
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	[%rbp + cc_blockpcl.gcomparejump.lab]
    call      pc_api.genlabel
    mov       %rcx,	26
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %al,	%dil
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+2],	%al
    mov       %rcx,	%r12
    call      cc_libpcl.setmode_u
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.getpclcond
cc_blockpcl.getpclcond:
#?>>
#?]]
#---------------
    mov       %rax,	%rcx
    cmp       %rax,	33
    jz        L6292
    cmp       %rax,	34
    jz        L6293
    cmp       %rax,	35
    jz        L6294
    cmp       %rax,	36
    jz        L6295
    cmp       %rax,	38
    jz        L6296
    cmp       %rax,	37
    jz        L6297
    jmp       L6298
L6292:
    mov       %rax,	1
    jmp       L6290
L6293:
    mov       %rax,	2
    jmp       L6290
L6294:
    mov       %rax,	3
    jmp       L6290
L6295:
    mov       %rax,	4
    jmp       L6290
L6296:
    mov       %rax,	5
    jmp       L6290
L6297:
    mov       %rax,	6
    jmp       L6290
L6298:
L6291:
    xor       %eax,	%eax
L6290:
#---------------
    ret       
# End 
# Proc cc_blockpcl.reversecond
cc_blockpcl.reversecond:
#?>>
#?]]
#---------------
    mov       %rax,	%rcx
    cmp       %rax,	1
    jz        L6301
    cmp       %rax,	2
    jz        L6302
    cmp       %rax,	3
    jz        L6303
    cmp       %rax,	4
    jz        L6304
    cmp       %rax,	5
    jz        L6305
    cmp       %rax,	6
    jz        L6306
    jmp       L6307
L6301:
    mov       %rax,	2
    mov       %rcx,	%rax
    jmp       L6300
L6302:
    mov       %rax,	1
    mov       %rcx,	%rax
    jmp       L6300
L6303:
    mov       %rax,	5
    mov       %rcx,	%rax
    jmp       L6300
L6304:
    mov       %rax,	6
    mov       %rcx,	%rax
    jmp       L6300
L6305:
    mov       %rax,	3
    mov       %rcx,	%rax
    jmp       L6300
L6306:
    mov       %rax,	4
    mov       %rcx,	%rax
L6307:
L6300:
    mov       %rax,	%rcx
L6299:
#---------------
    ret       
# End 
# Proc cc_blockpcl.genjumpl
cc_blockpcl.genjumpl:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      pc_api.genlabel
    mov       %rcx,	24
    mov       %rdx,	%rax
    call      pc_api.pc_gen
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.do_while
cc_blockpcl.do_while:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r12,	%rcx
    mov       %r13,	%rdx
#---------------
    movsxd    %rax,	dword ptr[%r12+40]
    cmp       %rax,	1
    jnz       L6311
    mov       %rax,	[%r12]
    test      %rax,	%rax
    jz        L6311
    mov       %rcx,	%r13
    call      cc_blockpcl.do_while1
    jmp       L6309
L6311:
    call      cc_libpcl.createfwdlabel
    mov       %rbx,	%rax
    call      cc_libpcl.createfwdlabel
    mov       %rsi,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      cc_blockpcl.stacklooplabels
    mov       %rcx,	%rbx
    call      cc_blockpcl.genjumpl
    call      cc_libpcl.definelabel
    mov       %rdi,	%rax
    mov       %rcx,	%r13
    call      cc_blockpcl.do_stmt
    mov       %rcx,	%rbx
    call      cc_libpcl.definefwdlabel
    mov       %rcx,	27
    mov       %rdx,	%r12
    mov       %r8,	%rdi
    call      cc_blockpcl.genjumpcond
    mov       %rcx,	%rsi
    call      cc_libpcl.definefwdlabel
    dec       qword ptr[%rip+cc_blockpcl.loopindex]
L6309:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.do_while1
cc_blockpcl.do_while1:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
    call      cc_libpcl.createfwdlabel
    mov       %rbx,	%rax
    call      cc_libpcl.createfwdlabel
    mov       %rsi,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      cc_blockpcl.stacklooplabels
    call      cc_libpcl.definelabel
    mov       %rdi,	%rax
    mov       %rcx,	%r12
    call      cc_blockpcl.do_stmt
    mov       %rcx,	%rbx
    call      cc_libpcl.definefwdlabel
    mov       %rcx,	%rdi
    call      cc_blockpcl.genjumpl
    mov       %rcx,	%rsi
    call      cc_libpcl.definefwdlabel
    dec       qword ptr[%rip+cc_blockpcl.loopindex]
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.do_dowhile
cc_blockpcl.do_dowhile:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r12,	%rcx
    mov       %r13,	%rdx
#---------------
    call      cc_libpcl.createfwdlabel
    mov       %rbx,	%rax
    call      cc_libpcl.createfwdlabel
    mov       %rsi,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      cc_blockpcl.stacklooplabels
    call      cc_libpcl.definelabel
    mov       %rdi,	%rax
    mov       %rcx,	%r12
    call      cc_blockpcl.do_stmt
    mov       %rcx,	%rbx
    call      cc_libpcl.definefwdlabel
    mov       %rcx,	%r13
    call      cc_parse.iscondfalse
    test      %rax,	%rax
    jnz       L6315
    mov       %rcx,	27
    mov       %rdx,	%r13
    mov       %r8,	%rdi
    call      cc_blockpcl.genjumpcond
L6315:
    mov       %rcx,	%rsi
    call      cc_libpcl.definefwdlabel
    dec       qword ptr[%rip+cc_blockpcl.loopindex]
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.stacklooplabels
cc_blockpcl.stacklooplabels:
#?>>
#?]]
#---------------
    inc       qword ptr[%rip+cc_blockpcl.loopindex]
    mov       %rax,	[%rip+cc_blockpcl.loopindex]
    mov       %r10,	%rcx
    lea       %r11,	[%rip+cc_blockpcl.continuestack]
    mov       [%r11 + %rax*8-8],	%r10
    mov       %rax,	%rdx
    lea       %r10,	[%rip+cc_blockpcl.breakstack]
    mov       %r11,	[%rip+cc_blockpcl.loopindex]
    mov       [%r10 + %r11*8-8],	%rax
#---------------
    ret       
# End 
# Proc cc_blockpcl.do_return
cc_blockpcl.do_return:
#?>>
    .set cc_blockpcl.do_return.p, 24
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rdx
#---------------
    test      %rdi,	%rdi
    jz        L6319
    mov       %rax,	[%rip+cc_decls.currproc]
    movzx     %rax,	byte ptr[%rax+108]
    shr       %eax,	3
    and       %eax,	1
    test      %rax,	%rax
    jz        L6321
    mov       %al,	[%rip+pepcl.pdcc]
    test      %al,	%al
    jnz       L6321
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	32
    xor       %edx,	%edx
    call      pc_api.pc_gen
    jmp       L6320
L6321:
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	[%rip+cc_genpcl.retindex]
    call      pc_api.genlabel
    mov       %rcx,	29
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	%rdi
    call      cc_libpcl.setmode_u
L6320:
    jmp       L6318
L6319:
    mov       %rcx,	[%rip+cc_genpcl.retindex]
    call      cc_blockpcl.genjumpl
L6318:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_call
cc_blockpcl.dx_call:
#?>>
    .set cc_blockpcl.dx_call.b, 88
    .set cc_blockpcl.dx_call.res, 96
    .set cc_blockpcl.dx_call.retmode, -8
    .set cc_blockpcl.dx_call.m, -16
    .set cc_blockpcl.dx_call.nvariadics, -24
    .set cc_blockpcl.dx_call.nfixedparams, -32
    .set cc_blockpcl.dx_call.isfn, -40
    .set cc_blockpcl.dx_call.paramlist, -296
    .set cc_blockpcl.dx_call.paramconst, -328
    .set cc_blockpcl.dx_call.argattr, -360
    .set cc_blockpcl.dx_call.iparams, -368
    .set cc_blockpcl.dx_call.fparams, -376
    .set cc_blockpcl.dx_call.q, -384
    .set cc_blockpcl.dx_call.i, -392
    .set cc_blockpcl.dx_call.$T1, -400
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	440
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       [%rbp+88],	%r8
    mov       [%rbp+96],	%r9
#---------------
    movsxd    %rax,	dword ptr[%r13+52]
    mov       [%rbp + cc_blockpcl.dx_call.retmode],	%rax
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.retmode]
    test      %rax,	%rax
    jnz       L6324
    mov       %rax,	3
    mov       [%rbp + cc_blockpcl.dx_call.retmode],	%rax
L6324:
    xor       %eax,	%eax
    mov       [%rbp + cc_blockpcl.dx_call.isfn],	%rax
    movsxd    %rax,	dword ptr[%r14+40]
    cmp       %rax,	52
    jnz       L6327
L6326:
    movsxd    %rax,	dword ptr[%r14+52]
    mov       [%rbp + cc_blockpcl.dx_call.m],	%rax
    jmp       L6329
L6328:
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	[%rbp + cc_blockpcl.dx_call.m]
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       [%rbp + cc_blockpcl.dx_call.m],	%rax
L6329:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	[%rbp + cc_blockpcl.dx_call.m]
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	13
    jz        L6328
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	[%rbp + cc_blockpcl.dx_call.m]
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	0
    setnz     %al
    movzx     %eax,	%al
    mov       [%rbp + cc_blockpcl.dx_call.isfn],	%rax
    lea       %rax,	[%rip+cc_decls.ttparams]
    mov       %r10,	[%rbp + cc_blockpcl.dx_call.m]
    mov       %rdi,	[%rax + %r10*8]
    mov       %rbx,	1
    jmp       L6325
L6327:
    mov       %rax,	[%r14]
    mov       %rdi,	[%rax+80]
    xor       %rbx,	%rbx
    mov       %rax,	[%r14]
    movzx     %rax,	word ptr[%rax+102]
    cmp       %rax,	0
    setnz     %al
    movzx     %eax,	%al
    mov       [%rbp + cc_blockpcl.dx_call.isfn],	%rax
L6325:
    movsx     %rax,	word ptr[%rdi+22]
    cmp       %rax,	3
    setz      %al
    movzx     %eax,	%al
    mov       %rsi,	%rax
    movsx     %rax,	word ptr[%rdi+20]
    mov       [%rbp + cc_blockpcl.dx_call.nfixedparams],	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_blockpcl.dx_call.nvariadics],	%rax
    mov       %r12,	%rax
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.b]
    mov       [%rbp + cc_blockpcl.dx_call.q],	%rax
    jmp       L6334
L6331:
    cmp       %r12,	32
    jl        L6336
    lea       %rcx,	[%rip+L9163]
    xor       %edx,	%edx
    call      cc_support.gerror
L6336:
    inc       %r12
    mov       %rax,	%r12
    mov       %r10,	[%rbp + cc_blockpcl.dx_call.q]
    mov       [%rbp + %rax*8 + cc_blockpcl.dx_call.paramlist-8],	%r10
    xor       %eax,	%eax
    mov       [%rbp + %r12 + cc_blockpcl.dx_call.paramconst-1],	%al
    test      %rsi,	%rsi
    jz        L6338
    cmp       %r12,	[%rbp + cc_blockpcl.dx_call.nfixedparams]
    jle       L6338
    cmp       %r12,	4
    jg        L6338
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.nvariadics]
    test      %rax,	%rax
    jnz       L6338
    mov       [%rbp + cc_blockpcl.dx_call.nvariadics],	%r12
L6338:
    cmp       %r12,	[%rbp + cc_blockpcl.dx_call.nfixedparams]
    jg        L6340
    movsxd    %rax,	dword ptr[%rdi+16]
    lea       %r10,	[%rip+cc_decls.ttconst]
    mov       %r10b,	[%r10 + %rax]
    mov       [%rbp + %r12 + cc_blockpcl.dx_call.paramconst-1],	%r10b
    mov       %rdi,	[%rdi+8]
L6340:
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.q]
    mov       %rax,	[%rax+8]
    mov       [%rbp + cc_blockpcl.dx_call.q],	%rax
L6334:
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.q]
    test      %rax,	%rax
    jnz       L6331
    mov       %rcx,	131
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	%r13
    call      cc_libpcl.setmode_u
    mov       %eax,	%r12d
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+16],	%eax
    xor       %eax,	%eax
    mov       [%rbp + cc_blockpcl.dx_call.fparams],	%rax
    mov       [%rbp + cc_blockpcl.dx_call.iparams],	%rax
    mov       %rax,	1
    mov       [%rbp + cc_blockpcl.dx_call.i],	%rax
    cmp       %r12,	1
    jl        L6343
L6341:
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.i]
    mov       %rax,	[%rbp + %rax*8 + cc_blockpcl.dx_call.paramlist-8]
    mov       [%rbp + cc_blockpcl.dx_call.q],	%rax
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.q]
    movsxd    %rax,	dword ptr[%rax+52]
    cmp       %rax,	10
    jz        L6346
    cmp       %rax,	11
    jnz       L6345
L6346:
    inc       qword ptr[%rbp + cc_blockpcl.dx_call.fparams]
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.fparams]
    neg       %rax
    mov       %r10,	[%rbp + cc_blockpcl.dx_call.i]
    mov       [%rbp + %r10 + cc_blockpcl.dx_call.argattr-1],	%al
    jmp       L6344
L6345:
    inc       qword ptr[%rbp + cc_blockpcl.dx_call.iparams]
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.iparams]
    mov       %r10,	[%rbp + cc_blockpcl.dx_call.i]
    mov       [%rbp + %r10 + cc_blockpcl.dx_call.argattr-1],	%al
L6344:
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.i]
    inc       %rax
    mov       [%rbp + cc_blockpcl.dx_call.i],	%rax
    cmp       %rax,	%r12
    jle       L6341
L6343:
    mov       [%rbp + cc_blockpcl.dx_call.i],	%r12
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.i]
    cmp       %rax,	1
    jl        L6349
L6347:
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.i]
    mov       %rax,	[%rbp + %rax*8 + cc_blockpcl.dx_call.paramlist-8]
    mov       [%rbp + cc_blockpcl.dx_call.q],	%rax
    mov       %rcx,	[%rbp + cc_blockpcl.dx_call.q]
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.nvariadics]
    test      %rax,	%rax
    jz        L6351
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.i]
    cmp       %rax,	[%rbp + cc_blockpcl.dx_call.nvariadics]
    jl        L6351
    mov       %rax,	[%rip+pc_api.pccurr]
    movzx     %rax,	byte ptr[%rax+3]
    cmp       %rax,	1
    jnz       L6351
    mov       %rcx,	115
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %al,	2
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+3],	%al
    mov       %rax,	[%rip+pc_api.pccurr]
    lea       %rax,	[%rax+28]
    mov       %r10d,	1
    mov       %r15d,	[%rax]
    mov       %r11,	-256
    and       %r15d,	%r11d
    or        %r15d,	%r10d
    mov       [%rax],	%r15d
L6351:
    mov       %rcx,	132
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	[%rbp + cc_blockpcl.dx_call.q]
    call      cc_libpcl.setmode_u
    mov       %eax,	[%rbp + cc_blockpcl.dx_call.i]
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+16],	%eax
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.i]
    movsx     %rax,	byte ptr[%rbp + %rax + cc_blockpcl.dx_call.argattr-1]
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+20],	%eax
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.i]
    dec       %rax
    mov       [%rbp + cc_blockpcl.dx_call.i],	%rax
    cmp       %rax,	1
    jge       L6347
L6349:
    test      %rbx,	%rbx
    jnz       L6353
    mov       %rax,	[%r14]
    mov       %rcx,	%rax
    call      cc_libpcl.genmemaddr_d
    mov       [%rbp + cc_blockpcl.dx_call.$T1],	%rax
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.isfn]
    test      %rax,	%rax
    jz        L6355
    mov       %rax,	21
    jmp       L6354
L6355:
    mov       %rax,	18
L6354:
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + cc_blockpcl.dx_call.$T1]
    call      pc_api.pc_gen
    jmp       L6352
L6353:
    mov       %rax,	[%r14+16]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.isfn]
    test      %rax,	%rax
    jz        L6357
    mov       %rax,	22
    jmp       L6356
L6357:
    mov       %rax,	19
L6356:
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      pc_api.pc_gen
L6352:
    mov       %eax,	%r12d
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+16],	%eax
    mov       %eax,	[%rbp + cc_blockpcl.dx_call.nvariadics]
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+20],	%eax
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.isfn]
    test      %rax,	%rax
    jz        L6359
    mov       %rcx,	%r13
    call      cc_parse.getmemmode
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.res]
    test      %rax,	%rax
    jnz       L6361
    mov       %rcx,	11
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	%r13
    call      cc_parse.getmemmode
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    jmp       L6360
L6361:
    mov       %rcx,	%r13
    call      cc_blockpcl.widen
L6360:
L6359:
#---------------
    add       %rsp,	440
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.do_decl
cc_blockpcl.do_decl:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rdi,	[%rbx+72]
    mov       %al,	1
    mov       [%rbx+122],	%al
    mov       %rax,	[%rbx+56]
    test      %rax,	%rax
    jz        L6364
    mov       %rax,	[%rbx+56]
    mov       %r10b,	1
    mov       [%rax+92],	%r10b
L6364:
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	28
    jz        L6366
    movzx     %rax,	word ptr[%rbx+102]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    cmp       %r10,	17
    jnz       L6368
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	1
    jz        L6369
L6368:
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	%rbx
    call      cc_libpcl.genmem_d
    mov       %rcx,	4
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    movsxd    %rax,	dword ptr[%rdi+52]
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    jmp       L6362
L6366:
#cc_blockpcl.do_decl.copyl:
L6369:
    mov       %rax,	[%rbx+114]
    mov       %rcx,	%rax
    call      pc_api.genmem
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    movzx     %rax,	word ptr[%rbx+102]
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    mov       %rcx,	%rbx
    call      cc_libpcl.genmem_d
    mov       %rcx,	4
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    movzx     %rax,	word ptr[%rbx+102]
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
L6362:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.do_for
cc_blockpcl.do_for:
#?>>
    .set cc_blockpcl.do_for.pbody, 80
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %r15,	%rcx
    mov       [%rbp+80],	%rdx
#---------------
    mov       %rdi,	[%r15+8]
    mov       %rbx,	[%rdi+8]
    call      cc_libpcl.createfwdlabel
    mov       %r12,	%rax
    call      cc_libpcl.createfwdlabel
    mov       %r13,	%rax
    call      cc_libpcl.createfwdlabel
    mov       %r14,	%rax
    movsxd    %rax,	dword ptr[%r15+40]
    cmp       %rax,	2
    jz        L6372
    mov       %rcx,	%r15
    call      cc_blockpcl.do_stmt
L6372:
    mov       %rcx,	%r14
    call      cc_blockpcl.genjumpl
    mov       %rcx,	%r12
    mov       %rdx,	%r13
    call      cc_blockpcl.stacklooplabels
    call      cc_libpcl.definelabel
    mov       %rsi,	%rax
    mov       %rcx,	[%rbp + cc_blockpcl.do_for.pbody]
    call      cc_blockpcl.do_stmt
    mov       %rcx,	%r12
    call      cc_libpcl.definefwdlabel
    mov       %rcx,	%rbx
    call      cc_blockpcl.do_stmt
    mov       %rcx,	%r14
    call      cc_libpcl.definefwdlabel
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	2
    jz        L6374
    mov       %rcx,	27
    mov       %rdx,	%rdi
    mov       %r8,	%rsi
    call      cc_blockpcl.genjumpcond
    jmp       L6373
L6374:
    mov       %rcx,	%rsi
    call      cc_blockpcl.genjumpl
L6373:
    mov       %rcx,	%r13
    call      cc_libpcl.definefwdlabel
    dec       qword ptr[%rip+cc_blockpcl.loopindex]
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.do_preincr
cc_blockpcl.do_preincr:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      cc_blockpcl.dx_expr
    call      cc_blockpcl.do_setinplace
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	%rdi
    call      cc_parse.getmemmode
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    movsxd    %rax,	dword ptr[%rdi+52]
    mov       %rcx,	%rax
    call      cc_blockpcl.setincrstep
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.setincrstep
cc_blockpcl.setincrstep:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	1
    call      pc_api.pc_setincr
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%rdi
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L6378
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      pc_api.pc_setincr
L6378:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_preincrx
cc_blockpcl.dx_preincrx:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      cc_blockpcl.dx_expr
    call      cc_blockpcl.do_setinplace
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	71
    jnz       L6381
    mov       %rax,	86
    jmp       L6380
L6381:
    mov       %rax,	87
L6380:
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      pc_api.pc_gen
    movsxd    %rax,	dword ptr[%rbx+52]
    mov       %rcx,	%rax
    call      cc_blockpcl.setincrstep
    mov       %rcx,	%rbx
    call      cc_blockpcl.widen
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_postincrx
cc_blockpcl.dx_postincrx:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      cc_blockpcl.dx_expr
    call      cc_blockpcl.do_setinplace
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	73
    jnz       L6384
    mov       %rax,	88
    jmp       L6383
L6384:
    mov       %rax,	89
L6383:
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      pc_api.pc_gen
    movsxd    %rax,	dword ptr[%rbx+52]
    mov       %rcx,	%rax
    call      cc_blockpcl.setincrstep
    mov       %rcx,	%rbx
    call      cc_blockpcl.widen
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_dot
cc_blockpcl.dx_dot:
#?>>
    .set cc_blockpcl.dx_dot.b, 56
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r9
#---------------
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      cc_blockpcl.dx_expr
    movsxd    %rax,	dword ptr[%rdi]
    mov       %rcx,	%rax
    call      pc_api.genint
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	9
    call      cc_libpcl.setmode
    test      %rsi,	%rsi
    jnz       L6387
    mov       %rcx,	57
    mov       %rdx,	1
    xor       %r8d,	%r8d
    call      pc_api.pc_genix
    mov       %rcx,	%rdi
    call      cc_parse.getmemmode
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    mov       %rcx,	1
    xor       %edx,	%edx
    call      pc_api.pc_setscaleoff
    mov       %rcx,	2
    mov       %rdx,	1
    xor       %r8d,	%r8d
    call      pc_api.pc_genix
    mov       %rcx,	%rdi
    call      cc_blockpcl.widen
    jmp       L6386
L6387:
    mov       %rcx,	57
    mov       %rdx,	1
    xor       %r8d,	%r8d
    call      pc_api.pc_genix
    mov       %rcx,	%rdi
    call      cc_parse.getmemmode
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    mov       %rcx,	1
    xor       %edx,	%edx
    call      pc_api.pc_setscaleoff
L6386:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_eq
cc_blockpcl.dx_eq:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      cc_blockpcl.do_fixwiden
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	31
    xor       %edx,	%edx
    call      pc_api.pc_gen
    movsxd    %rax,	dword ptr[%rdi+40]
    mov       %rcx,	%rax
    call      cc_blockpcl.getpclcond
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+2],	%al
    mov       %rcx,	%rbx
    call      cc_libpcl.setmode_u
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.do_labeldef
cc_blockpcl.do_labeldef:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%rdi+88]
    cmp       %rax,	0
    jg        L6391
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rax,	[%rip+pc_api.mlabelno]
    mov       [%rdi+88],	%eax
L6391:
    mov       %rcx,	[%rdi]
    call      pc_api.gencomment
    movsxd    %rax,	dword ptr[%rdi+88]
    mov       %rcx,	%rax
    call      pc_api.genlabel
    mov       %rcx,	127
    mov       %rdx,	%rax
    call      pc_api.pc_gen
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.do_goto
cc_blockpcl.do_goto:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%rdi+88]
    test      %rax,	%rax
    jnz       L6394
    mov       %rax,	[%rdi]
    lea       %rcx,	[%rip+L9164]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      cc_support.gerror_s
    jmp       L6393
L6394:
    movsxd    %rax,	dword ptr[%rdi+88]
    cmp       %rax,	0
    jge       L6395
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rax,	[%rip+pc_api.mlabelno]
    mov       [%rdi+88],	%eax
L6395:
L6393:
    movsxd    %rax,	dword ptr[%rdi+88]
    mov       %rcx,	%rax
    call      pc_api.genlabel
    mov       %rcx,	24
    mov       %rdx,	%rax
    call      pc_api.pc_gen
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_ifx
cc_blockpcl.dx_ifx:
#?>>
    .set cc_blockpcl.dx_ifx.c, 88
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	32
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
    mov       [%rbp+88],	%r9
#---------------
    movsxd    %rax,	dword ptr[%r12+52]
    cmp       %rax,	0
    setnz     %al
    movzx     %eax,	%al
    mov       %rsi,	%rax
    call      cc_libpcl.createfwdlabel
    mov       %rdi,	%rax
    call      cc_libpcl.createfwdlabel
    mov       %rbx,	%rax
    test      %rsi,	%rsi
    jz        L6398
    mov       %rcx,	117
    xor       %edx,	%edx
    call      pc_api.pc_gen
L6398:
    mov       %rcx,	28
    mov       %rdx,	%r13
    mov       %r8,	%rdi
    call      cc_blockpcl.genjumpcond
    mov       %rcx,	%r14
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    test      %rsi,	%rsi
    jz        L6400
    mov       %rcx,	118
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	%r12
    call      cc_libpcl.setmode_u
L6400:
    mov       %rcx,	%rbx
    call      cc_blockpcl.genjumpl
    mov       %rcx,	%rdi
    call      cc_libpcl.definefwdlabel
    mov       %rcx,	[%rbp + cc_blockpcl.dx_ifx.c]
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    test      %rsi,	%rsi
    jz        L6402
    mov       %rcx,	119
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	%r12
    call      cc_libpcl.setmode_u
L6402:
    mov       %rcx,	%rbx
    call      cc_libpcl.definefwdlabel
#---------------
    add       %rsp,	32
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.do_casestmt
cc_blockpcl.do_casestmt:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    mov       %rax,	[%rip+cc_blockpcl.sw_ncases]
    test      %rax,	%rax
    jnz       L6405
    mov       %rax,	[%rsi]
    sub       %rax,	[%rip+cc_blockpcl.sw_lower]
    mov       %r10,	[%rip+cc_blockpcl.sw_labeltable]
    movsxd    %r10,	dword ptr[%r10 + %rax*4]
    mov       %rcx,	%r10
    call      pc_api.genlabel
    mov       %rcx,	127
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    jmp       L6404
L6405:
    mov       %rdi,	[%rsi]
    mov       %rbx,	1
    mov       %rax,	[%rip+cc_blockpcl.sw_ncases]
    cmp       %rax,	1
    jl        L6409
L6406:
    mov       %rax,	[%rip+cc_blockpcl.sw_valuetable]
    mov       %r10,	%rbx
    movsxd    %rax,	dword ptr[%rax + %r10*4-4]
    cmp       %rax,	%rdi
    jnz       L6411
    mov       %rax,	[%rip+cc_blockpcl.sw_labeltable]
    mov       %r10,	%rbx
    movsxd    %rax,	dword ptr[%rax + %r10*4-4]
    mov       %rcx,	%rax
    call      pc_api.genlabel
    mov       %rcx,	127
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    jmp       L6408
L6411:
    inc       %rbx
    cmp       %rbx,	[%rip+cc_blockpcl.sw_ncases]
    jle       L6406
L6409:
    lea       %rcx,	[%rip+L9165]
    xor       %edx,	%edx
    call      cc_support.gerror
L6408:
L6404:
    mov       %rcx,	%r12
    call      cc_blockpcl.do_stmt
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.do_switch
cc_blockpcl.do_switch:
#?>>
    .set cc_blockpcl.do_switch.a, 80
    .set cc_blockpcl.do_switch.b, 88
    .set cc_blockpcl.do_switch.labeltable, -2000
    .set cc_blockpcl.do_switch.valuetable, -4000
    .set cc_blockpcl.do_switch.flags, -4504
    .set cc_blockpcl.do_switch.value, -4512
    .set cc_blockpcl.do_switch.ncases, -4520
    .set cc_blockpcl.do_switch.serialsw, -4528
    .set cc_blockpcl.do_switch.i, -4536
    .set cc_blockpcl.do_switch.index, -4544
    .set cc_blockpcl.do_switch.pcase, -4552
    .set cc_blockpcl.do_switch.old_labeltable, -4560
    .set cc_blockpcl.do_switch.old_valuetable, -4568
    .set cc_blockpcl.do_switch.old_ncases, -4576
    .set cc_blockpcl.do_switch.old_lower, -4584
    .set cc_blockpcl.do_switch.old_defaultseen, -4592
    .set cc_blockpcl.do_switch.old_defaultlabel, -4600
    .set cc_blockpcl.do_switch.old_breaklabel, -4608
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	4648
    mov       %r15,	%rcx
    mov       [%rbp+80],	%rdx
    mov       [%rbp+88],	%r8
#---------------
    mov       %rax,	[%r15]
    mov       [%rbp + cc_blockpcl.do_switch.pcase],	%rax
    xor       %eax,	%eax
    mov       %r14,	%rax
    mov       [%rbp + cc_blockpcl.do_switch.ncases],	%rax
    jmp       L6414
L6413:
    inc       qword ptr[%rbp + cc_blockpcl.do_switch.ncases]
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.ncases]
    cmp       %rax,	500
    jle       L6417
    lea       %rcx,	[%rip+L9166]
    xor       %edx,	%edx
    call      cc_support.gerror
L6417:
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.pcase]
    mov       %rax,	[%rax+8]
    mov       [%rbp + cc_blockpcl.do_switch.value],	%rax
    mov       %r10,	[%rbp + cc_blockpcl.do_switch.ncases]
    mov       [%rbp + %r10*4 + cc_blockpcl.do_switch.valuetable-4],	%eax
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.ncases]
    cmp       %rax,	1
    jnz       L6419
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.value]
    mov       %r13,	%rax
    mov       %r12,	%rax
    jmp       L6418
L6419:
    mov       %rax,	%r12
    mov       %r10,	[%rbp + cc_blockpcl.do_switch.value]
    cmp       %rax,	%r10
    cmovg     %rax,	%r10
    mov       %r12,	%rax
    mov       %rax,	%r13
    mov       %r10,	[%rbp + cc_blockpcl.do_switch.value]
    cmp       %rax,	%r10
    cmovl     %rax,	%r10
    mov       %r13,	%rax
L6418:
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.pcase]
    mov       %rax,	[%rax]
    mov       [%rbp + cc_blockpcl.do_switch.pcase],	%rax
L6414:
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.pcase]
    test      %rax,	%rax
    jnz       L6413
    mov       %rax,	[%r15]
    test      %rax,	%rax
    jz        L6421
    mov       %rax,	%r13
    sub       %rax,	%r12
    inc       %rax
    mov       %r14,	%rax
    jmp       L6420
L6421:
    xor       %r14,	%r14
L6420:
    call      cc_libpcl.createfwdlabel
    mov       %rdi,	%rax
    call      cc_libpcl.createfwdlabel
    mov       %rbx,	%rax
    cmp       %r14,	500
    jg        L6424
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.ncases]
    cmp       %rax,	8
    jg        L6423
L6424:
    mov       %al,	1
    mov       [%rbp + cc_blockpcl.do_switch.serialsw],	%al
    mov       %rcx,	[%rbp + cc_blockpcl.do_switch.a]
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rax,	1
    mov       [%rbp + cc_blockpcl.do_switch.i],	%rax
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.ncases]
    cmp       %rax,	1
    jl        L6427
L6425:
    call      cc_libpcl.createfwdlabel
    mov       %r10,	[%rbp + cc_blockpcl.do_switch.i]
    mov       [%rbp + %r10*4 + cc_blockpcl.do_switch.labeltable-4],	%eax
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.i]
    movsxd    %rax,	dword ptr[%rbp + %rax*4 + cc_blockpcl.do_switch.valuetable-4]
    mov       %rcx,	%rax
    call      pc_api.genint
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	3
    call      cc_libpcl.setmode
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.i]
    movsxd    %rax,	dword ptr[%rbp + %rax*4 + cc_blockpcl.do_switch.labeltable-4]
    mov       %rcx,	%rax
    call      pc_api.genlabel
    mov       %rcx,	26
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	3
    call      cc_libpcl.setmode
    mov       %al,	1
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+2],	%al
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.i]
    cmp       %rax,	[%rbp + cc_blockpcl.do_switch.ncases]
    jge       L6429
    mov       %eax,	1
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+16],	%eax
L6429:
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.i]
    inc       %rax
    mov       [%rbp + cc_blockpcl.do_switch.i],	%rax
    cmp       %rax,	[%rbp + cc_blockpcl.do_switch.ncases]
    jle       L6425
L6427:
    mov       %rcx,	%rdi
    call      cc_blockpcl.genjumpl
    jmp       L6422
L6423:
    test      %r14,	%r14
    jnz       L6430
    mov       %rcx,	%rdi
    call      cc_blockpcl.genjumpl
    jmp       L6422
L6430:
    xor       %eax,	%eax
    mov       [%rbp + cc_blockpcl.do_switch.serialsw],	%al
    lea       %rcx,	[%rbp + cc_blockpcl.do_switch.flags]
    xor       %edx,	%edx
    mov       %r8,	%r14
    call      memset
    mov       %rax,	1
    mov       [%rbp + cc_blockpcl.do_switch.i],	%rax
    cmp       %r14,	1
    jl        L6433
L6431:
    mov       %eax,	%edi
    mov       %r10,	[%rbp + cc_blockpcl.do_switch.i]
    mov       [%rbp + %r10*4 + cc_blockpcl.do_switch.labeltable-4],	%eax
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.i]
    inc       %rax
    mov       [%rbp + cc_blockpcl.do_switch.i],	%rax
    cmp       %rax,	%r14
    jle       L6431
L6433:
    mov       %rax,	1
    mov       [%rbp + cc_blockpcl.do_switch.i],	%rax
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.ncases]
    cmp       %rax,	1
    jl        L6436
L6434:
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.i]
    movsxd    %rax,	dword ptr[%rbp + %rax*4 + cc_blockpcl.do_switch.valuetable-4]
    mov       [%rbp + cc_blockpcl.do_switch.value],	%rax
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.value]
    sub       %rax,	%r12
    inc       %rax
    mov       [%rbp + cc_blockpcl.do_switch.index],	%rax
    call      cc_libpcl.createfwdlabel
    mov       %r10,	[%rbp + cc_blockpcl.do_switch.index]
    mov       [%rbp + %r10*4 + cc_blockpcl.do_switch.labeltable-4],	%eax
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.index]
    mov       %al,	[%rbp + %rax + cc_blockpcl.do_switch.flags-1]
    test      %al,	%al
    jz        L6438
    mov       %rcx,	[%rbp + cc_blockpcl.do_switch.value]
    xor       %edx,	%edx
    call      msys.strint
    lea       %rcx,	[%rip+L9167]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      cc_support.gerror_s
L6438:
    mov       %al,	1
    mov       %r10,	[%rbp + cc_blockpcl.do_switch.index]
    mov       [%rbp + %r10 + cc_blockpcl.do_switch.flags-1],	%al
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.i]
    inc       %rax
    mov       [%rbp + cc_blockpcl.do_switch.i],	%rax
    cmp       %rax,	[%rbp + cc_blockpcl.do_switch.ncases]
    jle       L6434
L6436:
    call      cc_libpcl.createfwdlabel
    mov       %rsi,	%rax
    mov       %rcx,	[%rbp + cc_blockpcl.do_switch.a]
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	%rsi
    call      pc_api.genlabel
    mov       %rcx,	37
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	3
    call      cc_libpcl.setmode
    mov       %rax,	%r12
    add       %rax,	%r14
    dec       %rax
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      pc_api.pc_setxy
    mov       %rcx,	%rdi
    call      pc_api.genlabel
    mov       %rcx,	12
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	3
    call      cc_libpcl.setmode
    mov       %rcx,	%rsi
    call      cc_libpcl.definefwdlabel
    mov       %rax,	1
    mov       [%rbp + cc_blockpcl.do_switch.i],	%rax
    cmp       %r14,	1
    jl        L6441
L6439:
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.i]
    movsxd    %rax,	dword ptr[%rbp + %rax*4 + cc_blockpcl.do_switch.labeltable-4]
    mov       %rcx,	%rax
    call      pc_api.genlabel
    mov       %rcx,	39
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.i]
    inc       %rax
    mov       [%rbp + cc_blockpcl.do_switch.i],	%rax
    cmp       %rax,	%r14
    jle       L6439
L6441:
    mov       %rcx,	40
    xor       %edx,	%edx
    call      pc_api.pc_gen
L6422:
    mov       %rax,	[%rip+cc_blockpcl.sw_labeltable]
    mov       [%rbp + cc_blockpcl.do_switch.old_labeltable],	%rax
    mov       %rax,	[%rip+cc_blockpcl.sw_valuetable]
    mov       [%rbp + cc_blockpcl.do_switch.old_valuetable],	%rax
    mov       %rax,	[%rip+cc_blockpcl.sw_lower]
    mov       [%rbp + cc_blockpcl.do_switch.old_lower],	%rax
    mov       %rax,	[%rip+cc_blockpcl.sw_ncases]
    mov       [%rbp + cc_blockpcl.do_switch.old_ncases],	%rax
    mov       %al,	[%rip+cc_blockpcl.sw_defaultseen]
    mov       [%rbp + cc_blockpcl.do_switch.old_defaultseen],	%al
    mov       %rax,	[%rip+cc_blockpcl.sw_defaultlabel]
    mov       [%rbp + cc_blockpcl.do_switch.old_defaultlabel],	%rax
    mov       %rax,	[%rip+cc_blockpcl.sw_breaklabel]
    mov       [%rbp + cc_blockpcl.do_switch.old_breaklabel],	%rax
    lea       %rax,	[%rbp + cc_blockpcl.do_switch.labeltable]
    mov       [%rip+cc_blockpcl.sw_labeltable],	%rax
    lea       %rax,	[%rbp + cc_blockpcl.do_switch.valuetable]
    mov       [%rip+cc_blockpcl.sw_valuetable],	%rax
    mov       [%rip+cc_blockpcl.sw_lower],	%r12
    mov       %al,	[%rbp + cc_blockpcl.do_switch.serialsw]
    test      %al,	%al
    jz        L6443
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.ncases]
    jmp       L6442
L6443:
    xor       %eax,	%eax
L6442:
    mov       [%rip+cc_blockpcl.sw_ncases],	%rax
    xor       %eax,	%eax
    mov       [%rip+cc_blockpcl.sw_defaultseen],	%al
    mov       [%rip+cc_blockpcl.sw_defaultlabel],	%rdi
    mov       [%rip+cc_blockpcl.sw_breaklabel],	%rbx
    mov       %rcx,	[%rbp + cc_blockpcl.do_switch.b]
    call      cc_blockpcl.do_stmt
    mov       %al,	[%rip+cc_blockpcl.sw_defaultseen]
    test      %al,	%al
    jnz       L6445
    mov       %rcx,	%rdi
    call      cc_libpcl.definefwdlabel
L6445:
    mov       %rcx,	%rbx
    call      cc_libpcl.definefwdlabel
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.old_labeltable]
    mov       [%rip+cc_blockpcl.sw_labeltable],	%rax
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.old_valuetable]
    mov       [%rip+cc_blockpcl.sw_valuetable],	%rax
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.old_lower]
    mov       [%rip+cc_blockpcl.sw_lower],	%rax
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.old_ncases]
    mov       [%rip+cc_blockpcl.sw_ncases],	%rax
    mov       %al,	[%rbp + cc_blockpcl.do_switch.old_defaultseen]
    mov       [%rip+cc_blockpcl.sw_defaultseen],	%al
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.old_defaultlabel]
    mov       [%rip+cc_blockpcl.sw_defaultlabel],	%rax
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.old_breaklabel]
    mov       [%rip+cc_blockpcl.sw_breaklabel],	%rax
#---------------
    add       %rsp,	4648
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_andorl
cc_blockpcl.dx_andorl:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    call      cc_libpcl.createfwdlabel
    mov       %rdi,	%rax
    mov       %rcx,	117
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	28
    mov       %rdx,	%rsi
    mov       %r8,	%rdi
    call      cc_blockpcl.genjumpcond
    call      cc_libpcl.createfwdlabel
    mov       %rbx,	%rax
    mov       %rcx,	1
    call      pc_api.genint
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	3
    call      cc_libpcl.setmode
    mov       %rcx,	118
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	[%rsi+16]
    call      cc_libpcl.setmode_u
    mov       %rcx,	%rbx
    call      cc_blockpcl.genjumpl
    mov       %rcx,	%rdi
    call      cc_libpcl.definefwdlabel
    xor       %ecx,	%ecx
    call      pc_api.genint
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	3
    call      cc_libpcl.setmode
    mov       %rcx,	119
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	[%rsi+16]
    call      cc_libpcl.setmode_u
    mov       %rcx,	%rbx
    call      cc_libpcl.definefwdlabel
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_scale
cc_blockpcl.dx_scale:
#?>>
    .set cc_blockpcl.dx_scale.b, 56
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    movsxd    %rax,	dword ptr[%rbx+48]
    mov       %rdi,	%rax
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    movsxd    %rax,	dword ptr[%rbx+48]
    cmp       %rax,	0
    jl        L6449
    movsxd    %rax,	dword ptr[%rbx+48]
    mov       %rcx,	%rax
    call      pc_api.genint
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	4
    call      cc_libpcl.setmode
    mov       %rcx,	45
    xor       %edx,	%edx
    call      pc_api.pc_gen
    jmp       L6448
L6449:
    movsxd    %rax,	dword ptr[%rbx+48]
    neg       %rax
    mov       %rcx,	%rax
    call      pc_api.genint
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	4
    call      cc_libpcl.setmode
    mov       %rcx,	47
    xor       %edx,	%edx
    call      pc_api.pc_gen
L6448:
    mov       %rcx,	%rsi
    call      cc_libpcl.setmode_u
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.widen
cc_blockpcl.widen:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    movsx     %rax,	word ptr[%rbx+56]
    test      %rax,	%rax
    jnz       L6452
    movsxd    %rax,	dword ptr[%rbx+52]
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    jmp       L6450
L6452:
    mov       %rcx,	%rbx
    call      cc_parse.getmemmode
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    call      cc_libpcl.setmode
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    cmp       %rax,	4
    jge       L6454
    mov       %rax,	[%rip+pc_api.pccurr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	1
    jz        L6455
    cmp       %rax,	2
    jz        L6455
    cmp       %rax,	3
    jz        L6455
    cmp       %rax,	86
    jz        L6455
    cmp       %rax,	87
    jz        L6455
    cmp       %rax,	88
    jz        L6455
    cmp       %rax,	89
    jz        L6455
    cmp       %rax,	21
    jnz       L6454
L6455:
    mov       %rcx,	114
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rax,	%rdi
    cmp       %rax,	1
    jz        L6458
    cmp       %rax,	2
    jnz       L6457
L6458:
    mov       %rax,	3
    jmp       L6456
L6457:
    mov       %rax,	8
L6456:
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    mov       %rcx,	%rdi
    call      cc_libpcl.setmode2
L6454:
L6450:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.do_setinplace
cc_blockpcl.do_setinplace:
#?>>
#?]]
#---------------
    mov       %rax,	[%rip+pc_api.pccurr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	1
    jnz       L6461
    mov       %rax,	[%rip+pc_api.pccurr]
    movzx     %rax,	byte ptr[%rax+1]
    cmp       %rax,	2
    jnz       L6461
    mov       %eax,	1
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+16],	%eax
L6461:
#---------------
    ret       
# End 
# Proc cc_blockpcl.do_fixwiden
cc_blockpcl.do_fixwiden:
#?>>
    .set cc_blockpcl.do_fixwiden.a, 16
    .set cc_blockpcl.do_fixwiden.b, 24
#?]]
#---------------
L6462:
#---------------
    ret       
# End 
# Proc cc_blockpcl.isboolexpr
cc_blockpcl.isboolexpr:
#?>>
#?]]
#---------------
    movsxd    %rax,	dword ptr[%rcx+40]
    cmp       %rax,	26
    jz        L6465
    cmp       %rax,	24
    jz        L6465
    cmp       %rax,	25
    jz        L6465
    cmp       %rax,	33
    jz        L6465
    cmp       %rax,	34
    jz        L6465
    cmp       %rax,	35
    jz        L6465
    cmp       %rax,	36
    jz        L6465
    cmp       %rax,	38
    jz        L6465
    cmp       %rax,	37
    jnz       L6466
L6465:
    mov       %rax,	1
    jmp       L6464
L6466:
    xor       %eax,	%eax
L6464:
L6463:
#---------------
    ret       
# End 
# Proc cc_libpcl.getpsymbol
cc_libpcl.getpsymbol:
#?>>
    .set cc_libpcl.getpsymbol.str, -256
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	296
    mov       %rsi,	%rcx
#---------------
    test      %rsi,	%rsi
    jnz       L6469
    xor       %eax,	%eax
    jmp       L6467
L6469:
    mov       %rax,	[%rsi+56]
    test      %rax,	%rax
    jz        L6471
    mov       %rax,	[%rsi+56]
    jmp       L6467
L6471:
    mov       %rbx,	[%rsi]
    movzx     %rax,	byte ptr[%rsi+109]
    cmp       %rax,	8
    jz        L6474
    cmp       %rax,	9
    jnz       L6473
L6474:
    mov       %rax,	[%rsi]
    lea       %rcx,	[%rbp + cc_libpcl.getpsymbol.str]
    mov       %rdx,	%rax
    call      strcpy
    movzx     %rax,	word ptr[%rsi+96]
    cmp       %rax,	1
    jle       L6476
    lea       %rcx,	[%rbp + cc_libpcl.getpsymbol.str]
    lea       %rdx,	[%rip+L9168]
    call      strcat
    movzx     %rax,	word ptr[%rsi+96]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.strint
    lea       %rcx,	[%rbp + cc_libpcl.getpsymbol.str]
    mov       %rdx,	%rax
    call      strcat
L6476:
    jmp       L6472
L6473:
    movzx     %rax,	byte ptr[%rsi+109]
    cmp       %rax,	7
    jnz       L6477
    mov       %rax,	[%rsi+8]
    test      %rax,	%rax
    jz        L6477
    mov       %rax,	[%rsi+8]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	6
    jnz       L6477
    mov       %rax,	[%rsi+8]
    mov       %rax,	[%rax]
    lea       %rcx,	[%rbp + cc_libpcl.getpsymbol.str]
    mov       %rdx,	%rax
    call      strcpy
    lea       %rcx,	[%rbp + cc_libpcl.getpsymbol.str]
    lea       %rdx,	[%rip+L9168]
    call      strcat
    mov       %rax,	[%rsi]
    lea       %rcx,	[%rbp + cc_libpcl.getpsymbol.str]
    mov       %rdx,	%rax
    call      strcat
    movzx     %rax,	word ptr[%rsi+96]
    cmp       %rax,	1
    jle       L6479
    lea       %rcx,	[%rbp + cc_libpcl.getpsymbol.str]
    lea       %rdx,	[%rip+L9168]
    call      strcat
    movzx     %rax,	word ptr[%rsi+96]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.strint
    lea       %rcx,	[%rbp + cc_libpcl.getpsymbol.str]
    mov       %rdx,	%rax
    call      strcat
L6479:
    jmp       L6472
L6477:
    mov       %rax,	[%rsi]
    lea       %rcx,	[%rbp + cc_libpcl.getpsymbol.str]
    mov       %rdx,	%rax
    call      strcpy
L6472:
    movzx     %rax,	byte ptr[%rsi+109]
    lea       %r10,	[%rip+cc_tables.name2pid]
    movzx     %r10,	byte ptr[%r10 + %rax]
    lea       %rcx,	[%rbp + cc_libpcl.getpsymbol.str]
    mov       %rdx,	%r10
    call      pc_api.pc_makesymbol
    mov       %rdi,	%rax
    mov       [%rsi+56],	%rax
    movzx     %rax,	word ptr[%rsi+102]
    mov       %rcx,	%rax
    call      cc_lib.getpclmode
    mov       [%rdi+82],	%al
    movzx     %rax,	word ptr[%rsi+102]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r10,	[%r10 + %rax*8]
    mov       [%rdi+84],	%r10d
    mov       %rax,	[%rsi+8]
    test      %rax,	%rax
    jz        L6481
    mov       %rax,	[%rsi+8]
    mov       %rax,	[%rax+8]
    test      %rax,	%rax
    jz        L6481
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    call      cc_libpcl.getpsymbol
    mov       [%rdi+32],	%rax
L6481:
    movzx     %rax,	byte ptr[%rsi+110]
    cmp       %rax,	4
    jnz       L6483
    mov       %al,	1
    mov       [%rdi+81],	%al
L6483:
    movzx     %rax,	byte ptr[%rsi+108]
    shr       %eax,	4
    and       %eax,	1
    test      %rax,	%rax
    jz        L6485
    lea       %rax,	[%rdi+104]
    or        byte ptr[%rax],	4
L6485:
    movzx     %rax,	byte ptr[%rsi+110]
    cmp       %rax,	3
    jnz       L6487
    mov       %al,	1
    mov       [%rdi+80],	%al
    mov       %al,	1
    mov       [%rdi+72],	%al
L6487:
    mov       %al,	[%rsi+122]
    mov       [%rdi+92],	%al
    mov       %eax,	[%rsi+88]
    mov       [%rdi+100],	%eax
    movzx     %rax,	byte ptr[%rsi+109]
    cmp       %rax,	6
    jnz       L6489
    mov       %rax,	[%rsi]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L9169]
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L6489
    mov       %al,	1
    mov       [%rdi+110],	%al
    lea       %r10,	[%rsi+108]
    and       byte ptr[%r10],	247
    shl       %al,	3
    or        [%r10],	%al
L6489:
    mov       %rax,	%rdi
L6467:
#---------------
    add       %rsp,	296
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_libpcl.setmode
cc_libpcl.setmode:
#?>>
    .set cc_libpcl.setmode.$T1, -8
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %rdi,	%rcx
#---------------
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    mov       [%rbp + cc_libpcl.setmode.$T1],	%rax
    mov       %rcx,	%rdi
    call      cc_lib.getpclmode
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + cc_libpcl.setmode.$T1]
    call      pc_api.pc_setmode
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc cc_libpcl.setmode2
cc_libpcl.setmode2:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      cc_lib.getpclmode
    mov       %rcx,	%rax
    call      pc_api.pc_setmode2
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_libpcl.setmode_u
cc_libpcl.setmode_u:
#?>>
    .set cc_libpcl.setmode_u.$T1, -8
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rbx,	%rcx
#---------------
    movsxd    %rax,	dword ptr[%rbx+52]
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    mov       [%rbp + cc_libpcl.setmode_u.$T1],	%rax
    mov       %rcx,	%rdi
    call      cc_lib.getpclmode
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + cc_libpcl.setmode_u.$T1]
    call      pc_api.pc_setmode
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_libpcl.genmem_d
cc_libpcl.genmem_d:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      cc_libpcl.getpsymbol
    mov       %rcx,	%rax
    call      pc_api.genmem
L6493:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_libpcl.genmemaddr_d
cc_libpcl.genmemaddr_d:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      cc_libpcl.getpsymbol
    mov       %rcx,	%rax
    call      pc_api.genmemaddr
L6494:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_libpcl.definelabel
cc_libpcl.definelabel:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rax,	[%rip+pc_api.mlabelno]
    mov       %rcx,	%rax
    call      pc_api.genlabel
    mov       %rcx,	127
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rax,	[%rip+pc_api.mlabelno]
L6495:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_libpcl.createfwdlabel
cc_libpcl.createfwdlabel:
#?>>
#?]]
#---------------
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rax,	[%rip+pc_api.mlabelno]
L6496:
#---------------
    ret       
# End 
# Proc cc_libpcl.definefwdlabel
cc_libpcl.definefwdlabel:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      pc_api.genlabel
    mov       %rcx,	127
    mov       %rdx,	%rax
    call      pc_api.pc_gen
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lib.newstrec
cc_lib.newstrec:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    mov       %rcx,	128
    call      mlib.pcm_alloc
    mov       %rdi,	%rax
    mov       %rax,	%rdi
    xor       %r10d,	%r10d
    mov       %r11,	4
L9170:
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    mov       [%rax+16],	%r10
    mov       [%rax+24],	%r10
    add       %rax,	32
    dec       %r11
    jnz       L9170
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %eax,	[%rax+16]
    mov       [%rdi+92],	%eax
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %al,	[%rax+20]
    mov       [%rdi+113],	%al
    mov       %rax,	%rdi
L6498:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lib.initcclib
cc_lib.initcclib:
#?>>
#?]]
#---------------
#---
#---------------
    ret       
# End 
# Proc cc_lib.createname
cc_lib.createname:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    call      cc_lib.allocunitrec
    mov       %rdi,	%rax
    mov       %eax,	3
    mov       [%rdi+40],	%eax
    mov       [%rdi],	%rbx
    mov       %rax,	%rdi
L6500:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createunit0
cc_lib.createunit0:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    call      cc_lib.allocunitrec
    mov       %rdi,	%rax
    mov       [%rdi+40],	%ebx
    mov       %rax,	%rdi
L6501:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createunit1
cc_lib.createunit1:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    call      cc_lib.allocunitrec
    mov       %rdi,	%rax
    mov       [%rdi+40],	%ebx
    mov       [%rdi+16],	%rsi
    mov       %rax,	%rdi
L6502:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createunit2
cc_lib.createunit2:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    call      cc_lib.allocunitrec
    mov       %rdi,	%rax
    mov       [%rdi+40],	%ebx
    mov       [%rdi+16],	%rsi
    mov       [%rdi+24],	%r12
    mov       %rax,	%rdi
L6503:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createunit3
cc_lib.createunit3:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
    mov       %r13,	%r9
#---------------
    call      cc_lib.allocunitrec
    mov       %rdi,	%rax
    mov       [%rdi+40],	%ebx
    mov       [%rdi+16],	%rsi
    mov       [%rdi+24],	%r12
    mov       [%rdi+32],	%r13
    mov       %rax,	%rdi
L6504:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createconstunit
cc_lib.createconstunit:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    call      cc_lib.allocunitrec
    mov       %rdi,	%rax
    mov       %eax,	1
    mov       [%rdi+40],	%eax
    mov       [%rdi],	%rbx
    mov       [%rdi+52],	%esi
    mov       %rax,	%rdi
L6505:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createstringconstunit
cc_lib.createstringconstunit:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    call      cc_lib.allocunitrec
    mov       %rdi,	%rax
    mov       %eax,	1
    mov       [%rdi+40],	%eax
    mov       [%rdi],	%rbx
    mov       %eax,	[%rip+cc_decls.trefchar]
    mov       [%rdi+52],	%eax
    cmp       %rsi,	-1
    jnz       L6508
    mov       %rcx,	%rbx
    call      strlen
    inc       %rax
    mov       [%rdi+48],	%eax
    jmp       L6507
L6508:
    lea       %rax,	[%rsi+1]
    mov       [%rdi+48],	%eax
L6507:
    mov       %al,	1
    mov       [%rdi+61],	%al
    mov       %rax,	%rdi
L6506:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createwstringconstunit
cc_lib.createwstringconstunit:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    call      cc_lib.allocunitrec
    mov       %rdi,	%rax
    mov       %eax,	1
    mov       [%rdi+40],	%eax
    mov       [%rdi],	%rbx
    mov       %eax,	[%rip+cc_decls.trefwchar]
    mov       [%rdi+52],	%eax
    lea       %rax,	[%rsi+1]
    mov       [%rdi+48],	%eax
    mov       %al,	1
    mov       [%rdi+62],	%al
    mov       %rax,	%rdi
L6509:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.getoptocode
cc_lib.getoptocode:
#?>>
    .set cc_lib.getoptocode.str, -24
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	64
    mov       %r12,	%rcx
#---------------
    lea       %rax,	[%rip+cc_lib.getoptocode.opctotable]
    mov       %r10,	%r12
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L6512
    mov       %rax,	%rdi
    jmp       L6510
L6512:
    lea       %rax,	[%rip+cc_tables.jtagnames]
    mov       %r10,	%r12
    mov       %rax,	[%rax + %r10*8]
    lea       %rcx,	[%rbp + cc_lib.getoptocode.str]
    mov       %rdx,	%rax
    call      strcpy
    lea       %rcx,	[%rbp + cc_lib.getoptocode.str]
    lea       %rdx,	[%rip+L9171]
    call      strcat
    xor       %rbx,	%rbx
    mov       %rax,	77
    mov       %rsi,	%rax
    cmp       %rsi,	0
    jl        L6515
L6513:
    lea       %rax,	[%rip+cc_tables.jtagnames]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8]
    mov       %rcx,	%rax
    lea       %rdx,	[%rbp + cc_lib.getoptocode.str]
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L6517
    mov       %ax,	%bx
    lea       %r10,	[%rip+cc_lib.getoptocode.opctotable]
    mov       %r11,	%r12
    mov       [%r10 + %r11*2],	%ax
    mov       %rax,	%rbx
    jmp       L6510
L6517:
    inc       %rbx
    cmp       %rbx,	%rsi
    jle       L6513
L6515:
    call      msys.m$print_startcon
    lea       %rax,	[%rip+cc_tables.jtagnames]
    mov       %r10,	%r12
    mov       %rcx,	[%rax + %r10*8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L9172]
    call      cc_support.serror
    xor       %eax,	%eax
L6510:
#---------------
    add       %rsp,	64
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.getconstvalue
cc_lib.getconstvalue:
#?>>
    .set cc_lib.getconstvalue.id, 32
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    test      %rdi,	%rdi
    jz        L6520
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	1
    jnz       L6520
    mov       %rax,	[%rdi]
    jmp       L6518
L6520:
    lea       %rcx,	[%rip+L9173]
    call      cc_support.serror
    xor       %eax,	%eax
L6518:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lib.nextautotype
cc_lib.nextautotype:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    lea       %rcx,	[%rip+cc_lib.nextautotype.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L9174]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    inc       qword ptr[%rip+cc_lib.autotypeno]
    mov       %rcx,	[%rip+cc_lib.autotypeno]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rax,	[%rip+cc_lib.nextautotype.str]
L6521:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_lib.createconstmode
cc_lib.createconstmode:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    lea       %rax,	[%rip+cc_decls.ttconst]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L6524
    mov       %rax,	%rbx
    jmp       L6522
L6524:
    lea       %rax,	[%rip+cc_decls.ttconsttype]
    mov       %r10,	%rbx
    mov       %ax,	[%rax + %r10*2]
    test      %ax,	%ax
    jz        L6526
    lea       %rax,	[%rip+cc_decls.ttconsttype]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    jmp       L6522
L6526:
    mov       %rcx,	%rbx
    call      cc_lib.copymode
    mov       %rdi,	%rax
    mov       %ax,	%di
    lea       %r10,	[%rip+cc_decls.ttconsttype]
    mov       %r11,	%rbx
    mov       [%r10 + %r11*2],	%ax
    mov       %al,	1
    lea       %r10,	[%rip+cc_decls.ttconst]
    mov       %r11,	%rdi
    mov       [%r10 + %r11],	%al
    mov       %ax,	%bx
    lea       %r10,	[%rip+cc_decls.ttconsttype]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*2],	%ax
    mov       %rax,	%rdi
L6522:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createrefmode
cc_lib.createrefmode:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    lea       %rax,	[%rip+cc_decls.ttreftype]
    mov       %r10,	%rbx
    mov       %ax,	[%rax + %r10*2]
    test      %ax,	%ax
    jz        L6529
    lea       %rax,	[%rip+cc_decls.ttreftype]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    lea       %r10,	[%rip+cc_decls.ttshared]
    lea       %r10,	[%r10 + %rax*4]
    inc       dword ptr[%r10]
    lea       %rax,	[%rip+cc_decls.ttreftype]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    jmp       L6527
L6529:
    mov       %rcx,	13
    call      cc_lib.createnewmode
    mov       %rdi,	%rax
    mov       %ax,	%di
    lea       %r10,	[%rip+cc_decls.ttreftype]
    mov       %r11,	%rbx
    mov       [%r10 + %r11*2],	%ax
    mov       %ax,	%bx
    lea       %r10,	[%rip+cc_decls.tttarget]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*2],	%ax
    mov       %al,	1
    lea       %r10,	[%rip+cc_decls.ttisref]
    mov       %r11,	%rdi
    mov       [%r10 + %r11],	%al
    mov       %rax,	%rdi
L6527:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createprocmode
cc_lib.createprocmode:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rcx,	14
    call      cc_lib.createnewmode
    mov       %rdi,	%rax
    mov       %rax,	%rsi
    lea       %r10,	[%rip+cc_decls.ttparams]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*8],	%rax
    mov       %ax,	%bx
    lea       %r10,	[%rip+cc_decls.tttarget]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*2],	%ax
    mov       %rax,	%rdi
L6530:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createarraymode
cc_lib.createarraymode:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rcx,	17
    call      cc_lib.createnewmode
    mov       %rdi,	%rax
    mov       %ax,	%bx
    lea       %r10,	[%rip+cc_decls.tttarget]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*2],	%ax
    mov       %rax,	%rsi
    lea       %r10,	[%rip+cc_decls.ttlength]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*8],	%rax
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8]
    mov       %r10,	%rsi
    imul      %r10,	%rax
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r11,	%rdi
    mov       [%rax + %r11*8],	%r10
    mov       %al,	1
    lea       %r10,	[%rip+cc_decls.ttisblock]
    mov       %r11,	%rdi
    mov       [%r10 + %r11],	%al
    mov       %rax,	%rdi
L6531:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createenummode
cc_lib.createenummode:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rcx,	12
    call      cc_lib.createnewmode
    mov       %rdi,	%rax
    mov       %rax,	%rbx
    lea       %r10,	[%rip+cc_decls.ttnamedef]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*8],	%rax
    mov       %rax,	%rdi
L6532:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createstructmode
cc_lib.createstructmode:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rcx,	%rsi
    call      cc_lib.createnewmode
    mov       %rdi,	%rax
    mov       %rax,	%rbx
    lea       %r10,	[%rip+cc_decls.ttnamedef]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*8],	%rax
    mov       %al,	1
    lea       %r10,	[%rip+cc_decls.ttisblock]
    mov       %r11,	%rdi
    mov       [%r10 + %r11],	%al
    mov       %rax,	%rdi
L6533:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.setnameptr
cc_lib.setnameptr:
#?>>
#?]]
#---------------
    mov       %rax,	[%rcx]
    mov       %r10,	%rcx
    mov       [%rax+72],	%r10
#---------------
    ret       
# End 
# Proc cc_lib.getautofieldname
cc_lib.getautofieldname:
#?>>
    .set cc_lib.getautofieldname.str, -32
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	72
#---------------
    lea       %rcx,	[%rbp + cc_lib.getautofieldname.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L9175]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    inc       qword ptr[%rip+cc_lib.nextafindex]
    mov       %rcx,	[%rip+cc_lib.nextafindex]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + cc_lib.getautofieldname.str]
    call      mlib.pcm_copyheapstring
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    call      cc_lex.addnamestr
L6535:
#---------------
    add       %rsp,	72
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc cc_lib.convertstringc
cc_lib.convertstringc:
#?>>
    .set cc_lib.convertstringc.str, -24
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	64
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
#---------------
    cmp       %r14,	-1
    jnz       L6538
    mov       %rcx,	%r12
    call      strlen
    mov       %r14,	%rax
L6538:
    mov       %rbx,	%r13
    mov       %rsi,	%r14
    cmp       %rsi,	0
    jle       L6541
L6539:
    mov       %rax,	%r12
    inc       %r12
    movzx     %rax,	byte ptr[%rax]
    mov       %rdi,	%rax
    lea       %rax,	[%rdi-7]
    cmp       %rax,	86
    jae       L6544
    lea       %r10,	[%rip+L6543]
    jmp       [%r10 + %rax*8]
    .data
L6543:
    .quad     L6551
    .quad     L6552
    .quad     L6549
    .quad     L6547
    .quad     L6554
    .quad     L6553
    .quad     L6548
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6545
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6546
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6544
    .quad     L6550
    .text
L6545:
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	34
    mov       [%rax],	%r10b
    jmp       L6542
L6546:
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	39
    mov       [%rax],	%r10b
    jmp       L6542
L6547:
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	110
    mov       [%rax],	%r10b
    jmp       L6542
L6548:
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	114
    mov       [%rax],	%r10b
    jmp       L6542
L6549:
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	116
    mov       [%rax],	%r10b
    jmp       L6542
L6550:
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	92
    mov       [%rax],	%r10b
    jmp       L6542
L6551:
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	97
    mov       [%rax],	%r10b
    jmp       L6542
L6552:
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	98
    mov       [%rax],	%r10b
    jmp       L6542
L6553:
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	102
    mov       [%rax],	%r10b
    jmp       L6542
L6554:
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	118
    mov       [%rax],	%r10b
    jmp       L6542
L6544:
    cmp       %rdi,	32
    jl        L6557
    cmp       %rdi,	127
    jl        L6556
L6557:
    lea       %rcx,	[%rbp + cc_lib.convertstringc.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L9176]
    call      msys.m$print_setfmt
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L9177]
    call      msys.m$print_i64
    call      msys.m$print_end
    mov       %al,	[%rbp + cc_lib.convertstringc.str]
    mov       %r10,	%r13
    inc       %r13
    mov       [%r10],	%al
    mov       %al,	[%rbp + cc_lib.convertstringc.str+1]
    mov       %r10,	%r13
    inc       %r13
    mov       [%r10],	%al
    mov       %al,	[%rbp + cc_lib.convertstringc.str+2]
    mov       %r10,	%r13
    inc       %r13
    mov       [%r10],	%al
    mov       %al,	[%rbp + cc_lib.convertstringc.str+3]
    mov       %r10,	%r13
    inc       %r13
    mov       [%r10],	%al
    jmp       L6555
L6556:
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	%dil
    mov       [%rax],	%r10b
L6555:
L6542:
    dec       %rsi
    jnz       L6539
L6541:
    xor       %eax,	%eax
    mov       [%r13],	%al
    mov       %rax,	%r13
    sub       %rax,	%rbx
L6536:
#---------------
    add       %rsp,	64
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.getopcjname
cc_lib.getopcjname:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    lea       %rax,	[%rip+cc_tables.jtagnames]
    mov       %r10,	%rsi
    mov       %rdi,	[%rax + %r10*8]
    mov       %rcx,	%rdi
    mov       %rdx,	32
    call      strchr
    mov       %rbx,	%rax
    test      %rbx,	%rbx
    jz        L6560
    mov       %rax,	%rbx
    sub       %rax,	%rdi
    lea       %rcx,	[%rip+cc_lib.getopcjname.str]
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      memcpy
    mov       %rax,	%rbx
    sub       %rax,	%rdi
    xor       %r10d,	%r10d
    lea       %r11,	[%rip+cc_lib.getopcjname.str]
    mov       [%r11 + %rax],	%r10b
    lea       %rax,	[%rip+cc_lib.getopcjname.str]
    jmp       L6559
L6560:
    mov       %rax,	%rdi
L6559:
L6558:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.strmode
cc_lib.strmode:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    lea       %r8,	[%rip+cc_lib.strmode.str]
    call      cc_lib.istrmode
    lea       %rax,	[%rip+cc_lib.strmode.str]
L6561:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.strmode2
cc_lib.strmode2:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    lea       %r8,	[%rip+cc_lib.strmode2.str]
    call      cc_lib.istrmode
    lea       %rax,	[%rip+cc_lib.strmode2.str]
L6562:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.istrmode
cc_lib.istrmode:
#?>>
    .set cc_lib.istrmode.expand, 80
    .set cc_lib.istrmode.dest, 88
    .set cc_lib.istrmode.n, -8
    .set cc_lib.istrmode.sxx, -24
    .set cc_lib.istrmode.xx, -32
    .set cc_lib.istrmode.pm, -40
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	72
    mov       %r15,	%rcx
    mov       [%rbp+80],	%rdx
    mov       [%rbp+88],	%r8
#---------------
    lea       %rax,	[%rbp + cc_lib.istrmode.sxx]
    mov       [%rbp + cc_lib.istrmode.xx],	%rax
    cmp       %r15,	21
    jge       L6565
    mov       %rcx,	%r15
    call      cc_lib.typename
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    mov       %rdx,	%rax
    call      strcpy
    jmp       L6563
L6565:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%r15
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %r14,	%rax
    mov       %rax,	%r14
    cmp       %rax,	13
    jz        L6567
    cmp       %rax,	17
    jz        L6568
    cmp       %rax,	12
    jz        L6569
    cmp       %rax,	18
    jz        L6570
    cmp       %rax,	19
    jz        L6570
    test      %rax,	%rax
    jz        L6571
    cmp       %rax,	14
    jz        L6572
    jmp       L6573
L6567:
    lea       %rax,	[%rip+cc_decls.ttconst]
    mov       %r10,	%r15
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L6575
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    lea       %rdx,	[%rip+L9178]
    call      strcpy
    jmp       L6574
L6575:
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    lea       %rdx,	[%rip+L9179]
    call      strcpy
L6574:
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%r15
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %r13,	%rax
    cmp       %r13,	0
    jl        L6577
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%r15
    movsx     %rax,	word ptr[%rax + %r10*2]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    cmp       %r10,	18
    jnz       L6577
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%r15
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rcx,	%rax
    call      cc_lib.typename
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    mov       %rdx,	%rax
    call      strcat
    jmp       L6576
L6577:
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    call      strlen
    mov       %r10,	[%rbp + cc_lib.istrmode.dest]
    lea       %r10,	[%r10 + %rax]
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r11,	%r15
    movsx     %rax,	word ptr[%rax + %r11*2]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    mov       %r8,	%r10
    call      cc_lib.istrmode
L6576:
    jmp       L6566
L6568:
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%r15
    mov       %rax,	[%rax + %r10*8]
    test      %rax,	%rax
    jz        L6579
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L9180]
    call      msys.m$print_setfmt
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%r15
    mov       %rcx,	[%rax + %r10*8]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L6578
L6579:
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    lea       %rdx,	[%rip+L9181]
    call      strcpy
L6578:
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    call      strlen
    mov       %r10,	[%rbp + cc_lib.istrmode.dest]
    lea       %r10,	[%r10 + %rax]
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r11,	%r15
    movsx     %rax,	word ptr[%rax + %r11*2]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    mov       %r8,	%r10
    call      cc_lib.istrmode
    jmp       L6566
L6569:
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    lea       %rdx,	[%rip+L9182]
    call      strcpy
    mov       %rcx,	%r15
    call      cc_lib.typename
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    mov       %rdx,	%rax
    call      strcat
    jmp       L6566
L6570:
    mov       %rax,	[%rbp + cc_lib.istrmode.expand]
    test      %rax,	%rax
    jnz       L6581
    mov       %rcx,	%r15
    call      cc_lib.typename
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    mov       %rdx,	%rax
    call      strcpy
    jmp       L6563
L6581:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%r15
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rcx,	%rax
    call      cc_lib.typename
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    mov       %rdx,	%rax
    call      strcpy
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    lea       %rdx,	[%rip+L9183]
    call      strcat
    lea       %rax,	[%rip+cc_decls.ttnamedef]
    mov       %r10,	%r15
    mov       %rdi,	[%rax + %r10*8]
    xor       %rsi,	%rsi
    mov       %rax,	[%rdi+16]
    mov       %rbx,	%rax
    jmp       L6583
L6582:
    test      %rsi,	%rsi
    jz        L6586
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    lea       %rdx,	[%rip+L9184]
    call      strcat
L6586:
    mov       %rsi,	1
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    call      strlen
    mov       %r10,	[%rbp + cc_lib.istrmode.dest]
    lea       %r10,	[%r10 + %rax]
    movzx     %rax,	word ptr[%rbx+102]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    mov       %r8,	%r10
    call      cc_lib.istrmode
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    lea       %rdx,	[%rip+L9185]
    call      strcat
    mov       %rax,	[%rbx]
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    mov       %rdx,	%rax
    call      strcat
    mov       %rbx,	[%rbx+32]
L6583:
    test      %rbx,	%rbx
    jnz       L6582
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    lea       %rdx,	[%rip+L9186]
    call      strcat
    jmp       L6566
L6571:
    mov       %rcx,	%r15
    call      cc_lib.typename
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    mov       %rdx,	%rax
    call      strcpy
    jmp       L6566
L6572:
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    lea       %rdx,	[%rip+L9187]
    call      strcpy
    lea       %rax,	[%rip+cc_decls.ttparams]
    mov       %r10,	%r15
    mov       %rax,	[%rax + %r10*8]
    mov       [%rbp + cc_lib.istrmode.pm],	%rax
    mov       %rax,	[%rbp + cc_lib.istrmode.pm]
    movsx     %rax,	word ptr[%rax+20]
    mov       [%rbp + cc_lib.istrmode.n],	%rax
    mov       %r12,	1
    mov       %rax,	[%rbp + cc_lib.istrmode.n]
    cmp       %rax,	1
    jl        L6589
L6587:
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    call      strlen
    mov       %r10,	[%rbp + cc_lib.istrmode.dest]
    lea       %r10,	[%r10 + %rax]
    mov       %rax,	[%rbp + cc_lib.istrmode.pm]
    movsxd    %rax,	dword ptr[%rax+16]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    mov       %r8,	%r10
    call      cc_lib.istrmode
    cmp       %r12,	[%rbp + cc_lib.istrmode.n]
    jz        L6591
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    lea       %rdx,	[%rip+L9188]
    call      strcat
L6591:
    mov       %rax,	[%rbp + cc_lib.istrmode.pm]
    mov       %rax,	[%rax+8]
    mov       [%rbp + cc_lib.istrmode.pm],	%rax
    inc       %r12
    cmp       %r12,	[%rbp + cc_lib.istrmode.n]
    jle       L6587
L6589:
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    lea       %rdx,	[%rip+L9189]
    call      strcat
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    call      strlen
    mov       %r10,	[%rbp + cc_lib.istrmode.dest]
    lea       %r10,	[%r10 + %rax]
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r11,	%r15
    movsx     %rax,	word ptr[%rax + %r11*2]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    mov       %r8,	%r10
    call      cc_lib.istrmode
    jmp       L6566
L6573:
    cmp       %r14,	21
    jge       L6593
    mov       %rcx,	%r15
    call      cc_lib.typename
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    mov       %rdx,	%rax
    call      strcpy
    jmp       L6563
L6593:
    call      msys.m$print_startcon
    mov       %rcx,	%r15
    call      cc_lib.typename
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L9190]
    call      cc_support.mcerror
L6592:
L6566:
L6563:
#---------------
    add       %rsp,	72
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.typename
cc_lib.typename:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rdi,	%rax
    mov       %rax,	%rdi
    cmp       %rax,	18
    jz        L6596
    cmp       %rax,	19
    jz        L6596
    cmp       %rax,	17
    jz        L6597
    cmp       %rax,	12
    jz        L6598
    jmp       L6599
L6596:
    cmp       %rdi,	18
    jnz       L6601
    lea       %rax,	[%rip+L9191]
    jmp       L6600
L6601:
    lea       %rax,	[%rip+L9192]
L6600:
    lea       %rcx,	[%rip+cc_lib.typename.str]
    mov       %rdx,	%rax
    call      strcpy
    lea       %rax,	[%rip+cc_decls.ttnamedef]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8]
    test      %rax,	%rax
    jz        L6603
    lea       %rax,	[%rip+cc_decls.ttnamedef]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8]
    mov       %rax,	[%rax]
    lea       %rcx,	[%rip+cc_lib.typename.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rcx,	[%rip+cc_lib.typename.str]
    lea       %rdx,	[%rip+L9193]
    call      strcat
    lea       %rax,	[%rip+cc_decls.ttnamedef]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8]
    movzx     %rax,	word ptr[%rax+96]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.strint
    lea       %rcx,	[%rip+cc_lib.typename.str]
    mov       %rdx,	%rax
    call      strcat
L6603:
    lea       %rax,	[%rip+cc_lib.typename.str]
    jmp       L6594
L6597:
    lea       %rax,	[%rip+L9194]
    jmp       L6594
L6598:
    lea       %rax,	[%rip+cc_decls.ttnamedef]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8]
    test      %rax,	%rax
    jz        L6605
    lea       %rax,	[%rip+cc_decls.ttnamedef]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8]
    mov       %rax,	[%rax]
    jmp       L6594
L6605:
    lea       %rax,	[%rip+L9195]
    jmp       L6594
L6599:
    lea       %rax,	[%rip+cc_decls.ttconst]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L6607
    lea       %rcx,	[%rip+cc_lib.typename.str]
    lea       %rdx,	[%rip+L9196]
    call      strcpy
    lea       %rax,	[%rip+cc_tables.stdtypenames]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    lea       %rcx,	[%rip+cc_lib.typename.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rax,	[%rip+cc_lib.typename.str]
    jmp       L6594
L6607:
    lea       %rax,	[%rip+cc_tables.stdtypenames]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    jmp       L6594
L6595:
    lea       %rax,	[%rip+L9197]
L6594:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.allocunitrec
cc_lib.allocunitrec:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
    inc       qword ptr[%rip+cc_decls.nunits]
    mov       %rax,	[%rip+cc_lib.remainingunits]
    dec       qword ptr[%rip+cc_lib.remainingunits]
    test      %rax,	%rax
    jz        L6610
    mov       %rdi,	[%rip+cc_lib.unitheapptr]
    add       qword ptr[%rip+cc_lib.unitheapptr],	64
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %eax,	[%rax+16]
    mov       [%rdi+44],	%eax
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+20]
    cmp       %rax,	255
    jg        L6612
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %al,	[%rax+20]
    mov       [%rdi+60],	%al
L6612:
    mov       %rax,	%rdi
    jmp       L6608
L6610:
    mov       %rcx,	3200000
    call      mlib.pcm_alloc
    mov       [%rip+cc_lib.unitheapptr],	%rax
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    mov       %r8,	3200000
    call      memset
    mov       %rax,	49999
    mov       [%rip+cc_lib.remainingunits],	%rax
    add       qword ptr[%rip+cc_lib.unitheapptr],	64
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %eax,	[%rax+16]
    mov       [%rdi+44],	%eax
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+20]
    cmp       %rax,	255
    jg        L6614
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %al,	[%rax+20]
    mov       [%rdi+60],	%al
L6614:
    mov       %rax,	%rdi
L6608:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lib.copymode
cc_lib.copymode:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	[%rip+cc_decls.ntypes]
    cmp       %rax,	80000
    jl        L6617
    lea       %rcx,	[%rip+L9198]
    call      cc_support.serror
L6617:
    inc       qword ptr[%rip+cc_decls.ntypes]
    lea       %rax,	[%rip+cc_decls.ttnamedef]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    lea       %r10,	[%rip+cc_decls.ttnamedef]
    mov       %r11,	[%rip+cc_decls.ntypes]
    mov       [%r10 + %r11*8],	%rax
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rdi
    mov       %ax,	[%rax + %r10*2]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    mov       %r11,	[%rip+cc_decls.ntypes]
    mov       [%r10 + %r11*2],	%ax
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    lea       %r10,	[%rip+cc_decls.ttlength]
    mov       %r11,	[%rip+cc_decls.ntypes]
    mov       [%r10 + %r11*8],	%rax
    lea       %rax,	[%rip+cc_decls.ttconst]
    mov       %r10,	%rdi
    mov       %al,	[%rax + %r10]
    lea       %r10,	[%rip+cc_decls.ttconst]
    mov       %r11,	[%rip+cc_decls.ntypes]
    mov       [%r10 + %r11],	%al
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r11,	[%rip+cc_decls.ntypes]
    mov       [%r10 + %r11*8],	%rax
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%rdi
    mov       %ax,	[%rax + %r10*2]
    lea       %r10,	[%rip+cc_decls.tttarget]
    mov       %r11,	[%rip+cc_decls.ntypes]
    mov       [%r10 + %r11*2],	%ax
    lea       %rax,	[%rip+cc_decls.ttparams]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    lea       %r10,	[%rip+cc_decls.ttparams]
    mov       %r11,	[%rip+cc_decls.ntypes]
    mov       [%r10 + %r11*8],	%rax
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%rdi
    mov       %al,	[%rax + %r10]
    lea       %r10,	[%rip+cc_decls.ttisref]
    mov       %r11,	[%rip+cc_decls.ntypes]
    mov       [%r10 + %r11],	%al
    lea       %rax,	[%rip+cc_decls.ttisblock]
    mov       %r10,	%rdi
    mov       %al,	[%rax + %r10]
    lea       %r10,	[%rip+cc_decls.ttisblock]
    mov       %r11,	[%rip+cc_decls.ntypes]
    mov       [%r10 + %r11],	%al
    mov       %rax,	[%rip+cc_decls.ntypes]
L6615:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createnewmode
cc_lib.createnewmode:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	[%rip+cc_decls.ntypes]
    cmp       %rax,	80000
    jl        L6620
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L9199]
    call      msys.m$print_str_nf
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L9200]
    call      cc_support.serror
L6620:
    inc       qword ptr[%rip+cc_decls.ntypes]
    mov       %ax,	%di
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    mov       %r11,	[%rip+cc_decls.ntypes]
    mov       [%r10 + %r11*2],	%ax
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r11,	[%rip+cc_decls.ntypes]
    mov       [%r10 + %r11*8],	%rax
    mov       %rax,	[%rip+cc_decls.ntypes]
L6618:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lib.addlistunit
cc_lib.addlistunit:
#?>>
#?]]
#---------------
    mov       %rax,	[%rcx]
    test      %rax,	%rax
    jnz       L6623
    mov       %rax,	%r8
    mov       [%rdx],	%rax
    mov       [%rcx],	%rax
    jmp       L6622
L6623:
    mov       %rax,	[%rdx]
    mov       %r10,	%r8
    mov       [%rax+8],	%r10
L6622:
    xor       %eax,	%eax
    mov       [%r8+8],	%rax
    mov       [%rdx],	%r8
#---------------
    ret       
# End 
# Proc cc_lib.addlistdef
cc_lib.addlistdef:
#?>>
#?]]
#---------------
    mov       %rax,	[%rcx]
    test      %rax,	%rax
    jnz       L6626
    mov       %rax,	%r8
    mov       [%rdx],	%rax
    mov       [%rcx],	%rax
    jmp       L6625
L6626:
    mov       %rax,	[%rdx]
    mov       %r10,	%r8
    mov       [%rax+32],	%r10
L6625:
    xor       %eax,	%eax
    mov       [%r8+32],	%rax
    mov       [%rdx],	%r8
#---------------
    ret       
# End 
# Proc cc_lib.addlistparam
cc_lib.addlistparam:
#?>>
#?]]
#---------------
    mov       %rax,	[%rcx]
    test      %rax,	%rax
    jnz       L6629
    mov       %rax,	%r8
    mov       [%rdx],	%rax
    mov       [%rcx],	%rax
    jmp       L6628
L6629:
    mov       %rax,	[%rdx]
    mov       %r10,	%r8
    mov       [%rax+8],	%r10
L6628:
    xor       %eax,	%eax
    mov       [%r8+8],	%rax
    mov       [%rdx],	%r8
#---------------
    ret       
# End 
# Proc cc_lib.checksymbol
cc_lib.checksymbol:
#?>>
    .set cc_lib.checksymbol.str, -256
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	296
    mov       %rdi,	%rcx
#---------------
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	%rdi
    jz        L6632
    lea       %rcx,	[%rbp + cc_lib.checksymbol.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L9201]
    call      msys.m$print_setfmt
    lea       %rax,	[%rip+cc_tables.symbolnames]
    mov       %r10,	%rdi
    mov       %rcx,	[%rax + %r10*8-8]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    lea       %r10,	[%rip+cc_tables.symbolnames]
    mov       %r10,	[%r10 + %rax*8-8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jnz       L6634
    lea       %rcx,	[%rbp + cc_lib.checksymbol.str]
    lea       %rdx,	[%rip+L9202]
    call      strcat
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    call      cc_lib.getstname
    lea       %rcx,	[%rbp + cc_lib.checksymbol.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rcx,	[%rbp + cc_lib.checksymbol.str]
    lea       %rdx,	[%rip+L9203]
    call      strcat
L6634:
    lea       %rcx,	[%rbp + cc_lib.checksymbol.str]
    call      cc_support.serror
L6632:
#---------------
    add       %rsp,	296
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc cc_lib.skipsymbol
cc_lib.skipsymbol:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	%rdi
    jz        L6637
    mov       %rcx,	%rdi
    call      cc_lib.checksymbol
L6637:
    call      cc_lex.lex
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lib.inittypetables
cc_lib.inittypetables:
#?>>
    .set cc_lib.inittypetables.av_2, -8
    .set cc_lib.inittypetables.av_3, -16
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	56
#---------------
    xor       %rdi,	%rdi
    mov       %rax,	20
    mov       %r15,	%rax
    cmp       %r15,	0
    jl        L6641
L6639:
    mov       %ax,	%di
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*2],	%ax
    lea       %rax,	[%rip+cc_tables.stdtypewidths]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %rsi,	%rax
    mov       %rax,	%rsi
    sar       %rax,	3
    mov       %rbx,	%rax
    mov       %rax,	%rbx
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*8],	%rax
    mov       %rax,	%rdi
    cmp       %rax,	17
    jz        L6644
    cmp       %rax,	18
    jnz       L6643
L6644:
    mov       %al,	1
    lea       %r10,	[%rip+cc_decls.ttisblock]
    mov       %r11,	%rdi
    mov       [%r10 + %r11],	%al
L6643:
    inc       %rdi
    cmp       %rdi,	%r15
    jle       L6639
L6641:
    mov       %rax,	20
    mov       [%rip+cc_decls.ntypes],	%rax
    mov       %rcx,	1
    call      cc_lib.createrefmode
    mov       [%rip+cc_decls.trefchar],	%rax
    mov       %rcx,	7
    call      cc_lib.createrefmode
    mov       [%rip+cc_decls.trefwchar],	%rax
    mov       %rdi,	1
    mov       %rax,	121
    mov       [%rbp + cc_lib.inittypetables.av_2],	%rax
    mov       %rax,	[%rbp + cc_lib.inittypetables.av_2]
    cmp       %rax,	1
    jl        L6647
L6645:
    lea       %rax,	[%rip+cc_tables.dominantsetuptable]
    mov       %r10,	%rdi
    lea       %r10,	[%r10 + %r10*2]
    lea       %rax,	[%rax + %r10-3]
    movzx     %rax,	byte ptr[%rax]
    mov       %r12,	%rax
    lea       %rax,	[%rip+cc_tables.dominantsetuptable]
    mov       %r10,	%rdi
    lea       %r10,	[%r10 + %r10*2]
    lea       %rax,	[%rax + %r10-3]
    movzx     %rax,	byte ptr[%rax+1]
    mov       %r13,	%rax
    lea       %rax,	[%rip+cc_tables.dominantsetuptable]
    mov       %r10,	%rdi
    lea       %r10,	[%r10 + %r10*2]
    lea       %rax,	[%rax + %r10-3]
    movzx     %rax,	byte ptr[%rax+2]
    mov       %r14,	%rax
    lea       %rax,	[%rip+cc_tables.dominantmode]
    mov       %r10,	%r12
    shl       %r10,	5
    lea       %rax,	[%rax + %r10]
    mov       %r10b,	%r14b
    mov       %r11,	%r13
    mov       [%rax + %r11],	%r10b
    inc       %rdi
    cmp       %rdi,	[%rbp + cc_lib.inittypetables.av_2]
    jle       L6645
L6647:
    mov       %rdi,	1
    mov       %rax,	121
    mov       [%rbp + cc_lib.inittypetables.av_3],	%rax
    mov       %rax,	[%rbp + cc_lib.inittypetables.av_3]
    cmp       %rax,	1
    jl        L6650
L6648:
    lea       %rax,	[%rip+cc_tables.convsetuptable]
    mov       %r10,	%rdi
    lea       %r10,	[%r10 + %r10*2]
    lea       %rax,	[%rax + %r10-3]
    movzx     %rax,	byte ptr[%rax]
    mov       %r12,	%rax
    lea       %rax,	[%rip+cc_tables.convsetuptable]
    mov       %r10,	%rdi
    lea       %r10,	[%r10 + %r10*2]
    lea       %rax,	[%rax + %r10-3]
    movzx     %rax,	byte ptr[%rax+1]
    mov       %r13,	%rax
    lea       %rax,	[%rip+cc_tables.convsetuptable]
    mov       %r10,	%rdi
    lea       %r10,	[%r10 + %r10*2]
    lea       %rax,	[%rax + %r10-3]
    movzx     %rax,	byte ptr[%rax+2]
    mov       %r14,	%rax
    lea       %rax,	[%rip+cc_tables.conversionops]
    mov       %r10,	%r12
    shl       %r10,	4
    lea       %rax,	[%rax + %r10]
    mov       %r10b,	%r14b
    mov       %r11,	%r13
    mov       [%rax + %r11],	%r10b
    inc       %rdi
    cmp       %rdi,	[%rbp + cc_lib.inittypetables.av_3]
    jle       L6648
L6650:
#---------------
    add       %rsp,	56
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createdupldef
cc_lib.createdupldef:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
    call      cc_lib.newstrec
    mov       %rdi,	%rax
    mov       %rax,	[%r12]
    mov       [%rdi],	%rax
    mov       %al,	[%r12+106]
    mov       [%rdi+106],	%al
    mov       %al,	67
    mov       [%rdi+107],	%al
    mov       [%rdi+8],	%rsi
    mov       [%rdi+109],	%r13b
    lea       %rax,	[%rip+cc_tables.namespaces]
    mov       %r10,	%r13
    mov       %eax,	[%rax + %r10*4]
    mov       [%rdi+98],	%ax
    mov       %rax,	[%r12+40]
    mov       %rbx,	%rax
    test      %rax,	%rax
    jz        L6653
    mov       [%rbx+48],	%rdi
L6653:
    mov       [%rdi+40],	%rbx
    mov       [%rdi+48],	%r12
    mov       [%r12+40],	%rdi
    test      %rsi,	%rsi
    jz        L6655
    mov       %rax,	[%rsi+16]
    test      %rax,	%rax
    jnz       L6657
    mov       %rax,	%rdi
    mov       [%rsi+24],	%rax
    mov       [%rsi+16],	%rax
    jmp       L6656
L6657:
    mov       %rax,	[%rsi+24]
    mov       %r10,	%rdi
    mov       [%rax+32],	%r10
    mov       [%rsi+24],	%rdi
L6656:
L6655:
    mov       %rax,	%rdi
L6651:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createnewmoduledef
cc_lib.createnewmoduledef:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	3
    call      cc_lib.createdupldef
    mov       %rdi,	%rax
    mov       %rax,	%rdi
L6658:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createnewproc
cc_lib.createnewproc:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	6
    call      cc_lib.createdupldef
    mov       %rdi,	%rax
    mov       %rbx,	%rdi
    jmp       L6661
L6660:
    mov       %rax,	[%rbx+8]
    cmp       %rax,	%rsi
    jnz       L6664
    call      msys.m$print_startcon
    mov       %rcx,	[%rbx]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L9204]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rsi]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L9205]
    call      cc_support.serror
L6664:
L6661:
    mov       %rax,	[%rbx+40]
    mov       %rbx,	%rax
    test      %rax,	%rax
    jnz       L6660
    mov       %rax,	%rdi
L6659:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.resolvename
cc_lib.resolvename:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
    mov       %r14,	%r9
#---------------
    movzx     %rax,	byte ptr[%r12+109]
    cmp       %rax,	1
    jle       L6667
    mov       %rax,	%r12
    jmp       L6665
L6667:
    cmp       %r13,	3
    jnz       L6669
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    call      cc_lib.resolvelabel
    jmp       L6665
L6669:
    test      %r14,	%r14
    jz        L6671
    lea       %rax,	[%rip+cc_decls.blockcounts]
    mov       %r10,	%r14
    movsxd    %rax,	dword ptr[%rax + %r10*4]
    test      %rax,	%rax
    jnz       L6671
    lea       %rax,	[%rip+cc_decls.blockowner]
    mov       %r10,	%r14
    movsxd    %rax,	dword ptr[%rax + %r10*4]
    mov       %r14,	%rax
L6671:
L6672:
    mov       %rax,	%r13
    shl       %rax,	16
    or        %rax,	%r14
    mov       %rdi,	%rax
    mov       %rbx,	%r12
    jmp       L6675
L6674:
    movzx     %rax,	byte ptr[%rsi+109]
    cmp       %rax,	6
    jnz       L6678
    mov       %rax,	[%rbx+8]
    cmp       %rax,	%rsi
    jz        L6678
    mov       %rax,	[%rbx+8]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	6
    jz        L6676
L6678:
    mov       %rax,	[%rbx+8]
    cmp       %rax,	%rsi
    jnz       L6680
    mov       %eax,	[%rbx+96]
    cmp       %rax,	%rdi
    jnz       L6680
    movzx     %rax,	byte ptr[%rbx+122]
    cmp       %rax,	255
    jge       L6682
    lea       %rax,	[%rbx+122]
    inc       byte ptr[%rax]
L6682:
    mov       %rax,	%rbx
    jmp       L6665
L6680:
L6675:
    mov       %rax,	[%rbx+40]
    mov       %rbx,	%rax
    test      %rax,	%rax
    jnz       L6674
L6676:
    test      %r14,	%r14
    jnz       L6684
    movzx     %rax,	byte ptr[%rsi+109]
    cmp       %rax,	6
    jz        L6686
    cmp       %rax,	13
    jz        L6687
    jmp       L6688
L6686:
    mov       %rsi,	[%rip+cc_decls.stmodule]
    jmp       L6672
L6687:
    mov       %rsi,	[%rsi+8]
    test      %rsi,	%rsi
    jnz       L6690
    xor       %eax,	%eax
    jmp       L6665
L6690:
    jmp       L6685
L6688:
    xor       %eax,	%eax
    jmp       L6665
L6685:
    jmp       L6683
L6684:
    lea       %rax,	[%rip+cc_decls.blockowner]
    mov       %r10,	%r14
    movsxd    %rax,	dword ptr[%rax + %r10*4]
    mov       %r14,	%rax
    test      %rax,	%rax
    jnz       L6691
    mov       %rsi,	[%rip+cc_decls.stmodule]
L6691:
L6683:
    jmp       L6672
    xor       %eax,	%eax
L6665:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.resolvelabel
cc_lib.resolvelabel:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	16
#---------------
    mov       %rdi,	%rdx
    jmp       L6694
L6693:
    movzx     %rax,	byte ptr[%rcx+109]
    cmp       %rax,	6
    jnz       L6697
    mov       %rax,	[%rdi+8]
    cmp       %rax,	%rcx
    jz        L6697
    mov       %rax,	[%rdi+8]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	6
    jz        L6695
L6697:
    mov       %rax,	[%rdi+8]
    cmp       %rax,	%rcx
    jnz       L6699
    movzx     %rax,	word ptr[%rdi+98]
    cmp       %rax,	3
    jnz       L6699
    mov       %rax,	%rdi
    jmp       L6692
L6699:
L6694:
    mov       %rax,	[%rdi+40]
    mov       %rdi,	%rax
    test      %rax,	%rax
    jnz       L6693
L6695:
    xor       %eax,	%eax
L6692:
#---------------
    add       %rsp,	16
    pop       %rdi
    ret       
# End 
# Proc cc_lib.checkdupl
cc_lib.checkdupl:
#?>>
    push      %rdi
    push      %rbx
#?]]
#---------------
    mov       %rbx,	%rdx
    mov       %rax,	%r8
    shl       %rax,	16
    or        %rax,	%r9
    mov       %rdi,	%rax
    jmp       L6702
L6701:
    mov       %rax,	[%rbx+8]
    cmp       %rax,	%rcx
    jnz       L6705
    mov       %eax,	[%rbx+96]
    cmp       %rax,	%rdi
    jnz       L6705
    mov       %rax,	%rbx
    jmp       L6700
L6705:
L6702:
    mov       %rax,	[%rbx+40]
    mov       %rbx,	%rax
    test      %rax,	%rax
    jnz       L6701
    xor       %eax,	%eax
L6700:
#---------------
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.checkdupl_inproc
cc_lib.checkdupl_inproc:
#?>>
    push      %rdi
    push      %rbx
#?]]
#---------------
    mov       %rbx,	%rdx
    mov       %rax,	%r8
    shl       %rax,	16
    or        %rax,	%r9
    mov       %rdi,	%rax
    jmp       L6708
L6707:
    mov       %eax,	[%rbx+96]
    cmp       %rax,	%rdi
    jnz       L6711
    mov       %rax,	%rbx
    jmp       L6706
L6711:
L6708:
    mov       %rax,	[%rbx+40]
    mov       %rbx,	%rax
    test      %rax,	%rax
    jz        L6712
    mov       %rax,	[%rbx+8]
    cmp       %rax,	%rcx
    jz        L6707
L6712:
    xor       %eax,	%eax
L6706:
#---------------
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.getalignment
cc_lib.getalignment:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jz        L6715
    cmp       %rax,	18
    jz        L6716
    cmp       %rax,	19
    jz        L6716
    jmp       L6717
L6715:
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rcx,	%rax
    call      cc_lib.getalignment
    jmp       L6713
L6716:
    lea       %rax,	[%rip+cc_decls.ttnamedef]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8]
    movzx     %rax,	byte ptr[%rax+112]
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L6719
    mov       %rax,	16
    jmp       L6713
L6719:
    mov       %rax,	%rdi
    jmp       L6713
L6717:
L6714:
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rbx
    mov       %rdi,	[%rax + %r10*8]
    mov       %rax,	%rdi
    cmp       %rax,	1
    jz        L6721
    cmp       %rax,	2
    jz        L6721
    cmp       %rax,	4
    jz        L6721
    cmp       %rax,	8
    jnz       L6722
L6721:
    mov       %rax,	%rdi
    jmp       L6713
L6722:
L6720:
    call      msys.m$print_startcon
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    mov       %rcx,	%rdi
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L9206]
    call      cc_support.serror
    xor       %eax,	%eax
L6713:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.isexported
cc_lib.isexported:
#?>>
#?]]
#---------------
    movzx     %rax,	byte ptr[%rcx+109]
    cmp       %rax,	6
    jnz       L6725
    mov       %rax,	[%rcx+72]
    test      %rax,	%rax
    jz        L6727
    movzx     %rax,	byte ptr[%rcx+110]
    cmp       %rax,	3
    jz        L6728
    movzx     %rax,	byte ptr[%rcx+110]
    cmp       %rax,	4
    jnz       L6727
L6728:
    mov       %rax,	1
    jmp       L6723
L6727:
    jmp       L6724
L6725:
    movzx     %rax,	byte ptr[%rcx+110]
    cmp       %rax,	4
    jnz       L6730
    mov       %rax,	1
    jmp       L6723
L6730:
L6724:
    xor       %eax,	%eax
L6723:
#---------------
    ret       
# End 
# Proc cc_lib.isimported
cc_lib.isimported:
#?>>
#?]]
#---------------
    movzx     %rax,	byte ptr[%rcx+109]
    cmp       %rax,	6
    jnz       L6733
    mov       %rax,	[%rcx+72]
    test      %rax,	%rax
    jnz       L6735
    movzx     %rax,	byte ptr[%rcx+110]
    cmp       %rax,	3
    jz        L6736
    movzx     %rax,	byte ptr[%rcx+110]
    cmp       %rax,	4
    jnz       L6735
L6736:
    mov       %rax,	1
    jmp       L6731
L6735:
    jmp       L6732
L6733:
    movzx     %rax,	byte ptr[%rcx+110]
    cmp       %rax,	3
    jnz       L6738
    mov       %rax,	1
    jmp       L6731
L6738:
L6732:
    xor       %eax,	%eax
L6731:
#---------------
    ret       
# End 
# Proc cc_lib.getstname
cc_lib.getstname:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    movzx     %rax,	byte ptr[%rdi+106]
    mov       %r10,	[%rdi]
    lea       %rcx,	[%rip+cc_lib.getstname.name]
    mov       %rdx,	%r10
    mov       %r8,	%rax
    call      memcpy
    movzx     %rax,	byte ptr[%rdi+106]
    xor       %r10d,	%r10d
    lea       %r11,	[%rip+cc_lib.getstname.name]
    mov       [%r11 + %rax],	%r10b
    lea       %rax,	[%rip+cc_lib.getstname.name]
L6739:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lib.isrealcc
cc_lib.isrealcc:
#?>>
#?]]
#---------------
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rcx
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rcx,	%rax
    mov       %rax,	%rcx
    cmp       %rax,	10
    jl        L6741
    cmp       %rax,	11
    jg        L6741
    mov       %rax,	1
    jmp       L6742
L6741:
    xor       %eax,	%eax
L6742:
L6740:
#---------------
    ret       
# End 
# Proc cc_lib.isintcc
cc_lib.isintcc:
#?>>
#?]]
#---------------
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rcx
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rcx,	%rax
    mov       %rax,	%rcx
    cmp       %rax,	1
    jl        L6744
    cmp       %rax,	9
    jg        L6744
    mov       %rax,	1
    jmp       L6745
L6744:
    xor       %eax,	%eax
L6745:
L6743:
#---------------
    ret       
# End 
# Proc cc_lib.writegsfile
cc_lib.writegsfile:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rcx,	%rbx
    lea       %rdx,	[%rip+L9207]
    call      fopen
    mov       %rdi,	%rax
    mov       %rcx,	%rsi
    mov       %rdx,	%rdi
    call      mlib.gs_println
    mov       %rcx,	%rdi
    call      fclose
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.pause
cc_lib.pause:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    call      msys.m$print_startcon
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    call      msys.m$print_end
    call      mnoos.os_getch
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lib.getpclmode
cc_lib.getpclmode:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	16
#---------------
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rcx
    movsx     %rax,	word ptr[%rax + %r10*2]
    lea       %r10,	[%rip+cc_tables.stdpcl]
    movzx     %r10,	byte ptr[%r10 + %rax]
    mov       %rdi,	%r10
    cmp       %rdi,	11
    jnz       L6750
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rcx
    mov       %rax,	[%rax + %r10*8]
    cmp       %rax,	8
    jz        L6752
    cmp       %rax,	4
    jz        L6753
    cmp       %rax,	2
    jz        L6754
    cmp       %rax,	1
    jz        L6755
    jmp       L6756
L6752:
    mov       %rdi,	6
    jmp       L6751
L6753:
    mov       %rdi,	5
    jmp       L6751
L6754:
    mov       %rdi,	4
    jmp       L6751
L6755:
    mov       %rdi,	3
L6756:
L6751:
L6750:
    mov       %rax,	%rdi
L6748:
#---------------
    add       %rsp,	16
    pop       %rdi
    ret       
# End 
# Proc cc_lib.addtolog
cc_lib.addtolog:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    mov       %rcx,	%rsi
    lea       %rdx,	[%rip+L9208]
    call      fopen
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L6759
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L9209]
    call      msys.m$print_str_nf
    mov       %rcx,	%rsi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L6757
L6759:
L6760:
    mov       %rcx,	%rdi
    call      fgetc
    movsxd    %r10,	%eax
    mov       %rbx,	%r10
    cmp       %rbx,	-1
    jz        L6761
L6763:
    mov       %rcx,	%rbx
    mov       %rdx,	%r12
    call      fputc
    jmp       L6760
L6761:
    mov       %rcx,	%rdi
    call      fclose
L6757:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.stopcompiler
cc_support.stopcompiler:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %al,	[%rip+cc_cli.fwriteerrors]
    test      %al,	%al
    jz        L6766
    lea       %rcx,	[%rip+L9210]
    lea       %rdx,	[%rip+L9211]
    call      fopen
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    call      msys.m$print_startfile
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    mov       %rcx,	%rsi
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%rdi
    call      fclose
L6766:
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	1
    call      exit
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.mcerror
cc_support.mcerror:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L9212]
    call      msys.m$print_str_nf
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	40
    call      exit
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_support.serror
cc_support.serror:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      cc_support.serror_gen
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_support.serror_gen
cc_support.serror_gen:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	[%rip+cc_decls.currproc]
    test      %rax,	%rax
    jz        L6771
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L9213]
    call      msys.m$print_str_nf
    mov       %rax,	[%rip+cc_decls.currproc]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L9214]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L6770
L6771:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L9215]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L6770:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L9216]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %eax,	[%rax+16]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    lea       %rcx,	[%rip+L9217]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+20]
    lea       %r10,	[%rip+cc_decls.sourcefilepaths]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+20]
    lea       %r10,	[%rip+cc_decls.sourcefilenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      cc_support.showmacrolineno
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L9218]
    call      msys.m$print_str_nf
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L9219]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %eax,	[%rax+16]
    lea       %r10,	[%rip+cc_decls.lx]
    movzx     %r10,	byte ptr[%r10+20]
    lea       %r11,	[%rip+cc_decls.sourcefilepaths]
    mov       %r11,	[%r11 + %r10*8]
    mov       %rcx,	%r11
    mov       %rdx,	%rax
    call      cc_support.stopcompiler
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_support.serror_ss
cc_support.serror_ss:
#?>>
    .set cc_support.serror_ss.str, -256
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	296
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    lea       %rcx,	[%rbp + cc_support.serror_ss.str]
    call      msys.m$print_startstr
    mov       %rcx,	%rdi
    call      msys.m$print_setfmt
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    mov       %rcx,	%rsi
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + cc_support.serror_ss.str]
    call      cc_support.serror_gen
#---------------
    add       %rsp,	296
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.serror_s
cc_support.serror_s:
#?>>
    .set cc_support.serror_s.str, -256
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	288
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    lea       %rcx,	[%rbp + cc_support.serror_s.str]
    call      msys.m$print_startstr
    mov       %rcx,	%rdi
    call      msys.m$print_setfmt
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + cc_support.serror_s.str]
    call      cc_support.serror_gen
#---------------
    add       %rsp,	288
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.terror_gen
cc_support.terror_gen:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rax,	[%rip+cc_decls.currproc]
    test      %rax,	%rax
    jz        L6776
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L9220]
    call      msys.m$print_str_nf
    mov       %rax,	[%rip+cc_decls.currproc]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L6776:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L9221]
    call      msys.m$print_str_nf
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L9222]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %eax,	[%rax+16]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+20]
    lea       %r10,	[%rip+cc_decls.sourcefilepaths]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      cc_support.showmacrolineno
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %eax,	[%rax+16]
    lea       %r10,	[%rip+cc_decls.lx]
    movzx     %r10,	byte ptr[%r10+20]
    lea       %r11,	[%rip+cc_decls.sourcefilepaths]
    mov       %r11,	[%r11 + %r10*8]
    mov       %rcx,	%r11
    mov       %rdx,	%rax
    call      cc_support.stopcompiler
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_support.terror
cc_support.terror:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	%rdi
    call      cc_support.terror_gen
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_support.terror_s
cc_support.terror_s:
#?>>
    .set cc_support.terror_s.str, -256
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	288
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    lea       %rcx,	[%rbp + cc_support.terror_s.str]
    call      msys.m$print_startstr
    mov       %rcx,	%rdi
    call      msys.m$print_setfmt
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + cc_support.terror_s.str]
    call      cc_support.terror_gen
#---------------
    add       %rsp,	288
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.terror_ss
cc_support.terror_ss:
#?>>
    .set cc_support.terror_ss.str, -256
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	296
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    lea       %rcx,	[%rbp + cc_support.terror_ss.str]
    call      msys.m$print_startstr
    mov       %rcx,	%rdi
    call      msys.m$print_setfmt
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    mov       %rcx,	%rsi
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + cc_support.terror_ss.str]
    call      cc_support.terror_gen
#---------------
    add       %rsp,	296
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.gerror_gen
cc_support.gerror_gen:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
    test      %r12,	%r12
    jz        L6782
    mov       %eax,	[%r12+44]
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%r12+60]
    mov       %rbx,	%rax
    jmp       L6781
L6782:
    mov       %rdi,	[%rip+cc_decls.clineno]
    mov       %rbx,	[%rip+cc_decls.cfileno]
L6781:
    mov       %rax,	[%rip+cc_decls.currproc]
    test      %rax,	%rax
    jz        L6784
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L9223]
    call      msys.m$print_str_nf
    mov       %rax,	[%rip+cc_decls.currproc]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L9224]
    call      msys.m$print_str_nf
    call      msys.m$print_end
L6784:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L9225]
    call      msys.m$print_str_nf
    mov       %rax,	%rdi
    and       %rax,	16777215
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    lea       %rcx,	[%rip+L9226]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.sourcefilepaths]
    mov       %r10,	%rbx
    mov       %rcx,	[%rax + %r10*8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L9227]
    call      msys.m$print_str_nf
    mov       %rcx,	%rsi
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L9228]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rax,	[%rip+cc_decls.sourcefilepaths]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8]
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    call      cc_support.stopcompiler
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.gerror
cc_support.gerror:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      cc_support.gerror_gen
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.gerror_s
cc_support.gerror_s:
#?>>
    .set cc_support.gerror_s.str, -256
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	296
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
    lea       %rcx,	[%rbp + cc_support.gerror_s.str]
    call      msys.m$print_startstr
    mov       %rcx,	%rdi
    call      msys.m$print_setfmt
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + cc_support.gerror_s.str]
    mov       %rdx,	%rsi
    call      cc_support.gerror_gen
#---------------
    add       %rsp,	296
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.nextpoweroftwo
cc_support.nextpoweroftwo:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	16
#---------------
    test      %rcx,	%rcx
    jnz       L6789
    xor       %eax,	%eax
    jmp       L6787
L6789:
    mov       %rdi,	1
    jmp       L6791
L6790:
    shl       %rdi,	1
L6791:
    cmp       %rdi,	%rcx
    jl        L6790
    mov       %rax,	%rdi
L6787:
#---------------
    add       %rsp,	16
    pop       %rdi
    ret       
# End 
# Proc cc_support.loaderror
cc_support.loaderror:
#?>>
    .set cc_support.loaderror.str, -512
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	544
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    lea       %rcx,	[%rbp + cc_support.loaderror.str]
    call      msys.m$print_startstr
    mov       %rcx,	%rdi
    call      msys.m$print_setfmt
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L9229]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rbp + cc_support.loaderror.str]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L9230]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	45
    call      exit
#---------------
    add       %rsp,	544
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.loadsourcefile
cc_support.loadsourcefile:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rax,	[%rip+cc_decls.nsourcefiles]
    cmp       %rax,	200
    jle       L6796
    lea       %rcx,	[%rip+L9231]
    lea       %rdx,	[%rip+L9232]
    call      cc_support.loaderror
L6796:
    inc       qword ptr[%rip+cc_decls.nsourcefiles]
    mov       %rcx,	%rbx
    call      mlib.pcm_copyheapstring
    lea       %r10,	[%rip+cc_decls.sourcefilepaths]
    mov       %r11,	[%rip+cc_decls.nsourcefiles]
    mov       [%r10 + %r11*8],	%rax
    mov       %rcx,	%rsi
    call      mlib.pcm_copyheapstring
    lea       %r10,	[%rip+cc_decls.sourcefilenames]
    mov       %r11,	[%rip+cc_decls.nsourcefiles]
    mov       [%r10 + %r11*8],	%rax
    mov       %rcx,	%rbx
    call      mlib.readfile
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L6798
    lea       %rcx,	[%rip+L9233]
    mov       %rdx,	%rbx
    call      cc_support.loaderror
L6798:
    mov       %rax,	%rdi
    lea       %r10,	[%rip+cc_decls.sourcefiletext]
    mov       %r11,	[%rip+cc_decls.nsourcefiles]
    mov       [%r10 + %r11*8],	%rax
    mov       %eax,	[%rip+mlib.rfsize]
    lea       %r10,	[%rip+cc_decls.sourcefilesizes]
    mov       %r11,	[%rip+cc_decls.nsourcefiles]
    mov       [%r10 + %r11*4],	%eax
    xor       %eax,	%eax
    mov       %r10,	[%rip+mlib.rfsize]
    mov       [%rdi + %r10],	%al
    mov       %rax,	[%rip+cc_decls.nsourcefiles]
L6794:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.splicelines
cc_support.splicelines:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    mov       %rcx,	%rsi
    call      strlen
    inc       %rax
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       %rbx,	%rax
    mov       %rdi,	%rax
    jmp       L6801
L6800:
    movzx     %rax,	byte ptr[%rsi]
    cmp       %rax,	92
    jnz       L6804
    movzx     %rax,	byte ptr[%rsi+1]
    cmp       %rax,	10
    jnz       L6804
    add       %rsi,	2
    jmp       L6803
L6804:
    movzx     %rax,	byte ptr[%rsi]
    cmp       %rax,	92
    jnz       L6805
    movzx     %rax,	byte ptr[%rsi+1]
    cmp       %rax,	13
    jnz       L6805
    movzx     %rax,	byte ptr[%rsi+2]
    cmp       %rax,	10
    jnz       L6805
    add       %rsi,	3
    jmp       L6803
L6805:
    mov       %rax,	%rsi
    inc       %rsi
    mov       %al,	[%rax]
    mov       %r10,	%rdi
    inc       %rdi
    mov       [%r10],	%al
L6803:
    xor       %eax,	%eax
    mov       [%rdi],	%al
L6801:
    mov       %al,	[%rsi]
    test      %al,	%al
    jnz       L6800
    mov       %rax,	%rbx
L6799:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.loadbuiltin
cc_support.loadbuiltin:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %rax,	[%rip+cc_decls.nsourcefiles]
    cmp       %rax,	200
    jle       L6808
    lea       %rcx,	[%rip+L9234]
    lea       %rdx,	[%rip+L9235]
    call      cc_support.loaderror
L6808:
    inc       qword ptr[%rip+cc_decls.nsourcefiles]
    lea       %rax,	[%rip+L9236]
    lea       %r10,	[%rip+cc_decls.sourcefilepaths]
    mov       %r11,	[%rip+cc_decls.nsourcefiles]
    mov       [%r10 + %r11*8],	%rax
    mov       %rcx,	%rdi
    call      mlib.pcm_copyheapstring
    lea       %r10,	[%rip+cc_decls.sourcefilenames]
    mov       %r11,	[%rip+cc_decls.nsourcefiles]
    mov       [%r10 + %r11*8],	%rax
    mov       %rcx,	%rbx
    call      mlib.pcm_copyheapstring
    lea       %r10,	[%rip+cc_decls.sourcefiletext]
    mov       %r11,	[%rip+cc_decls.nsourcefiles]
    mov       [%r10 + %r11*8],	%rax
    mov       %rcx,	%rbx
    call      strlen
    lea       %r10,	[%rip+cc_decls.sourcefilesizes]
    mov       %r11,	[%rip+cc_decls.nsourcefiles]
    mov       [%r10 + %r11*4],	%eax
    mov       %rax,	[%rip+cc_decls.nsourcefiles]
L6806:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.gs_copytostr
cc_support.gs_copytostr:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
    mov       %eax,	[%rdi+8]
    test      %eax,	%eax
    jz        L6811
    movsxd    %rax,	dword ptr[%rdi+8]
    mov       %r10,	[%rdi]
    mov       %rcx,	%rbx
    mov       %rdx,	%r10
    mov       %r8,	%rax
    call      memcpy
    movsxd    %rax,	dword ptr[%rdi+8]
    xor       %r10d,	%r10d
    mov       [%rbx + %rax],	%r10b
    jmp       L6810
L6811:
    xor       %eax,	%eax
    mov       [%rbx],	%al
L6810:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.gs_additem
cc_support.gs_additem:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r12,	%rcx
    mov       %r13,	%rdx
#---------------
    mov       %rdi,	[%r12]
    mov       %eax,	[%r12+8]
    test      %eax,	%eax
    jz        L6814
    movsxd    %rax,	dword ptr[%r12+8]
    lea       %r10,	[%rdi + %rax]
    sub       %r10,	1
    movzx     %r10,	byte ptr[%r10]
    mov       %rbx,	%r10
    movzx     %rax,	byte ptr[%r13]
    mov       %rsi,	%rax
    mov       %rcx,	%rbx
    call      cc_support.isalphanum
    test      %rax,	%rax
    jz        L6816
    mov       %rcx,	%rsi
    call      cc_support.isalphanum
    test      %rax,	%rax
    jz        L6816
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9237]
    mov       %r8,	-1
    call      mlib.strbuffer_add
L6816:
L6814:
    mov       %rcx,	%r12
    mov       %rdx,	%r13
    mov       %r8,	-1
    call      mlib.strbuffer_add
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.isalphanum
cc_support.isalphanum:
#?>>
#?]]
#---------------
    cmp       %rcx,	65
    jl        L6821
    cmp       %rcx,	90
    jle       L6820
L6821:
    cmp       %rcx,	97
    jl        L6822
    cmp       %rcx,	122
    jle       L6820
L6822:
    cmp       %rcx,	48
    jl        L6819
    cmp       %rcx,	57
    jg        L6819
L6820:
    mov       %rax,	1
    jmp       L6817
L6819:
    xor       %eax,	%eax
L6817:
#---------------
    ret       
# End 
# Proc cc_support.showmacrolineno
cc_support.showmacrolineno:
#?>>
#?]]
#---------------
    mov       %rax,	[%rip+cc_decls.slineno]
    test      %rax,	%rax
    jz        L6825
L6825:
#---------------
    ret       
# End 
# Proc cc_headers.findheader
cc_headers.findheader:
#?>>
    .set cc_headers.findheader.newname, -256
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	296
    mov       %r13,	%rcx
#---------------
    mov       %rcx,	%r13
    mov       %rdx,	92
    call      strchr
    test      %rax,	%rax
    jz        L6828
    mov       %rbx,	%r13
    lea       %rax,	[%rbp + cc_headers.findheader.newname]
    mov       %rsi,	%rax
    jmp       L6830
L6829:
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	92
    jnz       L6833
    mov       %rax,	%rsi
    inc       %rsi
    mov       %r10b,	47
    mov       [%rax],	%r10b
    jmp       L6832
L6833:
    mov       %al,	[%rbx]
    mov       %r10,	%rsi
    inc       %rsi
    mov       [%r10],	%al
L6832:
    inc       %rbx
L6830:
    mov       %al,	[%rbx]
    test      %al,	%al
    jnz       L6829
    xor       %eax,	%eax
    mov       [%rsi],	%al
    lea       %rax,	[%rbp + cc_headers.findheader.newname]
    mov       %r13,	%rax
L6828:
    mov       %rdi,	1
    mov       %r12,	40
    cmp       %r12,	1
    jl        L6836
L6834:
    lea       %rax,	[%rip+cc_headers.stdhdrnames]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rcx,	%r13
    mov       %rdx,	%rax
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L6838
    lea       %rax,	[%rip+cc_headers.stdhdrtext]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rax,	[%rax]
    jmp       L6826
L6838:
    inc       %rdi
    cmp       %rdi,	%r12
    jle       L6834
L6836:
    xor       %eax,	%eax
L6826:
#---------------
    add       %rsp,	296
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_headers.writeheaders
cc_headers.writeheaders:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
#---------------
    mov       %rsi,	1
    mov       %r12,	40
    cmp       %r12,	1
    jl        L6842
L6840:
    lea       %rax,	[%rip+cc_headers.stdhdrnames]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L9238]
    call      mlib.changeext
    mov       %rbx,	%rax
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L9239]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_headers.stdhdrnames]
    mov       %r10,	%rsi
    mov       %rcx,	[%rax + %r10*8-8]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L9240]
    call      msys.m$print_str_nf
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%rbx
    lea       %rdx,	[%rip+L9241]
    call      fopen
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_headers.stdhdrtext]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    call      strlen
    lea       %r10,	[%rip+cc_headers.stdhdrtext]
    mov       %r11,	%rsi
    mov       %r10,	[%r10 + %r11*8-8]
    mov       %r10,	[%r10]
    mov       %rcx,	%r10
    mov       %rdx,	1
    mov       %r8,	%rax
    mov       %r9,	%rdi
    call      fwrite
    mov       %rcx,	%rdi
    call      fclose
    inc       %rsi
    cmp       %rsi,	%r12
    jle       L6840
L6842:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_headers.isheaderfile
cc_headers.isheaderfile:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
    mov       %rbx,	1
    mov       %rdi,	40
    cmp       %rdi,	1
    jl        L6846
L6844:
    lea       %rax,	[%rip+cc_headers.stdhdrnames]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rcx,	%rax
    mov       %rdx,	%rsi
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L6848
    mov       %rax,	1
    jmp       L6843
L6848:
    inc       %rbx
    cmp       %rbx,	%rdi
    jle       L6844
L6846:
    xor       %eax,	%eax
L6843:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_show.printcode
cc_show.printcode:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
    mov       %rcx,	%rbx
    call      msys.m$print_startfile
    mov       %rcx,	%rsi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rax,	[%rip+cc_decls.stmodule]
    mov       %rdi,	[%rax+16]
    jmp       L6851
L6850:
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	6
    jnz       L6855
L6854:
    mov       %rax,	[%rdi+72]
    test      %rax,	%rax
    jz        L6857
    mov       %rcx,	%rbx
    call      msys.m$print_startfile
    mov       %rcx,	[%rdi]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L9242]
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rdi+110]
    lea       %r10,	[%rip+cc_tables.scopenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rax,	[%rdi+72]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    lea       %r9,	[%rip+L9243]
    call      cc_show.printunit
    mov       %rcx,	%rbx
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
L6857:
L6855:
L6853:
    mov       %rdi,	[%rdi+32]
L6851:
    test      %rdi,	%rdi
    jnz       L6850
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_show.printunit
cc_show.printunit:
#?>>
    .set cc_show.printunit.level, 80
    .set cc_show.printunit.prefix, 88
    .set cc_show.printunit.idname, -8
    .set cc_show.printunit.pc, -16
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       [%rbp+80],	%r8
    mov       [%rbp+88],	%r9
#---------------
    test      %r14,	%r14
    jnz       L6860
    jmp       L6858
L6860:
    movsxd    %rax,	dword ptr[%r14+40]
    cmp       %rax,	77
    jl        L6862
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L9244]
    call      msys.m$print_str_nf
    movsxd    %rax,	dword ptr[%r14+40]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	30
    call      exit
L6862:
    mov       %eax,	[%r14+44]
    test      %eax,	%eax
    jz        L6864
    mov       %eax,	[%r14+44]
    mov       [%rip+cc_show.currlineno],	%rax
    movzx     %rax,	byte ptr[%r14+60]
    mov       [%rip+cc_show.currfileno],	%rax
L6864:
    mov       %r12,	1
    mov       %rax,	[%rbp + cc_show.printunit.level]
    cmp       %rax,	0
    jge       L6866
    mov       %r12,	-1
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9245]
    call      msys.m$print_str_nf
    call      msys.m$print_end
L6866:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    mov       %rax,	[%rbp + cc_show.printunit.level]
    cmp       %rax,	0
    jge       L9246
    neg       %rax
L9246:
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + cc_show.printunit.prefix]
    mov       %r8,	%r14
    call      cc_show.getprefix
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
    movsxd    %rax,	dword ptr[%r14+40]
    lea       %r10,	[%rip+cc_tables.jtagnames]
    mov       %r10,	[%r10 + %rax*8]
    mov       [%rbp + cc_show.printunit.idname],	%r10
    mov       %rax,	[%rbp + cc_show.printunit.idname]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	106
    jnz       L6868
    inc       qword ptr[%rbp + cc_show.printunit.idname]
L6868:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    mov       %rcx,	[%rbp + cc_show.printunit.idname]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L9247]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    movsxd    %rax,	dword ptr[%r14+40]
    cmp       %rax,	3
    jz        L6870
    cmp       %rax,	5
    jz        L6870
    cmp       %rax,	7
    jz        L6871
    cmp       %rax,	8
    jz        L6871
    cmp       %rax,	16
    jz        L6871
    cmp       %rax,	16
    jz        L6872
    cmp       %rax,	17
    jz        L6873
    cmp       %rax,	18
    jz        L6874
    cmp       %rax,	1
    jz        L6875
    cmp       %rax,	56
    jz        L6876
    cmp       %rax,	57
    jz        L6877
    cmp       %rax,	53
    jz        L6878
    cmp       %rax,	54
    jz        L6878
    cmp       %rax,	22
    jz        L6879
    cmp       %rax,	30
    jz        L6880
    cmp       %rax,	52
    jz        L6881
    cmp       %rax,	49
    jz        L6882
    jmp       L6883
L6870:
    mov       %rdi,	[%r14]
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    mov       %rcx,	[%rdi]
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rdi+109]
    lea       %r10,	[%rip+cc_tables.namenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       %rax,	[%rdi+72]
    test      %rax,	%rax
    jz        L6885
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9248]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       %rax,	[%rdi+72]
    movsxd    %rax,	dword ptr[%rax+40]
    lea       %r10,	[%rip+cc_tables.jtagnames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L9249]
    call      msys.m$print_str_nf
    call      msys.m$print_end
L6885:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9250]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       %rcx,	%rdi
    call      cc_show.getdottedname
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       %rax,	[%r14+32]
    test      %rax,	%rax
    jz        L6887
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9251]
    call      msys.m$print_str_nf
    mov       %rcx,	[%r14+32]
    call      msys.m$print_ptr_nf
    call      msys.m$print_end
L6887:
    jmp       L6869
L6871:
    mov       %rdi,	[%r14]
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    mov       %rcx,	[%rdi]
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rdi+109]
    lea       %r10,	[%rip+cc_tables.namenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rax,	[%rbp + cc_show.printunit.level]
    add       %rax,	%r12
    mov       %r10,	[%rdi+72]
    mov       %rcx,	%r13
    mov       %rdx,	%r10
    mov       %r8,	%rax
    lea       %r9,	[%rip+L9252]
    call      cc_show.printunit
    jmp       L6858
L6872:
    mov       %rdi,	[%r14]
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    mov       %rcx,	[%rdi]
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rdi+109]
    lea       %r10,	[%rip+cc_tables.namenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L6869
L6873:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    mov       %rax,	[%r14]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L6869
L6874:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9253]
    call      msys.m$print_str_nf
    mov       %rcx,	[%r14]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L6869
L6875:
    movsxd    %rax,	dword ptr[%r14+52]
    mov       %rbx,	%rax
    cmp       %rbx,	[%rip+cc_decls.trefchar]
    jnz       L6889
    mov       %al,	[%r14+61]
    test      %al,	%al
    jz        L6892
L6891:
#cc_show.printunit.dostring:
L6893:
    movsxd    %rax,	dword ptr[%r14+48]
    cmp       %rax,	256
    jle       L6895
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9254]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L9255]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L9256]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    movsxd    %rax,	dword ptr[%r14+48]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L6894
L6895:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9257]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       %rcx,	[%r14]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L9258]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    movsxd    %rax,	dword ptr[%r14+48]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
L6894:
    jmp       L6888
L6889:
    cmp       %rbx,	[%rip+cc_decls.trefwchar]
    jnz       L6896
    mov       %al,	[%r14+62]
    test      %al,	%al
    jz        L6892
L6898:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9259]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L9260]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L9261]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    movsxd    %rax,	dword ptr[%r14+48]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L6888
L6896:
    cmp       %rbx,	1
    jl        L6899
    cmp       %rbx,	4
    jg        L6899
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    mov       %rcx,	[%r14]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L6888
L6899:
    cmp       %rbx,	6
    jl        L6900
    cmp       %rbx,	9
    jg        L6900
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    mov       %rax,	[%r14]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.m$print_u64
    call      msys.m$print_end
    jmp       L6888
L6900:
    mov       %rcx,	%rbx
    call      cc_lib.isrealcc
    test      %rax,	%rax
    jz        L6901
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    movq      %XMM4,	[%r14]
    movq      %XMM0,	%XMM4
    xor       %edx,	%edx
    call      msys.m$print_r64
    call      msys.m$print_end
    jmp       L6888
L6901:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	13
    jnz       L6902
    mov       %al,	[%r14+61]
    test      %al,	%al
    jnz       L6893
L6904:
#cc_show.printunit.doref:
L6892:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    mov       %rcx,	[%r14]
    call      msys.m$print_ptr_nf
    call      msys.m$print_end
    jmp       L6888
L6902:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jnz       L6905
    mov       %al,	[%r14+61]
    test      %al,	%al
    jnz       L6893
L6907:
    lea       %rcx,	[%rip+L9262]
    call      cc_support.serror
    jmp       L6888
L6905:
    call      msys.m$print_startcon
    mov       %rcx,	%rbx
    call      cc_lib.typename
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L9263]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L6888:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9264]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       %al,	[%r14+61]
    test      %al,	%al
    jz        L6909
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9265]
    call      msys.m$print_str_nf
    call      msys.m$print_end
L6909:
    mov       %al,	[%r14+62]
    test      %al,	%al
    jz        L6911
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9266]
    call      msys.m$print_str_nf
    call      msys.m$print_end
L6911:
    jmp       L6869
L6876:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    movsxd    %rax,	dword ptr[%r14+48]
    lea       %r10,	[%rip+cc_tables.convnames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9267]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    mov       %rax,	[%r14+16]
    movsxd    %rax,	dword ptr[%rax+52]
    mov       %rcx,	%rax
    call      cc_lib.typename
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9268]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    movsx     %rax,	word ptr[%r14+58]
    mov       %rcx,	%rax
    call      cc_lib.typename
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L6869
L6877:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9269]
    call      msys.m$print_str_nf
    movsxd    %rax,	dword ptr[%r14+48]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L6869
L6878:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9270]
    call      msys.m$print_str_nf
    movsxd    %rax,	dword ptr[%r14]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L6869
L6879:
    mov       %rax,	[%r14]
    mov       [%rbp + cc_show.printunit.pc],	%rax
    xor       %rsi,	%rsi
    jmp       L6913
L6912:
    inc       %rsi
    mov       %rax,	[%rbp + cc_show.printunit.pc]
    mov       %rax,	[%rax]
    mov       [%rbp + cc_show.printunit.pc],	%rax
L6913:
    mov       %rax,	[%rbp + cc_show.printunit.pc]
    test      %rax,	%rax
    jnz       L6912
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    mov       %rcx,	[%r14]
    call      msys.m$print_ptr_nf
    mov       %rcx,	%rsi
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L6869
L6880:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9271]
    call      msys.m$print_str_nf
    movsxd    %rax,	dword ptr[%r14+48]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L6869
L6881:
    jmp       L6869
L6882:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9272]
    call      msys.m$print_str_nf
    movsxd    %rax,	dword ptr[%r14]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
L6883:
L6869:
    mov       %ax,	[%r14+56]
    test      %ax,	%ax
    jz        L6916
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9273]
    call      msys.m$print_str_nf
    movsx     %rax,	word ptr[%r14+56]
    mov       %rcx,	%rax
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
L6916:
    mov       %eax,	[%r14+48]
    test      %eax,	%eax
    jz        L6918
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9274]
    call      msys.m$print_str_nf
    movsxd    %rax,	dword ptr[%r14+48]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
L6918:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rax,	[%rbp + cc_show.printunit.level]
    add       %rax,	%r12
    mov       %r10,	[%r14+16]
    mov       %rcx,	%r13
    mov       %rdx,	%r10
    mov       %r8,	%rax
    lea       %r9,	[%rip+L9275]
    call      cc_show.printunitlist
    mov       %rax,	[%rbp + cc_show.printunit.level]
    add       %rax,	%r12
    mov       %r10,	[%r14+24]
    mov       %rcx,	%r13
    mov       %rdx,	%r10
    mov       %r8,	%rax
    lea       %r9,	[%rip+L9276]
    call      cc_show.printunitlist
    movsxd    %rax,	dword ptr[%r14+40]
    cmp       %rax,	6
    jz        L6920
    mov       %rax,	[%rbp + cc_show.printunit.level]
    add       %rax,	%r12
    mov       %r10,	[%r14+32]
    mov       %rcx,	%r13
    mov       %rdx,	%r10
    mov       %r8,	%rax
    lea       %r9,	[%rip+L9277]
    call      cc_show.printunitlist
L6920:
L6858:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_show.printunitlist
cc_show.printunitlist:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
    mov       %r12,	%r9
#---------------
    test      %rbx,	%rbx
    jnz       L6923
    jmp       L6921
L6923:
    jmp       L6925
L6924:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    mov       %r9,	%r12
    call      cc_show.printunit
    mov       %rbx,	[%rbx+8]
L6925:
    test      %rbx,	%rbx
    jnz       L6924
L6921:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_show.getprefix
cc_show.getprefix:
#?>>
    .set cc_show.getprefix.indentstr, -512
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	544
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
#---------------
    xor       %eax,	%eax
    mov       [%rbp + cc_show.getprefix.indentstr],	%al
    cmp       %r12,	10
    jle       L6929
    mov       %r12,	10
L6929:
    lea       %rcx,	[%rbp + cc_show.getprefix.indentstr]
    lea       %rdx,	[%rip+L9278]
    call      strcpy
    movsxd    %rax,	dword ptr[%r14+52]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      cc_lib.strmode
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    call      strlen
    mov       %rbx,	%rax
    lea       %rcx,	[%rbp + cc_show.getprefix.indentstr]
    call      strlen
    mov       %r10,	%rbx
    cmp       %r10,	%rax
    jge       L6931
    lea       %rcx,	[%rbp + cc_show.getprefix.indentstr]
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      memcpy
    jmp       L6930
L6931:
    lea       %rcx,	[%rbp + cc_show.getprefix.indentstr]
    mov       %rdx,	%rdi
    call      strcpy
L6930:
    mov       %rsi,	%r12
    cmp       %rsi,	0
    jle       L6934
L6932:
    lea       %rcx,	[%rbp + cc_show.getprefix.indentstr]
    lea       %rdx,	[%rip+L9279]
    call      strcat
    dec       %rsi
    jnz       L6932
L6934:
    call      cc_show.getlineinfok
    lea       %rcx,	[%rip+cc_show.getprefix.str]
    mov       %rdx,	%rax
    call      strcpy
    lea       %rcx,	[%rip+cc_show.getprefix.str]
    lea       %rdx,	[%rbp + cc_show.getprefix.indentstr]
    call      strcat
    lea       %rcx,	[%rip+cc_show.getprefix.str]
    mov       %rdx,	%r13
    call      strcat
    mov       %al,	[%r13]
    test      %al,	%al
    jz        L6936
    lea       %rcx,	[%rip+cc_show.getprefix.str]
    lea       %rdx,	[%rip+L9280]
    call      strcat
L6936:
    lea       %rax,	[%rip+cc_show.getprefix.str]
L6927:
#---------------
    add       %rsp,	544
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_show.getdottedname
cc_show.getdottedname:
#?>>
    .set cc_show.getdottedname.str2, -256
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	288
    mov       %rbx,	%rcx
#---------------
    mov       %rax,	[%rbx]
    lea       %rcx,	[%rip+cc_show.getdottedname.str]
    mov       %rdx,	%rax
    call      strcpy
    mov       %rdi,	[%rbx+8]
    jmp       L6939
L6938:
    lea       %rcx,	[%rbp + cc_show.getdottedname.str2]
    lea       %rdx,	[%rip+cc_show.getdottedname.str]
    call      strcpy
    mov       %rax,	[%rdi]
    lea       %rcx,	[%rip+cc_show.getdottedname.str]
    mov       %rdx,	%rax
    call      strcpy
    lea       %rcx,	[%rip+cc_show.getdottedname.str]
    lea       %rdx,	[%rip+L9281]
    call      strcat
    lea       %rcx,	[%rip+cc_show.getdottedname.str]
    lea       %rdx,	[%rbp + cc_show.getdottedname.str2]
    call      strcat
    mov       %rdi,	[%rdi+8]
L6939:
    test      %rdi,	%rdi
    jz        L6941
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	2
    jnz       L6938
L6941:
    mov       %ax,	[%rbx+96]
    test      %ax,	%ax
    jz        L6943
    lea       %rcx,	[%rbp + cc_show.getdottedname.str2]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L9281]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    movzx     %rax,	word ptr[%rbx+96]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rcx,	[%rip+cc_show.getdottedname.str]
    lea       %rdx,	[%rbp + cc_show.getdottedname.str2]
    call      strcat
L6943:
    lea       %rax,	[%rip+cc_show.getdottedname.str]
L6937:
#---------------
    add       %rsp,	288
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_show.getlineinfok
cc_show.getlineinfok:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    lea       %rcx,	[%rip+cc_show.getlineinfok.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L9282]
    call      msys.m$print_setfmt
    mov       %rcx,	[%rip+cc_show.currfileno]
    call      msys.m$print_i64_nf
    mov       %rcx,	[%rip+cc_show.currlineno]
    lea       %rdx,	[%rip+L9283]
    call      msys.m$print_i64
    call      msys.m$print_space
    call      msys.m$print_end
    lea       %rax,	[%rip+cc_show.getlineinfok.str]
L6944:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_show.printst
cc_show.printst:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
    movzx     %rax,	byte ptr[%rsi+107]
    cmp       %rax,	67
    jz        L6947
    lea       %rcx,	[%rip+L9284]
    call      cc_support.mcerror
L6947:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      cc_show.printstrec
    mov       %rdi,	[%rsi+16]
    jmp       L6949
L6948:
    lea       %rax,	[%r12+1]
    mov       %rcx,	%rbx
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      cc_show.printst
    mov       %rdi,	[%rdi+32]
L6949:
    test      %rdi,	%rdi
    jnz       L6948
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_show.printstrec
cc_show.printstrec:
#?>>
    .set cc_show.printstrec.p, 72
    .set cc_show.printstrec.level, 80
    .set cc_show.printstrec.v, -16
    .set cc_show.printstrec.str, -272
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	304
    mov       %r14,	%rcx
    mov       [%rbp+72],	%rdx
    mov       [%rbp+80],	%r8
#---------------
    lea       %rax,	[%rbp + cc_show.printstrec.v]
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    call      mlib.gs_init
    xor       %rsi,	%rsi
    mov       %rax,	[%rbp + cc_show.printstrec.level]
    mov       %r13,	%rax
    cmp       %r13,	0
    jle       L6954
L6952:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L9285]
    call      mlib.gs_str
    mov       %rax,	4
    add       %rsi,	%rax
    dec       %r13
    jnz       L6952
L6954:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L9286]
    call      mlib.gs_str
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %ax,	[%rax+96]
    test      %ax,	%ax
    jz        L6956
    lea       %rcx,	[%rbp + cc_show.printstrec.str]
    call      msys.m$print_startstr
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L9287]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movzx     %rax,	word ptr[%rax+96]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    mov       %rax,	28
    sub       %rax,	%rsi
    mov       %rcx,	%rdi
    lea       %rdx,	[%rbp + cc_show.printstrec.str]
    mov       %r8,	%rax
    mov       %r9,	45
    call      mlib.gs_leftstr
    jmp       L6955
L6956:
    mov       %rax,	28
    sub       %rax,	%rsi
    mov       %r10,	[%rbp + cc_show.printstrec.p]
    mov       %r10,	[%r10]
    mov       %rcx,	%rdi
    mov       %rdx,	%r10
    mov       %r8,	%rax
    mov       %r9,	45
    call      mlib.gs_leftstr
L6955:
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movzx     %rax,	byte ptr[%rax+109]
    lea       %r10,	[%rip+cc_tables.namenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%rdi
    mov       %rdx,	%r10
    mov       %r8,	12
    mov       %r9,	46
    call      mlib.gs_leftstr
    mov       %rcx,	%rdi
    call      mlib.gs_getcol
    mov       %rbx,	%rax
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L9288]
    call      mlib.gs_str
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movzx     %rax,	byte ptr[%rax+110]
    lea       %r10,	[%rip+cc_tables.scopenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%rdi
    mov       %rdx,	%r10
    call      mlib.gs_str
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L9289]
    call      mlib.gs_str
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movzx     %rax,	byte ptr[%rax+108]
    shr       %eax,	4
    and       %eax,	1
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.strint
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mlib.gs_str
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L9289]
    call      mlib.gs_str
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %al,	[%rax+112]
    test      %al,	%al
    jz        L6958
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L9290]
    call      mlib.gs_str
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movzx     %rax,	byte ptr[%rax+112]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mlib.gs_strint
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L9291]
    call      mlib.gs_str
L6958:
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movzx     %rax,	byte ptr[%rax+108]
    shr       %eax,	1
    and       %eax,	1
    test      %rax,	%rax
    jz        L6960
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L9292]
    call      mlib.gs_str
L6960:
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %al,	[%rax+122]
    test      %al,	%al
    jz        L6962
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L9293]
    call      mlib.gs_str
L6962:
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %al,	[%rax+111]
    test      %al,	%al
    jz        L6964
    lea       %rcx,	[%rbp + cc_show.printstrec.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L9294]
    call      msys.m$print_setfmt
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movzx     %rax,	byte ptr[%rax+111]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    mov       %rcx,	%rdi
    lea       %rdx,	[%rbp + cc_show.printstrec.str]
    call      mlib.gs_str
L6964:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L9295]
    call      mlib.gs_str
    lea       %rax,	[%rbx+10]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    mov       %r8,	61
    call      mlib.gs_padto
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %rax,	[%rax+8]
    test      %rax,	%rax
    jz        L6966
    lea       %rcx,	[%rbp + cc_show.printstrec.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L9296]
    call      msys.m$print_setfmt
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %rax,	[%rax+8]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       %rcx,	%rdi
    lea       %rdx,	[%rbp + cc_show.printstrec.str]
    mov       %r8,	18
    mov       %r9,	32
    call      mlib.gs_leftstr
    jmp       L6965
L6966:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L9297]
    mov       %r8,	18
    mov       %r9,	32
    call      mlib.gs_leftstr
L6965:
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movzx     %rax,	word ptr[%rax+102]
    test      %rax,	%rax
    jnz       L6969
L6968:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L9298]
    call      mlib.gs_str
    jmp       L6967
L6969:
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movzx     %rax,	word ptr[%rax+102]
    mov       %rcx,	%rax
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mlib.gs_strsp
L6967:
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	10
    jz        L6971
    cmp       %rax,	8
    jz        L6972
    cmp       %rax,	9
    jz        L6972
    cmp       %rax,	6
    jz        L6973
    cmp       %rax,	11
    jz        L6974
    cmp       %rax,	7
    jz        L6975
    jmp       L6976
L6971:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L9299]
    call      mlib.gs_str
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movsxd    %rax,	dword ptr[%rax+88]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mlib.gs_strint
    jmp       L6970
L6972:
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %rax,	[%rax+72]
    test      %rax,	%rax
    jz        L6978
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L9300]
    call      mlib.gs_str
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %rax,	[%rax+72]
    mov       %rcx,	%rax
    call      cc_show.strexpr
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mlib.gs_strvar
L6978:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L9301]
    call      mlib.gs_str
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movsxd    %rax,	dword ptr[%rax+88]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mlib.gs_strint
    jmp       L6970
L6973:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L9302]
    call      mlib.gs_str
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movsxd    %rax,	dword ptr[%rax+88]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mlib.gs_strint
    jmp       L6970
L6974:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L9303]
    call      mlib.gs_str
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movsxd    %rax,	dword ptr[%rax+88]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mlib.gs_strint
    jmp       L6970
L6975:
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %rax,	[%rax+72]
    test      %rax,	%rax
    jz        L6980
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L9304]
    call      mlib.gs_str
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %rax,	[%rax+72]
    mov       %rcx,	%rax
    call      cc_show.strexpr
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mlib.gs_strvar
L6980:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L9305]
    call      mlib.gs_str
L6976:
L6970:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L9306]
    call      mlib.gs_str
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L9307]
    call      mlib.gs_str
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %eax,	[%rax+92]
    and       %rax,	16777215
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mlib.gs_strint
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L9308]
    call      mlib.gs_str
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %eax,	[%rax+92]
    sar       %rax,	24
    lea       %r10,	[%rip+cc_decls.sourcefilenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%rdi
    mov       %rdx,	%r10
    call      mlib.gs_str
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	6
    jnz       L6982
    mov       %rcx,	%rdi
    call      mlib.gs_line
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %r12,	[%rax+80]
    jmp       L6984
L6983:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L9309]
    call      mlib.gs_str
    mov       %rax,	[%r12]
    test      %rax,	%rax
    jz        L6987
    mov       %rax,	[%r12]
    mov       %rax,	[%rax]
    jmp       L6986
L6987:
    lea       %rax,	[%rip+L9310]
L6986:
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    mov       %r8,	10
    mov       %r9,	45
    call      mlib.gs_leftstr
    movsx     %rax,	word ptr[%r12+22]
    lea       %r10,	[%rip+cc_tables.pmflagnames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%rdi
    mov       %rdx,	%r10
    call      mlib.gs_str
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L9311]
    call      mlib.gs_str
    movsxd    %rax,	dword ptr[%r12+16]
    mov       %rcx,	%rax
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mlib.gs_str
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L9312]
    call      mlib.gs_str
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %rax,	[%rax+72]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mlib.gs_strint
    mov       %rcx,	%rdi
    call      mlib.gs_line
    mov       %r12,	[%r12+8]
L6984:
    test      %r12,	%r12
    jnz       L6983
L6982:
    mov       %rcx,	%rdi
    mov       %rdx,	%r14
    call      mlib.gs_println
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %rax,	[%rax+72]
    test      %rax,	%rax
    jz        L6989
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	8
    jz        L6991
    cmp       %rax,	7
    jnz       L6992
L6991:
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %rax,	[%rax+72]
    mov       %rcx,	%r14
    mov       %rdx,	%rax
    mov       %r8,	-3
    lea       %r9,	[%rip+L9313]
    call      cc_show.printunit
L6992:
L6990:
L6989:
#---------------
    add       %rsp,	304
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_show.printstflat
cc_show.printstflat:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9314]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    xor       %rdi,	%rdi
    mov       %rax,	[%rip+cc_decls.hstsize]
    dec       %rax
    mov       %rsi,	%rax
    cmp       %rsi,	0
    jl        L6996
L6994:
    mov       %rax,	[%rip+cc_decls.hashtable]
    mov       %r10,	%rdi
    mov       %rbx,	[%rax + %r10*8]
    mov       %rax,	[%rbx]
    test      %rax,	%rax
    jz        L6998
    movzx     %rax,	byte ptr[%rbx+107]
    cmp       %rax,	67
    jz        L7000
    cmp       %rax,	71
    jz        L7000
    cmp       %rax,	68
    jnz       L7001
L7000:
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    mov       %rcx,	%rdi
    call      msys.m$print_i64_nf
    mov       %rcx,	%rbx
    call      msys.m$print_ptr_nf
    lea       %rcx,	[%rip+L9315]
    call      msys.m$print_str_nf
    mov       %rcx,	%rbx
    call      cc_lib.getstname
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rbx+107]
    lea       %r10,	[%rip+cc_tables.symbolnames]
    mov       %r10,	[%r10 + %rax*8-8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rbx+109]
    lea       %r10,	[%rip+cc_tables.namenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rbx,	[%rbx+40]
    jmp       L7003
L7002:
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9316]
    call      msys.m$print_str_nf
    mov       %rcx,	%rbx
    call      msys.m$print_ptr_nf
    mov       %rcx,	%rbx
    call      cc_lib.getstname
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rbx+107]
    lea       %r10,	[%rip+cc_tables.symbolnames]
    mov       %r10,	[%r10 + %rax*8-8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rbx+109]
    lea       %r10,	[%rip+cc_tables.namenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    mov       %rcx,	[%rbx+48]
    call      msys.m$print_ptr_nf
    call      msys.m$print_end
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9317]
    call      msys.m$print_str_nf
    mov       %rax,	[%rbx+8]
    test      %rax,	%rax
    jz        L7006
    mov       %rcx,	[%rbx+8]
    call      cc_lib.getstname
    jmp       L7005
L7006:
    lea       %rax,	[%rip+L9318]
L7005:
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L9319]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rbx,	[%rbx+40]
L7003:
    test      %rbx,	%rbx
    jnz       L7002
L7001:
L6999:
L6998:
    inc       %rdi
    cmp       %rdi,	%rsi
    jle       L6994
L6996:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_show.strexpr
cc_show.strexpr:
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
    mov       %rcx,	[%rip+cc_show.exprstr]
    call      mlib.gs_init
    mov       %rcx,	[%rip+cc_show.exprstr]
    mov       %rdx,	%rdi
    call      cc_show.jeval
    mov       %rax,	[%rip+cc_show.exprstr]
L7007:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_show.jeval
cc_show.jeval:
#?>>
    .set cc_show.jeval.str, -16000
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	16040
    mov       %r12,	%rcx
    mov       %r13,	%rdx
#---------------
    movsxd    %rax,	dword ptr[%r13+40]
    cmp       %rax,	1
    jz        L7010
    cmp       %rax,	3
    jz        L7011
    cmp       %rax,	5
    jz        L7012
    cmp       %rax,	24
    jz        L7013
    cmp       %rax,	25
    jz        L7013
    cmp       %rax,	32
    jz        L7013
    cmp       %rax,	33
    jz        L7013
    cmp       %rax,	34
    jz        L7013
    cmp       %rax,	35
    jz        L7013
    cmp       %rax,	36
    jz        L7013
    cmp       %rax,	37
    jz        L7013
    cmp       %rax,	38
    jz        L7013
    cmp       %rax,	39
    jz        L7013
    cmp       %rax,	40
    jz        L7013
    cmp       %rax,	41
    jz        L7013
    cmp       %rax,	42
    jz        L7013
    cmp       %rax,	43
    jz        L7013
    cmp       %rax,	44
    jz        L7013
    cmp       %rax,	45
    jz        L7013
    cmp       %rax,	46
    jz        L7013
    cmp       %rax,	47
    jz        L7013
    cmp       %rax,	48
    jz        L7013
    cmp       %rax,	61
    jz        L7013
    cmp       %rax,	62
    jz        L7013
    cmp       %rax,	63
    jz        L7013
    cmp       %rax,	64
    jz        L7013
    cmp       %rax,	65
    jz        L7013
    cmp       %rax,	66
    jz        L7013
    cmp       %rax,	67
    jz        L7013
    cmp       %rax,	68
    jz        L7013
    cmp       %rax,	69
    jz        L7013
    cmp       %rax,	70
    jz        L7013
    cmp       %rax,	58
    jz        L7014
    cmp       %rax,	59
    jz        L7014
    cmp       %rax,	60
    jz        L7014
    cmp       %rax,	26
    jz        L7014
    cmp       %rax,	27
    jz        L7014
    cmp       %rax,	30
    jz        L7015
    cmp       %rax,	49
    jz        L7016
    cmp       %rax,	50
    jz        L7017
    cmp       %rax,	28
    jz        L7018
    cmp       %rax,	29
    jz        L7018
    cmp       %rax,	11
    jz        L7019
    cmp       %rax,	31
    jz        L7020
    cmp       %rax,	56
    jz        L7021
    cmp       %rax,	52
    jz        L7022
    cmp       %rax,	6
    jz        L7023
    cmp       %rax,	71
    jz        L7024
    cmp       %rax,	72
    jz        L7025
    cmp       %rax,	73
    jz        L7026
    cmp       %rax,	74
    jz        L7027
    cmp       %rax,	2
    jz        L7028
    cmp       %rax,	57
    jz        L7029
    cmp       %rax,	53
    jz        L7030
    cmp       %rax,	4
    jz        L7031
    jmp       L7032
L7010:
    movsxd    %rax,	dword ptr[%r13+52]
    mov       %rsi,	%rax
    cmp       %rax,	[%rip+cc_decls.trefchar]
    jnz       L7034
    movsxd    %rax,	dword ptr[%r13+48]
    test      %rax,	%rax
    jz        L7037
L7036:
    mov       %al,	[%r13+61]
    test      %al,	%al
    jz        L7037
L7039:
    movsxd    %rax,	dword ptr[%r13+48]
    cmp       %rax,	8000
    jle       L7041
    lea       %rcx,	[%rbp + cc_show.jeval.str]
    lea       %rdx,	[%rip+L9320]
    call      strcpy
    jmp       L7040
L7041:
    mov       %rax,	[%r13]
    mov       %rcx,	%rax
    lea       %rdx,	[%rbp + cc_show.jeval.str]
    call      pc_api.convertstring
L7040:
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9321]
    call      cc_support.gs_additem
    mov       %rcx,	%r12
    lea       %rdx,	[%rbp + cc_show.jeval.str]
    call      cc_support.gs_additem
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9321]
    call      cc_support.gs_additem
    jmp       L7008
L7034:
    cmp       %rsi,	1
    jl        L7042
    cmp       %rsi,	4
    jg        L7042
    mov       %rax,	[%r13]
    mov       %rcx,	%rax
    lea       %rdx,	[%rbp + cc_show.jeval.str]
    call      msys.getstrint
    jmp       L7033
L7042:
    cmp       %rsi,	6
    jl        L7043
    cmp       %rsi,	9
    jg        L7043
    mov       %rax,	[%r13]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.strword
    lea       %rcx,	[%rbp + cc_show.jeval.str]
    mov       %rdx,	%rax
    call      strcpy
    jmp       L7033
L7043:
    cmp       %rsi,	11
    jz        L7045
    cmp       %rsi,	10
    jnz       L7044
L7045:
    movq      %XMM4,	[%r13]
    movq      %XMM0,	%XMM4
    xor       %edx,	%edx
    call      msys.strreal
    lea       %rcx,	[%rbp + cc_show.jeval.str]
    mov       %rdx,	%rax
    call      strcpy
    jmp       L7033
L7044:
    movsxd    %rax,	dword ptr[%r13+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    cmp       %r10,	13
    jz        L7047
    cmp       %r10,	17
    jz        L7048
    jmp       L7049
L7047:
#cc_show.jeval.doref:
L7037:
    lea       %rcx,	[%rbp + cc_show.jeval.str]
    call      msys.m$print_startstr
    mov       %rcx,	[%r13]
    call      msys.m$print_ptr_nf
    call      msys.m$print_end
    jmp       L7046
L7048:
    lea       %rcx,	[%rbp + cc_show.jeval.str]
    lea       %rdx,	[%rip+L9322]
    call      strcpy
    jmp       L7046
L7049:
    call      msys.m$print_startcon
    movsxd    %rax,	dword ptr[%r13+52]
    mov       %rcx,	%rax
    call      cc_lib.typename
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L9323]
    call      mlib.abortprogram
L7046:
L7033:
    mov       %rcx,	%r12
    lea       %rdx,	[%rbp + cc_show.jeval.str]
    call      cc_support.gs_additem
    jmp       L7009
L7011:
    mov       %rax,	[%r13]
    mov       %rax,	[%rax]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_support.gs_additem
    jmp       L7009
L7012:
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9324]
    call      mlib.gs_str
    mov       %rax,	[%r13]
    mov       %rax,	[%rax]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_support.gs_additem
    jmp       L7009
L7013:
    movsxd    %rax,	dword ptr[%r13+40]
    mov       %rcx,	%rax
    call      cc_lib.getopcjname
    lea       %rcx,	[%rbp + cc_show.jeval.str]
    mov       %rdx,	%rax
    call      strcpy
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9325]
    call      cc_support.gs_additem
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rcx,	%r12
    lea       %rdx,	[%rbp + cc_show.jeval.str]
    call      cc_support.gs_additem
    mov       %rax,	[%r13+24]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9326]
    call      cc_support.gs_additem
    jmp       L7009
L7014:
    movsxd    %rax,	dword ptr[%r13+40]
    mov       %rcx,	%rax
    call      cc_lib.getopcjname
    lea       %rcx,	[%rbp + cc_show.jeval.str]
    mov       %rdx,	%rax
    call      strcpy
    mov       %rcx,	%r12
    lea       %rdx,	[%rbp + cc_show.jeval.str]
    call      cc_support.gs_additem
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9327]
    call      cc_support.gs_additem
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9328]
    call      cc_support.gs_additem
    jmp       L7009
L7015:
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9329]
    call      cc_support.gs_additem
    mov       %rdi,	[%r13+24]
    jmp       L7051
L7050:
    mov       %rcx,	%r12
    mov       %rdx,	%rdi
    call      cc_show.jeval
    mov       %rdi,	[%rdi+8]
    test      %rdi,	%rdi
    jz        L7054
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9330]
    call      cc_support.gs_additem
L7054:
L7051:
    test      %rdi,	%rdi
    jnz       L7050
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9331]
    call      cc_support.gs_additem
    jmp       L7009
L7016:
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9332]
    call      cc_support.gs_additem
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9333]
    call      mlib.gs_str
    jmp       L7009
L7017:
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9334]
    call      cc_support.gs_additem
    mov       %rax,	[%r13+24]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    jmp       L7009
L7018:
    movsxd    %rax,	dword ptr[%r13+40]
    cmp       %rax,	29
    setz      %al
    movzx     %eax,	%al
    mov       %rbx,	%rax
    test      %rbx,	%rbx
    jz        L7056
    lea       %rax,	[%rip+L9335]
    jmp       L7055
L7056:
    lea       %rax,	[%rip+L9336]
L7055:
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_support.gs_additem
    mov       %rdi,	[%r13+16]
    jmp       L7058
L7057:
    mov       %rcx,	%r12
    mov       %rdx,	%rdi
    call      cc_show.jeval
    mov       %rdi,	[%rdi+8]
    test      %rdi,	%rdi
    jz        L7061
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9337]
    call      cc_support.gs_additem
L7061:
L7058:
    test      %rdi,	%rdi
    jnz       L7057
    test      %rbx,	%rbx
    jz        L7063
    lea       %rax,	[%rip+L9338]
    jmp       L7062
L7063:
    lea       %rax,	[%rip+L9339]
L7062:
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_support.gs_additem
    jmp       L7009
L7019:
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9340]
    call      cc_support.gs_additem
    mov       %rax,	[%r13+24]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    jmp       L7009
L7020:
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9341]
    call      cc_support.gs_additem
    mov       %rax,	[%r13+24]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9342]
    call      cc_support.gs_additem
    mov       %rax,	[%r13+32]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    jmp       L7009
L7021:
    movsxd    %rax,	dword ptr[%r13+52]
    mov       %rcx,	%rax
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_support.gs_additem
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9343]
    call      cc_support.gs_additem
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9344]
    call      cc_support.gs_additem
    jmp       L7009
L7022:
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9345]
    call      cc_support.gs_additem
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rax,	[%r13+24]
    test      %rax,	%rax
    jz        L7065
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9346]
    call      cc_support.gs_additem
    mov       %rax,	[%r13+24]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
L7065:
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9347]
    call      cc_support.gs_additem
    jmp       L7009
L7023:
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9348]
    call      cc_support.gs_additem
    jmp       L7009
L7024:
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9349]
    call      cc_support.gs_additem
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    jmp       L7009
L7025:
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9350]
    call      cc_support.gs_additem
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    jmp       L7009
L7026:
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9351]
    call      cc_support.gs_additem
    jmp       L7009
L7027:
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9352]
    call      cc_support.gs_additem
    jmp       L7009
L7028:
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9353]
    call      mlib.gs_str
    jmp       L7009
L7029:
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9354]
    call      mlib.gs_str
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    movsxd    %rax,	dword ptr[%r13+48]
    cmp       %rax,	0
    jle       L7067
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9355]
    call      mlib.gs_str
    movsxd    %rax,	dword ptr[%r13+48]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      mlib.gs_strint
    jmp       L7066
L7067:
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9356]
    call      mlib.gs_str
    movsxd    %rax,	dword ptr[%r13+48]
    neg       %rax
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      mlib.gs_strint
L7066:
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9357]
    call      mlib.gs_str
    jmp       L7009
L7030:
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9358]
    call      mlib.gs_str
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9359]
    call      mlib.gs_str
    mov       %rax,	[%r13+24]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9360]
    call      mlib.gs_str
    jmp       L7009
L7031:
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    jmp       L7009
L7032:
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9361]
    call      mlib.gs_str
L7009:
L7008:
#---------------
    add       %rsp,	16040
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_show.printfilelist
cc_show.printfilelist:
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
    mov       %rcx,	%rbx
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9362]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+cc_decls.nsourcefiles]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rdi,	1
    mov       %rax,	[%rip+cc_decls.nsourcefiles]
    cmp       %rax,	1
    jl        L7071
L7069:
    mov       %rcx,	%rbx
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9363]
    call      msys.m$print_setfmt
    mov       %rcx,	%rdi
    call      msys.m$print_i64_nf
    lea       %rax,	[%rip+cc_decls.sourcefilenames]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L9364]
    call      msys.m$print_str
    lea       %rax,	[%rip+cc_decls.sourcefilepaths]
    mov       %r10,	%rdi
    mov       %rcx,	[%rax + %r10*8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    inc       %rdi
    cmp       %rdi,	[%rip+cc_decls.nsourcefiles]
    jle       L7069
L7071:
    mov       %rcx,	%rbx
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9365]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+cc_decls.inputfile]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%rbx
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9366]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+cc_decls.nlibfiles]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rdi,	1
    mov       %rax,	[%rip+cc_decls.nlibfiles]
    cmp       %rax,	1
    jl        L7074
L7072:
    mov       %rcx,	%rbx
    call      msys.m$print_startfile
    mov       %rcx,	%rdi
    call      msys.m$print_i64_nf
    lea       %rax,	[%rip+cc_decls.libfiles]
    mov       %r10,	%rdi
    mov       %rcx,	[%rax + %r10*8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    inc       %rdi
    cmp       %rdi,	[%rip+cc_decls.nlibfiles]
    jle       L7072
L7074:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_show.printmodelist
cc_show.printmodelist:
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9367]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+cc_decls.ntypes]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    xor       %rdi,	%rdi
    mov       %rax,	[%rip+cc_decls.ntypes]
    cmp       %rax,	0
    jl        L7078
L7076:
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L9368]
    call      msys.m$print_i64
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rbx,	%rax
    lea       %rax,	[%rip+cc_decls.tttypedef]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    test      %rax,	%rax
    jz        L7080
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9369]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L9370]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.tttypedef]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L7080:
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9371]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L9372]
    call      msys.m$print_str_nf
    mov       %rcx,	%rbx
    call      msys.m$print_i64_nf
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9373]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L9374]
    call      msys.m$print_str_nf
    mov       %rcx,	%rdi
    call      cc_lib.typename
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rax,	[%rip+cc_decls.ttnamedef]
    mov       %r10,	%rdi
    mov       %rsi,	[%rax + %r10*8]
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9375]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L9376]
    call      msys.m$print_str_nf
    mov       %rcx,	%rsi
    call      msys.m$print_ptr_nf
    call      msys.m$print_space
    call      msys.m$print_end
    test      %rsi,	%rsi
    jz        L7082
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    mov       %rcx,	[%rsi]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L9377]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    movzx     %rax,	word ptr[%rsi+96]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L7081
L7082:
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9378]
    call      msys.m$print_str_nf
    call      msys.m$print_end
L7081:
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9379]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L9380]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rcx,	%rax
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9381]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L9382]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rdi
    mov       %rcx,	[%rax + %r10*8]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9383]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L9384]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%rdi
    mov       %rcx,	[%rax + %r10*8]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9385]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L9386]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.ttisblock]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9387]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L9388]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.ttconst]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9389]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L9390]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.ttsigned]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9391]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L9392]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.ttreftype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9393]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L9394]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.ttconsttype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rcx,	%rax
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9395]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L9396]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.ttshared]
    mov       %r10,	%rdi
    movsxd    %rax,	dword ptr[%rax + %r10*4]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
    inc       %rdi
    cmp       %rdi,	[%rip+cc_decls.ntypes]
    jle       L7076
L7078:
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msyswin.start
msyswin.start:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    call      msys.start
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc pepcl.start
pepcl.start:
#?>>
#?]]
    sub       %rsp,	40
#---------------
    call      mc_decls.start
    call      mc_writegas.start
#---------------
    add       %rsp,	40
    ret       
# End 
    .data
$procaddr:
    .quad     mc_genmcl.px_nop
    .quad     mc_genmcl.px_dupl
    .quad     mc_genmcl.px_double
    .quad     mc_genmcl.px_opnd
    .quad     mc_genmcl.px_type
    .quad     mc_genmcl.px_comment
    .quad     mc_genmcl.px_proc
    .quad     mc_genmcl.px_endproc
    .quad     mc_genmcl.px_endprog
    .quad     mc_genmcl.px_istatic
    .quad     mc_genmcl.px_zstatic
    .quad     mc_genmcl.px_data
    .quad     mc_genmcl.px_label
    .quad     mc_genmcl.px_load
    .quad     mc_genmcl.px_store
    .quad     mc_genmcl.px_add
    .quad     mc_genmcl.px_sub
    .quad     mc_genmcl.px_mul
    .quad     mc_genmcl.px_div
    .quad     mc_genmcl.px_eval
    .quad     mc_genmcl.px_widen
    .quad     mc_genmcl.px_jump
    .quad     mc_genmcl.px_ijump
    .quad     mc_genmcl.px_neg
    .quad     mc_genmcl.px_abs
    .quad     mc_genmcl.px_bitnot
    .quad     mc_genmcl.px_not
    .quad     mc_genmcl.px_toboolt
    .quad     mc_genmcl.px_sqr
    .quad     mc_genmcl.px_sqrt
    .quad     mc_genmcl.px_jumpcc
    .quad     mc_genmcl.px_jumpt
    .quad     mc_genmcl.px_jumpf
    .quad     mc_genmcl.px_bitand
    .quad     mc_genmcl.px_bitor
    .quad     mc_genmcl.px_bitxor
    .quad     mc_genmcl.px_shl
    .quad     mc_genmcl.px_shr
    .quad     mc_genmcl.px_retproc
    .quad     mc_genmcl.px_retfn
    .quad     mc_genmcl.px_setcall
    .quad     mc_genmcl.px_setarg
    .quad     mc_genmcl.px_callp
    .quad     mc_genmcl.px_jumpret
    .quad     mc_genmcl.px_jumpretm
    .quad     mc_genmcl.px_startmx
    .quad     mc_genmcl.px_resetmx
    .quad     mc_genmcl.px_stop
    .quad     mc_genmcl.px_incrto
    .quad     mc_genmcl.px_decrto
    .quad     mc_genmcl.px_incrload
    .quad     mc_genmcl.px_decrload
    .quad     mc_genmcl.px_loadincr
    .quad     mc_genmcl.px_loaddecr
    .quad     mc_genmcl.px_forup
    .quad     mc_genmcl.px_fordown
    .quad     mc_genmcl.px_iload
    .quad     mc_genmcl.px_iloadx
    .quad     mc_genmcl.px_istore
    .quad     mc_genmcl.px_istorex
    .quad     mc_genmcl.px_storem
    .quad     mc_genmcl.px_addpx
    .quad     mc_genmcl.px_subpx
    .quad     mc_genmcl.px_to
    .quad     mc_genmcl.px_iswap
    .quad     mc_genmcl.px_swapstk
    .quad     mc_genmcl.px_labeldef
    .quad     mc_genmcl.px_addto
    .quad     mc_genmcl.px_subto
    .quad     mc_genmcl.px_multo
    .quad     mc_genmcl.px_bitandto
    .quad     mc_genmcl.px_bitorto
    .quad     mc_genmcl.px_bitxorto
    .quad     mc_genmcl.px_shlto
    .quad     mc_genmcl.px_shrto
    .quad     mc_genmcl.px_fix
    .quad     mc_genmcl.px_float
    .quad     mc_genmcl.px_idiv
    .quad     mc_genmcl.px_irem
    .quad     mc_genmcl.px_idivrem
    .quad     mc_genmcl.px_clear
    .quad     mc_genmcl.px_subp
    .quad     mc_genmcl.px_switch
    .quad     mc_genmcl.px_switchu
    .quad     mc_genmcl.px_swlabel
    .quad     mc_genmcl.px_endsw
    .quad     mc_genmcl.px_fwiden
    .quad     mc_genmcl.px_fnarrow
    .quad     mc_genmcl.px_truncate
    .quad     mc_genmcl.px_typepun
    .quad     mc_genmcl.px_unload
    .quad     mc_genmcl.px_loadbit
    .quad     mc_genmcl.px_assem
    .quad     mc_genmcl.px_sin
    .quad     mc_genmcl.px_cos
    .quad     mc_genmcl.px_tan
    .quad     mc_genmcl.px_asin
    .quad     mc_genmcl.px_acos
    .quad     mc_genmcl.px_atan
    .quad     mc_genmcl.px_log
    .quad     mc_genmcl.px_log10
    .quad     mc_genmcl.px_exp
    .quad     mc_genmcl.px_round
    .quad     mc_genmcl.px_floor
    .quad     mc_genmcl.px_ceil
    .quad     mc_genmcl.px_atan2
    .quad     mc_genmcl.px_fmod
    .quad     mc_genmcl.px_setcc
    .quad     mc_genmcl.px_min
    .quad     mc_genmcl.px_max
    .quad     mc_genmcl.px_power
    .quad     mc_genmcl.px_minto
    .quad     mc_genmcl.px_maxto
    .quad     mc_genmcl.px_negto
    .quad     mc_genmcl.px_absto
    .quad     mc_genmcl.px_addpxto
    .quad     mc_genmcl.px_subpxto
    .quad     mc_genmcl.px_divto
    .quad     mc_genmcl.px_bitnotto
    .quad     mc_genmcl.px_notto
    .quad     mc_genmcl.px_toboolto
    .quad     mc_genmcl.px_sign
    .quad     mc_genmcl.px_loadbf
    .quad     mc_genmcl.px_storebit
    .quad     mc_genmcl.px_storebf
    .quad     mc_genmcl.px_loadall
    .quad     mc_genmcl.px_setjmp
    .quad     mc_genmcl.px_longjmp
    .quad     mc_genmcl.px_initdswx
    .quad     mc_auxmcl.do_addrmode
$procname:
    .quad     L9397
    .quad     L9398
    .quad     L9399
    .quad     L9400
    .quad     L9401
    .quad     L9402
    .quad     L9403
    .quad     L9404
    .quad     L9405
    .quad     L9406
    .quad     L9407
    .quad     L9408
    .quad     L9409
    .quad     L9410
    .quad     L9411
    .quad     L9412
    .quad     L9413
    .quad     L9414
    .quad     L9415
    .quad     L9416
    .quad     L9417
    .quad     L9418
    .quad     L9419
    .quad     L9420
    .quad     L9421
    .quad     L9422
    .quad     L9423
    .quad     L9424
    .quad     L9425
    .quad     L9426
    .quad     L9427
    .quad     L9428
    .quad     L9429
    .quad     L9430
    .quad     L9431
    .quad     L9432
    .quad     L9433
    .quad     L9434
    .quad     L9435
    .quad     L9436
    .quad     L9437
    .quad     L9438
    .quad     L9439
    .quad     L9440
    .quad     L9441
    .quad     L9442
    .quad     L9443
    .quad     L9444
    .quad     L9445
    .quad     L9446
    .quad     L9447
    .quad     L9448
    .quad     L9449
    .quad     L9450
    .quad     L9451
    .quad     L9452
    .quad     L9453
    .quad     L9454
    .quad     L9455
    .quad     L9456
    .quad     L9457
    .quad     L9458
    .quad     L9459
    .quad     L9460
    .quad     L9461
    .quad     L9462
    .quad     L9463
    .quad     L9464
    .quad     L9465
    .quad     L9466
    .quad     L9467
    .quad     L9468
    .quad     L9469
    .quad     L9470
    .quad     L9471
    .quad     L9472
    .quad     L9473
    .quad     L9474
    .quad     L9475
    .quad     L9476
    .quad     L9477
    .quad     L9478
    .quad     L9479
    .quad     L9480
    .quad     L9481
    .quad     L9482
    .quad     L9483
    .quad     L9484
    .quad     L9485
    .quad     L9486
    .quad     L9487
    .quad     L9488
    .quad     L9489
    .quad     L9490
    .quad     L9491
    .quad     L9492
    .quad     L9493
    .quad     L9494
    .quad     L9495
    .quad     L9496
    .quad     L9497
    .quad     L9498
    .quad     L9499
    .quad     L9500
    .quad     L9501
    .quad     L9502
    .quad     L9503
    .quad     L9504
    .quad     L9505
    .quad     L9506
    .quad     L9507
    .quad     L9508
    .quad     L9509
    .quad     L9510
    .quad     L9511
    .quad     L9512
    .quad     L9513
    .quad     L9514
    .quad     L9515
    .quad     L9516
    .quad     L9517
    .quad     L9518
    .quad     L9519
    .quad     L9520
    .quad     L9521
    .quad     L9522
    .quad     L9523
    .quad     L9524
    .quad     L9525
    .quad     L9526
$nprocs:
    .quad     0x82
#Real Table
    .align    8
L9084:
    .quad     0x3FF0000000000000
L8991:
    .quad     0x4024000000000000
L8988:
    .quad     0x4024000000000000
L8983:
    .quad     0
L8982:
    .quad     0x4000000000000000
L8867:
    .quad     0x4000000000000000
L8824:
    .quad     0x4059000000000000
L8616:
    .quad     0x7FF0000000000000
L8614:
    .quad     0x7FF0000000000000
L8597:
    .quad     0
L8481:
    .quad     0x7FF0000000000000
L8468:
    .quad     0x7FF0000000000000
L8402:
    .quad     0x43E0000000000000
L8401:
    .quad     0x3FF0000000000000
L8400:
    .quad     0x43E0000000000000
L8377:
    .quad     0
L8375:
    .quad     0
#Real32 Table
    .align    16
#labneg64
L9073:
    .quad     0x8000000000000000
    .quad     0x8000000000000000
#mask63/offset64
L8986:
    .quad     0x7FFFFFFFFFFFFFFF
L8987:
    .quad     0x43E0000000000000
#String Table
    .align    8
L9526:
    .ascii    "do_addrmode"
    .byte     0
L9525:
    .ascii    "px_initdswx"
    .byte     0
L9524:
    .ascii    "px_longjmp"
    .byte     0
L9523:
    .ascii    "px_setjmp"
    .byte     0
L9522:
    .ascii    "px_loadall"
    .byte     0
L9521:
    .ascii    "px_storebf"
    .byte     0
L9520:
    .ascii    "px_storebit"
    .byte     0
L9519:
    .ascii    "px_loadbf"
    .byte     0
L9518:
    .ascii    "px_sign"
    .byte     0
L9517:
    .ascii    "px_toboolto"
    .byte     0
L9516:
    .ascii    "px_notto"
    .byte     0
L9515:
    .ascii    "px_bitnotto"
    .byte     0
L9514:
    .ascii    "px_divto"
    .byte     0
L9513:
    .ascii    "px_subpxto"
    .byte     0
L9512:
    .ascii    "px_addpxto"
    .byte     0
L9511:
    .ascii    "px_absto"
    .byte     0
L9510:
    .ascii    "px_negto"
    .byte     0
L9509:
    .ascii    "px_maxto"
    .byte     0
L9508:
    .ascii    "px_minto"
    .byte     0
L9507:
    .ascii    "px_power"
    .byte     0
L9506:
    .ascii    "px_max"
    .byte     0
L9505:
    .ascii    "px_min"
    .byte     0
L9504:
    .ascii    "px_setcc"
    .byte     0
L9503:
    .ascii    "px_fmod"
    .byte     0
L9502:
    .ascii    "px_atan2"
    .byte     0
L9501:
    .ascii    "px_ceil"
    .byte     0
L9500:
    .ascii    "px_floor"
    .byte     0
L9499:
    .ascii    "px_round"
    .byte     0
L9498:
    .ascii    "px_exp"
    .byte     0
L9497:
    .ascii    "px_log10"
    .byte     0
L9496:
    .ascii    "px_log"
    .byte     0
L9495:
    .ascii    "px_atan"
    .byte     0
L9494:
    .ascii    "px_acos"
    .byte     0
L9493:
    .ascii    "px_asin"
    .byte     0
L9492:
    .ascii    "px_tan"
    .byte     0
L9491:
    .ascii    "px_cos"
    .byte     0
L9490:
    .ascii    "px_sin"
    .byte     0
L9489:
    .ascii    "px_assem"
    .byte     0
L9488:
    .ascii    "px_loadbit"
    .byte     0
L9487:
    .ascii    "px_unload"
    .byte     0
L9486:
    .ascii    "px_typepun"
    .byte     0
L9485:
    .ascii    "px_truncate"
    .byte     0
L9484:
    .ascii    "px_fnarrow"
    .byte     0
L9483:
    .ascii    "px_fwiden"
    .byte     0
L9482:
    .ascii    "px_endsw"
    .byte     0
L9481:
    .ascii    "px_swlabel"
    .byte     0
L9480:
    .ascii    "px_switchu"
    .byte     0
L9479:
    .ascii    "px_switch"
    .byte     0
L9478:
    .ascii    "px_subp"
    .byte     0
L9477:
    .ascii    "px_clear"
    .byte     0
L9476:
    .ascii    "px_idivrem"
    .byte     0
L9475:
    .ascii    "px_irem"
    .byte     0
L9474:
    .ascii    "px_idiv"
    .byte     0
L9473:
    .ascii    "px_float"
    .byte     0
L9472:
    .ascii    "px_fix"
    .byte     0
L9471:
    .ascii    "px_shrto"
    .byte     0
L9470:
    .ascii    "px_shlto"
    .byte     0
L9469:
    .ascii    "px_bitxorto"
    .byte     0
L9468:
    .ascii    "px_bitorto"
    .byte     0
L9467:
    .ascii    "px_bitandto"
    .byte     0
L9466:
    .ascii    "px_multo"
    .byte     0
L9465:
    .ascii    "px_subto"
    .byte     0
L9464:
    .ascii    "px_addto"
    .byte     0
L9463:
    .ascii    "px_labeldef"
    .byte     0
L9462:
    .ascii    "px_swapstk"
    .byte     0
L9461:
    .ascii    "px_iswap"
    .byte     0
L9460:
    .ascii    "px_to"
    .byte     0
L9459:
    .ascii    "px_subpx"
    .byte     0
L9458:
    .ascii    "px_addpx"
    .byte     0
L9457:
    .ascii    "px_storem"
    .byte     0
L9456:
    .ascii    "px_istorex"
    .byte     0
L9455:
    .ascii    "px_istore"
    .byte     0
L9454:
    .ascii    "px_iloadx"
    .byte     0
L9453:
    .ascii    "px_iload"
    .byte     0
L9452:
    .ascii    "px_fordown"
    .byte     0
L9451:
    .ascii    "px_forup"
    .byte     0
L9450:
    .ascii    "px_loaddecr"
    .byte     0
L9449:
    .ascii    "px_loadincr"
    .byte     0
L9448:
    .ascii    "px_decrload"
    .byte     0
L9447:
    .ascii    "px_incrload"
    .byte     0
L9446:
    .ascii    "px_decrto"
    .byte     0
L9445:
    .ascii    "px_incrto"
    .byte     0
L9444:
    .ascii    "px_stop"
    .byte     0
L9443:
    .ascii    "px_resetmx"
    .byte     0
L9442:
    .ascii    "px_startmx"
    .byte     0
L9441:
    .ascii    "px_jumpretm"
    .byte     0
L9440:
    .ascii    "px_jumpret"
    .byte     0
L9439:
    .ascii    "px_callp"
    .byte     0
L9438:
    .ascii    "px_setarg"
    .byte     0
L9437:
    .ascii    "px_setcall"
    .byte     0
L9436:
    .ascii    "px_retfn"
    .byte     0
L9435:
    .ascii    "px_retproc"
    .byte     0
L9434:
    .ascii    "px_shr"
    .byte     0
L9433:
    .ascii    "px_shl"
    .byte     0
L9432:
    .ascii    "px_bitxor"
    .byte     0
L9431:
    .ascii    "px_bitor"
    .byte     0
L9430:
    .ascii    "px_bitand"
    .byte     0
L9429:
    .ascii    "px_jumpf"
    .byte     0
L9428:
    .ascii    "px_jumpt"
    .byte     0
L9427:
    .ascii    "px_jumpcc"
    .byte     0
L9426:
    .ascii    "px_sqrt"
    .byte     0
L9425:
    .ascii    "px_sqr"
    .byte     0
L9424:
    .ascii    "px_toboolt"
    .byte     0
L9423:
    .ascii    "px_not"
    .byte     0
L9422:
    .ascii    "px_bitnot"
    .byte     0
L9421:
    .ascii    "px_abs"
    .byte     0
L9420:
    .ascii    "px_neg"
    .byte     0
L9419:
    .ascii    "px_ijump"
    .byte     0
L9418:
    .ascii    "px_jump"
    .byte     0
L9417:
    .ascii    "px_widen"
    .byte     0
L9416:
    .ascii    "px_eval"
    .byte     0
L9415:
    .ascii    "px_div"
    .byte     0
L9414:
    .ascii    "px_mul"
    .byte     0
L9413:
    .ascii    "px_sub"
    .byte     0
L9412:
    .ascii    "px_add"
    .byte     0
L9411:
    .ascii    "px_store"
    .byte     0
L9410:
    .ascii    "px_load"
    .byte     0
L9409:
    .ascii    "px_label"
    .byte     0
L9408:
    .ascii    "px_data"
    .byte     0
L9407:
    .ascii    "px_zstatic"
    .byte     0
L9406:
    .ascii    "px_istatic"
    .byte     0
L9405:
    .ascii    "px_endprog"
    .byte     0
L9404:
    .ascii    "px_endproc"
    .byte     0
L9403:
    .ascii    "px_proc"
    .byte     0
L9402:
    .ascii    "px_comment"
    .byte     0
L9401:
    .ascii    "px_type"
    .byte     0
L9400:
    .ascii    "px_opnd"
    .byte     0
L9399:
    .ascii    "px_double"
    .byte     0
L9398:
    .ascii    "px_dupl"
    .byte     0
L9397:
    .ascii    "px_nop"
    .byte     0
L9396:
    .ascii    "Shared:"
    .byte     0
L9395:
    .byte     9
    .byte     0
L9394:
    .ascii    "Constver:"
    .byte     0
L9393:
    .byte     9
    .byte     0
L9392:
    .ascii    "Ref:"
    .byte     0
L9391:
    .byte     9
    .byte     0
L9390:
    .ascii    "Signed:"
    .byte     0
L9389:
    .byte     9
    .byte     0
L9388:
    .ascii    "Const:"
    .byte     0
L9387:
    .byte     9
    .byte     0
L9386:
    .ascii    "Isblock:"
    .byte     0
L9385:
    .byte     9
    .byte     0
L9384:
    .ascii    "Length:"
    .byte     0
L9383:
    .byte     9
    .byte     0
L9382:
    .ascii    "Size:"
    .byte     0
L9381:
    .byte     9
    .byte     0
L9380:
    .ascii    "Target:"
    .byte     0
L9379:
    .byte     9
    .byte     0
L9378:
    .ascii    "-"
    .byte     0
L9377:
    .ascii    "."
    .byte     0
L9376:
    .ascii    "ttnamedef:"
    .byte     0
L9375:
    .byte     9
    .byte     0
L9374:
    .ascii    "Name:"
    .byte     0
L9373:
    .byte     9
    .byte     0
L9372:
    .ascii    "Basetype:"
    .byte     0
L9371:
    .byte     9
    .byte     0
L9370:
    .ascii    "Typedef:"
    .byte     0
L9369:
    .byte     9
    .byte     0
L9368:
    .ascii    "4"
    .byte     0
L9367:
    .ascii    "PROC MODELIST"
    .byte     0
L9366:
    .byte     10
    .ascii    "Libfiles"
    .byte     0
L9365:
    .byte     10
    .ascii    "Input file:"
    .byte     0
L9364:
    .ascii    "12jl"
    .byte     0
L9363:
    .ascii    "# # (#)"
    .byte     0
L9362:
    .ascii    "Source files"
    .byte     0
L9361:
    .ascii    "<CAN'T DO JEVAL>"
    .byte     0
L9360:
    .ascii    ")"
    .byte     0
L9359:
    .ascii    "+"
    .byte     0
L9358:
    .ascii    "("
    .byte     0
L9357:
    .ascii    ")"
    .byte     0
L9356:
    .ascii    ")/"
    .byte     0
L9355:
    .ascii    ")*"
    .byte     0
L9354:
    .ascii    "scale(("
    .byte     0
L9353:
    .ascii    "<nullunit>"
    .byte     0
L9352:
    .ascii    "--"
    .byte     0
L9351:
    .ascii    "++"
    .byte     0
L9350:
    .ascii    "--"
    .byte     0
L9349:
    .ascii    "++"
    .byte     0
L9348:
    .ascii    "<JBLOCK>"
    .byte     0
L9347:
    .ascii    ")"
    .byte     0
L9346:
    .ascii    "+"
    .byte     0
L9345:
    .ascii    "*("
    .byte     0
L9344:
    .ascii    ")"
    .byte     0
L9343:
    .ascii    "("
    .byte     0
L9342:
    .ascii    ":"
    .byte     0
L9341:
    .ascii    "?"
    .byte     0
L9340:
    .ascii    "="
    .byte     0
L9339:
    .ascii    "}"
    .byte     0
L9338:
    .ascii    ")"
    .byte     0
L9337:
    .ascii    ","
    .byte     0
L9336:
    .ascii    "{"
    .byte     0
L9335:
    .ascii    "("
    .byte     0
L9334:
    .ascii    "->"
    .byte     0
L9333:
    .ascii    "???"
    .byte     0
L9332:
    .ascii    "."
    .byte     0
L9331:
    .ascii    ")"
    .byte     0
L9330:
    .ascii    ","
    .byte     0
L9329:
    .ascii    "("
    .byte     0
L9328:
    .ascii    ")"
    .byte     0
L9327:
    .ascii    "("
    .byte     0
L9326:
    .ascii    ")"
    .byte     0
L9325:
    .ascii    "("
    .byte     0
L9324:
    .ascii    "&"
    .byte     0
L9323:
    .ascii    "EVAL/C"
    .byte     0
L9322:
    .ascii    "ARRAY"
    .byte     0
L9321:
    .byte     34
    .byte     0
L9320:
    .ascii    "LONGSTR)"
    .byte     0
L9319:
    .ascii    ")"
    .byte     0
L9318:
    .ascii    "-"
    .byte     0
L9317:
    .ascii    "(From"
    .byte     0
L9316:
    .byte     9
    .byte     0
L9315:
    .ascii    ":"
    .byte     0
L9314:
    .ascii    "GLOBAL SYMBOL TABLE:"
    .byte     0
L9313:
    .ascii    "*"
    .byte     0
L9312:
    .ascii    " Code:"
    .byte     0
L9311:
    .ascii    " Mode:"
    .byte     0
L9310:
    .ascii    "Anon"
    .byte     0
L9309:
    .byte     9
    .byte     9
    .ascii    "Param: "
    .byte     0
L9308:
    .ascii    " "
    .byte     0
L9307:
    .ascii    "Lineno:"
    .byte     0
L9306:
    .ascii    " "
    .byte     0
L9305:
    .ascii    "STATIC********"
    .byte     0
L9304:
    .ascii    "="
    .byte     0
L9303:
    .ascii    "Enum:"
    .byte     0
L9302:
    .ascii    "Index:"
    .byte     0
L9301:
    .ascii    " Offset: "
    .byte     0
L9300:
    .ascii    "="
    .byte     0
L9299:
    .ascii    "Offset:"
    .byte     0
L9298:
    .ascii    "Void "
    .byte     0
L9297:
    .ascii    "()"
    .byte     0
L9296:
    .ascii    "(#)"
    .byte     0
L9295:
    .ascii    "]"
    .byte     0
L9294:
    .ascii    "Pm:# "
    .byte     0
L9293:
    .ascii    "Used "
    .byte     0
L9292:
    .ascii    "Var "
    .byte     0
L9291:
    .ascii    " "
    .byte     0
L9290:
    .ascii    "@@"
    .byte     0
L9289:
    .ascii    " "
    .byte     0
L9288:
    .ascii    "["
    .byte     0
L9287:
    .ascii    "."
    .byte     0
L9286:
    .ascii    ":"
    .byte     0
L9285:
    .ascii    "    "
    .byte     0
L9284:
    .ascii    "PRINTST not name"
    .byte     0
L9283:
    .ascii    "z5"
    .byte     0
L9282:
    .ascii    "# "
    .byte     0
L9281:
    .ascii    "."
    .byte     0
L9280:
    .ascii    " "
    .byte     0
L9279:
    .ascii    "|---"
    .byte     0
L9278:
    .ascii    "-----------------------"
    .byte     0
L9277:
    .ascii    "3"
    .byte     0
L9276:
    .ascii    "2"
    .byte     0
L9275:
    .ascii    "1"
    .byte     0
L9274:
    .ascii    " ALENGTH="
    .byte     0
L9273:
    .ascii    " Widen from:"
    .byte     0
L9272:
    .ascii    " Offset:"
    .byte     0
L9271:
    .ascii    " Aparams:"
    .byte     0
L9270:
    .ascii    "Ptrscale:"
    .byte     0
L9269:
    .ascii    "Scale:"
    .byte     0
L9268:
    .ascii    " => "
    .byte     0
L9267:
    .ascii    " "
    .byte     0
L9266:
    .ascii    "<WSTRCONST>"
    .byte     0
L9265:
    .ascii    "<STRCONST>"
    .byte     0
L9264:
    .ascii    " "
    .byte     0
L9263:
    .ascii    "PRINTUNIT BAD CONST"
    .byte     0
L9262:
    .ascii    "PRINTUNIT/CONST/aRRAY"
    .byte     0
L9261:
    .byte     34
    .ascii    " *"
    .byte     0
L9260:
    .ascii    "(WSTRING)"
    .byte     0
L9259:
    .byte     34
    .byte     0
L9258:
    .byte     34
    .ascii    " *"
    .byte     0
L9257:
    .byte     34
    .byte     0
L9256:
    .byte     34
    .ascii    " *"
    .byte     0
L9255:
    .ascii    "(LONGSTR)"
    .byte     0
L9254:
    .byte     34
    .byte     0
L9253:
    .ascii    "Value:"
    .byte     0
L9252:
    .ascii    "1"
    .byte     0
L9251:
    .ascii    " Lastcall:"
    .byte     0
L9250:
    .ascii    " "
    .byte     0
L9249:
    .ascii    "}"
    .byte     0
L9248:
    .ascii    " {"
    .byte     0
L9247:
    .ascii    ": "
    .byte     0
L9245:
    .ascii    "             "
    .byte     0
L9244:
    .ascii    "print unit: bad tag"
    .byte     0
L9243:
    .ascii    "1"
    .byte     0
L9242:
    .ascii    "="
    .byte     0
L9241:
    .ascii    "wb"
    .byte     0
L9240:
    .ascii    "as"
    .byte     0
L9239:
    .ascii    "Writing internal"
    .byte     0
L9238:
    .ascii    "hdr"
    .byte     0
L9237:
    .ascii    " "
    .byte     0
L9236:
    .ascii    "<builtin>"
    .byte     0
L9235:
    .byte     0
L9234:
    .ascii    "Too many source files"
    .byte     0
L9233:
    .ascii    "LSF can't load "
    .byte     0
L9232:
    .byte     0
L9231:
    .ascii    "Too many source files"
    .byte     0
L9230:
    .ascii    "Stopping"
    .byte     0
L9229:
    .ascii    "Load Error:"
    .byte     0
L9228:
    .ascii    "****"
    .byte     0
L9227:
    .ascii    "**** Code Gen Error:"
    .byte     0
L9226:
    .ascii    "in file"
    .byte     0
L9225:
    .ascii    "On line"
    .byte     0
L9224:
    .ascii    " "
    .byte     0
L9223:
    .ascii    "In function"
    .byte     0
L9222:
    .ascii    "on line"
    .byte     0
L9221:
    .ascii    "Type error:"
    .byte     0
L9220:
    .byte     10
    .ascii    "In function"
    .byte     0
L9219:
    .ascii    "****"
    .byte     0
L9218:
    .ascii    "**** Syntax Error:"
    .byte     0
L9217:
    .ascii    "in file"
    .byte     0
L9216:
    .ascii    "On line"
    .byte     0
L9215:
    .ascii    "OUTSIDE PROC"
    .byte     0
L9214:
    .ascii    " "
    .byte     0
L9213:
    .byte     10
    .ascii    "In function"
    .byte     0
L9212:
    .byte     10
    .ascii    "MC Error:"
    .byte     0
L9211:
    .ascii    "w"
    .byte     0
L9210:
    .ascii    "$error.tmp"
    .byte     0
L9209:
    .ascii    "ATL ERROR"
    .byte     0
L9208:
    .ascii    "rb"
    .byte     0
L9207:
    .ascii    "w"
    .byte     0
L9206:
    .ascii    "GETALIGN SIZE NOT 1248"
    .byte     0
L9205:
    .ascii    "Dupl proc name"
    .byte     0
L9204:
    .ascii    "in"
    .byte     0
L9203:
    .byte     34
    .byte     0
L9202:
    .ascii    " "
    .byte     34
    .byte     0
L9201:
    .ascii    "# expected, not #"
    .byte     0
L9200:
    .ascii    "Too many types/cnm"
    .byte     0
L9199:
    .ascii    "STRMODE(M)="
    .byte     0
L9198:
    .ascii    "Too many types"
    .byte     0
L9197:
    .byte     0
L9196:
    .ascii    "const "
    .byte     0
L9195:
    .ascii    "<enum>"
    .byte     0
L9194:
    .ascii    "<array>"
    .byte     0
L9193:
    .ascii    "."
    .byte     0
L9192:
    .ascii    "union "
    .byte     0
L9191:
    .ascii    "struct "
    .byte     0
L9190:
    .ascii    "NEWSTRMODE"
    .byte     0
L9189:
    .ascii    ")"
    .byte     0
L9188:
    .ascii    ","
    .byte     0
L9187:
    .ascii    "proc("
    .byte     0
L9186:
    .ascii    ")"
    .byte     0
L9185:
    .ascii    " "
    .byte     0
L9184:
    .ascii    ","
    .byte     0
L9183:
    .ascii    "("
    .byte     0
L9182:
    .ascii    "enum "
    .byte     0
L9181:
    .ascii    "[]"
    .byte     0
L9180:
    .ascii    "[#]"
    .byte     0
L9179:
    .ascii    "ref "
    .byte     0
L9178:
    .ascii    "const ref "
    .byte     0
L9177:
    .ascii    "z3"
    .byte     0
L9176:
    .byte     92
    .ascii    "#o"
    .byte     0
L9175:
    .ascii    "$F"
    .byte     0
L9174:
    .ascii    "$T"
    .byte     0
L9173:
    .ascii    "GCV Not constant"
    .byte     0
L9172:
    .ascii    "Can't find -to version"
    .byte     0
L9171:
    .ascii    "to"
    .byte     0
L9169:
    .ascii    "main"
    .byte     0
L9168:
    .ascii    "."
    .byte     0
L9167:
    .ascii    "Dupl case value: #"
    .byte     0
L9166:
    .ascii    "Too many cases on one switch"
    .byte     0
L9165:
    .ascii    "case: serial switch not found"
    .byte     0
L9164:
    .ascii    "Label not defined: #"
    .byte     0
L9163:
    .ascii    "maxparams"
    .byte     0
L9162:
    .ascii    "Convert op not implem: #"
    .byte     0
L9161:
    .ascii    "Bad cast"
    .byte     0
L9160:
    .ascii    "DOASSIGN not ready: #"
    .byte     0
L9159:
    .ascii    "dxname"
    .byte     0
L9158:
    .ascii    "const?"
    .byte     0
L9157:
    .ascii    "CONST/WSTRING"
    .byte     0
L9156:
    .ascii    "DX-EXPR: can't do tag: #"
    .byte     0
L9155:
    .ascii    "2:Runtime expr in static data"
    .byte     0
L9154:
    .ascii    "*"
    .byte     0
L9153:
    .ascii    "Complex ptr expr in static data"
    .byte     0
L9152:
    .ascii    "1:Runtime or unsupported expr in static data"
    .byte     0
L9151:
    .ascii    "+"
    .byte     0
L9150:
    .ascii    "Add/Idata &frame"
    .byte     0
L9149:
    .ascii    "+"
    .byte     0
L9148:
    .ascii    ","
    .byte     0
L9147:
    .ascii    "`"
    .byte     0
L9146:
    .ascii    "Idata &frame"
    .byte     0
L9145:
    .ascii    "IDATA/SCALAR"
    .byte     0
L9144:
    .ascii    "GENIDATA/WSTRING2"
    .byte     0
L9143:
    .ascii    "$#.#.#"
    .byte     0
L9142:
    .byte     0
L9141:
    .ascii    "------------------------"
    .byte     0
L9140:
    .ascii    "main"
    .byte     0
L9139:
    .byte     0
L9138:
    .ascii    "Static fn not defined: #"
    .byte     0
L9137:
    .ascii    "1:Start of code"
    .byte     0
L9136:
    .ascii    "GenPCL:"
    .byte     0
L9135:
    .ascii    "dllexport"
    .byte     0
L9134:
    .ascii    "Generic: multiple types match"
    .byte     0
L9133:
    .ascii    "Generic: no type match"
    .byte     0
L9132:
    .ascii    "generic/default twice"
    .byte     0
L9131:
    .ascii    "Not array"
    .byte     0
L9130:
    .ascii    "*"
    .byte     0
L9129:
    .ascii    "Can't do conversion # => #"
    .byte     0
L9128:
    .ascii    "*"
    .byte     0
L9127:
    .ascii    "case not inside switch stmt"
    .byte     0
L9126:
    .ascii    "poploop?"
    .byte     0
L9125:
    .ascii    "Too many nested loop or switch"
    .byte     0
L9124:
    .ascii    "Not allowed on ptrs"
    .byte     0
L9123:
    .ascii    "-= refs don't match"
    .byte     0
L9122:
    .ascii    "ptr+=ptr"
    .byte     0
L9121:
    .ascii    "Not a field of struct # #"
    .byte     0
L9120:
    .ascii    ". -> not a struct"
    .byte     0
L9119:
    .ascii    "-> needs pointer"
    .byte     0
L9118:
    .ascii    "enum name reused #"
    .byte     0
L9117:
    .ascii    "Redefining enum #"
    .byte     0
L9116:
    .ascii    "Enum tag in use #"
    .byte     0
L9115:
    .ascii    "BAD REF[]"
    .byte     0
L9114:
    .ascii    "const to non-const pointer"
    .byte     0
L9113:
    .ascii    "Struct decl error #"
    .byte     0
L9112:
    .ascii    "Struct decl error"
    .byte     0
L9111:
    .ascii    "Can't use ss in struct"
    .byte     0
L9110:
    .ascii    "member name in use #"
    .byte     0
L9109:
    .ascii    "typedef or function inside struct"
    .byte     0
L9108:
    .ascii    "Field name expected"
    .byte     0
L9107:
    .ascii    "Redefining struct #"
    .byte     0
L9106:
    .ascii    "Prev"
    .byte     0
L9105:
    .ascii    "Struct tag in use #"
    .byte     0
L9104:
    .ascii    "ATP?"
    .byte     0
L9103:
    .ascii    "*"
    .byte     0
L9102:
    .ascii    "ATP:"
    .byte     0
L9101:
    .ascii    "Variadic param is void"
    .byte     0
L9100:
    .ascii    "Too many args"
    .byte     0
L9099:
    .ascii    "1:Too few args"
    .byte     0
L9098:
    .ascii    "ccall?"
    .byte     0
L9097:
    .ascii    "*"
    .byte     0
L9096:
    .ascii    "JTAGNAMES[P.TAG]="
    .byte     0
L9095:
    .ascii    "Not function pointer: #"
    .byte     0
L9094:
    .ascii    "value: #"
    .byte     0
L9093:
    .ascii    "*"
    .byte     0
L9092:
    .ascii    "CHECKLV/WIDEN"
    .byte     0
L9090:
    .ascii    "Invalid condition #"
    .byte     0
L9089:
    .ascii    "rem 0"
    .byte     0
L9088:
    .ascii    "div 0"
    .byte     0
L9087:
    .ascii    "EVALSUB/REF"
    .byte     0
L9085:
    .ascii    "Rem bad types"
    .byte     0
L9083:
    .ascii    "Div bad types"
    .byte     0
L9082:
    .ascii    "Mul bad types"
    .byte     0
L9081:
    .ascii    "Sub bad types"
    .byte     0
L9080:
    .ascii    "++ bad type"
    .byte     0
L9079:
    .ascii    "* not pointer"
    .byte     0
L9078:
    .ascii    "*"
    .byte     0
L9077:
    .ascii    "! bad type"
    .byte     0
L9076:
    .ascii    "abs bad type"
    .byte     0
L9074:
    .ascii    "neg bad type"
    .byte     0
L9072:
    .ascii    "; after function def"
    .byte     0
L9071:
    .ascii    "Can't define function twice #"
    .byte     0
L9070:
    .ascii    "fn: name in use #"
    .byte     0
L9069:
    .ascii    "NAME not allowed in cast type #"
    .byte     0
L9068:
    .ascii    "bad symbol in paramlist"
    .byte     0
L9067:
    .ascii    "Param name reused # #"
    .byte     0
L9066:
    .ascii    "Param type missing or misspelt"
    .byte     0
L9065:
    .ascii    "Typedef redefined or can't match types #"
    .byte     0
L9064:
    .ascii    "Typedef name in use #"
    .byte     0
L9063:
    .ascii    "Local decl error #"
    .byte     0
L9062:
    .ascii    "Nested function"
    .byte     0
L9061:
    .ascii    "Var name expected"
    .byte     0
L9060:
    .ascii    "Return value needed"
    .byte     0
L9059:
    .ascii    "Can't return value in void function"
    .byte     0
L9058:
    .ascii    "For decl error"
    .byte     0
L9057:
    .ascii    "Not allowed in for stmt"
    .byte     0
L9056:
    .ascii    "Var name expected"
    .byte     0
L9054:
    .ascii    "2:Duplicate label"
    .byte     0
L9053:
    .ascii    "continue outside loop"
    .byte     0
L9052:
    .ascii    "break outside loop/sw"
    .byte     0
L9051:
    .ascii    "{...} statement expected"
    .byte     0
L9050:
    .ascii    "Too many blocks"
    .byte     0
L9049:
    .ascii    "Too many block levels"
    .byte     0
L9048:
    .ascii    "Init str too long"
    .byte     0
L9047:
    .ascii    "Array init"
    .byte     0
L9046:
    .ascii    "{} initialiser expected"
    .byte     0
L9045:
    .ascii    "Too many struct elems"
    .byte     0
L9044:
    .ascii    "Too many array elems"
    .byte     0
L9043:
    .ascii    "init/Empty struct"
    .byte     0
L9042:
    .ascii    "init/0-size array"
    .byte     0
L9041:
    .ascii    "readconstint #"
    .byte     0
L9040:
    .ascii    "Negative array dim"
    .byte     0
L9039:
    .ascii    "ZERO LEN ARRAY"
    .byte     0
L9038:
    .ascii    "Can't do VLAs"
    .byte     0
L9037:
    .ascii    "rnt1"
    .byte     0
L9036:
    .ascii    "Can't init extern #"
    .byte     0
L9035:
    .ascii    "Can't init twice #"
    .byte     0
L9034:
    .ascii    "var: name in use #"
    .byte     0
L9033:
    .ascii    "Can't init extern #"
    .byte     0
L9032:
    .ascii    "Can't init twice #"
    .byte     0
L9031:
    .ascii    "var: redefining #"
    .byte     0
L9030:
    .ascii    "var: name in use # #"
    .byte     0
L9029:
    .ascii    "Readterm?"
    .byte     0
L9028:
    .ascii    "RT"
    .byte     0
L9027:
    .ascii    "rt/alignof"
    .byte     0
L9026:
    .ascii    "rt/compound lit"
    .byte     0
L9025:
    .ascii    "rt/&&label"
    .byte     0
L9024:
    .ascii    "char const too long"
    .byte     0
L9023:
    .ascii    "Undefined name "
    .byte     34
    .ascii    "#"
    .byte     34
    .byte     0
L9022:
    .ascii    "shift:Not an int"
    .byte     0
L9021:
    .ascii    "invalid rel operands"
    .byte     0
L9020:
    .ascii    "Comparing distinct pointers/rel"
    .byte     0
L9019:
    .ascii    "invalid == operands"
    .byte     0
L9018:
    .ascii    "U="
    .byte     0
L9017:
    .ascii    "Can't compare pointer to int2"
    .byte     0
L9016:
    .ascii    "Can't compare pointer to int"
    .byte     0
L9015:
    .ascii    "Comparing distinct pointers/eq"
    .byte     0
L9014:
    .ascii    "invalid & operands"
    .byte     0
L9013:
    .ascii    "float&float"
    .byte     0
L9012:
    .ascii    "invalid ^ operands"
    .byte     0
L9011:
    .ascii    "float^float"
    .byte     0
L9010:
    .ascii    "invalid | operands"
    .byte     0
L9009:
    .ascii    "float|float"
    .byte     0
L9008:
    .ascii    "?: incompatible types"
    .byte     0
L9007:
    .ascii    "Modifying constant?"
    .byte     0
L9006:
    .ascii    "Modifying read-only var"
    .byte     0
L9005:
    .ascii    "declspec/float"
    .byte     0
L9004:
    .ascii    "dbl decl?"
    .byte     0
L9003:
    .ascii    "char decl?"
    .byte     0
L9002:
    .ascii    "Implicit decls not allowed: #"
    .byte     0
L9001:
    .ascii    "enum?"
    .byte     0
L9000:
    .ascii    "struct?"
    .byte     0
L8999:
    .ascii    "Dual storage spec"
    .byte     0
L8998:
    .ascii    "declspec/ts #"
    .byte     0
L8997:
    .ascii    "PARSETEST"
    .byte     0
L8996:
    .ascii    "Parsing:"
    .byte     0
L8995:
    .ascii    "Decl error #"
    .byte     0
L8994:
    .ascii    "fn def after comma"
    .byte     0
L8993:
    .ascii    "Var name expected"
    .byte     0
L8992:
    .ascii    "Extra semicolon 2"
    .byte     0
L8981:
    .ascii    "Real too long"
    .byte     0
L8980:
    .ascii    "REGENHST FULL?"
    .byte     0
L8979:
    .ascii    "regenhst dupl?"
    .byte     0
L8978:
    .ascii    "mcc.h"
    .byte     0
L8977:
    .ascii    "TMLM"
    .byte     0
L8976:
    .ascii    "TMH"
    .byte     0
L8975:
    .ascii    "TMM"
    .byte     0
L8974:
    .ascii    "Str expected"
    .byte     0
L8973:
    .ascii    "link"
    .byte     0
L8972:
    .ascii    "header"
    .byte     0
L8971:
    .ascii    "module"
    .byte     0
L8970:
    .ascii    "Only pack(1) or () allowed"
    .byte     0
L8969:
    .ascii    "'(' expected"
    .byte     0
L8968:
    .ascii    "pack"
    .byte     0
L8967:
    .ascii    "2:Too many pasted tokens"
    .byte     0
L8966:
    .ascii    "PDM"
    .byte     0
L8965:
    .ascii    "???"
    .byte     0
L8964:
    .ascii    "(File not available)"
    .byte     0
L8963:
    .ascii    "z2"
    .byte     0
L8962:
    .ascii    "2"
    .byte     0
L8961:
    .ascii    "#:#:#"
    .byte     0
L8960:
    .ascii    "4"
    .byte     0
L8959:
    .ascii    "#-#-#"
    .byte     0
L8958:
    .ascii    "#if:Unexpected eof"
    .byte     0
L8957:
    .ascii    "EOL expected"
    .byte     0
L8956:
    .ascii    "Name expected"
    .byte     0
L8955:
    .ascii    "evalterm?"
    .byte     0
L8954:
    .ascii    ") expected"
    .byte     0
L8953:
    .ascii    "')' expected"
    .byte     0
L8952:
    .ascii    "sizeof2"
    .byte     0
L8951:
    .ascii    "name expected"
    .byte     0
L8950:
    .ascii    "'(' expected"
    .byte     0
L8949:
    .ascii    "')' expected"
    .byte     0
L8948:
    .ascii    "defined?"
    .byte     0
L8947:
    .ascii    "#if:div by zero"
    .byte     0
L8946:
    .ascii    ": expected"
    .byte     0
L8945:
    .ascii    "#if:eol expected"
    .byte     0
L8944:
    .ascii    "Too many pasted tokens"
    .byte     0
L8943:
    .ascii    ".*"
    .byte     0
L8942:
    .ascii    "v"
    .byte     0
L8941:
    .byte     0
L8940:
    .byte     10
    .byte     0
L8939:
    .ascii    "Too many ##"
    .byte     0
L8938:
    .ascii    "## at start"
    .byte     0
L8937:
    .ascii    "# not followed by param"
    .byte     0
L8936:
    .ascii    "# at end"
    .byte     0
L8935:
    .ascii    "Wrong # macro params"
    .byte     0
L8934:
    .ascii    "EOS in macro call"
    .byte     0
L8933:
    .ascii    "rmc: ')' expected"
    .byte     0
L8932:
    .ascii    "rmc: no '('"
    .byte     0
L8931:
    .ascii    ">"
    .byte     0
L8930:
    .ascii    "<"
    .byte     0
L8929:
    .ascii    "macro params?"
    .byte     0
L8928:
    .ascii    "')' expected"
    .byte     0
L8927:
    .ascii    "__VA_ARGS__"
    .byte     0
L8926:
    .ascii    "Dupl macro param"
    .byte     0
L8925:
    .ascii    "define: name expected"
    .byte     0
L8924:
    .ascii    "Local str too long"
    .byte     0
L8923:
    .ascii    "String not terminated"
    .byte     0
L8922:
    .ascii    "NEXTLX.LINENO="
    .byte     0
L8921:
    .ascii    "#define __attribute__(x)"
    .byte     10
    .ascii    "#define _WIN32"
    .byte     10
    .ascii    "#define WIN32"
    .byte     10
    .ascii    "#define __WIN32__"
    .byte     10
    .ascii    "#define __inline"
    .byte     10
    .ascii    "#define __dllimport(x)"
    .byte     10
    .ascii    "//#define __declspec(x)"
    .byte     10
    .ascii    "#define __stdcall"
    .byte     10
    .ascii    "#define CALLBACK $callback"
    .byte     10
    .ascii    "#define __cdecl"
    .byte     10
    .ascii    "#define EXTERN_C extern"
    .byte     10
    .ascii    "#define DECLSPEC_IMPORT"
    .byte     10
    .ascii    "#define __32BIT__"
    .byte     10
    .ascii    "#define register"
    .byte     10
    .ascii    "#define __MCCC__"
    .byte     10
    .byte     10
    .ascii    "//typedef signed char"
    .byte     9
    .byte     9
    .ascii    "i8;"
    .byte     10
    .ascii    "//typedef short"
    .byte     9
    .byte     9
    .byte     9
    .ascii    "i16;"
    .byte     10
    .ascii    "//typedef int"
    .byte     9
    .byte     9
    .byte     9
    .byte     9
    .ascii    "i32;"
    .byte     10
    .ascii    "//typedef long long int"
    .byte     9
    .ascii    "i64;"
    .byte     10
    .ascii    "//typedef unsigned char"
    .byte     9
    .byte     9
    .byte     9
    .ascii    "u8;"
    .byte     10
    .ascii    "//typedef unsigned short"
    .byte     9
    .byte     9
    .byte     9
    .ascii    "u16;"
    .byte     10
    .ascii    "//typedef unsigned int"
    .byte     9
    .byte     9
    .byte     9
    .ascii    "u32;"
    .byte     10
    .ascii    "//typedef unsigned long long int"
    .byte     9
    .ascii    "u64;"
    .byte     10
    .ascii    "//"
    .byte     10
    .ascii    "//typedef unsigned char byte;"
    .byte     10
    .ascii    "//"
    .byte     10
    .ascii    "//typedef float r32;"
    .byte     10
    .ascii    "//typedef double r64;"
    .byte     10
    .byte     10
    .byte     0
L8920:
    .ascii    "mcc.h"
    .byte     0
L8919:
    .ascii    "Too many nested includes"
    .byte     0
L8918:
    .ascii    "Can't find include file"
    .byte     0
L8917:
    .ascii    "Overflow in decimal number"
    .byte     0
L8916:
    .ascii    "18446744073709551615"
    .byte     0
L8915:
    .ascii    "-U?"
    .byte     0
L8914:
    .ascii    "-LL?"
    .byte     0
L8913:
    .ascii    "Overflow in octal number"
    .byte     0
L8912:
    .ascii    "1777777777777777777777"
    .byte     0
L8911:
    .ascii    "-U?"
    .byte     0
L8910:
    .ascii    "-LL?"
    .byte     0
L8909:
    .ascii    "Overflow in binary number"
    .byte     0
L8908:
    .ascii    "Binary fp"
    .byte     0
L8907:
    .ascii    "Binary bad digit"
    .byte     0
L8906:
    .ascii    "Overflow in hex number"
    .byte     0
L8905:
    .ascii    "-U?"
    .byte     0
L8904:
    .ascii    "-LL?"
    .byte     0
L8903:
    .ascii    "block comment eof"
    .byte     0
L8902:
    .ascii    ":##"
    .byte     0
L8901:
    .ascii    ":::"
    .byte     0
L8900:
    .ascii    "#endif missing"
    .byte     0
L8899:
    .ascii    "Directive not implemented"
    .byte     0
L8898:
    .ascii    "DIRECTIVE NOT IMPL:"
    .byte     0
L8897:
    .ascii    "ABORTING"
    .byte     0
L8896:
    .ascii    "#ERROR:"
    .byte     0
L8895:
    .ascii    "#if missing/endif"
    .byte     0
L8894:
    .ascii    "#if missing/elif/else"
    .byte     0
L8893:
    .ascii    "undef: name expected"
    .byte     0
L8892:
    .ascii    "NSOURCEFILES="
    .byte     0
L8891:
    .ascii    "FROM"
    .byte     0
L8890:
    .ascii    "INCLUDE"
    .byte     0
L8889:
    .ascii    "include?"
    .byte     0
L8888:
    .ascii    "include: > expected"
    .byte     0
L8887:
    .ascii    "Bad include file"
    .byte     0
L8886:
    .ascii    "Invalid # directive"
    .byte     0
L8885:
    .ascii    "Duplicate symbol table entry"
    .byte     0
L8884:
    .ascii    "HASHTABLE FULL"
    .byte     0
L8883:
    .ascii    "Digit out of range"
    .byte     0
L8882:
    .ascii    ".*"
    .byte     0
L8881:
    .ascii    "v"
    .byte     0
L8880:
    .ascii    ".*"
    .byte     0
L8879:
    .ascii    "v"
    .byte     0
L8878:
    .ascii    "#"
    .byte     0
L8877:
    .ascii    "'"
    .byte     0
L8876:
    .byte     34
    .byte     0
L8875:
    .ascii    " "
    .byte     0
L8874:
    .ascii    "%-18s"
    .byte     0
L8873:
    .ascii    "Line:"
    .byte     0
L8872:
    .ascii    "in:"
    .byte     0
L8871:
    .byte     10
    .ascii    "Lex error"
    .byte     0
L8870:
    .ascii    "Non-base-10 floats temporarily unavailable"
    .byte     0
L8869:
    .ascii    "p"
    .byte     0
L8868:
    .ascii    "e"
    .byte     0
L8866:
    .ascii    "Real too long"
    .byte     0
L8865:
    .ascii    "ERROR CHAR"
    .byte     0
L8864:
    .ascii    "@ SEEN"
    .byte     0
L8863:
    .ascii    "wb"
    .byte     0
L8862:
    .ascii    "#endif missing"
    .byte     0
L8861:
    .ascii    "mcc.h"
    .byte     0
L8860:
    .ascii    "CC C Compiler 7.x"
    .byte     0
L8859:
    .ascii    "C Subset Compiler for 64-bit Windows"
    .byte     10
    .byte     10
    .ascii    "Normal use:           Compiles prog.c to:"
    .byte     10
    .byte     10
    .ascii    "    cc      prog      prog.exe (default)"
    .byte     10
    .ascii    "    cc -r   prog      in-memory native code then execute"
    .byte     10
    .ascii    "    cc -i   prog      in-memory IL then interpret"
    .byte     10
    .byte     10
    .ascii    "    cc -exe prog      prog.exe"
    .byte     10
    .ascii    "    cc -dll prog      prog.dll"
    .byte     10
    .ascii    "    cc -obj prog      prog.obj"
    .byte     10
    .ascii    "    cc -s   prog      prog.asm (also -a)"
    .byte     10
    .ascii    "    cc -mx  prog      prog.mx"
    .byte     10
    .ascii    "    cc -p   prog      prog.pcl (textual IL)"
    .byte     10
    .ascii    "    cc -e   prog      prog.i   (preprocess only)"
    .byte     10
    .byte     10
    .ascii    "Other options:"
    .byte     10
    .byte     10
    .ascii    "    -incl:path        Add path to search for includes"
    .byte     10
    .ascii    "    -ext              Used std headers external to compiler"
    .byte     10
    .ascii    "    -opt              Optimise native code"
    .byte     10
    .ascii    "    -o:file           Name output file (extension can be added)"
    .byte     10
    .ascii    "    -norip            Don't use RIP address modes"
    .byte     10
    .ascii    "    -himem            Generate PIC code (automatic with -obj/-dll)"
    .byte     10
    .ascii    "    @file             Read files and options from a file"
    .byte     10
    .ascii    "    -c                Same as -obj"
    .byte     10
    .ascii    "    -s                Same as -asm"
    .byte     10
    .ascii    "    -ei               Same as -e, but when result is interpreted"
    .byte     10
    .byte     10
    .ascii    "Notes:"
    .byte     10
    .byte     10
    .ascii    "    * Compiles single module only"
    .byte     10
    .ascii    "    * For -i and -r, options"
    .byte     10
    .ascii    "    * .c extension is optional on input file"
    .byte     10
    .byte     0
L8858:
    .ascii    "Include paths"
    .byte     0
L8857:
    .ascii    "   "
    .byte     0
L8856:
    .ascii    "/"
    .byte     0
L8855:
    .byte     0
L8854:
    .ascii    "Too many include paths"
    .byte     0
L8853:
    .byte     0
L8852:
    .ascii    "-RUNP OUT OF ORDER"
    .byte     0
L8851:
    .ascii    "-help                Show all options"
    .byte     0
L8850:
    .ascii    "    "
    .byte     0
L8849:
    .ascii    "-i prog[.c]          Compile prog.c and interpret"
    .byte     0
L8848:
    .ascii    "    "
    .byte     0
L8847:
    .ascii    "-r prog[.c]          Compile prog.c and run"
    .byte     0
L8846:
    .ascii    "    "
    .byte     0
L8845:
    .ascii    "   prog[.c]          Compile prog.c to prog.exe"
    .byte     0
L8844:
    .ascii    "    "
    .byte     0
L8843:
    .ascii    "Usage:"
    .byte     0
L8842:
    .byte     0
L8841:
    .ascii    "Too many lib files"
    .byte     0
L8840:
    .byte     0
L8839:
    .ascii    "One input file only"
    .byte     0
L8838:
    .ascii    "Unknown option:"
    .byte     0
L8837:
    .ascii    ".c"
    .byte     0
L8836:
    .byte     0
L8835:
    .ascii    "cs.exe"
    .byte     0
L8834:
    .ascii    "Total:"
    .byte     0
L8833:
    .ascii    "-----------------------------"
    .byte     0
L8832:
    .ascii    "EXE:"
    .byte     0
L8831:
    .ascii    "SS:"
    .byte     0
L8830:
    .ascii    "MCL:"
    .byte     0
L8829:
    .ascii    "PCL:"
    .byte     0
L8828:
    .ascii    "Parse:"
    .byte     0
L8827:
    .ascii    "Load:"
    .byte     0
L8826:
    .ascii    "Init:"
    .byte     0
L8825:
    .ascii    "5.1jr"
    .byte     0
L8823:
    .ascii    "5"
    .byte     0
L8822:
    .ascii    "12jl"
    .byte     0
L8821:
    .ascii    "# # ms # %"
    .byte     0
L8820:
    .ascii    "Size:"
    .byte     0
L8819:
    .ascii    ":"
    .byte     0
L8818:
    .ascii    "Sourcefiles:"
    .byte     0
L8817:
    .ascii    "PROC"
    .byte     0
L8816:
    .ascii    "PROC AST"
    .byte     0
L8815:
    .ascii    ": ."
    .byte     0
L8814:
    .ascii    ":"
    .byte     0
L8813:
    .ascii    "0: Internal standard headers (disable with -ext)"
    .byte     0
L8812:
    .ascii    "Include search paths:"
    .byte     0
L8811:
    .ascii    "c:/cx/headers/"
    .byte     0
L8810:
    .byte     0
L8809:
    .ascii    "<line>"
    .byte     0
L8808:
    .ascii    "kernel32"
    .byte     0
L8807:
    .ascii    "user32"
    .byte     0
L8806:
    .ascii    "gdi32"
    .byte     0
L8805:
    .ascii    "msvcrt"
    .byte     0
L8804:
    .ascii    "mcc.log"
    .byte     0
L8803:
    .ascii    "Diagnostic outputs written to"
    .byte     0
L8802:
    .ascii    "mcc.log"
    .byte     0
L8801:
    .byte     92
    .ascii    "m"
    .byte     92
    .ascii    "scripts"
    .byte     92
    .ascii    "med.bat "
    .byte     0
L8800:
    .ascii    "PRESS KEY"
    .byte     0
L8799:
    .ascii    "cc.m"
    .byte     0
L8798:
    .ascii    "STFLAT"
    .byte     0
L8797:
    .ascii    "ST"
    .byte     0
L8796:
    .ascii    "PSYMTAB"
    .byte     0
L8795:
    .ascii    "!PROC PCL"
    .byte     0
L8794:
    .ascii    "PROC ASM"
    .byte     0
L8793:
    .ascii    "w"
    .byte     0
L8792:
    .ascii    "mcc.log"
    .byte     0
L8791:
    .ascii    "Can't load main module: #"
    .byte     0
L8790:
    .ascii    "$prog"
    .byte     0
L8789:
    .ascii    "<sourcefile0>"
    .byte     0
L8788:
    .ascii    "<dummy path>"
    .byte     0
L8787:
    .ascii    "<dummy file>"
    .byte     0
L8786:
    .ascii    "Loading:"
    .byte     0
L8785:
    .ascii    "Done."
    .byte     0
L8784:
    .ascii    "not ready"
    .byte     0
L8783:
    .ascii    "Compiling # to #"
    .byte     0
L8782:
    .ascii    "No Run"
    .byte     0
L8781:
    .byte     0
L8780:
    .ascii    "qword ptr"
    .byte     0
L8779:
    .ascii    "dword ptr"
    .byte     0
L8778:
    .ascii    "word ptr"
    .byte     0
L8777:
    .ascii    "byte ptr"
    .byte     0
L8776:
    .byte     0
L8775:
    .ascii    "%"
    .byte     0
L8774:
    .ascii    "#.$T#"
    .byte     0
L8773:
    .ascii    "T"
    .byte     0
L8772:
    .ascii    "%XMM"
    .byte     0
L8771:
    .ascii    "-"
    .byte     0
L8770:
    .byte     0
L8769:
    .ascii    "Stropnd?"
    .byte     0
L8768:
    .ascii    "L"
    .byte     0
L8767:
    .byte     34
    .byte     0
L8766:
    .ascii    "M"
    .byte     0
L8765:
    .ascii    "20.20"
    .byte     0
L8764:
    .byte     0
L8763:
    .ascii    "+"
    .byte     0
L8762:
    .byte     0
L8761:
    .ascii    "<BAD OPND>"
    .byte     0
L8760:
    .ascii    "BAD OPND"
    .byte     0
L8759:
    .ascii    "]"
    .byte     0
L8758:
    .ascii    " + "
    .byte     0
L8757:
    .ascii    "%rip+"
    .byte     0
L8756:
    .ascii    "*"
    .byte     0
L8755:
    .ascii    " + "
    .byte     0
L8754:
    .byte     0
L8753:
    .ascii    "["
    .byte     0
L8752:
    .ascii    "H"
    .byte     0
L8751:
    .ascii    "0x"
    .byte     0
L8750:
    .ascii    ","
    .byte     0
L8749:
    .ascii    ","
    .byte     9
    .byte     0
L8748:
    .ascii    " "
    .byte     0
L8747:
    .ascii    "  "
    .byte     0
L8746:
    .ascii    " "
    .byte     0
L8745:
    .ascii    ".ascii"
    .byte     0
L8744:
    .ascii    ".quad"
    .byte     0
L8743:
    .ascii    ".long"
    .byte     0
L8742:
    .ascii    ".word"
    .byte     0
L8741:
    .ascii    ".byte"
    .byte     0
L8740:
    .ascii    ".space"
    .byte     0
L8739:
    .ascii    ".align"
    .byte     0
L8738:
    .ascii    "movsxd"
    .byte     0
L8737:
    .ascii    "imul"
    .byte     0
L8736:
    .ascii    "not"
    .byte     0
L8735:
    .ascii    "xor"
    .byte     0
L8734:
    .ascii    "or"
    .byte     0
L8733:
    .ascii    "and"
    .byte     0
L8732:
    .ascii    "cmov"
    .byte     0
L8731:
    .ascii    "set"
    .byte     0
L8730:
    .ascii    "j"
    .byte     0
L8729:
    .ascii    "    .bss"
    .byte     0
L8728:
    .ascii    "    .data"
    .byte     0
L8727:
    .ascii    "    .text"
    .byte     0
L8726:
    .ascii    ", "
    .byte     0
L8725:
    .ascii    "    .set "
    .byte     0
L8724:
    .ascii    "L#:"
    .byte     0
L8723:
    .ascii    ":"
    .byte     0
L8722:
    .byte     10
    .byte     0
L8721:
    .ascii    ":"
    .byte     0
L8720:
    .byte     0
L8719:
    .ascii    "strmcl/lab"
    .byte     0
L8718:
    .ascii    "# End "
    .byte     0
L8717:
    .ascii    "# Proc "
    .byte     0
L8716:
    .byte     10
    .byte     0
L8715:
    .byte     92
    .byte     34
    .byte     34
    .byte     10
    .byte     0
L8714:
    .ascii    "    .ascii "
    .byte     34
    .ascii    " -export:"
    .byte     92
    .byte     34
    .byte     0
L8713:
    .ascii    "    .section .drectve"
    .byte     10
    .byte     0
L8712:
    .byte     10
    .byte     0
L8711:
    .ascii    "    .global "
    .byte     0
L8710:
    .byte     10
    .byte     0
L8709:
    .ascii    "    .intel_syntax prefix"
    .byte     10
    .byte     0
L8708:
    .ascii    "    .code64"
    .byte     10
    .byte     0
L8707:
    .byte     0
L8706:
    .ascii    "delmcl?"
    .byte     0
L8705:
    .ascii    " ncalldepth:"
    .byte     0
L8704:
    .ascii    " noperands:"
    .byte     0
L8703:
    .ascii    ") hwstack:"
    .byte     0
L8702:
    .ascii    "0 "
    .byte     0
L8701:
    .ascii    "1 "
    .byte     0
L8700:
    .ascii    "XWR:("
    .byte     0
L8699:
    .ascii    ") "
    .byte     0
L8698:
    .ascii    "0 "
    .byte     0
L8697:
    .ascii    "1 "
    .byte     0
L8696:
    .ascii    "WR:("
    .byte     0
L8695:
    .ascii    " "
    .byte     0
L8694:
    .ascii    ") "
    .byte     0
L8693:
    .ascii    ", "
    .byte     0
L8692:
    .ascii    ">"
    .byte     0
L8691:
    .ascii    "<"
    .byte     0
L8690:
    .ascii    "@"
    .byte     0
L8689:
    .ascii    ")"
    .byte     0
L8688:
    .ascii    "(=="
    .byte     0
L8687:
    .ascii    "T"
    .byte     0
L8686:
    .ascii    "*"
    .byte     0
L8685:
    .byte     0
L8684:
    .ascii    "W:"
    .byte     0
L8683:
    .ascii    "X:"
    .byte     0
L8682:
    .ascii    "Y:"
    .byte     0
L8681:
    .ascii    "Z:"
    .byte     0
L8680:
    .ascii    "#:("
    .byte     0
L8679:
    .ascii    "========================================#:("
    .byte     0
L8678:
    .byte     0
L8677:
    .ascii    "MSA"
    .byte     0
L8676:
    .byte     0
L8675:
    .ascii    "makeopndind"
    .byte     0
L8674:
    .byte     0
L8673:
    .ascii    "SOR1"
    .byte     0
L8672:
    .byte     0
L8671:
    .ascii    "MOVE TO REG: XREG IN USE"
    .byte     0
L8670:
    .byte     0
L8669:
    .ascii    "No more work xregs"
    .byte     0
L8668:
    .byte     0
L8667:
    .ascii    "No more work regs"
    .byte     0
L8666:
    .byte     0
L8665:
    .ascii    "poppcl/underflow"
    .byte     0
L8664:
    .byte     0
L8663:
    .ascii    "PCL stack overflow"
    .byte     0
L8662:
    .byte     0
L8661:
    .ascii    "PCL stack overflow"
    .byte     0
L8660:
    .ascii    "getopnd"
    .byte     0
L8659:
    .byte     0
L8658:
    .ascii    "Ext nametab overflow"
    .byte     0
L8657:
    .ascii    "$B#"
    .byte     0
L8656:
    .byte     0
L8655:
    .ascii    "Too many block temps"
    .byte     0
L8654:
    .ascii    "FILENAME="
    .byte     0
L8653:
    .ascii    "LINENO="
    .byte     0
L8652:
    .ascii    "AAPOS="
    .byte     0
L8651:
    .ascii    "AASEQ:"
    .byte     0
L8650:
    .ascii    "AX ERROR:"
    .byte     0
L8649:
    .ascii    "MCL Opnd not supported: # (#) [#]"
    .byte     0
L8648:
    .byte     0
L8647:
    .ascii    "2:SIZE=0"
    .byte     0
L8646:
    .byte     0
L8645:
    .ascii    "1:SIZE=0"
    .byte     0
L8644:
    .byte     0
L8643:
    .ascii    "BAD SEG CODE"
    .byte     0
L8642:
    .byte     0
L8641:
    .ascii    "CAN'T DO RODATA SEG"
    .byte     0
L8640:
    .ascii    "MCLREC>64B"
    .byte     0
L8639:
    .ascii    "__getmainargs*"
    .byte     0
L8638:
    .ascii    "$info"
    .byte     0
L8637:
    .ascii    "$env"
    .byte     0
L8636:
    .ascii    "()"
    .byte     0
L8635:
    .ascii    "High block arg not copied in"
    .byte     0
L8634:
    .ascii    "No host fn:"
    .byte     0
L8633:
    .ascii    "gethostfn?"
    .byte     0
L8632:
    .ascii    "msysc.m$power_i64"
    .byte     0
L8631:
    .ascii    "msys.m$power_i64"
    .byte     0
L8630:
    .byte     0
L8629:
    .ascii    "storebf not imm"
    .byte     0
L8628:
    .byte     0
L8627:
    .ascii    "Storebit: both vars"
    .byte     0
L8626:
    .byte     0
L8625:
    .ascii    "STOREBIT/VAR"
    .byte     0
L8624:
    .byte     0
L8623:
    .ascii    "LOADBF_VAR"
    .byte     0
L8622:
    .ascii    "mask63/offset64"
    .byte     0
L8621:
    .ascii    "labzero"
    .byte     0
L8620:
    .ascii    "labneg64"
    .byte     0
L8619:
    .ascii    "labneg32"
    .byte     0
L8618:
    .ascii    "lababs64"
    .byte     0
L8617:
    .ascii    "lababs32"
    .byte     0
L8615:
    .ascii    "Real32 Table"
    .byte     0
L8613:
    .ascii    "Real Table"
    .byte     0
L8612:
    .ascii    "String Table"
    .byte     0
L8611:
    .ascii    "ENDDATA"
    .byte     0
L8610:
    .byte     0
L8609:
    .ascii    "div/u8"
    .byte     0
L8608:
    .byte     0
L8607:
    .ascii    "Divide by zero"
    .byte     0
L8606:
    .ascii    "---------------"
    .byte     0
L8605:
    .ascii    "?]]"
    .byte     0
L8604:
    .byte     0
L8603:
    .ascii    "Threaded proc has temps"
    .byte     0
L8602:
    .byte     0
L8601:
    .ascii    "Threaded proc has locals/params"
    .byte     0
L8600:
    .byte     0
L8599:
    .ascii    "@PARAM"
    .byte     0
L8598:
    .ascii    "$1x"
    .byte     0
L8596:
    .byte     0
L8595:
    .ascii    "SUBTOREF/EXTRA"
    .byte     0
L8594:
    .ascii    "pow*"
    .byte     0
L8593:
    .byte     0
L8592:
    .ascii    "setcc/block"
    .byte     0
L8591:
    .ascii    "fmod*"
    .byte     0
L8590:
    .ascii    "atan2*"
    .byte     0
L8589:
    .ascii    "ceil*"
    .byte     0
L8588:
    .ascii    "floor*"
    .byte     0
L8587:
    .ascii    "round*"
    .byte     0
L8586:
    .ascii    "exp*"
    .byte     0
L8585:
    .ascii    "log10*"
    .byte     0
L8584:
    .ascii    "log*"
    .byte     0
L8583:
    .ascii    "atan*"
    .byte     0
L8582:
    .ascii    "acos*"
    .byte     0
L8581:
    .ascii    "asin*"
    .byte     0
L8580:
    .ascii    "tan*"
    .byte     0
L8579:
    .ascii    "cos*"
    .byte     0
L8578:
    .ascii    "sin*"
    .byte     0
L8577:
    .byte     0
L8576:
    .ascii    "No Assem handler"
    .byte     0
L8575:
    .byte     0
L8574:
    .ascii    "SUB/REF NOT POWER OF xx"
    .byte     0
L8573:
    .byte     0
L8572:
    .ascii    "float/short"
    .byte     0
L8571:
    .byte     0
L8570:
    .ascii    "multo/byte"
    .byte     0
L8569:
    .ascii    ":"
    .byte     0
L8568:
    .byte     0
L8567:
    .ascii    "swap/block"
    .byte     0
L8566:
    .byte     0
L8565:
    .ascii    "SUBREF/EXTRA"
    .byte     0
L8564:
    .ascii    "EXTRA="
    .byte     0
L8563:
    .byte     0
L8562:
    .ascii    "Storem not 16"
    .byte     0
L8561:
    .ascii    "exit*"
    .byte     0
L8560:
    .byte     0
L8559:
    .ascii    "Too many nested calls"
    .byte     0
L8558:
    .ascii    "---"
    .byte     0
L8557:
    .byte     0
L8556:
    .ascii    "JUMPCC/BLOCK"
    .byte     0
L8555:
    .byte     0
L8554:
    .ascii    "DATA/not 1248"
    .byte     0
L8553:
    .ascii    "STRPMODE(P.MODE)="
    .byte     0
L8552:
    .ascii    "P.SIZE="
    .byte     0
L8551:
    .ascii    "db/dq optype? #"
    .byte     0
L8550:
    .ascii    "PCL STACK NOT EMPTY"
    .byte     0
L8549:
    .ascii    "?>>"
    .byte     0
L8548:
    .ascii    "Unimpl: # (#)"
    .byte     0
L8547:
    .ascii    "                       "
    .byte     0
L8546:
    .ascii    "Invalid handler name:"
    .byte     0
L8545:
    .ascii    "px_"
    .byte     0
L8544:
    .ascii    "z3x8"
    .byte     0
L8543:
    .ascii    "  Loc: # used:#, addrof:#"
    .byte     0
L8542:
    .ascii    "  Pm: # used:#, addrof:#"
    .byte     0
L8541:
    .ascii    "  Hasblocks:#"
    .byte     0
L8540:
    .ascii    "  MCLdone:  #"
    .byte     0
L8539:
    .ascii    "  Assem:    #"
    .byte     0
L8538:
    .ascii    "  Nmaxargs: #"
    .byte     0
L8537:
    .ascii    "  Leaf:     #"
    .byte     0
L8536:
    .ascii    "  Locals:   #"
    .byte     0
L8535:
    .ascii    "  Params:   #"
    .byte     0
L8534:
    .ascii    "PROC INFO FOR: #"
    .byte     0
L8533:
    .ascii    " Has statics"
    .byte     0
L8532:
    .ascii    ")"
    .byte     0
L8531:
    .ascii    "H"
    .byte     0
L8530:
    .ascii    ") (D:"
    .byte     0
L8529:
    .ascii    " (Proc:"
    .byte     0
L8528:
    .ascii    ")"
    .byte     0
L8527:
    .ascii    " "
    .byte     0
L8526:
    .ascii    " ("
    .byte     0
L8525:
    .ascii    "H"
    .byte     0
L8524:
    .ascii    " .PCADDR ="
    .byte     0
L8523:
    .ascii    " ENTRY PT"
    .byte     0
L8522:
    .ascii    " Dot"
    .byte     0
L8521:
    .ascii    " TC"
    .byte     0
L8520:
    .ascii    " Var:"
    .byte     0
L8519:
    .ascii    " Imp"
    .byte     0
L8518:
    .ascii    " Exp"
    .byte     0
L8517:
    .ascii    " Loc:"
    .byte     0
L8516:
    .ascii    " Pm:"
    .byte     0
L8515:
    .ascii    " "
    .byte     0
L8514:
    .ascii    "4"
    .byte     0
L8513:
    .ascii    "21jl"
    .byte     0
L8512:
    .ascii    "    "
    .byte     0
L8511:
    .ascii    "21jl"
    .byte     0
L8510:
    .ascii    "    "
    .byte     0
L8509:
    .ascii    "25jl"
    .byte     0
L8508:
    .ascii    " "
    .byte     0
L8507:
    .ascii    "H"
    .byte     0
L8506:
    .ascii    "PROC PC Symbol table"
    .byte     0
L8505:
    .ascii    " "
    .byte     0
L8504:
    .ascii    "  "
    .byte     0
L8503:
    .ascii    "    data mem:"
    .byte     0
L8502:
    .ascii    " "
    .byte     0
L8501:
    .ascii    ":"
    .byte     0
L8500:
    .ascii    "#"
    .byte     0
L8499:
    .ascii    " "
    .byte     0
L8498:
    .byte     10
    .byte     0
L8497:
    .ascii    " 1"
    .byte     0
L8496:
    .ascii    "extproc    "
    .byte     0
L8495:
    .byte     34
    .byte     0
L8494:
    .ascii    "addlib    "
    .byte     34
    .byte     0
L8493:
    .ascii    "!PROC PCL"
    .byte     0
L8492:
    .ascii    "<BIGSTR>"
    .byte     0
L8491:
    .ascii    "<PCLOPND?>"
    .byte     0
L8490:
    .ascii    "<Data * # (#)>"
    .byte     0
L8489:
    .ascii    "#"
    .byte     0
L8488:
    .ascii    "## "
    .byte     0
L8487:
    .ascii    "&"
    .byte     0
L8486:
    .ascii    ":"
    .byte     0
L8485:
    .byte     34
    .ascii    "*"
    .byte     0
L8484:
    .byte     34
    .byte     0
L8483:
    .ascii    "e16.16"
    .byte     0
L8482:
    .ascii    "infinity"
    .byte     0
L8480:
    .ascii    "<PCLOPND?>"
    .byte     0
L8479:
    .ascii    "---------"
    .byte     0
L8478:
    .ascii    "<Data * # (#)>"
    .byte     0
L8477:
    .byte     0
L8476:
    .ascii    "#"
    .byte     0
L8475:
    .ascii    "## "
    .byte     0
L8474:
    .ascii    "&"
    .byte     0
L8473:
    .ascii    ":"
    .byte     0
L8472:
    .ascii    "*"
    .byte     0
L8471:
    .byte     34
    .byte     0
L8470:
    .ascii    "e16.16"
    .byte     0
L8469:
    .ascii    "infinity"
    .byte     0
L8467:
    .byte     0
L8466:
    .ascii    " "
    .byte     0
L8465:
    .ascii    "/"
    .byte     0
L8464:
    .ascii    " "
    .byte     0
L8463:
    .ascii    "/"
    .byte     0
L8462:
    .ascii    "set"
    .byte     0
L8461:
    .ascii    "jump"
    .byte     0
L8460:
    .ascii    "    "
    .byte     0
L8459:
    .ascii    "endprog"
    .byte     0
L8458:
    .ascii    "endproc"
    .byte     0
L8457:
    .ascii    "    variadic"
    .byte     0
L8456:
    .ascii    "    rettype  "
    .byte     0
L8455:
    .ascii    "       "
    .byte     0
L8454:
    .ascii    "    local    "
    .byte     0
L8453:
    .ascii    "       "
    .byte     0
L8452:
    .ascii    "    param    "
    .byte     0
L8451:
    .ascii    ":"
    .byte     0
L8450:
    .ascii    "::"
    .byte     0
L8449:
    .ascii    " "
    .byte     0
L8448:
    .ascii    "proc"
    .byte     0
L8447:
    .ascii    "tcproc"
    .byte     0
L8446:
    .ascii    "! - - -"
    .byte     0
L8445:
    .ascii    "!"
    .byte     0
L8444:
    .ascii    ":"
    .byte     0
L8443:
    .ascii    "! "
    .byte     0
L8442:
    .ascii    " NOT USED"
    .byte     0
L8441:
    .ascii    "z2h"
    .byte     0
L8439:
    .ascii    "MCL Error: # (#) on Line: # in #, PCL:#"
    .byte     0
L8438:
    .ascii    "Proc:"
    .byte     0
L8437:
    .ascii    "?"
    .byte     0
L8436:
    .ascii    "FILENAME="
    .byte     0
L8435:
    .ascii    "LINENO="
    .byte     0
L8434:
    .ascii    "No proc"
    .byte     0
L8433:
    .ascii    "Dupl proc:"
    .byte     0
L8432:
    .ascii    "Nested proc"
    .byte     0
L8431:
    .byte     0
L8430:
    .ascii    "Too many libs"
    .byte     0
L8429:
    .ascii    "w"
    .byte     0
L8428:
    .ascii    "$error.tmp"
    .byte     0
L8427:
    .ascii    "."
    .byte     0
L8426:
    .ascii    "*"
    .byte     0
L8425:
    .ascii    "`"
    .byte     0
L8424:
    .ascii    "PCL Error:"
    .byte     0
L8423:
    .ascii    ":"
    .byte     0
L8422:
    .ascii    "PCL error:"
    .byte     0
L8421:
    .ascii    "---"
    .byte     0
L8420:
    .ascii    "mem:"
    .byte     0
L8419:
    .byte     0
L8418:
    .ascii    "dummy"
    .byte     0
L8417:
    .ascii    "w"
    .byte     0
L8416:
    .ascii    "Writing"
    .byte     0
L8415:
    .ascii    "w"
    .byte     0
L8414:
    .byte     0
L8413:
    .ascii    "Writing PST"
    .byte     0
L8412:
    .byte     0
L8411:
    .ascii    "Writing PCL"
    .byte     0
L8410:
    .ascii    "PCL start?"
    .byte     0
L8409:
    .ascii    "C:"
    .byte     92
    .ascii    "m"
    .byte     92
    .byte     34
L8408:
    .ascii    "?"
    .byte     0
L8407:
    .ascii    "wb"
    .byte     0
L8406:
    .ascii    "con"
    .byte     0
L8405:
    .ascii    "rb"
    .byte     0
L8404:
    .ascii    "con"
    .byte     0
L8403:
    .ascii    "NOOS"
    .byte     0
L8399:
    .ascii    "@file item too long"
    .byte     0
L8398:
    .ascii    "Unexpected EOF in @file"
    .byte     0
L8397:
    .ascii    "mcx"
    .byte     0
L8396:
    .ascii    "dll"
    .byte     0
L8395:
    .ascii    "Can't open"
    .byte     0
L8394:
    .byte     10
    .byte     0
L8393:
    .ascii    " "
    .byte     0
L8392:
    .byte     0
L8391:
    .ascii    "."
    .byte     0
L8390:
    .byte     0
L8389:
    .ascii    "."
    .byte     0
L8388:
    .ascii    "line too long"
    .byte     0
L8387:
    .ascii    "rb"
    .byte     0
L8386:
    .ascii    "wb"
    .byte     0
L8385:
    .ascii    "rb"
    .byte     0
L8384:
    .ascii    "ABORTING: Press key..."
    .byte     0
L8383:
    .ascii    "Realloc mem failure"
    .byte     0
L8382:
    .ascii    "Alloc mem failure"
    .byte     0
L8381:
    .ascii    "Can't alloc pc heap"
    .byte     0
L8380:
    .ascii    "pcm_alloc failure"
    .byte     0
L8379:
    .ascii    "%.*s"
    .byte     0
L8378:
    .ascii    "MCL-UNIMPL: %s"
    .byte     10
    .byte     0
L8376:
    .ascii    "%lf%n"
    .byte     0
L8374:
    .ascii    "READ CMDLINE"
    .byte     0
L8372:
    .ascii    "<mindint>"
    .byte     0
L8371:
    .ascii    "1000000000000000000000000000000000000000000000000000000000000000"
    .byte     0
L8370:
    .ascii    "8000000000000000"
    .byte     0
L8369:
    .ascii    "9223372036854775808"
    .byte     0
L8368:
    .ascii    "|"
    .byte     0
L8367:
    .ascii    "%.*s"
    .byte     0
L8366:
    .ascii    " "
    .byte     0
L8365:
    .byte     10
    .byte     0
L8364:
    .ascii    "PRTSL"
    .byte     0
L8363:
    .ascii    "<null>"
    .byte     0
L8362:
    .ascii    "%f"
    .byte     0
L8361:
    .ascii    "%llu"
    .byte     0
L8360:
    .ascii    "False"
    .byte     0
L8359:
    .ascii    "True"
    .byte     0
L8358:
    .ascii    "z8H"
    .byte     0
L8357:
    .ascii    "Too many io levels"
    .byte     10
    .byte     0
L8356:
    .ascii    "Too many params"
    .byte     10
    .byte     0
L8355:
    .ascii    "windowsx.h"
    .byte     0
L8354:
    .ascii    "_mingw.h"
    .byte     0
L8353:
    .ascii    "winsock2.h"
    .byte     0
L8352:
    .ascii    "conio.h"
    .byte     0
L8351:
    .ascii    "memory.h"
    .byte     0
L8350:
    .ascii    "process.h"
    .byte     0
L8349:
    .ascii    "direct.h"
    .byte     0
L8348:
    .ascii    "io.h"
    .byte     0
L8347:
    .ascii    "fcntl.h"
    .byte     0
L8346:
    .ascii    "malloc.h"
    .byte     0
L8345:
    .ascii    "sys/utime.h"
    .byte     0
L8344:
    .ascii    "sys/timeb.h"
    .byte     0
L8343:
    .ascii    "sys/stat.h"
    .byte     0
L8342:
    .ascii    "sys/types.h"
    .byte     0
L8341:
    .ascii    "wctype.h"
    .byte     0
L8340:
    .ascii    "wchar.h"
    .byte     0
L8339:
    .ascii    "safelib.h"
    .byte     0
L8338:
    .ascii    "unistd.h"
    .byte     0
L8337:
    .ascii    "utime.h"
    .byte     0
L8336:
    .ascii    "time.h"
    .byte     0
L8335:
    .ascii    "string.h"
    .byte     0
L8334:
    .ascii    "_syslist.h"
    .byte     0
L8333:
    .ascii    "stdlib.h"
    .byte     0
L8332:
    .ascii    "stdio.h"
    .byte     0
L8331:
    .ascii    "stddef.h"
    .byte     0
L8330:
    .ascii    "stdbool.h"
    .byte     0
L8329:
    .ascii    "stdarg.h"
    .byte     0
L8328:
    .ascii    "signal.h"
    .byte     0
L8327:
    .ascii    "setjmp.h"
    .byte     0
L8326:
    .ascii    "math.h"
    .byte     0
L8325:
    .ascii    "_ansi.h"
    .byte     0
L8324:
    .ascii    "locale.h"
    .byte     0
L8323:
    .ascii    "limits.h"
    .byte     0
L8322:
    .ascii    "stdint.h"
    .byte     0
L8321:
    .ascii    "inttypes.h"
    .byte     0
L8320:
    .ascii    "float.h"
    .byte     0
L8319:
    .ascii    "fenv.h"
    .byte     0
L8318:
    .ascii    "errno.h"
    .byte     0
L8317:
    .ascii    "ctype.h"
    .byte     0
L8316:
    .ascii    "assert.h"
    .byte     0
L8315:
    .ascii    "/* Header windowsx.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef $windowsx"
    .byte     13
    .byte     10
    .ascii    "#define $windowsx 1"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define GET_X_LPARAM(lp)                        ((int)(short)LOWORD(lp))"
    .byte     13
    .byte     10
    .ascii    "#define GET_Y_LPARAM(lp)                        ((int)(short)HIWORD(lp))"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#endif // windowsx"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     0
L8314:
    .ascii    "/*"
    .byte     13
    .byte     10
    .ascii    " * _mingw.h"
    .byte     13
    .byte     10
    .ascii    " *"
    .byte     13
    .byte     10
    .ascii    " *  This file is for TinyCC and not part of the Mingw32 package."
    .byte     13
    .byte     10
    .ascii    " *"
    .byte     13
    .byte     10
    .ascii    " *  THIS SOFTWARE IS NOT COPYRIGHTED"
    .byte     13
    .byte     10
    .ascii    " *"
    .byte     13
    .byte     10
    .ascii    " *  This source code is offered for use in the public domain. You may"
    .byte     13
    .byte     10
    .ascii    " *  use, modify or distribute it freely."
    .byte     13
    .byte     10
    .ascii    " *"
    .byte     13
    .byte     10
    .ascii    " *  This code is distributed in the hope that it will be useful but"
    .byte     13
    .byte     10
    .ascii    " *  WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY"
    .byte     13
    .byte     10
    .ascii    " *  DISCLAIMED. This includes but is not limited to warranties of"
    .byte     13
    .byte     10
    .ascii    " *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
    .byte     13
    .byte     10
    .ascii    " *"
    .byte     13
    .byte     10
    .ascii    " */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef __MINGW_H"
    .byte     13
    .byte     10
    .ascii    "#define __MINGW_H"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "/* some winapi files define these before including _mingw.h --> */"
    .byte     13
    .byte     10
    .ascii    "#undef __cdecl"
    .byte     13
    .byte     10
    .ascii    "#undef _X86_"
    .byte     13
    .byte     10
    .ascii    "#undef WIN32"
    .byte     13
    .byte     10
    .ascii    "/* <-- */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#include <stddef.h>"
    .byte     13
    .byte     10
    .ascii    "#include <stdarg.h>"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define __int8 char"
    .byte     13
    .byte     10
    .ascii    "#define __int16 short"
    .byte     13
    .byte     10
    .ascii    "#define __int32 int"
    .byte     13
    .byte     10
    .ascii    "#define __int64 long long"
    .byte     13
    .byte     10
    .ascii    "#define _HAVE_INT64"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define __cdecl"
    .byte     13
    .byte     10
    .ascii    "#define __declspec(x) __attribute__((x))"
    .byte     13
    .byte     10
    .ascii    "#define __unaligned __attribute__((packed))"
    .byte     13
    .byte     10
    .ascii    "#define __fastcall __attribute__((fastcall))"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define __MSVCRT__ 1"
    .byte     13
    .byte     10
    .ascii    "#undef _MSVCRT_"
    .byte     13
    .byte     10
    .ascii    "#define __MINGW_IMPORT extern __declspec(dllimport)"
    .byte     13
    .byte     10
    .ascii    "#define __MINGW_ATTRIB_NORETURN"
    .byte     13
    .byte     10
    .ascii    "#define __MINGW_ATTRIB_CONST"
    .byte     13
    .byte     10
    .ascii    "#define __MINGW_ATTRIB_DEPRECATED"
    .byte     13
    .byte     10
    .ascii    "#define __MINGW_ATTRIB_MALLOC"
    .byte     13
    .byte     10
    .ascii    "#define __MINGW_ATTRIB_PURE"
    .byte     13
    .byte     10
    .ascii    "#define __MINGW_ATTRIB_NONNULL(arg)"
    .byte     13
    .byte     10
    .ascii    "#define __MINGW_NOTHROW"
    .byte     13
    .byte     10
    .ascii    "#define __GNUC_VA_LIST"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define _CRTIMP extern"
    .byte     13
    .byte     10
    .ascii    "#define __CRT_INLINE extern __inline__"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define _CRT_ALIGN(x) __attribute__((aligned(x)))"
    .byte     13
    .byte     10
    .ascii    "#define DECLSPEC_ALIGN(x) __attribute__((aligned(x)))"
    .byte     13
    .byte     10
    .ascii    "#define _CRT_PACKING 8"
    .byte     13
    .byte     10
    .ascii    "#define __CRT_UNALIGNED"
    .byte     13
    .byte     10
    .ascii    "#define _CONST_RETURN"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef _TRUNCATE"
    .byte     13
    .byte     10
    .ascii    "#define _TRUNCATE ((size_t)-1)"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define __CRT_STRINGIZE(_Value) #_Value"
    .byte     13
    .byte     10
    .ascii    "#define _CRT_STRINGIZE(_Value) __CRT_STRINGIZE(_Value)"
    .byte     13
    .byte     10
    .ascii    "#define __CRT_WIDE(_String) L ## _String"
    .byte     13
    .byte     10
    .ascii    "#define _CRT_WIDE(_String) __CRT_WIDE(_String)"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifdef _WIN64"
    .byte     13
    .byte     10
    .ascii    "#define __stdcall"
    .byte     13
    .byte     10
    .ascii    "#define _AMD64_ 1"
    .byte     13
    .byte     10
    .ascii    "#define __x86_64 1"
    .byte     13
    .byte     10
    .ascii    "#define _M_X64 100 /* Visual Studio */"
    .byte     13
    .byte     10
    .ascii    "#define _M_AMD64 100 /* Visual Studio */"
    .byte     13
    .byte     10
    .ascii    "#define USE_MINGW_SETJMP_TWO_ARGS"
    .byte     13
    .byte     10
    .ascii    "#define mingw_getsp tinyc_getbp"
    .byte     13
    .byte     10
    .ascii    "#define __TRY__"
    .byte     13
    .byte     10
    .ascii    "#else"
    .byte     13
    .byte     10
    .ascii    "#define __stdcall __attribute__((__stdcall__))"
    .byte     13
    .byte     10
    .ascii    "#define _X86_ 1"
    .byte     13
    .byte     10
    .ascii    "#define _M_IX86 300 /* Visual Studio */"
    .byte     13
    .byte     10
    .ascii    "#define WIN32 1"
    .byte     13
    .byte     10
    .ascii    "#define _USE_32BIT_TIME_T"
    .byte     13
    .byte     10
    .ascii    "#ifdef __arm__"
    .byte     13
    .byte     10
    .ascii    "#define __TRY__"
    .byte     13
    .byte     10
    .ascii    "#else"
    .byte     13
    .byte     10
    .ascii    "#define __TRY__ void __try__(void**), *_sehrec[6]; __try__(_sehrec);"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "/* in stddef.h */"
    .byte     13
    .byte     10
    .ascii    "#define _SIZE_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "#define _SSIZE_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "#define _PTRDIFF_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "#define _WCHAR_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "#define _UINTPTR_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "#define _INTPTR_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "#define _INTEGRAL_MAX_BITS 64"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef _TIME32_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "#define _TIME32_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "typedef long __time32_t;"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef _TIME64_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "#define _TIME64_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "typedef long long __time64_t;"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef _TIME_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "#define _TIME_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "#ifdef _USE_32BIT_TIME_T"
    .byte     13
    .byte     10
    .ascii    "typedef __time32_t time_t;"
    .byte     13
    .byte     10
    .ascii    "#else"
    .byte     13
    .byte     10
    .ascii    "typedef __time64_t time_t;"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef _WCTYPE_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "#define _WCTYPE_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "typedef wchar_t wctype_t;"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef _WINT_T"
    .byte     13
    .byte     10
    .ascii    "#define _WINT_T"
    .byte     13
    .byte     10
    .ascii    "typedef short wint_t;"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef int errno_t;"
    .byte     13
    .byte     10
    .ascii    "#define _ERRCODE_DEFINED"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef struct threadlocaleinfostruct *pthreadlocinfo;"
    .byte     13
    .byte     10
    .ascii    "typedef struct threadmbcinfostruct *pthreadmbcinfo;"
    .byte     13
    .byte     10
    .ascii    "typedef struct localeinfo_struct _locale_tstruct,*_locale_t;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "/* for winapi */"
    .byte     13
    .byte     10
    .ascii    "#define _ANONYMOUS_UNION"
    .byte     13
    .byte     10
    .ascii    "#define _ANONYMOUS_STRUCT"
    .byte     13
    .byte     10
    .ascii    "#define DECLSPEC_NORETURN"
    .byte     13
    .byte     10
    .ascii    "#define DECLARE_STDCALL_P(type) __stdcall type"
    .byte     13
    .byte     10
    .ascii    "#define NOSERVICE 1"
    .byte     13
    .byte     10
    .ascii    "#define NOMCX 1"
    .byte     13
    .byte     10
    .ascii    "#define NOIME 1"
    .byte     13
    .byte     10
    .ascii    "#define __INTRIN_H_"
    .byte     13
    .byte     10
    .ascii    "#ifndef DUMMYUNIONNAME"
    .byte     13
    .byte     10
    .ascii    "#  define DUMMYUNIONNAME"
    .byte     13
    .byte     10
    .ascii    "#  define DUMMYUNIONNAME1"
    .byte     13
    .byte     10
    .ascii    "#  define DUMMYUNIONNAME2"
    .byte     13
    .byte     10
    .ascii    "#  define DUMMYUNIONNAME3"
    .byte     13
    .byte     10
    .ascii    "#  define DUMMYUNIONNAME4"
    .byte     13
    .byte     10
    .ascii    "#  define DUMMYUNIONNAME5"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .ascii    "#ifndef DUMMYSTRUCTNAME"
    .byte     13
    .byte     10
    .ascii    "#  define DUMMYSTRUCTNAME"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .ascii    "#ifndef WINVER"
    .byte     13
    .byte     10
    .ascii    "# define WINVER 0x0502"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .ascii    "#ifndef _WIN32_WINNT"
    .byte     13
    .byte     10
    .ascii    "# define _WIN32_WINNT 0x502"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define __C89_NAMELESS"
    .byte     13
    .byte     10
    .ascii    "#define __MINGW_EXTENSION"
    .byte     13
    .byte     10
    .ascii    "#define WINAPI_FAMILY_PARTITION(X) 1"
    .byte     13
    .byte     10
    .ascii    "#define MINGW_HAS_SECURE_API"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#endif /* __MINGW_H */"
    .byte     13
    .byte     10
    .byte     0
L8313:
    .ascii    "#ifndef _WINSOCK2_H"
    .byte     13
    .byte     10
    .ascii    "#define _WINSOCK2_H"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#include <_mingw.h>"
    .byte     13
    .byte     10
    .ascii    "#include <windows.h>"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef FD_SETSIZE"
    .byte     13
    .byte     10
    .ascii    "#define FD_SETSIZE 64"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef unsigned int SOCKET;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef struct fd_set {"
    .byte     13
    .byte     10
    .ascii    "  unsigned int   fd_count;"
    .byte     13
    .byte     10
    .ascii    "  SOCKET  fd_array[FD_SETSIZE];"
    .byte     13
    .byte     10
    .ascii    "} fd_set;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "extern int __stdcall __WSAFDIsSet(SOCKET,fd_set *);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef FD_CLR"
    .byte     13
    .byte     10
    .ascii    "#define FD_CLR(fd,set) do { unsigned int __i;"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "for (__i = 0; __i < ((fd_set *)(set))->fd_count ; __i++) {"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "    if (((fd_set *)(set))->fd_array[__i] == (fd)) {"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "    while (__i < ((fd_set *)(set))->fd_count-1) {"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "        ((fd_set*)(set))->fd_array[__i] = ((fd_set*)(set))->fd_array[__i+1];"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "        __i++;"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "    }"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "    ((fd_set*)(set))->fd_count--;"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "    break;"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "    }"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "}"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "} while (0)"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef FD_SET"
    .byte     13
    .byte     10
    .ascii    "/* this differs from the define in winsock.h and in cygwin sys/types.h */"
    .byte     13
    .byte     10
    .ascii    "#define FD_SET(fd, set) do { unsigned int __i;"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "for (__i = 0; __i < ((fd_set *)(set))->fd_count ; __i++) {"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "    if (((fd_set *)(set))->fd_array[__i] == (fd)) {"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "        break;"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "    }"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "}"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "if (__i == ((fd_set *)(set))->fd_count) {"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "    if (((fd_set *)(set))->fd_count < FD_SETSIZE) {"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "        ((fd_set *)(set))->fd_array[__i] = (fd);"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "        ((fd_set *)(set))->fd_count++;"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "    }"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "}"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "} while(0)"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef FD_ZERO"
    .byte     13
    .byte     10
    .ascii    "#define FD_ZERO(set) (((fd_set *)(set))->fd_count=0)"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef FD_ISSET"
    .byte     13
    .byte     10
    .ascii    "#define FD_ISSET(fd, set) __WSAFDIsSet((SOCKET)(fd), (fd_set *)(set))"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef _TIMEVAL_DEFINED /* also in sys/time.h */"
    .byte     13
    .byte     10
    .ascii    "#define _TIMEVAL_DEFINED"
    .byte     13
    .byte     10
    .ascii    "struct timeval {"
    .byte     13
    .byte     10
    .ascii    "    long tv_sec;"
    .byte     13
    .byte     10
    .ascii    "    long tv_usec;"
    .byte     13
    .byte     10
    .ascii    "};"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "struct in_addr {"
    .byte     13
    .byte     10
    .ascii    "    union {"
    .byte     13
    .byte     10
    .ascii    "        struct { unsigned char s_b1,s_b2,s_b3,s_b4; } S_un_b;"
    .byte     13
    .byte     10
    .ascii    "        struct { unsigned short s_w1,s_w2; } S_un_w;"
    .byte     13
    .byte     10
    .ascii    "        unsigned long S_addr;"
    .byte     13
    .byte     10
    .ascii    "    } S_un;"
    .byte     13
    .byte     10
    .ascii    "};"
    .byte     13
    .byte     10
    .ascii    "#define s_addr  S_un.S_addr"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "struct sockaddr_in {"
    .byte     13
    .byte     10
    .ascii    "    short sin_family;"
    .byte     13
    .byte     10
    .ascii    "    unsigned short sin_port;"
    .byte     13
    .byte     10
    .ascii    "    struct in_addr sin_addr;"
    .byte     13
    .byte     10
    .ascii    "    char sin_zero[8];"
    .byte     13
    .byte     10
    .ascii    "};"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "struct sockaddr {"
    .byte     13
    .byte     10
    .ascii    "    unsigned short sa_family;"
    .byte     13
    .byte     10
    .ascii    "    char sa_data[14];"
    .byte     13
    .byte     10
    .ascii    "};"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "struct hostent {"
    .byte     13
    .byte     10
    .ascii    "    char *h_name;"
    .byte     13
    .byte     10
    .ascii    "    char **h_aliases;"
    .byte     13
    .byte     10
    .ascii    "    short h_addrtype;"
    .byte     13
    .byte     10
    .ascii    "    short h_length;"
    .byte     13
    .byte     10
    .ascii    "    char **h_addr_list;"
    .byte     13
    .byte     10
    .ascii    "};"
    .byte     13
    .byte     10
    .ascii    "#define h_addr h_addr_list[0]"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define WSADESCRIPTION_LEN  256"
    .byte     13
    .byte     10
    .ascii    "#define WSASYS_STATUS_LEN   128"
    .byte     13
    .byte     10
    .ascii    "typedef struct WSAData {"
    .byte     13
    .byte     10
    .ascii    "    WORD wVersion;"
    .byte     13
    .byte     10
    .ascii    "    WORD wHighVersion;"
    .byte     13
    .byte     10
    .ascii    "    char szDescription[WSADESCRIPTION_LEN+1];"
    .byte     13
    .byte     10
    .ascii    "    char szSystemStatus[WSASYS_STATUS_LEN+1];"
    .byte     13
    .byte     10
    .ascii    "    unsigned short iMaxSockets;"
    .byte     13
    .byte     10
    .ascii    "    unsigned short iMaxUdpDg;"
    .byte     13
    .byte     10
    .ascii    "    char *lpVendorInfo;"
    .byte     13
    .byte     10
    .ascii    "} WSADATA;"
    .byte     13
    .byte     10
    .ascii    "typedef WSADATA *LPWSADATA;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define INVALID_SOCKET (SOCKET)(~0)"
    .byte     13
    .byte     10
    .ascii    "#define SOCK_STREAM  1"
    .byte     13
    .byte     10
    .ascii    "#define SO_REUSEADDR 4"
    .byte     13
    .byte     10
    .ascii    "#define AF_INET 2"
    .byte     13
    .byte     10
    .ascii    "#define MSG_PEEK 0x2"
    .byte     13
    .byte     10
    .ascii    "#define INADDR_ANY (unsigned long)0x00000000"
    .byte     13
    .byte     10
    .ascii    "#define INADDR_LOOPBACK 0x7f000001"
    .byte     13
    .byte     10
    .ascii    "#define SOL_SOCKET 0xffff"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define SD_RECEIVE  0x00"
    .byte     13
    .byte     10
    .ascii    "#define SD_SEND     0x01"
    .byte     13
    .byte     10
    .ascii    "#define SD_BOTH     0x02"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define h_errno WSAGetLastError()"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define WSABASEERR 10000"
    .byte     13
    .byte     10
    .ascii    "#define TRY_AGAIN (WSABASEERR+1002)"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "SOCKET __stdcall accept(SOCKET, struct sockaddr *, int *);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall bind(SOCKET, const struct sockaddr *, int);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall closesocket(SOCKET);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall connect(SOCKET, const struct sockaddr *, int);"
    .byte     13
    .byte     10
    .ascii    "struct hostent *__stdcall gethostbyname(const char *);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall gethostname(char *, int);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall getpeername(SOCKET, struct sockaddr *, int *);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall getsockname(SOCKET, struct sockaddr *, int *);"
    .byte     13
    .byte     10
    .ascii    "unsigned long __stdcall htonl(unsigned long);"
    .byte     13
    .byte     10
    .ascii    "unsigned short __stdcall htons(unsigned short);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall listen(SOCKET, int);"
    .byte     13
    .byte     10
    .ascii    "unsigned long __stdcall ntohl(unsigned long);"
    .byte     13
    .byte     10
    .ascii    "unsigned short __stdcall ntohs(unsigned short);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall recv(SOCKET, char *, int, int);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall recvfrom(SOCKET, char *, int, int, struct sockaddr *, int *);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall select(int nfds, fd_set *, fd_set *, fd_set *, const struct timeval *);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall send(SOCKET, const char *, int, int);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall sendto(SOCKET, const char *, int, int, const struct sockaddr *, int);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall setsockopt(SOCKET, int, int, const char *, int);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall shutdown(SOCKET, int);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall WSACleanup(void);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall WSAGetLastError(void);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall WSAStartup(WORD, LPWSADATA);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "SOCKET __stdcall socket(int, int, int);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     0
L8312:
    .ascii    "/* conio.h */"
    .byte     13
    .byte     10
    .ascii    "#include <stddef.h>"
    .byte     13
    .byte     10
    .ascii    "#include <wchar.h>"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _getch(void);"
    .byte     13
    .byte     10
    .ascii    "int _kbhit(void);"
    .byte     13
    .byte     10
    .ascii    "wint_t _getwch(void);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define getch _getch"
    .byte     13
    .byte     10
    .ascii    "#define kbhit _kbhit"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _putch(int);"
    .byte     13
    .byte     10
    .ascii    "int _cprintf(char *, ...);"
    .byte     13
    .byte     10
    .ascii    "int _getche(void);"
    .byte     13
    .byte     10
    .ascii    "int _ungetch(int);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define putch _putch"
    .byte     13
    .byte     10
    .ascii    "#define cprintf _cprintf"
    .byte     13
    .byte     10
    .ascii    "#define getche _getche"
    .byte     13
    .byte     10
    .ascii    "#define ungetch _ungetch"
    .byte     13
    .byte     10
    .byte     0
L8311:
    .ascii    "#include <stddef.h>"
    .byte     10
    .byte     10
    .ascii    "void* malloc(size_t);"
    .byte     10
    .ascii    "void* realloc(void *, size_t);"
    .byte     10
    .ascii    "void  free(void *);"
    .byte     10
    .ascii    "void *_alloca(size_t);"
    .byte     10
    .byte     10
    .ascii    "#define alloca malloc"
    .byte     10
    .byte     0
L8310:
    .ascii    "/* Header process.h */"
    .byte     13
    .byte     10
    .ascii    "#ifndef $process"
    .byte     13
    .byte     10
    .ascii    "#define $process"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#include <stdint.h>"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define P_WAIT"
    .byte     9
    .byte     9
    .ascii    "0"
    .byte     13
    .byte     10
    .ascii    "#define P_NOWAIT"
    .byte     9
    .ascii    "1"
    .byte     13
    .byte     10
    .ascii    "#define P_OVERLAY"
    .byte     9
    .ascii    "2"
    .byte     13
    .byte     10
    .ascii    "#define P_DETACH"
    .byte     9
    .ascii    "4"
    .byte     13
    .byte     10
    .ascii    "#define WAIT_CHILD 0"
    .byte     13
    .byte     10
    .ascii    "#define _P_WAIT P_WAIT"
    .byte     13
    .byte     10
    .ascii    "#define _P_NOWAIT P_NOWAIT"
    .byte     13
    .byte     10
    .ascii    "#define _P_OVERLAY P_OVERLAY"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _spawnvp(int, const char*, const char*const*);"
    .byte     13
    .byte     10
    .ascii    "#define spawnvp _spawnvp"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "void endthread(void);"
    .byte     13
    .byte     10
    .ascii    "unsigned long _beginthreadex(void *,unsigned,unsigned (*)(void *),void *,unsigned,unsigned *);"
    .byte     13
    .byte     10
    .ascii    "void _endthreadex(unsigned);"
    .byte     13
    .byte     10
    .ascii    "int _cwait(int*, int, int);"
    .byte     13
    .byte     10
    .ascii    "#define cwait _cwait"
    .byte     13
    .byte     10
    .ascii    "//int _System(const char *cmd,int nCmdShow);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "intptr_t _execve(const char*, const char*const*, const char*const*);"
    .byte     13
    .byte     10
    .ascii    "#define execve _execve"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "//#define _WAIT_CHILD"
    .byte     9
    .ascii    "0"
    .byte     13
    .byte     10
    .ascii    "//#endif"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     0
L8309:
    .ascii    "#ifndef $direct"
    .byte     13
    .byte     10
    .ascii    "#define $direct"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef struct {"
    .byte     13
    .byte     10
    .ascii    " unsigned int total_clusters;"
    .byte     13
    .byte     10
    .ascii    " unsigned int avail_clusters;"
    .byte     13
    .byte     10
    .ascii    " unsigned int sectors_per_cluster;"
    .byte     13
    .byte     10
    .ascii    " unsigned int bytes_per_sector;"
    .byte     13
    .byte     10
    .ascii    "} diskfree_t;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int chdir(const char *);"
    .byte     13
    .byte     10
    .ascii    "char* _getcwd(char *, int);"
    .byte     13
    .byte     10
    .ascii    "#define getcwd _getcwd"
    .byte     13
    .byte     10
    .ascii    "int _mkdir(const char *);"
    .byte     13
    .byte     10
    .ascii    "int _rmdir(const char *);"
    .byte     13
    .byte     10
    .ascii    "int _wrmdir(const wchar_t*);"
    .byte     13
    .byte     10
    .ascii    "int _wmkdir(const wchar_t*);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define mkdir _mkdir"
    .byte     13
    .byte     10
    .ascii    "#define rmdir _rmdir"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _chdrive(int);"
    .byte     13
    .byte     10
    .ascii    "char* _getdcwd(int, char *, int);"
    .byte     13
    .byte     10
    .ascii    "wchar_t* _wgetcwd(wchar_t*, int);"
    .byte     13
    .byte     10
    .ascii    "int _wchdir(const wchar_t*);"
    .byte     13
    .byte     10
    .ascii    "int _getdrive(void);"
    .byte     13
    .byte     10
    .ascii    "int _chdir(const char*);"
    .byte     13
    .byte     10
    .ascii    "#define chdir _chdir"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "unsigned long _getdrives(void);"
    .byte     13
    .byte     10
    .ascii    "unsigned int _getdiskfree(unsigned int, diskfree_t*);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     0
L8308:
    .byte     13
    .byte     10
    .ascii    "#ifndef $io"
    .byte     13
    .byte     10
    .ascii    "#define $io"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#include <stdint.h>"
    .byte     13
    .byte     10
    .ascii    "#include <wchar.h>"
    .byte     13
    .byte     10
    .ascii    "#include <time.h>"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "/* io.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define _A_NORMAL 0x00"
    .byte     13
    .byte     10
    .ascii    "#define _A_RDONLY 0x01"
    .byte     13
    .byte     10
    .ascii    "#define _A_HIDDEN 0x02"
    .byte     13
    .byte     10
    .ascii    "#define _A_SYSTEM 0x04"
    .byte     13
    .byte     10
    .ascii    "#define _A_SUBDIR 0x10"
    .byte     13
    .byte     10
    .ascii    "#define _A_ARCH 0x20"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "//#message "
    .byte     34
    .ascii    "IO included"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "struct _finddata_t {"
    .byte     13
    .byte     10
    .ascii    "        unsigned    attrib;"
    .byte     13
    .byte     10
    .ascii    "        time_t      time_create;"
    .byte     13
    .byte     10
    .ascii    "        time_t      time_access;"
    .byte     13
    .byte     10
    .ascii    "        time_t      time_write;"
    .byte     13
    .byte     10
    .ascii    "        unsigned long    size;"
    .byte     13
    .byte     10
    .ascii    "        char        name[260];"
    .byte     13
    .byte     10
    .ascii    "};"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _isatty(int);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _read(int, void*, unsigned int);"
    .byte     13
    .byte     10
    .ascii    "#define read _read"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _open(const char*, int, ...);"
    .byte     13
    .byte     10
    .ascii    "#define open _open"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "long _lseek(int, long, int);"
    .byte     13
    .byte     10
    .ascii    "#define lseek _lseek"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _close(int);"
    .byte     13
    .byte     10
    .ascii    "#define close _close"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "intptr_t _get_osfhandle(int);"
    .byte     13
    .byte     10
    .ascii    "int _open_osfhandle(intptr_t,int);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _setmode(int,int);"
    .byte     13
    .byte     10
    .ascii    "#define setmode _setmode"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _wchmod(const wchar_t*, int);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _chmod(const char *, int);"
    .byte     13
    .byte     10
    .ascii    "#define chmod _chmod"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _dup(int);"
    .byte     13
    .byte     10
    .ascii    "#define dup _dup"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "intptr_t _findfirst(const char*, struct _finddata_t*);"
    .byte     13
    .byte     10
    .ascii    "int _findnext(intptr_t, struct _finddata_t*);"
    .byte     13
    .byte     10
    .ascii    "int _findclose(intptr_t);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _access(const char*,int);"
    .byte     13
    .byte     10
    .ascii    "#define access _access"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _wunlink(const wchar_t*);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     0
L8307:
    .ascii    "/* FCNTL.H */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _setmode(int,int);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef _INC_FCNTL"
    .byte     13
    .byte     10
    .ascii    "#define _INC_FCNTL"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define _O_RDONLY 0x0000"
    .byte     13
    .byte     10
    .ascii    "#define _O_WRONLY 0x0001"
    .byte     13
    .byte     10
    .ascii    "#define _O_RDWR 0x0002"
    .byte     13
    .byte     10
    .ascii    "#define _O_APPEND 0x0008"
    .byte     13
    .byte     10
    .ascii    "#define _O_CREAT 0x0100"
    .byte     13
    .byte     10
    .ascii    "#define _O_TRUNC 0x0200"
    .byte     13
    .byte     10
    .ascii    "#define _O_EXCL 0x0400"
    .byte     13
    .byte     10
    .ascii    "#define _O_TEXT 0x4000"
    .byte     13
    .byte     10
    .ascii    "#define _O_BINARY 0x8000"
    .byte     13
    .byte     10
    .ascii    "#define _O_WTEXT 0x10000"
    .byte     13
    .byte     10
    .ascii    "#define _O_U16TEXT 0x20000"
    .byte     13
    .byte     10
    .ascii    "#define _O_U8TEXT 0x40000"
    .byte     13
    .byte     10
    .ascii    "#define _O_ACCMODE (_O_RDONLY|_O_WRONLY|_O_RDWR)"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define _O_RAW _O_BINARY"
    .byte     13
    .byte     10
    .ascii    "#define _O_NOINHERIT 0x0080"
    .byte     13
    .byte     10
    .ascii    "#define _O_TEMPORARY 0x0040"
    .byte     13
    .byte     10
    .ascii    "#define _O_SHORT_LIVED 0x1000"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define _O_SEQUENTIAL 0x0020"
    .byte     13
    .byte     10
    .ascii    "#define _O_RANDOM 0x0010"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#if !defined(NO_OLDNAMES) || defined(_POSIX)"
    .byte     13
    .byte     10
    .ascii    "#define O_RDONLY _O_RDONLY"
    .byte     13
    .byte     10
    .ascii    "#define O_WRONLY _O_WRONLY"
    .byte     13
    .byte     10
    .ascii    "#define O_RDWR _O_RDWR"
    .byte     13
    .byte     10
    .ascii    "#define O_APPEND _O_APPEND"
    .byte     13
    .byte     10
    .ascii    "#define O_CREAT _O_CREAT"
    .byte     13
    .byte     10
    .ascii    "#define O_TRUNC _O_TRUNC"
    .byte     13
    .byte     10
    .ascii    "#define O_EXCL _O_EXCL"
    .byte     13
    .byte     10
    .ascii    "#define O_TEXT _O_TEXT"
    .byte     13
    .byte     10
    .ascii    "#define O_BINARY _O_BINARY"
    .byte     13
    .byte     10
    .ascii    "#define O_RAW _O_BINARY"
    .byte     13
    .byte     10
    .ascii    "#define O_TEMPORARY _O_TEMPORARY"
    .byte     13
    .byte     10
    .ascii    "#define O_NOINHERIT _O_NOINHERIT"
    .byte     13
    .byte     10
    .ascii    "#define O_SEQUENTIAL _O_SEQUENTIAL"
    .byte     13
    .byte     10
    .ascii    "#define O_RANDOM _O_RANDOM"
    .byte     13
    .byte     10
    .ascii    "#define O_ACCMODE _O_ACCMODE"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     0
L8306:
    .ascii    "#include <malloc.h>"
    .byte     13
    .byte     10
    .byte     0
L8305:
    .ascii    "/* sys/utime.h header */"
    .byte     10
    .byte     10
    .ascii    "#ifndef $utime"
    .byte     10
    .ascii    "#define $utime"
    .byte     10
    .byte     10
    .ascii    "struct _utimbuf {"
    .byte     10
    .byte     9
    .ascii    "long actime;"
    .byte     10
    .byte     9
    .ascii    "long modtime;"
    .byte     10
    .ascii    "};"
    .byte     10
    .byte     10
    .byte     10
    .ascii    "struct utimbuf {"
    .byte     10
    .byte     9
    .ascii    "long actime;"
    .byte     10
    .byte     9
    .ascii    "long modtime;"
    .byte     10
    .ascii    "};"
    .byte     10
    .byte     10
    .ascii    "struct __utimbuf64 {"
    .byte     10
    .ascii    "  long long int actime;"
    .byte     10
    .ascii    "  long long int modtime;"
    .byte     10
    .ascii    "};"
    .byte     10
    .byte     10
    .ascii    "int _utime64(const char *_Filename,struct __utimbuf64 *_Time);"
    .byte     10
    .byte     10
    .ascii    "int utime(const char *_Filename,struct utimbuf *_Utimbuf) {"
    .byte     10
    .ascii    "  return _utime64(_Filename,(struct __utimbuf64 *)_Utimbuf);"
    .byte     10
    .ascii    "}"
    .byte     10
    .byte     10
    .ascii    "#endif"
    .byte     10
    .byte     0
L8304:
    .ascii    "/* timeb.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef $timeb"
    .byte     13
    .byte     10
    .ascii    "#define $timeb"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#include <time.h>"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "struct _timeb {"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "time_t time;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "unsigned short millitm;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "short timezone;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "short dstflag;"
    .byte     13
    .byte     10
    .ascii    "};"
    .byte     13
    .byte     10
    .ascii    "#define timeb _timeb"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "void _ftime64(struct _timeb*);"
    .byte     13
    .byte     10
    .ascii    "#define _ftime _ftime64"
    .byte     13
    .byte     10
    .ascii    "#define ftime _ftime64"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     0
L8303:
    .ascii    "/* stat.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef $sysstat"
    .byte     13
    .byte     10
    .ascii    "#define $sysstat"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#include <stddef.h>"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "struct _stat {"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "unsigned int"
    .byte     9
    .ascii    "st_dev;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "unsigned short"
    .byte     9
    .ascii    "st_ino;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "unsigned short"
    .byte     9
    .ascii    "st_mode;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "short"
    .byte     9
    .byte     9
    .byte     9
    .ascii    "st_nlink;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "short"
    .byte     9
    .byte     9
    .byte     9
    .ascii    "st_uid;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "short"
    .byte     9
    .byte     9
    .byte     9
    .ascii    "st_gid;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "unsigned long"
    .byte     9
    .ascii    "st_rdev;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "unsigned int"
    .byte     9
    .ascii    "st_size;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "unsigned long long int"
    .byte     9
    .ascii    "st_atime;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "unsigned long long int"
    .byte     9
    .ascii    "st_mtime;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "unsigned long long int"
    .byte     9
    .ascii    "st_ctime;"
    .byte     13
    .byte     10
    .ascii    "};"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define stat _stat"
    .byte     13
    .byte     10
    .ascii    "#define _stati64 _stat"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define _S_IFMT 0xF000"
    .byte     13
    .byte     10
    .ascii    "#define _S_IFDIR 0x4000"
    .byte     13
    .byte     10
    .ascii    "#define _S_IFCHR 0x2000"
    .byte     13
    .byte     10
    .ascii    "#define _S_IFIFO 0x1000"
    .byte     13
    .byte     10
    .ascii    "#define _S_IFREG 0x8000"
    .byte     13
    .byte     10
    .ascii    "#define _S_IREAD 0x0100"
    .byte     13
    .byte     10
    .ascii    "#define _S_IWRITE 0x0080"
    .byte     13
    .byte     10
    .ascii    "#define _S_IEXEC 0x0040"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define S_IFMT 0xF000"
    .byte     13
    .byte     10
    .ascii    "#define S_IFDIR 0x4000"
    .byte     13
    .byte     10
    .ascii    "#define S_IFCHR 0x2000"
    .byte     13
    .byte     10
    .ascii    "#define S_IFIFO 0x1000"
    .byte     13
    .byte     10
    .ascii    "#define S_IFREG 0x8000"
    .byte     13
    .byte     10
    .ascii    "#define S_IREAD 0x0100"
    .byte     13
    .byte     10
    .ascii    "#define S_IWRITE 0x0080"
    .byte     13
    .byte     10
    .ascii    "#define S_IEXEC 0x0040"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define S_ISCHR(nd) (((nd) & S_IFMT) == S_IFCHR)"
    .byte     13
    .byte     10
    .ascii    "#define S_ISDIR(nd) (((nd) & S_IFMT) == S_IFDIR)"
    .byte     13
    .byte     10
    .ascii    "#define S_ISFIFO(nd) (((nd) & S_IFMT) == S_IFIFO)"
    .byte     13
    .byte     10
    .ascii    "#define S_ISREG(nd) (((nd) & S_IFMT) == S_IFREG)"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define"
    .byte     9
    .ascii    "_S_IRWXU"
    .byte     9
    .ascii    "(_S_IREAD | _S_IWRITE | _S_IEXEC)"
    .byte     13
    .byte     10
    .ascii    "#define"
    .byte     9
    .ascii    "_S_IXUSR"
    .byte     9
    .ascii    "_S_IEXEC"
    .byte     13
    .byte     10
    .ascii    "#define"
    .byte     9
    .ascii    "_S_IWUSR"
    .byte     9
    .ascii    "_S_IWRITE"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define"
    .byte     9
    .ascii    "S_IRWXU"
    .byte     9
    .byte     9
    .ascii    "_S_IRWXU"
    .byte     13
    .byte     10
    .ascii    "#define"
    .byte     9
    .ascii    "S_IXUSR"
    .byte     9
    .byte     9
    .ascii    "_S_IXUSR"
    .byte     13
    .byte     10
    .ascii    "#define"
    .byte     9
    .ascii    "S_IWUSR"
    .byte     9
    .byte     9
    .ascii    "_S_IWUSR"
    .byte     13
    .byte     10
    .ascii    "#define"
    .byte     9
    .ascii    "S_IRUSR"
    .byte     9
    .byte     9
    .ascii    "_S_IRUSR"
    .byte     13
    .byte     10
    .ascii    "#define"
    .byte     9
    .ascii    "_S_IRUSR"
    .byte     9
    .ascii    "_S_IREAD"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define S_IRGRP    (S_IRUSR >> 3)"
    .byte     13
    .byte     10
    .ascii    "#define S_IWGRP    (S_IWUSR >> 3)"
    .byte     13
    .byte     10
    .ascii    "#define S_IXGRP    (S_IXUSR >> 3)"
    .byte     13
    .byte     10
    .ascii    "#define S_IRWXG    (S_IRWXU >> 3)"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define S_IROTH    (S_IRGRP >> 3)"
    .byte     13
    .byte     10
    .ascii    "#define S_IWOTH    (S_IWGRP >> 3)"
    .byte     13
    .byte     10
    .ascii    "#define S_IXOTH    (S_IXGRP >> 3)"
    .byte     13
    .byte     10
    .ascii    "#define S_IRWXO    (S_IRWXG >> 3)"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "//#define"
    .byte     9
    .ascii    "S_ISDIR(m)"
    .byte     9
    .ascii    "(((m) & S_IFMT) == S_IFDIR)"
    .byte     13
    .byte     10
    .ascii    "//#define"
    .byte     9
    .ascii    "S_ISFIFO(m)"
    .byte     9
    .ascii    "(((m) & S_IFMT) == S_IFIFO)"
    .byte     13
    .byte     10
    .ascii    "//#define"
    .byte     9
    .ascii    "S_ISCHR(m)"
    .byte     9
    .ascii    "(((m) & S_IFMT) == S_IFCHR)"
    .byte     13
    .byte     10
    .ascii    "#define"
    .byte     9
    .ascii    "S_IFBLK"
    .byte     9
    .ascii    "0x3000"
    .byte     9
    .ascii    "/* Block: Is this ever set under w32? */"
    .byte     13
    .byte     10
    .ascii    "#define"
    .byte     9
    .ascii    "S_ISBLK(m)"
    .byte     9
    .ascii    "(((m) & S_IFMT) == S_IFBLK)"
    .byte     13
    .byte     10
    .ascii    "#define"
    .byte     9
    .ascii    "S_ISREG(m)"
    .byte     9
    .ascii    "(((m) & S_IFMT) == S_IFREG)"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int stat(const char *, struct stat*);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _fstati64(int, struct stat*);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int fstat(int, struct stat *);"
    .byte     13
    .byte     10
    .ascii    "#define _fstat fstat"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _wstati64(const wchar_t,struct _stati64 *buffer);  "
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     0
L8302:
    .ascii    "/* types.h */"
    .byte     13
    .byte     10
    .ascii    "#ifndef $systypes"
    .byte     13
    .byte     10
    .ascii    "#define $systypes 1"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef long int off_t;"
    .byte     13
    .byte     10
    .ascii    "typedef long int ino_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned int dev_t;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef long long time_t;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     0
L8301:
    .ascii    "/* Header wctype.h */"
    .byte     13
    .byte     10
    .byte     0
L8300:
    .ascii    "/* Header wchar.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#include <stddef.h>"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define _WCHAR_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned short wint_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned short wchar_t;"
    .byte     13
    .byte     10
    .ascii    "//typedef signed short wchar_t;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "size_t wcslen(const wchar_t*);"
    .byte     13
    .byte     10
    .ascii    "wchar_t* wcscpy(wchar_t*,const wchar_t*);"
    .byte     13
    .byte     10
    .ascii    "//wchar_t* _wgetenv(constwchar_t*);"
    .byte     13
    .byte     10
    .ascii    "wchar_t* wcstok(wchar_t*,wchar_t*,wchar_t**);"
    .byte     13
    .byte     10
    .ascii    "wchar_t* wcstok_s(wchar_t*,wchar_t*,wchar_t**);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "wchar_t* wcschr(wchar_t*,wchar_t);"
    .byte     13
    .byte     10
    .ascii    "wchar_t* wcsstr(const wchar_t*,const wchar_t*);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int wcscmp(const wchar_t*,const wchar_t*);"
    .byte     13
    .byte     10
    .ascii    "typedef long _off_t;"
    .byte     13
    .byte     10
    .byte     0
L8299:
    .ascii    "/* Header safelib.h */"
    .byte     13
    .byte     10
    .byte     0
L8298:
    .ascii    "/* unistd.h header */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "unsigned int _sleep(unsigned int);"
    .byte     13
    .byte     10
    .ascii    "#define sleep _sleep"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define alarm(x) {puts("
    .byte     34
    .ascii    "ALARM"
    .byte     34
    .ascii    "); exit(1);}"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _write(int,void*,unsigned int);"
    .byte     13
    .byte     10
    .ascii    "#define write _write"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _close(int);"
    .byte     13
    .byte     10
    .ascii    "#define close _close"
    .byte     13
    .byte     10
    .byte     0
L8297:
    .ascii    "/* sys/utime.h header */"
    .byte     10
    .byte     10
    .ascii    "#ifndef $utime"
    .byte     10
    .ascii    "#define $utime"
    .byte     10
    .byte     10
    .ascii    "struct _utimbuf {"
    .byte     10
    .byte     9
    .ascii    "long actime;"
    .byte     10
    .byte     9
    .ascii    "long modtime;"
    .byte     10
    .ascii    "};"
    .byte     10
    .byte     10
    .byte     10
    .ascii    "struct utimbuf {"
    .byte     10
    .byte     9
    .ascii    "long actime;"
    .byte     10
    .byte     9
    .ascii    "long modtime;"
    .byte     10
    .ascii    "};"
    .byte     10
    .byte     10
    .ascii    "struct __utimbuf64 {"
    .byte     10
    .ascii    "  long long int actime;"
    .byte     10
    .ascii    "  long long int modtime;"
    .byte     10
    .ascii    "};"
    .byte     10
    .byte     10
    .ascii    "int _utime64(const char *_Filename,struct __utimbuf64 *_Time);"
    .byte     10
    .byte     10
    .ascii    "int utime(const char *_Filename,struct utimbuf *_Utimbuf) {"
    .byte     10
    .ascii    "  return _utime64(_Filename,(struct __utimbuf64 *)_Utimbuf);"
    .byte     10
    .ascii    "}"
    .byte     10
    .byte     10
    .ascii    "#endif"
    .byte     10
    .byte     0
L8296:
    .ascii    "/* Header time.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef $time"
    .byte     13
    .byte     10
    .ascii    "#define $time"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#include <stddef.h>"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef long clock_t;"
    .byte     13
    .byte     10
    .ascii    "clock_t clock(void);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "//typedef long time_t;"
    .byte     13
    .byte     10
    .ascii    "#ifndef _TIME_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "#define _TIME_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "typedef long long int time_t;"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "struct tm"
    .byte     13
    .byte     10
    .ascii    "{"
    .byte     13
    .byte     10
    .ascii    "  int"
    .byte     9
    .ascii    "tm_sec;"
    .byte     13
    .byte     10
    .ascii    "  int"
    .byte     9
    .ascii    "tm_min;"
    .byte     13
    .byte     10
    .ascii    "  int"
    .byte     9
    .ascii    "tm_hour;"
    .byte     13
    .byte     10
    .ascii    "  int"
    .byte     9
    .ascii    "tm_mday;"
    .byte     13
    .byte     10
    .ascii    "  int"
    .byte     9
    .ascii    "tm_mon;"
    .byte     13
    .byte     10
    .ascii    "  int"
    .byte     9
    .ascii    "tm_year;"
    .byte     13
    .byte     10
    .ascii    "  int"
    .byte     9
    .ascii    "tm_wday;"
    .byte     13
    .byte     10
    .ascii    "  int"
    .byte     9
    .ascii    "tm_yday;"
    .byte     13
    .byte     10
    .ascii    "  int"
    .byte     9
    .ascii    "tm_isdst;"
    .byte     13
    .byte     10
    .ascii    "};"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "//struct tm *localtime(time_t*);"
    .byte     13
    .byte     10
    .ascii    "struct tm* _localtime32(time_t*);"
    .byte     13
    .byte     10
    .ascii    "#define localtime _localtime32"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "time_t _time64(time_t *_timer);"
    .byte     13
    .byte     10
    .ascii    "#define time _time64"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define CLOCKS_PER_SEC 1000"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "struct tm *gmtime(const time_t*);"
    .byte     13
    .byte     10
    .ascii    "size_t strftime(char *, size_t, const char *, const struct tm *);"
    .byte     13
    .byte     10
    .ascii    "time_t mktime(struct tm *);"
    .byte     13
    .byte     10
    .ascii    "double difftime(time_t, time_t);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "char* asctime(const struct tm*);"
    .byte     13
    .byte     10
    .ascii    "//char* ctime(const time_t *_time);"
    .byte     13
    .byte     10
    .ascii    "char* _ctime64(const time_t *_time);"
    .byte     13
    .byte     10
    .ascii    "#define ctime _ctime64"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     0
L8295:
    .ascii    "/* Header string.h */"
    .byte     10
    .byte     10
    .ascii    "#include <stddef.h>"
    .byte     10
    .byte     10
    .ascii    "void* memcpy(void*, const void*, size_t);"
    .byte     10
    .ascii    "void* memmove(const void*, const void*, size_t);"
    .byte     10
    .ascii    "void* memset(void*, int, size_t);"
    .byte     10
    .ascii    "int memcmp(const void*, const void*, size_t);"
    .byte     10
    .ascii    "void* memchr(const void *, int, size_t);"
    .byte     10
    .byte     10
    .ascii    "size_t strlen(const char*);"
    .byte     10
    .ascii    "char* strcpy(char*, const char*);"
    .byte     10
    .ascii    "char* strncpy(char*, const char*, size_t);"
    .byte     10
    .ascii    "char* strcat(char*, const char*);"
    .byte     10
    .ascii    "int strcmp(const char*, const char*);"
    .byte     10
    .ascii    "int strncmp(const char*, const char*, size_t);"
    .byte     10
    .ascii    "char* strchr(const char*, int);"
    .byte     10
    .ascii    "char* strstr(const char*, const char*);"
    .byte     10
    .ascii    "char* strrchr(const char*, int);"
    .byte     10
    .ascii    "int _stricmp(const char*, const char*);"
    .byte     10
    .ascii    "#define stricmp _stricmp"
    .byte     10
    .ascii    "#define strcasecmp _stricmp"
    .byte     10
    .byte     10
    .byte     10
    .byte     10
    .ascii    "int _strnicmp(const char*, const char*, size_t);"
    .byte     10
    .ascii    "#define strnicmp _strnicmp"
    .byte     10
    .ascii    "char* strncat(char*, const char*, size_t);"
    .byte     10
    .ascii    "char* strtok(char*, const char*);"
    .byte     10
    .byte     10
    .ascii    "size_t strcspn(const char*, const char*);"
    .byte     10
    .ascii    "size_t strspn(const char*, const char*);"
    .byte     10
    .ascii    "int strcoll(const char *, const char *);"
    .byte     10
    .byte     10
    .ascii    "unsigned long strtoul(const char*, char**, int);"
    .byte     10
    .byte     10
    .ascii    "char* strerror(int);"
    .byte     10
    .ascii    "char* strpbrk(const char*, const char*);"
    .byte     10
    .ascii    "size_t strxfrm(char*, const char *, size_t);"
    .byte     10
    .byte     10
    .ascii    "char* _strupr(char*);"
    .byte     10
    .ascii    "char* _strlwr(char*);"
    .byte     10
    .ascii    "#define strupr _strupr"
    .byte     10
    .ascii    "#define strlwr _strlwr"
    .byte     10
    .byte     10
    .ascii    "char*strnupr(char*,size_t);"
    .byte     10
    .ascii    "char*strnlwr(char*,size_t);"
    .byte     10
    .ascii    "int strtrim(char*);"
    .byte     10
    .ascii    "char*strrev(char*);"
    .byte     10
    .byte     10
    .ascii    "char* _strdup(const char*);"
    .byte     10
    .ascii    "#define strdup _strdup"
    .byte     10
    .byte     10
    .ascii    "int _wcsicmp(const wchar_t *,const wchar_t *);"
    .byte     10
    .byte     10
    .ascii    "wchar_t *wcspbrk(const wchar_t*,const wchar_t*);"
    .byte     10
    .byte     10
    .ascii    "size_t wcslen(const wchar_t*);"
    .byte     10
    .byte     0
L8294:
    .ascii    "/* Header _syslist.h */"
    .byte     13
    .byte     10
    .byte     0
L8293:
    .ascii    "/* Header stdlib.h */"
    .byte     10
    .byte     10
    .ascii    "#ifndef $stdlib"
    .byte     10
    .ascii    "#define $stdlib 1"
    .byte     10
    .byte     10
    .ascii    "#include <stddef.h>"
    .byte     10
    .byte     10
    .ascii    "#define EXIT_FAILURE 1"
    .byte     10
    .ascii    "#define EXIT_SUCCESS 0"
    .byte     10
    .byte     10
    .ascii    "#define RAND_MAX 32767"
    .byte     10
    .byte     10
    .ascii    "void* malloc(size_t);"
    .byte     10
    .ascii    "void* realloc(void*, size_t);"
    .byte     10
    .ascii    "void* calloc(size_t, size_t);"
    .byte     10
    .byte     10
    .ascii    "void free(void*);"
    .byte     10
    .byte     10
    .ascii    "void exit(int);"
    .byte     10
    .byte     10
    .ascii    "int system(const char*);"
    .byte     10
    .ascii    "int _wsystem(const wchar_t*);"
    .byte     10
    .byte     10
    .ascii    "int abs(int);"
    .byte     10
    .ascii    "long labs(long);"
    .byte     10
    .ascii    "long long llabs(long);"
    .byte     10
    .ascii    "int rand(void);"
    .byte     10
    .ascii    "void srand(unsigned int);"
    .byte     10
    .ascii    "int atoi(const char*);"
    .byte     10
    .ascii    "long atol(const char*);"
    .byte     10
    .ascii    "long long atoll(const char*);"
    .byte     10
    .ascii    "long long atoi64(const char*);"
    .byte     10
    .ascii    "double atof(const char *);"
    .byte     10
    .ascii    "int"
    .byte     9
    .ascii    "atexit(void (*)(void));"
    .byte     10
    .ascii    "char *_itoa(int,char *,int);"
    .byte     10
    .byte     10
    .ascii    "#define itoa _itoa"
    .byte     10
    .byte     10
    .ascii    "void qsort(void*, size_t, size_t, int (*)(void*, void*));"
    .byte     10
    .byte     10
    .ascii    "typedef struct {"
    .byte     10
    .byte     9
    .ascii    "long long int quot;"
    .byte     10
    .byte     9
    .ascii    "long long int rem;"
    .byte     10
    .ascii    "} lldiv_t;"
    .byte     10
    .byte     10
    .ascii    "lldiv_t lldiv(long long int, long long int);"
    .byte     10
    .byte     10
    .ascii    "char* getenv(const char*);"
    .byte     10
    .ascii    "wchar_t* _wgetenv(const wchar_t*);"
    .byte     10
    .ascii    "int _wputenv(const wchar_t*);"
    .byte     10
    .byte     10
    .byte     10
    .ascii    "double strtod(const char*, char**);"
    .byte     10
    .byte     10
    .ascii    "//float strtof(const char *, char**);"
    .byte     10
    .ascii    "#define strtof strtod"
    .byte     10
    .byte     10
    .ascii    "long double strtold(const char*, char**);"
    .byte     10
    .ascii    "void abort(void);"
    .byte     10
    .ascii    "long int strtol(const char*, char**, int);"
    .byte     10
    .byte     10
    .ascii    "long double strtold(const char *,char **);"
    .byte     10
    .byte     10
    .ascii    "long long int _strtoi64(const char *,char **,int);"
    .byte     10
    .ascii    "#define strtoll _strtoi64"
    .byte     10
    .byte     10
    .ascii    "unsigned long long int _strtoui64(const char *,char **,int);"
    .byte     10
    .byte     10
    .ascii    "unsigned long long int _strtoui64(const char*, char**, int);"
    .byte     10
    .ascii    "#define strtoull _strtoui64"
    .byte     10
    .ascii    "unsigned long strtoul(const char*, char**, int);"
    .byte     10
    .byte     10
    .ascii    "size_t _msize(void *);"
    .byte     10
    .ascii    "#define msize _msize"
    .byte     10
    .byte     10
    .ascii    "void* bsearch(const void *,const void *, size_t, size_t,"
    .byte     10
    .byte     9
    .byte     9
    .ascii    "int (*_compar)(const void *,const void *));"
    .byte     10
    .byte     10
    .byte     10
    .ascii    "char* _fullpath(char*, const char*, size_t);"
    .byte     10
    .byte     10
    .byte     10
    .ascii    "#endif"
    .byte     10
    .byte     0
L8292:
    .ascii    "/* Header stdio.h */"
    .byte     10
    .byte     10
    .ascii    "#ifndef $stdio"
    .byte     10
    .ascii    "#define $stdio 1"
    .byte     10
    .byte     10
    .ascii    "#define __attribute__(x)"
    .byte     10
    .byte     10
    .ascii    "#ifndef $valist"
    .byte     10
    .byte     9
    .ascii    "typedef char* va_list;"
    .byte     10
    .byte     9
    .ascii    "#define $valist"
    .byte     10
    .ascii    "#endif"
    .byte     10
    .byte     10
    .ascii    "#include <stddef.h>"
    .byte     10
    .byte     10
    .ascii    "typedef long long int fpos_t;"
    .byte     10
    .byte     10
    .ascii    "#define SEEK_SET 0"
    .byte     10
    .ascii    "#define SEEK_CUR 1"
    .byte     10
    .ascii    "#define SEEK_END 2"
    .byte     10
    .byte     10
    .ascii    "#define"
    .byte     9
    .ascii    "STDIN_FILENO"
    .byte     9
    .ascii    "0"
    .byte     10
    .ascii    "#define"
    .byte     9
    .ascii    "STDOUT_FILENO"
    .byte     9
    .ascii    "1"
    .byte     10
    .ascii    "#define"
    .byte     9
    .ascii    "STDERR_FILENO"
    .byte     9
    .ascii    "2"
    .byte     10
    .byte     10
    .ascii    "#define EOF (-1)"
    .byte     10
    .ascii    "#define FILENAME_MAX 260"
    .byte     10
    .byte     10
    .ascii    "#define L_tmpnam 10"
    .byte     10
    .byte     10
    .ascii    "typedef struct {"
    .byte     10
    .byte     9
    .ascii    "char *_ptr;"
    .byte     10
    .byte     9
    .ascii    "int   _cnt;"
    .byte     10
    .byte     9
    .ascii    "char *_base;"
    .byte     10
    .byte     9
    .ascii    "int   _flag;"
    .byte     10
    .byte     9
    .ascii    "int   _file;"
    .byte     10
    .byte     9
    .ascii    "int   _charbuf;"
    .byte     10
    .byte     9
    .ascii    "int   _bufsiz;"
    .byte     10
    .byte     9
    .ascii    "char *_tmpfname;"
    .byte     10
    .ascii    "} FILE;"
    .byte     10
    .byte     10
    .ascii    "extern char* __iob_func(void);"
    .byte     10
    .byte     10
    .ascii    "#define stdin ((FILE*)(__iob_func()))"
    .byte     10
    .ascii    "#define stdout ((FILE*)(__iob_func()+sizeof(FILE)))"
    .byte     10
    .ascii    "#define stderr ((FILE*)(__iob_func()+sizeof(FILE)*2))"
    .byte     10
    .byte     10
    .ascii    "#define _IOREAD 0x0001"
    .byte     10
    .ascii    "#define _IOWRT 0x0002"
    .byte     10
    .byte     10
    .ascii    "#define _IOFBF 0x0000"
    .byte     10
    .ascii    "#define _IOLBF 0x0040"
    .byte     10
    .ascii    "#define _IONBF 0x0004"
    .byte     10
    .byte     10
    .ascii    "#define _IOMYBUF 0x0008"
    .byte     10
    .ascii    "#define _IOEOF 0x0010"
    .byte     10
    .ascii    "#define _IOERR 0x0020"
    .byte     10
    .ascii    "#define _IOSTRG 0x0040"
    .byte     10
    .ascii    "#define _IORW 0x0080"
    .byte     10
    .byte     10
    .ascii    "#define BUFSIZ 512"
    .byte     10
    .byte     10
    .ascii    "FILE* fopen(const char*, const char*);"
    .byte     10
    .ascii    "int fclose(FILE*);"
    .byte     10
    .ascii    "long ftell(FILE*);"
    .byte     10
    .ascii    "//long long int _ftelli64(FILE*);"
    .byte     10
    .ascii    "int fseek(FILE*,long,int);"
    .byte     10
    .ascii    "int _fseeki64(FILE*,long long int,int);"
    .byte     10
    .byte     10
    .ascii    "size_t fread(void*, size_t, size_t, FILE*);"
    .byte     10
    .ascii    "size_t fwrite(const void*, size_t, size_t, FILE*);"
    .byte     10
    .ascii    "int remove(const char*);"
    .byte     10
    .ascii    "int rename(const char *,const char *);"
    .byte     10
    .ascii    "FILE* freopen(const char*, const char*, FILE*);"
    .byte     10
    .ascii    "FILE* _wfopen(const wchar_t*,const wchar_t *);"
    .byte     10
    .byte     10
    .ascii    "int printf(const char*, ...);"
    .byte     10
    .ascii    "int sprintf(char*,const char*, ...);"
    .byte     10
    .ascii    "int fprintf(FILE*,const char*, ...);"
    .byte     10
    .ascii    "int sscanf(const char*, const char*, ...);"
    .byte     10
    .ascii    "int scanf(const char*, ...);"
    .byte     10
    .ascii    "int fscanf(FILE *,const char *, ...);"
    .byte     10
    .ascii    "int _snprintf(char *,size_t,const char*,...);"
    .byte     10
    .ascii    "#define snprintf _snprintf"
    .byte     10
    .ascii    "int _vsnprintf(char*, size_t, const char*, va_list);"
    .byte     10
    .ascii    "int vsnprintf(char*,size_t,const char*,va_list);"
    .byte     10
    .ascii    "int vsprintf(char*, const char*, va_list);"
    .byte     10
    .ascii    "int _wremove(const wchar_t*);"
    .byte     10
    .ascii    "int _wrename(const wchar_t*,const wchar_t*);"
    .byte     10
    .byte     10
    .ascii    "typedef char* va_list;"
    .byte     10
    .byte     10
    .ascii    "int vfprintf(FILE*, const char*, va_list);"
    .byte     10
    .ascii    "int vprintf(const char*, va_list);"
    .byte     10
    .byte     10
    .ascii    "int puts(const char*);"
    .byte     10
    .ascii    "char* fgets(char*, int, FILE*);"
    .byte     10
    .ascii    "int fputs(const char*, FILE*);"
    .byte     10
    .ascii    "int fgetc(FILE*);"
    .byte     10
    .ascii    "int fputc(int, FILE*);"
    .byte     10
    .ascii    "int ungetc(int, FILE*);"
    .byte     10
    .ascii    "int getchar(void);"
    .byte     10
    .ascii    "int putchar(int);"
    .byte     10
    .ascii    "int fflush(FILE *);"
    .byte     10
    .ascii    "int getc(FILE *);"
    .byte     10
    .ascii    "int putc(int, FILE *);"
    .byte     10
    .byte     10
    .ascii    "int feof(FILE*);"
    .byte     10
    .ascii    "int ferror(FILE*);"
    .byte     10
    .ascii    "void clearerr(FILE*);"
    .byte     10
    .byte     10
    .ascii    "int fileno(FILE*);"
    .byte     10
    .ascii    "int _fileno(FILE*);"
    .byte     10
    .ascii    "int setvbuf(FILE*,char*,int,size_t);"
    .byte     10
    .ascii    "FILE* _popen(const char*, const char*);"
    .byte     10
    .ascii    "int _pclose(FILE*);"
    .byte     10
    .ascii    "int _unlink(const char *);"
    .byte     10
    .ascii    "#define unlink _unlink;"
    .byte     10
    .ascii    "FILE* _fdopen(int, const char *);"
    .byte     10
    .ascii    "#define fdopen _fdopen"
    .byte     10
    .ascii    "int fgetpos(FILE*, fpos_t*);"
    .byte     10
    .ascii    "int fsetpos(FILE*, const fpos_t*);"
    .byte     10
    .ascii    "void perror(char*);"
    .byte     10
    .ascii    "void setbuf(FILE*, char*);"
    .byte     10
    .byte     10
    .ascii    "void rewind(FILE*);"
    .byte     10
    .byte     10
    .ascii    "FILE* tmpfile(void);"
    .byte     10
    .byte     10
    .ascii    "char* tmpnam(char*);"
    .byte     10
    .ascii    "wchar_t getwc(FILE *);"
    .byte     10
    .byte     10
    .ascii    "extern void* _wenviron;"
    .byte     10
    .byte     10
    .ascii    "#endif"
    .byte     10
    .byte     10
    .byte     0
L8291:
    .ascii    "/* Header stddef.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef $stddef"
    .byte     13
    .byte     10
    .ascii    "#define $stddef"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef signed long long int ssize_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned long long int size_t;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define _WCHAR_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned short wchar_t;"
    .byte     13
    .byte     10
    .ascii    "//typedef signed short wchar_t;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define NULL ((void*)0)"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define offsetof(a,b) (size_t) &( ((a*)0) -> b)"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef long long int ptrdiff_t;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#endif // stddef"
    .byte     13
    .byte     10
    .byte     0
L8290:
    .ascii    "/* Header stdbool.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define bool unsigned char"
    .byte     13
    .byte     10
    .ascii    "#define true 1"
    .byte     13
    .byte     10
    .ascii    "#define false 0"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     0
L8289:
    .ascii    "/* Header stdarg.h */"
    .byte     10
    .byte     10
    .ascii    "#ifndef $STDARG"
    .byte     10
    .ascii    " #define $STDARG"
    .byte     10
    .byte     10
    .ascii    "//coded for x64 target as used by mcc (with first four params also on stack)"
    .byte     10
    .byte     10
    .ascii    " typedef char *"
    .byte     9
    .ascii    "va_list;"
    .byte     10
    .byte     10
    .ascii    " #if __MCCI__"
    .byte     10
    .ascii    "  #define va_start(ap,v) ap=((va_list)&v-8)"
    .byte     10
    .ascii    "  #define va_arg(ap,t) *(t*)((ap-=8)+8)"
    .byte     10
    .ascii    "  #define va_copy(dest,src) (dest=src)"
    .byte     10
    .ascii    "  #define va_end(ap)"
    .byte     9
    .ascii    "( ap = (va_list)0 )"
    .byte     10
    .byte     10
    .ascii    " #else"
    .byte     10
    .ascii    "  #define va_start(ap,v) ap=((va_list)&v+8)"
    .byte     10
    .ascii    "  #define va_arg(ap,t) *(t*)((ap+=8)-8)"
    .byte     10
    .ascii    "  #define va_copy(dest,src) (dest=src)"
    .byte     10
    .ascii    "  #define va_end(ap)"
    .byte     9
    .ascii    "( ap = (va_list)0 )"
    .byte     10
    .byte     10
    .ascii    " #endif"
    .byte     10
    .byte     10
    .ascii    "#endif"
    .byte     10
    .byte     0
L8288:
    .ascii    "/* Header signal.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define SIGINT    2"
    .byte     13
    .byte     10
    .ascii    "#define SIGILL    4"
    .byte     13
    .byte     10
    .ascii    "#define SIGFPE    8"
    .byte     13
    .byte     10
    .ascii    "#define SIGSEGV  11"
    .byte     13
    .byte     10
    .ascii    "#define SIGTERM  15"
    .byte     13
    .byte     10
    .ascii    "#define SIGBREAK 21"
    .byte     13
    .byte     10
    .ascii    "#define SIGABRT  22"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define SIG_DFL (void (*)(int))0"
    .byte     13
    .byte     10
    .ascii    "#define SIG_IGN (void (*)(int))1"
    .byte     13
    .byte     10
    .ascii    "#define SIG_SGE (void (*)(int))3"
    .byte     13
    .byte     10
    .ascii    "#define SIG_ACK (void (*)(int))4"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define SIG_ERR (void (*)(int))-1"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "extern void (*signal(int, void (*)(int)))(int);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "extern int raise(int);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef int sig_atomic_t;"
    .byte     13
    .byte     10
    .byte     0
L8287:
    .ascii    "/* Header setjmp.h */"
    .byte     10
    .byte     10
    .byte     10
    .ascii    "#ifndef $setjmphdr"
    .byte     10
    .ascii    "#define $setjmphdr 1"
    .byte     10
    .byte     10
    .ascii    "typedef int jmp_buf[128];"
    .byte     10
    .byte     10
    .ascii    "//void $mcclongjmp(jmp_buf, int);"
    .byte     10
    .ascii    "//int $mccsetjmp(jmp_buf);"
    .byte     10
    .byte     10
    .ascii    "#define setjmp $setjmp"
    .byte     10
    .ascii    "#define longjmp $longjmp"
    .byte     10
    .byte     10
    .ascii    "#endif"
    .byte     10
    .byte     10
    .byte     0
L8286:
    .ascii    "/* Header math.h */"
    .byte     10
    .byte     10
    .ascii    "#define HUGE_VAL 1.7976931348623156e+308"
    .byte     10
    .byte     10
    .ascii    "double floor(double);"
    .byte     10
    .ascii    "double ceil(double);"
    .byte     10
    .ascii    "double sqrt(double);"
    .byte     10
    .ascii    "double sin(double);"
    .byte     10
    .ascii    "double cos(double);"
    .byte     10
    .ascii    "double tan(double);"
    .byte     10
    .ascii    "double fmod(double,double);"
    .byte     10
    .ascii    "double asin(double);"
    .byte     10
    .ascii    "double acos(double);"
    .byte     10
    .ascii    "double atan(double);"
    .byte     10
    .ascii    "double log(double);"
    .byte     10
    .ascii    "double log10(double);"
    .byte     10
    .ascii    "double exp(double);"
    .byte     10
    .ascii    "double modf(double,double*);"
    .byte     10
    .ascii    "double atan2(double,double);"
    .byte     10
    .ascii    "double pow(double,double);"
    .byte     10
    .ascii    "double fabs(double);"
    .byte     10
    .ascii    "double sinh(double);"
    .byte     10
    .ascii    "double cosh(double);"
    .byte     10
    .ascii    "double tanh(double);"
    .byte     10
    .ascii    "double frexp(double,int*);"
    .byte     10
    .ascii    "double ldexp(double,int);"
    .byte     10
    .ascii    "int isnan(double);"
    .byte     10
    .byte     10
    .ascii    "#define ldexpl ldexp"
    .byte     10
    .byte     10
    .ascii    "float sinf(float);"
    .byte     10
    .ascii    "float cosf(float);"
    .byte     10
    .ascii    "float tanf(float);"
    .byte     10
    .ascii    "float expf(float);"
    .byte     10
    .ascii    "float powf(float, float);"
    .byte     10
    .ascii    "float logf(float);"
    .byte     10
    .byte     10
    .ascii    "float sqrtf(float);"
    .byte     10
    .ascii    "float acosf(float);"
    .byte     10
    .ascii    "float atan2f(float,float);"
    .byte     10
    .ascii    "float ceilf(float);"
    .byte     10
    .byte     10
    .ascii    "double acosh (double);"
    .byte     10
    .ascii    "long double acoshl(long double);"
    .byte     10
    .ascii    "long double acoshl(long double);"
    .byte     10
    .ascii    "float acoshf(float);"
    .byte     10
    .byte     10
    .ascii    "double asinh (double);"
    .byte     10
    .ascii    "long double asinhl(long double);"
    .byte     10
    .ascii    "long double sinhl(long double);"
    .byte     10
    .ascii    "float asinhf(float);"
    .byte     10
    .byte     10
    .ascii    "double atanh(double);"
    .byte     10
    .ascii    "long double atanhl(long double);"
    .byte     10
    .ascii    "float atanhf(float);"
    .byte     10
    .byte     10
    .ascii    "long double expm1l(long double);"
    .byte     10
    .ascii    "double expm1(double);"
    .byte     10
    .ascii    "float expm1f(float);"
    .byte     10
    .ascii    "double _expm1i(int);"
    .byte     10
    .byte     10
    .ascii    "double cbrt(double);"
    .byte     10
    .ascii    "long double cbrtl(long double);"
    .byte     10
    .ascii    "float cbrtf(float);"
    .byte     10
    .byte     10
    .ascii    "double trunc(double x);"
    .byte     10
    .ascii    "long double truncl(long double);"
    .byte     10
    .ascii    "float truncf(float);"
    .byte     10
    .byte     10
    .ascii    "double round(double);"
    .byte     10
    .ascii    "float roundf(float);"
    .byte     10
    .ascii    "long double roundl(long double);"
    .byte     10
    .ascii    "double _roundi(int);"
    .byte     10
    .byte     10
    .ascii    "long double fminl(long double,long double);"
    .byte     10
    .ascii    "float fminf(float ,float);"
    .byte     10
    .ascii    "double fmin(double,double);"
    .byte     10
    .byte     10
    .ascii    "//float fabsf(float);"
    .byte     10
    .ascii    "#define fabsf fabs"
    .byte     10
    .byte     10
    .ascii    "double lgamma (double);"
    .byte     10
    .ascii    "long double lgammal(long double);"
    .byte     10
    .ascii    "float lgammaf(float);"
    .byte     10
    .byte     10
    .ascii    "long double tgammal(long double);"
    .byte     10
    .ascii    "double tgamma(double);"
    .byte     10
    .ascii    "float tgammaf(float);"
    .byte     10
    .byte     10
    .ascii    "double log1p(double);"
    .byte     10
    .ascii    "long double log1pl(long double);"
    .byte     10
    .ascii    "float log1pf(float);"
    .byte     10
    .byte     10
    .ascii    "long double log10l(long double);"
    .byte     10
    .ascii    "float log10f(float);"
    .byte     10
    .ascii    "double _log10i(int);"
    .byte     10
    .ascii    "double log10(double);"
    .byte     10
    .byte     10
    .ascii    "double erf(double);"
    .byte     10
    .ascii    "long double erfl(long double);"
    .byte     10
    .ascii    "float erff(float);"
    .byte     10
    .byte     10
    .ascii    "double hypot (double, double);"
    .byte     10
    .ascii    "double _hypot(double,double);"
    .byte     10
    .ascii    "long double hypotl(long double,long double);"
    .byte     10
    .ascii    "float hypotf(float,float);"
    .byte     10
    .byte     10
    .ascii    "double nextafter (double, double);"
    .byte     10
    .ascii    "long double nextafterl(long double,long double);"
    .byte     10
    .ascii    "float nextafterf(float,float);"
    .byte     10
    .byte     10
    .ascii    "double nexttoward(double,long double);"
    .byte     10
    .ascii    "long double nexttowardl(long double,long double);"
    .byte     10
    .ascii    "float nexttowardf(float,long double);"
    .byte     10
    .byte     10
    .ascii    "double erfc(double);"
    .byte     10
    .ascii    "long double erfcl(long double);"
    .byte     10
    .ascii    "float erfcf(float);"
    .byte     10
    .byte     10
    .ascii    "int _finite(double);"
    .byte     10
    .ascii    "#define finite _finite"
    .byte     10
    .byte     10
    .ascii    "float floorf(float);"
    .byte     10
    .byte     10
    .ascii    "double _copysign(double,double);"
    .byte     10
    .ascii    "#define copysign _copysign"
    .byte     10
    .byte     10
    .ascii    "long double fmaxl(long double,long double);"
    .byte     10
    .ascii    "double fmax(double,double);"
    .byte     10
    .ascii    "float fmaxf(float,float);"
    .byte     10
    .ascii    "float fmodf(float,float);"
    .byte     10
    .byte     10
    .ascii    "//long double exp2l(long double);"
    .byte     10
    .ascii    "double exp2(double);"
    .byte     10
    .ascii    "float exp2f(float);"
    .byte     10
    .byte     10
    .ascii    "//double log2(double);"
    .byte     10
    .ascii    "#define log2(x) (log(x)*1.442695041)"
    .byte     10
    .byte     10
    .ascii    "#define M_PI 3.1415926535897932384625433"
    .byte     10
    .ascii    "#define M_PI_2 (M_PI/2.0)"
    .byte     10
    .ascii    "#define M_2_PI 0.63661977236758134308"
    .byte     10
    .byte     10
    .ascii    "int isinf(double);"
    .byte     10
    .byte     10
    .ascii    "int _finite(double);"
    .byte     10
    .byte     10
    .ascii    "#define isfinite _finite"
    .byte     10
    .byte     10
    .ascii    "int isfinitef(float);"
    .byte     10
    .ascii    "int isfinitel(long double);"
    .byte     10
    .byte     10
    .byte     0
L8285:
    .ascii    "/* Header _ansi.h */"
    .byte     13
    .byte     10
    .byte     0
L8284:
    .ascii    "/* Header locale.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef $locale"
    .byte     13
    .byte     10
    .ascii    "#define $locale"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define LC_ALL 0"
    .byte     13
    .byte     10
    .ascii    "#define LC_COLLATE 1"
    .byte     13
    .byte     10
    .ascii    "#define LC_CTYPE 2"
    .byte     13
    .byte     10
    .ascii    "#define LC_MONETARY 3"
    .byte     13
    .byte     10
    .ascii    "#define LC_NUMERIC 4"
    .byte     13
    .byte     10
    .ascii    "#define LC_TIME 5"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "struct lconv {"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char *decimal_point;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char *thousands_sep;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char *grouping;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char *int_curr_symbol;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char *currency_symbol;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char *mon_decimal_point;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char *mon_thousands_sep;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char *mon_grouping;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char *positive_sign;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char *negative_sign;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char int_frac_digits;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char frac_digits;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char p_cs_precedes;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char p_sep_by_space;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char n_cs_precedes;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char n_sep_by_space;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char p_sign_posn;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char n_sign_posn;"
    .byte     13
    .byte     10
    .ascii    "};"
    .byte     13
    .byte     10
    .ascii    "char *setlocale(int category, const char *locale);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "struct lconv *localeconv(void);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "char * setlocale(int,const char *);"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     0
L8283:
    .ascii    "/* Header limits.h */"
    .byte     10
    .byte     10
    .ascii    "#define CHAR_BIT 8"
    .byte     10
    .byte     10
    .ascii    "#define CHAR_MIN 0"
    .byte     10
    .ascii    "#define CHAR_MAX 255"
    .byte     10
    .byte     10
    .ascii    "#define UCHAR_MIN 0"
    .byte     10
    .ascii    "#define UCHAR_MAX 255"
    .byte     10
    .byte     10
    .ascii    "#define SCHAR_MIN -128"
    .byte     10
    .ascii    "#define SCHAR_MAX 127"
    .byte     10
    .byte     10
    .ascii    "#define SHRT_MIN -32768"
    .byte     10
    .ascii    "#define SHRT_MAX 32767"
    .byte     10
    .byte     10
    .ascii    "#define USHRT_MIN 0"
    .byte     10
    .ascii    "#define USHRT_MAX 65535"
    .byte     10
    .byte     10
    .ascii    "#define INT_MIN -2147483648"
    .byte     10
    .ascii    "#define INT_MAX  2147483647"
    .byte     10
    .byte     10
    .ascii    "#define UINT_MIN 0"
    .byte     10
    .ascii    "#define UINT_MAX 4294967295"
    .byte     10
    .byte     10
    .ascii    "#define LONG_MIN -2147483648"
    .byte     10
    .ascii    "#define LONG_MAX  2147483647"
    .byte     10
    .byte     10
    .ascii    "#define ULONG_MIN 0"
    .byte     10
    .ascii    "#define ULONG_MAX 4294967295"
    .byte     10
    .byte     10
    .ascii    "#define LLONG_MIN -9223372036854775808LL"
    .byte     10
    .ascii    "#define LLONG_MAX  9223372036854775807LL"
    .byte     10
    .byte     10
    .ascii    "#define ULLONG_MIN 0"
    .byte     10
    .ascii    "#define ULLONG_MAX 0xFFFFFFFFFFFFFFFFLL"
    .byte     10
    .byte     10
    .ascii    "#define SIZE_MAX ULLONG_MAX"
    .byte     10
    .byte     0
L8282:
    .ascii    "/* Header stdint.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef $stdint"
    .byte     13
    .byte     10
    .ascii    "#define $stdint"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef signed char int8_t;"
    .byte     13
    .byte     10
    .ascii    "typedef short int16_t;"
    .byte     13
    .byte     10
    .ascii    "typedef int int32_t;"
    .byte     13
    .byte     10
    .ascii    "typedef long long int int64_t;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef unsigned char uint8_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned short uint16_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned int uint32_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned long long int uint64_t;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef long long int intptr_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned long long int uintptr_t;"
    .byte     13
    .byte     10
    .ascii    "typedef long long intmax_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned long long uintmax_t;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef char int_least8_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned char uint_least8_t;"
    .byte     13
    .byte     10
    .ascii    "typedef short int_least16_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned short uint_least16_t;"
    .byte     13
    .byte     10
    .ascii    "typedef int int_least32_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned int uint_least32_t;"
    .byte     13
    .byte     10
    .ascii    "typedef long long int_least64_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned long long uint_least64_t;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define INTMAX_C(a) (a##LL)"
    .byte     13
    .byte     10
    .ascii    "#define UINTMAX_C(a) (a##ULL)"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef char int_fast8_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned char uint_fast8_t;"
    .byte     13
    .byte     10
    .ascii    "typedef short int_fast16_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned short uint_fast16_t;"
    .byte     13
    .byte     10
    .ascii    "typedef int int_fast32_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned int uint_fast32_t;"
    .byte     13
    .byte     10
    .ascii    "typedef long long int_fast64_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned long long uint_fast64_t;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define INT8_MIN -128"
    .byte     13
    .byte     10
    .ascii    "#define INT8_MAX 127"
    .byte     13
    .byte     10
    .ascii    "#define INT16_MIN -32768"
    .byte     13
    .byte     10
    .ascii    "#define INT16_MAX 32767"
    .byte     13
    .byte     10
    .ascii    "#define INT32_MIN 0x80000000"
    .byte     13
    .byte     10
    .ascii    "#define INT32_MAX 0x7FFFFFFF"
    .byte     13
    .byte     10
    .ascii    "#define INT64_MIN 0x8000000000000000"
    .byte     13
    .byte     10
    .ascii    "#define INT64_MAX 0x7FFFFFFFFFFFFFFF"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define UINT8_MAX 255"
    .byte     13
    .byte     10
    .ascii    "#define UINT16_MAX 65535"
    .byte     13
    .byte     10
    .ascii    "#define UINT32_MAX 0xFFFFFFFF"
    .byte     13
    .byte     10
    .ascii    "#define UINT64_MAX 0xFFFFFFFFFFFFFFFF"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define INTPTR_MIN 0x8000000000000000"
    .byte     13
    .byte     10
    .ascii    "#define INTPTR_MAX 0x7FFFFFFFFFFFFFFF"
    .byte     13
    .byte     10
    .ascii    "#define UINTPTR_MAX 0xFFFFFFFFFFFFFFFF"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define UINT64_MAX 0xFFFFFFFFFFFFFFFF"
    .byte     13
    .byte     10
    .ascii    "#define SIZE_MAX 0xFFFFFFFFFFFFFFFF"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PTRDIFF_MIN 0x8000000000000000"
    .byte     13
    .byte     10
    .ascii    "#define PTRDIFF_MAX 0x7FFFFFFFFFFFFFFF"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define WCHAR_MIN 0"
    .byte     13
    .byte     10
    .ascii    "#define WCHAR_MAX 65535"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define WINT_MIN 0"
    .byte     13
    .byte     10
    .ascii    "#define WINT_MAX 65535"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define UINT64_C(x) (x##ull)"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     0
L8281:
    .ascii    "/* Header inttypes.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#include <stdint.h>"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "/* fprintf macros for signed types */"
    .byte     13
    .byte     10
    .ascii    "#define PRId8 "
    .byte     34
    .ascii    "d"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRId16 "
    .byte     34
    .ascii    "d"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRId32 "
    .byte     34
    .ascii    "d"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRId64 "
    .byte     34
    .ascii    "I64d"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIdLEAST8 "
    .byte     34
    .ascii    "d"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIdLEAST16 "
    .byte     34
    .ascii    "d"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIdLEAST32 "
    .byte     34
    .ascii    "d"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIdLEAST64 "
    .byte     34
    .ascii    "I64d"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIdFAST8 "
    .byte     34
    .ascii    "d"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIdFAST16 "
    .byte     34
    .ascii    "d"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIdFAST32 "
    .byte     34
    .ascii    "d"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIdFAST64 "
    .byte     34
    .ascii    "I64d"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIdMAX "
    .byte     34
    .ascii    "I64d"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIi8 "
    .byte     34
    .ascii    "i"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIi16 "
    .byte     34
    .ascii    "i"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIi32 "
    .byte     34
    .ascii    "i"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIi64 "
    .byte     34
    .ascii    "I64i"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIiLEAST8 "
    .byte     34
    .ascii    "i"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIiLEAST16 "
    .byte     34
    .ascii    "i"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIiLEAST32 "
    .byte     34
    .ascii    "i"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIiLEAST64 "
    .byte     34
    .ascii    "I64i"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIiFAST8 "
    .byte     34
    .ascii    "i"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIiFAST16 "
    .byte     34
    .ascii    "i"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIiFAST32 "
    .byte     34
    .ascii    "i"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIiFAST64 "
    .byte     34
    .ascii    "I64i"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIiMAX "
    .byte     34
    .ascii    "I64i"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIo8 "
    .byte     34
    .ascii    "o"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIo16 "
    .byte     34
    .ascii    "o"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIo32 "
    .byte     34
    .ascii    "o"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIo64 "
    .byte     34
    .ascii    "I64o"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIoLEAST8 "
    .byte     34
    .ascii    "o"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIoLEAST16 "
    .byte     34
    .ascii    "o"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIoLEAST32 "
    .byte     34
    .ascii    "o"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIoLEAST64 "
    .byte     34
    .ascii    "I64o"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIoFAST8 "
    .byte     34
    .ascii    "o"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIoFAST16 "
    .byte     34
    .ascii    "o"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIoFAST32 "
    .byte     34
    .ascii    "o"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIoFAST64 "
    .byte     34
    .ascii    "I64o"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIoMAX "
    .byte     34
    .ascii    "I64o"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "/* fprintf macros for unsigned types */"
    .byte     13
    .byte     10
    .ascii    "#define PRIu8 "
    .byte     34
    .ascii    "u"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIu16 "
    .byte     34
    .ascii    "u"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIu32 "
    .byte     34
    .ascii    "u"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIu64 "
    .byte     34
    .ascii    "I64u"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIuLEAST8 "
    .byte     34
    .ascii    "u"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIuLEAST16 "
    .byte     34
    .ascii    "u"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIuLEAST32 "
    .byte     34
    .ascii    "u"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIuLEAST64 "
    .byte     34
    .ascii    "I64u"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIuFAST8 "
    .byte     34
    .ascii    "u"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIuFAST16 "
    .byte     34
    .ascii    "u"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIuFAST32 "
    .byte     34
    .ascii    "u"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIuFAST64 "
    .byte     34
    .ascii    "I64u"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIuMAX "
    .byte     34
    .ascii    "I64u"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIx8 "
    .byte     34
    .ascii    "x"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIx16 "
    .byte     34
    .ascii    "x"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIx32 "
    .byte     34
    .ascii    "x"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIx64 "
    .byte     34
    .ascii    "I64x"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIxLEAST8 "
    .byte     34
    .ascii    "x"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIxLEAST16 "
    .byte     34
    .ascii    "x"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIxLEAST32 "
    .byte     34
    .ascii    "x"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIxLEAST64 "
    .byte     34
    .ascii    "I64x"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIxFAST8 "
    .byte     34
    .ascii    "x"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIxFAST16 "
    .byte     34
    .ascii    "x"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIxFAST32 "
    .byte     34
    .ascii    "x"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIxFAST64 "
    .byte     34
    .ascii    "I64x"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIxMAX "
    .byte     34
    .ascii    "I64x"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIX8 "
    .byte     34
    .ascii    "X"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIX16 "
    .byte     34
    .ascii    "X"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIX32 "
    .byte     34
    .ascii    "X"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIX64 "
    .byte     34
    .ascii    "I64X"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIXLEAST8 "
    .byte     34
    .ascii    "X"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIXLEAST16 "
    .byte     34
    .ascii    "X"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIXLEAST32 "
    .byte     34
    .ascii    "X"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIXLEAST64 "
    .byte     34
    .ascii    "I64X"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIXFAST8 "
    .byte     34
    .ascii    "X"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIXFAST16 "
    .byte     34
    .ascii    "X"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIXFAST32 "
    .byte     34
    .ascii    "X"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIXFAST64 "
    .byte     34
    .ascii    "I64X"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIXMAX "
    .byte     34
    .ascii    "I64X"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     0
L8280:
    .ascii    "/* Header float.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "//#define DBL_MAX_10_EXP 308"
    .byte     13
    .byte     10
    .ascii    "//#define DBL_MANT_DIG 53"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define FLT_RADIX 2"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define FLT_DIG 6"
    .byte     13
    .byte     10
    .ascii    "#define FLT_MIN_EXP -125"
    .byte     13
    .byte     10
    .ascii    "#define FLT_MIN 1.17549435E-38F // decimal constant"
    .byte     13
    .byte     10
    .ascii    "#define FLT_MIN 0X1P-126F // hex constant"
    .byte     13
    .byte     10
    .ascii    "#define FLT_TRUE_MIN 1.40129846E-45F // decimal constant"
    .byte     13
    .byte     10
    .ascii    "#define FLT_TRUE_MIN 0X1P-149F // hex constant"
    .byte     13
    .byte     10
    .ascii    "#define FLT_HAS_SUBNORM 1"
    .byte     13
    .byte     10
    .ascii    "#define FLT_MIN_10_EXP -37"
    .byte     13
    .byte     10
    .ascii    "#define FLT_MAX_EXP +128"
    .byte     13
    .byte     10
    .ascii    "#define FLT_MAX 3.40282347E+38F // decimal constant"
    .byte     13
    .byte     10
    .ascii    "#define FLT_MAX 0X1.fffffeP127F // hex constant"
    .byte     13
    .byte     10
    .ascii    "#define FLT_MAX_10_EXP +38"
    .byte     13
    .byte     10
    .ascii    "#define FLT_EPSILON 1.19209290e-07F"
    .byte     13
    .byte     10
    .ascii    "#define FLT_MANT_DIG 23"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define DBL_MANT_DIG 53"
    .byte     13
    .byte     10
    .ascii    "#define DBL_EPSILON 2.2204460492503131E-16 // decimal constant"
    .byte     13
    .byte     10
    .ascii    "//#define DBL_EPSILON 0X1P-52 // hex constant"
    .byte     13
    .byte     10
    .ascii    "#define DBL_DECIMAL_DIG 17"
    .byte     13
    .byte     10
    .ascii    "#define DBL_DIG 15"
    .byte     13
    .byte     10
    .ascii    "#define DBL_MIN_EXP -1021"
    .byte     13
    .byte     10
    .ascii    "#define DBL_MIN 2.2250738585072014E-308 // decimal constant"
    .byte     13
    .byte     10
    .ascii    "//#define DBL_MIN 0X1P-1022 // hex constant"
    .byte     13
    .byte     10
    .ascii    "#define DBL_TRUE_MIN 4.9406564584124654E-324 // decimal constant"
    .byte     13
    .byte     10
    .ascii    "//#define DBL_TRUE_MIN 0X1P-1074 // hex constant"
    .byte     13
    .byte     10
    .ascii    "#define DBL_HAS_SUBNORM 1"
    .byte     13
    .byte     10
    .ascii    "#define DBL_MIN_10_EXP -307"
    .byte     13
    .byte     10
    .ascii    "#define DBL_MAX_EXP +1024"
    .byte     13
    .byte     10
    .ascii    "#define DBL_MAX 1.7976931348623157E+308 // decimal constant"
    .byte     13
    .byte     10
    .ascii    "//#define DBL_MAX 0X1.fffffffffffffP1023 // h"
    .byte     13
    .byte     10
    .ascii    "#define DBL_MAX_10_EXP +308"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define LDBL_MIN DBL_MIN"
    .byte     13
    .byte     10
    .ascii    "#define LDBL_MAX DBL_MAX"
    .byte     13
    .byte     10
    .ascii    "#define LDBL_EPSILON 2.2204460492503131E-16"
    .byte     13
    .byte     10
    .ascii    "#define LDBL_MANT_DIG 53"
    .byte     13
    .byte     10
    .ascii    "#define LDBL_MIN_EXP -1021"
    .byte     13
    .byte     10
    .ascii    "#define LDBL_MAX_EXP +1024"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int     _isnan(double);"
    .byte     13
    .byte     10
    .ascii    "#define isnan _isnan"
    .byte     13
    .byte     10
    .byte     0
L8279:
    .ascii    "/* Header fenv.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int feclearexcept(int);"
    .byte     13
    .byte     10
    .ascii    "int fetestexcept(int);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define FE_INVALID 1"
    .byte     13
    .byte     10
    .ascii    "#define FE_DENORMAL 2"
    .byte     13
    .byte     10
    .ascii    "#define FE_INEXACT 32"
    .byte     13
    .byte     10
    .ascii    "#define FE_DIVBYZERO 4 "
    .byte     13
    .byte     10
    .ascii    "#define FE_OVERFLOW 8"
    .byte     13
    .byte     10
    .ascii    "#define FE_UNDERFLOW 16"
    .byte     13
    .byte     10
    .ascii    "#define FE_STACKFAULT 64"
    .byte     13
    .byte     10
    .ascii    "#define FE_ALL_EXCEPT (FE_INVALID|FE_DENORMAL|FE_INEXACT|FE_DIVBYZERO|FE_OVERFLOW|FE_UNDERFLOW)"
    .byte     13
    .byte     10
    .byte     0
L8278:
    .ascii    "/* Header errno.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef $errno"
    .byte     13
    .byte     10
    .ascii    "#define $errno"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "extern int* _errno(void);"
    .byte     13
    .byte     10
    .ascii    "#define errno (*_errno())"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define EPERM 1"
    .byte     13
    .byte     10
    .ascii    "#define ENOENT 2"
    .byte     13
    .byte     10
    .ascii    "#define ESRCH 3"
    .byte     13
    .byte     10
    .ascii    "#define EINTR 4"
    .byte     13
    .byte     10
    .ascii    "#define EIO 5"
    .byte     13
    .byte     10
    .ascii    "#define ENXIO 6"
    .byte     13
    .byte     10
    .ascii    "#define E2BIG 7"
    .byte     13
    .byte     10
    .ascii    "#define ENOEXEC 8"
    .byte     13
    .byte     10
    .ascii    "#define EBADF 9"
    .byte     13
    .byte     10
    .ascii    "#define ECHILD 10"
    .byte     13
    .byte     10
    .ascii    "#define EAGAIN 11"
    .byte     13
    .byte     10
    .ascii    "#define ENOMEM 12"
    .byte     13
    .byte     10
    .ascii    "#define EACCES 13"
    .byte     13
    .byte     10
    .ascii    "#define EFAULT 14"
    .byte     13
    .byte     10
    .ascii    "#define ENOTBLK 15"
    .byte     13
    .byte     10
    .ascii    "#define EBUSY 16"
    .byte     13
    .byte     10
    .ascii    "#define EEXIST 17"
    .byte     13
    .byte     10
    .ascii    "#define EXDEV 18"
    .byte     13
    .byte     10
    .ascii    "#define ENODEV 19"
    .byte     13
    .byte     10
    .ascii    "#define ENOTDIR 20"
    .byte     13
    .byte     10
    .ascii    "#define EISDIR 21"
    .byte     13
    .byte     10
    .ascii    "#define EINVAL 22"
    .byte     13
    .byte     10
    .ascii    "#define ENFILE 23"
    .byte     13
    .byte     10
    .ascii    "#define EMFILE 24"
    .byte     13
    .byte     10
    .ascii    "#define ENOTTY 25"
    .byte     13
    .byte     10
    .ascii    "#define ETXTBSY 26"
    .byte     13
    .byte     10
    .ascii    "#define EFBIG 27"
    .byte     13
    .byte     10
    .ascii    "#define ENOSPC 28"
    .byte     13
    .byte     10
    .ascii    "#define ESPIPE 29"
    .byte     13
    .byte     10
    .ascii    "#define EROFS 30"
    .byte     13
    .byte     10
    .ascii    "#define EMLINK 31"
    .byte     13
    .byte     10
    .ascii    "#define EPIPE 32"
    .byte     13
    .byte     10
    .ascii    "#define EDOM 33"
    .byte     13
    .byte     10
    .ascii    "#define ERANGE 34"
    .byte     13
    .byte     10
    .ascii    "#define ENOMSG 35"
    .byte     13
    .byte     10
    .ascii    "#define EIDRM 36"
    .byte     13
    .byte     10
    .ascii    "#define ECHRNG 37"
    .byte     13
    .byte     10
    .ascii    "#define EL2NSYNC 38"
    .byte     13
    .byte     10
    .ascii    "#define EL3HLT 39"
    .byte     13
    .byte     10
    .ascii    "#define EL3RST 40"
    .byte     13
    .byte     10
    .ascii    "#define ELNRNG 41"
    .byte     13
    .byte     10
    .ascii    "#define EUNATCH 42"
    .byte     13
    .byte     10
    .ascii    "#define ENOCSI 43"
    .byte     13
    .byte     10
    .ascii    "#define EL2HLT 44"
    .byte     13
    .byte     10
    .ascii    "#define EDEADLK 45"
    .byte     13
    .byte     10
    .ascii    "#define ENOLCK 46"
    .byte     13
    .byte     10
    .ascii    "#define EBADE 50"
    .byte     13
    .byte     10
    .ascii    "#define EBADR 51"
    .byte     13
    .byte     10
    .ascii    "#define EXFULL 52"
    .byte     13
    .byte     10
    .ascii    "#define ENOANO 53"
    .byte     13
    .byte     10
    .ascii    "#define EBADRQC 54"
    .byte     13
    .byte     10
    .ascii    "#define EBADSLT 55"
    .byte     13
    .byte     10
    .ascii    "#define EDEADLOCK 56"
    .byte     13
    .byte     10
    .ascii    "#define EBFONT 57"
    .byte     13
    .byte     10
    .ascii    "#define ENOSTR 60"
    .byte     13
    .byte     10
    .ascii    "#define ENODATA 61"
    .byte     13
    .byte     10
    .ascii    "#define ETIME 62"
    .byte     13
    .byte     10
    .ascii    "#define ENOSR 63"
    .byte     13
    .byte     10
    .ascii    "#define ENONET 64"
    .byte     13
    .byte     10
    .ascii    "#define ENOPKG 65"
    .byte     13
    .byte     10
    .ascii    "#define EREMOTE 66"
    .byte     13
    .byte     10
    .ascii    "#define ENOLINK 67"
    .byte     13
    .byte     10
    .ascii    "#define EADV 68"
    .byte     13
    .byte     10
    .ascii    "#define ESRMNT 69"
    .byte     13
    .byte     10
    .ascii    "#define ECOMM 70"
    .byte     13
    .byte     10
    .ascii    "#define EPROTO 71"
    .byte     13
    .byte     10
    .ascii    "#define EMULTIHOP 74"
    .byte     13
    .byte     10
    .ascii    "#define ELBIN 75"
    .byte     13
    .byte     10
    .ascii    "#define EOVERFLOW 76"
    .byte     13
    .byte     10
    .ascii    "#define EBADMSG 77"
    .byte     13
    .byte     10
    .ascii    "#define ENOTUNIQ 80"
    .byte     13
    .byte     10
    .ascii    "#define EBADFD 81"
    .byte     13
    .byte     10
    .ascii    "#define EREMCHG 82"
    .byte     13
    .byte     10
    .ascii    "#define ELIBACC 83"
    .byte     13
    .byte     10
    .ascii    "#define ELIBBAD 84"
    .byte     13
    .byte     10
    .ascii    "#define ELIBSCN 85"
    .byte     13
    .byte     10
    .ascii    "#define ELIBMAX 86"
    .byte     13
    .byte     10
    .ascii    "#define ELIBEXEC 87"
    .byte     13
    .byte     10
    .ascii    "#define ENOSYS 88"
    .byte     13
    .byte     10
    .ascii    "#define ENMFILE 89"
    .byte     13
    .byte     10
    .ascii    "#define ENOTEMPTY 90"
    .byte     13
    .byte     10
    .ascii    "#define ENAMETOOLONG 91"
    .byte     13
    .byte     10
    .ascii    "#define EILSEQ 92"
    .byte     13
    .byte     10
    .ascii    "#define __ELASTERROR 2000"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     0
L8277:
    .ascii    "/* Header ctype.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int tolower(int);"
    .byte     13
    .byte     10
    .ascii    "int toupper(int);"
    .byte     13
    .byte     10
    .ascii    "int isalpha(int);"
    .byte     13
    .byte     10
    .ascii    "int isdigit(int);"
    .byte     13
    .byte     10
    .ascii    "int isspace(int);"
    .byte     13
    .byte     10
    .ascii    "int isalnum(int);"
    .byte     13
    .byte     10
    .ascii    "int isupper(int);"
    .byte     13
    .byte     10
    .ascii    "int islower(int);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int isxdigit(int);"
    .byte     13
    .byte     10
    .ascii    "int iscntrl(int);"
    .byte     13
    .byte     10
    .ascii    "int isgraph(int);"
    .byte     13
    .byte     10
    .ascii    "int ispunct(int);"
    .byte     13
    .byte     10
    .ascii    "int isprint(int);"
    .byte     13
    .byte     10
    .ascii    "int __isascii(int);"
    .byte     13
    .byte     10
    .ascii    "#define isascii __isascii"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int __toascii(int);"
    .byte     13
    .byte     10
    .ascii    "#define toascii __toascii"
    .byte     13
    .byte     10
    .byte     0
L8276:
    .ascii    "/* Header assert.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "//#define assert(x) 0"
    .byte     13
    .byte     10
    .ascii    "#define assert(x)"
    .byte     13
    .byte     10
    .byte     0
L8275:
    .ascii    "stderr"
    .byte     0
L8274:
    .ascii    "stdout"
    .byte     0
L8273:
    .ascii    "stdin"
    .byte     0
L8272:
    .ascii    "Dec"
    .byte     0
L8271:
    .ascii    "Nov"
    .byte     0
L8270:
    .ascii    "Oct"
    .byte     0
L8269:
    .ascii    "Sep"
    .byte     0
L8268:
    .ascii    "Aug"
    .byte     0
L8267:
    .ascii    "Jul"
    .byte     0
L8266:
    .ascii    "Jun"
    .byte     0
L8265:
    .ascii    "May"
    .byte     0
L8264:
    .ascii    "Apr"
    .byte     0
L8263:
    .ascii    "Mar"
    .byte     0
L8262:
    .ascii    "Feb"
    .byte     0
L8261:
    .ascii    "Jan"
    .byte     0
L8260:
    .ascii    "bool_c"
    .byte     0
L8259:
    .ascii    "truncate_c"
    .byte     0
L8258:
    .ascii    "narrow_c"
    .byte     0
L8257:
    .ascii    "fnarrow_c"
    .byte     0
L8256:
    .ascii    "fwiden_c"
    .byte     0
L8255:
    .ascii    "ufix_c"
    .byte     0
L8254:
    .ascii    "sfix_c"
    .byte     0
L8253:
    .ascii    "ufloat_c"
    .byte     0
L8252:
    .ascii    "sfloat_c"
    .byte     0
L8251:
    .ascii    "uwiden_c"
    .byte     0
L8250:
    .ascii    "swiden_c"
    .byte     0
L8249:
    .ascii    "hard_c"
    .byte     0
L8248:
    .ascii    "soft_c"
    .byte     0
L8247:
    .ascii    "no_conv"
    .byte     0
L8246:
    .ascii    "$$dummy"
    .byte     0
L8245:
    .ascii    "$longjmp"
    .byte     0
L8244:
    .ascii    "$setjmp"
    .byte     0
L8243:
    .ascii    "_Alignof"
    .byte     0
L8242:
    .ascii    "_Generic"
    .byte     0
L8241:
    .ascii    "defined"
    .byte     0
L8240:
    .ascii    "lengthof"
    .byte     0
L8239:
    .ascii    "sizeof"
    .byte     0
L8238:
    .ascii    "__declspec"
    .byte     0
L8237:
    .ascii    "__FUNCTION__"
    .byte     0
L8236:
    .ascii    "__func__"
    .byte     0
L8235:
    .ascii    "__MCCI__"
    .byte     0
L8234:
    .ascii    "__MCC__"
    .byte     0
L8233:
    .ascii    "__TIME__"
    .byte     0
L8232:
    .ascii    "__LINE__"
    .byte     0
L8231:
    .ascii    "__FILE__"
    .byte     0
L8230:
    .ascii    "__DATE__"
    .byte     0
L8229:
    .ascii    "_Bool"
    .byte     0
L8228:
    .ascii    "unsigned"
    .byte     0
L8227:
    .ascii    "signed"
    .byte     0
L8226:
    .ascii    "double"
    .byte     0
L8225:
    .ascii    "float"
    .byte     0
L8224:
    .ascii    "int"
    .byte     0
L8223:
    .ascii    "long"
    .byte     0
L8222:
    .ascii    "short"
    .byte     0
L8221:
    .ascii    "char"
    .byte     0
L8220:
    .ascii    "void"
    .byte     0
L8219:
    .ascii    "enum"
    .byte     0
L8218:
    .ascii    "_Alignas"
    .byte     0
L8217:
    .ascii    "_Noreturn"
    .byte     0
L8216:
    .ascii    "inline"
    .byte     0
L8215:
    .ascii    "_Atomic"
    .byte     0
L8214:
    .ascii    "restrict"
    .byte     0
L8213:
    .ascii    "volatile"
    .byte     0
L8212:
    .ascii    "const"
    .byte     0
L8211:
    .ascii    "typedef"
    .byte     0
L8210:
    .ascii    "extern"
    .byte     0
L8209:
    .ascii    "static"
    .byte     0
L8208:
    .ascii    "register"
    .byte     0
L8207:
    .ascii    "auto"
    .byte     0
L8206:
    .ascii    "line"
    .byte     0
L8205:
    .ascii    "pragma"
    .byte     0
L8204:
    .ascii    "error"
    .byte     0
L8203:
    .ascii    "undef"
    .byte     0
L8202:
    .ascii    "endif"
    .byte     0
L8201:
    .ascii    "ifndef"
    .byte     0
L8200:
    .ascii    "ifdef"
    .byte     0
L8199:
    .ascii    "elif"
    .byte     0
L8198:
    .ascii    "define"
    .byte     0
L8197:
    .ascii    "include"
    .byte     0
L8196:
    .ascii    "union"
    .byte     0
L8195:
    .ascii    "struct"
    .byte     0
L8194:
    .ascii    "switch"
    .byte     0
L8193:
    .ascii    "goto"
    .byte     0
L8192:
    .ascii    "continue"
    .byte     0
L8191:
    .ascii    "break"
    .byte     0
L8190:
    .ascii    "return"
    .byte     0
L8189:
    .ascii    "while"
    .byte     0
L8188:
    .ascii    "do"
    .byte     0
L8187:
    .ascii    "for"
    .byte     0
L8186:
    .ascii    "default"
    .byte     0
L8185:
    .ascii    "case"
    .byte     0
L8184:
    .ascii    "else"
    .byte     0
L8183:
    .ascii    "if"
    .byte     0
L8182:
    .ascii    "labelid"
    .byte     0
L8181:
    .ascii    "structtagid"
    .byte     0
L8180:
    .ascii    "enumtagid"
    .byte     0
L8179:
    .ascii    "enumid"
    .byte     0
L8178:
    .ascii    "fieldid"
    .byte     0
L8177:
    .ascii    "paramid"
    .byte     0
L8176:
    .ascii    "frameid"
    .byte     0
L8175:
    .ascii    "staticid"
    .byte     0
L8174:
    .ascii    "procid"
    .byte     0
L8173:
    .ascii    "typeid"
    .byte     0
L8172:
    .ascii    "extmoduleid"
    .byte     0
L8171:
    .ascii    "moduleid"
    .byte     0
L8170:
    .ascii    "programid"
    .byte     0
L8169:
    .ascii    "macroid"
    .byte     0
L8168:
    .ascii    "nullid"
    .byte     0
L8167:
    .ascii    "ns_fields"
    .byte     0
L8166:
    .ascii    "ns_labels"
    .byte     0
L8165:
    .ascii    "ns_tags"
    .byte     0
L8164:
    .ascii    "ns_general"
    .byte     0
L8163:
    .ascii    "ns_none"
    .byte     0
L8162:
    .ascii    "pragmadir"
    .byte     0
L8161:
    .ascii    "linedir"
    .byte     0
L8160:
    .ascii    "blankdir"
    .byte     0
L8159:
    .ascii    "messagedir"
    .byte     0
L8158:
    .ascii    "errordir"
    .byte     0
L8157:
    .ascii    "undefdir"
    .byte     0
L8156:
    .ascii    "ifndefdir"
    .byte     0
L8155:
    .ascii    "ifdefdir"
    .byte     0
L8154:
    .ascii    "includedir"
    .byte     0
L8153:
    .ascii    "endifdir"
    .byte     0
L8152:
    .ascii    "elsedir"
    .byte     0
L8151:
    .ascii    "elifdir"
    .byte     0
L8150:
    .ascii    "ifdir"
    .byte     0
L8149:
    .ascii    "emitdir"
    .byte     0
L8148:
    .ascii    "definedir"
    .byte     0
L8147:
    .byte     0
L8146:
    .ascii    "k"
    .byte     0
L8145:
    .byte     0
L8144:
    .ascii    "w"
    .byte     0
L8143:
    .ascii    "s"
    .byte     0
L8142:
    .ascii    "n"
    .byte     0
L8141:
    .byte     0
L8140:
    .ascii    ">>="
    .byte     0
L8139:
    .ascii    "<<="
    .byte     0
L8138:
    .ascii    "^="
    .byte     0
L8137:
    .ascii    "&="
    .byte     0
L8136:
    .ascii    "|="
    .byte     0
L8135:
    .ascii    "%="
    .byte     0
L8134:
    .ascii    "/="
    .byte     0
L8133:
    .ascii    "*="
    .byte     0
L8132:
    .ascii    "-="
    .byte     0
L8131:
    .ascii    "+="
    .byte     0
L8130:
    .ascii    ">"
    .byte     0
L8129:
    .ascii    ">="
    .byte     0
L8128:
    .ascii    "<="
    .byte     0
L8127:
    .ascii    "<"
    .byte     0
L8126:
    .ascii    "!="
    .byte     0
L8125:
    .ascii    "=="
    .byte     0
L8124:
    .ascii    "abs"
    .byte     0
L8123:
    .ascii    "--"
    .byte     0
L8122:
    .ascii    "++"
    .byte     0
L8121:
    .ascii    "!"
    .byte     0
L8120:
    .ascii    "~"
    .byte     0
L8119:
    .ascii    ">>"
    .byte     0
L8118:
    .ascii    "<<"
    .byte     0
L8117:
    .ascii    "&&"
    .byte     0
L8116:
    .ascii    "||"
    .byte     0
L8115:
    .ascii    "^"
    .byte     0
L8114:
    .ascii    "&"
    .byte     0
L8113:
    .ascii    "|"
    .byte     0
L8112:
    .ascii    "%"
    .byte     0
L8111:
    .ascii    "/"
    .byte     0
L8110:
    .ascii    "*"
    .byte     0
L8109:
    .ascii    "-"
    .byte     0
L8108:
    .ascii    "+"
    .byte     0
L8107:
    .byte     92
    .byte     0
L8106:
    .ascii    "..."
    .byte     0
L8105:
    .ascii    "~"
    .byte     0
L8104:
    .ascii    "?"
    .byte     0
L8103:
    .ascii    "}"
    .byte     0
L8102:
    .ascii    "{"
    .byte     0
L8101:
    .ascii    "]"
    .byte     0
L8100:
    .ascii    "["
    .byte     0
L8099:
    .ascii    ")"
    .byte     0
L8098:
    .ascii    "("
    .byte     0
L8097:
    .ascii    ":="
    .byte     0
L8096:
    .ascii    "="
    .byte     0
L8095:
    .ascii    ":"
    .byte     0
L8094:
    .ascii    ";"
    .byte     0
L8093:
    .ascii    ","
    .byte     0
L8092:
    .ascii    "##"
    .byte     0
L8091:
    .ascii    "#"
    .byte     0
L8090:
    .ascii    "->"
    .byte     0
L8089:
    .ascii    "."
    .byte     0
L8088:
    .byte     0
L8087:
    .ascii    "kdummysym"
    .byte     0
L8086:
    .ascii    "ksetjmpsym"
    .byte     0
L8085:
    .ascii    "kalignofsym"
    .byte     0
L8084:
    .ascii    "kgenericsym"
    .byte     0
L8083:
    .ascii    "kdefinedsym"
    .byte     0
L8082:
    .ascii    "ksizeofsym"
    .byte     0
L8081:
    .ascii    "kenumsym"
    .byte     0
L8080:
    .ascii    "kalignassym"
    .byte     0
L8079:
    .ascii    "kfnspecsym"
    .byte     0
L8078:
    .ascii    "kstdtypesym"
    .byte     0
L8077:
    .ascii    "ktypequalsym"
    .byte     0
L8076:
    .ascii    "klinkagesym"
    .byte     0
L8075:
    .ascii    "kunionsym"
    .byte     0
L8074:
    .ascii    "kstructsym"
    .byte     0
L8073:
    .ascii    "kswitchsym"
    .byte     0
L8072:
    .ascii    "kgotosym"
    .byte     0
L8071:
    .ascii    "kcontinuesym"
    .byte     0
L8070:
    .ascii    "kbreaksym"
    .byte     0
L8069:
    .ascii    "kreturnsym"
    .byte     0
L8068:
    .ascii    "kdosym"
    .byte     0
L8067:
    .ascii    "kwhilesym"
    .byte     0
L8066:
    .ascii    "kforsym"
    .byte     0
L8065:
    .ascii    "kdefaultsym"
    .byte     0
L8064:
    .ascii    "kcasesym"
    .byte     0
L8063:
    .ascii    "kelsesym"
    .byte     0
L8062:
    .ascii    "kifsym"
    .byte     0
L8061:
    .ascii    "ktypespecsym"
    .byte     0
L8060:
    .ascii    "kdeclspecsym"
    .byte     0
L8059:
    .ascii    "predefmacrosym"
    .byte     0
L8058:
    .ascii    "ksourcedirsym"
    .byte     0
L8057:
    .ascii    "namesym"
    .byte     0
L8056:
    .ascii    "placeholdersym"
    .byte     0
L8055:
    .ascii    "whitespacesym"
    .byte     0
L8054:
    .ascii    "wstringconstsym"
    .byte     0
L8053:
    .ascii    "stringconstsym"
    .byte     0
L8052:
    .ascii    "wcharconstsym"
    .byte     0
L8051:
    .ascii    "charconstsym"
    .byte     0
L8050:
    .ascii    "realconstsym"
    .byte     0
L8049:
    .ascii    "intconstsym"
    .byte     0
L8048:
    .ascii    "rawnumbersym"
    .byte     0
L8047:
    .ascii    "eofsym"
    .byte     0
L8046:
    .ascii    "eolsym"
    .byte     0
L8045:
    .ascii    "shrtosym"
    .byte     0
L8044:
    .ascii    "shltosym"
    .byte     0
L8043:
    .ascii    "ixortosym"
    .byte     0
L8042:
    .ascii    "iandtosym"
    .byte     0
L8041:
    .ascii    "iortosym"
    .byte     0
L8040:
    .ascii    "remtosym"
    .byte     0
L8039:
    .ascii    "divtosym"
    .byte     0
L8038:
    .ascii    "multosym"
    .byte     0
L8037:
    .ascii    "subtosym"
    .byte     0
L8036:
    .ascii    "addtosym"
    .byte     0
L8035:
    .ascii    "gtsym"
    .byte     0
L8034:
    .ascii    "gesym"
    .byte     0
L8033:
    .ascii    "lesym"
    .byte     0
L8032:
    .ascii    "ltsym"
    .byte     0
L8031:
    .ascii    "nesym"
    .byte     0
L8030:
    .ascii    "eqsym"
    .byte     0
L8029:
    .ascii    "abssym"
    .byte     0
L8028:
    .ascii    "decrsym"
    .byte     0
L8027:
    .ascii    "incrsym"
    .byte     0
L8026:
    .ascii    "notlsym"
    .byte     0
L8025:
    .ascii    "inotsym"
    .byte     0
L8024:
    .ascii    "shrsym"
    .byte     0
L8023:
    .ascii    "shlsym"
    .byte     0
L8022:
    .ascii    "andlsym"
    .byte     0
L8021:
    .ascii    "orlsym"
    .byte     0
L8020:
    .ascii    "ixorsym"
    .byte     0
L8019:
    .ascii    "iandsym"
    .byte     0
L8018:
    .ascii    "iorsym"
    .byte     0
L8017:
    .ascii    "remsym"
    .byte     0
L8016:
    .ascii    "divsym"
    .byte     0
L8015:
    .ascii    "mulsym"
    .byte     0
L8014:
    .ascii    "subsym"
    .byte     0
L8013:
    .ascii    "addsym"
    .byte     0
L8012:
    .ascii    "backslashsym"
    .byte     0
L8011:
    .ascii    "ellipsissym"
    .byte     0
L8010:
    .ascii    "curlsym"
    .byte     0
L8009:
    .ascii    "questionsym"
    .byte     0
L8008:
    .ascii    "rcurlysym"
    .byte     0
L8007:
    .ascii    "lcurlysym"
    .byte     0
L8006:
    .ascii    "rsqsym"
    .byte     0
L8005:
    .ascii    "lsqsym"
    .byte     0
L8004:
    .ascii    "rbracksym"
    .byte     0
L8003:
    .ascii    "lbracksym"
    .byte     0
L8002:
    .ascii    "assignsym2"
    .byte     0
L8001:
    .ascii    "assignsym"
    .byte     0
L8000:
    .ascii    "colonsym"
    .byte     0
L7999:
    .ascii    "semisym"
    .byte     0
L7998:
    .ascii    "commasym"
    .byte     0
L7997:
    .ascii    "hashhashsym"
    .byte     0
L7996:
    .ascii    "lithashsym"
    .byte     0
L7995:
    .ascii    "hashsym"
    .byte     0
L7994:
    .ascii    "lexhashsym"
    .byte     0
L7993:
    .ascii    "idotsym"
    .byte     0
L7992:
    .ascii    "dotsym"
    .byte     0
L7991:
    .ascii    "errorsym"
    .byte     0
L7990:
    .ascii    "jdummy"
    .byte     0
L7989:
    .ascii    "longjmp"
    .byte     0
L7988:
    .ascii    "setjmp"
    .byte     0
L7987:
    .ascii    "-- postdecr"
    .byte     0
L7986:
    .ascii    "++ postincr"
    .byte     0
L7985:
    .ascii    "-- preincr"
    .byte     0
L7984:
    .ascii    "++ preincr"
    .byte     0
L7983:
    .ascii    ">>="
    .byte     0
L7982:
    .ascii    "<<="
    .byte     0
L7981:
    .ascii    "^="
    .byte     0
L7980:
    .ascii    "|="
    .byte     0
L7979:
    .ascii    "&="
    .byte     0
L7978:
    .ascii    "%="
    .byte     0
L7977:
    .ascii    "/="
    .byte     0
L7976:
    .ascii    "*="
    .byte     0
L7975:
    .ascii    "-="
    .byte     0
L7974:
    .ascii    "+="
    .byte     0
L7973:
    .ascii    "~ inot"
    .byte     0
L7972:
    .ascii    "abs"
    .byte     0
L7971:
    .ascii    "- neg"
    .byte     0
L7970:
    .ascii    "jscale"
    .byte     0
L7969:
    .ascii    "jconvert"
    .byte     0
L7968:
    .ascii    "addrof &"
    .byte     0
L7967:
    .ascii    "subptr"
    .byte     0
L7966:
    .ascii    "addptr"
    .byte     0
L7965:
    .ascii    "ptr"
    .byte     0
L7964:
    .ascii    "jindex"
    .byte     0
L7963:
    .ascii    "jidot"
    .byte     0
L7962:
    .ascii    "jdot"
    .byte     0
L7961:
    .ascii    ">>"
    .byte     0
L7960:
    .ascii    "<<"
    .byte     0
L7959:
    .ascii    "^ ixor"
    .byte     0
L7958:
    .ascii    "| ior"
    .byte     0
L7957:
    .ascii    "& iand"
    .byte     0
L7956:
    .ascii    "% mod"
    .byte     0
L7955:
    .ascii    "/ div"
    .byte     0
L7954:
    .ascii    "* mul"
    .byte     0
L7953:
    .ascii    "- sub"
    .byte     0
L7952:
    .ascii    "+ add"
    .byte     0
L7951:
    .ascii    ">="
    .byte     0
L7950:
    .ascii    ">"
    .byte     0
L7949:
    .ascii    "<="
    .byte     0
L7948:
    .ascii    "<"
    .byte     0
L7947:
    .ascii    "!="
    .byte     0
L7946:
    .ascii    "=="
    .byte     0
L7945:
    .ascii    "&&"
    .byte     0
L7944:
    .ascii    "jifx"
    .byte     0
L7943:
    .ascii    "jcallfn"
    .byte     0
L7942:
    .ascii    "jexprlist"
    .byte     0
L7941:
    .ascii    "jmakelist"
    .byte     0
L7940:
    .ascii    "jistruel"
    .byte     0
L7939:
    .ascii    "! notl"
    .byte     0
L7938:
    .ascii    "|| orl"
    .byte     0
L7937:
    .ascii    "&& andl"
    .byte     0
L7936:
    .ascii    "jbreaksw"
    .byte     0
L7935:
    .ascii    "jswitch"
    .byte     0
L7934:
    .ascii    "jcontinue"
    .byte     0
L7933:
    .ascii    "jbreak"
    .byte     0
L7932:
    .ascii    "jdefaultstmt"
    .byte     0
L7931:
    .ascii    "jcasestmt"
    .byte     0
L7930:
    .ascii    "jlabelstmt"
    .byte     0
L7929:
    .ascii    "jgoto"
    .byte     0
L7928:
    .ascii    "jdowhile"
    .byte     0
L7927:
    .ascii    "jwhile"
    .byte     0
L7926:
    .ascii    "jfor"
    .byte     0
L7925:
    .ascii    "jif"
    .byte     0
L7924:
    .ascii    "jassign"
    .byte     0
L7923:
    .ascii    "jreturnx"
    .byte     0
L7922:
    .ascii    "jreturn"
    .byte     0
L7921:
    .ascii    "jdecl"
    .byte     0
L7920:
    .ascii    "jtempdecl"
    .byte     0
L7919:
    .ascii    "jblock"
    .byte     0
L7918:
    .ascii    "jfuncname"
    .byte     0
L7917:
    .ascii    "jwidenmem"
    .byte     0
L7916:
    .ascii    "jname"
    .byte     0
L7915:
    .ascii    "jnull"
    .byte     0
L7914:
    .ascii    "jconst"
    .byte     0
L7913:
    .ascii    "jnone"
    .byte     0
L7912:
    .ascii    "callback_fnspec"
    .byte     0
L7911:
    .ascii    "noreturn_fnspec"
    .byte     0
L7910:
    .ascii    "inline_fnspec"
    .byte     0
L7909:
    .ascii    "atomic_qual"
    .byte     0
L7908:
    .ascii    "restrict_qual"
    .byte     0
L7907:
    .ascii    "volatile_qual"
    .byte     0
L7906:
    .ascii    "const_qual"
    .byte     0
L7905:
    .ascii    "typedef_ss"
    .byte     0
L7904:
    .ascii    "extern_ss"
    .byte     0
L7903:
    .ascii    "register_ss"
    .byte     0
L7902:
    .ascii    "auto_ss"
    .byte     0
L7901:
    .ascii    "static_ss"
    .byte     0
L7900:
    .ascii    "none_ss"
    .byte     0
L7899:
    .ascii    "dummy_cc"
    .byte     0
L7898:
    .ascii    "callback_cc"
    .byte     0
L7897:
    .ascii    "stdcall_cc"
    .byte     0
L7896:
    .ascii    "clang_cc"
    .byte     0
L7895:
    .ascii    "own_cc"
    .byte     0
L7894:
    .ascii    "open_cc"
    .byte     0
L7893:
    .ascii    "Exp"
    .byte     0
L7892:
    .ascii    "Imp"
    .byte     0
L7891:
    .ascii    "Loc"
    .byte     0
L7890:
    .ascii    "Fn"
    .byte     0
L7889:
    .ascii    "-"
    .byte     0
L7888:
    .ascii    "pm_variadic"
    .byte     0
L7887:
    .ascii    "pm_empty"
    .byte     0
L7886:
    .ascii    "pm_notset"
    .byte     0
L7885:
    .ascii    "pm_normal"
    .byte     0
L7884:
    .ascii    "ts_atomic"
    .byte     0
L7883:
    .ascii    "ts_enum"
    .byte     0
L7882:
    .ascii    "ts_union"
    .byte     0
L7881:
    .ascii    "ts_struct"
    .byte     0
L7880:
    .ascii    "ts_user"
    .byte     0
L7879:
    .ascii    "ts_bool"
    .byte     0
L7878:
    .ascii    "ts_unsigned"
    .byte     0
L7877:
    .ascii    "ts_signed"
    .byte     0
L7876:
    .ascii    "ts_double"
    .byte     0
L7875:
    .ascii    "ts_float"
    .byte     0
L7874:
    .ascii    "ts_int"
    .byte     0
L7873:
    .ascii    "ts_long"
    .byte     0
L7872:
    .ascii    "ts_short"
    .byte     0
L7871:
    .ascii    "ts_char"
    .byte     0
L7870:
    .ascii    "ts_void"
    .byte     0
L7869:
    .ascii    "blockcat"
    .byte     0
L7868:
    .ascii    "shortcat"
    .byte     0
L7867:
    .ascii    "realcat"
    .byte     0
L7866:
    .ascii    "intcat"
    .byte     0
L7865:
    .ascii    "voidcat"
    .byte     0
L7864:
    .ascii    "tlast"
    .byte     0
L7863:
    .ascii    "notset"
    .byte     0
L7862:
    .ascii    "union"
    .byte     0
L7861:
    .ascii    "struct"
    .byte     0
L7860:
    .ascii    "array"
    .byte     0
L7859:
    .ascii    "block"
    .byte     0
L7858:
    .ascii    "label"
    .byte     0
L7857:
    .ascii    "proc"
    .byte     0
L7856:
    .ascii    "ref"
    .byte     0
L7855:
    .ascii    "enum"
    .byte     0
L7854:
    .ascii    "r64"
    .byte     0
L7853:
    .ascii    "r32"
    .byte     0
L7852:
    .ascii    "u64"
    .byte     0
L7851:
    .ascii    "u32"
    .byte     0
L7850:
    .ascii    "u16"
    .byte     0
L7849:
    .ascii    "u8"
    .byte     0
L7848:
    .ascii    "bool"
    .byte     0
L7847:
    .ascii    "i64"
    .byte     0
L7846:
    .ascii    "i32"
    .byte     0
L7845:
    .ascii    "i16"
    .byte     0
L7844:
    .ascii    "i8"
    .byte     0
L7843:
    .ascii    "void"
    .byte     0
L7842:
    .ascii    "MCC"
    .byte     0
L7841:
    .ascii    "    The 'MCC' C Compiler comprises:"
    .byte     10
    .byte     10
    .ascii    "    mcc.exe            Compiles to .asm files"
    .byte     10
    .ascii    "    aa.exe             Assembles .asm files to .obj files"
    .byte     10
    .ascii    "                       Assemblers and links .asm/.dll files to .exe"
    .byte     10
    .ascii    "    Standard headers   A minimal set inside mcc.exe"
    .byte     10
    .ascii    "    windows.h          As a standalone file"
    .byte     10
    .byte     10
    .ascii    "    Input files:"
    .byte     10
    .byte     10
    .ascii    "      prog             This is prog.c as the extension is optional"
    .byte     10
    .ascii    "      prog.c"
    .byte     10
    .ascii    "      lib.dll          Include .dll library when generating .exe"
    .byte     10
    .ascii    "      @file            Read parameters and optons from given file"
    .byte     10
    .byte     10
    .ascii    "    Options:"
    .byte     10
    .byte     10
    .ascii    "      -exe             (DEFAULT) Compile all modules to one .exe file via .asm files"
    .byte     10
    .ascii    "      -e               Preprocess each module to .i file"
    .byte     10
    .ascii    "      -s               Compile each module to .asm file"
    .byte     10
    .ascii    "      -c               Compile each module .obj via .asm"
    .byte     10
    .byte     10
    .ascii    "      -out:file        Specify output file for -exe only"
    .byte     10
    .byte     10
    .ascii    "    For .exe output, it will be named based on the first input file. Otherwise"
    .byte     10
    .ascii    "    use -out option"
    .byte     10
    .byte     10
    .ascii    "    .obj files can be linked using gcc on Windows. This option is"
    .byte     10
    .ascii    "    needed to be able to generate .dll files. However, this will not"
    .byte     10
    .ascii    "    work on newer gcc versions because mcc's generated code is not position"
    .byte     10
    .ascii    "    independent, and will only work loaded in the low 2GB of address space."
    .byte     10
    .byte     10
    .ascii    "    Libraries msvcrt.dll, gdi32.dll, user32.dll and kernel32.dll are"
    .byte     10
    .ascii    "    automatically included as search libraries for imported functions."
    .byte     10
    .byte     10
    .ascii    "    Other kinds of binary libraries or files (.a, .lib, .obj etc) are not supported."
    .byte     10
    .byte     10
    .ascii    "    Omissions, Restrictions and Bugs (highlights only as there are dozens):"
    .byte     10
    .byte     10
    .ascii    "      * No VLAs, compound literals, designated initialisers"
    .byte     10
    .ascii    "      * Restrictions on complexity of data initialisers"
    .byte     10
    .byte     0
L7840:
    .ascii    "long64"
    .byte     0
L7839:
    .ascii    "showil"
    .byte     0
L7838:
    .ascii    "options"
    .byte     0
L7837:
    .ascii    "himem"
    .byte     0
L7836:
    .ascii    "norip"
    .byte     0
L7835:
    .ascii    "shortnames"
    .byte     0
L7834:
    .ascii    "stdout"
    .byte     0
L7833:
    .ascii    "o"
    .byte     0
L7832:
    .ascii    "writeheaders"
    .byte     0
L7831:
    .ascii    "ext"
    .byte     0
L7830:
    .ascii    "help"
    .byte     0
L7829:
    .ascii    "h"
    .byte     0
L7828:
    .ascii    "ss"
    .byte     0
L7827:
    .ascii    "cs"
    .byte     0
L7826:
    .ascii    "q"
    .byte     0
L7825:
    .ascii    "vv"
    .byte     0
L7824:
    .ascii    "v"
    .byte     0
L7823:
    .ascii    "time2"
    .byte     0
L7822:
    .ascii    "time"
    .byte     0
L7821:
    .ascii    "showfiles"
    .byte     0
L7820:
    .ascii    "showtypes"
    .byte     0
L7819:
    .ascii    "showss"
    .byte     0
L7818:
    .ascii    "showmcl"
    .byte     0
L7817:
    .ascii    "showpst"
    .byte     0
L7816:
    .ascii    "showpcl"
    .byte     0
L7815:
    .ascii    "showast"
    .byte     0
L7814:
    .ascii    "showstflat"
    .byte     0
L7813:
    .ascii    "showst"
    .byte     0
L7812:
    .ascii    "includes"
    .byte     0
L7811:
    .ascii    "incl"
    .byte     0
L7810:
    .ascii    "headers"
    .byte     0
L7809:
    .ascii    "paths"
    .byte     0
L7808:
    .ascii    "noconst"
    .byte     0
L7807:
    .ascii    "no"
    .byte     0
L7806:
    .ascii    "nopeep"
    .byte     0
L7805:
    .ascii    "noregs"
    .byte     0
L7804:
    .ascii    "r"
    .byte     0
L7803:
    .ascii    "exe"
    .byte     0
L7802:
    .ascii    "dll"
    .byte     0
L7801:
    .ascii    "mx"
    .byte     0
L7800:
    .ascii    "obj"
    .byte     0
L7799:
    .ascii    "c"
    .byte     0
L7798:
    .ascii    "a"
    .byte     0
L7797:
    .ascii    "s"
    .byte     0
L7796:
    .ascii    "mcl"
    .byte     0
L7795:
    .ascii    "i"
    .byte     0
L7794:
    .ascii    "pi"
    .byte     0
L7793:
    .ascii    "p"
    .byte     0
L7792:
    .ascii    "type"
    .byte     0
L7791:
    .ascii    "parse"
    .byte     0
L7790:
    .ascii    "ei"
    .byte     0
L7789:
    .ascii    "e"
    .byte     0
L7788:
    .ascii    "load"
    .byte     0
L7787:
    .ascii    "exe"
    .byte     0
L7786:
    .ascii    "(run)"
    .byte     0
L7785:
    .ascii    "exe"
    .byte     0
L7784:
    .ascii    "dll"
    .byte     0
L7783:
    .ascii    "obj"
    .byte     0
L7782:
    .ascii    "mx"
    .byte     0
L7781:
    .ascii    "asm"
    .byte     0
L7780:
    .ascii    "(int)"
    .byte     0
L7779:
    .ascii    "pcl"
    .byte     0
L7778:
    .byte     0
L7777:
    .ascii    "i"
    .byte     0
L7776:
    .byte     0
L7775:
    .ascii    "run_pass"
    .byte     0
L7774:
    .ascii    "exe_pass"
    .byte     0
L7773:
    .ascii    "dll_pass"
    .byte     0
L7772:
    .ascii    "obj_pass"
    .byte     0
L7771:
    .ascii    "mx_pass"
    .byte     0
L7770:
    .ascii    "asm_pass"
    .byte     0
L7769:
    .ascii    "mcl_pass"
    .byte     0
L7768:
    .ascii    "runpcl_pass"
    .byte     0
L7767:
    .ascii    "pcl_pass"
    .byte     0
L7766:
    .ascii    "type_pass"
    .byte     0
L7765:
    .ascii    "parse_pass"
    .byte     0
L7764:
    .ascii    "pp_pass"
    .byte     0
L7763:
    .ascii    "load_pass"
    .byte     0
L7762:
    .ascii    "asm"
    .byte     0
L7761:
    .ascii    "rel8_rel"
    .byte     0
L7760:
    .ascii    "rel321_rel"
    .byte     0
L7759:
    .ascii    "rel32_rel"
    .byte     0
L7758:
    .ascii    "addr32nb_rel"
    .byte     0
L7757:
    .ascii    "addr32_rel"
    .byte     0
L7756:
    .ascii    "addr64_rel"
    .byte     0
L7755:
    .ascii    "abs_rel"
    .byte     0
L7754:
    .ascii    "xmm15"
    .byte     0
L7753:
    .ascii    "xmm13"
    .byte     0
L7752:
    .ascii    "xmm12"
    .byte     0
L7751:
    .ascii    "xmm11"
    .byte     0
L7750:
    .ascii    "xmm10"
    .byte     0
L7749:
    .ascii    "xmm9"
    .byte     0
L7748:
    .ascii    "xmm8"
    .byte     0
L7747:
    .ascii    "xmm7"
    .byte     0
L7746:
    .ascii    "xmm6"
    .byte     0
L7745:
    .ascii    "xmm5"
    .byte     0
L7744:
    .ascii    "xmm4"
    .byte     0
L7743:
    .ascii    "xmm3"
    .byte     0
L7742:
    .ascii    "xmm2"
    .byte     0
L7741:
    .ascii    "xmm1"
    .byte     0
L7740:
    .ascii    "xmm0"
    .byte     0
L7739:
    .ascii    "-"
    .byte     0
L7738:
    .ascii    "temp"
    .byte     0
L7737:
    .ascii    "regvar"
    .byte     0
L7736:
    .ascii    "reg"
    .byte     0
L7735:
    .ascii    "pend"
    .byte     0
L7734:
    .ascii    "a_xreg"
    .byte     0
L7733:
    .ascii    "a_cond"
    .byte     0
L7732:
    .ascii    "a_mem"
    .byte     0
L7731:
    .ascii    "a_imm"
    .byte     0
L7730:
    .ascii    "a_reg"
    .byte     0
L7729:
    .ascii    "a_none"
    .byte     0
L7728:
    .ascii    "back_ref"
    .byte     0
L7727:
    .ascii    "fwd_ref"
    .byte     0
L7726:
    .ascii    "extern_ref"
    .byte     0
L7725:
    .ascii    "impdata_seg"
    .byte     0
L7724:
    .ascii    "rodata_seg"
    .byte     0
L7723:
    .ascii    "zdata_seg"
    .byte     0
L7722:
    .ascii    "idata_seg"
    .byte     0
L7721:
    .ascii    "code_seg"
    .byte     0
L7720:
    .ascii    "no_seg"
    .byte     0
L7719:
    .ascii    "cmovg"
    .byte     0
L7718:
    .ascii    "cmovle"
    .byte     0
L7717:
    .ascii    "cmovge"
    .byte     0
L7716:
    .ascii    "cmovl"
    .byte     0
L7715:
    .ascii    "cmovnp"
    .byte     0
L7714:
    .ascii    "cmovp"
    .byte     0
L7713:
    .ascii    "cmovns"
    .byte     0
L7712:
    .ascii    "cmovs"
    .byte     0
L7711:
    .ascii    "cmova"
    .byte     0
L7710:
    .ascii    "cmovbe"
    .byte     0
L7709:
    .ascii    "cmovnz"
    .byte     0
L7708:
    .ascii    "cmovz"
    .byte     0
L7707:
    .ascii    "cmovae"
    .byte     0
L7706:
    .ascii    "cmovb"
    .byte     0
L7705:
    .ascii    "cmovno"
    .byte     0
L7704:
    .ascii    "cmovo"
    .byte     0
L7703:
    .ascii    "setg"
    .byte     0
L7702:
    .ascii    "setle"
    .byte     0
L7701:
    .ascii    "setge"
    .byte     0
L7700:
    .ascii    "setl"
    .byte     0
L7699:
    .ascii    "setnp"
    .byte     0
L7698:
    .ascii    "setp"
    .byte     0
L7697:
    .ascii    "setns"
    .byte     0
L7696:
    .ascii    "sets"
    .byte     0
L7695:
    .ascii    "seta"
    .byte     0
L7694:
    .ascii    "setbe"
    .byte     0
L7693:
    .ascii    "setnz"
    .byte     0
L7692:
    .ascii    "setz"
    .byte     0
L7691:
    .ascii    "setae"
    .byte     0
L7690:
    .ascii    "setb"
    .byte     0
L7689:
    .ascii    "setno"
    .byte     0
L7688:
    .ascii    "seto"
    .byte     0
L7687:
    .ascii    "jnc"
    .byte     0
L7686:
    .ascii    "jc"
    .byte     0
L7685:
    .ascii    "jg"
    .byte     0
L7684:
    .ascii    "jle"
    .byte     0
L7683:
    .ascii    "jge"
    .byte     0
L7682:
    .ascii    "jl"
    .byte     0
L7681:
    .ascii    "jnp"
    .byte     0
L7680:
    .ascii    "jp"
    .byte     0
L7679:
    .ascii    "jns"
    .byte     0
L7678:
    .ascii    "js"
    .byte     0
L7677:
    .ascii    "ja"
    .byte     0
L7676:
    .ascii    "jbe"
    .byte     0
L7675:
    .ascii    "jnz"
    .byte     0
L7674:
    .ascii    "jz"
    .byte     0
L7673:
    .ascii    "jae"
    .byte     0
L7672:
    .ascii    "jb"
    .byte     0
L7671:
    .ascii    "jno"
    .byte     0
L7670:
    .ascii    "jo"
    .byte     0
L7669:
    .ascii    "mmx7"
    .byte     0
L7668:
    .ascii    "mmx6"
    .byte     0
L7667:
    .ascii    "mmx5"
    .byte     0
L7666:
    .ascii    "mmx4"
    .byte     0
L7665:
    .ascii    "mmx3"
    .byte     0
L7664:
    .ascii    "mmx2"
    .byte     0
L7663:
    .ascii    "mmx1"
    .byte     0
L7662:
    .ascii    "mmx0"
    .byte     0
L7661:
    .ascii    "st7"
    .byte     0
L7660:
    .ascii    "st6"
    .byte     0
L7659:
    .ascii    "st5"
    .byte     0
L7658:
    .ascii    "st4"
    .byte     0
L7657:
    .ascii    "st3"
    .byte     0
L7656:
    .ascii    "st2"
    .byte     0
L7655:
    .ascii    "st1"
    .byte     0
L7654:
    .ascii    "st0"
    .byte     0
L7653:
    .ascii    "xmm15"
    .byte     0
L7652:
    .ascii    "xmm14"
    .byte     0
L7651:
    .ascii    "xmm13"
    .byte     0
L7650:
    .ascii    "xmm12"
    .byte     0
L7649:
    .ascii    "xmm11"
    .byte     0
L7648:
    .ascii    "xmm10"
    .byte     0
L7647:
    .ascii    "xmm9"
    .byte     0
L7646:
    .ascii    "xmm8"
    .byte     0
L7645:
    .ascii    "xmm7"
    .byte     0
L7644:
    .ascii    "xmm6"
    .byte     0
L7643:
    .ascii    "xmm5"
    .byte     0
L7642:
    .ascii    "xmm4"
    .byte     0
L7641:
    .ascii    "xmm3"
    .byte     0
L7640:
    .ascii    "xmm2"
    .byte     0
L7639:
    .ascii    "xmm1"
    .byte     0
L7638:
    .ascii    "xmm0"
    .byte     0
L7637:
    .ascii    "r15b"
    .byte     0
L7636:
    .ascii    "r14b"
    .byte     0
L7635:
    .ascii    "r13b"
    .byte     0
L7634:
    .ascii    "r12b"
    .byte     0
L7633:
    .ascii    "r11b"
    .byte     0
L7632:
    .ascii    "r10b"
    .byte     0
L7631:
    .ascii    "r9b"
    .byte     0
L7630:
    .ascii    "r8b"
    .byte     0
L7629:
    .ascii    "spl"
    .byte     0
L7628:
    .ascii    "bpl"
    .byte     0
L7627:
    .ascii    "dil"
    .byte     0
L7626:
    .ascii    "sil"
    .byte     0
L7625:
    .ascii    "dh"
    .byte     0
L7624:
    .ascii    "ch"
    .byte     0
L7623:
    .ascii    "bh"
    .byte     0
L7622:
    .ascii    "ah"
    .byte     0
L7621:
    .ascii    "dl"
    .byte     0
L7620:
    .ascii    "cl"
    .byte     0
L7619:
    .ascii    "bl"
    .byte     0
L7618:
    .ascii    "al"
    .byte     0
L7617:
    .ascii    "r15w"
    .byte     0
L7616:
    .ascii    "r14w"
    .byte     0
L7615:
    .ascii    "r13w"
    .byte     0
L7614:
    .ascii    "r12w"
    .byte     0
L7613:
    .ascii    "r11w"
    .byte     0
L7612:
    .ascii    "r10w"
    .byte     0
L7611:
    .ascii    "r9w"
    .byte     0
L7610:
    .ascii    "r8w"
    .byte     0
L7609:
    .ascii    "sp"
    .byte     0
L7608:
    .ascii    "bp"
    .byte     0
L7607:
    .ascii    "di"
    .byte     0
L7606:
    .ascii    "si"
    .byte     0
L7605:
    .ascii    "dx"
    .byte     0
L7604:
    .ascii    "cx"
    .byte     0
L7603:
    .ascii    "bx"
    .byte     0
L7602:
    .ascii    "ax"
    .byte     0
L7601:
    .ascii    "r15d"
    .byte     0
L7600:
    .ascii    "r14d"
    .byte     0
L7599:
    .ascii    "r13d"
    .byte     0
L7598:
    .ascii    "r12d"
    .byte     0
L7597:
    .ascii    "r11d"
    .byte     0
L7596:
    .ascii    "r10d"
    .byte     0
L7595:
    .ascii    "r9d"
    .byte     0
L7594:
    .ascii    "r8d"
    .byte     0
L7593:
    .ascii    "esp"
    .byte     0
L7592:
    .ascii    "ebp"
    .byte     0
L7591:
    .ascii    "edi"
    .byte     0
L7590:
    .ascii    "esi"
    .byte     0
L7589:
    .ascii    "edx"
    .byte     0
L7588:
    .ascii    "ecx"
    .byte     0
L7587:
    .ascii    "ebx"
    .byte     0
L7586:
    .ascii    "eax"
    .byte     0
L7585:
    .ascii    "r15"
    .byte     0
L7584:
    .ascii    "r14"
    .byte     0
L7583:
    .ascii    "r13"
    .byte     0
L7582:
    .ascii    "r12"
    .byte     0
L7581:
    .ascii    "r11"
    .byte     0
L7580:
    .ascii    "r10"
    .byte     0
L7579:
    .ascii    "r9"
    .byte     0
L7578:
    .ascii    "r8"
    .byte     0
L7577:
    .ascii    "rsp"
    .byte     0
L7576:
    .ascii    "rbp"
    .byte     0
L7575:
    .ascii    "rdi"
    .byte     0
L7574:
    .ascii    "rsi"
    .byte     0
L7573:
    .ascii    "rdx"
    .byte     0
L7572:
    .ascii    "rcx"
    .byte     0
L7571:
    .ascii    "rbx"
    .byte     0
L7570:
    .ascii    "rax"
    .byte     0
L7569:
    .ascii    "_b20"
    .byte     0
L7568:
    .ascii    "b19"
    .byte     0
L7567:
    .ascii    "b18"
    .byte     0
L7566:
    .ascii    "b17"
    .byte     0
L7565:
    .ascii    "b16"
    .byte     0
L7564:
    .ascii    "b15"
    .byte     0
L7563:
    .ascii    "b14"
    .byte     0
L7562:
    .ascii    "b13"
    .byte     0
L7561:
    .ascii    "b12"
    .byte     0
L7560:
    .ascii    "b11"
    .byte     0
L7559:
    .ascii    "b10"
    .byte     0
L7558:
    .ascii    "b9"
    .byte     0
L7557:
    .ascii    "b8"
    .byte     0
L7556:
    .ascii    "b7"
    .byte     0
L7555:
    .ascii    "b6"
    .byte     0
L7554:
    .ascii    "b5"
    .byte     0
L7553:
    .ascii    "b4"
    .byte     0
L7552:
    .ascii    "b3"
    .byte     0
L7551:
    .ascii    "b2"
    .byte     0
L7550:
    .ascii    "b1"
    .byte     0
L7549:
    .ascii    "b0"
    .byte     0
L7548:
    .ascii    "w15"
    .byte     0
L7547:
    .ascii    "w14"
    .byte     0
L7546:
    .ascii    "w13"
    .byte     0
L7545:
    .ascii    "w12"
    .byte     0
L7544:
    .ascii    "w11"
    .byte     0
L7543:
    .ascii    "w10"
    .byte     0
L7542:
    .ascii    "w9"
    .byte     0
L7541:
    .ascii    "w8"
    .byte     0
L7540:
    .ascii    "w7"
    .byte     0
L7539:
    .ascii    "w6"
    .byte     0
L7538:
    .ascii    "w5"
    .byte     0
L7537:
    .ascii    "w4"
    .byte     0
L7536:
    .ascii    "w3"
    .byte     0
L7535:
    .ascii    "w2"
    .byte     0
L7534:
    .ascii    "w1"
    .byte     0
L7533:
    .ascii    "w0"
    .byte     0
L7532:
    .ascii    "a15"
    .byte     0
L7531:
    .ascii    "a14"
    .byte     0
L7530:
    .ascii    "a13"
    .byte     0
L7529:
    .ascii    "a12"
    .byte     0
L7528:
    .ascii    "a11"
    .byte     0
L7527:
    .ascii    "a10"
    .byte     0
L7526:
    .ascii    "a9"
    .byte     0
L7525:
    .ascii    "a8"
    .byte     0
L7524:
    .ascii    "a7"
    .byte     0
L7523:
    .ascii    "a6"
    .byte     0
L7522:
    .ascii    "a5"
    .byte     0
L7521:
    .ascii    "a4"
    .byte     0
L7520:
    .ascii    "a3"
    .byte     0
L7519:
    .ascii    "a2"
    .byte     0
L7518:
    .ascii    "a1"
    .byte     0
L7517:
    .ascii    "a0"
    .byte     0
L7516:
    .ascii    "d15"
    .byte     0
L7515:
    .ascii    "d14"
    .byte     0
L7514:
    .ascii    "d13"
    .byte     0
L7513:
    .ascii    "d12"
    .byte     0
L7512:
    .ascii    "d11"
    .byte     0
L7511:
    .ascii    "d10"
    .byte     0
L7510:
    .ascii    "d9"
    .byte     0
L7509:
    .ascii    "d8"
    .byte     0
L7508:
    .ascii    "d7"
    .byte     0
L7507:
    .ascii    "d6"
    .byte     0
L7506:
    .ascii    "d5"
    .byte     0
L7505:
    .ascii    "d4"
    .byte     0
L7504:
    .ascii    "d3"
    .byte     0
L7503:
    .ascii    "d2"
    .byte     0
L7502:
    .ascii    "d1"
    .byte     0
L7501:
    .ascii    "d0"
    .byte     0
L7500:
    .ascii    "a"
    .byte     0
L7499:
    .ascii    "be"
    .byte     0
L7498:
    .ascii    "ae"
    .byte     0
L7497:
    .ascii    "b"
    .byte     0
L7496:
    .ascii    "g"
    .byte     0
L7495:
    .ascii    "le"
    .byte     0
L7494:
    .ascii    "ge"
    .byte     0
L7493:
    .ascii    "l"
    .byte     0
L7492:
    .ascii    "np"
    .byte     0
L7491:
    .ascii    "p"
    .byte     0
L7490:
    .ascii    "ns"
    .byte     0
L7489:
    .ascii    "s"
    .byte     0
L7488:
    .ascii    "a"
    .byte     0
L7487:
    .ascii    "be"
    .byte     0
L7486:
    .ascii    "nz"
    .byte     0
L7485:
    .ascii    "z"
    .byte     0
L7484:
    .ascii    "ae"
    .byte     0
L7483:
    .ascii    "b"
    .byte     0
L7482:
    .ascii    "no"
    .byte     0
L7481:
    .ascii    "o"
    .byte     0
L7480:
    .ascii    "fgt"
    .byte     0
L7479:
    .ascii    "fle"
    .byte     0
L7478:
    .ascii    "fge"
    .byte     0
L7477:
    .ascii    "flt"
    .byte     0
L7476:
    .ascii    "gt"
    .byte     0
L7475:
    .ascii    "le"
    .byte     0
L7474:
    .ascii    "ge"
    .byte     0
L7473:
    .ascii    "lt"
    .byte     0
L7472:
    .ascii    "np"
    .byte     0
L7471:
    .ascii    "p"
    .byte     0
L7470:
    .ascii    "ns"
    .byte     0
L7469:
    .ascii    "s"
    .byte     0
L7468:
    .ascii    "gtu"
    .byte     0
L7467:
    .ascii    "leu"
    .byte     0
L7466:
    .ascii    "ne"
    .byte     0
L7465:
    .ascii    "eq"
    .byte     0
L7464:
    .ascii    "geu"
    .byte     0
L7463:
    .ascii    "ltu"
    .byte     0
L7462:
    .ascii    "nov"
    .byte     0
L7461:
    .ascii    "ov"
    .byte     0
L7460:
    .ascii    "r19"
    .byte     0
L7459:
    .ascii    "r18"
    .byte     0
L7458:
    .ascii    "r17"
    .byte     0
L7457:
    .ascii    "r16"
    .byte     0
L7456:
    .ascii    "r15"
    .byte     0
L7455:
    .ascii    "r14"
    .byte     0
L7454:
    .ascii    "r13"
    .byte     0
L7453:
    .ascii    "r12"
    .byte     0
L7452:
    .ascii    "r11"
    .byte     0
L7451:
    .ascii    "r10"
    .byte     0
L7450:
    .ascii    "r9"
    .byte     0
L7449:
    .ascii    "r8"
    .byte     0
L7448:
    .ascii    "r7"
    .byte     0
L7447:
    .ascii    "r6"
    .byte     0
L7446:
    .ascii    "r5"
    .byte     0
L7445:
    .ascii    "r4"
    .byte     0
L7444:
    .ascii    "r3"
    .byte     0
L7443:
    .ascii    "r2"
    .byte     0
L7442:
    .ascii    "r1"
    .byte     0
L7441:
    .ascii    "r0"
    .byte     0
L7440:
    .ascii    "rnone"
    .byte     0
L7439:
    .ascii    "m_halt"
    .byte     0
L7438:
    .ascii    "m_xxxx"
    .byte     0
L7437:
    .ascii    "m_cpuid"
    .byte     0
L7436:
    .ascii    "m_fldln2"
    .byte     0
L7435:
    .ascii    "m_fldlg2"
    .byte     0
L7434:
    .ascii    "m_fld2e"
    .byte     0
L7433:
    .ascii    "m_fld2t"
    .byte     0
L7432:
    .ascii    "m_fldpi"
    .byte     0
L7431:
    .ascii    "m_fld1"
    .byte     0
L7430:
    .ascii    "m_fldz"
    .byte     0
L7429:
    .ascii    "m_finit"
    .byte     0
L7428:
    .ascii    "m_bswap"
    .byte     0
L7427:
    .ascii    "m_popcnt"
    .byte     0
L7426:
    .ascii    "m_rdtsc"
    .byte     0
L7425:
    .ascii    "m_cmpsq"
    .byte     0
L7424:
    .ascii    "m_cmpsd"
    .byte     0
L7423:
    .ascii    "m_cmpsw"
    .byte     0
L7422:
    .ascii    "m_cmpsb"
    .byte     0
L7421:
    .ascii    "m_jrcxz"
    .byte     0
L7420:
    .ascii    "m_jecxz"
    .byte     0
L7419:
    .ascii    "m_loopcx"
    .byte     0
L7418:
    .ascii    "m_loopz"
    .byte     0
L7417:
    .ascii    "m_loopnz"
    .byte     0
L7416:
    .ascii    "m_xlat"
    .byte     0
L7415:
    .ascii    "m_resq"
    .byte     0
L7414:
    .ascii    "m_resd"
    .byte     0
L7413:
    .ascii    "m_resw"
    .byte     0
L7412:
    .ascii    "m_resb"
    .byte     0
L7411:
    .ascii    "m_align"
    .byte     0
L7410:
    .ascii    "m_csegment"
    .byte     0
L7409:
    .ascii    "m_zsegment"
    .byte     0
L7408:
    .ascii    "m_isegment"
    .byte     0
L7407:
    .ascii    "m_ascii"
    .byte     0
L7406:
    .ascii    "m_dq"
    .byte     0
L7405:
    .ascii    "m_dd"
    .byte     0
L7404:
    .ascii    "m_dw"
    .byte     0
L7403:
    .ascii    "m_db"
    .byte     0
L7402:
    .ascii    "m_maxsd"
    .byte     0
L7401:
    .ascii    "m_minsd"
    .byte     0
L7400:
    .ascii    "m_maxss"
    .byte     0
L7399:
    .ascii    "m_minss"
    .byte     0
L7398:
    .ascii    "m_fchs"
    .byte     0
L7397:
    .ascii    "m_fabs"
    .byte     0
L7396:
    .ascii    "m_fpatan"
    .byte     0
L7395:
    .ascii    "m_fptan"
    .byte     0
L7394:
    .ascii    "m_fsincos"
    .byte     0
L7393:
    .ascii    "m_fcos"
    .byte     0
L7392:
    .ascii    "m_fsin"
    .byte     0
L7391:
    .ascii    "m_fsqrt"
    .byte     0
L7390:
    .ascii    "m_fdiv"
    .byte     0
L7389:
    .ascii    "m_fmul"
    .byte     0
L7388:
    .ascii    "m_fsub"
    .byte     0
L7387:
    .ascii    "m_fadd"
    .byte     0
L7386:
    .ascii    "m_fistp"
    .byte     0
L7385:
    .ascii    "m_fist"
    .byte     0
L7384:
    .ascii    "m_fild"
    .byte     0
L7383:
    .ascii    "m_fstp"
    .byte     0
L7382:
    .ascii    "m_fst"
    .byte     0
L7381:
    .ascii    "m_fld"
    .byte     0
L7380:
    .ascii    "m_pcmpistrm"
    .byte     0
L7379:
    .ascii    "m_pcmpistri"
    .byte     0
L7378:
    .ascii    "m_movdqu"
    .byte     0
L7377:
    .ascii    "m_movdqa"
    .byte     0
L7376:
    .ascii    "m_cvtss2sd"
    .byte     0
L7375:
    .ascii    "m_cvtsd2ss"
    .byte     0
L7374:
    .ascii    "m_cvtsi2sd"
    .byte     0
L7373:
    .ascii    "m_cvtsi2ss"
    .byte     0
L7372:
    .ascii    "m_cvttsd2si"
    .byte     0
L7371:
    .ascii    "m_cvttss2si"
    .byte     0
L7370:
    .ascii    "m_cvtsd2si"
    .byte     0
L7369:
    .ascii    "m_cvtss2si"
    .byte     0
L7368:
    .ascii    "m_pand"
    .byte     0
L7367:
    .ascii    "m_pxor"
    .byte     0
L7366:
    .ascii    "m_andpd"
    .byte     0
L7365:
    .ascii    "m_andps"
    .byte     0
L7364:
    .ascii    "m_xorpd"
    .byte     0
L7363:
    .ascii    "m_xorps"
    .byte     0
L7362:
    .ascii    "m_ucomisd"
    .byte     0
L7361:
    .ascii    "m_comisd"
    .byte     0
L7360:
    .ascii    "m_comiss"
    .byte     0
L7359:
    .ascii    "m_divsd"
    .byte     0
L7358:
    .ascii    "m_divss"
    .byte     0
L7357:
    .ascii    "m_mulsd"
    .byte     0
L7356:
    .ascii    "m_mulss"
    .byte     0
L7355:
    .ascii    "m_subsd"
    .byte     0
L7354:
    .ascii    "m_subss"
    .byte     0
L7353:
    .ascii    "m_addsd"
    .byte     0
L7352:
    .ascii    "m_addss"
    .byte     0
L7351:
    .ascii    "m_sqrtsd"
    .byte     0
L7350:
    .ascii    "m_sqrtss"
    .byte     0
L7349:
    .ascii    "m_shrd"
    .byte     0
L7348:
    .ascii    "m_shld"
    .byte     0
L7347:
    .ascii    "m_bsr"
    .byte     0
L7346:
    .ascii    "m_bsf"
    .byte     0
L7345:
    .ascii    "m_setcc"
    .byte     0
L7344:
    .ascii    "m_cqo"
    .byte     0
L7343:
    .ascii    "m_cdq"
    .byte     0
L7342:
    .ascii    "m_cwd"
    .byte     0
L7341:
    .ascii    "m_cbw"
    .byte     0
L7340:
    .ascii    "m_dec"
    .byte     0
L7339:
    .ascii    "m_inc"
    .byte     0
L7338:
    .ascii    "m_notx"
    .byte     0
L7337:
    .ascii    "m_neg"
    .byte     0
L7336:
    .ascii    "m_rcr"
    .byte     0
L7335:
    .ascii    "m_rcl"
    .byte     0
L7334:
    .ascii    "m_ror"
    .byte     0
L7333:
    .ascii    "m_rol"
    .byte     0
L7332:
    .ascii    "m_shr"
    .byte     0
L7331:
    .ascii    "m_sar"
    .byte     0
L7330:
    .ascii    "m_shl"
    .byte     0
L7329:
    .ascii    "m_cmp"
    .byte     0
L7328:
    .ascii    "m_test"
    .byte     0
L7327:
    .ascii    "m_xorx"
    .byte     0
L7326:
    .ascii    "m_orx"
    .byte     0
L7325:
    .ascii    "m_andx"
    .byte     0
L7324:
    .ascii    "m_div"
    .byte     0
L7323:
    .ascii    "m_idiv"
    .byte     0
L7322:
    .ascii    "m_imul3"
    .byte     0
L7321:
    .ascii    "m_imul2"
    .byte     0
L7320:
    .ascii    "m_mul"
    .byte     0
L7319:
    .ascii    "m_imul"
    .byte     0
L7318:
    .ascii    "m_sbb"
    .byte     0
L7317:
    .ascii    "m_adc"
    .byte     0
L7316:
    .ascii    "m_sub"
    .byte     0
L7315:
    .ascii    "m_add"
    .byte     0
L7314:
    .ascii    "m_xchg"
    .byte     0
L7313:
    .ascii    "m_jmpcc"
    .byte     0
L7312:
    .ascii    "m_jmp"
    .byte     0
L7311:
    .ascii    "m_retn"
    .byte     0
L7310:
    .ascii    "m_leave"
    .byte     0
L7309:
    .ascii    "m_ret"
    .byte     0
L7308:
    .ascii    "m_call"
    .byte     0
L7307:
    .ascii    "m_movsxd"
    .byte     0
L7306:
    .ascii    "m_movzx"
    .byte     0
L7305:
    .ascii    "m_movsx"
    .byte     0
L7304:
    .ascii    "m_movq"
    .byte     0
L7303:
    .ascii    "m_movd"
    .byte     0
L7302:
    .ascii    "m_cmovcc"
    .byte     0
L7301:
    .ascii    "m_lea"
    .byte     0
L7300:
    .ascii    "m_pop"
    .byte     0
L7299:
    .ascii    "m_push"
    .byte     0
L7298:
    .ascii    "m_mov"
    .byte     0
L7297:
    .ascii    "m_nop"
    .byte     0
L7296:
    .ascii    "m_labelx"
    .byte     0
L7295:
    .ascii    "m_endx"
    .byte     0
L7294:
    .ascii    "m_trace"
    .byte     0
L7293:
    .ascii    "m_definereg"
    .byte     0
L7292:
    .ascii    "m_define"
    .byte     0
L7291:
    .ascii    "m_labelname"
    .byte     0
L7290:
    .ascii    "m_comment"
    .byte     0
L7289:
    .ascii    "m_procend"
    .byte     0
L7288:
    .ascii    "m_procstart"
    .byte     0
L7287:
    .ascii    "temp_val"
    .byte     0
L7286:
    .ascii    "name_val"
    .byte     0
L7285:
    .ascii    "label_val"
    .byte     0
L7284:
    .ascii    "def_val"
    .byte     0
L7283:
    .ascii    "stringimm_val"
    .byte     0
L7282:
    .ascii    "realmem_val"
    .byte     0
L7281:
    .ascii    "realimm_val"
    .byte     0
L7280:
    .ascii    "intimm_val"
    .byte     0
L7279:
    .ascii    "no_val"
    .byte     0
L7278:
    .ascii    "Program"
    .byte     0
L7277:
    .ascii    "Misc"
    .byte     0
L7276:
    .ascii    "Export"
    .byte     0
L7275:
    .ascii    "Label"
    .byte     0
L7274:
    .ascii    "Param"
    .byte     0
L7273:
    .ascii    "Local"
    .byte     0
L7272:
    .ascii    "Static"
    .byte     0
L7271:
    .ascii    "Proc"
    .byte     0
L7270:
    .ascii    "Import"
    .byte     0
L7269:
    .ascii    "--"
    .byte     0
L7268:
    .ascii    "gt"
    .byte     0
L7267:
    .ascii    "ge"
    .byte     0
L7266:
    .ascii    "le"
    .byte     0
L7265:
    .ascii    "lt"
    .byte     0
L7264:
    .ascii    "ne"
    .byte     0
L7263:
    .ascii    "eq"
    .byte     0
L7262:
    .ascii    "xx"
    .byte     0
L7261:
    .ascii    "extproc"
    .byte     0
L7260:
    .ascii    "addlib"
    .byte     0
L7259:
    .ascii    "variadic"
    .byte     0
L7258:
    .ascii    "rettype"
    .byte     0
L7257:
    .ascii    "local"
    .byte     0
L7256:
    .ascii    "param"
    .byte     0
L7255:
    .ascii    "endprog"
    .byte     0
L7254:
    .ascii    "comment"
    .byte     0
L7253:
    .ascii    "eval"
    .byte     0
L7252:
    .ascii    "loadall"
    .byte     0
L7251:
    .ascii    "setarg"
    .byte     0
L7250:
    .ascii    "setcall"
    .byte     0
L7249:
    .ascii    "longjmp"
    .byte     0
L7248:
    .ascii    "setjmp"
    .byte     0
L7247:
    .ascii    "labeldef"
    .byte     0
L7246:
    .ascii    "label"
    .byte     0
L7245:
    .ascii    "initdswx"
    .byte     0
L7244:
    .ascii    "data"
    .byte     0
L7243:
    .ascii    "zstatic"
    .byte     0
L7242:
    .ascii    "istatic"
    .byte     0
L7241:
    .ascii    "endproc"
    .byte     0
L7240:
    .ascii    "tcproc"
    .byte     0
L7239:
    .ascii    "proc"
    .byte     0
L7238:
    .ascii    "endmx"
    .byte     0
L7237:
    .ascii    "resetmx"
    .byte     0
L7236:
    .ascii    "startmx"
    .byte     0
L7235:
    .ascii    "fnarrow"
    .byte     0
L7234:
    .ascii    "fwiden"
    .byte     0
L7233:
    .ascii    "widen"
    .byte     0
L7232:
    .ascii    "truncate"
    .byte     0
L7231:
    .ascii    "fix"
    .byte     0
L7230:
    .ascii    "float"
    .byte     0
L7229:
    .ascii    "typepun"
    .byte     0
L7228:
    .ascii    "toboolto"
    .byte     0
L7227:
    .ascii    "notto"
    .byte     0
L7226:
    .ascii    "bitnotto"
    .byte     0
L7225:
    .ascii    "absto"
    .byte     0
L7224:
    .ascii    "negto"
    .byte     0
L7223:
    .ascii    "subpxto"
    .byte     0
L7222:
    .ascii    "addpxto"
    .byte     0
L7221:
    .ascii    "maxto"
    .byte     0
L7220:
    .ascii    "minto"
    .byte     0
L7219:
    .ascii    "shrto"
    .byte     0
L7218:
    .ascii    "shlto"
    .byte     0
L7217:
    .ascii    "bitxorto"
    .byte     0
L7216:
    .ascii    "bitorto"
    .byte     0
L7215:
    .ascii    "bitandto"
    .byte     0
L7214:
    .ascii    "iremto"
    .byte     0
L7213:
    .ascii    "idivto"
    .byte     0
L7212:
    .ascii    "divto"
    .byte     0
L7211:
    .ascii    "multo"
    .byte     0
L7210:
    .ascii    "subto"
    .byte     0
L7209:
    .ascii    "addto"
    .byte     0
L7208:
    .ascii    "loaddecr"
    .byte     0
L7207:
    .ascii    "loadincr"
    .byte     0
L7206:
    .ascii    "decrload"
    .byte     0
L7205:
    .ascii    "incrload"
    .byte     0
L7204:
    .ascii    "decrto"
    .byte     0
L7203:
    .ascii    "incrto"
    .byte     0
L7202:
    .ascii    "fmod"
    .byte     0
L7201:
    .ascii    "power"
    .byte     0
L7200:
    .ascii    "atan2"
    .byte     0
L7199:
    .ascii    "sign"
    .byte     0
L7198:
    .ascii    "ceil"
    .byte     0
L7197:
    .ascii    "floor"
    .byte     0
L7196:
    .ascii    "round"
    .byte     0
L7195:
    .ascii    "exp"
    .byte     0
L7194:
    .ascii    "log10"
    .byte     0
L7193:
    .ascii    "log"
    .byte     0
L7192:
    .ascii    "atan"
    .byte     0
L7191:
    .ascii    "acos"
    .byte     0
L7190:
    .ascii    "asin"
    .byte     0
L7189:
    .ascii    "tan"
    .byte     0
L7188:
    .ascii    "cos"
    .byte     0
L7187:
    .ascii    "sin"
    .byte     0
L7186:
    .ascii    "sqrt"
    .byte     0
L7185:
    .ascii    "sqr"
    .byte     0
L7184:
    .ascii    "toboolf"
    .byte     0
L7183:
    .ascii    "toboolt"
    .byte     0
L7182:
    .ascii    "not"
    .byte     0
L7181:
    .ascii    "bitnot"
    .byte     0
L7180:
    .ascii    "abs"
    .byte     0
L7179:
    .ascii    "neg"
    .byte     0
L7178:
    .ascii    "subp"
    .byte     0
L7177:
    .ascii    "subpx"
    .byte     0
L7176:
    .ascii    "addpx"
    .byte     0
L7175:
    .ascii    "max"
    .byte     0
L7174:
    .ascii    "min"
    .byte     0
L7173:
    .ascii    "shr"
    .byte     0
L7172:
    .ascii    "shl"
    .byte     0
L7171:
    .ascii    "bitxor"
    .byte     0
L7170:
    .ascii    "bitor"
    .byte     0
L7169:
    .ascii    "bitand"
    .byte     0
L7168:
    .ascii    "idivrem"
    .byte     0
L7167:
    .ascii    "irem"
    .byte     0
L7166:
    .ascii    "idiv"
    .byte     0
L7165:
    .ascii    "div"
    .byte     0
L7164:
    .ascii    "mul"
    .byte     0
L7163:
    .ascii    "sub"
    .byte     0
L7162:
    .ascii    "add"
    .byte     0
L7161:
    .ascii    "assem"
    .byte     0
L7160:
    .ascii    "clear"
    .byte     0
L7159:
    .ascii    "endsw"
    .byte     0
L7158:
    .ascii    "swlabel"
    .byte     0
L7157:
    .ascii    "switchu"
    .byte     0
L7156:
    .ascii    "switch"
    .byte     0
L7155:
    .ascii    "iswap"
    .byte     0
L7154:
    .ascii    "fordown"
    .byte     0
L7153:
    .ascii    "forup"
    .byte     0
L7152:
    .ascii    "to"
    .byte     0
L7151:
    .ascii    "stop"
    .byte     0
L7150:
    .ascii    "setcc"
    .byte     0
L7149:
    .ascii    "jumpretm"
    .byte     0
L7148:
    .ascii    "jumpret"
    .byte     0
L7147:
    .ascii    "jumpf"
    .byte     0
L7146:
    .ascii    "jumpt"
    .byte     0
L7145:
    .ascii    "jumpcc"
    .byte     0
L7144:
    .ascii    "ijump"
    .byte     0
L7143:
    .ascii    "jump"
    .byte     0
L7142:
    .ascii    "retfn"
    .byte     0
L7141:
    .ascii    "icallf"
    .byte     0
L7140:
    .ascii    "callf"
    .byte     0
L7139:
    .ascii    "retproc"
    .byte     0
L7138:
    .ascii    "icallp"
    .byte     0
L7137:
    .ascii    "callp"
    .byte     0
L7136:
    .ascii    "storebf"
    .byte     0
L7135:
    .ascii    "storebit"
    .byte     0
L7134:
    .ascii    "loadbf"
    .byte     0
L7133:
    .ascii    "loadbit"
    .byte     0
L7132:
    .ascii    "type"
    .byte     0
L7131:
    .ascii    "opnd"
    .byte     0
L7130:
    .ascii    "unload"
    .byte     0
L7129:
    .ascii    "swapstk"
    .byte     0
L7128:
    .ascii    "double"
    .byte     0
L7127:
    .ascii    "dupl"
    .byte     0
L7126:
    .ascii    "storem"
    .byte     0
L7125:
    .ascii    "istorex"
    .byte     0
L7124:
    .ascii    "istore"
    .byte     0
L7123:
    .ascii    "store"
    .byte     0
L7122:
    .ascii    "iloadx"
    .byte     0
L7121:
    .ascii    "iload"
    .byte     0
L7120:
    .ascii    "load"
    .byte     0
L7119:
    .ascii    "nop"
    .byte     0
L7118:
    .ascii    "any_opnd"
    .byte     0
L7117:
    .ascii    "data_opnd"
    .byte     0
L7116:
    .ascii    "realimm32_opnd"
    .byte     0
L7115:
    .ascii    "realimm_opnd"
    .byte     0
L7114:
    .ascii    "assem_opnd"
    .byte     0
L7113:
    .ascii    "strimm_opnd"
    .byte     0
L7112:
    .ascii    "string_opnd"
    .byte     0
L7111:
    .ascii    "r32_opnd"
    .byte     0
L7110:
    .ascii    "real_opnd"
    .byte     0
L7109:
    .ascii    "int_opnd"
    .byte     0
L7108:
    .ascii    "label_opnd"
    .byte     0
L7107:
    .ascii    "memaddr_opnd"
    .byte     0
L7106:
    .ascii    "mem_opnd"
    .byte     0
L7105:
    .ascii    "no_opnd"
    .byte     0
L7104:
    .ascii    "$last"
    .byte     0
L7103:
    .ascii    "vec"
    .byte     0
L7102:
    .ascii    "mem"
    .byte     0
L7101:
    .ascii    "i64"
    .byte     0
L7100:
    .ascii    "i32"
    .byte     0
L7099:
    .ascii    "i16"
    .byte     0
L7098:
    .ascii    "i8"
    .byte     0
L7097:
    .ascii    "u64"
    .byte     0
L7096:
    .ascii    "u32"
    .byte     0
L7095:
    .ascii    "u16"
    .byte     0
L7094:
    .ascii    "u8"
    .byte     0
L7093:
    .ascii    "r64"
    .byte     0
L7092:
    .ascii    "r32"
    .byte     0
L7091:
    .ascii    "void"
    .byte     0
L7090:
    .ascii    "pm_extra"
    .byte     0
L7089:
    .ascii    "pm_colon"
    .byte     0
L7088:
    .ascii    "pm_libfile"
    .byte     0
L7087:
    .ascii    "pm_sourcefile"
    .byte     0
L7086:
    .ascii    "pm_option"
    .byte     0
L7085:
    .ascii    "pm_end"
    .byte     0



