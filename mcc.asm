# GAS VERSION
    .intel_syntax prefix

    .global msys.$cmdskip
    .global main

    .text
#MCL1
    .bss
    .align    8
msys.fmtparam:
    .space    8
    .align    8
msys.$cmdskip:
$cmdskip:
    .space    8
    .data
    .align    8
msys.needgap:
    .quad     0
    .align    8
msys.outdev:
    .quad     1
    .align    8
msys.outchan:
    .quad     0
    .align    8
msys.fmtstr:
    .quad     0
    .bss
    .align    8
msys.outchan_stack:
    .space    80
    .align    8
msys.outdev_stack:
    .space    80
    .align    8
msys.fmtstr_stack:
    .space    80
msys.needgap_stack:
    .space    10
    .align    8
msys.ptr_stack:
    .space    80
    .data
    .align    8
msys.niostack:
    .quad     0
msys.digits:
    .quad     0x3736353433323130
    .quad     0x4645444342413938
    .byte     0
#ENDDATA
    .align    8
msys.defaultfmt:
    .byte     0
    .byte     0
    .byte     10
    .byte     0
    .byte     32
    .byte     102
    .byte     0
    .byte     0
    .byte     0
    .byte     82
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .bss
    .align    8
msys.rd_buffer:
    .space    8
    .align    8
msys.rd_length:
    .space    8
    .align    8
msys.rd_pos:
    .space    8
    .align    8
msys.rd_lastpos:
    .space    8
    .align    8
msys.termchar:
    .space    8
    .align    8
msys.itemerror:
    .space    8
msys.printbuffer:
    .space    4096
    .align    8
msys.printptr:
    .space    8
    .align    8
msys.printlen:
    .space    8
    .align    8
msys.nsysparams:
    .space    8
    .align    8
msys.ncmdparams:
    .space    8
    .align    8
msys.nenvstrings:
    .space    8
    .align    8
msys.sysparams:
    .space    1024
    .align    8
msys.cmdparams:
    .space    8
    .align    8
msys.envstrings:
    .space    8
msys.start.startupinfo:
    .space    128
    .align    8
msys.getfmt.fmt:
    .space    16
msys.strint.str:
    .space    100
msys.strword.str:
    .space    100
msys.strreal.str:
    .space    320
    .align    8
mlib.allocupper:
    .space    2408
    .align    8
mlib.alloccode:
    .space    8
    .align    8
mlib.allocbytes:
    .space    8
    .data
    .align    8
mlib.fdebug:
    .quad     0
    .bss
    .align    8
mlib.rfsize:
    .space    8
    .align    8
mlib.maxmemory:
    .space    8
    .align    8
mlib.maxalloccode:
    .space    8
    .data
mlib.pcm_setup:
    .byte     0
    .align    8
mlib.show:
    .quad     0
    .align    8
mlib.memtotal:
    .quad     0
    .align    8
mlib.smallmemtotal:
    .quad     0
    .align    8
mlib.smallmemobjs:
    .quad     0
    .align    8
mlib.maxmemtotal:
    .quad     0
    .bss
    .align    8
mlib.memalloctable:
    .space    24
    .align    4
mlib.memallocsize:
    .space    12
    .align    8
mlib.pcheapstart:
    .space    8
    .align    8
mlib.pcheapend:
    .space    8
    .align    8
mlib.pcheapptr:
    .space    8
mlib.sizeindextable:
    .space    2049
    .align    8
mlib.freelist:
    .space    72
    .data
    .align    8
mlib.pmnames:
    .quad     L7048
    .quad     L7049
    .quad     L7050
    .quad     L7051
    .quad     L7052
    .quad     L7053
    .align    8
mlib.seed:
    .quad     0x2989881111111272
    .quad     0x1673267373358264
    .bss
    .align    8
mlib.pcm_newblock.totalheapsize:
    .space    8
    .data
    .align    4
mlib.pcm_round.allocbytes:
    .long     0
    .long     16
    .long     32
    .long     64
    .long     128
    .long     256
    .long     512
    .long     1024
    .long     2048
    .bss
mlib.changeext.newfile:
    .space    260
mlib.extractpath.str:
    .space    260
mlib.extractbasefile.str:
    .space    100
    .data
    .align    8
mlib.nextcmdparamnew.infile:
    .quad     0
    .align    8
mlib.nextcmdparamnew.filestart:
    .quad     0
    .align    8
mlib.nextcmdparamnew.fileptr:
    .quad     0
mlib.nextcmdparamnew.colonseen:
    .byte     0
    .bss
mlib.nextcmdparamnew.str:
    .space    300
mlib.readnextfileitem.str:
    .space    256
mlib.padstr.str:
    .space    256
mlib.chr.str:
    .space    8
    .align    8
mwindows.hconsole:
    .space    8
    .align    8
mwindows.hconsolein:
    .space    8
    .align    4
mwindows.lastkey:
    .space    20
    .align    4
mwindows.pendkey:
    .space    20
    .align    8
mwindows.keypending:
    .space    8
    .align    8
mwindows.hpfreq:
    .space    8
    .data
    .align    8
mwindows.wndproc_callbackfn:
    .quad     0
    .align    8
mwindows.init_flag:
    .quad     0
    .bss
mwindows.os_gxregisterclass.registered:
    .space    1
    .data
    .align    8
mwindows.mainwndproc.count:
    .quad     0
    .bss
mwindows.os_gethostname.name:
    .space    300
    .align    8
mwindows.os_gethostname.n:
    .space    8
    .align    8
mwindows.os_peek.lastticks:
    .space    8
    .data
pepcl.pc_userunpcl:
    .byte     0
pepcl.asmonly:
    .byte     1
    .bss
    .align    8
pc_api.pclseqno:
    .space    8
    .align    8
pc_api.stseqno:
    .space    8
    .align    8
pc_api.pcstart:
    .space    8
    .align    8
pc_api.pccurr:
    .space    8
    .align    8
pc_api.pcend:
    .space    8
    .align    8
pc_api.pcalloc:
    .space    8
pc_api.pcfixed:
    .space    1
    .align    8
pc_api.pcseqno:
    .space    8
    .align    8
pc_api.pcneedfntable:
    .space    8
    .data
    .align    8
pc_api.initpcalloc:
    .quad     0x10000
    .bss
    .align    8
pc_api.longstring:
    .space    8
    .align    8
pc_api.longstringlen:
    .space    8
    .align    8
pc_api.mlabelno:
    .space    8
pc_api.phighmem:
    .space    1
pc_api.pfullsys:
    .space    1
pc_api.fpshortnames:
    .space    1
    .align    8
pc_api.idomcl_assem:
    .space    8
    .align    8
pc_api.icheckasmlabel:
    .space    8
    .align    8
pc_api.igethostfn:
    .space    8
pc_api.strpmode.str:
    .space    32
pc_api.getfullname.str:
    .space    256
pc_api.addstr.str:
    .space    256
    .align    8
pc_decls.pinfo:
    .space    8
    .align    8
pc_decls.bspill:
    .space    8
    .align    8
pc_decls.bxspill:
    .space    8
pc_decls.r10used:
    .space    1
pc_decls.r11used:
    .space    1
pc_decls.localshadow:
    .space    1
    .align    8
pc_decls.mmpos:
    .space    8
    .align    8
pc_decls.psymboltable:
    .space    8
    .align    8
pc_decls.psymboltablex:
    .space    8
    .align    8
pc_decls.currprog:
    .space    8
    .align    8
pc_decls.currfunc:
    .space    8
    .align    8
pc_decls.blockretname:
    .space    8
    .align    8
pc_decls.entryproc:
    .space    8
    .align    8
pc_decls.sbuffer:
    .space    16
    .data
    .align    8
pc_decls.pdest:
    .quad     pc_decls.sbuffer
    .bss
    .align    8
pc_decls.plibfiles:
    .space    400
    .align    8
pc_decls.plibinst:
    .space    400
    .align    8
pc_decls.nplibfiles:
    .space    8
    .align    8
pc_decls.igetmsourceinfo:
    .space    8
pc_decls.pcldone:
    .space    1
pc_decls.mcldone:
    .space    1
pc_decls.ssdone:
    .space    1
pc_decls.objdone:
    .space    1
pc_decls.exedone:
    .space    1
pc_decls.pverbose:
    .space    1
    .align    8
pc_decls.pcmdskip:
    .space    8
    .data
    .align    8
pc_decls.assemtype:
    .quad     0x4141
    .bss
    .align    8
pc_decls.ppseqno:
    .space    8
    .data
pc_decls.fpeephole:
    .byte     1
pc_decls.fregoptim:
    .byte     1
    .bss
    .align    8
pc_decls.pcltime:
    .space    8
    .align    8
pc_decls.mcltime:
    .space    8
    .align    8
pc_decls.sstime:
    .space    8
    .align    8
pc_decls.objtime:
    .space    8
    .align    8
pc_decls.exetime:
    .space    8
    .align    8
pc_decls.$pmodulename:
    .space    8
    .align    8
pc_decls.pclflags:
    .space    1144
    .align    8
pc_decls.pstartclock:
    .space    8
    .align    8
pc_decls.npcl:
    .space    8
    .align    8
pc_decls.npst:
    .space    8
    .align    8
pc_diags.sbuffer:
    .space    16
    .data
    .align    8
pc_diags.dest:
    .quad     pc_diags.sbuffer
    .bss
    .align    8
pc_diags.destlinestart:
    .space    8
pc_diags.stropnd.str:
    .space    512
    .align    8
pc_diags.stropnd.longstring:
    .space    8
    .data
    .align    8
pc_tables.pstdnames:
    .quad     L7054
    .quad     L7055
    .quad     L7056
    .quad     L7057
    .quad     L7058
    .quad     L7059
    .quad     L7060
    .quad     L7061
    .quad     L7062
    .quad     L7063
    .quad     L7064
    .quad     L7065
    .quad     L7066
    .quad     L7067
pc_tables.psize:
    .quad     0x108040201080400
    .byte     2
    .byte     4
    .byte     8
    .byte     0
    .byte     0
    .byte     0
#ENDDATA
pc_tables.psigned:
    .quad     0x100000000000000
    .byte     1
    .byte     1
    .byte     1
    .byte     0
    .byte     0
    .byte     0
#ENDDATA
pc_tables.pint:
    .quad     0x101010101000000
    .byte     1
    .byte     1
    .byte     1
    .byte     0
    .byte     0
    .byte     0
#ENDDATA
pc_tables.pfloat:
    .quad     0x10100
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
#ENDDATA
pc_tables.pmin:
    .quad     0x906050505020100
    .byte     9
    .byte     9
    .byte     10
    .byte     11
    .byte     12
    .byte     0
#ENDDATA
pc_tables.xxpiwrb:
    .quad     0xA06060606020100
    .byte     10
    .byte     10
    .byte     10
    .byte     0
    .byte     0
    .byte     0
#ENDDATA
    .align    8
pc_tables.opndnames:
    .quad     L7068
    .quad     L7069
    .quad     L7070
    .quad     L7071
    .quad     L7072
    .quad     L7073
    .quad     L7074
    .quad     L7075
    .quad     L7076
    .quad     L7077
    .quad     L7078
    .quad     L7079
    .quad     L7080
    .quad     L7081
    .align    8
pc_tables.pclnames:
    .quad     L7082
    .quad     L7083
    .quad     L7084
    .quad     L7085
    .quad     L7086
    .quad     L7087
    .quad     L7088
    .quad     L7089
    .quad     L7090
    .quad     L7091
    .quad     L7092
    .quad     L7093
    .quad     L7094
    .quad     L7095
    .quad     L7096
    .quad     L7097
    .quad     L7098
    .quad     L7099
    .quad     L7100
    .quad     L7101
    .quad     L7102
    .quad     L7103
    .quad     L7104
    .quad     L7105
    .quad     L7106
    .quad     L7107
    .quad     L7108
    .quad     L7109
    .quad     L7110
    .quad     L7111
    .quad     L7112
    .quad     L7113
    .quad     L7114
    .quad     L7115
    .quad     L7116
    .quad     L7117
    .quad     L7118
    .quad     L7119
    .quad     L7120
    .quad     L7121
    .quad     L7122
    .quad     L7123
    .quad     L7124
    .quad     L7125
    .quad     L7126
    .quad     L7127
    .quad     L7128
    .quad     L7129
    .quad     L7130
    .quad     L7131
    .quad     L7132
    .quad     L7133
    .quad     L7134
    .quad     L7135
    .quad     L7136
    .quad     L7137
    .quad     L7138
    .quad     L7139
    .quad     L7140
    .quad     L7141
    .quad     L7142
    .quad     L7143
    .quad     L7144
    .quad     L7145
    .quad     L7146
    .quad     L7147
    .quad     L7148
    .quad     L7149
    .quad     L7150
    .quad     L7151
    .quad     L7152
    .quad     L7153
    .quad     L7154
    .quad     L7155
    .quad     L7156
    .quad     L7157
    .quad     L7158
    .quad     L7159
    .quad     L7160
    .quad     L7161
    .quad     L7162
    .quad     L7163
    .quad     L7164
    .quad     L7165
    .quad     L7166
    .quad     L7167
    .quad     L7168
    .quad     L7169
    .quad     L7170
    .quad     L7171
    .quad     L7172
    .quad     L7173
    .quad     L7174
    .quad     L7175
    .quad     L7176
    .quad     L7177
    .quad     L7178
    .quad     L7179
    .quad     L7180
    .quad     L7181
    .quad     L7182
    .quad     L7183
    .quad     L7184
    .quad     L7185
    .quad     L7186
    .quad     L7187
    .quad     L7188
    .quad     L7189
    .quad     L7190
    .quad     L7191
    .quad     L7192
    .quad     L7193
    .quad     L7194
    .quad     L7195
    .quad     L7196
    .quad     L7197
    .quad     L7198
    .quad     L7199
    .quad     L7200
    .quad     L7201
    .quad     L7202
    .quad     L7203
    .quad     L7204
    .quad     L7205
    .quad     L7206
    .quad     L7207
    .quad     L7208
    .quad     L7209
    .quad     L7210
    .quad     L7211
    .quad     L7212
    .quad     L7213
    .quad     L7214
    .quad     L7215
    .quad     L7216
    .quad     L7217
    .quad     L7218
    .quad     L7219
    .quad     L7220
    .quad     L7221
    .quad     L7222
    .quad     L7223
    .quad     L7224
pc_tables.pclhastype:
    .quad     0x101010101010100
    .quad     0x101010101000000
    .quad     0x101010000000101
    .quad     0x101010101010100
    .quad     0x10101010100
    .quad     0x101010101000100
    .quad     0x101010101010101
    .quad     0x101010101010101
    .quad     0x101010101010202
    .quad     0x101010101010101
    .quad     0x101010101010101
    .quad     0x101010101010101
    .quad     0x101010101010101
    .quad     0x202010101010101
    .quad     0x101000202020202
    .quad     0x10101000000
    .quad     0
    .byte     0
    .byte     1
    .byte     1
    .byte     1
    .byte     0
    .byte     0
    .byte     0
#ENDDATA
pc_tables.pclextra:
    .quad     0x2000002000100
    .quad     0x20000
    .quad     0x2020002020000
    .quad     0x10000
    .quad     0x2020001010000
    .quad     0
    .quad     0
    .quad     0x1020200
    .quad     0
    .quad     0
    .quad     0x101010100000000
    .quad     0x101
    .quad     0x100000000000000
    .quad     1
    .quad     0
    .quad     0
    .quad     0x201000000
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
#ENDDATA
pc_tables.pclhasopnd:
    .quad     0x100000D00
    .quad     0xD00000000
    .quad     0x20000020000
    .quad     0x3030303030003
    .quad     0x303030003030300
    .quad     0xD0000
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .quad     0x3000D0101000101
    .quad     2
    .byte     0
    .byte     1
    .byte     1
    .byte     0
    .byte     0
    .byte     7
    .byte     1
#ENDDATA
pc_tables.pclargs:
    .quad     0
    .quad     0x202000000000000
    .quad     0x9090009090202
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .quad     0x101010100000000
    .quad     0x101010101010101
    .quad     0x2020201
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
#ENDDATA
    .align    8
pc_tables.ccnames:
    .quad     L7225
    .quad     L7226
    .quad     L7227
    .quad     L7228
    .quad     L7229
    .quad     L7230
    .quad     L7231
    .align    8
pc_tables.idnames:
    .quad     L7232
    .quad     L7233
    .quad     L7234
    .quad     L7235
    .quad     L7236
    .quad     L7237
    .quad     L7238
    .quad     L7239
    .quad     L7240
    .quad     L7241
    .bss
    .align    8
mc_genmcl.debug:
    .space    8
    .align    8
mc_genmcl.frameoffset:
    .space    8
    .align    8
mc_genmcl.paramoffset:
    .space    8
    .align    8
mc_genmcl.framebytes:
    .space    8
    .align    8
mc_genmcl.px_handlertable:
    .space    1144
    .data
mc_genmcl.scondcodes:
    .byte     4
    .byte     5
    .byte     12
    .byte     14
    .byte     13
    .byte     15
#ENDDATA
mc_genmcl.ucondcodes:
    .byte     4
    .byte     5
    .byte     2
    .byte     6
    .byte     3
    .byte     7
#ENDDATA
mc_genmcl.inithandlers.initdone:
    .byte     0
mc_genmcl.inithandlers.dupltable:
    .ascii    "MX"
#ENDDATA
    .ascii    "A@"
#ENDDATA
    .byte     21
    .byte     18
#ENDDATA
    .byte     19
    .byte     18
#ENDDATA
    .byte     22
    .byte     18
#ENDDATA
    .ascii    "wv"
#ENDDATA
    .ascii    "yx"
#ENDDATA
    .ascii    "^/"
#ENDDATA
    .ascii    "_0"
#ENDDATA
    .bss
    .align    8
mc_auxmcl.nnn:
    .space    8
    .align    8
mc_auxmcl.nauxprocs:
    .space    8
    .align    8
mc_auxmcl.nauxnoframe:
    .space    8
    .align    8
mc_auxmcl.mclframesetup:
    .space    8
    .align    8
mc_libmcl.mclseqno:
    .space    8
    .align    8
mc_libmcl.nmclopnd:
    .space    8
    .align    8
mc_libmcl.smallinttable:
    .space    96
    .align    8
mc_libmcl.nametable:
    .space    160
    .align    8
mc_libmcl.nnametable:
    .space    8
    .align    8
mc_libmcl.mgenextname.table:
    .space    160
    .align    8
mc_libmcl.mgenextname.ntable:
    .space    8
mc_stackmcl.stropndstack.str:
    .space    512
    .align    8
mc_genss_dummy.psstime:
    .space    8
    .data
    .align    8
mc_decls.valtypenames:
    .quad     L7242
    .quad     L7243
    .quad     L7244
    .quad     L7245
    .quad     L7246
    .quad     L7247
    .quad     L7248
    .quad     L7249
    .quad     L7250
    .align    8
mc_decls.mclnames:
    .quad     L7251
    .quad     L7252
    .quad     L7253
    .quad     L7254
    .quad     L7255
    .quad     L7256
    .quad     L7257
    .quad     L7258
    .quad     L7259
    .quad     L7260
    .quad     L7261
    .quad     L7262
    .quad     L7263
    .quad     L7264
    .quad     L7265
    .quad     L7266
    .quad     L7267
    .quad     L7268
    .quad     L7269
    .quad     L7270
    .quad     L7271
    .quad     L7272
    .quad     L7273
    .quad     L7274
    .quad     L7275
    .quad     L7276
    .quad     L7277
    .quad     L7278
    .quad     L7279
    .quad     L7280
    .quad     L7281
    .quad     L7282
    .quad     L7283
    .quad     L7284
    .quad     L7285
    .quad     L7286
    .quad     L7287
    .quad     L7288
    .quad     L7289
    .quad     L7290
    .quad     L7291
    .quad     L7292
    .quad     L7293
    .quad     L7294
    .quad     L7295
    .quad     L7296
    .quad     L7297
    .quad     L7298
    .quad     L7299
    .quad     L7300
    .quad     L7301
    .quad     L7302
    .quad     L7303
    .quad     L7304
    .quad     L7305
    .quad     L7306
    .quad     L7307
    .quad     L7308
    .quad     L7309
    .quad     L7310
    .quad     L7311
    .quad     L7312
    .quad     L7313
    .quad     L7314
    .quad     L7315
    .quad     L7316
    .quad     L7317
    .quad     L7318
    .quad     L7319
    .quad     L7320
    .quad     L7321
    .quad     L7322
    .quad     L7323
    .quad     L7324
    .quad     L7325
    .quad     L7326
    .quad     L7327
    .quad     L7328
    .quad     L7329
    .quad     L7330
    .quad     L7331
    .quad     L7332
    .quad     L7333
    .quad     L7334
    .quad     L7335
    .quad     L7336
    .quad     L7337
    .quad     L7338
    .quad     L7339
    .quad     L7340
    .quad     L7341
    .quad     L7342
    .quad     L7343
    .quad     L7344
    .quad     L7345
    .quad     L7346
    .quad     L7347
    .quad     L7348
    .quad     L7349
    .quad     L7350
    .quad     L7351
    .quad     L7352
    .quad     L7353
    .quad     L7354
    .quad     L7355
    .quad     L7356
    .quad     L7357
    .quad     L7358
    .quad     L7359
    .quad     L7360
    .quad     L7361
    .quad     L7362
    .quad     L7363
    .quad     L7364
    .quad     L7365
    .quad     L7366
    .quad     L7367
    .quad     L7368
    .quad     L7369
    .quad     L7370
    .quad     L7371
    .quad     L7372
    .quad     L7373
    .quad     L7374
    .quad     L7375
    .quad     L7376
    .quad     L7377
    .quad     L7378
    .quad     L7379
    .quad     L7380
    .quad     L7381
    .quad     L7382
    .quad     L7383
    .quad     L7384
    .quad     L7385
    .quad     L7386
    .quad     L7387
    .quad     L7388
    .quad     L7389
    .quad     L7390
    .quad     L7391
    .quad     L7392
    .quad     L7393
    .quad     L7394
    .quad     L7395
    .quad     L7396
    .quad     L7397
    .quad     L7398
    .quad     L7399
    .quad     L7400
    .quad     L7401
    .quad     L7402
mc_decls.mclnopnds:
    .quad     0
    .quad     0x202020101020001
    .quad     0x100000102020202
    .quad     0x102020202020101
    .quad     0x202020101030201
    .quad     0x202020202020202
    .quad     0x101010102
    .quad     0x202020202020100
    .quad     0x202020202020202
    .quad     0x202020202020202
    .quad     0x202020202020202
    .quad     0x101010303020202
    .quad     0x10101
    .quad     0x200000000000000
    .quad     0x101010101020202
    .quad     0x101010101000000
    .quad     0x10101010100
    .quad     0x102000000
    .quad     0
#ENDDATA
mc_decls.mclcodes:
    .quad     0
    .quad     0x9000
    .quad     0xC9C3E800000000
    .quad     0x5030205000000E9
    .quad     0x601040607000004
    .quad     0x201000507040700
    .quad     0x100020303
    .quad     0x5151ACA4BDBC0000
    .quad     0x5E5E59595C5C5858
    .quad     0xEF545457572E2F00
    .quad     0xDB
    .quad     0x302006263F36600
    .quad     0xFAF9C9E9C1030200
    .quad     0x5DE0E1F3F2FBFFFE
    .quad     0x5F5D5F
    .quad     0x804020100000000
    .quad     0xE3E3E2E1E0D7
    .quad     0xE8EE000000310000
    .quad     0xF4F400EDECEAE9EB
#ENDDATA
    .align    8
mc_decls.regnames:
    .quad     L7403
    .quad     L7404
    .quad     L7405
    .quad     L7406
    .quad     L7407
    .quad     L7408
    .quad     L7409
    .quad     L7410
    .quad     L7411
    .quad     L7412
    .quad     L7413
    .quad     L7414
    .quad     L7415
    .quad     L7416
    .quad     L7417
    .quad     L7418
    .quad     L7419
    .quad     L7420
    .quad     L7421
    .quad     L7422
    .quad     L7423
mc_decls.regcodes:
    .quad     0xC0603070B0A0000
    .quad     0x5090802010F0E0D
    .byte     4
    .byte     4
    .byte     7
    .byte     5
    .byte     6
#ENDDATA
    .align    8
mc_decls.condnames:
    .quad     L7424
    .quad     L7425
    .quad     L7426
    .quad     L7427
    .quad     L7428
    .quad     L7429
    .quad     L7430
    .quad     L7431
    .quad     L7432
    .quad     L7433
    .quad     L7434
    .quad     L7435
    .quad     L7436
    .quad     L7437
    .quad     L7438
    .quad     L7439
    .quad     L7440
    .quad     L7441
    .quad     L7442
    .quad     L7443
    .align    8
mc_decls.asmcondnames:
    .quad     L7444
    .quad     L7445
    .quad     L7446
    .quad     L7447
    .quad     L7448
    .quad     L7449
    .quad     L7450
    .quad     L7451
    .quad     L7452
    .quad     L7453
    .quad     L7454
    .quad     L7455
    .quad     L7456
    .quad     L7457
    .quad     L7458
    .quad     L7459
    .quad     L7460
    .quad     L7461
    .quad     L7462
    .quad     L7463
    .align    8
mc_decls.asmrevcond:
    .quad     1
    .quad     0
    .quad     3
    .quad     2
    .quad     5
    .quad     4
    .quad     7
    .quad     6
    .quad     9
    .quad     8
    .quad     0xB
    .quad     0xA
    .quad     0xD
    .quad     0xC
    .quad     0xF
    .quad     0xE
    .quad     0x11
    .quad     0x10
    .quad     0x13
    .quad     0x12
    .align    8
mc_decls.dregnames:
    .quad     L7464
    .quad     L7465
    .quad     L7466
    .quad     L7467
    .quad     L7468
    .quad     L7469
    .quad     L7470
    .quad     L7471
    .quad     L7472
    .quad     L7473
    .quad     L7474
    .quad     L7475
    .quad     L7476
    .quad     L7477
    .quad     L7478
    .quad     L7479
    .quad     L7480
    .quad     L7481
    .quad     L7482
    .quad     L7483
    .quad     L7484
    .quad     L7485
    .quad     L7486
    .quad     L7487
    .quad     L7488
    .quad     L7489
    .quad     L7490
    .quad     L7491
    .quad     L7492
    .quad     L7493
    .quad     L7494
    .quad     L7495
    .quad     L7496
    .quad     L7497
    .quad     L7498
    .quad     L7499
    .quad     L7500
    .quad     L7501
    .quad     L7502
    .quad     L7503
    .quad     L7504
    .quad     L7505
    .quad     L7506
    .quad     L7507
    .quad     L7508
    .quad     L7509
    .quad     L7510
    .quad     L7511
    .quad     L7512
    .quad     L7513
    .quad     L7514
    .quad     L7515
    .quad     L7516
    .quad     L7517
    .quad     L7518
    .quad     L7519
    .quad     L7520
    .quad     L7521
    .quad     L7522
    .quad     L7523
    .quad     L7524
    .quad     L7525
    .quad     L7526
    .quad     L7527
    .quad     L7528
    .quad     L7529
    .quad     L7530
    .quad     L7531
    .quad     L7532
    .quad     L7533
    .quad     L7534
    .quad     L7535
    .quad     L7536
    .quad     L7537
    .quad     L7538
    .quad     L7539
    .quad     L7540
    .quad     L7541
    .quad     L7542
    .quad     L7543
    .quad     L7544
    .quad     L7545
    .quad     L7546
    .quad     L7547
    .quad     L7548
    .quad     L7549
    .quad     L7550
    .quad     L7551
    .quad     L7552
    .quad     L7553
    .quad     L7554
    .quad     L7555
    .quad     L7556
    .quad     L7557
    .quad     L7558
    .quad     L7559
    .quad     L7560
    .quad     L7561
    .quad     L7562
    .quad     L7563
    .quad     L7564
    .quad     L7565
    .quad     L7566
    .quad     L7567
    .quad     L7568
    .quad     L7569
    .quad     L7570
    .quad     L7571
    .quad     L7572
    .quad     L7573
    .quad     L7574
    .quad     L7575
    .quad     L7576
    .quad     L7577
    .quad     L7578
    .quad     L7579
    .quad     L7580
    .quad     L7581
    .quad     L7582
    .quad     L7583
    .quad     L7584
    .quad     L7585
    .quad     L7586
    .quad     L7587
    .quad     L7588
    .quad     L7589
    .quad     L7590
    .quad     L7591
    .quad     L7592
    .quad     L7593
    .quad     L7594
    .quad     L7595
    .quad     L7596
    .quad     L7597
    .quad     L7598
    .quad     L7599
    .quad     L7600
mc_decls.regsizes:
    .quad     0x808080808080808
    .quad     0x808080808080808
    .quad     0x404040404040404
    .quad     0x404040404040404
    .quad     0x202020202020202
    .quad     0x202020202020202
    .quad     0x101010101010101
    .quad     0x101010101010101
    .quad     0x808080001010101
    .quad     0x808080808080808
    .quad     0x404040808080808
    .quad     0x404040404040404
    .quad     0x202020404040404
    .quad     0x202020202020202
    .quad     0x101010202020202
    .quad     0x101010101010101
    .quad     0x101010101010101
    .byte     1
#ENDDATA
mc_decls.regindices:
    .quad     0x807060504030201
    .quad     0x100F0E0D0C0B0A09
    .quad     0x807060504030201
    .quad     0x100F0E0D0C0B0A09
    .quad     0x807060504030201
    .quad     0x100F0E0D0C0B0A09
    .quad     0x807060504030201
    .quad     0x100F0E0D0C0B0A09
    .quad     0xB05010014131211
    .quad     0x20E0D100F04060C
    .quad     0xB05010A09080703
    .quad     0x20E0D100F04060C
    .quad     0xB05010A09080703
    .quad     0x20E0D100F04060C
    .quad     0xB05010A09080703
    .quad     0xF0406141312110C
    .quad     0x9080703020E0D10
    .byte     10
#ENDDATA
    .align    8
mc_decls.xmmregnames:
    .quad     L7601
    .quad     L7602
    .quad     L7603
    .quad     L7604
    .quad     L7605
    .quad     L7606
    .quad     L7607
    .quad     L7608
    .quad     L7609
    .quad     L7610
    .quad     L7611
    .quad     L7612
    .quad     L7613
    .quad     L7614
    .quad     L7615
    .quad     L7616
    .align    8
mc_decls.fregnames:
    .quad     L7617
    .quad     L7618
    .quad     L7619
    .quad     L7620
    .quad     L7621
    .quad     L7622
    .quad     L7623
    .quad     L7624
    .align    8
mc_decls.mregnames:
    .quad     L7625
    .quad     L7626
    .quad     L7627
    .quad     L7628
    .quad     L7629
    .quad     L7630
    .quad     L7631
    .quad     L7632
    .align    8
mc_decls.jmpccnames:
    .quad     L7633
    .quad     L7634
    .quad     L7635
    .quad     L7636
    .quad     L7637
    .quad     L7638
    .quad     L7639
    .quad     L7640
    .quad     L7641
    .quad     L7642
    .quad     L7643
    .quad     L7644
    .quad     L7645
    .quad     L7646
    .quad     L7647
    .quad     L7648
    .quad     L7649
    .quad     L7650
mc_decls.jmpcccodes:
    .quad     0x706050403020100
    .quad     0xF0E0D0C0B0A0908
    .byte     2
    .byte     3
#ENDDATA
    .align    8
mc_decls.setccnames:
    .quad     L7651
    .quad     L7652
    .quad     L7653
    .quad     L7654
    .quad     L7655
    .quad     L7656
    .quad     L7657
    .quad     L7658
    .quad     L7659
    .quad     L7660
    .quad     L7661
    .quad     L7662
    .quad     L7663
    .quad     L7664
    .quad     L7665
    .quad     L7666
mc_decls.setcccodes:
    .quad     0x706050403020100
    .quad     0xF0E0D0C0B0A0908
#ENDDATA
    .align    8
mc_decls.cmovccnames:
    .quad     L7667
    .quad     L7668
    .quad     L7669
    .quad     L7670
    .quad     L7671
    .quad     L7672
    .quad     L7673
    .quad     L7674
    .quad     L7675
    .quad     L7676
    .quad     L7677
    .quad     L7678
    .quad     L7679
    .quad     L7680
    .quad     L7681
    .quad     L7682
mc_decls.cmovcccodes:
    .quad     0x706050403020100
    .quad     0xF0E0D0C0B0A0908
#ENDDATA
    .align    8
mc_decls.segmentnames:
    .quad     L7683
    .quad     L7684
    .quad     L7685
    .quad     L7686
    .quad     L7687
    .quad     L7688
    .align    8
mc_decls.reftypenames:
    .quad     L7689
    .quad     L7690
    .quad     L7691
    .align    8
mc_decls.opndnames_ma:
    .quad     L7692
    .quad     L7693
    .quad     L7694
    .quad     L7695
    .quad     L7696
    .quad     L7697
    .bss
    .align    8
mc_decls.pclopnd:
    .space    400
mc_decls.pclreg:
    .space    50
mc_decls.pclmode:
    .space    50
mc_decls.pclcount:
    .space    50
mc_decls.pclloc:
    .space    50
mc_decls.pcltempflags:
    .space    50
    .align    8
mc_decls.pcltempopnds:
    .space    400
    .align    8
mc_decls.noperands:
    .space    8
    .align    8
mc_decls.mstackdepth:
    .space    8
    .data
    .align    8
mc_decls.locnames:
    .quad     L7698
    .quad     L7699
    .quad     L7700
    .quad     L7701
    .bss
mc_decls.workregs:
    .space    16
mc_decls.workxregs:
    .space    16
    .align    8
mc_decls.nworkregs:
    .space    8
    .align    8
mc_decls.nworkxregs:
    .space    8
    .align    8
mc_decls.nregvars:
    .space    8
    .align    8
mc_decls.nxregvars:
    .space    8
    .align    8
mc_decls.maxregvars:
    .space    8
    .align    8
mc_decls.maxxregvars:
    .space    8
    .align    8
mc_decls.xregmax:
    .space    8
mc_decls.regset:
    .space    16
mc_decls.xregset:
    .space    16
mc_decls.isregvar:
    .space    16
mc_decls.isxregvar:
    .space    16
mc_decls.usedregs:
    .space    16
mc_decls.usedxregs:
    .space    16
mc_decls.noxorclear:
    .space    1
    .data
    .align    8
mc_decls.xregnames:
    .quad     L7702
    .quad     L7703
    .quad     L7704
    .quad     L7705
    .quad     L7706
    .quad     L7707
    .quad     L7708
    .quad     L7709
    .quad     L7710
    .quad     L7711
    .quad     L7712
    .quad     L7713
    .quad     L7714
    .quad     L7715
    .quad     L7716
    .quad     L7717
    .quad     L7717
    .bss
mc_decls.callalign:
    .space    32
mc_decls.callblockret:
    .space    32
    .align    4
mc_decls.callblocksize:
    .space    128
    .align    4
mc_decls.callargsize:
    .space    512
    .align    8
mc_decls.ncalldepth:
    .space    8
    .align    8
mc_decls.lababs32:
    .space    8
    .align    8
mc_decls.lababs64:
    .space    8
    .align    8
mc_decls.labneg32:
    .space    8
    .align    8
mc_decls.labneg64:
    .space    8
    .align    8
mc_decls.labmask63:
    .space    8
    .align    8
mc_decls.laboffset64:
    .space    8
    .align    8
mc_decls.labzero:
    .space    8
    .data
    .align    8
mc_decls.kk0used:
    .quad     0
    .bss
    .align    8
mc_decls.mccode:
    .space    8
    .align    8
mc_decls.mccodex:
    .space    8
    .data
    .align    8
mc_decls.currsegment:
    .quad     0
    .bss
    .align    8
mc_decls.dstackopnd:
    .space    8
    .align    8
mc_decls.dframeopnd:
    .space    8
    .align    8
mc_decls.regtable:
    .space    1024
    .align    8
mc_decls.frameregtable:
    .space    1544
    .align    8
mc_decls.cstringlist:
    .space    8
    .align    8
mc_decls.vstringlist:
    .space    8
    .align    8
mc_decls.creallist:
    .space    8
    .align    8
mc_decls.cr32list:
    .space    8
    .align    8
mc_decls.currasmproc:
    .space    8
    .align    8
mc_decls.lab_funcnametable:
    .space    8
    .align    8
mc_decls.lab_funcaddrtable:
    .space    8
    .align    8
mc_decls.lab_funcnprocs:
    .space    8
    .align    8
mc_decls.ss_zdatalen:
    .space    8
    .align    8
mc_decls.ss_zdata:
    .space    8
    .align    8
mc_decls.ss_idata:
    .space    8
    .align    8
mc_decls.ss_code:
    .space    8
    .align    8
mc_decls.ss_idatarelocs:
    .space    8
    .align    8
mc_decls.ss_coderelocs:
    .space    8
    .align    8
mc_decls.ss_nidatarelocs:
    .space    8
    .align    8
mc_decls.ss_ncoderelocs:
    .space    8
    .align    8
mc_decls.ss_symboltable:
    .space    8
    .align    8
mc_decls.ss_nsymbols:
    .space    8
    .align    8
mc_decls.ss_symboltablesize:
    .space    8
    .align    8
mc_decls.labeldeftable:
    .space    8
    .align    8
mc_decls.aaseqno:
    .space    8
    .align    8
mc_decls.aapos:
    .space    8
    .data
mc_decls.regmodes:
    .quad     0x600000005000403
#ENDDATA
    .bss
mc_decls.pmode:
    .space    1
    .align    8
mc_decls.currpcl:
    .space    8
    .align    8
mc_decls.mclprocentry:
    .space    8
    .align    8
mc_decls.mce_oldmccodex:
    .space    8
    .align    8
mc_decls.mce_lastmcl:
    .space    8
    .align    8
mc_decls.mce_nextmcl:
    .space    8
    .align    8
mc_decls.mcf_oldmccodex:
    .space    8
    .align    8
mc_decls.mcf_lastmcl:
    .space    8
    .align    8
mc_decls.mcf_nextmcl:
    .space    8
mc_decls.fpcheckunusedlocals:
    .space    1
    .align    8
mc_decls.riplist:
    .space    8
    .align    8
mc_decls.blockdefs:
    .space    400
    .align    8
mc_decls.nblocktemps:
    .space    8
    .data
    .align    8
mc_decls.multregs:
    .quad     1
    .quad     2
    .quad     3
    .quad     0xB
    .quad     0xC
    .quad     0xD
    .align    8
mc_decls.multxregs:
    .quad     1
    .quad     2
    .quad     3
    .quad     4
    .quad     5
    .quad     6
    .bss
mc_decls.ploadopx:
    .space    14
mc_decls.ploadop:
    .space    14
    .data
    .align    8
mc_objdecls.relocnames:
    .quad     L7718
    .quad     L7719
    .quad     L7720
    .quad     L7721
    .quad     L7722
    .quad     L7723
    .quad     L7724
    .align    8
mc_writegas.asmext:
    .quad     L7725
    .bss
    .align    8
mc_writegas.nregnames:
    .space    1024
mc_writegas.currseg:
    .space    1
mc_writegas.strmcl.str:
    .space    512
mc_writegas.mstropnd.str:
    .space    512
mc_writegas.strvalue.str:
    .space    512
mc_writegas.getxregname.str:
    .space    32
mc_writegas.getdispname.str:
    .space    256
mc_writegas.gettempname.str:
    .space    128
mc_writegas.strreg.str:
    .space    16
    .data
    .align    8
cc_cli.passnames:
    .quad     L7726
    .quad     L7727
    .quad     L7728
    .quad     L7729
    .quad     L7730
    .quad     L7731
    .quad     L7732
    .quad     L7733
    .quad     L7734
    .quad     L7735
    .quad     L7736
    .quad     L7737
    .quad     L7738
    .align    8
cc_cli.extnames:
    .quad     L7739
    .quad     L7740
    .quad     L7741
    .quad     L7741
    .quad     L7742
    .quad     L7743
    .quad     L7744
    .quad     L7744
    .quad     L7745
    .quad     L7746
    .quad     L7747
    .quad     L7748
    .quad     L7749
    .bss
cc_cli.cc_pass:
    .space    1
cc_cli.dummy:
    .space    20
cc_cli.debugmode:
    .space    1
    .align    8
cc_cli.outfile:
    .space    8
    .data
    .align    8
cc_cli.outext:
    .quad     L7750
    .bss
    .align    8
cc_cli.cmdskip:
    .space    8
    .align    8
cc_cli.ttt:
    .space    8
    .data
cc_cli.fverbose:
    .byte     1
cc_cli.fshowincludes:
    .byte     0
cc_cli.dointheaders:
    .byte     1
cc_cli.highmem:
    .byte     1
    .bss
cc_cli.fshowst:
    .space    1
cc_cli.fshowstflat:
    .space    1
cc_cli.fshowast:
    .space    1
cc_cli.fshowpcl:
    .space    1
cc_cli.fshowpst:
    .space    1
cc_cli.fshowmcl:
    .space    1
cc_cli.fshowss:
    .space    1
cc_cli.fshowtypes:
    .space    1
cc_cli.fshowfiles:
    .space    1
cc_cli.fshowpaths:
    .space    1
cc_cli.fshowheaders:
    .space    1
cc_cli.fwriteheaders:
    .space    1
cc_cli.fshowlog:
    .space    1
cc_cli.fshowtiming:
    .space    1
cc_cli.fgendll:
    .space    1
cc_cli.fstdout:
    .space    1
cc_cli.fshortnames:
    .space    1
    .data
cc_cli.fwriteerrors:
    .byte     1
    .bss
    .align    8
cc_cli.entrypointname:
    .space    8
    .data
    .align    8
cc_cli.optionnames:
    .quad     L7751
    .quad     L7752
    .quad     L7753
    .quad     L7754
    .quad     L7755
    .quad     L7756
    .quad     L7757
    .quad     L7758
    .quad     L7759
    .quad     L7760
    .quad     L7761
    .quad     L7762
    .quad     L7763
    .quad     L7764
    .quad     L7765
    .quad     L7766
    .quad     L7767
    .quad     L7768
    .quad     L7769
    .quad     L7770
    .quad     L7771
    .quad     L7772
    .quad     L7773
    .quad     L7774
    .quad     L7775
    .quad     L7776
    .quad     L7777
    .quad     L7778
    .quad     L7779
    .quad     L7780
    .quad     L7781
    .quad     L7782
    .quad     L7783
    .quad     L7784
    .quad     L7785
    .quad     L7786
    .quad     L7787
    .quad     L7788
    .quad     L7789
    .quad     L7790
    .quad     L7791
    .quad     L7792
    .quad     L7793
    .quad     L7794
    .quad     L7795
    .quad     L7796
    .quad     L7797
    .quad     L7798
    .quad     L7799
    .align    8
cc_cli.optvars:
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     pc_decls.fregoptim
    .quad     pc_decls.fpeephole
    .quad     0
    .quad     cc_cli.fshowpaths
    .quad     cc_cli.fshowheaders
    .quad     0
    .quad     cc_cli.fshowincludes
    .quad     cc_cli.fshowst
    .quad     cc_cli.fshowstflat
    .quad     cc_cli.fshowast
    .quad     cc_cli.fshowpcl
    .quad     cc_cli.fshowpst
    .quad     cc_cli.fshowmcl
    .quad     cc_cli.fshowss
    .quad     cc_cli.fshowtypes
    .quad     cc_cli.fshowfiles
    .quad     cc_cli.fshowtiming
    .quad     cc_cli.fshowtiming
    .quad     cc_cli.fverbose
    .quad     cc_cli.fverbose
    .quad     cc_cli.fverbose
    .quad     pc_decls.pverbose
    .quad     pc_decls.pverbose
    .quad     0
    .quad     0
    .quad     cc_cli.dointheaders
    .quad     cc_cli.fwriteheaders
    .quad     0
    .quad     cc_cli.fstdout
    .quad     cc_cli.fshortnames
    .quad     cc_cli.highmem
    .quad     cc_cli.highmem
cc_cli.optvalues:
    .quad     0x605050403020201
    .quad     0xC0B090A0A080807
    .quad     0x10101010000000D
    .quad     0x101010101010101
    .quad     0x201000302020101
    .quad     0x1010001000000
    .byte     2
#ENDDATA
    .align    8
cc_cli.totallines:
    .quad     0
    .align    8
cc_cli.nstringobjects:
    .quad     0
    .bss
    .align    8
cc_cli.startclock:
    .space    8
    .align    8
cc_cli.loadtime:
    .space    8
    .align    8
cc_cli.parsetime:
    .space    8
    .align    8
cc_cli.pcltime:
    .space    8
    .align    8
cc_cli.compiletime:
    .space    8
    .align    8
cc_cli.inittime:
    .space    8
    .data
    .align    8
cc_cli.showextrainfo.infotext:
    .quad     L7800
    .bss
    .align    8
cc_decls.ntypes:
    .space    8
    .align    8
cc_decls.ttnamedef:
    .space    640000
    .align    2
cc_decls.ttbasetype:
    .space    160000
    .align    8
cc_decls.ttlength:
    .space    640000
cc_decls.ttconst:
    .space    80000
    .align    2
cc_decls.tttarget:
    .space    160000
    .align    2
cc_decls.ttreftype:
    .space    160000
    .align    2
cc_decls.ttconsttype:
    .space    160000
    .align    8
cc_decls.ttsize:
    .space    640000
cc_decls.ttisref:
    .space    80000
cc_decls.ttisblock:
    .space    80000
cc_decls.ttsigned:
    .space    80000
    .align    4
cc_decls.ttshared:
    .space    320000
    .align    8
cc_decls.ttparams:
    .space    640000
    .align    8
cc_decls.tttypedef:
    .space    640000
    .align    8
cc_decls.trefchar:
    .space    8
    .align    8
cc_decls.trefwchar:
    .space    8
    .align    8
cc_decls.inputfile:
    .space    8
    .align    8
cc_decls.mainfileno:
    .space    8
    .align    8
cc_decls.libfiles:
    .space    1608
    .align    8
cc_decls.sourcefilenames:
    .space    1608
    .align    8
cc_decls.sourcefilepaths:
    .space    1608
    .align    8
cc_decls.sourcefiletext:
    .space    1608
    .align    4
cc_decls.sourcefilesizes:
    .space    804
    .align    8
cc_decls.nsourcefiles:
    .space    8
    .align    8
cc_decls.nlibfiles:
    .space    8
    .align    8
cc_decls.searchdirs:
    .space    160
    .data
    .align    8
cc_decls.nsearchdirs:
    .quad     0
    .bss
    .align    8
cc_decls.includepaths:
    .space    160
    .data
    .align    8
cc_decls.nincludepaths:
    .quad     0
    .bss
    .align    8
cc_decls.stprogram:
    .space    8
    .align    8
cc_decls.stmodule:
    .space    8
    .align    8
cc_decls.logdev:
    .space    8
    .align    8
cc_decls.nullunit:
    .space    8
    .data
    .align    8
cc_decls.clineno:
    .quad     0
    .align    8
cc_decls.cfileno:
    .quad     0
    .bss
    .align    8
cc_decls.lx:
    .space    32
    .align    8
cc_decls.nextlx:
    .space    32
    .data
    .align    8
cc_decls.debug:
    .quad     0
    .align    8
cc_decls.hstsize:
    .quad     0x10000
    .bss
    .align    8
cc_decls.hstmask:
    .space    8
    .align    8
cc_decls.hashtable:
    .space    8
    .align    4
cc_decls.blockowner:
    .space    8404
    .align    4
cc_decls.blockcounts:
    .space    8404
    .align    4
cc_decls.blockstack:
    .space    404
    .align    8
cc_decls.currblockno:
    .space    8
    .align    8
cc_decls.nextblockno:
    .space    8
    .align    8
cc_decls.blocklevel:
    .space    8
    .align    8
cc_decls.currproc:
    .space    8
    .data
    .align    8
cc_decls.dheaderfile:
    .quad     0
    .align    8
cc_decls.structpadding:
    .quad     1
    .align    8
cc_decls.callbackflag:
    .quad     0
    .bss
    .align    8
cc_decls.slineno:
    .space    8
    .align    8
cc_decls.sfileno:
    .space    8
    .data
    .align    8
cc_decls.oemname:
    .quad     L7801
    .bss
    .align    8
cc_decls.mclstr:
    .space    8
    .align    8
cc_decls.mclstrlen:
    .space    8
    .align    8
cc_decls.nunits:
    .space    8
    .align    8
cc_decls.pmodulelist:
    .space    1592
    .align    8
cc_decls.pheaderlist:
    .space    800
    .align    8
cc_decls.pliblist:
    .space    800
    .align    8
cc_decls.npmodules:
    .space    8
    .align    8
cc_decls.npheaders:
    .space    8
    .align    8
cc_decls.nplibs:
    .space    8
cc_decls.pci_target:
    .space    1
    .data
    .align    8
cc_tables.stdtypenames:
    .quad     L7802
    .quad     L7803
    .quad     L7804
    .quad     L7805
    .quad     L7806
    .quad     L7807
    .quad     L7808
    .quad     L7809
    .quad     L7810
    .quad     L7811
    .quad     L7812
    .quad     L7813
    .quad     L7814
    .quad     L7815
    .quad     L7816
    .quad     L7817
    .quad     L7818
    .quad     L7819
    .quad     L7820
    .quad     L7821
    .quad     L7822
    .quad     L7823
cc_tables.stdtypewidths:
    .quad     0x1008084020100800
    .quad     0x4040400040204020
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
#ENDDATA
cc_tables.stdsigned:
    .quad     0x101010100
    .quad     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
#ENDDATA
cc_tables.stdpcl:
    .quad     0x403030A09080700
    .quad     0x60902010605
    .byte     11
    .byte     11
    .byte     11
    .byte     11
    .byte     0
    .byte     0
#ENDDATA
cc_tables.stdsize:
    .quad     0x201010804020100
    .quad     0x8040804
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
#ENDDATA
    .align    8
cc_tables.catnames:
    .quad     L7824
    .quad     L7825
    .quad     L7826
    .quad     L7827
    .quad     L7828
    .align    8
cc_tables.typespecnames:
    .quad     L7829
    .quad     L7830
    .quad     L7831
    .quad     L7832
    .quad     L7833
    .quad     L7834
    .quad     L7835
    .quad     L7836
    .quad     L7837
    .quad     L7838
    .quad     L7839
    .quad     L7840
    .quad     L7841
    .quad     L7842
    .quad     L7843
    .align    4
cc_tables.typespectypes:
    .long     0
    .long     1
    .long     0
    .long     0
    .long     3
    .long     10
    .long     11
    .long     0
    .long     0
    .long     5
    .long     0
    .long     0
    .long     0
    .long     0
    .long     0
cc_tables.typespecsizes:
    .quad     0x8040404020100
    .byte     0
    .byte     1
    .byte     0
    .byte     0
    .byte     0
    .byte     4
    .byte     0
#ENDDATA
    .align    8
cc_tables.pmflagnames:
    .quad     L7844
    .quad     L7845
    .quad     L7846
    .quad     L7847
    .align    8
cc_tables.scopenames:
    .quad     L7848
    .quad     L7849
    .quad     L7850
    .quad     L7851
    .quad     L7852
    .align    8
cc_tables.cccnames:
    .quad     L7853
    .quad     L7854
    .quad     L7855
    .quad     L7856
    .quad     L7857
    .quad     L7858
    .align    8
cc_tables.linkagenames:
    .quad     L7859
    .quad     L7860
    .quad     L7861
    .quad     L7862
    .quad     L7863
    .quad     L7864
    .align    8
cc_tables.typequalnames:
    .quad     L7865
    .quad     L7866
    .quad     L7867
    .quad     L7868
    .align    8
cc_tables.fnspecnames:
    .quad     L7869
    .quad     L7870
    .quad     L7871
    .align    8
cc_tables.jtagnames:
    .quad     L7872
    .quad     L7873
    .quad     L7874
    .quad     L7875
    .quad     L7876
    .quad     L7877
    .quad     L7878
    .quad     L7879
    .quad     L7880
    .quad     L7881
    .quad     L7882
    .quad     L7883
    .quad     L7884
    .quad     L7885
    .quad     L7886
    .quad     L7887
    .quad     L7888
    .quad     L7889
    .quad     L7890
    .quad     L7891
    .quad     L7892
    .quad     L7893
    .quad     L7894
    .quad     L7895
    .quad     L7896
    .quad     L7897
    .quad     L7898
    .quad     L7899
    .quad     L7900
    .quad     L7901
    .quad     L7902
    .quad     L7903
    .quad     L7904
    .quad     L7905
    .quad     L7906
    .quad     L7907
    .quad     L7908
    .quad     L7909
    .quad     L7910
    .quad     L7911
    .quad     L7912
    .quad     L7913
    .quad     L7914
    .quad     L7915
    .quad     L7916
    .quad     L7917
    .quad     L7918
    .quad     L7919
    .quad     L7920
    .quad     L7921
    .quad     L7922
    .quad     L7923
    .quad     L7924
    .quad     L7925
    .quad     L7926
    .quad     L7927
    .quad     L7928
    .quad     L7929
    .quad     L7930
    .quad     L7931
    .quad     L7932
    .quad     L7933
    .quad     L7934
    .quad     L7935
    .quad     L7936
    .quad     L7937
    .quad     L7938
    .quad     L7939
    .quad     L7940
    .quad     L7941
    .quad     L7942
    .quad     L7943
    .quad     L7944
    .quad     L7945
    .quad     L7946
    .quad     L7947
    .quad     L7948
    .quad     L7949
    .align    8
cc_tables.symbolnames:
    .quad     L7950
    .quad     L7951
    .quad     L7952
    .quad     L7953
    .quad     L7954
    .quad     L7955
    .quad     L7956
    .quad     L7957
    .quad     L7958
    .quad     L7959
    .quad     L7960
    .quad     L7961
    .quad     L7962
    .quad     L7963
    .quad     L7964
    .quad     L7965
    .quad     L7966
    .quad     L7967
    .quad     L7968
    .quad     L7969
    .quad     L7970
    .quad     L7971
    .quad     L7972
    .quad     L7973
    .quad     L7974
    .quad     L7975
    .quad     L7976
    .quad     L7977
    .quad     L7978
    .quad     L7979
    .quad     L7980
    .quad     L7981
    .quad     L7982
    .quad     L7983
    .quad     L7984
    .quad     L7985
    .quad     L7986
    .quad     L7987
    .quad     L7988
    .quad     L7989
    .quad     L7990
    .quad     L7991
    .quad     L7992
    .quad     L7993
    .quad     L7994
    .quad     L7995
    .quad     L7996
    .quad     L7997
    .quad     L7998
    .quad     L7999
    .quad     L8000
    .quad     L8001
    .quad     L8002
    .quad     L8003
    .quad     L8004
    .quad     L8005
    .quad     L8006
    .quad     L8007
    .quad     L8008
    .quad     L8009
    .quad     L8010
    .quad     L8011
    .quad     L8012
    .quad     L8013
    .quad     L8014
    .quad     L8015
    .quad     L8016
    .quad     L8017
    .quad     L8018
    .quad     L8019
    .quad     L8020
    .quad     L8021
    .quad     L8022
    .quad     L8023
    .quad     L8024
    .quad     L8025
    .quad     L8026
    .quad     L8027
    .quad     L8028
    .quad     L8029
    .quad     L8030
    .quad     L8031
    .quad     L8032
    .quad     L8033
    .quad     L8034
    .quad     L8035
    .quad     L8036
    .quad     L8037
    .quad     L8038
    .quad     L8039
    .quad     L8040
    .quad     L8041
    .quad     L8042
    .quad     L8043
    .quad     L8044
    .quad     L8045
    .align    8
cc_tables.shortsymbolnames:
    .quad     L8046
    .quad     L8047
    .quad     L8048
    .quad     L8049
    .quad     L8049
    .quad     L8049
    .quad     L8050
    .quad     L8051
    .quad     L8052
    .quad     L8053
    .quad     L8054
    .quad     L8055
    .quad     L8056
    .quad     L8057
    .quad     L8058
    .quad     L8059
    .quad     L8060
    .quad     L8061
    .quad     L8062
    .quad     L8063
    .quad     L8064
    .quad     L8065
    .quad     L8066
    .quad     L8067
    .quad     L8068
    .quad     L8069
    .quad     L8070
    .quad     L8071
    .quad     L8072
    .quad     L8073
    .quad     L8074
    .quad     L8075
    .quad     L8076
    .quad     L8077
    .quad     L8078
    .quad     L8079
    .quad     L8080
    .quad     L8081
    .quad     L8082
    .quad     L8083
    .quad     L8084
    .quad     L8085
    .quad     L8086
    .quad     L8087
    .quad     L8088
    .quad     L8089
    .quad     L8090
    .quad     L8091
    .quad     L8092
    .quad     L8093
    .quad     L8094
    .quad     L8095
    .quad     L8096
    .quad     L8097
    .quad     L8098
    .quad     L8099
    .quad     L8099
    .quad     L8100
    .quad     L8100
    .quad     L8100
    .quad     L8101
    .quad     L8101
    .quad     L8101
    .quad     L8101
    .quad     L8102
    .quad     L8103
    .quad     L8104
    .quad     L8104
    .quad     L8104
    .quad     L8104
    .quad     L8104
    .quad     L8104
    .quad     L8104
    .quad     L8104
    .quad     L8104
    .quad     L8104
    .quad     L8104
    .quad     L8104
    .quad     L8104
    .quad     L8104
    .quad     L8104
    .quad     L8104
    .quad     L8104
    .quad     L8104
    .quad     L8104
    .quad     L8104
    .quad     L8104
    .quad     L8104
    .quad     L8104
    .quad     L8104
    .quad     L8104
    .quad     L8104
    .quad     L8104
    .quad     L8104
    .quad     L8104
    .quad     L8105
cc_tables.symboltojtag:
    .quad     0x323100
    .quad     0xB0B0000
    .quad     0x2827000000000000
    .quad     0x18192E2C2D2B2A29
    .quad     0x213B48471A3C302F
    .quad     0x3F3E3D2526242322
    .quad     0x46454442434140
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .quad     0
#ENDDATA
    .align    8
cc_tables.sourcedirnames:
    .quad     L8106
    .quad     L8107
    .quad     L8108
    .quad     L8109
    .quad     L8110
    .quad     L8111
    .quad     L8112
    .quad     L8113
    .quad     L8114
    .quad     L8115
    .quad     L8116
    .quad     L8117
    .quad     L8118
    .quad     L8119
    .quad     L8120
    .align    8
cc_tables.namespacenames:
    .quad     L8121
    .quad     L8122
    .quad     L8123
    .quad     L8124
    .quad     L8125
    .align    8
cc_tables.namenames:
    .quad     L8126
    .quad     L8127
    .quad     L8128
    .quad     L8129
    .quad     L8130
    .quad     L8131
    .quad     L8132
    .quad     L8133
    .quad     L8134
    .quad     L8135
    .quad     L8136
    .quad     L8137
    .quad     L8138
    .quad     L8139
    .quad     L8140
    .align    4
cc_tables.namespaces:
    .long     0
    .long     0
    .long     0
    .long     0
    .long     0
    .long     1
    .long     1
    .long     1
    .long     1
    .long     1
    .long     4
    .long     1
    .long     2
    .long     2
    .long     3
cc_tables.name2pid:
    .quad     0x302000000000000
    .byte     4
    .byte     5
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     6
#ENDDATA
    .align    8
cc_tables.stnames:
    .quad     L8141
    .quad     L8142
    .quad     L8143
    .quad     L8144
    .quad     L8145
    .quad     L8146
    .quad     L8147
    .quad     L8148
    .quad     L8149
    .quad     L8150
    .quad     L8151
    .quad     L8152
    .quad     L8153
    .quad     L8154
    .quad     L8155
    .quad     L8156
    .quad     L8157
    .quad     L8158
    .quad     L8159
    .quad     L8160
    .quad     L8161
    .quad     L8162
    .quad     L8163
    .quad     L8164
    .quad     L8165
    .quad     L8166
    .quad     L8167
    .quad     L8168
    .quad     L8169
    .quad     L8170
    .quad     L8171
    .quad     L8172
    .quad     L8173
    .quad     L8174
    .quad     L8175
    .quad     L8176
    .quad     L8177
    .quad     L8178
    .quad     L8179
    .quad     L8180
    .quad     L8181
    .quad     L8182
    .quad     L8183
    .quad     L8184
    .quad     L8185
    .quad     L8186
    .quad     L8187
    .quad     L8188
    .quad     L8189
    .quad     L8190
    .quad     L8191
    .quad     L8192
    .quad     L8193
    .quad     L8194
    .quad     L8195
    .quad     L8196
    .quad     L8197
    .quad     L8198
    .quad     L8199
    .quad     L8200
    .quad     L8201
    .quad     L8202
    .quad     L8203
    .align    4
cc_tables.stsymbols:
    .long     71
    .long     72
    .long     73
    .long     74
    .long     75
    .long     77
    .long     76
    .long     78
    .long     79
    .long     80
    .long     81
    .long     82
    .long     83
    .long     84
    .long     68
    .long     68
    .long     68
    .long     68
    .long     68
    .long     68
    .long     68
    .long     68
    .long     68
    .long     68
    .long     85
    .long     85
    .long     85
    .long     85
    .long     85
    .long     86
    .long     86
    .long     86
    .long     86
    .long     88
    .long     88
    .long     89
    .long     90
    .long     70
    .long     70
    .long     70
    .long     70
    .long     70
    .long     70
    .long     70
    .long     70
    .long     70
    .long     70
    .long     69
    .long     69
    .long     69
    .long     69
    .long     69
    .long     69
    .long     69
    .long     69
    .long     91
    .long     91
    .long     92
    .long     93
    .long     94
    .long     95
    .long     95
    .long     0
    .align    4
cc_tables.stsubcodes:
    .long     12
    .long     0
    .long     0
    .long     0
    .long     0
    .long     0
    .long     0
    .long     0
    .long     0
    .long     0
    .long     0
    .long     0
    .long     0
    .long     0
    .long     7
    .long     1
    .long     4
    .long     8
    .long     9
    .long     6
    .long     10
    .long     11
    .long     15
    .long     14
    .long     2
    .long     3
    .long     1
    .long     4
    .long     5
    .long     1
    .long     2
    .long     3
    .long     4
    .long     1
    .long     2
    .long     0
    .long     0
    .long     1
    .long     2
    .long     3
    .long     4
    .long     5
    .long     6
    .long     7
    .long     8
    .long     9
    .long     10
    .long     1
    .long     3
    .long     4
    .long     2
    .long     7
    .long     8
    .long     5
    .long     5
    .long     0
    .long     1
    .long     0
    .long     0
    .long     0
    .long     75
    .long     76
    .long     0
    .align    8
cc_tables.convnames:
    .quad     L8204
    .quad     L8205
    .quad     L8206
    .quad     L8207
    .quad     L8208
    .quad     L8209
    .quad     L8210
    .quad     L8211
    .quad     L8212
    .quad     L8213
    .quad     L8214
    .quad     L8215
    .quad     L8216
    .quad     L8217
    .bss
cc_tables.dominantmode:
    .space    1024
cc_tables.conversionops:
    .space    256
    .data
cc_tables.dominantsetuptable:
    .byte     1
    .byte     1
    .byte     3
#ENDDATA
    .byte     1
    .byte     2
    .byte     3
#ENDDATA
    .byte     1
    .byte     3
    .byte     3
#ENDDATA
    .byte     1
    .byte     4
    .byte     4
#ENDDATA
    .byte     1
    .byte     5
    .byte     3
#ENDDATA
    .byte     1
    .byte     6
    .byte     3
#ENDDATA
    .byte     1
    .byte     7
    .byte     3
#ENDDATA
    .byte     1
    .byte     8
    .byte     3
#ENDDATA
    .byte     1
    .byte     9
    .byte     4
#ENDDATA
    .byte     1
    .byte     10
    .byte     10
#ENDDATA
    .byte     1
    .byte     11
    .byte     11
#ENDDATA
    .byte     2
    .byte     1
    .byte     3
#ENDDATA
    .byte     2
    .byte     2
    .byte     3
#ENDDATA
    .byte     2
    .byte     3
    .byte     3
#ENDDATA
    .byte     2
    .byte     4
    .byte     4
#ENDDATA
    .byte     2
    .byte     5
    .byte     3
#ENDDATA
    .byte     2
    .byte     6
    .byte     3
#ENDDATA
    .byte     2
    .byte     7
    .byte     3
#ENDDATA
    .byte     2
    .byte     8
    .byte     3
#ENDDATA
    .byte     2
    .byte     9
    .byte     4
#ENDDATA
    .byte     2
    .byte     10
    .byte     10
#ENDDATA
    .byte     2
    .byte     11
    .byte     11
#ENDDATA
    .byte     3
    .byte     1
    .byte     3
#ENDDATA
    .byte     3
    .byte     2
    .byte     3
#ENDDATA
    .byte     3
    .byte     3
    .byte     3
#ENDDATA
    .byte     3
    .byte     4
    .byte     4
#ENDDATA
    .byte     3
    .byte     5
    .byte     3
#ENDDATA
    .byte     3
    .byte     6
    .byte     3
#ENDDATA
    .byte     3
    .byte     7
    .byte     3
#ENDDATA
    .byte     3
    .byte     8
    .byte     8
#ENDDATA
    .byte     3
    .byte     9
    .byte     4
#ENDDATA
    .byte     3
    .byte     10
    .byte     10
#ENDDATA
    .byte     3
    .byte     11
    .byte     11
#ENDDATA
    .byte     4
    .byte     1
    .byte     4
#ENDDATA
    .byte     4
    .byte     2
    .byte     4
#ENDDATA
    .byte     4
    .byte     3
    .byte     4
#ENDDATA
    .byte     4
    .byte     4
    .byte     4
#ENDDATA
    .byte     4
    .byte     5
    .byte     4
#ENDDATA
    .byte     4
    .byte     6
    .byte     4
#ENDDATA
    .byte     4
    .byte     7
    .byte     4
#ENDDATA
    .byte     4
    .byte     8
    .byte     4
#ENDDATA
    .byte     4
    .byte     9
    .byte     9
#ENDDATA
    .byte     4
    .byte     10
    .byte     10
#ENDDATA
    .byte     4
    .byte     11
    .byte     11
#ENDDATA
    .byte     5
    .byte     1
    .byte     3
#ENDDATA
    .byte     5
    .byte     2
    .byte     3
#ENDDATA
    .byte     5
    .byte     3
    .byte     3
#ENDDATA
    .byte     5
    .byte     4
    .byte     4
#ENDDATA
    .byte     5
    .byte     5
    .byte     8
#ENDDATA
    .byte     5
    .byte     6
    .byte     8
#ENDDATA
    .byte     5
    .byte     7
    .byte     8
#ENDDATA
    .byte     5
    .byte     8
    .byte     8
#ENDDATA
    .byte     5
    .byte     9
    .byte     9
#ENDDATA
    .byte     5
    .byte     10
    .byte     10
#ENDDATA
    .byte     5
    .byte     11
    .byte     11
#ENDDATA
    .byte     6
    .byte     1
    .byte     3
#ENDDATA
    .byte     6
    .byte     2
    .byte     3
#ENDDATA
    .byte     6
    .byte     3
    .byte     3
#ENDDATA
    .byte     6
    .byte     4
    .byte     4
#ENDDATA
    .byte     6
    .byte     5
    .byte     0
#ENDDATA
    .byte     6
    .byte     6
    .byte     8
#ENDDATA
    .byte     6
    .byte     7
    .byte     8
#ENDDATA
    .byte     6
    .byte     8
    .byte     8
#ENDDATA
    .byte     6
    .byte     9
    .byte     9
#ENDDATA
    .byte     6
    .byte     10
    .byte     10
#ENDDATA
    .byte     6
    .byte     11
    .byte     11
#ENDDATA
    .byte     7
    .byte     1
    .byte     3
#ENDDATA
    .byte     7
    .byte     2
    .byte     3
#ENDDATA
    .byte     7
    .byte     3
    .byte     3
#ENDDATA
    .byte     7
    .byte     4
    .byte     4
#ENDDATA
    .byte     7
    .byte     5
    .byte     8
#ENDDATA
    .byte     7
    .byte     6
    .byte     8
#ENDDATA
    .byte     7
    .byte     7
    .byte     8
#ENDDATA
    .byte     7
    .byte     8
    .byte     8
#ENDDATA
    .byte     7
    .byte     9
    .byte     9
#ENDDATA
    .byte     7
    .byte     10
    .byte     10
#ENDDATA
    .byte     7
    .byte     11
    .byte     11
#ENDDATA
    .byte     8
    .byte     1
    .byte     3
#ENDDATA
    .byte     8
    .byte     2
    .byte     3
#ENDDATA
    .byte     8
    .byte     3
    .byte     8
#ENDDATA
    .byte     8
    .byte     4
    .byte     4
#ENDDATA
    .byte     8
    .byte     5
    .byte     8
#ENDDATA
    .byte     8
    .byte     6
    .byte     8
#ENDDATA
    .byte     8
    .byte     7
    .byte     8
#ENDDATA
    .byte     8
    .byte     8
    .byte     8
#ENDDATA
    .byte     8
    .byte     9
    .byte     9
#ENDDATA
    .byte     8
    .byte     10
    .byte     10
#ENDDATA
    .byte     8
    .byte     11
    .byte     11
#ENDDATA
    .byte     9
    .byte     1
    .byte     9
#ENDDATA
    .byte     9
    .byte     2
    .byte     9
#ENDDATA
    .byte     9
    .byte     3
    .byte     9
#ENDDATA
    .byte     9
    .byte     4
    .byte     9
#ENDDATA
    .byte     9
    .byte     5
    .byte     9
#ENDDATA
    .byte     9
    .byte     6
    .byte     9
#ENDDATA
    .byte     9
    .byte     7
    .byte     9
#ENDDATA
    .byte     9
    .byte     8
    .byte     9
#ENDDATA
    .byte     9
    .byte     9
    .byte     9
#ENDDATA
    .byte     9
    .byte     10
    .byte     10
#ENDDATA
    .byte     9
    .byte     11
    .byte     11
#ENDDATA
    .byte     10
    .byte     1
    .byte     11
#ENDDATA
    .byte     10
    .byte     2
    .byte     11
#ENDDATA
    .byte     10
    .byte     3
    .byte     11
#ENDDATA
    .byte     10
    .byte     4
    .byte     11
#ENDDATA
    .byte     10
    .byte     5
    .byte     11
#ENDDATA
    .byte     10
    .byte     6
    .byte     11
#ENDDATA
    .byte     10
    .byte     7
    .byte     11
#ENDDATA
    .byte     10
    .byte     8
    .byte     11
#ENDDATA
    .byte     10
    .byte     9
    .byte     11
#ENDDATA
    .byte     10
    .byte     10
    .byte     10
#ENDDATA
    .byte     10
    .byte     11
    .byte     11
#ENDDATA
    .byte     11
    .byte     1
    .byte     11
#ENDDATA
    .byte     11
    .byte     2
    .byte     11
#ENDDATA
    .byte     11
    .byte     3
    .byte     11
#ENDDATA
    .byte     11
    .byte     4
    .byte     11
#ENDDATA
    .byte     11
    .byte     5
    .byte     11
#ENDDATA
    .byte     11
    .byte     6
    .byte     11
#ENDDATA
    .byte     11
    .byte     7
    .byte     11
#ENDDATA
    .byte     11
    .byte     8
    .byte     11
#ENDDATA
    .byte     11
    .byte     9
    .byte     11
#ENDDATA
    .byte     11
    .byte     10
    .byte     11
#ENDDATA
    .byte     11
    .byte     11
    .byte     11
#ENDDATA
cc_tables.convsetuptable:
    .byte     1
    .byte     1
    .byte     3
#ENDDATA
    .byte     1
    .byte     2
    .byte     3
#ENDDATA
    .byte     1
    .byte     3
    .byte     3
#ENDDATA
    .byte     1
    .byte     4
    .byte     3
#ENDDATA
    .byte     1
    .byte     5
    .byte     13
#ENDDATA
    .byte     1
    .byte     6
    .byte     1
#ENDDATA
    .byte     1
    .byte     7
    .byte     3
#ENDDATA
    .byte     1
    .byte     8
    .byte     3
#ENDDATA
    .byte     1
    .byte     9
    .byte     3
#ENDDATA
    .byte     1
    .byte     10
    .byte     5
#ENDDATA
    .byte     1
    .byte     11
    .byte     5
#ENDDATA
    .byte     2
    .byte     1
    .byte     12
#ENDDATA
    .byte     2
    .byte     2
    .byte     0
#ENDDATA
    .byte     2
    .byte     3
    .byte     3
#ENDDATA
    .byte     2
    .byte     4
    .byte     3
#ENDDATA
    .byte     2
    .byte     5
    .byte     13
#ENDDATA
    .byte     2
    .byte     6
    .byte     12
#ENDDATA
    .byte     2
    .byte     7
    .byte     1
#ENDDATA
    .byte     2
    .byte     8
    .byte     3
#ENDDATA
    .byte     2
    .byte     9
    .byte     3
#ENDDATA
    .byte     2
    .byte     10
    .byte     5
#ENDDATA
    .byte     2
    .byte     11
    .byte     5
#ENDDATA
    .byte     3
    .byte     1
    .byte     12
#ENDDATA
    .byte     3
    .byte     2
    .byte     12
#ENDDATA
    .byte     3
    .byte     3
    .byte     0
#ENDDATA
    .byte     3
    .byte     4
    .byte     3
#ENDDATA
    .byte     3
    .byte     5
    .byte     13
#ENDDATA
    .byte     3
    .byte     6
    .byte     12
#ENDDATA
    .byte     3
    .byte     7
    .byte     12
#ENDDATA
    .byte     3
    .byte     8
    .byte     1
#ENDDATA
    .byte     3
    .byte     9
    .byte     3
#ENDDATA
    .byte     3
    .byte     10
    .byte     5
#ENDDATA
    .byte     3
    .byte     11
    .byte     5
#ENDDATA
    .byte     4
    .byte     1
    .byte     12
#ENDDATA
    .byte     4
    .byte     2
    .byte     12
#ENDDATA
    .byte     4
    .byte     3
    .byte     12
#ENDDATA
    .byte     4
    .byte     4
    .byte     0
#ENDDATA
    .byte     4
    .byte     5
    .byte     13
#ENDDATA
    .byte     4
    .byte     6
    .byte     12
#ENDDATA
    .byte     4
    .byte     7
    .byte     12
#ENDDATA
    .byte     4
    .byte     8
    .byte     12
#ENDDATA
    .byte     4
    .byte     9
    .byte     1
#ENDDATA
    .byte     4
    .byte     10
    .byte     5
#ENDDATA
    .byte     4
    .byte     11
    .byte     5
#ENDDATA
    .byte     5
    .byte     1
    .byte     1
#ENDDATA
    .byte     5
    .byte     2
    .byte     4
#ENDDATA
    .byte     5
    .byte     3
    .byte     4
#ENDDATA
    .byte     5
    .byte     4
    .byte     4
#ENDDATA
    .byte     5
    .byte     5
    .byte     0
#ENDDATA
    .byte     5
    .byte     6
    .byte     1
#ENDDATA
    .byte     5
    .byte     7
    .byte     4
#ENDDATA
    .byte     5
    .byte     8
    .byte     4
#ENDDATA
    .byte     5
    .byte     9
    .byte     4
#ENDDATA
    .byte     5
    .byte     10
    .byte     6
#ENDDATA
    .byte     5
    .byte     11
    .byte     6
#ENDDATA
    .byte     6
    .byte     1
    .byte     1
#ENDDATA
    .byte     6
    .byte     2
    .byte     4
#ENDDATA
    .byte     6
    .byte     3
    .byte     4
#ENDDATA
    .byte     6
    .byte     4
    .byte     4
#ENDDATA
    .byte     6
    .byte     5
    .byte     13
#ENDDATA
    .byte     6
    .byte     6
    .byte     1
#ENDDATA
    .byte     6
    .byte     7
    .byte     4
#ENDDATA
    .byte     6
    .byte     8
    .byte     4
#ENDDATA
    .byte     6
    .byte     9
    .byte     4
#ENDDATA
    .byte     6
    .byte     10
    .byte     6
#ENDDATA
    .byte     6
    .byte     11
    .byte     6
#ENDDATA
    .byte     7
    .byte     1
    .byte     12
#ENDDATA
    .byte     7
    .byte     2
    .byte     1
#ENDDATA
    .byte     7
    .byte     3
    .byte     4
#ENDDATA
    .byte     7
    .byte     4
    .byte     4
#ENDDATA
    .byte     7
    .byte     5
    .byte     13
#ENDDATA
    .byte     7
    .byte     6
    .byte     12
#ENDDATA
    .byte     7
    .byte     7
    .byte     0
#ENDDATA
    .byte     7
    .byte     8
    .byte     4
#ENDDATA
    .byte     7
    .byte     9
    .byte     4
#ENDDATA
    .byte     7
    .byte     10
    .byte     6
#ENDDATA
    .byte     7
    .byte     11
    .byte     6
#ENDDATA
    .byte     8
    .byte     1
    .byte     12
#ENDDATA
    .byte     8
    .byte     2
    .byte     12
#ENDDATA
    .byte     8
    .byte     3
    .byte     1
#ENDDATA
    .byte     8
    .byte     4
    .byte     4
#ENDDATA
    .byte     8
    .byte     5
    .byte     13
#ENDDATA
    .byte     8
    .byte     6
    .byte     12
#ENDDATA
    .byte     8
    .byte     7
    .byte     12
#ENDDATA
    .byte     8
    .byte     8
    .byte     0
#ENDDATA
    .byte     8
    .byte     9
    .byte     4
#ENDDATA
    .byte     8
    .byte     10
    .byte     6
#ENDDATA
    .byte     8
    .byte     11
    .byte     6
#ENDDATA
    .byte     9
    .byte     1
    .byte     12
#ENDDATA
    .byte     9
    .byte     2
    .byte     12
#ENDDATA
    .byte     9
    .byte     3
    .byte     12
#ENDDATA
    .byte     9
    .byte     4
    .byte     1
#ENDDATA
    .byte     9
    .byte     5
    .byte     13
#ENDDATA
    .byte     9
    .byte     6
    .byte     12
#ENDDATA
    .byte     9
    .byte     7
    .byte     12
#ENDDATA
    .byte     9
    .byte     8
    .byte     12
#ENDDATA
    .byte     9
    .byte     9
    .byte     0
#ENDDATA
    .byte     9
    .byte     10
    .byte     6
#ENDDATA
    .byte     9
    .byte     11
    .byte     6
#ENDDATA
    .byte     10
    .byte     1
    .byte     7
#ENDDATA
    .byte     10
    .byte     2
    .byte     7
#ENDDATA
    .byte     10
    .byte     3
    .byte     7
#ENDDATA
    .byte     10
    .byte     4
    .byte     7
#ENDDATA
    .byte     10
    .byte     5
    .byte     8
#ENDDATA
    .byte     10
    .byte     6
    .byte     8
#ENDDATA
    .byte     10
    .byte     7
    .byte     8
#ENDDATA
    .byte     10
    .byte     8
    .byte     8
#ENDDATA
    .byte     10
    .byte     9
    .byte     8
#ENDDATA
    .byte     10
    .byte     10
    .byte     0
#ENDDATA
    .byte     10
    .byte     11
    .byte     9
#ENDDATA
    .byte     11
    .byte     1
    .byte     7
#ENDDATA
    .byte     11
    .byte     2
    .byte     7
#ENDDATA
    .byte     11
    .byte     3
    .byte     7
#ENDDATA
    .byte     11
    .byte     4
    .byte     7
#ENDDATA
    .byte     11
    .byte     5
    .byte     8
#ENDDATA
    .byte     11
    .byte     6
    .byte     8
#ENDDATA
    .byte     11
    .byte     7
    .byte     8
#ENDDATA
    .byte     11
    .byte     8
    .byte     8
#ENDDATA
    .byte     11
    .byte     9
    .byte     8
#ENDDATA
    .byte     11
    .byte     10
    .byte     10
#ENDDATA
    .byte     11
    .byte     11
    .byte     0
#ENDDATA
    .align    8
cc_tables.badexprs:
    .quad     1
    .quad     3
    .quad     0x1F
    .quad     0x18
    .quad     0x19
    .quad     0x1A
    .quad     0x1B
    .quad     0x1D
    .quad     0x20
    .quad     0x21
    .quad     0x22
    .quad     0x23
    .quad     0x24
    .quad     0x26
    .quad     0x25
    .quad     0x27
    .quad     0x28
    .quad     0x29
    .quad     0x2A
    .quad     0x2B
    .quad     0x2C
    .quad     0x2D
    .quad     0x2E
    .quad     0x2F
    .quad     0x30
    .quad     0x31
    .quad     0x32
    .quad     0x33
    .quad     0x34
    .quad     0x35
    .quad     0x36
    .quad     0x3A
    .quad     0x3B
    .quad     0x3C
    .align    8
cc_lex.tkptr:
    .quad     0
    .align    8
cc_lex.dowhitespace:
    .quad     0
    .bss
    .align    8
cc_lex.nincludes:
    .space    8
    .align    8
cc_lex.normaltkx:
    .space    32
    .data
    .align    8
cc_lex.normaltk:
    .quad     cc_lex.normaltkx
    .align    8
cc_lex.noexpand:
    .quad     0
    .bss
    .align    8
cc_lex.lx_stack:
    .space    480
    .align    8
cc_lex.lx_stackindex:
    .space    8
    .data
    .align    8
cc_lex.ifcondlevel:
    .quad     0
    .bss
    .align    8
cc_lex.headerpathlist:
    .space    160
cc_lex.headerpath:
    .space    300
    .align    8
cc_lex.lxstart:
    .space    8
    .align    8
cc_lex.lxsptr:
    .space    8
    .align    8
cc_lex.lxhashvalue:
    .space    8
    .align    8
cc_lex.lxsvalue:
    .space    8
cc_lex.alphamap:
    .space    256
cc_lex.digitmap:
    .space    256
cc_lex.commentmap:
    .space    256
cc_lex.linecommentmap:
    .space    256
cc_lex.spacemap:
    .space    256
    .align    8
cc_lex.destcopy:
    .space    8
    .align    8
cc_lex.pastedtokenlist:
    .space    696000
    .data
    .align    8
cc_lex.npastedtokens:
    .quad     0
    .align    8
cc_lex.isincludefile:
    .quad     0
    .align    8
cc_lex.firstsymbol:
    .quad     1
    .bss
    .align    8
cc_lex.reallxsptr:
    .space    8
    .align    8
cc_lex.nhstsymbols:
    .space    8
    .align    8
cc_lex.hstthreshold:
    .space    8
    .align    8
cc_lex.lex_preprocess_only.sbuffer:
    .space    16
    .data
    .align    8
cc_lex.lex_preprocess_only.dest:
    .quad     cc_lex.lex_preprocess_only.sbuffer
    .bss
cc_lex.getsourcefile.filespec:
    .space    300
    .data
    .align    8
cc_lex.lexm.doreset:
    .quad     0
    .align    8
cc_lex.lasttoken:
    .quad     0
    .bss
    .align    8
cc_lex.showtoken.buffer:
    .space    16
    .data
    .align    8
cc_lex.showtoken.dest:
    .quad     cc_lex.showtoken.buffer
    .bss
    .align    8
cc_lex.stringify.buffer:
    .space    16
    .data
    .align    8
cc_lex.stringify.deststr:
    .quad     cc_lex.stringify.buffer
    .align    8
cc_lex.expandpredefmacro.monthnames:
    .quad     L8218
    .quad     L8219
    .quad     L8220
    .quad     L8221
    .quad     L8222
    .quad     L8223
    .quad     L8224
    .quad     L8225
    .quad     L8226
    .quad     L8227
    .quad     L8228
    .quad     L8229
    .align    8
cc_lex.issimpleconstmacro.specialnames:
    .quad     L8230
    .quad     L8231
    .quad     L8232
    .bss
    .align    8
cc_parse.ist_symptr:
    .space    8
cc_parse.looptypestack:
    .space    64
    .align    8
cc_parse.loopindex:
    .space    8
    .align    8
cc_parse.casevaluestack:
    .space    512
    .data
cc_parse.ingeneric:
    .byte     0
    .bss
    .align    8
cc_genpcl.retindex:
    .space    8
    .align    8
cc_genpcl.initstaticsindex:
    .space    8
    .align    8
cc_genpcl.loopstack:
    .space    1600
    .align    8
cc_genpcl.loopindex:
    .space    8
    .align    8
cc_genpcl.zero_unit:
    .space    64
    .data
    .align    8
cc_genpcl.pzero:
    .quad     cc_genpcl.zero_unit
    .bss
    .align    8
cc_genpcl.nvarlocals:
    .space    8
    .align    8
cc_genpcl.nvarparams:
    .space    8
    .align    8
cc_blockpcl.continuestack:
    .space    512
    .align    8
cc_blockpcl.breakstack:
    .space    512
    .align    8
cc_blockpcl.loopindex:
    .space    8
    .align    8
cc_blockpcl.sw_labeltable:
    .space    8
    .align    8
cc_blockpcl.sw_valuetable:
    .space    8
    .align    8
cc_blockpcl.sw_lower:
    .space    8
    .align    8
cc_blockpcl.sw_ncases:
    .space    8
cc_blockpcl.sw_defaultseen:
    .space    1
    .align    8
cc_blockpcl.sw_defaultlabel:
    .space    8
    .align    8
cc_blockpcl.sw_breaklabel:
    .space    8
    .data
    .align    8
cc_lib.autotypeno:
    .quad     0
    .align    8
cc_lib.nextafindex:
    .quad     0
    .align    8
cc_lib.unitheapptr:
    .quad     0
    .align    8
cc_lib.remainingunits:
    .quad     0
    .bss
    .align    2
cc_lib.getoptocode.opctotable:
    .space    156
cc_lib.nextautotype.str:
    .space    32
cc_lib.getopcjname.str:
    .space    20
cc_lib.strmode.str:
    .space    16384
cc_lib.strmode2.str:
    .space    16384
cc_lib.typename.str:
    .space    300
cc_lib.getstname.name:
    .space    256
    .data
cc_support.bytemasks:
    .quad     0x8040201008040201
#ENDDATA
    .align    8
cc_headers.builtinheaders:
    .quad     1
    .align    8
cc_headers.h_assert:
    .quad     L8233
    .align    8
cc_headers.h_ctype:
    .quad     L8234
    .align    8
cc_headers.h_errno:
    .quad     L8235
    .align    8
cc_headers.h_fenv:
    .quad     L8236
    .align    8
cc_headers.h_float:
    .quad     L8237
    .align    8
cc_headers.h_inttypes:
    .quad     L8238
    .align    8
cc_headers.h_stdint:
    .quad     L8239
    .align    8
cc_headers.h_limits:
    .quad     L8240
    .align    8
cc_headers.h_locale:
    .quad     L8241
    .align    8
cc_headers.h__ansi:
    .quad     L8242
    .align    8
cc_headers.h_math:
    .quad     L8243
    .align    8
cc_headers.h_setjmp:
    .quad     L8244
    .align    8
cc_headers.h_signal:
    .quad     L8245
    .align    8
cc_headers.h_stdarg:
    .quad     L8246
    .align    8
cc_headers.h_stdbool:
    .quad     L8247
    .align    8
cc_headers.h_stddef:
    .quad     L8248
    .align    8
cc_headers.h_stdio:
    .quad     L8249
    .align    8
cc_headers.h_stdlib:
    .quad     L8250
    .align    8
cc_headers.h__syslist:
    .quad     L8251
    .align    8
cc_headers.h_string:
    .quad     L8252
    .align    8
cc_headers.h_time:
    .quad     L8253
    .align    8
cc_headers.h_utime:
    .quad     L8254
    .align    8
cc_headers.h_unistd:
    .quad     L8255
    .align    8
cc_headers.h_safelib:
    .quad     L8256
    .align    8
cc_headers.h_wchar:
    .quad     L8257
    .align    8
cc_headers.h_wctype:
    .quad     L8258
    .align    8
cc_headers.h_systypes:
    .quad     L8259
    .align    8
cc_headers.h_sysstat:
    .quad     L8260
    .align    8
cc_headers.h_systimeb:
    .quad     L8261
    .align    8
cc_headers.h_sysutime:
    .quad     L8262
    .align    8
cc_headers.h_memory:
    .quad     L8263
    .align    8
cc_headers.h_fcntl:
    .quad     L8264
    .align    8
cc_headers.h_io:
    .quad     L8265
    .align    8
cc_headers.h_direct:
    .quad     L8266
    .align    8
cc_headers.h_process:
    .quad     L8267
    .align    8
cc_headers.h_malloc:
    .quad     L8268
    .align    8
cc_headers.h_conio:
    .quad     L8269
    .align    8
cc_headers.h_winsock2:
    .quad     L8270
    .align    8
cc_headers.h__mingw:
    .quad     L8271
    .align    8
cc_headers.h_windowsx:
    .quad     L8272
    .align    8
cc_headers.stdhdrnames:
    .quad     L8273
    .quad     L8274
    .quad     L8275
    .quad     L8276
    .quad     L8277
    .quad     L8278
    .quad     L8279
    .quad     L8280
    .quad     L8281
    .quad     L8282
    .quad     L8283
    .quad     L8284
    .quad     L8285
    .quad     L8286
    .quad     L8287
    .quad     L8288
    .quad     L8289
    .quad     L8290
    .quad     L8291
    .quad     L8292
    .quad     L8293
    .quad     L8294
    .quad     L8295
    .quad     L8296
    .quad     L8297
    .quad     L8298
    .quad     L8299
    .quad     L8300
    .quad     L8301
    .quad     L8302
    .quad     L8303
    .quad     L8304
    .quad     L8305
    .quad     L8306
    .quad     L8307
    .quad     L8308
    .quad     L8309
    .quad     L8310
    .quad     L8311
    .quad     L8312
    .align    8
cc_headers.stdhdrtext:
    .quad     cc_headers.h_assert
    .quad     cc_headers.h_ctype
    .quad     cc_headers.h_errno
    .quad     cc_headers.h_fenv
    .quad     cc_headers.h_float
    .quad     cc_headers.h_inttypes
    .quad     cc_headers.h_stdint
    .quad     cc_headers.h_limits
    .quad     cc_headers.h_locale
    .quad     cc_headers.h__ansi
    .quad     cc_headers.h_math
    .quad     cc_headers.h_setjmp
    .quad     cc_headers.h_signal
    .quad     cc_headers.h_stdarg
    .quad     cc_headers.h_stdbool
    .quad     cc_headers.h_stddef
    .quad     cc_headers.h_stdio
    .quad     cc_headers.h_stdlib
    .quad     cc_headers.h__syslist
    .quad     cc_headers.h_string
    .quad     cc_headers.h_time
    .quad     cc_headers.h_utime
    .quad     cc_headers.h_unistd
    .quad     cc_headers.h_safelib
    .quad     cc_headers.h_wchar
    .quad     cc_headers.h_wctype
    .quad     cc_headers.h_systypes
    .quad     cc_headers.h_sysstat
    .quad     cc_headers.h_systimeb
    .quad     cc_headers.h_sysutime
    .quad     cc_headers.h_malloc
    .quad     cc_headers.h_fcntl
    .quad     cc_headers.h_io
    .quad     cc_headers.h_direct
    .quad     cc_headers.h_process
    .quad     cc_headers.h_memory
    .quad     cc_headers.h_conio
    .quad     cc_headers.h_winsock2
    .quad     cc_headers.h__mingw
    .quad     cc_headers.h_windowsx
    .bss
    .align    8
cc_show.currfileno:
    .space    8
    .align    8
cc_show.currlineno:
    .space    8
    .align    8
cc_show.sbuffer:
    .space    16
    .data
    .align    8
cc_show.dest:
    .quad     cc_show.sbuffer
    .bss
    .align    8
cc_show.destlinestart:
    .space    8
    .align    8
cc_show.exprstrvar:
    .space    16
    .data
    .align    8
cc_show.exprstr:
    .quad     cc_show.exprstrvar
    .bss
cc_show.getprefix.str:
    .space    512
cc_show.getdottedname.str:
    .space    256
cc_show.getlineinfok.str:
    .space    40
    .text
# Proc msys.start
msys.start:
#PROC1
#PROC2
#?>>
    .set msys.start.nargs, -8
    .set msys.start.args, -16
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    sub       %rsp,	8
    lea       %rax,	[%rip+msys.start.startupinfo]
    push      %rax
    lea       %rcx,	[%rbp + msys.start.nargs]
    lea       %rdx,	[%rbp + msys.start.args]
    lea       %r8,	[%rip+msys.envstrings]
    xor       %r9d,	%r9d
    sub       %rsp,	32
    call      __getmainargs
    add       %rsp,	48
    movsxd    %r10,	%eax
    mov       %rbx,	%r10
    movsxd    %rax,	dword ptr[%rbp + msys.start.nargs]
    mov       [%rip+msys.nsysparams],	%rax
    mov       %rax,	[%rip+msys.nsysparams]
    cmp       %rax,	128
    jle       L3
    lea       %rcx,	[%rip+L8313]
    call      printf
    mov       %rcx,	50
    call      exit
L3:
    movsxd    %rax,	dword ptr[%rbp + msys.start.nargs]
    mov       %rdi,	%rax
    mov       %r12,	1
    cmp       %rdi,	1
    jl        L6
L4:
    mov       %rax,	[%rbp + msys.start.args]
    mov       %r10,	%r12
    mov       %rax,	[%rax + %r10*8-8]
    lea       %r10,	[%rip+msys.sysparams]
    mov       %r11,	%r12
    mov       [%r10 + %r11*8-8],	%rax
    inc       %r12
    cmp       %r12,	%rdi
    jle       L4
L6:
    mov       %rax,	[%rip+msys.$cmdskip]
    inc       %rax
    mov       %r10,	[%rip+msys.nsysparams]
    sub       %r10,	%rax
    mov       [%rip+msys.ncmdparams],	%r10
    lea       %rax,	[%rip+msys.sysparams]
    mov       %r10,	[%rip+msys.$cmdskip]
    lea       %rax,	[%rax + %r10*8]
    mov       [%rip+msys.cmdparams],	%rax
    mov       %rsi,	1
    xor       %eax,	%eax
    mov       [%rip+msys.nenvstrings],	%rax
    jmp       L8
L7:
    inc       qword ptr[%rip+msys.nenvstrings]
    inc       %rsi
L8:
    mov       %rax,	[%rip+msys.envstrings]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8-8]
    test      %rax,	%rax
    jnz       L7
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.pushio
msys.pushio:
#PROC1
#PROC2
#?>>
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+msys.niostack]
    cmp       %rax,	10
    jl        L12
    lea       %rcx,	[%rip+L8314]
    call      printf
    mov       %rcx,	53
    call      exit
L12:
    inc       qword ptr[%rip+msys.niostack]
    mov       %rax,	[%rip+msys.outchan]
    lea       %r10,	[%rip+msys.outchan_stack]
    mov       %r11,	[%rip+msys.niostack]
    mov       [%r10 + %r11*8-8],	%rax
    mov       %rax,	[%rip+msys.outdev]
    lea       %r10,	[%rip+msys.outdev_stack]
    mov       %r11,	[%rip+msys.niostack]
    mov       [%r10 + %r11*8-8],	%rax
    mov       %rax,	[%rip+msys.fmtstr]
    lea       %r10,	[%rip+msys.fmtstr_stack]
    mov       %r11,	[%rip+msys.niostack]
    mov       [%r10 + %r11*8-8],	%rax
    mov       %al,	[%rip+msys.needgap]
    lea       %r10,	[%rip+msys.needgap_stack]
    mov       %r11,	[%rip+msys.niostack]
    mov       [%r10 + %r11-1],	%al
    xor       %eax,	%eax
    mov       [%rip+msys.needgap],	%rax
    xor       %eax,	%eax
    mov       [%rip+msys.fmtstr],	%rax
    xor       %eax,	%eax
    mov       [%rip+msys.outchan],	%rax
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc msys.m$print_startfile
msys.m$print_startfile:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    call      msys.pushio
    mov       [%rip+msys.outchan],	%rdi
    test      %rdi,	%rdi
    jz        L15
    mov       %rax,	2
    mov       [%rip+msys.outdev],	%rax
    jmp       L14
L15:
    mov       %rax,	1
    mov       [%rip+msys.outdev],	%rax
L14:
    call      msys.resetprintbuffer
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_startstr
msys.m$print_startstr:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    call      msys.pushio
    mov       %rax,	%rbx
    lea       %r10,	[%rip+msys.ptr_stack]
    mov       %r11,	[%rip+msys.niostack]
    mov       [%r10 + %r11*8-8],	%rax
    lea       %rax,	[%rip+msys.ptr_stack]
    mov       %r10,	[%rip+msys.niostack]
    lea       %rax,	[%rax + %r10*8-8]
    mov       %rdi,	%rax
    mov       [%rip+msys.outchan],	%rdi
    mov       %rax,	3
    mov       [%rip+msys.outdev],	%rax
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_startptr
msys.m$print_startptr:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    call      msys.pushio
    mov       [%rip+msys.outchan],	%rdi
    mov       %rax,	3
    mov       [%rip+msys.outdev],	%rax
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_startcon
msys.m$print_startcon:
#PROC1
#PROC2
#?>>
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    call      msys.pushio
    mov       %rax,	1
    mov       [%rip+msys.outdev],	%rax
    call      msys.resetprintbuffer
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc msys.m$print_setfmt
msys.m$print_setfmt:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       [%rip+msys.fmtstr],	%rcx
#---------------
    ret       
# End 
# Proc msys.m$print_end
msys.m$print_end:
#PROC1
#PROC2
#?>>
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    xor       %eax,	%eax
    mov       [%rip+msys.needgap],	%rax
    mov       %rcx,	1
    call      msys.nextfmtchars
    mov       %rax,	[%rip+msys.niostack]
    cmp       %rax,	1
    jnz       L22
    mov       %rax,	[%rip+msys.outdev]
    cmp       %rax,	1
    jz        L23
    cmp       %rax,	2
    jnz       L22
L23:
    call      msys.dumpprintbuffer
L22:
    mov       %rax,	[%rip+msys.niostack]
    test      %rax,	%rax
    jz        L20
L25:
    lea       %rax,	[%rip+msys.outchan_stack]
    mov       %r10,	[%rip+msys.niostack]
    mov       %rax,	[%rax + %r10*8-8]
    mov       [%rip+msys.outchan],	%rax
    lea       %rax,	[%rip+msys.outdev_stack]
    mov       %r10,	[%rip+msys.niostack]
    mov       %rax,	[%rax + %r10*8-8]
    mov       [%rip+msys.outdev],	%rax
    lea       %rax,	[%rip+msys.fmtstr_stack]
    mov       %r10,	[%rip+msys.niostack]
    mov       %rax,	[%rax + %r10*8-8]
    mov       [%rip+msys.fmtstr],	%rax
    lea       %rax,	[%rip+msys.needgap_stack]
    mov       %r10,	[%rip+msys.niostack]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       [%rip+msys.needgap],	%rax
    dec       qword ptr[%rip+msys.niostack]
L20:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc msys.m$print_ptr
msys.m$print_ptr:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    test      %rbx,	%rbx
    jnz       L28
    lea       %rax,	[%rip+L8315]
    mov       %rbx,	%rax
L28:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      msys.m$print_u64
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_ptr_nf
msys.m$print_ptr_nf:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      msys.m$print_ptr
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_i64
msys.m$print_i64:
#PROC1
#PROC2
#?>>
    .set msys.m$print_i64.s, -40
    .set msys.m$print_i64.fmt, -56
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	88
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
#PROC3
#PROC4
    xor       %ecx,	%ecx
    call      msys.nextfmtchars
    test      %rsi,	%rsi
    jnz       L32
    cmp       %rbx,	0
    jl        L34
    mov       %rcx,	%rbx
    lea       %rdx,	[%rbp + msys.m$print_i64.s]
    mov       %r8,	10
    xor       %r9d,	%r9d
    call      msys.u64tostr
    mov       %rdi,	%rax
    jmp       L33
L34:
    mov       %rax,	%rbx
    mov       %r10,	-9223372036854775808
    cmp       %rax,	%r10
    jnz       L35
    lea       %rax,	[%rip+msys.defaultfmt]
    lea       %r10,	[%rbp + msys.m$print_i64.fmt]
    movdqu    %XMM4,	[%rax]
    movdqu    [%r10],	%XMM4
    jmp       L36
L35:
    mov       %al,	45
    mov       [%rbp + msys.m$print_i64.s],	%al
    lea       %rax,	[%rbp + msys.m$print_i64.s+1]
    mov       %r10,	%rbx
    neg       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    mov       %r8,	10
    xor       %r9d,	%r9d
    call      msys.u64tostr
    inc       %rax
    mov       %rdi,	%rax
L33:
    lea       %rcx,	[%rbp + msys.m$print_i64.s]
    mov       %rdx,	%rdi
    call      msys.printstr_n
    jmp       L31
L32:
    mov       %rcx,	%rsi
    mov       %rdx,	-1
    lea       %r8,	[%rbp + msys.m$print_i64.fmt]
    call      msys.strtofmt
    movzx     %rax,	byte ptr[%rbp + msys.m$print_i64.fmt+14]
    cmp       %rax,	86
    jnz       L38
    mov       [%rip+msys.fmtparam],	%rbx
    xor       %eax,	%eax
    mov       [%rip+msys.needgap],	%rax
    jmp       L37
L38:
#msys.m$print_i64.dofmt:
L36:
    mov       %rcx,	%rbx
    lea       %rdx,	[%rbp + msys.m$print_i64.fmt]
    call      msys.tostr_i64
L37:
L31:
    mov       %rax,	1
    mov       [%rip+msys.needgap],	%rax
#---------------
    add       %rsp,	88
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_i64_nf
msys.m$print_i64_nf:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      msys.m$print_i64
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_bool
msys.m$print_bool:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    test      %rdi,	%rdi
    jz        L42
    lea       %rcx,	[%rip+L8316]
    mov       %rdx,	%rbx
    call      msys.m$print_str
    jmp       L41
L42:
    lea       %rcx,	[%rip+L8317]
    mov       %rdx,	%rbx
    call      msys.m$print_str
L41:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_u64
msys.m$print_u64:
#PROC1
#PROC2
#?>>
    .set msys.m$print_u64.s, -40
    .set msys.m$print_u64.fmt, -56
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	96
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    xor       %ecx,	%ecx
    call      msys.nextfmtchars
    test      %rbx,	%rbx
    jnz       L45
    lea       %rcx,	[%rbp + msys.m$print_u64.s]
    lea       %rdx,	[%rip+L8318]
    mov       %r8,	%rdi
    call      sprintf
    lea       %rcx,	[%rbp + msys.m$print_u64.s]
    call      msys.printstr
    jmp       L44
L45:
    mov       %rcx,	%rbx
    mov       %rdx,	-1
    lea       %r8,	[%rbp + msys.m$print_u64.fmt]
    call      msys.strtofmt
    mov       %rcx,	%rdi
    lea       %rdx,	[%rbp + msys.m$print_u64.fmt]
    call      msys.tostr_u64
L44:
    mov       %rax,	1
    mov       [%rip+msys.needgap],	%rax
#---------------
    add       %rsp,	96
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_r64
msys.m$print_r64:
#PROC1
#PROC2
#?>>
    .set msys.m$print_r64.s, -360
    .set msys.m$print_r64.fmt, -376
    push      %rdi
    movq      %rax,	%XMM15
    push      %rax
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	416
    movq      %XMM15,	%XMM0
    mov       %rdi,	%rdx
#---------------
#PROC3
#PROC4
    xor       %ecx,	%ecx
    call      msys.nextfmtchars
    test      %rdi,	%rdi
    jnz       L48
    lea       %rcx,	[%rbp + msys.m$print_r64.s]
    lea       %rdx,	[%rip+L8319]
    movq      %XMM2,	%XMM15
    movq      %r8,	%XMM2
    call      sprintf
    lea       %rcx,	[%rbp + msys.m$print_r64.s]
    call      msys.printstr
    jmp       L47
L48:
    mov       %rcx,	%rdi
    mov       %rdx,	-1
    lea       %r8,	[%rbp + msys.m$print_r64.fmt]
    call      msys.strtofmt
    movq      %XMM0,	%XMM15
    lea       %rdx,	[%rbp + msys.m$print_r64.fmt]
    call      msys.tostr_r64
L47:
    mov       %rax,	1
    mov       [%rip+msys.needgap],	%rax
#---------------
    add       %rsp,	416
    pop       %rbp
    pop       %rcx
    movq      %XMM15,	%rcx
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_r32
msys.m$print_r32:
#PROC1
#PROC2
#?>>
    .set msys.m$print_r32.s, -360
    .set msys.m$print_r32.fmt, -376
    push      %rdi
    movq      %rax,	%XMM15
    push      %rax
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	416
    movq      %XMM15,	%XMM0
    mov       %rdi,	%rdx
#---------------
#PROC3
#PROC4
    xor       %ecx,	%ecx
    call      msys.nextfmtchars
    test      %rdi,	%rdi
    jnz       L51
    movq      %XMM4,	%XMM15
    cvtss2sd  %XMM4,	%XMM4
    lea       %rcx,	[%rbp + msys.m$print_r32.s]
    lea       %rdx,	[%rip+L8319]
    movq      %XMM2,	%XMM4
    movq      %r8,	%XMM2
    call      sprintf
    lea       %rcx,	[%rbp + msys.m$print_r32.s]
    call      msys.printstr
    jmp       L50
L51:
    mov       %rcx,	%rdi
    mov       %rdx,	-1
    lea       %r8,	[%rbp + msys.m$print_r32.fmt]
    call      msys.strtofmt
    movq      %XMM4,	%XMM15
    cvtss2sd  %XMM4,	%XMM4
    movq      %XMM0,	%XMM4
    lea       %rdx,	[%rbp + msys.m$print_r32.fmt]
    call      msys.tostr_r64
L50:
    mov       %rax,	1
    mov       [%rip+msys.needgap],	%rax
#---------------
    add       %rsp,	416
    pop       %rbp
    pop       %rcx
    movq      %XMM15,	%rcx
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_c8
msys.m$print_c8:
#PROC1
#PROC2
#?>>
    .set msys.m$print_c8.a, 40
    .set msys.m$print_c8.s, -32
    .set msys.m$print_c8.fmt, -48
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	88
    mov       [%rbp+40],	%rcx
    mov       %rsi,	%rdx
#---------------
#PROC3
#PROC4
    xor       %bl,	%bl
    xor       %ecx,	%ecx
    call      msys.nextfmtchars
    test      %rsi,	%rsi
    jz        L54
    mov       %rcx,	%rsi
    mov       %rdx,	-1
    lea       %r8,	[%rbp + msys.m$print_c8.fmt]
    call      msys.strtofmt
    mov       %bl,	[%rbp + msys.m$print_c8.fmt+12]
L54:
    movzx     %rax,	%bl
    cmp       %rax,	77
    jnz       L56
    lea       %rcx,	[%rbp + msys.m$print_c8.a]
    mov       %rdx,	8
    lea       %r8,	[%rbp + msys.m$print_c8.s]
    lea       %r9,	[%rbp + msys.m$print_c8.fmt]
    call      msys.domultichar
    mov       %rdi,	%rax
    jmp       L55
L56:
    mov       %rax,	[%rbp + msys.m$print_c8.a]
    mov       [%rbp + msys.m$print_c8.s],	%rax
    xor       %eax,	%eax
    mov       [%rbp + msys.m$print_c8.s+8],	%al
    lea       %rcx,	[%rbp + msys.m$print_c8.s]
    call      msys.getutfsize
    mov       %rdi,	%rax
L55:
    lea       %rcx,	[%rbp + msys.m$print_c8.s]
    mov       %rdx,	%rdi
    call      msys.printstr_n
    mov       %rax,	1
    mov       [%rip+msys.needgap],	%rax
#---------------
    add       %rsp,	88
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_str
msys.m$print_str:
#PROC1
#PROC2
#?>>
    .set msys.m$print_str.fmt, -16
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    xor       %ecx,	%ecx
    call      msys.nextfmtchars
    test      %rdi,	%rdi
    jnz       L59
    lea       %rcx,	[%rip+L8320]
    call      msys.printstr
    jmp       L57
L59:
    test      %rbx,	%rbx
    jnz       L61
    mov       %rcx,	%rdi
    call      msys.printstr
    jmp       L60
L61:
    mov       %rcx,	%rbx
    mov       %rdx,	-1
    lea       %r8,	[%rbp + msys.m$print_str.fmt]
    call      msys.strtofmt
    mov       %rcx,	%rdi
    mov       %rdx,	-1
    lea       %r8,	[%rbp + msys.m$print_str.fmt]
    call      msys.tostr_str
L60:
    mov       %rax,	1
    mov       [%rip+msys.needgap],	%rax
L57:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_strn
msys.m$print_strn:
#PROC1
#PROC2
#?>>
    .set msys.m$print_strn.fmt, -16
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	56
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
#PROC3
#PROC4
    xor       %ecx,	%ecx
    call      msys.nextfmtchars
    test      %rdi,	%rdi
    jnz       L64
    lea       %rcx,	[%rip+L8320]
    call      msys.printstr
    jmp       L62
L64:
    test      %rsi,	%rsi
    jnz       L66
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      msys.printstr_n
    jmp       L65
L66:
    mov       %rcx,	%rsi
    mov       %rdx,	-1
    lea       %r8,	[%rbp + msys.m$print_strn.fmt]
    call      msys.strtofmt
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    lea       %r8,	[%rbp + msys.m$print_strn.fmt]
    call      msys.tostr_str
L65:
    mov       %rax,	1
    mov       [%rip+msys.needgap],	%rax
L62:
#---------------
    add       %rsp,	56
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_str_nf
msys.m$print_str_nf:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      msys.m$print_str
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc msys.m$print_strsl
msys.m$print_strsl:
#PROC1
#PROC2
#?>>
    .set msys.m$print_strsl.s, 16
    .set msys.m$print_strsl.fmtstyle, 24
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    lea       %rcx,	[%rip+L8321]
    call      mlib.abortprogram
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc msys.m$print_newline
msys.m$print_newline:
#PROC1
#PROC2
#?>>
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    xor       %eax,	%eax
    mov       [%rip+msys.needgap],	%rax
    mov       %rcx,	1
    call      msys.nextfmtchars
    lea       %rcx,	[%rip+L8322]
    call      msys.printstr
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc msys.m$print_nogap
msys.m$print_nogap:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    xor       %eax,	%eax
    mov       [%rip+msys.needgap],	%rax
#---------------
    ret       
# End 
# Proc msys.m$print_space
msys.m$print_space:
#PROC1
#PROC2
#?>>
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    xor       %eax,	%eax
    mov       [%rip+msys.needgap],	%rax
    lea       %rcx,	[%rip+L8323]
    call      msys.printstr
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc msys.printstr
msys.printstr:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    call      strlen
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      msys.printstr_n
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc msys.printstr_n
msys.printstr_n:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      msys.dumpstr
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.printstrn_app
msys.printstrn_app:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
#PROC3
#PROC4
    test      %rbx,	%rbx
    jz        L76
    test      %rsi,	%rsi
    jnz       L78
    lea       %rcx,	[%rip+L8324]
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      printf
    jmp       L77
L78:
    mov       %rcx,	%rsi
    lea       %rdx,	[%rip+L8324]
    mov       %r8,	%rbx
    mov       %r9,	%rdi
    call      fprintf
L77:
L76:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.printchar
msys.printchar:
#PROC1
#PROC2
#?>>
    .set msys.printchar.str, -8
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       [%rbp + msys.printchar.str],	%dil
    xor       %eax,	%eax
    mov       [%rbp + msys.printchar.str+1],	%al
    lea       %rcx,	[%rbp + msys.printchar.str]
    mov       %rdx,	1
    call      msys.printstr_n
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc msys.nextfmtchars
msys.nextfmtchars:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+msys.fmtstr]
    test      %rax,	%rax
    jnz       L82
    mov       %rax,	[%rip+msys.needgap]
    test      %rax,	%rax
    jz        L84
    mov       %rcx,	32
    call      msys.printchar
L84:
    xor       %eax,	%eax
    mov       [%rip+msys.needgap],	%rax
    jmp       L80
L82:
    mov       %rbx,	[%rip+msys.fmtstr]
    xor       %rsi,	%rsi
L85:
    mov       %rax,	[%rip+msys.fmtstr]
    mov       %dil,	[%rax]
    movzx     %rax,	%dil
    cmp       %rax,	35
    jz        L88
    test      %rax,	%rax
    jz        L89
    cmp       %rax,	126
    jz        L90
    jmp       L91
L88:
    test      %r12,	%r12
    jz        L93
    jmp       L94
L93:
    inc       qword ptr[%rip+msys.fmtstr]
    test      %rsi,	%rsi
    jz        L96
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      msys.printstr_n
L96:
    jmp       L80
L89:
    test      %rsi,	%rsi
    jz        L98
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      msys.printstr_n
    jmp       L97
L98:
    test      %r12,	%r12
    jnz       L99
    lea       %rcx,	[%rip+L8325]
    mov       %rdx,	1
    call      msys.printstr_n
L99:
L97:
    jmp       L80
L90:
    test      %rsi,	%rsi
    jz        L101
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      msys.printstr_n
    xor       %rsi,	%rsi
L101:
    inc       qword ptr[%rip+msys.fmtstr]
    mov       %rax,	[%rip+msys.fmtstr]
    mov       %dil,	[%rax]
    test      %dil,	%dil
    jz        L103
    inc       qword ptr[%rip+msys.fmtstr]
    movzx     %rax,	%dil
    mov       %rcx,	%rax
    call      msys.printchar
L103:
    mov       %rbx,	[%rip+msys.fmtstr]
    jmp       L87
L91:
#msys.nextfmtchars.skip:
L94:
    inc       %rsi
    inc       qword ptr[%rip+msys.fmtstr]
L87:
    jmp       L85
L80:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.strtofmt
msys.strtofmt:
#PROC1
#PROC2
#?>>
    .set msys.strtofmt.str, -104
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	136
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       %r15,	%r8
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rip+msys.defaultfmt]
    movdqu    %XMM4,	[%rax]
    movdqu    [%r15],	%XMM4
    test      %r13,	%r13
    jnz       L106
    jmp       L104
L106:
    cmp       %r14,	-1
    jnz       L108
    mov       %rcx,	%r13
    call      strlen
    mov       %r14,	%rax
L108:
    lea       %rcx,	[%rbp + msys.strtofmt.str]
    mov       %rdx,	%r13
    mov       %r8,	%r14
    call      memcpy
    xor       %eax,	%eax
    mov       [%rbp + %r14 + msys.strtofmt.str],	%al
    lea       %rax,	[%rbp + msys.strtofmt.str]
    mov       %r13,	%rax
    xor       %sil,	%sil
    jmp       L110
L109:
    movzx     %rax,	byte ptr[%r13]
    mov       %rdi,	%rax
    inc       %r13
    cmp       %rdi,	65
    jnz       L113
    mov       %al,	65
    mov       [%r15+8],	%al
    jmp       L112
L113:
    cmp       %rdi,	97
    jnz       L114
    mov       %al,	97
    mov       [%r15+8],	%al
    jmp       L112
L114:
    mov       %rcx,	%rdi
    call      toupper
    movsxd    %r10,	%eax
    sub       %r10,	66
    cmp       %r10,	25
    jae       L117
    lea       %rax,	[%rip+L116]
    jmp       [%rax + %r10*8]
    .data
L116:
    .quad     L118
    .quad     L147
    .quad     L146
    .quad     L143
    .quad     L144
    .quad     L145
    .quad     L119
    .quad     L117
    .quad     L129
    .quad     L117
    .quad     L117
    .quad     L148
    .quad     L151
    .quad     L120
    .quad     L136
    .quad     L128
    .quad     L117
    .quad     L133
    .quad     L139
    .quad     L142
    .quad     L149
    .quad     L117
    .quad     L121
    .quad     L150
    .quad     L132
    .text
L118:
    mov       %al,	2
    mov       [%r15+2],	%al
    jmp       L115
L119:
    mov       %al,	16
    mov       [%r15+2],	%al
    jmp       L115
L120:
    mov       %al,	8
    mov       [%r15+2],	%al
    jmp       L115
L121:
    xor       %rbx,	%rbx
L122:
    movzx     %rax,	byte ptr[%r13]
    mov       %rdi,	%rax
    mov       %rax,	%rdi
    cmp       %rax,	48
    jl        L125
    cmp       %rax,	57
    jg        L125
    mov       %rax,	%rbx
    shl       %rax,	1
    lea       %rax,	[%rax + %rax*4]
    add       %rax,	%rdi
    sub       %rax,	48
    mov       %rbx,	%rax
    inc       %r13
    jmp       L124
L125:
    jmp       L123
L124:
    jmp       L122
L123:
    mov       %rax,	%rbx
    cmp       %rax,	2
    jl        L127
    cmp       %rax,	16
    jg        L127
    mov       [%r15+2],	%bl
L127:
    jmp       L115
L128:
    mov       %al,	34
    mov       [%r15+3],	%al
    jmp       L115
L129:
    movzx     %rax,	byte ptr[%r13]
    mov       %rcx,	%rax
    call      toupper
    mov       [%r15+9],	%al
    mov       %al,	[%r13]
    test      %al,	%al
    jz        L131
    inc       %r13
L131:
    jmp       L115
L132:
    mov       %al,	48
    mov       [%r15+4],	%al
    jmp       L115
L133:
    mov       %al,	[%r13]
    mov       [%r15+7],	%al
    mov       %al,	[%r13]
    test      %al,	%al
    jz        L135
    inc       %r13
L135:
    jmp       L115
L136:
    mov       %al,	[%r13]
    mov       [%r15+4],	%al
    mov       %al,	[%r13]
    test      %al,	%al
    jz        L138
    inc       %r13
L138:
    jmp       L115
L139:
    mov       %al,	[%r13]
    mov       [%r15+10],	%al
    mov       %al,	[%r13]
    test      %al,	%al
    jz        L141
    inc       %r13
L141:
    jmp       L115
L142:
    mov       %al,	87
    mov       [%r15+11],	%al
    jmp       L115
L143:
    mov       %al,	101
    mov       [%r15+5],	%al
    jmp       L115
L144:
    mov       %al,	102
    mov       [%r15+5],	%al
    jmp       L115
L145:
    mov       %al,	103
    mov       [%r15+5],	%al
    jmp       L115
L146:
    mov       %al,	68
    mov       [%r15+13],	%al
    jmp       L115
L147:
    mov       %al,	67
    mov       [%r15+12],	%al
    jmp       L115
L148:
    mov       %al,	77
    mov       [%r15+12],	%al
    jmp       L115
L149:
    mov       %al,	86
    mov       [%r15+14],	%al
    jmp       L115
L150:
    lea       %rax,	[%r15+15]
    or        byte ptr[%rax],	1
    jmp       L115
L151:
    lea       %rax,	[%r15+15]
    or        byte ptr[%rax],	2
    jmp       L115
L117:
    mov       %rax,	%rdi
    cmp       %rax,	46
    jz        L153
    cmp       %rax,	44
    jz        L154
    cmp       %rax,	95
    jz        L154
    cmp       %rax,	43
    jz        L155
    cmp       %rax,	126
    jz        L156
    cmp       %rax,	42
    jz        L157
    jmp       L158
L153:
    mov       %sil,	1
    jmp       L152
L154:
    mov       [%r15+7],	%dil
    jmp       L152
L155:
    mov       %al,	43
    mov       [%r15+6],	%al
    jmp       L152
L156:
    mov       %al,	126
    mov       [%r15+3],	%al
    jmp       L152
L157:
    mov       %r12,	[%rip+msys.fmtparam]
    jmp       L159
L158:
    cmp       %rdi,	48
    jl        L161
    cmp       %rdi,	57
    jg        L161
    lea       %rax,	[%rdi-48]
    mov       %r12,	%rax
L162:
    movzx     %rax,	byte ptr[%r13]
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%r13]
    test      %rax,	%rax
    jz        L163
L165:
    cmp       %rdi,	48
    jl        L167
    cmp       %rdi,	57
    jg        L167
    inc       %r13
    mov       %rax,	%r12
    shl       %rax,	1
    lea       %rax,	[%rax + %rax*4]
    add       %rax,	%rdi
    sub       %rax,	48
    mov       %r12,	%rax
    jmp       L166
L167:
    jmp       L163
L166:
    jmp       L162
L163:
#msys.strtofmt.gotwidth:
L159:
    test      %sil,	%sil
    jnz       L169
    mov       [%r15],	%r12b
    mov       %sil,	1
    jmp       L168
L169:
    mov       [%r15+1],	%r12b
L168:
L161:
L152:
L115:
L112:
L110:
    mov       %al,	[%r13]
    test      %al,	%al
    jnz       L109
L104:
#---------------
    add       %rsp,	136
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.domultichar
msys.domultichar:
#PROC1
#PROC2
#?>>
    .set msys.domultichar.fmt, 88
    .set msys.domultichar.str, -24
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	64
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
    mov       [%rbp+88],	%r9
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rbp + msys.domultichar.str]
    mov       %rdi,	%rax
    mov       %rbx,	%r13
    mov       %rsi,	%r13
    cmp       %rsi,	0
    jle       L173
L171:
    movzx     %rax,	byte ptr[%r12]
    test      %rax,	%rax
    jz        L173
L175:
    mov       %al,	[%r12]
    mov       [%rdi],	%al
    inc       %rdi
    inc       %r12
    dec       %rsi
    jnz       L171
L173:
    xor       %eax,	%eax
    mov       [%rdi],	%al
    lea       %rcx,	[%rbp + msys.domultichar.str]
    call      strlen
    lea       %rcx,	[%rbp + msys.domultichar.str]
    mov       %rdx,	%r14
    mov       %r8,	%rax
    mov       %r9,	[%rbp + msys.domultichar.fmt]
    call      msys.expandstr
L170:
#---------------
    add       %rsp,	64
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.expandstr
msys.expandstr:
#PROC1
#PROC2
#?>>
    .set msys.expandstr.n, 80
    .set msys.expandstr.fmt, 88
    .set msys.expandstr.av_2, -8
    .set msys.expandstr.av_3, -16
    .set msys.expandstr.av_4, -24
    .set msys.expandstr.av_5, -32
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	64
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       [%rbp+80],	%r8
    mov       [%rbp+88],	%r9
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rbp + msys.expandstr.fmt]
    movzx     %rax,	byte ptr[%rax]
    mov       %rbx,	%rax
    test      %rbx,	%rbx
    jz        L179
    cmp       %rbx,	[%rbp + msys.expandstr.n]
    jg        L178
L179:
    mov       %rcx,	%r14
    mov       %rdx,	%r13
    mov       %r8,	[%rbp + msys.expandstr.n]
    call      strncpy
    xor       %eax,	%eax
    mov       %r10,	[%rbp + msys.expandstr.n]
    mov       [%r14 + %r10],	%al
    mov       %rax,	[%rbp + msys.expandstr.n]
    jmp       L176
L178:
    mov       %rax,	[%rbp + msys.expandstr.fmt]
    movzx     %rax,	byte ptr[%rax+9]
    cmp       %rax,	76
    jnz       L181
    mov       %rcx,	%r14
    mov       %rdx,	%r13
    mov       %r8,	[%rbp + msys.expandstr.n]
    call      strncpy
    mov       %rax,	[%rbp + msys.expandstr.n]
    add       %r14,	%rax
    mov       %rdi,	1
    mov       %rax,	%rbx
    sub       %rax,	[%rbp + msys.expandstr.n]
    mov       %r12,	%rax
    cmp       %r12,	1
    jl        L184
L182:
    mov       %rax,	[%rbp + msys.expandstr.fmt]
    mov       %al,	[%rax+4]
    mov       [%r14],	%al
    inc       %r14
    inc       %rdi
    cmp       %rdi,	%r12
    jle       L182
L184:
    xor       %eax,	%eax
    mov       [%r14],	%al
    jmp       L180
L181:
    mov       %rax,	[%rbp + msys.expandstr.fmt]
    movzx     %rax,	byte ptr[%rax+9]
    cmp       %rax,	82
    jnz       L185
    mov       %rax,	[%rbp + msys.expandstr.fmt]
    movzx     %rax,	byte ptr[%rax+4]
    cmp       %rax,	48
    jnz       L187
    mov       %rax,	[%rbp + msys.expandstr.fmt]
    mov       %al,	[%rax+2]
    test      %al,	%al
    jz        L187
    movzx     %rax,	byte ptr[%r13]
    cmp       %rax,	45
    jz        L188
    movzx     %rax,	byte ptr[%r13]
    cmp       %rax,	43
    jnz       L187
L188:
    mov       %al,	[%r13]
    mov       [%r14],	%al
    inc       %r14
    mov       %rax,	%rbx
    sub       %rax,	[%rbp + msys.expandstr.n]
    mov       [%rbp + msys.expandstr.av_2],	%rax
    mov       %rax,	[%rbp + msys.expandstr.av_2]
    cmp       %rax,	0
    jle       L191
L189:
    mov       %rax,	[%rbp + msys.expandstr.fmt]
    mov       %al,	[%rax+4]
    mov       [%r14],	%al
    inc       %r14
    dec       qword ptr[%rbp + msys.expandstr.av_2]
    jnz       L189
L191:
    mov       %rax,	[%rbp + msys.expandstr.n]
    dec       %rax
    lea       %r10,	[%r13+1]
    mov       %rcx,	%r14
    mov       %rdx,	%r10
    mov       %r8,	%rax
    call      strncpy
    mov       %rax,	[%rbp + msys.expandstr.n]
    lea       %r10,	[%r14 + %rax]
    sub       %r10,	1
    xor       %eax,	%eax
    mov       [%r10],	%al
    jmp       L186
L187:
    mov       %rax,	%rbx
    sub       %rax,	[%rbp + msys.expandstr.n]
    mov       [%rbp + msys.expandstr.av_3],	%rax
    mov       %rax,	[%rbp + msys.expandstr.av_3]
    cmp       %rax,	0
    jle       L194
L192:
    mov       %rax,	[%rbp + msys.expandstr.fmt]
    mov       %al,	[%rax+4]
    mov       [%r14],	%al
    inc       %r14
    dec       qword ptr[%rbp + msys.expandstr.av_3]
    jnz       L192
L194:
    mov       %rcx,	%r14
    mov       %rdx,	%r13
    mov       %r8,	[%rbp + msys.expandstr.n]
    call      strncpy
    xor       %eax,	%eax
    mov       %r10,	[%rbp + msys.expandstr.n]
    mov       [%r14 + %r10],	%al
L186:
    jmp       L180
L185:
    mov       %rax,	%rbx
    sub       %rax,	[%rbp + msys.expandstr.n]
    inc       %rax
    sar       %rax,	1
    mov       %rsi,	%rax
    mov       [%rbp + msys.expandstr.av_4],	%rsi
    mov       %rax,	[%rbp + msys.expandstr.av_4]
    cmp       %rax,	0
    jle       L197
L195:
    mov       %rax,	[%rbp + msys.expandstr.fmt]
    mov       %al,	[%rax+4]
    mov       [%r14],	%al
    inc       %r14
    dec       qword ptr[%rbp + msys.expandstr.av_4]
    jnz       L195
L197:
    mov       %rcx,	%r14
    mov       %rdx,	%r13
    mov       %r8,	[%rbp + msys.expandstr.n]
    call      strncpy
    mov       %rax,	[%rbp + msys.expandstr.n]
    add       %r14,	%rax
    mov       %rax,	%rbx
    sub       %rax,	[%rbp + msys.expandstr.n]
    sub       %rax,	%rsi
    mov       [%rbp + msys.expandstr.av_5],	%rax
    mov       %rax,	[%rbp + msys.expandstr.av_5]
    cmp       %rax,	0
    jle       L200
L198:
    mov       %rax,	[%rbp + msys.expandstr.fmt]
    mov       %al,	[%rax+4]
    mov       [%r14],	%al
    inc       %r14
    dec       qword ptr[%rbp + msys.expandstr.av_5]
    jnz       L198
L200:
    xor       %eax,	%eax
    mov       [%r14],	%al
L180:
    mov       %rax,	%rbx
L176:
#---------------
    add       %rsp,	64
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.u64tostr
msys.u64tostr:
#PROC1
#PROC2
#?>>
    .set msys.u64tostr.t, -360
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	368
#---------------
#PROC3
#PROC4
    xor       %rbx,	%rbx
    xor       %eax,	%eax
    mov       %r12,	%rax
    cmp       %r8,	10
    jnz       L203
    mov       %rax,	3
    jmp       L202
L203:
    mov       %rax,	4
L202:
    mov       %r13,	%rax
L204:
    mov       %rax,	%rcx
    mov       %r10,	%r8
    push      %rdx
    xor       %edx,	%edx
    div       %r10
    xchg      %rax,	%rdx
    pop       %rdx
    mov       %rdi,	%rax
    mov       %rax,	%rcx
    mov       %r10,	%r8
    push      %rdx
    xor       %edx,	%edx
    div       %r10
    pop       %rdx
    mov       %rcx,	%rax
    lea       %rax,	[%rip+msys.digits]
    mov       %r10,	%rdi
    mov       %al,	[%rax + %r10]
    inc       %rbx
    mov       %r10,	%rbx
    mov       [%rbp + %r10 + msys.u64tostr.t],	%al
    inc       %r12
    test      %r9,	%r9
    jz        L208
    test      %rcx,	%rcx
    jz        L208
    cmp       %r12,	%r13
    jnz       L208
    inc       %rbx
    mov       %rax,	%rbx
    mov       %r10b,	%r9b
    mov       [%rbp + %rax + msys.u64tostr.t],	%r10b
    xor       %r12,	%r12
L208:
    test      %rcx,	%rcx
    jnz       L204
    mov       %rsi,	%rbx
    mov       %r14,	%rdx
    jmp       L210
L209:
    mov       %rax,	%rbx
    dec       %rbx
    mov       %al,	[%rbp + %rax + msys.u64tostr.t]
    mov       [%rdx],	%al
    inc       %rdx
L210:
    test      %rbx,	%rbx
    jnz       L209
    xor       %eax,	%eax
    mov       [%rdx],	%al
    mov       %rax,	%rsi
L201:
#---------------
    add       %rsp,	368
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.i64tostrfmt
msys.i64tostrfmt:
#PROC1
#PROC2
#?>>
    .set msys.i64tostrfmt.str, -360
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	392
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
#PROC3
#PROC4
    xor       %rbx,	%rbx
    mov       %al,	[%r13+11]
    test      %al,	%al
    jz        L214
    mov       %rbx,	1
L214:
    mov       %rax,	%rsi
    mov       %r10,	-9223372036854775808
    cmp       %rax,	%r10
    jnz       L216
    test      %rbx,	%rbx
    jnz       L216
    mov       %al,	45
    mov       [%rbp + msys.i64tostrfmt.str],	%al
    movzx     %rax,	byte ptr[%r13+7]
    movzx     %r10,	byte ptr[%r13+2]
    lea       %r11,	[%rbp + msys.i64tostrfmt.str+1]
    mov       %rcx,	%r11
    mov       %rdx,	%r10
    mov       %r8,	%rax
    call      msys.i64mintostr
    inc       %rax
    mov       %rdi,	%rax
    jmp       L215
L216:
    test      %rbx,	%rbx
    jnz       L220
    cmp       %rsi,	0
    jl        L219
L220:
    mov       %al,	[%r13+6]
    test      %al,	%al
    jz        L218
L219:
    cmp       %rsi,	0
    jge       L222
    mov       %rax,	%rsi
    neg       %rax
    mov       %rsi,	%rax
    mov       %al,	45
    mov       [%rbp + msys.i64tostrfmt.str],	%al
    jmp       L221
L222:
    mov       %al,	43
    mov       [%rbp + msys.i64tostrfmt.str],	%al
L221:
    movzx     %rax,	byte ptr[%r13+7]
    movzx     %r10,	byte ptr[%r13+2]
    lea       %r11,	[%rbp + msys.i64tostrfmt.str+1]
    mov       %rcx,	%rsi
    mov       %rdx,	%r11
    mov       %r8,	%r10
    mov       %r9,	%rax
    call      msys.u64tostr
    inc       %rax
    mov       %rdi,	%rax
    jmp       L217
L218:
    movzx     %rax,	byte ptr[%r13+7]
    movzx     %r10,	byte ptr[%r13+2]
    mov       %rcx,	%rsi
    lea       %rdx,	[%rbp + msys.i64tostrfmt.str]
    mov       %r8,	%r10
    mov       %r9,	%rax
    call      msys.u64tostr
    mov       %rdi,	%rax
L217:
L215:
    mov       %al,	[%r13+10]
    test      %al,	%al
    jz        L224
    mov       %al,	[%r13+10]
    mov       [%rbp + %rdi + msys.i64tostrfmt.str],	%al
    inc       %rdi
    mov       %rax,	%rdi
    xor       %r10d,	%r10d
    mov       [%rbp + %rax + msys.i64tostrfmt.str],	%r10b
L224:
    movzx     %rax,	byte ptr[%r13+2]
    cmp       %rax,	10
    jg        L227
    mov       %al,	[%r13+10]
    test      %al,	%al
    jz        L226
L227:
    movzx     %rax,	byte ptr[%r13+8]
    cmp       %rax,	97
    jnz       L226
    lea       %rcx,	[%rbp + msys.i64tostrfmt.str]
    call      mlib.convlcstring
L226:
    lea       %rcx,	[%rbp + msys.i64tostrfmt.str]
    mov       %rdx,	%r12
    mov       %r8,	%rdi
    mov       %r9,	%r13
    call      msys.expandstr
L212:
#---------------
    add       %rsp,	392
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.u64tostrfmt
msys.u64tostrfmt:
#PROC1
#PROC2
#?>>
    .set msys.u64tostrfmt.str, -360
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	400
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%r12+7]
    movzx     %r10,	byte ptr[%r12+2]
    mov       %rcx,	%rbx
    lea       %rdx,	[%rbp + msys.u64tostrfmt.str]
    mov       %r8,	%r10
    mov       %r9,	%rax
    call      msys.u64tostr
    mov       %rdi,	%rax
    mov       %al,	[%r12+10]
    test      %al,	%al
    jz        L230
    mov       %al,	[%r12+10]
    mov       [%rbp + %rdi + msys.u64tostrfmt.str],	%al
    inc       %rdi
    mov       %rax,	%rdi
    xor       %r10d,	%r10d
    mov       [%rbp + %rax + msys.u64tostrfmt.str],	%r10b
L230:
    movzx     %rax,	byte ptr[%r12+2]
    cmp       %rax,	10
    jg        L233
    mov       %al,	[%r12+10]
    test      %al,	%al
    jz        L232
    movzx     %rax,	byte ptr[%r12+8]
    cmp       %rax,	97
    jnz       L232
L233:
L232:
    lea       %rcx,	[%rbp + msys.u64tostrfmt.str]
    mov       %rdx,	%rsi
    mov       %r8,	%rdi
    mov       %r9,	%r12
    call      msys.expandstr
L228:
#---------------
    add       %rsp,	400
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.i64mintostr
msys.i64mintostr:
#PROC1
#PROC2
#?>>
    .set msys.i64mintostr.t, -360
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	392
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       %r15,	%r8
#---------------
#PROC3
#PROC4
    mov       %rax,	%r14
    cmp       %rax,	10
    jz        L236
    cmp       %rax,	16
    jz        L237
    cmp       %rax,	2
    jz        L238
    jmp       L239
L236:
    lea       %rax,	[%rbp + msys.i64mintostr.t]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8326]
    call      strcpy
    mov       %rbx,	3
    jmp       L235
L237:
    lea       %rax,	[%rbp + msys.i64mintostr.t]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8327]
    call      strcpy
    mov       %rbx,	1
    jmp       L235
L238:
    lea       %rax,	[%rbp + msys.i64mintostr.t]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8328]
    call      strcpy
    mov       %rbx,	7
    jmp       L235
L239:
    lea       %rax,	[%rbp + msys.i64mintostr.t]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8329]
    call      strcpy
L235:
    lea       %rax,	[%rbp + msys.i64mintostr.t]
    mov       %rcx,	%rax
    call      strlen
    mov       %rdi,	%rax
    mov       %rax,	%rdi
    add       %r13,	%rax
    test      %r15,	%r15
    jz        L241
    mov       %rax,	%rbx
    add       %r13,	%rax
L241:
    xor       %eax,	%eax
    mov       [%r13],	%al
    xor       %rsi,	%rsi
    mov       %rax,	%r14
    cmp       %rax,	10
    jnz       L243
    mov       %rax,	3
    jmp       L242
L243:
    mov       %rax,	4
L242:
    mov       %r12,	%rax
    jmp       L245
L244:
    dec       %r13
    mov       %rax,	%rdi
    dec       %rdi
    mov       %al,	[%rbp + %rax + msys.i64mintostr.t-1]
    mov       [%r13],	%al
    test      %r15,	%r15
    jz        L248
    test      %rdi,	%rdi
    jz        L248
    inc       %rsi
    cmp       %rsi,	%r12
    jnz       L248
    dec       %r13
    mov       [%r13],	%r15b
    xor       %rsi,	%rsi
L248:
L245:
    test      %rdi,	%rdi
    jnz       L244
    mov       %rcx,	%r13
    call      strlen
L234:
#---------------
    add       %rsp,	392
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.strtostrfmt
msys.strtostrfmt:
#PROC1
#PROC2
#?>>
    .set msys.strtostrfmt.n, 80
    .set msys.strtostrfmt.fmt, 88
    .set msys.strtostrfmt.str, -256
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	288
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       [%rbp+80],	%r8
    mov       [%rbp+88],	%r9
#---------------
#PROC3
#PROC4
    xor       %r12,	%r12
    mov       %rax,	[%rbp + msys.strtostrfmt.fmt]
    mov       %al,	[%rax+3]
    test      %al,	%al
    jnz       L252
    mov       %rax,	[%rbp + msys.strtostrfmt.fmt]
    mov       %al,	[%rax+8]
    test      %al,	%al
    jz        L251
L252:
    mov       %rax,	[%rbp + msys.strtostrfmt.n]
    cmp       %rax,	256
    jge       L254
    lea       %rax,	[%rbp + msys.strtostrfmt.str]
    mov       %rdi,	%rax
    jmp       L253
L254:
    mov       %rax,	[%rbp + msys.strtostrfmt.n]
    add       %rax,	3
    mov       %r12,	%rax
    mov       %rcx,	%r12
    call      mlib.pcm_alloc
    mov       %rdi,	%rax
L253:
    mov       %rax,	[%rbp + msys.strtostrfmt.fmt]
    mov       %al,	[%rax+3]
    test      %al,	%al
    jz        L256
    mov       %rbx,	%rdi
    mov       %rax,	[%rbp + msys.strtostrfmt.fmt]
    mov       %al,	[%rax+3]
    mov       [%rbx],	%al
    inc       %rbx
    mov       %rax,	[%rbp + msys.strtostrfmt.n]
    test      %rax,	%rax
    jz        L258
    mov       %rcx,	%rbx
    mov       %rdx,	%r13
    call      strcpy
    mov       %rax,	[%rbp + msys.strtostrfmt.n]
    add       %rbx,	%rax
L258:
    mov       %rax,	[%rbp + msys.strtostrfmt.fmt]
    mov       %al,	[%rax+3]
    mov       [%rbx],	%al
    inc       %rbx
    xor       %eax,	%eax
    mov       [%rbx],	%al
    mov       %rax,	2
    add       [%rbp + msys.strtostrfmt.n],	%rax
    jmp       L255
L256:
    mov       %rcx,	%rdi
    mov       %rdx,	%r13
    mov       %r8,	[%rbp + msys.strtostrfmt.n]
    call      memcpy
L255:
    mov       %rax,	[%rbp + msys.strtostrfmt.fmt]
    movzx     %rax,	byte ptr[%rax+8]
    cmp       %rax,	97
    jz        L260
    cmp       %rax,	65
    jz        L261
    jmp       L262
L260:
    mov       %rcx,	%rdi
    call      mlib.convlcstring
    jmp       L259
L261:
    mov       %rcx,	%rdi
    call      mlib.convucstring
L262:
L259:
    mov       %r13,	%rdi
L251:
    mov       %rax,	[%rbp + msys.strtostrfmt.fmt]
    movzx     %rax,	byte ptr[%rax]
    mov       %rsi,	%rax
    cmp       %rsi,	[%rbp + msys.strtostrfmt.n]
    jle       L264
    mov       %rcx,	%r13
    mov       %rdx,	%r14
    mov       %r8,	[%rbp + msys.strtostrfmt.n]
    mov       %r9,	[%rbp + msys.strtostrfmt.fmt]
    call      msys.expandstr
    mov       [%rbp + msys.strtostrfmt.n],	%rax
    jmp       L263
L264:
    mov       %rcx,	%r14
    mov       %rdx,	%r13
    mov       %r8,	[%rbp + msys.strtostrfmt.n]
    call      memcpy
L263:
    test      %r12,	%r12
    jz        L266
    mov       %rcx,	%rdi
    mov       %rdx,	%r12
    call      mlib.pcm_free
L266:
    mov       %rax,	[%rbp + msys.strtostrfmt.n]
L249:
#---------------
    add       %rsp,	288
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.tostr_i64
msys.tostr_i64:
#PROC1
#PROC2
#?>>
    .set msys.tostr_i64.a, 32
    .set msys.tostr_i64.str, -360
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	400
    mov       [%rbp+32],	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rbx+12]
    test      %rax,	%rax
    jz        L269
    cmp       %rax,	77
    jz        L270
    jmp       L271
L269:
    mov       %rcx,	[%rbp + msys.tostr_i64.a]
    lea       %rdx,	[%rbp + msys.tostr_i64.str]
    mov       %r8,	%rbx
    call      msys.i64tostrfmt
    mov       %rdi,	%rax
    jmp       L268
L270:
    lea       %rcx,	[%rbp + msys.tostr_i64.a]
    mov       %rdx,	8
    lea       %r8,	[%rbp + msys.tostr_i64.str]
    mov       %r9,	%rbx
    call      msys.domultichar
    mov       %rdi,	%rax
    jmp       L268
L271:
    mov       %rcx,	[%rbp + msys.tostr_i64.a]
    xor       %edx,	%edx
    call      msys.m$print_c8
    jmp       L267
L268:
    lea       %rcx,	[%rbp + msys.tostr_i64.str]
    mov       %rdx,	%rdi
    call      msys.printstr_n
L267:
#---------------
    add       %rsp,	400
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.tostr_u64
msys.tostr_u64:
#PROC1
#PROC2
#?>>
    .set msys.tostr_u64.a, 32
    .set msys.tostr_u64.str, -360
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	400
    mov       [%rbp+32],	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rbx+12]
    cmp       %rax,	77
    jz        L274
    cmp       %rax,	67
    jz        L275
    jmp       L276
L274:
    lea       %rcx,	[%rbp + msys.tostr_u64.a]
    mov       %rdx,	8
    lea       %r8,	[%rbp + msys.tostr_u64.str]
    mov       %r9,	%rbx
    call      msys.domultichar
    mov       %rdi,	%rax
    jmp       L273
L275:
    mov       %rcx,	[%rbp + msys.tostr_u64.a]
    xor       %edx,	%edx
    call      msys.m$print_c8
    jmp       L272
L276:
    mov       %rcx,	[%rbp + msys.tostr_u64.a]
    lea       %rdx,	[%rbp + msys.tostr_u64.str]
    mov       %r8,	%rbx
    call      msys.u64tostrfmt
    mov       %rdi,	%rax
L273:
    lea       %rcx,	[%rbp + msys.tostr_u64.str]
    mov       %rdx,	%rdi
    call      msys.printstr_n
L272:
#---------------
    add       %rsp,	400
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.tostr_r64
msys.tostr_r64:
#PROC1
#PROC2
#?>>
    .set msys.tostr_r64.str, -360
    .set msys.tostr_r64.str2, -720
    .set msys.tostr_r64.cfmt, -736
    push      %rdi
    push      %rbx
    movq      %rax,	%XMM15
    push      %rax
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	776
    movq      %XMM15,	%XMM0
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    mov       %al,	37
    mov       [%rbp + msys.tostr_r64.cfmt],	%al
    mov       %al,	[%rbx+1]
    test      %al,	%al
    jz        L279
    mov       %al,	46
    mov       [%rbp + msys.tostr_r64.cfmt+1],	%al
    mov       %al,	42
    mov       [%rbp + msys.tostr_r64.cfmt+2],	%al
    mov       %al,	[%rbx+5]
    mov       [%rbp + msys.tostr_r64.cfmt+3],	%al
    xor       %eax,	%eax
    mov       [%rbp + msys.tostr_r64.cfmt+4],	%al
    movsx     %rax,	byte ptr[%rbx+1]
    lea       %rcx,	[%rbp + msys.tostr_r64.str]
    lea       %rdx,	[%rbp + msys.tostr_r64.cfmt]
    mov       %r8,	%rax
    movq      %XMM3,	%XMM15
    movq      %r9,	%XMM3
    call      sprintf
    jmp       L278
L279:
    mov       %al,	[%rbx+5]
    mov       [%rbp + msys.tostr_r64.cfmt+1],	%al
    xor       %eax,	%eax
    mov       [%rbp + msys.tostr_r64.cfmt+2],	%al
    lea       %rcx,	[%rbp + msys.tostr_r64.str]
    lea       %rdx,	[%rbp + msys.tostr_r64.cfmt]
    movq      %XMM2,	%XMM15
    movq      %r8,	%XMM2
    call      sprintf
L278:
    lea       %rcx,	[%rbp + msys.tostr_r64.str]
    call      strlen
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rbx]
    mov       %r10,	%rdi
    cmp       %r10,	%rax
    jge       L281
    lea       %rcx,	[%rbp + msys.tostr_r64.str]
    lea       %rdx,	[%rbp + msys.tostr_r64.str2]
    mov       %r8,	%rdi
    mov       %r9,	%rbx
    call      msys.expandstr
    mov       %rdi,	%rax
    lea       %rcx,	[%rbp + msys.tostr_r64.str]
    lea       %rdx,	[%rbp + msys.tostr_r64.str2]
    call      strcpy
L281:
    lea       %rcx,	[%rbp + msys.tostr_r64.str]
    mov       %rdx,	%rdi
    call      msys.printstr_n
#---------------
    add       %rsp,	776
    pop       %rbp
    pop       %rcx
    movq      %XMM15,	%rcx
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.tostr_str
msys.tostr_str:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
#---------------
#PROC3
#PROC4
    cmp       %r13,	-1
    jnz       L284
    mov       %rcx,	%r12
    call      strlen
    mov       %r13,	%rax
L284:
    mov       %rdi,	%r13
    mov       %al,	[%r14+3]
    test      %al,	%al
    jnz       L287
    movzx     %rax,	byte ptr[%r14]
    cmp       %rax,	%rdi
    jg        L287
    mov       %al,	[%r14+8]
    test      %al,	%al
    jnz       L287
    mov       %al,	[%r14+1]
    test      %al,	%al
    jz        L286
L287:
    mov       %al,	[%r14+3]
    test      %al,	%al
    jz        L289
    mov       %rax,	2
    add       %rdi,	%rax
L289:
    movzx     %rax,	byte ptr[%r14]
    cmp       %rax,	%rdi
    jle       L291
    movzx     %rax,	byte ptr[%r14]
    mov       %rdi,	%rax
L291:
    lea       %rax,	[%rdi+1]
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       %rsi,	%rax
    mov       %rcx,	%r12
    mov       %rdx,	%rsi
    mov       %r8,	%r13
    mov       %r9,	%r14
    call      msys.strtostrfmt
    mov       %rbx,	%rax
    mov       %al,	[%r14+1]
    test      %al,	%al
    jz        L293
    movsx     %rax,	byte ptr[%r14+1]
    cmp       %rbx,	%rax
    jle       L8330
    mov       %rbx,	%rax
L8330:
L293:
    mov       %rcx,	%rsi
    mov       %rdx,	%rbx
    call      msys.printstr_n
    lea       %rax,	[%rdi+1]
    mov       %rcx,	%rsi
    mov       %rdx,	%rax
    call      mlib.pcm_free
    jmp       L285
L286:
    mov       %rcx,	%r12
    mov       %rdx,	%r13
    call      msys.printstr_n
L285:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.getfmt
msys.getfmt:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    test      %rdi,	%rdi
    jz        L296
    mov       %rcx,	%rdi
    mov       %rdx,	-1
    lea       %r8,	[%rip+msys.getfmt.fmt]
    call      msys.strtofmt
    lea       %rax,	[%rip+msys.getfmt.fmt]
    jmp       L295
L296:
    lea       %rax,	[%rip+msys.defaultfmt]
L295:
L294:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc msys.strint
msys.strint:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
#PROC3
#PROC4
    lea       %rcx,	[%rip+msys.strint.str]
    call      msys.m$print_startstr
    mov       %rcx,	%rsi
    call      msys.getfmt
    mov       %r10,	%rax
    mov       %rdi,	%r10
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      msys.tostr_i64
    call      msys.m$print_end
    lea       %rcx,	[%rip+msys.strint.str]
    mov       %rdx,	%rdi
    call      msys.getstr
L297:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.getstrint
msys.getstrint:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rbx
    call      msys.m$print_startstr
    xor       %ecx,	%ecx
    call      msys.getfmt
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      msys.tostr_i64
    call      msys.m$print_end
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.strword
msys.strword:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
#PROC3
#PROC4
    lea       %rcx,	[%rip+msys.strword.str]
    call      msys.m$print_startstr
    mov       %rcx,	%rsi
    call      msys.getfmt
    mov       %r10,	%rax
    mov       %rdi,	%r10
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      msys.tostr_u64
    call      msys.m$print_end
    lea       %rcx,	[%rip+msys.strword.str]
    mov       %rdx,	%rdi
    call      msys.getstr
L299:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.strreal
msys.strreal:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    movq      %rax,	%XMM15
    push      %rax
#?]]
    sub       %rsp,	48
    movq      %XMM15,	%XMM0
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    lea       %rcx,	[%rip+msys.strreal.str]
    call      msys.m$print_startstr
    mov       %rcx,	%rbx
    call      msys.getfmt
    mov       %r10,	%rax
    mov       %rdi,	%r10
    movq      %XMM0,	%XMM15
    mov       %rdx,	%rax
    call      msys.tostr_r64
    call      msys.m$print_end
    lea       %rcx,	[%rip+msys.strreal.str]
    mov       %rdx,	%rdi
    call      msys.getstr
L300:
#---------------
    add       %rsp,	48
    pop       %rcx
    movq      %XMM15,	%rcx
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.getstr
msys.getstr:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    mov       %al,	[%rbx+13]
    test      %al,	%al
    jz        L303
    mov       %rcx,	%rdi
    call      mlib.pcm_copyheapstring
    jmp       L302
L303:
    mov       %rax,	%rdi
L302:
L301:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.initreadbuffer
msys.initreadbuffer:
#PROC1
#PROC2
#?>>
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+msys.rd_buffer]
    test      %rax,	%rax
    jnz       L304
L306:
    mov       %rcx,	16384
    call      mlib.pcm_alloc
    mov       [%rip+msys.rd_buffer],	%rax
    xor       %eax,	%eax
    mov       %r10,	[%rip+msys.rd_buffer]
    mov       [%r10],	%al
    mov       %rax,	[%rip+msys.rd_buffer]
    mov       [%rip+msys.rd_lastpos],	%rax
    mov       [%rip+msys.rd_pos],	%rax
L304:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc msys.m$read_conline
msys.m$read_conline:
#PROC1
#PROC2
#?>>
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    call      msys.initreadbuffer
    xor       %ecx,	%ecx
    mov       %rdx,	[%rip+msys.rd_buffer]
    mov       %r8,	16384
    call      mlib.readlinen
    mov       %rcx,	[%rip+msys.rd_buffer]
    call      strlen
    mov       [%rip+msys.rd_length],	%rax
    mov       %rax,	[%rip+msys.rd_buffer]
    mov       [%rip+msys.rd_pos],	%rax
    xor       %eax,	%eax
    mov       [%rip+msys.rd_lastpos],	%rax
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc msys.m$read_fileline
msys.m$read_fileline:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    call      msys.initreadbuffer
    cmp       %rdi,	1
    jnz       L310
    lea       %rcx,	[%rip+L8331]
    call      mlib.abortprogram
    jmp       L308
L310:
    mov       %rcx,	%rdi
    mov       %rdx,	[%rip+msys.rd_buffer]
    mov       %r8,	16384
    call      mlib.readlinen
    mov       %rcx,	[%rip+msys.rd_buffer]
    call      strlen
    mov       [%rip+msys.rd_length],	%rax
    mov       %rax,	[%rip+msys.rd_buffer]
    mov       [%rip+msys.rd_pos],	%rax
    xor       %eax,	%eax
    mov       [%rip+msys.rd_lastpos],	%rax
L308:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc msys.m$read_strline
msys.m$read_strline:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    call      msys.initreadbuffer
    mov       %rcx,	%rbx
    call      strlen
    mov       %rdi,	%rax
    cmp       %rdi,	16384
    jge       L313
    mov       %rcx,	[%rip+msys.rd_buffer]
    mov       %rdx,	%rbx
    call      strcpy
    jmp       L312
L313:
    mov       %rcx,	[%rip+msys.rd_buffer]
    mov       %rdx,	%rbx
    mov       %r8,	16383
    call      memcpy
    mov       %rax,	[%rip+msys.rd_buffer]
    lea       %rax,	[%rax+16384]
    sub       %rax,	1
    xor       %r10d,	%r10d
    mov       [%rax],	%r10b
L312:
    mov       [%rip+msys.rd_length],	%rdi
    mov       %rax,	[%rip+msys.rd_buffer]
    mov       [%rip+msys.rd_pos],	%rax
    xor       %eax,	%eax
    mov       [%rip+msys.rd_lastpos],	%rax
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.readitem
msys.readitem:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r14,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+msys.rd_buffer]
    test      %rax,	%rax
    jnz       L316
    call      msys.initreadbuffer
L316:
    mov       %rbx,	[%rip+msys.rd_pos]
    jmp       L318
L317:
    inc       %rbx
L318:
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	32
    jz        L317
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	9
    jz        L317
    mov       %rsi,	%rbx
    mov       %rax,	%rbx
    mov       [%rip+msys.rd_pos],	%rax
    mov       [%rip+msys.rd_lastpos],	%rax
    movzx     %rax,	byte ptr[%rbx]
    test      %rax,	%rax
    jnz       L321
    xor       %eax,	%eax
    mov       [%rip+msys.termchar],	%rax
    xor       %eax,	%eax
    mov       [%r14],	%rax
    mov       %rax,	%rbx
    jmp       L314
L321:
    xor       %r12b,	%r12b
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	34
    jnz       L323
    mov       %r12b,	34
    inc       %rbx
    jmp       L322
L323:
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	39
    jnz       L324
    mov       %r12b,	39
    inc       %rbx
L324:
L322:
    mov       %rax,	%rbx
    mov       %rsi,	%rax
    mov       %rdi,	%rax
    jmp       L326
L325:
    mov       %rax,	%rbx
    inc       %rbx
    mov       %r13b,	[%rax]
    movzx     %rax,	%r13b
    cmp       %rax,	32
    jz        L329
    cmp       %rax,	9
    jz        L329
    cmp       %rax,	44
    jz        L329
    cmp       %rax,	61
    jnz       L330
L329:
    test      %r12b,	%r12b
    jnz       L333
    cmp       %rdi,	%rbx
    jnz       L332
L333:
    jmp       L334
L332:
    movzx     %rax,	%r13b
    mov       [%rip+msys.termchar],	%rax
    jmp       L327
L330:
#msys.readitem.normalchar:
L334:
    movzx     %rax,	%r13b
    movzx     %r10,	%r12b
    cmp       %rax,	%r10
    jnz       L336
    movzx     %rax,	byte ptr[%rbx]
    movzx     %r10,	%r12b
    cmp       %rax,	%r10
    jnz       L338
    mov       [%rdi],	%r13b
    inc       %rbx
    inc       %rdi
    jmp       L337
L338:
    movzx     %rax,	byte ptr[%rbx]
    mov       [%rip+msys.termchar],	%rax
    mov       %rax,	[%rip+msys.termchar]
    cmp       %rax,	44
    jz        L341
    cmp       %rax,	61
    jnz       L340
L341:
    inc       %rbx
    movzx     %rax,	byte ptr[%rbx]
    mov       [%rip+msys.termchar],	%rax
L340:
    jmp       L327
L337:
    jmp       L335
L336:
    mov       [%rdi],	%r13b
    inc       %rdi
L335:
L328:
L326:
    mov       %al,	[%rbx]
    test      %al,	%al
    jnz       L325
L327:
    movzx     %rax,	byte ptr[%rbx]
    test      %rax,	%rax
    jnz       L343
    xor       %eax,	%eax
    mov       [%rip+msys.termchar],	%rax
L343:
    mov       %rax,	%rdi
    sub       %rax,	%rsi
    mov       [%r14],	%rax
    mov       [%rip+msys.rd_pos],	%rbx
    mov       %rax,	%rsi
L314:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.strtoint
msys.strtoint:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       %r15,	%r8
#---------------
#PROC3
#PROC4
    xor       %eax,	%eax
    mov       [%rip+msys.itemerror],	%rax
    cmp       %r14,	-1
    jnz       L346
    mov       %rcx,	%r13
    call      strlen
    mov       %r14,	%rax
L346:
    xor       %dil,	%dil
    mov       %rax,	%r14
    test      %rax,	%rax
    jz        L348
    movzx     %rax,	byte ptr[%r13]
    cmp       %rax,	45
    jnz       L348
    mov       %dil,	1
    inc       %r13
    dec       %r14
    jmp       L347
L348:
    test      %r14,	%r14
    jz        L349
    movzx     %rax,	byte ptr[%r13]
    cmp       %rax,	43
    jnz       L349
    inc       %r13
    dec       %r14
L349:
L347:
    xor       %rbx,	%rbx
    jmp       L351
L350:
    mov       %rax,	%r13
    inc       %r13
    movzx     %rax,	byte ptr[%rax]
    mov       %rsi,	%rax
    dec       %r14
    mov       %rax,	%rsi
    cmp       %rax,	65
    jl        L354
    cmp       %rax,	70
    jg        L354
    lea       %rax,	[%rsi-65]
    add       %rax,	10
    mov       %r12,	%rax
    jmp       L353
L354:
    mov       %rax,	%rsi
    cmp       %rax,	97
    jl        L355
    cmp       %rax,	102
    jg        L355
    lea       %rax,	[%rsi-97]
    add       %rax,	10
    mov       %r12,	%rax
    jmp       L353
L355:
    mov       %rax,	%rsi
    cmp       %rax,	48
    jl        L356
    cmp       %rax,	57
    jg        L356
    lea       %rax,	[%rsi-48]
    mov       %r12,	%rax
    jmp       L353
L356:
    mov       %rax,	%rsi
    cmp       %rax,	95
    jz        L358
    cmp       %rax,	39
    jnz       L357
L358:
    jmp       L351
L357:
    mov       %rax,	1
    mov       [%rip+msys.itemerror],	%rax
    jmp       L352
L353:
    cmp       %r12,	%r15
    jb        L360
    mov       %rax,	1
    mov       [%rip+msys.itemerror],	%rax
    jmp       L352
L360:
    mov       %rax,	%rbx
    mov       %r10,	%r15
    imul      %rax,	%r10
    add       %rax,	%r12
    mov       %rbx,	%rax
L351:
    test      %r14,	%r14
    jnz       L350
L352:
    test      %dil,	%dil
    jz        L362
    mov       %rax,	%rbx
    neg       %rax
    jmp       L361
L362:
    mov       %rax,	%rbx
L361:
L344:
#---------------
    add       %rsp,	48
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.m$read_i64
msys.m$read_i64:
#PROC1
#PROC2
#?>>
    .set msys.m$read_i64.length, -8
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rbx
    call      toupper
    movsxd    %r10,	%eax
    mov       %rbx,	%r10
    mov       %rax,	%rbx
    cmp       %rax,	67
    jz        L365
    cmp       %rax,	84
    jz        L366
    cmp       %rax,	69
    jz        L367
    jmp       L368
L365:
    mov       %rax,	[%rip+msys.rd_pos]
    mov       [%rip+msys.rd_lastpos],	%rax
    mov       %rax,	[%rip+msys.rd_pos]
    mov       %al,	[%rax]
    test      %al,	%al
    jz        L370
    mov       %rax,	[%rip+msys.rd_pos]
    inc       qword ptr[%rip+msys.rd_pos]
    movzx     %rax,	byte ptr[%rax]
    jmp       L363
L370:
    xor       %eax,	%eax
    jmp       L363
L369:
    jmp       L364
L366:
    mov       %rax,	[%rip+msys.termchar]
    jmp       L363
L367:
    mov       %rax,	[%rip+msys.itemerror]
    jmp       L363
L368:
L364:
    lea       %rcx,	[%rbp + msys.m$read_i64.length]
    call      msys.readitem
    mov       %rdi,	%rax
    mov       %rax,	%rbx
    test      %rax,	%rax
    jz        L372
    cmp       %rax,	73
    jz        L372
    cmp       %rax,	66
    jz        L373
    cmp       %rax,	72
    jz        L374
    jmp       L375
L372:
    mov       %rcx,	%rdi
    mov       %rdx,	[%rbp + msys.m$read_i64.length]
    mov       %r8,	10
    call      msys.strtoint
    jmp       L363
L373:
    mov       %rcx,	%rdi
    mov       %rdx,	[%rbp + msys.m$read_i64.length]
    mov       %r8,	2
    call      msys.strtoint
    jmp       L363
L374:
    mov       %rcx,	%rdi
    mov       %rdx,	[%rbp + msys.m$read_i64.length]
    mov       %r8,	16
    call      msys.strtoint
    jmp       L363
L375:
L371:
    xor       %eax,	%eax
L363:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.m$read_r64
msys.m$read_r64:
#PROC1
#PROC2
#?>>
    .set msys.m$read_r64.fmt, 24
    .set msys.m$read_r64.str, -512
    .set msys.m$read_r64.length, -520
    .set msys.m$read_r64.numlength, -528
    .set msys.m$read_r64.x, -536
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	568
#---------------
#PROC3
#PROC4
    lea       %rcx,	[%rbp + msys.m$read_r64.length]
    call      msys.readitem
    mov       %rdi,	%rax
    mov       %rax,	[%rbp + msys.m$read_r64.length]
    test      %rax,	%rax
    jz        L379
    mov       %rax,	[%rbp + msys.m$read_r64.length]
    cmp       %rax,	512
    jl        L378
L379:
    movq      %XMM0,	[%rip+L8332]
    jmp       L376
L378:
    lea       %rcx,	[%rbp + msys.m$read_r64.str]
    mov       %rdx,	%rdi
    mov       %r8,	[%rbp + msys.m$read_r64.length]
    call      memcpy
    xor       %eax,	%eax
    mov       %r10,	[%rbp + msys.m$read_r64.length]
    mov       [%rbp + %r10 + msys.m$read_r64.str],	%al
    xor       %eax,	%eax
    mov       [%rip+msys.itemerror],	%rax
    lea       %rcx,	[%rbp + msys.m$read_r64.str]
    lea       %rdx,	[%rip+L8333]
    lea       %r8,	[%rbp + msys.m$read_r64.x]
    lea       %r9,	[%rbp + msys.m$read_r64.numlength]
    call      sscanf
    movsxd    %r10,	%eax
    test      %r10,	%r10
    jz        L382
    movsxd    %rax,	dword ptr[%rbp + msys.m$read_r64.numlength]
    cmp       %rax,	[%rbp + msys.m$read_r64.length]
    jz        L381
L382:
    movq      %XMM4,	[%rip+L8334]
    movq      [%rbp + msys.m$read_r64.x],	%XMM4
    mov       %rax,	1
    mov       [%rip+msys.itemerror],	%rax
L381:
    movq      %XMM0,	[%rbp + msys.m$read_r64.x]
L376:
#---------------
    add       %rsp,	568
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc msys.m$read_str
msys.m$read_str:
#PROC1
#PROC2
#?>>
    .set msys.m$read_str.length, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
#PROC3
#PROC4
    xor       %eax,	%eax
    mov       [%rip+msys.itemerror],	%rax
    mov       %rax,	%r12
    cmp       %rax,	76
    jz        L386
    cmp       %rax,	108
    jnz       L385
L386:
    mov       %rdi,	[%rip+msys.rd_pos]
    mov       %rax,	[%rip+msys.rd_buffer]
    mov       %r10,	[%rip+msys.rd_length]
    lea       %rax,	[%rax + %r10]
    sub       %rax,	[%rip+msys.rd_pos]
    mov       [%rbp + msys.m$read_str.length],	%rax
    jmp       L384
L385:
    lea       %rcx,	[%rbp + msys.m$read_str.length]
    call      msys.readitem
    mov       %rdi,	%rax
    mov       %rax,	%r12
    cmp       %rax,	78
    jz        L389
    cmp       %rax,	110
    jnz       L388
L389:
    mov       %rcx,	%rdi
    mov       %rdx,	[%rbp + msys.m$read_str.length]
    call      mlib.iconvlcn
L388:
L384:
    cmp       %rsi,	0
    jle       L391
    mov       %rax,	[%rbp + msys.m$read_str.length]
    cmp       %rax,	%rsi
    jl        L393
    lea       %rax,	[%rsi-1]
    mov       [%rbp + msys.m$read_str.length],	%rax
    mov       %rax,	1
    mov       [%rip+msys.itemerror],	%rax
L393:
L391:
    mov       %rcx,	%rbx
    mov       %rdx,	%rdi
    mov       %r8,	[%rbp + msys.m$read_str.length]
    call      memcpy
    xor       %eax,	%eax
    mov       %r10,	[%rbp + msys.m$read_str.length]
    mov       [%rbx + %r10],	%al
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.readstr
msys.readstr:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    mov       %rdx,	%rsi
    mov       %r8,	%rbx
    call      msys.m$read_str
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.rereadln
msys.rereadln:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+msys.rd_buffer]
    mov       [%rip+msys.rd_pos],	%rax
    mov       %rax,	[%rip+msys.rd_pos]
    mov       [%rip+msys.rd_lastpos],	%rax
#---------------
    ret       
# End 
# Proc msys.reread
msys.reread:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+msys.rd_lastpos]
    mov       [%rip+msys.rd_pos],	%rax
#---------------
    ret       
# End 
# Proc msys.valint
msys.valint:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r12,	%rcx
    mov       %r13,	%rdx
#---------------
#PROC3
#PROC4
    call      msys.initreadbuffer
    mov       %rdi,	[%rip+msys.rd_pos]
    mov       %rbx,	[%rip+msys.rd_lastpos]
    mov       [%rip+msys.rd_pos],	%r12
    mov       %rcx,	%r13
    call      msys.m$read_i64
    mov       %rsi,	%rax
    mov       [%rip+msys.rd_pos],	%rdi
    mov       [%rip+msys.rd_lastpos],	%rbx
    mov       %rax,	%rsi
L397:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.valreal
msys.valreal:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    movq      %rax,	%XMM15
    push      %rax
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
#---------------
#PROC3
#PROC4
    call      msys.initreadbuffer
    mov       %rdi,	[%rip+msys.rd_pos]
    mov       %rbx,	[%rip+msys.rd_lastpos]
    mov       [%rip+msys.rd_pos],	%rsi
    xor       %ecx,	%ecx
    call      msys.m$read_r64
    movq      %XMM15,	%XMM0
    mov       [%rip+msys.rd_pos],	%rdi
    mov       [%rip+msys.rd_lastpos],	%rbx
    movq      %XMM0,	%XMM15
L398:
#---------------
    add       %rsp,	40
    pop       %rcx
    movq      %XMM15,	%rcx
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.mclunimpl
msys.mclunimpl:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    lea       %rcx,	[%rip+L8335]
    mov       %rdx,	%rdi
    call      printf
    mov       %rcx,	1
    call      exit
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc msys.dumpstr
msys.dumpstr:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+msys.outdev]
    cmp       %rax,	3
    jnz       L402
    mov       %rdi,	[%rip+msys.outchan]
    test      %rsi,	%rsi
    jz        L404
    mov       %rax,	[%rdi]
    mov       %rcx,	%rax
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      memcpy
    mov       %rax,	%rdi
    mov       %r10,	%rsi
    add       [%rax],	%r10
L404:
    mov       %rax,	[%rdi]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10b
    jmp       L400
L402:
    test      %rsi,	%rsi
    jnz       L406
    jmp       L400
L406:
    test      %r12,	%r12
    jz        L408
    cmp       %rsi,	2
    jl        L408
    mov       %rax,	[%rip+msys.outdev]
    cmp       %rax,	1
    jnz       L408
    dec       qword ptr[%rip+msys.printptr]
    mov       %rax,	[%rip+msys.printptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	10
    jnz       L410
    mov       %rax,	[%rip+msys.printptr]
    sub       %rax,	1
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	13
    jnz       L412
    mov       %rax,	[%rip+msys.printptr]
    sub       %rax,	1
    xor       %r10d,	%r10d
    mov       [%rax],	%r10b
    jmp       L411
L412:
    xor       %eax,	%eax
    mov       %r10,	[%rip+msys.printptr]
    mov       [%r10],	%al
L411:
    lea       %rcx,	[%rip+msys.printbuffer]
    call      puts
    jmp       L400
L410:
L408:
    mov       %rax,	[%rip+msys.outdev]
    cmp       %rax,	1
    jz        L414
    cmp       %rax,	2
    jz        L415
    jmp       L416
L414:
    lea       %rcx,	[%rip+L8336]
    mov       %rdx,	%rsi
    mov       %r8,	%rbx
    call      printf
    jmp       L413
L415:
    mov       %rcx,	[%rip+msys.outchan]
    lea       %rdx,	[%rip+L8336]
    mov       %r8,	%rsi
    mov       %r9,	%rbx
    call      fprintf
L416:
L413:
L400:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.dumpprintbuffer
msys.dumpprintbuffer:
#PROC1
#PROC2
#?>>
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+msys.printlen]
    test      %rax,	%rax
    jz        L419
    lea       %rcx,	[%rip+msys.printbuffer]
    mov       %rdx,	[%rip+msys.printlen]
    mov       %r8,	1
    call      msys.dumpstr
L419:
    call      msys.resetprintbuffer
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc msys.resetprintbuffer
msys.resetprintbuffer:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rip+msys.printbuffer]
    mov       [%rip+msys.printptr],	%rax
    xor       %eax,	%eax
    mov       [%rip+msys.printlen],	%rax
#---------------
    ret       
# End 
# Proc msys.addtobuffer
msys.addtobuffer:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+msys.printlen]
    add       %rax,	%rbx
    cmp       %rax,	4088
    jl        L423
    call      msys.dumpprintbuffer
L423:
    cmp       %rbx,	4096
    jge       L425
    mov       %rcx,	[%rip+msys.printptr]
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      memcpy
    mov       %rax,	%rbx
    add       [%rip+msys.printptr],	%rax
    mov       %rax,	%rbx
    add       [%rip+msys.printlen],	%rax
    jmp       L421
L425:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      msys.dumpstr
L421:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.m$power_i64
msys.m$power_i64:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    cmp       %rbx,	0
    jge       L428
    xor       %eax,	%eax
    jmp       L427
L428:
    test      %rbx,	%rbx
    jnz       L429
    mov       %rax,	1
    jmp       L427
L429:
    cmp       %rbx,	1
    jnz       L430
    mov       %rax,	%rdi
    jmp       L427
L430:
    mov       %rax,	%rbx
    and       %rax,	1
    jnz       L431
    mov       %rax,	%rbx
    sar       %rax,	1
    mov       %r10,	%rdi
    imul      %r10,	%r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      msys.m$power_i64
    jmp       L427
L431:
    lea       %rax,	[%rbx-1]
    sar       %rax,	1
    mov       %r10,	%rdi
    imul      %r10,	%r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      msys.m$power_i64
    mov       %r10,	%rdi
    imul      %rax,	%r10
L427:
L426:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msys.getutfsize
msys.getutfsize:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	16
#---------------
#PROC3
#PROC4
    mov       %rax,	%rcx
    inc       %rcx
    movzx     %rax,	byte ptr[%rax]
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L434
    xor       %eax,	%eax
    jmp       L433
L434:
    mov       %eax,	%edi
    shr       %eax,	7
    and       %eax,	1
    test      %rax,	%rax
    jnz       L435
    mov       %rax,	1
    jmp       L433
L435:
    mov       %rax,	%rdi
    shr       %rax,	5
    and       %rax,	7
    cmp       %rax,	6
    jnz       L436
    mov       %rax,	2
    jmp       L433
L436:
    mov       %rax,	%rdi
    shr       %rax,	4
    and       %rax,	15
    cmp       %rax,	14
    jnz       L437
    mov       %rax,	3
    jmp       L433
L437:
    mov       %rax,	%rdi
    shr       %rax,	3
    and       %rax,	31
    cmp       %rax,	30
    jnz       L438
    mov       %rax,	4
    jmp       L433
L438:
    mov       %rax,	1
L433:
L432:
#---------------
    add       %rsp,	16
    pop       %rdi
    ret       
# End 
# Proc mlib.pcm_alloc
mlib.pcm_alloc:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    mov       %al,	[%rip+mlib.pcm_setup]
    test      %al,	%al
    jnz       L441
    call      mlib.pcm_init
L441:
    cmp       %rbx,	2048
    jle       L443
    mov       %rcx,	%rbx
    call      mlib.pcm_getac
    mov       [%rip+mlib.alloccode],	%rax
    lea       %rax,	[%rip+mlib.allocupper]
    mov       %r10,	[%rip+mlib.alloccode]
    mov       %rax,	[%rax + %r10*8]
    mov       [%rip+mlib.allocbytes],	%rax
    mov       %rcx,	[%rip+mlib.allocbytes]
    call      mlib.allocmem
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L445
    lea       %rcx,	[%rip+L8337]
    call      mlib.abortprogram
L445:
    mov       %rax,	%rdi
    jmp       L439
L443:
    lea       %rax,	[%rip+mlib.sizeindextable]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       [%rip+mlib.alloccode],	%rax
    lea       %rax,	[%rip+mlib.allocupper]
    mov       %r10,	[%rip+mlib.alloccode]
    mov       %rax,	[%rax + %r10*8]
    mov       [%rip+mlib.allocbytes],	%rax
    lea       %rax,	[%rip+mlib.freelist]
    mov       %r10,	[%rip+mlib.alloccode]
    mov       %rax,	[%rax + %r10*8]
    mov       %rdi,	%rax
    test      %rax,	%rax
    jz        L447
    lea       %rax,	[%rip+mlib.freelist]
    mov       %r10,	[%rip+mlib.alloccode]
    mov       %rax,	[%rax + %r10*8]
    mov       %rax,	[%rax]
    lea       %r10,	[%rip+mlib.freelist]
    mov       %r11,	[%rip+mlib.alloccode]
    mov       [%r10 + %r11*8],	%rax
    mov       %rax,	%rdi
    jmp       L439
L447:
    mov       %rdi,	[%rip+mlib.pcheapptr]
    mov       %rax,	[%rip+mlib.allocbytes]
    add       [%rip+mlib.pcheapptr],	%rax
    mov       %rax,	[%rip+mlib.pcheapptr]
    cmp       %rax,	[%rip+mlib.pcheapend]
    jb        L449
    mov       %rcx,	[%rip+mlib.allocbytes]
    call      mlib.pcm_newblock
    mov       %rdi,	%rax
    mov       %rax,	%rdi
    jmp       L439
L449:
    mov       %rax,	%rdi
L439:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.pcm_free
mlib.pcm_free:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
#PROC3
#PROC4
    test      %rsi,	%rsi
    jz        L453
    test      %rbx,	%rbx
    jnz       L452
L453:
    jmp       L450
L452:
    cmp       %rsi,	2048
    jle       L455
    mov       %rcx,	%rbx
    call      free
    jmp       L454
L455:
    lea       %rax,	[%rip+mlib.sizeindextable]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %rdi,	%rax
    lea       %rax,	[%rip+mlib.freelist]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    mov       [%rbx],	%rax
    mov       %rax,	%rbx
    lea       %r10,	[%rip+mlib.freelist]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*8],	%rax
L454:
L450:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.pcm_freeac
mlib.pcm_freeac:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rip+mlib.allocupper]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mlib.pcm_free
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.pcm_clearmem
mlib.pcm_clearmem:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    mov       %r8,	%rbx
    call      memset
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.pcm_init
mlib.pcm_init:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    xor       %eax,	%eax
    mov       [%rip+mlib.alloccode],	%rax
    mov       %al,	[%rip+mlib.pcm_setup]
    test      %al,	%al
    jnz       L458
L460:
    xor       %ecx,	%ecx
    call      mlib.pcm_newblock
    mov       %r13,	1
L461:
    mov       %rdi,	1
    mov       %rbx,	16
    jmp       L465
L464:
    mov       %rax,	%rbx
    shl       %rax,	1
    mov       %rbx,	%rax
    inc       %rdi
L465:
    cmp       %r13,	%rbx
    jg        L464
    mov       %al,	%dil
    lea       %r10,	[%rip+mlib.sizeindextable]
    mov       %r11,	%r13
    mov       [%r10 + %r11],	%al
    inc       %r13
    cmp       %r13,	2048
    jle       L461
    mov       %rax,	16
    lea       %r10,	[%rip+mlib.allocupper]
    mov       [%r10+8],	%rax
    mov       %rsi,	16
    mov       %r13,	2
L467:
    mov       %rax,	%rsi
    shl       %rax,	1
    mov       %rsi,	%rax
    mov       %rax,	%rsi
    lea       %r10,	[%rip+mlib.allocupper]
    mov       %r11,	%r13
    mov       [%r10 + %r11*8],	%rax
    cmp       %rsi,	33554432
    jl        L471
    mov       %rbx,	%r13
    jmp       L469
L471:
    inc       %r13
    cmp       %r13,	27
    jle       L467
L469:
    lea       %rax,	[%rbx+1]
    mov       %r13,	%rax
    mov       %r12,	300
    cmp       %r13,	%r12
    jg        L474
L472:
    mov       %rax,	33554432
    add       %rsi,	%rax
    mov       %rax,	%rsi
    mov       %r10,	8589934592
    cmp       %rax,	%r10
    jge       L476
    mov       %rax,	%rsi
    lea       %r10,	[%rip+mlib.allocupper]
    mov       %r11,	%r13
    mov       [%r10 + %r11*8],	%rax
    mov       [%rip+mlib.maxmemory],	%rsi
    jmp       L475
L476:
    lea       %rax,	[%r13-1]
    mov       [%rip+mlib.maxalloccode],	%rax
    jmp       L474
L475:
    inc       %r13
    cmp       %r13,	%r12
    jle       L472
L474:
    mov       %al,	1
    mov       [%rip+mlib.pcm_setup],	%al
L458:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.pcm_getac
mlib.pcm_getac:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    cmp       %rcx,	2048
    jg        L479
    lea       %rax,	[%rip+mlib.sizeindextable]
    mov       %r10,	%rcx
    movzx     %rax,	byte ptr[%rax + %r10]
    jmp       L477
L479:
    lea       %rax,	[%rcx+255]
    sar       %rax,	8
    mov       %rcx,	%rax
    cmp       %rcx,	2048
    jg        L481
    lea       %rax,	[%rip+mlib.sizeindextable]
    mov       %r10,	%rcx
    movzx     %rax,	byte ptr[%rax + %r10]
    add       %rax,	8
    jmp       L477
L481:
    lea       %rax,	[%rcx+63]
    sar       %rax,	6
    mov       %rcx,	%rax
    cmp       %rcx,	2048
    jg        L483
    lea       %rax,	[%rip+mlib.sizeindextable]
    mov       %r10,	%rcx
    movzx     %rax,	byte ptr[%rax + %r10]
    add       %rax,	14
    jmp       L477
L483:
    lea       %rax,	[%rcx-2048]
    add       %rax,	2047
    sar       %rax,	11
    add       %rax,	22
    mov       %rcx,	%rax
    mov       %rax,	%rcx
L477:
#---------------
    ret       
# End 
# Proc mlib.pcm_newblock
mlib.pcm_newblock:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rax,	2097152
    add       [%rip+mlib.pcm_newblock.totalheapsize],	%rax
    xor       %eax,	%eax
    mov       [%rip+mlib.alloccode],	%rax
    mov       %rcx,	2097152
    call      mlib.allocmem
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L486
    lea       %rcx,	[%rip+L8338]
    call      mlib.abortprogram
L486:
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    mov       %r8,	2097152
    call      memset
    mov       [%rip+mlib.pcheapptr],	%rdi
    lea       %rax,	[%rdi+2097152]
    mov       [%rip+mlib.pcheapend],	%rax
    mov       %rax,	[%rip+mlib.pcheapstart]
    test      %rax,	%rax
    jnz       L488
    mov       [%rip+mlib.pcheapstart],	%rdi
L488:
    mov       %rax,	%rbx
    add       [%rip+mlib.pcheapptr],	%rax
    mov       %rax,	%rdi
L484:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.pcm_round
mlib.pcm_round:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    cmp       %rcx,	2048
    jle       L491
    mov       %rax,	%rcx
    jmp       L490
L491:
    lea       %rax,	[%rip+mlib.sizeindextable]
    mov       %r10,	%rcx
    movzx     %rax,	byte ptr[%rax + %r10]
    lea       %r10,	[%rip+mlib.pcm_round.allocbytes]
    movsxd    %r10,	dword ptr[%r10 + %rax*4]
    mov       %rax,	%r10
L490:
L489:
#---------------
    ret       
# End 
# Proc mlib.pcm_allocz
mlib.pcm_allocz:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rbx
    call      mlib.pcm_alloc
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    mov       %r8,	%rbx
    call      memset
    mov       %rax,	%rdi
L492:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.pcm_copyheapstring
mlib.pcm_copyheapstring:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
#PROC3
#PROC4
    test      %rsi,	%rsi
    jnz       L495
    xor       %eax,	%eax
    jmp       L493
L495:
    mov       %rcx,	%rsi
    call      strlen
    inc       %rax
    mov       %rbx,	%rax
    mov       %rcx,	%rbx
    call      mlib.pcm_alloc
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	%rsi
    mov       %r8,	%rbx
    call      memcpy
    mov       %rax,	%rdi
L493:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.pcm_copyheapstringn
mlib.pcm_copyheapstringn:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
#PROC3
#PROC4
    test      %rbx,	%rbx
    jnz       L498
    xor       %eax,	%eax
    jmp       L496
L498:
    lea       %rax,	[%rsi+1]
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      memcpy
    xor       %eax,	%eax
    mov       [%rdi + %rsi],	%al
    mov       %rax,	%rdi
L496:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.pcm_copyheapblock
mlib.pcm_copyheapblock:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
#PROC3
#PROC4
    test      %rsi,	%rsi
    jnz       L501
    xor       %eax,	%eax
    jmp       L499
L501:
    mov       %rcx,	%rsi
    call      mlib.pcm_alloc
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      memcpy
    mov       %rax,	%rdi
L499:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.allocmem
mlib.allocmem:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rbx
    call      malloc
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L504
    mov       %rax,	%rdi
    jmp       L502
L504:
    call      msys.m$print_startcon
    mov       %rcx,	%rbx
    call      msys.m$print_i64_nf
    mov       %rcx,	[%rip+mlib.memtotal]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8339]
    call      mlib.abortprogram
    xor       %eax,	%eax
L502:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.reallocmem
mlib.reallocmem:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      realloc
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L507
    mov       %rax,	%rdi
    jmp       L505
L507:
    call      msys.m$print_startcon
    mov       %rcx,	%rbx
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8340]
    call      mlib.abortprogram
    xor       %eax,	%eax
L505:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.abortprogram
mlib.abortprogram:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    call      msys.m$print_startcon
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8341]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       %rcx,	5
    call      exit
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mlib.getfilesize
mlib.getfilesize:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rsi
    call      ftell
    mov       %edi,	%eax
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    mov       %r8,	2
    call      fseek
    mov       %rcx,	%rsi
    call      ftell
    mov       %ebx,	%eax
    mov       %eax,	%edi
    mov       %rcx,	%rsi
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      fseek
    mov       %eax,	%ebx
L509:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.readrandom
mlib.readrandom:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
    mov       %r13,	%r9
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rbx
    mov       %rdx,	%r12
    xor       %r8d,	%r8d
    call      fseek
    mov       %rcx,	%rsi
    mov       %rdx,	1
    mov       %r8,	%r13
    mov       %r9,	%rbx
    call      fread
    mov       %rdi,	%rax
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.writerandom
mlib.writerandom:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
    mov       %r12,	%r9
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    mov       %rdx,	%rsi
    xor       %r8d,	%r8d
    call      fseek
    mov       %rcx,	%rbx
    mov       %rdx,	1
    mov       %r8,	%r12
    mov       %r9,	%rdi
    call      fwrite
L511:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.setfilepos
mlib.setfilepos:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      fseek
    movsxd    %r10,	%eax
    mov       %rax,	%r10
L512:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.getfilepos
mlib.getfilepos:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    call      ftell
    movsxd    %r10,	%eax
    mov       %rax,	%r10
L513:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mlib.readfile
mlib.readfile:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%r13
    lea       %rdx,	[%rip+L8342]
    call      fopen
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L516
    xor       %eax,	%eax
    jmp       L514
L516:
    mov       %rcx,	%rdi
    call      mlib.getfilesize
    mov       %rbx,	%rax
    mov       [%rip+mlib.rfsize],	%rax
    lea       %rax,	[%rbx+2]
    mov       %rcx,	%rax
    call      malloc
    mov       %rsi,	%rax
    test      %rsi,	%rsi
    jnz       L518
    xor       %eax,	%eax
    jmp       L514
L518:
    mov       %rcx,	%rdi
    mov       %rdx,	%rsi
    xor       %r8d,	%r8d
    mov       %r9,	%rbx
    call      mlib.readrandom
    lea       %rax,	[%rsi + %rbx]
    mov       %r12,	%rax
    xor       %eax,	%eax
    mov       [%r12],	%ax
    mov       %rcx,	%rdi
    call      fclose
    mov       %rax,	%rsi
L514:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.writefile
mlib.writefile:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rsi
    lea       %rdx,	[%rip+L8343]
    call      fopen
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L521
    xor       %eax,	%eax
    jmp       L519
L521:
    mov       %rcx,	%rdi
    mov       %rdx,	%r12
    xor       %r8d,	%r8d
    mov       %r9,	%r13
    call      mlib.writerandom
    mov       %rbx,	%rax
    mov       %rcx,	%rdi
    call      fclose
    mov       %rax,	%rbx
L519:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.checkfile
mlib.checkfile:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rbx
    lea       %rdx,	[%rip+L8344]
    call      fopen
    mov       %rdi,	%rax
    test      %rax,	%rax
    jz        L524
    mov       %rcx,	%rdi
    call      fclose
    mov       %rax,	1
    jmp       L522
L524:
    xor       %eax,	%eax
L522:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.readlinen
mlib.readlinen:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       %r15,	%r8
#---------------
#PROC3
#PROC4
    test      %r13,	%r13
    jnz       L527
    call      mwindows.os_getstdin
    mov       %r13,	%rax
L527:
    test      %r13,	%r13
    jnz       L529
    xor       %rsi,	%rsi
    mov       %rax,	%r14
    mov       %rbx,	%rax
L530:
    call      getchar
    movsxd    %r10,	%eax
    mov       %rdi,	%r10
    cmp       %rdi,	13
    jz        L534
    cmp       %rdi,	10
    jz        L534
    cmp       %rdi,	-1
    jnz       L533
L534:
    xor       %eax,	%eax
    mov       [%rbx],	%al
    jmp       L525
L533:
    mov       %rax,	%rbx
    inc       %rbx
    mov       %r10b,	%dil
    mov       [%rax],	%r10b
    inc       %rsi
    lea       %rax,	[%r15-2]
    mov       %r10,	%rsi
    cmp       %r10,	%rax
    jl        L536
    xor       %eax,	%eax
    mov       [%rbx],	%al
    jmp       L525
L536:
    jmp       L530
L529:
    xor       %eax,	%eax
    mov       [%r14],	%al
    lea       %rax,	[%r15-2]
    mov       %rcx,	%r14
    mov       %rdx,	%rax
    mov       %r8,	%r13
    call      fgets
    test      %rax,	%rax
    jz        L525
L538:
    mov       %rcx,	%r14
    call      strlen
    mov       %rsi,	%rax
    test      %rsi,	%rsi
    jnz       L540
    jmp       L525
L540:
    lea       %rax,	[%r14 + %rsi]
    sub       %rax,	1
    mov       %rbx,	%rax
    xor       %r12b,	%r12b
    jmp       L542
L541:
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	13
    jz        L546
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	10
    jnz       L545
L546:
    mov       %r12b,	1
L545:
    mov       %rax,	%rbx
    dec       %rbx
    xor       %r10d,	%r10d
    mov       [%rax],	%r10b
L542:
    cmp       %rbx,	%r14
    jb        L547
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	13
    jz        L541
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	10
    jz        L541
L547:
    test      %r12b,	%r12b
    jnz       L549
    lea       %rax,	[%rsi+4]
    cmp       %rax,	%r15
    jle       L549
    call      msys.m$print_startcon
    mov       %rcx,	%r15
    call      msys.m$print_i64_nf
    mov       %rcx,	%rsi
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8345]
    call      mlib.abortprogram
L549:
L525:
#---------------
    add       %rsp,	48
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.iconvlcn
mlib.iconvlcn:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
#PROC3
#PROC4
    mov       %rdi,	%rsi
    cmp       %rdi,	0
    jle       L553
L551:
    movzx     %rax,	byte ptr[%rbx]
    mov       %rcx,	%rax
    call      tolower
    mov       [%rbx],	%al
    inc       %rbx
    dec       %rdi
    jnz       L551
L553:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.iconvucn
mlib.iconvucn:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
#PROC3
#PROC4
    mov       %rdi,	%rsi
    cmp       %rdi,	0
    jle       L557
L555:
    movzx     %rax,	byte ptr[%rbx]
    mov       %rcx,	%rax
    call      toupper
    mov       [%rbx],	%al
    inc       %rbx
    dec       %rdi
    jnz       L555
L557:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.convlcstring
mlib.convlcstring:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rdi,	%rbx
    jmp       L560
L559:
    movzx     %rax,	byte ptr[%rbx]
    mov       %rcx,	%rax
    call      tolower
    mov       [%rbx],	%al
    inc       %rbx
L560:
    mov       %al,	[%rbx]
    test      %al,	%al
    jnz       L559
    mov       %rax,	%rdi
L558:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.convucstring
mlib.convucstring:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rdi,	%rbx
    jmp       L564
L563:
    movzx     %rax,	byte ptr[%rbx]
    mov       %rcx,	%rax
    call      toupper
    mov       [%rbx],	%al
    inc       %rbx
L564:
    mov       %al,	[%rbx]
    test      %al,	%al
    jnz       L563
    mov       %rax,	%rdi
L562:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.changeext
mlib.changeext:
#PROC1
#PROC2
#?>>
    .set mlib.changeext.newext2, -32
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	64
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rip+mlib.changeext.newfile]
    mov       %rcx,	%rax
    mov       %rdx,	%rsi
    call      strcpy
    movzx     %rax,	byte ptr[%r12]
    test      %rax,	%rax
    jz        L568
    cmp       %rax,	46
    jz        L569
    jmp       L570
L568:
    xor       %eax,	%eax
    mov       [%rbp + mlib.changeext.newext2],	%al
    xor       %eax,	%eax
    mov       [%rbp + mlib.changeext.newext2+1],	%al
    jmp       L567
L569:
    lea       %rax,	[%rbp + mlib.changeext.newext2]
    mov       %rcx,	%rax
    mov       %rdx,	%r12
    call      strcpy
    jmp       L567
L570:
    lea       %rax,	[%rbp + mlib.changeext.newext2]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8346]
    call      strcpy
    lea       %rax,	[%rbp + mlib.changeext.newext2]
    mov       %rcx,	%rax
    mov       %rdx,	%r12
    call      strcat
L567:
    mov       %rcx,	%rsi
    mov       %rdx,	1
    call      mlib.extractext
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rdi]
    test      %rax,	%rax
    jz        L572
    cmp       %rax,	46
    jz        L573
    jmp       L574
L572:
    lea       %rax,	[%rbp + mlib.changeext.newext2]
    lea       %r10,	[%rip+mlib.changeext.newfile]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      strcat
    jmp       L571
L573:
    lea       %rax,	[%rbp + mlib.changeext.newext2+1]
    lea       %r10,	[%rip+mlib.changeext.newfile]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      strcat
    jmp       L571
L574:
    mov       %rax,	%rdi
    sub       %rax,	%rsi
    sub       %rax,	2
    mov       %rbx,	%rax
    lea       %rax,	[%rbp + mlib.changeext.newext2]
    lea       %r10,	[%rip+mlib.changeext.newfile]
    mov       %r11,	%rbx
    lea       %r10,	[%r10 + %r11+1]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      strcpy
L571:
    lea       %rax,	[%rip+mlib.changeext.newfile]
L566:
#---------------
    add       %rsp,	64
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.extractext
mlib.extractext:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rsi
    call      mlib.extractfile
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rdi]
    test      %rax,	%rax
    jnz       L577
    lea       %rax,	[%rip+L8347]
    jmp       L575
L577:
    mov       %rcx,	%rdi
    call      strlen
    lea       %r10,	[%rdi + %rax]
    sub       %r10,	1
    mov       %rbx,	%r10
    jmp       L579
L578:
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	46
    jnz       L582
    movzx     %rax,	byte ptr[%rbx+1]
    test      %rax,	%rax
    jnz       L584
    test      %r12,	%r12
    jz        L586
    lea       %rax,	[%rip+L8348]
    jmp       L585
L586:
    lea       %rax,	[%rip+L8349]
L585:
    jmp       L575
L584:
    lea       %rax,	[%rbx+1]
    jmp       L575
L582:
    dec       %rbx
L579:
    cmp       %rbx,	%rdi
    jae       L578
    lea       %rax,	[%rip+L8349]
L575:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.extractpath
mlib.extractpath:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rsi
    call      strlen
    lea       %r10,	[%rsi + %rax]
    sub       %r10,	1
    mov       %rdi,	%r10
    jmp       L589
L588:
    movzx     %rax,	byte ptr[%rdi]
    cmp       %rax,	92
    jz        L592
    cmp       %rax,	47
    jz        L592
    cmp       %rax,	58
    jnz       L593
L592:
    mov       %rax,	%rdi
    sub       %rax,	%rsi
    inc       %rax
    mov       %rbx,	%rax
    lea       %rcx,	[%rip+mlib.extractpath.str]
    mov       %rdx,	%rsi
    mov       %r8,	%rbx
    call      memcpy
    xor       %eax,	%eax
    lea       %r10,	[%rip+mlib.extractpath.str]
    mov       %r11,	%rbx
    mov       [%r10 + %r11],	%al
    lea       %rax,	[%rip+mlib.extractpath.str]
    jmp       L587
L593:
L591:
    dec       %rdi
L589:
    cmp       %rdi,	%rsi
    jae       L588
    lea       %rax,	[%rip+L8349]
L587:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.extractfile
mlib.extractfile:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rbx
    call      mlib.extractpath
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rdi]
    test      %rax,	%rax
    jnz       L596
    mov       %rax,	%rbx
    jmp       L594
L596:
    mov       %rcx,	%rdi
    call      strlen
    lea       %r10,	[%rbx + %rax]
    mov       %rax,	%r10
L594:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.extractbasefile
mlib.extractbasefile:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%r13
    call      mlib.extractfile
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    call      strlen
    mov       %r12,	%rax
    test      %r12,	%r12
    jnz       L599
    lea       %rax,	[%rip+L8349]
    jmp       L597
L599:
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      mlib.extractext
    mov       %rbx,	%rax
    mov       %al,	[%rbx]
    test      %al,	%al
    jz        L601
    mov       %rcx,	%rbx
    call      strlen
    mov       %r10,	%r12
    sub       %r10,	%rax
    dec       %r10
    mov       %rsi,	%r10
    lea       %rcx,	[%rip+mlib.extractbasefile.str]
    mov       %rdx,	%rdi
    mov       %r8,	%rsi
    call      memcpy
    xor       %eax,	%eax
    lea       %r10,	[%rip+mlib.extractbasefile.str]
    mov       %r11,	%rsi
    mov       [%r10 + %r11],	%al
    lea       %rax,	[%rip+mlib.extractbasefile.str]
    jmp       L597
L601:
    lea       %rax,	[%rdi + %r12]
    sub       %rax,	1
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	46
    jnz       L603
    lea       %rax,	[%r12-1]
    lea       %rcx,	[%rip+mlib.extractbasefile.str]
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      memcpy
    xor       %eax,	%eax
    lea       %r10,	[%rip+mlib.extractbasefile.str]
    mov       %r11,	%r12
    mov       [%r10 + %r11-1],	%al
    lea       %rax,	[%rip+mlib.extractbasefile.str]
    jmp       L597
L603:
    mov       %rax,	%rdi
L597:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.addext
mlib.addext:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      mlib.extractext
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rdi]
    test      %rax,	%rax
    jnz       L606
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      mlib.changeext
    jmp       L604
L606:
    mov       %rax,	%rbx
L604:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.pcm_alloc32
mlib.pcm_alloc32:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    mov       %rax,	32
    mov       [%rip+mlib.allocbytes],	%rax
    lea       %rax,	[%rip+mlib.freelist]
    mov       %rax,	[%rax+16]
    mov       %rdi,	%rax
    test      %rax,	%rax
    jz        L609
    lea       %rax,	[%rip+mlib.freelist]
    mov       %rax,	[%rax+16]
    mov       %rax,	[%rax]
    lea       %r10,	[%rip+mlib.freelist]
    mov       [%r10+16],	%rax
    mov       %rax,	%rdi
    jmp       L607
L609:
    mov       %rcx,	32
    call      mlib.pcm_alloc
L607:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mlib.pcm_free32
mlib.pcm_free32:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rip+mlib.freelist]
    mov       %rax,	[%rax+16]
    mov       [%rcx],	%rax
    mov       %rax,	%rcx
    lea       %r10,	[%rip+mlib.freelist]
    mov       [%r10+16],	%rax
#---------------
    ret       
# End 
# Proc mlib.outbyte
mlib.outbyte:
#PROC1
#PROC2
#?>>
    .set mlib.outbyte.x, 32
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       [%rbp+32],	%rdx
#---------------
#PROC3
#PROC4
    lea       %rcx,	[%rbp + mlib.outbyte.x]
    mov       %rdx,	1
    mov       %r8,	1
    mov       %r9,	%rdi
    call      fwrite
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc mlib.outu16
mlib.outu16:
#PROC1
#PROC2
#?>>
    .set mlib.outu16.x, 32
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       [%rbp+32],	%rdx
#---------------
#PROC3
#PROC4
    lea       %rcx,	[%rbp + mlib.outu16.x]
    mov       %rdx,	2
    mov       %r8,	1
    mov       %r9,	%rdi
    call      fwrite
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc mlib.outu32
mlib.outu32:
#PROC1
#PROC2
#?>>
    .set mlib.outu32.x, 32
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       [%rbp+32],	%rdx
#---------------
#PROC3
#PROC4
    lea       %rcx,	[%rbp + mlib.outu32.x]
    mov       %rdx,	4
    mov       %r8,	1
    mov       %r9,	%rdi
    call      fwrite
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc mlib.outu64
mlib.outu64:
#PROC1
#PROC2
#?>>
    .set mlib.outu64.x, 32
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       [%rbp+32],	%rdx
#---------------
#PROC3
#PROC4
    lea       %rcx,	[%rbp + mlib.outu64.x]
    mov       %rdx,	8
    mov       %r8,	1
    mov       %r9,	%rdi
    call      fwrite
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc mlib.outstring
mlib.outstring:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rbx
    call      strlen
    inc       %rax
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    mov       %r8,	1
    mov       %r9,	%rdi
    call      fwrite
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.outblock
mlib.outblock:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	1
    mov       %r9,	%rdi
    call      fwrite
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.myeof
mlib.myeof:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rbx
    call      fgetc
    movsxd    %r10,	%eax
    mov       %rdi,	%r10
    cmp       %rdi,	-1
    jnz       L619
    mov       %rax,	1
    jmp       L617
L619:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      ungetc
    xor       %eax,	%eax
L617:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.strbuffer_add
mlib.strbuffer_add:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
#---------------
#PROC3
#PROC4
    cmp       %r14,	-1
    jnz       L622
    mov       %rcx,	%r13
    call      strlen
    mov       %r14,	%rax
L622:
    movsxd    %rax,	dword ptr[%r12+8]
    mov       %rbx,	%rax
    test      %rbx,	%rbx
    jnz       L624
    lea       %rax,	[%r14+1]
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       [%r12],	%rax
    mov       %eax,	[%rip+mlib.allocbytes]
    mov       [%r12+12],	%eax
    mov       [%r12+8],	%r14d
    mov       %rax,	[%r12]
    mov       %rcx,	%rax
    mov       %rdx,	%r13
    mov       %r8,	%r14
    call      memcpy
    mov       %rax,	[%r12]
    xor       %r10d,	%r10d
    mov       %r11,	%r14
    mov       [%rax + %r11],	%r10b
    jmp       L620
L624:
    mov       %rax,	%rbx
    add       %rax,	%r14
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+1]
    movsxd    %r10,	dword ptr[%r12+12]
    cmp       %rax,	%r10
    jle       L626
    lea       %rax,	[%rdi+1]
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       %rsi,	%rax
    mov       %rax,	[%r12]
    mov       %rcx,	%rsi
    mov       %rdx,	%rax
    mov       %r8,	%rbx
    call      memcpy
    mov       [%r12],	%rsi
    mov       %eax,	[%rip+mlib.allocbytes]
    mov       [%r12+12],	%eax
L626:
    mov       %rax,	[%r12]
    mov       %r10,	%rbx
    lea       %rax,	[%rax + %r10]
    mov       %rcx,	%rax
    mov       %rdx,	%r13
    mov       %r8,	%r14
    call      memcpy
    mov       %rax,	[%r12]
    xor       %r10d,	%r10d
    mov       %r11,	%rdi
    mov       [%rax + %r11],	%r10b
    mov       [%r12+8],	%edi
L620:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.gs_init
mlib.gs_init:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    mov       %rdx,	16
    call      mlib.pcm_clearmem
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mlib.gs_free
mlib.gs_free:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %eax,	[%rdi+12]
    test      %eax,	%eax
    jz        L630
    movsxd    %rax,	dword ptr[%rdi+12]
    mov       %r10,	[%rdi]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mlib.pcm_free
L630:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mlib.gs_str
mlib.gs_str:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	-1
    call      mlib.strbuffer_add
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.gs_char
mlib.gs_char:
#PROC1
#PROC2
#?>>
    .set mlib.gs_char.s, -16
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    mov       [%rbp + mlib.gs_char.s],	%bl
    xor       %eax,	%eax
    mov       [%rbp + mlib.gs_char.s+1],	%al
    mov       %rcx,	%rdi
    lea       %rdx,	[%rbp + mlib.gs_char.s]
    mov       %r8,	1
    call      mlib.strbuffer_add
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.gs_strn
mlib.gs_strn:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      mlib.strbuffer_add
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.gs_strvar
mlib.gs_strvar:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rbx]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    mov       %r8,	-1
    call      mlib.strbuffer_add
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.gs_strint
mlib.gs_strint:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      msys.strint
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    mov       %r8,	-1
    call      mlib.strbuffer_add
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.gs_strln
mlib.gs_strln:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mlib.gs_str
    mov       %rcx,	%rdi
    call      mlib.gs_line
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.gs_strsp
mlib.gs_strsp:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mlib.gs_str
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8350]
    call      mlib.gs_str
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.gs_line
mlib.gs_line:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8351]
    mov       %r8,	-1
    call      mlib.strbuffer_add
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mlib.gs_getcol
mlib.gs_getcol:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    movsxd    %rax,	dword ptr[%rcx+8]
L639:
#---------------
    ret       
# End 
# Proc mlib.gs_leftstr
mlib.gs_leftstr:
#PROC1
#PROC2
#?>>
    .set mlib.gs_leftstr.w, 80
    .set mlib.gs_leftstr.padch, 88
    .set mlib.gs_leftstr.str, -2560
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	2592
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       [%rbp+80],	%r8
    mov       [%rbp+88],	%r9
#---------------
#PROC3
#PROC4
    movsxd    %rax,	dword ptr[%r13+8]
    mov       %rdi,	%rax
    lea       %rcx,	[%rbp + mlib.gs_leftstr.str]
    mov       %rdx,	%r14
    call      strcpy
    mov       %rcx,	%r14
    call      strlen
    mov       %r12,	%rax
    mov       %rax,	[%rbp + mlib.gs_leftstr.w]
    sub       %rax,	%r12
    mov       %rsi,	%rax
    cmp       %rsi,	0
    jle       L642
    mov       %rbx,	1
    cmp       %rsi,	1
    jl        L645
L643:
    mov       %rax,	%r12
    add       %rax,	%rbx
    mov       %r10b,	[%rbp + mlib.gs_leftstr.padch]
    mov       [%rbp + %rax + mlib.gs_leftstr.str-1],	%r10b
    inc       %rbx
    cmp       %rbx,	%rsi
    jle       L643
L645:
    mov       %rax,	%r12
    add       %rax,	%rsi
    xor       %r10d,	%r10d
    mov       [%rbp + %rax + mlib.gs_leftstr.str],	%r10b
L642:
    mov       %rcx,	%r13
    lea       %rdx,	[%rbp + mlib.gs_leftstr.str]
    call      mlib.gs_str
#---------------
    add       %rsp,	2592
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.gs_leftint
mlib.gs_leftint:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
    mov       %r12,	%r9
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      msys.strint
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    mov       %r8,	%rsi
    mov       %r9,	%r12
    call      mlib.gs_leftstr
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.gs_padto
mlib.gs_padto:
#PROC1
#PROC2
#?>>
    .set mlib.gs_padto.str, -2560
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	2600
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
#PROC3
#PROC4
    movsxd    %rax,	dword ptr[%rsi+8]
    mov       %r10,	%r12
    sub       %r10,	%rax
    mov       %rdi,	%r10
    cmp       %rdi,	0
    jle       L647
L649:
    mov       %rbx,	1
    cmp       %rdi,	1
    jl        L652
L650:
    mov       [%rbp + %rbx + mlib.gs_padto.str-1],	%r13b
    inc       %rbx
    cmp       %rbx,	%rdi
    jle       L650
L652:
    xor       %eax,	%eax
    mov       [%rbp + %rdi + mlib.gs_padto.str],	%al
    mov       %rcx,	%rsi
    lea       %rdx,	[%rbp + mlib.gs_padto.str]
    call      mlib.gs_str
L647:
#---------------
    add       %rsp,	2600
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.gs_println
mlib.gs_println:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    movsxd    %rax,	dword ptr[%rdi+8]
    test      %rax,	%rax
    jz        L653
L655:
    mov       %rax,	[%rdi]
    movsxd    %r10,	dword ptr[%rdi+8]
    xor       %r11d,	%r11d
    mov       [%rax + %r10],	%r11b
    test      %rbx,	%rbx
    jnz       L657
    call      msys.m$print_startcon
    mov       %rcx,	[%rdi]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L656
L657:
    mov       %rcx,	%rbx
    call      msys.m$print_startfile
    mov       %rcx,	[%rdi]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L656:
L653:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.nextcmdparamnew
mlib.nextcmdparamnew:
#PROC1
#PROC2
#?>>
    .set mlib.nextcmdparamnew.defext, 88
    .set mlib.nextcmdparamnew.item, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
    mov       [%rbp+88],	%r9
#---------------
#PROC3
#PROC4
#mlib.nextcmdparamnew.reenter:
L659:
    xor       %eax,	%eax
    mov       [%r14],	%rax
    xor       %eax,	%eax
    mov       [%r13],	%rax
    mov       %rax,	[%rip+mlib.nextcmdparamnew.infile]
    test      %rax,	%rax
    jz        L661
    lea       %rcx,	[%rip+mlib.nextcmdparamnew.fileptr]
    lea       %rdx,	[%rbp + mlib.nextcmdparamnew.item]
    call      mlib.readnextfileitem
    test      %rax,	%rax
    jnz       L663
    mov       %rcx,	[%rip+mlib.nextcmdparamnew.filestart]
    call      free
    xor       %eax,	%eax
    mov       [%rip+mlib.nextcmdparamnew.infile],	%rax
    jmp       L659
L663:
    jmp       L660
L661:
    mov       %rax,	[%r12]
    cmp       %rax,	[%rip+msys.ncmdparams]
    jle       L665
    xor       %eax,	%eax
    jmp       L658
L665:
    mov       %rax,	[%r12]
    mov       %r10,	[%rip+msys.cmdparams]
    mov       %r10,	[%r10 + %rax*8]
    mov       [%rbp + mlib.nextcmdparamnew.item],	%r10
    mov       %rax,	%r12
    inc       qword ptr[%rax]
    mov       %rcx,	[%rbp + mlib.nextcmdparamnew.item]
    call      strlen
    mov       %rsi,	%rax
    mov       %rax,	[%rbp + mlib.nextcmdparamnew.item]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	64
    jnz       L667
    mov       %rax,	[%rbp + mlib.nextcmdparamnew.item]
    lea       %rax,	[%rax+1]
    mov       %rcx,	%rax
    call      mlib.readfile
    mov       [%rip+mlib.nextcmdparamnew.fileptr],	%rax
    mov       [%rip+mlib.nextcmdparamnew.filestart],	%rax
    mov       %rax,	[%rip+mlib.nextcmdparamnew.filestart]
    test      %rax,	%rax
    jnz       L669
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8352]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rbp + mlib.nextcmdparamnew.item]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	7
    call      exit
L669:
    mov       %rax,	1
    mov       [%rip+mlib.nextcmdparamnew.infile],	%rax
    jmp       L659
L667:
    mov       %rax,	[%rbp + mlib.nextcmdparamnew.item]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	58
    jnz       L671
    mov       %al,	1
    mov       [%rip+mlib.nextcmdparamnew.colonseen],	%al
    mov       %rax,	4
    jmp       L658
L671:
L660:
    xor       %eax,	%eax
    mov       [%r14],	%rax
    mov       %rax,	[%rbp + mlib.nextcmdparamnew.item]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	45
    jnz       L673
    mov       %al,	[%rip+mlib.nextcmdparamnew.colonseen]
    test      %al,	%al
    jz        L675
    xor       %eax,	%eax
    jmp       L674
L675:
    mov       %rax,	1
L674:
    mov       %r10,	[%rbp + mlib.nextcmdparamnew.item]
    lea       %r10,	[%r10 + %rax]
    mov       [%r13],	%r10
    mov       %rcx,	[%rbp + mlib.nextcmdparamnew.item]
    mov       %rdx,	58
    call      strchr
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L677
    mov       %rcx,	[%rbp + mlib.nextcmdparamnew.item]
    mov       %rdx,	61
    call      strchr
    mov       %rdi,	%rax
L677:
    test      %rdi,	%rdi
    jz        L679
    lea       %rax,	[%rdi+1]
    mov       [%r14],	%rax
    xor       %eax,	%eax
    mov       [%rdi],	%al
L679:
    mov       %al,	[%rip+mlib.nextcmdparamnew.colonseen]
    test      %al,	%al
    jz        L681
    mov       %rax,	5
    jmp       L680
L681:
    mov       %rax,	1
L680:
    jmp       L658
L673:
    mov       %rcx,	[%rbp + mlib.nextcmdparamnew.item]
    xor       %edx,	%edx
    call      mlib.extractext
    mov       %rbx,	%rax
    mov       %rax,	[%rbp + mlib.nextcmdparamnew.item]
    mov       [%r13],	%rax
    movzx     %rax,	byte ptr[%rbx]
    test      %rax,	%rax
    jnz       L683
    mov       %rax,	[%r13]
    lea       %rcx,	[%rip+mlib.nextcmdparamnew.str]
    mov       %rdx,	%rax
    call      strcpy
    mov       %rax,	[%rbp + mlib.nextcmdparamnew.defext]
    test      %rax,	%rax
    jz        L685
    mov       %al,	[%rip+mlib.nextcmdparamnew.colonseen]
    test      %al,	%al
    jnz       L685
    lea       %rcx,	[%rip+mlib.nextcmdparamnew.str]
    mov       %rdx,	[%rbp + mlib.nextcmdparamnew.defext]
    call      mlib.addext
    mov       [%r13],	%rax
L685:
    jmp       L682
L683:
    mov       %rcx,	%rbx
    lea       %rdx,	[%rip+L8353]
    call      mlib.eqstring
    test      %rax,	%rax
    jnz       L687
    mov       %rcx,	%rbx
    lea       %rdx,	[%rip+L8354]
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L686
L687:
    mov       %al,	[%rip+mlib.nextcmdparamnew.colonseen]
    test      %al,	%al
    jz        L689
    mov       %rax,	5
    jmp       L688
L689:
    mov       %rax,	3
L688:
    jmp       L658
L686:
L682:
    mov       %al,	[%rip+mlib.nextcmdparamnew.colonseen]
    test      %al,	%al
    jz        L691
    mov       %rax,	5
    jmp       L690
L691:
    mov       %rax,	2
L690:
L658:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.readnextfileitem
mlib.readnextfileitem:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r13,	%rcx
    mov       %r14,	%rdx
#---------------
#PROC3
#PROC4
    mov       %rdi,	[%r13]
#mlib.readnextfileitem.reenter:
L693:
L694:
    movzx     %rax,	byte ptr[%rdi]
    cmp       %rax,	32
    jz        L697
    cmp       %rax,	9
    jz        L697
    cmp       %rax,	13
    jz        L697
    cmp       %rax,	10
    jz        L697
    cmp       %rax,	26
    jz        L698
    test      %rax,	%rax
    jz        L698
    jmp       L699
L697:
    inc       %rdi
    jmp       L696
L698:
    xor       %eax,	%eax
    jmp       L692
L699:
    jmp       L695
L696:
    jmp       L694
L695:
    movzx     %rax,	byte ptr[%rdi]
    cmp       %rax,	33
    jz        L701
    cmp       %rax,	35
    jnz       L702
L701:
    inc       %rdi
L703:
    mov       %rax,	%rdi
    inc       %rdi
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	10
    jz        L705
    cmp       %rax,	26
    jz        L706
    test      %rax,	%rax
    jz        L706
    jmp       L707
L705:
    jmp       L693
L706:
    lea       %rax,	[%rdi-1]
    mov       [%r13],	%rax
    xor       %eax,	%eax
    jmp       L692
L707:
    jmp       L703
L702:
L700:
    movzx     %rax,	byte ptr[%rdi]
    cmp       %rax,	34
    jnz       L710
L709:
    inc       %rdi
    mov       %rbx,	%rdi
L711:
    movzx     %rax,	byte ptr[%rdi]
    test      %rax,	%rax
    jz        L714
    cmp       %rax,	26
    jz        L714
    cmp       %rax,	34
    jz        L715
    jmp       L716
L714:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8355]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	8
    call      exit
    jmp       L713
L715:
    mov       %rax,	%rdi
    inc       %rdi
    mov       %rsi,	%rax
    movzx     %rax,	byte ptr[%rdi]
    cmp       %rax,	44
    jnz       L718
    inc       %rdi
L718:
    jmp       L712
L716:
L713:
    inc       %rdi
    jmp       L711
L712:
    jmp       L708
L710:
    mov       %rbx,	%rdi
L719:
    movzx     %rax,	byte ptr[%rdi]
    test      %rax,	%rax
    jz        L722
    cmp       %rax,	26
    jz        L722
    cmp       %rax,	32
    jz        L723
    cmp       %rax,	9
    jz        L723
    cmp       %rax,	44
    jz        L723
    cmp       %rax,	13
    jz        L723
    cmp       %rax,	10
    jz        L723
    jmp       L724
L722:
    mov       %rsi,	%rdi
    jmp       L720
L723:
    mov       %rax,	%rdi
    inc       %rdi
    mov       %rsi,	%rax
    jmp       L720
L724:
L721:
    inc       %rdi
    jmp       L719
L720:
L708:
    mov       %rax,	%rsi
    sub       %rax,	%rbx
    mov       %r12,	%rax
    cmp       %r12,	256
    jl        L726
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8356]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	9
    call      exit
L726:
    lea       %rcx,	[%rip+mlib.readnextfileitem.str]
    mov       %rdx,	%rbx
    mov       %r8,	%r12
    call      memcpy
    xor       %eax,	%eax
    lea       %r10,	[%rip+mlib.readnextfileitem.str]
    mov       %r11,	%r12
    mov       [%r10 + %r11],	%al
    lea       %rax,	[%rip+mlib.readnextfileitem.str]
    mov       [%r14],	%rax
    mov       [%r13],	%rdi
    mov       %rax,	1
L692:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.ipadstr
mlib.ipadstr:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rsi
    call      strlen
    mov       %rdi,	%rax
    mov       %rax,	%r12
    sub       %rax,	%rdi
    mov       %rbx,	%rax
    cmp       %rbx,	0
    jle       L730
L728:
    mov       %rcx,	%rsi
    mov       %rdx,	%r13
    call      strcat
    dec       %rbx
    jnz       L728
L730:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.padstr
mlib.padstr:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
#PROC3
#PROC4
    lea       %rcx,	[%rip+mlib.padstr.str]
    mov       %rdx,	%rdi
    call      strcpy
    lea       %rcx,	[%rip+mlib.padstr.str]
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      mlib.ipadstr
    lea       %rax,	[%rip+mlib.padstr.str]
L731:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.chr
mlib.chr:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       %al,	%cl
    lea       %r10,	[%rip+mlib.chr.str]
    mov       [%r10],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+mlib.chr.str]
    mov       [%r10+1],	%al
    lea       %rax,	[%rip+mlib.chr.str]
L732:
#---------------
    ret       
# End 
# Proc mlib.cmpstring
mlib.cmpstring:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      strcmp
    movsxd    %r10,	%eax
    mov       %rdi,	%r10
    cmp       %r10,	0
    jge       L735
    mov       %rax,	-1
    jmp       L734
L735:
    cmp       %rdi,	0
    jle       L736
    mov       %rax,	1
    jmp       L734
L736:
    xor       %eax,	%eax
L734:
L733:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.cmpstringn
mlib.cmpstringn:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      strncmp
    movsxd    %r10,	%eax
    mov       %rdi,	%r10
    cmp       %r10,	0
    jge       L739
    mov       %rax,	-1
    jmp       L738
L739:
    cmp       %rdi,	0
    jle       L740
    mov       %rax,	1
    jmp       L738
L740:
    xor       %eax,	%eax
L738:
L737:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.eqstring
mlib.eqstring:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      strcmp
    movsxd    %r10,	%eax
    cmp       %r10,	0
    setz      %r10b
    movzx     %r10d,	%r10b
    mov       %rax,	%r10
L741:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.cmpbytes
mlib.cmpbytes:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      memcmp
    movsxd    %r10,	%eax
    mov       %rdi,	%r10
    cmp       %r10,	0
    jge       L744
    mov       %rax,	-1
    jmp       L743
L744:
    cmp       %rdi,	0
    jle       L745
    mov       %rax,	1
    jmp       L743
L745:
    xor       %eax,	%eax
L743:
L742:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.eqbytes
mlib.eqbytes:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      memcmp
    movsxd    %r10,	%eax
    cmp       %r10,	0
    setz      %r10b
    movzx     %r10d,	%r10b
    mov       %rax,	%r10
L746:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.mseed
mlib.mseed:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       %rax,	%rcx
    lea       %r10,	[%rip+mlib.seed]
    mov       [%r10],	%rax
    test      %rdx,	%rdx
    jz        L749
    mov       %rax,	%rdx
    lea       %r10,	[%rip+mlib.seed]
    mov       [%r10+8],	%rax
    jmp       L748
L749:
    lea       %rax,	[%rip+mlib.seed]
    lea       %rax,	[%rax+8]
    mov       %r10,	%rcx
    xor       [%rax],	%r10
L748:
#---------------
    ret       
# End 
# Proc mlib.mrandom
mlib.mrandom:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rip+mlib.seed]
    mov       %rdi,	[%rax]
    lea       %rax,	[%rip+mlib.seed]
    mov       %rbx,	[%rax+8]
    mov       %rax,	%rbx
    lea       %r10,	[%rip+mlib.seed]
    mov       [%r10],	%rax
    mov       %rax,	%rdi
    shl       %rax,	23
    xor       %rdi,	%rax
    mov       %rax,	%rdi
    xor       %rax,	%rbx
    mov       %r10,	%rdi
    sar       %r10,	17
    xor       %rax,	%r10
    mov       %r10,	%rbx
    sar       %r10,	26
    xor       %rax,	%r10
    lea       %r10,	[%rip+mlib.seed]
    mov       [%r10+8],	%rax
    lea       %rax,	[%rip+mlib.seed]
    mov       %rax,	[%rax+8]
    add       %rax,	%rbx
L750:
#---------------
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.mrandomp
mlib.mrandomp:
#PROC1
#PROC2
#?>>
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    call      mlib.mrandom
    mov       %r10,	9223372036854775807
    and       %rax,	%r10
L751:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mlib.mrandomint
mlib.mrandomint:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    call      mlib.mrandomp
    mov       %r10,	%rdi
    cqo       
    idiv      %r10
    xchg      %rax,	%rdx
L752:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mlib.mrandomrange
mlib.mrandomrange:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
#PROC3
#PROC4
    mov       %rax,	%rsi
    sub       %rax,	%rbx
    inc       %rax
    mov       %rdi,	%rax
    cmp       %rdi,	0
    jg        L755
    xor       %eax,	%eax
    jmp       L753
L755:
    call      mlib.mrandomp
    mov       %r10,	%rdi
    cqo       
    idiv      %r10
    xchg      %rax,	%rdx
    add       %rax,	%rbx
L753:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.mrandomreal
mlib.mrandomreal:
#PROC1
#PROC2
#?>>
    movq      %rax,	%XMM15
    push      %rax
#?]]
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
L757:
    call      mlib.mrandomp
    cvtsi2sd  %XMM4,	%rax
    divsd     %XMM4,	[%rip+L8357]
    movq      %XMM15,	%XMM4
    movq      %XMM4,	%XMM15
    comisd    %XMM4,	[%rip+L8358]
    jz        L757
    movq      %XMM0,	%XMM15
L756:
#---------------
    add       %rsp,	48
    pop       %rcx
    movq      %XMM15,	%rcx
    ret       
# End 
# Proc mlib.mrandomreal1
mlib.mrandomreal1:
#PROC1
#PROC2
#?>>
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    call      mlib.mrandomp
    cvtsi2sd  %XMM4,	%rax
    divsd     %XMM4,	[%rip+L8359]
    movq      %XMM0,	%XMM4
L760:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mlib.readline
mlib.readline:
#PROC1
#PROC2
#?>>
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    call      msys.m$read_conline
    mov       %rax,	[%rip+msys.rd_buffer]
L761:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mlib.findfunction
mlib.findfunction:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rbx,	1
    mov       %rdi,	[%rip+$nprocs]
    cmp       %rdi,	1
    jl        L765
L763:
    lea       %rax,	[%rip+$procname]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rcx,	%rax
    mov       %rdx,	%rsi
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L767
    lea       %rax,	[%rip+$procaddr]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8-8]
    jmp       L762
L767:
    inc       %rbx
    cmp       %rbx,	%rdi
    jle       L763
L765:
    xor       %eax,	%eax
L762:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mlib.roundtoblock
mlib.roundtoblock:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rdx-1]
    mov       %r10,	%rcx
    and       %r10,	%rax
    test      %r10,	%r10
    jnz       L770
    mov       %rax,	%rcx
    jmp       L768
L770:
    lea       %rax,	[%rdx-1]
    mov       %r10,	%rcx
    and       %r10,	%rax
    mov       %rax,	%rdx
    sub       %rax,	%r10
    mov       %r10,	%rcx
    add       %r10,	%rax
    mov       %rax,	%r10
L768:
#---------------
    ret       
# End 
# Proc mlib.pcm_allocnfz
mlib.pcm_allocnfz:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rax,	%rbx
    and       %rax,	7
    jz        L773
    mov       %rax,	%rbx
    and       %rax,	7
    mov       %r10,	8
    sub       %r10,	%rax
    mov       %rax,	%rbx
    add       %rax,	%r10
    mov       %rbx,	%rax
L773:
    mov       %rdi,	[%rip+mlib.pcheapptr]
    mov       %rax,	%rbx
    add       [%rip+mlib.pcheapptr],	%rax
    mov       %rax,	[%rip+mlib.pcheapptr]
    cmp       %rax,	[%rip+mlib.pcheapend]
    jb        L775
    mov       %rcx,	%rbx
    call      mlib.pcm_newblock
    mov       %rdi,	%rax
L775:
    mov       %rax,	%rdi
L771:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mwindows.os_init
mwindows.os_init:
#PROC1
#PROC2
#?>>
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    mov       %eax,	4294967285
    mov       %eax,	%eax
    mov       %rcx,	%rax
    call      GetStdHandle
    mov       [%rip+mwindows.hconsole],	%rax
    mov       %eax,	4294967286
    mov       %eax,	%eax
    mov       %rcx,	%rax
    call      GetStdHandle
    mov       [%rip+mwindows.hconsolein],	%rax
    xor       %eax,	%eax
    lea       %r10,	[%rip+mwindows.lastkey]
    mov       [%r10+8],	%ax
    xor       %eax,	%eax
    mov       [%rip+mwindows.keypending],	%rax
    xor       %ecx,	%ecx
    mov       %rdx,	1
    call      SetConsoleCtrlHandler
    mov       %rcx,	[%rip+mwindows.hconsole]
    mov       %rdx,	3
    call      SetConsoleMode
    mov       %rax,	1
    mov       [%rip+mwindows.init_flag],	%rax
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mwindows.os_execwait
mwindows.os_execwait:
#PROC1
#PROC2
#?>>
    .set mwindows.os_execwait.workdir, 64
    .set mwindows.os_execwait.exitcode, -8
    .set mwindows.os_execwait.si, -112
    .set mwindows.os_execwait.xpi, -136
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	176
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
#PROC3
#PROC4
    xor       %rbx,	%rbx
    mov       %rax,	104
    mov       %rdi,	%rax
    mov       %rdi,	24
    mov       %rdi,	123456
    mov       %rdi,	1193046
    lea       %rax,	[%rbp + mwindows.os_execwait.si]
    xor       %r10d,	%r10d
    mov       %r11,	13
L8360:
    mov       [%rax],	%r10
    add       %rax,	8
    dec       %r11
    jnz       L8360
    lea       %rax,	[%rbp + mwindows.os_execwait.xpi]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    mov       [%rax+16],	%r10
    mov       %rax,	%r12
    test      %rax,	%rax
    jz        L779
    cmp       %rax,	1
    jz        L780
    cmp       %rax,	2
    jz        L781
    jmp       L782
L779:
    mov       %rbx,	32
    jmp       L778
L780:
    mov       %rbx,	48
    jmp       L778
L781:
    mov       %rbx,	48
L782:
L778:
    mov       %eax,	104
    mov       [%rbp + mwindows.os_execwait.si],	%eax
    lea       %rax,	[%rbp + mwindows.os_execwait.xpi]
    push      %rax
    lea       %rax,	[%rbp + mwindows.os_execwait.si]
    push      %rax
    push      0
    push      0
    mov       %eax,	%ebx
    push      %rax
    push      1
    xor       %ecx,	%ecx
    mov       %rdx,	%rsi
    xor       %r8d,	%r8d
    xor       %r9d,	%r9d
    sub       %rsp,	32
    call      CreateProcessA
    add       %rsp,	80
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L784
    call      GetLastError
    mov       %r10d,	%eax
    mov       %rdi,	%r10
    lea       %rcx,	[%rip+L8361]
    mov       %rdx,	%rdi
    call      printf
    mov       %rax,	-1
    jmp       L777
L784:
    mov       %rax,	[%rbp + mwindows.os_execwait.xpi]
    mov       %rcx,	%rax
    mov       %rdx,	4294967295
    call      WaitForSingleObject
    mov       %rax,	[%rbp + mwindows.os_execwait.xpi]
    mov       %rcx,	%rax
    lea       %rdx,	[%rbp + mwindows.os_execwait.exitcode]
    call      GetExitCodeProcess
    mov       %rcx,	[%rbp + mwindows.os_execwait.xpi]
    call      CloseHandle
    mov       %rcx,	[%rbp + mwindows.os_execwait.xpi+8]
    call      CloseHandle
    mov       %eax,	[%rbp + mwindows.os_execwait.exitcode]
L777:
#---------------
    add       %rsp,	176
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mwindows.os_execcmd
mwindows.os_execcmd:
#PROC1
#PROC2
#?>>
    .set mwindows.os_execcmd.si, -104
    .set mwindows.os_execcmd.xpi, -128
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	160
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rbp + mwindows.os_execcmd.si]
    xor       %r10d,	%r10d
    mov       %r11,	13
L8362:
    mov       [%rax],	%r10
    add       %rax,	8
    dec       %r11
    jnz       L8362
    lea       %rax,	[%rbp + mwindows.os_execcmd.xpi]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    mov       [%rax+16],	%r10
    mov       %eax,	104
    mov       [%rbp + mwindows.os_execcmd.si],	%eax
    lea       %rax,	[%rbp + mwindows.os_execcmd.xpi]
    push      %rax
    lea       %rax,	[%rbp + mwindows.os_execcmd.si]
    push      %rax
    push      0
    push      0
    test      %rbx,	%rbx
    jz        L787
    mov       %rax,	16
    jmp       L786
L787:
    xor       %eax,	%eax
L786:
    mov       %r10,	32
    or        %r10,	%rax
    push      %r10
    push      1
    xor       %ecx,	%ecx
    mov       %rdx,	%rdi
    xor       %r8d,	%r8d
    xor       %r9d,	%r9d
    sub       %rsp,	32
    call      CreateProcessA
    add       %rsp,	80
    mov       %rcx,	[%rbp + mwindows.os_execcmd.xpi]
    call      CloseHandle
    mov       %rcx,	[%rbp + mwindows.os_execcmd.xpi+8]
    call      CloseHandle
    mov       %rax,	1
L785:
#---------------
    add       %rsp,	160
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mwindows.os_getch
mwindows.os_getch:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    call      mwindows.os_getchx
    and       %rax,	255
    mov       %rdi,	%rax
    mov       %rax,	%rdi
L788:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mwindows.os_kbhit
mwindows.os_kbhit:
#PROC1
#PROC2
#?>>
    .set mwindows.os_kbhit.count, -8
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+mwindows.init_flag]
    test      %rax,	%rax
    jnz       L791
    call      mwindows.os_init
L791:
    mov       %rcx,	[%rip+mwindows.hconsolein]
    lea       %rdx,	[%rbp + mwindows.os_kbhit.count]
    call      GetNumberOfConsoleInputEvents
    mov       %eax,	[%rbp + mwindows.os_kbhit.count]
    cmp       %rax,	1
    setg      %al
    movzx     %eax,	%al
L789:
#---------------
    add       %rsp,	48
    pop       %rbp
    ret       
# End 
# Proc mwindows.os_getdllinst
mwindows.os_getdllinst:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rbx
    call      LoadLibraryA
    mov       %rdi,	%rax
    mov       %rax,	%rdi
L792:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mwindows.os_getdllprocaddr
mwindows.os_getdllprocaddr:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      GetProcAddress
L793:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mwindows.os_initwindows
mwindows.os_initwindows:
#PROC1
#PROC2
#?>>
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    call      mwindows.os_init
    lea       %rcx,	[%rip+L8363]
    call      mwindows.os_gxregisterclass
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mwindows.os_gxregisterclass
mwindows.os_gxregisterclass:
#PROC1
#PROC2
#?>>
    .set mwindows.os_gxregisterclass.r, -80
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	120
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %al,	[%rip+mwindows.os_gxregisterclass.registered]
    test      %al,	%al
    jnz       L795
L797:
    lea       %rax,	[%rbp + mwindows.os_gxregisterclass.r]
    xor       %r10d,	%r10d
    mov       %r11,	10
L8364:
    mov       [%rax],	%r10
    add       %rax,	8
    dec       %r11
    jnz       L8364
    mov       %eax,	80
    mov       [%rbp + mwindows.os_gxregisterclass.r],	%eax
    mov       %eax,	40
    mov       [%rbp + mwindows.os_gxregisterclass.r+4],	%eax
    lea       %rax,	[%rip+mwindows.mainwndproc]
    mov       [%rbp + mwindows.os_gxregisterclass.r+8],	%rax
    xor       %eax,	%eax
    mov       [%rbp + mwindows.os_gxregisterclass.r+24],	%rax
    xor       %eax,	%eax
    mov       [%rbp + mwindows.os_gxregisterclass.r+32],	%rax
    xor       %ecx,	%ecx
    mov       %rdx,	32512
    call      LoadCursorA
    mov       [%rbp + mwindows.os_gxregisterclass.r+40],	%rax
    mov       %rax,	16
    mov       [%rbp + mwindows.os_gxregisterclass.r+48],	%rax
    xor       %eax,	%eax
    mov       [%rbp + mwindows.os_gxregisterclass.r+56],	%rax
    mov       [%rbp + mwindows.os_gxregisterclass.r+64],	%rdi
    xor       %eax,	%eax
    mov       [%rbp + mwindows.os_gxregisterclass.r+72],	%rax
    lea       %rcx,	[%rbp + mwindows.os_gxregisterclass.r]
    call      RegisterClassExA
    mov       %r10d,	%eax
    test      %r10,	%r10
    jnz       L799
    call      GetLastError
    mov       %r10d,	%eax
    lea       %rcx,	[%rip+L8365]
    mov       %rdx,	%rdi
    mov       %r8,	%r10
    call      printf
    mov       %rcx,	1
    call      exit
L799:
    mov       %al,	1
    mov       [%rip+mwindows.os_gxregisterclass.registered],	%al
L795:
#---------------
    add       %rsp,	120
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc mwindows.mainwndproc
mwindows.mainwndproc:
#PROC1
#PROC2
#?>>
    .set mwindows.mainwndproc.m, -48
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	88
    mov       %rbx,	%rcx
    mov       %esi,	%edx
    mov       %r12,	%r8
    mov       %r13,	%r9
#---------------
#PROC3
#PROC4
    mov       [%rbp + mwindows.mainwndproc.m],	%rbx
    mov       [%rbp + mwindows.mainwndproc.m+8],	%esi
    mov       [%rbp + mwindows.mainwndproc.m+16],	%r12
    mov       [%rbp + mwindows.mainwndproc.m+24],	%r13
    xor       %eax,	%eax
    mov       [%rbp + mwindows.mainwndproc.m+40],	%eax
    xor       %eax,	%eax
    mov       [%rbp + mwindows.mainwndproc.m+44],	%eax
    mov       %rax,	[%rip+mwindows.wndproc_callbackfn]
    test      %rax,	%rax
    jz        L802
    lea       %rcx,	[%rbp + mwindows.mainwndproc.m]
    mov       %rax,	[%rip+mwindows.wndproc_callbackfn]
    call      %rax
    mov       %rdi,	%rax
    jmp       L801
L802:
    xor       %rdi,	%rdi
L801:
    mov       %eax,	[%rbp + mwindows.mainwndproc.m+8]
    cmp       %rax,	2
    jnz       L804
    xor       %eax,	%eax
    jmp       L800
L804:
    test      %rdi,	%rdi
    jnz       L806
    mov       %eax,	%esi
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    mov       %r8,	%r12
    mov       %r9,	%r13
    call      DefWindowProcA
    jmp       L805
L806:
    xor       %eax,	%eax
L805:
L800:
#---------------
    add       %rsp,	88
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mwindows.os_setmesshandler
mwindows.os_setmesshandler:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       [%rip+mwindows.wndproc_callbackfn],	%rcx
#---------------
    ret       
# End 
# Proc mwindows.os_getchx
mwindows.os_getchx:
#PROC1
#PROC2
#?>>
    .set mwindows.os_getchx.count, -8
    .set mwindows.os_getchx.shiftdown, -16
    .set mwindows.os_getchx.capslock, -24
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	56
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+mwindows.init_flag]
    test      %rax,	%rax
    jnz       L810
    call      mwindows.os_init
L810:
    mov       %rax,	[%rip+mwindows.keypending]
    test      %rax,	%rax
    jz        L812
    lea       %rax,	[%rip+mwindows.pendkey]
    lea       %r10,	[%rip+mwindows.lastkey]
    mov       %r11,	[%rax]
    mov       [%r10],	%r11
    mov       %r11,	[%rax+8]
    mov       [%r10+8],	%r11
    mov       %r11d,	[%rax+16]
    mov       [%r10+16],	%r11d
    xor       %eax,	%eax
    mov       [%rip+mwindows.keypending],	%rax
    jmp       L811
L812:
    lea       %rax,	[%rip+mwindows.lastkey]
    movzx     %rax,	word ptr[%rax+8]
    test      %rax,	%rax
    jnz       L814
L815:
    xor       %eax,	%eax
    mov       [%rbp + mwindows.os_getchx.count],	%rax
    mov       %rcx,	[%rip+mwindows.hconsolein]
    lea       %rdx,	[%rip+mwindows.lastkey]
    mov       %r8,	1
    lea       %r9,	[%rbp + mwindows.os_getchx.count]
    call      ReadConsoleInputA
    lea       %rax,	[%rip+mwindows.lastkey]
    movzx     %rax,	word ptr[%rax]
    cmp       %rax,	1
    jnz       L815
    lea       %rax,	[%rip+mwindows.lastkey]
    mov       %eax,	[%rax+4]
    cmp       %rax,	1
    jnz       L815
L814:
L811:
    lea       %rax,	[%rip+mwindows.lastkey]
    mov       %eax,	[%rax+16]
    and       %rax,	3
    jz        L819
    mov       %rax,	1
    jmp       L818
L819:
    xor       %eax,	%eax
L818:
    mov       %r12,	%rax
    lea       %rax,	[%rip+mwindows.lastkey]
    mov       %eax,	[%rax+16]
    and       %rax,	12
    jz        L821
    mov       %rax,	1
    jmp       L820
L821:
    xor       %eax,	%eax
L820:
    mov       %r13,	%rax
    lea       %rax,	[%rip+mwindows.lastkey]
    mov       %eax,	[%rax+16]
    and       %rax,	16
    jz        L823
    mov       %rax,	1
    jmp       L822
L823:
    xor       %eax,	%eax
L822:
    mov       [%rbp + mwindows.os_getchx.shiftdown],	%rax
    lea       %rax,	[%rip+mwindows.lastkey]
    mov       %eax,	[%rax+16]
    and       %rax,	128
    jz        L825
    mov       %rax,	1
    jmp       L824
L825:
    xor       %eax,	%eax
L824:
    mov       [%rbp + mwindows.os_getchx.capslock],	%rax
    lea       %rax,	[%rip+mwindows.lastkey]
    lea       %rax,	[%rax+8]
    dec       word ptr[%rax]
    lea       %rax,	[%rip+mwindows.lastkey]
    movzx     %rax,	byte ptr[%rax+14]
    mov       %rdi,	%rax
    lea       %rax,	[%rip+mwindows.lastkey]
    movzx     %rax,	word ptr[%rax+10]
    and       %rax,	255
    mov       %rsi,	%rax
    cmp       %rdi,	0
    jge       L827
    cmp       %rdi,	-128
    jge       L829
    xor       %rdi,	%rdi
    jmp       L828
L829:
    mov       %rax,	256
    add       %rdi,	%rax
L828:
L827:
    test      %r12,	%r12
    jz        L831
    test      %r13,	%r13
    jz        L831
    cmp       %rdi,	166
    jnz       L831
    xor       %eax,	%eax
    mov       %r13,	%rax
    mov       %r12,	%rax
    jmp       L830
L831:
    test      %r12,	%r12
    jnz       L834
    test      %r13,	%r13
    jz        L833
L834:
    xor       %rdi,	%rdi
    mov       %rax,	%rsi
    cmp       %rax,	65
    jl        L836
    cmp       %rsi,	90
    jg        L836
    lea       %rax,	[%rsi-64]
    mov       %rdi,	%rax
L836:
L833:
L830:
    mov       %rax,	[%rbp + mwindows.os_getchx.capslock]
    shl       %rax,	3
    mov       %r10,	%r12
    shl       %r10,	2
    or        %rax,	%r10
    mov       %r10,	%r13
    shl       %r10,	1
    or        %rax,	%r10
    or        %rax,	[%rbp + mwindows.os_getchx.shiftdown]
    mov       %rbx,	%rax
    mov       %rax,	%rbx
    shl       %rax,	24
    mov       %r10,	%rsi
    shl       %r10,	16
    or        %rax,	%r10
    or        %rax,	%rdi
L808:
#---------------
    add       %rsp,	56
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mwindows.os_getos
mwindows.os_getos:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rip+L8366]
L837:
#---------------
    ret       
# End 
# Proc mwindows.os_gethostsize
mwindows.os_gethostsize:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       %rax,	64
L838:
#---------------
    ret       
# End 
# Proc mwindows.os_shellexec
mwindows.os_shellexec:
#PROC1
#PROC2
#?>>
    .set mwindows.os_shellexec.opc, 24
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rdx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    call      system
    movsxd    %r10,	%eax
    mov       %rax,	%r10
L839:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mwindows.os_sleep
mwindows.os_sleep:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    call      Sleep
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mwindows.os_getstdin
mwindows.os_getstdin:
#PROC1
#PROC2
#?>>
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    lea       %rcx,	[%rip+L8367]
    lea       %rdx,	[%rip+L8368]
    call      fopen
L841:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mwindows.os_getstdout
mwindows.os_getstdout:
#PROC1
#PROC2
#?>>
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    lea       %rcx,	[%rip+L8369]
    lea       %rdx,	[%rip+L8370]
    call      fopen
L842:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mwindows.os_gethostname
mwindows.os_gethostname:
#PROC1
#PROC2
#?>>
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    xor       %ecx,	%ecx
    lea       %rdx,	[%rip+mwindows.os_gethostname.name]
    mov       %r8,	300
    call      GetModuleFileNameA
    lea       %rax,	[%rip+mwindows.os_gethostname.name]
L843:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mwindows.os_getmpath
mwindows.os_getmpath:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rip+L8371]
L844:
#---------------
    ret       
# End 
# Proc mwindows.os_clock
mwindows.os_clock:
#PROC1
#PROC2
#?>>
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    call      mwindows.os_hpcounter
L845:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mwindows.os_ticks
mwindows.os_ticks:
#PROC1
#PROC2
#?>>
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    call      GetTickCount64
L846:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mwindows.os_iswindows
mwindows.os_iswindows:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       %rax,	1
L847:
#---------------
    ret       
# End 
# Proc mwindows.os_getsystime
mwindows.os_getsystime:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    call      GetLocalTime
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mwindows.os_peek
mwindows.os_peek:
#PROC1
#PROC2
#?>>
    .set mwindows.os_peek.m, -104
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	136
#---------------
#PROC3
#PROC4
    call      GetTickCount64
    mov       %rdi,	%rax
    mov       %rax,	%rdi
    sub       %rax,	[%rip+mwindows.os_peek.lastticks]
    cmp       %rax,	1000
    jl        L851
    mov       [%rip+mwindows.os_peek.lastticks],	%rdi
    sub       %rsp,	8
    push      0
    lea       %rcx,	[%rbp + mwindows.os_peek.m]
    xor       %edx,	%edx
    xor       %r8d,	%r8d
    xor       %r9d,	%r9d
    sub       %rsp,	32
    call      PeekMessageA
    add       %rsp,	48
L851:
#---------------
    add       %rsp,	136
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc mwindows.os_allocexecmem
mwindows.os_allocexecmem:
#PROC1
#PROC2
#?>>
    .set mwindows.os_allocexecmem.oldprot, -8
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %rsi,	%rcx
#---------------
#PROC3
#PROC4
    xor       %ecx,	%ecx
    mov       %rdx,	%rsi
    mov       %r8,	12288
    mov       %r9,	1
    call      VirtualAlloc
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L854
    xor       %eax,	%eax
    jmp       L852
L854:
    mov       %rcx,	%rdi
    mov       %rdx,	%rsi
    mov       %r8,	64
    lea       %r9,	[%rbp + mwindows.os_allocexecmem.oldprot]
    call      VirtualProtect
    mov       %r10d,	%eax
    mov       %rbx,	%r10
    test      %rbx,	%rbx
    jnz       L856
    xor       %eax,	%eax
    jmp       L852
L856:
    mov       %rax,	%rdi
L852:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mwindows.dirlist
mwindows.dirlist:
#PROC1
#PROC2
#?>>
    .set mwindows.dirlist.file, -328
    .set mwindows.dirlist.path, -632
    .set mwindows.dirlist.fullfilename, -936
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	976
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
    mov       %r14,	%r9
#---------------
#PROC3
#PROC4
    xor       %rbx,	%rbx
    mov       %rcx,	%rsi
    call      mlib.extractpath
    lea       %rcx,	[%rbp + mwindows.dirlist.path]
    mov       %rdx,	%rax
    call      strcpy
    mov       %rcx,	%rsi
    lea       %rdx,	[%rbp + mwindows.dirlist.file]
    call      FindFirstFileA
    mov       %rdi,	%rax
    cmp       %rax,	-1
    jz        L859
L860:
    mov       %eax,	[%rbp + mwindows.dirlist.file]
    and       %rax,	16
    jz        L864
    mov       %rax,	%r14
    and       %rax,	2
    jnz       L866
    jmp       L861
L866:
    jmp       L863
L864:
    mov       %rax,	%r14
    and       %rax,	1
    jnz       L868
    jmp       L861
L868:
L863:
    cmp       %rbx,	%r13
    jl        L870
    mov       %rbx,	-1
    jmp       L862
L870:
    mov       %rax,	%r14
    and       %rax,	4
    jz        L872
    lea       %rax,	[%rbp + mwindows.dirlist.file+44]
    mov       %rcx,	%rax
    call      mlib.convlcstring
L872:
    lea       %rcx,	[%rbp + mwindows.dirlist.fullfilename]
    lea       %rdx,	[%rbp + mwindows.dirlist.path]
    call      strcpy
    lea       %rax,	[%rbp + mwindows.dirlist.file+44]
    lea       %rcx,	[%rbp + mwindows.dirlist.fullfilename]
    mov       %rdx,	%rax
    call      strcat
    lea       %rcx,	[%rbp + mwindows.dirlist.fullfilename]
    call      mlib.pcm_copyheapstring
    inc       %rbx
    mov       %r10,	%rbx
    mov       [%r12 + %r10*8-8],	%rax
L861:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rbp + mwindows.dirlist.file]
    call      FindNextFileA
    test      %eax,	%eax
    jnz       L860
L862:
    mov       %rcx,	%rdi
    call      FindClose
L859:
    mov       %rax,	%rbx
L857:
#---------------
    add       %rsp,	976
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mwindows.os_hpcounter
mwindows.os_hpcounter:
#PROC1
#PROC2
#?>>
    .set mwindows.os_hpcounter.a, -8
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+mwindows.hpfreq]
    test      %rax,	%rax
    jnz       L875
    call      mwindows.os_hpfreq
    mov       %r10,	1000
    cqo       
    idiv      %r10
    mov       [%rip+mwindows.hpfreq],	%rax
L875:
    lea       %rcx,	[%rbp + mwindows.os_hpcounter.a]
    call      QueryPerformanceCounter
    mov       %rax,	[%rbp + mwindows.os_hpcounter.a]
    mov       %r10,	[%rip+mwindows.hpfreq]
    cqo       
    idiv      %r10
L873:
#---------------
    add       %rsp,	48
    pop       %rbp
    ret       
# End 
# Proc mwindows.os_hpfreq
mwindows.os_hpfreq:
#PROC1
#PROC2
#?>>
    .set mwindows.os_hpfreq.a, -8
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    lea       %rcx,	[%rbp + mwindows.os_hpfreq.a]
    call      QueryPerformanceFrequency
    mov       %rax,	[%rbp + mwindows.os_hpfreq.a]
L876:
#---------------
    add       %rsp,	48
    pop       %rbp
    ret       
# End 
# Proc mwindll.os_calldllfunction
mwindll.os_calldllfunction:
#PROC1
#PROC2
#?>>
    .set mwindll.os_calldllfunction.fnaddr, 16
    .set mwindll.os_calldllfunction.retcode, 24
    .set mwindll.os_calldllfunction.nargs, 32
    .set mwindll.os_calldllfunction.args, 40
    .set mwindll.os_calldllfunction.argcodes, 48
    .set mwindll.os_calldllfunction.a, -8
    .set mwindll.os_calldllfunction.x, -16
    .set mwindll.os_calldllfunction.nextra, -24
    .set mwindll.os_calldllfunction.pushedbytes, -32
    .set mwindll.os_calldllfunction.av_1, -40
    .set mwindll.os_calldllfunction.i, -48
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	80
    mov       [%rbp+16],	%rcx
    mov       [%rbp+24],	%rdx
    mov       [%rbp+32],	%r8
    mov       [%rbp+40],	%r9
#---------------
#PROC3
#PROC4
    xor       %eax,	%eax
    mov       [%rbp + mwindll.os_calldllfunction.nextra],	%rax
    mov       %rax,	[%rbp + mwindll.os_calldllfunction.nargs]
    cmp       %rax,	4
    jge       L879
    mov       %rax,	4
    sub       %rax,	[%rbp + mwindll.os_calldllfunction.nargs]
    mov       [%rbp + mwindll.os_calldllfunction.nextra],	%rax
    jmp       L878
L879:
    mov       %eax,	[%rbp + mwindll.os_calldllfunction.nargs]
    and       %eax,	1
    test      %rax,	%rax
    jz        L880
    mov       %rax,	1
    mov       [%rbp + mwindll.os_calldllfunction.nextra],	%rax
L880:
L878:
    mov       %rax,	[%rbp + mwindll.os_calldllfunction.nextra]
    add       %rax,	[%rbp + mwindll.os_calldllfunction.nargs]
    shl       %rax,	3
    mov       [%rbp + mwindll.os_calldllfunction.pushedbytes],	%rax
    mov       %rax,	[%rbp + mwindll.os_calldllfunction.nextra]
    mov       [%rbp + mwindll.os_calldllfunction.av_1],	%rax
    mov       %rax,	[%rbp + mwindll.os_calldllfunction.av_1]
    cmp       %rax,	0
    jle       L883
L881:
    push      0
    dec       qword ptr[%rbp + mwindll.os_calldllfunction.av_1]
    jnz       L881
L883:
    mov       %rax,	[%rbp + mwindll.os_calldllfunction.nargs]
    mov       [%rbp + mwindll.os_calldllfunction.i],	%rax
    mov       %rax,	[%rbp + mwindll.os_calldllfunction.i]
    cmp       %rax,	1
    jl        L886
L884:
    mov       %rax,	[%rbp + mwindll.os_calldllfunction.args]
    mov       %r10,	[%rbp + mwindll.os_calldllfunction.i]
    mov       %rax,	[%rax + %r10*8-8]
    mov       [%rbp + mwindll.os_calldllfunction.a],	%rax
    push      qword ptr[%rbp + mwindll.os_calldllfunction.a]
    mov       %rax,	[%rbp + mwindll.os_calldllfunction.i]
    dec       %rax
    mov       [%rbp + mwindll.os_calldllfunction.i],	%rax
    cmp       %rax,	1
    jge       L884
L886:
    mov       %rcx,	[%rsp]
    movq      %XMM0,	[%rsp]
    mov       %rdx,	[%rsp+8]
    movq      %XMM1,	[%rsp+8]
    mov       %r8,	[%rsp+16]
    movq      %XMM2,	[%rsp+16]
    mov       %r9,	[%rsp+24]
    movq      %XMM3,	[%rsp+24]
    mov       %rax,	[%rbp + mwindll.os_calldllfunction.retcode]
    cmp       %rax,	73
    jnz       L888
    mov       %rax,	[%rbp + mwindll.os_calldllfunction.fnaddr]
    call      %rax
    mov       [%rbp + mwindll.os_calldllfunction.a],	%rax
    add       %rsp,	[%rbp + mwindll.os_calldllfunction.pushedbytes]
    mov       %rax,	[%rbp + mwindll.os_calldllfunction.a]
    jmp       L887
L888:
    mov       %rax,	[%rbp + mwindll.os_calldllfunction.fnaddr]
    call      %rax
    movq      [%rbp + mwindll.os_calldllfunction.x],	%XMM0
    add       %rsp,	[%rbp + mwindll.os_calldllfunction.pushedbytes]
    movq      %XMM4,	[%rbp + mwindll.os_calldllfunction.x]
    movq      %rax,	%XMM4
L887:
L877:
#---------------
    add       %rsp,	80
    pop       %rbp
    ret       
# End 
# Proc pc_api.pcl_start
pc_api.pcl_start:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    mov       %al,	[%rip+pc_decls.pcldone]
    test      %al,	%al
    jz        L891
    lea       %rcx,	[%rip+L8372]
    call      pc_api.pclerror
L891:
    test      %rdi,	%rdi
    jz        L893
    mov       %rcx,	%rdi
    mov       %rdx,	9
    call      pc_api.pc_makesymbol
    mov       [%rip+pc_decls.currprog],	%rax
L893:
    mov       %rax,	[%rip+pc_api.initpcalloc]
    mov       [%rip+pc_api.pcalloc],	%rax
    test      %rbx,	%rbx
    jz        L895
    mov       %rax,	%rbx
    lea       %rax,	[%rax + %rax*8]
    sar       %rax,	3
    mov       %rbx,	%rax
    jmp       L897
L896:
    mov       %rax,	[%rip+pc_api.pcalloc]
    shl       %rax,	1
    mov       [%rip+pc_api.pcalloc],	%rax
L897:
    mov       %rax,	[%rip+pc_api.pcalloc]
    cmp       %rax,	%rbx
    jl        L896
L895:
    mov       %rax,	[%rip+pc_api.pcalloc]
    shl       %rax,	5
    mov       %rcx,	%rax
    call      mlib.pcm_allocz
    mov       [%rip+pc_api.pcstart],	%rax
    mov       %rax,	[%rip+pc_api.pcstart]
    mov       %r10,	[%rip+pc_api.pcalloc]
    shl       %r10,	5
    lea       %rax,	[%rax + %r10]
    sub       %rax,	256
    mov       [%rip+pc_api.pcend],	%rax
    mov       %rax,	[%rip+pc_api.pcstart]
    sub       %rax,	32
    mov       [%rip+pc_api.pccurr],	%rax
    xor       %eax,	%eax
    mov       [%rip+pc_api.pcfixed],	%al
    xor       %eax,	%eax
    mov       [%rip+pc_api.pcseqno],	%rax
    xor       %eax,	%eax
    mov       [%rip+pc_api.pcneedfntable],	%rax
    xor       %eax,	%eax
    mov       [%rip+pc_api.mlabelno],	%rax
    mov       %rax,	[%rip+pc_decls.currprog]
L889:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pcl_end
pc_api.pcl_end:
#PROC1
#PROC2
#?>>
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+pc_api.pccurr]
    cmp       %rax,	[%rip+pc_api.pccurr]
    jb        L901
    mov       %rax,	[%rip+pc_api.pccurr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	136
    jz        L901
    mov       %rcx,	136
    xor       %edx,	%edx
    call      pc_api.pc_gen
L901:
    mov       %al,	1
    mov       [%rip+pc_decls.pcldone],	%al
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc pc_api.pcl_writepcl
pc_api.pcl_writepcl:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    call      pc_diags.writeallpcl
    mov       %rdi,	%rax
    test      %rbx,	%rbx
    jz        L904
    mov       %al,	[%rip+pc_decls.pverbose]
    test      %al,	%al
    jz        L906
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8373]
    call      msys.m$print_str_nf
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L906:
    movsxd    %rax,	dword ptr[%rdi+8]
    mov       %r10,	[%rdi]
    mov       %rcx,	%rbx
    mov       %rdx,	%r10
    mov       %r8,	%rax
    call      mlib.writefile
    lea       %rax,	[%rip+L8374]
    jmp       L903
L904:
    mov       %rax,	[%rdi]
L903:
L902:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pcl_writepst
pc_api.pcl_writepst:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    call      pc_diags.writepst
    mov       %rdi,	%rax
    test      %rbx,	%rbx
    jz        L909
    mov       %al,	[%rip+pc_decls.pverbose]
    test      %al,	%al
    jz        L911
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8375]
    call      msys.m$print_str_nf
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L911:
    movsxd    %rax,	dword ptr[%rdi+8]
    mov       %r10,	[%rdi]
    mov       %rcx,	%rbx
    mov       %rdx,	%r10
    mov       %r8,	%rax
    call      mlib.writefile
    lea       %rax,	[%rip+L8376]
    jmp       L908
L909:
    mov       %rax,	[%rdi]
L908:
L907:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pcl_genmcl
pc_api.pcl_genmcl:
#PROC1
#PROC2
#?>>
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    xor       %ecx,	%ecx
    call      mc_genmcl.genmcl
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc pc_api.pcl_genss
pc_api.pcl_genss:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    xor       %ecx,	%ecx
    call      mc_genmcl.genmcl
    mov       %rcx,	%rdi
    call      mc_genss_dummy.genss
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc pc_api.pcl_writess
pc_api.pcl_writess:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
#PROC3
#PROC4
    xor       %ecx,	%ecx
    call      mc_genmcl.genmcl
    mov       %rcx,	%r12
    call      mc_genss_dummy.genss
    mov       %rax,	%r12
    test      %rax,	%rax
    setz      %al
    movzx     %eax,	%al
    mov       %rcx,	%rax
    call      mc_writess_dummy.writessdata
    mov       %rdi,	%rax
    test      %rsi,	%rsi
    jz        L916
    mov       %rcx,	%rsi
    lea       %rdx,	[%rip+L8377]
    call      fopen
    mov       %rbx,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mlib.gs_println
    mov       %rcx,	%rbx
    call      fclose
    mov       %rcx,	%rdi
    call      mlib.gs_free
    xor       %eax,	%eax
    jmp       L915
L916:
    mov       %rax,	[%rdi]
L915:
L914:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pcl_writeasm
pc_api.pcl_writeasm:
#PROC1
#PROC2
#?>>
    .set pc_api.pcl_writeasm.atype, 48
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+pc_decls.assemtype]
    cmp       %rax,	1297301838
    jnz       L919
    mov       %al,	2
    mov       [%rip+pc_api.phighmem],	%al
L919:
    xor       %ecx,	%ecx
    call      mc_genmcl.genmcl
    call      mc_writegas.getassemstr
    mov       %rdi,	%rax
    test      %rsi,	%rsi
    jz        L921
    mov       %al,	[%rip+pc_decls.pverbose]
    test      %al,	%al
    jz        L923
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8378]
    call      msys.m$print_str_nf
    mov       %rcx,	%rsi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L923:
    mov       %rcx,	%rsi
    lea       %rdx,	[%rip+L8379]
    call      fopen
    mov       %rbx,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mlib.gs_println
    mov       %rcx,	%rbx
    call      fclose
    mov       %rcx,	%rdi
    call      mlib.gs_free
    xor       %eax,	%eax
    jmp       L920
L921:
    mov       %rax,	[%rdi]
L920:
L917:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pcl_writeobj
pc_api.pcl_writeobj:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    xor       %ecx,	%ecx
    call      mc_genmcl.genmcl
    mov       %rcx,	1
    call      mc_genss_dummy.genss
    xor       %eax,	%eax
    mov       [%rip+pc_api.phighmem],	%al
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8380]
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rip+pc_api.phighmem]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      mwindows.os_clock
    mov       %rdi,	%rax
    mov       %rcx,	%rbx
    call      mc_writeobj_dummy.writecoff
    call      mwindows.os_clock
    sub       %rax,	%rdi
    mov       [%rip+pc_decls.objtime],	%rax
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pcl_writedll
pc_api.pcl_writedll:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    mov       %al,	2
    mov       [%rip+pc_api.phighmem],	%al
    xor       %ecx,	%ecx
    call      mc_genmcl.genmcl
    xor       %ecx,	%ecx
    call      mc_genss_dummy.genss
    call      mwindows.os_clock
    mov       %rdi,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      mc_writeexe_dummy.writeexe
    call      mwindows.os_clock
    sub       %rax,	%rdi
    mov       [%rip+pc_decls.exetime],	%rax
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pcl_writeexe
pc_api.pcl_writeexe:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    xor       %ecx,	%ecx
    call      mc_genmcl.genmcl
    xor       %ecx,	%ecx
    call      mc_genss_dummy.genss
    call      mwindows.os_clock
    mov       %rdi,	%rax
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      mc_writeexe_dummy.writeexe
    call      mwindows.os_clock
    sub       %rax,	%rdi
    mov       [%rip+pc_decls.exetime],	%rax
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pcl_writemx
pc_api.pcl_writemx:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    xor       %ecx,	%ecx
    call      mc_genmcl.genmcl
    xor       %ecx,	%ecx
    call      mc_genss_dummy.genss
    mov       %rcx,	%rdi
    call      mx_run_dummy.writemcx
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc pc_api.pcl_exec
pc_api.pcl_exec:
#PROC1
#PROC2
#?>>
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    xor       %ecx,	%ecx
    call      mc_genmcl.genmcl
    xor       %ecx,	%ecx
    call      mc_genss_dummy.genss
    lea       %rcx,	[%rip+L8381]
    mov       %rdx,	[%rip+pc_decls.pcmdskip]
    call      mx_run_dummy.runlibfile
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc pc_api.pcl_setflags
pc_api.pcl_setflags:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    cmp       %rcx,	0
    jl        L931
    mov       [%rip+pc_api.phighmem],	%cl
L931:
    cmp       %rdx,	0
    jl        L933
    mov       [%rip+pc_decls.pverbose],	%dl
L933:
    cmp       %r8,	0
    jl        L935
    mov       [%rip+pc_api.fpshortnames],	%r8b
L935:
#---------------
    ret       
# End 
# Proc pc_api.extendpclblock
pc_api.extendpclblock:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+pc_api.pcalloc]
    shl       %rax,	1
    mov       %rdi,	%rax
    mov       %rax,	[%rip+pc_api.pccurr]
    sub       %rax,	[%rip+pc_api.pcstart]
    shr       %rax,	5
    inc       %rax
    mov       %rbx,	%rax
    mov       %rax,	32
    mov       %r10,	%rdi
    imul      %rax,	%r10
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       %rsi,	%rax
    mov       %rax,	%rbx
    shl       %rax,	5
    mov       %rcx,	%rsi
    mov       %rdx,	[%rip+pc_api.pcstart]
    mov       %r8,	%rax
    call      memcpy
    mov       %rax,	%rdi
    sub       %rax,	%rbx
    shl       %rax,	5
    mov       %r10,	%rbx
    shl       %r10,	5
    lea       %r11,	[%rsi + %r10]
    mov       %rcx,	%r11
    mov       %rdx,	%rax
    call      mlib.pcm_clearmem
    mov       %rax,	[%rip+pc_api.pccurr]
    sub       %rax,	[%rip+pc_api.pcstart]
    shr       %rax,	5
    shl       %rax,	5
    lea       %r10,	[%rsi + %rax]
    mov       [%rip+pc_api.pccurr],	%r10
    mov       %rax,	%rdi
    shl       %rax,	5
    lea       %r10,	[%rsi + %rax]
    sub       %r10,	256
    mov       [%rip+pc_api.pcend],	%r10
    mov       %rax,	[%rip+pc_api.pcalloc]
    shl       %rax,	5
    mov       %rcx,	[%rip+pc_api.pcstart]
    mov       %rdx,	%rax
    call      mlib.pcm_free
    mov       [%rip+pc_api.pcstart],	%rsi
    mov       [%rip+pc_api.pcalloc],	%rdi
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.newpcl
pc_api.newpcl:
#PROC1
#PROC2
#?>>
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+pc_api.pccurr]
    cmp       %rax,	[%rip+pc_api.pcend]
    jb        L939
    call      pc_api.extendpclblock
L939:
    add       qword ptr[%rip+pc_api.pccurr],	32
    mov       %eax,	[%rip+pc_decls.mmpos]
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+24],	%eax
    inc       qword ptr[%rip+pc_api.pclseqno]
    mov       %rax,	[%rip+pc_api.pclseqno]
    mov       %r10,	[%rip+pc_api.pccurr]
    lea       %r10,	[%r10+28]
    mov       %r9d,	[%r10]
    mov       %r11,	-4294967041
    shl       %eax,	8
    and       %r9d,	%r11d
    or        %r9d,	%eax
    mov       [%r10],	%r9d
    inc       qword ptr[%rip+pc_decls.npcl]
    mov       %rax,	[%rip+pc_api.pccurr]
L937:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc pc_api.pc_gen
pc_api.pc_gen:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    test      %rbx,	%rbx
    jnz       L942
    call      pc_api.newpcl
    mov       %rbx,	%rax
L942:
    mov       [%rbx],	%dil
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pc_genix
pc_api.pc_genix:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
#PROC3
#PROC4
    call      pc_api.newpcl
    mov       %rdi,	%rax
    mov       [%rdi],	%bl
    mov       [%rdi+16],	%esi
    mov       [%rdi+20],	%r12d
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pc_genx
pc_api.pc_genx:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
#PROC3
#PROC4
    test      %rsi,	%rsi
    jnz       L946
    call      pc_api.newpcl
    mov       %rsi,	%rax
L946:
    mov       [%rsi],	%dil
    mov       [%rsi+16],	%ebx
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pc_genxy
pc_api.pc_genxy:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
    mov       %r12,	%r9
#---------------
#PROC3
#PROC4
    test      %r12,	%r12
    jnz       L949
    call      pc_api.newpcl
    mov       %r12,	%rax
L949:
    mov       [%r12],	%dil
    mov       [%r12+16],	%ebx
    mov       [%r12+20],	%esi
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pc_gencond
pc_api.pc_gencond:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
#PROC3
#PROC4
    test      %rsi,	%rsi
    jnz       L952
    call      pc_api.newpcl
    mov       %rsi,	%rax
L952:
    mov       [%rsi],	%dil
    mov       [%rsi+2],	%bl
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.genint
pc_api.genint:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    call      pc_api.newpcl
    mov       %rdi,	%rax
    mov       [%rdi+8],	%rbx
    mov       %al,	4
    mov       [%rdi+1],	%al
    mov       %rax,	%rdi
L953:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.genreal
pc_api.genreal:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    movq      %rax,	%XMM15
    push      %rax
#?]]
    sub       %rsp,	48
    movq      %XMM15,	%XMM0
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    call      pc_api.newpcl
    mov       %rdi,	%rax
    movq      %XMM4,	%XMM15
    movq      [%rdi+8],	%XMM4
    cmp       %rbx,	2
    jnz       L956
    mov       %rax,	5
    jmp       L955
L956:
    mov       %rax,	6
L955:
    mov       [%rdi+1],	%al
    mov       %rax,	%rdi
L954:
#---------------
    add       %rsp,	48
    pop       %rcx
    movq      %XMM15,	%rcx
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.genrealimm
pc_api.genrealimm:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    movq      %rax,	%XMM15
    push      %rax
#?]]
    sub       %rsp,	48
    movq      %XMM15,	%XMM0
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    call      pc_api.newpcl
    mov       %rdi,	%rax
    movq      %XMM4,	%XMM15
    movq      [%rdi+8],	%XMM4
    cmp       %rbx,	2
    jnz       L959
    mov       %rax,	10
    jmp       L958
L959:
    mov       %rax,	11
L958:
    mov       [%rdi+1],	%al
    mov       %rax,	%rdi
L957:
#---------------
    add       %rsp,	48
    pop       %rcx
    movq      %XMM15,	%rcx
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.genstring
pc_api.genstring:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    call      pc_api.newpcl
    mov       %rdi,	%rax
    mov       %rcx,	%rbx
    call      mlib.pcm_copyheapstring
    mov       [%rdi+8],	%rax
    mov       %al,	7
    mov       [%rdi+1],	%al
    mov       %rax,	%rdi
L960:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.genpcstrimm
pc_api.genpcstrimm:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    call      pc_api.newpcl
    mov       %rdi,	%rax
    mov       %rcx,	%rbx
    call      mlib.pcm_copyheapstring
    mov       [%rdi+8],	%rax
    mov       %al,	8
    mov       [%rdi+1],	%al
    mov       %rax,	%rdi
L961:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.genlabel
pc_api.genlabel:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    call      pc_api.newpcl
    mov       %rdi,	%rax
    mov       [%rdi+8],	%rbx
    mov       %al,	3
    mov       [%rdi+1],	%al
    mov       %rax,	%rdi
L962:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.genmem
pc_api.genmem:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    call      pc_api.newpcl
    mov       %rdi,	%rax
    mov       [%rdi+8],	%rbx
    mov       %al,	1
    mov       [%rdi+1],	%al
    mov       %rax,	%rdi
L963:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.genmemaddr
pc_api.genmemaddr:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    call      pc_api.newpcl
    mov       %rdi,	%rax
    mov       [%rdi+8],	%rbx
    mov       %al,	2
    mov       [%rdi+1],	%al
    mov       %rax,	%rdi
L964:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.gendata
pc_api.gendata:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
#PROC3
#PROC4
    call      pc_api.newpcl
    mov       %rdi,	%rax
    mov       [%rdi+8],	%rbx
    mov       %al,	12
    mov       [%rdi+1],	%al
    mov       %al,	11
    mov       [%rdi+3],	%al
    mov       [%rdi+4],	%esi
    mov       %rax,	%rdi
L965:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.gencomment
pc_api.gencomment:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %al,	[%rip+pc_decls.fregoptim]
    test      %al,	%al
    jnz       L969
    mov       %al,	[%rip+pc_decls.fpeephole]
    test      %al,	%al
    jz        L968
L969:
    jmp       L966
L968:
    mov       %rcx,	%rdi
    call      pc_api.genpcstrimm
    mov       %rcx,	135
    mov       %rdx,	%rax
    call      pc_api.pc_gen
L966:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc pc_api.genname
pc_api.genname:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    mov       %rdx,	8
    call      pc_api.pc_makesymbol
    mov       %rcx,	%rax
    call      pc_api.genmem
L970:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc pc_api.gennameaddr
pc_api.gennameaddr:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    mov       %rdx,	8
    call      pc_api.pc_makesymbol
    mov       %rcx,	%rax
    call      pc_api.genmemaddr
L971:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc pc_api.genassem
pc_api.genassem:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    call      pc_api.newpcl
    mov       %rdi,	%rax
    mov       [%rdi+8],	%rbx
    mov       %al,	9
    mov       [%rdi+1],	%al
    mov       %rax,	%rdi
L972:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.strpmode
pc_api.strpmode:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    lea       %rcx,	[%rip+pc_api.strpmode.str]
    lea       %rdx,	[%rip+L8382]
    call      strcpy
    mov       %rax,	%rdi
    cmp       %rax,	11
    jz        L975
    test      %rax,	%rax
    jz        L976
    jmp       L977
L975:
    lea       %rcx,	[%rip+pc_api.strpmode.str]
    lea       %rdx,	[%rip+L8383]
    call      strcpy
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      msys.strint
    lea       %rcx,	[%rip+pc_api.strpmode.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rax,	[%rip+pc_api.strpmode.str]
    jmp       L974
L976:
    lea       %rax,	[%rip+L8384]
    jmp       L974
L977:
    lea       %rax,	[%rip+pc_tables.pstdnames]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
L974:
L973:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pc_setmode
pc_api.pc_setmode:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       %al,	%cl
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+3],	%al
    test      %rdx,	%rdx
    jz        L980
    mov       %eax,	%edx
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+4],	%eax
    jmp       L979
L980:
    mov       %rax,	[%rip+pc_api.pccurr]
    movzx     %rax,	byte ptr[%rax+3]
    lea       %r10,	[%rip+pc_tables.psize]
    movzx     %r10,	byte ptr[%r10 + %rax]
    mov       %rax,	[%rip+pc_api.pccurr]
    mov       [%rax+4],	%r10d
L979:
    mov       %rax,	[%rip+pc_api.pccurr]
    movzx     %rax,	byte ptr[%rax]
    lea       %r10,	[%rip+pc_tables.pclhastype]
    movzx     %r10,	byte ptr[%r10 + %rax]
    cmp       %r10,	2
    jnz       L982
    mov       %rax,	[%rip+pc_api.pccurr]
    movzx     %rax,	byte ptr[%rax+3]
    mov       %r10,	[%rip+pc_api.pccurr]
    lea       %r10,	[%r10+28]
    mov       %r9d,	[%r10]
    mov       %r11,	-256
    and       %r9d,	%r11d
    or        %r9d,	%eax
    mov       [%r10],	%r9d
L982:
#---------------
    ret       
# End 
# Proc pc_api.pc_setmode2
pc_api.pc_setmode2:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+pc_api.pccurr]
    lea       %rax,	[%rax+28]
    mov       %r10d,	%ecx
    mov       %r9d,	[%rax]
    mov       %r11,	-256
    and       %r9d,	%r11d
    or        %r9d,	%r10d
    mov       [%rax],	%r9d
#---------------
    ret       
# End 
# Proc pc_api.pc_setxy
pc_api.pc_setxy:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       %eax,	%ecx
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+16],	%eax
    mov       %eax,	%edx
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+20],	%eax
#---------------
    ret       
# End 
# Proc pc_api.pc_setscaleoff
pc_api.pc_setscaleoff:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       %eax,	%ecx
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+16],	%eax
    mov       %eax,	%edx
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+20],	%eax
#---------------
    ret       
# End 
# Proc pc_api.pc_setoffset
pc_api.pc_setoffset:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       %eax,	%ecx
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+20],	%eax
#---------------
    ret       
# End 
# Proc pc_api.pc_addoffset
pc_api.pc_addoffset:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+pc_api.pccurr]
    lea       %rax,	[%rax+20]
    mov       %r10d,	%ecx
    add       [%rax],	%r10d
#---------------
    ret       
# End 
# Proc pc_api.pc_setincr
pc_api.pc_setincr:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       %eax,	%ecx
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+16],	%eax
#---------------
    ret       
# End 
# Proc pc_api.pc_setnargs
pc_api.pc_setnargs:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       %eax,	%ecx
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+16],	%eax
#---------------
    ret       
# End 
# Proc pc_api.pc_setnvariadics
pc_api.pc_setnvariadics:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       %eax,	%ecx
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+20],	%eax
#---------------
    ret       
# End 
# Proc pc_api.pc_setalign
pc_api.pc_setalign:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       %eax,	%ecx
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+16],	%eax
#---------------
    ret       
# End 
# Proc pc_api.perror
pc_api.perror:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      pc_api.perror_s
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc pc_api.perror_s
pc_api.perror_s:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8385]
    call      msys.m$print_str_nf
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    call      msys.m$print_end
    test      %rbx,	%rbx
    jz        L995
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8386]
    call      msys.m$print_str_nf
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    call      msys.m$print_end
L995:
    mov       %rcx,	1
    call      exit
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.getbasename
pc_api.getbasename:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rbx
    call      strlen
    lea       %r10,	[%rbx + %rax]
    sub       %r10,	1
    mov       %rdi,	%r10
    jmp       L998
L997:
    dec       %rdi
L998:
    cmp       %rdi,	%rbx
    jbe       L1000
    lea       %rax,	[%rdi-1]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	46
    jnz       L997
L1000:
    mov       %rax,	%rdi
L996:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pclerror
pc_api.pclerror:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8387]
    call      msys.m$print_str_nf
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	1
    call      exit
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc pc_api.pc_addsymbol
pc_api.pc_addsymbol:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+pc_decls.psymboltable]
    test      %rax,	%rax
    jnz       L1004
    mov       %rax,	%rcx
    mov       [%rip+pc_decls.psymboltablex],	%rax
    mov       [%rip+pc_decls.psymboltable],	%rax
    jmp       L1003
L1004:
    mov       %rax,	%rcx
    mov       %r10,	[%rip+pc_decls.psymboltablex]
    mov       [%r10+8],	%rax
    mov       [%rip+pc_decls.psymboltablex],	%rcx
L1003:
#---------------
    ret       
# End 
# Proc pc_api.pc_makesymbol
pc_api.pc_makesymbol:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
#PROC3
#PROC4
    inc       qword ptr[%rip+pc_decls.npst]
    mov       %rcx,	128
    call      mlib.pcm_allocnfz
    mov       %rdi,	%rax
    mov       %rcx,	%rbx
    call      mlib.pcm_copyheapstring
    mov       [%rdi],	%rax
    inc       qword ptr[%rip+pc_api.stseqno]
    mov       %rax,	[%rip+pc_api.stseqno]
    mov       [%rdi+120],	%eax
    mov       %rax,	%rsi
    cmp       %rax,	1
    jz        L1007
    cmp       %rax,	7
    jz        L1008
    jmp       L1009
L1007:
    mov       %al,	1
    mov       [%rdi+80],	%al
    jmp       L1006
L1008:
    mov       %al,	1
    mov       [%rdi+81],	%al
    mov       %rsi,	2
L1009:
L1006:
    mov       [%rdi+72],	%sil
    mov       %rax,	%rsi
    cmp       %rax,	4
    jz        L1012
    cmp       %rax,	5
    jnz       L1011
L1012:
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       [%rdi+32],	%rax
    jmp       L1010
L1011:
    test      %rsi,	%rsi
    jz        L1013
    mov       %rcx,	%rdi
    call      pc_api.pc_addsymbol
L1013:
L1010:
    mov       %rax,	%rdi
L1005:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.getfullname
pc_api.getfullname:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
#PROC3
#PROC4
    xor       %rdi,	%rdi
    mov       %rax,	%rsi
    mov       %rbx,	%rax
    xor       %eax,	%eax
    lea       %r10,	[%rip+pc_api.getfullname.str]
    mov       [%r10],	%al
    test      %r12,	%r12
    jz        L1016
    lea       %rcx,	[%rip+pc_api.getfullname.str]
    lea       %rdx,	[%rip+L8388]
    call      strcpy
L1016:
    mov       %al,	[%rsi+80]
    test      %al,	%al
    jz        L1018
    test      %r12,	%r12
    jz        L1020
    mov       %rax,	[%rsi]
    lea       %rcx,	[%rip+pc_api.getfullname.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rcx,	[%rip+pc_api.getfullname.str]
    lea       %rdx,	[%rip+L8389]
    call      strcat
    jmp       L1019
L1020:
    mov       %rax,	[%rsi]
    lea       %rcx,	[%rip+pc_api.getfullname.str]
    mov       %rdx,	%rax
    call      strcat
L1019:
    lea       %rax,	[%rip+pc_api.getfullname.str]
    jmp       L1014
L1018:
    movzx     %rax,	byte ptr[%rsi+72]
    cmp       %rax,	4
    jz        L1023
    cmp       %rax,	5
    jnz       L1022
L1023:
    mov       %rax,	[%rsi+32]
    mov       %rax,	[%rax]
    lea       %rcx,	[%rip+pc_api.getfullname.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rcx,	[%rip+pc_api.getfullname.str]
    lea       %rdx,	[%rip+L8390]
    call      strcat
    mov       %rax,	[%rsi]
    lea       %rcx,	[%rip+pc_api.getfullname.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rax,	[%rip+pc_api.getfullname.str]
    jmp       L1014
L1022:
    test      %r12,	%r12
    jz        L1025
    mov       %rax,	[%rsi]
    lea       %rcx,	[%rip+pc_api.getfullname.str]
    mov       %rdx,	%rax
    call      strcat
    jmp       L1024
L1025:
    mov       %rax,	[%rsi]
L1024:
L1014:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pcerrorstop
pc_api.pcerrorstop:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
#PROC3
#PROC4
    lea       %rcx,	[%rip+L8391]
    lea       %rdx,	[%rip+L8392]
    call      fopen
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    call      msys.m$print_startfile
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    mov       %rcx,	%rsi
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%rdi
    call      fclose
    mov       %rcx,	1
    call      exit
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pc_addplib
pc_api.pc_addplib:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+pc_decls.nplibfiles]
    cmp       %rax,	50
    jl        L1029
    lea       %rcx,	[%rip+L8393]
    call      pc_api.perror
L1029:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8394]
    call      mlib.changeext
    mov       %rcx,	%rax
    call      mlib.pcm_copyheapstring
    inc       qword ptr[%rip+pc_decls.nplibfiles]
    mov       %r10,	[%rip+pc_decls.nplibfiles]
    lea       %r11,	[%rip+pc_decls.plibfiles]
    mov       [%r11 + %r10*8-8],	%rax
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc pc_api.pc_defproc
pc_api.pc_defproc:
#PROC1
#PROC2
#?>>
    .set pc_api.pc_defproc.$T1, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
    mov       %r12,	%r9
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+pc_decls.currfunc]
    test      %rax,	%rax
    jz        L1032
    lea       %rcx,	[%rip+L8395]
    call      pc_api.pclerror
L1032:
    mov       %rcx,	%rdi
    call      pc_api.genmem
    mov       [%rbp + pc_api.pc_defproc.$T1],	%rax
    test      %r12,	%r12
    jz        L1034
    mov       %rax,	121
    jmp       L1033
L1034:
    mov       %rax,	120
L1033:
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + pc_api.pc_defproc.$T1]
    call      pc_api.pc_gen
    test      %rbx,	%rbx
    jnz       L1036
    movzx     %rax,	byte ptr[%rdi+82]
    mov       %rbx,	%rax
L1036:
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      pc_api.pc_setmode
    mov       %rax,	[%rdi+56]
    test      %rax,	%rax
    jz        L1038
    mov       %rax,	[%rdi]
    lea       %rcx,	[%rip+L8396]
    mov       %rdx,	%rax
    call      pc_api.addstr
    mov       %rcx,	%rax
    call      pc_api.pclerror
L1038:
    mov       %rax,	[%rip+pc_api.pccurr]
    mov       [%rdi+56],	%rax
    mov       %rax,	[%rip+pc_decls.entryproc]
    test      %rax,	%rax
    jnz       L1040
    test      %rsi,	%rsi
    jz        L1040
    mov       [%rip+pc_decls.entryproc],	%rdi
    mov       %al,	1
    mov       [%rdi+83],	%al
L1040:
    mov       [%rip+pc_decls.currfunc],	%rdi
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pc_setimport
pc_api.pc_setimport:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       [%rip+pc_decls.currfunc],	%rcx
#---------------
    ret       
# End 
# Proc pc_api.pc_addparam
pc_api.pc_addparam:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rdi,	[%rip+pc_decls.currfunc]
    test      %rdi,	%rdi
    jnz       L1044
    lea       %rcx,	[%rip+L8397]
    call      pc_api.pclerror
L1044:
    mov       %rbx,	[%rdi+16]
    test      %rbx,	%rbx
    jnz       L1046
    mov       [%rdi+16],	%rsi
    jmp       L1045
L1046:
    jmp       L1048
L1047:
    mov       %rbx,	[%rbx+16]
L1048:
    mov       %rax,	[%rbx+16]
    test      %rax,	%rax
    jnz       L1047
    mov       [%rbx+16],	%rsi
L1045:
    mov       %rax,	[%rsi+32]
    test      %rax,	%rax
    jnz       L1051
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       [%rsi+32],	%rax
L1051:
    mov       %rax,	[%rip+pc_decls.currfunc]
    lea       %rax,	[%rax+112]
    inc       byte ptr[%rax]
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pc_addlocal
pc_api.pc_addlocal:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rdi,	[%rip+pc_decls.currfunc]
    test      %rdi,	%rdi
    jnz       L1054
    lea       %rcx,	[%rip+L8397]
    call      pc_api.pclerror
L1054:
    mov       %rbx,	[%rdi+24]
    test      %rbx,	%rbx
    jnz       L1056
    mov       [%rdi+24],	%rsi
    jmp       L1055
L1056:
    jmp       L1058
L1057:
    mov       %rbx,	[%rbx+24]
L1058:
    mov       %rax,	[%rbx+24]
    test      %rax,	%rax
    jnz       L1057
    mov       [%rbx+24],	%rsi
L1055:
    mov       %rax,	[%rsi+32]
    test      %rax,	%rax
    jnz       L1061
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       [%rsi+32],	%rax
L1061:
    mov       %rax,	[%rip+pc_decls.currfunc]
    lea       %rax,	[%rax+114]
    inc       word ptr[%rax]
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pc_endproc
pc_api.pc_endproc:
#PROC1
#PROC2
#?>>
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+pc_decls.currfunc]
    test      %rax,	%rax
    jnz       L1064
    lea       %rcx,	[%rip+L8397]
    call      pc_api.pclerror
L1064:
    mov       %rcx,	122
    xor       %edx,	%edx
    call      pc_api.pc_gen
    xor       %eax,	%eax
    mov       [%rip+pc_decls.currfunc],	%rax
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc pc_api.addstr
pc_api.addstr:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    lea       %rcx,	[%rip+pc_api.addstr.str]
    mov       %rdx,	%rdi
    call      strcpy
    lea       %rcx,	[%rip+pc_api.addstr.str]
    mov       %rdx,	%rbx
    call      strcat
    lea       %rax,	[%rip+pc_api.addstr.str]
L1065:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.merror
pc_api.merror:
#PROC1
#PROC2
#?>>
    .set pc_api.merror.filename, -8
    .set pc_api.merror.sourceline, -16
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	56
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+pc_decls.igetmsourceinfo]
    test      %rax,	%rax
    jz        L1068
    mov       %rcx,	[%rip+pc_decls.mmpos]
    lea       %rdx,	[%rbp + pc_api.merror.filename]
    lea       %r8,	[%rbp + pc_api.merror.sourceline]
    mov       %rax,	[%rip+pc_decls.igetmsourceinfo]
    call      %rax
    mov       %rdi,	%rax
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8398]
    call      msys.m$print_str_nf
    mov       %rcx,	%rdi
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8399]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rbp + pc_api.merror.filename]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L1067
L1068:
    xor       %rdi,	%rdi
    lea       %rax,	[%rip+L8400]
    mov       [%rbp + pc_api.merror.filename],	%rax
L1067:
    mov       %rax,	[%rip+pc_decls.currfunc]
    test      %rax,	%rax
    jz        L1070
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8401]
    call      msys.m$print_str_nf
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L1070:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8402]
    call      msys.m$print_setfmt
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    mov       %rcx,	%rsi
    call      msys.m$print_str_nf
    mov       %rcx,	%rdi
    call      msys.m$print_i64_nf
    mov       %rcx,	[%rbp + pc_api.merror.filename]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+pc_decls.ppseqno]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	[%rbp + pc_api.merror.filename]
    mov       %rdx,	%rdi
    call      pc_api.pcerrorstop
#---------------
    add       %rsp,	56
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pc_duplpst
pc_api.pc_duplpst:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	128
    call      mlib.pcm_allocnfz
    mov       %rdi,	%rax
    mov       %rax,	%rbx
    push      %rdi
    mov       %r11,	16
L8403:
    mov       %r10,	[%rax]
    mov       [%rdi],	%r10
    add       %rdi,	8
    add       %rax,	8
    dec       %r11
    jnz       L8403
    pop       %rdi
    inc       qword ptr[%rip+pc_api.stseqno]
    mov       %rax,	[%rip+pc_api.stseqno]
    mov       [%rdi+120],	%eax
    xor       %eax,	%eax
    mov       [%rdi+8],	%rax
    mov       %rax,	%rdi
L1071:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_api.pcl_cmdskip
pc_api.pcl_cmdskip:
#PROC1
#PROC2
#?>>
    .set pc_api.pcl_cmdskip.dcmdskip, 24
#?]]
#---------------
#PROC3
#PROC4
    mov       [%rip+pc_decls.pcmdskip],	%rcx
#---------------
    ret       
# End 
# Proc pc_api.convertstring
pc_api.convertstring:
#PROC1
#PROC2
#?>>
    .set pc_api.convertstring.str, -16
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
#PROC3
#PROC4
    mov       %rbx,	%r12
    jmp       L1075
L1074:
    mov       %rax,	%rdi
    cmp       %rax,	34
    jz        L1078
    cmp       %rax,	10
    jz        L1079
    cmp       %rax,	13
    jz        L1080
    cmp       %rax,	9
    jz        L1081
    cmp       %rax,	92
    jz        L1082
    cmp       %rax,	7
    jz        L1083
    cmp       %rax,	8
    jz        L1083
    cmp       %rax,	26
    jz        L1083
    cmp       %rax,	27
    jz        L1083
    jmp       L1084
L1078:
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	34
    mov       [%rax],	%r10b
    jmp       L1077
L1079:
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	110
    mov       [%rax],	%r10b
    jmp       L1077
L1080:
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	114
    mov       [%rax],	%r10b
    jmp       L1077
L1081:
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	116
    mov       [%rax],	%r10b
    jmp       L1077
L1082:
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	92
    mov       [%rax],	%r10b
    jmp       L1077
L1083:
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	60
    mov       [%rax],	%r10b
    mov       %rax,	%rdi
    mov       %r10,	10
    cqo       
    idiv      %r10
    add       %rax,	48
    mov       %r10,	%r12
    inc       %r12
    mov       [%r10],	%al
    mov       %rax,	%rdi
    mov       %r10,	10
    cqo       
    idiv      %r10
    xchg      %rax,	%rdx
    add       %rax,	48
    mov       %r10,	%r12
    inc       %r12
    mov       [%r10],	%al
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	62
    mov       [%rax],	%r10b
    jmp       L1077
L1084:
    mov       %rax,	%rdi
    cmp       %rax,	32
    jl        L1086
    cmp       %rax,	126
    jg        L1086
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	%dil
    mov       [%rax],	%r10b
    jmp       L1085
L1086:
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r12
    inc       %r12
    mov       %r10b,	120
    mov       [%rax],	%r10b
    lea       %rcx,	[%rbp + pc_api.convertstring.str]
    call      msys.m$print_startstr
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8404]
    call      msys.m$print_i64
    call      msys.m$print_end
    mov       %al,	[%rbp + pc_api.convertstring.str]
    mov       %r10,	%r12
    inc       %r12
    mov       [%r10],	%al
    mov       %al,	[%rbp + pc_api.convertstring.str+1]
    mov       %r10,	%r12
    inc       %r12
    mov       [%r10],	%al
L1085:
L1077:
L1075:
    mov       %rax,	%rsi
    inc       %rsi
    movzx     %rax,	byte ptr[%rax]
    mov       %rdi,	%rax
    test      %rax,	%rax
    jnz       L1074
    xor       %eax,	%eax
    mov       [%r12],	%al
    mov       %rax,	%r12
    sub       %rax,	%rbx
L1073:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_diags.strpcl
pc_diags.strpcl:
#PROC1
#PROC2
#?>>
    .set pc_diags.strpcl.p, 64
    .set pc_diags.strpcl.str, -256
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	288
    mov       [%rbp+64],	%rcx
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    movzx     %rax,	byte ptr[%rax]
    mov       %rdi,	%rax
    mov       %rax,	%rdi
    cmp       %rax,	127
    jz        L1089
    cmp       %rax,	128
    jz        L1090
    cmp       %rax,	135
    jz        L1091
    cmp       %rax,	120
    jz        L1092
    cmp       %rax,	121
    jz        L1092
    cmp       %rax,	122
    jz        L1093
    cmp       %rax,	136
    jz        L1094
    cmp       %rax,	125
    jz        L1095
    cmp       %rax,	123
    jz        L1096
    cmp       %rax,	124
    jz        L1096
    jmp       L1097
L1089:
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    mov       %rax,	[%rax+8]
    mov       %rcx,	%rax
    mov       %rdx,	1
    call      pc_diags.strlabel
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    mov       %eax,	[%rax+16]
    test      %eax,	%eax
    jz        L1099
    lea       %rcx,	[%rip+L8405]
    call      pc_diags.psstr
L1099:
    jmp       L1087
L1090:
    lea       %rcx,	[%rip+L8406]
    call      pc_diags.psstr
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    mov       %rax,	[%rax+8]
    mov       %rcx,	[%rax]
    call      pc_diags.psstr
    lea       %rcx,	[%rip+L8407]
    call      pc_diags.psstr
    jmp       L1087
L1091:
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    mov       %rax,	[%rax+8]
    mov       %al,	[%rax]
    test      %al,	%al
    jz        L1101
    lea       %rcx,	[%rip+L8408]
    call      pc_diags.psstr
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    mov       %rcx,	[%rax+8]
    call      pc_diags.psstr
    jmp       L1100
L1101:
    lea       %rcx,	[%rip+L8409]
    call      pc_diags.psstr
L1100:
    jmp       L1087
L1092:
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    mov       %r13,	[%rax+8]
    cmp       %rdi,	121
    jnz       L1103
    lea       %rcx,	[%rip+L8410]
    call      pc_diags.psstr
    jmp       L1102
L1103:
    lea       %rcx,	[%rip+L8411]
    call      pc_diags.psstr
L1102:
    lea       %rcx,	[%rip+L8412]
    call      pc_diags.psstr
    mov       %rcx,	%r13
    call      pc_diags.psname
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    mov       %rax,	[%rax+8]
    mov       %al,	[%rax+81]
    test      %al,	%al
    jz        L1105
    lea       %rax,	[%rip+L8413]
    jmp       L1104
L1105:
    lea       %rax,	[%rip+L8414]
L1104:
    mov       %rcx,	%rax
    call      pc_diags.psstr
    mov       %al,	[%r13+83]
    test      %al,	%al
    jz        L1107
    lea       %rcx,	[%rip+L8414]
    call      pc_diags.psstr
L1107:
    call      pc_diags.psline
    mov       %r14,	[%r13+16]
    jmp       L1111
L1108:
    lea       %rcx,	[%rip+L8415]
    call      pc_diags.psstr
    mov       %eax,	[%r14+84]
    movzx     %r10,	byte ptr[%r14+82]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      pc_api.strpmode
    mov       %rcx,	%rax
    call      pc_diags.psstr
    lea       %rcx,	[%rip+L8416]
    call      pc_diags.psstr
    mov       %rcx,	[%r14]
    call      pc_diags.psstr
    call      pc_diags.psline
    mov       %r14,	[%r14+16]
L1111:
    test      %r14,	%r14
    jnz       L1108
    mov       %r14,	[%r13+24]
    jmp       L1115
L1112:
    lea       %rcx,	[%rip+L8417]
    call      pc_diags.psstr
    mov       %eax,	[%r14+84]
    movzx     %r10,	byte ptr[%r14+82]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      pc_api.strpmode
    mov       %rcx,	%rax
    call      pc_diags.psstr
    lea       %rcx,	[%rip+L8418]
    call      pc_diags.psstr
    mov       %rcx,	[%r14]
    call      pc_diags.psstr
    call      pc_diags.psline
    mov       %r14,	[%r14+24]
L1115:
    test      %r14,	%r14
    jnz       L1112
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    mov       %al,	[%rax+3]
    test      %al,	%al
    jz        L1117
    lea       %rcx,	[%rip+L8419]
    call      pc_diags.psstr
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    movzx     %rax,	byte ptr[%rax+3]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      pc_api.strpmode
    mov       %rcx,	%rax
    call      pc_diags.psstr
    call      pc_diags.psline
L1117:
    mov       %al,	[%r13+113]
    test      %al,	%al
    jz        L1119
    lea       %rcx,	[%rip+L8420]
    call      pc_diags.psstrline
L1119:
    jmp       L1087
L1093:
    lea       %rcx,	[%rip+L8421]
    call      pc_diags.psstr
    call      pc_diags.psline
    jmp       L1087
L1094:
    lea       %rcx,	[%rip+L8422]
    call      pc_diags.psstr
    jmp       L1087
L1095:
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    movzx     %rax,	byte ptr[%rax+3]
    cmp       %rax,	11
    jnz       L1121
    mov       %rcx,	[%rbp + pc_diags.strpcl.p]
    call      pc_diags.psdata
    jmp       L1087
L1121:
    jmp       L1088
L1096:
    jmp       L1122
L1097:
L1088:
    lea       %rcx,	[%rip+L8423]
    call      pc_diags.psstr
#pc_diags.strpcl.skiptab:
L1122:
    mov       %rax,	%rdi
    cmp       %rax,	26
    jz        L1124
    cmp       %rax,	31
    jz        L1125
    jmp       L1126
L1124:
    lea       %rcx,	[%rbp + pc_diags.strpcl.str]
    lea       %rdx,	[%rip+L8424]
    call      strcpy
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    movzx     %rax,	byte ptr[%rax+2]
    lea       %r10,	[%rip+pc_tables.ccnames]
    mov       %r10,	[%r10 + %rax*8]
    lea       %rcx,	[%rbp + pc_diags.strpcl.str]
    mov       %rdx,	%r10
    call      strcat
    jmp       L1123
L1125:
    lea       %rcx,	[%rbp + pc_diags.strpcl.str]
    lea       %rdx,	[%rip+L8425]
    call      strcpy
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    movzx     %rax,	byte ptr[%rax+2]
    lea       %r10,	[%rip+pc_tables.ccnames]
    mov       %r10,	[%r10 + %rax*8]
    lea       %rcx,	[%rbp + pc_diags.strpcl.str]
    mov       %rdx,	%r10
    call      strcat
    jmp       L1123
L1126:
    lea       %rax,	[%rip+pc_tables.pclnames]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    lea       %rcx,	[%rbp + pc_diags.strpcl.str]
    mov       %rdx,	%rax
    call      strcpy
L1123:
    mov       %rcx,	[%rip+pc_diags.dest]
    lea       %rdx,	[%rbp + pc_diags.strpcl.str]
    mov       %r8,	9
    mov       %r9,	32
    call      mlib.gs_leftstr
    xor       %eax,	%eax
    mov       [%rbp + pc_diags.strpcl.str],	%al
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    mov       %al,	[%rax+3]
    test      %al,	%al
    jz        L1128
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    mov       %eax,	[%rax+4]
    mov       %r10,	[%rbp + pc_diags.strpcl.p]
    movzx     %r10,	byte ptr[%r10+3]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      pc_api.strpmode
    lea       %rcx,	[%rbp + pc_diags.strpcl.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rax,	[%rip+pc_tables.pclhastype]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10]
    cmp       %rax,	2
    jnz       L1130
    lea       %rcx,	[%rbp + pc_diags.strpcl.str]
    lea       %rdx,	[%rip+L8426]
    call      strcat
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    movsxd    %rax,	dword ptr[%rax+28]
    and       %rax,	255
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      pc_api.strpmode
    lea       %rcx,	[%rbp + pc_diags.strpcl.str]
    mov       %rdx,	%rax
    call      strcat
L1130:
    lea       %rcx,	[%rbp + pc_diags.strpcl.str]
    lea       %rdx,	[%rip+L8427]
    call      strcat
L1128:
    mov       %rcx,	[%rip+pc_diags.dest]
    lea       %rdx,	[%rbp + pc_diags.strpcl.str]
    mov       %r8,	4
    mov       %r9,	32
    call      mlib.gs_leftstr
    xor       %eax,	%eax
    mov       [%rbp + pc_diags.strpcl.str],	%al
    lea       %rax,	[%rip+pc_tables.pclextra]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %rbx,	%rax
    test      %rbx,	%rbx
    jz        L1132
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    movsxd    %rax,	dword ptr[%rax+16]
    mov       %rsi,	%rax
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    movsxd    %rax,	dword ptr[%rax+20]
    mov       %r12,	%rax
    test      %rsi,	%rsi
    jnz       L1135
    cmp       %rbx,	2
    jnz       L1134
L1135:
    lea       %rcx,	[%rbp + pc_diags.strpcl.str]
    lea       %rdx,	[%rip+L8428]
    call      strcat
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    movsxd    %rax,	dword ptr[%rax+16]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.strint
    lea       %rcx,	[%rbp + pc_diags.strpcl.str]
    mov       %rdx,	%rax
    call      strcat
L1134:
    cmp       %rbx,	2
    jnz       L1137
    test      %r12,	%r12
    jz        L1137
    lea       %rcx,	[%rbp + pc_diags.strpcl.str]
    lea       %rdx,	[%rip+L8428]
    call      strcat
    mov       %rcx,	%r12
    xor       %edx,	%edx
    call      msys.strint
    lea       %rcx,	[%rbp + pc_diags.strpcl.str]
    mov       %rdx,	%rax
    call      strcat
L1137:
    lea       %rcx,	[%rbp + pc_diags.strpcl.str]
    lea       %rdx,	[%rip+L8429]
    call      strcat
L1132:
    mov       %rcx,	[%rip+pc_diags.dest]
    lea       %rdx,	[%rbp + pc_diags.strpcl.str]
    mov       %r8,	5
    mov       %r9,	32
    call      mlib.gs_leftstr
    mov       %rax,	[%rbp + pc_diags.strpcl.p]
    movzx     %rax,	byte ptr[%rax+1]
    test      %rax,	%rax
    jz        L1139
    lea       %rcx,	[%rip+L8429]
    call      pc_diags.psstr
    mov       %rcx,	[%rbp + pc_diags.strpcl.p]
    call      pc_diags.stropnd
    mov       %rcx,	%rax
    call      pc_diags.psstr
L1139:
    mov       %rcx,	40
    call      pc_diags.pstabto
L1087:
#---------------
    add       %rsp,	288
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_diags.stropnd
pc_diags.stropnd:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
#PROC3
#PROC4
    test      %rsi,	%rsi
    jnz       L1142
    lea       %rax,	[%rip+L8430]
    jmp       L1140
L1142:
    xor       %eax,	%eax
    lea       %r10,	[%rip+pc_diags.stropnd.str]
    mov       [%r10],	%al
    movzx     %rax,	byte ptr[%rsi+1]
    cmp       %rax,	4
    jz        L1144
    cmp       %rax,	5
    jz        L1145
    cmp       %rax,	10
    jz        L1145
    cmp       %rax,	11
    jz        L1145
    cmp       %rax,	6
    jz        L1145
    cmp       %rax,	7
    jz        L1146
    cmp       %rax,	1
    jz        L1147
    cmp       %rax,	2
    jz        L1148
    cmp       %rax,	3
    jz        L1149
    test      %rax,	%rax
    jz        L1150
    cmp       %rax,	9
    jz        L1151
    cmp       %rax,	12
    jz        L1152
    jmp       L1153
L1144:
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.strint
    jmp       L1140
L1145:
    movq      %XMM4,	[%rsi+8]
    comisd    %XMM4,	[%rip+L8431]
    jnz       L1155
    lea       %rcx,	[%rip+pc_diags.stropnd.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8432]
    call      msys.m$print_setfmt
    call      msys.m$print_end
    jmp       L1154
L1155:
    lea       %rcx,	[%rip+pc_diags.stropnd.str]
    call      msys.m$print_startstr
    movq      %XMM4,	[%rsi+8]
    movq      %XMM0,	%XMM4
    lea       %rdx,	[%rip+L8433]
    call      msys.m$print_r64
    call      msys.m$print_end
L1154:
    jmp       L1143
L1146:
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    call      strlen
    mov       %rdi,	%rax
    cmp       %rax,	256
    jge       L1157
    lea       %rcx,	[%rip+pc_diags.stropnd.str]
    lea       %rdx,	[%rip+L8434]
    call      strcpy
    lea       %rax,	[%rip+pc_diags.stropnd.str]
    lea       %rax,	[%rax+1]
    mov       %r10,	[%rsi+8]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      pc_api.convertstring
    lea       %rcx,	[%rip+pc_diags.stropnd.str]
    lea       %rdx,	[%rip+L8434]
    call      strcat
    jmp       L1156
L1157:
    mov       %rax,	[%rip+pc_diags.stropnd.longstring]
    test      %rax,	%rax
    jz        L1159
    mov       %rcx,	[%rip+pc_diags.stropnd.longstring]
    mov       %rdx,	[%rip+pc_api.longstringlen]
    call      mlib.pcm_free
L1159:
    mov       %rax,	%rdi
    shl       %rax,	1
    mov       [%rip+pc_api.longstringlen],	%rax
    mov       %rcx,	[%rip+pc_api.longstringlen]
    call      mlib.pcm_alloc
    mov       [%rip+pc_diags.stropnd.longstring],	%rax
    mov       %al,	34
    mov       %r10,	[%rip+pc_diags.stropnd.longstring]
    mov       [%r10],	%al
    mov       %rax,	[%rip+pc_diags.stropnd.longstring]
    lea       %rax,	[%rax+1]
    mov       %r10,	[%rsi+8]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      pc_api.convertstring
    mov       %rdi,	%rax
    mov       %al,	34
    mov       %r10,	[%rip+pc_diags.stropnd.longstring]
    mov       %r11,	%rdi
    mov       [%r10 + %r11+1],	%al
    xor       %eax,	%eax
    mov       %r10,	[%rip+pc_diags.stropnd.longstring]
    mov       %r11,	%rdi
    mov       [%r10 + %r11+2],	%al
    mov       %rax,	[%rip+pc_diags.stropnd.longstring]
    jmp       L1140
L1156:
    jmp       L1143
L1147:
    mov       %rbx,	[%rsi+8]
    mov       %rax,	[%rsi+8]
    mov       %rax,	[%rax]
    lea       %rcx,	[%rip+pc_diags.stropnd.str]
    mov       %rdx,	%rax
    call      strcat
    movzx     %rax,	byte ptr[%rsi]
    cmp       %rax,	123
    jz        L1162
    cmp       %rax,	124
    jnz       L1161
L1162:
    lea       %rcx,	[%rip+pc_diags.stropnd.str]
    lea       %rdx,	[%rip+L8435]
    call      strcat
    mov       %al,	[%rbx+81]
    test      %al,	%al
    jz        L1164
    lea       %rcx,	[%rip+pc_diags.stropnd.str]
    lea       %rdx,	[%rip+L8435]
    call      strcat
L1164:
L1161:
    jmp       L1143
L1148:
    lea       %rcx,	[%rip+pc_diags.stropnd.str]
    lea       %rdx,	[%rip+L8436]
    call      strcpy
    jmp       L1147
L1149:
    lea       %rcx,	[%rip+pc_diags.stropnd.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8437]
    call      msys.m$print_setfmt
    lea       %rcx,	[%rip+L8438]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rsi+8]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L1143
L1150:
    lea       %rax,	[%rip+L8439]
    jmp       L1140
L1151:
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.strint
    jmp       L1140
L1152:
    lea       %rcx,	[%rip+pc_diags.stropnd.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8440]
    call      msys.m$print_setfmt
    mov       %eax,	[%rsi+4]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    mov       %rcx,	[%rsi+8]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L1143
L1153:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8441]
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rsi+1]
    lea       %r10,	[%rip+pc_tables.opndnames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rax,	[%rip+L8442]
    jmp       L1140
L1143:
    lea       %rax,	[%rip+pc_diags.stropnd.str]
L1140:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_diags.strpclstr
pc_diags.strpclstr:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    mov       %rcx,	[%rip+pc_diags.dest]
    call      mlib.gs_free
    mov       %rcx,	[%rip+pc_diags.dest]
    call      mlib.gs_init
    xor       %eax,	%eax
    mov       [%rip+pc_diags.destlinestart],	%rax
    mov       %rcx,	%rdi
    call      pc_diags.strpcl
    mov       %rcx,	[%rip+pc_diags.dest]
    xor       %edx,	%edx
    call      mlib.gs_char
    mov       %rax,	[%rip+pc_diags.dest]
    movsxd    %rax,	dword ptr[%rax+8]
    cmp       %rax,	%rbx
    jl        L1167
    lea       %rax,	[%rip+L8443]
    jmp       L1165
L1167:
    mov       %rax,	[%rip+pc_diags.dest]
    mov       %rax,	[%rax]
L1165:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_diags.writepcl
pc_diags.writepcl:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    call      pc_diags.strpcl
    movzx     %rax,	byte ptr[%rdi]
    cmp       %rax,	120
    jnz       L1171
L1170:
    jmp       L1169
L1171:
    mov       %rcx,	[%rip+pc_diags.dest]
    call      mlib.gs_line
L1169:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc pc_diags.writeallpcl
pc_diags.writeallpcl:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    mov       %rcx,	[%rip+pc_diags.dest]
    call      mlib.gs_init
    mov       %rax,	[%rip+pc_diags.dest]
    movsxd    %rax,	dword ptr[%rax+8]
    mov       [%rip+pc_diags.destlinestart],	%rax
    mov       %rcx,	[%rip+pc_diags.dest]
    lea       %rdx,	[%rip+L8444]
    call      mlib.gs_strln
    mov       %rsi,	1
    mov       %rax,	[%rip+pc_decls.nplibfiles]
    cmp       %rax,	1
    jl        L1175
L1173:
    lea       %rcx,	[%rip+L8445]
    call      pc_diags.psstr
    lea       %rax,	[%rip+pc_decls.plibfiles]
    mov       %r10,	%rsi
    mov       %rcx,	[%rax + %r10*8-8]
    call      pc_diags.psstr
    lea       %rcx,	[%rip+L8446]
    call      pc_diags.psstr
    call      pc_diags.psline
    inc       %rsi
    cmp       %rsi,	[%rip+pc_decls.nplibfiles]
    jle       L1173
L1175:
    mov       %rax,	[%rip+pc_decls.nplibfiles]
    test      %rax,	%rax
    jz        L1177
    call      pc_diags.psline
L1177:
    mov       %rbx,	[%rip+pc_decls.psymboltable]
    jmp       L1181
L1178:
    movzx     %rax,	byte ptr[%rbx+72]
    cmp       %rax,	1
    jnz       L1183
    lea       %rcx,	[%rip+L8447]
    call      pc_diags.psstr
    mov       %rcx,	[%rbx]
    call      pc_diags.psstr
    mov       %al,	[%rbx+113]
    test      %al,	%al
    jz        L1185
    lea       %rcx,	[%rip+L8448]
    call      pc_diags.psstr
L1185:
    call      pc_diags.psline
L1183:
    mov       %rbx,	[%rbx+8]
L1181:
    test      %rbx,	%rbx
    jnz       L1178
    mov       %rdi,	[%rip+pc_api.pcstart]
    jmp       L1187
L1186:
    mov       %rcx,	%rdi
    call      pc_diags.writepcl
    mov       %rax,	[%rip+pc_diags.dest]
    movsxd    %rax,	dword ptr[%rax+8]
    mov       [%rip+pc_diags.destlinestart],	%rax
    add       %rdi,	32
L1187:
    cmp       %rdi,	[%rip+pc_api.pccurr]
    jbe       L1186
    call      pc_diags.psline
    mov       %rax,	[%rip+pc_api.longstring]
    test      %rax,	%rax
    jz        L1190
    mov       %rcx,	[%rip+pc_api.longstring]
    mov       %rdx,	[%rip+pc_api.longstringlen]
    call      mlib.pcm_free
L1190:
    mov       %rax,	[%rip+pc_diags.dest]
L1172:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_diags.psstr
pc_diags.psstr:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	[%rip+pc_diags.dest]
    mov       %rdx,	%rdi
    call      mlib.gs_str
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc pc_diags.psstrline
pc_diags.psstrline:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	[%rip+pc_diags.dest]
    mov       %rdx,	%rdi
    call      mlib.gs_str
    mov       %rcx,	[%rip+pc_diags.dest]
    call      mlib.gs_line
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc pc_diags.psline
pc_diags.psline:
#PROC1
#PROC2
#?>>
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    mov       %rcx,	[%rip+pc_diags.dest]
    lea       %rdx,	[%rip+L8449]
    call      mlib.gs_str
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc pc_diags.psint
pc_diags.psint:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      msys.strint
    mov       %rcx,	[%rip+pc_diags.dest]
    mov       %rdx,	%rax
    call      mlib.gs_str
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc pc_diags.psname
pc_diags.psname:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rdi]
    mov       %rcx,	[%rip+pc_diags.dest]
    mov       %rdx,	%rax
    call      mlib.gs_str
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc pc_diags.pstabto
pc_diags.pstabto:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+pc_diags.dest]
    movsxd    %rax,	dword ptr[%rax+8]
    sub       %rax,	[%rip+pc_diags.destlinestart]
    mov       %rdi,	%rax
    jmp       L1198
L1197:
    lea       %rcx,	[%rip+L8450]
    call      pc_diags.psstr
    inc       %rdi
L1198:
    cmp       %rbx,	%rdi
    jg        L1197
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_diags.strlabel
pc_diags.strlabel:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    lea       %rcx,	[%rip+L8451]
    call      pc_diags.psstr
    mov       %rcx,	%rdi
    call      pc_diags.psint
    test      %rbx,	%rbx
    jz        L1202
    lea       %rcx,	[%rip+L8452]
    call      pc_diags.psstr
L1202:
    lea       %rcx,	[%rip+L8453]
    call      pc_diags.psstr
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_diags.psopnd
pc_diags.psopnd:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    call      pc_diags.stropnd
    mov       %rcx,	%rax
    call      pc_diags.psstr
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc pc_diags.psdata
pc_diags.psdata:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
#---------------
#PROC3
#PROC4
    mov       %eax,	[%r13+4]
    mov       %rdi,	%rax
    mov       %rsi,	[%r13+8]
    test      %rdi,	%rdi
    jnz       L1206
    jmp       L1204
L1206:
    jmp       L1208
L1207:
    mov       %rbx,	%rdi
    cmp       %rbx,	20
    jl        L1211
    mov       %rbx,	20
L1211:
    mov       %rax,	%rbx
    sub       %rdi,	%rax
    lea       %rcx,	[%rip+L8454]
    call      pc_diags.psstr
    mov       %rcx,	%rbx
    call      pc_diags.psint
    lea       %rcx,	[%rip+L8455]
    call      pc_diags.psstr
    cmp       %rbx,	10
    jge       L1213
    lea       %rcx,	[%rip+L8456]
    call      pc_diags.psstr
L1213:
    mov       %r12,	%rbx
    cmp       %r12,	0
    jle       L1216
L1214:
    movzx     %rax,	byte ptr[%rsi]
    mov       %rcx,	%rax
    call      pc_diags.psint
    lea       %rcx,	[%rip+L8456]
    call      pc_diags.psstr
    inc       %rsi
    dec       %r12
    jnz       L1214
L1216:
    test      %rdi,	%rdi
    jz        L1218
    call      pc_diags.psline
L1218:
L1208:
    cmp       %rdi,	0
    jg        L1207
L1204:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_diags.writepst
pc_diags.writepst:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    xor       %dil,	%dil
    xor       %eax,	%eax
    mov       %rbx,	%rax
    mov       %rcx,	[%rip+pc_diags.dest]
    call      mlib.gs_init
    lea       %rcx,	[%rip+L8457]
    call      pc_diags.psstrline
    call      pc_diags.psline
    mov       %r12,	[%rip+pc_decls.psymboltable]
    jmp       L1223
L1220:
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L8458]
    call      msys.strint
    mov       %rcx,	%rax
    call      pc_diags.psstr
    lea       %rcx,	[%rip+L8459]
    call      pc_diags.psstr
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L8460]
    call      pc_diags.writepsymbol
    movzx     %rax,	byte ptr[%r12+72]
    cmp       %rax,	2
    jz        L1226
    cmp       %rax,	1
    jnz       L1225
L1226:
    mov       %r13,	[%r12+16]
    xor       %rsi,	%rsi
    jmp       L1230
L1227:
    lea       %rcx,	[%rip+L8461]
    call      pc_diags.psstr
    mov       %rcx,	%r13
    lea       %rdx,	[%rip+L8462]
    call      pc_diags.writepsymbol
    mov       %r13,	[%r13+16]
L1230:
    test      %r13,	%r13
    jnz       L1227
    mov       %r13,	[%r12+24]
    xor       %rsi,	%rsi
    jmp       L1234
L1231:
    lea       %rcx,	[%rip+L8463]
    call      pc_diags.psstr
    mov       %rcx,	%r13
    lea       %rdx,	[%rip+L8464]
    call      pc_diags.writepsymbol
    mov       %r13,	[%r13+24]
L1234:
    test      %r13,	%r13
    jnz       L1231
L1225:
    call      pc_diags.psline
    mov       %r12,	[%r12+8]
L1223:
    test      %r12,	%r12
    jnz       L1220
    call      pc_diags.psline
    mov       %rax,	[%rip+pc_diags.dest]
L1219:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_diags.writepsymbol
pc_diags.writepsymbol:
#PROC1
#PROC2
#?>>
    .set pc_diags.writepsymbol.str, -256
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	288
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
#PROC3
#PROC4
    xor       %dil,	%dil
    lea       %rcx,	[%rbp + pc_diags.writepsymbol.str]
    call      msys.m$print_startstr
    mov       %eax,	[%rsi+120]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8465]
    call      msys.m$print_i64
    movzx     %rax,	byte ptr[%rsi+72]
    lea       %r10,	[%rip+pc_tables.idnames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + pc_diags.writepsymbol.str]
    call      pc_diags.psstr
    movzx     %rax,	byte ptr[%rsi+72]
    lea       %r10,	[%rip+pc_tables.idnames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      strlen
    mov       %r10,	8
    sub       %r10,	%rax
    mov       %rbx,	%r10
    cmp       %rbx,	0
    jle       L1238
L1236:
    lea       %rcx,	[%rip+L8466]
    call      pc_diags.psstr
    dec       %rbx
    jnz       L1236
L1238:
    xor       %eax,	%eax
    mov       [%rbp + pc_diags.writepsymbol.str],	%al
    lea       %rcx,	[%rbp + pc_diags.writepsymbol.str]
    call      msys.m$print_startstr
    mov       %rax,	[%rsi]
    mov       %rcx,	%rax
    mov       %rdx,	%r12
    call      msys.m$print_str
    call      msys.m$print_end
    lea       %rcx,	[%rbp + pc_diags.writepsymbol.str]
    call      pc_diags.psstr
    mov       %eax,	[%rsi+84]
    movzx     %r10,	byte ptr[%rsi+82]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      pc_api.strpmode
    mov       %rcx,	%rax
    call      pc_diags.psstr
    movzx     %rax,	byte ptr[%rsi+72]
    cmp       %rax,	2
    jnz       L1240
    lea       %rcx,	[%rip+L8467]
    call      pc_diags.psstr
    movzx     %rax,	byte ptr[%rsi+112]
    mov       %rcx,	%rax
    call      pc_diags.psint
    lea       %rcx,	[%rip+L8468]
    call      pc_diags.psstr
    movsx     %rax,	word ptr[%rsi+114]
    mov       %rcx,	%rax
    call      pc_diags.psint
L1240:
    mov       %al,	[%rsi+81]
    test      %al,	%al
    jz        L1242
    lea       %rcx,	[%rip+L8469]
    call      pc_diags.psstr
L1242:
    mov       %al,	[%rsi+80]
    test      %al,	%al
    jz        L1244
    lea       %rcx,	[%rip+L8470]
    call      pc_diags.psstr
L1244:
    mov       %al,	[%rsi+107]
    test      %al,	%al
    jz        L1246
    lea       %rcx,	[%rip+L8471]
    call      pc_diags.psstr
    movzx     %rax,	byte ptr[%rsi+107]
    mov       %rcx,	%rax
    call      pc_diags.psint
L1246:
    mov       %al,	[%rsi+108]
    test      %al,	%al
    jz        L1248
    lea       %rcx,	[%rip+L8472]
    call      pc_diags.psstr
L1248:
    mov       %al,	[%rsi+95]
    test      %al,	%al
    jz        L1250
    lea       %rcx,	[%rip+L8473]
    call      pc_diags.psstr
L1250:
    mov       %al,	[%rsi+83]
    test      %al,	%al
    jz        L1252
    lea       %rcx,	[%rip+L8474]
    call      pc_diags.psstr
L1252:
    movzx     %rax,	byte ptr[%rsi+72]
    cmp       %rax,	2
    jnz       L1254
    lea       %rcx,	[%rip+L8475]
    call      pc_diags.psstr
    mov       %rax,	[%rsi+56]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8476]
    call      msys.strint
    mov       %rcx,	%rax
    call      pc_diags.psstr
L1254:
    mov       %rax,	[%rsi+32]
    test      %rax,	%rax
    jz        L1256
    lea       %rcx,	[%rip+L8477]
    call      pc_diags.psstr
    mov       %rax,	[%rsi+32]
    mov       %eax,	[%rax+120]
    mov       %rcx,	%rax
    call      pc_diags.psint
    lea       %rcx,	[%rip+L8478]
    call      pc_diags.psstr
    mov       %rax,	[%rsi+32]
    mov       %rcx,	[%rax]
    call      pc_diags.psstr
    lea       %rcx,	[%rip+L8479]
    call      pc_diags.psstr
L1256:
    xor       %eax,	%eax
    test      %ax,	%ax
    jz        L1258
    movzx     %rax,	byte ptr[%rsi+72]
    cmp       %rax,	3
    jnz       L1258
    mov       %rax,	[%rsi+56]
    test      %rax,	%rax
    jz        L1258
    lea       %rcx,	[%rip+L8480]
    call      pc_diags.psstr
    mov       %rax,	[%rsi+56]
    mov       %rcx,	[%rax]
    call      pc_diags.psstr
    lea       %rcx,	[%rip+L8481]
    call      pc_diags.psstr
    mov       %rax,	[%rsi+24]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8482]
    call      msys.strint
    mov       %rcx,	%rax
    call      pc_diags.psstr
    lea       %rcx,	[%rip+L8483]
    call      pc_diags.psstr
L1258:
    xor       %eax,	%eax
    test      %ax,	%ax
    jz        L1260
    movzx     %rax,	byte ptr[%rsi+72]
    cmp       %rax,	2
    jnz       L1260
    movzx     %rax,	byte ptr[%rsi+104]
    shr       %eax,	1
    and       %eax,	1
    test      %rax,	%rax
    jz        L1260
    lea       %rcx,	[%rip+L8484]
    call      pc_diags.psstr
L1260:
    call      pc_diags.psline
#---------------
    add       %rsp,	288
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_diags.showprocinfo
pc_diags.showprocinfo:
#PROC1
#PROC2
#?>>
    .set pc_diags.showprocinfo.str, -256
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	296
    mov       %rsi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rdi,	[%rsi+48]
    test      %rdi,	%rdi
    jnz       L1263
    jmp       L1261
L1263:
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8485]
    call      msys.m$print_setfmt
    mov       %rcx,	[%rsi]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8486]
    call      msys.m$print_setfmt
    movzx     %rax,	byte ptr[%rdi+1]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8487]
    call      msys.m$print_setfmt
    movzx     %rax,	byte ptr[%rdi+2]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8488]
    call      msys.m$print_setfmt
    movzx     %rax,	byte ptr[%rdi+3]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8489]
    call      msys.m$print_setfmt
    movzx     %rax,	byte ptr[%rdi+4]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8490]
    call      msys.m$print_setfmt
    movzx     %rax,	byte ptr[%rdi+5]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8491]
    call      msys.m$print_setfmt
    movzx     %rax,	byte ptr[%rdi+6]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8492]
    call      msys.m$print_setfmt
    movzx     %rax,	byte ptr[%rdi+7]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    call      pc_diags.psline
    mov       %rbx,	[%rsi+16]
    jmp       L1267
L1264:
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8493]
    call      msys.m$print_setfmt
    mov       %rcx,	[%rbx]
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rbx+92]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    movzx     %rax,	byte ptr[%rbx+88]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    mov       %rbx,	[%rbx+16]
L1267:
    test      %rbx,	%rbx
    jnz       L1264
    mov       %rbx,	[%rsi+24]
    jmp       L1271
L1268:
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8494]
    call      msys.m$print_setfmt
    mov       %rcx,	[%rbx]
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rbx+92]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    movzx     %rax,	byte ptr[%rbx+88]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    mov       %rbx,	[%rbx+24]
L1271:
    test      %rbx,	%rbx
    jnz       L1268
    call      pc_diags.psline
L1261:
#---------------
    add       %rsp,	296
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_reduce.pcl_reducetest
pc_reduce.pcl_reducetest:
#PROC1
#PROC2
#?>>
    .set pc_reduce.pcl_reducetest.pcproc, -8
    .set pc_reduce.pcl_reducetest.labelmap, -16
    .set pc_reduce.pcl_reducetest.pdef, -24
    .set pc_reduce.pcl_reducetest.callstack, -280
    .set pc_reduce.pcl_reducetest.ncall, -288
    .set pc_reduce.pcl_reducetest.nprocs, -296
    .set pc_reduce.pcl_reducetest.nleaf, -304
    .set pc_reduce.pcl_reducetest.nallparams, -312
    .set pc_reduce.pcl_reducetest.nalllocals, -320
    .set pc_reduce.pcl_reducetest.av_1, -328
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	360
#---------------
#PROC3
#PROC4
    xor       %eax,	%eax
    mov       [%rbp + pc_reduce.pcl_reducetest.nprocs],	%rax
    xor       %eax,	%eax
    mov       [%rbp + pc_reduce.pcl_reducetest.nleaf],	%rax
    xor       %eax,	%eax
    mov       [%rbp + pc_reduce.pcl_reducetest.nallparams],	%rax
    xor       %eax,	%eax
    mov       [%rbp + pc_reduce.pcl_reducetest.nalllocals],	%rax
    mov       %rax,	[%rip+pc_api.pccurr]
    sub       %rax,	[%rip+pc_api.pcstart]
    shr       %rax,	5
    inc       %rax
    mov       %rdi,	%rax
    mov       %r13,	[%rip+pc_api.pcstart]
    mov       %rax,	[%rip+pc_api.mlabelno]
    shl       %rax,	1
    mov       %rcx,	%rax
    call      mlib.pcm_allocz
    mov       [%rbp + pc_reduce.pcl_reducetest.labelmap],	%rax
    jmp       L1276
L1273:
    movzx     %rax,	byte ptr[%r13]
    cmp       %rax,	127
    jz        L1278
    cmp       %rax,	42
    jz        L1279
    jmp       L1280
L1278:
    jmp       L1277
L1279:
    mov       %rax,	[%rip+pc_api.icheckasmlabel]
    test      %rax,	%rax
    jz        L1282
    mov       %rax,	[%r13+8]
    mov       %rcx,	%rax
    mov       %r10,	[%rip+pc_api.icheckasmlabel]
    call      %r10
    mov       %rsi,	%rax
    test      %rsi,	%rsi
    jz        L1284
    mov       %rax,	[%rbp + pc_reduce.pcl_reducetest.labelmap]
    mov       %r10,	%rsi
    lea       %rax,	[%rax + %r10*2-2]
    inc       word ptr[%rax]
L1284:
L1282:
    jmp       L1277
L1280:
    movzx     %rax,	byte ptr[%r13+1]
    cmp       %rax,	3
    jnz       L1286
    mov       %rax,	[%r13+8]
    mov       %r10,	[%rbp + pc_reduce.pcl_reducetest.labelmap]
    lea       %r10,	[%r10 + %rax*2-2]
    inc       word ptr[%r10]
L1286:
L1277:
    add       %r13,	32
L1276:
    cmp       %r13,	[%rip+pc_api.pccurr]
    jbe       L1273
#pc_reduce.pcl_reducetest.skip:
    mov       %r13,	[%rip+pc_api.pcstart]
    mov       %rax,	[%rip+pc_api.pcstart]
    sub       %rax,	32
    mov       %r14,	%rax
    xor       %rbx,	%rbx
    mov       %rax,	%rdi
    mov       [%rbp + pc_reduce.pcl_reducetest.av_1],	%rax
    mov       %rax,	[%rbp + pc_reduce.pcl_reducetest.av_1]
    cmp       %rax,	0
    jle       L1290
L1288:
    lea       %rax,	[%r13+32]
    mov       %r15,	%rax
    movzx     %rax,	byte ptr[%r13]
    lea       %r10,	[%rip+pc_tables.pclargs]
    movzx     %r10,	byte ptr[%r10 + %rax]
    mov       %r12,	%r10
    test      %r10,	%r10
    jz        L1292
    cmp       %r12,	9
    jnz       L1294
    movsxd    %rax,	dword ptr[%r13+16]
    mov       %r12,	%rax
L1294:
    mov       %rax,	[%rip+pc_decls.pinfo]
    movzx     %rax,	byte ptr[%rax+4]
    mov       %r10,	%r12
    cmp       %rax,	%r10
    cmovl     %rax,	%r10
    mov       %r10,	[%rip+pc_decls.pinfo]
    mov       [%r10+4],	%al
L1292:
    movzx     %rax,	byte ptr[%r13+3]
    cmp       %rax,	11
    jnz       L1296
    mov       %rax,	[%rip+pc_decls.pinfo]
    test      %rax,	%rax
    jz        L1296
    mov       %eax,	[%r13+4]
    cmp       %rax,	16
    jz        L1296
    mov       %al,	1
    mov       %r10,	[%rip+pc_decls.pinfo]
    mov       [%r10+7],	%al
L1296:
    movzx     %rax,	byte ptr[%r13]
    cmp       %rax,	135
    jz        L1298
    cmp       %rax,	127
    jz        L1299
    cmp       %rax,	120
    jz        L1300
    cmp       %rax,	121
    jz        L1300
    cmp       %rax,	18
    jz        L1301
    cmp       %rax,	21
    jz        L1301
    cmp       %rax,	19
    jz        L1301
    cmp       %rax,	22
    jz        L1301
    cmp       %rax,	131
    jz        L1302
    cmp       %rax,	122
    jz        L1303
    cmp       %rax,	42
    jz        L1304
    cmp       %rax,	2
    jz        L1305
    cmp       %rax,	5
    jz        L1305
    cmp       %rax,	114
    jz        L1306
    cmp       %rax,	113
    jz        L1307
    cmp       %rax,	1
    jz        L1308
    jmp       L1309
L1298:
    jmp       L1297
L1299:
    mov       %rax,	[%r13+8]
    mov       %r10,	[%rbp + pc_reduce.pcl_reducetest.labelmap]
    mov       %r10w,	[%r10 + %rax*2-2]
    test      %r10w,	%r10w
    jz        L1311
    jmp       L1309
L1311:
    jmp       L1297
L1300:
    inc       qword ptr[%rbp + pc_reduce.pcl_reducetest.nprocs]
    mov       %rax,	[%r13+8]
    mov       [%rbp + pc_reduce.pcl_reducetest.pdef],	%rax
    lea       %rax,	[%r14+32]
    mov       %r10,	[%rbp + pc_reduce.pcl_reducetest.pdef]
    mov       [%r10+56],	%rax
    mov       %rcx,	8
    call      mlib.pcm_alloc
    mov       [%rip+pc_decls.pinfo],	%rax
    mov       %rax,	[%rip+pc_decls.pinfo]
    mov       %r10,	[%rbp + pc_reduce.pcl_reducetest.pdef]
    mov       [%r10+48],	%rax
    mov       %al,	1
    mov       %r10,	[%rip+pc_decls.pinfo]
    mov       [%r10+3],	%al
    mov       %rax,	[%rbp + pc_reduce.pcl_reducetest.pdef]
    mov       %al,	[%rax+112]
    mov       %r10,	[%rip+pc_decls.pinfo]
    mov       [%r10+1],	%al
    mov       %rax,	[%rbp + pc_reduce.pcl_reducetest.pdef]
    mov       %ax,	[%rax+114]
    mov       %r10,	[%rip+pc_decls.pinfo]
    mov       [%r10+2],	%al
    mov       %rax,	[%rbp + pc_reduce.pcl_reducetest.pdef]
    movzx     %rax,	byte ptr[%rax+112]
    add       [%rbp + pc_reduce.pcl_reducetest.nallparams],	%rax
    mov       %rax,	[%rbp + pc_reduce.pcl_reducetest.pdef]
    movsx     %rax,	word ptr[%rax+114]
    add       [%rbp + pc_reduce.pcl_reducetest.nalllocals],	%rax
    xor       %eax,	%eax
    mov       [%rbp + pc_reduce.pcl_reducetest.ncall],	%rax
    lea       %rax,	[%r14+32]
    mov       [%rbp + pc_reduce.pcl_reducetest.pcproc],	%rax
    jmp       L1309
    jmp       L1297
L1301:
    xor       %eax,	%eax
    mov       %r10,	[%rip+pc_decls.pinfo]
    mov       [%r10+3],	%al
    dec       qword ptr[%rbp + pc_reduce.pcl_reducetest.ncall]
    jmp       L1309
    jmp       L1297
L1302:
    add       %r14,	32
    mov       %rax,	%r13
    mov       %r10,	[%rax]
    mov       [%r14],	%r10
    mov       %r10,	[%rax+8]
    mov       [%r14+8],	%r10
    mov       %r10,	[%rax+16]
    mov       [%r14+16],	%r10
    mov       %r10,	[%rax+24]
    mov       [%r14+24],	%r10
    inc       %rbx
    mov       %rax,	%rbx
    lea       %r10,	[%r14+28]
    mov       %r8d,	[%r10]
    mov       %r11,	-4294967041
    shl       %eax,	8
    and       %r8d,	%r11d
    or        %r8d,	%eax
    mov       [%r10],	%r8d
    inc       qword ptr[%rbp + pc_reduce.pcl_reducetest.ncall]
    mov       %rax,	[%rbp + pc_reduce.pcl_reducetest.ncall]
    mov       %r10,	%r14
    mov       [%rbp + %rax*8 + pc_reduce.pcl_reducetest.callstack-8],	%r10
    jmp       L1297
L1303:
    mov       %rax,	[%rip+pc_decls.pinfo]
    mov       %al,	[%rax+3]
    test      %al,	%al
    jz        L1313
    inc       qword ptr[%rbp + pc_reduce.pcl_reducetest.nleaf]
L1313:
    xor       %eax,	%eax
    mov       [%rip+pc_decls.pinfo],	%rax
    jmp       L1309
    jmp       L1297
L1304:
    mov       %al,	1
    mov       %r10,	[%rip+pc_decls.pinfo]
    mov       [%r10+5],	%al
    jmp       L1309
    jmp       L1297
L1305:
    movzx     %rax,	byte ptr[%r14]
    cmp       %rax,	57
    jnz       L1315
    movzx     %rax,	byte ptr[%r13+3]
    cmp       %rax,	11
    jz        L1315
    mov       %al,	[%r13+3]
    mov       [%r14+3],	%al
    movzx     %rax,	byte ptr[%r13]
    cmp       %rax,	2
    jnz       L1317
    mov       %rax,	3
    jmp       L1316
L1317:
    mov       %rax,	6
L1316:
    mov       [%r14],	%al
    jmp       L1314
L1315:
    jmp       L1309
L1314:
    jmp       L1297
L1306:
    movzx     %rax,	byte ptr[%r15]
    cmp       %rax,	113
    jnz       L1319
    movsxd    %rax,	dword ptr[%r13+28]
    and       %rax,	255
    movsxd    %r10,	dword ptr[%r15+28]
    and       %r10,	255
    cmp       %rax,	%r10
    jnz       L1319
    add       %r13,	32
    jmp       L1318
L1319:
    movzx     %rax,	byte ptr[%r15]
    cmp       %rax,	28
    jz        L1321
    cmp       %rax,	27
    jnz       L1320
L1321:
    movsxd    %rax,	dword ptr[%r13+28]
    and       %rax,	255
    mov       [%r15+3],	%al
    jmp       L1318
L1320:
    jmp       L1309
L1318:
    jmp       L1297
L1307:
    movzx     %rax,	byte ptr[%r14]
    cmp       %rax,	1
    jz        L1324
    cmp       %rax,	2
    jz        L1324
    cmp       %rax,	3
    jnz       L1323
L1324:
    movzx     %rax,	byte ptr[%r14+3]
    movsxd    %r10,	dword ptr[%r13+28]
    and       %r10,	255
    cmp       %rax,	%r10
    jz        L1322
L1323:
    jmp       L1309
L1322:
    jmp       L1297
L1308:
    movzx     %rax,	byte ptr[%r13+1]
    cmp       %rax,	4
    jnz       L1326
    movzx     %rax,	byte ptr[%r15]
    movzx     %r10,	byte ptr[%r14]
    cmp       %r10,	%rax
    jnz       L1327
    cmp       %r10,	57
    jnz       L1327
    mov       %rax,	1
    jmp       L1328
L1327:
    xor       %eax,	%eax
L1328:
    test      %rax,	%rax
    setnz     %al
    movzx     %eax,	%al
    test      %ax,	%ax
    jz        L1326
    mov       %rax,	[%r13+8]
    movsxd    %r10,	dword ptr[%r15+16]
    imul      %rax,	%r10
    movsxd    %r10,	dword ptr[%r15+20]
    add       %rax,	%r10
    lea       %r10,	[%r14+20]
    add       [%r10],	%eax
    add       %r13,	32
    jmp       L1325
L1326:
    movzx     %rax,	byte ptr[%r15]
    cmp       %rax,	11
    jnz       L1329
    add       %r13,	32
    jmp       L1325
L1329:
    jmp       L1309
L1325:
    jmp       L1297
L1309:
    add       %r14,	32
    mov       %rax,	%r13
    mov       %r10,	[%rax]
    mov       [%r14],	%r10
    mov       %r10,	[%rax+8]
    mov       [%r14+8],	%r10
    mov       %r10,	[%rax+16]
    mov       [%r14+16],	%r10
    mov       %r10,	[%rax+24]
    mov       [%r14+24],	%r10
    inc       %rbx
    mov       %rax,	%rbx
    lea       %r10,	[%r14+28]
    mov       %r8d,	[%r10]
    mov       %r11,	-4294967041
    shl       %eax,	8
    and       %r8d,	%r11d
    or        %r8d,	%eax
    mov       [%r10],	%r8d
    movzx     %rax,	byte ptr[%r14+1]
    cmp       %rax,	2
    jnz       L1331
    movzx     %rax,	byte ptr[%r14]
    cmp       %rax,	1
    jnz       L1334
    mov       %eax,	[%r14+16]
    test      %eax,	%eax
    jnz       L1333
L1334:
    mov       %rax,	[%r14+8]
    mov       %r10b,	1
    mov       [%rax+88],	%r10b
L1333:
L1331:
L1297:
    add       %r13,	32
    dec       qword ptr[%rbp + pc_reduce.pcl_reducetest.av_1]
    jnz       L1288
L1290:
    mov       [%rip+pc_api.pccurr],	%r14
    mov       %rcx,	[%rbp + pc_reduce.pcl_reducetest.labelmap]
    mov       %rdx,	[%rip+pc_api.mlabelno]
    call      mlib.pcm_free
#---------------
    add       %rsp,	360
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc pc_run_dummy.pcl_runpcl
pc_run_dummy.pcl_runpcl:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
#---------------
    ret       
# End 
# Proc mc_genmcl.genmcl
mc_genmcl.genmcl:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.genmcl.dummy, 32
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    mov       %al,	[%rip+pc_decls.mcldone]
    test      %al,	%al
    jnz       L1336
L1338:
    xor       %eax,	%eax
    test      %ax,	%ax
    jnz       L1341
    xor       %eax,	%eax
    test      %ax,	%ax
    jz        L1340
L1341:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8495]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L1340:
    call      mwindows.os_clock
    mov       %rdi,	%rax
    call      mc_genmcl.inithandlers
    xor       %ecx,	%ecx
    call      mc_libmcl.mclinit
    mov       %rax,	[%rip+pc_api.pcstart]
    mov       [%rip+mc_decls.currpcl],	%rax
    lea       %rcx,	[%rip+L8496]
    call      mc_libmcl.mgencomment
    xor       %rbx,	%rbx
L1342:
    mov       %rcx,	[%rip+mc_decls.currpcl]
    call      mc_genmcl.convertpcl
    xor       %eax,	%eax
    test      %ax,	%ax
    jz        L1346
    mov       %rax,	[%rip+mc_decls.currpcl]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	127
    jz        L1346
    cmp       %rax,	135
    jz        L1346
    cmp       %rax,	120
    jz        L1346
    cmp       %rax,	121
    jz        L1346
    cmp       %rax,	20
    jz        L1346
    cmp       %rax,	122
    jz        L1346
    call      mc_stackmcl.showopndstack
L1346:
    add       qword ptr[%rip+mc_decls.currpcl],	32
    mov       %rax,	[%rip+mc_decls.currpcl]
    cmp       %rax,	[%rip+pc_api.pccurr]
    ja        L1347
    mov       %rax,	[%rip+mc_decls.currpcl]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	136
    jnz       L1342
L1347:
    call      mc_auxmcl.genrealtable
    call      mc_auxmcl.genabsneg
    call      mc_auxmcl.genstringtable
    mov       %rcx,	8
    xor       %edx,	%edx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	8
    xor       %edx,	%edx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %al,	[%rip+pc_decls.fpeephole]
    test      %al,	%al
    jz        L1349
    call      mc_optim.peephole
L1349:
    mov       %al,	1
    mov       [%rip+pc_decls.mcldone],	%al
    call      mwindows.os_clock
    sub       %rax,	%rdi
    mov       [%rip+pc_decls.mcltime],	%rax
L1336:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.convertpcl
mc_genmcl.convertpcl:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.convertpcl.oldregset, -16
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	56
    mov       %rsi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %al,	[%rsi+3]
    mov       [%rip+mc_decls.pmode],	%al
    mov       [%rip+mc_decls.currpcl],	%rsi
    mov       %eax,	[%rsi+24]
    mov       [%rip+pc_decls.mmpos],	%rax
    movsxd    %rax,	dword ptr[%rsi+28]
    shr       %rax,	8
    and       %rax,	16777215
    mov       [%rip+pc_decls.ppseqno],	%rax
    movzx     %rax,	byte ptr[%rsi]
    lea       %r10,	[%rip+mc_genmcl.px_handlertable]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%rsi
    call      %r10
    lea       %rax,	[%rip+mc_decls.regset]
    lea       %r10,	[%rbp + mc_genmcl.convertpcl.oldregset]
    movdqu    %XMM4,	[%rax]
    movdqu    [%r10],	%XMM4
    lea       %rax,	[%rip+mc_decls.regset]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    lea       %rax,	[%rip+mc_decls.xregset]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    mov       %rbx,	1
    mov       %rax,	[%rip+mc_decls.noperands]
    cmp       %rax,	1
    jl        L1353
L1351:
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L1355
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	2
    jg        L1357
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.xregset]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    jmp       L1356
L1357:
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.regset]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
L1356:
L1355:
    inc       %rbx
    cmp       %rbx,	[%rip+mc_decls.noperands]
    jle       L1351
L1353:
    mov       %rax,	[%rbp + mc_genmcl.convertpcl.oldregset]
    lea       %r10,	[%rip+mc_decls.regset]
    mov       %r10,	[%r10]
    lea       %r11,	[%rip+mc_decls.isregvar]
    mov       %r11,	[%r11]
    or        %r10,	%r11
    mov       %r11,	72340172838076673
    xor       %r10,	%r11
    and       %rax,	%r10
    mov       %r10,	[%rip+mc_decls.mccodex]
    lea       %r10,	[%r10+48]
    or        [%r10],	%rax
    mov       %rax,	[%rbp + mc_genmcl.convertpcl.oldregset+8]
    lea       %r10,	[%rip+mc_decls.regset]
    mov       %r10,	[%r10+8]
    lea       %r11,	[%rip+mc_decls.isregvar]
    mov       %r11,	[%r11+8]
    or        %r10,	%r11
    mov       %r11,	72340172838076673
    xor       %r10,	%r11
    and       %rax,	%r10
    mov       %r10,	[%rip+mc_decls.mccodex]
    lea       %r10,	[%r10+56]
    or        [%r10],	%rax
#---------------
    add       %rsp,	56
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.inithandlers
mc_genmcl.inithandlers:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.inithandlers.k, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    mov       %al,	[%rip+mc_genmcl.inithandlers.initdone]
    test      %al,	%al
    jnz       L1358
L1360:
    mov       %rsi,	[%rip+$nprocs]
    mov       %r15,	1
    cmp       %rsi,	1
    jl        L1363
L1361:
    lea       %rax,	[%rip+$procname]
    mov       %r10,	%r15
    mov       %rdi,	[%rax + %r10*8-8]
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8497]
    mov       %r8,	3
    call      mlib.eqbytes
    test      %rax,	%rax
    jz        L1365
    xor       %eax,	%eax
    mov       [%rbp + mc_genmcl.inithandlers.k],	%rax
    mov       %r12,	142
    cmp       %r12,	0
    jl        L1369
L1366:
    lea       %rax,	[%rip+pc_tables.pclnames]
    mov       %r10,	[%rbp + mc_genmcl.inithandlers.k]
    mov       %rbx,	[%rax + %r10*8]
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	107
    jnz       L1371
    inc       %rbx
L1371:
    lea       %rax,	[%rdi+3]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L1373
    lea       %rax,	[%rip+$procaddr]
    mov       %r10,	%r15
    mov       %rax,	[%rax + %r10*8-8]
    lea       %r10,	[%rip+mc_genmcl.px_handlertable]
    mov       %r11,	[%rbp + mc_genmcl.inithandlers.k]
    mov       [%r10 + %r11*8],	%rax
    jmp       L1368
L1373:
    mov       %rax,	[%rbp + mc_genmcl.inithandlers.k]
    inc       %rax
    mov       [%rbp + mc_genmcl.inithandlers.k],	%rax
    cmp       %rax,	%r12
    jle       L1366
L1369:
    lea       %rcx,	[%rip+L8498]
    mov       %rdx,	%rdi
    call      pc_api.merror
L1368:
L1365:
    inc       %r15
    cmp       %r15,	%rsi
    jle       L1361
L1363:
    mov       %r15,	1
    mov       %r13,	9
    cmp       %r13,	1
    jl        L1376
L1374:
    lea       %rax,	[%rip+mc_genmcl.inithandlers.dupltable]
    mov       %r10,	%r15
    lea       %rax,	[%rax + %r10*2-2]
    movzx     %rax,	byte ptr[%rax+1]
    lea       %r10,	[%rip+mc_genmcl.px_handlertable]
    mov       %r10,	[%r10 + %rax*8]
    lea       %rax,	[%rip+mc_genmcl.inithandlers.dupltable]
    mov       %r11,	%r15
    lea       %rax,	[%rax + %r11*2-2]
    movzx     %rax,	byte ptr[%rax]
    lea       %r11,	[%rip+mc_genmcl.px_handlertable]
    mov       [%r11 + %rax*8],	%r10
    inc       %r15
    cmp       %r15,	%r13
    jle       L1374
L1376:
    xor       %r15,	%r15
    mov       %rax,	142
    mov       %r14,	%rax
    cmp       %r14,	0
    jl        L1379
L1377:
    lea       %rax,	[%rip+mc_genmcl.px_handlertable]
    mov       %r10,	%r15
    mov       %rax,	[%rax + %r10*8]
    test      %rax,	%rax
    jnz       L1381
    lea       %rax,	[%rip+mc_genmcl.unimpl]
    lea       %r10,	[%rip+mc_genmcl.px_handlertable]
    mov       %r11,	%r15
    mov       [%r10 + %r11*8],	%rax
L1381:
    inc       %r15
    cmp       %r15,	%r14
    jle       L1377
L1379:
    mov       %al,	1
    mov       [%rip+mc_genmcl.inithandlers.initdone],	%al
L1358:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.doshowpcl
mc_genmcl.doshowpcl:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.doshowpcl.str, -1256
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	1288
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    jmp       L1382
    movzx     %rax,	byte ptr[%rdi]
    cmp       %rax,	120
    jz        L1384
    cmp       %rax,	121
    jz        L1384
    cmp       %rax,	20
    jz        L1384
    cmp       %rax,	122
    jz        L1384
    cmp       %rax,	123
    jz        L1384
    cmp       %rax,	124
    jz        L1384
    cmp       %rax,	125
    jnz       L1385
L1384:
    jmp       L1383
L1385:
    lea       %rcx,	[%rbp + mc_genmcl.doshowpcl.str]
    lea       %rdx,	[%rip+L8499]
    call      strcpy
    mov       %rcx,	%rdi
    mov       %rdx,	1256
    call      pc_diags.strpclstr
    lea       %rcx,	[%rbp + mc_genmcl.doshowpcl.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rcx,	[%rbp + mc_genmcl.doshowpcl.str]
    call      mlib.pcm_copyheapstring
    mov       %rcx,	%rax
    call      mc_libmcl.mgencomment
L1383:
L1382:
#---------------
    add       %rsp,	1288
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.unimpl
mc_genmcl.unimpl:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.unimpl.str, -104
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	136
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    lea       %rcx,	[%rbp + mc_genmcl.unimpl.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8500]
    call      msys.m$print_setfmt
    movzx     %rax,	byte ptr[%rdi]
    lea       %r10,	[%rip+pc_tables.pclnames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      pc_api.strpmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       %rcx,	[%rbp + mc_genmcl.unimpl.str]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rbp + mc_genmcl.unimpl.str]
    call      mlib.pcm_copyheapstring
    mov       %rcx,	%rax
    call      mc_libmcl.mgencomment
#---------------
    add       %rsp,	136
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_nop
mc_genmcl.px_nop:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_nop.p, 16
#?]]
#---------------
#PROC3
#PROC4
#---------------
    ret       
# End 
# Proc mc_genmcl.px_dupl
mc_genmcl.px_dupl:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_dupl.p, 16
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    call      mc_stackmcl.duplpcl
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_genmcl.px_double
mc_genmcl.px_double:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_double.p, 16
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+mc_decls.ncalldepth]
    test      %rax,	%rax
    jz        L1391
    call      mc_stackmcl.duplpcl
    jmp       L1390
L1391:
    lea       %rax,	[%rip+mc_decls.pclcount]
    mov       %r10,	[%rip+mc_decls.noperands]
    lea       %rax,	[%rax + %r10-1]
    inc       byte ptr[%rax]
L1390:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_genmcl.px_opnd
mc_genmcl.px_opnd:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    call      mc_genmcl.unimpl
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_type
mc_genmcl.px_type:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    call      mc_genmcl.unimpl
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_comment
mc_genmcl.px_comment:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_comment.p, 16
#?]]
#---------------
#PROC3
#PROC4
#---------------
    ret       
# End 
# Proc mc_genmcl.px_proc
mc_genmcl.px_proc:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rdi+8]
    mov       [%rip+pc_decls.currfunc],	%rax
    mov       %rcx,	67
    mov       %rdx,	1
    call      mc_libmcl.setsegment
    mov       %rcx,	[%rip+pc_decls.currfunc]
    call      mc_libmcl.mgenmemaddr
    mov       %rcx,	1
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	[%rip+pc_decls.currfunc]
    call      mc_libmcl.mgenmemaddr
    mov       %rcx,	4
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    lea       %rcx,	[%rip+L8501]
    call      mc_libmcl.mgencomment
    mov       %rcx,	[%rip+pc_decls.currfunc]
    call      mc_auxmcl.initproc
    lea       %rcx,	[%rip+L8502]
    call      mc_libmcl.mgencomment
    lea       %rcx,	[%rip+L8503]
    call      mc_libmcl.mgencomment
    mov       %rax,	[%rip+mc_decls.mccodex]
    mov       [%rip+mc_decls.mclprocentry],	%rax
    lea       %rcx,	[%rip+L8504]
    call      mc_libmcl.mgencomment
    mov       %rax,	[%rip+pc_decls.currfunc]
    movzx     %rax,	byte ptr[%rax+112]
    cmp       %rax,	2
    jnz       L1397
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %al,	[%rax+83]
    test      %al,	%al
    jz        L1397
    call      mc_auxmcl.fixmain
L1397:
    lea       %rcx,	[%rip+L8505]
    call      mc_libmcl.mgencomment
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_endproc
mc_genmcl.px_endproc:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_endproc.p, 16
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+mc_decls.noperands]
    test      %rax,	%rax
    jz        L1400
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8506]
    call      msys.m$print_str_nf
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8506]
    call      mc_libmcl.mgencomment
L1400:
    mov       %rcx,	2
    xor       %edx,	%edx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_genmcl.px_endprog
mc_genmcl.px_endprog:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    call      mc_genmcl.unimpl
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_istatic
mc_genmcl.px_istatic:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    movsxd    %rax,	dword ptr[%rdi+16]
    mov       %rcx,	73
    mov       %rdx,	%rax
    call      mc_libmcl.setsegment
    mov       %rax,	[%rdi+8]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenmemaddr
    mov       %rcx,	4
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_zstatic
mc_genmcl.px_zstatic:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rdi,	[%rbx+8]
    movsxd    %rax,	dword ptr[%rbx+16]
    mov       %rcx,	90
    mov       %rdx,	%rax
    call      mc_libmcl.setsegment
    mov       %rcx,	%rdi
    call      mc_libmcl.mgenmemaddr
    mov       %rcx,	4
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %eax,	[%rbx+4]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	125
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_data
mc_genmcl.px_data:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rsi+3]
    cmp       %rax,	11
    jnz       L1406
    mov       %rcx,	%rsi
    call      mc_auxmcl.do_blockdata
    jmp       L1404
L1406:
    movzx     %rax,	byte ptr[%rsi+1]
    cmp       %rax,	4
    jz        L1408
    cmp       %rax,	10
    jz        L1409
    cmp       %rax,	11
    jz        L1410
    cmp       %rax,	6
    jz        L1411
    cmp       %rax,	7
    jz        L1412
    cmp       %rax,	2
    jz        L1413
    cmp       %rax,	3
    jz        L1414
    jmp       L1415
L1408:
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rdi,	%rax
    jmp       L1407
L1409:
    movq      %XMM4,	[%rsi+8]
    movq      %XMM0,	%XMM4
    mov       %rdx,	2
    call      mc_libmcl.mgenrealimm
    mov       %rdi,	%rax
    jmp       L1407
L1410:
    movq      %XMM4,	[%rsi+8]
    movq      %XMM0,	%XMM4
    mov       %rdx,	1
    call      mc_libmcl.mgenrealimm
    mov       %rdi,	%rax
    jmp       L1407
L1411:
    movq      %XMM4,	[%rsi+8]
    movq      %XMM0,	%XMM4
    mov       %rdx,	1
    call      mc_libmcl.mgenrealimm
    mov       %rdi,	%rax
    jmp       L1407
L1412:
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    call      mc_libmcl.getstringindex
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %rdi,	%rax
    jmp       L1407
L1413:
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenmemaddr
    mov       %rdi,	%rax
    mov       %eax,	[%rsi+20]
    mov       [%rdi+12],	%eax
    jmp       L1407
L1414:
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %rdi,	%rax
    jmp       L1407
L1415:
    movzx     %rax,	byte ptr[%rsi+1]
    lea       %r10,	[%rip+pc_tables.opndnames]
    mov       %r10,	[%r10 + %rax*8]
    lea       %rcx,	[%rip+L8507]
    mov       %rdx,	%r10
    call      pc_api.merror
L1407:
    mov       %eax,	[%rsi+4]
    cmp       %rax,	1
    jz        L1417
    cmp       %rax,	2
    jz        L1418
    cmp       %rax,	4
    jz        L1419
    cmp       %rax,	8
    jz        L1420
    jmp       L1421
L1417:
    mov       %rbx,	116
    jmp       L1416
L1418:
    mov       %rbx,	117
    jmp       L1416
L1419:
    mov       %rbx,	118
    jmp       L1416
L1420:
    mov       %rbx,	119
    jmp       L1416
L1421:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8508]
    call      msys.m$print_str_nf
    mov       %eax,	[%rsi+4]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    lea       %rcx,	[%rip+L8509]
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rsi+3]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      pc_api.strpmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8510]
    lea       %rdx,	[%rip+L8511]
    call      pc_api.merror
L1416:
    mov       %rcx,	%rbx
    mov       %rdx,	%rdi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L1404:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_label
mc_genmcl.px_label:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rdi+8]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_load
mc_genmcl.px_load:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    call      mc_stackmcl.pushpcl
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_store
mc_genmcl.px_store:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rsi+3]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rsi+3]
    cmp       %rax,	11
    jz        L1426
    movzx     %rax,	byte ptr[%rsi+3]
    mov       %r10,	[%rsi+8]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_libmcl.mgenmem
    mov       %rdi,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    jmp       L1425
L1426:
    mov       %rcx,	6
    call      mc_stackmcl.getworkregm
    mov       %rdi,	%rax
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       %rcx,	14
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	%rdi
    mov       %rdx,	6
    call      mc_stackmcl.makeopndind
    mov       %rdi,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	6
    call      mc_stackmcl.makeopndind
    mov       %rbx,	%rax
    mov       %eax,	[%rsi+4]
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    mov       %r9,	1
    call      mc_auxmcl.copyblock
L1425:
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_add
mc_genmcl.px_add:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rsi+3]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rsi+3]
    cmp       %rax,	2
    jle       L1429
    mov       %rcx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.isimmload
    test      %rax,	%rax
    jz        L1431
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	[%rip+mc_decls.noperands]
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rax,	[%rax+8]
    cmp       %rax,	1
    jnz       L1431
    mov       %rcx,	52
    mov       %rdx,	%rdi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L1430
L1431:
    movzx     %rax,	byte ptr[%rsi+3]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    mov       %rcx,	28
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L1430:
    jmp       L1428
L1429:
    movzx     %rax,	byte ptr[%rsi+3]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rsi+3]
    dec       %rax
    mov       %r10,	65
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L1428:
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_sub
mc_genmcl.px_sub:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rsi+3]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rsi+3]
    cmp       %rax,	2
    jle       L1434
    mov       %rcx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.isimmload
    test      %rax,	%rax
    jz        L1436
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	[%rip+mc_decls.noperands]
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rax,	[%rax+8]
    cmp       %rax,	1
    jnz       L1436
    mov       %rcx,	53
    mov       %rdx,	%rdi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L1435
L1436:
    movzx     %rax,	byte ptr[%rsi+3]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    mov       %rcx,	29
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L1435:
    jmp       L1433
L1434:
    movzx     %rax,	byte ptr[%rsi+3]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rsi+3]
    dec       %rax
    mov       %r10,	67
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L1433:
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_mul
mc_genmcl.px_mul:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rsi+3]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rsi+3]
    cmp       %rax,	2
    jle       L1439
    mov       %rcx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.isimmload
    test      %rax,	%rax
    jz        L1441
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	[%rip+mc_decls.noperands]
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rax,	[%rax+8]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mc_auxmcl.mulimm
    jmp       L1440
L1441:
    movzx     %rax,	byte ptr[%rsi+3]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    mov       %rcx,	34
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L1440:
    jmp       L1438
L1439:
    movzx     %rax,	byte ptr[%rsi+3]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rsi+3]
    dec       %rax
    mov       %r10,	69
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L1438:
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_div
mc_genmcl.px_div:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_div.p, 32
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    dec       %rax
    mov       %r10,	71
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_eval
mc_genmcl.px_eval:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rdi+3]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_widen
mc_genmcl.px_widen:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	6
    jnz       L1446
    movsxd    %rax,	dword ptr[%rsi+28]
    and       %rax,	255
    cmp       %rax,	5
    jnz       L1446
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	5
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    mov       %rax,	[%rip+mc_decls.mccodex]
    movzx     %rax,	byte ptr[%rax+33]
    cmp       %rax,	11
    jz        L1448
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
L1448:
    jmp       L1445
L1446:
    movsxd    %rax,	dword ptr[%rsi+28]
    and       %rax,	255
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rax
    call      mc_stackmcl.getworkregm
    mov       %rdi,	%rax
    movsxd    %rax,	dword ptr[%rsi+28]
    and       %rax,	255
    lea       %r10,	[%rip+pc_tables.psigned]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1450
    mov       %rax,	18
    jmp       L1449
L1450:
    mov       %rax,	19
L1449:
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    movzx     %r10,	byte ptr[%rdi+10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_stackmcl.setnewzz
L1445:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_jump
mc_genmcl.px_jump:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rdi,	[%rsi+8]
    lea       %rax,	[%rsi+32]
    mov       %rbx,	%rax
    jmp       L1453
L1452:
    add       %rbx,	32
L1453:
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	135
    jz        L1452
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	127
    jz        L1456
    cmp       %rax,	24
    jz        L1457
    jmp       L1458
L1456:
    mov       %rax,	[%rbx+8]
    cmp       %rax,	%rdi
    jz        L1451
L1460:
    add       %rbx,	32
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	127
    jnz       L1462
    mov       %rax,	[%rbx+8]
    cmp       %rax,	%rdi
    jz        L1451
L1462:
    jmp       L1455
L1457:
    xor       %eax,	%eax
    mov       [%rbx],	%al
L1458:
L1455:
    mov       %rcx,	%rdi
    call      mc_libmcl.mgenlabel
    mov       %rcx,	25
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L1451:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_ijump
mc_genmcl.px_ijump:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_ijump.p, 16
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rcx,	25
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_genmcl.px_neg
mc_genmcl.px_neg:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_neg.p, 24
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jle       L1466
    mov       %rcx,	50
    mov       %rdx,	%rdi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L1465
L1466:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mc_auxmcl.do_negreal
L1465:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_abs
mc_genmcl.px_abs:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_abs.p, 32
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jle       L1469
    xor       %ecx,	%ecx
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	42
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rax,	[%rip+pc_api.mlabelno]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %r10,	%rax
    mov       %rbx,	%r10
    mov       %rcx,	26
    mov       %rdx,	13
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    mov       %rcx,	50
    mov       %rdx,	%rdi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	9
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L1468
L1469:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mc_auxmcl.do_absreal
L1468:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_bitnot
mc_genmcl.px_bitnot:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_bitnot.p, 24
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    mov       %rcx,	51
    mov       %rdx,	%rdi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_not
mc_genmcl.px_not:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_not.p, 24
    .set mc_genmcl.px_not.$T1, -8
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    mov       %rcx,	1
    mov       %rdx,	3
    call      mc_libmcl.mgenint
    mov       [%rbp + mc_genmcl.px_not.$T1],	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      mc_libmcl.changeopndsize
    mov       %rcx,	40
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_genmcl.px_not.$T1]
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_toboolt
mc_genmcl.px_toboolt:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_toboolt.$T2, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %r13,	%rcx
#---------------
#PROC3
#PROC4
    movsxd    %rax,	dword ptr[%r13+28]
    and       %rax,	255
    mov       %r12b,	%al
    movzx     %rax,	%r12b
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	%r12b
    cmp       %rax,	2
    jg        L1474
    movzx     %rax,	%r12b
    mov       %rcx,	%rax
    call      mc_stackmcl.getworkregm
    mov       %rbx,	%rax
    mov       %rcx,	3
    call      mc_stackmcl.getworkregm
    mov       %rsi,	%rax
    movzx     %rax,	%r12b
    dec       %rax
    mov       %r10,	76
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rbx
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    movzx     %rax,	%r12b
    dec       %rax
    mov       %r10,	73
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%r13]
    cmp       %rax,	64
    jnz       L1476
    mov       %rax,	5
    jmp       L1475
L1476:
    mov       %rax,	4
L1475:
    mov       %rcx,	58
    mov       %rdx,	%rax
    mov       %r8,	%rsi
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    mov       %rcx,	%rsi
    mov       %rdx,	4
    call      mc_libmcl.changeopndsize
    mov       %rcx,	19
    mov       %rdx,	%rax
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    movzx     %r10,	byte ptr[%rsi+10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_stackmcl.setnewzz
    jmp       L1473
L1474:
    mov       %rcx,	41
    mov       %rdx,	%rdi
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      mc_libmcl.changeopndsize
    mov       %r10,	%rax
    mov       %rbx,	%r10
    mov       [%rbp + mc_genmcl.px_toboolt.$T2],	%rax
    movzx     %rax,	byte ptr[%r13]
    cmp       %rax,	64
    jnz       L1478
    mov       %rax,	5
    jmp       L1477
L1478:
    mov       %rax,	4
L1477:
    mov       %rcx,	58
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_genmcl.px_toboolt.$T2]
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    mov       %rcx,	%rdi
    mov       %rdx,	4
    call      mc_libmcl.changeopndsize
    mov       %rcx,	19
    mov       %rdx,	%rax
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    mov       %al,	[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+mc_decls.pclmode]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11-3],	%al
L1473:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_sqr
mc_genmcl.px_sqr:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_sqr.p, 24
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jle       L1481
    mov       %rcx,	34
    mov       %rdx,	%rdi
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    jmp       L1480
L1481:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    dec       %rax
    mov       %r10,	69
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rdi
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
L1480:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_sqrt
mc_genmcl.px_sqrt:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_sqrt.p, 24
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    dec       %rax
    mov       %r10,	63
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rdi
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_jumpcc
mc_genmcl.px_jumpcc:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%r13+2]
    lea       %r10,	[%rip+mc_genmcl.ucondcodes]
    movzx     %r10,	byte ptr[%r10 + %rax-1]
    mov       %rdi,	%r10
    mov       %rax,	[%r13+8]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %r12,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	11
    jnz       L1485
    lea       %rcx,	[%rip+L8512]
    lea       %rdx,	[%rip+L8513]
    call      pc_api.merror
    jmp       L1484
L1485:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jle       L1487
    mov       %rcx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.isimmload
    test      %rax,	%rax
    jz        L1489
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	[%rip+mc_decls.noperands]
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rax,	[%rax+8]
    test      %rax,	%rax
    jnz       L1489
    movzx     %rax,	byte ptr[%r13+2]
    cmp       %rax,	1
    jz        L1490
    cmp       %rax,	2
    jnz       L1489
L1490:
    mov       %rcx,	41
    mov       %rdx,	%rbx
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    jmp       L1488
L1489:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rsi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.psigned]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1492
    movzx     %rax,	byte ptr[%r13+2]
    lea       %r10,	[%rip+mc_genmcl.scondcodes]
    movzx     %r10,	byte ptr[%r10 + %rax-1]
    mov       %rdi,	%r10
L1492:
    mov       %rcx,	42
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
L1488:
    jmp       L1486
L1487:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rsi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    dec       %rax
    mov       %r10,	73
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
L1486:
    mov       %rcx,	26
    mov       %rdx,	%rdi
    mov       %r8,	%r12
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    call      mc_stackmcl.poppcl
    mov       %eax,	[%r13+16]
    test      %eax,	%eax
    jnz       L1494
    call      mc_stackmcl.poppcl
L1494:
L1484:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_jumpt
mc_genmcl.px_jumpt:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    mov       %rdx,	5
    call      mc_auxmcl.do_jumptruefalse
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_jumpf
mc_genmcl.px_jumpf:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    mov       %rdx,	4
    call      mc_auxmcl.do_jumptruefalse
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_bitand
mc_genmcl.px_bitand:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    mov       %rdx,	38
    call      mc_auxmcl.do_bitwise
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_bitor
mc_genmcl.px_bitor:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    mov       %rdx,	39
    call      mc_auxmcl.do_bitwise
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_bitxor
mc_genmcl.px_bitxor:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    mov       %rdx,	40
    call      mc_auxmcl.do_bitwise
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_shl
mc_genmcl.px_shl:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    mov       %rdx,	43
    call      mc_auxmcl.do_shift
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_shr
mc_genmcl.px_shr:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.psigned]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1503
    mov       %rax,	44
    jmp       L1502
L1503:
    mov       %rax,	45
L1502:
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mc_auxmcl.do_shift
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_retproc
mc_genmcl.px_retproc:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+mc_decls.mclprocentry]
    cmp       %rax,	[%rip+mc_decls.mccodex]
    jnz       L1506
    lea       %rcx,	[%rip+L8514]
    call      mc_libmcl.mgencomment
L1506:
    mov       %rcx,	%rdi
    call      mc_auxmcl.do_procentry
    call      mc_auxmcl.do_procexit
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_retfn
mc_genmcl.px_retfn:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_retfn.$T1, -8
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %rsi,	%rcx
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	11
    jnz       L1509
    mov       %rcx,	1
    mov       %rdx,	10
    xor       %r8d,	%r8d
    call      mc_libmcl.mgenireg
    mov       %rbx,	%rax
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.regset]
    mov       [%r10],	%al
    mov       %rcx,	6
    call      mc_stackmcl.getworkregm
    mov       %rdi,	%rax
    mov       %rcx,	[%rip+pc_decls.blockretname]
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rdi+10]
    mov       %rcx,	%rax
    mov       %rdx,	10
    xor       %r8d,	%r8d
    call      mc_libmcl.mgenireg
    mov       %rdi,	%rax
    mov       %eax,	[%rsi+4]
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    mov       %r9,	1
    call      mc_auxmcl.copyblock
    mov       %rcx,	[%rip+pc_decls.blockretname]
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       [%rbp + mc_genmcl.px_retfn.$T1],	%rax
    mov       %rcx,	1
    mov       %rdx,	6
    call      mc_libmcl.mgenreg
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_genmcl.px_retfn.$T1]
    call      mc_libmcl.genmc
L1509:
    mov       %rcx,	%rsi
    call      mc_genmcl.px_retproc
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_setcall
mc_genmcl.px_setcall:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    xor       %ecx,	%ecx
    call      mc_stackmcl.saveopnds
    mov       %rax,	[%rip+mc_decls.ncalldepth]
    cmp       %rax,	32
    jl        L1512
    lea       %rcx,	[%rip+L8515]
    lea       %rdx,	[%rip+L8516]
    call      pc_api.merror
L1512:
    inc       qword ptr[%rip+mc_decls.ncalldepth]
    movsxd    %rax,	dword ptr[%rdi+16]
    cmp       %rax,	4
    jg        L1514
    mov       %eax,	[%rip+mc_decls.mstackdepth]
    and       %eax,	1
    lea       %r10,	[%rip+mc_decls.callalign]
    mov       %r11,	[%rip+mc_decls.ncalldepth]
    mov       [%r10 + %r11-1],	%al
    jmp       L1513
L1514:
    movsxd    %rax,	dword ptr[%rdi+16]
    and       %eax,	1
    mov       %r10d,	[%rip+mc_decls.mstackdepth]
    and       %r10d,	1
    xor       %rax,	%r10
    lea       %r10,	[%rip+mc_decls.callalign]
    mov       %r11,	[%rip+mc_decls.ncalldepth]
    mov       [%r10 + %r11-1],	%al
L1513:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	11
    setz      %al
    movzx     %eax,	%al
    lea       %r10,	[%rip+mc_decls.callblockret]
    mov       %r11,	[%rip+mc_decls.ncalldepth]
    mov       [%r10 + %r11-1],	%al
    mov       %eax,	[%rdi+4]
    lea       %r10,	[%rip+mc_decls.callblocksize]
    mov       %r11,	[%rip+mc_decls.ncalldepth]
    mov       [%r10 + %r11*4-4],	%eax
    lea       %rax,	[%rip+mc_decls.callalign]
    mov       %r10,	[%rip+mc_decls.ncalldepth]
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L1516
    mov       %rcx,	1
    call      mc_libmcl.pushslots
L1516:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_setarg
mc_genmcl.px_setarg:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    movsxd    %rax,	dword ptr[%rbx+16]
    lea       %r10,	[%rip+mc_decls.callblockret]
    mov       %r11,	[%rip+mc_decls.ncalldepth]
    movzx     %r10,	byte ptr[%r10 + %r11-1]
    add       %rax,	%r10
    mov       %rdi,	%rax
    cmp       %rdi,	4
    jle       L1519
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	11
    jnz       L1521
    mov       %eax,	[%rbx+4]
    xor       %ecx,	%ecx
    mov       %rdx,	%rax
    mov       %r8,	%rdi
    call      mc_auxmcl.copyblockarg
L1521:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.pushopnd
    jmp       L1518
L1519:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	11
    jnz       L1522
    mov       %eax,	[%rbx+4]
    lea       %r10,	[%rip+mc_decls.callargsize]
    mov       %r11,	[%rip+mc_decls.ncalldepth]
    shl       %r11,	4
    lea       %r10,	[%r10 + %r11-16]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*4-4],	%eax
L1522:
L1518:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_callp
mc_genmcl.px_callp:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_callp.p, 72
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       [%rbp+72],	%rcx
#---------------
#PROC3
#PROC4
    xor       %r12,	%r12
    xor       %eax,	%eax
    mov       %r13,	%rax
    lea       %rax,	[%rip+mc_decls.callblockret]
    mov       %r10,	[%rip+mc_decls.ncalldepth]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %r14,	%rax
    mov       %rax,	[%rbp + mc_genmcl.px_callp.p]
    movsxd    %rax,	dword ptr[%rax+16]
    add       %rax,	%r14
    mov       %rdi,	%rax
    mov       %rax,	%rdi
    mov       %r10,	4
    cmp       %rax,	%r10
    cmovg     %rax,	%r10
    mov       %rbx,	%rax
    mov       %rax,	[%rbp + mc_genmcl.px_callp.p]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	19
    jz        L1526
    cmp       %rax,	22
    jnz       L1525
L1526:
    mov       %r12,	1
L1525:
    mov       %rax,	[%rbp + mc_genmcl.px_callp.p]
    movsxd    %rax,	dword ptr[%rax+20]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    mov       %r8,	%r12
    call      mc_auxmcl.do_pushlowargs
    xor       %rsi,	%rsi
    mov       %rax,	%rdi
    cmp       %rax,	4
    jg        L1528
    mov       %rax,	[%rip+mc_decls.mstackdepth]
    test      %rax,	%rax
    jz        L1530
    mov       %rax,	4
    add       %rsi,	%rax
    mov       %rcx,	4
    call      mc_libmcl.pushslots
    lea       %rax,	[%rip+mc_decls.callalign]
    mov       %r10,	[%rip+mc_decls.ncalldepth]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    add       %rsi,	%rax
    jmp       L1529
L1530:
    mov       %al,	1
    mov       [%rip+pc_decls.localshadow],	%al
L1529:
    jmp       L1527
L1528:
    lea       %rax,	[%rip+mc_decls.callalign]
    mov       %r10,	[%rip+mc_decls.ncalldepth]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %r10,	%rdi
    add       %r10,	%rax
    mov       %rsi,	%r10
    mov       %rcx,	4
    call      mc_libmcl.pushslots
L1527:
    test      %r12,	%r12
    jz        L1532
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rcx,	21
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    jmp       L1531
L1532:
    mov       %rax,	[%rbp + mc_genmcl.px_callp.p]
    mov       %rax,	[%rax+8]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenmemaddr
    mov       %rcx,	21
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L1531:
    mov       %rax,	%rbx
    sub       %rax,	%r14
    mov       %r15,	%rax
    cmp       %r15,	0
    jle       L1535
L1533:
    call      mc_stackmcl.poppcl
    dec       %r15
    jnz       L1533
L1535:
    test      %rsi,	%rsi
    jz        L1537
    mov       %rcx,	%rsi
    call      mc_libmcl.popslots
L1537:
    mov       %al,	[%rip+mc_decls.pmode]
    test      %al,	%al
    jz        L1539
    mov       %rcx,	[%rbp + mc_genmcl.px_callp.p]
    call      mc_auxmcl.do_getretvalue
L1539:
    dec       qword ptr[%rip+mc_decls.ncalldepth]
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_jumpret
mc_genmcl.px_jumpret:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %al,	[%rip+mc_decls.pmode]
    test      %al,	%al
    jz        L1542
    mov       %rax,	[%rip+mc_decls.noperands]
    test      %rax,	%rax
    jz        L1544
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    mov       %r8,	1
    call      mc_stackmcl.loadparam
    call      mc_stackmcl.poppcl
L1544:
L1542:
    mov       %rcx,	%rdi
    call      mc_genmcl.px_jump
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_jumpretm
mc_genmcl.px_jumpretm:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
#---------------
#PROC3
#PROC4
    movsxd    %rax,	dword ptr[%r13+16]
    mov       %r10,	[%rip+mc_decls.noperands]
    sub       %r10,	%rax
    inc       %r10
    mov       %rdi,	%r10
    movsxd    %rax,	dword ptr[%r13+16]
    mov       %rsi,	%rax
    cmp       %rsi,	0
    jle       L1548
L1546:
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    inc       %rdi
    dec       %rsi
    jnz       L1546
L1548:
    mov       %rbx,	1
    movsxd    %rax,	dword ptr[%r13+16]
    mov       %r12,	%rax
    cmp       %r12,	0
    jle       L1551
L1549:
    cmp       %rbx,	4
    jnz       L1553
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	2
    jle       L1553
    mov       %rbx,	11
L1553:
    mov       %rcx,	%rbx
    call      mc_stackmcl.movetoreg
    call      mc_stackmcl.poppcl
    inc       %rbx
    dec       %r12
    jnz       L1549
L1551:
    mov       %rcx,	%r13
    call      mc_genmcl.px_jump
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_startmx
mc_genmcl.px_startmx:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_startmx.p, 16
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    xor       %ecx,	%ecx
    call      mc_stackmcl.saveopnds
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_genmcl.px_resetmx
mc_genmcl.px_resetmx:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	1
    call      mc_stackmcl.movetoreg
    movzx     %rax,	byte ptr[%rdi]
    cmp       %rax,	118
    jnz       L1557
    call      mc_stackmcl.poppcl
L1557:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_stop
mc_genmcl.px_stop:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_stop.p, 16
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	6
    mov       %r8,	11
    call      mc_stackmcl.loadparam
    lea       %rcx,	[%rip+L8517]
    call      mc_libmcl.mgenextname
    mov       %rcx,	21
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %al,	1
    mov       [%rip+pc_decls.localshadow],	%al
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_genmcl.px_incrto
mc_genmcl.px_incrto:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    mov       %rdx,	52
    mov       %r8,	28
    call      mc_auxmcl.do_incr
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_decrto
mc_genmcl.px_decrto:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    mov       %rdx,	53
    mov       %r8,	29
    call      mc_auxmcl.do_incr
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_incrload
mc_genmcl.px_incrload:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    mov       %rdx,	52
    mov       %r8,	28
    call      mc_auxmcl.do_incrload
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_decrload
mc_genmcl.px_decrload:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    mov       %rdx,	53
    mov       %r8,	29
    call      mc_auxmcl.do_incrload
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_loadincr
mc_genmcl.px_loadincr:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    mov       %rdx,	52
    mov       %r8,	28
    call      mc_auxmcl.do_loadincr
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_loaddecr
mc_genmcl.px_loaddecr:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    mov       %rdx,	53
    mov       %r8,	29
    call      mc_auxmcl.do_loadincr
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_forup
mc_genmcl.px_forup:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    mov       %rdx,	52
    mov       %r8,	28
    mov       %r9,	14
    call      mc_auxmcl.do_for
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_fordown
mc_genmcl.px_fordown:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    mov       %rdx,	53
    mov       %r8,	29
    mov       %r9,	13
    call      mc_auxmcl.do_for
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_iload
mc_genmcl.px_iload:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_iload.p, 40
    .set mc_genmcl.px_iload.$T1, -8
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	11
    jz        L1569
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	2
    jnz       L1571
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	[%rip+mc_decls.noperands]
    movzx     %r10,	byte ptr[%r10 + %r11-1]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.mgenireg
    mov       %rbx,	%rax
    jmp       L1570
L1571:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rbx,	%rax
L1570:
    mov       %rax,	[%rip+mc_decls.currpcl]
    lea       %rax,	[%rax+32]
    mov       %rsi,	%rax
    movzx     %rax,	byte ptr[%rsi]
    cmp       %rax,	114
    jnz       L1573
    movzx     %rax,	byte ptr[%rsi+3]
    mov       [%rbp + mc_genmcl.px_iload.$T1],	%rax
    movzx     %rax,	byte ptr[%rsi+3]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      mc_genmcl.getsharereg
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_genmcl.px_iload.$T1]
    call      mc_stackmcl.getworkreg_rm
    mov       %rdi,	%rax
    movsxd    %rax,	dword ptr[%rsi+28]
    and       %rax,	255
    lea       %r10,	[%rip+mc_decls.ploadop]
    movzx     %r10,	byte ptr[%r10 + %rax]
    mov       %rcx,	%r10
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rsi+3]
    movzx     %r10,	byte ptr[%rdi+10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_stackmcl.setnewzz
    mov       [%rip+mc_decls.currpcl],	%rsi
    jmp       L1572
L1573:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       [%rbp + mc_genmcl.px_iload.$T1],	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      mc_genmcl.getsharereg
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_genmcl.px_iload.$T1]
    call      mc_stackmcl.getworkreg_rm
    mov       %rdi,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    movzx     %r10,	byte ptr[%rdi+10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_stackmcl.setnewzz
L1572:
    jmp       L1568
L1569:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind_simp
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rbx+10]
    mov       %rcx,	%rax
    mov       %rdx,	6
    call      mc_stackmcl.getworkreg_rm
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mc_auxmcl.dolea
L1568:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.getsharereg
mc_genmcl.getsharereg:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
#---------------
#PROC3
#PROC4
    mov       %dil,	[%rcx+10]
    mov       %bl,	[%rcx+11]
    cmp       %rdx,	2
    jg        L1576
    xor       %eax,	%eax
    jmp       L1574
L1576:
    test      %dil,	%dil
    jz        L1578
    movzx     %rax,	%dil
    lea       %r10,	[%rip+mc_decls.workregs]
    mov       %r10b,	[%r10 + %rax-1]
    test      %r10b,	%r10b
    jnz       L1579
    movzx     %rax,	%dil
    cmp       %rax,	11
    jl        L1578
    cmp       %rax,	14
    jg        L1578
L1579:
    movzx     %rax,	%dil
    jmp       L1574
L1578:
    test      %bl,	%bl
    jz        L1580
    movzx     %rax,	%bl
    lea       %r10,	[%rip+mc_decls.workregs]
    mov       %r10b,	[%r10 + %rax-1]
    test      %r10b,	%r10b
    jnz       L1581
    movzx     %rax,	%dil
    cmp       %rax,	11
    jl        L1580
    cmp       %rax,	14
    jg        L1580
L1581:
    movzx     %rax,	%bl
    jmp       L1574
L1580:
L1577:
    xor       %eax,	%eax
L1574:
#---------------
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_iloadx
mc_genmcl.px_iloadx:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_iloadx.$T1, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %r12,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%r12
    call      mc_auxmcl.do_addrmode
    mov       %rsi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	11
    jnz       L1584
    movzx     %rax,	byte ptr[%rsi+10]
    mov       %rcx,	%rax
    mov       %rdx,	6
    call      mc_stackmcl.getworkreg_rm
    mov       %rbx,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      mc_auxmcl.dolea
    call      mc_stackmcl.poppcl
    movzx     %rax,	byte ptr[%rbx+10]
    mov       %rcx,	%rax
    mov       %rdx,	6
    call      mc_stackmcl.setnewzz
    jmp       L1583
L1584:
    mov       %rax,	[%rip+mc_decls.currpcl]
    lea       %rax,	[%rax+32]
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rdi]
    cmp       %rax,	114
    jnz       L1586
    movzx     %rax,	byte ptr[%rdi+3]
    mov       [%rbp + mc_genmcl.px_iloadx.$T1],	%rax
    movzx     %rax,	byte ptr[%rdi+3]
    mov       %rcx,	%rsi
    mov       %rdx,	%rax
    call      mc_genmcl.getsharereg
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_genmcl.px_iloadx.$T1]
    call      mc_stackmcl.getworkreg_rm
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%rdi+28]
    and       %rax,	255
    lea       %r10,	[%rip+mc_decls.ploadop]
    movzx     %r10,	byte ptr[%r10 + %rax]
    mov       %rcx,	%r10
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    movzx     %rax,	byte ptr[%rdi+3]
    movzx     %r10,	byte ptr[%rbx+10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_stackmcl.setnewzz
    mov       [%rip+mc_decls.currpcl],	%rdi
    jmp       L1585
L1586:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       [%rbp + mc_genmcl.px_iloadx.$T1],	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rsi
    mov       %rdx,	%rax
    call      mc_genmcl.getsharereg
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_genmcl.px_iloadx.$T1]
    call      mc_stackmcl.getworkreg_rm
    mov       %rbx,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    movzx     %r10,	byte ptr[%rbx+10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_stackmcl.setnewzz
L1585:
L1583:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_istore
mc_genmcl.px_istore:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	2
    jnz       L1589
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	[%rip+mc_decls.noperands]
    movzx     %r10,	byte ptr[%r10 + %r11-1]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.mgenireg
    mov       %rbx,	%rax
    jmp       L1588
L1589:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rbx,	%rax
L1588:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	11
    jnz       L1591
    mov       %rcx,	%rbx
    call      mc_stackmcl.makesimpleaddr
    mov       %rbx,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	6
    call      mc_stackmcl.makeopndind
    mov       %rdi,	%rax
    mov       %eax,	[%rsi+4]
    mov       %rcx,	%rbx
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    mov       %r9,	1
    call      mc_auxmcl.copyblock
    jmp       L1590
L1591:
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
L1590:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_istorex
mc_genmcl.px_istorex:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    sub       %r10,	2
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    mov       %rcx,	%rsi
    call      mc_auxmcl.do_addrmode
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	11
    jnz       L1594
    mov       %rcx,	%rbx
    call      mc_stackmcl.makesimpleaddr
    mov       %rbx,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	6
    call      mc_stackmcl.makeopndind
    mov       %rdi,	%rax
    mov       %eax,	[%rsi+4]
    mov       %rcx,	%rbx
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    mov       %r9,	1
    call      mc_auxmcl.copyblock
    jmp       L1593
L1594:
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
L1593:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_storem
mc_genmcl.px_storem:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
#PROC3
#PROC4
    mov       %eax,	[%r12+4]
    cmp       %rax,	16
    jz        L1597
    lea       %rcx,	[%rip+L8518]
    lea       %rdx,	[%rip+L8519]
    call      pc_api.merror
L1597:
    mov       %rcx,	16
    call      mc_libmcl.newblocktemp
    mov       %rsi,	%rax
    mov       %rcx,	%rsi
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       %rbx,	%rax
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	8
    xor       %r8d,	%r8d
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rdi+10]
    mov       %rcx,	%rax
    mov       %rdx,	6
    call      mc_libmcl.mgenreg
    mov       %rcx,	14
    mov       %rdx,	%rax
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rdi+10]
    mov       %rcx,	%rax
    mov       %rdx,	6
    call      mc_stackmcl.setnewzz
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_addpx
mc_genmcl.px_addpx:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rsi
    call      mc_auxmcl.do_addrmode
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rbx+10]
    mov       %rcx,	%rax
    mov       %rdx,	6
    call      mc_stackmcl.getworkreg_rm
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mc_auxmcl.dolea
    call      mc_stackmcl.poppcl
    movzx     %rax,	byte ptr[%rdi+10]
    mov       %rcx,	%rax
    mov       %rdx,	6
    call      mc_stackmcl.setnewzz
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_subpx
mc_genmcl.px_subpx:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r14,	%rcx
#---------------
#PROC3
#PROC4
    movsxd    %rax,	dword ptr[%r14+16]
    mov       %rdi,	%rax
    movsxd    %rax,	dword ptr[%r14+20]
    mov       %rbx,	%rax
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rsi,	%rax
    mov       %rcx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.isimmload
    mov       %r13,	%rax
    test      %rax,	%rax
    jz        L1601
    mov       %rax,	[%r13+8]
    mov       %r10,	%rdi
    imul      %rax,	%r10
    add       %rax,	%rbx
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	29
    mov       %rdx,	%rsi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L1600
L1601:
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %r12,	%rax
    mov       %rcx,	%r12
    mov       %rdx,	%rdi
    call      mc_auxmcl.scaleindex
    mov       %rdi,	%rax
    cmp       %rdi,	1
    jle       L1603
    mov       %rcx,	%r12
    mov       %rdx,	%rdi
    call      mc_auxmcl.mulimm
L1603:
    mov       %rcx,	29
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      mc_libmcl.genmc
    test      %rbx,	%rbx
    jz        L1605
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8520]
    call      msys.m$print_str_nf
    mov       %rcx,	%rbx
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8521]
    lea       %rdx,	[%rip+L8522]
    call      pc_api.merror
L1605:
L1600:
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_to
mc_genmcl.px_to:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rsi+32]
    mov       [%rip+mc_decls.currpcl],	%rax
    mov       %rdi,	%rax
    mov       %rax,	[%rdi+8]
    mov       %rcx,	%rax
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       %rbx,	%rax
    mov       %rcx,	53
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %rcx,	26
    mov       %rdx,	5
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_iswap
mc_genmcl.px_iswap:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_iswap.p, 48
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rsi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %r12,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rax
    call      mc_stackmcl.getworkregm
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rax
    call      mc_stackmcl.getworkregm
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	11
    jz        L1609
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%r12
    call      mc_libmcl.genmc
    mov       %rcx,	11
    mov       %rdx,	%r12
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rcx,	11
    mov       %rdx,	%rsi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    jmp       L1608
L1609:
    lea       %rcx,	[%rip+L8523]
    lea       %rdx,	[%rip+L8524]
    call      pc_api.merror
L1608:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_swapstk
mc_genmcl.px_swapstk:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    movsxd    %rax,	dword ptr[%rdi+20]
    mov       %r10,	[%rip+mc_decls.noperands]
    sub       %r10,	%rax
    inc       %r10
    movsxd    %rax,	dword ptr[%rdi+16]
    mov       %r11,	[%rip+mc_decls.noperands]
    sub       %r11,	%rax
    inc       %r11
    mov       %rcx,	%r11
    mov       %rdx,	%r10
    call      mc_stackmcl.swapopnds
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_labeldef
mc_genmcl.px_labeldef:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_labeldef.str, -104
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	136
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rdi+8]
    mov       %rax,	[%rax]
    lea       %rcx,	[%rbp + mc_genmcl.px_labeldef.str]
    mov       %rdx,	%rax
    call      strcpy
    lea       %rcx,	[%rbp + mc_genmcl.px_labeldef.str]
    lea       %rdx,	[%rip+L8525]
    call      strcat
    lea       %rcx,	[%rbp + mc_genmcl.px_labeldef.str]
    call      mc_libmcl.mgencomment
#---------------
    add       %rsp,	136
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_addto
mc_genmcl.px_addto:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    mov       %rdx,	28
    mov       %r8,	65
    call      mc_auxmcl.do_binto
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_subto
mc_genmcl.px_subto:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    mov       %rdx,	29
    mov       %r8,	67
    call      mc_auxmcl.do_binto
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_multo
mc_genmcl.px_multo:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jg        L1616
    mov       %rcx,	%r13
    mov       %rdx,	69
    call      mc_auxmcl.do_binto_float
    jmp       L1614
L1616:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.psize]
    movzx     %r10,	byte ptr[%r10 + %rax]
    cmp       %r10,	1
    jnz       L1618
    lea       %rcx,	[%rip+L8526]
    lea       %rdx,	[%rip+L8527]
    call      pc_api.merror
L1618:
    mov       %rcx,	10
    xor       %edx,	%edx
    call      mc_stackmcl.pushpcl_reg
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    sub       %r10,	2
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rsi,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rsi
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rax,	[%rip+mc_decls.noperands]
    sub       %rax,	2
    mov       %rcx,	%rax
    call      mc_stackmcl.isimmload
    mov       %r12,	%rax
    test      %rax,	%rax
    jz        L1620
    mov       %rax,	[%r12+8]
    mov       %rcx,	%rsi
    mov       %rdx,	%rax
    call      mc_auxmcl.mulimm
    jmp       L1619
L1620:
    mov       %rcx,	34
    mov       %rdx,	%rsi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L1619:
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
L1614:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_bitandto
mc_genmcl.px_bitandto:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    mov       %rdx,	38
    xor       %r8d,	%r8d
    call      mc_auxmcl.do_binto
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_bitorto
mc_genmcl.px_bitorto:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    mov       %rdx,	39
    xor       %r8d,	%r8d
    call      mc_auxmcl.do_binto
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_bitxorto
mc_genmcl.px_bitxorto:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    mov       %rdx,	40
    xor       %r8d,	%r8d
    call      mc_auxmcl.do_binto
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_shlto
mc_genmcl.px_shlto:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    mov       %rdx,	43
    call      mc_auxmcl.do_shiftnto
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_shrto
mc_genmcl.px_shrto:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.psigned]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1627
    mov       %rax,	44
    jmp       L1626
L1627:
    mov       %rax,	45
L1626:
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mc_auxmcl.do_shiftnto
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_fix
mc_genmcl.px_fix:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
#PROC3
#PROC4
    movsxd    %rax,	dword ptr[%rsi+28]
    and       %rax,	255
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      mc_stackmcl.pushpcl_reg
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.pmin]
    movzx     %r10,	byte ptr[%r10 + %rax]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%r10
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%rsi+28]
    and       %rax,	255
    dec       %rax
    mov       %r10,	84
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    call      mc_stackmcl.poppcl
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    movzx     %r10,	byte ptr[%rbx+10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_stackmcl.setnewzz
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_float
mc_genmcl.px_float:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r14,	%rcx
#---------------
#PROC3
#PROC4
    movsxd    %rax,	dword ptr[%r14+28]
    and       %rax,	255
    mov       %r13b,	%al
    movzx     %rax,	%r13b
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	%r13b
    lea       %r10,	[%rip+pc_tables.psize]
    movzx     %r10,	byte ptr[%r10 + %rax]
    cmp       %r10,	4
    jge       L1631
    lea       %rcx,	[%rip+L8528]
    lea       %rdx,	[%rip+L8529]
    call      pc_api.merror
L1631:
    movzx     %rax,	%r13b
    lea       %r10,	[%rip+pc_tables.psigned]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1633
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      mc_stackmcl.pushpcl_reg
    movzx     %rax,	byte ptr[%r14+3]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    dec       %rax
    mov       %r10,	86
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    jmp       L1632
L1633:
    movzx     %rax,	%r13b
    cmp       %rax,	6
    jnz       L1634
    mov       %rcx,	2
    xor       %edx,	%edx
    call      mc_stackmcl.pushpcl_reg
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	2
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    call      mc_libmcl.mcreatefwdlabel
    mov       %rsi,	%rax
    call      mc_libmcl.mcreatefwdlabel
    mov       %r12,	%rax
    xor       %ecx,	%ecx
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	42
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	%rsi
    call      mc_libmcl.mgenlabel
    mov       %rcx,	26
    mov       %rdx,	12
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    mov       %rcx,	87
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rcx,	%r12
    call      mc_libmcl.mgenlabel
    mov       %rcx,	25
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	%rsi
    call      mc_libmcl.mdefinefwdlabel
    mov       %rax,	[%rip+mc_decls.labmask63]
    test      %rax,	%rax
    jnz       L1636
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rax,	[%rip+pc_api.mlabelno]
    mov       [%rip+mc_decls.labmask63],	%rax
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rax,	[%rip+pc_api.mlabelno]
    mov       [%rip+mc_decls.laboffset64],	%rax
L1636:
    mov       %rcx,	[%rip+mc_decls.labmask63]
    call      mc_libmcl.mgenlabelmem
    mov       %rcx,	38
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	87
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rcx,	[%rip+mc_decls.laboffset64]
    call      mc_libmcl.mgenlabelmem
    mov       %rcx,	66
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	%r12
    call      mc_libmcl.mdefinefwdlabel
#mc_genmcl.px_float.reduce:
L1637:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	1
    jnz       L1639
    mov       %rcx,	%rbx
    mov       %rdx,	4
    call      mc_libmcl.changeopndsize
    mov       %rcx,	88
    mov       %rdx,	%rax
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.pclmode]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11-1],	%al
L1639:
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    jmp       L1632
L1634:
    mov       %rcx,	2
    xor       %edx,	%edx
    call      mc_stackmcl.pushpcl_reg
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	2
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	8
    call      mc_libmcl.changeopndsize
    mov       %rdi,	%rax
    mov       %rcx,	87
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    jmp       L1637
L1632:
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_idiv
mc_genmcl.px_idiv:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.psigned]
    movzx     %r10,	byte ptr[%r10 + %rax]
    mov       %rcx,	%rdi
    mov       %rdx,	%r10
    mov       %r8,	1
    call      mc_auxmcl.do_divrem
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_irem
mc_genmcl.px_irem:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.psigned]
    movzx     %r10,	byte ptr[%r10 + %rax]
    mov       %rcx,	%rdi
    mov       %rdx,	%r10
    xor       %r8d,	%r8d
    call      mc_auxmcl.do_divrem
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_idivrem
mc_genmcl.px_idivrem:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.psigned]
    movzx     %r10,	byte ptr[%r10 + %rax]
    mov       %rcx,	%rdi
    mov       %rdx,	%r10
    mov       %r8,	2
    call      mc_auxmcl.do_divrem
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_clear
mc_genmcl.px_clear:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	6
    call      mc_stackmcl.getopnd_ind_simp
    mov       %rdi,	%rax
    mov       %eax,	[%rbx+4]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mc_auxmcl.clearblock
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_subp
mc_genmcl.px_subp:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    mov       %rcx,	29
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    movsxd    %rax,	dword ptr[%r12+16]
    cmp       %rax,	1
    jle       L1646
    movsxd    %rax,	dword ptr[%r12+16]
    mov       %rcx,	%rax
    call      mc_libmcl.ispoweroftwo
    mov       %rsi,	%rax
    test      %rsi,	%rsi
    jz        L1648
    mov       %rcx,	%rsi
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	45
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L1647
L1648:
    call      msys.m$print_startcon
    movsxd    %rax,	dword ptr[%r12+16]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8530]
    lea       %rdx,	[%rip+L8531]
    call      pc_api.merror
L1647:
L1646:
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_switch
mc_genmcl.px_switch:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_switch.p, 64
    .set mc_genmcl.px_switch.bx, -8
    .set mc_genmcl.px_switch.ax2, -16
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       [%rbp+64],	%rcx
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rbp + mc_genmcl.px_switch.p]
    movsxd    %rax,	dword ptr[%rax+16]
    mov       %rdi,	%rax
    mov       %rax,	[%rbp + mc_genmcl.px_switch.p]
    movsxd    %rax,	dword ptr[%rax+20]
    mov       %rbx,	%rax
    mov       %rax,	[%rbp + mc_genmcl.px_switch.p]
    mov       %rsi,	[%rax+8]
    mov       %rax,	[%rbp + mc_genmcl.px_switch.p]
    lea       %rax,	[%rax+32]
    mov       [%rip+mc_decls.currpcl],	%rax
    mov       %rax,	[%rip+mc_decls.currpcl]
    mov       %r12,	[%rax+8]
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %r14,	%rax
    mov       %rax,	[%rbp + mc_genmcl.px_switch.p]
    mov       %eax,	[%rax+4]
    cmp       %rax,	8
    jge       L1651
    mov       %rcx,	%r14
    mov       %rdx,	8
    call      mc_libmcl.changeopndsize
    mov       %r10,	%rax
    mov       [%rbp + mc_genmcl.px_switch.ax2],	%r10
    mov       %rcx,	18
    mov       %rdx,	%rax
    mov       %r8,	%r14
    call      mc_libmcl.genmc
    mov       %r14,	[%rbp + mc_genmcl.px_switch.ax2]
L1651:
    test      %rdi,	%rdi
    jz        L1653
    mov       %rcx,	%rdi
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	29
    mov       %rdx,	%r14
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L1653:
    mov       %rax,	%rbx
    sub       %rax,	%rdi
    inc       %rax
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	42
    mov       %rdx,	%r14
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	%r12
    call      mc_libmcl.mgenlabel
    mov       %rcx,	26
    mov       %rdx,	3
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    movzx     %rax,	byte ptr[%rip+pc_api.phighmem]
    cmp       %rax,	2
    jnz       L1655
    call      mc_stackmcl.getworkireg
    mov       %r13,	%rax
    mov       %rcx,	%r13
    mov       %rdx,	6
    call      mc_libmcl.mgenreg
    mov       [%rbp + mc_genmcl.px_switch.bx],	%rax
    mov       %rcx,	%rsi
    call      mc_libmcl.mgenlabelmem
    mov       %rcx,	14
    mov       %rdx,	[%rbp + mc_genmcl.px_switch.bx]
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    sub       %rsp,	8
    push      0
    push      0
    push      0
    movzx     %rax,	byte ptr[%r14+10]
    mov       %rcx,	%r13
    mov       %rdx,	%rax
    mov       %r8,	8
    xor       %r9d,	%r9d
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rcx,	25
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L1654
L1655:
    sub       %rsp,	8
    push      0
    mov       %rax,	%rsi
    push      %rax
    push      0
    movzx     %rax,	byte ptr[%r14+10]
    xor       %ecx,	%ecx
    mov       %rdx,	%rax
    mov       %r8,	8
    xor       %r9d,	%r9d
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rcx,	25
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L1654:
    call      mc_stackmcl.poppcl
    mov       %rcx,	73
    mov       %rdx,	1
    call      mc_libmcl.setsegment
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_switchu
mc_genmcl.px_switchu:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_switchu.p, 64
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	32
    mov       [%rbp+64],	%rcx
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rbp + mc_genmcl.px_switchu.p]
    movsxd    %rax,	dword ptr[%rax+16]
    mov       %rdi,	%rax
    mov       %rax,	[%rbp + mc_genmcl.px_switchu.p]
    movsxd    %rax,	dword ptr[%rax+20]
    mov       %rbx,	%rax
    mov       %rax,	[%rbp + mc_genmcl.px_switchu.p]
    mov       %rsi,	[%rax+8]
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %r13,	%rax
    movzx     %rax,	byte ptr[%rip+pc_api.phighmem]
    cmp       %rax,	2
    jnz       L1658
    call      mc_stackmcl.getworkireg
    mov       %r12,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      mc_libmcl.mgenreg
    mov       %r14,	%rax
    mov       %rcx,	%rsi
    call      mc_libmcl.mgenlabelmem
    mov       %rcx,	14
    mov       %rdx,	%r14
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    sub       %rsp,	8
    push      0
    push      0
    push      0
    mov       %rax,	%rdi
    neg       %rax
    shl       %rax,	3
    movzx     %r10,	byte ptr[%r13+10]
    mov       %rcx,	%r12
    mov       %rdx,	%r10
    mov       %r8,	8
    mov       %r9,	%rax
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rcx,	25
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L1657
L1658:
    sub       %rsp,	8
    push      0
    mov       %rax,	%rsi
    push      %rax
    push      0
    mov       %rax,	%rdi
    neg       %rax
    shl       %rax,	3
    movzx     %r10,	byte ptr[%r13+10]
    xor       %ecx,	%ecx
    mov       %rdx,	%r10
    mov       %r8,	8
    mov       %r9,	%rax
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rcx,	25
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L1657:
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	32
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_swlabel
mc_genmcl.px_swlabel:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rdi+8]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %rcx,	119
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_endsw
mc_genmcl.px_endsw:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_endsw.p, 16
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    mov       %rcx,	67
    mov       %rdx,	1
    call      mc_libmcl.setsegment
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_genmcl.px_fwiden
mc_genmcl.px_fwiden:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    movsxd    %rax,	dword ptr[%rbx+28]
    and       %rax,	255
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	8
    call      mc_libmcl.changeopndsize
    mov       %rcx,	89
    mov       %rdx,	%rax
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %al,	2
    lea       %r10,	[%rip+mc_decls.pclmode]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11-1],	%al
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_fnarrow
mc_genmcl.px_fnarrow:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    movsxd    %rax,	dword ptr[%rbx+28]
    and       %rax,	255
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	4
    call      mc_libmcl.changeopndsize
    mov       %rcx,	88
    mov       %rdx,	%rax
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.pclmode]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11-1],	%al
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_truncate
mc_genmcl.px_truncate:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
#PROC3
#PROC4
    movsxd    %rax,	dword ptr[%rsi+28]
    and       %rax,	255
    mov       %bl,	%al
    movzx     %rax,	%bl
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    mov       %eax,	[%rsi+4]
    movzx     %r10,	%bl
    lea       %r11,	[%rip+pc_tables.psize]
    movzx     %r11,	byte ptr[%r11 + %r10]
    cmp       %rax,	%r11
    jz        L1665
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.psize]
    movzx     %r10,	byte ptr[%r10 + %rax]
    mov       %rcx,	%rdi
    mov       %rdx,	%r10
    call      mc_libmcl.changeopndsize
    movzx     %r10,	%bl
    lea       %r11,	[%rip+mc_decls.ploadop]
    movzx     %r11,	byte ptr[%r11 + %r10]
    mov       %rcx,	%r11
    mov       %rdx,	%rax
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
L1665:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_typepun
mc_genmcl.px_typepun:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
#PROC3
#PROC4
    movsxd    %rax,	dword ptr[%rsi+28]
    and       %rax,	255
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rax
    call      mc_stackmcl.getworkregm
    mov       %rdi,	%rax
    movzx     %rax,	word ptr[%rdi+8]
    and       %rax,	31
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      mc_libmcl.changeopndsize
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    movzx     %r10,	byte ptr[%rdi+10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_stackmcl.setnewzz
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_unload
mc_genmcl.px_unload:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_unload.p, 16
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_genmcl.px_loadbit
mc_genmcl.px_loadbit:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_loadbit.p, 48
    .set mc_genmcl.px_loadbit.$T1, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    mov       %rcx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.isimmload
    mov       %rbx,	%rax
    test      %rax,	%rax
    jz        L1670
    mov       %rsi,	[%rbx+8]
    mov       %rax,	%rsi
    cmp       %rax,	0
    jl        L1672
    cmp       %rax,	31
    jg        L1672
    mov       %rax,	5
    jmp       L1671
L1672:
    mov       %rax,	6
L1671:
    mov       %r12,	%rax
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	%r12
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    test      %rsi,	%rsi
    jz        L1674
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    call      mc_libmcl.mgenint
    mov       %rcx,	45
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    cmp       %rsi,	63
    jz        L1677
L1676:
L1674:
    jmp       L1669
L1670:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    mov       %al,	[%rip+pc_decls.r10used]
    test      %al,	%al
    jz        L1679
    mov       %rcx,	11
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	12
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L1679:
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	3
    mov       %r8,	11
    call      mc_stackmcl.loadparam
    mov       %rcx,	45
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %al,	[%rip+pc_decls.r10used]
    test      %al,	%al
    jz        L1681
    mov       %rcx,	11
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	13
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L1681:
L1669:
    mov       %rcx,	1
    mov       %rdx,	5
    call      mc_libmcl.mgenint
    mov       [%rbp + mc_genmcl.px_loadbit.$T1],	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	4
    call      mc_libmcl.changeopndsize
    mov       %rcx,	38
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_genmcl.px_loadbit.$T1]
    call      mc_libmcl.genmc
#mc_genmcl.px_loadbit.skip:
L1677:
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_assem
mc_genmcl.px_assem:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+pc_api.idomcl_assem]
    test      %rax,	%rax
    jz        L1684
    mov       %rax,	[%rdi+8]
    mov       %rcx,	%rax
    mov       %r10,	[%rip+pc_api.idomcl_assem]
    call      %r10
    jmp       L1683
L1684:
    lea       %rcx,	[%rip+L8532]
    lea       %rdx,	[%rip+L8533]
    call      pc_api.merror
L1683:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_sin
mc_genmcl.px_sin:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8534]
    mov       %r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_cos
mc_genmcl.px_cos:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8535]
    mov       %r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_tan
mc_genmcl.px_tan:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8536]
    mov       %r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_asin
mc_genmcl.px_asin:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8537]
    mov       %r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_acos
mc_genmcl.px_acos:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8538]
    mov       %r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_atan
mc_genmcl.px_atan:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8539]
    mov       %r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_log
mc_genmcl.px_log:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8540]
    mov       %r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_log10
mc_genmcl.px_log10:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8541]
    mov       %r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_exp
mc_genmcl.px_exp:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8542]
    mov       %r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_round
mc_genmcl.px_round:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8543]
    mov       %r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_floor
mc_genmcl.px_floor:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8544]
    mov       %r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_ceil
mc_genmcl.px_ceil:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8545]
    mov       %r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_atan2
mc_genmcl.px_atan2:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8546]
    mov       %r8,	2
    call      mc_auxmcl.do_maths
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_fmod
mc_genmcl.px_fmod:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8547]
    mov       %r8,	2
    call      mc_auxmcl.do_maths
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_setcc
mc_genmcl.px_setcc:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rsi,	%rax
    movzx     %rax,	byte ptr[%r13+2]
    lea       %r10,	[%rip+mc_genmcl.ucondcodes]
    movzx     %r10,	byte ptr[%r10 + %rax-1]
    mov       %rdi,	%r10
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	11
    jnz       L1701
    lea       %rcx,	[%rip+L8548]
    lea       %rdx,	[%rip+L8549]
    call      pc_api.merror
    jmp       L1700
L1701:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jle       L1702
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.psigned]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1704
    movzx     %rax,	byte ptr[%r13+2]
    lea       %r10,	[%rip+mc_genmcl.scondcodes]
    movzx     %r10,	byte ptr[%r10 + %rax-1]
    mov       %rdi,	%r10
L1704:
    mov       %rcx,	42
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      mc_libmcl.changeopndsize
    mov       %r12,	%rax
    jmp       L1700
L1702:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    dec       %rax
    mov       %r10,	73
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
    mov       %rcx,	3
    call      mc_stackmcl.getworkregm
    mov       %r12,	%rax
    movzx     %rax,	byte ptr[%r12+10]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_stackmcl.setnewzz
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
L1700:
    mov       %rcx,	58
    mov       %rdx,	%rdi
    mov       %r8,	%r12
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    mov       %rcx,	%r12
    mov       %rdx,	4
    call      mc_libmcl.changeopndsize
    mov       %rcx,	19
    mov       %rdx,	%rax
    mov       %r8,	%r12
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_min
mc_genmcl.px_min:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_min.p, 16
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jle       L1707
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.psigned]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1709
    mov       %rax,	15
    jmp       L1708
L1709:
    mov       %rax,	7
L1708:
    mov       %rcx,	%rax
    call      mc_auxmcl.do_max_int
    jmp       L1706
L1707:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    dec       %rax
    mov       %r10,	112
    add       %r10,	%rax
    mov       %rcx,	%r10
    call      mc_auxmcl.do_max_float
L1706:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_genmcl.px_max
mc_genmcl.px_max:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_max.p, 16
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jle       L1712
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.psigned]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1714
    mov       %rax,	12
    jmp       L1713
L1714:
    mov       %rax,	2
L1713:
    mov       %rcx,	%rax
    call      mc_auxmcl.do_max_int
    jmp       L1711
L1712:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    dec       %rax
    mov       %r10,	113
    add       %r10,	%rax
    mov       %rcx,	%r10
    call      mc_auxmcl.do_max_float
L1711:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_genmcl.px_power
mc_genmcl.px_power:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jle       L1717
    mov       %rcx,	82
    call      mc_auxmcl.gethostfn
    mov       %rdi,	%rax
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    mov       %rcx,	%rbx
    mov       %rdx,	%rdi
    mov       %r8,	2
    call      mc_auxmcl.do_host
    jmp       L1716
L1717:
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    mov       %rcx,	%rbx
    lea       %rdx,	[%rip+L8550]
    mov       %r8,	2
    call      mc_auxmcl.do_maths
L1716:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_minto
mc_genmcl.px_minto:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_minto.p, 16
    .set mc_genmcl.px_minto.$T1, -8
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jle       L1720
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       [%rbp + mc_genmcl.px_minto.$T1],	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.psigned]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1722
    mov       %rax,	14
    jmp       L1721
L1722:
    mov       %rax,	6
L1721:
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_genmcl.px_minto.$T1]
    call      mc_auxmcl.do_maxto_int
    jmp       L1719
L1720:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	6
    mov       %rdx,	%rax
    call      mc_auxmcl.do_maxto_real
L1719:
#---------------
    add       %rsp,	48
    pop       %rbp
    ret       
# End 
# Proc mc_genmcl.px_maxto
mc_genmcl.px_maxto:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_maxto.p, 16
    .set mc_genmcl.px_maxto.$T1, -8
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jle       L1725
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       [%rbp + mc_genmcl.px_maxto.$T1],	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.psigned]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1727
    mov       %rax,	13
    jmp       L1726
L1727:
    mov       %rax,	3
L1726:
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_genmcl.px_maxto.$T1]
    call      mc_auxmcl.do_maxto_int
    jmp       L1724
L1725:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	3
    mov       %rdx,	%rax
    call      mc_auxmcl.do_maxto_real
L1724:
#---------------
    add       %rsp,	48
    pop       %rbp
    ret       
# End 
# Proc mc_genmcl.px_negto
mc_genmcl.px_negto:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_negto.p, 32
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jle       L1730
    mov       %rcx,	50
    mov       %rdx,	%rdi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L1729
L1730:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rax
    call      mc_stackmcl.getworkregm
    mov       %rbx,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      mc_auxmcl.do_negreal
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L1729:
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_absto
mc_genmcl.px_absto:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_absto.p, 40
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rax
    call      mc_stackmcl.getworkregm
    mov       %rbx,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jle       L1733
    xor       %ecx,	%ecx
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	42
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rax,	[%rip+pc_api.mlabelno]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %r10,	%rax
    mov       %rsi,	%r10
    mov       %rcx,	26
    mov       %rdx,	13
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    mov       %rcx,	50
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	9
    mov       %rdx,	%rsi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L1732
L1733:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      mc_auxmcl.do_absreal
L1732:
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_addpxto
mc_genmcl.px_addpxto:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    call      mc_stackmcl.isimmload
    mov       %rsi,	%rax
    test      %rax,	%rax
    jz        L1736
    mov       %rax,	[%rsi+8]
    movsxd    %r10,	dword ptr[%r12+16]
    imul      %rax,	%r10
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	28
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L1735
L1736:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%r12+16]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      mc_auxmcl.mulimm
    mov       %rcx,	28
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L1735:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_subpxto
mc_genmcl.px_subpxto:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    call      mc_stackmcl.isimmload
    mov       %rsi,	%rax
    test      %rax,	%rax
    jz        L1739
    mov       %rax,	[%rsi+8]
    movsxd    %r10,	dword ptr[%r12+16]
    imul      %rax,	%r10
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	29
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L1738
L1739:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%r12+16]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      mc_auxmcl.mulimm
    mov       %rcx,	29
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    mov       %eax,	[%r12+20]
    test      %eax,	%eax
    jz        L1741
    lea       %rcx,	[%rip+L8551]
    lea       %rdx,	[%rip+L8552]
    call      pc_api.merror
L1741:
L1738:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_divto
mc_genmcl.px_divto:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    mov       %rdx,	71
    call      mc_auxmcl.do_binto_float
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_bitnotto
mc_genmcl.px_bitnotto:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_bitnotto.p, 24
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    mov       %rcx,	51
    mov       %rdx,	%rdi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_notto
mc_genmcl.px_notto:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_notto.p, 24
    .set mc_genmcl.px_notto.$T1, -8
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	3
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    mov       %rcx,	1
    mov       %rdx,	3
    call      mc_libmcl.mgenint
    mov       [%rbp + mc_genmcl.px_notto.$T1],	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      mc_libmcl.changeopndsize
    mov       %rcx,	40
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_genmcl.px_notto.$T1]
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_toboolto
mc_genmcl.px_toboolto:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_toboolto.p, 40
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	3
    call      mc_stackmcl.getopnd_ind
    mov       %rsi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rax
    call      mc_stackmcl.getworkregm
    mov       %rdi,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
    mov       %rcx,	41
    mov       %rdx,	%rdi
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      mc_libmcl.changeopndsize
    mov       %r10,	%rax
    mov       %rbx,	%r10
    mov       %rcx,	58
    mov       %rdx,	5
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    mov       %rcx,	%rdi
    mov       %rdx,	4
    call      mc_libmcl.changeopndsize
    mov       %rcx,	19
    mov       %rdx,	%rax
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    mov       %rcx,	11
    mov       %rdx,	%rsi
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_sign
mc_genmcl.px_sign:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_sign.p, 64
    .set mc_genmcl.px_sign.ltop, -8
    .set mc_genmcl.px_sign.$T1, -16
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    mov       %rcx,	10
    call      mc_stackmcl.getworkregm
    mov       %rbx,	%rax
    mov       %rcx,	%rbx
    call      mc_libmcl.clearreg
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jg        L1748
    mov       %r14b,	7
    mov       %al,	2
    mov       [%rbp + mc_genmcl.px_sign.ltop],	%al
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    movq      %XMM0,	[%rip+L8553]
    mov       %rdx,	%rax
    call      mc_libmcl.mgenrealmem
    movzx     %r10,	byte ptr[%rip+mc_decls.pmode]
    dec       %r10
    mov       %r11,	73
    add       %r11,	%r10
    mov       %rcx,	%r11
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L1747
L1748:
    mov       %r14b,	15
    mov       %al,	12
    mov       [%rbp + mc_genmcl.px_sign.ltop],	%al
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    xor       %ecx,	%ecx
    mov       %rdx,	%rax
    call      mc_libmcl.mgenint
    mov       %rcx,	42
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L1747:
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rax,	[%rip+pc_api.mlabelno]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %r10,	%rax
    mov       %rsi,	%r10
    movzx     %r10,	%r14b
    mov       %rcx,	26
    mov       %rdx,	%r10
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rax,	[%rip+pc_api.mlabelno]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %r10,	%rax
    mov       %r12,	%r10
    movzx     %r10,	byte ptr[%rbp + mc_genmcl.px_sign.ltop]
    mov       %rcx,	26
    mov       %rdx,	%r10
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rax,	[%rip+pc_api.mlabelno]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %r10,	%rax
    mov       %r13,	%r10
    mov       %rcx,	25
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	9
    mov       %rdx,	%rsi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	1
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       [%rbp + mc_genmcl.px_sign.$T1],	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      mc_libmcl.changeopndsize
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_genmcl.px_sign.$T1]
    call      mc_libmcl.genmc
    mov       %rcx,	25
    mov       %rdx,	%r13
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	9
    mov       %rdx,	%r12
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	53
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	9
    mov       %rdx,	%r13
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rbx+10]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_stackmcl.setnewzz
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_loadbf
mc_genmcl.px_loadbf:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    call      mc_stackmcl.isimmload
    mov       %rdi,	%rax
    mov       %rcx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.isimmload
    mov       %rbx,	%rax
    test      %rdi,	%rdi
    jz        L1751
    test      %rbx,	%rbx
    jz        L1751
    mov       %rax,	[%rbx+8]
    mov       %r10,	[%rdi+8]
    mov       %rcx,	%rsi
    mov       %rdx,	%r10
    mov       %r8,	%rax
    call      mc_auxmcl.do_loadbf_const
    jmp       L1750
L1751:
    mov       %rcx,	%rsi
    call      mc_auxmcl.do_loadbf_var
L1750:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_storebit
mc_genmcl.px_storebit:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    call      mc_auxmcl.do_storebit
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_storebf
mc_genmcl.px_storebf:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    call      mc_auxmcl.do_storebf
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_loadall
mc_genmcl.px_loadall:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_loadall.p, 16
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    call      mc_stackmcl.checkallloaded
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_genmcl.px_setjmp
mc_genmcl.px_setjmp:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
#PROC3
#PROC4
    call      mc_libmcl.mcreatefwdlabel
    mov       %rsi,	%rax
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	6
    call      mc_stackmcl.getopnd_ind
    mov       %rbx,	%rax
    mov       %rcx,	6
    xor       %edx,	%edx
    call      mc_stackmcl.pushpcl_reg
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rdi,	%rax
    mov       %rcx,	%rsi
    call      mc_libmcl.mgenlabel
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rcx,	%rbx
    mov       %rdx,	8
    xor       %r8d,	%r8d
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	[%rip+mc_decls.dstackopnd]
    call      mc_libmcl.genmc
    mov       %rcx,	%rbx
    mov       %rdx,	16
    xor       %r8d,	%r8d
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	[%rip+mc_decls.dframeopnd]
    call      mc_libmcl.genmc
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    call      mc_stackmcl.poppcl
    mov       %rcx,	%rdi
    call      mc_libmcl.clearreg
    mov       %rcx,	%r12
    call      mc_stackmcl.freeworkregs
    mov       %rcx,	1
    call      mc_stackmcl.movetoreg
    mov       %rcx,	%rsi
    call      mc_libmcl.mdefinefwdlabel
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_longjmp
mc_genmcl.px_longjmp:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_longjmp.p, 40
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	6
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	8
    xor       %r8d,	%r8d
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	[%rip+mc_decls.dstackopnd]
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	%rdi
    mov       %rdx,	16
    xor       %r8d,	%r8d
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	[%rip+mc_decls.dframeopnd]
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	6
    xor       %edx,	%edx
    call      mc_stackmcl.pushpcl_reg
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rsi,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rsi
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rax,	[%rip+mc_decls.noperands]
    sub       %rax,	2
    mov       %rcx,	%rax
    mov       %rdx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    call      mc_stackmcl.poppcl
    mov       %rcx,	1
    call      mc_stackmcl.swapopndregs
    mov       %rcx,	25
    mov       %rdx,	%rsi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_genmcl.px_initdswx
mc_genmcl.px_initdswx:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_initdswx.p, 16
#?]]
#---------------
#PROC3
#PROC4
#---------------
    ret       
# End 
# Proc mc_auxmcl.allocregvars
mc_auxmcl.allocregvars:
#PROC1
#PROC2
#?>>
    .set mc_auxmcl.allocregvars.params, -32
    .set mc_auxmcl.allocregvars.xparams, -64
    .set mc_auxmcl.allocregvars.leafparams, -96
    .set mc_auxmcl.allocregvars.xleafparams, -128
    .set mc_auxmcl.allocregvars.leafparamno, -136
    .set mc_auxmcl.allocregvars.xleafparamno, -144
    .set mc_auxmcl.allocregvars.locals, -400
    .set mc_auxmcl.allocregvars.xlocals, -656
    .set mc_auxmcl.allocregvars.reg, -664
    .set mc_auxmcl.allocregvars.nl, -672
    .set mc_auxmcl.allocregvars.np, -680
    .set mc_auxmcl.allocregvars.nlx, -688
    .set mc_auxmcl.allocregvars.npx, -696
    .set mc_auxmcl.allocregvars.d, -704
    .set mc_auxmcl.allocregvars.i, -712
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	712
#---------------
#PROC3
#PROC4
    xor       %rdi,	%rdi
    xor       %eax,	%eax
    mov       %rbx,	%rax
    xor       %rsi,	%rsi
    xor       %eax,	%eax
    mov       %r12,	%rax
    xor       %r13,	%r13
    xor       %eax,	%eax
    mov       %r14,	%rax
    mov       %rax,	[%rip+mc_decls.maxregvars]
    add       %rax,	[%rip+mc_decls.maxxregvars]
    test      %rax,	%rax
    jz        L1758
L1760:
    test      %rcx,	%rcx
    jnz       L1762
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %rax,	[%rax+16]
    mov       [%rbp + mc_auxmcl.allocregvars.d],	%rax
    xor       %r15,	%r15
    jmp       L1766
L1763:
    inc       %r15
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       %al,	[%rax+92]
    test      %al,	%al
    jz        L1768
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       %al,	[%rax+91]
    test      %al,	%al
    jnz       L1768
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       %al,	[%rax+88]
    test      %al,	%al
    jnz       L1768
    cmp       %r15,	4
    jg        L1768
    test      %rdx,	%rdx
    jnz       L1770
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    movzx     %rax,	byte ptr[%rax+82]
    lea       %r10,	[%rip+pc_tables.pint]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1772
    cmp       %rdi,	4
    jge       L1774
    inc       %rdi
    mov       %rax,	%rdi
    mov       %r10,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       [%rbp + %rax*8 + mc_auxmcl.allocregvars.params-8],	%r10
L1774:
    jmp       L1771
L1772:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    movzx     %rax,	byte ptr[%rax+82]
    lea       %r10,	[%rip+pc_tables.pfloat]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1775
    cmp       %rbx,	4
    jge       L1777
    inc       %rbx
    mov       %rax,	%rbx
    mov       %r10,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       [%rbp + %rax*8 + mc_auxmcl.allocregvars.xparams-8],	%r10
L1777:
L1775:
L1771:
    jmp       L1769
L1770:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    movzx     %rax,	byte ptr[%rax+82]
    lea       %r10,	[%rip+pc_tables.pint]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1779
    cmp       %rsi,	4
    jge       L1781
    inc       %rsi
    mov       %rax,	%rsi
    mov       %r10,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       [%rbp + %rax*8 + mc_auxmcl.allocregvars.leafparams-8],	%r10
    mov       [%rbp + %rsi + mc_auxmcl.allocregvars.leafparamno-1],	%r15b
L1781:
    jmp       L1778
L1779:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    movzx     %rax,	byte ptr[%rax+82]
    lea       %r10,	[%rip+pc_tables.pfloat]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1782
    cmp       %r12,	4
    jge       L1784
    inc       %r12
    mov       %rax,	%r12
    mov       %r10,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       [%rbp + %rax*8 + mc_auxmcl.allocregvars.xleafparams-8],	%r10
    mov       [%rbp + %r12 + mc_auxmcl.allocregvars.xleafparamno-1],	%r15b
L1784:
L1782:
L1778:
L1769:
L1768:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       %rax,	[%rax+16]
    mov       [%rbp + mc_auxmcl.allocregvars.d],	%rax
L1766:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    test      %rax,	%rax
    jnz       L1763
L1762:
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %rax,	[%rax+24]
    mov       [%rbp + mc_auxmcl.allocregvars.d],	%rax
    jmp       L1788
L1785:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       %al,	[%rax+92]
    test      %al,	%al
    jz        L1790
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       %al,	[%rax+91]
    test      %al,	%al
    jnz       L1790
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       %al,	[%rax+88]
    test      %al,	%al
    jnz       L1790
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    movzx     %rax,	byte ptr[%rax+82]
    lea       %r10,	[%rip+pc_tables.pint]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1792
    cmp       %r13,	32
    jge       L1794
    inc       %r13
    mov       %rax,	%r13
    mov       %r10,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       [%rbp + %rax*8 + mc_auxmcl.allocregvars.locals-8],	%r10
L1794:
    jmp       L1791
L1792:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    movzx     %rax,	byte ptr[%rax+82]
    lea       %r10,	[%rip+pc_tables.pfloat]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L1795
    cmp       %r14,	32
    jge       L1795
    inc       %r14
    mov       %rax,	%r14
    mov       %r10,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       [%rbp + %rax*8 + mc_auxmcl.allocregvars.xlocals-8],	%r10
L1795:
L1791:
L1790:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       %rax,	[%rax+24]
    mov       [%rbp + mc_auxmcl.allocregvars.d],	%rax
L1788:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.d]
    test      %rax,	%rax
    jnz       L1785
    test      %r13,	%r13
    jnz       L1797
    mov       %rax,	[%rip+mc_decls.maxregvars]
    mov       %r10,	%rdi
    cmp       %rax,	%r10
    cmovg     %rax,	%r10
    mov       [%rbp + mc_auxmcl.allocregvars.np],	%rax
    xor       %eax,	%eax
    mov       [%rbp + mc_auxmcl.allocregvars.nl],	%rax
    jmp       L1796
L1797:
    test      %rdi,	%rdi
    jnz       L1798
    mov       %rax,	[%rip+mc_decls.maxregvars]
    mov       %r10,	%r13
    cmp       %rax,	%r10
    cmovg     %rax,	%r10
    mov       [%rbp + mc_auxmcl.allocregvars.nl],	%rax
    xor       %eax,	%eax
    mov       [%rbp + mc_auxmcl.allocregvars.np],	%rax
    jmp       L1796
L1798:
    mov       [%rbp + mc_auxmcl.allocregvars.nl],	%r13
    mov       [%rbp + mc_auxmcl.allocregvars.np],	%rdi
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.np]
    add       %rax,	[%rbp + mc_auxmcl.allocregvars.nl]
    sub       %rax,	[%rip+mc_decls.maxregvars]
    mov       %r15,	%rax
    cmp       %r15,	0
    jle       L1800
    dec       qword ptr[%rbp + mc_auxmcl.allocregvars.np]
    dec       %r15
    cmp       %r15,	0
    jle       L1802
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.np]
    cmp       %rax,	0
    jle       L1802
    dec       qword ptr[%rbp + mc_auxmcl.allocregvars.np]
    dec       %r15
L1802:
    cmp       %r15,	0
    jle       L1804
    mov       %rax,	%r15
    sub       [%rbp + mc_auxmcl.allocregvars.nl],	%rax
L1804:
L1800:
L1796:
    mov       %rax,	4
    mov       [%rbp + mc_auxmcl.allocregvars.reg],	%rax
    mov       %rax,	1
    mov       [%rbp + mc_auxmcl.allocregvars.i],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.nl]
    cmp       %rax,	1
    jl        L1807
L1805:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.i]
    mov       %rax,	[%rbp + %rax*8 + mc_auxmcl.allocregvars.locals-8]
    mov       [%rbp + mc_auxmcl.allocregvars.d],	%rax
    mov       %al,	[%rbp + mc_auxmcl.allocregvars.reg]
    mov       %r10,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       [%r10+90],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.isregvar]
    mov       %r11,	[%rbp + mc_auxmcl.allocregvars.reg]
    mov       [%r10 + %r11-1],	%al
    inc       qword ptr[%rbp + mc_auxmcl.allocregvars.reg]
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.i]
    inc       %rax
    mov       [%rbp + mc_auxmcl.allocregvars.i],	%rax
    cmp       %rax,	[%rbp + mc_auxmcl.allocregvars.nl]
    jle       L1805
L1807:
    mov       %rax,	1
    mov       [%rbp + mc_auxmcl.allocregvars.i],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.np]
    cmp       %rax,	1
    jl        L1810
L1808:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.i]
    mov       %rax,	[%rbp + %rax*8 + mc_auxmcl.allocregvars.params-8]
    mov       [%rbp + mc_auxmcl.allocregvars.d],	%rax
    mov       %al,	[%rbp + mc_auxmcl.allocregvars.reg]
    mov       %r10,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       [%r10+90],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.isregvar]
    mov       %r11,	[%rbp + mc_auxmcl.allocregvars.reg]
    mov       [%r10 + %r11-1],	%al
    inc       qword ptr[%rbp + mc_auxmcl.allocregvars.reg]
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.i]
    inc       %rax
    mov       [%rbp + mc_auxmcl.allocregvars.i],	%rax
    cmp       %rax,	[%rbp + mc_auxmcl.allocregvars.np]
    jle       L1808
L1810:
    mov       %rax,	1
    mov       [%rbp + mc_auxmcl.allocregvars.i],	%rax
    cmp       %rsi,	1
    jl        L1813
L1811:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.i]
    mov       %rax,	[%rbp + %rax*8 + mc_auxmcl.allocregvars.leafparams-8]
    mov       [%rbp + mc_auxmcl.allocregvars.d],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.i]
    movzx     %rax,	byte ptr[%rbp + %rax + mc_auxmcl.allocregvars.leafparamno-1]
    add       %rax,	11
    dec       %rax
    mov       [%rbp + mc_auxmcl.allocregvars.reg],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.reg]
    cmp       %rax,	11
    jnz       L1815
    mov       %al,	1
    mov       [%rip+pc_decls.r10used],	%al
L1815:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.reg]
    cmp       %rax,	12
    jnz       L1817
    mov       %al,	1
    mov       [%rip+pc_decls.r11used],	%al
L1817:
    mov       %al,	[%rbp + mc_auxmcl.allocregvars.reg]
    mov       %r10,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       [%r10+90],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.isregvar]
    mov       %r11,	[%rbp + mc_auxmcl.allocregvars.reg]
    mov       [%r10 + %r11-1],	%al
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.i]
    inc       %rax
    mov       [%rbp + mc_auxmcl.allocregvars.i],	%rax
    cmp       %rax,	%rsi
    jle       L1811
L1813:
    test      %r14,	%r14
    jnz       L1819
    mov       %rax,	[%rip+mc_decls.maxxregvars]
    mov       %r10,	%rbx
    cmp       %rax,	%r10
    cmovg     %rax,	%r10
    mov       [%rbp + mc_auxmcl.allocregvars.npx],	%rax
    xor       %eax,	%eax
    mov       [%rbp + mc_auxmcl.allocregvars.nlx],	%rax
    jmp       L1818
L1819:
    test      %rbx,	%rbx
    jnz       L1820
    mov       %rax,	[%rip+mc_decls.maxxregvars]
    mov       %r10,	%r14
    cmp       %rax,	%r10
    cmovg     %rax,	%r10
    mov       [%rbp + mc_auxmcl.allocregvars.nlx],	%rax
    xor       %eax,	%eax
    mov       [%rbp + mc_auxmcl.allocregvars.npx],	%rax
    jmp       L1818
L1820:
    mov       [%rbp + mc_auxmcl.allocregvars.nlx],	%r14
    mov       [%rbp + mc_auxmcl.allocregvars.npx],	%rbx
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.npx]
    add       %rax,	[%rbp + mc_auxmcl.allocregvars.nlx]
    sub       %rax,	[%rip+mc_decls.maxregvars]
    mov       %r15,	%rax
    cmp       %r15,	0
    jle       L1822
    dec       qword ptr[%rbp + mc_auxmcl.allocregvars.npx]
    dec       %r15
    cmp       %r15,	0
    jle       L1824
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.npx]
    cmp       %rax,	0
    jle       L1824
    dec       qword ptr[%rbp + mc_auxmcl.allocregvars.npx]
    dec       %r15
L1824:
    cmp       %r15,	0
    jle       L1826
    mov       %rax,	%r15
    sub       [%rbp + mc_auxmcl.allocregvars.nlx],	%rax
L1826:
L1822:
L1818:
    mov       %rax,	16
    mov       [%rbp + mc_auxmcl.allocregvars.reg],	%rax
    mov       %rax,	1
    mov       [%rbp + mc_auxmcl.allocregvars.i],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.nlx]
    cmp       %rax,	1
    jl        L1829
L1827:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.i]
    mov       %rax,	[%rbp + %rax*8 + mc_auxmcl.allocregvars.xlocals-8]
    mov       [%rbp + mc_auxmcl.allocregvars.d],	%rax
    mov       %al,	[%rbp + mc_auxmcl.allocregvars.reg]
    mov       %r10,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       [%r10+90],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.isxregvar]
    mov       %r11,	[%rbp + mc_auxmcl.allocregvars.reg]
    mov       [%r10 + %r11-1],	%al
    dec       qword ptr[%rbp + mc_auxmcl.allocregvars.reg]
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.i]
    inc       %rax
    mov       [%rbp + mc_auxmcl.allocregvars.i],	%rax
    cmp       %rax,	[%rbp + mc_auxmcl.allocregvars.nlx]
    jle       L1827
L1829:
    mov       %rax,	1
    mov       [%rbp + mc_auxmcl.allocregvars.i],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.npx]
    cmp       %rax,	1
    jl        L1832
L1830:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.i]
    mov       %rax,	[%rbp + %rax*8 + mc_auxmcl.allocregvars.xparams-8]
    mov       [%rbp + mc_auxmcl.allocregvars.d],	%rax
    mov       %al,	[%rbp + mc_auxmcl.allocregvars.reg]
    mov       %r10,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       [%r10+90],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.isxregvar]
    mov       %r11,	[%rbp + mc_auxmcl.allocregvars.reg]
    mov       [%r10 + %r11-1],	%al
    dec       qword ptr[%rbp + mc_auxmcl.allocregvars.reg]
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.i]
    inc       %rax
    mov       [%rbp + mc_auxmcl.allocregvars.i],	%rax
    cmp       %rax,	[%rbp + mc_auxmcl.allocregvars.npx]
    jle       L1830
L1832:
    mov       %rax,	1
    mov       [%rbp + mc_auxmcl.allocregvars.i],	%rax
    cmp       %r12,	1
    jl        L1835
L1833:
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.i]
    mov       %rax,	[%rbp + %rax*8 + mc_auxmcl.allocregvars.xleafparams-8]
    mov       [%rbp + mc_auxmcl.allocregvars.d],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.i]
    movzx     %rax,	byte ptr[%rbp + %rax + mc_auxmcl.allocregvars.xleafparamno-1]
    inc       %rax
    dec       %rax
    mov       [%rbp + mc_auxmcl.allocregvars.reg],	%rax
    mov       %al,	[%rbp + mc_auxmcl.allocregvars.reg]
    mov       %r10,	[%rbp + mc_auxmcl.allocregvars.d]
    mov       [%r10+90],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.isxregvar]
    mov       %r11,	[%rbp + mc_auxmcl.allocregvars.reg]
    mov       [%r10 + %r11-1],	%al
    mov       %rax,	[%rbp + mc_auxmcl.allocregvars.i]
    inc       %rax
    mov       [%rbp + mc_auxmcl.allocregvars.i],	%rax
    cmp       %rax,	%r12
    jle       L1833
L1835:
L1758:
#---------------
    add       %rsp,	712
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.initproc
mc_auxmcl.initproc:
#PROC1
#PROC2
#?>>
    .set mc_auxmcl.initproc.$T1, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %r15,	%rcx
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rip+mc_decls.regset]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    lea       %rax,	[%rip+mc_decls.xregset]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    lea       %rax,	[%rip+mc_decls.workregs]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    lea       %rax,	[%rip+mc_decls.workxregs]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    lea       %rax,	[%rip+mc_decls.isregvar]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    lea       %rax,	[%rip+mc_decls.isxregvar]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    mov       %rax,	3
    mov       [%rip+mc_decls.nworkregs],	%rax
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.workregs]
    mov       [%r10],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.workregs]
    mov       [%r10+1],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.workregs]
    mov       [%r10+2],	%al
    mov       %rax,	2
    mov       [%rip+mc_decls.nworkxregs],	%rax
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.workxregs]
    mov       [%r10+4],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.workxregs]
    mov       [%r10+5],	%al
    xor       %eax,	%eax
    mov       [%rip+mc_decls.maxxregvars],	%rax
    mov       [%rip+mc_decls.maxregvars],	%rax
    xor       %r12,	%r12
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %rax,	[%rax+48]
    mov       [%rip+pc_decls.pinfo],	%rax
    mov       %rax,	[%rip+pc_decls.pinfo]
    test      %rax,	%rax
    jnz       L1838
    mov       %rax,	10
    mov       [%rip+mc_decls.nworkregs],	%rax
    mov       %rax,	12
    mov       [%rip+mc_decls.nworkxregs],	%rax
    mov       %rsi,	4
L1839:
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.workregs]
    mov       %r11,	%rsi
    mov       [%r10 + %r11-1],	%al
    inc       %rsi
    cmp       %rsi,	10
    jle       L1839
    mov       %rsi,	7
L1842:
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.workxregs]
    mov       %r11,	%rsi
    mov       [%r10 + %r11-1],	%al
    inc       %rsi
    cmp       %rsi,	16
    jle       L1842
    jmp       L1837
L1838:
    mov       %rax,	[%rip+pc_decls.currfunc]
    movzx     %rax,	byte ptr[%rax+112]
    mov       %r10,	[%rip+pc_decls.pinfo]
    movzx     %r10,	byte ptr[%r10+4]
    cmp       %rax,	%r10
    cmovl     %rax,	%r10
    mov       %r10,	4
    cmp       %r10,	%rax
    cmovg     %r10,	%rax
    mov       %r12,	%r10
    mov       %rax,	4
    mov       [%rip+mc_decls.nworkregs],	%rax
    mov       %rax,	[%rip+pc_decls.pinfo]
    mov       %al,	[%rax+7]
    test      %al,	%al
    jz        L1846
    inc       qword ptr[%rip+mc_decls.nworkregs]
L1846:
    mov       %rax,	5
    mov       [%rip+mc_decls.nworkxregs],	%rax
    mov       %rax,	[%rip+mc_decls.nworkregs]
    sub       %rax,	3
    mov       %rbx,	%rax
    cmp       %r12,	3
    jg        L1848
    test      %rbx,	%rbx
    jz        L1848
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.workregs]
    mov       [%r10+13],	%al
    dec       %rbx
    cmp       %r12,	2
    jg        L1850
    test      %rbx,	%rbx
    jz        L1850
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.workregs]
    mov       [%r10+12],	%al
    dec       %rbx
L1850:
L1848:
    mov       %rsi,	10
    mov       %r13,	%rbx
    cmp       %r13,	0
    jle       L1853
L1851:
    mov       %rax,	%rsi
    dec       %rsi
    mov       %r10b,	1
    lea       %r11,	[%rip+mc_decls.workregs]
    mov       [%r11 + %rax-1],	%r10b
    dec       %r13
    jnz       L1851
L1853:
    mov       %rsi,	7
    mov       %rax,	[%rip+mc_decls.nworkxregs]
    sub       %rax,	2
    mov       %r14,	%rax
    cmp       %r14,	0
    jle       L1856
L1854:
    mov       %rax,	%rsi
    inc       %rsi
    mov       %r10b,	1
    lea       %r11,	[%rip+mc_decls.workxregs]
    mov       [%r11 + %rax-1],	%r10b
    dec       %r14
    jnz       L1854
L1856:
L1837:
    mov       %rsi,	4
L1857:
    lea       %rax,	[%rip+mc_decls.workregs]
    mov       %r10,	%rsi
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jnz       L1861
    inc       qword ptr[%rip+mc_decls.maxregvars]
L1861:
    inc       %rsi
    cmp       %rsi,	10
    jle       L1857
    mov       %rsi,	7
L1862:
    lea       %rax,	[%rip+mc_decls.workxregs]
    mov       %r10,	%rsi
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jnz       L1866
    inc       qword ptr[%rip+mc_decls.maxxregvars]
L1866:
    inc       %rsi
    cmp       %rsi,	16
    jle       L1862
    lea       %rax,	[%rip+mc_decls.usedregs]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    lea       %rax,	[%rip+mc_decls.usedxregs]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    lea       %rax,	[%rip+mc_decls.pcltempflags]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    mov       [%rax+16],	%r10
    mov       [%rax+24],	%r10
    mov       [%rax+32],	%r10
    mov       [%rax+40],	%r10
    mov       [%rax+48],	%r10w
    xor       %eax,	%eax
    mov       [%rip+pc_decls.r11used],	%al
    mov       [%rip+pc_decls.r10used],	%al
    xor       %eax,	%eax
    mov       [%rip+mc_decls.mstackdepth],	%rax
    xor       %eax,	%eax
    mov       [%rip+mc_decls.noperands],	%rax
    xor       %eax,	%eax
    mov       [%rip+mc_genmcl.framebytes],	%rax
    mov       [%rip+mc_genmcl.paramoffset],	%rax
    mov       [%rip+mc_genmcl.frameoffset],	%rax
    xor       %eax,	%eax
    mov       [%rip+pc_decls.localshadow],	%al
    xor       %eax,	%eax
    mov       [%rip+mc_decls.nblocktemps],	%rax
    movzx     %rax,	byte ptr[%r15+82]
    cmp       %rax,	11
    jnz       L1868
    lea       %rcx,	[%rip+L8554]
    mov       %rdx,	8
    call      pc_api.pc_makesymbol
    mov       %rdi,	%rax
    mov       %al,	[%r15+82]
    mov       [%rdi+82],	%al
    mov       %al,	1
    mov       [%rdi+92],	%al
    mov       %al,	5
    mov       [%rdi+72],	%al
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %rax,	[%rax+16]
    mov       [%rdi+16],	%rax
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       [%rdi+32],	%rax
    mov       %rax,	%rdi
    mov       %r10,	[%rip+pc_decls.currfunc]
    mov       [%r10+16],	%rax
    mov       [%rip+pc_decls.blockretname],	%rdi
L1868:
    mov       %al,	[%rip+pc_decls.fregoptim]
    test      %al,	%al
    jz        L1871
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %rax,	[%rax+48]
    test      %rax,	%rax
    jnz       L1870
L1871:
    jmp       L1836
L1870:
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %rax,	[%rax+48]
    mov       %al,	[%rax+5]
    test      %al,	%al
    jnz       L1836
L1873:
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %rax,	[%rax+48]
    movzx     %rax,	byte ptr[%rax+3]
    mov       [%rbp + mc_auxmcl.initproc.$T1],	%rax
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %al,	[%rax+110]
    test      %al,	%al
    jnz       L1874
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %al,	[%rax+113]
    test      %al,	%al
    jz        L1875
L1874:
    mov       %rax,	1
    jmp       L1876
L1875:
    xor       %eax,	%eax
L1876:
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_auxmcl.initproc.$T1]
    call      mc_auxmcl.allocregvars
L1836:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_procentry
mc_auxmcl.do_procentry:
#PROC1
#PROC2
#?>>
    .set mc_auxmcl.do_procentry.p, 72
    .set mc_auxmcl.do_procentry.ff, -8
    .set mc_auxmcl.do_procentry.r, -16
    .set mc_auxmcl.do_procentry.i, -24
    .set mc_auxmcl.do_procentry.$T1, -32
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	72
#---------------
#PROC3
#PROC4
    mov       %rcx,	[%rip+mc_decls.mclprocentry]
    call      mc_auxmcl.setmclentry
    xor       %eax,	%eax
    mov       [%rip+pc_decls.bxspill],	%rax
    mov       [%rip+pc_decls.bspill],	%rax
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %rax,	[%rax+48]
    test      %rax,	%rax
    jz        L1880
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %rax,	[%rax+48]
    mov       %al,	[%rax+5]
    test      %al,	%al
    jnz       L1879
L1880:
    mov       %rax,	4
    mov       [%rbp + mc_auxmcl.do_procentry.r],	%rax
L1881:
    lea       %rax,	[%rip+mc_decls.usedregs]
    mov       %r10,	[%rbp + mc_auxmcl.do_procentry.r]
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jnz       L1886
    lea       %rax,	[%rip+mc_decls.isregvar]
    mov       %r10,	[%rbp + mc_auxmcl.do_procentry.r]
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L1885
L1886:
    inc       qword ptr[%rip+pc_decls.bspill]
L1885:
    mov       %rax,	[%rbp + mc_auxmcl.do_procentry.r]
    inc       %rax
    mov       [%rbp + mc_auxmcl.do_procentry.r],	%rax
    cmp       %rax,	10
    jle       L1881
    mov       %rax,	7
    mov       [%rbp + mc_auxmcl.do_procentry.r],	%rax
L1887:
    lea       %rax,	[%rip+mc_decls.usedxregs]
    mov       %r10,	[%rbp + mc_auxmcl.do_procentry.r]
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jnz       L1892
    lea       %rax,	[%rip+mc_decls.isxregvar]
    mov       %r10,	[%rbp + mc_auxmcl.do_procentry.r]
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L1891
L1892:
    inc       qword ptr[%rip+pc_decls.bxspill]
L1891:
    mov       %rax,	[%rbp + mc_auxmcl.do_procentry.r]
    inc       %rax
    mov       [%rbp + mc_auxmcl.do_procentry.r],	%rax
    cmp       %rax,	16
    jle       L1887
L1879:
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %r14,	[%rax+16]
    jmp       L1896
L1893:
    mov       %al,	[%r14+91]
    test      %al,	%al
    jz        L1898
    lea       %rcx,	[%rip+L8555]
    lea       %rdx,	[%rip+L8556]
    call      pc_api.merror
L1898:
    mov       %al,	[%r14+90]
    test      %al,	%al
    jnz       L1900
    mov       %rax,	[%rip+mc_genmcl.paramoffset]
    add       %rax,	16
    mov       %r10,	[%rip+pc_decls.bspill]
    add       %r10,	[%rip+pc_decls.bxspill]
    shl       %r10,	3
    add       %rax,	%r10
    mov       [%r14+76],	%eax
    movsxd    %rax,	dword ptr[%r14+76]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       [%rbp + mc_auxmcl.do_procentry.$T1],	%rax
    mov       %rcx,	%r14
    call      mc_writegas.getdispname
    mov       %rcx,	%rax
    call      mc_libmcl.mgenname
    mov       %rcx,	5
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.do_procentry.$T1]
    call      mc_libmcl.genmc
    jmp       L1899
L1900:
    movzx     %rax,	byte ptr[%r14+90]
    mov       %r15,	%rax
    lea       %rax,	[%rip+mc_decls.usedregs]
    movzx     %rax,	byte ptr[%rax+14]
    mov       [%rbp + mc_auxmcl.do_procentry.ff],	%rax
    xor       %eax,	%eax
    mov       [%r14+90],	%al
    movzx     %rax,	byte ptr[%r14+82]
    mov       %rcx,	%r15
    mov       %rdx,	%rax
    call      mc_libmcl.mgenreg
    mov       [%rbp + mc_auxmcl.do_procentry.$T1],	%rax
    mov       %rcx,	%r14
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       %rcx,	6
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.do_procentry.$T1]
    call      mc_libmcl.genmc
    mov       [%r14+90],	%r15b
    mov       %al,	[%rbp + mc_auxmcl.do_procentry.ff]
    lea       %r10,	[%rip+mc_decls.usedregs]
    mov       [%r10+14],	%al
L1899:
    mov       %rax,	8
    add       [%rip+mc_genmcl.paramoffset],	%rax
    mov       %r14,	[%r14+16]
L1896:
    test      %r14,	%r14
    jnz       L1893
    mov       %rax,	[%rip+pc_decls.currfunc]
    movzx     %rax,	byte ptr[%rax+82]
    mov       %rdi,	%rax
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %r14,	[%rax+24]
    jmp       L1904
L1901:
    movzx     %rax,	byte ptr[%r14+82]
    lea       %r10,	[%rip+pc_tables.psize]
    movzx     %r10,	byte ptr[%r10 + %rax]
    mov       %r12,	%r10
    movzx     %rax,	byte ptr[%r14+82]
    cmp       %rax,	11
    jnz       L1906
    mov       %eax,	[%r14+84]
    mov       %r12,	%rax
L1906:
    mov       %al,	[%r14+92]
    test      %al,	%al
    jz        L1902
L1908:
    mov       %al,	[%r14+91]
    test      %al,	%al
    jz        L1910
    mov       %rsi,	1
    jmp       L1909
L1910:
    mov       %al,	[%r14+90]
    test      %al,	%al
    jz        L1911
    movzx     %rax,	byte ptr[%r14+90]
    mov       %r15,	%rax
    lea       %rax,	[%rip+mc_decls.usedregs]
    movzx     %rax,	byte ptr[%rax+14]
    mov       [%rbp + mc_auxmcl.do_procentry.ff],	%rax
    xor       %eax,	%eax
    mov       [%r14+90],	%al
    movzx     %rax,	byte ptr[%r14+82]
    mov       %rcx,	%r15
    mov       %rdx,	%rax
    call      mc_libmcl.mgenreg
    mov       [%rbp + mc_auxmcl.do_procentry.$T1],	%rax
    mov       %rcx,	%r14
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       %rcx,	6
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.do_procentry.$T1]
    call      mc_libmcl.genmc
    mov       [%r14+90],	%r15b
    mov       %al,	[%rbp + mc_auxmcl.do_procentry.ff]
    lea       %r10,	[%rip+mc_decls.usedregs]
    mov       [%r10+14],	%al
    jmp       L1909
L1911:
    mov       %rcx,	%r12
    call      mc_libmcl.roundsizetg
    sub       [%rip+mc_genmcl.frameoffset],	%rax
    mov       %eax,	[%rip+mc_genmcl.frameoffset]
    mov       [%r14+76],	%eax
    movsxd    %rax,	dword ptr[%r14+76]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       [%rbp + mc_auxmcl.do_procentry.$T1],	%rax
    mov       %rcx,	%r14
    call      mc_writegas.getdispname
    mov       %rcx,	%rax
    call      mc_libmcl.mgenname
    mov       %rcx,	5
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.do_procentry.$T1]
    call      mc_libmcl.genmc
L1909:
L1902:
    mov       %r14,	[%r14+24]
L1904:
    test      %r14,	%r14
    jnz       L1901
    xor       %rbx,	%rbx
    mov       %rax,	1
    mov       [%rbp + mc_auxmcl.do_procentry.i],	%rax
L1912:
    lea       %rax,	[%rip+mc_decls.pcltempflags]
    mov       %r10,	[%rbp + mc_auxmcl.do_procentry.i]
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L1916
    inc       %rbx
    mov       %rax,	8
    sub       [%rip+mc_genmcl.frameoffset],	%rax
    lea       %rax,	[%rip+mc_decls.pcltempopnds]
    mov       %r10,	[%rbp + mc_auxmcl.do_procentry.i]
    mov       %r13,	[%rax + %r10*8-8]
    mov       %eax,	[%rip+mc_genmcl.frameoffset]
    mov       [%r13+12],	%eax
    movsxd    %rax,	dword ptr[%r13+12]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       [%rbp + mc_auxmcl.do_procentry.$T1],	%rax
    mov       %rcx,	[%rip+pc_decls.currfunc]
    mov       %rdx,	[%rbp + mc_auxmcl.do_procentry.i]
    call      mc_writegas.gettempname
    mov       %rcx,	%rax
    call      mc_libmcl.mgenname
    mov       %rcx,	5
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.do_procentry.$T1]
    call      mc_libmcl.genmc
L1916:
    mov       %rax,	[%rbp + mc_auxmcl.do_procentry.i]
    inc       %rax
    mov       [%rbp + mc_auxmcl.do_procentry.i],	%rax
    cmp       %rax,	50
    jle       L1912
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %al,	[%rax+108]
    test      %al,	%al
    jz        L1918
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %ax,	[%rax+114]
    test      %ax,	%ax
    jnz       L1921
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %al,	[%rax+112]
    test      %al,	%al
    jz        L1920
L1921:
    lea       %rcx,	[%rip+L8557]
    lea       %rdx,	[%rip+L8558]
    call      pc_api.merror
L1920:
    test      %rbx,	%rbx
    jz        L1923
    lea       %rcx,	[%rip+L8559]
    lea       %rdx,	[%rip+L8560]
    call      pc_api.merror
L1923:
    call      mc_auxmcl.resetmclentry
    jmp       L1877
L1918:
    mov       %rax,	[%rip+mc_genmcl.frameoffset]
    neg       %rax
    mov       [%rip+mc_genmcl.framebytes],	%rax
    mov       %rax,	[%rip+pc_decls.bspill]
    add       %rax,	[%rip+pc_decls.bxspill]
    and       %eax,	1
    test      %rax,	%rax
    jz        L1925
    mov       %rax,	[%rip+mc_genmcl.framebytes]
    and       %rax,	8
    jnz       L1927
    mov       %rax,	8
    add       [%rip+mc_genmcl.framebytes],	%rax
L1927:
    jmp       L1924
L1925:
    mov       %rax,	[%rip+mc_genmcl.framebytes]
    and       %rax,	8
    jz        L1929
    mov       %rax,	8
    add       [%rip+mc_genmcl.framebytes],	%rax
L1929:
L1924:
    mov       %al,	[%rip+pc_decls.localshadow]
    test      %al,	%al
    jz        L1931
    mov       %rax,	32
    add       [%rip+mc_genmcl.framebytes],	%rax
L1931:
    mov       %rax,	[%rip+pc_decls.bspill]
    test      %rax,	%rax
    jz        L1933
    mov       %rax,	4
    mov       [%rbp + mc_auxmcl.do_procentry.r],	%rax
L1934:
    lea       %rax,	[%rip+mc_decls.usedregs]
    mov       %r10,	[%rbp + mc_auxmcl.do_procentry.r]
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jnz       L1939
    lea       %rax,	[%rip+mc_decls.isregvar]
    mov       %r10,	[%rbp + mc_auxmcl.do_procentry.r]
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L1938
L1939:
    mov       %rcx,	[%rbp + mc_auxmcl.do_procentry.r]
    mov       %rdx,	6
    call      mc_libmcl.mgenreg
    mov       %rcx,	12
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L1938:
    mov       %rax,	[%rbp + mc_auxmcl.do_procentry.r]
    inc       %rax
    mov       [%rbp + mc_auxmcl.do_procentry.r],	%rax
    cmp       %rax,	10
    jle       L1934
L1933:
    mov       %rax,	[%rip+pc_decls.bxspill]
    test      %rax,	%rax
    jz        L1941
    mov       %rcx,	1
    mov       %rdx,	6
    call      mc_libmcl.mgenreg
    mov       %r13,	%rax
    mov       %rax,	7
    mov       [%rbp + mc_auxmcl.do_procentry.r],	%rax
L1942:
    lea       %rax,	[%rip+mc_decls.usedxregs]
    mov       %r10,	[%rbp + mc_auxmcl.do_procentry.r]
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jnz       L1947
    lea       %rax,	[%rip+mc_decls.isxregvar]
    mov       %r10,	[%rbp + mc_auxmcl.do_procentry.r]
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L1946
L1947:
    mov       %rcx,	[%rbp + mc_auxmcl.do_procentry.r]
    mov       %rdx,	8
    call      mc_libmcl.mgenxreg
    mov       %rcx,	17
    mov       %rdx,	%r13
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	12
    mov       %rdx,	%r13
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L1946:
    mov       %rax,	[%rbp + mc_auxmcl.do_procentry.r]
    inc       %rax
    mov       [%rbp + mc_auxmcl.do_procentry.r],	%rax
    cmp       %rax,	16
    jle       L1942
L1941:
    lea       %rcx,	[%rip+L8561]
    call      mc_libmcl.mgencomment
    mov       %rax,	[%rip+mc_decls.mccodex]
    mov       [%rip+mc_auxmcl.mclframesetup],	%rax
    call      mc_auxmcl.spillparams
    lea       %rcx,	[%rip+L8562]
    call      mc_libmcl.mgencomment
    call      mc_auxmcl.resetmclentry
L1877:
#---------------
    add       %rsp,	72
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_procexit
mc_auxmcl.do_procexit:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    lea       %rcx,	[%rip+L8562]
    call      mc_libmcl.mgencomment
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %al,	[%rax+108]
    test      %al,	%al
    jz        L1950
    mov       %rcx,	22
    xor       %edx,	%edx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L1948
L1950:
    mov       %rcx,	[%rip+mc_auxmcl.mclframesetup]
    call      mc_auxmcl.setmclentryf
    mov       %rax,	[%rip+mc_genmcl.framebytes]
    test      %rax,	%rax
    jnz       L1953
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %al,	[%rax+112]
    test      %al,	%al
    jz        L1952
L1953:
    lea       %rax,	[%rip+mc_decls.usedregs]
    mov       %al,	[%rax+14]
    test      %al,	%al
    jz        L1955
    mov       %rcx,	12
    mov       %rdx,	[%rip+mc_decls.dframeopnd]
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	11
    mov       %rdx,	[%rip+mc_decls.dframeopnd]
    mov       %r8,	[%rip+mc_decls.dstackopnd]
    call      mc_libmcl.genmc
    mov       %rcx,	[%rip+mc_genmcl.framebytes]
    call      mc_libmcl.pushstack
    jmp       L1954
L1955:
    mov       %rax,	[%rip+mc_genmcl.framebytes]
    test      %rax,	%rax
    jz        L1957
    mov       %rax,	[%rip+mc_genmcl.framebytes]
    add       %rax,	8
    mov       %rcx,	%rax
    call      mc_libmcl.pushstack
L1957:
L1954:
L1952:
    call      mc_auxmcl.resetmclentryf
    mov       %rax,	[%rip+mc_genmcl.framebytes]
    test      %rax,	%rax
    jnz       L1960
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %al,	[%rax+112]
    test      %al,	%al
    jz        L1959
L1960:
    lea       %rax,	[%rip+mc_decls.usedregs]
    mov       %al,	[%rax+14]
    test      %al,	%al
    jz        L1962
    mov       %rcx,	[%rip+mc_genmcl.framebytes]
    call      mc_libmcl.popstack
    mov       %rcx,	13
    mov       %rdx,	[%rip+mc_decls.dframeopnd]
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L1961
L1962:
    mov       %rax,	[%rip+mc_genmcl.framebytes]
    test      %rax,	%rax
    jz        L1964
    mov       %rax,	[%rip+mc_genmcl.framebytes]
    add       %rax,	8
    mov       %rcx,	%rax
    call      mc_libmcl.popstack
L1964:
L1961:
L1959:
    mov       %rax,	[%rip+pc_decls.bxspill]
    test      %rax,	%rax
    jz        L1966
    mov       %rcx,	11
    mov       %rdx,	6
    call      mc_libmcl.mgenreg
    mov       %rdi,	%rax
    mov       %rbx,	16
L1967:
    lea       %rax,	[%rip+mc_decls.usedxregs]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L1971
    mov       %rcx,	13
    mov       %rdx,	%rdi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	%rbx
    mov       %rdx,	8
    call      mc_libmcl.mgenxreg
    mov       %rcx,	17
    mov       %rdx,	%rax
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
L1971:
    dec       %rbx
    cmp       %rbx,	7
    jge       L1967
L1966:
    mov       %rax,	[%rip+pc_decls.bspill]
    test      %rax,	%rax
    jz        L1973
    mov       %rbx,	10
L1974:
    lea       %rax,	[%rip+mc_decls.usedregs]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L1978
    mov       %rcx,	%rbx
    mov       %rdx,	6
    call      mc_libmcl.mgenreg
    mov       %rcx,	13
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L1978:
    dec       %rbx
    cmp       %rbx,	4
    jge       L1974
L1973:
    mov       %rcx,	22
    xor       %edx,	%edx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L1948:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.spillparams
mc_auxmcl.spillparams:
#PROC1
#PROC2
#?>>
    .set mc_auxmcl.spillparams.$T1, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    mov       %rsi,	16
    xor       %r12,	%r12
    xor       %eax,	%eax
    mov       %r12,	%rax
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %rdi,	[%rax+16]
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %al,	[%rax+113]
    test      %al,	%al
    jz        L1981
    movsxd    %rax,	dword ptr[%rdi+76]
    mov       %r13,	%rax
    mov       %rax,	[%rip+pc_decls.currfunc]
    movzx     %rax,	byte ptr[%rax+112]
    mov       %r14,	%rax
    cmp       %r14,	3
    jg        L1984
L1982:
    sub       %rsp,	8
    push      0
    push      0
    push      8
    mov       %rax,	%r14
    shl       %rax,	3
    add       %rax,	%r13
    mov       %rcx,	15
    xor       %edx,	%edx
    mov       %r8,	1
    mov       %r9,	%rax
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rbx,	%rax
    lea       %rax,	[%r14+11]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    inc       %r14
    cmp       %r14,	3
    jle       L1982
L1984:
L1981:
    jmp       L1988
L1985:
    cmp       %r12,	3
    jg        L1987
L1990:
    mov       %al,	[%rdi+92]
    test      %al,	%al
    jz        L1992
    mov       %al,	[%rdi+90]
    test      %al,	%al
    jnz       L1994
    sub       %rsp,	8
    push      0
    push      0
    push      8
    movsxd    %rax,	dword ptr[%rdi+76]
    mov       %rcx,	15
    xor       %edx,	%edx
    mov       %r8,	1
    mov       %r9,	%rax
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rdi+82]
    cmp       %rax,	2
    jz        L1996
    cmp       %rax,	1
    jz        L1997
    jmp       L1998
L1996:
    lea       %rax,	[%r12+1]
    mov       %rcx,	%rax
    mov       %rdx,	8
    call      mc_libmcl.mgenxreg
    mov       %rcx,	17
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L1995
L1997:
    lea       %rax,	[%r12+1]
    mov       %rcx,	%rax
    mov       %rdx,	8
    call      mc_libmcl.mgenxreg
    mov       [%rbp + mc_auxmcl.spillparams.$T1],	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	4
    call      mc_libmcl.changeopndsize
    mov       %rcx,	16
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.spillparams.$T1]
    call      mc_libmcl.genmc
    jmp       L1995
L1998:
    lea       %rax,	[%r12+11]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L1995:
    jmp       L1993
L1994:
    mov       %al,	[%rdi+90]
    test      %al,	%al
    jz        L1999
    movzx     %rax,	byte ptr[%rdi+82]
    cmp       %rax,	2
    jg        L2001
    movzx     %rax,	byte ptr[%rdi+90]
    cmp       %rax,	5
    jl        L2003
    movzx     %rax,	byte ptr[%rdi+82]
    lea       %r10,	[%r12+1]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_libmcl.mgenxreg
    mov       [%rbp + mc_auxmcl.spillparams.$T1],	%rax
    movzx     %rax,	byte ptr[%rdi+90]
    mov       %rcx,	%rax
    mov       %rdx,	8
    call      mc_libmcl.mgenxreg
    mov       %rcx,	17
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.spillparams.$T1]
    call      mc_libmcl.genmc
L2003:
    jmp       L2000
L2001:
    movzx     %rax,	byte ptr[%rdi+90]
    cmp       %rax,	10
    jg        L2004
    movzx     %rax,	byte ptr[%rdi+82]
    lea       %r10,	[%r12+11]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_libmcl.mgenreg
    mov       [%rbp + mc_auxmcl.spillparams.$T1],	%rax
    movzx     %rax,	byte ptr[%rdi+82]
    movzx     %r10,	byte ptr[%rdi+90]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_libmcl.mgenreg
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.spillparams.$T1]
    call      mc_libmcl.genmc
L2004:
L2000:
L1999:
L1993:
L1992:
    mov       %rax,	8
    add       %rsi,	%rax
    inc       %r12
    mov       %rdi,	[%rdi+16]
L1988:
    test      %rdi,	%rdi
    jnz       L1985
L1987:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_jumptruefalse
mc_auxmcl.do_jumptruefalse:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jle       L2007
    mov       %rcx,	41
    mov       %rdx,	%rdi
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    jmp       L2006
L2007:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rax
    call      mc_stackmcl.getworkregm
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    dec       %rax
    mov       %r10,	76
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rbx
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    dec       %rax
    mov       %r10,	73
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L2006:
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %rcx,	26
    mov       %rdx,	%r12
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_bitwise
mc_auxmcl.do_bitwise:
#PROC1
#PROC2
#?>>
    .set mc_auxmcl.do_bitwise.p, 40
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rdx
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    mov       %rcx,	%rsi
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_shift
mc_auxmcl.do_shift:
#PROC1
#PROC2
#?>>
    .set mc_auxmcl.do_shift.p, 48
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rdx
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	[%rip+mc_decls.noperands]
    mov       %rsi,	[%rax + %r10*8-8]
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    test      %rax,	%rax
    jnz       L2011
    movzx     %rax,	byte ptr[%rsi+1]
    cmp       %rax,	4
    jnz       L2011
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	%r12
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L2010
L2011:
    mov       %al,	[%rip+pc_decls.r10used]
    test      %al,	%al
    jz        L2013
    mov       %rcx,	11
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	12
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L2013:
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	3
    mov       %r8,	11
    call      mc_stackmcl.loadparam
    mov       %rbx,	%rax
    mov       %rcx,	%r12
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    mov       %al,	[%rip+pc_decls.r10used]
    test      %al,	%al
    jz        L2015
    mov       %rcx,	11
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	13
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L2015:
L2010:
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.setmclentry
mc_auxmcl.setmclentry:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+mc_decls.mccodex]
    mov       [%rip+mc_decls.mce_oldmccodex],	%rax
    mov       [%rip+mc_decls.mccodex],	%rcx
    mov       %rax,	[%rcx]
    mov       [%rip+mc_decls.mce_lastmcl],	%rax
    mov       %rax,	[%rcx+8]
    mov       [%rip+mc_decls.mce_nextmcl],	%rax
#---------------
    ret       
# End 
# Proc mc_auxmcl.resetmclentry
mc_auxmcl.resetmclentry:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	16
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+mc_decls.mce_lastmcl]
    mov       %r10,	[%rip+mc_decls.mccodex]
    mov       [%r10],	%rax
    mov       %rax,	[%rip+mc_decls.mce_nextmcl]
    mov       %r10,	[%rip+mc_decls.mccodex]
    mov       [%r10+8],	%rax
    mov       %rdi,	[%rip+mc_decls.mccodex]
    mov       %rax,	[%rip+mc_decls.mce_oldmccodex]
    mov       [%rip+mc_decls.mccodex],	%rax
    mov       %rax,	%rdi
L2017:
#---------------
    add       %rsp,	16
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.setmclentryf
mc_auxmcl.setmclentryf:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+mc_decls.mccodex]
    mov       [%rip+mc_decls.mcf_oldmccodex],	%rax
    mov       [%rip+mc_decls.mccodex],	%rcx
    mov       %rax,	[%rcx]
    mov       [%rip+mc_decls.mcf_lastmcl],	%rax
    mov       %rax,	[%rcx+8]
    mov       [%rip+mc_decls.mcf_nextmcl],	%rax
#---------------
    ret       
# End 
# Proc mc_auxmcl.resetmclentryf
mc_auxmcl.resetmclentryf:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	16
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+mc_decls.mcf_lastmcl]
    mov       %r10,	[%rip+mc_decls.mccodex]
    mov       [%r10],	%rax
    mov       %rax,	[%rip+mc_decls.mcf_nextmcl]
    mov       %r10,	[%rip+mc_decls.mccodex]
    mov       [%r10+8],	%rax
    mov       %rdi,	[%rip+mc_decls.mccodex]
    mov       %rax,	[%rip+mc_decls.mcf_oldmccodex]
    mov       [%rip+mc_decls.mccodex],	%rax
    mov       %rax,	%rdi
L2019:
#---------------
    add       %rsp,	16
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_pushlowargs
mc_auxmcl.do_pushlowargs:
#PROC1
#PROC2
#?>>
    .set mc_auxmcl.do_pushlowargs.nvariadics, 80
    .set mc_auxmcl.do_pushlowargs.isptr, 88
    .set mc_auxmcl.do_pushlowargs.imode, -8
    .set mc_auxmcl.do_pushlowargs.blockret, -16
    .set mc_auxmcl.do_pushlowargs.dblock, -24
    .set mc_auxmcl.do_pushlowargs.av_1, -32
    .set mc_auxmcl.do_pushlowargs.i, -40
    .set mc_auxmcl.do_pushlowargs.$T1, -48
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	88
    mov       %r15,	%rcx
    mov       [%rbp+80],	%rdx
    mov       [%rbp+88],	%r8
#---------------
#PROC3
#PROC4
    test      %r15,	%r15
    jnz       L2022
    jmp       L2020
L2022:
    lea       %rax,	[%rip+mc_decls.callblockret]
    mov       %r10,	[%rip+mc_decls.ncalldepth]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       [%rbp + mc_auxmcl.do_pushlowargs.blockret],	%rax
    mov       %r12,	11
    mov       %r13,	1
    xor       %rsi,	%rsi
    mov       %rax,	[%rip+mc_decls.noperands]
    mov       [%rbp + mc_auxmcl.do_pushlowargs.i],	%rax
    mov       %rax,	[%rip+mc_decls.noperands]
    sub       %rax,	%r15
    inc       %rax
    mov       [%rbp + mc_auxmcl.do_pushlowargs.av_1],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.do_pushlowargs.i]
    cmp       %rax,	[%rbp + mc_auxmcl.do_pushlowargs.av_1]
    jl        L2025
L2023:
    inc       %rsi
    cmp       %rsi,	1
    jnz       L2027
    mov       %rax,	[%rbp + mc_auxmcl.do_pushlowargs.blockret]
    test      %rax,	%rax
    jz        L2027
    lea       %rax,	[%rip+mc_decls.callblocksize]
    mov       %r10,	[%rip+mc_decls.ncalldepth]
    mov       %eax,	[%rax + %r10*4-4]
    mov       %rcx,	%rax
    call      mc_libmcl.newblocktemp
    mov       [%rbp + mc_auxmcl.do_pushlowargs.dblock],	%rax
    mov       %al,	1
    mov       %r10,	[%rbp + mc_auxmcl.do_pushlowargs.dblock]
    mov       [%r10+92],	%al
    mov       %rcx,	[%rbp + mc_auxmcl.do_pushlowargs.dblock]
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       [%rbp + mc_auxmcl.do_pushlowargs.$T1],	%rax
    mov       %rcx,	11
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	14
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.do_pushlowargs.$T1]
    call      mc_libmcl.genmc
    jmp       L2026
L2027:
    mov       %rax,	[%rbp + mc_auxmcl.do_pushlowargs.i]
    sub       %rax,	[%rbp + mc_auxmcl.do_pushlowargs.isptr]
    add       %rax,	[%rbp + mc_auxmcl.do_pushlowargs.blockret]
    mov       %rbx,	%rax
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %r14,	%rax
    mov       %rax,	%r14
    cmp       %rax,	11
    jz        L2029
    cmp       %rax,	2
    jz        L2030
    cmp       %rax,	1
    jz        L2030
    jmp       L2031
L2029:
    mov       %rcx,	%rbx
    mov       %rdx,	%r14
    mov       %r8,	%r12
    call      mc_stackmcl.loadparam
    mov       %rdi,	%rax
    lea       %rax,	[%rip+mc_decls.callargsize]
    mov       %r10,	[%rip+mc_decls.ncalldepth]
    shl       %r10,	4
    lea       %rax,	[%rax + %r10-16]
    mov       %r10,	%rsi
    mov       %eax,	[%rax + %r10*4-4]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    mov       %r8,	%rsi
    call      mc_auxmcl.copyblockarg
    jmp       L2028
L2030:
    mov       %rcx,	%rbx
    mov       %rdx,	%r14
    mov       %r8,	%r13
    call      mc_stackmcl.loadparam
    mov       %rax,	[%rbp + mc_auxmcl.do_pushlowargs.nvariadics]
    test      %rax,	%rax
    jz        L2033
    cmp       %rsi,	[%rbp + mc_auxmcl.do_pushlowargs.nvariadics]
    jl        L2033
    cmp       %r14,	1
    jnz       L2035
    mov       %rax,	5
    jmp       L2034
L2035:
    mov       %rax,	6
L2034:
    mov       [%rbp + mc_auxmcl.do_pushlowargs.imode],	%rax
    mov       %rcx,	%r13
    mov       %rdx,	%r14
    call      mc_libmcl.mgenreg
    mov       [%rbp + mc_auxmcl.do_pushlowargs.$T1],	%rax
    mov       %rcx,	%r12
    mov       %rdx,	[%rbp + mc_auxmcl.do_pushlowargs.imode]
    call      mc_libmcl.mgenreg
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.do_pushlowargs.$T1]
    call      mc_libmcl.genmc
L2033:
    jmp       L2028
L2031:
#mc_auxmcl.do_pushlowargs.doint:
    mov       %rcx,	%rbx
    mov       %rdx,	%r14
    mov       %r8,	%r12
    call      mc_stackmcl.loadparam
L2028:
L2026:
    inc       %r12
    inc       %r13
    mov       %rax,	[%rbp + mc_auxmcl.do_pushlowargs.i]
    dec       %rax
    mov       [%rbp + mc_auxmcl.do_pushlowargs.i],	%rax
    cmp       %rax,	[%rbp + mc_auxmcl.do_pushlowargs.av_1]
    jge       L2023
L2025:
L2020:
#---------------
    add       %rsp,	88
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_getretvalue
mc_auxmcl.do_getretvalue:
#PROC1
#PROC2
#?>>
    .set mc_auxmcl.do_getretvalue.modes, -80
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	112
    mov       %r12,	%rcx
#---------------
#PROC3
#PROC4
    lea       %rax,	[%r12+32]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	13
    jnz       L2039
    xor       %rbx,	%rbx
    jmp       L2041
L2040:
    movzx     %rax,	byte ptr[%r12+3]
    inc       %rbx
    mov       %r10,	%rbx
    mov       [%rbp + %r10*8 + mc_auxmcl.do_getretvalue.modes-8],	%rax
L2041:
    add       %r12,	32
    mov       %rax,	%r12
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	13
    jz        L2040
    lea       %rax,	[%r12-32]
    mov       [%rip+mc_decls.currpcl],	%rax
    mov       %rdi,	%rbx
    cmp       %rdi,	1
    jl        L2045
L2043:
    mov       %rsi,	[%rbp + %rdi*8 + mc_auxmcl.do_getretvalue.modes-8]
    cmp       %rsi,	2
    jg        L2047
    lea       %rax,	[%rip+mc_decls.multxregs]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    jmp       L2046
L2047:
    lea       %rax,	[%rip+mc_decls.multregs]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
L2046:
    mov       %rcx,	%rsi
    mov       %rdx,	%rax
    call      mc_stackmcl.pushpcl_reg
    dec       %rdi
    cmp       %rdi,	1
    jge       L2043
L2045:
    jmp       L2038
L2039:
    movzx     %rax,	byte ptr[%r12+3]
    mov       %rcx,	%rax
    mov       %rdx,	1
    call      mc_stackmcl.pushpcl_reg
L2038:
#---------------
    add       %rsp,	112
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.ismemaddr
mc_auxmcl.ismemaddr:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rcx
    movzx     %rax,	byte ptr[%rax + %r10-1]
    test      %rax,	%rax
    jnz       L2050
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	%rcx
    mov       %rax,	[%rax + %r10*8-8]
    movzx     %rax,	byte ptr[%rax+1]
    cmp       %rax,	2
    jnz       L2050
    mov       %rax,	1
    jmp       L2048
L2050:
    xor       %eax,	%eax
L2048:
#---------------
    ret       
# End 
# Proc mc_auxmcl.do_incr
mc_auxmcl.do_incr:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rbx+3]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    movsxd    %rax,	dword ptr[%rbx+16]
    cmp       %rax,	1
    jnz       L2053
    mov       %rcx,	%rsi
    mov       %rdx,	%rdi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L2052
L2053:
    movsxd    %rax,	dword ptr[%rbx+16]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	%r12
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2052:
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_incrload
mc_auxmcl.do_incrload:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	[%rip+mc_decls.noperands]
    movzx     %r10,	byte ptr[%r10 + %r11-1]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_stackmcl.getworkreg_rm
    mov       %rdi,	%rax
    movsxd    %rax,	dword ptr[%rsi+16]
    cmp       %rax,	1
    jnz       L2056
    mov       %rcx,	%r12
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L2055
L2056:
    movsxd    %rax,	dword ptr[%rsi+16]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	%r13
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2055:
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.pclloc]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11-1],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+mc_decls.pclopnd]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11*8-8],	%rax
    mov       %al,	[%rdi+10]
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11-1],	%al
    mov       %al,	[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+mc_decls.pclmode]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11-1],	%al
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_loadincr
mc_auxmcl.do_loadincr:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      mc_stackmcl.pushpcl_reg
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rdi,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    movsxd    %rax,	dword ptr[%rsi+16]
    cmp       %rax,	1
    jnz       L2059
    mov       %rcx,	%r12
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L2058
L2059:
    movsxd    %rax,	dword ptr[%rsi+16]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	%r13
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2058:
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_for
mc_auxmcl.do_for:
#PROC1
#PROC2
#?>>
    .set mc_auxmcl.do_for.addop, 80
    .set mc_auxmcl.do_for.cond, 88
    .set mc_auxmcl.do_for.mx, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       [%rbp+80],	%r8
    mov       [%rbp+88],	%r9
#---------------
#PROC3
#PROC4
    lea       %rax,	[%r13+32]
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+32]
    mov       [%rip+mc_decls.currpcl],	%rax
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rdi+8]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_libmcl.mgenmem
    mov       [%rbp + mc_auxmcl.do_for.mx],	%rax
    mov       %rax,	[%rdi+8]
    mov       %al,	[%rax+90]
    test      %al,	%al
    jz        L2062
    movsxd    %rax,	dword ptr[%r13+16]
    cmp       %rax,	1
    jnz       L2064
    mov       %rcx,	%r14
    mov       %rdx,	[%rbp + mc_auxmcl.do_for.mx]
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L2063
L2064:
    movsxd    %rax,	dword ptr[%r13+16]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	[%rbp + mc_auxmcl.do_for.addop]
    mov       %rdx,	[%rbp + mc_auxmcl.do_for.mx]
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2063:
    mov       %rsi,	[%rbp + mc_auxmcl.do_for.mx]
    jmp       L2061
L2062:
    call      mc_stackmcl.getworkireg
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rsi,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rsi
    mov       %r8,	[%rbp + mc_auxmcl.do_for.mx]
    call      mc_libmcl.genmc
    movsxd    %rax,	dword ptr[%r13+16]
    cmp       %rax,	1
    jnz       L2066
    mov       %rcx,	%r14
    mov       %rdx,	%rsi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L2065
L2066:
    movsxd    %rax,	dword ptr[%r13+16]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	[%rbp + mc_auxmcl.do_for.addop]
    mov       %rdx,	%rsi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2065:
    mov       %rcx,	11
    mov       %rdx,	[%rbp + mc_auxmcl.do_for.mx]
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
L2061:
    movzx     %rax,	byte ptr[%rbx+1]
    cmp       %rax,	4
    jnz       L2068
    mov       %rax,	[%rbx+8]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %r12,	%rax
    jmp       L2067
L2068:
    mov       %rax,	[%rbx+8]
    mov       %rcx,	%rax
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       %r12,	%rax
L2067:
    mov       %rcx,	42
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      mc_libmcl.genmc
    mov       %rax,	[%r13+8]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %rcx,	26
    mov       %rdx,	[%rbp + mc_auxmcl.do_for.cond]
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.scaleindex
mc_auxmcl.scaleindex:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    mov       %rax,	%rbx
    cmp       %rax,	1
    jz        L2072
    cmp       %rax,	2
    jz        L2072
    cmp       %rax,	4
    jz        L2072
    cmp       %rax,	8
    jnz       L2071
L2072:
    mov       %rax,	%rbx
    jmp       L2069
L2071:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mc_auxmcl.mulimm
    mov       %rax,	1
L2069:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.mulimm
mc_auxmcl.mulimm:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r12,	%rcx
    mov       %r13,	%rdx
#---------------
#PROC3
#PROC4
    mov       %rax,	%r13
    test      %rax,	%rax
    jz        L2075
    cmp       %rax,	1
    jz        L2076
    cmp       %rax,	-1
    jz        L2077
    jmp       L2078
L2075:
    mov       %rcx,	%r12
    call      mc_libmcl.clearreg
    jmp       L2073
L2076:
    jmp       L2073
L2077:
    mov       %rcx,	50
    mov       %rdx,	%r12
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L2073
L2078:
L2074:
    xor       %rdi,	%rdi
    mov       %rax,	%r13
    mov       %rbx,	%rax
    jmp       L2080
L2079:
    sar       %rbx,	1
    inc       %rdi
L2080:
    mov       %eax,	%ebx
    and       %eax,	1
    test      %rax,	%rax
    jz        L2079
    test      %rdi,	%rdi
    jz        L2083
    mov       %rcx,	%rdi
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	43
    mov       %rdx,	%r12
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2083:
    mov       %rax,	%rbx
    cmp       %rax,	1
    jz        L2085
    cmp       %rax,	3
    jz        L2086
    cmp       %rax,	5
    jz        L2086
    cmp       %rax,	9
    jz        L2086
    jmp       L2087
L2085:
    jmp       L2073
L2086:
    sub       %rsp,	8
    push      0
    push      0
    push      0
    lea       %rax,	[%rbx-1]
    movzx     %r10,	byte ptr[%r12+10]
    movzx     %r11,	byte ptr[%r12+10]
    mov       %rcx,	%r11
    mov       %rdx,	%r10
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rcx,	14
    mov       %rdx,	%r12
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L2084
L2087:
    test      %rdi,	%rdi
    jz        L2089
    mov       %al,	34
    mov       %r10,	[%rip+mc_decls.mccodex]
    mov       [%r10+33],	%al
    mov       %rcx,	%r13
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %r10,	[%rip+mc_decls.mccodex]
    mov       [%r10+24],	%rax
    jmp       L2088
L2089:
    movzx     %rax,	word ptr[%r12+8]
    and       %rax,	31
    cmp       %rax,	4
    jnz       L2091
    mov       %rax,	9
    jmp       L2090
L2091:
    mov       %rax,	10
L2090:
    mov       %rcx,	%rax
    call      mc_stackmcl.getworkregm
    mov       %rsi,	%rax
    mov       %rcx,	%r13
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	11
    mov       %rdx,	%rsi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	34
    mov       %rdx,	%r12
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
L2088:
L2084:
L2073:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_addrmode
mc_auxmcl.do_addrmode:
#PROC1
#PROC2
#?>>
    .set mc_auxmcl.do_addrmode.p, 72
    .set mc_auxmcl.do_addrmode.scale, -8
    .set mc_auxmcl.do_addrmode.regix, -16
    .set mc_auxmcl.do_addrmode.d, -24
    .set mc_auxmcl.do_addrmode.q, -32
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	72
    mov       [%rbp+72],	%rcx
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rbp + mc_auxmcl.do_addrmode.p]
    movsxd    %rax,	dword ptr[%rax+16]
    mov       [%rbp + mc_auxmcl.do_addrmode.scale],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.do_addrmode.p]
    movsxd    %rax,	dword ptr[%rax+20]
    mov       %r12,	%rax
    mov       %rcx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.isimmload
    mov       [%rbp + mc_auxmcl.do_addrmode.q],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.do_addrmode.q]
    test      %rax,	%rax
    jz        L2094
    mov       %rax,	[%rbp + mc_auxmcl.do_addrmode.q]
    mov       %rax,	[%rax+8]
    mov       %r10,	[%rbp + mc_auxmcl.do_addrmode.scale]
    imul      %rax,	%r10
    add       %rax,	%r12
    mov       %r13,	%rax
L2094:
    xor       %rdi,	%rdi
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-2]
    cmp       %rax,	2
    jnz       L2096
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	2
    jnz       L2098
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %r14,	%rax
    mov       %rcx,	%r14
    lea       %rdx,	[%rbp + mc_auxmcl.do_addrmode.scale]
    mov       %r8,	[%rip+mc_decls.noperands]
    call      mc_auxmcl.scaleregvar
    mov       [%rbp + mc_auxmcl.do_addrmode.regix],	%rax
    sub       %rsp,	8
    push      0
    push      0
    push      0
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-2]
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_auxmcl.do_addrmode.regix]
    mov       %r8,	[%rbp + mc_auxmcl.do_addrmode.scale]
    mov       %r9,	%r12
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rdi,	%rax
    jmp       L2097
L2098:
    mov       %rax,	[%rbp + mc_auxmcl.do_addrmode.q]
    test      %rax,	%rax
    jz        L2099
    sub       %rsp,	8
    push      0
    push      0
    push      0
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-2]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    mov       %r8,	1
    mov       %r9,	%r13
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rdi,	%rax
    jmp       L2097
L2099:
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %r10,	%rax
    mov       %rsi,	%r10
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_auxmcl.do_addrmode.scale]
    call      mc_auxmcl.scaleindex
    mov       [%rbp + mc_auxmcl.do_addrmode.scale],	%rax
    sub       %rsp,	8
    push      0
    push      0
    push      0
    movzx     %rax,	byte ptr[%rsi+10]
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	[%rip+mc_decls.noperands]
    movzx     %r10,	byte ptr[%r10 + %r11-2]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.do_addrmode.scale]
    mov       %r9,	%r12
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rdi,	%rax
L2097:
    jmp       L2095
L2096:
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    call      mc_auxmcl.ismemaddr
    test      %rax,	%rax
    jz        L2100
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	[%rip+mc_decls.noperands]
    mov       %rax,	[%rax + %r10*8-16]
    mov       %rax,	[%rax+8]
    mov       [%rbp + mc_auxmcl.do_addrmode.d],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.do_addrmode.d]
    movzx     %rax,	byte ptr[%rax+72]
    cmp       %rax,	3
    jnz       L2104
    movzx     %rax,	byte ptr[%rip+pc_api.phighmem]
    cmp       %rax,	2
    jz        L2103
L2104:
    mov       %rax,	[%rbp + mc_auxmcl.do_addrmode.d]
    movzx     %rax,	byte ptr[%rax+72]
    cmp       %rax,	5
    jnz       L2102
    mov       %rax,	[%rbp + mc_auxmcl.do_addrmode.d]
    movzx     %rax,	byte ptr[%rax+82]
    cmp       %rax,	11
    jnz       L2102
L2103:
    jmp       L2105
L2102:
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	2
    jnz       L2107
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %r14,	%rax
    mov       %rcx,	%r14
    lea       %rdx,	[%rbp + mc_auxmcl.do_addrmode.scale]
    mov       %r8,	[%rip+mc_decls.noperands]
    call      mc_auxmcl.scaleregvar
    mov       [%rbp + mc_auxmcl.do_addrmode.regix],	%rax
    sub       %rsp,	8
    push      qword ptr[%rbp + mc_auxmcl.do_addrmode.d]
    push      0
    push      0
    xor       %ecx,	%ecx
    mov       %rdx,	[%rbp + mc_auxmcl.do_addrmode.regix]
    mov       %r8,	[%rbp + mc_auxmcl.do_addrmode.scale]
    mov       %r9,	%r12
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rdi,	%rax
    jmp       L2106
L2107:
    mov       %rax,	[%rbp + mc_auxmcl.do_addrmode.q]
    test      %rax,	%rax
    jz        L2108
    sub       %rsp,	8
    push      qword ptr[%rbp + mc_auxmcl.do_addrmode.d]
    push      0
    push      0
    xor       %ecx,	%ecx
    xor       %edx,	%edx
    mov       %r8,	1
    mov       %r9,	%r13
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rdi,	%rax
    jmp       L2106
L2108:
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	10
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %r10,	%rax
    mov       %rsi,	%r10
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_auxmcl.do_addrmode.scale]
    call      mc_auxmcl.scaleindex
    mov       [%rbp + mc_auxmcl.do_addrmode.scale],	%rax
    sub       %rsp,	8
    push      qword ptr[%rbp + mc_auxmcl.do_addrmode.d]
    push      0
    push      0
    movzx     %rax,	byte ptr[%rsi+10]
    xor       %ecx,	%ecx
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.do_addrmode.scale]
    mov       %r9,	%r12
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rdi,	%rax
L2106:
    jmp       L2095
L2100:
#mc_auxmcl.do_addrmode.skip:
L2105:
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	1
    jnz       L2110
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %r14,	%rax
    mov       %rcx,	%r14
    lea       %rdx,	[%rbp + mc_auxmcl.do_addrmode.scale]
    mov       %r8,	[%rip+mc_decls.noperands]
    call      mc_auxmcl.scaleregvar
    mov       [%rbp + mc_auxmcl.do_addrmode.regix],	%rax
    sub       %rsp,	8
    push      0
    push      0
    push      0
    movzx     %rax,	byte ptr[%rbx+10]
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_auxmcl.do_addrmode.regix]
    mov       %r8,	[%rbp + mc_auxmcl.do_addrmode.scale]
    mov       %r9,	%r12
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rdi,	%rax
    jmp       L2109
L2110:
    mov       %rax,	[%rbp + mc_auxmcl.do_addrmode.q]
    test      %rax,	%rax
    jz        L2111
    sub       %rsp,	8
    push      0
    push      0
    push      0
    movzx     %rax,	byte ptr[%rbx+10]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    mov       %r8,	1
    mov       %r9,	%r13
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rdi,	%rax
    jmp       L2109
L2111:
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %r10,	%rax
    mov       %rsi,	%r10
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_auxmcl.do_addrmode.scale]
    call      mc_auxmcl.scaleindex
    mov       [%rbp + mc_auxmcl.do_addrmode.scale],	%rax
    sub       %rsp,	8
    push      0
    push      0
    push      0
    movzx     %rax,	byte ptr[%rsi+10]
    movzx     %r10,	byte ptr[%rbx+10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.do_addrmode.scale]
    mov       %r9,	%r12
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rdi,	%rax
L2109:
L2095:
    mov       %rax,	[%rbp + mc_auxmcl.do_addrmode.p]
    movzx     %rax,	byte ptr[%rax+3]
    lea       %r10,	[%rip+pc_tables.psize]
    movzx     %r10,	byte ptr[%r10 + %rax]
    lea       %rax,	[%rdi+8]
    mov       %r15w,	[%rax]
    mov       %r11,	-32
    and       %r15w,	%r11w
    or        %r15w,	%r10w
    mov       [%rax],	%r15w
    mov       %rax,	%rdi
L2092:
#---------------
    add       %rsp,	72
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.scaleregvar
mc_auxmcl.scaleregvar:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
#PROC3
#PROC4
    mov       %rax,	[%r12]
    cmp       %rax,	1
    jz        L2115
    cmp       %rax,	2
    jz        L2115
    cmp       %rax,	4
    jz        L2115
    cmp       %rax,	8
    jnz       L2114
L2115:
    mov       %rax,	%rsi
    jmp       L2112
L2114:
    call      mc_stackmcl.getworkireg
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rbx,	%rax
    mov       %rax,	[%r12]
    cmp       %rax,	16
    jnz       L2117
    sub       %rsp,	8
    push      0
    push      0
    push      0
    mov       %rcx,	%rsi
    mov       %rdx,	%rsi
    mov       %r8,	1
    xor       %r9d,	%r9d
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       %rcx,	14
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rax,	8
    mov       [%r12],	%rax
    jmp       L2116
L2117:
    mov       %rcx,	%rsi
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rax,	[%r12]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      mc_auxmcl.mulimm
    mov       %rax,	1
    mov       [%r12],	%rax
L2116:
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.pclloc]
    mov       %r11,	%r13
    mov       [%r10 + %r11-1],	%al
    mov       %al,	%dil
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	%r13
    mov       [%r10 + %r11-1],	%al
    mov       %al,	10
    lea       %r10,	[%rip+mc_decls.pclmode]
    mov       %r11,	%r13
    mov       [%r10 + %r11-1],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+mc_decls.pclopnd]
    mov       %r11,	%r13
    mov       [%r10 + %r11*8-8],	%rax
    mov       %rax,	%rdi
L2112:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.dolea
mc_auxmcl.dolea:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rbx+11]
    movzx     %r10,	word ptr[%rbx+8]
    shr       %r10,	12
    and       %r10,	15
    cmp       %r10,	%rax
    jnz       L2122
    movsxd    %rax,	dword ptr[%rbx+12]
    cmp       %rax,	%r10
    jnz       L2122
    test      %rax,	%rax
    jnz       L2122
    mov       %rax,	1
    jmp       L2123
L2122:
    xor       %eax,	%eax
L2123:
    test      %rax,	%rax
    setnz     %al
    movzx     %eax,	%al
    test      %ax,	%ax
    jz        L2121
    movzx     %rax,	byte ptr[%rbx+10]
    movzx     %r10,	byte ptr[%rdi+10]
    cmp       %rax,	%r10
    jz        L2120
L2121:
    mov       %rcx,	14
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L2120:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_binto
mc_auxmcl.do_binto:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    cmp       %rax,	2
    jg        L2126
    mov       %rcx,	%rsi
    mov       %rdx,	%r13
    call      mc_auxmcl.do_binto_float
    jmp       L2124
L2126:
    movzx     %rax,	byte ptr[%rsi+3]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rsi+3]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    mov       %rcx,	%r12
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
L2124:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_binto_float
mc_auxmcl.do_binto_float:
#PROC1
#PROC2
#?>>
    .set mc_auxmcl.do_binto_float.p, 48
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rdx
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      mc_stackmcl.pushpcl_reg
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    sub       %r10,	2
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rsi,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rsi
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    dec       %rax
    mov       %r10,	%r12
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rsi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_shiftnto
mc_auxmcl.do_shiftnto:
#PROC1
#PROC2
#?>>
    .set mc_auxmcl.do_shiftnto.p, 40
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rdx
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-2]
    test      %rax,	%rax
    jnz       L2130
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	[%rip+mc_decls.noperands]
    mov       %rax,	[%rax + %r10*8-16]
    movzx     %rax,	byte ptr[%rax+1]
    cmp       %rax,	4
    jnz       L2130
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	[%rip+mc_decls.noperands]
    mov       %rax,	[%rax + %r10*8-16]
    mov       %rax,	[%rax+8]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	%rsi
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L2129
L2130:
    mov       %al,	[%rip+pc_decls.r10used]
    test      %al,	%al
    jz        L2132
    mov       %rcx,	11
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	12
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L2132:
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	3
    mov       %r8,	11
    call      mc_stackmcl.loadparam
    mov       %rbx,	%rax
    mov       %rcx,	%rsi
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    mov       %al,	[%rip+pc_decls.r10used]
    test      %al,	%al
    jz        L2134
    mov       %rcx,	11
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	13
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L2134:
L2129:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_divrem
mc_auxmcl.do_divrem:
#PROC1
#PROC2
#?>>
    .set mc_auxmcl.do_divrem.issigned, 80
    .set mc_auxmcl.do_divrem.isdiv, 88
    .set mc_auxmcl.do_divrem.shifts, -8
    .set mc_auxmcl.do_divrem.fdivto, -16
    .set mc_auxmcl.do_divrem.locyy, -24
    .set mc_auxmcl.do_divrem.loczz, -32
    .set mc_auxmcl.do_divrem.$T1, -40
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	72
    mov       %r15,	%rcx
    mov       [%rbp+80],	%rdx
    mov       [%rbp+88],	%r8
#---------------
#PROC3
#PROC4
    xor       %eax,	%eax
    mov       [%rbp + mc_auxmcl.do_divrem.fdivto],	%al
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       [%rbp + mc_auxmcl.do_divrem.locyy],	%rax
    mov       %rax,	[%rip+mc_decls.noperands]
    mov       [%rbp + mc_auxmcl.do_divrem.loczz],	%rax
    movzx     %rax,	byte ptr[%r15]
    cmp       %rax,	94
    jz        L2138
    cmp       %rax,	95
    jnz       L2137
L2138:
    mov       %rax,	[%rbp + mc_auxmcl.do_divrem.locyy]
    mov       %r10,	[%rbp + mc_auxmcl.do_divrem.loczz]
    mov       [%rbp + mc_auxmcl.do_divrem.loczz],	%rax
    mov       [%rbp + mc_auxmcl.do_divrem.locyy],	%r10
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rbp + mc_auxmcl.do_divrem.locyy]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    mov       %al,	1
    mov       [%rbp + mc_auxmcl.do_divrem.fdivto],	%al
    mov       %rcx,	%rdi
    mov       %rdx,	8
    call      mc_libmcl.changeopndsize
    mov       %rcx,	12
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mc_stackmcl.makeopndind
    mov       %rsi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    movzx     %r10,	byte ptr[%rdi+10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_libmcl.mgenreg
    mov       %rdi,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
    jmp       L2136
L2137:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rbp + mc_auxmcl.do_divrem.locyy]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
L2136:
    mov       %rcx,	[%rbp + mc_auxmcl.do_divrem.loczz]
    call      mc_stackmcl.isimmload
    mov       %r12,	%rax
    test      %r12,	%r12
    jz        L2140
    mov       %rax,	[%rbp + mc_auxmcl.do_divrem.isdiv]
    cmp       %rax,	1
    jnz       L2140
    mov       %r14,	[%r12+8]
    mov       %rax,	%r14
    test      %rax,	%rax
    jz        L2142
    cmp       %rax,	1
    jz        L2143
    jmp       L2144
L2142:
    lea       %rcx,	[%rip+L8563]
    lea       %rdx,	[%rip+L8564]
    call      pc_api.merror
    jmp       L2141
L2143:
    call      mc_stackmcl.poppcl
    jmp       L2135
L2144:
    mov       %rcx,	%r14
    call      mc_libmcl.ispoweroftwo
    mov       [%rbp + mc_auxmcl.do_divrem.shifts],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.do_divrem.shifts]
    test      %rax,	%rax
    jz        L2146
    mov       %al,	[%rbp + mc_auxmcl.do_divrem.fdivto]
    test      %al,	%al
    jnz       L2146
    mov       %rcx,	[%rbp + mc_auxmcl.do_divrem.shifts]
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       [%rbp + mc_auxmcl.do_divrem.$T1],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.do_divrem.issigned]
    test      %rax,	%rax
    jz        L2148
    mov       %rax,	44
    jmp       L2147
L2148:
    mov       %rax,	45
L2147:
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    mov       %r8,	[%rbp + mc_auxmcl.do_divrem.$T1]
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    jmp       L2135
L2146:
L2141:
L2140:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rbp + mc_auxmcl.do_divrem.loczz]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    call      mc_auxmcl.saverdx
    mov       %rcx,	[%rbp + mc_auxmcl.do_divrem.locyy]
    mov       %rdx,	[%rbp + mc_auxmcl.do_divrem.loczz]
    call      mc_auxmcl.fixdivopnds
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rbp + mc_auxmcl.do_divrem.loczz]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    mov       %rax,	[%rbp + mc_auxmcl.do_divrem.issigned]
    test      %rax,	%rax
    jz        L2150
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    lea       %r10,	[%rip+pc_tables.psize]
    movzx     %r10,	byte ptr[%r10 + %rax]
    cmp       %r10,	8
    jz        L2152
    cmp       %r10,	4
    jz        L2153
    cmp       %r10,	2
    jz        L2154
    jmp       L2155
L2152:
    mov       %rax,	57
    jmp       L2151
L2153:
    mov       %rax,	56
    jmp       L2151
L2154:
    mov       %rax,	55
    jmp       L2151
L2155:
    lea       %rcx,	[%rip+L8565]
    lea       %rdx,	[%rip+L8566]
    call      pc_api.merror
    xor       %eax,	%eax
L2151:
    mov       %r13,	%rax
    mov       %rcx,	%r13
    xor       %edx,	%edx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %r13,	36
    jmp       L2149
L2150:
    mov       %rcx,	12
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	%rax
    call      mc_libmcl.clearreg
    mov       %r13,	37
L2149:
    mov       %rcx,	%r13
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rax,	[%rbp + mc_auxmcl.do_divrem.isdiv]
    test      %rax,	%rax
    jz        L2157
    cmp       %rax,	2
    jz        L2158
    jmp       L2159
L2157:
    mov       %rcx,	12
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       [%rbp + mc_auxmcl.do_divrem.$T1],	%rax
    mov       %rcx,	1
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	27
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.do_divrem.$T1]
    call      mc_libmcl.genmc
    jmp       L2156
L2158:
    mov       %rcx,	12
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	27
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	2
    call      mc_stackmcl.swapopndregs
    mov       %rcx,	[%rbp + mc_auxmcl.do_divrem.locyy]
    mov       %rdx,	[%rbp + mc_auxmcl.do_divrem.loczz]
    call      mc_stackmcl.swapopnds
L2159:
L2156:
    call      mc_auxmcl.restorerdx
    mov       %al,	[%rbp + mc_auxmcl.do_divrem.fdivto]
    test      %al,	%al
    jz        L2161
    mov       %rcx,	6
    call      mc_stackmcl.getworkregm
    mov       %rbx,	%rax
    mov       %rcx,	13
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rbp + mc_auxmcl.do_divrem.locyy]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       [%rbp + mc_auxmcl.do_divrem.$T1],	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      mc_stackmcl.makeopndind
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.do_divrem.$T1]
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
L2161:
    mov       %rax,	[%rbp + mc_auxmcl.do_divrem.isdiv]
    cmp       %rax,	2
    jz        L2163
    call      mc_stackmcl.poppcl
L2163:
L2135:
#---------------
    add       %rsp,	72
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.fixdivopnds
mc_auxmcl.fixdivopnds:
#PROC1
#PROC2
#?>>
    .set mc_auxmcl.fixdivopnds.$T1, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %r14,	%rcx
    mov       %r15,	%rdx
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%r14
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rdi,	%rax
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%r15
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rbx,	%rax
    cmp       %rdi,	1
    jz        L2164
L2166:
    mov       %rcx,	%r14
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %r12,	%rax
    mov       %rcx,	%r15
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %r13,	%rax
    cmp       %rbx,	1
    jnz       L2168
    mov       %rcx,	27
    mov       %rdx,	%r12
    mov       %r8,	%r13
    call      mc_libmcl.genmc
    mov       %rcx,	%r14
    mov       %rdx,	%r15
    call      mc_stackmcl.swapopnds
    jmp       L2164
L2168:
    lea       %rax,	[%rip+mc_decls.regset]
    movzx     %rax,	byte ptr[%rax]
    test      %rax,	%rax
    jnz       L2170
    mov       %rcx,	1
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	27
    mov       %rdx,	%rax
    mov       %r8,	%r12
    call      mc_libmcl.genmc
    xor       %eax,	%eax
    lea       %r10,	[%rip+mc_decls.regset]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	%r14
    mov       [%r10 + %r11-1],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.regset]
    mov       [%r10],	%al
    jmp       L2164
L2170:
    mov       %rsi,	[%rip+mc_decls.noperands]
    cmp       %rsi,	1
    jl        L2174
L2171:
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	1
    jnz       L2176
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	1
    jz        L2173
L2176:
    dec       %rsi
    cmp       %rsi,	1
    jge       L2171
L2174:
    jmp       L2164
L2173:
    mov       %rcx,	%r14
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       [%rbp + mc_auxmcl.fixdivopnds.$T1],	%rax
    mov       %rcx,	1
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	27
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.fixdivopnds.$T1]
    call      mc_libmcl.genmc
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%r14
    lea       %rax,	[%rax + %r10-1]
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	%rsi
    lea       %r10,	[%r10 + %r11-1]
    mov       %r11b,	[%rax]
    mov       %r9b,	[%r10]
    mov       [%r10],	%r11b
    mov       [%rax],	%r9b
L2164:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.saverdx
mc_auxmcl.saverdx:
#PROC1
#PROC2
#?>>
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    mov       %al,	[%rip+pc_decls.r11used]
    test      %al,	%al
    jz        L2179
    mov       %rcx,	12
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	12
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L2179:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_auxmcl.restorerdx
mc_auxmcl.restorerdx:
#PROC1
#PROC2
#?>>
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    mov       %al,	[%rip+pc_decls.r11used]
    test      %al,	%al
    jz        L2182
    mov       %rcx,	12
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	13
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L2182:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_auxmcl.clearblock
mc_auxmcl.clearblock:
#PROC1
#PROC2
#?>>
    .set mc_auxmcl.clearblock.ax, 64
    .set mc_auxmcl.clearblock.n, 72
    .set mc_auxmcl.clearblock.countreg, -8
    .set mc_auxmcl.clearblock.av_1, -16
    .set mc_auxmcl.clearblock.i, -24
    .set mc_auxmcl.clearblock.$T1, -32
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	64
    mov       [%rbp+64],	%rcx
    mov       [%rbp+72],	%rdx
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rbp + mc_auxmcl.clearblock.n]
    mov       %r10,	8
    cqo       
    idiv      %r10
    xchg      %rax,	%rdx
    mov       %r13,	%rax
    mov       %rax,	%r13
    sub       [%rbp + mc_auxmcl.clearblock.n],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.clearblock.n]
    sar       %rax,	3
    mov       %rsi,	%rax
    mov       %rcx,	6
    call      mc_stackmcl.getworkregm
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    call      mc_libmcl.clearreg
    xor       %r14,	%r14
    mov       %rax,	%rsi
    cmp       %rax,	1
    jl        L2185
    cmp       %rax,	8
    jg        L2185
    mov       %rcx,	[%rbp + mc_auxmcl.clearblock.ax]
    mov       %rdx,	8
    call      mc_libmcl.changeopndsize
    mov       [%rbp + mc_auxmcl.clearblock.ax],	%rax
    mov       [%rbp + mc_auxmcl.clearblock.av_1],	%rsi
    mov       %rax,	[%rbp + mc_auxmcl.clearblock.av_1]
    cmp       %rax,	0
    jle       L2188
L2186:
    mov       %rcx,	[%rbp + mc_auxmcl.clearblock.ax]
    mov       %rdx,	%r14
    xor       %r8d,	%r8d
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rax,	8
    add       %r14,	%rax
    dec       qword ptr[%rbp + mc_auxmcl.clearblock.av_1]
    jnz       L2186
L2188:
    jmp       L2184
L2185:
    test      %rsi,	%rsi
    jz        L2189
    mov       %rax,	%rsi
    and       %rax,	3
    jz        L2191
    call      mc_stackmcl.getworkireg
    mov       %r10,	%rax
    mov       [%rbp + mc_auxmcl.clearblock.countreg],	%r10
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rbx,	%rax
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %r12,	[%rip+pc_api.mlabelno]
    mov       %rcx,	[%rbp + mc_auxmcl.clearblock.ax]
    call      mc_stackmcl.makesimpleaddr
    mov       [%rbp + mc_auxmcl.clearblock.ax],	%rax
    mov       %rcx,	%rsi
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	%r12
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	11
    mov       %rdx,	[%rbp + mc_auxmcl.clearblock.ax]
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rcx,	8
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       [%rbp + mc_auxmcl.clearblock.$T1],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.clearblock.ax]
    movzx     %rax,	byte ptr[%rax+10]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	28
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.clearblock.$T1]
    call      mc_libmcl.genmc
    mov       %rcx,	53
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	%r12
    call      mc_libmcl.mgenlabel
    mov       %rcx,	26
    mov       %rdx,	5
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    xor       %r14,	%r14
    jmp       L2190
L2191:
    call      mc_stackmcl.getworkireg
    mov       %r10,	%rax
    mov       [%rbp + mc_auxmcl.clearblock.countreg],	%r10
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rbx,	%rax
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %r12,	[%rip+pc_api.mlabelno]
    mov       %rcx,	[%rbp + mc_auxmcl.clearblock.ax]
    call      mc_stackmcl.makesimpleaddr
    mov       [%rbp + mc_auxmcl.clearblock.ax],	%rax
    mov       %rax,	%rsi
    sar       %rax,	2
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	%r12
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rax,	1
    mov       [%rbp + mc_auxmcl.clearblock.i],	%rax
L2192:
    mov       %rcx,	[%rbp + mc_auxmcl.clearblock.ax]
    mov       %rdx,	%r14
    xor       %r8d,	%r8d
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rax,	8
    add       %r14,	%rax
    mov       %rax,	[%rbp + mc_auxmcl.clearblock.i]
    inc       %rax
    mov       [%rbp + mc_auxmcl.clearblock.i],	%rax
    cmp       %rax,	4
    jle       L2192
    mov       %rcx,	32
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       [%rbp + mc_auxmcl.clearblock.$T1],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.clearblock.ax]
    movzx     %rax,	byte ptr[%rax+10]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	28
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.clearblock.$T1]
    call      mc_libmcl.genmc
    mov       %rcx,	53
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	%r12
    call      mc_libmcl.mgenlabel
    mov       %rcx,	26
    mov       %rdx,	5
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    xor       %r14,	%r14
L2190:
L2189:
L2184:
    test      %r13,	%r13
    jz        L2196
    mov       [%rbp + mc_auxmcl.clearblock.n],	%r13
    mov       %rax,	[%rbp + mc_auxmcl.clearblock.n]
    cmp       %rax,	4
    jl        L2198
    mov       %rcx,	%rdi
    mov       %rdx,	4
    call      mc_libmcl.changeopndsize
    mov       %rdi,	%rax
    mov       %rcx,	[%rbp + mc_auxmcl.clearblock.ax]
    mov       %rdx,	%r14
    mov       %r8,	4
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rax,	4
    sub       [%rbp + mc_auxmcl.clearblock.n],	%rax
    mov       %rax,	4
    add       %r14,	%rax
L2198:
    mov       %rax,	[%rbp + mc_auxmcl.clearblock.n]
    cmp       %rax,	2
    jl        L2200
    mov       %rcx,	%rdi
    mov       %rdx,	2
    call      mc_libmcl.changeopndsize
    mov       %rdi,	%rax
    mov       %rcx,	[%rbp + mc_auxmcl.clearblock.ax]
    mov       %rdx,	%r14
    mov       %r8,	2
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rax,	2
    sub       [%rbp + mc_auxmcl.clearblock.n],	%rax
    mov       %rax,	2
    add       %r14,	%rax
L2200:
    mov       %rax,	[%rbp + mc_auxmcl.clearblock.n]
    cmp       %rax,	1
    jnz       L2202
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      mc_libmcl.changeopndsize
    mov       %rdi,	%rax
    mov       %rcx,	[%rbp + mc_auxmcl.clearblock.ax]
    mov       %rdx,	%r14
    mov       %r8,	1
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
L2202:
L2196:
#---------------
    add       %rsp,	64
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_blockdata
mc_auxmcl.do_blockdata:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r14,	%rcx
#---------------
#PROC3
#PROC4
    mov       %eax,	[%r14+4]
    mov       %rbx,	%rax
    test      %rbx,	%rbx
    jnz       L2205
    jmp       L2203
L2205:
    mov       %rax,	%rbx
    sar       %rax,	3
    mov       %rsi,	%rax
    mov       %rdi,	[%r14+8]
    mov       %r13,	%rsi
    cmp       %r13,	0
    jle       L2208
L2206:
    mov       %rax,	%rdi
    add       %rdi,	8
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	119
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    dec       %r13
    jnz       L2206
L2208:
    mov       %rax,	%rsi
    shl       %rax,	3
    mov       %r10,	%rbx
    sub       %r10,	%rax
    mov       %r12,	%r10
    test      %r12,	%r12
    jz        L2210
    mov       %rcx,	%rdi
    mov       %rdx,	%r12
    mov       %r8,	66
    call      mc_auxmcl.genstring_db
L2210:
    lea       %rcx,	[%rip+L8567]
    call      mc_libmcl.mgencomment
L2203:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.copyblock
mc_auxmcl.copyblock:
#PROC1
#PROC2
#?>>
    .set mc_auxmcl.copyblock.n, 88
    .set mc_auxmcl.copyblock.savedest, 96
    .set mc_auxmcl.copyblock.oddbytes, -8
    .set mc_auxmcl.copyblock.offset, -16
    .set mc_auxmcl.copyblock.axreg, -24
    .set mc_auxmcl.copyblock.saved, -32
    .set mc_auxmcl.copyblock.av_1, -40
    .set mc_auxmcl.copyblock.$T1, -48
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	88
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       [%rbp+88],	%r8
    mov       [%rbp+96],	%r9
#---------------
#PROC3
#PROC4
    xor       %eax,	%eax
    mov       [%rbp + mc_auxmcl.copyblock.saved],	%al
    mov       %rax,	[%rbp + mc_auxmcl.copyblock.n]
    cmp       %rax,	16
    jnz       L2213
    mov       %rcx,	2
    call      mc_stackmcl.getworkregm
    mov       %rdi,	%rax
    mov       %rcx,	91
    mov       %rdx,	%rdi
    mov       %r8,	%r14
    call      mc_libmcl.genmc
    mov       %rcx,	91
    mov       %rdx,	%r13
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    jmp       L2211
L2213:
    mov       %rax,	[%rbp + mc_auxmcl.copyblock.n]
    mov       %r10,	8
    cqo       
    idiv      %r10
    xchg      %rax,	%rdx
    mov       [%rbp + mc_auxmcl.copyblock.oddbytes],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.copyblock.oddbytes]
    sub       [%rbp + mc_auxmcl.copyblock.n],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.copyblock.n]
    sar       %rax,	3
    mov       %rsi,	%rax
    mov       %rcx,	6
    call      mc_stackmcl.getworkregm
    mov       %rdi,	%rax
    xor       %eax,	%eax
    mov       [%rbp + mc_auxmcl.copyblock.offset],	%rax
    mov       %rax,	%rsi
    cmp       %rax,	1
    jl        L2215
    cmp       %rax,	4
    jg        L2215
    mov       %rcx,	%r13
    mov       %rdx,	8
    call      mc_libmcl.changeopndsize
    mov       %r13,	%rax
    mov       %rcx,	%r14
    mov       %rdx,	8
    call      mc_libmcl.changeopndsize
    mov       %r14,	%rax
    mov       [%rbp + mc_auxmcl.copyblock.av_1],	%rsi
    mov       %rax,	[%rbp + mc_auxmcl.copyblock.av_1]
    cmp       %rax,	0
    jle       L2218
L2216:
    mov       %rcx,	%r14
    mov       %rdx,	[%rbp + mc_auxmcl.copyblock.offset]
    xor       %r8d,	%r8d
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + mc_auxmcl.copyblock.offset]
    xor       %r8d,	%r8d
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rax,	8
    add       [%rbp + mc_auxmcl.copyblock.offset],	%rax
    dec       qword ptr[%rbp + mc_auxmcl.copyblock.av_1]
    jnz       L2216
L2218:
    jmp       L2214
L2215:
    test      %rsi,	%rsi
    jz        L2219
    mov       %rcx,	6
    call      mc_stackmcl.getworkregm
    mov       %rbx,	%rax
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %r12,	[%rip+pc_api.mlabelno]
    mov       %rax,	[%rbp + mc_auxmcl.copyblock.savedest]
    test      %rax,	%rax
    jz        L2221
    movzx     %rax,	byte ptr[%r13+10]
    mov       [%rbp + mc_auxmcl.copyblock.axreg],	%rax
    mov       %rcx,	[%rbp + mc_auxmcl.copyblock.axreg]
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	12
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %al,	1
    mov       [%rbp + mc_auxmcl.copyblock.saved],	%al
L2221:
    mov       %rcx,	%r13
    call      mc_stackmcl.makesimpleaddr
    mov       %r13,	%rax
    mov       %rcx,	%r14
    call      mc_stackmcl.makesimpleaddr
    mov       %r14,	%rax
    lea       %rax,	[%r13+8]
    mov       %r10w,	8
    mov       %r15w,	[%rax]
    mov       %r11,	-32
    and       %r15w,	%r11w
    or        %r15w,	%r10w
    mov       [%rax],	%r15w
    mov       %rcx,	%rsi
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	%r12
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%r14
    call      mc_libmcl.genmc
    mov       %rcx,	11
    mov       %rdx,	%r13
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rcx,	8
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       [%rbp + mc_auxmcl.copyblock.$T1],	%rax
    movzx     %rax,	byte ptr[%r13+10]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	28
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.copyblock.$T1]
    call      mc_libmcl.genmc
    mov       %rcx,	8
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       [%rbp + mc_auxmcl.copyblock.$T1],	%rax
    movzx     %rax,	byte ptr[%r14+10]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	28
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.copyblock.$T1]
    call      mc_libmcl.genmc
    mov       %rcx,	53
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	%r12
    call      mc_libmcl.mgenlabel
    mov       %rcx,	26
    mov       %rdx,	5
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    xor       %eax,	%eax
    mov       [%rbp + mc_auxmcl.copyblock.offset],	%rax
L2219:
L2214:
    mov       %rax,	[%rbp + mc_auxmcl.copyblock.oddbytes]
    test      %rax,	%rax
    jz        L2223
    mov       %rax,	[%rbp + mc_auxmcl.copyblock.oddbytes]
    mov       [%rbp + mc_auxmcl.copyblock.n],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.copyblock.n]
    cmp       %rax,	4
    jl        L2225
    mov       %rcx,	%rdi
    mov       %rdx,	4
    call      mc_libmcl.changeopndsize
    mov       %rdi,	%rax
    mov       %rcx,	%r14
    mov       %rdx,	[%rbp + mc_auxmcl.copyblock.offset]
    mov       %r8,	4
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + mc_auxmcl.copyblock.offset]
    mov       %r8,	4
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rax,	4
    sub       [%rbp + mc_auxmcl.copyblock.n],	%rax
    mov       %rax,	4
    add       [%rbp + mc_auxmcl.copyblock.offset],	%rax
L2225:
    mov       %rax,	[%rbp + mc_auxmcl.copyblock.n]
    cmp       %rax,	2
    jl        L2227
    mov       %rcx,	%rdi
    mov       %rdx,	2
    call      mc_libmcl.changeopndsize
    mov       %rdi,	%rax
    mov       %rcx,	%r14
    mov       %rdx,	[%rbp + mc_auxmcl.copyblock.offset]
    mov       %r8,	2
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + mc_auxmcl.copyblock.offset]
    mov       %r8,	2
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rax,	2
    sub       [%rbp + mc_auxmcl.copyblock.n],	%rax
    mov       %rax,	2
    add       [%rbp + mc_auxmcl.copyblock.offset],	%rax
L2227:
    mov       %rax,	[%rbp + mc_auxmcl.copyblock.n]
    cmp       %rax,	1
    jnz       L2229
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      mc_libmcl.changeopndsize
    mov       %rdi,	%rax
    mov       %rcx,	%r14
    mov       %rdx,	[%rbp + mc_auxmcl.copyblock.offset]
    mov       %r8,	1
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + mc_auxmcl.copyblock.offset]
    mov       %r8,	1
    call      mc_libmcl.applyoffset
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
L2229:
L2223:
    mov       %al,	[%rbp + mc_auxmcl.copyblock.saved]
    test      %al,	%al
    jz        L2231
    mov       %rcx,	[%rbp + mc_auxmcl.copyblock.axreg]
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	13
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L2231:
L2211:
#---------------
    add       %rsp,	88
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.genstringtable
mc_auxmcl.genstringtable:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+mc_decls.cstringlist]
    test      %rax,	%rax
    jz        L2232
L2234:
    lea       %rcx,	[%rip+L8568]
    call      mc_libmcl.mgencomment
    mov       %rcx,	73
    mov       %rdx,	8
    call      mc_libmcl.setsegment
    mov       %rax,	[%rip+mc_decls.kk0used]
    test      %rax,	%rax
    jz        L2236
    mov       %rcx,	[%rip+mc_decls.kk0used]
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    xor       %ecx,	%ecx
    call      mc_auxmcl.gendb
L2236:
    mov       %rdi,	[%rip+mc_decls.cstringlist]
    jmp       L2240
L2237:
    mov       %rax,	[%rdi+16]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rax,	[%rdi]
    mov       %rcx,	%rax
    mov       %rdx,	-1
    xor       %r8d,	%r8d
    call      mc_auxmcl.genstring_db
    mov       %rdi,	[%rdi+8]
L2240:
    test      %rdi,	%rdi
    jnz       L2237
L2232:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.genstring_db
mc_auxmcl.genstring_db:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       %r15,	%r8
#---------------
#PROC3
#PROC4
    cmp       %r14,	-1
    jnz       L2243
    mov       %rcx,	%r13
    call      strlen
    mov       %r14,	%rax
L2243:
    test      %r14,	%r14
    jnz       L2245
    xor       %ecx,	%ecx
    call      mc_auxmcl.gendb
    jmp       L2241
L2245:
    xor       %rbx,	%rbx
    mov       %rax,	%r14
    mov       %r12,	%rax
    cmp       %r12,	0
    jle       L2248
L2246:
    mov       %rax,	%r13
    inc       %r13
    movzx     %rax,	byte ptr[%rax]
    mov       %rdi,	%rax
    cmp       %rdi,	32
    jl        L2251
    cmp       %rdi,	127
    jge       L2251
    mov       %rax,	%rdi
    cmp       %rax,	34
    jz        L2252
    cmp       %rax,	92
    jnz       L2250
L2252:
L2251:
    test      %rbx,	%rbx
    jz        L2254
    mov       %rcx,	%rsi
    mov       %rdx,	%rbx
    call      mc_auxmcl.gendbstring
    xor       %rbx,	%rbx
L2254:
    mov       %rcx,	%rdi
    call      mc_auxmcl.gendb
    jmp       L2249
L2250:
    test      %rbx,	%rbx
    jnz       L2256
    mov       %rbx,	1
    lea       %rax,	[%r13-1]
    mov       %rsi,	%rax
    jmp       L2255
L2256:
    inc       %rbx
L2255:
L2249:
    dec       %r12
    jnz       L2246
L2248:
    test      %rbx,	%rbx
    jz        L2258
    mov       %rcx,	%rsi
    mov       %rdx,	%rbx
    call      mc_auxmcl.gendbstring
L2258:
    test      %r15,	%r15
    jnz       L2260
    xor       %ecx,	%ecx
    call      mc_auxmcl.gendb
L2260:
L2241:
#---------------
    add       %rsp,	48
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.gendb
mc_auxmcl.gendb:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	116
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.gendbstring
mc_auxmcl.gendbstring:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mc_libmcl.mgenstring
    mov       %rcx,	120
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.gendq
mc_auxmcl.gendq:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	119
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.genrealtable
mc_auxmcl.genrealtable:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+mc_decls.creallist]
    test      %rax,	%rax
    jnz       L2266
    mov       %rax,	[%rip+mc_decls.cr32list]
    test      %rax,	%rax
    jz        L2264
L2266:
    lea       %rcx,	[%rip+L8569]
    call      mc_libmcl.mgencomment
    mov       %rcx,	73
    mov       %rdx,	8
    call      mc_libmcl.setsegment
    mov       %rdi,	[%rip+mc_decls.creallist]
    jmp       L2270
L2267:
    mov       %rax,	[%rdi+16]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    movq      %XMM4,	[%rdi]
    comisd    %XMM4,	[%rip+L8570]
    jnz       L2272
    movq      %XMM4,	[%rdi]
    movq      %rax,	%XMM4
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	119
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L2271
L2272:
    movq      %XMM4,	[%rdi]
    movq      %rax,	%XMM4
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	119
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L2271:
    mov       %rdi,	[%rdi+8]
L2270:
    test      %rdi,	%rdi
    jnz       L2267
    lea       %rcx,	[%rip+L8571]
    call      mc_libmcl.mgencomment
    mov       %rdi,	[%rip+mc_decls.cr32list]
    jmp       L2276
L2273:
    mov       %rax,	[%rdi+16]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    movq      %XMM4,	[%rdi]
    comisd    %XMM4,	[%rip+L8572]
    jnz       L2278
    movq      %XMM4,	[%rdi]
    cvtsd2ss  %XMM4,	%XMM4
    movd      %eax,	%XMM4
    mov       %ecx,	%eax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	118
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L2277
L2278:
    movq      %XMM4,	[%rdi]
    movq      %XMM0,	%XMM4
    mov       %rdx,	1
    call      mc_libmcl.mgenrealimm
    mov       %rcx,	118
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L2277:
    mov       %rdi,	[%rdi+8]
L2276:
    test      %rdi,	%rdi
    jnz       L2273
L2264:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.genabsneg
mc_auxmcl.genabsneg:
#PROC1
#PROC2
#?>>
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+mc_decls.lababs32]
    add       %rax,	[%rip+mc_decls.lababs64]
    add       %rax,	[%rip+mc_decls.labneg32]
    add       %rax,	[%rip+mc_decls.labneg64]
    test      %rax,	%rax
    jz        L2281
    mov       %rcx,	73
    mov       %rdx,	16
    call      mc_libmcl.setsegment
L2281:
    mov       %rax,	[%rip+mc_decls.lababs32]
    test      %rax,	%rax
    jz        L2283
    lea       %rcx,	[%rip+L8573]
    call      mc_libmcl.mgencomment
    mov       %rcx,	[%rip+mc_decls.lababs32]
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	9223372034707292159
    call      mc_auxmcl.gendq
    mov       %rcx,	9223372034707292159
    call      mc_auxmcl.gendq
L2283:
    mov       %rax,	[%rip+mc_decls.lababs64]
    test      %rax,	%rax
    jz        L2285
    lea       %rcx,	[%rip+L8574]
    call      mc_libmcl.mgencomment
    mov       %rcx,	[%rip+mc_decls.lababs64]
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	9223372036854775807
    call      mc_auxmcl.gendq
    mov       %rcx,	9223372036854775807
    call      mc_auxmcl.gendq
L2285:
    mov       %rax,	[%rip+mc_decls.labneg32]
    test      %rax,	%rax
    jz        L2287
    lea       %rcx,	[%rip+L8575]
    call      mc_libmcl.mgencomment
    mov       %rcx,	[%rip+mc_decls.labneg32]
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	-9223372034707292160
    call      mc_auxmcl.gendq
    mov       %rcx,	-9223372034707292160
    call      mc_auxmcl.gendq
L2287:
    mov       %rax,	[%rip+mc_decls.labneg64]
    test      %rax,	%rax
    jz        L2289
    lea       %rcx,	[%rip+L8576]
    call      mc_libmcl.mgencomment
    mov       %rcx,	[%rip+mc_decls.labneg64]
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	-9223372036854775808
    call      mc_auxmcl.gendq
    mov       %rcx,	-9223372036854775808
    call      mc_auxmcl.gendq
L2289:
    mov       %rax,	[%rip+mc_decls.labzero]
    test      %rax,	%rax
    jz        L2291
    lea       %rcx,	[%rip+L8577]
    call      mc_libmcl.mgencomment
    mov       %rcx,	[%rip+mc_decls.labzero]
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    xor       %ecx,	%ecx
    call      mc_auxmcl.gendq
L2291:
    mov       %rax,	[%rip+mc_decls.labmask63]
    test      %rax,	%rax
    jz        L2293
    lea       %rcx,	[%rip+L8578]
    call      mc_libmcl.mgencomment
    mov       %rcx,	[%rip+mc_decls.labmask63]
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	9223372036854775807
    call      mc_auxmcl.gendq
    mov       %rcx,	[%rip+mc_decls.laboffset64]
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	4890909195324358656
    call      mc_auxmcl.gendq
L2293:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_auxmcl.do_maths
mc_auxmcl.do_maths:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    mov       %r9,	%rsi
    call      mc_auxmcl.do_callrts
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_host
mc_auxmcl.do_host:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    mov       %r8,	%rbx
    mov       %r9,	%rsi
    call      mc_auxmcl.do_callrts
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_callrts
mc_auxmcl.do_callrts:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
    mov       %r14,	%r9
#---------------
#PROC3
#PROC4
    mov       %rcx,	%r14
    call      mc_stackmcl.saveopnds
    xor       %rdi,	%rdi
    mov       %eax,	[%rip+mc_decls.mstackdepth]
    and       %eax,	1
    test      %rax,	%rax
    jz        L2298
    mov       %rcx,	1
    call      mc_libmcl.pushslots
    mov       %rdi,	1
L2298:
    mov       %rcx,	%r14
    xor       %edx,	%edx
    xor       %r8d,	%r8d
    call      mc_auxmcl.do_pushlowargs
    mov       %rax,	[%rip+mc_decls.mstackdepth]
    test      %rax,	%rax
    jz        L2300
    mov       %rax,	4
    add       %rdi,	%rax
    mov       %rcx,	4
    call      mc_libmcl.pushslots
    jmp       L2299
L2300:
    mov       %al,	1
    mov       [%rip+pc_decls.localshadow],	%al
L2299:
    test      %r12,	%r12
    jz        L2302
    mov       %rcx,	%r12
    call      mc_libmcl.mgenextname
    mov       %rcx,	21
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    jmp       L2301
L2302:
    mov       %rcx,	%r13
    call      mc_libmcl.mgenmemaddr
    mov       %rcx,	21
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L2301:
    mov       %rbx,	%r14
    cmp       %rbx,	0
    jle       L2305
L2303:
    call      mc_stackmcl.poppcl
    dec       %rbx
    jnz       L2303
L2305:
    test      %rdi,	%rdi
    jz        L2307
    mov       %rcx,	%rdi
    call      mc_libmcl.popslots
L2307:
    mov       %rcx,	%rsi
    call      mc_auxmcl.do_getretvalue
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_max_int
mc_auxmcl.do_max_int:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    mov       %rcx,	42
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    mov       %rcx,	15
    mov       %rdx,	%rsi
    mov       %r8,	%rdi
    mov       %r9,	%rbx
    call      mc_libmcl.genmc_cond
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_max_float
mc_auxmcl.do_max_float:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    mov       %rcx,	%rsi
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_maxto_int
mc_auxmcl.do_maxto_int:
#PROC1
#PROC2
#?>>
    .set mc_auxmcl.do_maxto_int.mode, 64
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    mov       %rcx,	42
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %r12,	[%rip+pc_api.mlabelno]
    mov       %rcx,	%r12
    call      mc_libmcl.mgenlabel
    mov       %r10,	%rax
    mov       %rsi,	%r10
    mov       %rcx,	26
    mov       %rdx,	%r13
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    mov       %rcx,	9
    mov       %rdx,	%rsi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_maxto_real
mc_auxmcl.do_maxto_real:
#PROC1
#PROC2
#?>>
    .set mc_auxmcl.do_maxto_real.mode, 72
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	32
    mov       %r14,	%rcx
    mov       [%rbp+72],	%rdx
#---------------
#PROC3
#PROC4
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	[%rbp + mc_auxmcl.do_maxto_real.mode]
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_auxmcl.do_maxto_real.mode]
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rsi,	%rax
    mov       %rcx,	[%rbp + mc_auxmcl.do_maxto_real.mode]
    xor       %edx,	%edx
    call      mc_stackmcl.pushpcl_reg
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rbx,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rax,	[%rbp + mc_auxmcl.do_maxto_real.mode]
    dec       %rax
    mov       %r10,	73
    add       %r10,	%rax
    mov       %rcx,	%r10
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %r13,	[%rip+pc_api.mlabelno]
    mov       %rcx,	%r13
    call      mc_libmcl.mgenlabel
    mov       %r10,	%rax
    mov       %r12,	%r10
    mov       %rcx,	26
    mov       %rdx,	%r14
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      mc_libmcl.genmc_cond
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rsi
    call      mc_libmcl.genmc
    mov       %rcx,	9
    mov       %rdx,	%r12
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	32
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_negreal
mc_auxmcl.do_negreal:
#PROC1
#PROC2
#?>>
    .set mc_auxmcl.do_negreal.mode, 32
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    dec       %rax
    test      %rax,	%rax
    jz        L2314
    mov       %rax,	[%rip+mc_decls.labneg64]
    test      %rax,	%rax
    jnz       L2316
    call      mc_libmcl.mcreatefwdlabel
    mov       [%rip+mc_decls.labneg64],	%rax
L2316:
    mov       %rcx,	[%rip+mc_decls.labneg64]
    call      mc_libmcl.mgenlabelmem
    mov       %rcx,	77
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L2313
L2314:
    mov       %rax,	[%rip+mc_decls.labneg32]
    test      %rax,	%rax
    jnz       L2318
    call      mc_libmcl.mcreatefwdlabel
    mov       [%rip+mc_decls.labneg32],	%rax
L2318:
    mov       %rcx,	[%rip+mc_decls.labneg32]
    call      mc_libmcl.mgenlabelmem
    mov       %rcx,	76
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2313:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_absreal
mc_auxmcl.do_absreal:
#PROC1
#PROC2
#?>>
    .set mc_auxmcl.do_absreal.mode, 32
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    dec       %rax
    test      %rax,	%rax
    jz        L2321
    mov       %rax,	[%rip+mc_decls.lababs64]
    test      %rax,	%rax
    jnz       L2323
    call      mc_libmcl.mcreatefwdlabel
    mov       [%rip+mc_decls.lababs64],	%rax
L2323:
    mov       %rcx,	[%rip+mc_decls.lababs64]
    call      mc_libmcl.mgenlabelmem
    mov       %rcx,	79
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L2320
L2321:
    mov       %rax,	[%rip+mc_decls.lababs32]
    test      %rax,	%rax
    jnz       L2325
    call      mc_libmcl.mcreatefwdlabel
    mov       [%rip+mc_decls.lababs32],	%rax
L2325:
    mov       %rcx,	[%rip+mc_decls.lababs32]
    call      mc_libmcl.mgenlabelmem
    mov       %rcx,	78
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2320:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_loadbf_const
mc_auxmcl.do_loadbf_const:
#PROC1
#PROC2
#?>>
    .set mc_auxmcl.do_loadbf_const.p, 56
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    sub       %r10,	2
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    cmp       %r13,	63
    jnz       L2328
    mov       %rcx,	%r12
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	44
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L2327
L2328:
    test      %r12,	%r12
    jz        L2330
    mov       %rcx,	%r12
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	45
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2330:
    mov       %rax,	%r13
    sub       %rax,	%r12
    inc       %rax
    mov       %r10,	-1
    mov       %cl,	%al
    shl       %r10,	%cl
    not       %r10
    mov       %rsi,	%r10
    cmp       %rsi,	2147483647
    ja        L2332
    mov       %rcx,	%rsi
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	38
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L2331
L2332:
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    mov       %rcx,	%rsi
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	38
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L2331:
L2327:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_loadbf_var
mc_auxmcl.do_loadbf_var:
#PROC1
#PROC2
#?>>
    .set mc_auxmcl.do_loadbf_var.p, 16
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    lea       %rcx,	[%rip+L8579]
    lea       %rdx,	[%rip+L8580]
    call      pc_api.merror
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_auxmcl.do_storebit
mc_auxmcl.do_storebit:
#PROC1
#PROC2
#?>>
    .set mc_auxmcl.do_storebit.p, 72
    .set mc_auxmcl.do_storebit.offset, -8
    .set mc_auxmcl.do_storebit.mask1s, -16
    .set mc_auxmcl.do_storebit.mask0s, -24
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	56
#---------------
#PROC3
#PROC4
    mov       %rcx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.isimmload
    mov       %r13,	%rax
    mov       %rax,	[%rip+mc_decls.noperands]
    sub       %rax,	2
    mov       %rcx,	%rax
    call      mc_stackmcl.isimmload
    mov       %r14,	%rax
    test      %r13,	%r13
    jz        L2336
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	3
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    mov       %r15,	[%r13+8]
    mov       %rax,	%r15
    sar       %rax,	3
    mov       [%rbp + mc_auxmcl.do_storebit.offset],	%rax
    mov       %rax,	7
    and       %r15,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	[%rbp + mc_auxmcl.do_storebit.offset]
    xor       %r8d,	%r8d
    call      mc_libmcl.applyoffset
    mov       %rdi,	%rax
    mov       %rax,	1
    mov       %cl,	%r15b
    shl       %rax,	%cl
    mov       [%rbp + mc_auxmcl.do_storebit.mask0s],	%al
    mov       %rax,	1
    mov       %cl,	%r15b
    shl       %rax,	%cl
    not       %rax
    mov       [%rbp + mc_auxmcl.do_storebit.mask1s],	%al
    test      %r14,	%r14
    jz        L2338
    mov       %rax,	[%r14+8]
    test      %rax,	%rax
    jnz       L2340
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    movzx     %r10,	byte ptr[%rbp + mc_auxmcl.do_storebit.mask1s]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_libmcl.mgenint
    mov       %rcx,	38
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L2339
L2340:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    movzx     %r10,	byte ptr[%rbp + mc_auxmcl.do_storebit.mask0s]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_libmcl.mgenint
    mov       %rcx,	39
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2339:
    jmp       L2337
L2338:
    mov       %rax,	[%rip+mc_decls.noperands]
    sub       %rax,	2
    mov       %rcx,	%rax
    mov       %rdx,	3
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rbx,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    movzx     %r10,	byte ptr[%rbp + mc_auxmcl.do_storebit.mask1s]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_libmcl.mgenint
    mov       %rcx,	38
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    test      %r15,	%r15
    jz        L2342
    mov       %rcx,	%r15
    mov       %rdx,	3
    call      mc_libmcl.mgenint
    mov       %rcx,	43
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2342:
    mov       %rcx,	39
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L2337:
    jmp       L2335
L2336:
    test      %r14,	%r14
    jz        L2343
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    dec       %r10
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    test      %r13,	%r13
    jnz       L2345
    mov       %rcx,	6
    call      mc_stackmcl.getworkregm
    mov       %rbx,	%rax
    mov       %rcx,	1
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	11
    mov       %rdx,	6
    call      mc_libmcl.mgenreg
    mov       %rsi,	%rax
    mov       %al,	[%rip+pc_decls.r10used]
    test      %al,	%al
    jz        L2347
    mov       %rcx,	12
    mov       %rdx,	%rsi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L2347:
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	10
    mov       %r8,	11
    call      mc_stackmcl.loadparam
    mov       %r12,	%rax
    mov       %rcx,	%rsi
    mov       %rdx,	1
    call      mc_libmcl.changeopndsize
    mov       %rcx,	43
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %al,	[%rip+pc_decls.r10used]
    test      %al,	%al
    jz        L2349
    mov       %rcx,	13
    mov       %rdx,	%rsi
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L2349:
    mov       %rax,	[%r14+8]
    test      %rax,	%rax
    jnz       L2351
    mov       %rcx,	51
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	38
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
    jmp       L2350
L2351:
    mov       %rcx,	39
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L2350:
    jmp       L2344
L2345:
    lea       %rcx,	[%rip+L8581]
    lea       %rdx,	[%rip+L8582]
    call      pc_api.merror
L2344:
    jmp       L2335
L2343:
    lea       %rcx,	[%rip+L8583]
    lea       %rdx,	[%rip+L8584]
    call      pc_api.merror
L2335:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	56
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.do_storebf
mc_auxmcl.do_storebf:
#PROC1
#PROC2
#?>>
    .set mc_auxmcl.do_storebf.p, 72
    .set mc_auxmcl.do_storebf.r, -8
    .set mc_auxmcl.do_storebf.mask, -16
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	56
    mov       [%rbp+72],	%rcx
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    call      mc_stackmcl.isimmload
    mov       %r15,	%rax
    mov       %rcx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.isimmload
    mov       [%rbp + mc_auxmcl.do_storebf.r],	%rax
    mov       %rax,	[%rbp + mc_auxmcl.do_storebf.r]
    cmp       %rax,	%r15
    jnz       L2354
    test      %rax,	%rax
    jnz       L2354
    lea       %rcx,	[%rip+L8585]
    lea       %rdx,	[%rip+L8586]
    call      pc_api.merror
L2354:
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    sub       %r10,	3
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %r12,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    sub       %r10,	2
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_stackmcl.getopnd_ind
    mov       %rdi,	%rax
    mov       %r13,	[%r15+8]
    mov       %rax,	[%rbp + mc_auxmcl.do_storebf.r]
    mov       %r14,	[%rax+8]
    mov       %rcx,	6
    call      mc_stackmcl.getworkregm
    mov       %rsi,	%rax
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %rcx,	%rax
    call      mc_stackmcl.getworkregm
    mov       %rbx,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rbx
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
    mov       %rax,	%r14
    sub       %rax,	%r13
    inc       %rax
    mov       %r10,	-1
    mov       %cl,	%al
    shl       %r10,	%cl
    not       %r10
    mov       %cl,	%r13b
    shl       %r10,	%cl
    not       %r10
    mov       [%rbp + mc_auxmcl.do_storebf.mask],	%r10
    mov       %rcx,	[%rbp + mc_auxmcl.do_storebf.mask]
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	11
    mov       %rdx,	%rsi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    test      %r13,	%r13
    jz        L2356
    mov       %rcx,	%r13
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	43
    mov       %rdx,	%r12
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2356:
    mov       %rax,	[%rbp + mc_auxmcl.do_storebf.p]
    mov       %eax,	[%rax+4]
    mov       %rcx,	%rsi
    mov       %rdx,	%rax
    call      mc_libmcl.changeopndsize
    mov       %rcx,	38
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	39
    mov       %rdx,	%rbx
    mov       %r8,	%r12
    call      mc_libmcl.genmc
    mov       %rax,	[%rbp + mc_auxmcl.do_storebf.p]
    mov       %eax,	[%rax+4]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      mc_libmcl.changeopndsize
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       %rsp,	56
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.gethostfn
mc_auxmcl.gethostfn:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+pc_api.igethostfn]
    test      %rax,	%rax
    jnz       L2359
    cmp       %r13,	82
    jnz       L2362
L2361:
    lea       %rax,	[%rip+L8587]
    mov       %rbx,	%rax
    lea       %rax,	[%rip+L8588]
    mov       %rsi,	%rax
    jmp       L2360
L2362:
    xor       %rbx,	%rbx
L2360:
    test      %rbx,	%rbx
    jz        L2364
    mov       %r12,	[%rip+pc_decls.psymboltable]
    jmp       L2368
L2365:
    mov       %rax,	[%r12]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      mlib.eqstring
    test      %rax,	%rax
    jnz       L2371
    mov       %rax,	[%r12]
    mov       %rcx,	%rsi
    mov       %rdx,	%rax
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L2370
L2371:
    mov       %rax,	%r12
    jmp       L2357
L2370:
    mov       %r12,	[%r12+8]
L2368:
    test      %r12,	%r12
    jnz       L2365
L2364:
    lea       %rax,	[%rip+pc_tables.pclnames]
    mov       %r10,	%r13
    mov       %rax,	[%rax + %r10*8]
    lea       %rcx,	[%rip+L8589]
    mov       %rdx,	%rax
    call      pc_api.merror
L2359:
    mov       %rcx,	%r13
    mov       %rax,	[%rip+pc_api.igethostfn]
    call      %rax
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L2373
    lea       %rax,	[%rip+pc_tables.pclnames]
    mov       %r10,	%r13
    mov       %rax,	[%rax + %r10*8]
    lea       %rcx,	[%rip+L8590]
    mov       %rdx,	%rax
    call      pc_api.merror
L2373:
    mov       %rax,	%rdi
L2357:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.copyblockarg
mc_auxmcl.copyblockarg:
#PROC1
#PROC2
#?>>
    .set mc_auxmcl.copyblockarg.argno, 72
    .set mc_auxmcl.copyblockarg.$T3, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %r12,	%rcx
    mov       %r13,	%rdx
#---------------
#PROC3
#PROC4
    test      %r12,	%r12
    jnz       L2376
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8591]
    call      msys.m$print_str_nf
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L8592]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L2374
L2376:
    mov       %rcx,	%r13
    call      mc_libmcl.newblocktemp
    mov       %rdi,	%rax
    mov       %al,	1
    mov       [%rdi+92],	%al
    test      %r12,	%r12
    jz        L2378
    mov       %rcx,	6
    call      mc_stackmcl.getworkregm
    mov       %rsi,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      mc_libmcl.genmc
    jmp       L2377
L2378:
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	11
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rsi,	%rax
L2377:
    mov       %rcx,	6
    call      mc_stackmcl.getworkregm
    mov       %rbx,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       %rcx,	14
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    movzx     %rax,	byte ptr[%rsi+10]
    mov       %rcx,	%rax
    mov       %rdx,	10
    xor       %r8d,	%r8d
    call      mc_libmcl.mgenireg
    mov       [%rbp + mc_auxmcl.copyblockarg.$T3],	%rax
    movzx     %rax,	byte ptr[%rbx+10]
    mov       %rcx,	%rax
    mov       %rdx,	10
    xor       %r8d,	%r8d
    call      mc_libmcl.mgenireg
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_auxmcl.copyblockarg.$T3]
    mov       %r8,	%r13
    mov       %r9,	1
    call      mc_auxmcl.copyblock
    test      %r12,	%r12
    jz        L2380
    mov       %rcx,	%rdi
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       %rcx,	14
    mov       %rdx,	%r12
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2380:
    xor       %ecx,	%ecx
    call      mc_stackmcl.freeworkregs
L2374:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_auxmcl.fixmain
mc_auxmcl.fixmain:
#PROC1
#PROC2
#?>>
    .set mc_auxmcl.fixmain.$T1, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    mov       %rdi,	[%rip+pc_decls.currfunc]
    mov       %rbx,	[%rdi+16]
    mov       %rsi,	[%rbx+16]
    lea       %rcx,	[%rip+L8593]
    mov       %rdx,	3
    call      pc_api.pc_makesymbol
    mov       %r12,	%rax
    mov       %al,	6
    mov       [%r12+82],	%al
    mov       %eax,	8
    mov       [%r12+84],	%eax
    lea       %rcx,	[%rip+L8594]
    mov       %rdx,	3
    call      pc_api.pc_makesymbol
    mov       %r13,	%rax
    mov       %al,	11
    mov       [%r13+82],	%al
    mov       %eax,	128
    mov       [%r13+84],	%eax
    mov       %rcx,	90
    mov       %rdx,	8
    call      mc_libmcl.setsegment
    mov       %rcx,	%r13
    call      mc_libmcl.mgenmemaddr
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	128
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	125
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	%r12
    call      mc_libmcl.mgenmemaddr
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	8
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	125
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	67
    mov       %rdx,	1
    call      mc_libmcl.setsegment
    mov       %rcx,	%r12
    call      pc_api.pc_addlocal
    mov       %rcx,	%r13
    call      pc_api.pc_addlocal
    xor       %eax,	%eax
    mov       [%rdi+16],	%rax
    mov       [%rsi+16],	%rax
    mov       [%rbx+16],	%rax
    xor       %eax,	%eax
    mov       [%rdi+112],	%al
    mov       %al,	4
    mov       [%rbx+72],	%al
    mov       %al,	1
    mov       [%rbx+92],	%al
    mov       %al,	4
    mov       [%rsi+72],	%al
    mov       %al,	4
    mov       [%rsi+92],	%al
    mov       %rcx,	%rsi
    call      pc_api.pc_addlocal
    mov       %rcx,	%rbx
    call      pc_api.pc_addlocal
    mov       %rcx,	1
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %r10,	%rax
    mov       %r14,	%r10
    mov       %rcx,	12
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	%r13
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       %rcx,	14
    mov       %rdx,	%r14
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %al,	1
    mov       [%r13+88],	%al
    mov       %rcx,	12
    mov       %rdx,	%r14
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	32
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	29
    mov       %rdx,	[%rip+mc_decls.dstackopnd]
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rcx,	%rbx
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       [%rbp + mc_auxmcl.fixmain.$T1],	%rax
    mov       %rcx,	11
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	14
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.fixmain.$T1]
    call      mc_libmcl.genmc
    mov       %al,	1
    mov       [%rbx+88],	%al
    mov       %rcx,	%rsi
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       [%rbp + mc_auxmcl.fixmain.$T1],	%rax
    mov       %rcx,	12
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	14
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.fixmain.$T1]
    call      mc_libmcl.genmc
    mov       %al,	1
    mov       [%rsi+88],	%al
    mov       %rcx,	%r12
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       [%rbp + mc_auxmcl.fixmain.$T1],	%rax
    mov       %rcx,	13
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	14
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.fixmain.$T1]
    call      mc_libmcl.genmc
    mov       %al,	1
    mov       [%r12+88],	%al
    mov       %rcx,	14
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	%rax
    call      mc_libmcl.clearreg
    lea       %rcx,	[%rip+L8595]
    call      mc_libmcl.mgenextname
    mov       %rcx,	21
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    mov       %rcx,	48
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	29
    mov       %rdx,	[%rip+mc_decls.dstackopnd]
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    mov       %rax,	[%rip+pc_decls.pcmdskip]
    test      %rax,	%rax
    jz        L2383
    mov       %rcx,	[%rip+pc_decls.pcmdskip]
    mov       %rdx,	9
    call      mc_libmcl.mgenint
    mov       [%rbp + mc_auxmcl.fixmain.$T1],	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       %rcx,	29
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.fixmain.$T1]
    call      mc_libmcl.genmc
    mov       %rax,	[%rip+pc_decls.pcmdskip]
    shl       %rax,	3
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       [%rbp + mc_auxmcl.fixmain.$T1],	%rax
    mov       %rcx,	%rsi
    mov       %rdx,	6
    call      mc_libmcl.mgenmem
    mov       %rcx,	28
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_auxmcl.fixmain.$T1]
    call      mc_libmcl.genmc
L2383:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mclinit
mc_libmcl.mclinit:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r14,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rax,	64
    cmp       %rax,	64
    jle       L2386
    lea       %rcx,	[%rip+L8596]
    call      mlib.abortprogram
L2386:
    mov       %rbx,	1
L2387:
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      mc_libmcl.mgenreg0
    lea       %r10,	[%rip+mc_decls.regtable]
    mov       %r11,	%rbx
    shl       %r11,	6
    lea       %r10,	[%r10 + %r11-64]
    mov       [%r10],	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	2
    call      mc_libmcl.mgenreg0
    lea       %r10,	[%rip+mc_decls.regtable]
    mov       %r11,	%rbx
    shl       %r11,	6
    lea       %r10,	[%r10 + %r11-64]
    mov       [%r10+8],	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	4
    call      mc_libmcl.mgenreg0
    lea       %r10,	[%rip+mc_decls.regtable]
    mov       %r11,	%rbx
    shl       %r11,	6
    lea       %r10,	[%r10 + %r11-64]
    mov       [%r10+24],	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	8
    call      mc_libmcl.mgenreg0
    lea       %r10,	[%rip+mc_decls.regtable]
    mov       %r11,	%rbx
    shl       %r11,	6
    lea       %r10,	[%r10 + %r11-64]
    mov       [%r10+56],	%rax
    inc       %rbx
    cmp       %rbx,	16
    jle       L2387
    mov       %r13,	-128
    mov       %rsi,	64
    cmp       %rsi,	-128
    jl        L2392
L2390:
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	3
    mov       %r8w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r8w,	%r11w
    or        %r8w,	%r10w
    mov       [%rax],	%r8w
    mov       %al,	15
    mov       [%rdi+10],	%al
    lea       %rax,	[%rdi+8]
    mov       %r10w,	8
    mov       %r8w,	[%rax]
    mov       %r11,	-32
    and       %r8w,	%r11w
    or        %r8w,	%r10w
    mov       [%rax],	%r8w
    mov       [%rdi+12],	%r13d
    mov       %rax,	%rdi
    lea       %r10,	[%rip+mc_decls.frameregtable]
    mov       %r11,	%r13
    mov       [%r10 + %r11*8+1024],	%rax
    inc       %r13
    cmp       %r13,	%rsi
    jle       L2390
L2392:
    mov       %rcx,	15
    mov       %rdx,	6
    call      mc_libmcl.mgenreg
    mov       [%rip+mc_decls.dframeopnd],	%rax
    mov       %rcx,	16
    mov       %rdx,	6
    call      mc_libmcl.mgenreg
    mov       [%rip+mc_decls.dstackopnd],	%rax
    call      mc_libmcl.initmcdest
    mov       %rcx,	67
    mov       %rdx,	1
    call      mc_libmcl.setsegment
    xor       %eax,	%eax
    mov       [%rip+mc_decls.lab_funcnametable],	%rax
    xor       %eax,	%eax
    mov       [%rip+mc_decls.lab_funcaddrtable],	%rax
    mov       %r13,	-1
    mov       %r12,	10
    cmp       %r12,	-1
    jl        L2395
L2393:
    mov       %rcx,	%r13
    mov       %rdx,	8
    call      mc_libmcl.mgenint0
    lea       %r10,	[%rip+mc_libmcl.smallinttable]
    mov       %r11,	%r13
    mov       [%r10 + %r11*8+8],	%rax
    inc       %r13
    cmp       %r13,	%r12
    jle       L2393
L2395:
    test      %r14,	%r14
    jz        L2397
    mov       %al,	1
    mov       [%rip+pc_decls.mcldone],	%al
L2397:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.initmcdest
mc_libmcl.initmcdest:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    xor       %eax,	%eax
    mov       [%rip+mc_decls.mccodex],	%rax
    mov       [%rip+mc_decls.mccode],	%rax
#---------------
    ret       
# End 
# Proc mc_libmcl.genmc
mc_libmcl.genmc:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
#PROC3
#PROC4
    mov       %rcx,	64
    call      mlib.pcm_allocnfz
    mov       %rdi,	%rax
    mov       [%rdi+33],	%sil
    inc       qword ptr[%rip+mc_libmcl.mclseqno]
    mov       %rax,	[%rip+mc_libmcl.mclseqno]
    mov       [%rdi+36],	%eax
    mov       %eax,	[%rip+pc_decls.mmpos]
    mov       [%rdi+40],	%eax
    mov       [%rdi+16],	%r12
    mov       [%rdi+24],	%r13
    mov       %rax,	%rsi
    cmp       %rax,	14
    jz        L2401
    cmp       %rax,	9
    jz        L2402
    cmp       %rax,	11
    jz        L2403
    jmp       L2404
L2401:
    test      %r13,	%r13
    jz        L2406
    movzx     %rax,	word ptr[%r13+8]
    shr       %rax,	12
    and       %rax,	15
    cmp       %rax,	5
    jnz       L2406
    mov       %rax,	[%r13]
    mov       %r10b,	1
    mov       [%rax+88],	%r10b
L2406:
    jmp       L2400
L2402:
    mov       %rbx,	[%r12]
    jmp       L2400
L2403:
    movzx     %rax,	word ptr[%r12+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	5
    jz        L2409
    test      %r13,	%r13
    jz        L2408
    movzx     %rax,	word ptr[%r13+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	5
    jnz       L2408
L2409:
    movzx     %rax,	word ptr[%r12+8]
    and       %rax,	31
    cmp       %rax,	8
    jnz       L2411
    mov       %rax,	17
    jmp       L2410
L2411:
    mov       %rax,	16
L2410:
    mov       [%rdi+33],	%al
L2408:
L2404:
L2400:
    mov       %rax,	[%rip+mc_decls.mccode]
    test      %rax,	%rax
    jz        L2413
    mov       %rax,	[%rip+mc_decls.mccodex]
    mov       [%rdi],	%rax
    mov       %rax,	%rdi
    mov       %r10,	[%rip+mc_decls.mccodex]
    mov       [%r10+8],	%rax
    mov       [%rip+mc_decls.mccodex],	%rdi
    jmp       L2412
L2413:
    mov       %rax,	%rdi
    mov       [%rip+mc_decls.mccodex],	%rax
    mov       [%rip+mc_decls.mccode],	%rax
L2412:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.genmc_cond
mc_libmcl.genmc_cond:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
    mov       %r12,	%r9
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      mc_libmcl.genmc
    mov       %al,	%bl
    mov       %r10,	[%rip+mc_decls.mccodex]
    mov       [%r10+34],	%al
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.genmc_str
mc_libmcl.genmc_str:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rbx
    mov       %rdx,	-1
    call      mc_libmcl.mgenstring
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.newmclopnd
mc_libmcl.newmclopnd:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    mov       %rcx,	16
    call      mlib.pcm_allocnfz
    mov       %rdi,	%rax
    inc       qword ptr[%rip+mc_libmcl.nmclopnd]
    mov       %rax,	%rdi
L2416:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.duplopnd
mc_libmcl.duplopnd:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	16
    call      mlib.pcm_allocnfz
    mov       %rdi,	%rax
    mov       %rax,	%rbx
    movdqu    %XMM4,	[%rax]
    movdqu    [%rdi],	%XMM4
    mov       %rax,	%rdi
L2417:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenindex
mc_libmcl.mgenindex:
#PROC1
#PROC2
#?>>
    .set mc_libmcl.mgenindex.size, 96
    .set mc_libmcl.mgenindex.labno, 104
    .set mc_libmcl.mgenindex.def, 112
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	32
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
    mov       %r13,	%r9
#---------------
#PROC3
#PROC4
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	3
    mov       %r15w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r15w,	%r11w
    or        %r15w,	%r10w
    mov       [%rax],	%r15w
    mov       [%rdi+10],	%bl
    cmp       %rbx,	15
    jz        L2421
    cmp       %rsi,	15
    jnz       L2420
L2421:
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.usedregs]
    mov       [%r10+14],	%al
L2420:
    mov       [%rdi+11],	%sil
    lea       %rax,	[%rdi+8]
    mov       %r10w,	%r12w
    mov       %r15w,	[%rax]
    mov       %r11,	-481
    shl       %r10w,	5
    and       %r15w,	%r11w
    or        %r15w,	%r10w
    mov       [%rax],	%r15w
    lea       %rax,	[%rdi+8]
    mov       %r10w,	[%rbp + mc_libmcl.mgenindex.size]
    mov       %r15w,	[%rax]
    mov       %r11,	-32
    and       %r15w,	%r11w
    or        %r15w,	%r10w
    mov       [%rax],	%r15w
    mov       [%rdi+12],	%r13d
    mov       %rax,	[%rbp + mc_libmcl.mgenindex.labno]
    test      %rax,	%rax
    jz        L2423
    mov       %rax,	[%rbp + mc_libmcl.mgenindex.labno]
    mov       [%rdi],	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	6
    mov       %r15w,	[%rax]
    mov       %r11,	-61441
    shl       %r10w,	12
    and       %r15w,	%r11w
    or        %r15w,	%r10w
    mov       [%rax],	%r15w
    jmp       L2422
L2423:
    mov       %rax,	[%rbp + mc_libmcl.mgenindex.def]
    test      %rax,	%rax
    jz        L2424
    mov       %rax,	[%rbp + mc_libmcl.mgenindex.def]
    mov       [%rdi],	%rax
    mov       %rax,	[%rbp + mc_libmcl.mgenindex.def]
    lea       %rax,	[%rax+89]
    inc       byte ptr[%rax]
    lea       %rax,	[%rdi+8]
    mov       %r10w,	5
    mov       %r15w,	[%rax]
    mov       %r11,	-61441
    shl       %r10w,	12
    and       %r15w,	%r11w
    or        %r15w,	%r10w
    mov       [%rax],	%r15w
    mov       %rax,	[%rbp + mc_libmcl.mgenindex.def]
    movzx     %rax,	byte ptr[%rax+72]
    cmp       %rax,	4
    jz        L2427
    cmp       %rax,	5
    jnz       L2426
L2427:
    mov       %al,	15
    mov       [%rdi+10],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.usedregs]
    mov       [%r10+14],	%al
L2426:
L2424:
L2422:
    mov       %rax,	%rdi
L2418:
#---------------
    add       %rsp,	32
    pop       %rbp
    pop       %r15
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgencomment
mc_libmcl.mgencomment:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	3
    mov       %rdx,	%rdi
    call      mc_libmcl.genmc_str
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenstring
mc_libmcl.mgenstring:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
#PROC3
#PROC4
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	2
    mov       %r9w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    cmp       %rsi,	0
    jge       L2431
    mov       %rcx,	%rbx
    call      strlen
    mov       %rsi,	%rax
L2431:
    lea       %rax,	[%rsi+1]
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       [%rdi],	%rax
    mov       %rax,	[%rdi]
    mov       %rcx,	%rax
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      memcpy
    mov       %rax,	[%rdi]
    xor       %r10d,	%r10d
    mov       %r11,	%rsi
    mov       [%rax + %r11],	%r10b
    lea       %rax,	[%rdi+8]
    mov       %r10w,	4
    mov       %r9w,	[%rax]
    mov       %r11,	-61441
    shl       %r10w,	12
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    lea       %rax,	[%rdi+8]
    mov       %r10w,	8
    mov       %r9w,	[%rax]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       %rax,	%rdi
L2429:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenname
mc_libmcl.mgenname:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	2
    mov       %r9w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       %rcx,	%rbx
    call      mlib.pcm_copyheapstring
    mov       [%rdi],	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	7
    mov       %r9w,	[%rax]
    mov       %r11,	-61441
    shl       %r10w,	12
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    lea       %rax,	[%rdi+8]
    mov       %r10w,	8
    mov       %r9w,	[%rax]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       %rax,	%rdi
L2432:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.setsegment
mc_libmcl.setsegment:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
#PROC3
#PROC4
    cmp       %rsi,	[%rip+mc_decls.currsegment]
    jz        L2435
    mov       %rax,	%rsi
    cmp       %rax,	73
    jz        L2437
    cmp       %rax,	90
    jz        L2438
    cmp       %rax,	67
    jz        L2439
    cmp       %rax,	82
    jz        L2440
    jmp       L2441
L2437:
    mov       %rdi,	121
    jmp       L2436
L2438:
    mov       %rdi,	122
    jmp       L2436
L2439:
    mov       %rdi,	123
    jmp       L2436
L2440:
    lea       %rcx,	[%rip+L8597]
    lea       %rdx,	[%rip+L8598]
    call      pc_api.merror
    jmp       L2436
L2441:
    lea       %rcx,	[%rip+L8599]
    lea       %rdx,	[%rip+L8600]
    call      pc_api.merror
L2436:
    mov       %rax,	[%rip+mc_decls.mccodex]
    test      %rax,	%rax
    jz        L2443
    mov       %rax,	[%rip+mc_decls.mccodex]
    movzx     %rax,	byte ptr[%rax+33]
    cmp       %rax,	121
    jz        L2444
    cmp       %rax,	122
    jz        L2444
    cmp       %rax,	123
    jnz       L2443
L2444:
    mov       %al,	%dil
    mov       %r10,	[%rip+mc_decls.mccodex]
    mov       [%r10+33],	%al
    jmp       L2442
L2443:
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L2442:
    mov       [%rip+mc_decls.currsegment],	%rsi
L2435:
    cmp       %r12,	1
    jle       L2446
    mov       %rax,	[%rip+mc_decls.mccodex]
    movzx     %rax,	byte ptr[%rax+33]
    cmp       %rax,	124
    jnz       L2448
    mov       %rax,	[%rip+mc_decls.mccodex]
    mov       %rax,	[%rax+16]
    mov       %rbx,	[%rax]
    cmp       %rbx,	%r12
    jge       L2433
L2450:
L2448:
    mov       %rcx,	%r12
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	124
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
L2446:
L2433:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.changeopndsize
mc_libmcl.changeopndsize:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
#PROC3
#PROC4
    movzx     %rax,	word ptr[%rbx+8]
    and       %rax,	31
    cmp       %rax,	%rsi
    jz        L2453
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jnz       L2455
    movzx     %rax,	byte ptr[%rbx+10]
    lea       %r10,	[%rip+mc_decls.regtable]
    mov       %r11,	%rax
    shl       %r11,	6
    lea       %r10,	[%r10 + %r11-64]
    mov       %rax,	%rsi
    mov       %r10,	[%r10 + %rax*8-8]
    mov       %rdi,	%r10
    jmp       L2454
L2455:
    mov       %rcx,	%rbx
    call      mc_libmcl.duplopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	%si
    mov       %r8w,	[%rax]
    mov       %r11,	-32
    and       %r8w,	%r11w
    or        %r8w,	%r10w
    mov       [%rax],	%r8w
L2454:
    mov       %rax,	%rdi
    jmp       L2451
L2453:
    mov       %rax,	%rbx
L2451:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.applyoffset
mc_libmcl.applyoffset:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
#PROC3
#PROC4
    test      %rsi,	%rsi
    jnz       L2458
    test      %r12,	%r12
    jnz       L2458
    mov       %rax,	%rbx
    jmp       L2456
L2458:
    mov       %rcx,	%rbx
    call      mc_libmcl.duplopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+12]
    mov       %r10d,	%esi
    add       [%rax],	%r10d
    test      %r12,	%r12
    jz        L2460
    lea       %rax,	[%rdi+8]
    mov       %r10w,	%r12w
    mov       %r9w,	[%rax]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
L2460:
    mov       %rax,	%rdi
L2456:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenint
mc_libmcl.mgenint:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rip+pc_tables.psize]
    mov       %r10,	%r12
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %rbx,	%rax
    mov       %rax,	%rsi
    cmp       %rax,	-1
    jl        L2463
    cmp       %rax,	10
    jg        L2463
    cmp       %rbx,	8
    jnz       L2463
    lea       %rax,	[%rip+mc_libmcl.smallinttable]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8+8]
    jmp       L2461
L2463:
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	2
    mov       %r9w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       [%rdi],	%rsi
    lea       %rax,	[%rdi+8]
    mov       %r10w,	1
    mov       %r9w,	[%rax]
    mov       %r11,	-61441
    shl       %r10w,	12
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    lea       %rax,	[%rdi+8]
    mov       %r10w,	%bx
    mov       %r9w,	[%rax]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       %rax,	%rdi
L2461:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenint0
mc_libmcl.mgenint0:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
#PROC3
#PROC4
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	2
    mov       %r9w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       [%rdi],	%rbx
    lea       %rax,	[%rdi+8]
    mov       %r10w,	1
    mov       %r9w,	[%rax]
    mov       %r11,	-61441
    shl       %r10w,	12
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    lea       %rax,	[%rdi+8]
    mov       %r10w,	%si
    mov       %r9w,	[%rax]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       %rax,	%rdi
L2464:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenrealmem
mc_libmcl.mgenrealmem:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    movq      %rax,	%XMM15
    push      %rax
#?]]
    sub       %rsp,	48
    movq      %XMM15,	%XMM0
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	3
    mov       %r9w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    lea       %rax,	[%rbx-1]
    test      %rax,	%rax
    jz        L2467
    movq      %XMM0,	%XMM15
    call      mc_libmcl.getrealindex
    mov       [%rdi],	%rax
    jmp       L2466
L2467:
    movq      %XMM0,	%XMM15
    call      mc_libmcl.getr32index
    mov       [%rdi],	%rax
L2466:
    lea       %rax,	[%rdi+8]
    mov       %r10w,	6
    mov       %r9w,	[%rax]
    mov       %r11,	-61441
    shl       %r10w,	12
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    lea       %rax,	[%rip+pc_tables.psize]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10]
    lea       %r10,	[%rdi+8]
    mov       %r9w,	[%r10]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%ax
    mov       [%r10],	%r9w
    mov       %rax,	%rdi
L2465:
#---------------
    add       %rsp,	48
    pop       %rcx
    movq      %XMM15,	%rcx
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenrealimm
mc_libmcl.mgenrealimm:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    movq      %rax,	%XMM15
    push      %rax
#?]]
    sub       %rsp,	48
    movq      %XMM15,	%XMM0
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	2
    mov       %r9w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    movq      %XMM4,	%XMM15
    movq      [%rdi],	%XMM4
    lea       %rax,	[%rdi+8]
    mov       %r10w,	2
    mov       %r9w,	[%rax]
    mov       %r11,	-61441
    shl       %r10w,	12
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    lea       %rax,	[%rip+pc_tables.psize]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10]
    lea       %r10,	[%rdi+8]
    mov       %r9w,	[%r10]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%ax
    mov       [%r10],	%r9w
    mov       %rax,	%rdi
L2468:
#---------------
    add       %rsp,	48
    pop       %rcx
    movq      %XMM15,	%rcx
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenlabel
mc_libmcl.mgenlabel:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	2
    mov       %r9w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    test      %rbx,	%rbx
    jnz       L2471
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rbx,	[%rip+pc_api.mlabelno]
L2471:
    mov       [%rdi],	%rbx
    lea       %rax,	[%rdi+8]
    mov       %r10w,	6
    mov       %r9w,	[%rax]
    mov       %r11,	-61441
    shl       %r10w,	12
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       %rax,	%rdi
L2469:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenlabelmem
mc_libmcl.mgenlabelmem:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rbx
    call      mc_libmcl.mgenlabel
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	3
    mov       %r9w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       %rax,	%rdi
L2472:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenmem
mc_libmcl.mgenmem:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
#PROC3
#PROC4
    mov       %al,	[%rsi+90]
    test      %al,	%al
    jz        L2475
    movzx     %rax,	byte ptr[%rsi+82]
    lea       %r10,	[%rip+pc_tables.pfloat]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L2477
    mov       %rcx,	%rsi
    call      mc_libmcl.mgenxregvar
    jmp       L2473
L2477:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    call      mc_libmcl.mgenregvar
    jmp       L2473
L2476:
L2475:
    xor       %rbx,	%rbx
    movzx     %rax,	byte ptr[%rsi+72]
    cmp       %rax,	4
    jz        L2480
    cmp       %rax,	5
    jnz       L2479
L2480:
    mov       %rbx,	15
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.usedregs]
    mov       [%r10+14],	%al
L2479:
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	3
    mov       %r9w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       [%rdi+10],	%bl
    mov       [%rdi],	%rsi
    lea       %rax,	[%rsi+89]
    inc       byte ptr[%rax]
    lea       %rax,	[%rdi+8]
    mov       %r10w,	5
    mov       %r9w,	[%rax]
    mov       %r11,	-61441
    shl       %r10w,	12
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    test      %r12,	%r12
    jz        L2482
    lea       %rax,	[%rip+pc_tables.psize]
    mov       %r10,	%r12
    movzx     %rax,	byte ptr[%rax + %r10]
    lea       %r10,	[%rdi+8]
    mov       %r9w,	[%r10]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%ax
    mov       [%r10],	%r9w
    jmp       L2481
L2482:
    mov       %eax,	[%rsi+84]
    mov       %r10,	8
    cmp       %rax,	%r10
    cmova     %rax,	%r10
    lea       %r10,	[%rdi+8]
    mov       %r9w,	[%r10]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%ax
    mov       [%r10],	%r9w
L2481:
    mov       %rax,	%rdi
L2473:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenmemaddr
mc_libmcl.mgenmemaddr:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    mov       %al,	1
    mov       [%rbx+88],	%al
    lea       %rax,	[%rbx+89]
    inc       byte ptr[%rax]
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	2
    mov       %r9w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       [%rdi],	%rbx
    lea       %rax,	[%rbx+89]
    inc       byte ptr[%rax]
    lea       %rax,	[%rdi+8]
    mov       %r10w,	5
    mov       %r9w,	[%rax]
    mov       %r11,	-61441
    shl       %r10w,	12
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    lea       %rax,	[%rdi+8]
    mov       %r10w,	8
    mov       %r9w,	[%rax]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       %rax,	%rdi
L2483:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenreg0
mc_libmcl.mgenreg0:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
#PROC3
#PROC4
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	1
    mov       %r9w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       [%rdi+10],	%bl
    lea       %rax,	[%rdi+8]
    mov       %r10w,	%si
    mov       %r9w,	[%rax]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    test      %rsi,	%rsi
    jnz       L2486
    lea       %rcx,	[%rip+L8601]
    lea       %rdx,	[%rip+L8602]
    call      pc_api.merror
L2486:
    mov       %rax,	%rdi
L2484:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenxreg
mc_libmcl.mgenxreg:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
#PROC3
#PROC4
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	5
    mov       %r9w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       [%rdi+10],	%bl
    lea       %rax,	[%rdi+8]
    mov       %r10w,	%si
    mov       %r9w,	[%rax]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    test      %rsi,	%rsi
    jnz       L2489
    lea       %rcx,	[%rip+L8603]
    lea       %rdx,	[%rip+L8604]
    call      pc_api.merror
L2489:
    mov       %rax,	%rdi
L2487:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenreg
mc_libmcl.mgenreg:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rip+pc_tables.psize]
    mov       %r10,	%r12
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %rbx,	%rax
    cmp       %r12,	2
    jg        L2492
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	5
    mov       %r8w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r8w,	%r11w
    or        %r8w,	%r10w
    mov       [%rax],	%r8w
    mov       [%rdi+10],	%sil
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.usedxregs]
    mov       %r11,	%rsi
    mov       [%r10 + %r11-1],	%al
    lea       %rax,	[%rip+pc_tables.psize]
    mov       %r10,	%r12
    movzx     %rax,	byte ptr[%rax + %r10]
    lea       %r10,	[%rdi+8]
    mov       %r8w,	[%r10]
    mov       %r11,	-32
    and       %r8w,	%r11w
    or        %r8w,	%ax
    mov       [%r10],	%r8w
    mov       %rax,	%rdi
    jmp       L2491
L2492:
    test      %rbx,	%rbx
    jnz       L2494
    mov       %rbx,	8
L2494:
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.usedregs]
    mov       %r11,	%rsi
    mov       [%r10 + %r11-1],	%al
    mov       %rax,	%rsi
    cmp       %rax,	11
    jl        L2496
    cmp       %rax,	14
    jg        L2496
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.regset]
    mov       %r11,	%rsi
    mov       [%r10 + %r11-1],	%al
L2496:
    lea       %rax,	[%rip+mc_decls.regtable]
    mov       %r10,	%rsi
    shl       %r10,	6
    lea       %rax,	[%rax + %r10-64]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8-8]
    jmp       L2490
    mov       %rcx,	%rsi
    mov       %rdx,	%rbx
    call      mc_libmcl.mgenreg0
L2491:
L2490:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenregi
mc_libmcl.mgenregi:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rip+mc_decls.regtable]
    mov       %r10,	%rdi
    shl       %r10,	6
    lea       %rax,	[%rax + %r10-64]
    lea       %r10,	[%rip+pc_tables.psize]
    mov       %r11,	%rbx
    movzx     %r10,	byte ptr[%r10 + %r11]
    mov       %rax,	[%rax + %r10*8-8]
    jmp       L2497
    lea       %rax,	[%rip+pc_tables.psize]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mc_libmcl.mgenreg0
L2497:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenireg
mc_libmcl.mgenireg:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
#PROC3
#PROC4
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	3
    mov       %r9w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       [%rdi+10],	%bl
    lea       %rax,	[%rip+pc_tables.psize]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10]
    lea       %r10,	[%rdi+8]
    mov       %r9w,	[%r10]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%ax
    mov       [%r10],	%r9w
    mov       [%rdi+12],	%r12d
    mov       %rax,	%rdi
L2498:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgentemp
mc_libmcl.mgentemp:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rip+mc_decls.pcltempflags]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L2501
    lea       %rax,	[%rip+pc_tables.psize]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10]
    lea       %r10,	[%rip+mc_decls.pcltempopnds]
    mov       %r11,	%rbx
    mov       %r10,	[%r10 + %r11*8-8]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_libmcl.changeopndsize
    jmp       L2499
L2501:
    call      mc_libmcl.newmclopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rdi+8]
    mov       %r10w,	3
    mov       %r9w,	[%rax]
    mov       %r11,	-3585
    shl       %r10w,	9
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    mov       %al,	15
    mov       [%rdi+10],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.usedregs]
    mov       [%r10+14],	%al
    lea       %rax,	[%rdi+8]
    mov       %r10w,	8
    mov       %r9w,	[%rax]
    mov       %r11,	-61441
    shl       %r10w,	12
    and       %r9w,	%r11w
    or        %r9w,	%r10w
    mov       [%rax],	%r9w
    lea       %rax,	[%rip+pc_tables.psize]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10]
    lea       %r10,	[%rdi+8]
    mov       %r9w,	[%r10]
    mov       %r11,	-32
    and       %r9w,	%r11w
    or        %r9w,	%ax
    mov       [%r10],	%r9w
    mov       [%rdi],	%rbx
    mov       %rax,	%rdi
    lea       %r10,	[%rip+mc_decls.pcltempopnds]
    mov       %r11,	%rbx
    mov       [%r10 + %r11*8-8],	%rax
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.pcltempflags]
    mov       %r11,	%rbx
    mov       [%r10 + %r11-1],	%al
    mov       %rax,	%rdi
L2499:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.roundsizetg
mc_libmcl.roundsizetg:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       %rax,	%rcx
    and       %rax,	7
    jnz       L2504
    mov       %rax,	%rcx
    jmp       L2502
L2504:
    mov       %rax,	%rcx
    and       %rax,	7
    mov       %r10,	8
    sub       %r10,	%rax
    mov       %rax,	%rcx
    add       %rax,	%r10
L2502:
#---------------
    ret       
# End 
# Proc mc_libmcl.merroropnd
mc_libmcl.merroropnd:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8605]
    call      msys.m$print_setfmt
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+pc_tables.opndnames]
    mov       %r10,	%rbx
    mov       %rcx,	[%rax + %r10*8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	1
    call      exit
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mcreatefwdlabel
mc_libmcl.mcreatefwdlabel:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rax,	[%rip+pc_api.mlabelno]
L2506:
#---------------
    ret       
# End 
# Proc mc_libmcl.mdefinefwdlabel
mc_libmcl.mdefinefwdlabel:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    call      mc_libmcl.mgenlabel
    mov       %rcx,	9
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenextname
mc_libmcl.mgenextname:
#PROC1
#PROC2
#?>>
    .set mc_libmcl.mgenextname.str, -64
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	96
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    lea       %rcx,	[%rbp + mc_libmcl.mgenextname.str]
    mov       %rdx,	%rbx
    call      strcpy
    mov       %rcx,	%rbx
    call      strlen
    xor       %r10d,	%r10d
    mov       [%rbp + %rax + mc_libmcl.mgenextname.str-1],	%r10b
    lea       %rcx,	[%rbp + mc_libmcl.mgenextname.str]
    call      mc_libmcl.findnamesym
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L2510
    mov       %rcx,	128
    call      mlib.pcm_allocnfz
    mov       %rdi,	%rax
    lea       %rcx,	[%rbp + mc_libmcl.mgenextname.str]
    call      mlib.pcm_copyheapstring
    mov       [%rdi],	%rax
    mov       %al,	1
    mov       [%rdi+72],	%al
    mov       %al,	1
    mov       [%rdi+80],	%al
    mov       %rcx,	%rdi
    call      mc_libmcl.addnamesym
L2510:
    mov       %rcx,	%rdi
    call      mc_libmcl.mgenmemaddr
L2508:
#---------------
    add       %rsp,	96
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenregvar
mc_libmcl.mgenregvar:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rbx+90]
    mov       %rcx,	%rax
    mov       %rdx,	%rsi
    call      mc_libmcl.mgenreg
    mov       %rdi,	%rax
    mov       %rax,	%rdi
L2511:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.mgenxregvar
mc_libmcl.mgenxregvar:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rbx+90]
    mov       %rcx,	%rax
    mov       %rdx,	8
    call      mc_libmcl.mgenxreg
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%rbx+90]
    mov       %r10b,	1
    lea       %r11,	[%rip+mc_decls.isxregvar]
    mov       [%r11 + %rax-1],	%r10b
    mov       %rax,	%rdi
L2512:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.getprimreg
mc_libmcl.getprimreg:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       %al,	[%rcx+10]
    test      %al,	%al
    jz        L2515
    movzx     %rax,	byte ptr[%rcx+10]
    jmp       L2514
L2515:
    movzx     %rax,	byte ptr[%rcx+11]
L2514:
L2513:
#---------------
    ret       
# End 
# Proc mc_libmcl.pushslots
mc_libmcl.pushslots:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rax,	%rdi
    shl       %rax,	3
    mov       %rcx,	%rax
    call      mc_libmcl.pushstack
    mov       %rax,	%rdi
    add       [%rip+mc_decls.mstackdepth],	%rax
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.popslots
mc_libmcl.popslots:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rax,	%rdi
    shl       %rax,	3
    mov       %rcx,	%rax
    call      mc_libmcl.popstack
    mov       %rax,	%rdi
    sub       [%rip+mc_decls.mstackdepth],	%rax
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.pushstack
mc_libmcl.pushstack:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    test      %rdi,	%rdi
    jz        L2520
    mov       %rcx,	%rdi
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	29
    mov       %rdx,	[%rip+mc_decls.dstackopnd]
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2520:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.popstack
mc_libmcl.popstack:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    test      %rdi,	%rdi
    jz        L2523
    mov       %rcx,	%rdi
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rcx,	28
    mov       %rdx,	[%rip+mc_decls.dstackopnd]
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2523:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.getstringindex
mc_libmcl.getstringindex:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    test      %rdi,	%rdi
    jnz       L2526
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rax,	[%rip+pc_api.mlabelno]
    mov       [%rip+mc_decls.kk0used],	%rax
    mov       %rax,	[%rip+mc_decls.kk0used]
    jmp       L2524
L2526:
    mov       %rax,	[%rip+mc_decls.cstringlist]
    test      %rax,	%rax
    jz        L2528
    mov       %rax,	[%rip+mc_decls.cstringlist]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L2528
    mov       %rax,	[%rip+mc_decls.cstringlist]
    mov       %rax,	[%rax+16]
    jmp       L2524
L2528:
    lea       %rcx,	[%rip+mc_decls.cstringlist]
    mov       %rdx,	%rdi
    call      mc_libmcl.addconst
L2524:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.addconst
mc_libmcl.addconst:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
#PROC3
#PROC4
    mov       %rcx,	24
    call      mlib.pcm_allocnfz
    mov       %rdi,	%rax
    mov       [%rdi],	%rsi
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rax,	[%rip+pc_api.mlabelno]
    mov       [%rdi+16],	%rax
    mov       %rax,	[%rbx]
    mov       [%rdi+8],	%rax
    mov       [%rbx],	%rdi
    mov       %rax,	[%rip+pc_api.mlabelno]
L2529:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.getrealindex
mc_libmcl.getrealindex:
#PROC1
#PROC2
#?>>
    movq      %rax,	%XMM15
    push      %rax
#?]]
    sub       %rsp,	48
    movq      %XMM15,	%XMM0
#---------------
#PROC3
#PROC4
    movq      %XMM4,	%XMM15
    movq      %rax,	%XMM4
    lea       %rcx,	[%rip+mc_decls.creallist]
    mov       %rdx,	%rax
    call      mc_libmcl.addconst
L2530:
#---------------
    add       %rsp,	48
    pop       %rcx
    movq      %XMM15,	%rcx
    ret       
# End 
# Proc mc_libmcl.getr32index
mc_libmcl.getr32index:
#PROC1
#PROC2
#?>>
    movq      %rax,	%XMM15
    push      %rax
#?]]
    sub       %rsp,	48
    movq      %XMM15,	%XMM0
#---------------
#PROC3
#PROC4
    movq      %XMM4,	%XMM15
    movq      %rax,	%XMM4
    lea       %rcx,	[%rip+mc_decls.cr32list]
    mov       %rdx,	%rax
    call      mc_libmcl.addconst
L2531:
#---------------
    add       %rsp,	48
    pop       %rcx
    movq      %XMM15,	%rcx
    ret       
# End 
# Proc mc_libmcl.ispoweroftwo
mc_libmcl.ispoweroftwo:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	16
#---------------
#PROC3
#PROC4
    mov       %rdi,	1
    xor       %rbx,	%rbx
    mov       %rax,	60
    mov       %rsi,	%rax
L2533:
    inc       %rbx
    mov       %rax,	%rdi
    shl       %rax,	1
    mov       %rdi,	%rax
    cmp       %rdi,	%rcx
    jnz       L2537
    mov       %rax,	%rbx
    jmp       L2532
L2537:
    dec       %rsi
    jnz       L2533
    xor       %eax,	%eax
L2532:
#---------------
    add       %rsp,	16
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.axerror
mc_libmcl.axerror:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8606]
    call      msys.m$print_str_nf
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L8607]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+mc_decls.aapos]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	1
    call      exit
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.newblocktemp
mc_libmcl.newblocktemp:
#PROC1
#PROC2
#?>>
    .set mc_libmcl.newblocktemp.str, -16
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+mc_decls.nblocktemps]
    cmp       %rax,	50
    jle       L2541
    lea       %rcx,	[%rip+L8608]
    lea       %rdx,	[%rip+L8609]
    call      pc_api.merror
L2541:
    inc       qword ptr[%rip+mc_decls.nblocktemps]
    lea       %rcx,	[%rbp + mc_libmcl.newblocktemp.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8610]
    call      msys.m$print_setfmt
    mov       %rcx,	[%rip+mc_decls.nblocktemps]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + mc_libmcl.newblocktemp.str]
    mov       %rdx,	8
    call      pc_api.pc_makesymbol
    mov       %rdi,	%rax
    mov       %al,	11
    mov       [%rdi+82],	%al
    mov       [%rdi+84],	%ebx
    mov       %al,	1
    mov       [%rdi+92],	%al
    mov       %al,	4
    mov       [%rdi+72],	%al
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       %rax,	[%rax+24]
    mov       [%rdi+24],	%rax
    mov       %rax,	[%rip+pc_decls.currfunc]
    mov       [%rdi+32],	%rax
    mov       %rax,	%rdi
    mov       %r10,	[%rip+pc_decls.currfunc]
    mov       [%r10+24],	%rax
    mov       %rax,	%rdi
    lea       %r10,	[%rip+mc_decls.blockdefs]
    mov       %r11,	[%rip+mc_decls.nblocktemps]
    mov       [%r10 + %r11*8-8],	%rax
    mov       %rax,	%rdi
L2539:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.findnamesym
mc_libmcl.findnamesym:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rdi,	1
    mov       %rax,	[%rip+mc_libmcl.nnametable]
    cmp       %rax,	1
    jl        L2545
L2543:
    lea       %rax,	[%rip+mc_libmcl.nametable]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rax,	[%rax]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L2547
    lea       %rax,	[%rip+mc_libmcl.nametable]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    jmp       L2542
L2547:
    inc       %rdi
    cmp       %rdi,	[%rip+mc_libmcl.nnametable]
    jle       L2543
L2545:
    xor       %eax,	%eax
L2542:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.addnamesym
mc_libmcl.addnamesym:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+mc_libmcl.nnametable]
    cmp       %rax,	20
    jge       L2550
    inc       qword ptr[%rip+mc_libmcl.nnametable]
    mov       %rax,	[%rip+mc_libmcl.nnametable]
    mov       %r10,	%rdi
    lea       %r11,	[%rip+mc_libmcl.nametable]
    mov       [%r11 + %rax*8-8],	%r10
    jmp       L2549
L2550:
    lea       %rcx,	[%rip+L8611]
    lea       %rdx,	[%rip+L8612]
    call      pc_api.merror
L2549:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.callproc
mc_libmcl.callproc:
#PROC1
#PROC2
#?>>
    .set mc_libmcl.callproc.cpname, 16
    .set mc_libmcl.callproc.name, 24
    .set mc_libmcl.callproc.lineno, 32
#?]]
#---------------
#PROC3
#PROC4
L2551:
#---------------
    ret       
# End 
# Proc mc_libmcl.mgenstringx
mc_libmcl.mgenstringx:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    call      mc_libmcl.getstringindex
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabelmem
L2552:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_libmcl.clearreg
mc_libmcl.clearreg:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    movzx     %rax,	word ptr[%rdi+8]
    and       %rax,	31
    cmp       %rax,	8
    jnz       L2555
    mov       %rcx,	%rdi
    mov       %rdx,	4
    call      mc_libmcl.changeopndsize
    mov       %rdi,	%rax
L2555:
    mov       %rcx,	40
    mov       %rdx,	%rdi
    mov       %r8,	%rdi
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.getopnd
mc_stackmcl.getopnd:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       %r15,	%r8
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	%r13
    mov       %rsi,	[%rax + %r10*8-8]
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%r13
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	1
    jz        L2558
    cmp       %rax,	2
    jz        L2558
    cmp       %rax,	3
    jz        L2559
    jmp       L2560
L2558:
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%r13
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rcx,	%rax
    mov       %rdx,	%r14
    call      mc_libmcl.mgenreg
    jmp       L2556
L2559:
    mov       %rcx,	%r13
    mov       %rdx,	%r14
    call      mc_libmcl.mgentemp
    mov       %rbx,	%rax
    mov       %rax,	%rbx
    jmp       L2556
L2560:
L2557:
    movzx     %rax,	byte ptr[%rsi+1]
    cmp       %rax,	1
    jz        L2562
    cmp       %rax,	2
    jz        L2563
    cmp       %rax,	4
    jz        L2564
    cmp       %rax,	5
    jz        L2565
    cmp       %rax,	6
    jz        L2565
    cmp       %rax,	7
    jz        L2566
    cmp       %rax,	3
    jz        L2567
    jmp       L2568
L2562:
    mov       %r12,	[%rsi+8]
    cmp       %r14,	11
    jnz       L2570
    movzx     %rax,	byte ptr[%r12+72]
    cmp       %rax,	5
    jz        L2570
    mov       %r14,	6
    jmp       L2563
L2570:
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    mov       %rdx,	%r14
    call      mc_libmcl.mgenmem
    mov       %rdi,	%rax
L2569:
    jmp       L2561
L2563:
    mov       %r12,	[%rsi+8]
    movzx     %rax,	byte ptr[%r12+72]
    cmp       %rax,	5
    jnz       L2572
    movzx     %rax,	byte ptr[%r12+82]
    cmp       %rax,	11
    jnz       L2572
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    mov       %rdx,	%r14
    call      mc_libmcl.mgenmem
    mov       %rdi,	%rax
    jmp       L2571
L2572:
    mov       %rcx,	%r15
    mov       %rdx,	%r14
    call      mc_stackmcl.getworkreg_rm
    mov       %rdi,	%rax
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    mov       %rdx,	%r14
    call      mc_libmcl.mgenmem
    mov       %rcx,	14
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
L2571:
    jmp       L2561
L2564:
    lea       %rax,	[%rip+pc_tables.psize]
    mov       %r10,	%r14
    movzx     %rax,	byte ptr[%rax + %r10]
    cmp       %rax,	2
    jz        L2574
    cmp       %rax,	4
    jz        L2575
    jmp       L2576
L2574:
    lea       %rax,	[%rsi+8]
    mov       %r10,	65535
    and       [%rax],	%r10
    jmp       L2573
L2575:
    lea       %rax,	[%rsi+8]
    mov       %r10,	4294967295
    and       [%rax],	%r10
L2576:
L2573:
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    mov       %rdx,	%r14
    call      mc_libmcl.mgenint
    mov       %rbx,	%rax
    mov       %rax,	[%rsi+8]
    cmp       %rax,	-2147483648
    jl        L2578
    cmp       %rax,	2147483647
    jg        L2578
    mov       %rdi,	%rbx
    jmp       L2577
L2578:
    mov       %rcx,	%r15
    mov       %rdx,	%r14
    call      mc_stackmcl.getworkreg_rm
    mov       %rdi,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L2577:
    jmp       L2561
L2565:
    movq      %XMM4,	[%rsi+8]
    movq      %XMM0,	%XMM4
    mov       %rdx,	%r14
    call      mc_libmcl.mgenrealmem
    mov       %rdi,	%rax
    jmp       L2561
L2566:
    mov       %rcx,	%r15
    mov       %rdx,	%r14
    call      mc_stackmcl.getworkreg_rm
    mov       %rdi,	%rax
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    call      mc_libmcl.getstringindex
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabelmem
    mov       %rcx,	14
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L2561
L2567:
    mov       %rcx,	%r15
    mov       %rdx,	%r14
    call      mc_stackmcl.getworkreg_rm
    mov       %rdi,	%rax
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    call      mc_libmcl.mgenlabelmem
    mov       %rcx,	14
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      mc_libmcl.genmc
    jmp       L2561
L2568:
#mc_stackmcl.getopnd.error:
    movzx     %rax,	byte ptr[%rsi+1]
    lea       %r10,	[%rip+pc_tables.opndnames]
    mov       %r10,	[%r10 + %rax*8]
    lea       %rcx,	[%rip+L8613]
    mov       %rdx,	%r10
    call      pc_api.merror
L2561:
    mov       %rax,	%rdi
L2556:
#---------------
    add       %rsp,	48
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.loadopnd
mc_stackmcl.loadopnd:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      mc_stackmcl.getopnd
    mov       %rdi,	%rax
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	2
    jnz       L2582
    test      %r12,	%r12
    jnz       L2584
    mov       %rcx,	%rsi
    call      mc_stackmcl.getworkreg
    mov       %r12,	%rax
L2584:
L2582:
    mov       %rcx,	%rdi
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      mc_stackmcl.loadtoreg
    mov       %rdi,	%rax
    xor       %eax,	%eax
    lea       %r10,	[%rip+mc_decls.pclopnd]
    mov       %r11,	%rbx
    mov       [%r10 + %r11*8-8],	%rax
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.pclloc]
    mov       %r11,	%rbx
    mov       [%r10 + %r11-1],	%al
    mov       %al,	[%rdi+10]
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	%rbx
    mov       [%r10 + %r11-1],	%al
    mov       %rax,	%rdi
L2580:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.loadparam
mc_stackmcl.loadparam:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      mc_stackmcl.getopnd
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      mc_stackmcl.loadtoreg_m
    mov       %rdi,	%rax
    mov       %rax,	%rdi
L2585:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.pushopnd
mc_stackmcl.pushopnd:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r12,	%rcx
    mov       %r13,	%rdx
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	%r12
    mov       %rsi,	[%rax + %r10*8-8]
    test      %r13,	%r13
    jnz       L2588
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	%r12
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %r13,	%rax
L2588:
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%r12
    movzx     %rax,	byte ptr[%rax + %r10-1]
    test      %rax,	%rax
    jnz       L2590
    movzx     %rax,	byte ptr[%rsi+1]
    cmp       %rax,	1
    jz        L2592
    cmp       %rax,	4
    jz        L2593
    cmp       %rax,	5
    jz        L2594
    jmp       L2595
L2592:
    lea       %rax,	[%rip+pc_tables.psize]
    mov       %r10,	%r13
    movzx     %rax,	byte ptr[%rax + %r10]
    cmp       %rax,	8
    jnz       L2597
    movzx     %rax,	byte ptr[%rip+mc_decls.pmode]
    mov       %r10,	[%rsi+8]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_libmcl.mgenmem
    mov       %rdi,	%rax
    jmp       L2598
L2597:
    jmp       L2591
L2593:
    mov       %rax,	[%rsi+8]
    cmp       %rax,	-2147483648
    jl        L2600
    cmp       %rax,	2147483647
    jg        L2600
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    mov       %rdx,	10
    call      mc_libmcl.mgenint
    mov       %rdi,	%rax
    jmp       L2598
L2600:
    jmp       L2591
L2594:
    movq      %XMM4,	[%rsi+8]
    movq      %XMM0,	%XMM4
    mov       %rdx,	2
    call      mc_libmcl.mgenrealmem
    mov       %rdi,	%rax
    jmp       L2598
L2595:
L2591:
L2590:
    mov       %rcx,	%r12
    mov       %rdx,	%r13
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rdi,	%rax
    movzx     %rax,	word ptr[%rdi+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	5
    jnz       L2602
    mov       %rbx,	%rdi
    cmp       %r13,	4
    jnz       L2604
    mov       %rax,	5
    jmp       L2603
L2604:
    mov       %rax,	6
L2603:
    mov       %rcx,	%rax
    call      mc_stackmcl.getworkregm
    mov       %rdi,	%rax
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L2602:
#mc_stackmcl.pushopnd.pushit:
L2598:
    mov       %rcx,	%rdi
    mov       %rdx,	8
    call      mc_libmcl.changeopndsize
    mov       %rcx,	12
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    inc       qword ptr[%rip+mc_decls.mstackdepth]
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.loadtoreg
mc_stackmcl.loadtoreg:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
#PROC3
#PROC4
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jz        L2608
    cmp       %rax,	5
    jnz       L2607
L2608:
    test      %r12,	%r12
    jz        L2611
    movzx     %rax,	byte ptr[%rbx+10]
    cmp       %rax,	%r12
    jnz       L2610
L2611:
    mov       %rax,	%rbx
    jmp       L2605
L2610:
L2607:
    mov       %rcx,	%r12
    mov       %rdx,	%rsi
    call      mc_stackmcl.getworkreg_rm
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mc_stackmcl.loadtoreg_common
    mov       %rax,	%rdi
L2605:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.loadtoreg_m
mc_stackmcl.loadtoreg_m:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
#PROC3
#PROC4
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jz        L2615
    cmp       %rax,	5
    jnz       L2614
L2615:
    movzx     %rax,	byte ptr[%rbx+10]
    cmp       %rax,	%r12
    jnz       L2617
    mov       %rax,	%rbx
    jmp       L2612
L2617:
L2614:
    mov       %rcx,	%r12
    mov       %rdx,	%rsi
    call      mc_libmcl.mgenreg
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mc_stackmcl.loadtoreg_common
    mov       %rax,	%rdi
L2612:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.loadtoreg_common
mc_stackmcl.loadtoreg_common:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	2
    jnz       L2620
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	12
    and       %rax,	15
    cmp       %rax,	1
    jnz       L2620
    mov       %rax,	[%rbx]
    test      %rax,	%rax
    jnz       L2620
    mov       %rcx,	%rdi
    mov       %rdx,	4
    call      mc_libmcl.changeopndsize
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    call      mc_libmcl.clearreg
    jmp       L2619
L2620:
    mov       %rcx,	11
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_libmcl.genmc
L2619:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.pushpcl
mc_stackmcl.pushpcl:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+mc_decls.noperands]
    cmp       %rax,	50
    jl        L2623
    lea       %rcx,	[%rip+L8614]
    lea       %rdx,	[%rip+L8615]
    call      pc_api.merror
L2623:
    inc       qword ptr[%rip+mc_decls.noperands]
    mov       %rdi,	[%rip+mc_decls.noperands]
    xor       %eax,	%eax
    lea       %r10,	[%rip+mc_decls.pclloc]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    mov       %rax,	%rbx
    lea       %r10,	[%rip+mc_decls.pclopnd]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*8-8],	%rax
    xor       %eax,	%eax
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.pclcount]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    mov       %al,	[%rbx+3]
    lea       %r10,	[%rip+mc_decls.pclmode]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    movzx     %rax,	byte ptr[%rbx+1]
    cmp       %rax,	1
    jnz       L2625
    mov       %rax,	[%rbx+8]
    mov       %al,	[%rax+90]
    test      %al,	%al
    jz        L2625
    mov       %rax,	[%rbx+8]
    mov       %al,	[%rax+90]
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    mov       %al,	2
    lea       %r10,	[%rip+mc_decls.pclloc]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
L2625:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.pushpcl_reg
mc_stackmcl.pushpcl_reg:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+mc_decls.noperands]
    cmp       %rax,	50
    jl        L2628
    lea       %rcx,	[%rip+L8616]
    lea       %rdx,	[%rip+L8617]
    call      pc_api.merror
L2628:
    test      %rsi,	%rsi
    jnz       L2630
    mov       %rcx,	%rbx
    call      mc_stackmcl.getworkreg
    mov       %rsi,	%rax
L2630:
    inc       qword ptr[%rip+mc_decls.noperands]
    mov       %rdi,	[%rip+mc_decls.noperands]
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.pclloc]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+mc_decls.pclopnd]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*8-8],	%rax
    mov       %al,	%sil
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.pclcount]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    mov       %al,	%bl
    lea       %r10,	[%rip+mc_decls.pclmode]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    cmp       %rbx,	2
    jg        L2632
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.xregset]
    mov       %r11,	%rsi
    mov       [%r10 + %r11-1],	%al
    jmp       L2631
L2632:
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.regset]
    mov       %r11,	%rsi
    mov       [%r10 + %r11-1],	%al
L2631:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.poppcl
mc_stackmcl.poppcl:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    mov       %rdi,	[%rip+mc_decls.noperands]
    cmp       %rdi,	0
    jg        L2635
    lea       %rcx,	[%rip+L8618]
    lea       %rdx,	[%rip+L8619]
    call      pc_api.merror
L2635:
    lea       %rax,	[%rip+mc_decls.pclcount]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	1
    jle       L2637
    lea       %rax,	[%rip+mc_decls.pclcount]
    mov       %r10,	%rdi
    lea       %rax,	[%rax + %r10-1]
    dec       byte ptr[%rax]
    jmp       L2633
L2637:
    dec       qword ptr[%rip+mc_decls.noperands]
L2633:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.duplpcl
mc_stackmcl.duplpcl:
#PROC1
#PROC2
#?>>
    .set mc_stackmcl.duplpcl.$T1, -8
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rdi,	%rax
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rdi
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      mc_stackmcl.pushpcl_reg
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       [%rbp + mc_stackmcl.duplpcl.$T1],	%rax
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rdi
    xor       %r8d,	%r8d
    call      mc_stackmcl.getopnd
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_stackmcl.duplpcl.$T1]
    call      mc_libmcl.genmc
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.getworkireg
mc_stackmcl.getworkireg:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    mov       %rbx,	10
L2640:
    mov       %rdi,	1
L2643:
    lea       %rax,	[%rip+mc_decls.workregs]
    mov       %r10,	%rdi
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L2647
    lea       %rax,	[%rip+mc_decls.regset]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    test      %rax,	%rax
    jnz       L2647
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.regset]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    mov       %rax,	%rdi
    jmp       L2639
L2647:
    inc       %rdi
    cmp       %rdi,	14
    jle       L2643
    call      mc_stackmcl.savenextopnd
    dec       %rbx
    jnz       L2640
    lea       %rcx,	[%rip+L8620]
    lea       %rdx,	[%rip+L8621]
    call      pc_api.merror
    xor       %eax,	%eax
L2639:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.getworkxreg
mc_stackmcl.getworkxreg:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    mov       %rdi,	5
L2649:
    lea       %rax,	[%rip+mc_decls.workxregs]
    mov       %r10,	%rdi
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L2653
    lea       %rax,	[%rip+mc_decls.xregset]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    test      %rax,	%rax
    jnz       L2653
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.xregset]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    mov       %rax,	%rdi
    jmp       L2648
L2653:
    inc       %rdi
    cmp       %rdi,	16
    jle       L2649
    lea       %rcx,	[%rip+L8622]
    lea       %rdx,	[%rip+L8623]
    call      pc_api.merror
    xor       %eax,	%eax
L2648:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.getworkregm
mc_stackmcl.getworkregm:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    call      mc_stackmcl.getworkreg
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    call      mc_libmcl.mgenreg
L2654:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.getworkreg
mc_stackmcl.getworkreg:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    cmp       %rdi,	2
    jg        L2657
    call      mc_stackmcl.getworkxreg
    jmp       L2656
L2657:
    call      mc_stackmcl.getworkireg
L2656:
L2655:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.getworkreg_rm
mc_stackmcl.getworkreg_rm:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    mov       %rax,	%rdi
    test      %rax,	%rax
    jz        L2661
    cmp       %rax,	15
    jnz       L2660
L2661:
    mov       %rcx,	%rbx
    call      mc_stackmcl.getworkregm
    jmp       L2658
L2660:
    cmp       %rbx,	2
    jle       L2665
    lea       %rax,	[%rip+mc_decls.isregvar]
    mov       %r10,	%rdi
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jnz       L2664
L2665:
    lea       %rax,	[%rip+mc_decls.isxregvar]
    mov       %r10,	%rdi
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L2663
L2664:
    mov       %rcx,	%rbx
    call      mc_stackmcl.getworkregm
    jmp       L2658
L2663:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mc_libmcl.mgenreg
L2658:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.saveopnd
mc_stackmcl.saveopnd:
#PROC1
#PROC2
#?>>
    .set mc_stackmcl.saveopnd.$T1, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	1
    jnz       L2666
L2668:
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rdi,	%rax
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rbx,	%rax
    cmp       %rbx,	2
    jle       L2670
    test      %r12,	%r12
    jnz       L2673
    mov       %rax,	%rdi
    cmp       %rax,	4
    jl        L2674
    cmp       %rax,	10
    jle       L2672
L2674:
L2673:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mc_libmcl.mgenreg
    mov       [%rbp + mc_stackmcl.saveopnd.$T1],	%rax
    mov       %rcx,	%rsi
    mov       %rdx,	%rbx
    call      mc_libmcl.mgentemp
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_stackmcl.saveopnd.$T1]
    call      mc_libmcl.genmc
L2672:
    xor       %eax,	%eax
    lea       %r10,	[%rip+mc_decls.regset]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    jmp       L2669
L2670:
    test      %r12,	%r12
    jnz       L2677
    mov       %rax,	%rdi
    cmp       %rax,	1
    jl        L2676
    cmp       %rax,	6
    jg        L2676
L2677:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mc_libmcl.mgenxreg
    mov       [%rbp + mc_stackmcl.saveopnd.$T1],	%rax
    mov       %rcx,	%rsi
    mov       %rdx,	%rbx
    call      mc_libmcl.mgentemp
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_stackmcl.saveopnd.$T1]
    call      mc_libmcl.genmc
L2676:
    xor       %eax,	%eax
    lea       %r10,	[%rip+mc_decls.xregset]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
L2669:
    mov       %al,	3
    lea       %r10,	[%rip+mc_decls.pclloc]
    mov       %r11,	%rsi
    mov       [%r10 + %r11-1],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	%rsi
    mov       [%r10 + %r11-1],	%al
L2666:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.saveopnds
mc_stackmcl.saveopnds:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rbx,	1
    mov       %rax,	[%rip+mc_decls.noperands]
    sub       %rax,	%rsi
    mov       %rdi,	%rax
    cmp       %rdi,	1
    jl        L2681
L2679:
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      mc_stackmcl.saveopnd
    inc       %rbx
    cmp       %rbx,	%rdi
    jle       L2679
L2681:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.savenextopnd
mc_stackmcl.savenextopnd:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    mov       %rdi,	1
    mov       %rax,	[%rip+mc_decls.noperands]
    cmp       %rax,	1
    jl        L2685
L2683:
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	1
    jnz       L2687
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	2
    jle       L2687
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      mc_stackmcl.saveopnd
    jmp       L2682
L2687:
    inc       %rdi
    cmp       %rdi,	[%rip+mc_decls.noperands]
    jle       L2683
L2685:
L2682:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.savenextxopnd
mc_stackmcl.savenextxopnd:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    mov       %rdi,	1
    mov       %rax,	[%rip+mc_decls.noperands]
    cmp       %rax,	1
    jl        L2691
L2689:
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	1
    jnz       L2693
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	2
    jg        L2693
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      mc_stackmcl.saveopnd
    jmp       L2688
L2693:
    inc       %rdi
    cmp       %rdi,	[%rip+mc_decls.noperands]
    jle       L2689
L2691:
L2688:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.movetoreg
mc_stackmcl.movetoreg:
#PROC1
#PROC2
#?>>
    .set mc_stackmcl.movetoreg.$T1, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %r12,	%rcx
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rbx,	%rax
    mov       %rcx,	[%rip+mc_decls.noperands]
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
#mc_stackmcl.movetoreg.retry:
L2695:
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rdi,	%rax
    cmp       %rdi,	%r12
    jz        L2694
L2697:
    cmp       %rbx,	2
    jg        L2699
    lea       %rax,	[%rip+mc_decls.xregset]
    mov       %r10,	%r12
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L2701
    lea       %rcx,	[%rip+L8624]
    lea       %rdx,	[%rip+L8625]
    call      pc_api.merror
L2701:
    jmp       L2698
L2699:
    lea       %rax,	[%rip+mc_decls.regset]
    mov       %r10,	%r12
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L2703
    mov       %rsi,	1
    mov       %rax,	[%rip+mc_decls.noperands]
    cmp       %rax,	1
    jl        L2706
L2704:
    cmp       %rbx,	2
    jle       L2708
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	%r12
    jnz       L2708
    mov       %rcx,	%rsi
    mov       %rdx,	[%rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    mov       %rcx,	%r12
    mov       %rdx,	6
    call      mc_libmcl.mgenreg
    mov       [%rbp + mc_stackmcl.movetoreg.$T1],	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	6
    call      mc_libmcl.mgenreg
    mov       %rcx,	27
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_stackmcl.movetoreg.$T1]
    call      mc_libmcl.genmc
    jmp       L2695
L2708:
    inc       %rsi
    cmp       %rsi,	[%rip+mc_decls.noperands]
    jle       L2704
L2706:
L2703:
L2698:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      mc_libmcl.mgenreg
    mov       [%rbp + mc_stackmcl.movetoreg.$T1],	%rax
    mov       %rcx,	%r12
    mov       %rdx,	%rbx
    call      mc_libmcl.mgenreg
    mov       %rcx,	11
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + mc_stackmcl.movetoreg.$T1]
    call      mc_libmcl.genmc
    mov       %al,	%r12b
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11-1],	%al
    cmp       %rbx,	2
    jg        L2710
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.xregset]
    mov       %r11,	%r12
    mov       [%r10 + %r11-1],	%al
    jmp       L2709
L2710:
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.regset]
    mov       %r11,	%r12
    mov       [%r10 + %r11-1],	%al
L2709:
L2694:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.getopnd_ind
mc_stackmcl.getopnd_ind:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    test      %rax,	%rax
    jnz       L2713
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	%rsi
    mov       %rdi,	[%rax + %r10*8-8]
    movzx     %rax,	byte ptr[%rdi+1]
    cmp       %rax,	2
    jnz       L2715
    mov       %rbx,	[%rdi+8]
    movzx     %rax,	byte ptr[%rbx+72]
    cmp       %rax,	5
    jnz       L2718
    movzx     %rax,	byte ptr[%rbx+82]
    cmp       %rax,	11
    jz        L2717
L2718:
    mov       %rax,	[%rdi+8]
    mov       %rcx,	%rax
    mov       %rdx,	%r12
    call      mc_libmcl.mgenmem
    jmp       L2711
L2717:
L2715:
L2713:
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	1
    jz        L2720
    mov       %rcx,	%rsi
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
L2720:
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rcx,	%rax
    mov       %rdx,	%r12
    xor       %r8d,	%r8d
    call      mc_libmcl.mgenireg
L2711:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.getopnd_ind_simp
mc_stackmcl.getopnd_ind_simp:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	1
    jz        L2723
    mov       %rcx,	%rdi
    mov       %rdx,	6
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
L2723:
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rcx,	%rax
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_libmcl.mgenireg
L2721:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.swapopnds
mc_stackmcl.swapopnds:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	%rcx
    lea       %rax,	[%rax + %r10*8-8]
    lea       %r10,	[%rip+mc_decls.pclopnd]
    mov       %r11,	%rdx
    lea       %r10,	[%r10 + %r11*8-8]
    mov       %r11,	[%rax]
    mov       %r9,	[%r10]
    mov       [%r10],	%r11
    mov       [%rax],	%r9
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rcx
    lea       %rax,	[%rax + %r10-1]
    lea       %r10,	[%rip+mc_decls.pclloc]
    mov       %r11,	%rdx
    lea       %r10,	[%r10 + %r11-1]
    mov       %r11b,	[%rax]
    mov       %r9b,	[%r10]
    mov       [%r10],	%r11b
    mov       [%rax],	%r9b
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%rcx
    lea       %rax,	[%rax + %r10-1]
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	%rdx
    lea       %r10,	[%r10 + %r11-1]
    mov       %r11b,	[%rax]
    mov       %r9b,	[%r10]
    mov       [%r10],	%r11b
    mov       [%rax],	%r9b
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	%rcx
    lea       %rax,	[%rax + %r10-1]
    lea       %r10,	[%rip+mc_decls.pclmode]
    mov       %r11,	%rdx
    lea       %r10,	[%r10 + %r11-1]
    mov       %r11b,	[%rax]
    mov       %r9b,	[%r10]
    mov       [%r10],	%r11b
    mov       [%rax],	%r9b
    lea       %rax,	[%rip+mc_decls.pclcount]
    mov       %r10,	%rcx
    lea       %rax,	[%rax + %r10-1]
    lea       %r10,	[%rip+mc_decls.pclcount]
    mov       %r11,	%rdx
    lea       %r10,	[%r10 + %r11-1]
    mov       %r11b,	[%rax]
    mov       %r9b,	[%r10]
    mov       [%r10],	%r11b
    mov       [%rax],	%r9b
#---------------
    ret       
# End 
# Proc mc_stackmcl.isimmload
mc_stackmcl.isimmload:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	16
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	%rcx
    mov       %rdi,	[%rax + %r10*8-8]
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rcx
    movzx     %rax,	byte ptr[%rax + %r10-1]
    test      %rax,	%rax
    jnz       L2727
    movzx     %rax,	byte ptr[%rdi]
    cmp       %rax,	1
    jnz       L2727
    movzx     %rax,	byte ptr[%rdi+1]
    cmp       %rax,	4
    jnz       L2727
    mov       %rax,	%rdi
    jmp       L2726
L2727:
    xor       %eax,	%eax
L2726:
L2725:
#---------------
    add       %rsp,	16
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.setnewzz
mc_stackmcl.setnewzz:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.pclloc]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11-1],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+mc_decls.pclopnd]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11*8-8],	%rax
    mov       %al,	%cl
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11-1],	%al
    mov       %al,	%dl
    lea       %r10,	[%rip+mc_decls.pclmode]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11-1],	%al
#---------------
    ret       
# End 
# Proc mc_stackmcl.freeworkregs
mc_stackmcl.freeworkregs:
#PROC1
#PROC2
#?>>
    .set mc_stackmcl.freeworkregs.p, 32
    push      %rdi
    push      %rbx
#?]]
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rip+mc_decls.regset]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    lea       %rax,	[%rip+mc_decls.xregset]
    xor       %r10d,	%r10d
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    mov       %rbx,	1
    mov       %rax,	[%rip+mc_decls.noperands]
    cmp       %rax,	1
    jl        L2732
L2730:
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rdi,	%rax
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L2734
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	2
    jg        L2736
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.xregset]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    jmp       L2735
L2736:
    mov       %al,	1
    lea       %r10,	[%rip+mc_decls.regset]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
L2735:
L2734:
    inc       %rbx
    cmp       %rbx,	[%rip+mc_decls.noperands]
    jle       L2730
L2732:
#---------------
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.swapopndregs
mc_stackmcl.swapopndregs:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	2
    jg        L2739
    lea       %rcx,	[%rip+L8626]
    lea       %rdx,	[%rip+L8627]
    call      pc_api.merror
L2739:
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	[%rip+mc_decls.noperands]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rdi,	%rax
    cmp       %rdi,	%rsi
    jz        L2737
L2741:
    mov       %rax,	[%rip+mc_decls.noperands]
    dec       %rax
    mov       %rbx,	%rax
    cmp       %rbx,	1
    jl        L2745
L2742:
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	1
    jnz       L2747
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	%rsi
    jnz       L2747
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	[%rip+mc_decls.noperands]
    lea       %rax,	[%rax + %r10-1]
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	%rbx
    lea       %r10,	[%r10 + %r11-1]
    mov       %r11b,	[%rax]
    mov       %r9b,	[%r10]
    mov       [%r10],	%r11b
    mov       [%rax],	%r9b
    jmp       L2737
L2747:
    dec       %rbx
    cmp       %rbx,	1
    jge       L2742
L2745:
    xor       %eax,	%eax
    lea       %r10,	[%rip+mc_decls.regset]
    mov       %r11,	%rdi
    mov       [%r10 + %r11-1],	%al
    mov       %al,	%sil
    lea       %r10,	[%rip+mc_decls.pclreg]
    mov       %r11,	[%rip+mc_decls.noperands]
    mov       [%r10 + %r11-1],	%al
L2737:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.makeopndind
mc_stackmcl.makeopndind:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    movzx     %rax,	word ptr[%rdi+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jz        L2750
    lea       %rcx,	[%rip+L8628]
    lea       %rdx,	[%rip+L8629]
    call      pc_api.merror
L2750:
    movzx     %rax,	byte ptr[%rdi+10]
    mov       %rcx,	%rax
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    call      mc_libmcl.mgenireg
L2748:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.makesimpleaddr
mc_stackmcl.makesimpleaddr:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%r13+10]
    mov       %rsi,	%rax
    movzx     %rax,	byte ptr[%r13+11]
    mov       %r12,	%rax
    cmp       %rsi,	15
    jnz       L2753
    xor       %rsi,	%rsi
L2753:
    movzx     %rax,	word ptr[%r13+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	3
    jz        L2755
    lea       %rcx,	[%rip+L8630]
    lea       %rdx,	[%rip+L8631]
    call      pc_api.merror
L2755:
    test      %rsi,	%rsi
    jnz       L2757
    test      %r12,	%r12
    jnz       L2757
    call      mc_stackmcl.getworkireg
    mov       %rbx,	%rax
    jmp       L2756
L2757:
    test      %rsi,	%rsi
    jz        L2758
    mov       %rax,	%r13
    jmp       L2751
L2758:
    test      %r12,	%r12
    jz        L2759
    mov       %rbx,	%r12
    jmp       L2756
L2759:
    mov       %rbx,	%r12
L2756:
    mov       %rcx,	%rbx
    mov       %rdx,	10
    xor       %r8d,	%r8d
    call      mc_libmcl.mgenireg
    mov       %rdi,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	10
    call      mc_libmcl.mgenreg
    mov       %rcx,	14
    mov       %rdx,	%rax
    mov       %r8,	%r13
    call      mc_libmcl.genmc
    mov       %rax,	%rdi
L2751:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.checkallloaded
mc_stackmcl.checkallloaded:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    mov       %rdi,	1
    mov       %rax,	[%rip+mc_decls.noperands]
    cmp       %rax,	1
    jl        L2763
L2761:
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    test      %rax,	%rax
    jnz       L2765
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    movzx     %rax,	byte ptr[%rax+1]
    cmp       %rax,	1
    jnz       L2765
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    movzx     %rax,	byte ptr[%rax+3]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      mc_stackmcl.loadopnd
L2765:
    inc       %rdi
    cmp       %rdi,	[%rip+mc_decls.noperands]
    jle       L2761
L2763:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.stropndstack
mc_stackmcl.stropndstack:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rip+mc_stackmcl.stropndstack.str]
    mov       %rdi,	%rax
    test      %r13,	%r13
    jz        L2768
    mov       %rcx,	%rdi
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8632]
    call      msys.m$print_setfmt
    mov       %rcx,	[%rip+mc_decls.noperands]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L2767
L2768:
    mov       %rcx,	%rdi
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8633]
    call      msys.m$print_setfmt
    mov       %rcx,	[%rip+mc_decls.noperands]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
L2767:
    mov       %rsi,	1
    mov       %rax,	[%rip+mc_decls.noperands]
    cmp       %rax,	1
    jl        L2771
L2769:
    mov       %rax,	[%rip+mc_decls.noperands]
    sub       %rax,	%rsi
    inc       %rax
    sub       %rax,	1
    cmp       %rax,	4
    jae       L2774
    lea       %r10,	[%rip+L2773]
    jmp       [%r10 + %rax*8]
    .data
L2773:
    .quad     L2775
    .quad     L2776
    .quad     L2777
    .quad     L2778
    .text
L2775:
    lea       %rax,	[%rip+L8634]
    jmp       L2772
L2776:
    lea       %rax,	[%rip+L8635]
    jmp       L2772
L2777:
    lea       %rax,	[%rip+L8636]
    jmp       L2772
L2778:
    lea       %rax,	[%rip+L8637]
    jmp       L2772
L2774:
    lea       %rax,	[%rip+L8638]
L2772:
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      strcat
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	1
    jz        L2780
    cmp       %rax,	2
    jz        L2780
    cmp       %rax,	3
    jz        L2781
    jmp       L2782
L2780:
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	2
    jg        L2784
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    lea       %r10,	[%rip+mc_decls.xregnames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%rdi
    mov       %rdx,	%r10
    call      strcat
    jmp       L2783
L2784:
    lea       %rax,	[%rip+mc_decls.pclreg]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    lea       %r10,	[%rip+mc_decls.regnames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%rdi
    mov       %rdx,	%r10
    call      strcat
L2783:
    lea       %rax,	[%rip+mc_decls.pclloc]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	2
    jnz       L2786
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8639]
    call      strcat
L2786:
    jmp       L2779
L2781:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8640]
    call      strcat
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    call      msys.strint
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      strcat
    jmp       L2779
L2782:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8641]
    call      strcat
    movzx     %rax,	byte ptr[%rip+pc_api.fpshortnames]
    mov       %rbx,	%rax
    mov       %al,	1
    mov       [%rip+pc_api.fpshortnames],	%al
    lea       %rax,	[%rip+mc_decls.pclopnd]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rcx,	%rax
    call      pc_diags.stropnd
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      strcat
    mov       [%rip+pc_api.fpshortnames],	%bl
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8642]
    call      strcat
L2779:
    lea       %rax,	[%rip+mc_decls.pclcount]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	1
    jle       L2788
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8643]
    call      strcat
L2788:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8644]
    call      strcat
    lea       %rax,	[%rip+mc_decls.pclmode]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    lea       %r10,	[%rip+pc_tables.pstdnames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%rdi
    mov       %rdx,	%r10
    call      strcat
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8645]
    call      strcat
    cmp       %rsi,	[%rip+mc_decls.noperands]
    jge       L2790
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8646]
    call      strcat
L2790:
    inc       %rsi
    cmp       %rsi,	[%rip+mc_decls.noperands]
    jle       L2769
L2771:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8647]
    call      strcat
    lea       %rcx,	[%rip+mc_stackmcl.stropndstack.str]
    mov       %rdx,	50
    lea       %r8,	[%rip+L8648]
    call      mlib.ipadstr
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8649]
    call      strcat
    mov       %r12,	1
L2791:
    lea       %rax,	[%rip+mc_decls.regset]
    mov       %r10,	%r12
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L2795
    lea       %rax,	[%rip+L8650]
    jmp       L2794
L2795:
    lea       %rax,	[%rip+L8651]
L2794:
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      strcat
    inc       %r12
    cmp       %r12,	10
    jle       L2791
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8652]
    call      strcat
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8653]
    call      strcat
    mov       %r12,	1
    mov       %rax,	[%rip+mc_decls.xregmax]
    cmp       %rax,	1
    jl        L2798
L2796:
    lea       %rax,	[%rip+mc_decls.xregset]
    mov       %r10,	%r12
    mov       %al,	[%rax + %r10-1]
    test      %al,	%al
    jz        L2800
    lea       %rax,	[%rip+L8654]
    jmp       L2799
L2800:
    lea       %rax,	[%rip+L8655]
L2799:
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      strcat
    inc       %r12
    cmp       %r12,	[%rip+mc_decls.xregmax]
    jle       L2796
L2798:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8656]
    call      strcat
    mov       %rcx,	[%rip+mc_decls.mstackdepth]
    xor       %edx,	%edx
    call      msys.strint
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      strcat
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8657]
    call      strcat
    mov       %rcx,	[%rip+mc_decls.noperands]
    xor       %edx,	%edx
    call      msys.strint
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      strcat
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8658]
    call      strcat
    mov       %rcx,	[%rip+mc_decls.ncalldepth]
    xor       %edx,	%edx
    call      msys.strint
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      strcat
    mov       %rax,	%rdi
L2766:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_stackmcl.showopndstack
mc_stackmcl.showopndstack:
#PROC1
#PROC2
#?>>
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    mov       %rcx,	1
    call      mc_stackmcl.stropndstack
    mov       %rcx,	%rax
    call      mc_libmcl.mgencomment
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mc_optim.peephole
mc_optim.peephole:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    mov       %al,	[%rip+pc_decls.fpeephole]
    test      %al,	%al
    jz        L2802
L2804:
    mov       %rax,	[%rip+mc_decls.mccode]
    mov       %rdi,	[%rax+8]
    jmp       L2808
L2805:
    mov       %rbx,	[%rdi+8]
    mov       %rsi,	[%rbx+8]
    movzx     %rax,	byte ptr[%rdi+33]
    cmp       %rax,	8
    jz        L2810
    cmp       %rax,	11
    jz        L2811
    cmp       %rax,	38
    jz        L2812
    cmp       %rax,	40
    jz        L2813
    cmp       %rax,	26
    jz        L2814
    jmp       L2815
L2810:
    jmp       L2807
L2811:
    movzx     %rax,	byte ptr[%rbx+33]
    cmp       %rax,	11
    jz        L2817
    cmp       %rax,	41
    jz        L2818
    cmp       %rax,	42
    jz        L2819
    cmp       %rax,	28
    jz        L2820
    cmp       %rax,	29
    jz        L2820
    cmp       %rax,	52
    jz        L2821
    cmp       %rax,	53
    jz        L2821
    cmp       %rax,	25
    jz        L2822
    jmp       L2823
L2817:
    mov       %rax,	[%rdi+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg0
    test      %rax,	%rax
    jz        L2825
    mov       %rax,	[%rdi+16]
    mov       %r10,	[%rbx+24]
    cmp       %rax,	%r10
    jnz       L2825
    mov       %rcx,	%rbx
    call      mc_optim.endr0
    test      %rax,	%rax
    jz        L2825
    mov       %rax,	[%rbx+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg10
    test      %rax,	%rax
    jnz       L2826
L2827:
    mov       %rax,	[%rbx+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg
    test      %rax,	%rax
    jnz       L2829
    mov       %rax,	[%rdi+24]
    mov       %rcx,	%rax
    call      mc_optim.isreg
    test      %rax,	%rax
    jz        L2828
L2829:
    mov       %rax,	[%rbx+16]
    mov       [%rdi+16],	%rax
    mov       %rcx,	%rbx
    call      mc_optim.deletemcl
L2828:
L2826:
    jmp       L2824
L2825:
    mov       %rax,	[%rdi+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg0
    test      %rax,	%rax
    jz        L2830
    mov       %rax,	[%rdi+16]
    mov       %r10,	[%rbx+24]
    cmp       %rax,	%r10
    jnz       L2830
    mov       %rax,	[%rbx+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg10
    test      %rax,	%rax
    jz        L2830
    movzx     %rax,	byte ptr[%rsi+33]
    cmp       %rax,	21
    jnz       L2830
    mov       %rcx,	%rsi
    call      mc_optim.endr0
    test      %rax,	%rax
    jz        L2830
    mov       %rax,	[%rbx+16]
    mov       [%rdi+16],	%rax
    mov       %rcx,	%rbx
    call      mc_optim.deletemcl
L2830:
L2824:
    jmp       L2816
L2818:
    mov       %rax,	[%rdi+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg0
    test      %rax,	%rax
    jz        L2832
    mov       %rax,	[%rdi+16]
    mov       %r10,	[%rbx+16]
    cmp       %r10,	%rax
    jnz       L2833
    mov       %rax,	[%rbx+24]
    cmp       %r10,	%rax
    jnz       L2833
    mov       %rax,	1
    jmp       L2834
L2833:
    xor       %eax,	%eax
L2834:
    test      %rax,	%rax
    setnz     %al
    movzx     %eax,	%al
    test      %ax,	%ax
    jz        L2832
    mov       %rax,	[%rdi+24]
    mov       %rcx,	%rax
    call      mc_optim.isreg
    test      %rax,	%rax
    jz        L2832
    mov       %rcx,	%rsi
    call      mc_optim.endr0
    test      %rax,	%rax
    jz        L2832
    mov       %al,	41
    mov       [%rdi+33],	%al
    mov       %rax,	[%rdi+24]
    mov       [%rdi+16],	%rax
    mov       %rcx,	%rbx
    call      mc_optim.deletemcl
    mov       %rdi,	%rax
L2832:
    jmp       L2816
L2819:
    mov       %rax,	[%rdi+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg0
    test      %rax,	%rax
    jz        L2836
    mov       %rax,	[%rdi+16]
    mov       %r10,	[%rbx+16]
    cmp       %rax,	%r10
    jnz       L2836
    mov       %rax,	[%rdi+24]
    mov       %rcx,	%rax
    call      mc_optim.isreg
    test      %rax,	%rax
    jz        L2836
    mov       %rcx,	%rsi
    call      mc_optim.endr0
    test      %rax,	%rax
    jz        L2836
    mov       %al,	42
    mov       [%rdi+33],	%al
    mov       %rax,	[%rdi+24]
    mov       [%rdi+16],	%rax
    mov       %rax,	[%rbx+24]
    mov       [%rdi+24],	%rax
    mov       %rcx,	%rbx
    call      mc_optim.deletemcl
L2836:
    jmp       L2816
L2820:
    mov       %rax,	[%rdi+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg
    test      %rax,	%rax
    jz        L2838
    mov       %rax,	[%rdi+16]
    mov       %r10,	[%rbx+16]
    cmp       %rax,	%r10
    jnz       L2838
    mov       %rax,	[%rdi+24]
    mov       %rcx,	%rax
    call      mc_optim.isreg
    test      %rax,	%rax
    jz        L2838
    mov       %rax,	[%rbx+24]
    mov       %rcx,	%rax
    call      mc_optim.isconst
    test      %rax,	%rax
    jz        L2838
    mov       %al,	14
    mov       [%rdi+33],	%al
    sub       %rsp,	8
    push      0
    push      0
    push      0
    movzx     %rax,	byte ptr[%rbx+33]
    cmp       %rax,	28
    jnz       L2840
    mov       %rax,	[%rbx+24]
    mov       %rax,	[%rax]
    jmp       L2839
L2840:
    mov       %rax,	[%rbx+24]
    mov       %rax,	[%rax]
    neg       %rax
L2839:
    mov       %r10,	[%rdi+24]
    movzx     %r10,	byte ptr[%r10+10]
    mov       %rcx,	%r10
    xor       %edx,	%edx
    mov       %r8,	1
    mov       %r9,	%rax
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       [%rdi+24],	%rax
    mov       %rcx,	%rbx
    call      mc_optim.deletemcl
L2838:
    jmp       L2816
L2821:
    mov       %rax,	[%rdi+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg
    test      %rax,	%rax
    jz        L2842
    mov       %rax,	[%rdi+16]
    mov       %r10,	[%rbx+16]
    cmp       %rax,	%r10
    jnz       L2842
    mov       %rax,	[%rdi+24]
    mov       %rcx,	%rax
    call      mc_optim.isreg
    test      %rax,	%rax
    jz        L2842
    mov       %al,	14
    mov       [%rdi+33],	%al
    sub       %rsp,	8
    push      0
    push      0
    push      0
    movzx     %rax,	byte ptr[%rbx+33]
    cmp       %rax,	52
    jnz       L2844
    mov       %rax,	1
    jmp       L2843
L2844:
    mov       %rax,	-1
L2843:
    mov       %r10,	[%rdi+24]
    movzx     %r10,	byte ptr[%r10+10]
    mov       %rcx,	%r10
    xor       %edx,	%edx
    mov       %r8,	1
    mov       %r9,	%rax
    sub       %rsp,	32
    call      mc_libmcl.mgenindex
    add       %rsp,	64
    mov       [%rdi+24],	%rax
    mov       %rcx,	%rbx
    call      mc_optim.deletemcl
L2842:
    jmp       L2816
L2822:
    mov       %rax,	[%rdi+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg0
    test      %rax,	%rax
    jz        L2846
    mov       %rax,	[%rbx+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg0
    test      %rax,	%rax
    jz        L2846
    mov       %al,	25
    mov       [%rdi+33],	%al
    mov       %rax,	[%rdi+24]
    mov       [%rdi+16],	%rax
    xor       %eax,	%eax
    mov       [%rdi+24],	%rax
    mov       %rcx,	%rbx
    call      mc_optim.deletemcl
L2846:
L2823:
L2816:
    jmp       L2809
L2812:
    movzx     %rax,	byte ptr[%rbx+33]
    cmp       %rax,	41
    jnz       L2848
    mov       %rax,	[%rdi+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg0
    test      %rax,	%rax
    jz        L2850
    mov       %rax,	[%rdi+16]
    mov       %r10,	[%rbx+16]
    cmp       %r10,	%rax
    jnz       L2851
    mov       %rax,	[%rbx+24]
    cmp       %r10,	%rax
    jnz       L2851
    mov       %rax,	1
    jmp       L2852
L2851:
    xor       %eax,	%eax
L2852:
    test      %rax,	%rax
    setnz     %al
    movzx     %eax,	%al
    test      %ax,	%ax
    jz        L2850
    mov       %rcx,	%rsi
    call      mc_optim.endr0
    test      %rax,	%rax
    jz        L2850
    mov       %rcx,	%rbx
    call      mc_optim.deletemcl
    mov       %rdi,	%rax
L2850:
L2848:
    jmp       L2809
L2813:
    movzx     %rax,	byte ptr[%rbx+33]
    cmp       %rax,	11
    jnz       L2854
    mov       %rax,	[%rdi+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg0
    test      %rax,	%rax
    jz        L2856
    mov       %rax,	[%rdi+16]
    mov       %r10,	[%rdi+24]
    cmp       %rax,	%r10
    jnz       L2856
    mov       %rax,	[%rbx+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg
    test      %rax,	%rax
    jz        L2856
    mov       %rax,	[%rbx+24]
    mov       %rcx,	%rax
    call      mc_optim.isreg0
    test      %rax,	%rax
    jz        L2856
    mov       %rcx,	%rbx
    call      mc_optim.endr0
    test      %rax,	%rax
    jz        L2856
    mov       %rax,	[%rbx+16]
    mov       [%rdi+24],	%rax
    mov       [%rdi+16],	%rax
    mov       %rcx,	%rbx
    call      mc_optim.deletemcl
    mov       %rdi,	%rax
L2856:
L2854:
    jmp       L2809
L2814:
    movzx     %rax,	byte ptr[%rbx+33]
    cmp       %rax,	25
    jnz       L2858
    movzx     %rax,	byte ptr[%rsi+33]
    cmp       %rax,	9
    jnz       L2858
    mov       %rax,	[%rdi+16]
    mov       %rax,	[%rax]
    mov       %r10,	[%rsi+16]
    mov       %r10,	[%r10]
    cmp       %rax,	%r10
    jnz       L2858
    mov       %rcx,	%rdi
    call      mc_optim.endr0
    test      %rax,	%rax
    jz        L2858
    movzx     %rax,	byte ptr[%rdi+34]
    lea       %r10,	[%rip+mc_decls.asmrevcond]
    mov       %r10,	[%r10 + %rax*8]
    mov       [%rdi+34],	%r10b
    mov       %rax,	[%rbx+16]
    mov       [%rdi+16],	%rax
    mov       %rcx,	%rbx
    call      mc_optim.deletemcl
    mov       %rdi,	%rax
L2858:
L2815:
L2809:
    mov       %rdi,	[%rdi+8]
L2808:
    test      %rdi,	%rdi
    jnz       L2805
L2807:
L2802:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_optim.isreg
mc_optim.isreg:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    movzx     %rax,	word ptr[%rcx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    setz      %al
    movzx     %eax,	%al
L2859:
#---------------
    ret       
# End 
# Proc mc_optim.isreg0
mc_optim.isreg0:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    test      %rcx,	%rcx
    jnz       L2862
    xor       %eax,	%eax
    jmp       L2860
L2862:
    movzx     %rax,	word ptr[%rcx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jnz       L2864
    movzx     %rax,	byte ptr[%rcx+10]
    cmp       %rax,	1
    jnz       L2864
    mov       %rax,	1
    jmp       L2860
L2864:
    xor       %eax,	%eax
L2860:
#---------------
    ret       
# End 
# Proc mc_optim.isreg10
mc_optim.isreg10:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    test      %rcx,	%rcx
    jnz       L2867
    xor       %eax,	%eax
    jmp       L2865
L2867:
    movzx     %rax,	word ptr[%rcx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jnz       L2869
    movzx     %rax,	byte ptr[%rcx+10]
    cmp       %rax,	11
    jnz       L2869
    mov       %rax,	1
    jmp       L2865
L2869:
    xor       %eax,	%eax
L2865:
#---------------
    ret       
# End 
# Proc mc_optim.isreg00
mc_optim.isreg00:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rdi+16]
    mov       %rcx,	%rax
    call      mc_optim.isreg
    test      %rax,	%rax
    jz        L2872
    mov       %rax,	[%rdi+16]
    mov       %r10,	[%rdi+24]
    cmp       %rax,	%r10
    jnz       L2872
    mov       %rax,	1
    jmp       L2870
L2872:
    xor       %eax,	%eax
L2870:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_optim.isconst
mc_optim.isconst:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    test      %rcx,	%rcx
    jnz       L2875
    xor       %eax,	%eax
    jmp       L2873
L2875:
    movzx     %rax,	word ptr[%rcx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	2
    jnz       L2877
    movzx     %rax,	word ptr[%rcx+8]
    shr       %rax,	12
    and       %rax,	15
    cmp       %rax,	1
    jnz       L2877
    mov       %rax,	1
    jmp       L2873
L2877:
    xor       %eax,	%eax
L2873:
#---------------
    ret       
# End 
# Proc mc_optim.sameoperand
mc_optim.sameoperand:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	16
    call      memcmp
    movsxd    %r10,	%eax
    cmp       %r10,	0
    setz      %r10b
    movzx     %r10d,	%r10b
    mov       %rax,	%r10
L2878:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_optim.sameregopnd
mc_optim.sameregopnd:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    movzx     %rax,	word ptr[%rcx+8]
    shr       %rax,	9
    and       %rax,	7
    movzx     %r10,	word ptr[%rdx+8]
    shr       %r10,	9
    and       %r10,	7
    cmp       %r10,	%rax
    jnz       L2882
    cmp       %r10,	1
    jz        L2881
L2882:
    xor       %eax,	%eax
    jmp       L2879
L2881:
    movzx     %rax,	byte ptr[%rcx+10]
    movzx     %r10,	byte ptr[%rdx+10]
    cmp       %rax,	%r10
    setz      %al
    movzx     %eax,	%al
L2879:
#---------------
    ret       
# End 
# Proc mc_optim.deletemcl
mc_optim.deletemcl:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rdi,	[%rsi]
    mov       %rbx,	[%rsi+8]
    test      %rdi,	%rdi
    jz        L2886
    test      %rbx,	%rbx
    jnz       L2885
L2886:
    lea       %rcx,	[%rip+L8659]
    lea       %rdx,	[%rip+L8660]
    call      pc_api.merror
L2885:
    mov       [%rdi+8],	%rbx
    mov       [%rbx],	%rdi
    mov       %rax,	%rbx
L2883:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_optim.endr0
mc_optim.endr0:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rcx+48]
    movzx     %rax,	byte ptr[%rax]
L2887:
#---------------
    ret       
# End 
# Proc mc_genss_dummy.genss
mc_genss_dummy.genss:
#PROC1
#PROC2
#?>>
    .set mc_genss_dummy.genss.obj, 16
#?]]
#---------------
#PROC3
#PROC4
#---------------
    ret       
# End 
# Proc mc_decls.start
mc_decls.start:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
#---------------
#PROC3
#PROC4
    xor       %rbx,	%rbx
    mov       %rax,	13
    mov       %rdi,	%rax
    cmp       %rdi,	0
    jl        L2892
L2890:
    mov       %al,	10
    lea       %r10,	[%rip+mc_decls.ploadop]
    mov       %r11,	%rbx
    mov       [%r10 + %r11],	%al
    inc       %rbx
    cmp       %rbx,	%rdi
    jle       L2890
L2892:
    mov       %al,	19
    lea       %r10,	[%rip+mc_decls.ploadop]
    mov       [%r10+5],	%al
    lea       %r10,	[%rip+mc_decls.ploadop]
    mov       [%r10+4],	%al
    lea       %r10,	[%rip+mc_decls.ploadop]
    mov       [%r10+3],	%al
    mov       %al,	18
    lea       %r10,	[%rip+mc_decls.ploadop]
    mov       [%r10+9],	%al
    lea       %r10,	[%rip+mc_decls.ploadop]
    mov       [%r10+8],	%al
    lea       %r10,	[%rip+mc_decls.ploadop]
    mov       [%r10+7],	%al
    mov       %al,	16
    lea       %r10,	[%rip+mc_decls.ploadop]
    mov       [%r10+1],	%al
    mov       %al,	17
    lea       %r10,	[%rip+mc_decls.ploadop]
    mov       [%r10+2],	%al
    mov       %al,	11
    lea       %r10,	[%rip+mc_decls.ploadop]
    mov       [%r10+10],	%al
    lea       %r10,	[%rip+mc_decls.ploadop]
    mov       [%r10+6],	%al
#---------------
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writegas.getassemstr
mc_writegas.getassemstr:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    mov       %rcx,	[%rip+pc_decls.pdest]
    call      mlib.gs_init
    lea       %rcx,	[%rip+L8661]
    call      mc_writegas.asmstr
    lea       %rcx,	[%rip+L8662]
    call      mc_writegas.asmstr
    lea       %rcx,	[%rip+L8663]
    call      mc_writegas.asmstr
    mov       %rdi,	[%rip+pc_decls.psymboltable]
    jmp       L2897
L2894:
    mov       %al,	[%rdi+81]
    test      %al,	%al
    jz        L2899
    lea       %rcx,	[%rip+L8664]
    call      mc_writegas.asmstr
    mov       %rcx,	[%rdi]
    call      mc_writegas.asmstr
    lea       %rcx,	[%rip+L8665]
    call      mc_writegas.asmstr
L2899:
    mov       %rdi,	[%rdi+8]
L2897:
    test      %rdi,	%rdi
    jnz       L2894
    lea       %rcx,	[%rip+L8665]
    call      mc_writegas.asmstr
    mov       %rbx,	[%rip+mc_decls.mccode]
    mov       %rsi,	1
    jmp       L2901
L2900:
    mov       %rcx,	%rsi
    mov       %rdx,	%rbx
    call      mc_writegas.writemcl
    inc       %rsi
    mov       %rbx,	[%rbx+8]
L2901:
    test      %rbx,	%rbx
    jnz       L2900
    mov       %rax,	[%rip+pc_decls.pdest]
L2893:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writegas.writemcl
mc_writegas.writemcl:
#PROC1
#PROC2
#?>>
    .set mc_writegas.writemcl.index, 24
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rdx
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rdi+33]
    cmp       %rax,	6
    jnz       L2906
L2905:
    jmp       L2904
L2906:
    mov       %rcx,	%rdi
    call      mc_writegas.strmcl
    mov       %rcx,	[%rip+pc_decls.pdest]
    call      mlib.gs_line
L2904:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_writegas.start
mc_writegas.start:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	16
#---------------
#PROC3
#PROC4
    mov       %rax,	1297301838
    mov       [%rip+pc_decls.assemtype],	%rax
    mov       %rsi,	1
L2908:
    mov       %rax,	%rsi
    cmp       %rax,	1
    jz        L2913
    cmp       %rax,	2
    jz        L2913
    cmp       %rax,	4
    jz        L2913
    cmp       %rax,	8
    jnz       L2912
L2913:
    mov       %r12,	1
L2914:
    xor       %dil,	%dil
    mov       %rax,	1
    mov       %r13,	%rax
    mov       %rbx,	137
    cmp       %rbx,	1
    jl        L2919
L2917:
    test      %dil,	%dil
    jz        L2921
    lea       %rax,	[%rip+mc_decls.regsizes]
    mov       %r10,	%r13
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	%rsi
    jnz       L2923
    lea       %rax,	[%rip+mc_decls.regindices]
    mov       %r10,	%r13
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	%r12
    jnz       L2923
    lea       %rax,	[%rip+mc_decls.dregnames]
    mov       %r10,	%r13
    mov       %rax,	[%rax + %r10*8-8]
    lea       %r10,	[%rip+mc_writegas.nregnames]
    mov       %r11,	%rsi
    shl       %r11,	7
    lea       %r10,	[%r10 + %r11-128]
    mov       %r11,	%r12
    mov       [%r10 + %r11*8-8],	%rax
L2923:
    jmp       L2920
L2921:
    lea       %rax,	[%rip+mc_decls.regsizes]
    mov       %r10,	%r13
    movzx     %rax,	byte ptr[%rax + %r10-1]
    test      %rax,	%rax
    jnz       L2924
    mov       %dil,	1
L2924:
L2920:
    inc       %r13
    cmp       %r13,	%rbx
    jle       L2917
L2919:
    inc       %r12
    cmp       %r12,	16
    jle       L2914
L2912:
    inc       %rsi
    cmp       %rsi,	8
    jle       L2908
#---------------
    add       %rsp,	16
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writegas.strmcl
mc_writegas.strmcl:
#PROC1
#PROC2
#?>>
    .set mc_writegas.strmcl.mcl, 72
    .set mc_writegas.strmcl.opcname, -128
    .set mc_writegas.strmcl.$T1, -136
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	168
    mov       [%rbp+72],	%rcx
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rbp + mc_writegas.strmcl.mcl]
    movzx     %rax,	byte ptr[%rax+33]
    mov       %rsi,	%rax
    mov       %rax,	[%rbp + mc_writegas.strmcl.mcl]
    movzx     %rax,	byte ptr[%rax+34]
    mov       %r12,	%rax
    mov       %rax,	[%rbp + mc_writegas.strmcl.mcl]
    mov       %rdi,	[%rax+16]
    mov       %rax,	[%rbp + mc_writegas.strmcl.mcl]
    mov       %rbx,	[%rax+24]
    xor       %r14,	%r14
    mov       %rax,	%rsi
    cmp       %rax,	1
    jz        L2927
    cmp       %rax,	2
    jz        L2928
    cmp       %rax,	3
    jz        L2929
    cmp       %rax,	4
    jz        L2930
    cmp       %rax,	9
    jz        L2931
    cmp       %rax,	5
    jz        L2932
    cmp       %rax,	123
    jz        L2933
    cmp       %rax,	121
    jz        L2934
    cmp       %rax,	122
    jz        L2935
    jmp       L2936
L2927:
    lea       %rcx,	[%rip+L8666]
    call      mc_writegas.asmstr
    mov       %rax,	[%rdi]
    mov       %rcx,	[%rax]
    call      mc_writegas.asmstr
    mov       %rax,	[%rdi]
    mov       [%rip+mc_decls.currasmproc],	%rax
    jmp       L2925
L2928:
    lea       %rcx,	[%rip+L8667]
    call      mc_writegas.asmstr
    xor       %eax,	%eax
    mov       [%rip+mc_decls.currasmproc],	%rax
    jmp       L2925
L2929:
    mov       %rcx,	8227
    call      mc_writegas.asmchar
    mov       %rcx,	[%rdi]
    call      mc_writegas.asmstr
    jmp       L2925
L2930:
    mov       %r15,	[%rdi]
    movzx     %rax,	word ptr[%rdi+8]
    shr       %rax,	12
    and       %rax,	15
    cmp       %rax,	5
    jz        L2938
    cmp       %rax,	4
    jz        L2939
    jmp       L2940
L2938:
    mov       %rcx,	%r15
    call      mc_writegas.getdispname
    mov       %rcx,	%rax
    call      mc_writegas.asmstr
    jmp       L2937
L2939:
    mov       %rcx,	[%rdi]
    call      mc_writegas.asmstr
    jmp       L2925
L2940:
    lea       %rcx,	[%rip+L8668]
    lea       %rdx,	[%rip+L8669]
    call      pc_api.merror
L2937:
    lea       %rcx,	[%rip+L8670]
    call      mc_writegas.asmstr
    mov       %al,	[%r15+81]
    test      %al,	%al
    jz        L2942
    mov       %rax,	[%r15]
    mov       [%rbp + mc_writegas.strmcl.$T1],	%rax
    mov       %rax,	[%r15]
    mov       %rcx,	%rax
    call      pc_api.getbasename
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + mc_writegas.strmcl.$T1]
    call      mlib.eqstring
    test      %rax,	%rax
    jnz       L2943
L2944:
    lea       %rcx,	[%rip+L8671]
    call      mc_writegas.asmstr
    mov       %rax,	[%r15]
    mov       %rcx,	%rax
    call      pc_api.getbasename
    mov       %rcx,	%rax
    call      mc_writegas.asmstr
    lea       %rcx,	[%rip+L8672]
    call      mc_writegas.asmstr
L2943:
L2942:
    jmp       L2925
L2931:
    movzx     %rax,	word ptr[%rdi+8]
    shr       %rax,	12
    and       %rax,	15
    cmp       %rax,	6
    jnz       L2946
    lea       %rcx,	[%rip+mc_writegas.strmcl.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8673]
    call      msys.m$print_setfmt
    mov       %rcx,	[%rdi]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L2945
L2946:
    jmp       L2930
L2945:
    lea       %rcx,	[%rip+mc_writegas.strmcl.str]
    call      mc_writegas.asmstr
    jmp       L2925
L2932:
    lea       %rcx,	[%rip+L8674]
    call      mc_writegas.asmstr
    mov       %rcx,	[%rdi]
    call      mc_writegas.asmstr
    lea       %rcx,	[%rip+L8675]
    call      mc_writegas.asmstr
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    xor       %r8d,	%r8d
    call      mc_writegas.asmopnd
    jmp       L2925
    jmp       L2926
L2933:
    lea       %rcx,	[%rip+L8676]
    call      mc_writegas.asmstr
    mov       %al,	1
    mov       [%rip+mc_writegas.currseg],	%al
    jmp       L2925
L2934:
    lea       %rcx,	[%rip+L8677]
    call      mc_writegas.asmstr
    mov       %al,	2
    mov       [%rip+mc_writegas.currseg],	%al
    jmp       L2925
L2935:
    lea       %rcx,	[%rip+L8678]
    call      mc_writegas.asmstr
    mov       %al,	3
    mov       [%rip+mc_writegas.currseg],	%al
    jmp       L2925
L2936:
L2926:
    mov       %rax,	%rsi
    cmp       %rax,	26
    jz        L2948
    cmp       %rax,	58
    jz        L2949
    cmp       %rax,	15
    jz        L2950
    cmp       %rax,	38
    jz        L2951
    cmp       %rax,	39
    jz        L2952
    cmp       %rax,	40
    jz        L2953
    cmp       %rax,	51
    jz        L2954
    cmp       %rax,	34
    jz        L2955
    cmp       %rax,	19
    jz        L2956
    cmp       %rax,	18
    jz        L2957
    cmp       %rax,	16
    jz        L2958
    cmp       %rax,	11
    jz        L2959
    cmp       %rax,	124
    jz        L2960
    cmp       %rax,	125
    jz        L2961
    cmp       %rax,	116
    jz        L2962
    cmp       %rax,	117
    jz        L2963
    cmp       %rax,	118
    jz        L2964
    cmp       %rax,	119
    jz        L2965
    cmp       %rax,	120
    jz        L2966
    cmp       %rax,	8
    jz        L2967
    jmp       L2968
L2948:
    lea       %rcx,	[%rbp + mc_writegas.strmcl.opcname]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8679]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rax,	[%rip+mc_decls.asmcondnames]
    mov       %r10,	%r12
    mov       %rcx,	[%rax + %r10*8]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L2947
L2949:
    lea       %rcx,	[%rbp + mc_writegas.strmcl.opcname]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8680]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rax,	[%rip+mc_decls.asmcondnames]
    mov       %r10,	%r12
    mov       %rcx,	[%rax + %r10*8]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L2947
L2950:
    lea       %rcx,	[%rbp + mc_writegas.strmcl.opcname]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8681]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rax,	[%rip+mc_decls.asmcondnames]
    mov       %r10,	%r12
    mov       %rcx,	[%rax + %r10*8]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L2947
L2951:
    lea       %rcx,	[%rbp + mc_writegas.strmcl.opcname]
    lea       %rdx,	[%rip+L8682]
    call      strcpy
    jmp       L2947
L2952:
    lea       %rcx,	[%rbp + mc_writegas.strmcl.opcname]
    lea       %rdx,	[%rip+L8683]
    call      strcpy
    jmp       L2947
L2953:
    lea       %rcx,	[%rbp + mc_writegas.strmcl.opcname]
    lea       %rdx,	[%rip+L8684]
    call      strcpy
    jmp       L2947
L2954:
    lea       %rcx,	[%rbp + mc_writegas.strmcl.opcname]
    lea       %rdx,	[%rip+L8685]
    call      strcpy
    jmp       L2947
L2955:
    lea       %rcx,	[%rbp + mc_writegas.strmcl.opcname]
    lea       %rdx,	[%rip+L8686]
    call      strcpy
    jmp       L2947
L2956:
    movzx     %rax,	word ptr[%rdi+8]
    and       %rax,	31
    cmp       %rax,	8
    jnz       L2970
    movzx     %rax,	word ptr[%rbx+8]
    and       %rax,	31
    cmp       %rax,	4
    jnz       L2970
    mov       %rcx,	%rdi
    mov       %rdx,	4
    call      mc_libmcl.changeopndsize
    mov       %rdi,	%rax
    mov       %r10,	[%rbp + mc_writegas.strmcl.mcl]
    mov       [%r10+16],	%rax
    mov       %rsi,	11
L2970:
    jmp       L2968
    jmp       L2947
L2957:
    movzx     %rax,	word ptr[%rdi+8]
    and       %rax,	31
    cmp       %rax,	8
    jnz       L2972
    movzx     %rax,	word ptr[%rbx+8]
    and       %rax,	31
    cmp       %rax,	4
    jnz       L2972
    lea       %rcx,	[%rbp + mc_writegas.strmcl.opcname]
    lea       %rdx,	[%rip+L8687]
    call      strcpy
    jmp       L2971
L2972:
    jmp       L2968
L2971:
    jmp       L2947
L2958:
    movzx     %rax,	word ptr[%rdi+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	5
    jnz       L2974
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	5
    jnz       L2974
    mov       %rsi,	17
L2974:
    jmp       L2968
    jmp       L2947
L2959:
    movzx     %rax,	word ptr[%rdi+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jnz       L2976
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	2
    jnz       L2976
    movzx     %rax,	word ptr[%rbx+8]
    shr       %rax,	12
    and       %rax,	15
    cmp       %rax,	1
    jnz       L2976
    mov       %rax,	[%rbx]
    cmp       %rax,	-2147483648
    jl        L2977
    cmp       %rax,	2147483647
    jle       L2976
L2977:
    mov       %al,	17
    mov       %r10,	[%rbp + mc_writegas.strmcl.mcl]
    mov       [%r10+33],	%al
L2976:
    jmp       L2968
    jmp       L2947
L2960:
    lea       %rcx,	[%rbp + mc_writegas.strmcl.opcname]
    lea       %rdx,	[%rip+L8688]
    call      strcpy
    jmp       L2947
L2961:
    lea       %rcx,	[%rbp + mc_writegas.strmcl.opcname]
    lea       %rdx,	[%rip+L8689]
    call      strcpy
    jmp       L2947
L2962:
    lea       %rcx,	[%rbp + mc_writegas.strmcl.opcname]
    lea       %rdx,	[%rip+L8690]
    call      strcpy
    jmp       L2947
L2963:
    lea       %rcx,	[%rbp + mc_writegas.strmcl.opcname]
    lea       %rdx,	[%rip+L8691]
    call      strcpy
    jmp       L2947
L2964:
    lea       %rcx,	[%rbp + mc_writegas.strmcl.opcname]
    lea       %rdx,	[%rip+L8692]
    call      strcpy
    jmp       L2947
L2965:
    lea       %rcx,	[%rbp + mc_writegas.strmcl.opcname]
    lea       %rdx,	[%rip+L8693]
    call      strcpy
    jmp       L2947
L2966:
    lea       %rcx,	[%rbp + mc_writegas.strmcl.opcname]
    lea       %rdx,	[%rip+L8694]
    call      strcpy
    jmp       L2947
L2967:
    jmp       L2925
L2968:
    cmp       %rsi,	152
    jle       L2979
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    call      msys.strint
    lea       %rcx,	[%rbp + mc_writegas.strmcl.opcname]
    mov       %rdx,	%rax
    call      strcpy
    jmp       L2978
L2979:
    lea       %rax,	[%rip+mc_decls.mclnames]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8-8]
    lea       %rax,	[%rax+2]
    lea       %rcx,	[%rbp + mc_writegas.strmcl.opcname]
    mov       %rdx,	%rax
    call      strcpy
L2978:
L2947:
    lea       %rcx,	[%rbp + mc_writegas.strmcl.opcname]
    mov       %rdx,	10
    lea       %r8,	[%rip+L8695]
    call      mlib.ipadstr
    lea       %rcx,	[%rip+mc_writegas.strmcl.str]
    lea       %rdx,	[%rip+L8696]
    call      strcpy
    lea       %rcx,	[%rip+mc_writegas.strmcl.str]
    mov       %rdx,	4
    lea       %r8,	[%rip+L8697]
    call      mlib.ipadstr
    lea       %rcx,	[%rip+mc_writegas.strmcl.str]
    lea       %rdx,	[%rbp + mc_writegas.strmcl.opcname]
    call      strcat
    lea       %rcx,	[%rip+mc_writegas.strmcl.str]
    call      mc_writegas.asmstr
    test      %rdi,	%rdi
    jz        L2981
    test      %rbx,	%rbx
    jz        L2981
    mov       %rcx,	%rsi
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      mc_writegas.needsizeprefix
    mov       %r13,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	%r13
    xor       %r8d,	%r8d
    call      mc_writegas.asmopnd
    lea       %rcx,	[%rip+L8698]
    call      mc_writegas.asmstr
    mov       %rcx,	%rbx
    mov       %rdx,	%r13
    xor       %r8d,	%r8d
    call      mc_writegas.asmopnd
    mov       %rax,	[%rbp + mc_writegas.strmcl.mcl]
    mov       %al,	[%rax+32]
    test      %al,	%al
    jz        L2983
    lea       %rcx,	[%rip+L8699]
    call      mc_writegas.asmstr
    mov       %rax,	[%rbp + mc_writegas.strmcl.mcl]
    movzx     %rax,	byte ptr[%rax+32]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.strint
    mov       %rcx,	%rax
    call      mc_writegas.asmstr
L2983:
    jmp       L2980
L2981:
    test      %rdi,	%rdi
    jz        L2984
    movzx     %rax,	word ptr[%rdi+8]
    shr       %rax,	9
    and       %rax,	7
    jz        L2984
    cmp       %rsi,	21
    jnz       L2986
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    mov       %r8,	%rsi
    call      mc_writegas.asmopnd
    jmp       L2985
L2986:
    mov       %rcx,	%rdi
    mov       %rdx,	1
    mov       %r8,	%rsi
    call      mc_writegas.asmopnd
L2985:
L2984:
L2980:
L2925:
#---------------
    add       %rsp,	168
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writegas.strmclstr
mc_writegas.strmclstr:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	[%rip+pc_decls.pdest]
    call      mlib.gs_init
    mov       %rcx,	%rdi
    call      mc_writegas.strmcl
    mov       %rax,	[%rip+pc_decls.pdest]
    mov       %rax,	[%rax]
L2987:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_writegas.mstropnd
mc_writegas.mstropnd:
#PROC1
#PROC2
#?>>
    .set mc_writegas.mstropnd.str2, -128
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	168
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
#PROC3
#PROC4
    xor       %eax,	%eax
    lea       %r10,	[%rip+mc_writegas.mstropnd.str]
    mov       [%r10],	%al
    movzx     %rax,	word ptr[%rsi+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jz        L2990
    cmp       %rax,	2
    jz        L2991
    cmp       %rax,	3
    jz        L2992
    cmp       %rax,	5
    jz        L2993
    jmp       L2994
L2990:
    movzx     %rax,	word ptr[%rsi+8]
    and       %rax,	31
    movzx     %r10,	byte ptr[%rsi+10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_writegas.strreg
    jmp       L2988
L2991:
    cmp       %r13,	119
    jnz       L2996
    movzx     %rax,	word ptr[%rsi+8]
    shr       %rax,	12
    and       %rax,	15
    cmp       %rax,	1
    jnz       L2996
    mov       %rax,	[%rsi]
    cmp       %rax,	0
    jl        L2998
    cmp       %rax,	9
    jg        L2998
    mov       %rax,	[%rsi]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.strint
    lea       %rcx,	[%rip+mc_writegas.mstropnd.str]
    mov       %rdx,	%rax
    call      strcat
    jmp       L2997
L2998:
    lea       %rcx,	[%rip+mc_writegas.mstropnd.str]
    lea       %rdx,	[%rip+L8700]
    call      strcat
    mov       %rax,	[%rsi]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8701]
    call      msys.strword
    lea       %rcx,	[%rip+mc_writegas.mstropnd.str]
    mov       %rdx,	%rax
    call      strcat
L2997:
    jmp       L2995
L2996:
    mov       %rcx,	%rsi
    call      mc_writegas.strvalue
    lea       %rcx,	[%rip+mc_writegas.mstropnd.str]
    mov       %rdx,	%rax
    call      strcpy
L2995:
    jmp       L2989
L2992:
    movzx     %rax,	word ptr[%rsi+8]
    and       %rax,	31
    mov       %rcx,	%rax
    mov       %rdx,	%r12
    call      mc_writegas.getsizeprefix
    lea       %rcx,	[%rip+mc_writegas.mstropnd.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rcx,	[%rip+mc_writegas.mstropnd.str]
    lea       %rdx,	[%rip+L8702]
    call      strcat
    lea       %rax,	[%rip+L8703]
    mov       %rdi,	%rax
    mov       %al,	[%rsi+10]
    test      %al,	%al
    jz        L3000
    movzx     %rax,	byte ptr[%rsi+10]
    mov       %rcx,	%rax
    mov       %rdx,	8
    call      mc_writegas.strreg
    lea       %rcx,	[%rip+mc_writegas.mstropnd.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rax,	[%rip+L8704]
    mov       %rdi,	%rax
L3000:
    mov       %al,	[%rsi+11]
    test      %al,	%al
    jz        L3002
    lea       %rcx,	[%rip+mc_writegas.mstropnd.str]
    mov       %rdx,	%rdi
    call      strcat
    movzx     %rax,	byte ptr[%rsi+11]
    mov       %rcx,	%rax
    mov       %rdx,	8
    call      mc_writegas.strreg
    lea       %rcx,	[%rip+mc_writegas.mstropnd.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rax,	[%rip+L8704]
    mov       %rdi,	%rax
    movzx     %rax,	word ptr[%rsi+8]
    shr       %rax,	5
    and       %rax,	15
    cmp       %rax,	1
    jle       L3004
    lea       %rcx,	[%rip+mc_writegas.mstropnd.str]
    lea       %rdx,	[%rip+L8705]
    call      strcat
    movzx     %rax,	word ptr[%rsi+8]
    shr       %rax,	5
    and       %rax,	15
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.strint
    lea       %rcx,	[%rip+mc_writegas.mstropnd.str]
    mov       %rdx,	%rax
    call      strcat
L3004:
L3002:
    movzx     %rax,	word ptr[%rsi+8]
    shr       %rax,	12
    and       %rax,	15
    cmp       %rax,	5
    jz        L3007
    cmp       %rax,	6
    jz        L3007
    cmp       %rax,	8
    jnz       L3006
L3007:
    movzx     %rax,	byte ptr[%rsi+10]
    movzx     %r10,	byte ptr[%rsi+11]
    cmp       %r10,	%rax
    jnz       L3009
    test      %r10,	%r10
    jnz       L3009
    lea       %rcx,	[%rip+mc_writegas.mstropnd.str]
    lea       %rdx,	[%rip+L8706]
    call      strcat
L3009:
    mov       %al,	[%rdi]
    test      %al,	%al
    jz        L3011
    lea       %rcx,	[%rip+mc_writegas.mstropnd.str]
    mov       %rdx,	%rdi
    call      strcat
L3011:
    mov       %rcx,	%rsi
    call      mc_writegas.strvalue
    lea       %rcx,	[%rip+mc_writegas.mstropnd.str]
    mov       %rdx,	%rax
    call      strcat
    jmp       L3005
L3006:
    movsxd    %rax,	dword ptr[%rsi+12]
    mov       %rbx,	%rax
    test      %rax,	%rax
    jz        L3012
    lea       %rcx,	[%rbp + mc_writegas.mstropnd.str2]
    call      msys.m$print_startstr
    mov       %rcx,	%rbx
    lea       %rdx,	[%rip+L8707]
    call      msys.m$print_i64
    call      msys.m$print_end
    lea       %rcx,	[%rip+mc_writegas.mstropnd.str]
    lea       %rdx,	[%rbp + mc_writegas.mstropnd.str2]
    call      strcat
L3012:
L3005:
    lea       %rcx,	[%rip+mc_writegas.mstropnd.str]
    lea       %rdx,	[%rip+L8708]
    call      strcat
    jmp       L2989
L2993:
    movzx     %rax,	word ptr[%rsi+8]
    and       %rax,	31
    movzx     %r10,	byte ptr[%rsi+10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mc_writegas.strxreg
    jmp       L2988
L2994:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8709]
    call      msys.m$print_str_nf
    movzx     %rax,	word ptr[%rsi+8]
    shr       %rax,	9
    and       %rax,	7
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.m$print_u64
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rax,	[%rip+L8710]
    jmp       L2988
L2989:
    lea       %rax,	[%rip+mc_writegas.mstropnd.str]
L2988:
#---------------
    add       %rsp,	168
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writegas.strvalue
mc_writegas.strvalue:
#PROC1
#PROC2
#?>>
    .set mc_writegas.strvalue.str2, -128
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	160
    mov       %r12,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rdi,	[%r12]
    mov       %rbx,	[%r12]
    lea       %rcx,	[%rip+mc_writegas.strvalue.str]
    lea       %rdx,	[%rip+L8711]
    call      strcpy
    movzx     %rax,	word ptr[%r12+8]
    shr       %rax,	12
    and       %rax,	15
    cmp       %rax,	5
    jz        L3015
    cmp       %rax,	1
    jz        L3016
    cmp       %rax,	2
    jz        L3017
    cmp       %rax,	3
    jz        L3018
    cmp       %rax,	4
    jz        L3019
    cmp       %rax,	7
    jz        L3020
    cmp       %rax,	6
    jz        L3021
    cmp       %rax,	8
    jz        L3022
    jmp       L3023
L3015:
    mov       %rcx,	%rdi
    call      mc_writegas.getdispname
    lea       %rcx,	[%rip+mc_writegas.strvalue.str]
    mov       %rdx,	%rax
    call      strcat
#mc_writegas.strvalue.addoffset:
L3024:
    movsxd    %rax,	dword ptr[%r12+12]
    mov       %rsi,	%rax
    test      %rax,	%rax
    jz        L3026
    lea       %rcx,	[%rbp + mc_writegas.strvalue.str2]
    call      msys.m$print_startstr
    cmp       %rsi,	0
    jle       L3028
    lea       %rax,	[%rip+L8712]
    jmp       L3027
L3028:
    lea       %rax,	[%rip+L8713]
L3027:
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       %rcx,	%rsi
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rcx,	[%rip+mc_writegas.strvalue.str]
    lea       %rdx,	[%rbp + mc_writegas.strvalue.str2]
    call      strcat
L3026:
    jmp       L3014
L3016:
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      msys.strint
    lea       %rcx,	[%rip+mc_writegas.strvalue.str]
    mov       %rdx,	%rax
    call      strcat
    jmp       L3014
L3017:
    lea       %rcx,	[%rip+mc_writegas.strvalue.str]
    call      msys.m$print_startstr
    movq      %XMM4,	[%r12]
    movq      %XMM0,	%XMM4
    lea       %rdx,	[%rip+L8714]
    call      msys.m$print_r64
    call      msys.m$print_end
    jmp       L3014
L3018:
    lea       %rcx,	[%rip+mc_writegas.strvalue.str]
    lea       %rdx,	[%rip+L8715]
    call      strcat
    movq      %XMM4,	[%r12]
    movq      %XMM0,	%XMM4
    xor       %edx,	%edx
    call      msys.strreal
    lea       %rcx,	[%rip+mc_writegas.strvalue.str]
    mov       %rdx,	%rax
    call      strcat
    jmp       L3014
L3019:
    lea       %rcx,	[%rip+mc_writegas.strvalue.str]
    lea       %rdx,	[%rip+L8716]
    call      strcat
    mov       %rax,	[%r12]
    lea       %rcx,	[%rip+mc_writegas.strvalue.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rcx,	[%rip+mc_writegas.strvalue.str]
    lea       %rdx,	[%rip+L8716]
    call      strcat
    jmp       L3014
L3020:
    mov       %rax,	[%r12]
    lea       %rcx,	[%rip+mc_writegas.strvalue.str]
    mov       %rdx,	%rax
    call      strcat
    jmp       L3014
L3021:
    lea       %rcx,	[%rip+mc_writegas.strvalue.str]
    lea       %rdx,	[%rip+L8717]
    call      strcat
    mov       %rax,	[%r12]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.strint
    lea       %rcx,	[%rip+mc_writegas.strvalue.str]
    mov       %rdx,	%rax
    call      strcat
    jmp       L3024
L3022:
    mov       %rax,	[%r12]
    mov       %rcx,	[%rip+mc_decls.currasmproc]
    mov       %rdx,	%rax
    call      mc_writegas.gettempname
    jmp       L3013
L3023:
    lea       %rcx,	[%rip+L8718]
    lea       %rdx,	[%rip+L8719]
    call      pc_api.merror
L3014:
    lea       %rax,	[%rip+mc_writegas.strvalue.str]
L3013:
#---------------
    add       %rsp,	160
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writegas.asmopnd
mc_writegas.asmopnd:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      mc_writegas.mstropnd
    mov       %rcx,	%rax
    call      mc_writegas.asmstr
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writegas.getxregname
mc_writegas.getxregname:
#PROC1
#PROC2
#?>>
    .set mc_writegas.getxregname.size, 32
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    test      %rdi,	%rdi
    jnz       L3032
    lea       %rax,	[%rip+L8720]
    jmp       L3030
L3032:
    lea       %rcx,	[%rip+mc_writegas.getxregname.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8721]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rax,	[%rdi-1]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rax,	[%rip+mc_writegas.getxregname.str]
L3030:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_writegas.asmstr
mc_writegas.asmstr:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	[%rip+pc_decls.pdest]
    mov       %rdx,	%rdi
    call      mlib.gs_str
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_writegas.asmchar
mc_writegas.asmchar:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	[%rip+pc_decls.pdest]
    mov       %rdx,	%rdi
    call      mlib.gs_char
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_writegas.getdispname
mc_writegas.getdispname:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      pc_api.getfullname
L3035:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc mc_writegas.gettempname
mc_writegas.gettempname:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    mov       %al,	[%rip+pc_api.fpshortnames]
    test      %al,	%al
    jz        L3038
    lea       %rcx,	[%rip+mc_writegas.gettempname.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8722]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       %rcx,	%rbx
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L3037
L3038:
    lea       %rcx,	[%rip+mc_writegas.gettempname.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8723]
    call      msys.m$print_setfmt
    mov       %rcx,	%rdi
    call      mc_writegas.getdispname
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    mov       %rcx,	%rbx
    call      msys.m$print_i64_nf
    call      msys.m$print_end
L3037:
    lea       %rax,	[%rip+mc_writegas.gettempname.str]
L3036:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writegas.strreg
mc_writegas.strreg:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    lea       %rcx,	[%rip+mc_writegas.strreg.str]
    lea       %rdx,	[%rip+L8724]
    call      strcpy
    lea       %rax,	[%rip+mc_writegas.nregnames]
    mov       %r10,	%rbx
    shl       %r10,	7
    lea       %rax,	[%rax + %r10-128]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    lea       %rcx,	[%rip+mc_writegas.strreg.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rax,	[%rip+mc_writegas.strreg.str]
L3039:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writegas.strxreg
mc_writegas.strxreg:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      mc_writegas.checkregvar
    mov       %rdi,	%rax
    cmp       %rsi,	8
    jnz       L3042
    test      %rdi,	%rdi
    jz        L3042
    mov       %rcx,	%rdi
    call      mc_writegas.getdispname
    jmp       L3041
L3042:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      mc_writegas.getxregname
L3041:
L3040:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc mc_writegas.needsizeprefix
mc_writegas.needsizeprefix:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       %rax,	%rcx
    cmp       %rax,	18
    jz        L3045
    cmp       %rax,	19
    jz        L3045
    cmp       %rax,	86
    jz        L3045
    cmp       %rax,	87
    jz        L3045
    cmp       %rax,	82
    jz        L3046
    cmp       %rax,	83
    jz        L3046
    cmp       %rax,	84
    jz        L3046
    cmp       %rax,	85
    jz        L3046
    cmp       %rax,	43
    jz        L3047
    cmp       %rax,	45
    jz        L3047
    cmp       %rax,	44
    jz        L3047
    jmp       L3048
L3045:
    mov       %rax,	1
    jmp       L3043
L3046:
    mov       %rax,	1
    jmp       L3043
L3047:
    movzx     %rax,	word ptr[%rdx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	3
    jnz       L3050
    mov       %rax,	1
    jmp       L3043
L3050:
    xor       %eax,	%eax
    jmp       L3043
L3048:
L3044:
    movzx     %rax,	word ptr[%rdx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jz        L3053
    movzx     %rax,	word ptr[%rdx+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	5
    jz        L3053
    movzx     %rax,	word ptr[%r8+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	1
    jz        L3053
    movzx     %rax,	word ptr[%r8+8]
    shr       %rax,	9
    and       %rax,	7
    cmp       %rax,	5
    jnz       L3052
L3053:
    xor       %eax,	%eax
    jmp       L3043
L3052:
    mov       %rax,	1
L3043:
#---------------
    ret       
# End 
# Proc mc_writegas.getsizeprefix
mc_writegas.getsizeprefix:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    test      %rdx,	%rdx
    jnz       L3056
    lea       %rax,	[%rip+L8725]
    jmp       L3054
L3056:
    mov       %rax,	%rcx
    cmp       %rax,	1
    jz        L3058
    cmp       %rax,	2
    jz        L3059
    cmp       %rax,	4
    jz        L3060
    cmp       %rax,	8
    jz        L3061
    jmp       L3062
L3058:
    lea       %rax,	[%rip+L8726]
    jmp       L3054
L3059:
    lea       %rax,	[%rip+L8727]
    jmp       L3054
L3060:
    lea       %rax,	[%rip+L8728]
    jmp       L3054
L3061:
    lea       %rax,	[%rip+L8729]
    jmp       L3054
L3062:
L3057:
    lea       %rax,	[%rip+L8730]
L3054:
#---------------
    ret       
# End 
# Proc mc_writegas.checkregvar
mc_writegas.checkregvar:
#PROC1
#PROC2
#?>>
    .set mc_writegas.checkregvar.reg, 16
    .set mc_writegas.checkregvar.ispfloat, 24
#?]]
#---------------
#PROC3
#PROC4
    xor       %eax,	%eax
L3063:
#---------------
    ret       
# End 
# Proc mc_writeexe_dummy.genexe
mc_writeexe_dummy.genexe:
#PROC1
#PROC2
#?>>
    .set mc_writeexe_dummy.genexe.entrypoint, 16
    .set mc_writeexe_dummy.genexe.outfile, 24
    .set mc_writeexe_dummy.genexe.dodll, 32
#?]]
#---------------
#PROC3
#PROC4
#---------------
    ret       
# End 
# Proc mc_writeexe_dummy.writeexe
mc_writeexe_dummy.writeexe:
#PROC1
#PROC2
#?>>
    .set mc_writeexe_dummy.writeexe.outfile, 16
    .set mc_writeexe_dummy.writeexe.dodll, 24
#?]]
#---------------
#PROC3
#PROC4
#---------------
    ret       
# End 
# Proc mc_writeobj_dummy.writecoff
mc_writeobj_dummy.writecoff:
#PROC1
#PROC2
#?>>
    .set mc_writeobj_dummy.writecoff.outfile, 16
#?]]
#---------------
#PROC3
#PROC4
#---------------
    ret       
# End 
# Proc mc_writess_dummy.writessdata
mc_writess_dummy.writessdata:
#PROC1
#PROC2
#?>>
    .set mc_writess_dummy.writessdata.fexe, 16
#?]]
#---------------
#PROC3
#PROC4
    xor       %eax,	%eax
L3067:
#---------------
    ret       
# End 
# Proc mx_run_dummy.runlibfile
mx_run_dummy.runlibfile:
#PROC1
#PROC2
#?>>
    .set mx_run_dummy.runlibfile.filename, 16
    .set mx_run_dummy.runlibfile.cmdskip, 24
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    lea       %rcx,	[%rip+L8731]
    call      mlib.abortprogram
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc mx_run_dummy.writemcx
mx_run_dummy.writemcx:
#PROC1
#PROC2
#?>>
    .set mx_run_dummy.writemcx.filename, 16
#?]]
#---------------
#PROC3
#PROC4
#---------------
    ret       
# End 
# Proc cc_cli.main
cc_cli.main:
main:
#PROC1
#PROC2
#?>>
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    call      msyswin.start
    call      pepcl.start
    call      mwindows.os_clock
    mov       [%rip+cc_cli.startclock],	%rax
    mov       %rax,	[%rip+cc_cli.startclock]
    mov       [%rip+pc_decls.pstartclock],	%rax
    call      cc_cli.starttiming
    call      cc_cli.initdata
    call      cc_cli.getinputoptions
    call      cc_cli.initsearchdirs
    movzx     %rax,	byte ptr[%rip+cc_cli.fverbose]
    cmp       %rax,	3
    jnz       L3072
    call      cc_cli.showsearchdirs
L3072:
    call      cc_cli.initlogfile
    call      cc_cli.gettiming
    mov       [%rip+cc_cli.inittime],	%rax
    mov       %al,	[%rip+cc_cli.fverbose]
    test      %al,	%al
    jz        L3074
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8732]
    call      msys.m$print_setfmt
    mov       %rcx,	[%rip+cc_decls.inputfile]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+cc_cli.outfile]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L3074:
    mov       %rcx,	[%rip+cc_decls.inputfile]
    call      mlib.extractbasefile
    mov       %rcx,	%rax
    call      mlib.pcm_copyheapstring
    mov       [%rip+pc_decls.$pmodulename],	%rax
    call      cc_cli.do_loadmodule
    call      cc_cli.do_preprocess
    call      cc_cli.do_parsemodule
    call      cc_cli.do_genpcl
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	6
    jz        L3076
    cmp       %rax,	7
    jz        L3077
    cmp       %rax,	8
    jz        L3078
    cmp       %rax,	10
    jz        L3079
    cmp       %rax,	11
    jz        L3080
    cmp       %rax,	12
    jz        L3081
    cmp       %rax,	9
    jz        L3082
    cmp       %rax,	13
    jz        L3083
    jmp       L3084
L3076:
    call      pc_run_dummy.pcl_runpcl
    jmp       L3075
L3077:
    call      cc_cli.do_genmcl
    jmp       L3075
L3078:
    call      cc_cli.do_asm
    jmp       L3075
L3079:
    call      cc_cli.do_obj
    jmp       L3075
L3080:
    call      cc_cli.do_dll
    jmp       L3075
L3081:
    call      cc_cli.do_exe
    jmp       L3075
L3082:
    call      cc_cli.do_mx
    jmp       L3075
L3083:
    call      cc_cli.do_run
    jmp       L3075
L3084:
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	7
    jl        L3086
    call      msys.m$print_startcon
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    lea       %r10,	[%rip+cc_cli.passnames]
    mov       %r10,	[%r10 + %rax*8-8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L8733]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L3086:
L3075:
    movzx     %rax,	byte ptr[%rip+cc_cli.fverbose]
    cmp       %rax,	2
    jl        L3088
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8734]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L3088:
    mov       %al,	[%rip+cc_cli.fshowtiming]
    test      %al,	%al
    jz        L3090
    call      cc_cli.showtiming
L3090:
    call      cc_cli.closelogfile
    xor       %ecx,	%ecx
    call      exit
    xor       %ecx,	%ecx
    call      exit
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.do_preprocess
cc_cli.do_preprocess:
#PROC1
#PROC2
#?>>
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	2
    jnz       L3093
    movzx     %rax,	byte ptr[%rip+cc_cli.fstdout]
    mov       %rcx,	[%rip+cc_decls.inputfile]
    mov       %rdx,	[%rip+cc_cli.outfile]
    mov       %r8,	%rax
    call      cc_lex.lex_preprocess_only
    xor       %ecx,	%ecx
    call      exit
L3093:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.do_loadmodule
cc_cli.do_loadmodule:
#PROC1
#PROC2
#?>>
    .set cc_cli.do_loadmodule.path, -304
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	336
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+cc_cli.fverbose]
    cmp       %rax,	3
    jnz       L3096
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8735]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+cc_decls.inputfile]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L3096:
    call      cc_cli.starttiming
    lea       %rax,	[%rip+L8736]
    lea       %r10,	[%rip+cc_decls.sourcefilenames]
    mov       [%r10],	%rax
    lea       %rax,	[%rip+L8737]
    lea       %r10,	[%rip+cc_decls.sourcefilepaths]
    mov       [%r10],	%rax
    lea       %rax,	[%rip+L8738]
    lea       %r10,	[%rip+cc_decls.sourcefiletext]
    mov       [%r10],	%rax
    lea       %rax,	[%rip+cc_decls.sourcefiletext]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    call      strlen
    lea       %r10,	[%rip+cc_decls.sourcefilesizes]
    mov       [%r10],	%eax
    lea       %rcx,	[%rip+L8739]
    call      cc_lex.addnamestr
    xor       %ecx,	%ecx
    mov       %rdx,	%rax
    mov       %r8,	2
    call      cc_lib.createdupldef
    mov       [%rip+cc_decls.stprogram],	%rax
    mov       %rcx,	[%rip+cc_decls.inputfile]
    call      mlib.checkfile
    test      %rax,	%rax
    jnz       L3098
    lea       %rcx,	[%rip+L8740]
    mov       %rdx,	[%rip+cc_decls.inputfile]
    call      cc_support.loaderror
L3098:
    mov       %rcx,	[%rip+cc_decls.inputfile]
    mov       %rdx,	[%rip+cc_decls.inputfile]
    call      cc_support.loadsourcefile
    mov       [%rip+cc_decls.mainfileno],	%rax
    mov       %rcx,	[%rip+cc_decls.inputfile]
    call      mlib.extractbasefile
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    call      cc_lex.addnamestr
    mov       %rcx,	[%rip+cc_decls.stprogram]
    mov       %rdx,	%rax
    mov       %r8,	3
    call      cc_lib.createdupldef
    mov       [%rip+cc_decls.stmodule],	%rax
    mov       %rcx,	[%rip+cc_decls.inputfile]
    call      mlib.extractpath
    lea       %rcx,	[%rbp + cc_cli.do_loadmodule.path]
    mov       %rdx,	%rax
    call      strcpy
    mov       %al,	[%rbp + cc_cli.do_loadmodule.path]
    test      %al,	%al
    jz        L3100
    inc       qword ptr[%rip+cc_decls.nsearchdirs]
    mov       %rbx,	[%rip+cc_decls.nsearchdirs]
    cmp       %rbx,	2
    jl        L3103
L3101:
    lea       %rax,	[%rip+cc_decls.searchdirs]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8-16]
    lea       %r10,	[%rip+cc_decls.searchdirs]
    mov       %r11,	%rbx
    mov       [%r10 + %r11*8-8],	%rax
    dec       %rbx
    cmp       %rbx,	2
    jge       L3101
L3103:
    lea       %rcx,	[%rbp + cc_cli.do_loadmodule.path]
    call      mlib.pcm_copyheapstring
    lea       %r10,	[%rip+cc_decls.searchdirs]
    mov       [%r10],	%rax
L3100:
    call      cc_cli.gettiming
    mov       [%rip+cc_cli.loadtime],	%rax
#---------------
    add       %rsp,	336
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_cli.do_parsemodule
cc_cli.do_parsemodule:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    call      cc_cli.starttiming
    call      cc_parse.parsemodule
    call      cc_cli.gettiming
    mov       %rdi,	%rax
    mov       [%rip+cc_cli.parsetime],	%rax
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_cli.do_genpcl
cc_cli.do_genpcl:
#PROC1
#PROC2
#?>>
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	5
    jl        L3105
L3107:
    call      cc_cli.starttiming
    call      cc_genpcl.codegen_pcl
    call      cc_cli.gettiming
    mov       [%rip+cc_cli.pcltime],	%rax
    mov       %al,	[%rip+pc_decls.fregoptim]
    test      %al,	%al
    jnz       L3110
    mov       %al,	[%rip+pc_decls.fpeephole]
    test      %al,	%al
    jz        L3109
L3110:
    call      pc_reduce.pcl_reducetest
L3109:
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	5
    jnz       L3112
    mov       %rcx,	[%rip+cc_cli.outfile]
    call      pc_api.pcl_writepcl
L3112:
L3105:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.do_genmcl
cc_cli.do_genmcl:
#PROC1
#PROC2
#?>>
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	7
    jl        L3113
L3115:
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	7
    jnz       L3117
    mov       %rcx,	[%rip+cc_cli.outfile]
    mov       %rdx,	16705
    call      pc_api.pcl_writeasm
L3117:
L3113:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.do_asm
cc_cli.do_asm:
#PROC1
#PROC2
#?>>
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	8
    jl        L3118
L3120:
    mov       %rcx,	[%rip+cc_cli.outfile]
    mov       %rdx,	16705
    call      pc_api.pcl_writeasm
L3118:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.do_obj
cc_cli.do_obj:
#PROC1
#PROC2
#?>>
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	10
    jnz       L3121
L3123:
    mov       %rcx,	[%rip+cc_cli.outfile]
    call      pc_api.pcl_writeobj
L3121:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.do_dll
cc_cli.do_dll:
#PROC1
#PROC2
#?>>
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	11
    jnz       L3124
L3126:
    mov       %rcx,	[%rip+cc_cli.outfile]
    call      pc_api.pcl_writedll
L3124:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.do_exe
cc_cli.do_exe:
#PROC1
#PROC2
#?>>
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	12
    jnz       L3127
L3129:
    mov       %rcx,	[%rip+cc_cli.outfile]
    call      pc_api.pcl_writeexe
L3127:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.do_mx
cc_cli.do_mx:
#PROC1
#PROC2
#?>>
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	9
    jnz       L3130
L3132:
    mov       %rcx,	[%rip+cc_cli.outfile]
    call      pc_api.pcl_writemx
L3130:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.do_run
cc_cli.do_run:
#PROC1
#PROC2
#?>>
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	13
    jnz       L3133
L3135:
    call      pc_api.pcl_exec
L3133:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.initlogfile
cc_cli.initlogfile:
#PROC1
#PROC2
#?>>
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+cc_cli.debugmode]
    cmp       %rax,	2
    jl        L3138
    lea       %rcx,	[%rip+L8741]
    call      remove
    lea       %rcx,	[%rip+L8741]
    lea       %rdx,	[%rip+L8742]
    call      fopen
    mov       [%rip+cc_decls.logdev],	%rax
L3138:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.closelogfile
cc_cli.closelogfile:
#PROC1
#PROC2
#?>>
    .set cc_cli.closelogfile.str, -104
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	144
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+cc_cli.debugmode]
    cmp       %rax,	2
    jl        L3139
L3141:
    mov       %al,	[%rip+cc_cli.fshowmcl]
    test      %al,	%al
    jz        L3143
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	7
    jl        L3143
    mov       %rcx,	[%rip+cc_decls.logdev]
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L8743]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	[%rip+cc_decls.logdev]
    call      msys.m$print_startfile
    xor       %ecx,	%ecx
    mov       %rdx,	16705
    call      pc_api.pcl_writeasm
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L3143:
    mov       %al,	[%rip+cc_cli.fshowpcl]
    test      %al,	%al
    jz        L3145
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	5
    jl        L3145
    mov       %rcx,	[%rip+cc_decls.logdev]
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L8744]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	[%rip+cc_decls.logdev]
    call      msys.m$print_startfile
    xor       %ecx,	%ecx
    call      pc_api.pcl_writepcl
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %al,	[%rip+cc_cli.fshowpst]
    test      %al,	%al
    jz        L3147
    lea       %rcx,	[%rip+L8745]
    call      pc_api.pcl_writepst
    lea       %rcx,	[%rip+L8745]
    mov       %rdx,	[%rip+cc_decls.logdev]
    call      cc_lib.addtolog
L3147:
L3145:
    call      cc_cli.showast
    mov       %al,	[%rip+cc_cli.fshowst]
    test      %al,	%al
    jz        L3149
    lea       %rcx,	[%rip+L8746]
    call      cc_cli.showst
L3149:
    mov       %al,	[%rip+cc_cli.fshowstflat]
    test      %al,	%al
    jz        L3151
    lea       %rcx,	[%rip+L8747]
    call      cc_cli.showstflat
L3151:
    mov       %al,	[%rip+cc_cli.fshowtypes]
    test      %al,	%al
    jz        L3153
    mov       %rcx,	[%rip+cc_decls.logdev]
    call      cc_show.printmodelist
L3153:
    mov       %rcx,	[%rip+cc_decls.logdev]
    call      fclose
    lea       %rcx,	[%rip+L8748]
    call      mlib.checkfile
    test      %rax,	%rax
    jz        L3155
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8749]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      mwindows.os_getch
    cmp       %rax,	27
    jnz       L3157
    xor       %ecx,	%ecx
    call      exit
L3157:
    lea       %rcx,	[%rbp + cc_cli.closelogfile.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8750]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L8751]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + cc_cli.closelogfile.str]
    xor       %edx,	%edx
    xor       %r8d,	%r8d
    call      mwindows.os_execwait
    jmp       L3154
L3155:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8752]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L8753]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L3154:
L3139:
#---------------
    add       %rsp,	144
    pop       %rbp
    ret       
# End 
# Proc cc_cli.initdata
cc_cli.initdata:
#PROC1
#PROC2
#?>>
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    call      mlib.pcm_init
    call      cc_lex.lexsetup
    call      cc_lib.inittypetables
    call      cc_lib.initcclib
    xor       %eax,	%eax
    mov       [%rip+cc_decls.nlibfiles],	%rax
    inc       qword ptr[%rip+cc_decls.nlibfiles]
    mov       %rax,	[%rip+cc_decls.nlibfiles]
    lea       %r10,	[%rip+L8754]
    lea       %r11,	[%rip+cc_decls.libfiles]
    mov       [%r11 + %rax*8],	%r10
    inc       qword ptr[%rip+cc_decls.nlibfiles]
    mov       %rax,	[%rip+cc_decls.nlibfiles]
    lea       %r10,	[%rip+L8755]
    lea       %r11,	[%rip+cc_decls.libfiles]
    mov       [%r11 + %rax*8],	%r10
    inc       qword ptr[%rip+cc_decls.nlibfiles]
    mov       %rax,	[%rip+cc_decls.nlibfiles]
    lea       %r10,	[%rip+L8756]
    lea       %r11,	[%rip+cc_decls.libfiles]
    mov       [%r11 + %rax*8],	%r10
    inc       qword ptr[%rip+cc_decls.nlibfiles]
    mov       %rax,	[%rip+cc_decls.nlibfiles]
    lea       %r10,	[%rip+L8757]
    lea       %r11,	[%rip+cc_decls.libfiles]
    mov       [%r11 + %rax*8],	%r10
    lea       %rax,	[%rip+cc_cli.cgetsourceinfo]
    mov       [%rip+pc_decls.igetmsourceinfo],	%rax
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.cgetsourceinfo
cc_cli.cgetsourceinfo:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       %rax,	%rcx
    shr       %rax,	24
    and       %rax,	511
    lea       %r10,	[%rip+cc_decls.sourcefilenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       [%rdx],	%r10
    lea       %rax,	[%rip+L8758]
    mov       [%r8],	%rax
    mov       %rax,	%rcx
    and       %rax,	16777215
L3159:
#---------------
    ret       
# End 
# Proc cc_cli.initsearchdirs
cc_cli.initsearchdirs:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    inc       qword ptr[%rip+cc_decls.nsearchdirs]
    mov       %rax,	[%rip+cc_decls.nsearchdirs]
    lea       %r10,	[%rip+L8759]
    lea       %r11,	[%rip+cc_decls.searchdirs]
    mov       [%r11 + %rax*8-8],	%r10
    inc       qword ptr[%rip+cc_decls.nsearchdirs]
    mov       %rax,	[%rip+cc_decls.nsearchdirs]
    lea       %r10,	[%rip+L8760]
    lea       %r11,	[%rip+cc_decls.searchdirs]
    mov       [%r11 + %rax*8-8],	%r10
    call      mwindows.os_gethostname
    mov       %rcx,	%rax
    call      mlib.extractpath
    mov       %rcx,	%rax
    call      mlib.pcm_copyheapstring
    inc       qword ptr[%rip+cc_decls.nsearchdirs]
    mov       %r10,	[%rip+cc_decls.nsearchdirs]
    lea       %r11,	[%rip+cc_decls.searchdirs]
    mov       [%r11 + %r10*8-8],	%rax
    mov       %rdi,	1
    mov       %rax,	[%rip+cc_decls.nincludepaths]
    cmp       %rax,	1
    jl        L3163
L3161:
    lea       %rax,	[%rip+cc_decls.includepaths]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    mov       %al,	[%rax]
    test      %al,	%al
    jz        L3165
    lea       %rax,	[%rip+cc_decls.includepaths]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    inc       qword ptr[%rip+cc_decls.nsearchdirs]
    mov       %r10,	[%rip+cc_decls.nsearchdirs]
    lea       %r11,	[%rip+cc_decls.searchdirs]
    mov       [%r11 + %r10*8-8],	%rax
L3165:
    inc       %rdi
    cmp       %rdi,	[%rip+cc_decls.nincludepaths]
    jle       L3161
L3163:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_cli.showsearchdirs
cc_cli.showsearchdirs:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8761]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %al,	[%rip+cc_cli.dointheaders]
    test      %al,	%al
    jz        L3168
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8762]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L3168:
    mov       %rdi,	1
    mov       %rax,	[%rip+cc_decls.nsearchdirs]
    cmp       %rax,	1
    jl        L3171
L3169:
    lea       %rax,	[%rip+cc_decls.searchdirs]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    mov       %al,	[%rax]
    test      %al,	%al
    jz        L3173
    call      msys.m$print_startcon
    mov       %rcx,	%rdi
    call      msys.m$print_i64_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L8763]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.searchdirs]
    mov       %r10,	%rdi
    mov       %rcx,	[%rax + %r10*8-8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L3172
L3173:
    call      msys.m$print_startcon
    mov       %rcx,	%rdi
    call      msys.m$print_i64_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L8764]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L3172:
    inc       %rdi
    cmp       %rdi,	[%rip+cc_decls.nsearchdirs]
    jle       L3169
L3171:
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_cli.showast
cc_cli.showast:
#PROC1
#PROC2
#?>>
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    mov       %al,	[%rip+cc_cli.fshowast]
    test      %al,	%al
    jz        L3176
    mov       %rcx,	[%rip+cc_decls.logdev]
    lea       %rdx,	[%rip+L8765]
    call      cc_show.printcode
    mov       %rcx,	[%rip+cc_decls.logdev]
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
L3176:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.showstflat
cc_cli.showstflat:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	[%rip+cc_decls.logdev]
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L8766]
    call      msys.m$print_str_nf
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	[%rip+cc_decls.logdev]
    call      cc_show.printstflat
    mov       %rcx,	[%rip+cc_decls.logdev]
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_cli.showst
cc_cli.showst:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	[%rip+cc_decls.logdev]
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L8766]
    call      msys.m$print_str_nf
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	[%rip+cc_decls.logdev]
    mov       %rdx,	[%rip+cc_decls.stmodule]
    xor       %r8d,	%r8d
    call      cc_show.printst
    mov       %rcx,	[%rip+cc_decls.logdev]
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_cli.showfiles
cc_cli.showfiles:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8767]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rdi,	1
    mov       %rax,	[%rip+cc_decls.nsourcefiles]
    cmp       %rax,	1
    jl        L3182
L3180:
    call      msys.m$print_startcon
    mov       %rcx,	%rdi
    call      msys.m$print_i64_nf
    lea       %rcx,	[%rip+L8768]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.sourcefilepaths]
    mov       %r10,	%rdi
    mov       %rcx,	[%rax + %r10*8]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.sourcefilenames]
    mov       %r10,	%rdi
    mov       %rcx,	[%rax + %r10*8]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L8769]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.sourcefilesizes]
    mov       %r10,	%rdi
    movsxd    %rax,	dword ptr[%rax + %r10*4]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    inc       %rdi
    cmp       %rdi,	[%rip+cc_decls.nsourcefiles]
    jle       L3180
L3182:
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_cli.showtime
cc_cli.showtime:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8770]
    call      msys.m$print_setfmt
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8771]
    call      msys.m$print_str
    mov       %rcx,	%rbx
    lea       %rdx,	[%rip+L8772]
    call      msys.m$print_i64
    mov       %rax,	%rbx
    cvtsi2sd  %XMM4,	%rax
    mulsd     %XMM4,	[%rip+L8773]
    mov       %rax,	[%rip+cc_cli.compiletime]
    cvtsi2sd  %XMM5,	%rax
    divsd     %XMM4,	%XMM5
    movq      %XMM0,	%XMM4
    lea       %rdx,	[%rip+L8774]
    call      msys.m$print_r64
    call      msys.m$print_newline
    call      msys.m$print_end
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_cli.showtiming
cc_cli.showtiming:
#PROC1
#PROC2
#?>>
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    call      mwindows.os_clock
    sub       %rax,	[%rip+cc_cli.startclock]
    mov       [%rip+cc_cli.compiletime],	%rax
    lea       %rcx,	[%rip+L8775]
    mov       %rdx,	[%rip+cc_cli.inittime]
    call      cc_cli.showtime
    lea       %rcx,	[%rip+L8776]
    mov       %rdx,	[%rip+cc_cli.loadtime]
    call      cc_cli.showtime
    lea       %rcx,	[%rip+L8777]
    mov       %rdx,	[%rip+cc_cli.parsetime]
    call      cc_cli.showtime
    lea       %rcx,	[%rip+L8778]
    mov       %rdx,	[%rip+cc_cli.pcltime]
    call      cc_cli.showtime
    lea       %rcx,	[%rip+L8779]
    mov       %rdx,	[%rip+pc_decls.mcltime]
    call      cc_cli.showtime
    lea       %rcx,	[%rip+L8780]
    mov       %rdx,	[%rip+pc_decls.sstime]
    call      cc_cli.showtime
    lea       %rcx,	[%rip+L8781]
    mov       %rdx,	[%rip+pc_decls.exetime]
    call      cc_cli.showtime
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8782]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8783]
    mov       %rdx,	[%rip+cc_cli.compiletime]
    call      cc_cli.showtime
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.getinputoptions
cc_cli.getinputoptions:
#PROC1
#PROC2
#?>>
    .set cc_cli.getinputoptions.paramno, -8
    .set cc_cli.getinputoptions.name, -16
    .set cc_cli.getinputoptions.value, -24
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	64
#---------------
#PROC3
#PROC4
    mov       %rax,	1
    mov       [%rbp + cc_cli.getinputoptions.paramno],	%rax
    xor       %rsi,	%rsi
    mov       %al,	[%rip+pepcl.pc_userunpcl]
    test      %al,	%al
    jz        L3187
    mov       %al,	6
    mov       [%rip+cc_cli.cc_pass],	%al
    xor       %eax,	%eax
    mov       [%rip+cc_cli.fverbose],	%al
L3187:
    call      mwindows.os_gethostname
    mov       %rcx,	%rax
    call      mlib.extractfile
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8784]
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L3189
    xor       %eax,	%eax
    mov       [%rip+cc_cli.fverbose],	%al
    mov       %rcx,	17
    lea       %rdx,	[%rip+L8785]
    call      cc_cli.do_option
L3189:
L3190:
    lea       %rcx,	[%rbp + cc_cli.getinputoptions.paramno]
    lea       %rdx,	[%rbp + cc_cli.getinputoptions.name]
    lea       %r8,	[%rbp + cc_cli.getinputoptions.value]
    lea       %r9,	[%rip+L8786]
    call      mlib.nextcmdparamnew
    mov       %rdi,	%rax
    mov       %rax,	%rdi
    cmp       %rax,	1
    jz        L3193
    cmp       %rax,	2
    jz        L3194
    cmp       %rax,	3
    jz        L3195
    test      %rax,	%rax
    jz        L3196
    jmp       L3197
L3193:
    mov       %rcx,	[%rbp + cc_cli.getinputoptions.name]
    call      mlib.convlcstring
    mov       %rbx,	1
    mov       %r12,	49
    cmp       %r12,	1
    jl        L3201
L3198:
    lea       %rax,	[%rip+cc_cli.optionnames]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rcx,	[%rbp + cc_cli.getinputoptions.name]
    mov       %rdx,	%rax
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L3203
    mov       %rcx,	%rbx
    mov       %rdx,	[%rbp + cc_cli.getinputoptions.value]
    call      cc_cli.do_option
    jmp       L3200
L3203:
    inc       %rbx
    cmp       %rbx,	%r12
    jle       L3198
L3201:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8787]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rbp + cc_cli.getinputoptions.name]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	1
    call      exit
L3200:
    jmp       L3192
L3194:
    mov       %rax,	[%rip+cc_decls.inputfile]
    test      %rax,	%rax
    jz        L3205
    lea       %rcx,	[%rip+L8788]
    lea       %rdx,	[%rip+L8789]
    call      cc_support.loaderror
L3205:
    mov       %rcx,	[%rbp + cc_cli.getinputoptions.name]
    call      mlib.pcm_copyheapstring
    mov       [%rip+cc_decls.inputfile],	%rax
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	13
    jz        L3208
    cmp       %rax,	6
    jnz       L3207
L3208:
    mov       %rax,	[%rbp + cc_cli.getinputoptions.paramno]
    dec       %rax
    add       %rax,	[%rip+msys.$cmdskip]
    mov       [%rip+cc_cli.cmdskip],	%rax
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	6
    setz      %al
    movzx     %eax,	%al
    mov       [%rip+cc_decls.pci_target],	%al
    jmp       L3191
L3207:
    jmp       L3192
L3195:
    mov       %rax,	[%rip+cc_decls.nlibfiles]
    cmp       %rax,	200
    jl        L3210
    lea       %rcx,	[%rip+L8790]
    lea       %rdx,	[%rip+L8791]
    call      cc_support.loaderror
L3210:
    mov       %rcx,	[%rbp + cc_cli.getinputoptions.name]
    call      mlib.pcm_copyheapstring
    inc       qword ptr[%rip+cc_decls.nlibfiles]
    mov       %r10,	[%rip+cc_decls.nlibfiles]
    lea       %r11,	[%rip+cc_decls.libfiles]
    mov       [%r11 + %r10*8],	%rax
    jmp       L3192
L3196:
    jmp       L3191
L3197:
L3192:
    jmp       L3190
L3191:
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    test      %rax,	%rax
    jnz       L3212
    mov       %al,	12
    mov       [%rip+cc_cli.cc_pass],	%al
    mov       %al,	[%rip+pepcl.asmonly]
    test      %al,	%al
    jz        L3214
    mov       %al,	8
    mov       [%rip+cc_cli.cc_pass],	%al
L3214:
L3212:
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	11
    jz        L3217
    cmp       %rax,	10
    jnz       L3216
L3217:
    mov       %al,	2
    mov       [%rip+cc_cli.highmem],	%al
    jmp       L3215
L3216:
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	9
    jz        L3219
    cmp       %rax,	13
    jnz       L3218
L3219:
    xor       %eax,	%eax
    mov       [%rip+cc_cli.highmem],	%al
L3218:
L3215:
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    lea       %r10,	[%rip+cc_cli.extnames]
    mov       %r10,	[%r10 + %rax*8-8]
    mov       [%rip+cc_cli.outext],	%r10
    movzx     %rax,	byte ptr[%rip+cc_cli.cc_pass]
    cmp       %rax,	7
    jz        L3222
    cmp       %rax,	8
    jnz       L3221
L3222:
    mov       %rax,	[%rip+mc_writegas.asmext]
    mov       [%rip+cc_cli.outext],	%rax
L3221:
    mov       %rax,	[%rip+cc_decls.inputfile]
    test      %rax,	%rax
    jnz       L3224
    mov       %al,	[%rip+cc_cli.fwriteheaders]
    test      %al,	%al
    jnz       L3224
    call      cc_cli.showcaption
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8792]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8793]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       %rax,	[%rip+msys.cmdparams]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L8794]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8795]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       %rax,	[%rip+msys.cmdparams]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L8796]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8797]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       %rax,	[%rip+msys.cmdparams]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L8798]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8799]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       %rax,	[%rip+msys.cmdparams]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L8800]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	1
    call      exit
L3224:
    mov       %al,	[%rip+cc_cli.fwriteheaders]
    test      %al,	%al
    jz        L3226
    call      cc_headers.writeheaders
    mov       %rcx,	20
    call      exit
L3226:
    mov       %rax,	[%rip+cc_cli.outfile]
    test      %rax,	%rax
    jnz       L3228
    mov       %rcx,	[%rip+cc_decls.inputfile]
    mov       %rdx,	[%rip+cc_cli.outext]
    call      mlib.changeext
    mov       %rcx,	%rax
    call      mlib.pcm_copyheapstring
    mov       [%rip+cc_cli.outfile],	%rax
L3228:
    movzx     %rax,	byte ptr[%rip+cc_cli.fshortnames]
    movzx     %r10,	byte ptr[%rip+cc_cli.highmem]
    mov       %rcx,	%r10
    mov       %rdx,	-1
    mov       %r8,	%rax
    call      pc_api.pcl_setflags
    mov       %rcx,	[%rip+cc_cli.cmdskip]
    xor       %edx,	%edx
    call      pc_api.pcl_cmdskip
#---------------
    add       %rsp,	64
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_cli.do_option
cc_cli.do_option:
#PROC1
#PROC2
#?>>
    .set cc_cli.do_option.str, -304
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	336
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rip+cc_cli.optvars]
    mov       %r10,	%rsi
    mov       %rbx,	[%rax + %r10*8-8]
    test      %rbx,	%rbx
    jz        L3231
    lea       %rax,	[%rip+cc_cli.optvalues]
    mov       %r10,	%rsi
    mov       %al,	[%rax + %r10-1]
    mov       [%rbx],	%al
    mov       %rax,	%rsi
    cmp       %rax,	1
    jl        L3233
    cmp       %rax,	9
    jg        L3233
    mov       %al,	1
    or        [%rip+cc_cli.debugmode],	%al
L3233:
    mov       %rax,	%rsi
    cmp       %rax,	25
    jl        L3235
    cmp       %rax,	33
    jg        L3235
    mov       %al,	2
    or        [%rip+cc_cli.debugmode],	%al
L3235:
    cmp       %rsi,	8
    jnz       L3237
    mov       %rax,	[%rip+cc_decls.inputfile]
    test      %rax,	%rax
    jz        L3237
    lea       %rcx,	[%rip+L8801]
    lea       %rdx,	[%rip+L8802]
    call      cc_support.loaderror
L3237:
    mov       %rax,	%rsi
    cmp       %rax,	3
    jz        L3240
    cmp       %rax,	7
    jnz       L3239
L3240:
    mov       %al,	1
    mov       [%rip+cc_decls.pci_target],	%al
L3239:
    jmp       L3229
L3231:
    mov       %rax,	%rsi
    cmp       %rax,	23
    jz        L3242
    cmp       %rax,	41
    jz        L3243
    cmp       %rax,	42
    jz        L3243
    cmp       %rax,	45
    jz        L3244
    cmp       %rax,	20
    jz        L3245
    jmp       L3246
L3242:
    mov       %rax,	[%rip+cc_decls.nincludepaths]
    cmp       %rax,	20
    jle       L3248
    lea       %rcx,	[%rip+L8803]
    lea       %rdx,	[%rip+L8804]
    call      cc_support.loaderror
L3248:
    mov       %rcx,	%r12
    call      strlen
    mov       %rdi,	%rax
    lea       %rax,	[%r12 + %rdi]
    sub       %rax,	1
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	92
    jz        L3250
    cmp       %rax,	47
    jnz       L3251
L3250:
    jmp       L3249
L3251:
    lea       %rcx,	[%rbp + cc_cli.do_option.str]
    mov       %rdx,	%r12
    call      strcpy
    lea       %rcx,	[%rbp + cc_cli.do_option.str]
    lea       %rdx,	[%rip+L8805]
    call      strcat
    lea       %rax,	[%rbp + cc_cli.do_option.str]
    mov       %r12,	%rax
L3249:
    mov       %rcx,	%r12
    call      mlib.pcm_copyheapstring
    inc       qword ptr[%rip+cc_decls.nincludepaths]
    mov       %r10,	[%rip+cc_decls.nincludepaths]
    lea       %r11,	[%rip+cc_decls.includepaths]
    mov       [%r11 + %r10*8-8],	%rax
    jmp       L3241
L3243:
    call      cc_cli.showhelp
    jmp       L3241
L3244:
    mov       %rcx,	%r12
    mov       %rdx,	[%rip+cc_cli.outext]
    call      mlib.addext
    mov       %rcx,	%rax
    call      mlib.pcm_copyheapstring
    mov       [%rip+cc_cli.outfile],	%rax
    jmp       L3241
L3245:
    xor       %eax,	%eax
    mov       [%rip+pc_decls.fpeephole],	%al
    mov       [%rip+pc_decls.fregoptim],	%al
L3246:
L3241:
L3229:
#---------------
    add       %rsp,	336
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_cli.showincludepaths
cc_cli.showincludepaths:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8806]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+cc_decls.nincludepaths]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rdi,	1
    mov       %rax,	[%rip+cc_decls.nincludepaths]
    cmp       %rax,	1
    jl        L3255
L3253:
    call      msys.m$print_startcon
    mov       %rcx,	%rdi
    call      msys.m$print_i64_nf
    lea       %rax,	[%rip+cc_decls.includepaths]
    mov       %r10,	%rdi
    mov       %rcx,	[%rax + %r10*8-8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    inc       %rdi
    cmp       %rdi,	[%rip+cc_decls.nincludepaths]
    jle       L3253
L3255:
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_cli.showhelp
cc_cli.showhelp:
#PROC1
#PROC2
#?>>
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    call      cc_cli.showcaption
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8807]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	23
    call      exit
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.showextrainfo
cc_cli.showextrainfo:
#PROC1
#PROC2
#?>>
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    call      msys.m$print_startcon
    mov       %rcx,	[%rip+cc_cli.showextrainfo.infotext]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	24
    call      exit
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.showcaption
cc_cli.showcaption:
#PROC1
#PROC2
#?>>
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8808]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L8809]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L8810]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.starttiming
cc_cli.starttiming:
#PROC1
#PROC2
#?>>
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    call      mwindows.os_clock
    mov       [%rip+cc_cli.ttt],	%rax
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_cli.gettiming
cc_cli.gettiming:
#PROC1
#PROC2
#?>>
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    call      mwindows.os_clock
    sub       %rax,	[%rip+cc_cli.ttt]
L3260:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_lex.lex_preprocess_only
cc_lex.lex_preprocess_only:
#PROC1
#PROC2
#?>>
    .set cc_lex.lex_preprocess_only.outfile, 80
    .set cc_lex.lex_preprocess_only.toconsole, 88
    .set cc_lex.lex_preprocess_only.hashtot, -8
    .set cc_lex.lex_preprocess_only.symtot, -16
    .set cc_lex.lex_preprocess_only.f, -24
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	56
    mov       %r15,	%rcx
    mov       [%rbp+80],	%rdx
    mov       [%rbp+88],	%r8
#---------------
#PROC3
#PROC4
    mov       %rax,	1
    mov       [%rip+cc_lex.dowhitespace],	%rax
    mov       %rcx,	%r15
    mov       %rdx,	%r15
    call      cc_support.loadsourcefile
    mov       %r12,	%rax
    lea       %rax,	[%rip+cc_decls.sourcefiletext]
    mov       %r10,	%r12
    mov       %rdi,	[%rax + %r10*8]
    lea       %rax,	[%rip+cc_decls.sourcefilesizes]
    mov       %r10,	%r12
    movsxd    %rax,	dword ptr[%rax + %r10*4]
    mov       %r13,	%rax
    xor       %eax,	%eax
    mov       %rbx,	%rax
    mov       %rsi,	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.lex_preprocess_only.symtot],	%rax
    mov       [%rbp + cc_lex.lex_preprocess_only.hashtot],	%rax
    call      mwindows.os_clock
    mov       %r14,	%rax
    mov       %rax,	[%rip+cc_lex.lex_preprocess_only.dest]
    mov       [%rip+cc_lex.destcopy],	%rax
    mov       %rcx,	[%rip+cc_lex.lex_preprocess_only.dest]
    call      mlib.gs_init
    mov       [%rip+cc_lex.lxsptr],	%rdi
    mov       %rax,	[%rip+cc_lex.lxsptr]
    mov       [%rip+cc_lex.lxstart],	%rax
    mov       %eax,	1
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+16],	%eax
    mov       %rcx,	1
    call      cc_lex.setfileno
    xor       %eax,	%eax
    mov       [%rip+cc_lex.ifcondlevel],	%rax
    lea       %rcx,	[%rip+L8811]
    mov       %rdx,	1
    call      cc_lex.stacksourcefile
    mov       %al,	56
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L3262:
    call      cc_lex.lexm
    inc       %rbx
    lea       %rcx,	[%rip+cc_decls.nextlx]
    mov       %rdx,	[%rip+cc_lex.lex_preprocess_only.dest]
    xor       %r8d,	%r8d
    call      cc_lex.emittoken
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	57
    jnz       L3262
    mov       %rax,	[%rip+cc_lex.ifcondlevel]
    test      %rax,	%rax
    jz        L3266
    lea       %rcx,	[%rip+L8812]
    call      cc_lex.lxerror
L3266:
    lea       %rax,	[%rip+cc_lex.showtokens]
    test      %rax,	%rax
    jz        L3268
    mov       %rax,	[%rbp + cc_lex.lex_preprocess_only.toconsole]
    test      %rax,	%rax
    jz        L3270
    mov       %rcx,	[%rip+cc_lex.lex_preprocess_only.dest]
    xor       %edx,	%edx
    call      mlib.gs_println
    jmp       L3269
L3270:
    mov       %rcx,	[%rbp + cc_lex.lex_preprocess_only.outfile]
    lea       %rdx,	[%rip+L8813]
    call      fopen
    mov       [%rbp + cc_lex.lex_preprocess_only.f],	%rax
    mov       %rcx,	[%rip+cc_lex.lex_preprocess_only.dest]
    mov       %rdx,	[%rbp + cc_lex.lex_preprocess_only.f]
    call      mlib.gs_println
    mov       %rcx,	[%rbp + cc_lex.lex_preprocess_only.f]
    call      fclose
L3269:
L3268:
#---------------
    add       %rsp,	56
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.lexreadtoken
cc_lex.lexreadtoken:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+23],	%al
    jmp       L3273
L3272:
    inc       qword ptr[%rip+cc_lex.lxsptr]
L3273:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	32
    jz        L3272
    cmp       %rax,	9
    jz        L3272
L3275:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	240
    jae       L3278
    lea       %r10,	[%rip+L3277]
    jmp       [%r10 + %rax*8]
    .data
L3277:
    .quad     L3412
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3397
    .quad     L3398
    .quad     L3278
    .quad     L3416
    .quad     L3406
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3397
    .quad     L3407
    .quad     L3396
    .quad     L3305
    .quad     L3279
    .quad     L3369
    .quad     L3390
    .quad     L3395
    .quad     L3335
    .quad     L3336
    .quad     L3360
    .quad     L3349
    .quad     L3329
    .quad     L3354
    .quad     L3321
    .quad     L3363
    .quad     L3296
    .quad     L3292
    .quad     L3292
    .quad     L3292
    .quad     L3292
    .quad     L3292
    .quad     L3292
    .quad     L3292
    .quad     L3292
    .quad     L3292
    .quad     L3331
    .quad     L3330
    .quad     L3376
    .quad     L3372
    .quad     L3383
    .quad     L3347
    .quad     L3411
    .quad     L3279
    .quad     L3279
    .quad     L3279
    .quad     L3279
    .quad     L3279
    .quad     L3279
    .quad     L3279
    .quad     L3279
    .quad     L3279
    .quad     L3279
    .quad     L3279
    .quad     L3279
    .quad     L3279
    .quad     L3279
    .quad     L3279
    .quad     L3279
    .quad     L3279
    .quad     L3279
    .quad     L3279
    .quad     L3279
    .quad     L3279
    .quad     L3279
    .quad     L3279
    .quad     L3279
    .quad     L3279
    .quad     L3279
    .quad     L3337
    .quad     L3309
    .quad     L3338
    .quad     L3344
    .quad     L3279
    .quad     L3278
    .quad     L3279
    .quad     L3279
    .quad     L3279
    .quad     L3279
    .quad     L3279
    .quad     L3279
    .quad     L3279
    .quad     L3279
    .quad     L3279
    .quad     L3279
    .quad     L3279
    .quad     L3279
    .quad     L3279
    .quad     L3279
    .quad     L3279
    .quad     L3279
    .quad     L3279
    .quad     L3279
    .quad     L3279
    .quad     L3279
    .quad     L3279
    .quad     L3279
    .quad     L3279
    .quad     L3279
    .quad     L3279
    .quad     L3279
    .quad     L3319
    .quad     L3339
    .quad     L3320
    .quad     L3348
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3278
    .quad     L3417
    .text
L3279:
#cc_lex.lexreadtoken.doname:
L3280:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	1
    mov       [%rip+cc_lex.lxsvalue],	%rax
    mov       %rax,	[%rip+cc_lex.lxsvalue]
    movzx     %rax,	byte ptr[%rax]
    mov       %rbx,	%rax
    jmp       L3282
L3281:
    mov       %rax,	%rbx
    shl       %rax,	4
    sub       %rax,	%rbx
    add       %rax,	%rdi
    mov       %rbx,	%rax
L3282:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    mov       %rdi,	%rax
    lea       %r10,	[%rip+cc_lex.alphamap]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jnz       L3281
    dec       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	67
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	[%rip+cc_lex.lxsvalue]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
    mov       %rax,	%rdi
    cmp       %rax,	39
    jz        L3285
    cmp       %rax,	34
    jnz       L3286
L3285:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+24]
    cmp       %rax,	1
    jnz       L3288
    mov       %rax,	[%rip+cc_lex.lxsvalue]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	108
    jz        L3290
    cmp       %rax,	76
    jz        L3290
    cmp       %rax,	117
    jz        L3290
    cmp       %rax,	85
    jnz       L3291
L3290:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      cc_lex.lxreadstring
    jmp       L3271
L3291:
L3289:
L3288:
L3286:
L3284:
    mov       %rax,	%rbx
    shl       %rax,	5
    sub       %rax,	%rbx
    mov       [%rip+cc_lex.lxhashvalue],	%rax
    call      cc_lex.lookup
    jmp       L3271
L3292:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	32
    jz        L3294
    cmp       %rax,	41
    jz        L3294
    cmp       %rax,	13
    jz        L3294
    cmp       %rax,	44
    jz        L3294
    cmp       %rax,	59
    jnz       L3295
L3294:
    mov       %al,	59
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    mov       %al,	3
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	1
    movzx     %rax,	byte ptr[%rax]
    sub       %rax,	48
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10],	%rax
    mov       %eax,	1
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	1
    sub       %rax,	[%rip+cc_lex.lxstart]
    mov       %rcx,	%rax
    call      cc_lex.setnumberoffset
    jmp       L3293
L3295:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	1
    mov       %rcx,	%rax
    call      cc_lex.readdecimal
L3293:
    jmp       L3271
L3296:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    sub       %rax,	10
    cmp       %rax,	116
    jae       L3299
    lea       %r10,	[%rip+L3298]
    jmp       [%r10 + %rax*8]
    .data
L3298:
    .quad     L3304
    .quad     L3299
    .quad     L3299
    .quad     L3304
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3304
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3304
    .quad     L3299
    .quad     L3299
    .quad     L3304
    .quad     L3299
    .quad     L3299
    .quad     L3304
    .quad     L3299
    .quad     L3302
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3304
    .quad     L3304
    .quad     L3299
    .quad     L3304
    .quad     L3299
    .quad     L3304
    .quad     L3299
    .quad     L3299
    .quad     L3301
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3303
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3303
    .quad     L3299
    .quad     L3299
    .quad     L3300
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3304
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3301
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3303
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3303
    .quad     L3299
    .quad     L3299
    .quad     L3300
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3299
    .quad     L3304
    .text
L3300:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	2
    mov       %rcx,	%rax
    call      cc_lex.readhex
    jmp       L3271
L3301:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	2
    mov       %rcx,	%rax
    call      cc_lex.readbinary
    jmp       L3271
L3302:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	1
    mov       %r10,	[%rip+cc_lex.lxsptr]
    sub       %r10,	1
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    mov       %r8,	1
    mov       %r9,	10
    call      cc_lex.readrealnumber
    jmp       L3271
L3303:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	1
    mov       %rcx,	%rax
    call      cc_lex.readdecimal
    jmp       L3271
L3304:
    mov       %al,	59
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    mov       %al,	3
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10],	%rax
    mov       %eax,	1
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	1
    sub       %rax,	[%rip+cc_lex.lxstart]
    mov       %rcx,	%rax
    call      cc_lex.setnumberoffset
    jmp       L3271
L3299:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	1
    mov       %rcx,	%rax
    call      cc_lex.readoctal
    jmp       L3271
L3297:
    jmp       L3275
L3305:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	56
    jnz       L3307
    mov       %al,	4
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3271
L3307:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	35
    jnz       L3308
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	7
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3271
L3308:
    mov       %al,	5
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3271
L3306:
    jmp       L3275
L3309:
L3310:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	13
    jz        L3312
    cmp       %rax,	10
    jz        L3312
    cmp       %rax,	32
    jz        L3313
    cmp       %rax,	9
    jz        L3313
    jmp       L3314
L3312:
    jmp       L3311
L3313:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L3310
L3314:
    mov       %al,	22
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3271
L3311:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	1
    mov       %r10b,	32
    mov       [%rax],	%r10b
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %rax,	[%rax+16]
    inc       dword ptr[%rax]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	13
    jz        L3316
    cmp       %rax,	10
    jz        L3317
    jmp       L3318
L3316:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %r10b,	32
    mov       [%rax],	%r10b
    jmp       L3315
L3317:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %r10b,	32
    mov       [%rax],	%r10b
L3318:
L3315:
    jmp       L3275
L3319:
    mov       %al,	17
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3271
L3320:
    mov       %al,	18
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3271
L3321:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    sub       %rax,	46
    cmp       %rax,	12
    jae       L3324
    lea       %r10,	[%rip+L3323]
    jmp       [%r10 + %rax*8]
    .data
L3323:
    .quad     L3325
    .quad     L3324
    .quad     L3328
    .quad     L3328
    .quad     L3328
    .quad     L3328
    .quad     L3328
    .quad     L3328
    .quad     L3328
    .quad     L3328
    .quad     L3328
    .quad     L3328
    .text
L3325:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	46
    jnz       L3327
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	21
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3326
L3327:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	2
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3271
L3326:
    jmp       L3271
L3328:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rcx,	[%rip+cc_lex.lxsptr]
    mov       %rdx,	[%rip+cc_lex.lxsptr]
    xor       %r8d,	%r8d
    mov       %r9,	10
    call      cc_lex.readrealnumber
    jmp       L3271
L3324:
    mov       %al,	2
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3271
L3322:
    jmp       L3275
L3329:
    mov       %al,	8
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3271
L3330:
    mov       %al,	9
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3271
L3331:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	61
    jnz       L3334
L3333:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	11
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3332
L3334:
    mov       %al,	10
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L3332:
    jmp       L3271
L3335:
    mov       %al,	13
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3271
L3336:
    mov       %al,	14
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3271
L3337:
    mov       %al,	15
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3271
L3338:
    mov       %al,	16
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3271
L3339:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	124
    jz        L3341
    cmp       %rax,	61
    jz        L3342
    jmp       L3343
L3341:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	31
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3340
L3342:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	51
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3340
L3343:
    mov       %al,	28
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L3340:
    jmp       L3271
L3344:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	61
    jnz       L3346
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	53
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3345
L3346:
    mov       %al,	30
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L3345:
    jmp       L3271
L3347:
    mov       %al,	19
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3271
L3348:
    mov       %al,	35
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3271
L3349:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	43
    jz        L3351
    cmp       %rax,	61
    jz        L3352
    jmp       L3353
L3351:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	37
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3350
L3352:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	46
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3350
L3353:
    mov       %al,	23
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L3350:
    jmp       L3271
L3354:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	45
    jz        L3356
    cmp       %rax,	62
    jz        L3357
    cmp       %rax,	61
    jz        L3358
    jmp       L3359
L3356:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	38
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3355
L3357:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	3
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3355
L3358:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	47
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3355
L3359:
    mov       %al,	24
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L3355:
    jmp       L3271
L3360:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	61
    jnz       L3362
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	48
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3361
L3362:
    mov       %al,	25
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L3361:
    jmp       L3271
L3363:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	47
    jz        L3365
    cmp       %rax,	42
    jz        L3366
    cmp       %rax,	61
    jz        L3367
    jmp       L3368
L3365:
    call      cc_lex.readlinecomment
    mov       %al,	56
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
    jmp       L3271
L3366:
    call      cc_lex.readblockcomment
    jmp       L3364
L3367:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	49
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3271
L3368:
    mov       %al,	26
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3271
L3364:
    jmp       L3275
L3369:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	61
    jnz       L3371
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	50
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3370
L3371:
    mov       %al,	27
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L3370:
    jmp       L3271
L3372:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	61
    jnz       L3375
L3374:
    mov       %al,	40
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    inc       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L3373
L3375:
    mov       %al,	11
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L3373:
    jmp       L3271
L3376:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	61
    jz        L3378
    cmp       %rax,	60
    jz        L3379
    jmp       L3380
L3378:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	43
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3377
L3379:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	61
    jnz       L3382
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	54
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3381
L3382:
    mov       %al,	33
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L3381:
    jmp       L3377
L3380:
    mov       %al,	42
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L3377:
    jmp       L3271
L3383:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	61
    jz        L3385
    cmp       %rax,	62
    jz        L3386
    jmp       L3387
L3385:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	44
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3384
L3386:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	61
    jnz       L3389
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	55
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3388
L3389:
    mov       %al,	34
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L3388:
    jmp       L3384
L3387:
    mov       %al,	45
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L3384:
    jmp       L3271
L3390:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	38
    jz        L3392
    cmp       %rax,	61
    jz        L3393
    jmp       L3394
L3392:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	32
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3391
L3393:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %al,	52
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3391
L3394:
    mov       %al,	29
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L3391:
    jmp       L3271
L3395:
    mov       %rcx,	39
    xor       %edx,	%edx
    call      cc_lex.lxreadstring
    jmp       L3271
L3396:
    mov       %rcx,	34
    xor       %edx,	%edx
    call      cc_lex.lxreadstring
    jmp       L3271
L3397:
    jmp       L3275
L3398:
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %rax,	[%rax+16]
    inc       dword ptr[%rax]
    mov       %al,	56
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
    mov       %rax,	[%rip+cc_lex.dowhitespace]
    test      %rax,	%rax
    jz        L3400
    mov       %rax,	[%rip+cc_lex.lxsptr]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10],	%rax
L3401:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    sub       %rax,	9
    cmp       %rax,	24
    jae       L3404
    lea       %r10,	[%rip+L3403]
    jmp       [%r10 + %rax*8]
    .data
L3403:
    .quad     L3405
    .quad     L3404
    .quad     L3404
    .quad     L3404
    .quad     L3404
    .quad     L3404
    .quad     L3404
    .quad     L3404
    .quad     L3404
    .quad     L3404
    .quad     L3404
    .quad     L3404
    .quad     L3404
    .quad     L3404
    .quad     L3404
    .quad     L3404
    .quad     L3404
    .quad     L3404
    .quad     L3404
    .quad     L3404
    .quad     L3404
    .quad     L3404
    .quad     L3404
    .quad     L3405
    .text
L3405:
    jmp       L3401
L3404:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L3402
L3402:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    mov       %r10,	[%rip+cc_lex.lxsptr]
    sub       %r10,	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       [%rax+24],	%r10d
L3400:
    jmp       L3271
L3406:
    jmp       L3275
L3407:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	61
    jnz       L3410
L3409:
    mov       %al,	41
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    inc       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L3408
L3410:
    mov       %al,	36
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L3408:
    jmp       L3271
L3411:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8814]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %eax,	[%rax+16]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+20]
    lea       %r10,	[%rip+cc_decls.sourcefilenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+cc_lex.lx_stackindex]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L3275
L3412:
#cc_lex.lexreadtoken.doeof:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lx_stackindex]
    test      %rax,	%rax
    jz        L3415
    call      cc_lex.unstacksourcefile
    mov       %al,	56
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3414
L3415:
    mov       %al,	57
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L3414:
    jmp       L3271
L3416:
    jmp       L3275
L3417:
    add       qword ptr[%rip+cc_lex.lxsptr],	2
    jmp       L3275
L3278:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	1
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	128
    jl        L3419
    cmp       %rax,	255
    jle       L3280
L3419:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8815]
    call      msys.m$print_str_nf
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	1
    movzx     %rax,	byte ptr[%rax]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.m$print_c8
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	1
    movzx     %rax,	byte ptr[%rax]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    mov       %rcx,	[%rip+cc_lex.lx_stackindex]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8815]
    call      cc_lex.lxerror
    mov       %al,	1
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3271
L3271:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.readrealnumber
cc_lex.readrealnumber:
#PROC1
#PROC2
#?>>
    .set cc_lex.readrealnumber.intlen, 104
    .set cc_lex.readrealnumber.base, 112
    .set cc_lex.readrealnumber.badexpon, -8
    .set cc_lex.readrealnumber.realstr, -520
    .set cc_lex.readrealnumber.rs, -528
    .set cc_lex.readrealnumber.expstr, -560
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    movq      %rax,	%XMM13
    push      %rax
    movq      %rax,	%XMM14
    push      %rax
    movq      %rax,	%XMM15
    push      %rax
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	600
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       [%rbp+104],	%r8
    mov       [%rbp+112],	%r9
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rbp + cc_lex.readrealnumber.base]
    cmp       %rax,	10
    jz        L3422
    mov       %rcx,	%r13
    mov       %rdx,	%r14
    mov       %r8,	[%rbp + cc_lex.readrealnumber.intlen]
    mov       %r9,	[%rbp + cc_lex.readrealnumber.base]
    call      cc_lex.old_readrealnumber
    jmp       L3420
L3422:
    xor       %rdi,	%rdi
    xor       %eax,	%eax
    mov       %rbx,	%rax
    xor       %rsi,	%rsi
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	46
    jnz       L3424
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rdi,	[%rip+cc_lex.lxsptr]
    mov       %rcx,	[%rbp + cc_lex.readrealnumber.base]
    call      cc_lex.scannumber
    sub       %rax,	%rdi
    mov       %rbx,	%rax
L3424:
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.readrealnumber.badexpon],	%rax
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	101
    jz        L3426
    cmp       %rax,	69
    jz        L3426
    cmp       %rax,	112
    jz        L3427
    cmp       %rax,	80
    jz        L3427
    jmp       L3428
L3426:
    mov       %rax,	[%rbp + cc_lex.readrealnumber.base]
    cmp       %rax,	16
    jz        L3430
    inc       qword ptr[%rip+cc_lex.lxsptr]
    lea       %rcx,	[%rbp + cc_lex.readrealnumber.badexpon]
    call      cc_lex.readexponent
    mov       %rsi,	%rax
L3430:
    jmp       L3425
L3427:
    mov       %rax,	[%rbp + cc_lex.readrealnumber.base]
    cmp       %rax,	16
    jnz       L3432
    inc       qword ptr[%rip+cc_lex.lxsptr]
    lea       %rcx,	[%rbp + cc_lex.readrealnumber.badexpon]
    call      cc_lex.readexponent
    mov       %rsi,	%rax
L3432:
L3428:
L3425:
    mov       %rax,	[%rbp + cc_lex.readrealnumber.badexpon]
    test      %rax,	%rax
    jz        L3434
    dec       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rcx,	%r13
    call      cc_lex.readalphanumeric
    jmp       L3420
L3434:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	102
    jz        L3436
    cmp       %rax,	70
    jz        L3436
    cmp       %rax,	108
    jz        L3436
    cmp       %rax,	76
    jnz       L3437
L3436:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L3435
L3437:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    lea       %r10,	[%rip+cc_lex.alphamap]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L3439
    mov       %rcx,	%r13
    call      cc_lex.readalphanumeric
    jmp       L3420
L3439:
L3435:
    mov       %rax,	[%rbp + cc_lex.readrealnumber.base]
    cmp       %rax,	16
    jnz       L3441
    mov       %al,	48
    mov       [%rbp + cc_lex.readrealnumber.realstr],	%al
    mov       %al,	120
    mov       [%rbp + cc_lex.readrealnumber.realstr+1],	%al
    lea       %rax,	[%rbp + cc_lex.readrealnumber.realstr+2]
    mov       [%rbp + cc_lex.readrealnumber.rs],	%rax
    mov       %r12,	2
    jmp       L3440
L3441:
    lea       %rax,	[%rbp + cc_lex.readrealnumber.realstr]
    mov       [%rbp + cc_lex.readrealnumber.rs],	%rax
    xor       %r12,	%r12
L3440:
    mov       %rax,	[%rbp + cc_lex.readrealnumber.intlen]
    add       %rax,	%rbx
    cmp       %rax,	500
    jle       L3443
    lea       %rcx,	[%rip+L8816]
    call      cc_lex.lxerror
L3443:
    mov       %rax,	[%rbp + cc_lex.readrealnumber.intlen]
    test      %rax,	%rax
    jz        L3445
    mov       %rcx,	[%rbp + cc_lex.readrealnumber.rs]
    mov       %rdx,	%r14
    mov       %r8,	[%rbp + cc_lex.readrealnumber.intlen]
    call      memcpy
L3445:
    test      %rbx,	%rbx
    jz        L3447
    mov       %rax,	[%rbp + cc_lex.readrealnumber.rs]
    mov       %r10,	[%rbp + cc_lex.readrealnumber.intlen]
    lea       %rax,	[%rax + %r10]
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      memcpy
L3447:
    mov       %rax,	[%rbp + cc_lex.readrealnumber.base]
    cvtsi2sd  %XMM4,	%rax
    movq      %XMM15,	%XMM4
    movq      %XMM13,	%XMM4
    mov       %rax,	[%rbp + cc_lex.readrealnumber.base]
    cmp       %rax,	10
    jnz       L3449
    mov       %rax,	%rbx
    sub       %rsi,	%rax
    jmp       L3448
L3449:
    mov       %rax,	%rbx
    shl       %rax,	2
    sub       %rsi,	%rax
    movq      %XMM4,	[%rip+L8817]
    movq      %XMM13,	%XMM4
L3448:
    mov       %rax,	%r12
    add       %rax,	[%rbp + cc_lex.readrealnumber.intlen]
    add       %rax,	%rbx
    xor       %r10d,	%r10d
    mov       [%rbp + %rax + cc_lex.readrealnumber.realstr],	%r10b
    lea       %rcx,	[%rbp + cc_lex.readrealnumber.expstr]
    call      msys.m$print_startstr
    mov       %rax,	[%rbp + cc_lex.readrealnumber.base]
    cmp       %rax,	10
    jnz       L3451
    lea       %rax,	[%rip+L8818]
    jmp       L3450
L3451:
    lea       %rax,	[%rip+L8819]
L3450:
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       %rcx,	%rsi
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + cc_lex.readrealnumber.realstr]
    lea       %rdx,	[%rbp + cc_lex.readrealnumber.expstr]
    call      strcat
    mov       %rax,	[%rbp + cc_lex.readrealnumber.base]
    cmp       %rax,	10
    jz        L3453
    lea       %rcx,	[%rip+L8820]
    call      cc_lex.lxerror
L3453:
    lea       %rcx,	[%rbp + cc_lex.readrealnumber.realstr]
    xor       %edx,	%edx
    call      strtod
    movq      %XMM14,	%XMM0
    mov       %al,	60
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    mov       %al,	11
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    movq      %XMM4,	%XMM14
    lea       %rax,	[%rip+cc_decls.nextlx]
    movq      [%rax],	%XMM4
    mov       %rax,	%r14
    sub       %rax,	[%rip+cc_lex.lxstart]
    mov       %rcx,	%rax
    call      cc_lex.setnumberoffset
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	%r14
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
L3420:
#---------------
    add       %rsp,	600
    pop       %rbp
    pop       %rcx
    movq      %XMM15,	%rcx
    pop       %rcx
    movq      %XMM14,	%rcx
    pop       %rcx
    movq      %XMM13,	%rcx
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.readexponent
cc_lex.readexponent:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    sub       %rsp,	48
    mov       %r15,	%rcx
#---------------
#PROC3
#PROC4
    xor       %rsi,	%rsi
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	43
    jz        L3456
    cmp       %rax,	45
    jz        L3457
    jmp       L3458
L3456:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L3455
L3457:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rsi,	1
L3458:
L3455:
    mov       %rdi,	[%rip+cc_lex.lxsptr]
    mov       %rcx,	10
    call      cc_lex.scannumber
    sub       %rax,	%rdi
    mov       %rbx,	%rax
    test      %rbx,	%rbx
    jnz       L3460
    mov       %rax,	1
    mov       [%r15],	%rax
    xor       %eax,	%eax
    jmp       L3454
L3460:
    xor       %r13,	%r13
    mov       %rax,	%rbx
    mov       %r14,	%rax
    cmp       %r14,	0
    jle       L3463
L3461:
    mov       %rax,	%rdi
    inc       %rdi
    movzx     %rax,	byte ptr[%rax]
    mov       %r12,	%rax
    mov       %rax,	%r13
    shl       %rax,	1
    lea       %rax,	[%rax + %rax*4]
    add       %rax,	%r12
    sub       %rax,	48
    mov       %r13,	%rax
    dec       %r14
    jnz       L3461
L3463:
    test      %rsi,	%rsi
    jz        L3465
    mov       %rax,	%r13
    neg       %rax
    jmp       L3464
L3465:
    mov       %rax,	%r13
L3464:
L3454:
#---------------
    add       %rsp,	48
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.lxerror
cc_lex.lxerror:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8821]
    call      msys.m$print_str_nf
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L8822]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    call      cc_lex.getfileno
    lea       %r10,	[%rip+cc_decls.sourcefilepaths]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L8823]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %eax,	[%rax+16]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	11
    call      exit
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lex.printsymbol
cc_lex.printsymbol:
#PROC1
#PROC2
#?>>
    .set cc_lex.printsymbol.l, -32
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	72
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rax,	%rdi
    lea       %r10,	[%rbp + cc_lex.printsymbol.l]
    mov       %r11,	[%rax]
    mov       [%r10],	%r11
    mov       %r11,	[%rax+8]
    mov       [%r10+8],	%r11
    mov       %r11,	[%rax+16]
    mov       [%r10+16],	%r11
    mov       %r11,	[%rax+24]
    mov       [%r10+24],	%r11
    movzx     %rax,	byte ptr[%rbp + cc_lex.printsymbol.l+21]
    lea       %r10,	[%rip+cc_tables.symbolnames]
    mov       %r10,	[%r10 + %rax*8-8]
    lea       %rcx,	[%rip+L8824]
    mov       %rdx,	%r10
    call      printf
    movzx     %rax,	byte ptr[%rbp + cc_lex.printsymbol.l+21]
    cmp       %rax,	67
    jz        L3469
    cmp       %rax,	59
    jz        L3470
    cmp       %rax,	60
    jz        L3471
    cmp       %rax,	63
    jz        L3472
    cmp       %rax,	61
    jz        L3473
    jmp       L3474
L3469:
    mov       %rax,	[%rbp + cc_lex.printsymbol.l]
    movzx     %rax,	byte ptr[%rax+106]
    mov       %r10,	[%rbp + cc_lex.printsymbol.l]
    mov       %r10,	[%r10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      cc_lex.printstrn
    jmp       L3468
L3470:
    call      msys.m$print_startcon
    mov       %rcx,	[%rbp + cc_lex.printsymbol.l]
    call      msys.m$print_i64_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L8825]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      cc_lex.shownumberstr
    jmp       L3468
L3471:
    call      msys.m$print_startcon
    movq      %XMM4,	[%rbp + cc_lex.printsymbol.l]
    movq      %XMM0,	%XMM4
    xor       %edx,	%edx
    call      msys.m$print_r64
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L8825]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      cc_lex.shownumberstr
    jmp       L3468
L3472:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8826]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    movsxd    %rax,	dword ptr[%rbp + cc_lex.printsymbol.l+24]
    mov       %r10,	[%rbp + cc_lex.printsymbol.l]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      cc_lex.printstrn
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8826]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L3468
L3473:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8827]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    movsxd    %rax,	dword ptr[%rbp + cc_lex.printsymbol.l+24]
    mov       %r10,	[%rbp + cc_lex.printsymbol.l]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      cc_lex.printstrn
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8827]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L3468
L3474:
    mov       %al,	[%rbp + cc_lex.printsymbol.l+22]
    test      %al,	%al
    jz        L3476
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8828]
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rbp + cc_lex.printsymbol.l+22]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
L3476:
L3468:
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
#---------------
    add       %rsp,	72
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc cc_lex.lexsetup
cc_lex.lexsetup:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    call      cc_lex.inithashtable
    call      cc_lex.fillhashtable
    xor       %rdi,	%rdi
L3478:
    lea       %rax,	[%rdi-36]
    cmp       %rax,	220
    jae       L3483
    lea       %r10,	[%rip+L3482]
    jmp       [%r10 + %rax*8]
    .data
L3482:
    .quad     L3484
    .quad     L3483
    .quad     L3483
    .quad     L3483
    .quad     L3483
    .quad     L3483
    .quad     L3483
    .quad     L3483
    .quad     L3483
    .quad     L3483
    .quad     L3483
    .quad     L3483
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3483
    .quad     L3483
    .quad     L3483
    .quad     L3483
    .quad     L3483
    .quad     L3483
    .quad     L3483
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3483
    .quad     L3483
    .quad     L3483
    .quad     L3483
    .quad     L3484
    .quad     L3483
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3483
    .quad     L3483
    .quad     L3483
    .quad     L3483
    .quad     L3483
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .quad     L3484
    .text
L3484:
    mov       %al,	1
    lea       %r10,	[%rip+cc_lex.alphamap]
    mov       %r11,	%rdi
    mov       [%r10 + %r11],	%al
L3483:
L3481:
    lea       %rax,	[%rdi-48]
    cmp       %rax,	10
    jae       L3487
    lea       %r10,	[%rip+L3486]
    jmp       [%r10 + %rax*8]
    .data
L3486:
    .quad     L3488
    .quad     L3488
    .quad     L3488
    .quad     L3488
    .quad     L3488
    .quad     L3488
    .quad     L3488
    .quad     L3488
    .quad     L3488
    .quad     L3488
    .text
L3488:
    mov       %al,	1
    lea       %r10,	[%rip+cc_lex.digitmap]
    mov       %r11,	%rdi
    mov       [%r10 + %r11],	%al
L3487:
L3485:
    mov       %al,	1
    lea       %r10,	[%rip+cc_lex.commentmap]
    mov       %r11,	%rdi
    mov       [%r10 + %r11],	%al
    mov       %al,	1
    lea       %r10,	[%rip+cc_lex.linecommentmap]
    mov       %r11,	%rdi
    mov       [%r10 + %r11],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_lex.spacemap]
    mov       %r11,	%rdi
    mov       [%r10 + %r11],	%al
    inc       %rdi
    cmp       %rdi,	255
    jle       L3478
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_lex.commentmap]
    mov       [%r10+42],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_lex.commentmap]
    mov       [%r10],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_lex.commentmap]
    mov       [%r10+10],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_lex.linecommentmap]
    mov       [%r10],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_lex.linecommentmap]
    mov       [%r10+92],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_lex.linecommentmap]
    mov       [%r10+10],	%al
    mov       %al,	1
    lea       %r10,	[%rip+cc_lex.spacemap]
    mov       [%r10+32],	%al
    mov       %al,	1
    lea       %r10,	[%rip+cc_lex.spacemap]
    mov       [%r10+9],	%al
    mov       %al,	56
    lea       %r10,	[%rip+cc_lex.normaltkx]
    mov       [%r10+21],	%al
    xor       %eax,	%eax
    mov       [%rip+cc_lex.npastedtokens],	%rax
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lex.printstrn
cc_lex.printstrn:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
#PROC3
#PROC4
    test      %rbx,	%rbx
    jz        L3491
    test      %rsi,	%rsi
    jnz       L3493
    call      msys.m$print_startcon
    mov       %rcx,	%rbx
    lea       %rdx,	[%rip+L8829]
    call      msys.m$print_i64
    call      msys.m$print_nogap
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8830]
    call      msys.m$print_str
    call      msys.m$print_end
    jmp       L3492
L3493:
    mov       %rcx,	%rsi
    call      msys.m$print_startfile
    mov       %rcx,	%rbx
    lea       %rdx,	[%rip+L8831]
    call      msys.m$print_i64
    call      msys.m$print_nogap
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L8832]
    call      msys.m$print_str
    call      msys.m$print_end
L3492:
L3491:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.scannumber
cc_lex.scannumber:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rdi,	[%rip+cc_lex.lxsptr]
L3495:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    mov       %rbx,	%rax
    sub       %rax,	39
    cmp       %rax,	64
    jae       L3498
    lea       %r10,	[%rip+L3497]
    jmp       [%r10 + %rax*8]
    .data
L3497:
    .quad     L3505
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3499
    .quad     L3499
    .quad     L3499
    .quad     L3499
    .quad     L3499
    .quad     L3499
    .quad     L3499
    .quad     L3499
    .quad     L3499
    .quad     L3499
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3502
    .quad     L3502
    .quad     L3502
    .quad     L3502
    .quad     L3502
    .quad     L3502
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3498
    .quad     L3505
    .quad     L3505
    .quad     L3502
    .quad     L3502
    .quad     L3502
    .quad     L3502
    .quad     L3502
    .quad     L3502
    .text
L3499:
    mov       %rax,	%rdi
    inc       %rdi
    mov       %r10b,	%bl
    mov       [%rax],	%r10b
    mov       %rax,	48
    add       %rax,	%rsi
    mov       %r10,	%rbx
    cmp       %r10,	%rax
    jl        L3501
    lea       %rcx,	[%rip+L8833]
    call      cc_lex.lxerror
L3501:
    jmp       L3495
L3502:
    cmp       %rsi,	16
    jnz       L3504
    mov       %rax,	%rdi
    inc       %rdi
    mov       %r10b,	%bl
    mov       [%rax],	%r10b
    jmp       L3503
L3504:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L3496
L3503:
    jmp       L3495
L3505:
    jmp       L3495
L3498:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L3496
L3496:
    mov       %rax,	%rdi
L3494:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.lookup
cc_lex.lookup:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
#cc_lex.lookup.retry:
L3507:
    mov       %rax,	[%rip+cc_lex.lxhashvalue]
    and       %rax,	[%rip+cc_decls.hstmask]
    mov       %rdi,	%rax
    xor       %rbx,	%rbx
L3508:
    mov       %rax,	[%rip+cc_decls.hashtable]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10],	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    movzx     %rax,	byte ptr[%rax+106]
    mov       %rsi,	%rax
    test      %rsi,	%rsi
    jnz       L3511
    jmp       L3509
L3511:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+24]
    mov       %r10,	%rsi
    cmp       %r10,	%rax
    jnz       L3513
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    mov       %rdx,	[%rip+cc_lex.lxsvalue]
    mov       %r8,	%rsi
    call      memcmp
    movsxd    %r10,	%eax
    test      %r10,	%r10
    jnz       L3515
    mov       %rax,	1
    jmp       L3506
L3515:
L3513:
    inc       %rdi
    cmp       %rdi,	[%rip+cc_decls.hstsize]
    jl        L3517
    test      %rbx,	%rbx
    jz        L3519
    lea       %rcx,	[%rip+L8834]
    call      mlib.abortprogram
L3519:
    mov       %rbx,	1
    xor       %rdi,	%rdi
L3517:
    jmp       L3508
L3509:
    mov       %rax,	[%rip+cc_lex.nhstsymbols]
    cmp       %rax,	[%rip+cc_lex.hstthreshold]
    jl        L3521
    call      cc_lex.newhashtable
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+24]
    mov       %rcx,	[%rip+cc_lex.lxsvalue]
    mov       %rdx,	%rax
    call      cc_lex.gethashvalue
    mov       [%rip+cc_lex.lxhashvalue],	%rax
    jmp       L3507
L3521:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+24]
    mov       %rcx,	[%rip+cc_lex.lxsvalue]
    mov       %rdx,	%rax
    call      mlib.pcm_copyheapstringn
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       %r10,	[%r10]
    mov       [%r10],	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %eax,	[%rax+24]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       %r10,	[%r10]
    mov       [%r10+106],	%al
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    mov       %r10b,	67
    mov       [%rax+107],	%r10b
    inc       qword ptr[%rip+cc_lex.nhstsymbols]
    xor       %eax,	%eax
L3506:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.gethashvalue
cc_lex.gethashvalue:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
#PROC3
#PROC4
    cmp       %r12,	-1
    jnz       L3524
    mov       %rcx,	%rsi
    call      strlen
    mov       %r12,	%rax
L3524:
    xor       %rdi,	%rdi
    mov       %rax,	%r12
    mov       %rbx,	%rax
    cmp       %rbx,	0
    jle       L3527
L3525:
    mov       %rax,	%rdi
    shl       %rax,	4
    sub       %rax,	%rdi
    mov       %r10,	%rsi
    inc       %rsi
    movzx     %r10,	byte ptr[%r10]
    add       %rax,	%r10
    mov       %rdi,	%rax
    dec       %rbx
    jnz       L3525
L3527:
    mov       %rax,	%rdi
    shl       %rax,	5
    sub       %rax,	%rdi
L3522:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.inithashtable
cc_lex.inithashtable:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+cc_decls.hstsize]
    shl       %rax,	3
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       [%rip+cc_decls.hashtable],	%rax
    mov       %rax,	[%rip+cc_decls.hstsize]
    dec       %rax
    mov       [%rip+cc_decls.hstmask],	%rax
    xor       %rdi,	%rdi
    mov       %rax,	[%rip+cc_decls.hstmask]
    cmp       %rax,	0
    jl        L3531
L3529:
    mov       %rcx,	128
    call      mlib.pcm_allocz
    mov       %r10,	[%rip+cc_decls.hashtable]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*8],	%rax
    inc       %rdi
    cmp       %rdi,	[%rip+cc_decls.hstmask]
    jle       L3529
L3531:
    xor       %eax,	%eax
    mov       [%rip+cc_lex.nhstsymbols],	%rax
    mov       %rax,	6
    mov       %r10,	[%rip+cc_decls.hstsize]
    imul      %rax,	%r10
    mov       %r10,	10
    cqo       
    idiv      %r10
    mov       [%rip+cc_lex.hstthreshold],	%rax
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lex.fillhashtable
cc_lex.fillhashtable:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    mov       %rdi,	1
    mov       %rbx,	63
    cmp       %rbx,	1
    jl        L3535
L3533:
    lea       %rax,	[%rip+cc_tables.stnames]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    mov       [%rip+cc_lex.lxsvalue],	%rax
    lea       %rax,	[%rip+cc_tables.stsymbols]
    mov       %r10,	%rdi
    movsxd    %rax,	dword ptr[%rax + %r10*4-4]
    cmp       %rax,	68
    jnz       L3537
    mov       %rcx,	[%rip+cc_lex.lxsvalue]
    call      mlib.pcm_copyheapstring
    mov       [%rip+cc_lex.lxsvalue],	%rax
L3537:
    mov       %rcx,	[%rip+cc_lex.lxsvalue]
    call      strlen
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+24]
    mov       %rcx,	[%rip+cc_lex.lxsvalue]
    mov       %rdx,	%rax
    call      cc_lex.gethashvalue
    mov       [%rip+cc_lex.lxhashvalue],	%rax
    call      cc_lex.lookup
    test      %rax,	%rax
    jz        L3539
    call      msys.m$print_startcon
    lea       %rax,	[%rip+cc_tables.stnames]
    mov       %r10,	%rdi
    mov       %rcx,	[%rax + %r10*8-8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8835]
    call      mlib.abortprogram
L3539:
    lea       %rax,	[%rip+cc_tables.stsymbols]
    mov       %r10,	%rdi
    mov       %eax,	[%rax + %r10*4-4]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       %r10,	[%r10]
    mov       [%r10+107],	%al
    lea       %rax,	[%rip+cc_tables.stsubcodes]
    mov       %r10,	%rdi
    mov       %eax,	[%rax + %r10*4-4]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       %r10,	[%r10]
    mov       [%r10+100],	%ax
    inc       %rdi
    cmp       %rdi,	%rbx
    jle       L3533
L3535:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.dolexdirective
cc_lex.dolexdirective:
#PROC1
#PROC2
#?>>
    .set cc_lex.dolexdirective.dir, -8
    .set cc_lex.dolexdirective.length, -16
    .set cc_lex.dolexdirective.allowmacros, -24
    .set cc_lex.dolexdirective.filename, -328
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	360
#---------------
#PROC3
#PROC4
    mov       %rsi,	[%rip+cc_lex.lxsptr]
    call      cc_lex.getlexdirective
    mov       [%rbp + cc_lex.dolexdirective.dir],	%rax
    mov       %rax,	[%rbp + cc_lex.dolexdirective.dir]
    test      %rax,	%rax
    jnz       L3542
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	%rsi
    mov       %rcx,	%rsi
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      cc_lex.printstrn
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8836]
    call      cc_lex.lxerror
L3542:
    mov       %rax,	[%rbp + cc_lex.dolexdirective.dir]
    cmp       %rax,	7
    jz        L3544
    cmp       %rax,	1
    jz        L3545
    cmp       %rax,	10
    jz        L3546
    cmp       %rax,	8
    jz        L3547
    cmp       %rax,	9
    jz        L3548
    cmp       %rax,	3
    jz        L3549
    cmp       %rax,	4
    jz        L3550
    cmp       %rax,	5
    jz        L3550
    cmp       %rax,	6
    jz        L3551
    cmp       %rax,	13
    jz        L3552
    cmp       %rax,	14
    jz        L3553
    cmp       %rax,	11
    jz        L3554
    cmp       %rax,	15
    jz        L3555
    jmp       L3556
L3544:
    mov       %rax,	1
    mov       [%rip+cc_lex.isincludefile],	%rax
    jmp       L3558
L3557:
    inc       qword ptr[%rip+cc_lex.lxsptr]
L3558:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	32
    jz        L3557
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	9
    jz        L3557
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	60
    setnz     %al
    movzx     %eax,	%al
    mov       [%rbp + cc_lex.dolexdirective.allowmacros],	%rax
    call      cc_lex.lexm
    xor       %eax,	%eax
    mov       [%rip+cc_lex.isincludefile],	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	42
    jnz       L3561
    mov       %r15,	1
    lea       %rax,	[%rbp + cc_lex.dolexdirective.filename]
    mov       %rbx,	%rax
    mov       %rax,	[%rbp + cc_lex.dolexdirective.allowmacros]
    test      %rax,	%rax
    jz        L3563
L3564:
    call      cc_lex.lexm
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	57
    jz        L3567
    cmp       %rax,	56
    jz        L3567
    cmp       %rax,	45
    jz        L3568
    jmp       L3569
L3567:
    lea       %rcx,	[%rip+L8837]
    call      cc_lex.lxerror
    jmp       L3566
L3568:
    jmp       L3565
L3569:
    lea       %rcx,	[%rip+cc_decls.nextlx]
    lea       %rdx,	[%rbp + cc_lex.dolexdirective.length]
    call      cc_lex.strtoken
    mov       %r12,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	%r12
    mov       %r8,	[%rbp + cc_lex.dolexdirective.length]
    call      memcpy
    mov       %rax,	[%rbp + cc_lex.dolexdirective.length]
    add       %rbx,	%rax
L3566:
    jmp       L3564
L3565:
    jmp       L3562
L3563:
L3570:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    mov       %r14,	%rax
    mov       %rax,	%r14
    cmp       %rax,	62
    jz        L3573
    cmp       %rax,	10
    jz        L3574
    test      %rax,	%rax
    jz        L3574
    jmp       L3575
L3573:
    jmp       L3571
L3574:
    lea       %rcx,	[%rip+L8838]
    call      cc_lex.lxerror
    jmp       L3572
L3575:
    mov       %rax,	%rbx
    inc       %rbx
    mov       %r10b,	%r14b
    mov       [%rax],	%r10b
L3572:
    jmp       L3570
L3571:
L3562:
    xor       %eax,	%eax
    mov       [%rbx],	%al
    jmp       L3560
L3561:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	63
    jnz       L3576
    xor       %r15,	%r15
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    lea       %rcx,	[%rbp + cc_lex.dolexdirective.filename]
    mov       %rdx,	%rax
    call      strcpy
    jmp       L3560
L3576:
    lea       %rcx,	[%rip+L8839]
    call      cc_lex.lxerror
L3560:
    call      cc_lex.lexm
    mov       %al,	[%rip+cc_cli.fshowincludes]
    test      %al,	%al
    jz        L3578
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8840]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rbp + cc_lex.dolexdirective.filename]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L8841]
    call      msys.m$print_str_nf
    call      cc_lex.getfileno
    lea       %r10,	[%rip+cc_decls.sourcefilepaths]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %eax,	[%rax+16]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    lea       %rcx,	[%rip+L8842]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+cc_decls.nsourcefiles]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L3578:
    inc       qword ptr[%rip+cc_lex.nincludes]
    lea       %rcx,	[%rbp + cc_lex.dolexdirective.filename]
    mov       %rdx,	%r15
    call      cc_lex.stacksourcefile
    jmp       L3543
L3545:
    call      cc_lex.dodefine
    jmp       L3543
L3546:
    call      cc_lex.lexreadtoken
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L3580
    lea       %rcx,	[%rip+L8843]
    call      cc_lex.lxerror
L3580:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rdi,	[%rax]
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	1
    jnz       L3581
L3582:
    xor       %eax,	%eax
    mov       [%rdi+109],	%al
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    mov       %al,	[%rax+88]
    mov       [%rdi+107],	%al
    xor       %eax,	%eax
    mov       [%rdi+80],	%rax
    lea       %rax,	[%rdi+108]
    and       byte ptr[%rax],	251
L3581:
    jmp       L3543
L3547:
    call      cc_lex.getifdef
    mov       %r13,	%rax
    jmp       L3583
L3548:
    call      cc_lex.getifdef
    test      %rax,	%rax
    setz      %al
    movzx     %eax,	%al
    mov       %r13,	%rax
    jmp       L3583
L3549:
    call      cc_lex.getifexpr
    mov       %r13,	%rax
#cc_lex.dolexdirective.doif:
L3583:
    inc       qword ptr[%rip+cc_lex.ifcondlevel]
    test      %r13,	%r13
    jz        L3585
    xor       %eax,	%eax
    jmp       L3540
L3585:
#cc_lex.dolexdirective.doskipcode:
L3586:
    call      cc_lex.skipcode
    mov       [%rbp + cc_lex.dolexdirective.dir],	%rax
    mov       %rax,	[%rbp + cc_lex.dolexdirective.dir]
    cmp       %rax,	4
    jz        L3588
    cmp       %rax,	5
    jz        L3589
    cmp       %rax,	6
    jz        L3590
    jmp       L3591
L3588:
    call      cc_lex.getifexpr
    mov       %r13,	%rax
    test      %r13,	%r13
    jz        L3593
    xor       %eax,	%eax
    jmp       L3540
L3593:
    jmp       L3586
L3589:
    jmp       L3587
L3590:
    dec       qword ptr[%rip+cc_lex.ifcondlevel]
L3591:
L3587:
L3584:
    jmp       L3543
L3550:
    mov       %rax,	[%rip+cc_lex.ifcondlevel]
    test      %rax,	%rax
    jnz       L3595
    lea       %rcx,	[%rip+L8844]
    call      cc_lex.lxerror
L3595:
L3596:
    call      cc_lex.skipcode
    mov       [%rbp + cc_lex.dolexdirective.dir],	%rax
    mov       %rax,	[%rbp + cc_lex.dolexdirective.dir]
    cmp       %rax,	6
    jnz       L3596
    dec       qword ptr[%rip+cc_lex.ifcondlevel]
    jmp       L3543
L3551:
    mov       %rax,	[%rip+cc_lex.ifcondlevel]
    test      %rax,	%rax
    jnz       L3600
    lea       %rcx,	[%rip+L8845]
    call      cc_lex.lxerror
L3600:
    dec       qword ptr[%rip+cc_lex.ifcondlevel]
    jmp       L3543
L3552:
    jmp       L3543
L3553:
L3601:
    call      cc_lex.lexreadtoken
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	56
    jnz       L3601
    jmp       L3543
L3554:
    call      cc_lex.lexm
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8846]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       %rcx,	[%rip+cc_decls.nextlx]
    call      cc_lex.showtoken
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8847]
    call      cc_lex.lxerror
    jmp       L3543
L3555:
    call      cc_lex.dopragmadir
    jmp       L3543
L3556:
#cc_lex.dolexdirective.skip:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8848]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_tables.sourcedirnames]
    mov       %r10,	[%rbp + cc_lex.dolexdirective.dir]
    mov       %rcx,	[%rax + %r10*8-8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       [%rip+cc_lex.lxsptr],	%rsi
    mov       %al,	4
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    mov       %rax,	1
    jmp       L3540
    lea       %rcx,	[%rip+L8849]
    call      cc_lex.lxerror
L3543:
    xor       %eax,	%eax
L3540:
#---------------
    add       %rsp,	360
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.getlexdirective
cc_lex.getlexdirective:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    call      cc_lex.lexreadtoken
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L3607
    cmp       %rax,	56
    jz        L3608
    cmp       %rax,	59
    jz        L3609
    jmp       L3610
L3607:
    jmp       L3606
L3608:
    mov       %rax,	13
    jmp       L3605
L3609:
L3611:
    call      cc_lex.lexreadtoken
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	56
    jz        L3614
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	57
    jnz       L3611
L3614:
    mov       %rax,	13
    jmp       L3605
L3610:
    xor       %eax,	%eax
    jmp       L3605
L3606:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    movzx     %rax,	byte ptr[%rax+107]
    cmp       %rax,	68
    jz        L3616
    cmp       %rax,	71
    jz        L3617
    cmp       %rax,	72
    jz        L3618
    cmp       %rax,	56
    jz        L3619
    jmp       L3620
L3616:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    movsx     %rax,	word ptr[%rax+100]
    jmp       L3605
L3617:
    mov       %rax,	3
    jmp       L3605
L3618:
    mov       %rax,	5
    jmp       L3605
L3619:
    mov       %rax,	13
    jmp       L3605
L3620:
L3615:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rdi,	[%rax]
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	1
    jnz       L3622
    movzx     %rax,	byte ptr[%rdi+88]
    cmp       %rax,	68
    jnz       L3624
    movsx     %rax,	word ptr[%rdi+100]
    jmp       L3605
L3624:
L3622:
    xor       %eax,	%eax
L3605:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lex.startlex
cc_lex.startlex:
#PROC1
#PROC2
#?>>
    .set cc_lex.startlex.caption, 24
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rdx
#---------------
#PROC3
#PROC4
    xor       %eax,	%eax
    mov       [%rip+cc_lex.ifcondlevel],	%rax
    xor       %eax,	%eax
    mov       [%rip+cc_lex.lx_stackindex],	%rax
    xor       %eax,	%eax
    mov       [%rip+cc_lex.noexpand],	%rax
    lea       %rax,	[%rip+cc_lex.normaltkx]
    mov       [%rip+cc_lex.normaltk],	%rax
    xor       %eax,	%eax
    mov       [%rip+cc_lex.lx_stackindex],	%rax
    xor       %eax,	%eax
    mov       [%rip+cc_lex.ifcondlevel],	%rax
    mov       %rax,	1
    mov       [%rip+cc_lex.firstsymbol],	%rax
    xor       %eax,	%eax
    mov       [%rip+cc_lex.npastedtokens],	%rax
    xor       %eax,	%eax
    mov       [%rip+cc_lex.isincludefile],	%rax
    xor       %eax,	%eax
    mov       [%rip+cc_lex.tkptr],	%rax
    lea       %rax,	[%rip+cc_decls.sourcefiletext]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    mov       [%rip+cc_lex.lxsptr],	%rax
    mov       [%rip+cc_lex.lxstart],	%rax
    mov       %rcx,	%rdi
    call      cc_lex.setfileno
    mov       %eax,	1
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+16],	%eax
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+28],	%eax
    mov       %al,	56
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    call      cc_lex.lex
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lex.endlex
cc_lex.endlex:
#PROC1
#PROC2
#?>>
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+cc_lex.ifcondlevel]
    test      %rax,	%rax
    jz        L3628
    call      msys.m$print_startcon
    mov       %rcx,	[%rip+cc_lex.ifcondlevel]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8850]
    call      cc_lex.lxerror
L3628:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_lex.ps
cc_lex.ps:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    call      msys.m$print_startcon
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L8851]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       %rcx,	[%rip+cc_decls.lx]
    call      cc_lex.printsymbol
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lex.psnext
cc_lex.psnext:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    call      msys.m$print_startcon
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L8852]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       %rcx,	[%rip+cc_decls.nextlx]
    call      cc_lex.printsymbol
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lex.gethashtablesize
cc_lex.gethashtablesize:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
#---------------
#PROC3
#PROC4
    xor       %rbx,	%rbx
    xor       %eax,	%eax
    mov       %rdi,	%rax
    mov       %rax,	[%rip+cc_decls.hstmask]
    cmp       %rax,	0
    jl        L3634
L3632:
    mov       %rax,	[%rip+cc_decls.hashtable]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    mov       %rax,	[%rax]
    test      %rax,	%rax
    jz        L3636
    inc       %rbx
L3636:
    inc       %rdi
    cmp       %rdi,	[%rip+cc_decls.hstmask]
    jle       L3632
L3634:
    mov       %rax,	%rbx
L3631:
#---------------
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.readlinecomment
cc_lex.readlinecomment:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
L3638:
L3640:
L3641:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    lea       %r10,	[%rip+cc_lex.linecommentmap]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jnz       L3640
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	10
    jz        L3644
    test      %rax,	%rax
    jz        L3645
    cmp       %rax,	92
    jz        L3646
    jmp       L3647
L3644:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L3639
L3645:
    jmp       L3639
L3646:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	13
    jz        L3649
    cmp       %rax,	10
    jz        L3650
    jmp       L3651
L3649:
    add       qword ptr[%rip+cc_lex.lxsptr],	2
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %rax,	[%rax+16]
    inc       dword ptr[%rax]
    jmp       L3648
L3650:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %rax,	[%rax+16]
    inc       dword ptr[%rax]
L3651:
L3648:
L3647:
L3643:
    jmp       L3638
L3639:
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %rax,	[%rax+16]
    inc       dword ptr[%rax]
#---------------
    ret       
# End 
# Proc cc_lex.readblockcomment
cc_lex.readblockcomment:
#PROC1
#PROC2
#?>>
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
L3653:
L3655:
L3656:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    lea       %r10,	[%rip+cc_lex.commentmap]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jnz       L3655
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	10
    jz        L3659
    test      %rax,	%rax
    jz        L3660
    cmp       %rax,	42
    jz        L3661
    jmp       L3662
L3659:
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %rax,	[%rax+16]
    inc       dword ptr[%rax]
    jmp       L3658
L3660:
    lea       %rcx,	[%rip+L8853]
    call      cc_lex.lxerror
    jmp       L3658
L3661:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax+1]
    cmp       %rax,	47
    jnz       L3664
    add       qword ptr[%rip+cc_lex.lxsptr],	2
    jmp       L3654
L3664:
L3662:
L3658:
    jmp       L3653
L3654:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_lex.readhex
cc_lex.readhex:
#PROC1
#PROC2
#?>>
    .set cc_lex.readhex.pstart, 64
    .set cc_lex.readhex.p, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       [%rbp+64],	%rcx
#---------------
#PROC3
#PROC4
    xor       %rdi,	%rdi
    mov       %rax,	[%rip+cc_lex.lxsptr]
    mov       [%rbp + cc_lex.readhex.p],	%rax
    mov       %r12,	1
    xor       %eax,	%eax
    mov       %r14,	%rax
    mov       %r13,	%rax
    xor       %rsi,	%rsi
L3666:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    mov       %rbx,	%rax
    sub       %rax,	46
    cmp       %rax,	72
    jae       L3669
    lea       %r10,	[%rip+L3668]
    jmp       [%r10 + %rax*8]
    .data
L3668:
    .quad     L3676
    .quad     L3669
    .quad     L3671
    .quad     L3670
    .quad     L3670
    .quad     L3670
    .quad     L3670
    .quad     L3670
    .quad     L3670
    .quad     L3670
    .quad     L3670
    .quad     L3670
    .quad     L3669
    .quad     L3669
    .quad     L3669
    .quad     L3669
    .quad     L3669
    .quad     L3669
    .quad     L3669
    .quad     L3674
    .quad     L3674
    .quad     L3674
    .quad     L3674
    .quad     L3674
    .quad     L3674
    .quad     L3669
    .quad     L3669
    .quad     L3669
    .quad     L3669
    .quad     L3669
    .quad     L3677
    .quad     L3669
    .quad     L3669
    .quad     L3669
    .quad     L3676
    .quad     L3669
    .quad     L3669
    .quad     L3669
    .quad     L3669
    .quad     L3680
    .quad     L3669
    .quad     L3669
    .quad     L3669
    .quad     L3669
    .quad     L3669
    .quad     L3669
    .quad     L3669
    .quad     L3669
    .quad     L3669
    .quad     L3669
    .quad     L3669
    .quad     L3675
    .quad     L3675
    .quad     L3675
    .quad     L3675
    .quad     L3675
    .quad     L3675
    .quad     L3669
    .quad     L3669
    .quad     L3669
    .quad     L3669
    .quad     L3669
    .quad     L3677
    .quad     L3669
    .quad     L3669
    .quad     L3669
    .quad     L3676
    .quad     L3669
    .quad     L3669
    .quad     L3669
    .quad     L3669
    .quad     L3680
    .text
L3670:
    xor       %r12,	%r12
    mov       %rax,	%rdi
    shl       %rax,	4
    lea       %r10,	[%rbx-48]
    add       %rax,	%r10
    mov       %rdi,	%rax
    inc       %rsi
    jmp       L3666
L3671:
    test      %r12,	%r12
    jz        L3673
    inc       qword ptr[%rbp + cc_lex.readhex.p]
    jmp       L3672
L3673:
    inc       %rsi
    mov       %rax,	%rdi
    shl       %rax,	4
    mov       %rdi,	%rax
L3672:
    jmp       L3666
L3674:
    xor       %r12,	%r12
    inc       %rsi
    mov       %rax,	%rdi
    shl       %rax,	4
    lea       %r10,	[%rbx-65]
    add       %r10,	10
    add       %rax,	%r10
    mov       %rdi,	%rax
    jmp       L3666
L3675:
    xor       %r12,	%r12
    inc       %rsi
    mov       %rax,	%rdi
    shl       %rax,	4
    lea       %r10,	[%rbx-97]
    add       %r10,	10
    add       %rax,	%r10
    mov       %rdi,	%rax
    jmp       L3666
L3676:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	[%rbp + cc_lex.readhex.p]
    mov       %rcx,	[%rbp + cc_lex.readhex.pstart]
    mov       %rdx,	[%rbp + cc_lex.readhex.p]
    mov       %r8,	%rax
    mov       %r9,	16
    call      cc_lex.readrealnumber
    jmp       L3665
L3677:
    inc       %r13
    cmp       %r13,	2
    jle       L3679
    lea       %rcx,	[%rip+L8854]
    call      cc_lex.lxerror
L3679:
    jmp       L3666
L3680:
    test      %r14,	%r14
    jz        L3682
    lea       %rcx,	[%rip+L8855]
    call      cc_lex.lxerror
L3682:
    mov       %r14,	1
    jmp       L3666
L3669:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L3667
L3667:
    mov       %rax,	[%rbp + cc_lex.readhex.pstart]
    sub       %rax,	[%rip+cc_lex.lxstart]
    mov       %rcx,	%rax
    call      cc_lex.setnumberoffset
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	[%rbp + cc_lex.readhex.pstart]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
    cmp       %rsi,	16
    jle       L3684
    lea       %rcx,	[%rip+L8856]
    call      cc_lex.lxerror
L3684:
    mov       %al,	59
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    mov       %rax,	%rdi
    mov       %r10,	9223372036854775807
    cmp       %rax,	%r10
    jbe       L3686
    mov       %al,	9
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    jmp       L3685
L3686:
    mov       %rax,	%rdi
    mov       %r10,	4294967295
    cmp       %rax,	%r10
    jbe       L3687
    mov       %al,	4
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    jmp       L3685
L3687:
    cmp       %rdi,	2147483647
    jbe       L3688
    mov       %al,	8
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    jmp       L3685
L3688:
    mov       %al,	3
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
L3685:
    mov       %rax,	%rdi
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10],	%rax
    call      cc_lex.checknumbersuffix
L3665:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.readbinary
cc_lex.readbinary:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    sub       %rsp,	48
    mov       %r15,	%rcx
#---------------
#PROC3
#PROC4
    xor       %rdi,	%rdi
    mov       %rax,	[%rip+cc_lex.lxsptr]
    mov       %r13,	%rax
    mov       %r12,	1
L3690:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    mov       %rbx,	%rax
    sub       %rax,	46
    cmp       %rax,	12
    jae       L3693
    lea       %r10,	[%rip+L3692]
    jmp       [%r10 + %rax*8]
    .data
L3692:
    .quad     L3699
    .quad     L3693
    .quad     L3695
    .quad     L3694
    .quad     L3698
    .quad     L3698
    .quad     L3698
    .quad     L3698
    .quad     L3698
    .quad     L3698
    .quad     L3698
    .quad     L3698
    .text
L3694:
    xor       %r12,	%r12
    jmp       L3690
L3695:
    test      %r12,	%r12
    jz        L3697
    inc       %r13
L3697:
    jmp       L3690
L3698:
    lea       %rcx,	[%rip+L8857]
    call      cc_lex.lxerror
    jmp       L3690
L3699:
    lea       %rcx,	[%rip+L8858]
    call      cc_lex.lxerror
    jmp       L3690
L3693:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L3691
L3691:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	%r13
    mov       %rsi,	%rax
    mov       %rax,	%r15
    sub       %rax,	[%rip+cc_lex.lxstart]
    mov       %rcx,	%rax
    call      cc_lex.setnumberoffset
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	%r15
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
    cmp       %rsi,	64
    jle       L3701
    lea       %rcx,	[%rip+L8859]
    call      cc_lex.lxerror
L3701:
    mov       %r14,	%rsi
    cmp       %r14,	0
    jle       L3704
L3702:
    mov       %rax,	%rdi
    shl       %rax,	1
    mov       %r10,	%r13
    inc       %r13
    movzx     %r10,	byte ptr[%r10]
    add       %rax,	%r10
    sub       %rax,	48
    mov       %rdi,	%rax
    dec       %r14
    jnz       L3702
L3704:
    mov       %al,	59
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    mov       %al,	3
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    cmp       %rdi,	2147483647
    jb        L3706
    mov       %al,	4
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
L3706:
    mov       %rax,	%rdi
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10],	%rax
    call      cc_lex.checknumbersuffix
#---------------
    add       %rsp,	48
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.readoctal
cc_lex.readoctal:
#PROC1
#PROC2
#?>>
    .set cc_lex.readoctal.pstart, 64
    .set cc_lex.readoctal.usigned, -8
    .set cc_lex.readoctal.p, -16
    .set cc_lex.readoctal.av_1, -24
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	64
    mov       [%rbp+64],	%rcx
#---------------
#PROC3
#PROC4
    xor       %rdi,	%rdi
    mov       %rax,	[%rip+cc_lex.lxsptr]
    mov       [%rbp + cc_lex.readoctal.p],	%rax
    mov       %r13,	1
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.readoctal.usigned],	%rax
    mov       %r14,	%rax
    xor       %rsi,	%rsi
L3708:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    mov       %rbx,	%rax
    sub       %rax,	46
    cmp       %rax,	72
    jae       L3711
    lea       %r10,	[%rip+L3710]
    jmp       [%r10 + %rax*8]
    .data
L3710:
    .quad     L3716
    .quad     L3711
    .quad     L3713
    .quad     L3712
    .quad     L3712
    .quad     L3712
    .quad     L3712
    .quad     L3712
    .quad     L3712
    .quad     L3712
    .quad     L3711
    .quad     L3711
    .quad     L3711
    .quad     L3711
    .quad     L3711
    .quad     L3711
    .quad     L3711
    .quad     L3711
    .quad     L3711
    .quad     L3711
    .quad     L3711
    .quad     L3711
    .quad     L3711
    .quad     L3711
    .quad     L3711
    .quad     L3711
    .quad     L3711
    .quad     L3711
    .quad     L3711
    .quad     L3711
    .quad     L3717
    .quad     L3711
    .quad     L3711
    .quad     L3711
    .quad     L3711
    .quad     L3711
    .quad     L3711
    .quad     L3711
    .quad     L3711
    .quad     L3720
    .quad     L3711
    .quad     L3711
    .quad     L3711
    .quad     L3711
    .quad     L3711
    .quad     L3711
    .quad     L3711
    .quad     L3711
    .quad     L3711
    .quad     L3711
    .quad     L3711
    .quad     L3711
    .quad     L3711
    .quad     L3711
    .quad     L3711
    .quad     L3711
    .quad     L3711
    .quad     L3711
    .quad     L3711
    .quad     L3711
    .quad     L3711
    .quad     L3711
    .quad     L3717
    .quad     L3711
    .quad     L3711
    .quad     L3711
    .quad     L3711
    .quad     L3711
    .quad     L3711
    .quad     L3711
    .quad     L3711
    .quad     L3720
    .text
L3712:
    xor       %r13,	%r13
    inc       %rsi
    jmp       L3708
L3713:
    test      %r13,	%r13
    jz        L3715
    inc       qword ptr[%rbp + cc_lex.readoctal.p]
    jmp       L3714
L3715:
    inc       %rsi
L3714:
    jmp       L3708
L3716:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	[%rbp + cc_lex.readoctal.p]
    mov       %rcx,	[%rbp + cc_lex.readoctal.pstart]
    mov       %rdx,	[%rbp + cc_lex.readoctal.p]
    mov       %r8,	%rax
    mov       %r9,	10
    call      cc_lex.readrealnumber
    jmp       L3707
L3717:
    inc       %r14
    cmp       %r14,	2
    jle       L3719
    lea       %rcx,	[%rip+L8860]
    call      cc_lex.lxerror
L3719:
    jmp       L3708
L3720:
    mov       %rax,	[%rbp + cc_lex.readoctal.usigned]
    test      %rax,	%rax
    jz        L3722
    lea       %rcx,	[%rip+L8861]
    call      cc_lex.lxerror
L3722:
    mov       %rax,	1
    mov       [%rbp + cc_lex.readoctal.usigned],	%rax
    jmp       L3708
L3711:
    lea       %rax,	[%rip+cc_lex.alphamap]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L3724
#cc_lex.readoctal.doalpha:
    mov       %rcx,	[%rbp + cc_lex.readoctal.pstart]
    call      cc_lex.readalphanumeric
    jmp       L3707
L3724:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L3709
L3709:
    mov       %rax,	[%rbp + cc_lex.readoctal.pstart]
    sub       %rax,	[%rip+cc_lex.lxstart]
    mov       %rcx,	%rax
    call      cc_lex.setnumberoffset
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	[%rbp + cc_lex.readoctal.pstart]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
    cmp       %rsi,	22
    jg        L3728
    cmp       %rsi,	22
    jnz       L3727
    mov       %rcx,	[%rbp + cc_lex.readoctal.p]
    lea       %rdx,	[%rip+L8862]
    mov       %r8,	22
    call      mlib.cmpstringn
    mov       %r12,	%rax
    cmp       %rax,	0
    jle       L3727
L3728:
    lea       %rcx,	[%rip+L8863]
    call      cc_lex.lxerror
L3727:
    mov       [%rbp + cc_lex.readoctal.av_1],	%rsi
    mov       %rax,	[%rbp + cc_lex.readoctal.av_1]
    cmp       %rax,	0
    jle       L3731
L3729:
    mov       %rax,	%rdi
    shl       %rax,	3
    mov       %r10,	[%rbp + cc_lex.readoctal.p]
    inc       qword ptr[%rbp + cc_lex.readoctal.p]
    movzx     %r10,	byte ptr[%r10]
    add       %rax,	%r10
    sub       %rax,	48
    mov       %rdi,	%rax
    dec       qword ptr[%rbp + cc_lex.readoctal.av_1]
    jnz       L3729
L3731:
    mov       %al,	59
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    mov       %al,	3
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    cmp       %rdi,	2147483647
    jb        L3733
    mov       %al,	4
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
L3733:
    mov       %rax,	%rdi
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10],	%rax
    call      cc_lex.checknumbersuffix
L3707:
#---------------
    add       %rsp,	64
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.readdecimal
cc_lex.readdecimal:
#PROC1
#PROC2
#?>>
    .set cc_lex.readdecimal.pstart, 64
    .set cc_lex.readdecimal.p, -8
    .set cc_lex.readdecimal.av_1, -16
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       [%rbp+64],	%rcx
#---------------
#PROC3
#PROC4
    xor       %rdi,	%rdi
    xor       %eax,	%eax
    mov       %r14b,	%al
    mov       %r13b,	%al
    dec       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    mov       [%rbp + cc_lex.readdecimal.p],	%rax
L3735:
L3736:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    lea       %r10,	[%rip+cc_lex.digitmap]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jnz       L3735
    jmp       L3739
L3738:
    inc       qword ptr[%rbp + cc_lex.readdecimal.p]
L3739:
    mov       %rax,	[%rbp + cc_lex.readdecimal.p]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	48
    jz        L3738
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	[%rbp + cc_lex.readdecimal.p]
    mov       %rsi,	%rax
L3741:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    mov       %rbx,	%rax
    sub       %rax,	46
    cmp       %rax,	72
    jae       L3744
    lea       %r10,	[%rip+L3743]
    jmp       [%r10 + %rax*8]
    .data
L3743:
    .quad     L3745
    .quad     L3744
    .quad     L3744
    .quad     L3744
    .quad     L3744
    .quad     L3744
    .quad     L3744
    .quad     L3744
    .quad     L3744
    .quad     L3744
    .quad     L3744
    .quad     L3744
    .quad     L3744
    .quad     L3744
    .quad     L3744
    .quad     L3744
    .quad     L3744
    .quad     L3744
    .quad     L3744
    .quad     L3744
    .quad     L3744
    .quad     L3744
    .quad     L3744
    .quad     L3745
    .quad     L3744
    .quad     L3744
    .quad     L3744
    .quad     L3744
    .quad     L3744
    .quad     L3744
    .quad     L3746
    .quad     L3744
    .quad     L3744
    .quad     L3744
    .quad     L3744
    .quad     L3744
    .quad     L3744
    .quad     L3744
    .quad     L3744
    .quad     L3749
    .quad     L3744
    .quad     L3744
    .quad     L3744
    .quad     L3744
    .quad     L3744
    .quad     L3744
    .quad     L3744
    .quad     L3744
    .quad     L3744
    .quad     L3744
    .quad     L3744
    .quad     L3744
    .quad     L3744
    .quad     L3744
    .quad     L3744
    .quad     L3745
    .quad     L3744
    .quad     L3744
    .quad     L3744
    .quad     L3744
    .quad     L3744
    .quad     L3744
    .quad     L3746
    .quad     L3744
    .quad     L3744
    .quad     L3744
    .quad     L3744
    .quad     L3744
    .quad     L3744
    .quad     L3744
    .quad     L3744
    .quad     L3749
    .text
L3745:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	[%rbp + cc_lex.readdecimal.p]
    mov       %rcx,	[%rbp + cc_lex.readdecimal.pstart]
    mov       %rdx,	[%rbp + cc_lex.readdecimal.p]
    mov       %r8,	%rax
    mov       %r9,	10
    call      cc_lex.readrealnumber
    jmp       L3734
L3746:
    inc       %r13b
    movzx     %rax,	%r13b
    cmp       %rax,	2
    jle       L3748
    lea       %rcx,	[%rip+L8864]
    call      cc_lex.lxerror
L3748:
    jmp       L3741
L3749:
    test      %r14b,	%r14b
    jz        L3751
    lea       %rcx,	[%rip+L8865]
    call      cc_lex.lxerror
L3751:
    mov       %r14b,	1
    jmp       L3741
L3744:
    lea       %rax,	[%rip+cc_lex.alphamap]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L3753
    mov       %rcx,	[%rbp + cc_lex.readdecimal.pstart]
    call      cc_lex.readalphanumeric
    jmp       L3734
L3753:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L3742
L3742:
    mov       %rax,	[%rbp + cc_lex.readdecimal.pstart]
    sub       %rax,	[%rip+cc_lex.lxstart]
    mov       %rcx,	%rax
    call      cc_lex.setnumberoffset
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	[%rbp + cc_lex.readdecimal.pstart]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
    cmp       %rsi,	20
    jg        L3756
    cmp       %rsi,	20
    jnz       L3755
    mov       %rcx,	[%rbp + cc_lex.readdecimal.p]
    lea       %rdx,	[%rip+L8866]
    mov       %r8,	20
    call      mlib.cmpstringn
    mov       %r12,	%rax
    cmp       %rax,	0
    jle       L3755
L3756:
    lea       %rcx,	[%rip+L8867]
    call      cc_lex.lxerror
L3755:
    mov       [%rbp + cc_lex.readdecimal.av_1],	%rsi
    mov       %rax,	[%rbp + cc_lex.readdecimal.av_1]
    cmp       %rax,	0
    jle       L3759
L3757:
    mov       %rax,	%rdi
    shl       %rax,	1
    lea       %rax,	[%rax + %rax*4]
    mov       %r10,	[%rbp + cc_lex.readdecimal.p]
    inc       qword ptr[%rbp + cc_lex.readdecimal.p]
    movzx     %r10,	byte ptr[%r10]
    sub       %r10,	48
    add       %rax,	%r10
    mov       %rdi,	%rax
    dec       qword ptr[%rbp + cc_lex.readdecimal.av_1]
    jnz       L3757
L3759:
    mov       %al,	59
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    movzx     %rax,	%r13b
    test      %rax,	%rax
    jz        L3761
    cmp       %rax,	1
    jz        L3762
    cmp       %rax,	2
    jz        L3763
    jmp       L3764
L3761:
    cmp       %rdi,	2147483647
    jl        L3766
    mov       %al,	4
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    jmp       L3765
L3766:
    mov       %al,	3
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
L3765:
    test      %r14b,	%r14b
    jz        L3768
    mov       %rax,	%rdi
    mov       %r10,	4294967295
    cmp       %rax,	%r10
    jb        L3770
    mov       %al,	9
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    jmp       L3769
L3770:
    mov       %al,	8
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
L3769:
    jmp       L3767
L3768:
    cmp       %rdi,	2147483647
    jb        L3772
    mov       %al,	4
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
L3772:
L3767:
    jmp       L3760
L3762:
    test      %r14b,	%r14b
    jz        L3774
    mov       %rax,	%rdi
    mov       %r10,	4294967295
    cmp       %rax,	%r10
    jb        L3776
    mov       %al,	9
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    jmp       L3775
L3776:
    mov       %al,	8
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
L3775:
    jmp       L3773
L3774:
    cmp       %rdi,	2147483647
    jb        L3778
    mov       %al,	4
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
L3778:
L3773:
    jmp       L3760
L3763:
    test      %r14b,	%r14b
    jz        L3780
    mov       %al,	9
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    jmp       L3779
L3780:
    mov       %al,	4
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
L3779:
L3764:
L3760:
    mov       %rax,	%rdi
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10],	%rax
L3734:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.checknumbersuffix
cc_lex.checknumbersuffix:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	16
#---------------
#PROC3
#PROC4
L3782:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    mov       %dil,	%al
    sub       %rax,	76
    cmp       %rax,	42
    jae       L3785
    lea       %r10,	[%rip+L3784]
    jmp       [%r10 + %rax*8]
    .data
L3784:
    .quad     L3786
    .quad     L3785
    .quad     L3785
    .quad     L3785
    .quad     L3785
    .quad     L3785
    .quad     L3785
    .quad     L3785
    .quad     L3785
    .quad     L3786
    .quad     L3785
    .quad     L3785
    .quad     L3785
    .quad     L3785
    .quad     L3785
    .quad     L3785
    .quad     L3785
    .quad     L3785
    .quad     L3785
    .quad     L3785
    .quad     L3785
    .quad     L3785
    .quad     L3785
    .quad     L3785
    .quad     L3785
    .quad     L3785
    .quad     L3785
    .quad     L3785
    .quad     L3785
    .quad     L3785
    .quad     L3785
    .quad     L3785
    .quad     L3786
    .quad     L3785
    .quad     L3785
    .quad     L3785
    .quad     L3785
    .quad     L3785
    .quad     L3785
    .quad     L3785
    .quad     L3785
    .quad     L3786
    .text
L3786:
    jmp       L3782
L3785:
    movzx     %rax,	%dil
    lea       %r10,	[%rip+cc_lex.alphamap]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L3788
L3788:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L3783
L3783:
    mov       %rax,	3
L3781:
#---------------
    add       %rsp,	16
    pop       %rdi
    ret       
# End 
# Proc cc_lex.stacksourcefile
cc_lex.stacksourcefile:
#PROC1
#PROC2
#?>>
    .set cc_lex.stacksourcefile.info, -24
    .set cc_lex.stacksourcefile.fullpath, -528
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	568
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      cc_lex.getsourcefile
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L3791
    call      msys.m$print_startcon
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    mov       %rcx,	%rbx
    call      strlen
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8868]
    call      cc_lex.lxerror
L3791:
    mov       %rax,	[%rip+cc_lex.lx_stackindex]
    cmp       %rax,	20
    jl        L3793
    lea       %rcx,	[%rip+L8869]
    call      cc_lex.lxerror
L3793:
    inc       qword ptr[%rip+cc_lex.lx_stackindex]
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.stacksourcefile.fullpath],	%al
    mov       %rax,	[%rip+cc_lex.lx_stackindex]
    cmp       %rax,	1
    jle       L3795
    lea       %rax,	[%rip+cc_lex.headerpathlist]
    mov       %r10,	[%rip+cc_lex.lx_stackindex]
    mov       %rax,	[%rax + %r10*8-16]
    lea       %rcx,	[%rbp + cc_lex.stacksourcefile.fullpath]
    mov       %rdx,	%rax
    call      strcpy
L3795:
    lea       %rax,	[%rip+cc_lex.headerpath]
    mov       %al,	[%rax]
    test      %al,	%al
    jz        L3797
    lea       %rcx,	[%rip+cc_lex.headerpath]
    call      mlib.pcm_copyheapstring
    lea       %rcx,	[%rbp + cc_lex.stacksourcefile.fullpath]
    mov       %rdx,	%rax
    call      strcat
L3797:
    lea       %rcx,	[%rbp + cc_lex.stacksourcefile.fullpath]
    call      mlib.pcm_copyheapstring
    lea       %r10,	[%rip+cc_lex.headerpathlist]
    mov       %r11,	[%rip+cc_lex.lx_stackindex]
    mov       [%r10 + %r11*8-8],	%rax
    mov       %rax,	[%rip+cc_lex.lxstart]
    mov       [%rbp + cc_lex.stacksourcefile.info],	%rax
    mov       %rax,	[%rip+cc_lex.lxsptr]
    mov       [%rbp + cc_lex.stacksourcefile.info+8],	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %eax,	[%rax+16]
    mov       [%rbp + cc_lex.stacksourcefile.info+16],	%eax
    call      cc_lex.getfileno
    mov       [%rbp + cc_lex.stacksourcefile.info+20],	%eax
    lea       %rax,	[%rbp + cc_lex.stacksourcefile.info]
    lea       %r10,	[%rip+cc_lex.lx_stack]
    mov       %r11,	[%rip+cc_lex.lx_stackindex]
    shl       %r11,	3
    lea       %r11,	[%r11 + %r11*2]
    mov       %r8,	[%rax]
    mov       [%r10 + %r11-24],	%r8
    mov       %r8,	[%rax+8]
    mov       [%r10 + %r11-16],	%r8
    mov       %r8,	[%rax+16]
    mov       [%r10 + %r11-8],	%r8
    lea       %rax,	[%rip+cc_decls.sourcefiletext]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    mov       [%rip+cc_lex.lxsptr],	%rax
    mov       [%rip+cc_lex.lxstart],	%rax
    mov       %rcx,	%rdi
    call      cc_lex.setfileno
    mov       %eax,	1
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+16],	%eax
#---------------
    add       %rsp,	568
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.unstacksourcefile
cc_lex.unstacksourcefile:
#PROC1
#PROC2
#?>>
    .set cc_lex.unstacksourcefile.info, -24
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	56
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rip+cc_lex.headerpathlist]
    mov       %r10,	[%rip+cc_lex.lx_stackindex]
    mov       %rdi,	[%rax + %r10*8-8]
    mov       %rcx,	%rdi
    call      strlen
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mlib.pcm_free
    mov       %rax,	[%rip+cc_lex.lx_stackindex]
    dec       qword ptr[%rip+cc_lex.lx_stackindex]
    lea       %r10,	[%rip+cc_lex.lx_stack]
    mov       %r11,	%rax
    shl       %r11,	3
    lea       %r11,	[%r11 + %r11*2]
    lea       %r10,	[%r10 + %r11-24]
    lea       %rax,	[%rbp + cc_lex.unstacksourcefile.info]
    mov       %r11,	[%r10]
    mov       [%rax],	%r11
    mov       %r11,	[%r10+8]
    mov       [%rax+8],	%r11
    mov       %r11,	[%r10+16]
    mov       [%rax+16],	%r11
    mov       %rax,	[%rbp + cc_lex.unstacksourcefile.info]
    mov       [%rip+cc_lex.lxstart],	%rax
    mov       %rax,	[%rbp + cc_lex.unstacksourcefile.info+8]
    mov       [%rip+cc_lex.lxsptr],	%rax
    mov       %eax,	[%rbp + cc_lex.unstacksourcefile.info+16]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+16],	%eax
    movsxd    %rax,	dword ptr[%rbp + cc_lex.unstacksourcefile.info+20]
    mov       %rcx,	%rax
    call      cc_lex.setfileno
#---------------
    add       %rsp,	56
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc cc_lex.getsourcefile
cc_lex.getsourcefile:
#PROC1
#PROC2
#?>>
    .set cc_lex.getsourcefile.syshdr, 48
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
#PROC3
#PROC4
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_lex.headerpath]
    mov       [%r10],	%al
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    mov       %rdx,	%rsi
    call      strcpy
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    call      mlib.convlcstring
    mov       %rbx,	1
    mov       %rax,	[%rip+cc_decls.nsourcefiles]
    cmp       %rax,	1
    jl        L3802
L3800:
    lea       %rax,	[%rip+cc_decls.sourcefilenames]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8]
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    mov       %rdx,	%rax
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L3804
    mov       %rax,	%rbx
    jmp       L3799
L3804:
    inc       %rbx
    cmp       %rbx,	[%rip+cc_decls.nsourcefiles]
    jle       L3800
L3802:
    mov       %al,	[%rip+cc_cli.dointheaders]
    test      %al,	%al
    jz        L3806
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    call      cc_headers.findheader
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L3808
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    mov       %rdx,	%rdi
    call      cc_support.loadbuiltin
    jmp       L3799
L3808:
L3806:
    mov       %rcx,	%rsi
    lea       %rdx,	[%rip+L8870]
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L3810
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    lea       %rdx,	[%rip+L8871]
    call      cc_support.loadbuiltin
    jmp       L3799
L3810:
    mov       %rcx,	%rsi
    call      mlib.extractpath
    lea       %rcx,	[%rip+cc_lex.headerpath]
    mov       %rdx,	%rax
    call      strcpy
    lea       %rax,	[%rip+cc_lex.headerpath]
    mov       %al,	[%rax]
    test      %al,	%al
    jz        L3812
    lea       %rax,	[%rip+cc_lex.headerpath]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	47
    jz        L3815
    lea       %rax,	[%rip+cc_lex.headerpath]
    movzx     %rax,	byte ptr[%rax+1]
    cmp       %rax,	58
    jnz       L3814
    lea       %rax,	[%rip+cc_lex.headerpath]
    movzx     %rax,	byte ptr[%rax+2]
    cmp       %rax,	47
    jnz       L3814
L3815:
    mov       %rcx,	%rsi
    call      mlib.checkfile
    test      %rax,	%rax
    jz        L3817
    mov       %rcx,	%rsi
    mov       %rdx,	%rsi
    call      cc_support.loadsourcefile
    jmp       L3799
L3817:
    xor       %eax,	%eax
    jmp       L3799
L3814:
L3812:
    mov       %rbx,	[%rip+cc_lex.lx_stackindex]
    cmp       %rbx,	1
    jl        L3820
L3818:
    lea       %rax,	[%rip+cc_lex.headerpathlist]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8-8]
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    mov       %rdx,	%rax
    call      strcpy
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    mov       %rdx,	%rsi
    call      strcat
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    call      mlib.checkfile
    test      %rax,	%rax
    jz        L3822
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    mov       %rdx,	%rsi
    call      cc_support.loadsourcefile
    jmp       L3799
L3822:
    dec       %rbx
    cmp       %rbx,	1
    jge       L3818
L3820:
    mov       %rbx,	1
    mov       %rax,	[%rip+cc_decls.nsearchdirs]
    cmp       %rax,	1
    jl        L3825
L3823:
    lea       %rax,	[%rip+cc_decls.searchdirs]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8-8]
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    mov       %rdx,	%rax
    call      strcpy
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    mov       %rdx,	%rsi
    call      strcat
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    call      mlib.checkfile
    test      %rax,	%rax
    jz        L3827
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    call      mlib.extractpath
    lea       %rcx,	[%rip+cc_lex.headerpath]
    mov       %rdx,	%rax
    call      strcpy
    lea       %rcx,	[%rip+cc_lex.getsourcefile.filespec]
    mov       %rdx,	%rsi
    call      cc_support.loadsourcefile
    jmp       L3799
L3827:
    inc       %rbx
    cmp       %rbx,	[%rip+cc_decls.nsearchdirs]
    jle       L3823
L3825:
    xor       %eax,	%eax
L3799:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.lex
cc_lex.lex:
#PROC1
#PROC2
#?>>
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
#cc_lex.lex.reenter:
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %r10,	[%rip+cc_decls.lx]
    mov       %r11,	[%rax]
    mov       [%r10],	%r11
    mov       %r11,	[%rax+8]
    mov       [%r10+8],	%r11
    mov       %r11,	[%rax+16]
    mov       [%r10+16],	%r11
    mov       %r11,	[%rax+24]
    mov       [%r10+24],	%r11
    call      cc_lex.lexm
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jnz       L3831
    mov       %rax,	[%rip+cc_lex.lx_stackindex]
    test      %rax,	%rax
    jnz       L3831
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       %rax,	[%rax]
    lea       %r10,	[%rip+cc_decls.lx]
    movsxd    %r10,	dword ptr[%r10+24]
    xor       %r11d,	%r11d
    mov       [%rax + %r10],	%r11b
L3831:
L3832:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L3834
    cmp       %rax,	56
    jz        L3835
    jmp       L3836
L3834:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    mov       %al,	[%rax+107]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	68
    jnz       L3838
    mov       %al,	67
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L3838:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    mov       %ax,	[%rax+100]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    jmp       L3828
L3835:
    call      cc_lex.lexm
    jmp       L3832
L3836:
    jmp       L3828
L3828:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_lex.shownumberstr
cc_lex.shownumberstr:
#PROC1
#PROC2
#?>>
    .set cc_lex.shownumberstr.$T1, -8
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rbx
    call      cc_lex.getfilenox
    test      %rax,	%rax
    jz        L3841
    mov       %rcx,	%rbx
    call      cc_lex.getfilenox
    lea       %r10,	[%rip+cc_decls.sourcefiletext]
    mov       %r10,	[%r10 + %rax*8]
    mov       [%rbp + cc_lex.shownumberstr.$T1],	%r10
    mov       %rcx,	%rbx
    call      cc_lex.getnumberoffsetx
    mov       %r10,	[%rbp + cc_lex.shownumberstr.$T1]
    lea       %r10,	[%r10 + %rax]
    mov       %rdi,	%r10
    jmp       L3840
L3841:
    movsx     %rax,	word ptr[%rbx+28]
    lea       %r10,	[%rip+cc_lex.pastedtokenlist]
    mov       %r10,	[%r10 + %rax*8-8]
    mov       %rdi,	%r10
L3840:
    movsxd    %rax,	dword ptr[%rbx+24]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    mov       %r8,	%rsi
    call      cc_lex.printstrn
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.addnamestr
cc_lex.addnamestr:
#PROC1
#PROC2
#?>>
    .set cc_lex.addnamestr.oldlx, -32
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	64
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %r10,	[%rbp + cc_lex.addnamestr.oldlx]
    mov       %r11,	[%rax]
    mov       [%r10],	%r11
    mov       %r11,	[%rax+8]
    mov       [%r10+8],	%r11
    mov       %r11,	[%rax+16]
    mov       [%r10+16],	%r11
    mov       %r11,	[%rax+24]
    mov       [%r10+24],	%r11
    mov       %rcx,	%rbx
    call      strlen
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+24]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      cc_lex.gethashvalue
    mov       [%rip+cc_lex.lxhashvalue],	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+24]
    inc       %rax
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       [%rip+cc_lex.lxsvalue],	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+24]
    inc       %rax
    mov       %rcx,	[%rip+cc_lex.lxsvalue]
    mov       %rdx,	%rbx
    mov       %r8,	%rax
    call      memcpy
    call      cc_lex.lookup
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rdi,	[%rax]
    lea       %rax,	[%rbp + cc_lex.addnamestr.oldlx]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       %r11,	[%rax]
    mov       [%r10],	%r11
    mov       %r11,	[%rax+8]
    mov       [%r10+8],	%r11
    mov       %r11,	[%rax+16]
    mov       [%r10+16],	%r11
    mov       %r11,	[%rax+24]
    mov       [%r10+24],	%r11
    mov       %rax,	%rdi
L3842:
#---------------
    add       %rsp,	64
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.lxreadstring
cc_lex.lxreadstring:
#PROC1
#PROC2
#?>>
    .set cc_lex.lxreadstring.termchar, 72
    .set cc_lex.lxreadstring.fwide, 80
    .set cc_lex.lxreadstring.str, -2048
    .set cc_lex.lxreadstring.useheap, -2056
    .set cc_lex.lxreadstring.av_1, -2064
    .set cc_lex.lxreadstring.av_2, -2072
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	2104
    mov       [%rbp+72],	%rcx
    mov       [%rbp+80],	%rdx
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rbp + cc_lex.lxreadstring.termchar]
    cmp       %rax,	34
    jnz       L3845
    mov       %rax,	[%rbp + cc_lex.lxreadstring.fwide]
    test      %rax,	%rax
    jz        L3847
    mov       %rax,	64
    jmp       L3846
L3847:
    mov       %rax,	63
L3846:
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3844
L3845:
    mov       %al,	61
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
L3844:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10],	%rax
    mov       %rax,	[%rip+cc_lex.lx_stackindex]
    test      %rax,	%rax
    jnz       L3849
    mov       %rax,	[%rbp + cc_lex.lxreadstring.fwide]
    test      %rax,	%rax
    jnz       L3849
    mov       %rdi,	[%rip+cc_lex.lxsptr]
    mov       %rbx,	%rdi
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.lxreadstring.useheap],	%rax
    jmp       L3848
L3849:
    lea       %rax,	[%rbp + cc_lex.lxreadstring.str]
    mov       %rdi,	%rax
    mov       %rbx,	%rdi
    mov       %rax,	1
    mov       [%rbp + cc_lex.lxreadstring.useheap],	%rax
L3848:
    xor       %r15,	%r15
L3850:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    mov       %r13,	%rax
    cmp       %rax,	92
    jz        L3853
    cmp       %rax,	34
    jz        L3854
    cmp       %rax,	39
    jz        L3854
    test      %rax,	%rax
    jz        L3855
    jmp       L3856
L3853:
    mov       %rax,	[%rip+cc_lex.isincludefile]
    test      %rax,	%rax
    jz        L3858
    mov       %r13,	47
    jmp       L3859
L3858:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    mov       %r13,	%rax
#cc_lex.lxreadstring.reenter:
    lea       %rax,	[%r13-10]
    cmp       %rax,	111
    jae       L3863
    lea       %r10,	[%rip+L3862]
    jmp       [%r10 + %rax*8]
    .data
L3862:
    .quad     L3893
    .quad     L3863
    .quad     L3863
    .quad     L3890
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3887
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3889
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3880
    .quad     L3880
    .quad     L3880
    .quad     L3880
    .quad     L3880
    .quad     L3880
    .quad     L3880
    .quad     L3880
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3888
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3864
    .quad     L3865
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3866
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3867
    .quad     L3863
    .quad     L3863
    .quad     L3863
    .quad     L3868
    .quad     L3863
    .quad     L3869
    .quad     L3863
    .quad     L3870
    .quad     L3863
    .quad     L3871
    .text
L3864:
    mov       %r13,	7
    jmp       L3861
L3865:
    mov       %r13,	8
    jmp       L3861
L3866:
    mov       %r13,	12
    jmp       L3861
L3867:
    mov       %r13,	10
    jmp       L3861
L3868:
    mov       %r13,	13
    jmp       L3861
L3869:
    mov       %r13,	9
    jmp       L3861
L3870:
    mov       %r13,	11
    jmp       L3861
L3871:
    xor       %r13,	%r13
L3872:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    mov       %r14,	%rax
    sub       %rax,	48
    cmp       %rax,	55
    jae       L3876
    lea       %r10,	[%rip+L3875]
    jmp       [%r10 + %rax*8]
    .data
L3875:
    .quad     L3879
    .quad     L3879
    .quad     L3879
    .quad     L3879
    .quad     L3879
    .quad     L3879
    .quad     L3879
    .quad     L3879
    .quad     L3879
    .quad     L3879
    .quad     L3876
    .quad     L3876
    .quad     L3876
    .quad     L3876
    .quad     L3876
    .quad     L3876
    .quad     L3876
    .quad     L3877
    .quad     L3877
    .quad     L3877
    .quad     L3877
    .quad     L3877
    .quad     L3877
    .quad     L3876
    .quad     L3876
    .quad     L3876
    .quad     L3876
    .quad     L3876
    .quad     L3876
    .quad     L3876
    .quad     L3876
    .quad     L3876
    .quad     L3876
    .quad     L3876
    .quad     L3876
    .quad     L3876
    .quad     L3876
    .quad     L3876
    .quad     L3876
    .quad     L3876
    .quad     L3876
    .quad     L3876
    .quad     L3876
    .quad     L3876
    .quad     L3876
    .quad     L3876
    .quad     L3876
    .quad     L3876
    .quad     L3876
    .quad     L3878
    .quad     L3878
    .quad     L3878
    .quad     L3878
    .quad     L3878
    .quad     L3878
    .text
L3877:
    mov       %rax,	%r13
    shl       %rax,	4
    add       %rax,	%r14
    sub       %rax,	65
    add       %rax,	10
    mov       %r13,	%rax
    jmp       L3874
L3878:
    mov       %rax,	%r13
    shl       %rax,	4
    add       %rax,	%r14
    sub       %rax,	97
    add       %rax,	10
    mov       %r13,	%rax
    jmp       L3874
L3879:
    mov       %rax,	%r13
    shl       %rax,	4
    add       %rax,	%r14
    sub       %rax,	48
    mov       %r13,	%rax
    jmp       L3874
L3876:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L3873
L3874:
    jmp       L3872
L3873:
    jmp       L3861
L3880:
    mov       %rax,	48
    sub       %r13,	%rax
    mov       %rax,	2
    mov       [%rbp + cc_lex.lxreadstring.av_1],	%rax
L3881:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    mov       %r14,	%rax
    cmp       %rax,	48
    jz        L3885
    cmp       %rax,	49
    jz        L3885
    cmp       %rax,	50
    jz        L3885
    cmp       %rax,	51
    jz        L3885
    cmp       %rax,	52
    jz        L3885
    cmp       %rax,	53
    jz        L3885
    cmp       %rax,	54
    jz        L3885
    cmp       %rax,	55
    jnz       L3886
L3885:
    mov       %rax,	%r13
    shl       %rax,	3
    add       %rax,	%r14
    sub       %rax,	48
    mov       %r13,	%rax
    jmp       L3884
L3886:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L3883
L3884:
    dec       qword ptr[%rbp + cc_lex.lxreadstring.av_1]
    jnz       L3881
L3883:
    jmp       L3861
L3887:
    mov       %r13,	34
    jmp       L3861
L3888:
    mov       %r13,	92
    jmp       L3861
L3889:
    mov       %r13,	39
    jmp       L3861
L3890:
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %rax,	[%rax+16]
    inc       dword ptr[%rax]
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	10
    jnz       L3892
    inc       qword ptr[%rip+cc_lex.lxsptr]
L3892:
    jmp       L3850
L3893:
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %rax,	[%rax+16]
    inc       dword ptr[%rax]
    jmp       L3850
L3863:
L3861:
    jmp       L3852
L3854:
    cmp       %r13,	[%rbp + cc_lex.lxreadstring.termchar]
    jz        L3851
L3895:
    jmp       L3852
L3855:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8872]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %eax,	[%rax+16]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8873]
    call      cc_lex.lxerror
L3856:
L3852:
#cc_lex.lxreadstring.normalchar:
L3859:
    mov       %rax,	[%rbp + cc_lex.lxreadstring.useheap]
    test      %rax,	%rax
    jnz       L3897
    mov       %rax,	%rdi
    inc       %rdi
    mov       %r10b,	%r13b
    mov       [%rax],	%r10b
    jmp       L3896
L3897:
    inc       %r15
    cmp       %r15,	2048
    jge       L3898
    mov       %rax,	%rdi
    inc       %rdi
    mov       %r10b,	%r13b
    mov       [%rax],	%r10b
    jmp       L3896
L3898:
    lea       %rcx,	[%rip+L8874]
    call      cc_lex.lxerror
L3896:
    jmp       L3850
L3851:
    xor       %eax,	%eax
    mov       [%rdi],	%al
    mov       %rax,	[%rbp + cc_lex.lxreadstring.fwide]
    test      %rax,	%rax
    jz        L3900
    mov       %rax,	%r15
    shl       %rax,	1
    add       %rax,	2
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       %rsi,	%rax
    mov       %r12,	%rax
    mov       [%rbp + cc_lex.lxreadstring.av_2],	%r15
    mov       %rax,	[%rbp + cc_lex.lxreadstring.av_2]
    cmp       %rax,	0
    jle       L3903
L3901:
    mov       %rax,	%rbx
    inc       %rbx
    movzx     %rax,	byte ptr[%rax]
    mov       %r10,	%rsi
    add       %rsi,	2
    mov       [%r10],	%ax
    dec       qword ptr[%rbp + cc_lex.lxreadstring.av_2]
    jnz       L3901
L3903:
    xor       %eax,	%eax
    mov       [%rsi],	%ax
    mov       %rax,	%r12
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10],	%rax
    jmp       L3899
L3900:
    mov       %rax,	[%rbp + cc_lex.lxreadstring.useheap]
    test      %rax,	%rax
    jz        L3904
    mov       %eax,	%r15d
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
    lea       %rax,	[%r15+1]
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10],	%rax
    lea       %rax,	[%r15+1]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       %r10,	[%r10]
    mov       %rcx,	%r10
    lea       %rdx,	[%rbp + cc_lex.lxreadstring.str]
    mov       %r8,	%rax
    call      memcpy
    jmp       L3899
L3904:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    mov       %r10,	%rdi
    sub       %r10,	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       [%rax+24],	%r10d
L3899:
#---------------
    add       %rsp,	2104
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.addlisttoken
cc_lex.addlisttoken:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rcx]
    test      %rax,	%rax
    jnz       L3907
    mov       %rax,	%r8
    mov       [%rdx],	%rax
    mov       [%rcx],	%rax
    jmp       L3906
L3907:
    mov       %rax,	[%rdx]
    mov       %r10,	%r8
    mov       [%rax+8],	%r10
L3906:
    xor       %eax,	%eax
    mov       [%r8+8],	%rax
    mov       [%rdx],	%r8
#---------------
    ret       
# End 
# Proc cc_lex.addlisttoken_copy
cc_lex.addlisttoken_copy:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
#PROC3
#PROC4
    call      cc_lex.alloctoken
    mov       %rdi,	%rax
    mov       %rax,	%r12
    mov       %r10,	[%rax]
    mov       [%rdi],	%r10
    mov       %r10,	[%rax+8]
    mov       [%rdi+8],	%r10
    mov       %r10,	[%rax+16]
    mov       [%rdi+16],	%r10
    mov       %r10,	[%rax+24]
    mov       [%rdi+24],	%r10
    xor       %eax,	%eax
    mov       [%rdi+8],	%rax
    mov       %rax,	[%rbx]
    test      %rax,	%rax
    jnz       L3910
    mov       %rax,	%rdi
    mov       [%rsi],	%rax
    mov       [%rbx],	%rax
    jmp       L3909
L3910:
    mov       %rax,	[%rsi]
    mov       %r10,	%rdi
    mov       [%rax+8],	%r10
L3909:
    xor       %eax,	%eax
    mov       [%rdi+8],	%rax
    mov       [%rsi],	%rdi
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.addlist_nextlx
cc_lex.addlist_nextlx:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
#PROC3
#PROC4
    call      cc_lex.alloctoken
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %r10,	[%rax]
    mov       [%rdi],	%r10
    mov       %r10,	[%rax+8]
    mov       [%rdi+8],	%r10
    mov       %r10,	[%rax+16]
    mov       [%rdi+16],	%r10
    mov       %r10,	[%rax+24]
    mov       [%rdi+24],	%r10
    xor       %eax,	%eax
    mov       [%rdi+8],	%rax
    mov       %rax,	[%rbx]
    test      %rax,	%rax
    jnz       L3913
    mov       %rax,	%rdi
    mov       [%rsi],	%rax
    mov       [%rbx],	%rax
    jmp       L3912
L3913:
    mov       %rax,	[%rsi]
    mov       %r10,	%rdi
    mov       [%rax+8],	%r10
L3912:
    xor       %eax,	%eax
    mov       [%rdi+8],	%rax
    mov       [%rsi],	%rdi
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.addlisttoken_seq
cc_lex.addlisttoken_seq:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
#PROC3
#PROC4
    jmp       L3916
L3915:
    call      cc_lex.alloctoken
    mov       %rdi,	%rax
    mov       %rax,	%r12
    mov       %r10,	[%rax]
    mov       [%rdi],	%r10
    mov       %r10,	[%rax+8]
    mov       [%rdi+8],	%r10
    mov       %r10,	[%rax+16]
    mov       [%rdi+16],	%r10
    mov       %r10,	[%rax+24]
    mov       [%rdi+24],	%r10
    mov       %rax,	[%rbx]
    test      %rax,	%rax
    jnz       L3919
    mov       %rax,	%rdi
    mov       [%rsi],	%rax
    mov       [%rbx],	%rax
    jmp       L3918
L3919:
    mov       %rax,	[%rsi]
    mov       %r10,	%rdi
    mov       [%rax+8],	%r10
L3918:
    xor       %eax,	%eax
    mov       [%rdi+8],	%rax
    mov       [%rsi],	%rdi
    mov       %r12,	[%r12+8]
L3916:
    test      %r12,	%r12
    jnz       L3915
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.addlistmparam
cc_lex.addlistmparam:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rcx]
    test      %rax,	%rax
    jnz       L3922
    mov       %rax,	%r8
    mov       [%rdx],	%rax
    mov       [%rcx],	%rax
    jmp       L3921
L3922:
    mov       %rax,	[%rdx]
    mov       %r10,	%r8
    mov       [%rax+8],	%r10
L3921:
    mov       [%rdx],	%r8
#---------------
    ret       
# End 
# Proc cc_lex.dodefine
cc_lex.dodefine:
#PROC1
#PROC2
#?>>
    .set cc_lex.dodefine.stlist, -8
    .set cc_lex.dodefine.stlistx, -16
    .set cc_lex.dodefine.tklist, -24
    .set cc_lex.dodefine.tklistx, -32
    .set cc_lex.dodefine.ntokens, -40
    .set cc_lex.dodefine.paramno, -48
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	80
#---------------
#PROC3
#PROC4
    call      cc_lex.lexreadtoken
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L3925
    lea       %rcx,	[%rip+L8875]
    call      cc_lex.lxerror
L3925:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rsi,	[%rax]
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %eax,	[%rax+16]
    mov       [%rsi+92],	%eax
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %al,	[%rax+20]
    mov       [%rsi+113],	%al
    mov       %al,	[%rsi+107]
    mov       [%rsi+88],	%al
    mov       %al,	67
    mov       [%rsi+107],	%al
    mov       %al,	1
    mov       [%rsi+109],	%al
    xor       %r14,	%r14
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	40
    jnz       L3927
    inc       qword ptr[%rip+cc_lex.lxsptr]
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.dodefine.stlistx],	%rax
    mov       [%rbp + cc_lex.dodefine.stlist],	%rax
    lea       %rax,	[%rsi+108]
    or        byte ptr[%rax],	4
    call      cc_lex.lexreadtoken
L3928:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L3931
    cmp       %rax,	14
    jz        L3932
    cmp       %rax,	21
    jz        L3933
    jmp       L3934
L3931:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %r12,	[%rax]
    mov       %rdi,	[%rbp + cc_lex.dodefine.stlist]
    jmp       L3936
L3935:
    mov       %rax,	[%rdi]
    cmp       %rax,	%r12
    jnz       L3939
    lea       %rcx,	[%rip+L8876]
    call      cc_lex.lxerror
L3939:
    mov       %rdi,	[%rdi+8]
L3936:
    test      %rdi,	%rdi
    jnz       L3935
    mov       %rcx,	16
    call      mlib.pcm_alloc
    mov       %rbx,	%rax
    mov       [%rbx],	%r12
    xor       %eax,	%eax
    mov       [%rbx+8],	%rax
    lea       %rcx,	[%rbp + cc_lex.dodefine.stlist]
    lea       %rdx,	[%rbp + cc_lex.dodefine.stlistx]
    mov       %r8,	%rbx
    call      cc_lex.addlistmparam
    inc       %r14
    call      cc_lex.lexreadtoken
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jnz       L3941
    call      cc_lex.lexreadtoken
L3941:
    jmp       L3930
L3932:
    jmp       L3929
L3933:
    lea       %rcx,	[%rip+L8877]
    call      cc_lex.addnamestr
    mov       %r12,	%rax
    lea       %rax,	[%rsi+108]
    or        byte ptr[%rax],	2
    call      cc_lex.lexreadtoken
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	14
    jz        L3943
    lea       %rcx,	[%rip+L8878]
    call      cc_lex.lxerror
L3943:
    mov       %rcx,	16
    call      mlib.pcm_alloc
    mov       %rbx,	%rax
    mov       [%rbx],	%r12
    xor       %eax,	%eax
    mov       [%rbx+8],	%rax
    lea       %rcx,	[%rbp + cc_lex.dodefine.stlist]
    lea       %rdx,	[%rbp + cc_lex.dodefine.stlistx]
    mov       %r8,	%rbx
    call      cc_lex.addlistmparam
    inc       %r14
    jmp       L3929
L3934:
    lea       %rcx,	[%rip+L8879]
    call      cc_lex.lxerror
L3930:
    jmp       L3928
L3929:
    mov       %rax,	[%rbp + cc_lex.dodefine.stlist]
    mov       [%rsi+80],	%rax
L3927:
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.dodefine.tklistx],	%rax
    mov       [%rbp + cc_lex.dodefine.tklist],	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.dodefine.ntokens],	%rax
L3944:
    call      cc_lex.lexreadtoken
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	56
    jz        L3947
    cmp       %rax,	57
    jz        L3947
    cmp       %rax,	67
    jz        L3948
    jmp       L3949
L3947:
    jmp       L3945
L3948:
    mov       %rdi,	[%rsi+80]
    mov       %rax,	1
    mov       [%rbp + cc_lex.dodefine.paramno],	%rax
    jmp       L3951
L3950:
    mov       %rax,	[%rdi]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       %r10,	[%r10]
    cmp       %rax,	%r10
    jnz       L3954
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %rax,	[%rax+23]
    mov       %r10b,	2
    or        [%rax],	%r10b
    mov       %ax,	[%rbp + cc_lex.dodefine.paramno]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+28],	%ax
    jmp       L3952
L3954:
    mov       %rdi,	[%rdi+8]
    inc       qword ptr[%rbp + cc_lex.dodefine.paramno]
L3951:
    test      %rdi,	%rdi
    jnz       L3950
L3952:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    cmp       %rax,	%rsi
    jnz       L3956
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %rax,	[%rax+23]
    mov       %r10b,	1
    or        [%rax],	%r10b
L3956:
L3949:
L3946:
    inc       qword ptr[%rbp + cc_lex.dodefine.ntokens]
    call      cc_lex.alloctoken
    mov       %r13,	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %r10,	[%rax]
    mov       [%r13],	%r10
    mov       %r10,	[%rax+8]
    mov       [%r13+8],	%r10
    mov       %r10,	[%rax+16]
    mov       [%r13+16],	%r10
    mov       %r10,	[%rax+24]
    mov       [%r13+24],	%r10
    lea       %rcx,	[%rbp + cc_lex.dodefine.tklist]
    lea       %rdx,	[%rbp + cc_lex.dodefine.tklistx]
    mov       %r8,	%r13
    call      cc_lex.addlisttoken
    jmp       L3944
L3945:
    mov       %rax,	[%rbp + cc_lex.dodefine.tklist]
    mov       [%rsi+72],	%rax
    mov       [%rsi+111],	%r14b
#---------------
    add       %rsp,	80
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.readalphanumeric
cc_lex.readalphanumeric:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
L3958:
L3959:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    lea       %r10,	[%rip+cc_lex.alphamap]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jnz       L3958
    dec       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	%rcx
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10],	%rax
    mov       %al,	58
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	%rcx
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
#---------------
    ret       
# End 
# Proc cc_lex.inmacrostack
cc_lex.inmacrostack:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    jmp       L3963
L3962:
    mov       %rax,	[%rdx]
    cmp       %rax,	%rcx
    jnz       L3966
    mov       %rax,	1
    jmp       L3961
L3966:
    mov       %rdx,	[%rdx+8]
L3963:
    test      %rdx,	%rdx
    jnz       L3962
    xor       %eax,	%eax
L3961:
#---------------
    ret       
# End 
# Proc cc_lex.showtokens
cc_lex.showtokens:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    call      msys.m$print_startcon
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L8880]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L3969
L3968:
    mov       %rcx,	%rbx
    call      cc_lex.showtoken
    mov       %rbx,	[%rbx+8]
L3969:
    test      %rbx,	%rbx
    jnz       L3968
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8881]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.lexa
cc_lex.lexa:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rdi]
    cmp       %rax,	[%rip+cc_lex.normaltk]
    jnz       L3973
    call      cc_lex.lexreadtoken
    jmp       L3971
L3973:
    mov       %rax,	[%rdi]
    test      %rax,	%rax
    jnz       L3975
    mov       %al,	57
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L3971
L3975:
    mov       %rax,	[%rdi]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       %r11,	[%rax]
    mov       [%r10],	%r11
    mov       %r11,	[%rax+8]
    mov       [%r10+8],	%r11
    mov       %r11,	[%rax+16]
    mov       [%r10+16],	%r11
    mov       %r11,	[%rax+24]
    mov       [%r10+24],	%r11
    mov       %rax,	[%rdi]
    mov       %rax,	[%rax+8]
    mov       [%rdi],	%rax
L3971:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lex.lexm
cc_lex.lexm:
#PROC1
#PROC2
#?>>
    .set cc_lex.lexm.newlineno, -8
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
L3977:
    mov       %rax,	[%rip+cc_lex.tkptr]
    test      %rax,	%rax
    jz        L3980
    mov       %rax,	[%rip+cc_lex.tkptr]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       %r11,	[%rax]
    mov       [%r10],	%r11
    mov       %r11,	[%rax+8]
    mov       [%r10+8],	%r11
    mov       %r11,	[%rax+16]
    mov       [%r10+16],	%r11
    mov       %r11,	[%rax+24]
    mov       [%r10+24],	%r11
    mov       %rax,	[%rip+cc_lex.tkptr]
    mov       %rax,	[%rax+8]
    mov       [%rip+cc_lex.tkptr],	%rax
    mov       %rax,	[%rip+cc_lex.tkptr]
    test      %rax,	%rax
    jnz       L3982
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jnz       L3984
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	1
    jnz       L3984
    call      cc_lex.peeklb
    test      %rax,	%rax
    jz        L3984
    mov       %rcx,	[%rip+cc_decls.sfileno]
    call      cc_lex.setfileno
    mov       %eax,	[%rip+cc_decls.slineno]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+16],	%eax
    xor       %eax,	%eax
    mov       [%rip+cc_lex.lexm.doreset],	%rax
    jmp       L3985
L3984:
    mov       %rax,	1
    mov       [%rip+cc_lex.lexm.doreset],	%rax
L3982:
    jmp       L3976
L3980:
    mov       %rax,	[%rip+cc_lex.lexm.doreset]
    test      %rax,	%rax
    jz        L3987
    mov       %rcx,	[%rip+cc_decls.sfileno]
    call      cc_lex.setfileno
    mov       %eax,	[%rip+cc_decls.slineno]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+16],	%eax
    xor       %eax,	%eax
    mov       [%rip+cc_lex.lexm.doreset],	%rax
L3987:
    mov       %rax,	[%rip+cc_lex.firstsymbol]
    test      %rax,	%rax
    jz        L3989
    xor       %eax,	%eax
    mov       [%rip+cc_lex.firstsymbol],	%rax
    call      cc_lex.dospecialinclude
L3989:
    call      cc_lex.lexreadtoken
#cc_lex.lexm.test1:
L3985:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	4
    jz        L3991
    cmp       %rax,	67
    jz        L3992
    jmp       L3993
L3991:
    call      cc_lex.dolexdirective
    test      %rax,	%rax
    jnz       L3976
L3995:
    jmp       L3977
L3992:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rdi,	[%rax]
    movzx     %rax,	byte ptr[%rdi+107]
    cmp       %rax,	69
    jnz       L3998
L3997:
    call      cc_lex.getfileno
    mov       [%rip+cc_decls.sfileno],	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %eax,	[%rax+16]
    mov       [%rip+cc_decls.slineno],	%rax
    movsx     %rax,	word ptr[%rdi+100]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+cc_decls.nextlx]
    mov       %r8,	[%rip+cc_decls.slineno]
    call      cc_lex.expandpredefmacro
    mov       %rax,	1
    mov       [%rip+cc_lex.lexm.doreset],	%rax
    jmp       L3976
L3998:
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	1
    jnz       L4001
    mov       %rax,	[%rip+cc_lex.noexpand]
    test      %rax,	%rax
    jz        L4000
L4001:
    jmp       L3976
L4000:
L3996:
    jmp       L3990
L3993:
    jmp       L3976
L3990:
    call      cc_lex.getfileno
    mov       [%rip+cc_decls.sfileno],	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %eax,	[%rax+16]
    mov       [%rip+cc_decls.slineno],	%rax
    movzx     %rax,	byte ptr[%rdi+108]
    shr       %eax,	2
    and       %eax,	1
    test      %rax,	%rax
    jz        L4003
    call      cc_lex.peeklb
    test      %rax,	%rax
    jz        L3976
L4005:
    sub       %rsp,	8
    lea       %rax,	[%rbp + cc_lex.lexm.newlineno]
    push      %rax
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    lea       %r8,	[%rip+cc_lex.normaltk]
    mov       %r9,	1
    sub       %rsp,	32
    call      cc_lex.expandfnmacro
    add       %rsp,	48
    mov       [%rip+cc_lex.tkptr],	%rax
    mov       %rax,	[%rbp + cc_lex.lexm.newlineno]
    mov       [%rip+cc_decls.slineno],	%rax
    jmp       L4002
L4003:
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    lea       %r8,	[%rip+cc_lex.normaltk]
    mov       %r9,	1
    call      cc_lex.expandobjmacro
    mov       [%rip+cc_lex.tkptr],	%rax
L4002:
    mov       %rax,	[%rip+cc_lex.tkptr]
    test      %rax,	%rax
    jnz       L4007
    mov       %rax,	1
    mov       [%rip+cc_lex.lexm.doreset],	%rax
L4007:
    jmp       L3977
L3976:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc cc_lex.peeklb
cc_lex.peeklb:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	40
    jz        L4011
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	32
    jnz       L4010
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax+1]
    cmp       %rax,	40
    jnz       L4010
L4011:
    mov       %rax,	1
    jmp       L4008
L4010:
    xor       %eax,	%eax
L4008:
#---------------
    ret       
# End 
# Proc cc_lex.peektk
cc_lex.peektk:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rcx+8]
    mov       %rcx,	%rax
    test      %rcx,	%rcx
    jnz       L4014
    xor       %eax,	%eax
    jmp       L4012
L4014:
    movzx     %rax,	byte ptr[%rcx+21]
    cmp       %rax,	13
    jnz       L4016
    mov       %rax,	1
    jmp       L4012
L4016:
    xor       %eax,	%eax
L4012:
#---------------
    ret       
# End 
# Proc cc_lex.expandobjmacro
cc_lex.expandobjmacro:
#PROC1
#PROC2
#?>>
    .set cc_lex.expandobjmacro.m, 64
    .set cc_lex.expandobjmacro.macrostack, 72
    .set cc_lex.expandobjmacro.tksource, 80
    .set cc_lex.expandobjmacro.frombaselevel, 88
    .set cc_lex.expandobjmacro.newmacro, -32
    .set cc_lex.expandobjmacro.expanded, -40
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	80
    mov       [%rbp+64],	%rcx
    mov       [%rbp+72],	%rdx
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rbp + cc_lex.expandobjmacro.m]
    mov       %rax,	[%rax+72]
    mov       %rdi,	%rax
    mov       %rbx,	%rax
    xor       %eax,	%eax
    mov       %r13,	%rax
    mov       %r12,	%rax
    jmp       L4019
L4018:
    movzx     %rax,	byte ptr[%rbx+21]
    cmp       %rax,	67
    jnz       L4022
    mov       %r14,	[%rbx]
    movzx     %rax,	byte ptr[%r14+109]
    cmp       %rax,	1
    jz        L4025
    movzx     %rax,	byte ptr[%r14+107]
    cmp       %rax,	69
    jnz       L4024
L4025:
    mov       %r12,	1
    jmp       L4020
L4024:
    jmp       L4021
L4022:
    movzx     %rax,	byte ptr[%rbx+21]
    cmp       %rax,	7
    jnz       L4026
    mov       %rax,	1
    mov       %r13,	%rax
    mov       %r12,	%rax
    jmp       L4020
L4026:
L4021:
    mov       %rbx,	[%rbx+8]
L4019:
    test      %rbx,	%rbx
    jnz       L4018
L4020:
    test      %r12,	%r12
    jnz       L4028
    mov       %rax,	%rdi
    jmp       L4017
L4028:
    mov       %rax,	[%rbp + cc_lex.expandobjmacro.m]
    mov       [%rbp + cc_lex.expandobjmacro.newmacro],	%rax
    mov       %rax,	[%rbp + cc_lex.expandobjmacro.macrostack]
    mov       [%rbp + cc_lex.expandobjmacro.newmacro+8],	%rax
    test      %r13,	%r13
    jz        L4030
    sub       %rsp,	8
    push      0
    mov       %rcx,	[%rbp + cc_lex.expandobjmacro.m]
    xor       %edx,	%edx
    xor       %r8d,	%r8d
    xor       %r9d,	%r9d
    sub       %rsp,	32
    call      cc_lex.substituteargs
    add       %rsp,	48
    mov       %rsi,	%rax
    jmp       L4029
L4030:
    mov       %rax,	[%rbp + cc_lex.expandobjmacro.m]
    mov       %rsi,	[%rax+72]
L4029:
    mov       %rcx,	%rsi
    lea       %rdx,	[%rbp + cc_lex.expandobjmacro.newmacro]
    lea       %r8,	[%rbp + cc_lex.expandobjmacro.expanded]
    call      cc_lex.scantokenseq
    mov       %rdi,	%rax
    mov       %rax,	%rdi
L4017:
#---------------
    add       %rsp,	80
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.expandfnmacro
cc_lex.expandfnmacro:
#PROC1
#PROC2
#?>>
    .set cc_lex.expandfnmacro.frombaselevel, 88
    .set cc_lex.expandfnmacro.endlineno, 96
    .set cc_lex.expandfnmacro.args, -1600
    .set cc_lex.expandfnmacro.expargs, -3200
    .set cc_lex.expandfnmacro.newmacro, -3232
    .set cc_lex.expandfnmacro.expanded, -3240
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	3280
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
    mov       [%rbp+88],	%r9
#---------------
#PROC3
#PROC4
    mov       %rcx,	%r12
    lea       %rdx,	[%rbp + cc_lex.expandfnmacro.args]
    mov       %r8,	%r14
    call      cc_lex.readmacrocall
    mov       %rbx,	%rax
    mov       %rax,	[%rbp + cc_lex.expandfnmacro.frombaselevel]
    test      %rax,	%rax
    jz        L4033
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %eax,	[%rax+16]
    mov       %r10,	[%rbp + cc_lex.expandfnmacro.endlineno]
    mov       [%r10],	%rax
L4033:
    mov       %rsi,	1
    cmp       %rbx,	1
    jl        L4036
L4034:
    xor       %eax,	%eax
    mov       [%rbp + %rsi*8 + cc_lex.expandfnmacro.expargs-8],	%rax
    inc       %rsi
    cmp       %rsi,	%rbx
    jle       L4034
L4036:
    sub       %rsp,	8
    mov       %rax,	%r13
    push      %rax
    mov       %rcx,	%r12
    lea       %rdx,	[%rbp + cc_lex.expandfnmacro.args]
    lea       %r8,	[%rbp + cc_lex.expandfnmacro.expargs]
    mov       %r9,	%rbx
    sub       %rsp,	32
    call      cc_lex.substituteargs
    add       %rsp,	48
    mov       %rdi,	%rax
    mov       [%rbp + cc_lex.expandfnmacro.newmacro],	%r12
    mov       [%rbp + cc_lex.expandfnmacro.newmacro+8],	%r13
    mov       %rcx,	%rdi
    lea       %rdx,	[%rbp + cc_lex.expandfnmacro.newmacro]
    lea       %r8,	[%rbp + cc_lex.expandfnmacro.expanded]
    call      cc_lex.scantokenseq
    mov       %rdi,	%rax
    mov       %rax,	%rdi
L4031:
#---------------
    add       %rsp,	3280
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.scantokenseq
cc_lex.scantokenseq:
#PROC1
#PROC2
#?>>
    .set cc_lex.scantokenseq.tk, 64
    .set cc_lex.scantokenseq.expanded, 80
    .set cc_lex.scantokenseq.newtk, -8
    .set cc_lex.scantokenseq.newtkx, -16
    .set cc_lex.scantokenseq.dummy, -24
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	64
    mov       [%rbp+64],	%rcx
    mov       %r14,	%rdx
    mov       [%rbp+80],	%r8
#---------------
#PROC3
#PROC4
#cc_lex.scantokenseq.reenter:
L4038:
    xor       %eax,	%eax
    mov       %r10,	[%rbp + cc_lex.scantokenseq.expanded]
    mov       [%r10],	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.scantokenseq.newtkx],	%rax
    mov       [%rbp + cc_lex.scantokenseq.newtk],	%rax
    xor       %r12,	%r12
    mov       %rax,	1
    mov       %r13,	%rax
    mov       %rbx,	[%rbp + cc_lex.scantokenseq.tk]
    jmp       L4040
L4039:
    mov       %rax,	[%rbp + cc_lex.scantokenseq.tk]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jnz       L4044
L4043:
    mov       %rax,	[%rbp + cc_lex.scantokenseq.tk]
    mov       %rax,	[%rax]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	1
    jz        L4047
    mov       %rax,	[%rbp + cc_lex.scantokenseq.tk]
    mov       %rax,	[%rax]
    movzx     %rax,	byte ptr[%rax+107]
    cmp       %rax,	69
    jnz       L4046
L4047:
    xor       %r13,	%r13
    jmp       L4041
L4046:
L4044:
L4042:
    mov       %rax,	[%rbp + cc_lex.scantokenseq.tk]
    test      %rax,	%rax
    jz        L4041
L4049:
    mov       %rax,	[%rbp + cc_lex.scantokenseq.tk]
    mov       %rax,	[%rax+8]
    mov       [%rbp + cc_lex.scantokenseq.tk],	%rax
L4040:
    mov       %rax,	[%rbp + cc_lex.scantokenseq.tk]
    test      %rax,	%rax
    jnz       L4039
L4041:
    test      %r13,	%r13
    jz        L4051
    mov       %rax,	%rbx
    jmp       L4037
L4051:
    mov       [%rbp + cc_lex.scantokenseq.tk],	%rbx
    jmp       L4053
L4052:
    mov       %rax,	[%rbp + cc_lex.scantokenseq.tk]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jnz       L4057
L4056:
    mov       %rax,	[%rbp + cc_lex.scantokenseq.tk]
    mov       %rsi,	[%rax]
    movzx     %rax,	byte ptr[%rsi+109]
    cmp       %rax,	1
    jnz       L4059
    test      %r12,	%r12
    jnz       L4059
    mov       %rax,	[%rbp + cc_lex.scantokenseq.tk]
    movzx     %rax,	byte ptr[%rax+23]
    and       %rax,	4
    jnz       L4062
    mov       %rax,	[%rip+cc_lex.noexpand]
    test      %rax,	%rax
    jz        L4061
L4062:
    jmp       L4063
L4061:
    mov       %rcx,	%rsi
    mov       %rdx,	%r14
    call      cc_lex.inmacrostack
    test      %rax,	%rax
    jz        L4065
    lea       %rcx,	[%rbp + cc_lex.scantokenseq.newtk]
    lea       %rdx,	[%rbp + cc_lex.scantokenseq.newtkx]
    mov       %r8,	[%rbp + cc_lex.scantokenseq.tk]
    call      cc_lex.addlisttoken_copy
    mov       %rax,	[%rbp + cc_lex.scantokenseq.newtkx]
    lea       %rax,	[%rax+23]
    mov       %r10b,	4
    or        [%rax],	%r10b
    jmp       L4066
L4065:
    xor       %r13,	%r13
    movzx     %rax,	byte ptr[%rsi+108]
    shr       %eax,	2
    and       %eax,	1
    test      %rax,	%rax
    jz        L4068
    mov       %rcx,	[%rbp + cc_lex.scantokenseq.tk]
    call      cc_lex.peektk
    test      %rax,	%rax
    jz        L4063
L4070:
    lea       %rcx,	[%rbp + cc_lex.scantokenseq.tk]
    call      cc_lex.lexa
    sub       %rsp,	8
    lea       %rax,	[%rbp + cc_lex.scantokenseq.dummy]
    push      %rax
    mov       %rcx,	%rsi
    mov       %rdx,	%r14
    lea       %r8,	[%rbp + cc_lex.scantokenseq.tk]
    mov       %r9,	1
    sub       %rsp,	32
    call      cc_lex.expandfnmacro
    add       %rsp,	48
    mov       %rdi,	%rax
    lea       %rcx,	[%rbp + cc_lex.scantokenseq.newtk]
    lea       %rdx,	[%rbp + cc_lex.scantokenseq.newtkx]
    mov       %r8,	%rdi
    call      cc_lex.addlisttoken_seq
    mov       %rax,	1
    mov       %r10,	[%rbp + cc_lex.scantokenseq.expanded]
    mov       [%r10],	%rax
    jmp       L4053
L4068:
    mov       %rcx,	%rsi
    mov       %rdx,	%r14
    lea       %r8,	[%rbp + cc_lex.scantokenseq.tk]
    xor       %r9d,	%r9d
    call      cc_lex.expandobjmacro
    mov       %rdi,	%rax
    mov       %rax,	1
    mov       %r10,	[%rbp + cc_lex.scantokenseq.expanded]
    mov       [%r10],	%rax
    lea       %rcx,	[%rbp + cc_lex.scantokenseq.newtk]
    lea       %rdx,	[%rbp + cc_lex.scantokenseq.newtkx]
    mov       %r8,	%rdi
    call      cc_lex.addlisttoken_seq
L4067:
    jmp       L4058
L4059:
    movzx     %rax,	byte ptr[%rsi+107]
    cmp       %rax,	92
    jnz       L4071
    mov       %r12,	1
    jmp       L4063
L4071:
    movzx     %rax,	byte ptr[%rsi+107]
    cmp       %rax,	69
    jnz       L4072
    call      cc_lex.alloctokenz
    mov       %rdi,	%rax
    movsx     %rax,	word ptr[%rsi+100]
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    mov       %r8,	[%rip+cc_decls.slineno]
    call      cc_lex.expandpredefmacro
    lea       %rcx,	[%rbp + cc_lex.scantokenseq.newtk]
    lea       %rdx,	[%rbp + cc_lex.scantokenseq.newtkx]
    mov       %r8,	%rdi
    call      cc_lex.addlisttoken_copy
    jmp       L4073
L4072:
    xor       %r12,	%r12
    jmp       L4063
L4058:
    jmp       L4055
L4057:
#cc_lex.scantokenseq.simpletoken:
L4063:
    lea       %rcx,	[%rbp + cc_lex.scantokenseq.newtk]
    lea       %rdx,	[%rbp + cc_lex.scantokenseq.newtkx]
    mov       %r8,	[%rbp + cc_lex.scantokenseq.tk]
    call      cc_lex.addlisttoken_copy
L4055:
#cc_lex.scantokenseq.skip:
L4066:
    mov       %rax,	[%rbp + cc_lex.scantokenseq.tk]
    test      %rax,	%rax
    jz        L4054
L4075:
#cc_lex.scantokenseq.skip2:
L4073:
    mov       %rax,	[%rbp + cc_lex.scantokenseq.tk]
    mov       %rax,	[%rax+8]
    mov       [%rbp + cc_lex.scantokenseq.tk],	%rax
L4053:
    mov       %rax,	[%rbp + cc_lex.scantokenseq.tk]
    test      %rax,	%rax
    jnz       L4052
L4054:
    mov       %rax,	[%rbp + cc_lex.scantokenseq.expanded]
    mov       %rax,	[%rax]
    test      %rax,	%rax
    jz        L4077
    mov       %rax,	[%rbp + cc_lex.scantokenseq.newtk]
    mov       [%rbp + cc_lex.scantokenseq.tk],	%rax
    jmp       L4038
L4077:
    mov       %rax,	[%rbp + cc_lex.scantokenseq.newtk]
L4037:
#---------------
    add       %rsp,	64
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.readmacrocall
cc_lex.readmacrocall:
#PROC1
#PROC2
#?>>
    .set cc_lex.readmacrocall.args, 80
    .set cc_lex.readmacrocall.tksource, 88
    .set cc_lex.readmacrocall.tklist, -8
    .set cc_lex.readmacrocall.tklistx, -16
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	56
    mov       %r15,	%rcx
    mov       [%rbp+80],	%rdx
    mov       [%rbp+88],	%r8
#---------------
#PROC3
#PROC4
    mov       %rcx,	[%rbp + cc_lex.readmacrocall.tksource]
    call      cc_lex.lexa
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	13
    jz        L4080
    lea       %rcx,	[%rip+L8882]
    call      cc_lex.lxerror
L4080:
    movzx     %rax,	byte ptr[%r15+111]
    mov       %rdi,	%rax
    xor       %r12,	%r12
    mov       %rax,	%rdi
    test      %rax,	%rax
    jnz       L4082
    mov       %rcx,	[%rbp + cc_lex.readmacrocall.tksource]
    call      cc_lex.lexa
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	14
    jz        L4084
    lea       %rcx,	[%rip+L8883]
    call      cc_lex.lxerror
L4084:
    xor       %eax,	%eax
    jmp       L4078
L4082:
    mov       %rsi,	1
    mov       %rbx,	1
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.readmacrocall.tklistx],	%rax
    mov       [%rbp + cc_lex.readmacrocall.tklist],	%rax
    movzx     %rax,	byte ptr[%r15+108]
    shr       %eax,	1
    and       %eax,	1
    mov       %r13,	%rax
    xor       %r14,	%r14
L4085:
    cmp       %rsi,	%rdi
    jnz       L4088
    test      %r13,	%r13
    jz        L4088
    mov       %r14,	1
L4088:
    mov       %rcx,	[%rbp + cc_lex.readmacrocall.tksource]
    call      cc_lex.lexa
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jz        L4090
    cmp       %rax,	57
    jz        L4091
    cmp       %rax,	13
    jz        L4092
    cmp       %rax,	14
    jz        L4093
    jmp       L4094
L4090:
    cmp       %rbx,	1
    jnz       L4096
    test      %r14,	%r14
    jnz       L4096
    mov       %rax,	[%rbp + cc_lex.readmacrocall.tklist]
    test      %rax,	%rax
    jnz       L4098
    call      cc_lex.alloctokenz
    mov       [%rbp + cc_lex.readmacrocall.tklist],	%rax
    call      cc_lex.getfileno
    mov       %rcx,	[%rbp + cc_lex.readmacrocall.tklist]
    mov       %rdx,	%rax
    call      cc_lex.setfilenox
    mov       %al,	66
    mov       %r10,	[%rbp + cc_lex.readmacrocall.tklist]
    mov       [%r10+21],	%al
L4098:
    mov       %rax,	[%rbp + cc_lex.readmacrocall.tklist]
    mov       %r10,	[%rbp + cc_lex.readmacrocall.args]
    mov       %r11,	%rsi
    mov       [%r10 + %r11*8-8],	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.readmacrocall.tklistx],	%rax
    mov       [%rbp + cc_lex.readmacrocall.tklist],	%rax
    inc       %rsi
    jmp       L4095
L4096:
    jmp       L4099
L4095:
    jmp       L4089
L4091:
    lea       %rcx,	[%rip+L8884]
    call      cc_lex.lxerror
    jmp       L4089
L4092:
    inc       %rbx
    jmp       L4099
L4093:
    cmp       %rbx,	1
    jle       L4101
    dec       %rbx
    lea       %rcx,	[%rbp + cc_lex.readmacrocall.tklist]
    lea       %rdx,	[%rbp + cc_lex.readmacrocall.tklistx]
    call      cc_lex.addlist_nextlx
    jmp       L4100
L4101:
    mov       %rax,	[%rbp + cc_lex.readmacrocall.tklist]
    test      %rax,	%rax
    jnz       L4103
    call      cc_lex.alloctokenz
    mov       [%rbp + cc_lex.readmacrocall.tklist],	%rax
    call      cc_lex.getfileno
    mov       %rcx,	[%rbp + cc_lex.readmacrocall.tklist]
    mov       %rdx,	%rax
    call      cc_lex.setfilenox
    mov       %al,	66
    mov       %r10,	[%rbp + cc_lex.readmacrocall.tklist]
    mov       [%r10+21],	%al
L4103:
    mov       %rax,	[%rbp + cc_lex.readmacrocall.tklist]
    mov       %r10,	[%rbp + cc_lex.readmacrocall.args]
    mov       %r11,	%rsi
    mov       [%r10 + %r11*8-8],	%rax
    jmp       L4086
L4100:
    jmp       L4089
L4094:
#cc_lex.readmacrocall.addtoken:
L4099:
    lea       %rcx,	[%rbp + cc_lex.readmacrocall.tklist]
    lea       %rdx,	[%rbp + cc_lex.readmacrocall.tklistx]
    call      cc_lex.addlist_nextlx
L4089:
    jmp       L4085
L4086:
    cmp       %rsi,	%rdi
    jz        L4105
    lea       %rax,	[%rsi+1]
    cmp       %rax,	%rdi
    jnz       L4107
    test      %r13,	%r13
    jz        L4107
    xor       %eax,	%eax
    mov       %r10,	[%rbp + cc_lex.readmacrocall.args]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*8-8],	%rax
    jmp       L4106
L4107:
    lea       %rcx,	[%rip+L8885]
    call      cc_lex.lxerror
L4106:
L4105:
    mov       %rax,	%rdi
L4078:
#---------------
    add       %rsp,	56
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.substituteargs
cc_lex.substituteargs:
#PROC1
#PROC2
#?>>
    .set cc_lex.substituteargs.expargs, 80
    .set cc_lex.substituteargs.nargs, 88
    .set cc_lex.substituteargs.macrostack, 96
    .set cc_lex.substituteargs.newtk, -8
    .set cc_lex.substituteargs.newtkx, -16
    .set cc_lex.substituteargs.niltk, -24
    .set cc_lex.substituteargs.tkexp, -32
    .set cc_lex.substituteargs.tk, -64
    .set cc_lex.substituteargs.n, -72
    .set cc_lex.substituteargs.i, -80
    .set cc_lex.substituteargs.expanded, -88
    .set cc_lex.substituteargs.hhpoints, -2088
    .set cc_lex.substituteargs.nhashhash, -2096
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	2128
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       [%rbp+80],	%r8
    mov       [%rbp+88],	%r9
#---------------
#PROC3
#PROC4
    mov       %rdi,	[%r13+80]
    mov       %rax,	[%r13+72]
    mov       %rsi,	%rax
    mov       %rbx,	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.substituteargs.newtkx],	%rax
    mov       [%rbp + cc_lex.substituteargs.newtk],	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.substituteargs.nhashhash],	%rax
    xor       %r12,	%r12
    jmp       L4110
L4109:
    movzx     %rax,	byte ptr[%rbx+21]
    cmp       %rax,	5
    jz        L4113
    cmp       %rax,	7
    jz        L4114
    jmp       L4115
L4113:
    mov       %rax,	[%rbp + cc_lex.substituteargs.nargs]
    test      %rax,	%rax
    jz        L4117
    mov       %rbx,	[%rbx+8]
    test      %rbx,	%rbx
    jnz       L4119
    lea       %rcx,	[%rip+L8886]
    call      cc_lex.lxerror
L4119:
    movzx     %rax,	byte ptr[%rbx+23]
    and       %rax,	2
    jnz       L4121
    lea       %rcx,	[%rip+L8887]
    call      cc_lex.lxerror
L4121:
    movsx     %rax,	word ptr[%rbx+28]
    mov       [%rbp + cc_lex.substituteargs.n],	%rax
    mov       %rax,	[%rbp + cc_lex.substituteargs.n]
    mov       %rax,	[%r14 + %rax*8-8]
    mov       %rcx,	%rax
    lea       %rdx,	[%rbp + cc_lex.substituteargs.tk]
    call      cc_lex.stringify
    lea       %rcx,	[%rbp + cc_lex.substituteargs.newtk]
    lea       %rdx,	[%rbp + cc_lex.substituteargs.newtkx]
    lea       %r8,	[%rbp + cc_lex.substituteargs.tk]
    call      cc_lex.addlisttoken_copy
    jmp       L4116
L4117:
    lea       %rcx,	[%rbp + cc_lex.substituteargs.newtk]
    lea       %rdx,	[%rbp + cc_lex.substituteargs.newtkx]
    mov       %r8,	%rbx
    call      cc_lex.addlisttoken
    mov       %al,	6
    mov       %r10,	[%rbp + cc_lex.substituteargs.newtkx]
    mov       [%r10+21],	%al
L4116:
    jmp       L4112
L4114:
    cmp       %rbx,	%rsi
    jnz       L4123
    lea       %rcx,	[%rip+L8888]
    call      cc_lex.lxerror
L4123:
    mov       %rax,	[%rbp + cc_lex.substituteargs.nhashhash]
    cmp       %rax,	250
    jl        L4125
    lea       %rcx,	[%rip+L8889]
    call      cc_lex.lxerror
L4125:
    inc       qword ptr[%rbp + cc_lex.substituteargs.nhashhash]
    mov       %rax,	[%rbp + cc_lex.substituteargs.nhashhash]
    mov       %r10,	[%rbp + cc_lex.substituteargs.newtkx]
    mov       [%rbp + %rax*8 + cc_lex.substituteargs.hhpoints-8],	%r10
    jmp       L4112
L4115:
    movzx     %rax,	byte ptr[%rbx+21]
    cmp       %rax,	67
    jnz       L4127
    movzx     %rax,	byte ptr[%rbx+23]
    and       %rax,	2
    jz        L4127
    mov       %rax,	[%rbp + cc_lex.substituteargs.nargs]
    test      %rax,	%rax
    jz        L4127
    movsx     %rax,	word ptr[%rbx+28]
    mov       [%rbp + cc_lex.substituteargs.n],	%rax
    mov       %rax,	[%rbx+8]
    test      %rax,	%rax
    jz        L4131
    mov       %rax,	[%rbx+8]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	7
    jz        L4130
L4131:
    test      %r12,	%r12
    jz        L4129
    movzx     %rax,	byte ptr[%r12+21]
    cmp       %rax,	7
    jnz       L4129
L4130:
    mov       %rax,	[%rbp + cc_lex.substituteargs.n]
    mov       %rax,	[%r14 + %rax*8-8]
    lea       %rcx,	[%rbp + cc_lex.substituteargs.newtk]
    lea       %rdx,	[%rbp + cc_lex.substituteargs.newtkx]
    mov       %r8,	%rax
    call      cc_lex.addlisttoken_seq
    jmp       L4128
L4129:
    mov       %rax,	[%rbp + cc_lex.substituteargs.expargs]
    mov       %r10,	[%rbp + cc_lex.substituteargs.n]
    mov       %rax,	[%rax + %r10*8-8]
    mov       [%rbp + cc_lex.substituteargs.tkexp],	%rax
    mov       %rax,	[%rbp + cc_lex.substituteargs.tkexp]
    test      %rax,	%rax
    jnz       L4133
    mov       %rax,	[%rbp + cc_lex.substituteargs.n]
    mov       %rax,	[%r14 + %rax*8-8]
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + cc_lex.substituteargs.macrostack]
    lea       %r8,	[%rbp + cc_lex.substituteargs.expanded]
    call      cc_lex.scantokenseq
    mov       %r10,	[%rbp + cc_lex.substituteargs.expargs]
    mov       %r11,	[%rbp + cc_lex.substituteargs.n]
    mov       [%r10 + %r11*8-8],	%rax
    mov       [%rbp + cc_lex.substituteargs.tkexp],	%rax
L4133:
    lea       %rcx,	[%rbp + cc_lex.substituteargs.newtk]
    lea       %rdx,	[%rbp + cc_lex.substituteargs.newtkx]
    mov       %r8,	[%rbp + cc_lex.substituteargs.tkexp]
    call      cc_lex.addlisttoken_seq
L4128:
    jmp       L4126
L4127:
#cc_lex.substituteargs.doother:
    lea       %rcx,	[%rbp + cc_lex.substituteargs.newtk]
    lea       %rdx,	[%rbp + cc_lex.substituteargs.newtkx]
    mov       %r8,	%rbx
    call      cc_lex.addlisttoken_copy
L4126:
L4112:
    mov       %r12,	%rbx
    mov       %rbx,	[%rbx+8]
L4110:
    test      %rbx,	%rbx
    jnz       L4109
    mov       %rax,	[%rbp + cc_lex.substituteargs.nhashhash]
    test      %rax,	%rax
    jz        L4136
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.substituteargs.niltk],	%rax
    mov       %rax,	1
    mov       [%rbp + cc_lex.substituteargs.i],	%rax
    mov       %rax,	[%rbp + cc_lex.substituteargs.nhashhash]
    cmp       %rax,	1
    jl        L4139
L4137:
    mov       %rax,	[%rbp + cc_lex.substituteargs.i]
    cmp       %rax,	[%rbp + cc_lex.substituteargs.nhashhash]
    jge       L4141
    mov       %rax,	[%rbp + cc_lex.substituteargs.i]
    lea       %r10,	[%rbp + %rax*8 + cc_lex.substituteargs.hhpoints]
    mov       %rax,	%r10
    jmp       L4140
L4141:
    lea       %rax,	[%rbp + cc_lex.substituteargs.niltk]
L4140:
    mov       %r10,	[%rbp + cc_lex.substituteargs.i]
    mov       %r10,	[%rbp + %r10*8 + cc_lex.substituteargs.hhpoints-8]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      cc_lex.pastetokens
    mov       %rax,	[%rbp + cc_lex.substituteargs.i]
    inc       %rax
    mov       [%rbp + cc_lex.substituteargs.i],	%rax
    cmp       %rax,	[%rbp + cc_lex.substituteargs.nhashhash]
    jle       L4137
L4139:
L4136:
    mov       %rax,	[%rbp + cc_lex.substituteargs.newtk]
L4108:
#---------------
    add       %rsp,	2128
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.strtoken
cc_lex.strtoken:
#PROC1
#PROC2
#?>>
    .set cc_lex.strtoken.l, -32
    .set cc_lex.strtoken.$T1, -40
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	80
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
#PROC3
#PROC4
    mov       %rax,	%rsi
    lea       %r10,	[%rbp + cc_lex.strtoken.l]
    mov       %r11,	[%rax]
    mov       [%r10],	%r11
    mov       %r11,	[%rax+8]
    mov       [%r10+8],	%r11
    mov       %r11,	[%rax+16]
    mov       [%r10+16],	%r11
    mov       %r11,	[%rax+24]
    mov       [%r10+24],	%r11
    movzx     %rax,	byte ptr[%rbp + cc_lex.strtoken.l+21]
    cmp       %rax,	67
    jz        L4144
    cmp       %rax,	59
    jz        L4145
    cmp       %rax,	60
    jz        L4145
    cmp       %rax,	58
    jz        L4146
    cmp       %rax,	63
    jz        L4147
    cmp       %rax,	64
    jz        L4147
    cmp       %rax,	61
    jz        L4148
    cmp       %rax,	56
    jz        L4149
    cmp       %rax,	57
    jz        L4150
    cmp       %rax,	70
    jz        L4151
    cmp       %rax,	86
    jz        L4151
    cmp       %rax,	85
    jz        L4151
    cmp       %rax,	88
    jz        L4151
    jmp       L4152
L4144:
#cc_lex.strtoken.doname:
L4153:
    mov       %rax,	[%rbp + cc_lex.strtoken.l]
    movzx     %rax,	byte ptr[%rax+106]
    mov       [%r12],	%rax
    mov       %rax,	[%rbp + cc_lex.strtoken.l]
    mov       %rax,	[%rax]
    jmp       L4142
L4145:
    movsxd    %rax,	dword ptr[%rbp + cc_lex.strtoken.l+24]
    mov       [%r12],	%rax
    lea       %rcx,	[%rbp + cc_lex.strtoken.l]
    call      cc_lex.getfilenox
    test      %rax,	%rax
    jz        L4155
    lea       %rcx,	[%rbp + cc_lex.strtoken.l]
    call      cc_lex.getfilenox
    lea       %r10,	[%rip+cc_decls.sourcefiletext]
    mov       %r10,	[%r10 + %rax*8]
    mov       [%rbp + cc_lex.strtoken.$T1],	%r10
    lea       %rcx,	[%rbp + cc_lex.strtoken.l]
    call      cc_lex.getnumberoffsetx
    mov       %r10,	[%rbp + cc_lex.strtoken.$T1]
    lea       %r10,	[%r10 + %rax]
    mov       %rax,	%r10
    jmp       L4142
L4155:
    movsx     %rax,	word ptr[%rbp + cc_lex.strtoken.l+28]
    lea       %r10,	[%rip+cc_lex.pastedtokenlist]
    mov       %r10,	[%r10 + %rax*8-8]
    mov       %rax,	%r10
    jmp       L4142
L4154:
    jmp       L4143
L4146:
    movsxd    %rax,	dword ptr[%rbp + cc_lex.strtoken.l+24]
    mov       [%r12],	%rax
    mov       %rax,	[%rbp + cc_lex.strtoken.l]
    jmp       L4142
L4147:
    movsxd    %rax,	dword ptr[%rbp + cc_lex.strtoken.l+24]
    mov       %r10,	[%rbp + cc_lex.strtoken.l]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    mov       %r8,	%r12
    mov       %r9,	34
    call      cc_lex.strstring
    mov       %rbx,	%rax
    mov       %rax,	%rbx
    jmp       L4142
L4148:
    movsxd    %rax,	dword ptr[%rbp + cc_lex.strtoken.l+24]
    mov       %r10,	[%rbp + cc_lex.strtoken.l]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    mov       %r8,	%r12
    mov       %r9,	39
    call      cc_lex.strstring
    mov       %rbx,	%rax
    mov       %rax,	%rbx
    jmp       L4142
L4149:
    mov       %rax,	[%rip+cc_lex.dowhitespace]
    test      %rax,	%rax
    jz        L4157
    movsxd    %rax,	dword ptr[%rbp + cc_lex.strtoken.l+24]
    inc       %rax
    mov       [%r12],	%rax
    mov       %rax,	[%r12]
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       %rbx,	%rax
    mov       %al,	10
    mov       [%rbx],	%al
    movsxd    %rax,	dword ptr[%rbp + cc_lex.strtoken.l+24]
    mov       %r10,	[%rbp + cc_lex.strtoken.l]
    lea       %r11,	[%rbx+1]
    mov       %rcx,	%r11
    mov       %rdx,	%r10
    mov       %r8,	%rax
    call      memcpy
    jmp       L4156
L4157:
    mov       %rax,	1
    mov       [%r12],	%rax
    lea       %rax,	[%rip+L8890]
    jmp       L4142
L4156:
    mov       %rax,	%rbx
    jmp       L4142
L4150:
    xor       %eax,	%eax
    mov       [%r12],	%rax
    lea       %rax,	[%rip+L8891]
    jmp       L4142
L4151:
    jmp       L4153
L4152:
    movzx     %rax,	byte ptr[%rbp + cc_lex.strtoken.l+21]
    lea       %r10,	[%rip+cc_tables.shortsymbolnames]
    mov       %r10,	[%r10 + %rax*8-8]
    mov       %rdi,	%r10
    mov       %rcx,	%rdi
    call      strlen
    mov       [%r12],	%rax
    test      %rax,	%rax
    jz        L4159
    movzx     %rax,	byte ptr[%rdi]
    cmp       %rax,	107
    jz        L4161
    mov       %rax,	%rdi
    jmp       L4142
L4161:
    movzx     %rax,	byte ptr[%rbp + cc_lex.strtoken.l+21]
    lea       %r10,	[%rip+cc_tables.symbolnames]
    mov       %r10,	[%r10 + %rax*8-8]
    lea       %r10,	[%r10+1]
    mov       %rcx,	%r10
    call      strlen
    mov       [%r12],	%rax
    movzx     %rax,	byte ptr[%rbp + cc_lex.strtoken.l+21]
    lea       %r10,	[%rip+cc_tables.symbolnames]
    mov       %r10,	[%r10 + %rax*8-8]
    lea       %r10,	[%r10+1]
    mov       %rax,	%r10
    jmp       L4142
L4160:
    jmp       L4158
L4159:
    lea       %rax,	[%rip+L8891]
    jmp       L4142
L4158:
L4143:
    lea       %rax,	[%rip+L8891]
L4142:
#---------------
    add       %rsp,	80
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.strstring
cc_lex.strstring:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
    mov       %r14,	%r9
#---------------
#PROC3
#PROC4
    mov       %rax,	%r12
    shl       %rax,	1
    add       %rax,	4
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       %rbx,	%rax
    mov       %rdi,	%rax
    test      %r14,	%r14
    jz        L4164
    mov       [%rbx],	%r14b
    inc       %rbx
L4164:
    mov       %rcx,	%rsi
    mov       %rdx,	%rbx
    mov       %r8,	%r12
    call      cc_lib.convertstringc
    mov       %rcx,	%rdi
    call      strlen
    mov       [%r13],	%rax
    test      %r14,	%r14
    jz        L4166
    mov       %rax,	[%r13]
    mov       %r10b,	%r14b
    mov       [%rdi + %rax],	%r10b
    mov       %rax,	%r13
    inc       qword ptr[%rax]
L4166:
    mov       %rax,	%rdi
L4162:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.emittoken
cc_lex.emittoken:
#PROC1
#PROC2
#?>>
    .set cc_lex.emittoken.length, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rbx+21]
    cmp       %rax,	56
    jnz       L4169
    mov       %rax,	[%rip+cc_lex.lasttoken]
    cmp       %rax,	56
    jz        L4167
L4169:
    mov       %rcx,	%rbx
    lea       %rdx,	[%rbp + cc_lex.emittoken.length]
    call      cc_lex.strtoken
    mov       %rdi,	%rax
    test      %r12,	%r12
    jnz       L4172
    movzx     %rax,	byte ptr[%rbx+21]
    mov       %rcx,	[%rip+cc_lex.lasttoken]
    mov       %rdx,	%rax
    call      cc_lex.needspace
    test      %rax,	%rax
    jz        L4171
L4172:
    mov       %rcx,	%rsi
    mov       %rdx,	32
    call      mlib.gs_char
L4171:
    mov       %rcx,	%rsi
    mov       %rdx,	%rdi
    mov       %r8,	[%rbp + cc_lex.emittoken.length]
    call      mlib.gs_strn
    movzx     %rax,	byte ptr[%rbx+21]
    mov       [%rip+cc_lex.lasttoken],	%rax
L4167:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.showtoken
cc_lex.showtoken:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	[%rip+cc_lex.showtoken.dest]
    call      mlib.gs_init
    mov       %rcx,	%rdi
    mov       %rdx,	[%rip+cc_lex.showtoken.dest]
    xor       %r8d,	%r8d
    call      cc_lex.emittoken
    call      msys.m$print_startcon
    mov       %rax,	[%rip+cc_lex.showtoken.dest]
    movsxd    %rax,	dword ptr[%rax+8]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8892]
    call      msys.m$print_i64
    call      msys.m$print_nogap
    mov       %rax,	[%rip+cc_lex.showtoken.dest]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8893]
    call      msys.m$print_str
    call      msys.m$print_end
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lex.stringify
cc_lex.stringify:
#PROC1
#PROC2
#?>>
    .set cc_lex.stringify.length, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
#PROC3
#PROC4
    mov       %al,	63
    mov       [%r12+21],	%al
    xor       %eax,	%eax
    mov       [%r12+8],	%rax
    mov       %rax,	[%rsi+8]
    test      %rax,	%rax
    jnz       L4176
    mov       %rcx,	%rsi
    lea       %rdx,	[%rbp + cc_lex.stringify.length]
    call      cc_lex.strtoken
    mov       %rdi,	%rax
    mov       %eax,	[%rbp + cc_lex.stringify.length]
    mov       [%r12+24],	%eax
    mov       [%r12],	%rdi
    jmp       L4174
L4176:
    mov       %rcx,	[%rip+cc_lex.stringify.deststr]
    call      mlib.gs_init
    xor       %eax,	%eax
    mov       [%rip+cc_lex.lasttoken],	%rax
    xor       %rbx,	%rbx
    jmp       L4178
L4177:
    mov       %rcx,	%rsi
    mov       %rdx,	[%rip+cc_lex.stringify.deststr]
    mov       %r8,	%rbx
    call      cc_lex.emittoken
    mov       %rbx,	1
    mov       %rsi,	[%rsi+8]
L4178:
    test      %rsi,	%rsi
    jnz       L4177
    mov       %eax,	[%rbp + cc_lex.stringify.length]
    mov       [%r12+24],	%eax
    mov       %rax,	[%rip+cc_lex.stringify.deststr]
    mov       %rax,	[%rax]
    mov       [%r12],	%rax
    mov       %rax,	[%rip+cc_lex.stringify.deststr]
    mov       %eax,	[%rax+8]
    mov       [%r12+24],	%eax
L4174:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.pastetokens
cc_lex.pastetokens:
#PROC1
#PROC2
#?>>
    .set cc_lex.pastetokens.tk, 64
    .set cc_lex.pastetokens.tknext, 72
    .set cc_lex.pastetokens.length1, -8
    .set cc_lex.pastetokens.length2, -16
    .set cc_lex.pastetokens.oldtoken, -48
    .set cc_lex.pastetokens.token, -80
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	112
    mov       [%rbp+64],	%rcx
    mov       [%rbp+72],	%rdx
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rbp + cc_lex.pastetokens.tk]
    mov       %rdi,	[%rax+8]
    mov       %rax,	[%rbp + cc_lex.pastetokens.tknext]
    mov       %rax,	[%rax]
    mov       %r10,	%rdi
    cmp       %r10,	%rax
    jnz       L4182
    mov       %rax,	[%rbp + cc_lex.pastetokens.tk]
    mov       %r10,	[%rbp + cc_lex.pastetokens.tknext]
    mov       [%r10],	%rax
L4182:
    mov       %rax,	[%rdi+8]
    mov       %r10,	[%rbp + cc_lex.pastetokens.tk]
    mov       [%r10+8],	%rax
    mov       %rax,	[%rbp + cc_lex.pastetokens.tk]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	66
    jnz       L4184
    movzx     %rax,	byte ptr[%rdi+21]
    cmp       %rax,	66
    jz        L4185
L4186:
    mov       %rax,	%rdi
    mov       %r10,	[%rbp + cc_lex.pastetokens.tk]
    mov       %r11,	[%rax]
    mov       [%r10],	%r11
    mov       %r11,	[%rax+8]
    mov       [%r10+8],	%r11
    mov       %r11,	[%rax+16]
    mov       [%r10+16],	%r11
    mov       %r11,	[%rax+24]
    mov       [%r10+24],	%r11
L4185:
    jmp       L4183
L4184:
    movzx     %rax,	byte ptr[%rdi+21]
    cmp       %rax,	66
    jz        L4183
L4187:
    mov       %rcx,	[%rbp + cc_lex.pastetokens.tk]
    lea       %rdx,	[%rbp + cc_lex.pastetokens.length1]
    call      cc_lex.strtoken
    mov       %rbx,	%rax
    mov       %rcx,	%rdi
    lea       %rdx,	[%rbp + cc_lex.pastetokens.length2]
    call      cc_lex.strtoken
    mov       %rsi,	%rax
    mov       %rax,	[%rbp + cc_lex.pastetokens.length1]
    add       %rax,	[%rbp + cc_lex.pastetokens.length2]
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       %r12,	%rax
    mov       %rcx,	%r12
    mov       %rdx,	%rbx
    mov       %r8,	[%rbp + cc_lex.pastetokens.length1]
    call      memcpy
    mov       %rax,	[%rbp + cc_lex.pastetokens.length1]
    lea       %r10,	[%r12 + %rax]
    mov       %rcx,	%r10
    mov       %rdx,	%rsi
    mov       %r8,	[%rbp + cc_lex.pastetokens.length2]
    call      memcpy
    mov       %rax,	[%rbp + cc_lex.pastetokens.length1]
    lea       %r10,	[%r12 + %rax]
    xor       %eax,	%eax
    mov       %r11,	[%rbp + cc_lex.pastetokens.length2]
    mov       [%r10 + %r11],	%al
    mov       %rax,	[%rip+cc_lex.npastedtokens]
    cmp       %rax,	87000
    jl        L4189
    lea       %rcx,	[%rip+L8894]
    call      cc_lex.lxerror
L4189:
    inc       qword ptr[%rip+cc_lex.npastedtokens]
    mov       %rax,	[%rip+cc_lex.npastedtokens]
    mov       %r10,	%r12
    lea       %r11,	[%rip+cc_lex.pastedtokenlist]
    mov       [%r11 + %rax*8-8],	%r10
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %r10,	[%rbp + cc_lex.pastetokens.oldtoken]
    mov       %r11,	[%rax]
    mov       [%r10],	%r11
    mov       %r11,	[%rax+8]
    mov       [%r10+8],	%r11
    mov       %r11,	[%rax+16]
    mov       [%r10+16],	%r11
    mov       %r11,	[%rax+24]
    mov       [%r10+24],	%r11
    mov       %r13,	[%rip+cc_lex.lxsptr]
    mov       %r14,	[%rip+cc_lex.lx_stackindex]
    mov       [%rip+cc_lex.lxsptr],	%r12
    xor       %eax,	%eax
    mov       [%rip+cc_lex.lx_stackindex],	%rax
    xor       %ecx,	%ecx
    call      cc_lex.setfileno
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+16],	%eax
    call      cc_lex.lexreadtoken
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %r10,	[%rbp + cc_lex.pastetokens.token]
    mov       %r11,	[%rax]
    mov       [%r10],	%r11
    mov       %r11,	[%rax+8]
    mov       [%r10+8],	%r11
    mov       %r11,	[%rax+16]
    mov       [%r10+16],	%r11
    mov       %r11,	[%rax+24]
    mov       [%r10+24],	%r11
    call      cc_lex.lexreadtoken
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	57
    jz        L4191
L4191:
    lea       %rax,	[%rbp + cc_lex.pastetokens.oldtoken]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       %r11,	[%rax]
    mov       [%r10],	%r11
    mov       %r11,	[%rax+8]
    mov       [%r10+8],	%r11
    mov       %r11,	[%rax+16]
    mov       [%r10+16],	%r11
    mov       %r11,	[%rax+24]
    mov       [%r10+24],	%r11
    mov       [%rip+cc_lex.lxsptr],	%r13
    mov       [%rip+cc_lex.lx_stackindex],	%r14
    mov       %rax,	[%rbp + cc_lex.pastetokens.tk]
    mov       %rax,	[%rax+8]
    mov       [%rbp + cc_lex.pastetokens.token+8],	%rax
    lea       %rcx,	[%rbp + cc_lex.pastetokens.token]
    xor       %edx,	%edx
    call      cc_lex.setfilenox
    mov       %ax,	[%rip+cc_lex.npastedtokens]
    mov       [%rbp + cc_lex.pastetokens.token+28],	%ax
    lea       %rax,	[%rbp + cc_lex.pastetokens.token+23]
    mov       %r10b,	8
    or        [%rax],	%r10b
    lea       %rax,	[%rbp + cc_lex.pastetokens.token]
    mov       %r10,	[%rbp + cc_lex.pastetokens.tk]
    mov       %r11,	[%rax]
    mov       [%r10],	%r11
    mov       %r11,	[%rax+8]
    mov       [%r10+8],	%r11
    mov       %r11,	[%rax+16]
    mov       [%r10+16],	%r11
    mov       %r11,	[%rax+24]
    mov       [%r10+24],	%r11
L4183:
#---------------
    add       %rsp,	112
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.getifexpr
cc_lex.getifexpr:
#PROC1
#PROC2
#?>>
    .set cc_lex.getifexpr.sx, -8
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    call      cc_lex.lexm
    lea       %rcx,	[%rbp + cc_lex.getifexpr.sx]
    call      cc_lex.evalcondexpr
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	56
    jz        L4194
    lea       %rcx,	[%rip+L8895]
    call      cc_lex.lxerror
L4194:
    mov       %rax,	%rdi
    cmp       %rax,	0
    setnz     %al
    movzx     %eax,	%al
L4192:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc cc_lex.evalcondexpr
cc_lex.evalcondexpr:
#PROC1
#PROC2
#?>>
    .set cc_lex.evalcondexpr.sy, -8
    .set cc_lex.evalcondexpr.sz, -16
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %r12,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%r12
    call      cc_lex.evalorexpr
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	19
    jnz       L4197
    call      cc_lex.lexm
    lea       %rcx,	[%rbp + cc_lex.evalcondexpr.sy]
    call      cc_lex.evalcondexpr
    mov       %rbx,	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	10
    jz        L4199
    lea       %rcx,	[%rip+L8896]
    call      cc_lex.lxerror
L4199:
    call      cc_lex.lexm
    lea       %rcx,	[%rbp + cc_lex.evalcondexpr.sz]
    call      cc_lex.evalcondexpr
    mov       %rsi,	%rax
    test      %rdi,	%rdi
    jz        L4201
    mov       %rax,	[%rbp + cc_lex.evalcondexpr.sy]
    mov       [%r12],	%rax
    mov       %rdi,	%rbx
    jmp       L4200
L4201:
    mov       %rax,	[%rbp + cc_lex.evalcondexpr.sz]
    mov       [%r12],	%rax
    mov       %rdi,	%rsi
L4200:
L4197:
    mov       %rax,	%rdi
L4195:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.evalorexpr
cc_lex.evalorexpr:
#PROC1
#PROC2
#?>>
    .set cc_lex.evalorexpr.sy, -8
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %rsi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rsi
    call      cc_lex.evalandexpr
    mov       %rdi,	%rax
    jmp       L4204
L4203:
    call      cc_lex.lexm
    lea       %rcx,	[%rbp + cc_lex.evalorexpr.sy]
    call      cc_lex.evalandexpr
    mov       %rbx,	%rax
    test      %rdi,	%rdi
    jnz       L4208
    test      %rbx,	%rbx
    jz        L4207
L4208:
    mov       %rax,	1
    jmp       L4206
L4207:
    xor       %eax,	%eax
L4206:
    mov       %rdi,	%rax
L4204:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	31
    jz        L4203
    mov       %rax,	%rdi
L4202:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.evalandexpr
cc_lex.evalandexpr:
#PROC1
#PROC2
#?>>
    .set cc_lex.evalandexpr.sy, -8
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %rsi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rsi
    call      cc_lex.evaliorexpr
    mov       %rdi,	%rax
    jmp       L4211
L4210:
    call      cc_lex.lexm
    lea       %rcx,	[%rbp + cc_lex.evalandexpr.sy]
    call      cc_lex.evaliorexpr
    mov       %rbx,	%rax
    test      %rdi,	%rdi
    jz        L4214
    test      %rbx,	%rbx
    jz        L4214
    mov       %rax,	1
    jmp       L4213
L4214:
    xor       %eax,	%eax
L4213:
    mov       %rdi,	%rax
L4211:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	32
    jz        L4210
    mov       %rax,	%rdi
L4209:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.evaliorexpr
cc_lex.evaliorexpr:
#PROC1
#PROC2
#?>>
    .set cc_lex.evaliorexpr.sy, -8
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rbx
    call      cc_lex.evalixorexpr
    mov       %rdi,	%rax
    jmp       L4217
L4216:
    call      cc_lex.lexm
    lea       %rcx,	[%rbp + cc_lex.evaliorexpr.sy]
    call      cc_lex.evalixorexpr
    or        %rdi,	%rax
L4217:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	28
    jz        L4216
    mov       %rax,	%rdi
L4215:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.evalixorexpr
cc_lex.evalixorexpr:
#PROC1
#PROC2
#?>>
    .set cc_lex.evalixorexpr.sy, -8
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rbx
    call      cc_lex.evaliandexpr
    mov       %rdi,	%rax
    jmp       L4221
L4220:
    call      cc_lex.lexm
    lea       %rcx,	[%rbp + cc_lex.evalixorexpr.sy]
    call      cc_lex.evaliandexpr
    xor       %rdi,	%rax
L4221:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	30
    jz        L4220
    mov       %rax,	%rdi
L4219:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.evaliandexpr
cc_lex.evaliandexpr:
#PROC1
#PROC2
#?>>
    .set cc_lex.evaliandexpr.sy, -8
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rbx
    call      cc_lex.evaleqexpr
    mov       %rdi,	%rax
    jmp       L4225
L4224:
    call      cc_lex.lexm
    lea       %rcx,	[%rbp + cc_lex.evaliandexpr.sy]
    call      cc_lex.evaleqexpr
    and       %rdi,	%rax
L4225:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	29
    jz        L4224
    mov       %rax,	%rdi
L4223:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.evaleqexpr
cc_lex.evaleqexpr:
#PROC1
#PROC2
#?>>
    .set cc_lex.evaleqexpr.sy, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %r12,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%r12
    call      cc_lex.evalcmpexpr
    mov       %rdi,	%rax
    jmp       L4229
L4228:
    call      cc_lex.lexm
    lea       %rcx,	[%rbp + cc_lex.evaleqexpr.sy]
    call      cc_lex.evalcmpexpr
    mov       %rbx,	%rax
    mov       %rax,	%rsi
    cmp       %rax,	40
    jz        L4232
    cmp       %rax,	41
    jz        L4233
    jmp       L4234
L4232:
    mov       %rax,	%rdi
    cmp       %rax,	%rbx
    setz      %al
    movzx     %eax,	%al
    mov       %rdi,	%rax
    jmp       L4231
L4233:
    mov       %rax,	%rdi
    cmp       %rax,	%rbx
    setnz     %al
    movzx     %eax,	%al
    mov       %rdi,	%rax
L4234:
L4231:
L4229:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %rsi,	%rax
    cmp       %rax,	40
    jz        L4228
    cmp       %rsi,	41
    jz        L4228
    mov       %rax,	%rdi
L4227:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.evalcmpexpr
cc_lex.evalcmpexpr:
#PROC1
#PROC2
#?>>
    .set cc_lex.evalcmpexpr.sy, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %r12,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%r12
    call      cc_lex.evalshiftexpr
    mov       %rdi,	%rax
    jmp       L4237
L4236:
    call      cc_lex.lexm
    lea       %rcx,	[%rbp + cc_lex.evalcmpexpr.sy]
    call      cc_lex.evalshiftexpr
    mov       %rbx,	%rax
    mov       %rax,	%rsi
    cmp       %rax,	42
    jz        L4240
    cmp       %rax,	43
    jz        L4241
    cmp       %rax,	44
    jz        L4242
    cmp       %rax,	45
    jz        L4243
    jmp       L4244
L4240:
    mov       %rax,	%rdi
    cmp       %rax,	%rbx
    setl      %al
    movzx     %eax,	%al
    mov       %rdi,	%rax
    jmp       L4239
L4241:
    mov       %rax,	%rdi
    cmp       %rax,	%rbx
    setle     %al
    movzx     %eax,	%al
    mov       %rdi,	%rax
    jmp       L4239
L4242:
    mov       %rax,	%rdi
    cmp       %rax,	%rbx
    setge     %al
    movzx     %eax,	%al
    mov       %rdi,	%rax
    jmp       L4239
L4243:
    mov       %rax,	%rdi
    cmp       %rax,	%rbx
    setg      %al
    movzx     %eax,	%al
    mov       %rdi,	%rax
L4244:
L4239:
L4237:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %rsi,	%rax
    cmp       %rax,	42
    jz        L4236
    cmp       %rsi,	43
    jz        L4236
    cmp       %rsi,	44
    jz        L4236
    cmp       %rsi,	45
    jz        L4236
    mov       %rax,	%rdi
L4235:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.evalshiftexpr
cc_lex.evalshiftexpr:
#PROC1
#PROC2
#?>>
    .set cc_lex.evalshiftexpr.sy, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %r12,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%r12
    call      cc_lex.evaladdexpr
    mov       %rdi,	%rax
    jmp       L4247
L4246:
    call      cc_lex.lexm
    lea       %rcx,	[%rbp + cc_lex.evalshiftexpr.sy]
    call      cc_lex.evaladdexpr
    mov       %rbx,	%rax
    mov       %rax,	%rsi
    cmp       %rax,	34
    jz        L4250
    cmp       %rax,	33
    jz        L4251
    jmp       L4252
L4250:
    mov       %rax,	%rdi
    mov       %cl,	%bl
    sar       %rax,	%cl
    mov       %rdi,	%rax
    jmp       L4249
L4251:
    mov       %rax,	%rdi
    mov       %cl,	%bl
    shl       %rax,	%cl
    mov       %rdi,	%rax
L4252:
L4249:
L4247:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %rsi,	%rax
    cmp       %rax,	33
    jz        L4246
    cmp       %rsi,	34
    jz        L4246
    mov       %rax,	%rdi
L4245:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.evaladdexpr
cc_lex.evaladdexpr:
#PROC1
#PROC2
#?>>
    .set cc_lex.evaladdexpr.sy, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %r12,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%r12
    call      cc_lex.evalmulexpr
    mov       %rdi,	%rax
    jmp       L4255
L4254:
    call      cc_lex.lexm
    lea       %rcx,	[%rbp + cc_lex.evaladdexpr.sy]
    call      cc_lex.evalmulexpr
    mov       %rbx,	%rax
    mov       %rax,	%rsi
    cmp       %rax,	23
    jz        L4258
    cmp       %rax,	24
    jz        L4259
    jmp       L4260
L4258:
    mov       %rax,	%rbx
    add       %rdi,	%rax
    jmp       L4257
L4259:
    mov       %rax,	%rbx
    sub       %rdi,	%rax
L4260:
L4257:
L4255:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %rsi,	%rax
    cmp       %rax,	23
    jz        L4254
    cmp       %rsi,	24
    jz        L4254
    mov       %rax,	%rdi
L4253:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.evalmulexpr
cc_lex.evalmulexpr:
#PROC1
#PROC2
#?>>
    .set cc_lex.evalmulexpr.sy, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %r12,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%r12
    call      cc_lex.evalunaryexpr
    mov       %rdi,	%rax
    jmp       L4263
L4262:
    call      cc_lex.lexm
    lea       %rcx,	[%rbp + cc_lex.evalmulexpr.sy]
    call      cc_lex.evalunaryexpr
    mov       %rbx,	%rax
    test      %rbx,	%rbx
    jnz       L4266
    cmp       %rsi,	25
    jz        L4266
    lea       %rcx,	[%rip+L8897]
    call      cc_lex.lxerror
L4266:
    mov       %rax,	%rsi
    cmp       %rax,	25
    jz        L4268
    cmp       %rax,	26
    jz        L4269
    cmp       %rax,	27
    jz        L4270
    jmp       L4271
L4268:
    mov       %rax,	%rdi
    imul      %rax,	%rbx
    mov       %rdi,	%rax
    jmp       L4267
L4269:
    mov       %rax,	%rdi
    mov       %r10,	%rbx
    cqo       
    idiv      %r10
    mov       %rdi,	%rax
    jmp       L4267
L4270:
    mov       %rax,	%rdi
    mov       %r10,	%rbx
    cqo       
    idiv      %r10
    xchg      %rax,	%rdx
    mov       %rdi,	%rax
L4271:
L4267:
L4263:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %rsi,	%rax
    cmp       %rax,	25
    jz        L4262
    cmp       %rsi,	26
    jz        L4262
    cmp       %rsi,	27
    jz        L4262
    mov       %rax,	%rdi
L4261:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.evalunaryexpr
cc_lex.evalunaryexpr:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	23
    jz        L4274
    cmp       %rax,	24
    jz        L4274
    cmp       %rax,	36
    jz        L4274
    cmp       %rax,	35
    jnz       L4275
L4274:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %rbx,	%rax
    call      cc_lex.lexm
    mov       %rcx,	%rsi
    call      cc_lex.evalunaryexpr
    mov       %rdi,	%rax
    mov       %rax,	%rbx
    cmp       %rax,	23
    jz        L4277
    cmp       %rax,	24
    jz        L4278
    cmp       %rax,	36
    jz        L4279
    cmp       %rax,	35
    jz        L4280
    jmp       L4281
L4277:
    mov       %rax,	%rdi
    jmp       L4272
L4278:
    mov       %rax,	%rdi
    neg       %rax
    jmp       L4272
L4279:
    mov       %rax,	%rdi
    test      %rax,	%rax
    setz      %al
    movzx     %eax,	%al
    jmp       L4272
L4280:
    mov       %rax,	%rdi
    not       %rax
    jmp       L4272
L4281:
L4276:
L4275:
L4273:
    mov       %rcx,	%rsi
    call      cc_lex.evalterm
L4272:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.evalterm
cc_lex.evalterm:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rax,	1
    mov       [%rsi],	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L4284
    cmp       %rax,	59
    jz        L4285
    cmp       %rax,	61
    jz        L4286
    cmp       %rax,	13
    jz        L4287
    jmp       L4288
L4284:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    movzx     %rax,	byte ptr[%rax+107]
    cmp       %rax,	92
    jz        L4290
    cmp       %rax,	91
    jz        L4291
    jmp       L4292
L4290:
    mov       %rax,	1
    mov       [%rip+cc_lex.noexpand],	%rax
    xor       %rbx,	%rbx
    call      cc_lex.lexm
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	13
    jnz       L4294
    mov       %rbx,	1
    call      cc_lex.lexm
L4294:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L4296
    lea       %rcx,	[%rip+L8898]
    call      cc_lex.lxerror
L4296:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	1
    setz      %al
    movzx     %eax,	%al
    mov       %rdi,	%rax
    call      cc_lex.lexm
    test      %rbx,	%rbx
    jz        L4298
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	14
    jz        L4300
    lea       %rcx,	[%rip+L8899]
    call      cc_lex.lxerror
L4300:
    call      cc_lex.lexm
L4298:
    xor       %eax,	%eax
    mov       [%rip+cc_lex.noexpand],	%rax
    jmp       L4289
L4291:
    call      cc_lex.lexm
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	13
    jz        L4302
    lea       %rcx,	[%rip+L8900]
    call      cc_lex.lxerror
L4302:
    call      cc_lex.lexm
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L4304
    lea       %rcx,	[%rip+L8901]
    call      cc_lex.lxerror
L4304:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    movzx     %rax,	byte ptr[%rax+107]
    cmp       %rax,	70
    jnz       L4307
L4306:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    movsx     %rax,	word ptr[%rax+100]
    lea       %r10,	[%rip+cc_tables.typespecsizes]
    movzx     %r10,	byte ptr[%r10 + %rax-1]
    mov       %rdi,	%r10
    jmp       L4305
L4307:
    lea       %rcx,	[%rip+L8902]
    call      cc_lex.lxerror
L4305:
    call      cc_lex.lexm
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	14
    jz        L4309
    lea       %rcx,	[%rip+L8903]
    call      cc_lex.lxerror
L4309:
    call      cc_lex.lexm
    jmp       L4289
L4292:
    call      cc_lex.lexm
    xor       %eax,	%eax
    jmp       L4282
L4289:
    jmp       L4283
L4285:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rdi,	[%rax]
    call      cc_lex.lexm
    jmp       L4283
L4286:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+24]
    test      %rax,	%rax
    jnz       L4311
    xor       %rdi,	%rdi
    jmp       L4310
L4311:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    movzx     %rax,	byte ptr[%rax]
    mov       %rdi,	%rax
L4310:
    call      cc_lex.lexm
    jmp       L4283
L4287:
    call      cc_lex.lexm
    mov       %rcx,	%rsi
    call      cc_lex.evalcondexpr
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	14
    jz        L4313
    lea       %rcx,	[%rip+L8904]
    call      cc_lex.lxerror
L4313:
    call      cc_lex.lexm
    jmp       L4283
L4288:
    lea       %rcx,	[%rip+cc_decls.nextlx]
    call      cc_lex.printsymbol
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+24]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       %r10,	[%r10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      cc_lex.printstrn
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8905]
    call      cc_lex.lxerror
L4283:
    mov       %rax,	%rdi
L4282:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.getifdef
cc_lex.getifdef:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    mov       %rax,	1
    mov       [%rip+cc_lex.noexpand],	%rax
    call      cc_lex.lexreadtoken
    xor       %eax,	%eax
    mov       [%rip+cc_lex.noexpand],	%rax
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L4316
    lea       %rcx,	[%rip+L8906]
    call      cc_lex.lxerror
L4316:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rbx,	[%rax]
    xor       %rdi,	%rdi
    movzx     %rax,	byte ptr[%rbx+109]
    cmp       %rax,	1
    jnz       L4318
    mov       %rdi,	1
    jmp       L4317
L4318:
    movzx     %rax,	byte ptr[%rbx+107]
    cmp       %rax,	69
    jnz       L4319
    mov       %rdi,	1
L4319:
L4317:
    call      cc_lex.lexreadtoken
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	56
    jz        L4321
    lea       %rcx,	[%rip+L8907]
    call      cc_lex.lxerror
L4321:
    mov       %rax,	%rdi
L4314:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.skipcode
cc_lex.skipcode:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    xor       %rdi,	%rdi
L4323:
    call      cc_lex.fastreadtoken
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	4
    jz        L4326
    cmp       %rax,	57
    jz        L4327
    jmp       L4328
L4326:
    call      cc_lex.getlexdirective
    mov       %rbx,	%rax
    mov       %rax,	%rbx
    cmp       %rax,	3
    jz        L4330
    cmp       %rax,	8
    jz        L4330
    cmp       %rax,	9
    jz        L4330
    cmp       %rax,	4
    jz        L4331
    cmp       %rax,	5
    jz        L4331
    cmp       %rax,	6
    jz        L4332
    jmp       L4333
L4330:
    inc       %rdi
    jmp       L4329
L4331:
    test      %rdi,	%rdi
    jnz       L4335
    mov       %rax,	%rbx
    jmp       L4322
L4335:
    jmp       L4329
L4332:
    test      %rdi,	%rdi
    jnz       L4337
    mov       %rax,	%rbx
    jmp       L4322
L4337:
    dec       %rdi
L4333:
L4329:
    jmp       L4325
L4327:
    lea       %rcx,	[%rip+L8908]
    call      cc_lex.lxerror
L4328:
L4325:
    jmp       L4323
    xor       %eax,	%eax
L4322:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.freetokens
cc_lex.freetokens:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	16
#---------------
#PROC3
#PROC4
    jmp       L4340
L4339:
    mov       %rdi,	[%rcx+8]
    mov       %rax,	%rdi
    mov       %rcx,	%rax
L4340:
    test      %rcx,	%rcx
    jnz       L4339
#---------------
    add       %rsp,	16
    pop       %rdi
    ret       
# End 
# Proc cc_lex.fastreadtoken
cc_lex.fastreadtoken:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
L4343:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    inc       qword ptr[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    mov       %rdi,	%rax
    cmp       %rax,	48
    jae       L4346
    lea       %r10,	[%rip+L4345]
    jmp       [%r10 + %rax*8]
    .data
L4345:
    .quad     L4368
    .quad     L4346
    .quad     L4346
    .quad     L4346
    .quad     L4346
    .quad     L4346
    .quad     L4346
    .quad     L4346
    .quad     L4346
    .quad     L4346
    .quad     L4367
    .quad     L4346
    .quad     L4371
    .quad     L4366
    .quad     L4346
    .quad     L4346
    .quad     L4346
    .quad     L4346
    .quad     L4346
    .quad     L4346
    .quad     L4346
    .quad     L4346
    .quad     L4346
    .quad     L4346
    .quad     L4346
    .quad     L4346
    .quad     L4346
    .quad     L4346
    .quad     L4346
    .quad     L4346
    .quad     L4346
    .quad     L4346
    .quad     L4346
    .quad     L4346
    .quad     L4365
    .quad     L4347
    .quad     L4346
    .quad     L4346
    .quad     L4346
    .quad     L4364
    .quad     L4346
    .quad     L4346
    .quad     L4346
    .quad     L4346
    .quad     L4346
    .quad     L4346
    .quad     L4346
    .quad     L4359
    .text
L4347:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	2
    mov       %rsi,	%rax
    xor       %rbx,	%rbx
    jmp       L4349
L4348:
    movzx     %rax,	byte ptr[%rsi]
    cmp       %rax,	10
    jz        L4352
    cmp       %rax,	9
    jz        L4353
    cmp       %rax,	32
    jz        L4353
    jmp       L4354
L4352:
    mov       %rbx,	1
    jmp       L4350
L4353:
    jmp       L4351
L4354:
    jmp       L4350
L4351:
    dec       %rsi
L4349:
    cmp       %rsi,	[%rip+cc_lex.lxstart]
    jae       L4348
L4350:
    test      %rbx,	%rbx
    jnz       L4357
    cmp       %rsi,	[%rip+cc_lex.lxstart]
    jae       L4356
L4357:
    mov       %al,	4
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L4342
L4356:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	35
    jnz       L4358
    inc       qword ptr[%rip+cc_lex.lxsptr]
L4358:
L4355:
    jmp       L4343
L4359:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	47
    jz        L4361
    cmp       %rax,	42
    jz        L4362
    jmp       L4363
L4361:
    call      cc_lex.readlinecomment
    jmp       L4360
L4362:
    call      cc_lex.readblockcomment
L4363:
L4360:
    jmp       L4343
L4364:
    mov       %rcx,	39
    xor       %edx,	%edx
    call      cc_lex.lxreadstring
    jmp       L4343
L4365:
    mov       %rcx,	34
    xor       %edx,	%edx
    call      cc_lex.lxreadstring
    jmp       L4343
L4366:
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %rax,	[%rax+16]
    inc       dword ptr[%rax]
    mov       %al,	56
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
    inc       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L4343
L4367:
    lea       %rax,	[%rip+cc_decls.nextlx]
    lea       %rax,	[%rax+16]
    inc       dword ptr[%rax]
    mov       %al,	56
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
    jmp       L4343
L4368:
    dec       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rax,	[%rip+cc_lex.lx_stackindex]
    test      %rax,	%rax
    jz        L4370
    call      cc_lex.unstacksourcefile
    jmp       L4369
L4370:
    mov       %al,	57
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    jmp       L4342
L4369:
    jmp       L4343
L4371:
    jmp       L4343
L4346:
    jmp       L4343
L4342:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.alloctoken
cc_lex.alloctoken:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    mov       %rcx,	32
    call      mlib.pcm_alloc
    mov       %rdi,	%rax
    mov       %rax,	%rdi
L4372:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lex.alloctokenz
cc_lex.alloctokenz:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    mov       %rcx,	32
    call      mlib.pcm_alloc
    mov       %rdi,	%rax
    xor       %eax,	%eax
    mov       [%rdi+8],	%rax
    mov       %rax,	%rdi
L4373:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lex.expandpredefmacro
cc_lex.expandpredefmacro:
#PROC1
#PROC2
#?>>
    .set cc_lex.expandpredefmacro.str, -256
    .set cc_lex.expandpredefmacro.tm, -272
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	312
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+cc_lex.noexpand]
    test      %rax,	%rax
    jnz       L4374
L4376:
    mov       %rax,	%rsi
    cmp       %rax,	1
    jz        L4378
    cmp       %rax,	2
    jz        L4379
    cmp       %rax,	3
    jz        L4380
    cmp       %rax,	5
    jz        L4381
    cmp       %rax,	4
    jz        L4382
    cmp       %rax,	9
    jz        L4383
    cmp       %rax,	7
    jz        L4384
    cmp       %rax,	8
    jz        L4385
    jmp       L4386
L4378:
    lea       %rcx,	[%rbp + cc_lex.expandpredefmacro.tm]
    call      mwindows.os_getsystime
    lea       %rcx,	[%rbp + cc_lex.expandpredefmacro.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8909]
    call      msys.m$print_setfmt
    movzx     %rax,	word ptr[%rbp + cc_lex.expandpredefmacro.tm+6]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    movzx     %rax,	word ptr[%rbp + cc_lex.expandpredefmacro.tm+2]
    lea       %r10,	[%rip+cc_lex.expandpredefmacro.monthnames]
    mov       %r10,	[%r10 + %rax*8-8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    movzx     %rax,	word ptr[%rbp + cc_lex.expandpredefmacro.tm]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8910]
    call      msys.m$print_i64
    call      msys.m$print_end
    mov       %al,	63
    mov       [%r12+21],	%al
    lea       %rcx,	[%rbp + cc_lex.expandpredefmacro.str]
    call      mlib.pcm_copyheapstring
    mov       [%r12],	%rax
    jmp       L4377
L4379:
    lea       %rcx,	[%rbp + cc_lex.expandpredefmacro.tm]
    call      mwindows.os_getsystime
    lea       %rcx,	[%rbp + cc_lex.expandpredefmacro.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L8911]
    call      msys.m$print_setfmt
    movzx     %rax,	word ptr[%rbp + cc_lex.expandpredefmacro.tm+8]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8912]
    call      msys.m$print_i64
    movzx     %rax,	word ptr[%rbp + cc_lex.expandpredefmacro.tm+10]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8913]
    call      msys.m$print_i64
    movzx     %rax,	word ptr[%rbp + cc_lex.expandpredefmacro.tm+12]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8913]
    call      msys.m$print_i64
    call      msys.m$print_end
    mov       %al,	63
    mov       [%r12+21],	%al
    lea       %rcx,	[%rbp + cc_lex.expandpredefmacro.str]
    call      mlib.pcm_copyheapstring
    mov       [%r12],	%rax
    jmp       L4377
L4380:
    mov       %al,	63
    mov       [%r12+21],	%al
    mov       %rcx,	%r12
    call      cc_lex.getfilenox
    mov       %rbx,	%rax
    test      %rbx,	%rbx
    jnz       L4388
    mov       %rbx,	[%rip+cc_decls.sfileno]
L4388:
    mov       %rax,	[%rip+cc_decls.sfileno]
    test      %rax,	%rax
    jz        L4390
    lea       %rax,	[%rip+cc_decls.sourcefilenames]
    mov       %r10,	[%rip+cc_decls.sfileno]
    mov       %rax,	[%rax + %r10*8]
    mov       [%r12],	%rax
    jmp       L4389
L4390:
    lea       %rax,	[%rip+L8914]
    mov       [%r12],	%rax
L4389:
    jmp       L4377
L4381:
    mov       %al,	63
    mov       [%r12+21],	%al
    mov       %rax,	[%rip+cc_decls.currproc]
    test      %rax,	%rax
    jz        L4392
    mov       %rax,	[%rip+cc_decls.currproc]
    mov       %rax,	[%rax]
    mov       [%r12],	%rax
    jmp       L4391
L4392:
    lea       %rax,	[%rip+L8915]
    mov       [%r12],	%rax
L4391:
    jmp       L4377
L4382:
    mov       %al,	59
    mov       [%r12+21],	%al
    mov       [%r12],	%r13
    jmp       L4377
L4383:
    mov       %al,	59
    mov       [%r12+21],	%al
    mov       %rax,	1
    mov       [%r12],	%rax
    jmp       L4377
L4384:
    mov       %al,	59
    mov       [%r12+21],	%al
    mov       %rax,	1
    mov       [%r12],	%rax
    jmp       L4377
L4385:
    mov       %al,	59
    mov       [%r12+21],	%al
    movzx     %rax,	byte ptr[%rip+cc_decls.pci_target]
    mov       [%r12],	%rax
    jmp       L4377
L4386:
    call      msys.m$print_startcon
    mov       %rcx,	%rsi
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8916]
    call      cc_lex.lxerror
L4377:
    movzx     %rax,	byte ptr[%r12+21]
    cmp       %rax,	63
    jnz       L4394
    mov       %rax,	[%r12]
    mov       %rcx,	%rax
    call      strlen
    mov       [%r12+24],	%eax
    mov       %al,	[%rip+cc_decls.trefchar]
    mov       [%r12+22],	%al
    jmp       L4393
L4394:
    mov       %al,	3
    mov       [%r12+22],	%al
    mov       %rcx,	16
    call      mlib.pcm_alloc
    mov       %rdi,	%rax
    mov       %rax,	[%r12]
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    call      msys.getstrint
    mov       %rcx,	%rdi
    call      strlen
    mov       [%r12+24],	%eax
    mov       %rax,	[%rip+cc_lex.npastedtokens]
    cmp       %rax,	87000
    jl        L4396
    lea       %rcx,	[%rip+L8917]
    call      cc_lex.lxerror
L4396:
    inc       qword ptr[%rip+cc_lex.npastedtokens]
    mov       %rax,	[%rip+cc_lex.npastedtokens]
    mov       %r10,	%rdi
    lea       %r11,	[%rip+cc_lex.pastedtokenlist]
    mov       [%r11 + %rax*8-8],	%r10
    mov       %rcx,	%r12
    xor       %edx,	%edx
    call      cc_lex.setfilenox
    mov       %ax,	[%rip+cc_lex.npastedtokens]
    mov       [%r12+28],	%ax
L4393:
L4374:
#---------------
    add       %rsp,	312
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.dopragmadir
cc_lex.dopragmadir:
#PROC1
#PROC2
#?>>
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    call      cc_lex.lexm
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jnz       L4399
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8918]
    mov       %r8,	4
    call      memcmp
    movsxd    %r10,	%eax
    test      %r10,	%r10
    jnz       L4401
    call      cc_lex.lexm
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	13
    jz        L4403
    lea       %rcx,	[%rip+L8919]
    call      cc_lex.lxerror
L4403:
    call      cc_lex.lexm
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	59
    jnz       L4405
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    cmp       %rax,	1
    jnz       L4408
L4407:
    xor       %eax,	%eax
    mov       [%rip+cc_decls.structpadding],	%rax
    jmp       L4406
L4408:
    jmp       L4409
    lea       %rcx,	[%rip+L8920]
    call      cc_lex.lxerror
L4406:
    call      cc_lex.lexm
    jmp       L4404
L4405:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	14
    jnz       L4410
    mov       %rax,	1
    mov       [%rip+cc_decls.structpadding],	%rax
L4410:
L4404:
    jmp       L4400
L4401:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8921]
    mov       %r8,	6
    call      memcmp
    movsxd    %r10,	%eax
    test      %r10,	%r10
    jnz       L4411
    mov       %rcx,	77
    call      cc_lex.addbuildinfo
    jmp       L4400
L4411:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8922]
    mov       %r8,	6
    call      memcmp
    movsxd    %r10,	%eax
    test      %r10,	%r10
    jnz       L4412
    mov       %rcx,	72
    call      cc_lex.addbuildinfo
    jmp       L4400
L4412:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L8923]
    mov       %r8,	4
    call      memcmp
    movsxd    %r10,	%eax
    test      %r10,	%r10
    jnz       L4413
    mov       %rcx,	76
    call      cc_lex.addbuildinfo
L4413:
L4400:
L4399:
#cc_lex.dopragmadir.finish:
L4409:
    jmp       L4415
L4414:
    call      cc_lex.lexm
L4415:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	56
    jz        L4417
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	57
    jnz       L4414
L4417:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_lex.addbuildinfo
cc_lex.addbuildinfo:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    call      cc_lex.lexm
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	63
    jz        L4420
    lea       %rcx,	[%rip+L8924]
    call      cc_lex.lxerror
L4420:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    call      mlib.pcm_copyheapstring
    mov       %rdi,	%rax
    mov       %rax,	%rbx
    cmp       %rax,	77
    jz        L4422
    cmp       %rax,	72
    jz        L4423
    cmp       %rax,	76
    jz        L4424
    jmp       L4425
L4422:
    mov       %rax,	[%rip+cc_decls.npmodules]
    cmp       %rax,	199
    jl        L4427
    lea       %rcx,	[%rip+L8925]
    call      cc_lex.lxerror
L4427:
    inc       qword ptr[%rip+cc_decls.npmodules]
    mov       %rax,	[%rip+cc_decls.npmodules]
    mov       %r10,	%rdi
    lea       %r11,	[%rip+cc_decls.pmodulelist]
    mov       [%r11 + %rax*8-8],	%r10
    jmp       L4421
L4423:
    mov       %rax,	[%rip+cc_decls.npheaders]
    cmp       %rax,	100
    jl        L4429
    lea       %rcx,	[%rip+L8926]
    call      cc_lex.lxerror
L4429:
    inc       qword ptr[%rip+cc_decls.npheaders]
    mov       %rax,	[%rip+cc_decls.npheaders]
    mov       %r10,	%rdi
    lea       %r11,	[%rip+cc_decls.pheaderlist]
    mov       [%r11 + %rax*8-8],	%r10
    jmp       L4421
L4424:
    mov       %rax,	[%rip+cc_decls.nplibs]
    cmp       %rax,	100
    jl        L4431
    lea       %rcx,	[%rip+L8927]
    call      cc_lex.lxerror
L4431:
    inc       qword ptr[%rip+cc_decls.nplibs]
    mov       %rax,	[%rip+cc_decls.nplibs]
    mov       %r10,	%rdi
    lea       %r11,	[%rip+cc_decls.pliblist]
    mov       [%r11 + %rax*8-8],	%r10
L4425:
L4421:
    call      cc_lex.lexm
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.needspace
cc_lex.needspace:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
#---------------
#PROC3
#PROC4
    test      %rcx,	%rcx
    jnz       L4434
    xor       %eax,	%eax
    jmp       L4432
L4434:
    lea       %rax,	[%rip+cc_tables.shortsymbolnames]
    mov       %r10,	%rcx
    mov       %rdi,	[%rax + %r10*8-8]
    lea       %rax,	[%rip+cc_tables.shortsymbolnames]
    mov       %r10,	%rdx
    mov       %rbx,	[%rax + %r10*8-8]
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	110
    jz        L4436
    cmp       %rax,	107
    jz        L4436
    cmp       %rax,	45
    jz        L4437
    cmp       %rax,	43
    jz        L4437
    jmp       L4438
L4436:
    movzx     %rax,	byte ptr[%rdi]
    cmp       %rax,	110
    jz        L4440
    cmp       %rax,	107
    jnz       L4441
L4440:
    mov       %rax,	1
    jmp       L4432
L4441:
L4439:
    jmp       L4435
L4437:
    movzx     %rax,	byte ptr[%rdi]
    cmp       %rax,	45
    jz        L4443
    cmp       %rax,	43
    jnz       L4444
L4443:
    mov       %rax,	1
    jmp       L4432
L4444:
L4442:
L4438:
L4435:
    xor       %eax,	%eax
L4432:
#---------------
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.dospecialinclude
cc_lex.dospecialinclude:
#PROC1
#PROC2
#?>>
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    lea       %rcx,	[%rip+L8928]
    mov       %rdx,	1
    call      cc_lex.stacksourcefile
    mov       %rax,	[%rip+cc_decls.dheaderfile]
    test      %rax,	%rax
    jz        L4447
    mov       %rcx,	[%rip+cc_decls.dheaderfile]
    mov       %rdx,	1
    call      cc_lex.stacksourcefile
L4447:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_lex.setnumberoffset
cc_lex.setnumberoffset:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+28]
    mov       %r10,	4278190080
    and       %rax,	%r10
    mov       %r10,	%rcx
    and       %r10,	16777215
    or        %rax,	%r10
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+28],	%eax
#---------------
    ret       
# End 
# Proc cc_lex.setfileno
cc_lex.setfileno:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       %rax,	%rcx
    and       %rax,	255
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+20],	%al
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+28]
    and       %rax,	16777215
    mov       %r10,	%rcx
    and       %r10,	65280
    shl       %r10,	16
    or        %rax,	%r10
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+28],	%eax
#---------------
    ret       
# End 
# Proc cc_lex.setfilenox
cc_lex.setfilenox:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       %rax,	%rdx
    and       %rax,	255
    mov       [%rcx+20],	%al
    movsxd    %rax,	dword ptr[%rcx+28]
    and       %rax,	16777215
    mov       %r10,	%rdx
    and       %r10,	65280
    shl       %r10,	16
    or        %rax,	%r10
    mov       [%rcx+28],	%eax
#---------------
    ret       
# End 
# Proc cc_lex.getfileno
cc_lex.getfileno:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+28]
    sar       %rax,	24
    shl       %rax,	8
    lea       %r10,	[%rip+cc_decls.nextlx]
    movzx     %r10,	byte ptr[%r10+20]
    or        %rax,	%r10
L4451:
#---------------
    ret       
# End 
# Proc cc_lex.getfilenox
cc_lex.getfilenox:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    movsxd    %rax,	dword ptr[%rcx+28]
    sar       %rax,	24
    shl       %rax,	8
    movzx     %r10,	byte ptr[%rcx+20]
    or        %rax,	%r10
L4452:
#---------------
    ret       
# End 
# Proc cc_lex.getnumberoffsetx
cc_lex.getnumberoffsetx:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    movsxd    %rax,	dword ptr[%rcx+28]
    and       %rax,	16777215
L4453:
#---------------
    ret       
# End 
# Proc cc_lex.freehashtable
cc_lex.freehashtable:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    xor       %r12,	%r12
    mov       %rax,	[%rip+cc_decls.hstmask]
    cmp       %rax,	0
    jl        L4457
L4455:
    mov       %rax,	[%rip+cc_decls.hashtable]
    mov       %r10,	%r12
    mov       %rdi,	[%rax + %r10*8]
    mov       %rax,	[%rdi]
    test      %rax,	%rax
    jz        L4459
    movzx     %rax,	byte ptr[%rdi+107]
    cmp       %rax,	67
    jnz       L4459
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	1
    jnz       L4461
    mov       %rcx,	[%rdi+72]
    call      cc_lex.freetokens
L4461:
    mov       %rsi,	[%rdi+40]
    jmp       L4463
L4462:
    mov       %rbx,	[%rsi+40]
    mov       %rcx,	%rsi
    mov       %rdx,	128
    call      mlib.pcm_free
    mov       %rsi,	%rbx
L4463:
    test      %rsi,	%rsi
    jnz       L4462
    mov       %rax,	[%rip+cc_decls.hashtable]
    mov       %r10,	%r12
    mov       %rax,	[%rax + %r10*8]
    mov       %rcx,	%rax
    mov       %rdx,	128
    call      mlib.pcm_clearmem
    jmp       L4458
L4459:
    mov       %rax,	[%rdi]
    test      %rax,	%rax
    jz        L4465
    xor       %eax,	%eax
    mov       [%rdi+40],	%rax
L4465:
L4458:
    inc       %r12
    cmp       %r12,	[%rip+cc_decls.hstmask]
    jle       L4455
L4457:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.regenlookup
cc_lex.regenlookup:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%r13+106]
    mov       %r10,	[%r13]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      cc_lex.gethashvalue
    and       %rax,	[%rip+cc_decls.hstmask]
    mov       %rdi,	%rax
    xor       %rbx,	%rbx
L4467:
    mov       %rax,	[%rip+cc_decls.hashtable]
    mov       %r10,	%rdi
    mov       %r12,	[%rax + %r10*8]
    movzx     %rax,	byte ptr[%r12+106]
    mov       %rsi,	%rax
    test      %rsi,	%rsi
    jnz       L4470
    mov       %rax,	[%rip+cc_decls.hashtable]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    mov       %rcx,	%rax
    mov       %rdx,	128
    call      mlib.pcm_free
    mov       %rax,	%r13
    mov       %r10,	[%rip+cc_decls.hashtable]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*8],	%rax
    inc       qword ptr[%rip+cc_lex.nhstsymbols]
    jmp       L4466
L4470:
    movzx     %rax,	byte ptr[%r13+106]
    mov       %r10,	%rsi
    cmp       %r10,	%rax
    jnz       L4472
    mov       %rax,	[%r13]
    mov       %r10,	[%r12]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    mov       %r8,	%rsi
    call      memcmp
    movsxd    %r10,	%eax
    test      %r10,	%r10
    jnz       L4474
    lea       %rcx,	[%rip+L8929]
    call      cc_lex.lxerror
L4474:
L4472:
    inc       %rdi
    cmp       %rdi,	[%rip+cc_decls.hstsize]
    jl        L4476
    test      %rbx,	%rbx
    jz        L4478
    lea       %rcx,	[%rip+L8930]
    call      mlib.abortprogram
L4478:
    mov       %rbx,	1
    xor       %rdi,	%rdi
L4476:
    jmp       L4467
L4466:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.newhashtable
cc_lex.newhashtable:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    mov       %rdi,	[%rip+cc_decls.hashtable]
    mov       %rbx,	[%rip+cc_decls.hstsize]
    mov       %rax,	[%rip+cc_decls.hstsize]
    shl       %rax,	1
    mov       [%rip+cc_decls.hstsize],	%rax
    mov       %rax,	[%rip+cc_decls.hstsize]
    dec       %rax
    mov       [%rip+cc_decls.hstmask],	%rax
    xor       %eax,	%eax
    mov       [%rip+cc_lex.nhstsymbols],	%rax
    mov       %rax,	6
    mov       %r10,	[%rip+cc_decls.hstsize]
    imul      %rax,	%r10
    mov       %r10,	10
    cqo       
    idiv      %r10
    mov       [%rip+cc_lex.hstthreshold],	%rax
    mov       %rax,	[%rip+cc_decls.hstsize]
    shl       %rax,	3
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       [%rip+cc_decls.hashtable],	%rax
    xor       %r13,	%r13
    mov       %rax,	[%rip+cc_decls.hstmask]
    cmp       %rax,	0
    jl        L4482
L4480:
    mov       %rcx,	128
    call      mlib.pcm_allocz
    mov       %r10,	[%rip+cc_decls.hashtable]
    mov       %r11,	%r13
    mov       [%r10 + %r11*8],	%rax
    inc       %r13
    cmp       %r13,	[%rip+cc_decls.hstmask]
    jle       L4480
L4482:
    xor       %r13,	%r13
    mov       %rax,	%rbx
    dec       %rax
    mov       %r12,	%rax
    cmp       %r12,	0
    jl        L4485
L4483:
    mov       %rsi,	[%rdi + %r13*8]
    mov       %rax,	[%rsi]
    test      %rax,	%rax
    jz        L4487
    mov       %rcx,	%rsi
    call      cc_lex.regenlookup
L4487:
    inc       %r13
    cmp       %r13,	%r12
    jle       L4483
L4485:
    mov       %rax,	%rbx
    shl       %rax,	3
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mlib.pcm_free
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.old_readrealnumber
cc_lex.old_readrealnumber:
#PROC1
#PROC2
#?>>
    .set cc_lex.old_readrealnumber.intlen, 104
    .set cc_lex.old_readrealnumber.base, 112
    .set cc_lex.old_readrealnumber.c, -8
    .set cc_lex.old_readrealnumber.badexpon, -16
    .set cc_lex.old_readrealnumber.realstr, -520
    .set cc_lex.old_readrealnumber.av_1, -528
    .set cc_lex.old_readrealnumber.av_2, -536
    .set cc_lex.old_readrealnumber.av_3, -544
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    movq      %rax,	%XMM13
    push      %rax
    movq      %rax,	%XMM14
    push      %rax
    movq      %rax,	%XMM15
    push      %rax
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	584
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       [%rbp+104],	%r8
    mov       [%rbp+112],	%r9
#---------------
#PROC3
#PROC4
    xor       %rdi,	%rdi
    xor       %eax,	%eax
    mov       %rbx,	%rax
    xor       %rsi,	%rsi
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	46
    jnz       L4490
    inc       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rdi,	[%rip+cc_lex.lxsptr]
    mov       %rcx,	[%rbp + cc_lex.old_readrealnumber.base]
    call      cc_lex.scannumber
    sub       %rax,	%rdi
    mov       %rbx,	%rax
L4490:
    xor       %eax,	%eax
    mov       [%rbp + cc_lex.old_readrealnumber.badexpon],	%rax
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	101
    jz        L4492
    cmp       %rax,	69
    jz        L4492
    cmp       %rax,	112
    jz        L4493
    cmp       %rax,	80
    jz        L4493
    jmp       L4494
L4492:
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.base]
    cmp       %rax,	16
    jz        L4496
    inc       qword ptr[%rip+cc_lex.lxsptr]
    lea       %rcx,	[%rbp + cc_lex.old_readrealnumber.badexpon]
    call      cc_lex.readexponent
    mov       %rsi,	%rax
L4496:
    jmp       L4491
L4493:
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.base]
    cmp       %rax,	16
    jnz       L4498
    inc       qword ptr[%rip+cc_lex.lxsptr]
    lea       %rcx,	[%rbp + cc_lex.old_readrealnumber.badexpon]
    call      cc_lex.readexponent
    mov       %rsi,	%rax
L4498:
L4494:
L4491:
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.badexpon]
    test      %rax,	%rax
    jz        L4500
    dec       qword ptr[%rip+cc_lex.lxsptr]
    mov       %rcx,	%r13
    call      cc_lex.readalphanumeric
    jmp       L4488
L4500:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	102
    jz        L4502
    cmp       %rax,	70
    jz        L4502
    cmp       %rax,	108
    jz        L4502
    cmp       %rax,	76
    jnz       L4503
L4502:
    inc       qword ptr[%rip+cc_lex.lxsptr]
    jmp       L4501
L4503:
    mov       %rax,	[%rip+cc_lex.lxsptr]
    movzx     %rax,	byte ptr[%rax]
    lea       %r10,	[%rip+cc_lex.alphamap]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L4505
    mov       %rcx,	%r13
    call      cc_lex.readalphanumeric
    jmp       L4488
L4505:
L4501:
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.intlen]
    add       %rax,	%rbx
    cmp       %rax,	500
    jle       L4507
    lea       %rcx,	[%rip+L8931]
    call      cc_lex.lxerror
L4507:
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.intlen]
    test      %rax,	%rax
    jz        L4509
    lea       %rcx,	[%rbp + cc_lex.old_readrealnumber.realstr]
    mov       %rdx,	%r14
    mov       %r8,	[%rbp + cc_lex.old_readrealnumber.intlen]
    call      memcpy
L4509:
    test      %rbx,	%rbx
    jz        L4511
    lea       %rax,	[%rbp + cc_lex.old_readrealnumber.realstr]
    mov       %r10,	[%rbp + cc_lex.old_readrealnumber.intlen]
    lea       %rax,	[%rax + %r10]
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      memcpy
L4511:
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.base]
    cvtsi2sd  %XMM4,	%rax
    movq      %XMM15,	%XMM4
    movq      %XMM13,	%XMM4
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.base]
    cmp       %rax,	10
    jnz       L4513
    mov       %rax,	%rbx
    sub       %rsi,	%rax
    jmp       L4512
L4513:
    mov       %rax,	%rbx
    shl       %rax,	2
    sub       %rsi,	%rax
    movq      %XMM4,	[%rip+L8932]
    movq      %XMM13,	%XMM4
L4512:
    movq      %XMM4,	[%rip+L8933]
    movq      %XMM14,	%XMM4
    mov       %r12,	1
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.intlen]
    add       %rax,	%rbx
    mov       [%rbp + cc_lex.old_readrealnumber.av_1],	%rax
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.av_1]
    cmp       %rax,	1
    jl        L4516
L4514:
    movzx     %rax,	byte ptr[%rbp + %r12 + cc_lex.old_readrealnumber.realstr-1]
    mov       [%rbp + cc_lex.old_readrealnumber.c],	%rax
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.c]
    cmp       %rax,	48
    jl        L4518
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.c]
    cmp       %rax,	57
    jg        L4518
    movq      %XMM4,	%XMM14
    mulsd     %XMM4,	%XMM15
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.c]
    sub       %rax,	48
    cvtsi2sd  %XMM5,	%rax
    addsd     %XMM4,	%XMM5
    movq      %XMM14,	%XMM4
    jmp       L4517
L4518:
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.c]
    cmp       %rax,	97
    jle       L4519
    movq      %XMM4,	%XMM14
    mulsd     %XMM4,	%XMM15
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.c]
    cvtsi2sd  %XMM5,	%rax
    addsd     %XMM4,	%XMM5
    mov       %rax,	97
    cmp       %rax,	0
    jl        L8934
    cvtsi2sd  %XMM5,	%rax
    jmp       L8935
L8934:
    and       %rax,	[%rip+L8936]
    cvtsi2sd  %XMM5,	%rax
    addsd     %XMM5,	[%rip+L8937]
L8935:
    subsd     %XMM4,	%XMM5
    addsd     %XMM4,	[%rip+L8938]
    movq      %XMM14,	%XMM4
    jmp       L4517
L4519:
    movq      %XMM4,	%XMM14
    mulsd     %XMM4,	%XMM15
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.c]
    cvtsi2sd  %XMM5,	%rax
    addsd     %XMM4,	%XMM5
    mov       %rax,	65
    cmp       %rax,	0
    jl        L8939
    cvtsi2sd  %XMM5,	%rax
    jmp       L8940
L8939:
    and       %rax,	[%rip+L8936]
    cvtsi2sd  %XMM5,	%rax
    addsd     %XMM5,	[%rip+L8937]
L8940:
    subsd     %XMM4,	%XMM5
    addsd     %XMM4,	[%rip+L8941]
    movq      %XMM14,	%XMM4
L4517:
    inc       %r12
    cmp       %r12,	[%rbp + cc_lex.old_readrealnumber.av_1]
    jle       L4514
L4516:
    cmp       %rsi,	0
    jl        L4521
    mov       [%rbp + cc_lex.old_readrealnumber.av_2],	%rsi
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.av_2]
    cmp       %rax,	0
    jle       L4524
L4522:
    movq      %XMM4,	%XMM14
    mulsd     %XMM4,	%XMM13
    movq      %XMM14,	%XMM4
    dec       qword ptr[%rbp + cc_lex.old_readrealnumber.av_2]
    jnz       L4522
L4524:
    jmp       L4520
L4521:
    mov       %rax,	%rsi
    neg       %rax
    mov       [%rbp + cc_lex.old_readrealnumber.av_3],	%rax
    mov       %rax,	[%rbp + cc_lex.old_readrealnumber.av_3]
    cmp       %rax,	0
    jle       L4527
L4525:
    movq      %XMM4,	%XMM14
    divsd     %XMM4,	%XMM13
    movq      %XMM14,	%XMM4
    dec       qword ptr[%rbp + cc_lex.old_readrealnumber.av_3]
    jnz       L4525
L4527:
L4520:
    mov       %al,	60
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+21],	%al
    mov       %al,	11
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+22],	%al
    movq      %XMM4,	%XMM14
    lea       %rax,	[%rip+cc_decls.nextlx]
    movq      [%rax],	%XMM4
    mov       %rax,	%r14
    sub       %rax,	[%rip+cc_lex.lxstart]
    mov       %rcx,	%rax
    call      cc_lex.setnumberoffset
    mov       %rax,	[%rip+cc_lex.lxsptr]
    sub       %rax,	%r14
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10+24],	%eax
L4488:
#---------------
    add       %rsp,	584
    pop       %rbp
    pop       %rcx
    movq      %XMM15,	%rcx
    pop       %rcx
    movq      %XMM14,	%rcx
    pop       %rcx
    movq      %XMM13,	%rcx
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lex.issimpleconstmacro
cc_lex.issimpleconstmacro:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rsi,	1
    mov       %rbx,	3
    cmp       %rbx,	1
    jl        L4531
L4529:
    mov       %rax,	[%r12]
    lea       %r10,	[%rip+cc_lex.issimpleconstmacro.specialnames]
    mov       %r11,	%rsi
    mov       %r10,	[%r10 + %r11*8-8]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L4533
    mov       %rax,	2
    jmp       L4528
L4533:
    inc       %rsi
    cmp       %rsi,	%rbx
    jle       L4529
L4531:
    mov       %rdi,	[%r12+72]
    test      %rdi,	%rdi
    jz        L4535
    mov       %rax,	[%rdi+8]
    test      %rax,	%rax
    jnz       L4535
    movzx     %rax,	byte ptr[%rdi+21]
    cmp       %rax,	59
    jz        L4538
    movzx     %rax,	byte ptr[%rdi+21]
    cmp       %rax,	60
    jnz       L4537
L4538:
    mov       %rax,	1
    jmp       L4528
L4537:
L4535:
    xor       %eax,	%eax
L4528:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readmodule
cc_parse.readmodule:
#PROC1
#PROC2
#?>>
    .set cc_parse.readmodule.linkage, -8
    .set cc_parse.readmodule.wasdef, -16
    .set cc_parse.readmodule.d, -24
    .set cc_parse.readmodule.pm, -32
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	72
#---------------
#PROC3
#PROC4
    jmp       L4541
L4540:
    xor       %r12,	%r12
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	9
    jnz       L4545
L4544:
    lea       %rcx,	[%rip+L8942]
    call      cc_support.serror
L4545:
L4543:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %r13,	%rax
    mov       %rcx,	[%rip+cc_decls.stmodule]
    lea       %rdx,	[%rbp + cc_parse.readmodule.linkage]
    call      cc_parse.readdeclspec
    mov       %rbx,	%rax
    xor       %rsi,	%rsi
L4546:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L4548
    cmp       %rax,	25
    jz        L4548
    cmp       %rax,	13
    jnz       L4549
L4548:
    inc       %r12
    mov       %rcx,	[%rip+cc_decls.stmodule]
    lea       %rdx,	[%rbp + cc_parse.readmodule.d]
    mov       %r8,	%rbx
    lea       %r9,	[%rbp + cc_parse.readmodule.pm]
    call      cc_parse.readtype
    mov       %rdi,	%rax
    mov       %rax,	[%rbp + cc_parse.readmodule.d]
    test      %rax,	%rax
    jnz       L4551
    lea       %rcx,	[%rip+L8943]
    call      cc_support.serror
L4551:
    mov       %rax,	[%rbp + cc_parse.readmodule.linkage]
    cmp       %rax,	5
    jnz       L4553
    mov       %rax,	[%rbp + cc_parse.readmodule.pm]
    test      %rax,	%rax
    jz        L4555
    mov       %rcx,	%rdi
    mov       %rdx,	[%rbp + cc_parse.readmodule.pm]
    call      cc_lib.createprocmode
    mov       %rdi,	%rax
L4555:
    mov       %rcx,	[%rip+cc_decls.stmodule]
    mov       %rdx,	[%rbp + cc_parse.readmodule.d]
    mov       %r8,	%rdi
    call      cc_parse.createtypedef
    mov       [%rbp + cc_parse.readmodule.d],	%rax
    jmp       L4552
L4553:
    mov       %rax,	[%rbp + cc_parse.readmodule.pm]
    test      %rax,	%rax
    jz        L4556
#cc_parse.readmodule.readfn:
L4557:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	17
    jnz       L4559
    test      %rsi,	%rsi
    jz        L4559
    lea       %rcx,	[%rip+L8944]
    call      cc_support.serror
L4559:
    sub       %rsp,	8
    lea       %rax,	[%rbp + cc_parse.readmodule.wasdef]
    push      %rax
    mov       %rcx,	[%rbp + cc_parse.readmodule.d]
    mov       %rdx,	%rdi
    mov       %r8,	[%rbp + cc_parse.readmodule.linkage]
    mov       %r9,	[%rbp + cc_parse.readmodule.pm]
    sub       %rsp,	32
    call      cc_parse.readfunction
    add       %rsp,	48
    mov       [%rbp + cc_parse.readmodule.d],	%rax
    mov       %rax,	[%rbp + cc_parse.readmodule.wasdef]
    test      %rax,	%rax
    jnz       L4547
L4561:
    jmp       L4552
L4556:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	14
    jnz       L4562
    lea       %rax,	[%rip+cc_decls.ttparams]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    mov       [%rbp + cc_parse.readmodule.pm],	%rax
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rdi,	%rax
    jmp       L4557
L4562:
    mov       %rcx,	[%rbp + cc_parse.readmodule.d]
    mov       %rdx,	%rdi
    mov       %r8,	[%rbp + cc_parse.readmodule.linkage]
    call      cc_parse.readmodulevar
    mov       [%rbp + cc_parse.readmodule.d],	%rax
L4552:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jnz       L4565
L4564:
    mov       %rsi,	1
    call      cc_lex.lex
    jmp       L4563
L4565:
    mov       %rcx,	9
    call      cc_lib.skipsymbol
    jmp       L4547
L4563:
    jmp       L4546
L4549:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	12
    jz        L4567
    cmp       %rax,	18
    jz        L4567
    cmp       %rax,	19
    jz        L4567
    cmp       %rax,	3
    jz        L4568
    jmp       L4569
L4567:
    mov       %rcx,	9
    call      cc_lib.skipsymbol
    jmp       L4547
L4568:
    mov       %rcx,	9
    call      cc_lib.skipsymbol
    jmp       L4547
L4569:
    mov       %rcx,	%rbx
    call      cc_lib.typename
    lea       %rcx,	[%rip+L8945]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L4566:
    jmp       L4546
L4547:
L4541:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	57
    jnz       L4540
#---------------
    add       %rsp,	72
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.parsemodule
cc_parse.parsemodule:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+cc_cli.fverbose]
    cmp       %rax,	3
    jnz       L4572
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8946]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+cc_decls.inputfile]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L4572:
    xor       %eax,	%eax
    mov       [%rip+cc_parse.ingeneric],	%al
    mov       [%rip+cc_parse.loopindex],	%rax
    xor       %eax,	%eax
    mov       [%rip+cc_parse.ist_symptr],	%rax
    lea       %rcx,	[%rip+cc_parse.casevaluestack]
    xor       %edx,	%edx
    mov       %r8,	512
    call      memset
    lea       %rcx,	[%rip+L8947]
    mov       %rdx,	[%rip+cc_decls.mainfileno]
    call      cc_lex.startlex
    mov       %rdi,	[%rip+cc_decls.stmodule]
    xor       %eax,	%eax
    mov       [%rip+cc_decls.currproc],	%rax
    xor       %eax,	%eax
    mov       [%rip+cc_parse.loopindex],	%rax
    call      cc_lex.lex
    call      cc_parse.readmodule
    call      cc_lex.endlex
    mov       %rax,	1
L4570:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readdeclspec
cc_parse.readdeclspec:
#PROC1
#PROC2
#?>>
    .set cc_parse.readdeclspec.d, -16
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %r13,	%rcx
    mov       %r14,	%rdx
#---------------
#PROC3
#PROC4
    lea       %rcx,	[%rbp + cc_parse.readdeclspec.d]
    xor       %edx,	%edx
    mov       %r8,	15
    call      memset
    mov       %eax,	20
    mov       [%rbp + cc_parse.readdeclspec.d],	%eax
    xor       %eax,	%eax
    mov       %rbx,	%rax
    mov       %r12,	%rax
L4574:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    sub       %rax,	67
    cmp       %rax,	24
    jae       L4577
    lea       %r10,	[%rip+L4576]
    jmp       [%r10 + %rax*8]
    .data
L4576:
    .quad     L4625
    .quad     L4577
    .quad     L4577
    .quad     L4579
    .quad     L4577
    .quad     L4577
    .quad     L4577
    .quad     L4577
    .quad     L4577
    .quad     L4577
    .quad     L4577
    .quad     L4577
    .quad     L4577
    .quad     L4577
    .quad     L4577
    .quad     L4577
    .quad     L4619
    .quad     L4619
    .quad     L4612
    .quad     L4606
    .quad     L4578
    .quad     L4615
    .quad     L4577
    .quad     L4622
    .text
L4578:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+22]
    mov       [%rbp + cc_parse.readdeclspec.d],	%eax
    call      cc_lex.lex
    jmp       L4574
L4579:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+22]
    sub       %rax,	1
    cmp       %rax,	10
    jae       L4582
    lea       %r10,	[%rip+L4581]
    jmp       [%r10 + %rax*8]
    .data
L4581:
    .quad     L4583
    .quad     L4583
    .quad     L4589
    .quad     L4593
    .quad     L4583
    .quad     L4583
    .quad     L4583
    .quad     L4598
    .quad     L4602
    .quad     L4583
    .text
L4583:
    movsxd    %rax,	dword ptr[%rbp + cc_parse.readdeclspec.d]
    cmp       %rax,	20
    jz        L4585
    test      %r12,	%r12
    jz        L4587
    mov       %rcx,	9
    call      cc_lib.checksymbol
    jmp       L4586
L4587:
    jmp       L4588
L4586:
L4585:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+22]
    lea       %r10,	[%rip+cc_tables.typespectypes]
    mov       %r10d,	[%r10 + %rax*4-4]
    mov       [%rbp + cc_parse.readdeclspec.d],	%r10d
    jmp       L4580
L4589:
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+9]
    test      %al,	%al
    jnz       L4592
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+10]
    test      %al,	%al
    jnz       L4592
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+11]
    test      %al,	%al
    jz        L4591
L4592:
    jmp       L4588
L4591:
    mov       %rax,	1
    mov       %rbx,	%rax
    mov       [%rbp + cc_parse.readdeclspec.d+9],	%al
    jmp       L4580
L4593:
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+11]
    test      %al,	%al
    jnz       L4596
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+9]
    test      %al,	%al
    jz        L4595
L4596:
    jmp       L4588
L4595:
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+10]
    test      %al,	%al
    jz        L4597
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readdeclspec.d+10],	%al
    mov       %al,	1
    mov       [%rbp + cc_parse.readdeclspec.d+11],	%al
    jmp       L4594
L4597:
    mov       %al,	1
    mov       [%rbp + cc_parse.readdeclspec.d+10],	%al
L4594:
    mov       %rbx,	1
    jmp       L4580
L4598:
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+12]
    test      %al,	%al
    jnz       L4601
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+13]
    test      %al,	%al
    jz        L4600
L4601:
    jmp       L4588
L4600:
    mov       %rax,	1
    mov       %rbx,	%rax
    mov       [%rbp + cc_parse.readdeclspec.d+12],	%al
    jmp       L4580
L4602:
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+12]
    test      %al,	%al
    jnz       L4605
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+13]
    test      %al,	%al
    jz        L4604
L4605:
    jmp       L4588
L4604:
    mov       %rax,	1
    mov       %rbx,	%rax
    mov       [%rbp + cc_parse.readdeclspec.d+13],	%al
    jmp       L4580
L4582:
#cc_parse.readdeclspec.tserror:
L4588:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+22]
    lea       %r10,	[%rip+cc_tables.typespecnames]
    mov       %r10,	[%r10 + %rax*8-8]
    lea       %rcx,	[%rip+L8948]
    mov       %rdx,	%r10
    call      cc_support.serror_s
L4580:
    call      cc_lex.lex
    jmp       L4574
L4606:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+22]
    cmp       %rax,	1
    jz        L4608
    cmp       %rax,	2
    jz        L4609
    cmp       %rax,	3
    jz        L4610
    jmp       L4611
L4608:
    mov       %al,	1
    mov       [%rbp + cc_parse.readdeclspec.d+4],	%al
    jmp       L4607
L4609:
    mov       %al,	1
    mov       [%rbp + cc_parse.readdeclspec.d+5],	%al
    jmp       L4607
L4610:
    mov       %al,	1
    mov       [%rbp + cc_parse.readdeclspec.d+6],	%al
L4611:
L4607:
    call      cc_lex.lex
    jmp       L4574
L4612:
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+7]
    test      %al,	%al
    jz        L4614
    lea       %rcx,	[%rip+L8949]
    call      cc_support.serror
L4614:
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %al,	[%rax+22]
    mov       [%rbp + cc_parse.readdeclspec.d+7],	%al
    call      cc_lex.lex
    jmp       L4574
L4615:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+22]
    cmp       %rax,	1
    jnz       L4618
L4617:
    mov       %al,	1
    mov       [%rbp + cc_parse.readdeclspec.d+8],	%al
L4618:
L4616:
    call      cc_lex.lex
    jmp       L4574
L4619:
    movsxd    %rax,	dword ptr[%rbp + cc_parse.readdeclspec.d]
    cmp       %rax,	20
    jz        L4621
    lea       %rcx,	[%rip+L8950]
    call      cc_support.serror
L4621:
    mov       %rcx,	%r13
    call      cc_parse.readstructdecl
    mov       [%rbp + cc_parse.readdeclspec.d],	%eax
    mov       %al,	1
    mov       [%rbp + cc_parse.readdeclspec.d+14],	%al
    mov       %r12,	1
    jmp       L4574
L4622:
    movsxd    %rax,	dword ptr[%rbp + cc_parse.readdeclspec.d]
    cmp       %rax,	20
    jz        L4624
    lea       %rcx,	[%rip+L8951]
    call      cc_support.serror
L4624:
    mov       %rcx,	%r13
    call      cc_parse.readenumdecl
    mov       %eax,	3
    mov       [%rbp + cc_parse.readdeclspec.d],	%eax
    mov       %al,	1
    mov       [%rbp + cc_parse.readdeclspec.d+14],	%al
    jmp       L4574
L4625:
    movsxd    %rax,	dword ptr[%rbp + cc_parse.readdeclspec.d]
    cmp       %rax,	20
    jnz       L4627
    mov       %rcx,	%r13
    call      cc_parse.isusertype
    mov       %rsi,	%rax
    cmp       %rax,	20
    jz        L4627
    test      %rbx,	%rbx
    jz        L4629
    mov       %eax,	3
    mov       [%rbp + cc_parse.readdeclspec.d],	%eax
    jmp       L4575
L4629:
    mov       [%rbp + cc_parse.readdeclspec.d],	%esi
    mov       %al,	1
    mov       [%rbp + cc_parse.readdeclspec.d+14],	%al
    call      cc_lex.lex
    jmp       L4626
L4627:
    movsxd    %rax,	dword ptr[%rbp + cc_parse.readdeclspec.d]
    cmp       %rax,	20
    jnz       L4631
    test      %rbx,	%rbx
    jnz       L4631
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       %rax,	[%rax]
    lea       %rcx,	[%rip+L8952]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L4631:
    movsxd    %rax,	dword ptr[%rbp + cc_parse.readdeclspec.d]
    cmp       %rax,	20
    jnz       L4633
    mov       %eax,	3
    mov       [%rbp + cc_parse.readdeclspec.d],	%eax
L4633:
    jmp       L4575
L4626:
    jmp       L4574
L4577:
    jmp       L4575
L4575:
    movsxd    %rax,	dword ptr[%rbp + cc_parse.readdeclspec.d]
    cmp       %rax,	20
    jz        L4635
    movsxd    %rax,	dword ptr[%rbp + cc_parse.readdeclspec.d]
    jmp       L4634
L4635:
    mov       %rax,	3
L4634:
    mov       %rdi,	%rax
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+14]
    test      %al,	%al
    jnz       L4637
    mov       %rax,	%rdi
    cmp       %rax,	3
    jz        L4639
    cmp       %rax,	1
    jz        L4640
    cmp       %rax,	11
    jz        L4641
    jmp       L4642
L4639:
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+9]
    test      %al,	%al
    jz        L4644
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+13]
    test      %al,	%al
    jz        L4646
    mov       %rax,	7
    jmp       L4645
L4646:
    mov       %rax,	2
L4645:
    mov       %rdi,	%rax
    jmp       L4643
L4644:
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+10]
    test      %al,	%al
    jz        L4647
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+13]
    test      %al,	%al
    jz        L4649
    mov       %rax,	8
    jmp       L4648
L4649:
    mov       %rax,	3
L4648:
    mov       %rdi,	%rax
    jmp       L4643
L4647:
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+11]
    test      %al,	%al
    jz        L4650
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+13]
    test      %al,	%al
    jz        L4652
    mov       %rax,	9
    jmp       L4651
L4652:
    mov       %rax,	4
L4651:
    mov       %rdi,	%rax
    jmp       L4643
L4650:
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+13]
    test      %al,	%al
    jz        L4653
    mov       %rdi,	8
L4653:
L4643:
    jmp       L4638
L4640:
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+9]
    test      %al,	%al
    jnz       L4656
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+10]
    test      %al,	%al
    jnz       L4656
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+11]
    test      %al,	%al
    jz        L4655
L4656:
    lea       %rcx,	[%rip+L8953]
    call      cc_support.serror
L4655:
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+13]
    test      %al,	%al
    jz        L4658
    mov       %rax,	6
    jmp       L4657
L4658:
    mov       %rax,	1
L4657:
    mov       %rdi,	%rax
    jmp       L4638
L4641:
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+9]
    test      %al,	%al
    jnz       L4661
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+11]
    test      %al,	%al
    jnz       L4661
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+12]
    test      %al,	%al
    jnz       L4661
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+13]
    test      %al,	%al
    jz        L4660
L4661:
    lea       %rcx,	[%rip+L8954]
    call      cc_support.serror
L4660:
    jmp       L4638
L4642:
    test      %rbx,	%rbx
    jz        L4663
    lea       %rcx,	[%rip+L8955]
    call      cc_support.serror
L4663:
L4638:
L4637:
    mov       %al,	[%rbp + cc_parse.readdeclspec.d+4]
    test      %al,	%al
    jz        L4665
    mov       %rcx,	%rdi
    call      cc_lib.createconstmode
    mov       %rdi,	%rax
L4665:
    movzx     %rax,	byte ptr[%rbp + cc_parse.readdeclspec.d+7]
    mov       [%r14],	%rax
    mov       %rax,	%rdi
L4573:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.istypestarter
cc_parse.istypestarter:
#PROC1
#PROC2
#?>>
    .set cc_parse.istypestarter.$T3, -8
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	70
    jz        L4668
    cmp       %rax,	87
    jz        L4668
    cmp       %rax,	86
    jz        L4669
    cmp       %rax,	67
    jz        L4670
    cmp       %rax,	83
    jz        L4671
    cmp       %rax,	84
    jz        L4671
    cmp       %rax,	90
    jz        L4671
    jmp       L4672
L4668:
    mov       %rax,	1
    jmp       L4666
L4669:
    mov       %rax,	1
    jmp       L4666
L4670:
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       [%rbp + cc_parse.istypestarter.$T3],	%rax
    mov       %rax,	[%rip+cc_decls.currproc]
    test      %rax,	%rax
    jz        L4674
    mov       %rax,	[%rip+cc_decls.currproc]
    jmp       L4673
L4674:
    mov       %rax,	[%rip+cc_decls.stmodule]
L4673:
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + cc_parse.istypestarter.$T3]
    mov       %r8,	1
    mov       %r9,	[%rip+cc_decls.currblockno]
    call      cc_lib.resolvename
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L4676
    mov       %rax,	%rdi
    lea       %r10,	[%rip+cc_decls.lx]
    mov       [%r10],	%rax
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	5
    setz      %al
    movzx     %eax,	%al
    jmp       L4666
L4676:
    jmp       L4667
L4671:
    mov       %rax,	1
    jmp       L4666
L4672:
L4667:
    xor       %eax,	%eax
L4666:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc cc_parse.istypestarter_next
cc_parse.istypestarter_next:
#PROC1
#PROC2
#?>>
    .set cc_parse.istypestarter_next.$T3, -8
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	70
    jz        L4679
    cmp       %rax,	87
    jz        L4679
    cmp       %rax,	86
    jz        L4680
    cmp       %rax,	67
    jz        L4681
    cmp       %rax,	83
    jz        L4682
    cmp       %rax,	84
    jz        L4682
    cmp       %rax,	90
    jz        L4682
    jmp       L4683
L4679:
    mov       %rax,	1
    jmp       L4677
L4680:
    mov       %rax,	1
    jmp       L4677
L4681:
    lea       %rax,	[%rip+cc_decls.nextlx]
    mov       %rax,	[%rax]
    mov       [%rbp + cc_parse.istypestarter_next.$T3],	%rax
    mov       %rax,	[%rip+cc_decls.currproc]
    test      %rax,	%rax
    jz        L4685
    mov       %rax,	[%rip+cc_decls.currproc]
    jmp       L4684
L4685:
    mov       %rax,	[%rip+cc_decls.stmodule]
L4684:
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + cc_parse.istypestarter_next.$T3]
    mov       %r8,	1
    mov       %r9,	[%rip+cc_decls.currblockno]
    call      cc_lib.resolvename
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L4687
    mov       %rax,	%rdi
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       [%r10],	%rax
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	5
    setz      %al
    movzx     %eax,	%al
    jmp       L4677
L4687:
    jmp       L4678
L4682:
    mov       %rax,	1
    jmp       L4677
L4683:
L4678:
    xor       %eax,	%eax
L4677:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readexpression
cc_parse.readexpression:
#PROC1
#PROC2
#?>>
    .set cc_parse.readexpression.ulist, -8
    .set cc_parse.readexpression.ulistx, -16
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	56
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	9
    jz        L4690
    cmp       %rax,	14
    jnz       L4691
L4690:
    call      cc_parse.readterm
    jmp       L4688
L4691:
L4689:
    call      cc_parse.readassignexpr
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jnz       L4693
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readexpression.ulistx],	%rax
    mov       [%rbp + cc_parse.readexpression.ulist],	%rax
L4694:
    lea       %rcx,	[%rbp + cc_parse.readexpression.ulist]
    lea       %rdx,	[%rbp + cc_parse.readexpression.ulistx]
    mov       %r8,	%rdi
    call      cc_lib.addlistunit
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jnz       L4695
L4697:
    call      cc_lex.lex
    call      cc_parse.readassignexpr
    mov       %rdi,	%rax
    jmp       L4694
L4695:
    mov       %rcx,	29
    mov       %rdx,	[%rbp + cc_parse.readexpression.ulist]
    call      cc_lib.createunit1
    mov       %rdi,	%rax
    mov       %rax,	[%rbp + cc_parse.readexpression.ulistx]
    test      %rax,	%rax
    jz        L4699
    mov       %rax,	[%rbp + cc_parse.readexpression.ulistx]
    mov       %eax,	[%rax+52]
    mov       [%rdi+52],	%eax
L4699:
    mov       %rax,	%rdi
    jmp       L4688
L4693:
    mov       %rax,	%rdi
L4688:
#---------------
    add       %rsp,	56
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readassignexpr
cc_parse.readassignexpr:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jz        L4702
    cmp       %rax,	9
    jz        L4702
    cmp       %rax,	14
    jz        L4702
    cmp       %rax,	11
    jz        L4703
    jmp       L4704
L4702:
    call      cc_parse.readterm
    jmp       L4700
L4703:
    call      cc_parse.readterm
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %r12,	%rax
    jmp       L4705
L4704:
L4701:
    call      cc_parse.readcondexpr
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %r12,	%rax
    sub       %rax,	11
    cmp       %rax,	45
    jae       L4708
    lea       %r10,	[%rip+L4707]
    jmp       [%r10 + %rax*8]
    .data
L4707:
    .quad     L4709
    .quad     L4708
    .quad     L4708
    .quad     L4708
    .quad     L4708
    .quad     L4708
    .quad     L4708
    .quad     L4708
    .quad     L4708
    .quad     L4708
    .quad     L4708
    .quad     L4708
    .quad     L4708
    .quad     L4708
    .quad     L4708
    .quad     L4708
    .quad     L4708
    .quad     L4708
    .quad     L4708
    .quad     L4708
    .quad     L4708
    .quad     L4708
    .quad     L4708
    .quad     L4708
    .quad     L4708
    .quad     L4708
    .quad     L4708
    .quad     L4708
    .quad     L4708
    .quad     L4708
    .quad     L4708
    .quad     L4708
    .quad     L4708
    .quad     L4708
    .quad     L4708
    .quad     L4709
    .quad     L4709
    .quad     L4709
    .quad     L4709
    .quad     L4709
    .quad     L4709
    .quad     L4709
    .quad     L4709
    .quad     L4709
    .quad     L4709
    .text
L4709:
#cc_parse.readassignexpr.gotp:
L4705:
    call      cc_lex.lex
    movsxd    %rax,	dword ptr[%rdi+52]
    mov       %r13,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      cc_parse.checklvalue
    call      cc_parse.readassignexpr
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%rdi+52]
    lea       %r10,	[%rip+cc_decls.ttisref]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L4711
    mov       %rcx,	%r12
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      cc_parse.createassignopref
    jmp       L4700
L4711:
    mov       %rcx,	%rbx
    mov       %rdx,	%r13
    call      cc_parse.coercemode
    mov       %rbx,	%rax
    lea       %rax,	[%rip+cc_decls.ttconst]
    mov       %r10,	%r13
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L4713
    lea       %rcx,	[%rip+L8956]
    call      cc_support.terror
L4713:
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	52
    jnz       L4715
    mov       %rax,	[%rdi+16]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L4715
    lea       %rcx,	[%rip+L8957]
    call      cc_support.terror
L4715:
    lea       %rax,	[%rip+cc_tables.symboltojtag]
    mov       %r10,	%r12
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      cc_lib.createunit2
    mov       %rsi,	%rax
    mov       [%rsi+52],	%r13d
    mov       %rax,	%rsi
    jmp       L4700
L4708:
L4706:
    mov       %rax,	%rdi
L4700:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readcondexpr
cc_parse.readcondexpr:
#PROC1
#PROC2
#?>>
    .set cc_parse.readcondexpr.u, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    call      cc_parse.readorlexpr
    mov       %rsi,	%rax
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	19
    jnz       L4718
    mov       %rcx,	%rsi
    call      cc_parse.coercecond
    call      cc_lex.lex
    call      cc_parse.readexpression
    mov       %rdi,	%rax
    mov       %rcx,	10
    call      cc_lib.skipsymbol
    call      cc_parse.readcondexpr
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%rdi+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %r12,	%r10
    lea       %rax,	[%rip+cc_tables.dominantmode]
    mov       %r11,	%r10
    shl       %r11,	5
    lea       %rax,	[%rax + %r11]
    movsxd    %r10,	dword ptr[%rbx+52]
    lea       %r11,	[%rip+cc_decls.ttbasetype]
    movsx     %r11,	word ptr[%r11 + %r10*2]
    mov       %r13,	%r11
    movzx     %rax,	byte ptr[%rax + %r11]
    mov       [%rbp + cc_parse.readcondexpr.u],	%rax
    test      %rax,	%rax
    jz        L4720
    mov       %rcx,	%rdi
    mov       %rdx,	[%rbp + cc_parse.readcondexpr.u]
    call      cc_parse.coercemode
    mov       %rdi,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	[%rbp + cc_parse.readcondexpr.u]
    call      cc_parse.coercemode
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%rsi+40]
    cmp       %rax,	1
    jnz       L4722
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	1
    jnz       L4722
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L4722
    mov       %rax,	[%rsi]
    test      %rax,	%rax
    jz        L4724
    mov       %rax,	%rdi
    jmp       L4723
L4724:
    mov       %rax,	%rbx
L4723:
    jmp       L4716
L4722:
    jmp       L4719
L4720:
    cmp       %r12,	13
    jnz       L4725
    cmp       %r13,	13
    jnz       L4725
    movsxd    %rax,	dword ptr[%rdi+52]
    mov       [%rbp + cc_parse.readcondexpr.u],	%rax
    jmp       L4719
L4725:
    cmp       %r12,	13
    jnz       L4726
    cmp       %r13,	3
    jnz       L4726
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L4726
    mov       %rax,	[%rbx]
    test      %rax,	%rax
    jnz       L4726
    movsxd    %rax,	dword ptr[%rdi+52]
    mov       [%rbp + cc_parse.readcondexpr.u],	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	[%rbp + cc_parse.readcondexpr.u]
    call      cc_parse.coercemode
    jmp       L4719
L4726:
    cmp       %r12,	3
    jnz       L4727
    cmp       %r13,	13
    jnz       L4727
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	1
    jnz       L4727
    mov       %rax,	[%rdi]
    test      %rax,	%rax
    jnz       L4727
    movsxd    %rax,	dword ptr[%rbx+52]
    mov       [%rbp + cc_parse.readcondexpr.u],	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	[%rbp + cc_parse.readcondexpr.u]
    call      cc_parse.coercemode
    jmp       L4719
L4727:
    cmp       %r12,	18
    jnz       L4728
    cmp       %r13,	18
    jnz       L4728
    movsxd    %rax,	dword ptr[%rdi+52]
    mov       [%rbp + cc_parse.readcondexpr.u],	%rax
    jmp       L4719
L4728:
    cmp       %r12,	19
    jnz       L4729
    cmp       %r13,	19
    jnz       L4729
    movsxd    %rax,	dword ptr[%rdi+52]
    mov       [%rbp + cc_parse.readcondexpr.u],	%rax
    jmp       L4719
L4729:
    mov       %rax,	%r13
    cmp       %rax,	%r12
    jnz       L4730
    test      %rax,	%rax
    jnz       L4730
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readcondexpr.u],	%rax
    jmp       L4719
L4730:
    call      msys.m$print_startcon
    movsxd    %rax,	dword ptr[%rdi+52]
    mov       %rcx,	%rax
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    movsxd    %rax,	dword ptr[%rbx+52]
    mov       %rcx,	%rax
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8958]
    call      cc_support.terror
L4719:
    mov       %rcx,	31
    mov       %rdx,	%rsi
    mov       %r8,	%rdi
    mov       %r9,	%rbx
    call      cc_lib.createunit3
    mov       %rsi,	%rax
    mov       %eax,	[%rbp + cc_parse.readcondexpr.u]
    mov       [%rsi+52],	%eax
L4718:
    mov       %rax,	%rsi
L4716:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readorlexpr
cc_parse.readorlexpr:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    call      cc_parse.readandlexpr
    mov       %rdi,	%rax
    jmp       L4733
L4732:
    call      cc_lex.lex
    call      cc_parse.readandlexpr
    mov       %rbx,	%rax
    mov       %rcx,	%rdi
    call      cc_parse.coercecond
    mov       %rcx,	%rbx
    call      cc_parse.coercecond
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	1
    jnz       L4736
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L4736
    mov       %rax,	[%rdi]
    test      %rax,	%rax
    jnz       L4739
    mov       %rax,	[%rbx]
    test      %rax,	%rax
    jz        L4738
L4739:
    mov       %rax,	1
    jmp       L4737
L4738:
    xor       %eax,	%eax
L4737:
    mov       [%rdi],	%rax
    jmp       L4733
L4736:
    mov       %rcx,	25
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       %eax,	3
    mov       [%rdi+52],	%eax
L4733:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	31
    jz        L4732
    mov       %rax,	%rdi
L4731:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readandlexpr
cc_parse.readandlexpr:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    call      cc_parse.readiorexpr
    mov       %rdi,	%rax
    jmp       L4742
L4741:
    call      cc_lex.lex
    call      cc_parse.readiorexpr
    mov       %rbx,	%rax
    mov       %rcx,	%rdi
    call      cc_parse.coercecond
    mov       %rcx,	%rbx
    call      cc_parse.coercecond
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	1
    jnz       L4745
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L4745
    mov       %rax,	[%rdi]
    test      %rax,	%rax
    jz        L4747
    mov       %rax,	[%rbx]
    test      %rax,	%rax
    jz        L4747
    mov       %rax,	1
    jmp       L4746
L4747:
    xor       %eax,	%eax
L4746:
    mov       [%rdi],	%rax
    jmp       L4742
L4745:
    mov       %rcx,	24
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       %eax,	3
    mov       [%rdi+52],	%eax
L4742:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	32
    jz        L4741
    mov       %rax,	%rdi
L4740:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readiorexpr
cc_parse.readiorexpr:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    call      cc_parse.readixorexpr
    mov       %rdi,	%rax
    jmp       L4750
L4749:
    call      cc_lex.lex
    call      cc_parse.readixorexpr
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%rdi+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    lea       %rax,	[%rip+cc_tables.dominantmode]
    mov       %r11,	%r10
    shl       %r11,	5
    lea       %rax,	[%rax + %r11]
    movsxd    %r10,	dword ptr[%rbx+52]
    lea       %r11,	[%rip+cc_decls.ttbasetype]
    movsx     %r11,	word ptr[%r11 + %r10*2]
    movzx     %rax,	byte ptr[%rax + %r11]
    mov       %rsi,	%rax
    test      %rax,	%rax
    jz        L4753
    cmp       %rsi,	10
    jl        L4755
    lea       %rcx,	[%rip+L8959]
    call      cc_support.terror
L4755:
    mov       %rcx,	%rdi
    mov       %rdx,	%rsi
    call      cc_parse.coercemode
    mov       %rdi,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      cc_parse.coercemode
    mov       %rbx,	%rax
    jmp       L4752
L4753:
    lea       %rcx,	[%rip+L8960]
    call      cc_support.terror
L4752:
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	1
    jnz       L4757
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L4757
    mov       %rax,	%rsi
    cmp       %rax,	3
    jz        L4759
    cmp       %rax,	4
    jz        L4759
    cmp       %rax,	8
    jz        L4759
    cmp       %rax,	9
    jnz       L4760
L4759:
    mov       %rax,	[%rbx]
    mov       %r10,	%rdi
    or        [%r10],	%rax
    jmp       L4750
L4760:
L4758:
L4757:
    mov       %rcx,	45
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%esi
L4750:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	28
    jz        L4749
    mov       %rax,	%rdi
L4748:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readixorexpr
cc_parse.readixorexpr:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    call      cc_parse.readiandexpr
    mov       %rdi,	%rax
    jmp       L4763
L4762:
    call      cc_lex.lex
    call      cc_parse.readiandexpr
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%rdi+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    lea       %rax,	[%rip+cc_tables.dominantmode]
    mov       %r11,	%r10
    shl       %r11,	5
    lea       %rax,	[%rax + %r11]
    movsxd    %r10,	dword ptr[%rbx+52]
    lea       %r11,	[%rip+cc_decls.ttbasetype]
    movsx     %r11,	word ptr[%r11 + %r10*2]
    movzx     %rax,	byte ptr[%rax + %r11]
    mov       %rsi,	%rax
    test      %rax,	%rax
    jz        L4766
    cmp       %rsi,	10
    jl        L4768
    lea       %rcx,	[%rip+L8961]
    call      cc_support.terror
L4768:
    mov       %rcx,	%rdi
    mov       %rdx,	%rsi
    call      cc_parse.coercemode
    mov       %rdi,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      cc_parse.coercemode
    mov       %rbx,	%rax
    jmp       L4765
L4766:
    lea       %rcx,	[%rip+L8962]
    call      cc_support.terror
L4765:
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	1
    jnz       L4770
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L4770
    mov       %rax,	%rsi
    cmp       %rax,	3
    jz        L4772
    cmp       %rax,	4
    jz        L4772
    cmp       %rax,	8
    jz        L4772
    cmp       %rax,	9
    jnz       L4773
L4772:
    mov       %rax,	[%rbx]
    mov       %r10,	%rdi
    xor       [%r10],	%rax
    jmp       L4763
L4773:
L4771:
L4770:
    mov       %rcx,	46
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%esi
L4763:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	30
    jz        L4762
    mov       %rax,	%rdi
L4761:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readiandexpr
cc_parse.readiandexpr:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    call      cc_parse.readeqexpr
    mov       %rdi,	%rax
    jmp       L4776
L4775:
    call      cc_lex.lex
    call      cc_parse.readeqexpr
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%rdi+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    lea       %rax,	[%rip+cc_tables.dominantmode]
    mov       %r11,	%r10
    shl       %r11,	5
    lea       %rax,	[%rax + %r11]
    movsxd    %r10,	dword ptr[%rbx+52]
    lea       %r11,	[%rip+cc_decls.ttbasetype]
    movsx     %r11,	word ptr[%r11 + %r10*2]
    movzx     %rax,	byte ptr[%rax + %r11]
    mov       %rsi,	%rax
    test      %rax,	%rax
    jz        L4779
    cmp       %rsi,	10
    jl        L4781
    lea       %rcx,	[%rip+L8963]
    call      cc_support.terror
L4781:
    mov       %rcx,	%rdi
    mov       %rdx,	%rsi
    call      cc_parse.coercemode
    mov       %rdi,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      cc_parse.coercemode
    mov       %rbx,	%rax
    jmp       L4778
L4779:
    call      msys.m$print_startcon
    movsxd    %rax,	dword ptr[%rdi+52]
    mov       %rcx,	%rax
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    movsxd    %rax,	dword ptr[%rbx+52]
    mov       %rcx,	%rax
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8964]
    call      cc_support.terror
L4778:
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	1
    jnz       L4783
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L4783
    mov       %rax,	%rsi
    cmp       %rax,	3
    jz        L4785
    cmp       %rax,	4
    jz        L4785
    cmp       %rax,	8
    jz        L4785
    cmp       %rax,	9
    jnz       L4786
L4785:
    mov       %rax,	[%rbx]
    mov       %r10,	%rdi
    and       [%r10],	%rax
    jmp       L4776
L4786:
L4784:
L4783:
    mov       %rcx,	44
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%esi
L4776:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	29
    jz        L4775
    mov       %rax,	%rdi
L4774:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readeqexpr
cc_parse.readeqexpr:
#PROC1
#PROC2
#?>>
    .set cc_parse.readeqexpr.ss, -8
    .set cc_parse.readeqexpr.tt, -16
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    call      cc_parse.readrelexpr
    mov       %rdi,	%rax
    jmp       L4789
L4788:
    call      cc_lex.lex
    call      cc_parse.readrelexpr
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%rdi+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %r12,	%r10
    lea       %rax,	[%rip+cc_tables.dominantmode]
    mov       %r11,	%r10
    shl       %r11,	5
    lea       %rax,	[%rax + %r11]
    movsxd    %r10,	dword ptr[%rbx+52]
    lea       %r11,	[%rip+cc_decls.ttbasetype]
    movsx     %r11,	word ptr[%r11 + %r10*2]
    mov       %r13,	%r11
    movzx     %rax,	byte ptr[%rax + %r11]
    mov       %r14,	%rax
    test      %rax,	%rax
    jz        L4792
    mov       %rcx,	%rdi
    mov       %rdx,	%r14
    call      cc_parse.coercemode
    mov       %rdi,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	%r14
    call      cc_parse.coercemode
    mov       %rbx,	%rax
    jmp       L4791
L4792:
    cmp       %r12,	13
    jnz       L4793
    cmp       %r13,	13
    jnz       L4793
    movsxd    %rax,	dword ptr[%rdi+52]
    lea       %r10,	[%rip+cc_decls.tttarget]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       [%rbp + cc_parse.readeqexpr.ss],	%r10
    movsxd    %rax,	dword ptr[%rbx+52]
    lea       %r11,	[%rip+cc_decls.tttarget]
    movsx     %r11,	word ptr[%r11 + %rax*2]
    mov       [%rbp + cc_parse.readeqexpr.tt],	%r11
    cmp       %r10,	%r11
    jz        L4795
    mov       %rax,	[%rbp + cc_parse.readeqexpr.ss]
    test      %rax,	%rax
    jz        L4797
    mov       %rax,	[%rbp + cc_parse.readeqexpr.tt]
    test      %rax,	%rax
    jz        L4797
    movsxd    %rax,	dword ptr[%rbx+52]
    movsxd    %r10,	dword ptr[%rdi+52]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    mov       %r8,	1
    call      cc_parse.checkpointertypes
    test      %rax,	%rax
    jnz       L4799
    lea       %rcx,	[%rip+L8965]
    call      cc_support.terror
L4799:
L4797:
L4795:
    jmp       L4791
L4793:
    cmp       %r12,	13
    jnz       L4800
    cmp       %r13,	3
    jnz       L4800
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L4803
    mov       %rax,	[%rbx]
    test      %rax,	%rax
    jz        L4802
L4803:
    lea       %rcx,	[%rip+L8966]
    call      cc_support.terror
L4802:
    jmp       L4791
L4800:
    cmp       %r12,	3
    jnz       L4804
    cmp       %r13,	13
    jnz       L4804
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	1
    jnz       L4807
    mov       %rax,	[%rdi]
    test      %rax,	%rax
    jz        L4806
L4807:
    lea       %rcx,	[%rip+L8967]
    call      cc_support.terror
L4806:
    jmp       L4791
L4804:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L8968]
    call      msys.m$print_str_nf
    mov       %rcx,	%r14
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L8969]
    call      cc_support.terror
L4791:
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	1
    jnz       L4809
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L4809
    mov       %rax,	%r14
    cmp       %rax,	3
    jz        L4811
    cmp       %rax,	4
    jz        L4811
    cmp       %rax,	8
    jz        L4811
    cmp       %rax,	9
    jz        L4811
    test      %rax,	%rax
    jnz       L4812
L4811:
    cmp       %rsi,	40
    jnz       L4814
    mov       %rax,	[%rdi]
    mov       %r10,	[%rbx]
    cmp       %rax,	%r10
    setz      %al
    movzx     %eax,	%al
    mov       [%rdi],	%rax
    jmp       L4813
L4814:
    mov       %rax,	[%rdi]
    mov       %r10,	[%rbx]
    cmp       %rax,	%r10
    setnz     %al
    movzx     %eax,	%al
    mov       [%rdi],	%rax
L4813:
    jmp       L4789
L4812:
L4810:
L4809:
    lea       %rax,	[%rip+cc_tables.symboltojtag]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       %eax,	3
    mov       [%rdi+52],	%eax
L4789:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %rsi,	%rax
    cmp       %rax,	40
    jz        L4788
    cmp       %rsi,	41
    jz        L4788
    mov       %rax,	%rdi
L4787:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readrelexpr
cc_parse.readrelexpr:
#PROC1
#PROC2
#?>>
    .set cc_parse.readrelexpr.a, -8
    .set cc_parse.readrelexpr.b, -16
    .set cc_parse.readrelexpr.c, -24
    .set cc_parse.readrelexpr.aa, -32
    .set cc_parse.readrelexpr.bb, -40
    .set cc_parse.readrelexpr.cc, -48
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	80
#---------------
#PROC3
#PROC4
    call      cc_parse.readshiftexpr
    mov       %rdi,	%rax
    jmp       L4817
L4816:
    call      cc_lex.lex
    call      cc_parse.readshiftexpr
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%rdi+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %r12,	%r10
    lea       %rax,	[%rip+cc_tables.dominantmode]
    mov       %r11,	%r10
    shl       %r11,	5
    lea       %rax,	[%rax + %r11]
    movsxd    %r10,	dword ptr[%rbx+52]
    lea       %r11,	[%rip+cc_decls.ttbasetype]
    movsx     %r11,	word ptr[%r11 + %r10*2]
    mov       %r13,	%r11
    movzx     %rax,	byte ptr[%rax + %r11]
    mov       %r14,	%rax
    test      %rax,	%rax
    jz        L4820
    mov       %rcx,	%rdi
    mov       %rdx,	%r14
    call      cc_parse.coercemode
    mov       %rdi,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	%r14
    call      cc_parse.coercemode
    mov       %rbx,	%rax
    jmp       L4819
L4820:
    cmp       %r12,	13
    jnz       L4821
    cmp       %r13,	13
    jnz       L4821
    movsxd    %rax,	dword ptr[%rbx+52]
    movsxd    %r10,	dword ptr[%rdi+52]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    mov       %r8,	1
    call      cc_parse.checkpointertypes
    test      %rax,	%rax
    jnz       L4823
    lea       %rcx,	[%rip+L8970]
    call      cc_support.terror
L4823:
    jmp       L4819
L4821:
    lea       %rcx,	[%rip+L8971]
    call      cc_support.terror
L4819:
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	1
    jnz       L4825
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L4825
    mov       %rax,	[%rdi]
    mov       [%rbp + cc_parse.readrelexpr.a],	%rax
    mov       %rax,	[%rbx]
    mov       [%rbp + cc_parse.readrelexpr.b],	%rax
    mov       %rax,	%r14
    cmp       %rax,	3
    jz        L4827
    cmp       %rax,	4
    jz        L4827
    cmp       %rax,	8
    jz        L4828
    cmp       %rax,	9
    jz        L4828
    jmp       L4829
L4827:
    mov       %rax,	%rsi
    cmp       %rax,	42
    jz        L4831
    cmp       %rax,	43
    jz        L4832
    cmp       %rax,	44
    jz        L4833
    jmp       L4834
L4831:
    mov       %rax,	[%rbp + cc_parse.readrelexpr.a]
    cmp       %rax,	[%rbp + cc_parse.readrelexpr.b]
    setl      %al
    movzx     %eax,	%al
    mov       [%rbp + cc_parse.readrelexpr.c],	%rax
    jmp       L4830
L4832:
    mov       %rax,	[%rbp + cc_parse.readrelexpr.a]
    cmp       %rax,	[%rbp + cc_parse.readrelexpr.b]
    setle     %al
    movzx     %eax,	%al
    mov       [%rbp + cc_parse.readrelexpr.c],	%rax
    jmp       L4830
L4833:
    mov       %rax,	[%rbp + cc_parse.readrelexpr.a]
    cmp       %rax,	[%rbp + cc_parse.readrelexpr.b]
    setge     %al
    movzx     %eax,	%al
    mov       [%rbp + cc_parse.readrelexpr.c],	%rax
    jmp       L4830
L4834:
    mov       %rax,	[%rbp + cc_parse.readrelexpr.a]
    cmp       %rax,	[%rbp + cc_parse.readrelexpr.b]
    setg      %al
    movzx     %eax,	%al
    mov       [%rbp + cc_parse.readrelexpr.c],	%rax
L4830:
    mov       %rax,	[%rbp + cc_parse.readrelexpr.c]
    mov       [%rdi],	%rax
    jmp       L4817
L4828:
    mov       %rax,	[%rdi]
    mov       [%rbp + cc_parse.readrelexpr.aa],	%rax
    mov       %rax,	[%rbx]
    mov       [%rbp + cc_parse.readrelexpr.bb],	%rax
    mov       %rax,	%rsi
    cmp       %rax,	42
    jz        L4836
    cmp       %rax,	43
    jz        L4837
    cmp       %rax,	44
    jz        L4838
    jmp       L4839
L4836:
    mov       %rax,	[%rbp + cc_parse.readrelexpr.aa]
    cmp       %rax,	[%rbp + cc_parse.readrelexpr.bb]
    setb      %al
    movzx     %eax,	%al
    mov       [%rbp + cc_parse.readrelexpr.cc],	%rax
    jmp       L4835
L4837:
    mov       %rax,	[%rbp + cc_parse.readrelexpr.aa]
    cmp       %rax,	[%rbp + cc_parse.readrelexpr.bb]
    setbe     %al
    movzx     %eax,	%al
    mov       [%rbp + cc_parse.readrelexpr.cc],	%rax
    jmp       L4835
L4838:
    mov       %rax,	[%rbp + cc_parse.readrelexpr.aa]
    cmp       %rax,	[%rbp + cc_parse.readrelexpr.bb]
    setae     %al
    movzx     %eax,	%al
    mov       [%rbp + cc_parse.readrelexpr.cc],	%rax
    jmp       L4835
L4839:
    mov       %rax,	[%rbp + cc_parse.readrelexpr.aa]
    cmp       %rax,	[%rbp + cc_parse.readrelexpr.bb]
    seta      %al
    movzx     %eax,	%al
    mov       [%rbp + cc_parse.readrelexpr.cc],	%rax
L4835:
    mov       %rax,	[%rbp + cc_parse.readrelexpr.cc]
    mov       [%rdi],	%rax
    jmp       L4817
L4829:
L4826:
L4825:
    lea       %rax,	[%rip+cc_tables.symboltojtag]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       %eax,	3
    mov       [%rdi+52],	%eax
L4817:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %rsi,	%rax
    cmp       %rax,	42
    jz        L4816
    cmp       %rsi,	43
    jz        L4816
    cmp       %rsi,	44
    jz        L4816
    cmp       %rsi,	45
    jz        L4816
    mov       %rax,	%rdi
L4815:
#---------------
    add       %rsp,	80
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readshiftexpr
cc_parse.readshiftexpr:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    call      cc_parse.readaddexpr
    mov       %rdi,	%rax
    jmp       L4842
L4841:
    call      cc_lex.lex
    call      cc_parse.readaddexpr
    mov       %rbx,	%rax
    mov       %rcx,	%rdi
    call      cc_parse.coercebasetype
    movsxd    %rax,	dword ptr[%rdi+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %r12,	%r10
    cmp       %r10,	1
    jl        L4846
    cmp       %r12,	9
    jle       L4845
L4846:
    lea       %rcx,	[%rip+L8972]
    call      cc_support.terror
L4845:
    mov       %rcx,	%rbx
    mov       %rdx,	3
    call      cc_parse.coercemode
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	1
    jnz       L4848
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L4848
    mov       %rax,	%r12
    cmp       %rax,	3
    jz        L4850
    cmp       %rax,	4
    jz        L4850
    cmp       %rax,	8
    jz        L4851
    cmp       %rax,	9
    jz        L4851
    jmp       L4852
L4850:
    cmp       %rsi,	33
    jnz       L4854
    mov       %rax,	[%rdi]
    mov       %r10,	[%rbx]
    mov       %cl,	%r10b
    shl       %rax,	%cl
    mov       [%rdi],	%rax
    jmp       L4853
L4854:
    mov       %rax,	[%rdi]
    mov       %r10,	[%rbx]
    mov       %cl,	%r10b
    sar       %rax,	%cl
    mov       [%rdi],	%rax
L4853:
    jmp       L4842
L4851:
    cmp       %rsi,	33
    jnz       L4856
    mov       %rax,	[%rdi]
    mov       %r10,	[%rbx]
    mov       %cl,	%r10b
    shl       %rax,	%cl
    mov       [%rdi],	%rax
    jmp       L4855
L4856:
    mov       %rax,	[%rdi]
    mov       %r10,	[%rbx]
    mov       %cl,	%r10b
    shr       %rax,	%cl
    mov       [%rdi],	%rax
L4855:
    jmp       L4842
L4852:
L4849:
L4848:
    cmp       %rsi,	33
    jnz       L4858
    mov       %rax,	47
    jmp       L4857
L4858:
    mov       %rax,	48
L4857:
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%r12d
L4842:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %rsi,	%rax
    cmp       %rax,	33
    jz        L4841
    cmp       %rsi,	34
    jz        L4841
    mov       %rax,	%rdi
L4840:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readaddexpr
cc_parse.readaddexpr:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    call      cc_parse.readmulexpr
    mov       %rdi,	%rax
    jmp       L4861
L4860:
    call      cc_lex.lex
    call      cc_parse.readmulexpr
    mov       %rbx,	%rax
    cmp       %rsi,	23
    jnz       L4864
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      cc_parse.createaddop
    mov       %rdi,	%rax
    jmp       L4863
L4864:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      cc_parse.createsubop
    mov       %rdi,	%rax
L4863:
L4861:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %rsi,	%rax
    cmp       %rax,	23
    jz        L4860
    cmp       %rsi,	24
    jz        L4860
    mov       %rax,	%rdi
L4859:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readmulexpr
cc_parse.readmulexpr:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    call      cc_parse.readterm
    mov       %rdi,	%rax
    jmp       L4867
L4866:
    call      cc_lex.lex
    call      cc_parse.readterm
    mov       %rbx,	%rax
    mov       %rax,	%rsi
    cmp       %rax,	25
    jz        L4870
    cmp       %rax,	26
    jz        L4871
    cmp       %rax,	27
    jz        L4872
    jmp       L4873
L4870:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      cc_parse.createmulop
    mov       %rdi,	%rax
    jmp       L4869
L4871:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      cc_parse.createdivop
    mov       %rdi,	%rax
    jmp       L4869
L4872:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      cc_parse.createremop
    mov       %rdi,	%rax
L4873:
L4869:
L4867:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %rsi,	%rax
    cmp       %rax,	25
    jz        L4866
    cmp       %rsi,	26
    jz        L4866
    cmp       %rsi,	27
    jz        L4866
    mov       %rax,	%rdi
L4865:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readterm
cc_parse.readterm:
#PROC1
#PROC2
#?>>
    .set cc_parse.readterm.slength, -8
    .set cc_parse.readterm.fwide, -16
    .set cc_parse.readterm.tag, -24
    .set cc_parse.readterm.pbyte, -32
    .set cc_parse.readterm.a, -40
    .set cc_parse.readterm.d, -48
    .set cc_parse.readterm.ss, -56
    .set cc_parse.readterm.s, -64
    .set cc_parse.readterm.pm, -72
    .set cc_parse.readterm.av_1, -80
    .set cc_parse.readterm.$T3, -88
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	120
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    sub       %rax,	13
    cmp       %rax,	83
    jae       L4877
    lea       %r10,	[%rip+L4876]
    jmp       [%r10 + %rax*8]
    .data
L4876:
    .quad     L4924
    .quad     L4877
    .quad     L4877
    .quad     L4877
    .quad     L4877
    .quad     L4877
    .quad     L4877
    .quad     L4877
    .quad     L4877
    .quad     L4877
    .quad     L4911
    .quad     L4912
    .quad     L4921
    .quad     L4877
    .quad     L4877
    .quad     L4877
    .quad     L4917
    .quad     L4877
    .quad     L4877
    .quad     L4920
    .quad     L4877
    .quad     L4877
    .quad     L4916
    .quad     L4913
    .quad     L4922
    .quad     L4922
    .quad     L4923
    .quad     L4877
    .quad     L4877
    .quad     L4877
    .quad     L4877
    .quad     L4877
    .quad     L4877
    .quad     L4877
    .quad     L4877
    .quad     L4877
    .quad     L4877
    .quad     L4877
    .quad     L4877
    .quad     L4877
    .quad     L4877
    .quad     L4877
    .quad     L4877
    .quad     L4877
    .quad     L4877
    .quad     L4877
    .quad     L4878
    .quad     L4878
    .quad     L4903
    .quad     L4877
    .quad     L4897
    .quad     L4897
    .quad     L4877
    .quad     L4877
    .quad     L4879
    .quad     L4877
    .quad     L4877
    .quad     L4877
    .quad     L4877
    .quad     L4877
    .quad     L4877
    .quad     L4877
    .quad     L4877
    .quad     L4877
    .quad     L4877
    .quad     L4877
    .quad     L4877
    .quad     L4877
    .quad     L4877
    .quad     L4877
    .quad     L4877
    .quad     L4877
    .quad     L4877
    .quad     L4877
    .quad     L4877
    .quad     L4877
    .quad     L4877
    .quad     L4877
    .quad     L4929
    .quad     L4877
    .quad     L4940
    .quad     L4941
    .quad     L4942
    .text
L4878:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+22]
    lea       %r10,	[%rip+cc_decls.lx]
    mov       %r10,	[%r10]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      cc_lib.createconstunit
    mov       %rdi,	%rax
    call      cc_lex.lex
    jmp       L4875
L4879:
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	1
    jg        L4881
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       [%rbp + cc_parse.readterm.$T3],	%rax
    mov       %rax,	[%rip+cc_decls.currproc]
    test      %rax,	%rax
    jz        L4883
    mov       %rax,	[%rip+cc_decls.currproc]
    jmp       L4882
L4883:
    mov       %rax,	[%rip+cc_decls.stmodule]
L4882:
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + cc_parse.readterm.$T3]
    mov       %r8,	1
    mov       %r9,	[%rip+cc_decls.currblockno]
    call      cc_lib.resolvename
    mov       [%rbp + cc_parse.readterm.d],	%rax
    mov       %rax,	[%rbp + cc_parse.readterm.d]
    test      %rax,	%rax
    jnz       L4885
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    call      cc_lib.getstname
    lea       %rcx,	[%rip+L8973]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L4885:
    jmp       L4880
L4881:
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       [%rbp + cc_parse.readterm.d],	%rax
L4880:
    mov       %rax,	[%rbp + cc_parse.readterm.d]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	11
    jz        L4887
    cmp       %rax,	6
    jz        L4888
    jmp       L4889
L4887:
    mov       %rax,	[%rbp + cc_parse.readterm.d]
    movsxd    %rax,	dword ptr[%rax+88]
    mov       %rcx,	%rax
    mov       %rdx,	3
    call      cc_lib.createconstunit
    mov       %rdi,	%rax
    jmp       L4886
L4888:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	13
    jz        L4891
    mov       %rcx,	5
    call      cc_lib.createunit0
    mov       %rdi,	%rax
    mov       %rax,	[%rbp + cc_parse.readterm.d]
    mov       [%rdi],	%rax
    mov       %rax,	[%rbp + cc_parse.readterm.d]
    mov       %rax,	[%rax+80]
    mov       %r10,	[%rbp + cc_parse.readterm.d]
    movzx     %r10,	word ptr[%r10+102]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      cc_lib.createprocmode
    mov       %rcx,	%rax
    call      cc_lib.createrefmode
    mov       [%rdi+52],	%eax
    jmp       L4890
L4891:
    jmp       L4892
L4890:
    jmp       L4886
L4889:
#cc_parse.readterm.doname:
L4892:
    mov       %rcx,	[%rbp + cc_parse.readterm.d]
    call      cc_lib.createname
    mov       %rdi,	%rax
    mov       %rax,	[%rbp + cc_parse.readterm.d]
    movzx     %rax,	word ptr[%rax+102]
    mov       %rsi,	%rax
    mov       [%rdi+52],	%eax
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rsi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jnz       L4894
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8]
    mov       [%rdi+48],	%eax
    mov       %rcx,	%rdi
    call      cc_parse.createaddrofop
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%rsi
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rcx,	%rax
    call      cc_lib.createrefmode
    mov       [%rdi+52],	%eax
    jmp       L4893
L4894:
    mov       %rax,	[%rbp + cc_parse.readterm.d]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	6
    jz        L4895
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8]
    cmp       %rax,	4
    jge       L4895
    mov       %rcx,	%rdi
    call      cc_parse.fixmemopnd
    jmp       L4893
L4895:
    mov       %rax,	[%rbp + cc_parse.readterm.d]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	9
    jnz       L4896
L4896:
L4893:
L4886:
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %eax,	[%rax+16]
    mov       [%rdi+44],	%eax
    call      cc_lex.lex
    jmp       L4875
L4897:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	64
    setz      %al
    movzx     %eax,	%al
    mov       [%rbp + cc_parse.readterm.fwide],	%rax
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       [%rbp + cc_parse.readterm.s],	%rax
    lea       %rax,	[%rip+cc_decls.lx]
    movsxd    %rax,	dword ptr[%rax+24]
    mov       [%rbp + cc_parse.readterm.slength],	%rax
    jmp       L4899
L4898:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+24]
    mov       %r10,	[%rbp + cc_parse.readterm.slength]
    add       %r10,	%rax
    mov       %r14,	%r10
    lea       %rax,	[%r14+1]
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       [%rbp + cc_parse.readterm.ss],	%rax
    mov       %rcx,	[%rbp + cc_parse.readterm.ss]
    mov       %rdx,	[%rbp + cc_parse.readterm.s]
    mov       %r8,	[%rbp + cc_parse.readterm.slength]
    call      memcpy
    lea       %rax,	[%rip+cc_decls.nextlx]
    movsxd    %rax,	dword ptr[%rax+24]
    lea       %r10,	[%rip+cc_decls.nextlx]
    mov       %r10,	[%r10]
    mov       %r11,	[%rbp + cc_parse.readterm.ss]
    mov       %r15,	[%rbp + cc_parse.readterm.slength]
    lea       %r11,	[%r11 + %r15]
    mov       %rcx,	%r11
    mov       %rdx,	%r10
    mov       %r8,	%rax
    call      memcpy
    xor       %eax,	%eax
    mov       %r10,	[%rbp + cc_parse.readterm.ss]
    mov       %r11,	%r14
    mov       [%r10 + %r11],	%al
    mov       %rax,	[%rbp + cc_parse.readterm.ss]
    mov       [%rbp + cc_parse.readterm.s],	%rax
    mov       [%rbp + cc_parse.readterm.slength],	%r14
    call      cc_lex.lex
L4899:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	63
    jz        L4898
    mov       %rax,	[%rbp + cc_parse.readterm.fwide]
    test      %rax,	%rax
    jz        L4902
    mov       %rcx,	[%rbp + cc_parse.readterm.s]
    mov       %rdx,	[%rbp + cc_parse.readterm.slength]
    call      cc_lib.createwstringconstunit
    mov       %rdi,	%rax
    mov       %eax,	[%rbp + cc_parse.readterm.slength]
    mov       [%rdi+48],	%eax
    mov       %eax,	[%rip+cc_decls.trefwchar]
    mov       [%rdi+52],	%eax
    jmp       L4901
L4902:
    mov       %rcx,	[%rbp + cc_parse.readterm.s]
    mov       %rdx,	[%rbp + cc_parse.readterm.slength]
    call      cc_lib.createstringconstunit
    mov       %rdi,	%rax
    mov       %eax,	[%rbp + cc_parse.readterm.slength]
    mov       [%rdi+48],	%eax
    mov       %eax,	[%rip+cc_decls.trefchar]
    mov       [%rdi+52],	%eax
L4901:
    call      cc_lex.lex
    jmp       L4875
L4903:
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readterm.a],	%rax
    xor       %r13,	%r13
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       [%rbp + cc_parse.readterm.pbyte],	%rax
    lea       %rax,	[%rip+cc_decls.lx]
    movsxd    %rax,	dword ptr[%rax+24]
    cmp       %rax,	8
    jle       L4905
    lea       %rcx,	[%rip+L8974]
    call      cc_support.serror
L4905:
    lea       %rax,	[%rip+cc_decls.lx]
    movsxd    %rax,	dword ptr[%rax+24]
    mov       [%rbp + cc_parse.readterm.av_1],	%rax
    mov       %rax,	[%rbp + cc_parse.readterm.av_1]
    cmp       %rax,	0
    jle       L4908
L4906:
    mov       %rax,	[%rbp + cc_parse.readterm.pbyte]
    movzx     %rax,	byte ptr[%rax]
    mov       %cl,	%r13b
    shl       %rax,	%cl
    mov       %r10,	[%rbp + cc_parse.readterm.a]
    or        %r10,	%rax
    mov       [%rbp + cc_parse.readterm.a],	%r10
    mov       %rax,	8
    add       %r13,	%rax
    inc       qword ptr[%rbp + cc_parse.readterm.pbyte]
    dec       qword ptr[%rbp + cc_parse.readterm.av_1]
    jnz       L4906
L4908:
    lea       %rax,	[%rip+cc_decls.lx]
    movsxd    %rax,	dword ptr[%rax+24]
    cmp       %rax,	4
    jg        L4910
    mov       %rax,	3
    jmp       L4909
L4910:
    mov       %rax,	4
L4909:
    mov       %rcx,	[%rbp + cc_parse.readterm.a]
    mov       %rdx,	%rax
    call      cc_lib.createconstunit
    mov       %rdi,	%rax
    call      cc_lex.lex
    jmp       L4875
L4911:
    call      cc_lex.lex
    call      cc_parse.readterm
    mov       %rdi,	%rax
    jmp       L4875
L4912:
    call      cc_lex.lex
    call      cc_parse.readterm
    mov       %rcx,	%rax
    call      cc_parse.createnegop
    mov       %rdi,	%rax
    jmp       L4875
L4913:
    call      cc_lex.lex
    call      cc_parse.readterm
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    call      cc_parse.coercecond
    mov       %rcx,	26
    mov       %rdx,	%rdi
    call      cc_lib.createunit1
    mov       %rdi,	%rax
    mov       %eax,	3
    mov       [%rdi+52],	%eax
    mov       %rax,	[%rdi+16]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	26
    jnz       L4915
    mov       %rax,	[%rdi+16]
    mov       %rax,	[%rax+16]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	26
    jnz       L4915
    mov       %rax,	[%rdi+16]
    mov       %rax,	[%rax+16]
    mov       %rax,	[%rax+16]
    mov       [%rdi+16],	%rax
L4915:
    jmp       L4875
L4916:
    call      cc_lex.lex
    call      cc_parse.readterm
    mov       %rcx,	%rax
    call      cc_parse.createinotop
    mov       %rdi,	%rax
    jmp       L4875
L4917:
    call      cc_lex.lex
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	25
    jnz       L4919
    call      cc_lex.lex
    call      cc_parse.readterm
    mov       %rdi,	%rax
    jmp       L4918
L4919:
    call      cc_parse.readterm
    mov       %rcx,	%rax
    call      cc_parse.createaddrofop
    mov       %rdi,	%rax
L4918:
    jmp       L4875
L4920:
    lea       %rcx,	[%rip+L8975]
    call      cc_support.serror
    jmp       L4875
L4921:
    call      cc_lex.lex
    call      cc_parse.readterm
    mov       %rcx,	%rax
    call      cc_parse.createptrop
    mov       %rdi,	%rax
    jmp       L4875
L4922:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    lea       %r10,	[%rip+cc_tables.symboltojtag]
    movzx     %r10,	byte ptr[%r10 + %rax-1]
    mov       %r12,	%r10
    call      cc_lex.lex
    call      cc_parse.readterm
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_parse.createincrop
    mov       %rdi,	%rax
    jmp       L4875
L4923:
    call      cc_lex.lex
    mov       %rcx,	13
    call      cc_lib.skipsymbol
    call      cc_parse.readexpression
    mov       %rcx,	%rax
    call      cc_parse.createabsop
    mov       %rdi,	%rax
    mov       %rcx,	14
    call      cc_lib.skipsymbol
    jmp       L4875
L4924:
    call      cc_lex.lex
    call      cc_parse.istypestarter
    test      %rax,	%rax
    jz        L4926
    sub       %rsp,	8
    push      0
    lea       %rcx,	[%rbp + cc_parse.readterm.d]
    xor       %edx,	%edx
    lea       %r8,	[%rbp + cc_parse.readterm.pm]
    xor       %r9d,	%r9d
    sub       %rsp,	32
    call      cc_parse.readcasttype
    add       %rsp,	48
    mov       %rsi,	%rax
    mov       %rcx,	14
    call      cc_lib.skipsymbol
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	17
    jnz       L4928
    lea       %rcx,	[%rip+L8976]
    call      cc_support.serror
    jmp       L4927
L4928:
    call      cc_parse.readterm
    mov       %rcx,	%rax
    mov       %rdx,	%rsi
    mov       %r8,	1
    xor       %r9d,	%r9d
    call      cc_parse.docast
    mov       %rdi,	%rax
L4927:
    jmp       L4925
L4926:
    call      cc_parse.readexpression
    mov       %rdi,	%rax
    mov       %rcx,	14
    call      cc_lib.skipsymbol
L4925:
    jmp       L4875
L4929:
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %al,	[%rax+22]
    test      %al,	%al
    jz        L4931
    call      cc_lex.lex
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	13
    jnz       L4933
    call      cc_lex.lex
    call      cc_parse.istypestarter
    test      %rax,	%rax
    jz        L4935
    sub       %rsp,	8
    push      0
    lea       %rcx,	[%rbp + cc_parse.readterm.d]
    xor       %edx,	%edx
    lea       %r8,	[%rbp + cc_parse.readterm.pm]
    xor       %r9d,	%r9d
    sub       %rsp,	32
    call      cc_parse.readcasttype
    add       %rsp,	48
    mov       %rsi,	%rax
    mov       %rcx,	14
    call      cc_lib.skipsymbol
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8]
    mov       %rcx,	%rax
    mov       %rdx,	9
    call      cc_lib.createconstunit
    mov       %rdi,	%rax
    jmp       L4934
L4935:
    call      cc_parse.readexpression
    mov       %rdi,	%rax
    mov       %rcx,	14
    call      cc_lib.skipsymbol
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      cc_parse.createsizeofop
    mov       %rdi,	%rax
L4934:
    jmp       L4932
L4933:
    call      cc_parse.readterm
    mov       %rcx,	%rax
    mov       %rdx,	1
    call      cc_parse.createsizeofop
    mov       %rdi,	%rax
L4932:
    jmp       L4930
L4931:
    call      cc_lex.lex
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	13
    jnz       L4937
    call      cc_parse.istypestarter_next
    test      %rax,	%rax
    jz        L4939
    call      cc_lex.lex
    sub       %rsp,	8
    push      0
    lea       %rcx,	[%rbp + cc_parse.readterm.d]
    xor       %edx,	%edx
    lea       %r8,	[%rbp + cc_parse.readterm.pm]
    xor       %r9d,	%r9d
    sub       %rsp,	32
    call      cc_parse.readcasttype
    add       %rsp,	48
    mov       %rsi,	%rax
    mov       %rcx,	14
    call      cc_lib.skipsymbol
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8]
    mov       %rcx,	%rax
    mov       %rdx,	9
    call      cc_lib.createconstunit
    mov       %rdi,	%rax
    jmp       L4938
L4939:
    call      cc_parse.readterm
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      cc_parse.createsizeofop
    mov       %rdi,	%rax
L4938:
    jmp       L4936
L4937:
    call      cc_parse.readterm
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      cc_parse.createsizeofop
    mov       %rdi,	%rax
L4936:
L4930:
    jmp       L4875
L4940:
    call      cc_parse.readgeneric
    mov       %rdi,	%rax
    jmp       L4875
L4941:
    lea       %rcx,	[%rip+L8977]
    call      cc_support.serror
    jmp       L4875
L4942:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+22]
    mov       [%rbp + cc_parse.readterm.tag],	%rax
    call      cc_lex.lex
    mov       %rcx,	13
    call      cc_lib.checksymbol
    call      cc_lex.lex
    call      cc_parse.readassignexpr
    mov       %rdi,	%rax
    mov       %rax,	[%rbp + cc_parse.readterm.tag]
    cmp       %rax,	76
    jnz       L4944
    mov       %rcx,	8
    call      cc_lib.checksymbol
    call      cc_lex.lex
    call      cc_parse.readassignexpr
    mov       %rbx,	%rax
    jmp       L4943
L4944:
    xor       %rbx,	%rbx
L4943:
    mov       %rcx,	[%rbp + cc_parse.readterm.tag]
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       %eax,	3
    mov       [%rdi+52],	%eax
    mov       %rcx,	14
    call      cc_lib.checksymbol
    call      cc_lex.lex
    jmp       L4875
L4877:
    lea       %rcx,	[%rip+L8978]
    call      cc_lex.ps
    lea       %rcx,	[%rip+L8979]
    call      cc_support.serror
L4875:
L4945:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    sub       %rax,	2
    cmp       %rax,	37
    jae       L4948
    lea       %r10,	[%rip+L4947]
    jmp       [%r10 + %rax*8]
    .data
L4947:
    .quad     L4950
    .quad     L4950
    .quad     L4948
    .quad     L4948
    .quad     L4948
    .quad     L4948
    .quad     L4948
    .quad     L4948
    .quad     L4948
    .quad     L4948
    .quad     L4948
    .quad     L4951
    .quad     L4948
    .quad     L4949
    .quad     L4948
    .quad     L4948
    .quad     L4948
    .quad     L4948
    .quad     L4948
    .quad     L4948
    .quad     L4948
    .quad     L4948
    .quad     L4948
    .quad     L4948
    .quad     L4948
    .quad     L4948
    .quad     L4948
    .quad     L4948
    .quad     L4948
    .quad     L4948
    .quad     L4948
    .quad     L4948
    .quad     L4948
    .quad     L4948
    .quad     L4948
    .quad     L4954
    .quad     L4955
    .text
L4949:
    call      cc_lex.lex
    call      cc_parse.readexpression
    mov       %rbx,	%rax
    mov       %rcx,	16
    call      cc_lib.skipsymbol
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      cc_parse.createindexop
    mov       %rdi,	%rax
    jmp       L4945
L4950:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    lea       %r10,	[%rip+cc_tables.symboltojtag]
    movzx     %r10,	byte ptr[%r10 + %rax-1]
    mov       %r12,	%r10
    call      cc_lex.lex
    mov       %rcx,	67
    call      cc_lib.checksymbol
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       [%rbp + cc_parse.readterm.d],	%rax
    call      cc_lex.lex
    mov       %rcx,	%r12
    mov       %rdx,	%rdi
    mov       %r8,	[%rbp + cc_parse.readterm.d]
    call      cc_parse.createdotop
    mov       %rdi,	%rax
    jmp       L4945
L4951:
    call      cc_lex.lex
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	14
    jnz       L4953
    xor       %rbx,	%rbx
    call      cc_lex.lex
    jmp       L4952
L4953:
    xor       %ecx,	%ecx
    call      cc_parse.readexprlist
    mov       %rbx,	%rax
    mov       %rcx,	14
    call      cc_lib.skipsymbol
L4952:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      cc_parse.createcall
    mov       %rdi,	%rax
    jmp       L4945
L4954:
    call      cc_lex.lex
    mov       %rcx,	73
    mov       %rdx,	%rdi
    call      cc_parse.createincrop
    mov       %rdi,	%rax
    jmp       L4945
L4955:
    call      cc_lex.lex
    mov       %rcx,	74
    mov       %rdx,	%rdi
    call      cc_parse.createincrop
    mov       %rdi,	%rax
    jmp       L4945
L4948:
    jmp       L4946
L4946:
    mov       %rax,	%rdi
L4874:
#---------------
    add       %rsp,	120
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readexprlist
cc_parse.readexprlist:
#PROC1
#PROC2
#?>>
    .set cc_parse.readexprlist.ulist, -8
    .set cc_parse.readexprlist.ulistx, -16
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	56
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rax,	%rdi
    mov       [%rbp + cc_parse.readexprlist.ulistx],	%rax
    mov       [%rbp + cc_parse.readexprlist.ulist],	%rax
L4957:
    call      cc_parse.readassignexpr
    mov       %rdi,	%rax
    lea       %rcx,	[%rbp + cc_parse.readexprlist.ulist]
    lea       %rdx,	[%rbp + cc_parse.readexprlist.ulistx]
    mov       %r8,	%rdi
    call      cc_lib.addlistunit
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jnz       L4958
L4960:
    call      cc_lex.lex
    jmp       L4957
L4958:
    mov       %rax,	[%rbp + cc_parse.readexprlist.ulist]
L4956:
#---------------
    add       %rsp,	56
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readmodulevar
cc_parse.readmodulevar:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
#---------------
#PROC3
#PROC4
    mov       %rcx,	[%rip+cc_decls.stmodule]
    mov       %rdx,	%r12
    mov       %r8,	1
    xor       %r9d,	%r9d
    call      cc_lib.checkdupl
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L4963
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	7
    jz        L4965
    movzx     %rax,	byte ptr[%rdi+109]
    lea       %r10,	[%rip+cc_tables.namenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rax,	[%rdi]
    lea       %rcx,	[%rip+L8980]
    mov       %rdx,	%rax
    mov       %r8,	%r10
    call      cc_support.serror_ss
L4965:
    movzx     %rax,	word ptr[%rdi+102]
    mov       %rsi,	%rax
    cmp       %rsi,	%r13
    jz        L4967
    mov       %rcx,	%rsi
    mov       %rdx,	%r13
    call      cc_parse.comparemode
    test      %rax,	%rax
    jnz       L4969
#cc_parse.readmodulevar.redef:
L4970:
    mov       %rax,	[%rdi]
    lea       %rcx,	[%rip+L8981]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L4969:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rsi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jnz       L4973
L4972:
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8]
    test      %rax,	%rax
    jnz       L4975
    mov       [%rdi+102],	%r13w
    jmp       L4974
L4975:
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%r13
    mov       %rax,	[%rax + %r10*8]
    test      %rax,	%rax
    jz        L4976
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8]
    lea       %r10,	[%rip+cc_decls.ttlength]
    mov       %r11,	%r13
    mov       %r10,	[%r10 + %r11*8]
    cmp       %rax,	%r10
    jnz       L4970
L4976:
L4974:
L4973:
L4971:
L4967:
    mov       %r12,	%rdi
    movzx     %rax,	byte ptr[%r12+110]
    mov       %rbx,	%rax
    cmp       %rbx,	2
    jnz       L4980
    test      %r14,	%r14
    jz        L4979
L4980:
    cmp       %rbx,	4
    jnz       L4981
    cmp       %r14,	1
    jz        L4979
L4981:
    cmp       %rbx,	3
    jnz       L4978
    cmp       %r14,	1
    jnz       L4978
L4979:
    jmp       L4977
L4978:
    cmp       %rbx,	3
    jnz       L4982
    test      %r14,	%r14
    jnz       L4982
    mov       %rbx,	4
L4982:
L4977:
    jmp       L4962
L4963:
    mov       %rcx,	[%rip+cc_decls.stmodule]
    mov       %rdx,	%r12
    mov       %r8,	7
    call      cc_lib.createdupldef
    mov       %r12,	%rax
    mov       [%r12+102],	%r13w
    mov       %rax,	%r14
    cmp       %rax,	1
    jz        L4984
    cmp       %rax,	4
    jz        L4985
    jmp       L4986
L4984:
    mov       %rbx,	2
    jmp       L4983
L4985:
    mov       %rbx,	3
    jmp       L4983
L4986:
    mov       %rbx,	4
L4983:
L4962:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	11
    jnz       L4988
    mov       %rax,	[%r12+72]
    test      %rax,	%rax
    jz        L4990
    mov       %rax,	[%r12]
    lea       %rcx,	[%rip+L8982]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L4990:
    cmp       %rbx,	3
    jnz       L4992
    mov       %rax,	[%r12]
    lea       %rcx,	[%rip+L8983]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L4992:
    call      cc_lex.lex
    movzx     %rax,	word ptr[%r12+102]
    mov       %rcx,	[%rip+cc_decls.stmodule]
    mov       %rdx,	%rax
    call      cc_parse.readinitexpr
    mov       [%r12+72],	%rax
L4988:
    mov       [%r12+110],	%bl
    mov       %rax,	%r12
L4961:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readframevar
cc_parse.readframevar:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
#---------------
#PROC3
#PROC4
    mov       %rcx,	[%rip+cc_decls.currproc]
    mov       %rdx,	%r12
    mov       %r8,	1
    mov       %r9,	[%rip+cc_decls.currblockno]
    call      cc_lib.checkdupl_inproc
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L4995
    mov       %rax,	[%rdi]
    lea       %rcx,	[%rip+L8984]
    mov       %rdx,	%rax
    call      cc_support.serror_s
    mov       %r12,	%rdi
    movzx     %rax,	byte ptr[%r12+110]
    mov       %rbx,	%rax
    cmp       %rbx,	2
    jnz       L4999
    test      %r14,	%r14
    jz        L4998
L4999:
    cmp       %rbx,	4
    jnz       L5000
    cmp       %r14,	1
    jz        L4998
L5000:
    cmp       %rbx,	3
    jnz       L4997
    cmp       %r14,	1
    jnz       L4997
L4998:
    jmp       L4996
L4997:
    cmp       %rbx,	3
    jnz       L5001
    test      %r14,	%r14
    jnz       L5001
    mov       %rbx,	4
L5001:
L4996:
    jmp       L4994
L4995:
    mov       %rsi,	8
    mov       %rbx,	1
    mov       %rax,	%r14
    cmp       %rax,	1
    jz        L5003
    cmp       %rax,	4
    jz        L5004
    jmp       L5005
L5003:
    mov       %rsi,	7
    jmp       L5002
L5004:
    mov       %rbx,	3
    mov       %rsi,	7
L5005:
L5002:
    mov       %rcx,	[%rip+cc_decls.currproc]
    mov       %rdx,	%r12
    mov       %r8,	%rsi
    call      cc_lib.createdupldef
    mov       %r12,	%rax
    mov       [%r12+102],	%r13w
    mov       %ax,	[%rip+cc_decls.currblockno]
    mov       [%r12+96],	%ax
    mov       %eax,	1
    lea       %r10,	[%rip+cc_decls.blockcounts]
    mov       %r11,	[%rip+cc_decls.currblockno]
    mov       [%r10 + %r11*4],	%eax
L4994:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	11
    jnz       L5007
    mov       %rax,	[%r12+72]
    test      %rax,	%rax
    jz        L5009
    mov       %rax,	[%r12]
    lea       %rcx,	[%rip+L8985]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L5009:
    cmp       %rbx,	3
    jnz       L5011
    mov       %rax,	[%r12]
    lea       %rcx,	[%rip+L8986]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L5011:
    call      cc_lex.lex
    movzx     %rax,	word ptr[%r12+102]
    mov       %rcx,	[%rip+cc_decls.currproc]
    mov       %rdx,	%rax
    call      cc_parse.readinitexpr
    mov       [%r12+72],	%rax
L5007:
    mov       [%r12+110],	%bl
    mov       %rax,	%r12
L4993:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readtype
cc_parse.readtype:
#PROC1
#PROC2
#?>>
    .set cc_parse.readtype.modtype, -256
    .set cc_parse.readtype.modvalue, -512
    .set cc_parse.readtype.nmodifiers, -520
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	560
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
    mov       %r14,	%r9
#---------------
#PROC3
#PROC4
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readtype.nmodifiers],	%rax
    xor       %eax,	%eax
    mov       [%r14],	%rax
    sub       %rsp,	8
    lea       %rax,	[%rbp + cc_parse.readtype.nmodifiers]
    push      %rax
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    lea       %r8,	[%rbp + cc_parse.readtype.modtype]
    lea       %r9,	[%rbp + cc_parse.readtype.modvalue]
    sub       %rsp,	32
    call      cc_parse.readnamedtype
    add       %rsp,	48
    mov       %rbx,	[%rbp + cc_parse.readtype.nmodifiers]
    cmp       %rbx,	1
    jl        L5015
L5013:
    mov       %rax,	[%rbp + %rbx*8 + cc_parse.readtype.modtype-8]
    cmp       %rax,	65
    jz        L5017
    cmp       %rax,	82
    jz        L5018
    cmp       %rax,	67
    jz        L5019
    cmp       %rax,	70
    jz        L5020
    jmp       L5021
L5017:
    mov       %rax,	[%rbp + %rbx*8 + cc_parse.readtype.modvalue-8]
    mov       %rcx,	%r13
    mov       %rdx,	%rax
    call      cc_lib.createarraymode
    mov       %r13,	%rax
    jmp       L5016
L5018:
    mov       %rcx,	%r13
    call      cc_lib.createrefmode
    mov       %r13,	%rax
    jmp       L5016
L5019:
    mov       %rcx,	%r13
    call      cc_lib.createconstmode
    mov       %r13,	%rax
    jmp       L5016
L5020:
    mov       %rdi,	[%rbp + %rbx*8 + cc_parse.readtype.modvalue-8]
    cmp       %rbx,	1
    jnz       L5023
    mov       [%r14],	%rdi
    jmp       L5022
L5023:
    mov       %rcx,	%r13
    mov       %rdx,	%rdi
    call      cc_lib.createprocmode
    mov       %r13,	%rax
L5022:
L5021:
L5016:
    dec       %rbx
    cmp       %rbx,	1
    jge       L5013
L5015:
    mov       %rax,	%r13
L5012:
#---------------
    add       %rsp,	560
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readnamedtype
cc_parse.readnamedtype:
#PROC1
#PROC2
#?>>
    .set cc_parse.readnamedtype.modvalue, 88
    .set cc_parse.readnamedtype.nmodifiers, 96
    .set cc_parse.readnamedtype.fconst, -256
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	288
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
    mov       [%rbp+88],	%r9
#---------------
#PROC3
#PROC4
    xor       %eax,	%eax
    mov       [%r13],	%rax
    xor       %rbx,	%rbx
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	88
    jnz       L5026
    call      cc_lex.lex
L5026:
    jmp       L5028
L5027:
    inc       %rbx
    xor       %eax,	%eax
    mov       [%rbp + %rbx*8 + cc_parse.readnamedtype.fconst-8],	%rax
    call      cc_lex.lex
    jmp       L5031
L5030:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+22]
    cmp       %rax,	1
    jz        L5034
    cmp       %rax,	2
    jz        L5035
    cmp       %rax,	3
    jz        L5035
    jmp       L5036
L5034:
    mov       %rax,	1
    mov       [%rbp + %rbx*8 + cc_parse.readnamedtype.fconst-8],	%rax
    jmp       L5033
L5035:
    jmp       L5033
L5036:
    lea       %rcx,	[%rip+L8987]
    call      cc_support.serror
L5033:
    call      cc_lex.lex
L5031:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	86
    jz        L5030
L5028:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	25
    jz        L5027
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L5038
    cmp       %rax,	13
    jz        L5039
    jmp       L5040
L5038:
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       [%r13],	%rax
    call      cc_lex.lex
    jmp       L5037
L5039:
    call      cc_lex.lex
    sub       %rsp,	8
    push      qword ptr[%rbp + cc_parse.readnamedtype.nmodifiers]
    mov       %rcx,	%r12
    mov       %rdx,	%r13
    mov       %r8,	%r14
    mov       %r9,	[%rbp + cc_parse.readnamedtype.modvalue]
    sub       %rsp,	32
    call      cc_parse.readnamedtype
    add       %rsp,	48
    mov       %rcx,	14
    call      cc_lib.skipsymbol
L5040:
L5037:
L5041:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	15
    jz        L5043
    cmp       %rax,	13
    jz        L5044
    jmp       L5045
L5043:
    call      cc_lex.lex
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	16
    jnz       L5047
    xor       %rdi,	%rdi
    jmp       L5046
L5047:
    call      cc_parse.readassignexpr
    mov       %rsi,	%rax
    movsxd    %rax,	dword ptr[%rsi+40]
    cmp       %rax,	1
    jnz       L5049
    mov       %rdi,	[%rsi]
    jmp       L5048
L5049:
    lea       %rcx,	[%rip+L8988]
    call      cc_support.serror
L5048:
    mov       %rcx,	16
    call      cc_lib.checksymbol
    test      %rdi,	%rdi
    jnz       L5051
    lea       %rcx,	[%rip+L8989]
    call      cc_support.serror
L5051:
L5046:
    cmp       %rdi,	0
    jge       L5053
    lea       %rcx,	[%rip+L8990]
    call      cc_support.terror
L5053:
    call      cc_lex.lex
    mov       %rax,	[%rbp + cc_parse.readnamedtype.nmodifiers]
    inc       qword ptr[%rax]
    mov       %rax,	[%rax]
    mov       %r10,	65
    mov       [%r14 + %rax*8-8],	%r10
    mov       %rax,	[%rbp + cc_parse.readnamedtype.nmodifiers]
    mov       %rax,	[%rax]
    mov       %r10,	%rdi
    mov       %r11,	[%rbp + cc_parse.readnamedtype.modvalue]
    mov       [%r11 + %rax*8-8],	%r10
    jmp       L5041
L5044:
    call      cc_lex.lex
    mov       %rax,	[%rbp + cc_parse.readnamedtype.nmodifiers]
    inc       qword ptr[%rax]
    mov       %rax,	[%rax]
    mov       %r10,	70
    mov       [%r14 + %rax*8-8],	%r10
    mov       %rcx,	%r12
    call      cc_parse.readparams
    mov       %r10,	[%rbp + cc_parse.readnamedtype.nmodifiers]
    mov       %r10,	[%r10]
    mov       %r11,	[%rbp + cc_parse.readnamedtype.modvalue]
    mov       [%r11 + %r10*8-8],	%rax
    jmp       L5041
L5045:
    jmp       L5042
L5042:
    jmp       L5055
L5054:
    mov       %rax,	[%rbp + %rbx*8 + cc_parse.readnamedtype.fconst-8]
    test      %rax,	%rax
    jz        L5058
    mov       %rax,	[%rbp + cc_parse.readnamedtype.nmodifiers]
    inc       qword ptr[%rax]
    mov       %rax,	[%rax]
    mov       %r10,	67
    mov       [%r14 + %rax*8-8],	%r10
L5058:
    mov       %rax,	[%rbp + cc_parse.readnamedtype.nmodifiers]
    inc       qword ptr[%rax]
    mov       %rax,	[%rax]
    mov       %r10,	82
    mov       [%r14 + %rax*8-8],	%r10
    dec       %rbx
L5055:
    test      %rbx,	%rbx
    jnz       L5054
#---------------
    add       %rsp,	288
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readconstintexpr
cc_parse.readconstintexpr:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    call      cc_parse.readassignexpr
    mov       %rdi,	%rax
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	1
    jnz       L5062
L5061:
    mov       %rax,	[%rdi]
    jmp       L5059
L5062:
    movsxd    %rax,	dword ptr[%rdi+40]
    lea       %r10,	[%rip+cc_tables.jtagnames]
    mov       %r10,	[%r10 + %rax*8]
    lea       %rcx,	[%rip+L8991]
    mov       %rdx,	%r10
    call      cc_support.serror_s
L5060:
    xor       %eax,	%eax
L5059:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readinitexpr
cc_parse.readinitexpr:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	1
    call      cc_parse.readinitexpr2
    mov       %rdi,	%rax
    mov       %rax,	%rdi
L5063:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readinitexpr2
cc_parse.readinitexpr2:
#PROC1
#PROC2
#?>>
    .set cc_parse.readinitexpr2.m, 80
    .set cc_parse.readinitexpr2.istop, 88
    .set cc_parse.readinitexpr2.ulist, -8
    .set cc_parse.readinitexpr2.ulistx, -16
    .set cc_parse.readinitexpr2.d, -24
    .set cc_parse.readinitexpr2.e, -32
    .set cc_parse.readinitexpr2.braces, -40
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	72
    mov       %r15,	%rcx
    mov       [%rbp+80],	%rdx
    mov       [%rbp+88],	%r8
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	[%rbp + cc_parse.readinitexpr2.m]
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rbx,	%rax
    xor       %r14,	%r14
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	17
    jnz       L5066
    call      cc_lex.lex
    xor       %r14,	%r14
    mov       %rax,	%rbx
    cmp       %rax,	17
    jz        L5068
    cmp       %rax,	18
    jz        L5069
    cmp       %rax,	19
    jz        L5069
    jmp       L5070
L5068:
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	[%rbp + cc_parse.readinitexpr2.m]
    mov       %r13,	[%rax + %r10*8]
    mov       %rax,	[%rbp + cc_parse.readinitexpr2.istop]
    test      %rax,	%rax
    jnz       L5072
    test      %r13,	%r13
    jnz       L5072
    lea       %rcx,	[%rip+L8992]
    call      cc_support.terror
L5072:
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	[%rbp + cc_parse.readinitexpr2.m]
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rsi,	%rax
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rsi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	1
    jnz       L5074
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	63
    jnz       L5074
    mov       %rax,	1
    mov       [%rbp + cc_parse.readinitexpr2.braces],	%rax
    jmp       L5075
L5074:
    jmp       L5067
L5069:
    lea       %rax,	[%rip+cc_decls.ttnamedef]
    mov       %r10,	[%rbp + cc_parse.readinitexpr2.m]
    mov       %rax,	[%rax + %r10*8]
    mov       [%rbp + cc_parse.readinitexpr2.d],	%rax
    mov       %rax,	[%rbp + cc_parse.readinitexpr2.d]
    mov       %rax,	[%rax+16]
    mov       [%rbp + cc_parse.readinitexpr2.e],	%rax
    mov       %rax,	[%rbp + cc_parse.readinitexpr2.e]
    test      %rax,	%rax
    jnz       L5077
    lea       %rcx,	[%rip+L8993]
    call      cc_support.terror
L5077:
    mov       %rax,	[%rbp + cc_parse.readinitexpr2.e]
    movzx     %rax,	word ptr[%rax+102]
    mov       %rsi,	%rax
    jmp       L5067
L5070:
    call      cc_parse.readassignexpr
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	[%rbp + cc_parse.readinitexpr2.m]
    call      cc_parse.coercemode
    mov       %rdi,	%rax
    mov       %rcx,	18
    call      cc_lib.skipsymbol
    mov       %rax,	%rdi
    jmp       L5064
L5067:
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readinitexpr2.ulistx],	%rax
    mov       [%rbp + cc_parse.readinitexpr2.ulist],	%rax
L5078:
    mov       %rcx,	%r15
    mov       %rdx,	%rsi
    xor       %r8d,	%r8d
    call      cc_parse.readinitexpr2
    mov       %rdi,	%rax
    inc       %r14
    mov       %rax,	%rbx
    cmp       %rax,	17
    jz        L5081
    cmp       %rax,	18
    jz        L5082
    cmp       %rax,	19
    jz        L5083
    jmp       L5084
L5081:
    test      %r13,	%r13
    jz        L5086
    cmp       %r14,	%r13
    jle       L5086
    lea       %rcx,	[%rip+L8994]
    call      cc_support.terror
L5086:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rsi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jnz       L5088
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%rsi
    movsx     %rax,	word ptr[%rax + %r10*2]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    cmp       %r10,	1
    jnz       L5088
    movsxd    %rax,	dword ptr[%rdi+52]
    cmp       %rax,	[%rip+cc_decls.trefchar]
    jz        L5087
L5088:
    mov       %rcx,	%rdi
    mov       %rdx,	%rsi
    call      cc_parse.coercemode
    mov       %rdi,	%rax
L5087:
    jmp       L5080
L5082:
    mov       %rax,	[%rbp + cc_parse.readinitexpr2.e]
    movzx     %rax,	word ptr[%rax+102]
    mov       %r12,	%rax
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%r12
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jnz       L5090
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%r12
    movsx     %rax,	word ptr[%rax + %r10*2]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    cmp       %r10,	6
    jnz       L5090
    movsxd    %rax,	dword ptr[%rdi+52]
    cmp       %rax,	[%rip+cc_decls.trefchar]
    jz        L5089
L5090:
    mov       %rcx,	%rdi
    mov       %rdx,	%r12
    call      cc_parse.coercemode
    mov       %rdi,	%rax
L5089:
    mov       %rax,	[%rbp + cc_parse.readinitexpr2.e]
    mov       %rax,	[%rax+32]
    mov       [%rbp + cc_parse.readinitexpr2.e],	%rax
    mov       %rax,	[%rbp + cc_parse.readinitexpr2.e]
    test      %rax,	%rax
    jnz       L5092
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jnz       L5094
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	18
    jz        L5094
    lea       %rcx,	[%rip+L8995]
    call      cc_support.terror
L5094:
    jmp       L5091
L5092:
    mov       %rax,	[%rbp + cc_parse.readinitexpr2.e]
    movzx     %rax,	word ptr[%rax+102]
    mov       %rsi,	%rax
L5091:
    jmp       L5080
L5083:
    mov       %rcx,	%rdi
    mov       %rdx,	%rsi
    call      cc_parse.coercemode
    mov       %rdi,	%rax
    mov       %rax,	%rdi
    mov       [%rbp + cc_parse.readinitexpr2.ulistx],	%rax
    mov       [%rbp + cc_parse.readinitexpr2.ulist],	%rax
    jmp       L5095
L5084:
L5080:
    lea       %rcx,	[%rbp + cc_parse.readinitexpr2.ulist]
    lea       %rdx,	[%rbp + cc_parse.readinitexpr2.ulistx]
    mov       %r8,	%rdi
    call      cc_lib.addlistunit
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jnz       L5079
L5097:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	18
    jnz       L5099
    call      cc_lex.lex
    jmp       L5079
L5099:
    call      cc_lex.lex
    jmp       L5078
L5079:
    cmp       %rbx,	17
    jnz       L5101
    test      %r13,	%r13
    jnz       L5101
    mov       %rax,	%r14
    lea       %r10,	[%rip+cc_decls.ttlength]
    mov       %r11,	[%rbp + cc_parse.readinitexpr2.m]
    mov       [%r10 + %r11*8],	%rax
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8]
    mov       %r10,	%r14
    imul      %r10,	%rax
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r11,	[%rbp + cc_parse.readinitexpr2.m]
    mov       [%rax + %r11*8],	%r10
L5101:
#cc_parse.readinitexpr2.donestruct:
L5095:
    mov       %rcx,	18
    call      cc_lib.skipsymbol
    mov       %rcx,	28
    mov       %rdx,	[%rbp + cc_parse.readinitexpr2.ulist]
    call      cc_lib.createunit1
    mov       %rdi,	%rax
    mov       [%rdi+48],	%r14d
    mov       %eax,	[%rbp + cc_parse.readinitexpr2.m]
    mov       [%rdi+52],	%eax
    jmp       L5065
L5066:
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readinitexpr2.braces],	%rax
    cmp       %rbx,	17
    jnz       L5104
L5103:
#cc_parse.readinitexpr2.doarraystring:
L5075:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	63
    jz        L5106
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	64
    jz        L5106
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	[%rbp + cc_parse.readinitexpr2.m]
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	1
    jz        L5106
    lea       %rcx,	[%rip+L8996]
    call      cc_support.terror
L5106:
    call      cc_parse.readassignexpr
    mov       %rdi,	%rax
    movsxd    %rax,	dword ptr[%rdi+52]
    cmp       %rax,	[%rip+cc_decls.trefchar]
    jz        L5108
    cmp       %rax,	[%rip+cc_decls.trefwchar]
    jz        L5109
    jmp       L5110
L5108:
    jmp       L5107
L5109:
    jmp       L5107
L5110:
    lea       %rcx,	[%rip+L8997]
    call      cc_support.terror
L5107:
    mov       %eax,	[%rbp + cc_parse.readinitexpr2.m]
    mov       [%rdi+52],	%eax
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	[%rbp + cc_parse.readinitexpr2.m]
    mov       %rax,	[%rax + %r10*8]
    mov       %r13,	%rax
    test      %rax,	%rax
    jnz       L5112
    movsxd    %rax,	dword ptr[%rdi+48]
    inc       %rax
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r11,	[%rbp + cc_parse.readinitexpr2.m]
    mov       [%r10 + %r11*8],	%rax
    lea       %r10,	[%rip+cc_decls.ttlength]
    mov       %r11,	[%rbp + cc_parse.readinitexpr2.m]
    mov       [%r10 + %r11*8],	%rax
    jmp       L5111
L5112:
    movsxd    %rax,	dword ptr[%rdi+48]
    cmp       %rax,	%r13
    jle       L5114
    lea       %rcx,	[%rip+L8998]
    call      cc_support.terror
L5114:
L5111:
    mov       %rax,	[%rbp + cc_parse.readinitexpr2.braces]
    test      %rax,	%rax
    jz        L5116
    mov       %rcx,	18
    call      cc_lib.skipsymbol
L5116:
    mov       %rax,	%rdi
    jmp       L5064
L5104:
L5102:
    call      cc_parse.readassignexpr
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	[%rbp + cc_parse.readinitexpr2.m]
    call      cc_parse.coercemode
    mov       %rdi,	%rax
L5065:
    mov       %rax,	%rdi
L5064:
#---------------
    add       %rsp,	72
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.pushblock
cc_parse.pushblock:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+cc_decls.blocklevel]
    cmp       %rax,	100
    jl        L5119
    lea       %rcx,	[%rip+L8999]
    call      cc_support.serror
L5119:
    mov       %rax,	[%rip+cc_decls.nextblockno]
    cmp       %rax,	2100
    jl        L5121
    lea       %rcx,	[%rip+L9000]
    call      cc_support.serror
L5121:
    inc       qword ptr[%rip+cc_decls.blocklevel]
    inc       qword ptr[%rip+cc_decls.nextblockno]
    mov       %rdi,	[%rip+cc_decls.currblockno]
    mov       %rbx,	[%rip+cc_decls.blocklevel]
    jmp       L5123
L5122:
    dec       %rbx
    lea       %rax,	[%rip+cc_decls.blockstack]
    mov       %r10,	%rbx
    movsxd    %rax,	dword ptr[%rax + %r10*4]
    mov       %rdi,	%rax
L5123:
    test      %rbx,	%rbx
    jz        L5125
    lea       %rax,	[%rip+cc_decls.blockstack]
    mov       %r10,	%rbx
    movsxd    %rax,	dword ptr[%rax + %r10*4]
    lea       %r10,	[%rip+cc_decls.blockcounts]
    movsxd    %r10,	dword ptr[%r10 + %rax*4]
    test      %r10,	%r10
    jz        L5122
L5125:
    mov       %eax,	%edi
    lea       %r10,	[%rip+cc_decls.blockowner]
    mov       %r11,	[%rip+cc_decls.nextblockno]
    mov       [%r10 + %r11*4],	%eax
    mov       %eax,	[%rip+cc_decls.nextblockno]
    lea       %r10,	[%rip+cc_decls.blockstack]
    mov       %r11,	[%rip+cc_decls.blocklevel]
    mov       [%r10 + %r11*4],	%eax
    mov       [%rip+cc_decls.currblockno],	%rax
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_decls.blockcounts]
    mov       %r11,	[%rip+cc_decls.currblockno]
    mov       [%r10 + %r11*4],	%eax
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.popblock
cc_parse.popblock:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    dec       qword ptr[%rip+cc_decls.blocklevel]
    mov       %rax,	[%rip+cc_decls.blocklevel]
    lea       %r10,	[%rip+cc_decls.blockstack]
    movsxd    %r10,	dword ptr[%r10 + %rax*4]
    mov       [%rip+cc_decls.currblockno],	%r10
#---------------
    ret       
# End 
# Proc cc_parse.readcompoundstmt
cc_parse.readcompoundstmt:
#PROC1
#PROC2
#?>>
    .set cc_parse.readcompoundstmt.ulist, -8
    .set cc_parse.readcompoundstmt.ulistx, -16
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	56
    mov       %rsi,	%rcx
#---------------
#PROC3
#PROC4
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readcompoundstmt.ulistx],	%rax
    mov       [%rbp + cc_parse.readcompoundstmt.ulist],	%rax
    call      cc_lex.lex
    call      cc_parse.pushblock
    test      %rsi,	%rsi
    jz        L5129
    mov       %eax,	1
    lea       %r10,	[%rip+cc_decls.blockcounts]
    mov       [%r10+4],	%eax
L5129:
    jmp       L5131
L5130:
    call      cc_parse.readstatement
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L5134
    jmp       L5131
L5134:
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	7
    jnz       L5136
L5137:
    mov       %rbx,	[%rdi+8]
    mov       %rax,	[%rdi]
    mov       %rax,	[%rax+72]
    test      %rax,	%rax
    jz        L5141
    mov       %rax,	[%rdi]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	7
    jz        L5141
    mov       %eax,	8
    mov       [%rdi+40],	%eax
    xor       %eax,	%eax
    mov       [%rdi+8],	%rax
    lea       %rcx,	[%rbp + cc_parse.readcompoundstmt.ulist]
    lea       %rdx,	[%rbp + cc_parse.readcompoundstmt.ulistx]
    mov       %r8,	%rdi
    call      cc_lib.addlistunit
L5141:
    mov       %rdi,	%rbx
    test      %rdi,	%rdi
    jnz       L5137
    jmp       L5135
L5136:
    lea       %rcx,	[%rbp + cc_parse.readcompoundstmt.ulist]
    lea       %rdx,	[%rbp + cc_parse.readcompoundstmt.ulistx]
    mov       %r8,	%rdi
    call      cc_lib.addlistunit
L5135:
L5131:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	18
    jnz       L5130
    call      cc_lex.lex
    call      cc_parse.popblock
    mov       %rcx,	6
    mov       %rdx,	[%rbp + cc_parse.readcompoundstmt.ulist]
    xor       %r8d,	%r8d
    mov       %r9,	[%rbp + cc_parse.readcompoundstmt.ulistx]
    call      cc_lib.createunit3
L5127:
#---------------
    add       %rsp,	56
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readblock
cc_parse.readblock:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    call      cc_parse.readstatement
    jmp       L5142
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	71
    jnz       L5144
    test      %rdi,	%rdi
    jz        L5144
    call      cc_parse.readstatement
    jmp       L5142
L5144:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	17
    jz        L5146
    lea       %rcx,	[%rip+L9001]
    call      cc_support.serror
L5146:
    xor       %ecx,	%ecx
    call      cc_parse.readcompoundstmt
L5142:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readstatement
cc_parse.readstatement:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    sub       %rax,	9
    cmp       %rax,	82
    jae       L5150
    lea       %r10,	[%rip+L5149]
    jmp       [%r10 + %rax*8]
    .data
L5149:
    .quad     L5173
    .quad     L5150
    .quad     L5150
    .quad     L5150
    .quad     L5150
    .quad     L5150
    .quad     L5150
    .quad     L5150
    .quad     L5157
    .quad     L5150
    .quad     L5150
    .quad     L5150
    .quad     L5150
    .quad     L5150
    .quad     L5150
    .quad     L5150
    .quad     L5150
    .quad     L5150
    .quad     L5150
    .quad     L5150
    .quad     L5150
    .quad     L5150
    .quad     L5150
    .quad     L5150
    .quad     L5150
    .quad     L5150
    .quad     L5150
    .quad     L5150
    .quad     L5150
    .quad     L5150
    .quad     L5150
    .quad     L5150
    .quad     L5150
    .quad     L5150
    .quad     L5150
    .quad     L5150
    .quad     L5150
    .quad     L5150
    .quad     L5150
    .quad     L5150
    .quad     L5150
    .quad     L5150
    .quad     L5150
    .quad     L5150
    .quad     L5150
    .quad     L5150
    .quad     L5150
    .quad     L5150
    .quad     L5150
    .quad     L5150
    .quad     L5150
    .quad     L5150
    .quad     L5150
    .quad     L5150
    .quad     L5150
    .quad     L5150
    .quad     L5150
    .quad     L5150
    .quad     L5174
    .quad     L5150
    .quad     L5150
    .quad     L5190
    .quad     L5151
    .quad     L5150
    .quad     L5171
    .quad     L5172
    .quad     L5152
    .quad     L5153
    .quad     L5154
    .quad     L5155
    .quad     L5159
    .quad     L5164
    .quad     L5158
    .quad     L5156
    .quad     L5190
    .quad     L5190
    .quad     L5190
    .quad     L5190
    .quad     L5190
    .quad     L5190
    .quad     L5150
    .quad     L5190
    .text
L5151:
    call      cc_parse.readifstmt
    jmp       L5147
L5152:
    call      cc_parse.readforstmt
    jmp       L5147
L5153:
    call      cc_parse.readwhilestmt
    jmp       L5147
L5154:
    call      cc_parse.readdostmt
    jmp       L5147
L5155:
    call      cc_parse.readreturnstmt
    jmp       L5147
L5156:
    call      cc_parse.readswitchstmt
    jmp       L5147
L5157:
    xor       %ecx,	%ecx
    call      cc_parse.readcompoundstmt
    jmp       L5147
L5158:
    call      cc_parse.readgotostmt
    jmp       L5147
L5159:
    mov       %rax,	[%rip+cc_parse.loopindex]
    test      %rax,	%rax
    jz        L5161
    lea       %rax,	[%rip+cc_parse.looptypestack]
    mov       %r10,	[%rip+cc_parse.loopindex]
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	76
    jnz       L5163
    mov       %rcx,	20
    call      cc_lib.createunit0
    mov       %rdi,	%rax
    call      cc_lex.lex
    jmp       L5162
L5163:
    mov       %rcx,	23
    call      cc_lib.createunit0
    mov       %rdi,	%rax
    call      cc_lex.lex
L5162:
    jmp       L5160
L5161:
    lea       %rcx,	[%rip+L9002]
    call      cc_support.serror
L5160:
    jmp       L5148
L5164:
    mov       %rsi,	[%rip+cc_parse.loopindex]
    jmp       L5166
L5165:
    dec       %rsi
L5166:
    test      %rsi,	%rsi
    jz        L5168
    lea       %rax,	[%rip+cc_parse.looptypestack]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	76
    jnz       L5165
L5168:
    test      %rsi,	%rsi
    jnz       L5170
    lea       %rcx,	[%rip+L9003]
    call      cc_support.serror
L5170:
    mov       %rcx,	21
    call      cc_lib.createunit0
    mov       %rdi,	%rax
    call      cc_lex.lex
    jmp       L5148
L5171:
    call      cc_parse.readcaselabel
    jmp       L5147
L5172:
    call      cc_lex.lex
    mov       %rcx,	10
    call      cc_lib.skipsymbol
    call      cc_parse.readstatement
    mov       %rcx,	19
    mov       %rdx,	%rax
    call      cc_lib.createunit1
    jmp       L5147
L5173:
    call      cc_lex.lex
    xor       %eax,	%eax
    jmp       L5147
L5174:
    lea       %rax,	[%rip+cc_decls.nextlx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	10
    jnz       L5176
    mov       %rcx,	17
    xor       %edx,	%edx
    call      cc_lib.createunit1
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       %rcx,	[%rip+cc_decls.currproc]
    mov       %rdx,	%rax
    mov       %r8,	3
    xor       %r9d,	%r9d
    call      cc_lib.resolvename
    mov       %rbx,	%rax
    test      %rbx,	%rbx
    jz        L5178
    movsxd    %rax,	dword ptr[%rbx+88]
    cmp       %rax,	-1
    jnz       L5180
    call      msys.m$print_startcon
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L9004]
    call      cc_support.terror
L5180:
    jmp       L5177
L5178:
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       %rcx,	[%rip+cc_decls.currproc]
    mov       %rdx,	%rax
    mov       %r8,	14
    call      cc_lib.createdupldef
    mov       %rbx,	%rax
    xor       %eax,	%eax
    mov       [%rbx+102],	%ax
L5177:
    mov       %eax,	4294967295
    mov       [%rbx+88],	%eax
    mov       [%rdi],	%rbx
    call      cc_lex.lex
    call      cc_lex.lex
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	18
    jz        L5181
L5182:
    call      cc_parse.istypestarter
    test      %rax,	%rax
    jnz       L5184
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	85
    jnz       L5183
L5184:
    jmp       L5181
L5183:
    call      cc_parse.readstatement
    mov       [%rdi+16],	%rax
L5181:
    mov       %rax,	%rdi
    jmp       L5147
L5176:
    xor       %eax,	%eax
    mov       [%rip+cc_parse.ist_symptr],	%rax
    mov       %rcx,	[%rip+cc_decls.currproc]
    call      cc_parse.isusertype
    cmp       %rax,	20
    jnz       L5187
L5186:
    mov       %rax,	[%rip+cc_parse.ist_symptr]
    test      %rax,	%rax
    jz        L5189
    mov       %rax,	[%rip+cc_parse.ist_symptr]
    lea       %r10,	[%rip+cc_decls.lx]
    mov       [%r10],	%rax
L5189:
    call      cc_parse.readexpression
    mov       %rdi,	%rax
L5175:
    jmp       L5148
L5190:
#cc_parse.readstatement.doreaddecl:
L5187:
    call      cc_parse.readlocaldecl
    jmp       L5147
L5150:
    call      cc_parse.readexpression
    mov       %rdi,	%rax
L5148:
    mov       %rcx,	9
    call      cc_lib.skipsymbol
    mov       %rax,	%rdi
L5147:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readifstmt
cc_parse.readifstmt:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    call      cc_lex.lex
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %eax,	[%rax+16]
    mov       %r13,	%rax
    call      cc_parse.readcond
    mov       %rbx,	%rax
    mov       %rcx,	%rbx
    call      cc_parse.coercecond
    xor       %ecx,	%ecx
    call      cc_parse.readblock
    mov       %rsi,	%rax
    xor       %r12,	%r12
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	72
    jnz       L5193
    call      cc_lex.lex
    mov       %rcx,	1
    call      cc_parse.readblock
    mov       %r12,	%rax
L5193:
    mov       %rcx,	12
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    mov       %r9,	%r12
    call      cc_lib.createunit3
    mov       %rdi,	%rax
    mov       [%rdi+44],	%r13d
    mov       %rcx,	%rbx
    call      cc_parse.iscondtrue
    test      %rax,	%rax
    jz        L5195
    test      %rsi,	%rsi
    jnz       L5197
    mov       %rcx,	6
    call      cc_lib.createunit0
    mov       %rsi,	%rax
L5197:
    mov       %rcx,	%rdi
    mov       %rdx,	%rsi
    call      cc_parse.deleteunit
    jmp       L5194
L5195:
    mov       %rcx,	%rbx
    call      cc_parse.iscondfalse
    test      %rax,	%rax
    jz        L5198
    test      %r12,	%r12
    jnz       L5200
    mov       %rcx,	6
    call      cc_lib.createunit0
    mov       %r12,	%rax
L5200:
    mov       %rcx,	%rdi
    mov       %rdx,	%r12
    call      cc_parse.deleteunit
L5198:
L5194:
    mov       %rax,	%rdi
L5191:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.iscondtrue
cc_parse.iscondtrue:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    movsxd    %rax,	dword ptr[%rcx+40]
    cmp       %rax,	1
    jnz       L5202
    mov       %rax,	[%rcx]
    test      %rax,	%rax
    jz        L5202
    mov       %rax,	1
    jmp       L5203
L5202:
    xor       %eax,	%eax
L5203:
L5201:
#---------------
    ret       
# End 
# Proc cc_parse.iscondfalse
cc_parse.iscondfalse:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    movsxd    %rax,	dword ptr[%rcx+40]
    cmp       %rax,	1
    jnz       L5205
    mov       %rax,	[%rcx]
    test      %rax,	%rax
    jnz       L5205
    mov       %rax,	1
    jmp       L5206
L5205:
    xor       %eax,	%eax
L5206:
L5204:
#---------------
    ret       
# End 
# Proc cc_parse.deleteunit
cc_parse.deleteunit:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	16
#---------------
#PROC3
#PROC4
    mov       %rdi,	[%rcx+8]
    mov       %rax,	%rdx
    push      %rcx
    mov       %r11,	8
L9005:
    mov       %r10,	[%rax]
    mov       [%rcx],	%r10
    add       %rcx,	8
    add       %rax,	8
    dec       %r11
    jnz       L9005
    pop       %rcx
    mov       [%rcx+8],	%rdi
#---------------
    add       %rsp,	16
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readforstmt
cc_parse.readforstmt:
#PROC1
#PROC2
#?>>
    .set cc_parse.readforstmt.ulist, -8
    .set cc_parse.readforstmt.ulistx, -16
    .set cc_parse.readforstmt.linkage, -24
    .set cc_parse.readforstmt.m, -32
    .set cc_parse.readforstmt.mbase, -40
    .set cc_parse.readforstmt.pm, -48
    .set cc_parse.readforstmt.d, -56
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	96
#---------------
#PROC3
#PROC4
    call      cc_lex.lex
    mov       %rcx,	13
    call      cc_lib.skipsymbol
    xor       %r14,	%r14
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	9
    jz        L5210
    call      cc_parse.istypestarter
    test      %rax,	%rax
    jz        L5212
    mov       %r14,	1
    call      cc_parse.pushblock
    mov       %rcx,	[%rip+cc_decls.currproc]
    lea       %rdx,	[%rbp + cc_parse.readforstmt.linkage]
    call      cc_parse.readdeclspec
    mov       [%rbp + cc_parse.readforstmt.mbase],	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readforstmt.ulistx],	%rax
    mov       [%rbp + cc_parse.readforstmt.ulist],	%rax
L5213:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L5215
    cmp       %rax,	25
    jz        L5215
    cmp       %rax,	13
    jnz       L5216
L5215:
    mov       %rcx,	[%rip+cc_decls.currproc]
    lea       %rdx,	[%rbp + cc_parse.readforstmt.d]
    mov       %r8,	[%rbp + cc_parse.readforstmt.mbase]
    lea       %r9,	[%rbp + cc_parse.readforstmt.pm]
    call      cc_parse.readtype
    mov       [%rbp + cc_parse.readforstmt.m],	%rax
    mov       %rax,	[%rbp + cc_parse.readforstmt.d]
    test      %rax,	%rax
    jnz       L5218
    lea       %rcx,	[%rip+L9006]
    call      cc_support.serror
L5218:
    mov       %rax,	[%rbp + cc_parse.readforstmt.linkage]
    cmp       %rax,	5
    jz        L5221
    mov       %rax,	[%rbp + cc_parse.readforstmt.pm]
    test      %rax,	%rax
    jz        L5220
L5221:
    lea       %rcx,	[%rip+L9007]
    call      cc_support.serror
L5220:
    mov       %rcx,	[%rbp + cc_parse.readforstmt.d]
    mov       %rdx,	[%rbp + cc_parse.readforstmt.m]
    mov       %r8,	[%rbp + cc_parse.readforstmt.linkage]
    call      cc_parse.readframevar
    mov       [%rbp + cc_parse.readforstmt.d],	%rax
    mov       %rax,	[%rbp + cc_parse.readforstmt.d]
    mov       %rax,	[%rax+72]
    test      %rax,	%rax
    jz        L5223
    mov       %rcx,	8
    call      cc_lib.createunit0
    mov       %r13,	%rax
    mov       %rax,	[%rbp + cc_parse.readforstmt.d]
    mov       [%r13],	%rax
    lea       %rcx,	[%rbp + cc_parse.readforstmt.ulist]
    lea       %rdx,	[%rbp + cc_parse.readforstmt.ulistx]
    mov       %r8,	%r13
    call      cc_lib.addlistunit
L5223:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jnz       L5226
L5225:
    call      cc_lex.lex
    jmp       L5224
L5226:
    jmp       L5214
L5224:
    jmp       L5213
L5216:
    lea       %rcx,	[%rip+L9008]
    call      cc_support.serror
    jmp       L5213
L5214:
    mov       %rcx,	6
    mov       %rdx,	[%rbp + cc_parse.readforstmt.ulist]
    xor       %r8d,	%r8d
    mov       %r9,	[%rbp + cc_parse.readforstmt.ulistx]
    call      cc_lib.createunit3
    mov       %rdi,	%rax
    jmp       L5211
L5212:
    call      cc_parse.readexpression
    mov       %rdi,	%rax
L5211:
    jmp       L5209
L5210:
    mov       %rcx,	2
    call      cc_lib.createunit0
    mov       %rdi,	%rax
L5209:
    mov       %rcx,	9
    call      cc_lib.skipsymbol
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	9
    jz        L5228
    call      cc_parse.readexpression
    mov       %rbx,	%rax
    mov       %rcx,	%rbx
    call      cc_parse.coercecond
    jmp       L5227
L5228:
    mov       %rcx,	2
    call      cc_lib.createunit0
    mov       %rbx,	%rax
L5227:
    mov       %rcx,	9
    call      cc_lib.skipsymbol
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	14
    jz        L5230
    call      cc_parse.readexprstmt
    mov       %rsi,	%rax
    jmp       L5229
L5230:
    xor       %rsi,	%rsi
L5229:
    mov       %rcx,	14
    call      cc_lib.skipsymbol
    mov       %rcx,	76
    call      cc_parse.pushloop
    xor       %ecx,	%ecx
    call      cc_parse.readblock
    mov       %r12,	%rax
    call      cc_parse.poploop
    test      %r14,	%r14
    jz        L5232
    call      cc_parse.popblock
L5232:
    mov       [%rdi+8],	%rbx
    mov       [%rbx+8],	%rsi
    mov       %rcx,	13
    mov       %rdx,	%rdi
    mov       %r8,	%r12
    call      cc_lib.createunit2
L5208:
#---------------
    add       %rsp,	96
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readwhilestmt
cc_parse.readwhilestmt:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    call      cc_lex.lex
    call      cc_parse.readcond
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    call      cc_parse.coercecond
    mov       %rcx,	76
    call      cc_parse.pushloop
    xor       %ecx,	%ecx
    call      cc_parse.readblock
    mov       %rbx,	%rax
    call      cc_parse.poploop
    mov       %rcx,	14
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      cc_lib.createunit2
L5233:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readdostmt
cc_parse.readdostmt:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    call      cc_lex.lex
    mov       %rcx,	76
    call      cc_parse.pushloop
    xor       %ecx,	%ecx
    call      cc_parse.readblock
    mov       %rdi,	%rax
    call      cc_parse.poploop
    mov       %rcx,	76
    call      cc_lib.skipsymbol
    call      cc_parse.readcond
    mov       %rbx,	%rax
    mov       %rcx,	%rbx
    call      cc_parse.coercecond
    mov       %rcx,	9
    call      cc_lib.skipsymbol
    mov       %rcx,	15
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      cc_lib.createunit2
L5234:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readreturnstmt
cc_parse.readreturnstmt:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    call      cc_lex.lex
    xor       %rdi,	%rdi
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	9
    jz        L5237
    mov       %rax,	[%rip+cc_decls.currproc]
    movzx     %rax,	word ptr[%rax+102]
    test      %rax,	%rax
    jnz       L5239
    lea       %rcx,	[%rip+L9009]
    call      cc_support.terror
L5239:
    call      cc_parse.readexpression
    mov       %rdi,	%rax
    mov       %rax,	[%rip+cc_decls.currproc]
    movzx     %rax,	word ptr[%rax+102]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      cc_parse.coercemode
    mov       %rdi,	%rax
    mov       %rcx,	9
    call      cc_lib.checksymbol
    jmp       L5236
L5237:
    mov       %rax,	[%rip+cc_decls.currproc]
    movzx     %rax,	word ptr[%rax+102]
    test      %rax,	%rax
    jz        L5240
    lea       %rcx,	[%rip+L9010]
    call      cc_support.terror
L5240:
L5236:
    call      cc_lex.lex
    mov       %rcx,	9
    mov       %rdx,	%rdi
    call      cc_lib.createunit1
L5235:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readgotostmt
cc_parse.readgotostmt:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    call      cc_lex.lex
    mov       %rcx,	67
    call      cc_lib.checksymbol
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       %rcx,	[%rip+cc_decls.currproc]
    mov       %rdx,	%rax
    mov       %r8,	3
    xor       %r9d,	%r9d
    call      cc_lib.resolvename
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L5243
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       %rcx,	[%rip+cc_decls.currproc]
    mov       %rdx,	%rax
    mov       %r8,	14
    call      cc_lib.createdupldef
    mov       %rdi,	%rax
    xor       %eax,	%eax
    mov       [%rdi+102],	%ax
L5243:
    mov       %rcx,	16
    xor       %edx,	%edx
    call      cc_lib.createunit1
    mov       %rbx,	%rax
    mov       [%rbx],	%rdi
    call      cc_lex.lex
    mov       %rcx,	9
    call      cc_lib.skipsymbol
    mov       %rax,	%rbx
L5241:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readswitchstmt
cc_parse.readswitchstmt:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    call      cc_lex.lex
    call      cc_parse.readcond
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    mov       %rdx,	3
    call      cc_parse.coercemode
    mov       %rcx,	83
    call      cc_parse.pushloop
    xor       %ecx,	%ecx
    call      cc_parse.readblock
    mov       %rbx,	%rax
    mov       %rcx,	22
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      cc_lib.createunit2
    mov       %rsi,	%rax
    lea       %rax,	[%rip+cc_parse.casevaluestack]
    mov       %r10,	[%rip+cc_parse.loopindex]
    mov       %rax,	[%rax + %r10*8-8]
    mov       [%rsi],	%rax
    call      cc_parse.poploop
    mov       %rax,	%rsi
L5244:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readcaselabel
cc_parse.readcaselabel:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    call      cc_lex.lex
    call      cc_parse.readconstintexpr
    mov       %rbx,	%rax
    mov       %rcx,	10
    call      cc_lib.skipsymbol
    call      cc_parse.readstatement
    mov       %rcx,	18
    mov       %rdx,	%rax
    call      cc_lib.createunit1
    mov       %rdi,	%rax
    mov       [%rdi],	%rbx
    mov       %rcx,	%rbx
    call      cc_parse.addcasevalue
    mov       %rax,	%rdi
L5245:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readexprstmt
cc_parse.readexprstmt:
#PROC1
#PROC2
#?>>
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    call      cc_parse.readexpression
L5246:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_parse.readcond
cc_parse.readcond:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    mov       %rcx,	13
    call      cc_lib.skipsymbol
    call      cc_parse.readexpression
    mov       %rdi,	%rax
    mov       %rcx,	14
    call      cc_lib.skipsymbol
    mov       %rax,	%rdi
L5247:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_parse.isusertype
cc_parse.isusertype:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    mov       %r8,	1
    mov       %r9,	[%rip+cc_decls.currblockno]
    call      cc_lib.resolvename
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L5250
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	5
    jnz       L5252
    movzx     %rax,	word ptr[%rdi+102]
    jmp       L5248
L5252:
    mov       [%rip+cc_parse.ist_symptr],	%rdi
L5250:
    mov       %rax,	20
L5248:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readlocaldecl
cc_parse.readlocaldecl:
#PROC1
#PROC2
#?>>
    .set cc_parse.readlocaldecl.linkage, -8
    .set cc_parse.readlocaldecl.wasdef, -16
    .set cc_parse.readlocaldecl.d, -24
    .set cc_parse.readlocaldecl.ulist, -32
    .set cc_parse.readlocaldecl.ulistx, -40
    .set cc_parse.readlocaldecl.pm, -48
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	88
#---------------
#PROC3
#PROC4
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readlocaldecl.ulistx],	%rax
    mov       [%rbp + cc_parse.readlocaldecl.ulist],	%rax
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    mov       %r12,	%rax
    mov       %rcx,	[%rip+cc_decls.currproc]
    lea       %rdx,	[%rbp + cc_parse.readlocaldecl.linkage]
    call      cc_parse.readdeclspec
    mov       %rbx,	%rax
    xor       %rsi,	%rsi
L5254:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L5256
    cmp       %rax,	25
    jz        L5256
    cmp       %rax,	13
    jnz       L5257
L5256:
    inc       %rsi
    mov       %rcx,	[%rip+cc_decls.currproc]
    lea       %rdx,	[%rbp + cc_parse.readlocaldecl.d]
    mov       %r8,	%rbx
    lea       %r9,	[%rbp + cc_parse.readlocaldecl.pm]
    call      cc_parse.readtype
    mov       %rdi,	%rax
    mov       %rax,	[%rbp + cc_parse.readlocaldecl.d]
    test      %rax,	%rax
    jnz       L5259
    lea       %rcx,	[%rip+L9011]
    call      cc_support.serror
L5259:
    mov       %rax,	[%rbp + cc_parse.readlocaldecl.linkage]
    cmp       %rax,	5
    jnz       L5261
    mov       %rcx,	[%rip+cc_decls.currproc]
    mov       %rdx,	[%rbp + cc_parse.readlocaldecl.d]
    mov       %r8,	%rdi
    call      cc_parse.createtypedef
    mov       [%rbp + cc_parse.readlocaldecl.d],	%rax
    jmp       L5260
L5261:
    mov       %rax,	[%rbp + cc_parse.readlocaldecl.pm]
    test      %rax,	%rax
    jz        L5262
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	17
    jnz       L5264
    lea       %rcx,	[%rip+L9012]
    call      cc_support.serror
L5264:
    sub       %rsp,	8
    lea       %rax,	[%rbp + cc_parse.readlocaldecl.wasdef]
    push      %rax
    mov       %rcx,	[%rbp + cc_parse.readlocaldecl.d]
    mov       %rdx,	%rdi
    mov       %r8,	[%rbp + cc_parse.readlocaldecl.linkage]
    mov       %r9,	[%rbp + cc_parse.readlocaldecl.pm]
    sub       %rsp,	32
    call      cc_parse.readfunction
    add       %rsp,	48
    mov       [%rbp + cc_parse.readlocaldecl.d],	%rax
    jmp       L5260
L5262:
    mov       %rcx,	[%rbp + cc_parse.readlocaldecl.d]
    mov       %rdx,	%rdi
    mov       %r8,	[%rbp + cc_parse.readlocaldecl.linkage]
    call      cc_parse.readframevar
    mov       [%rbp + cc_parse.readlocaldecl.d],	%rax
    mov       %rcx,	7
    call      cc_lib.createunit0
    mov       %r13,	%rax
    mov       %rax,	[%rbp + cc_parse.readlocaldecl.d]
    mov       [%r13],	%rax
    lea       %rcx,	[%rbp + cc_parse.readlocaldecl.ulist]
    lea       %rdx,	[%rbp + cc_parse.readlocaldecl.ulistx]
    mov       %r8,	%r13
    call      cc_lib.addlistunit
L5260:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jnz       L5267
L5266:
    call      cc_lex.lex
    jmp       L5265
L5267:
    mov       %rcx,	9
    call      cc_lib.skipsymbol
    jmp       L5255
L5265:
    jmp       L5254
L5257:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	12
    jz        L5269
    cmp       %rax,	18
    jz        L5269
    cmp       %rax,	19
    jz        L5269
    cmp       %rax,	3
    jz        L5270
    jmp       L5271
L5269:
    mov       %rcx,	9
    call      cc_lib.skipsymbol
    jmp       L5255
L5270:
    mov       %rcx,	9
    call      cc_lib.skipsymbol
    jmp       L5255
L5271:
    mov       %rcx,	%rdi
    call      cc_lib.typename
    lea       %rcx,	[%rip+L9013]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L5268:
    jmp       L5254
L5255:
    mov       %rax,	[%rbp + cc_parse.readlocaldecl.ulist]
L5253:
#---------------
    add       %rsp,	88
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createtypedef
cc_parse.createtypedef:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	1
    mov       %r9,	[%rip+cc_decls.currblockno]
    call      cc_lib.checkdupl
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L5274
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	5
    jz        L5276
    mov       %rax,	[%rdi]
    lea       %rcx,	[%rip+L9014]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L5276:
    movzx     %rax,	word ptr[%rdi+102]
    cmp       %rax,	%r12
    jz        L5278
    movzx     %rax,	word ptr[%rdi+102]
    mov       %rcx,	%rax
    mov       %rdx,	%r12
    call      cc_parse.comparemode
    test      %rax,	%rax
    jnz       L5280
    mov       %rax,	[%rdi]
    lea       %rcx,	[%rip+L9015]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L5280:
L5278:
    mov       %rax,	%rdi
    jmp       L5272
L5274:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	5
    call      cc_lib.createdupldef
    mov       %rdi,	%rax
    mov       [%rdi+102],	%r12w
    mov       %rax,	%rdi
    lea       %r10,	[%rip+cc_decls.tttypedef]
    mov       %r11,	%r12
    mov       [%r10 + %r11*8],	%rax
    mov       %ax,	[%rip+cc_decls.currblockno]
    mov       [%rdi+96],	%ax
    mov       %eax,	1
    lea       %r10,	[%rip+cc_decls.blockcounts]
    mov       %r11,	[%rip+cc_decls.currblockno]
    mov       [%r10 + %r11*4],	%eax
    mov       %rax,	%rdi
L5272:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readparams
cc_parse.readparams:
#PROC1
#PROC2
#?>>
    .set cc_parse.readparams.owner, 64
    .set cc_parse.readparams.ulist, -8
    .set cc_parse.readparams.ulistx, -16
    .set cc_parse.readparams.pm, -24
    .set cc_parse.readparams.lastbasetype, -32
    .set cc_parse.readparams.d, -40
    .set cc_parse.readparams.names, -48
    .set cc_parse.readparams.nonames, -56
    .set cc_parse.readparams.reported, -64
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	96
#---------------
#PROC3
#PROC4
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readparams.d],	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readparams.ulistx],	%rax
    mov       [%rbp + cc_parse.readparams.ulist],	%rax
    xor       %eax,	%eax
    mov       %r14,	%rax
    mov       %rsi,	%rax
    mov       %r12,	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readparams.lastbasetype],	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readparams.names],	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readparams.nonames],	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readparams.reported],	%rax
    jmp       L5283
L5282:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	21
    jnz       L5286
    mov       %r12,	1
    call      cc_lex.lex
    jmp       L5284
L5286:
    call      cc_parse.istypestarter
    test      %rax,	%rax
    jz        L5288
    sub       %rsp,	8
    lea       %rax,	[%rbp + cc_parse.readparams.lastbasetype]
    push      %rax
    lea       %rcx,	[%rbp + cc_parse.readparams.d]
    mov       %rdx,	1
    lea       %r8,	[%rbp + cc_parse.readparams.pm]
    xor       %r9d,	%r9d
    sub       %rsp,	32
    call      cc_parse.readcasttype
    add       %rsp,	48
    mov       %rbx,	%rax
    mov       %rax,	[%rbp + cc_parse.readparams.pm]
    test      %rax,	%rax
    jz        L5290
    mov       %rcx,	%rbx
    mov       %rdx,	[%rbp + cc_parse.readparams.pm]
    call      cc_lib.createprocmode
    mov       %rcx,	%rax
    call      cc_lib.createrefmode
    mov       %rbx,	%rax
L5290:
    jmp       L5287
L5288:
    mov       %rax,	[%rbp + cc_parse.readparams.lastbasetype]
    test      %rax,	%rax
    jnz       L5292
    lea       %rcx,	[%rip+L9016]
    call      cc_support.serror
L5292:
    sub       %rsp,	8
    push      0
    lea       %rcx,	[%rbp + cc_parse.readparams.d]
    mov       %rdx,	1
    lea       %r8,	[%rbp + cc_parse.readparams.pm]
    mov       %r9,	[%rbp + cc_parse.readparams.lastbasetype]
    sub       %rsp,	32
    call      cc_parse.readcasttype
    add       %rsp,	48
    mov       %rbx,	%rax
L5287:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jz        L5294
    cmp       %rax,	14
    jz        L5295
    jmp       L5296
L5294:
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rcx,	%rax
    call      cc_lib.createrefmode
    mov       %rbx,	%rax
    jmp       L5293
L5295:
    lea       %rax,	[%rip+cc_decls.ttparams]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      cc_lib.createprocmode
    mov       %rcx,	%rax
    call      cc_lib.createrefmode
    mov       %rbx,	%rax
L5296:
L5293:
    mov       %rcx,	24
    call      mlib.pcm_allocz
    mov       [%rbp + cc_parse.readparams.pm],	%rax
    mov       %rax,	[%rbp + cc_parse.readparams.d]
    mov       %r10,	[%rbp + cc_parse.readparams.pm]
    mov       [%r10],	%rax
    mov       %eax,	%ebx
    mov       %r10,	[%rbp + cc_parse.readparams.pm]
    mov       [%r10+16],	%eax
    inc       %rsi
    mov       %rax,	[%rbp + cc_parse.readparams.d]
    test      %rax,	%rax
    jz        L5298
    mov       %rax,	1
    mov       [%rbp + cc_parse.readparams.names],	%rax
    jmp       L5297
L5298:
    mov       %rax,	1
    mov       [%rbp + cc_parse.readparams.nonames],	%rax
L5297:
    mov       %rax,	[%rbp + cc_parse.readparams.names]
    test      %rax,	%rax
    jz        L5300
    mov       %rax,	[%rbp + cc_parse.readparams.nonames]
    test      %rax,	%rax
    jz        L5300
    mov       %rax,	[%rbp + cc_parse.readparams.reported]
    test      %rax,	%rax
    jnz       L5300
    mov       %rax,	1
    mov       [%rbp + cc_parse.readparams.reported],	%rax
L5300:
    mov       %rax,	[%rbp + cc_parse.readparams.d]
    test      %rax,	%rax
    jz        L5302
    inc       %r14
    mov       %rdi,	[%rbp + cc_parse.readparams.ulist]
    jmp       L5304
L5303:
    mov       %rax,	[%rdi]
    cmp       %rax,	[%rbp + cc_parse.readparams.d]
    jnz       L5307
    mov       %rax,	[%rbp + cc_parse.readparams.d]
    movzx     %rax,	byte ptr[%rax+109]
    lea       %r10,	[%rip+cc_tables.namenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rax,	[%rbp + cc_parse.readparams.d]
    mov       %rax,	[%rax]
    lea       %rcx,	[%rip+L9017]
    mov       %rdx,	%rax
    mov       %r8,	%r10
    call      cc_support.serror_ss
L5307:
    mov       %rdi,	[%rdi+8]
L5304:
    test      %rdi,	%rdi
    jnz       L5303
L5302:
    lea       %rcx,	[%rbp + cc_parse.readparams.ulist]
    lea       %rdx,	[%rbp + cc_parse.readparams.ulistx]
    mov       %r8,	[%rbp + cc_parse.readparams.pm]
    call      cc_lib.addlistparam
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jz        L5309
    cmp       %rax,	21
    jz        L5310
    cmp       %rax,	14
    jz        L5310
    jmp       L5311
L5309:
    call      cc_lex.lex
    jmp       L5308
L5310:
    jmp       L5308
L5311:
    lea       %rcx,	[%rip+L9018]
    call      cc_support.serror
L5308:
L5283:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	14
    jnz       L5282
L5284:
    xor       %r13,	%r13
    mov       %rcx,	14
    call      cc_lib.skipsymbol
    test      %r12,	%r12
    jz        L5313
    mov       %r13,	3
    jmp       L5312
L5313:
    test      %rsi,	%rsi
    jnz       L5314
    mov       %r13,	1
    jmp       L5312
L5314:
    cmp       %rsi,	1
    jnz       L5315
    test      %rbx,	%rbx
    jnz       L5315
    mov       %r13,	2
    xor       %rsi,	%rsi
    xor       %eax,	%eax
    mov       %r10,	[%rbp + cc_parse.readparams.ulist]
    mov       [%r10+16],	%eax
L5315:
L5312:
    mov       %rax,	[%rbp + cc_parse.readparams.ulist]
    test      %rax,	%rax
    jnz       L5317
    mov       %rcx,	24
    call      mlib.pcm_allocz
    mov       [%rbp + cc_parse.readparams.ulist],	%rax
L5317:
    mov       %ax,	%si
    mov       %r10,	[%rbp + cc_parse.readparams.ulist]
    mov       [%r10+20],	%ax
    mov       %ax,	%r13w
    mov       %r10,	[%rbp + cc_parse.readparams.ulist]
    mov       [%r10+22],	%ax
    mov       %rax,	[%rbp + cc_parse.readparams.ulist]
L5281:
#---------------
    add       %rsp,	96
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readcasttype
cc_parse.readcasttype:
#PROC1
#PROC2
#?>>
    .set cc_parse.readcasttype.mbase, 88
    .set cc_parse.readcasttype.linkage, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
    mov       %r13,	%r9
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+cc_decls.currproc]
    test      %rax,	%rax
    jz        L5320
    mov       %rax,	[%rip+cc_decls.currproc]
    jmp       L5319
L5320:
    mov       %rax,	[%rip+cc_decls.stmodule]
L5319:
    mov       %rdi,	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readcasttype.linkage],	%rax
    xor       %eax,	%eax
    mov       [%rbx],	%rax
    test      %r13,	%r13
    jnz       L5322
    mov       %rcx,	%rdi
    lea       %rdx,	[%rbp + cc_parse.readcasttype.linkage]
    call      cc_parse.readdeclspec
    mov       %r13,	%rax
    mov       %rax,	[%rbp + cc_parse.readcasttype.mbase]
    test      %rax,	%rax
    jz        L5324
    mov       %rax,	%r13
    mov       %r10,	[%rbp + cc_parse.readcasttype.mbase]
    mov       [%r10],	%rax
L5324:
L5322:
    xor       %eax,	%eax
    mov       [%r12],	%rax
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L5326
    cmp       %rax,	25
    jz        L5326
    cmp       %rax,	13
    jz        L5326
    cmp       %rax,	15
    jnz       L5327
L5326:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	%r13
    mov       %r9,	%r12
    call      cc_parse.readtype
    mov       %r13,	%rax
    mov       %rax,	[%rbx]
    test      %rax,	%rax
    jz        L5329
    test      %rsi,	%rsi
    jnz       L5329
    mov       %rax,	[%rbx]
    mov       %rax,	[%rax]
    lea       %rcx,	[%rip+L9019]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L5329:
L5327:
L5325:
    mov       %rax,	%r13
L5318:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readfunction
cc_parse.readfunction:
#PROC1
#PROC2
#?>>
    .set cc_parse.readfunction.pm, 88
    .set cc_parse.readfunction.wasdef, 96
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	32
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
    mov       [%rbp+88],	%r9
#---------------
#PROC3
#PROC4
    mov       %rbx,	[%rip+cc_decls.stmodule]
    xor       %eax,	%eax
    mov       %r10,	[%rbp + cc_parse.readfunction.wasdef]
    mov       [%r10],	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	%r12
    mov       %r8,	1
    xor       %r9d,	%r9d
    call      cc_lib.checkdupl
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L5332
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	6
    jz        L5334
    mov       %rax,	[%r12]
    lea       %rcx,	[%rip+L9020]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L5334:
    mov       %r12,	%rdi
    movzx     %rax,	byte ptr[%r12+110]
    mov       %rsi,	%rax
    cmp       %rsi,	3
    jnz       L5336
    test      %r14,	%r14
    jnz       L5336
    mov       %rsi,	4
    jmp       L5335
L5336:
    cmp       %r14,	1
    jnz       L5337
    mov       %rsi,	2
L5337:
L5335:
    jmp       L5331
L5332:
    mov       %rcx,	%rbx
    mov       %rdx,	%r12
    mov       %r8,	6
    call      cc_lib.createdupldef
    mov       %r12,	%rax
    mov       [%r12+102],	%r13w
    mov       %rax,	%r14
    cmp       %rax,	1
    jz        L5339
    cmp       %rax,	4
    jz        L5340
    jmp       L5341
L5339:
    mov       %rsi,	2
    jmp       L5338
L5340:
    mov       %rsi,	3
    jmp       L5338
L5341:
    mov       %rsi,	4
L5338:
L5331:
    mov       %rax,	[%rbp + cc_parse.readfunction.pm]
    mov       [%r12+80],	%rax
    mov       [%r12+110],	%sil
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	17
    jnz       L5343
    mov       %rax,	1
    mov       %r10,	[%rbp + cc_parse.readfunction.wasdef]
    mov       [%r10],	%rax
    mov       %rax,	[%r12+72]
    test      %rax,	%rax
    jz        L5345
    mov       %rax,	[%r12]
    lea       %rcx,	[%rip+L9021]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L5345:
    cmp       %rsi,	3
    jnz       L5347
    mov       %al,	4
    mov       [%r12+110],	%al
L5347:
    mov       %rcx,	%r12
    call      cc_parse.readfunctionbody
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	9
    jnz       L5349
    lea       %rcx,	[%rip+L9022]
    call      cc_support.serror
L5349:
L5343:
    mov       %rax,	%r12
L5330:
#---------------
    add       %rsp,	32
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readfunctionbody
cc_parse.readfunctionbody:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r14,	%rcx
#---------------
#PROC3
#PROC4
    mov       [%rip+cc_decls.currproc],	%r14
    xor       %eax,	%eax
    mov       [%rip+cc_decls.currblockno],	%rax
    mov       [%rip+cc_decls.nextblockno],	%rax
    xor       %r12,	%r12
    mov       %rax,	[%r14+80]
    mov       %rsi,	%rax
    movsx     %rax,	word ptr[%rsi+20]
    mov       %r13,	%rax
    cmp       %r13,	0
    jle       L5353
L5351:
    mov       %rax,	[%rsi]
    test      %rax,	%rax
    jz        L5354
L5355:
    mov       %rax,	[%rsi]
    mov       %rcx,	%r14
    mov       %rdx,	%rax
    mov       %r8,	9
    call      cc_lib.createdupldef
    mov       %rdi,	%rax
    mov       %rax,	[%rdi]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	36
    jnz       L5357
    mov       %al,	1
    mov       [%rdi+122],	%al
L5357:
    mov       %ax,	1
    mov       [%rdi+96],	%ax
    mov       %eax,	[%rsi+16]
    mov       [%rdi+102],	%ax
L5354:
    mov       %rsi,	[%rsi+8]
    mov       %r12,	1
    dec       %r13
    jnz       L5351
L5353:
    mov       %rcx,	%r12
    call      cc_parse.readcompoundstmt
    mov       %rbx,	%rax
    mov       %rax,	%rbx
    mov       %r10,	[%rip+cc_decls.currproc]
    mov       [%r10+72],	%rax
    xor       %eax,	%eax
    mov       [%rip+cc_decls.currproc],	%rax
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createnegop
cc_parse.createnegop:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
#PROC3
#PROC4
    movsxd    %rax,	dword ptr[%rsi+52]
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%rsi+40]
    cmp       %rax,	1
    jnz       L5360
    mov       %rax,	%rbx
    cmp       %rax,	3
    jz        L5362
    cmp       %rax,	4
    jz        L5362
    cmp       %rax,	9
    jz        L5362
    cmp       %rax,	8
    jz        L5363
    cmp       %rax,	11
    jz        L5364
    jmp       L5365
L5362:
    mov       %rax,	[%rsi]
    neg       %rax
    mov       [%rsi],	%rax
    mov       %rax,	%rsi
    jmp       L5358
L5363:
    mov       %rax,	[%rsi]
    neg       %rax
    mov       %r10,	4294967295
    and       %rax,	%r10
    mov       [%rsi],	%rax
    mov       %rax,	%rsi
    jmp       L5358
L5364:
    movq      %XMM4,	[%rsi]
    xorpd     %XMM4,	[%rip+L9023]
    movq      [%rsi],	%XMM4
    mov       %rax,	%rsi
    jmp       L5358
L5365:
L5361:
L5360:
#cc_parse.createnegop.retry:
L5366:
    cmp       %rbx,	1
    jl        L5368
    cmp       %rbx,	11
    jg        L5368
    mov       %rcx,	%rsi
    call      cc_parse.coercebasetype
    mov       %rcx,	58
    mov       %rdx,	%rsi
    call      cc_lib.createunit1
    mov       %rdi,	%rax
    jmp       L5367
L5368:
    lea       %rax,	[%rip+cc_decls.ttconst]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5369
    lea       %rax,	[%rip+cc_decls.ttconsttype]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rbx,	%rax
    jmp       L5366
L5369:
    call      msys.m$print_startcon
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L9024]
    call      cc_support.terror
L5367:
    mov       %eax,	[%rsi+52]
    mov       [%rdi+52],	%eax
    mov       %rax,	%rdi
L5358:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createabsop
cc_parse.createabsop:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
#PROC3
#PROC4
    movsxd    %rax,	dword ptr[%rsi+52]
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%rsi+40]
    cmp       %rax,	1
    jnz       L5372
    mov       %rax,	%rbx
    cmp       %rax,	3
    jz        L5374
    cmp       %rax,	4
    jnz       L5375
L5374:
    mov       %rax,	[%rsi]
    cmp       %rax,	0
    jge       L9025
    neg       %rax
L9025:
    mov       [%rsi],	%rax
    mov       %rax,	%rsi
    jmp       L5370
L5375:
L5373:
L5372:
    mov       %rcx,	%rbx
    call      cc_lib.isintcc
    test      %rax,	%rax
    jz        L5377
    mov       %rcx,	%rsi
    call      cc_parse.coercebasetype
    mov       %rcx,	59
    mov       %rdx,	%rsi
    call      cc_lib.createunit1
    mov       %rdi,	%rax
    jmp       L5376
L5377:
    lea       %rcx,	[%rip+L9026]
    call      cc_support.terror
L5376:
    mov       %eax,	[%rsi+52]
    mov       [%rdi+52],	%eax
    mov       %rax,	%rdi
L5370:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createinotop
cc_parse.createinotop:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
#PROC3
#PROC4
    movsxd    %rax,	dword ptr[%rsi+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rbx,	%r10
    movsxd    %rax,	dword ptr[%rsi+40]
    cmp       %rax,	1
    jnz       L5380
    mov       %rax,	%rbx
    cmp       %rax,	3
    jz        L5382
    cmp       %rax,	4
    jz        L5382
    cmp       %rax,	8
    jz        L5382
    cmp       %rax,	9
    jnz       L5383
L5382:
    mov       %rax,	[%rsi]
    not       %rax
    mov       [%rsi],	%rax
    mov       %rax,	%rsi
    jmp       L5378
L5383:
L5381:
L5380:
    mov       %rcx,	%rbx
    call      cc_lib.isintcc
    test      %rax,	%rax
    jz        L5385
    mov       %rcx,	%rsi
    call      cc_parse.coercebasetype
    mov       %rcx,	60
    mov       %rdx,	%rsi
    call      cc_lib.createunit1
    mov       %rdi,	%rax
    jmp       L5384
L5385:
    call      msys.m$print_startcon
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L9027]
    call      cc_support.terror
L5384:
    mov       %eax,	[%rsi+52]
    mov       [%rdi+52],	%eax
    mov       %rax,	%rdi
L5378:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createptrop
cc_parse.createptrop:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
#PROC3
#PROC4
    movsxd    %rax,	dword ptr[%r12+52]
    mov       %rbx,	%rax
    lea       %r10,	[%rip+cc_decls.ttisref]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jnz       L5388
    xor       %ecx,	%ecx
    mov       %rdx,	%r12
    xor       %r8d,	%r8d
    lea       %r9,	[%rip+L9028]
    call      cc_show.printunit
    lea       %rcx,	[%rip+L9029]
    call      cc_support.terror
L5388:
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rsi,	%rax
    movsxd    %rax,	dword ptr[%r12+40]
    cmp       %rax,	55
    jnz       L5391
L5390:
    mov       %rdi,	[%r12+16]
    movsxd    %rax,	dword ptr[%r12+52]
    lea       %r10,	[%rip+cc_decls.tttarget]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       [%rdi+52],	%r10d
    mov       %rcx,	%rdi
    call      cc_parse.fixmemopnd
    mov       %rax,	%rdi
    jmp       L5386
L5391:
L5389:
    mov       %rcx,	52
    mov       %rdx,	%r12
    call      cc_lib.createunit1
    mov       %rdi,	%rax
    mov       [%rdi+52],	%esi
    mov       %rcx,	%rdi
    call      cc_parse.arraytopointer
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    call      cc_parse.fixmemopnd
    mov       %rax,	%rdi
L5386:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createincrop
cc_parse.createincrop:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
#PROC3
#PROC4
    movsxd    %rax,	dword ptr[%r12+52]
    mov       %rbx,	%rax
    mov       %rcx,	%r12
    mov       %rdx,	1
    call      cc_parse.checklvalue
    mov       %rcx,	%rbx
    call      cc_lib.isintcc
    test      %rax,	%rax
    jz        L5395
    cmp       %rbx,	5
    jnz       L5394
L5395:
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jnz       L5394
    lea       %rcx,	[%rip+L9030]
    call      cc_support.terror
L5394:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    call      cc_lib.createunit1
    mov       %rdi,	%rax
    mov       %eax,	[%r12+52]
    mov       [%rdi+52],	%eax
    mov       %rax,	%rdi
L5392:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createaddrofop
cc_parse.createaddrofop:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
#PROC3
#PROC4
    xor       %rsi,	%rsi
#cc_parse.createaddrofop.restartx:
L5397:
    movsxd    %rax,	dword ptr[%r12+52]
    mov       %rbx,	%rax
    mov       %ax,	[%r12+56]
    test      %ax,	%ax
    jz        L5399
    movsx     %rax,	word ptr[%r12+56]
    mov       %rbx,	%rax
L5399:
    movsxd    %rax,	dword ptr[%r12+40]
    cmp       %rax,	3
    jz        L5401
    cmp       %rax,	55
    jz        L5402
    cmp       %rax,	49
    jz        L5403
    cmp       %rax,	53
    jz        L5404
    cmp       %rax,	4
    jz        L5405
    cmp       %rax,	5
    jz        L5406
    jmp       L5407
L5401:
    mov       %rax,	[%r12]
    lea       %rax,	[%rax+108]
    or        byte ptr[%rax],	1
    mov       %eax,	[%r12+48]
    test      %eax,	%eax
    jz        L5409
    mov       %rax,	[%r12]
    movzx     %rax,	word ptr[%rax+102]
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%r12+48]
    mov       %rsi,	%rax
L5409:
    jmp       L5400
L5402:
    mov       %rax,	[%r12+16]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	3
    jnz       L5411
    mov       %rax,	[%r12+16]
    mov       %eax,	[%rax+48]
    test      %eax,	%eax
    jz        L5411
    mov       %rax,	[%r12+16]
    mov       %rax,	[%rax]
    movzx     %rax,	word ptr[%rax+102]
    mov       %rcx,	%rax
    call      cc_lib.createrefmode
    mov       [%r12+52],	%eax
    mov       %rax,	[%r12+16]
    mov       %eax,	[%rax+48]
    mov       [%r12+48],	%eax
    mov       %rax,	%r12
    jmp       L5396
L5411:
    jmp       L5400
L5403:
    mov       %rdi,	[%r12+16]
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	52
    jnz       L5413
    mov       %rax,	[%rdi+16]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5413
    movsxd    %rax,	dword ptr[%r12]
    mov       %r10,	[%rdi+16]
    mov       %r10,	[%r10]
    add       %rax,	%r10
    mov       %rcx,	%rax
    mov       %rdx,	3
    call      cc_lib.createconstunit
    mov       %r12,	%rax
    mov       %rax,	%r12
    jmp       L5396
L5413:
    jmp       L5414
L5404:
    mov       %eax,	[%r12+48]
    test      %eax,	%eax
    jz        L5416
    movsxd    %rax,	dword ptr[%r12+48]
    movsxd    %r10,	dword ptr[%r12+52]
    lea       %r11,	[%rip+cc_decls.tttarget]
    movsx     %r11,	word ptr[%r11 + %r10*2]
    mov       %rcx,	%r11
    mov       %rdx,	%rax
    call      cc_lib.createarraymode
    mov       %rcx,	%rax
    call      cc_lib.createrefmode
    mov       [%r12+52],	%eax
    mov       %rax,	%r12
    jmp       L5396
L5416:
    jmp       L5400
L5405:
    mov       %r12,	[%r12+16]
    jmp       L5397
L5406:
    mov       %rax,	%r12
    jmp       L5396
L5407:
#cc_parse.createaddrofop.cad1:
L5414:
    mov       %rcx,	%r12
    xor       %edx,	%edx
    call      cc_parse.checklvalue
L5400:
    mov       %rcx,	55
    mov       %rdx,	%r12
    call      cc_lib.createunit1
    mov       %r12,	%rax
    mov       %rcx,	%rbx
    call      cc_lib.createrefmode
    mov       [%r12+52],	%eax
    mov       [%r12+48],	%esi
    mov       %rax,	%r12
L5396:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createaddop
cc_parse.createaddop:
#PROC1
#PROC2
#?>>
    .set cc_parse.createaddop.x, 56
    .set cc_parse.createaddop.y, 64
    .set cc_parse.createaddop.elemsize, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       [%rbp+56],	%rcx
    mov       [%rbp+64],	%rdx
#---------------
#PROC3
#PROC4
    mov       %rcx,	[%rbp + cc_parse.createaddop.x]
    call      cc_parse.getmemmode
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rbx,	%r10
    mov       %rcx,	[%rbp + cc_parse.createaddop.y]
    call      cc_parse.getmemmode
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rsi,	%r10
    mov       %r13,	39
    lea       %rax,	[%rip+cc_tables.dominantmode]
    mov       %r10,	%rbx
    shl       %r10,	5
    lea       %rax,	[%rax + %r10]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %r12,	%rax
    test      %rax,	%rax
    jz        L5419
    mov       %rcx,	[%rbp + cc_parse.createaddop.x]
    mov       %rdx,	%r12
    call      cc_parse.coercemode
    mov       [%rbp + cc_parse.createaddop.x],	%rax
    mov       %rcx,	[%rbp + cc_parse.createaddop.y]
    mov       %rdx,	%r12
    call      cc_parse.coercemode
    mov       [%rbp + cc_parse.createaddop.y],	%rax
    jmp       L5418
L5419:
    cmp       %rbx,	13
    jnz       L5420
#cc_parse.createaddop.doaddref:
L5421:
    mov       %rax,	[%rbp + cc_parse.createaddop.x]
    movsxd    %rax,	dword ptr[%rax+52]
    mov       %r12,	%rax
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%r12
    movsx     %rax,	word ptr[%rax + %r10*2]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r10,	[%r10 + %rax*8]
    mov       [%rbp + cc_parse.createaddop.elemsize],	%r10
    mov       %rax,	[%rbp + cc_parse.createaddop.x]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5423
    mov       %rax,	[%rbp + cc_parse.createaddop.y]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5423
    mov       %rax,	[%rbp + cc_parse.createaddop.y]
    mov       %rax,	[%rax]
    mov       %r10,	[%rbp + cc_parse.createaddop.elemsize]
    imul      %rax,	%r10
    mov       %r10,	[%rbp + cc_parse.createaddop.x]
    add       [%r10],	%rax
    mov       %rax,	[%rbp + cc_parse.createaddop.x]
    jmp       L5417
L5423:
    mov       %rcx,	[%rbp + cc_parse.createaddop.y]
    mov       %rdx,	4
    call      cc_parse.coercemode
    mov       [%rbp + cc_parse.createaddop.y],	%rax
    mov       %rcx,	53
    mov       %rdx,	[%rbp + cc_parse.createaddop.x]
    mov       %r8,	[%rbp + cc_parse.createaddop.y]
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%r12d
    mov       %eax,	[%rbp + cc_parse.createaddop.elemsize]
    mov       [%rdi],	%eax
    mov       %rax,	%rdi
    jmp       L5417
L5420:
    cmp       %rsi,	13
    jnz       L5424
    mov       %rax,	[%rbp + cc_parse.createaddop.x]
    mov       %r10,	[%rbp + cc_parse.createaddop.y]
    mov       [%rbp + cc_parse.createaddop.y],	%rax
    mov       [%rbp + cc_parse.createaddop.x],	%r10
    jmp       L5421
    lea       %rcx,	[%rip+L9031]
    call      cc_support.terror
L5424:
L5418:
    mov       %rax,	[%rbp + cc_parse.createaddop.x]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5426
    mov       %rax,	[%rbp + cc_parse.createaddop.y]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5428
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + cc_parse.createaddop.x]
    mov       %r8,	[%rbp + cc_parse.createaddop.y]
    mov       %r9,	%r12
    call      cc_parse.eval_add
    jmp       L5417
L5428:
    mov       %rax,	[%rbp + cc_parse.createaddop.x]
    mov       %r10,	[%rbp + cc_parse.createaddop.y]
    mov       [%rbp + cc_parse.createaddop.y],	%rax
    mov       [%rbp + cc_parse.createaddop.x],	%r10
L5427:
    mov       %rax,	[%rbp + cc_parse.createaddop.y]
    mov       %rax,	[%rax]
    test      %rax,	%rax
    jnz       L5430
    mov       %rax,	[%rbp + cc_parse.createaddop.x]
    jmp       L5417
L5430:
L5426:
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + cc_parse.createaddop.x]
    mov       %r8,	[%rbp + cc_parse.createaddop.y]
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%r12d
    mov       %rax,	%rdi
L5417:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createsubop
cc_parse.createsubop:
#PROC1
#PROC2
#?>>
    .set cc_parse.createsubop.x, 56
    .set cc_parse.createsubop.y, 64
    .set cc_parse.createsubop.elemsize, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       [%rbp+56],	%rcx
    mov       [%rbp+64],	%rdx
#---------------
#PROC3
#PROC4
    mov       %rcx,	[%rbp + cc_parse.createsubop.x]
    call      cc_parse.getmemmode
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rbx,	%r10
    mov       %rcx,	[%rbp + cc_parse.createsubop.y]
    call      cc_parse.getmemmode
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rsi,	%r10
    mov       %r13,	40
    lea       %rax,	[%rip+cc_tables.dominantmode]
    mov       %r10,	%rbx
    shl       %r10,	5
    lea       %rax,	[%rax + %r10]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %r12,	%rax
    test      %rax,	%rax
    jz        L5433
    mov       %rcx,	[%rbp + cc_parse.createsubop.x]
    mov       %rdx,	%r12
    call      cc_parse.coercemode
    mov       [%rbp + cc_parse.createsubop.x],	%rax
    mov       %rcx,	[%rbp + cc_parse.createsubop.y]
    mov       %rdx,	%r12
    call      cc_parse.coercemode
    mov       [%rbp + cc_parse.createsubop.y],	%rax
    jmp       L5432
L5433:
    cmp       %rbx,	13
    jnz       L5434
    cmp       %rsi,	13
    jz        L5436
    mov       %rax,	[%rbp + cc_parse.createsubop.x]
    movsxd    %rax,	dword ptr[%rax+52]
    mov       %r12,	%rax
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%r12
    movsx     %rax,	word ptr[%rax + %r10*2]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r10,	[%r10 + %rax*8]
    mov       [%rbp + cc_parse.createsubop.elemsize],	%r10
    mov       %rcx,	[%rbp + cc_parse.createsubop.y]
    mov       %rdx,	4
    call      cc_parse.coercemode
    mov       [%rbp + cc_parse.createsubop.y],	%rax
    mov       %rcx,	54
    mov       %rdx,	[%rbp + cc_parse.createsubop.x]
    mov       %r8,	[%rbp + cc_parse.createsubop.y]
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%r12d
    mov       %eax,	[%rbp + cc_parse.createsubop.elemsize]
    mov       [%rdi],	%eax
    mov       %rax,	%rdi
    jmp       L5431
L5436:
    mov       %rax,	[%rbp + cc_parse.createsubop.x]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5438
    mov       %rax,	[%rbp + cc_parse.createsubop.y]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5438
    mov       %rax,	[%rbp + cc_parse.createsubop.y]
    mov       %rax,	[%rax]
    mov       %r10,	[%rbp + cc_parse.createsubop.x]
    movsxd    %r10,	dword ptr[%r10+52]
    lea       %r11,	[%rip+cc_decls.tttarget]
    movsx     %r11,	word ptr[%r11 + %r10*2]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r10,	[%r10 + %r11*8]
    cqo       
    idiv      %r10
    mov       %r10,	[%rbp + cc_parse.createsubop.x]
    sub       [%r10],	%rax
    mov       %eax,	3
    mov       %r10,	[%rbp + cc_parse.createsubop.x]
    mov       [%r10+52],	%eax
    mov       %rax,	[%rbp + cc_parse.createsubop.x]
    jmp       L5431
L5438:
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + cc_parse.createsubop.x]
    mov       %r8,	[%rbp + cc_parse.createsubop.y]
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       %eax,	4
    mov       [%rdi+52],	%eax
    mov       %rax,	[%rbp + cc_parse.createsubop.x]
    movsxd    %rax,	dword ptr[%rax+52]
    lea       %r10,	[%rip+cc_decls.tttarget]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rcx,	%rdi
    mov       %rdx,	%r10
    call      cc_parse.divunit
    mov       %rdi,	%rax
    mov       %eax,	4
    mov       [%rdi+52],	%eax
    mov       %rax,	%rdi
    jmp       L5431
L5437:
L5435:
    mov       %rax,	[%rbp + cc_parse.createsubop.x]
    movsxd    %rax,	dword ptr[%rax+52]
    lea       %r10,	[%rip+cc_decls.tttarget]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rcx,	[%rbp + cc_parse.createsubop.y]
    mov       %rdx,	%r10
    call      cc_parse.mulunit
    mov       [%rbp + cc_parse.createsubop.y],	%rax
    jmp       L5432
L5434:
    lea       %rcx,	[%rip+L9031]
    call      cc_support.terror
L5432:
    mov       %rax,	[%rbp + cc_parse.createsubop.x]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5440
    mov       %rax,	[%rbp + cc_parse.createsubop.y]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5440
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + cc_parse.createsubop.x]
    mov       %r8,	[%rbp + cc_parse.createsubop.y]
    mov       %r9,	%r12
    call      cc_parse.eval_sub
    jmp       L5431
L5440:
    mov       %rax,	[%rbp + cc_parse.createsubop.y]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5442
    mov       %rax,	[%rbp + cc_parse.createsubop.y]
    mov       %rax,	[%rax]
    test      %rax,	%rax
    jnz       L5442
L5442:
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + cc_parse.createsubop.x]
    mov       %r8,	[%rbp + cc_parse.createsubop.y]
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%r12d
    mov       %rax,	%rdi
L5431:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createmulop
cc_parse.createmulop:
#PROC1
#PROC2
#?>>
    .set cc_parse.createmulop.x, 56
    .set cc_parse.createmulop.y, 64
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       [%rbp+56],	%rcx
    mov       [%rbp+64],	%rdx
#---------------
#PROC3
#PROC4
    mov       %rcx,	[%rbp + cc_parse.createmulop.x]
    call      cc_parse.getmemmode
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rbx,	%r10
    mov       %rcx,	[%rbp + cc_parse.createmulop.y]
    call      cc_parse.getmemmode
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rsi,	%r10
    mov       %r13,	41
    lea       %rax,	[%rip+cc_tables.dominantmode]
    mov       %r10,	%rbx
    shl       %r10,	5
    lea       %rax,	[%rax + %r10]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %r12,	%rax
    test      %rax,	%rax
    jz        L5445
    mov       %rcx,	[%rbp + cc_parse.createmulop.x]
    mov       %rdx,	%r12
    call      cc_parse.coercemode
    mov       [%rbp + cc_parse.createmulop.x],	%rax
    mov       %rcx,	[%rbp + cc_parse.createmulop.y]
    mov       %rdx,	%r12
    call      cc_parse.coercemode
    mov       [%rbp + cc_parse.createmulop.y],	%rax
    jmp       L5444
L5445:
    lea       %rcx,	[%rip+L9032]
    call      cc_support.terror
L5444:
    mov       %rax,	[%rbp + cc_parse.createmulop.x]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5447
    mov       %rax,	[%rbp + cc_parse.createmulop.y]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5449
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + cc_parse.createmulop.x]
    mov       %r8,	[%rbp + cc_parse.createmulop.y]
    mov       %r9,	%r12
    call      cc_parse.eval_mul
    jmp       L5443
L5449:
    mov       %rax,	[%rbp + cc_parse.createmulop.x]
    mov       %r10,	[%rbp + cc_parse.createmulop.y]
    mov       [%rbp + cc_parse.createmulop.y],	%rax
    mov       [%rbp + cc_parse.createmulop.x],	%r10
L5448:
L5447:
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + cc_parse.createmulop.x]
    mov       %r8,	[%rbp + cc_parse.createmulop.y]
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%r12d
    mov       %rax,	%rdi
L5443:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createdivop
cc_parse.createdivop:
#PROC1
#PROC2
#?>>
    .set cc_parse.createdivop.x, 56
    .set cc_parse.createdivop.y, 64
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       [%rbp+56],	%rcx
    mov       [%rbp+64],	%rdx
#---------------
#PROC3
#PROC4
    mov       %rcx,	[%rbp + cc_parse.createdivop.x]
    call      cc_parse.getmemmode
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rbx,	%r10
    mov       %rcx,	[%rbp + cc_parse.createdivop.y]
    call      cc_parse.getmemmode
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rsi,	%r10
    mov       %r13,	42
    lea       %rax,	[%rip+cc_tables.dominantmode]
    mov       %r10,	%rbx
    shl       %r10,	5
    lea       %rax,	[%rax + %r10]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %r12,	%rax
    test      %rax,	%rax
    jz        L5452
    mov       %rcx,	[%rbp + cc_parse.createdivop.x]
    mov       %rdx,	%r12
    call      cc_parse.coercemode
    mov       [%rbp + cc_parse.createdivop.x],	%rax
    mov       %rcx,	[%rbp + cc_parse.createdivop.y]
    mov       %rdx,	%r12
    call      cc_parse.coercemode
    mov       [%rbp + cc_parse.createdivop.y],	%rax
    jmp       L5451
L5452:
    lea       %rcx,	[%rip+L9033]
    call      cc_support.terror
L5451:
    mov       %rax,	[%rbp + cc_parse.createdivop.x]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5454
    mov       %rax,	[%rbp + cc_parse.createdivop.y]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5454
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + cc_parse.createdivop.x]
    mov       %r8,	[%rbp + cc_parse.createdivop.y]
    mov       %r9,	%r12
    call      cc_parse.eval_div
    jmp       L5450
L5454:
    mov       %rax,	[%rbp + cc_parse.createdivop.y]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5455
    cmp       %r12,	11
    jnz       L5455
    mov       %r13,	41
    mov       %rax,	[%rbp + cc_parse.createdivop.y]
    movq      %XMM4,	[%rax]
    movq      %XMM5,	[%rip+L9034]
    divsd     %XMM5,	%XMM4
    mov       %rax,	[%rbp + cc_parse.createdivop.y]
    movq      [%rax],	%XMM5
L5455:
L5453:
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + cc_parse.createdivop.x]
    mov       %r8,	[%rbp + cc_parse.createdivop.y]
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%r12d
    mov       %rax,	%rdi
L5450:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createremop
cc_parse.createremop:
#PROC1
#PROC2
#?>>
    .set cc_parse.createremop.x, 56
    .set cc_parse.createremop.y, 64
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       [%rbp+56],	%rcx
    mov       [%rbp+64],	%rdx
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rbp + cc_parse.createremop.x]
    movsxd    %rax,	dword ptr[%rax+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rbx,	%r10
    mov       %rax,	[%rbp + cc_parse.createremop.y]
    movsxd    %rax,	dword ptr[%rax+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rsi,	%r10
    mov       %r13,	43
    lea       %rax,	[%rip+cc_tables.dominantmode]
    mov       %r10,	%rbx
    shl       %r10,	5
    lea       %rax,	[%rax + %r10]
    mov       %r10,	%rsi
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %r12,	%rax
    test      %rax,	%rax
    jz        L5458
    cmp       %r12,	11
    jz        L5461
    cmp       %r12,	10
    jnz       L5460
L5461:
    mov       %r12,	3
L5460:
    mov       %rcx,	[%rbp + cc_parse.createremop.x]
    mov       %rdx,	%r12
    call      cc_parse.coercemode
    mov       [%rbp + cc_parse.createremop.x],	%rax
    mov       %rcx,	[%rbp + cc_parse.createremop.y]
    mov       %rdx,	%r12
    call      cc_parse.coercemode
    mov       [%rbp + cc_parse.createremop.y],	%rax
    jmp       L5457
L5458:
    lea       %rcx,	[%rip+L9035]
    call      cc_support.terror
L5457:
    mov       %rax,	[%rbp + cc_parse.createremop.x]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5463
    mov       %rax,	[%rbp + cc_parse.createremop.y]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5463
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + cc_parse.createremop.x]
    mov       %r8,	[%rbp + cc_parse.createremop.y]
    mov       %r9,	%r12
    call      cc_parse.eval_rem
    jmp       L5456
L5463:
    mov       %rcx,	%r13
    mov       %rdx,	[%rbp + cc_parse.createremop.x]
    mov       %r8,	[%rbp + cc_parse.createremop.y]
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%r12d
    mov       %rax,	%rdi
L5456:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.insertunit
cc_parse.insertunit:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
#PROC3
#PROC4
    xor       %ecx,	%ecx
    call      cc_lib.createunit0
    mov       %rdi,	%rax
    mov       %rax,	%rbx
    push      %rdi
    mov       %r11,	8
L9036:
    mov       %r10,	[%rax]
    mov       [%rdi],	%r10
    add       %rdi,	8
    add       %rax,	8
    dec       %r11
    jnz       L9036
    pop       %rdi
    mov       [%rbx+40],	%esi
    mov       [%rbx+16],	%rdi
    xor       %eax,	%eax
    mov       [%rbx+32],	%rax
    mov       [%rbx+24],	%rax
    mov       %eax,	[%rdi+44]
    mov       [%rbx+44],	%eax
    mov       %rax,	[%rdi+8]
    mov       [%rbx+8],	%rax
    xor       %eax,	%eax
    mov       [%rbx+56],	%ax
    xor       %eax,	%eax
    mov       [%rdi+8],	%rax
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.eval_add
cc_parse.eval_add:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
    mov       %r13,	%r9
#---------------
#PROC3
#PROC4
    mov       %rax,	%r13
    cmp       %rax,	3
    jz        L5467
    cmp       %rax,	4
    jz        L5467
    cmp       %rax,	8
    jz        L5467
    cmp       %rax,	9
    jz        L5467
    cmp       %rax,	11
    jz        L5468
    jmp       L5469
L5467:
    mov       %rax,	[%r12]
    mov       %r10,	%rsi
    add       [%r10],	%rax
    mov       %rax,	%rsi
    jmp       L5465
L5468:
    movq      %XMM4,	[%r12]
    mov       %rax,	%rsi
    movq      %XMM5,	[%rax]
    addsd     %XMM5,	%XMM4
    movq      [%rax],	%XMM5
    mov       %rax,	%rsi
    jmp       L5465
L5469:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%r13
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	13
    jnz       L5471
    mov       %rax,	[%r12]
    lea       %r10,	[%rip+cc_decls.tttarget]
    mov       %r11,	%r13
    movsx     %r10,	word ptr[%r10 + %r11*2]
    lea       %r11,	[%rip+cc_decls.ttsize]
    mov       %r11,	[%r11 + %r10*8]
    imul      %rax,	%r11
    mov       %r10,	%rsi
    add       [%r10],	%rax
    mov       %rax,	%rsi
    jmp       L5465
L5471:
L5466:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%r13d
    mov       %rax,	%rdi
L5465:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.eval_sub
cc_parse.eval_sub:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
    mov       %r13,	%r9
#---------------
#PROC3
#PROC4
    mov       %rax,	%r13
    cmp       %rax,	3
    jz        L5474
    cmp       %rax,	4
    jz        L5474
    cmp       %rax,	8
    jz        L5474
    cmp       %rax,	9
    jz        L5474
    cmp       %rax,	11
    jz        L5475
    jmp       L5476
L5474:
    mov       %rax,	[%r12]
    mov       %r10,	%rsi
    sub       [%r10],	%rax
    mov       %rax,	%rsi
    jmp       L5472
L5475:
    movq      %XMM4,	[%r12]
    mov       %rax,	%rsi
    movq      %XMM5,	[%rax]
    subsd     %XMM5,	%XMM4
    movq      [%rax],	%XMM5
    mov       %rax,	%rsi
    jmp       L5472
L5476:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%r13
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	13
    jnz       L5478
    movsxd    %rax,	dword ptr[%r12+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    cmp       %r10,	13
    jnz       L5480
    lea       %rcx,	[%rip+L9037]
    call      cc_support.terror
L5480:
    mov       %rax,	%rsi
    jmp       L5472
L5478:
L5473:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%r13d
    mov       %rax,	%rdi
L5472:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.eval_mul
cc_parse.eval_mul:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
    mov       %r13,	%r9
#---------------
#PROC3
#PROC4
    mov       %rax,	%r13
    cmp       %rax,	3
    jz        L5483
    cmp       %rax,	4
    jz        L5483
    cmp       %rax,	2
    jz        L5483
    cmp       %rax,	1
    jz        L5483
    cmp       %rax,	8
    jz        L5484
    cmp       %rax,	9
    jz        L5484
    cmp       %rax,	7
    jz        L5484
    cmp       %rax,	6
    jz        L5484
    cmp       %rax,	11
    jz        L5485
    jmp       L5486
L5483:
    mov       %rax,	[%r12]
    mov       %r11,	%rsi
    mov       %r10,	[%r11]
    imul      %r10,	%rax
    mov       [%r11],	%r10
    mov       %rax,	%rsi
    jmp       L5481
L5484:
    mov       %rax,	[%rsi]
    mov       %r10,	[%r12]
    imul      %rax,	%r10
    mov       [%rsi],	%rax
    mov       %rax,	%rsi
    jmp       L5481
L5485:
    movq      %XMM4,	[%r12]
    mov       %rax,	%rsi
    movq      %XMM5,	[%rax]
    mulsd     %XMM5,	%XMM4
    movq      [%rax],	%XMM5
    mov       %rax,	%rsi
    jmp       L5481
L5486:
L5482:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%r13d
    mov       %rax,	%rdi
L5481:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.eval_div
cc_parse.eval_div:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
    mov       %r13,	%r9
#---------------
#PROC3
#PROC4
    mov       %rax,	%r13
    cmp       %rax,	3
    jz        L5489
    cmp       %rax,	4
    jz        L5489
    cmp       %rax,	8
    jz        L5490
    cmp       %rax,	9
    jz        L5490
    cmp       %rax,	11
    jz        L5491
    jmp       L5492
L5489:
    mov       %rax,	[%r12]
    test      %rax,	%rax
    jnz       L5494
    lea       %rcx,	[%rip+L9038]
    call      cc_support.serror
L5494:
    mov       %rax,	[%rsi]
    mov       %r10,	[%r12]
    cqo       
    idiv      %r10
    mov       [%rsi],	%rax
    mov       %rax,	%rsi
    jmp       L5487
L5490:
    mov       %rax,	[%r12]
    test      %rax,	%rax
    jnz       L5496
    lea       %rcx,	[%rip+L9038]
    call      cc_support.serror
L5496:
    mov       %rax,	[%rsi]
    mov       %r10,	[%r12]
    xor       %edx,	%edx
    div       %r10
    mov       [%rsi],	%rax
    mov       %rax,	%rsi
    jmp       L5487
L5491:
    movq      %XMM4,	[%r12]
    mov       %rax,	%rsi
    movq      %XMM5,	[%rax]
    divsd     %XMM5,	%XMM4
    movq      [%rax],	%XMM5
    mov       %rax,	%rsi
    jmp       L5487
L5492:
L5488:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%r13d
    mov       %rax,	%rdi
L5487:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.eval_rem
cc_parse.eval_rem:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
    mov       %r13,	%r9
#---------------
#PROC3
#PROC4
    mov       %rax,	%r13
    cmp       %rax,	3
    jz        L5499
    cmp       %rax,	4
    jnz       L5500
L5499:
    mov       %rax,	[%r12]
    test      %rax,	%rax
    jnz       L5502
    lea       %rcx,	[%rip+L9039]
    call      cc_support.serror
L5502:
    mov       %rax,	[%rsi]
    mov       %r10,	[%r12]
    cqo       
    idiv      %r10
    xchg      %rax,	%rdx
    mov       [%rsi],	%rax
    mov       %rax,	%rsi
    jmp       L5497
L5500:
L5498:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       [%rdi+52],	%r13d
    mov       %rax,	%rdi
L5497:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.eval_convert
cc_parse.eval_convert:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	16
#---------------
#PROC3
#PROC4
    cmp       %r8,	1
    jnz       L5505
#cc_parse.eval_convert.dosoft:
L5506:
    mov       [%rcx+52],	%edx
    mov       %rax,	1
    jmp       L5503
L5505:
    movsxd    %rax,	dword ptr[%rcx+52]
    mov       %rdi,	%rax
    cmp       %rdi,	%rdx
    jnz       L5508
    mov       %rax,	1
    jmp       L5503
L5508:
    mov       %rax,	%rdi
    cmp       %rax,	3
    jz        L5510
    cmp       %rax,	2
    jz        L5510
    cmp       %rax,	1
    jz        L5510
    cmp       %rax,	4
    jz        L5510
    cmp       %rax,	8
    jz        L5511
    cmp       %rax,	6
    jz        L5511
    cmp       %rax,	7
    jz        L5511
    cmp       %rax,	9
    jz        L5511
    cmp       %rax,	11
    jz        L5512
    jmp       L5513
L5510:
    mov       %rax,	%rdx
    cmp       %rax,	11
    jz        L5515
    cmp       %rax,	10
    jz        L5515
    cmp       %rax,	9
    jz        L5516
    cmp       %rax,	4
    jz        L5516
    cmp       %rax,	8
    jz        L5516
    cmp       %rax,	3
    jz        L5516
    cmp       %rax,	2
    jz        L5516
    cmp       %rax,	1
    jz        L5516
    cmp       %rax,	6
    jz        L5516
    cmp       %rax,	7
    jz        L5516
    jmp       L5517
L5515:
    mov       %rax,	[%rcx]
    cvtsi2sd  %XMM4,	%rax
    movq      [%rcx],	%XMM4
    mov       [%rcx+52],	%edx
    mov       %rax,	1
    jmp       L5503
L5516:
#cc_parse.eval_convert.dotrunc:
L5518:
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rdx
    mov       %rax,	[%rax + %r10*8]
    cmp       %rax,	1
    jz        L5520
    cmp       %rax,	2
    jz        L5521
    cmp       %rax,	4
    jz        L5522
    jmp       L5523
L5520:
    mov       %rax,	%rcx
    mov       %r10,	255
    and       [%rax],	%r10
    lea       %rax,	[%rip+cc_tables.stdsigned]
    mov       %r10,	%rdx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5525
    mov       %rax,	[%rcx]
    movsx     %rax,	%al
    mov       [%rcx],	%rax
L5525:
    jmp       L5519
L5521:
    mov       %rax,	%rcx
    mov       %r10,	65535
    and       [%rax],	%r10
    lea       %rax,	[%rip+cc_tables.stdsigned]
    mov       %r10,	%rdx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5527
    mov       %rax,	[%rcx]
    movsx     %rax,	%ax
    mov       [%rcx],	%rax
L5527:
    jmp       L5519
L5522:
    mov       %rax,	[%rcx]
    mov       %r10,	4294967295
    and       %rax,	%r10
    mov       [%rcx],	%rax
    lea       %rax,	[%rip+cc_tables.stdsigned]
    mov       %r10,	%rdx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5529
    mov       %rax,	[%rcx]
    movsxd    %rax,	%eax
    mov       [%rcx],	%rax
L5529:
L5523:
L5519:
    jmp       L5506
L5517:
L5514:
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%rdx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5531
    mov       [%rcx+52],	%edx
    mov       %rax,	1
    jmp       L5503
L5531:
    jmp       L5509
L5511:
    mov       %rax,	%rdx
    cmp       %rax,	11
    jz        L5533
    cmp       %rax,	10
    jz        L5533
    cmp       %rax,	9
    jz        L5534
    cmp       %rax,	4
    jz        L5534
    cmp       %rax,	3
    jz        L5534
    cmp       %rax,	8
    jz        L5534
    cmp       %rax,	9
    jz        L5534
    cmp       %rax,	7
    jz        L5534
    cmp       %rax,	1
    jz        L5534
    cmp       %rax,	6
    jz        L5534
    cmp       %rax,	2
    jz        L5534
    jmp       L5535
L5533:
    xor       %eax,	%eax
    jmp       L5503
    mov       [%rcx+52],	%edx
    mov       %rax,	1
    jmp       L5503
L5534:
    jmp       L5518
L5535:
L5532:
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%rdx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5537
    mov       [%rcx+52],	%edx
    mov       %rax,	1
    jmp       L5503
L5537:
    jmp       L5509
L5512:
    mov       %rax,	%rdx
    cmp       %rax,	3
    jz        L5539
    cmp       %rax,	4
    jz        L5539
    cmp       %rax,	8
    jz        L5540
    cmp       %rax,	9
    jz        L5540
    cmp       %rax,	10
    jz        L5541
    jmp       L5542
L5539:
    movq      %XMM4,	[%rcx]
    cvttsd2si %rax,	%XMM4
    mov       [%rcx],	%rax
    mov       [%rcx+52],	%edx
    mov       %rax,	1
    jmp       L5503
L5540:
    movq      %XMM4,	[%rcx]
    cvttsd2si %rax,	%XMM4
    mov       [%rcx],	%rax
    mov       [%rcx+52],	%edx
    mov       %rax,	1
    jmp       L5503
L5541:
    mov       %eax,	10
    mov       [%rcx+52],	%eax
    mov       %rax,	1
    jmp       L5503
L5542:
L5538:
    jmp       L5509
L5513:
    movsxd    %rax,	dword ptr[%rcx+52]
    lea       %r10,	[%rip+cc_decls.ttisref]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L5544
    mov       %al,	[%rcx+61]
    test      %al,	%al
    jnz       L5546
    mov       %rax,	%rdx
    cmp       %rax,	3
    jz        L5548
    cmp       %rax,	4
    jz        L5548
    cmp       %rax,	8
    jz        L5548
    cmp       %rax,	9
    jnz       L5549
L5548:
    mov       [%rcx+52],	%edx
    mov       %rax,	1
    jmp       L5503
L5549:
L5547:
L5546:
L5544:
L5509:
    xor       %eax,	%eax
L5503:
#---------------
    add       %rsp,	16
    pop       %rdi
    ret       
# End 
# Proc cc_parse.coercecond
cc_parse.coercecond:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    movsxd    %rax,	dword ptr[%rbx+52]
    mov       %rdi,	%rax
    cmp       %rax,	3
    jz        L5550
L5552:
#cc_parse.coercecond.retry:
L5553:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	10
    jz        L5555
    cmp       %rax,	11
    jz        L5555
    cmp       %rax,	13
    jnz       L5556
L5555:
    jmp       L5557
L5556:
    mov       %rcx,	%rdi
    call      cc_lib.isintcc
    test      %rax,	%rax
    jz        L5559
#cc_parse.coercecond.doint:
L5557:
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L5561
    mov       %rax,	[%rbx]
    test      %rax,	%rax
    jz        L5561
    mov       %rax,	1
    mov       [%rbx],	%rax
    jmp       L5560
L5561:
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L5562
    mov       %rax,	[%rbx]
    test      %rax,	%rax
    jnz       L5562
    xor       %eax,	%eax
    mov       [%rbx],	%rax
    jmp       L5560
L5562:
    mov       %rcx,	%rbx
    mov       %rdx,	27
    call      cc_parse.insertunit
L5560:
    jmp       L5558
L5559:
    lea       %rax,	[%rip+cc_decls.ttconst]
    mov       %r10,	%rdi
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5563
    lea       %rax,	[%rip+cc_decls.ttconsttype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rdi,	%rax
    jmp       L5553
L5563:
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      cc_lib.strmode
    lea       %rcx,	[%rip+L9040]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L5558:
L5554:
    mov       %eax,	3
    mov       [%rbx+52],	%eax
L5550:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.coercebasetype
cc_parse.coercebasetype:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    movsxd    %rax,	dword ptr[%rbx+52]
    mov       %rdi,	%rax
    cmp       %rax,	1
    jl        L5566
    cmp       %rdi,	2
    jg        L5566
    mov       %rcx,	%rbx
    mov       %rdx,	3
    call      cc_parse.coercemode
    mov       %rbx,	%rax
    jmp       L5565
L5566:
    cmp       %rdi,	5
    jl        L5567
    cmp       %rdi,	7
    jg        L5567
    mov       %rcx,	%rbx
    mov       %rdx,	8
    call      cc_parse.coercemode
    mov       %rbx,	%rax
L5567:
L5565:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.checklvalue
cc_parse.checklvalue:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	3
    jz        L5570
    cmp       %rax,	52
    jz        L5571
    cmp       %rax,	5
    jz        L5572
    cmp       %rax,	4
    jz        L5573
    cmp       %rax,	49
    jz        L5574
    cmp       %rax,	1
    jz        L5575
    cmp       %rax,	56
    jz        L5576
    jmp       L5577
L5570:
    jmp       L5569
L5571:
    jmp       L5569
L5572:
    test      %rbx,	%rbx
    jz        L5579
    jmp       L5580
L5579:
    jmp       L5569
L5573:
    mov       %rax,	[%rdi+16]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	3
    jz        L5582
    cmp       %rax,	52
    jz        L5582
    cmp       %rax,	49
    jnz       L5583
L5582:
    mov       %rax,	[%rdi+16]
    push      %rdi
    mov       %r11,	8
L9041:
    mov       %r10,	[%rax]
    mov       [%rdi],	%r10
    add       %rdi,	8
    add       %rax,	8
    dec       %r11
    jnz       L9041
    pop       %rdi
    jmp       L5581
L5583:
    lea       %rcx,	[%rip+L9042]
    call      cc_support.terror
L5581:
    jmp       L5569
L5574:
    jmp       L5569
L5575:
    movsxd    %rax,	dword ptr[%rdi+52]
    lea       %r10,	[%rip+cc_decls.ttisref]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jnz       L5585
    jmp       L5580
L5585:
    jmp       L5569
L5576:
    test      %rbx,	%rbx
    jz        L5587
    jmp       L5580
L5587:
    jmp       L5569
L5577:
#cc_parse.checklvalue.notlv:
L5580:
    xor       %ecx,	%ecx
    mov       %rdx,	%rdi
    xor       %r8d,	%r8d
    lea       %r9,	[%rip+L9043]
    call      cc_show.printunit
    movsxd    %rax,	dword ptr[%rdi+40]
    lea       %r10,	[%rip+cc_tables.jtagnames]
    mov       %r10,	[%r10 + %rax*8]
    lea       %rcx,	[%rip+L9044]
    mov       %rdx,	%r10
    call      cc_support.terror_s
L5569:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createcall
cc_parse.createcall:
#PROC1
#PROC2
#?>>
    .set cc_parse.createcall.p, 64
    .set cc_parse.createcall.q, 72
    .set cc_parse.createcall.aparams, -8
    .set cc_parse.createcall.retmode, -16
    .set cc_parse.createcall.mproc, -24
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	64
    mov       [%rbp+64],	%rcx
    mov       [%rbp+72],	%rdx
#---------------
#PROC3
#PROC4
    xor       %rsi,	%rsi
    mov       %rax,	[%rbp + cc_parse.createcall.p]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	52
    jz        L5590
    cmp       %rax,	3
    jz        L5591
    cmp       %rax,	5
    jz        L5591
    cmp       %rax,	49
    jz        L5592
    cmp       %rax,	30
    jz        L5592
    cmp       %rax,	31
    jz        L5592
    cmp       %rax,	56
    jz        L5592
    cmp       %rax,	29
    jz        L5592
    jmp       L5593
L5590:
#cc_parse.createcall.doptr:
L5594:
    mov       %rax,	[%rbp + cc_parse.createcall.p]
    movsxd    %rax,	dword ptr[%rax+52]
    mov       [%rbp + cc_parse.createcall.mproc],	%rax
    jmp       L5596
L5595:
    mov       %rcx,	52
    mov       %rdx,	[%rbp + cc_parse.createcall.p]
    call      cc_lib.createunit1
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	[%rbp + cc_parse.createcall.mproc]
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       [%rbp + cc_parse.createcall.mproc],	%rax
    mov       %eax,	[%rbp + cc_parse.createcall.mproc]
    mov       [%rdi+52],	%eax
    mov       [%rbp + cc_parse.createcall.p],	%rdi
L5596:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	[%rbp + cc_parse.createcall.mproc]
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	13
    jz        L5595
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	[%rbp + cc_parse.createcall.mproc]
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	14
    jz        L5599
    mov       %rcx,	[%rbp + cc_parse.createcall.mproc]
    call      cc_lib.typename
    lea       %rcx,	[%rip+L9045]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L5599:
    lea       %rax,	[%rip+cc_decls.ttparams]
    mov       %r10,	[%rbp + cc_parse.createcall.mproc]
    mov       %r12,	[%rax + %r10*8]
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	[%rbp + cc_parse.createcall.mproc]
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       [%rbp + cc_parse.createcall.retmode],	%rax
    jmp       L5589
L5591:
    mov       %rax,	[%rbp + cc_parse.createcall.p]
    mov       %rsi,	[%rax]
    movzx     %rax,	byte ptr[%rsi+109]
    cmp       %rax,	6
    jnz       L5601
    mov       %r12,	[%rsi+80]
    movzx     %rax,	word ptr[%rsi+102]
    mov       [%rbp + cc_parse.createcall.retmode],	%rax
    jmp       L5600
L5601:
    jmp       L5594
L5600:
    jmp       L5589
L5592:
    mov       %rcx,	52
    mov       %rdx,	[%rbp + cc_parse.createcall.p]
    call      cc_lib.createunit1
    mov       %rdi,	%rax
    mov       %rax,	[%rbp + cc_parse.createcall.p]
    movsxd    %rax,	dword ptr[%rax+52]
    lea       %r10,	[%rip+cc_decls.tttarget]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       [%rdi+52],	%r10d
    mov       [%rbp + cc_parse.createcall.p],	%rdi
    jmp       L5594
L5593:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L9046]
    call      msys.m$print_str_nf
    mov       %rax,	[%rbp + cc_parse.createcall.p]
    movsxd    %rax,	dword ptr[%rax+40]
    lea       %r10,	[%rip+cc_tables.jtagnames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    xor       %ecx,	%ecx
    mov       %rdx,	[%rbp + cc_parse.createcall.p]
    xor       %r8d,	%r8d
    lea       %r9,	[%rip+L9047]
    call      cc_show.printunit
    lea       %rcx,	[%rip+L9048]
    call      cc_support.serror
L5589:
    movsx     %rax,	word ptr[%r12+20]
    mov       %r14,	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.createcall.aparams],	%rax
    mov       %rbx,	[%rbp + cc_parse.createcall.q]
    jmp       L5603
L5602:
    inc       qword ptr[%rbp + cc_parse.createcall.aparams]
    mov       %rbx,	[%rbx+8]
L5603:
    test      %rbx,	%rbx
    jnz       L5602
    mov       %rax,	[%rbp + cc_parse.createcall.aparams]
    cmp       %rax,	%r14
    jge       L5606
    lea       %rcx,	[%rip+L9049]
    call      cc_support.terror
    jmp       L5605
L5606:
    mov       %rax,	[%rbp + cc_parse.createcall.aparams]
    cmp       %rax,	%r14
    jle       L5607
    movsx     %rax,	word ptr[%r12+22]
    cmp       %rax,	3
    jz        L5607
    movsx     %rax,	word ptr[%r12+22]
    cmp       %rax,	1
    jz        L5607
    movsx     %rax,	word ptr[%r12+22]
    cmp       %rax,	1
    jz        L5609
    call      msys.m$print_startcon
    mov       %rcx,	[%rbp + cc_parse.createcall.aparams]
    call      msys.m$print_i64_nf
    mov       %rcx,	%r14
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L9050]
    call      cc_support.terror
L5609:
L5607:
L5605:
    mov       %rbx,	[%rbp + cc_parse.createcall.q]
    mov       %r13,	1
    mov       %rax,	[%rbp + cc_parse.createcall.aparams]
    cmp       %rax,	1
    jl        L5612
L5610:
    cmp       %r13,	%r14
    jg        L5614
    movsxd    %rax,	dword ptr[%r12+16]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    call      cc_parse.coercemode_inplace
    mov       %r12,	[%r12+8]
    jmp       L5613
L5614:
    movsxd    %rax,	dword ptr[%rbx+52]
    test      %rax,	%rax
    jnz       L5616
    lea       %rcx,	[%rip+L9051]
    call      cc_support.terror
L5616:
    mov       %rcx,	%rbx
    call      cc_parse.coercebasetype
L5613:
    mov       %rbx,	[%rbx+8]
    inc       %r13
    cmp       %r13,	[%rbp + cc_parse.createcall.aparams]
    jle       L5610
L5612:
    mov       %rcx,	30
    mov       %rdx,	[%rbp + cc_parse.createcall.p]
    mov       %r8,	[%rbp + cc_parse.createcall.q]
    call      cc_lib.createunit2
    mov       %rdi,	%rax
    mov       %eax,	[%rbp + cc_parse.createcall.retmode]
    mov       [%rdi+52],	%eax
    mov       %rcx,	%rdi
    call      cc_parse.fixmemopnd
    mov       %eax,	[%rbp + cc_parse.createcall.aparams]
    mov       [%rdi+48],	%eax
    mov       %rax,	%rdi
L5588:
#---------------
    add       %rsp,	64
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.arraytopointer
cc_parse.arraytopointer:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r14,	%rcx
#---------------
#PROC3
#PROC4
    movsxd    %rax,	dword ptr[%r14+52]
    mov       %rsi,	%rax
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%rsi
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %r12,	%rax
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rsi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jnz       L5619
    mov       %rcx,	%r12
    call      cc_lib.createrefmode
    mov       %r13,	%rax
    movsxd    %rax,	dword ptr[%r14+40]
    cmp       %rax,	52
    jz        L5621
    cmp       %rax,	49
    jz        L5622
    jmp       L5623
L5621:
    mov       %r14,	[%r14+16]
    jmp       L5620
L5622:
    movsxd    %rax,	dword ptr[%r14]
    mov       %rbx,	%rax
    mov       %eax,	53
    mov       [%r14+40],	%eax
    mov       %eax,	1
    mov       [%r14],	%eax
    mov       %rax,	[%r14+16]
    mov       %rcx,	55
    mov       %rdx,	%rax
    call      cc_lib.createunit1
    mov       %rdi,	%rax
    mov       [%rdi+52],	%r13d
    mov       [%r14+16],	%rdi
    mov       %rcx,	%rbx
    mov       %rdx,	3
    call      cc_lib.createconstunit
    mov       [%r14+24],	%rax
    jmp       L5620
L5623:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L9052]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    xor       %ecx,	%ecx
    mov       %rdx,	%r14
    xor       %r8d,	%r8d
    lea       %r9,	[%rip+L9053]
    call      cc_show.printunit
    lea       %rcx,	[%rip+L9054]
    call      cc_support.terror
L5620:
    mov       [%r14+52],	%r13d
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8]
    mov       [%r14+48],	%eax
L5619:
    mov       %rax,	%r14
L5617:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createindexop
cc_parse.createindexop:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      cc_parse.createaddop
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    call      cc_parse.createptrop
L5624:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readstructdecl
cc_parse.readstructdecl:
#PROC1
#PROC2
#?>>
    .set cc_parse.readstructdecl.owner, 64
    .set cc_parse.readstructdecl.d, -8
    .set cc_parse.readstructdecl.ulist, -16
    .set cc_parse.readstructdecl.ulistx, -24
    .set cc_parse.readstructdecl.linkage, -32
    .set cc_parse.readstructdecl.offset, -40
    .set cc_parse.readstructdecl.recsize, -48
    .set cc_parse.readstructdecl.maxsize, -56
    .set cc_parse.readstructdecl.maxalignment, -64
    .set cc_parse.readstructdecl.alignment, -72
    .set cc_parse.readstructdecl.size, -80
    .set cc_parse.readstructdecl.pm, -88
    .set cc_parse.readstructdecl.fieldlist, -96
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	128
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	84
    setz      %al
    movzx     %eax,	%al
    mov       %r12,	%rax
    call      cc_lex.lex
    mov       %rax,	[%rip+cc_decls.currproc]
    test      %rax,	%rax
    jz        L5627
    mov       %rax,	[%rip+cc_decls.currproc]
    jmp       L5626
L5627:
    mov       %rax,	[%rip+cc_decls.stmodule]
L5626:
    mov       %rsi,	%rax
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	17
    jnz       L5629
    call      cc_lib.nextautotype
    mov       %rcx,	%rax
    call      cc_lex.addnamestr
    mov       [%rbp + cc_parse.readstructdecl.d],	%rax
    jmp       L5628
L5629:
    mov       %rcx,	67
    call      cc_lib.checksymbol
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       [%rbp + cc_parse.readstructdecl.d],	%rax
    call      cc_lex.lex
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	17
    jz        L5631
    mov       %rcx,	%rsi
    mov       %rdx,	[%rbp + cc_parse.readstructdecl.d]
    mov       %r8,	2
    mov       %r9,	[%rip+cc_decls.currblockno]
    call      cc_lib.resolvename
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L5633
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	13
    jz        L5635
    mov       %rax,	[%rdi]
    lea       %rcx,	[%rip+L9055]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L5635:
    movzx     %rax,	word ptr[%rdi+102]
    jmp       L5625
L5633:
    mov       %rcx,	%rsi
    mov       %rdx,	[%rbp + cc_parse.readstructdecl.d]
    mov       %r8,	13
    call      cc_lib.createdupldef
    mov       %rdi,	%rax
    test      %r12,	%r12
    jz        L5637
    mov       %rax,	19
    jmp       L5636
L5637:
    mov       %rax,	18
L5636:
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      cc_lib.createstructmode
    mov       [%rdi+102],	%ax
    mov       %ax,	[%rip+cc_decls.currblockno]
    mov       [%rdi+96],	%ax
    mov       %eax,	1
    lea       %r10,	[%rip+cc_decls.blockcounts]
    mov       %r11,	[%rip+cc_decls.currblockno]
    mov       [%r10 + %r11*4],	%eax
    movzx     %rax,	word ptr[%rdi+102]
    jmp       L5625
L5631:
L5628:
    mov       %rcx,	%rsi
    mov       %rdx,	[%rbp + cc_parse.readstructdecl.d]
    mov       %r8,	2
    mov       %r9,	[%rip+cc_decls.currblockno]
    call      cc_lib.checkdupl
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L5639
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	13
    jz        L5641
    mov       %rax,	[%rdi]
    lea       %rcx,	[%rip+L9055]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L5641:
    mov       %rax,	[%rdi+16]
    test      %rax,	%rax
    jz        L5643
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L9056]
    call      msys.m$print_str_nf
    mov       %eax,	[%rdi+92]
    and       %rax,	1677215
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    mov       %eax,	[%rdi+92]
    sar       %rax,	24
    lea       %r10,	[%rip+cc_decls.sourcefilenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    mov       %eax,	[%rdi+92]
    sar       %rax,	24
    lea       %r10,	[%rip+cc_decls.sourcefilepaths]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rax,	[%rdi]
    lea       %rcx,	[%rip+L9057]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L5643:
    jmp       L5638
L5639:
    mov       %rcx,	%rsi
    mov       %rdx,	[%rbp + cc_parse.readstructdecl.d]
    mov       %r8,	13
    call      cc_lib.createdupldef
    mov       %rdi,	%rax
    test      %r12,	%r12
    jz        L5645
    mov       %rax,	19
    jmp       L5644
L5645:
    mov       %rax,	18
L5644:
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      cc_lib.createstructmode
    mov       [%rdi+102],	%ax
    mov       %ax,	[%rip+cc_decls.currblockno]
    mov       [%rdi+96],	%ax
    mov       %eax,	1
    lea       %r10,	[%rip+cc_decls.blockcounts]
    mov       %r11,	[%rip+cc_decls.currblockno]
    mov       [%r10 + %r11*4],	%eax
L5638:
    call      cc_lex.lex
    mov       %rbx,	%rdi
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readstructdecl.ulistx],	%rax
    mov       [%rbp + cc_parse.readstructdecl.ulist],	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readstructdecl.recsize],	%rax
    mov       [%rbp + cc_parse.readstructdecl.maxsize],	%rax
    mov       [%rbp + cc_parse.readstructdecl.offset],	%rax
    mov       %rax,	1
    mov       [%rbp + cc_parse.readstructdecl.maxalignment],	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readstructdecl.fieldlist],	%rax
    mov       %r14,	-1
    jmp       L5647
L5646:
    mov       %rcx,	%rbx
    lea       %rdx,	[%rbp + cc_parse.readstructdecl.linkage]
    call      cc_parse.readdeclspec
    mov       %r13,	%rax
L5649:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L5651
    cmp       %rax,	25
    jz        L5651
    cmp       %rax,	13
    jz        L5651
    cmp       %rax,	10
    jz        L5652
    jmp       L5653
L5651:
    mov       %rcx,	%rbx
    lea       %rdx,	[%rbp + cc_parse.readstructdecl.d]
    mov       %r8,	%r13
    lea       %r9,	[%rbp + cc_parse.readstructdecl.pm]
    call      cc_parse.readtype
    mov       %r14,	%rax
    mov       %rax,	[%rbp + cc_parse.readstructdecl.d]
    test      %rax,	%rax
    jnz       L5655
    lea       %rcx,	[%rip+L9058]
    call      cc_support.serror
L5655:
    mov       %rax,	[%rbp + cc_parse.readstructdecl.linkage]
    cmp       %rax,	5
    jz        L5658
    mov       %rax,	[%rbp + cc_parse.readstructdecl.pm]
    test      %rax,	%rax
    jz        L5657
L5658:
    lea       %rcx,	[%rip+L9059]
    call      cc_support.serror
L5657:
    mov       %rcx,	%rbx
    mov       %rdx,	[%rbp + cc_parse.readstructdecl.d]
    mov       %r8,	4
    xor       %r9d,	%r9d
    call      cc_lib.checkdupl
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L5660
    mov       %rax,	[%rdi]
    lea       %rcx,	[%rip+L9060]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L5660:
    mov       %rax,	[%rbp + cc_parse.readstructdecl.linkage]
    test      %rax,	%rax
    jz        L5662
    lea       %rcx,	[%rip+L9061]
    call      cc_support.serror
L5662:
#cc_parse.readstructdecl.addanonfield:
L5663:
    xor       %ecx,	%ecx
    mov       %rdx,	[%rbp + cc_parse.readstructdecl.d]
    mov       %r8,	10
    call      cc_lib.createdupldef
    mov       [%rbp + cc_parse.readstructdecl.d],	%rax
    mov       %ax,	%r14w
    mov       %r10,	[%rbp + cc_parse.readstructdecl.d]
    mov       [%r10+102],	%ax
    lea       %rcx,	[%rbp + cc_parse.readstructdecl.ulist]
    lea       %rdx,	[%rbp + cc_parse.readstructdecl.ulistx]
    mov       %r8,	[%rbp + cc_parse.readstructdecl.d]
    call      cc_lib.addlistdef
    mov       %rax,	[%rbp + cc_parse.readstructdecl.ulist]
    mov       [%rbx+16],	%rax
    mov       %rax,	[%rbp + cc_parse.readstructdecl.ulistx]
    mov       [%rbx+24],	%rax
    mov       %rax,	%rbx
    mov       %r10,	[%rbp + cc_parse.readstructdecl.d]
    mov       [%r10+8],	%rax
    mov       %rcx,	%r14
    call      cc_lib.getalignment
    mov       [%rbp + cc_parse.readstructdecl.alignment],	%rax
    mov       %rax,	[%rbp + cc_parse.readstructdecl.alignment]
    cmp       %rax,	[%rbp + cc_parse.readstructdecl.maxalignment]
    jle       L5665
    mov       %rax,	[%rbp + cc_parse.readstructdecl.alignment]
    mov       [%rbp + cc_parse.readstructdecl.maxalignment],	%rax
L5665:
    mov       %rcx,	[%rbp + cc_parse.readstructdecl.offset]
    mov       %rdx,	[%rbp + cc_parse.readstructdecl.alignment]
    call      cc_parse.roundoffset
    mov       %r10,	[%rbp + cc_parse.readstructdecl.d]
    mov       [%r10+88],	%eax
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%r14
    mov       %rax,	[%rax + %r10*8]
    mov       [%rbp + cc_parse.readstructdecl.size],	%rax
    mov       %rax,	[%rbp + cc_parse.readstructdecl.d]
    movsxd    %rax,	dword ptr[%rax+88]
    sub       %rax,	[%rbp + cc_parse.readstructdecl.offset]
    add       [%rbp + cc_parse.readstructdecl.recsize],	%rax
    mov       %rax,	[%rbp + cc_parse.readstructdecl.d]
    movsxd    %rax,	dword ptr[%rax+88]
    mov       [%rbp + cc_parse.readstructdecl.offset],	%rax
    lea       %rcx,	[%rbp + cc_parse.readstructdecl.fieldlist]
    mov       %rdx,	[%rbp + cc_parse.readstructdecl.d]
    mov       %r8,	[%rbp + cc_parse.readstructdecl.offset]
    call      cc_parse.addnewfield
    test      %r12,	%r12
    jz        L5667
    mov       %rax,	[%rbp + cc_parse.readstructdecl.maxsize]
    mov       %r10,	[%rbp + cc_parse.readstructdecl.size]
    cmp       %rax,	%r10
    cmovl     %rax,	%r10
    mov       [%rbp + cc_parse.readstructdecl.maxsize],	%rax
    jmp       L5666
L5667:
    mov       %rax,	[%rbp + cc_parse.readstructdecl.size]
    add       [%rbp + cc_parse.readstructdecl.offset],	%rax
    mov       %rax,	[%rbp + cc_parse.readstructdecl.size]
    add       [%rbp + cc_parse.readstructdecl.recsize],	%rax
L5666:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	10
    jnz       L5669
    call      cc_lex.lex
    call      cc_parse.readassignexpr
L5669:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jnz       L5672
L5671:
    call      cc_lex.lex
    jmp       L5670
L5672:
    mov       %rcx,	9
    call      cc_lib.skipsymbol
    jmp       L5650
L5670:
    jmp       L5649
L5652:
    call      cc_lex.lex
    call      cc_parse.readassignexpr
    mov       %rcx,	9
    call      cc_lib.skipsymbol
    jmp       L5650
L5653:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%r13
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	18
    jz        L5674
    cmp       %rax,	19
    jnz       L5675
L5674:
    call      cc_lib.getautofieldname
    mov       [%rbp + cc_parse.readstructdecl.d],	%rax
    mov       %r14,	%r13
    jmp       L5663
L5675:
    cmp       %r14,	-1
    jnz       L5677
    lea       %rcx,	[%rip+L9062]
    call      cc_support.serror
    jmp       L5676
L5677:
    mov       %rcx,	%r14
    call      cc_lib.typename
    lea       %rcx,	[%rip+L9063]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L5676:
L5673:
    jmp       L5649
L5650:
L5647:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	18
    jnz       L5646
    mov       %rcx,	18
    call      cc_lib.skipsymbol
    mov       %rax,	[%rbp + cc_parse.readstructdecl.fieldlist]
    mov       [%rbx+64],	%rax
    test      %r12,	%r12
    jz        L5679
    mov       %rax,	[%rbp + cc_parse.readstructdecl.maxsize]
    jmp       L5678
L5679:
    mov       %rax,	[%rbp + cc_parse.readstructdecl.recsize]
L5678:
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + cc_parse.readstructdecl.maxalignment]
    call      cc_parse.roundoffset
    movzx     %r10,	word ptr[%rbx+102]
    lea       %r11,	[%rip+cc_decls.ttsize]
    mov       [%r11 + %r10*8],	%rax
    mov       %al,	[%rbp + cc_parse.readstructdecl.maxalignment]
    mov       [%rbx+112],	%al
    movzx     %rax,	word ptr[%rbx+102]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r10,	[%r10 + %rax*8]
    cmp       %r10,	1
    jz        L5682
    cmp       %r10,	2
    jz        L5682
    cmp       %r10,	4
    jz        L5682
    cmp       %r10,	8
    jnz       L5681
L5682:
    movzx     %rax,	word ptr[%rbx+102]
    xor       %r10d,	%r10d
    lea       %r11,	[%rip+cc_decls.ttisblock]
    mov       [%r11 + %rax],	%r10b
L5681:
    movzx     %rax,	word ptr[%rbx+102]
L5625:
#---------------
    add       %rsp,	128
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.checkpointertypes
cc_parse.checkpointertypes:
#PROC1
#PROC2
#?>>
    .set cc_parse.checkpointertypes.t, 80
    .set cc_parse.checkpointertypes.hard, 88
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %r15,	%rcx
    mov       [%rbp+80],	%rdx
    mov       [%rbp+88],	%r8
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%r15
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	[%rbp + cc_parse.checkpointertypes.t]
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rbx,	%rax
    xor       %r13,	%r13
    xor       %eax,	%eax
    mov       %r14,	%rax
    lea       %rax,	[%rip+cc_decls.ttconst]
    mov       %r10,	%rdi
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5685
    lea       %rax,	[%rip+cc_decls.ttconsttype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rdi,	%rax
    mov       %r13,	1
L5685:
    lea       %rax,	[%rip+cc_decls.ttconst]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5687
    lea       %rax,	[%rip+cc_decls.ttconsttype]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rbx,	%rax
    mov       %r14,	1
L5687:
    mov       %rax,	[%rbp + cc_parse.checkpointertypes.hard]
    test      %rax,	%rax
    jnz       L5689
    test      %r13,	%r13
    jz        L5689
    test      %r14,	%r14
    jnz       L5689
    call      msys.m$print_startcon
    mov       %rcx,	%r15
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    mov       %rcx,	[%rbp + cc_parse.checkpointertypes.t]
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L9064]
    call      cc_support.terror
L5689:
    cmp       %rdi,	%rbx
    jnz       L5691
    mov       %rax,	1
    jmp       L5683
L5691:
    mov       %r15,	%rdi
    mov       [%rbp + cc_parse.checkpointertypes.t],	%rbx
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%r15
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rsi,	%rax
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	[%rbp + cc_parse.checkpointertypes.t]
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %r12,	%rax
    mov       %rax,	%rsi
    cmp       %rax,	1
    jl        L5693
    cmp       %rax,	9
    jg        L5693
    mov       %rax,	%r12
    cmp       %rax,	1
    jl        L5693
    cmp       %rax,	9
    jg        L5693
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r11,	%r12
    mov       %r10,	[%r10 + %r11*8]
    cmp       %rax,	%r10
    jnz       L5695
    mov       %rax,	1
    jmp       L5683
L5695:
L5693:
    test      %rsi,	%rsi
    jz        L5698
    test      %r12,	%r12
    jnz       L5697
L5698:
    mov       %rax,	1
    jmp       L5683
L5697:
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%r15
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5700
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	[%rbp + cc_parse.checkpointertypes.t]
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5700
    mov       %rcx,	%r15
    mov       %rdx,	[%rbp + cc_parse.checkpointertypes.t]
    mov       %r8,	[%rbp + cc_parse.checkpointertypes.hard]
    call      cc_parse.checkpointertypes
    jmp       L5683
L5700:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%r15
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jnz       L5701
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	[%rbp + cc_parse.checkpointertypes.t]
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jnz       L5701
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%r15
    mov       %rax,	[%rax + %r10*8]
    lea       %r10,	[%rip+cc_decls.ttlength]
    mov       %r11,	[%rbp + cc_parse.checkpointertypes.t]
    mov       %r10,	[%r10 + %r11*8]
    cmp       %rax,	%r10
    jz        L5703
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%r15
    mov       %rax,	[%rax + %r10*8]
    test      %rax,	%rax
    jz        L5705
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	[%rbp + cc_parse.checkpointertypes.t]
    mov       %rax,	[%rax + %r10*8]
    test      %rax,	%rax
    jz        L5705
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L9065]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rax,	1
    jmp       L5683
    xor       %eax,	%eax
    jmp       L5683
L5705:
L5703:
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%r15
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	[%rbp + cc_parse.checkpointertypes.t]
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rbx,	%rax
    cmp       %rdi,	%rbx
    jnz       L5707
    mov       %rax,	1
    jmp       L5683
L5707:
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%rdi
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5709
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5709
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	[%rbp + cc_parse.checkpointertypes.hard]
    call      cc_parse.checkpointertypes
    jmp       L5683
L5709:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jnz       L5711
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jnz       L5711
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	[%rbp + cc_parse.checkpointertypes.hard]
    call      cc_parse.checkpointertypes
    jmp       L5683
L5711:
    jmp       L5699
L5701:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%r15
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	14
    jnz       L5712
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	[%rbp + cc_parse.checkpointertypes.t]
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	14
    jnz       L5712
    mov       %rax,	1
    jmp       L5683
L5712:
L5699:
    xor       %eax,	%eax
L5683:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.comparemode
cc_parse.comparemode:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    cmp       %rdi,	%rbx
    jnz       L5715
    mov       %rax,	1
    jmp       L5713
L5715:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jnz       L5717
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jnz       L5717
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    lea       %r10,	[%rip+cc_decls.tttarget]
    mov       %r11,	%rdi
    movsx     %r10,	word ptr[%r10 + %r11*2]
    mov       %rcx,	%r10
    mov       %rdx,	%rax
    call      cc_parse.comparemode
    test      %rax,	%rax
    jnz       L5719
    xor       %eax,	%eax
    jmp       L5713
L5719:
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    test      %rax,	%rax
    jz        L5722
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8]
    test      %rax,	%rax
    jz        L5722
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    lea       %r10,	[%rip+cc_decls.ttlength]
    mov       %r11,	%rbx
    mov       %r10,	[%r10 + %r11*8]
    cmp       %rax,	%r10
    jnz       L5721
L5722:
    mov       %rax,	1
    jmp       L5713
L5721:
L5717:
    xor       %eax,	%eax
L5713:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readenumdecl
cc_parse.readenumdecl:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
#PROC3
#PROC4
    call      cc_lex.lex
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	17
    jnz       L5725
    mov       %rcx,	%rsi
    call      cc_parse.readenumnames
    mov       %rax,	12
    jmp       L5723
L5725:
    mov       %rcx,	67
    call      cc_lib.checksymbol
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rdi,	[%rax]
    call      cc_lex.lex
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	17
    jz        L5727
    mov       %rcx,	%rsi
    mov       %rdx,	%rdi
    mov       %r8,	2
    mov       %r9,	[%rip+cc_decls.currblockno]
    call      cc_lib.checkdupl
    mov       %rbx,	%rax
    test      %rbx,	%rbx
    jz        L5729
    movzx     %rax,	byte ptr[%rbx+109]
    cmp       %rax,	12
    jz        L5731
    mov       %rax,	[%rbx]
    lea       %rcx,	[%rip+L9066]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L5731:
L5729:
    mov       %rcx,	%rsi
    mov       %rdx,	%rdi
    mov       %r8,	12
    call      cc_lib.createdupldef
    mov       %rbx,	%rax
    mov       %rcx,	%rbx
    call      cc_lib.createenummode
    mov       [%rbx+102],	%ax
    mov       %ax,	[%rip+cc_decls.currblockno]
    mov       [%rbx+96],	%ax
    mov       %eax,	1
    lea       %r10,	[%rip+cc_decls.blockcounts]
    mov       %r11,	[%rip+cc_decls.currblockno]
    mov       [%r10 + %r11*4],	%eax
    movzx     %rax,	word ptr[%rbx+102]
    jmp       L5723
L5727:
    mov       %rcx,	%rsi
    mov       %rdx,	%rdi
    mov       %r8,	2
    mov       %r9,	[%rip+cc_decls.currblockno]
    call      cc_lib.checkdupl
    mov       %rbx,	%rax
    test      %rbx,	%rbx
    jz        L5733
    movzx     %rax,	byte ptr[%rbx+109]
    cmp       %rax,	12
    jz        L5735
    mov       %rax,	[%rbx]
    lea       %rcx,	[%rip+L9066]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L5735:
    mov       %rax,	[%rbx+16]
    test      %rax,	%rax
    jz        L5737
    mov       %rax,	[%rbx]
    lea       %rcx,	[%rip+L9067]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L5737:
    jmp       L5732
L5733:
    mov       %rcx,	%rsi
    mov       %rdx,	%rdi
    mov       %r8,	12
    call      cc_lib.createdupldef
    mov       %rbx,	%rax
    mov       %rcx,	%rbx
    call      cc_lib.createenummode
    mov       [%rbx+102],	%ax
    mov       %ax,	[%rip+cc_decls.currblockno]
    mov       [%rbx+96],	%ax
    mov       %eax,	1
    lea       %r10,	[%rip+cc_decls.blockcounts]
    mov       %r11,	[%rip+cc_decls.currblockno]
    mov       [%r10 + %r11*4],	%eax
L5732:
    mov       %rcx,	%rsi
    call      cc_parse.readenumnames
    movzx     %rax,	word ptr[%rbx+102]
    mov       %r10,	%rbx
    lea       %r11,	[%rip+cc_decls.ttnamedef]
    mov       [%r11 + %rax*8],	%r10
    movzx     %rax,	word ptr[%rbx+102]
L5723:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readenumnames
cc_parse.readenumnames:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r13,	%rcx
#---------------
#PROC3
#PROC4
    xor       %eax,	%eax
    mov       %rsi,	%rax
    mov       %rbx,	%rax
    xor       %r12,	%r12
    call      cc_lex.lex
    movzx     %rax,	byte ptr[%r13+109]
    cmp       %rax,	6
    jz        L5740
    cmp       %rax,	3
    jnz       L5741
L5740:
    jmp       L5739
L5741:
    mov       %rax,	[%rip+cc_decls.currproc]
    test      %rax,	%rax
    jz        L5743
    mov       %rax,	[%rip+cc_decls.currproc]
    jmp       L5742
L5743:
    mov       %rax,	[%rip+cc_decls.stmodule]
L5742:
    mov       %r13,	%rax
L5739:
    jmp       L5745
L5744:
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       %rcx,	%r13
    mov       %rdx,	%rax
    mov       %r8,	1
    mov       %r9,	[%rip+cc_decls.currblockno]
    call      cc_lib.checkdupl
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L5748
    mov       %rax,	[%rdi]
    lea       %rcx,	[%rip+L9068]
    mov       %rdx,	%rax
    call      cc_support.serror_s
L5748:
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       %rcx,	%r13
    mov       %rdx,	%rax
    mov       %r8,	11
    call      cc_lib.createdupldef
    mov       %rdi,	%rax
    call      cc_lex.lex
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	11
    jnz       L5750
    call      cc_lex.lex
    call      cc_parse.readconstintexpr
    mov       %r12,	%rax
L5750:
    mov       [%rdi+88],	%r12d
    mov       %ax,	[%rip+cc_decls.currblockno]
    mov       [%rdi+96],	%ax
    mov       %eax,	1
    lea       %r10,	[%rip+cc_decls.blockcounts]
    mov       %r11,	[%rip+cc_decls.currblockno]
    mov       [%r10 + %r11*4],	%eax
    inc       %r12
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jnz       L5752
    call      cc_lex.lex
L5752:
L5745:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jz        L5744
    mov       %rcx,	18
    call      cc_lib.skipsymbol
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createdotop
cc_parse.createdotop:
#PROC1
#PROC2
#?>>
    .set cc_parse.createdotop.p, 80
    .set cc_parse.createdotop.d, 88
    .set cc_parse.createdotop.fl, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %r15,	%rcx
    mov       [%rbp+80],	%rdx
    mov       [%rbp+88],	%r8
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rbp + cc_parse.createdotop.p]
    movsxd    %rax,	dword ptr[%rax+52]
    mov       %r13,	%rax
    cmp       %r15,	50
    jnz       L5755
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%r13
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jnz       L5757
    lea       %rcx,	[%rip+L9069]
    call      cc_support.serror
L5757:
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%r13
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %r13,	%rax
L5755:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%r13
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	18
    jz        L5759
    cmp       %rax,	19
    jnz       L5760
L5759:
    jmp       L5758
L5760:
    lea       %rcx,	[%rip+L9070]
    call      cc_support.serror
L5758:
    lea       %rax,	[%rip+cc_decls.ttnamedef]
    mov       %r10,	%r13
    mov       %rsi,	[%rax + %r10*8]
    mov       %rbx,	[%rbp + cc_parse.createdotop.d]
    jmp       L5762
L5761:
    mov       %rax,	[%rbx+8]
    cmp       %rax,	%rsi
    jnz       L5765
    movsxd    %rax,	dword ptr[%rbx+88]
    mov       %r14,	%rax
    jmp       L5763
L5765:
L5762:
    mov       %rax,	[%rbx+40]
    mov       %rbx,	%rax
    test      %rax,	%rax
    jnz       L5761
L5763:
    test      %rbx,	%rbx
    jnz       L5767
    mov       %r12,	[%rbp + cc_parse.createdotop.d]
    jmp       L5769
L5768:
    mov       %r12,	[%r12+48]
L5769:
    mov       %rax,	[%r12+48]
    test      %rax,	%rax
    jnz       L5768
    mov       %rax,	[%rsi+64]
    mov       [%rbp + cc_parse.createdotop.fl],	%rax
    jmp       L5772
L5771:
    mov       %rax,	[%rbp + cc_parse.createdotop.fl]
    mov       %rax,	[%rax+8]
    cmp       %rax,	%r12
    jnz       L5775
    mov       %rax,	[%rbp + cc_parse.createdotop.fl]
    mov       %rbx,	[%rax]
    mov       %rax,	[%rbp + cc_parse.createdotop.fl]
    mov       %r14,	[%rax+24]
    jmp       L5773
L5775:
    mov       %rax,	[%rbp + cc_parse.createdotop.fl]
    mov       %rax,	[%rax+16]
    mov       [%rbp + cc_parse.createdotop.fl],	%rax
L5772:
    mov       %rax,	[%rbp + cc_parse.createdotop.fl]
    test      %rax,	%rax
    jnz       L5771
L5773:
L5767:
    test      %rbx,	%rbx
    jnz       L5777
    mov       %rcx,	%r13
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %r10,	[%rbp + cc_parse.createdotop.d]
    mov       %r10,	[%r10]
    lea       %rcx,	[%rip+L9071]
    mov       %rdx,	%r10
    mov       %r8,	%rax
    call      cc_support.terror_ss
L5777:
    mov       %rcx,	%r14
    mov       %rdx,	3
    call      cc_lib.createconstunit
    mov       %rdi,	%rax
    cmp       %r15,	50
    jnz       L5779
    mov       %rcx,	[%rbp + cc_parse.createdotop.p]
    call      cc_parse.createptrop
    mov       [%rbp + cc_parse.createdotop.p],	%rax
L5779:
    mov       %rcx,	49
    mov       %rdx,	[%rbp + cc_parse.createdotop.p]
    call      cc_lib.createunit1
    mov       [%rbp + cc_parse.createdotop.p],	%rax
    mov       %eax,	%r14d
    mov       %r10,	[%rbp + cc_parse.createdotop.p]
    mov       [%r10],	%eax
    movzx     %rax,	word ptr[%rbx+102]
    mov       %r10,	[%rbp + cc_parse.createdotop.p]
    mov       [%r10+52],	%eax
    mov       %rcx,	[%rbp + cc_parse.createdotop.p]
    call      cc_parse.arraytopointer
    mov       [%rbp + cc_parse.createdotop.p],	%rax
    mov       %rcx,	[%rbp + cc_parse.createdotop.p]
    call      cc_parse.fixmemopnd
    mov       %rax,	[%rbp + cc_parse.createdotop.p]
L5753:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.mulunit
cc_parse.mulunit:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8]
    mov       %rdi,	%rax
    cmp       %rax,	1
    jz        L5782
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L5784
    mov       %rax,	[%rbx]
    mov       %r10,	%rdi
    imul      %rax,	%r10
    mov       [%rbx],	%rax
    jmp       L5783
L5784:
    mov       %rcx,	57
    mov       %rdx,	%rbx
    call      cc_lib.createunit1
    mov       %rbx,	%rax
    mov       [%rbx+48],	%edi
    mov       %eax,	4
    mov       [%rbx+52],	%eax
L5783:
L5782:
    mov       %rax,	%rbx
L5780:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.divunit
cc_parse.divunit:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8]
    mov       %rdi,	%rax
    cmp       %rax,	1
    jz        L5787
    movsxd    %rax,	dword ptr[%rbx+40]
    cmp       %rax,	1
    jnz       L5789
    mov       %rax,	[%rbx]
    mov       %r10,	%rdi
    cqo       
    idiv      %r10
    mov       [%rbx],	%rax
    jmp       L5788
L5789:
    mov       %rcx,	57
    mov       %rdx,	%rbx
    call      cc_lib.createunit1
    mov       %rbx,	%rax
    mov       %rax,	%rdi
    neg       %rax
    mov       [%rbx+48],	%eax
    mov       %eax,	4
    mov       [%rbx+52],	%eax
L5788:
L5787:
    mov       %rax,	%rbx
L5785:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createassignopref
cc_parse.createassignopref:
#PROC1
#PROC2
#?>>
    .set cc_parse.createassignopref.q, 88
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %r14,	%rcx
    mov       %r15,	%rdx
    mov       [%rbp+88],	%r8
#---------------
#PROC3
#PROC4
    movsxd    %rax,	dword ptr[%r15+52]
    mov       %rsi,	%rax
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %r12,	%rax
    mov       %rax,	[%rbp + cc_parse.createassignopref.q]
    movsxd    %rax,	dword ptr[%rax+52]
    mov       %rbx,	%rax
    mov       %rax,	%r14
    cmp       %rax,	11
    jz        L5792
    cmp       %rax,	46
    jz        L5793
    cmp       %rax,	47
    jz        L5794
    jmp       L5795
L5792:
    mov       %rcx,	[%rbp + cc_parse.createassignopref.q]
    mov       %rdx,	%rdi
    call      cc_parse.coercemode
    mov       [%rbp + cc_parse.createassignopref.q],	%rax
    mov       %rcx,	11
    mov       %rdx,	%r15
    mov       %r8,	[%rbp + cc_parse.createassignopref.q]
    call      cc_lib.createunit2
    mov       %r13,	%rax
    jmp       L5791
L5793:
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5797
    lea       %rcx,	[%rip+L9072]
    call      cc_support.serror
L5797:
    mov       %rcx,	[%rbp + cc_parse.createassignopref.q]
    mov       %rdx,	4
    call      cc_parse.coercemode
    mov       [%rbp + cc_parse.createassignopref.q],	%rax
    mov       %rcx,	[%rbp + cc_parse.createassignopref.q]
    mov       %rdx,	%r12
    call      cc_parse.mulunit
    mov       %rcx,	61
    mov       %rdx,	%r15
    mov       %r8,	%rax
    call      cc_lib.createunit2
    mov       %r13,	%rax
    jmp       L5791
L5794:
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5799
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      cc_parse.comparemode
    test      %rax,	%rax
    jnz       L5801
    lea       %rcx,	[%rip+L9073]
    call      cc_support.serror
L5801:
    mov       %rcx,	40
    mov       %rdx,	%r15
    mov       %r8,	[%rbp + cc_parse.createassignopref.q]
    call      cc_lib.createunit2
    mov       %rcx,	%rax
    mov       %rdx,	%r12
    call      cc_parse.divunit
    mov       %r13,	%rax
    mov       %rsi,	3
    jmp       L5798
L5799:
    mov       %rcx,	[%rbp + cc_parse.createassignopref.q]
    mov       %rdx,	%r12
    call      cc_parse.mulunit
    mov       %rcx,	62
    mov       %rdx,	%r15
    mov       %r8,	%rax
    call      cc_lib.createunit2
    mov       %r13,	%rax
L5798:
    jmp       L5791
L5795:
    lea       %rcx,	[%rip+L9074]
    call      cc_support.serror
L5791:
    mov       [%r13+52],	%esi
    mov       %rax,	%r13
L5790:
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.addnewfield
cc_parse.addnewfield:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
#PROC3
#PROC4
    mov       %rax,	[%r12]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	36
    jz        L5804
    mov       %rcx,	32
    call      mlib.pcm_allocz
    mov       %rbx,	%rax
    mov       [%rbx],	%r12
    jmp       L5806
L5805:
    mov       %r12,	[%r12+48]
L5806:
    mov       %rax,	[%r12+48]
    test      %rax,	%rax
    jnz       L5805
    mov       [%rbx+8],	%r12
    mov       [%rbx+24],	%r13
    mov       %rax,	[%rsi]
    mov       [%rbx+16],	%rax
    mov       [%rsi],	%rbx
    jmp       L5803
L5804:
    movzx     %rax,	word ptr[%r12+102]
    lea       %r10,	[%rip+cc_decls.ttnamedef]
    mov       %r10,	[%r10 + %rax*8]
    mov       %r10,	[%r10+16]
    mov       %rdi,	%r10
    jmp       L5809
L5808:
    movsxd    %rax,	dword ptr[%rdi+88]
    mov       %r10,	%r13
    add       %r10,	%rax
    mov       %rcx,	%rsi
    mov       %rdx,	%rdi
    mov       %r8,	%r10
    call      cc_parse.addnewfield
    mov       %rdi,	[%rdi+32]
L5809:
    test      %rdi,	%rdi
    jnz       L5808
L5803:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.pushloop
cc_parse.pushloop:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+cc_parse.loopindex]
    cmp       %rax,	64
    jl        L5813
    lea       %rcx,	[%rip+L9075]
    call      cc_support.serror
L5813:
    inc       qword ptr[%rip+cc_parse.loopindex]
    mov       %al,	%dil
    lea       %r10,	[%rip+cc_parse.looptypestack]
    mov       %r11,	[%rip+cc_parse.loopindex]
    mov       [%r10 + %r11-1],	%al
    xor       %eax,	%eax
    lea       %r10,	[%rip+cc_parse.casevaluestack]
    mov       %r11,	[%rip+cc_parse.loopindex]
    mov       [%r10 + %r11*8-8],	%rax
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_parse.poploop
cc_parse.poploop:
#PROC1
#PROC2
#?>>
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+cc_parse.loopindex]
    test      %rax,	%rax
    jz        L5816
    dec       qword ptr[%rip+cc_parse.loopindex]
    jmp       L5815
L5816:
    lea       %rcx,	[%rip+L9076]
    call      cc_support.serror
L5815:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_parse.addcasevalue
cc_parse.addcasevalue:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rbx,	[%rip+cc_parse.loopindex]
    jmp       L5819
L5818:
    dec       %rbx
L5819:
    test      %rbx,	%rbx
    jz        L5821
    lea       %rax,	[%rip+cc_parse.looptypestack]
    mov       %r10,	%rbx
    movzx     %rax,	byte ptr[%rax + %r10-1]
    cmp       %rax,	83
    jnz       L5818
L5821:
    test      %rbx,	%rbx
    jnz       L5823
    lea       %rcx,	[%rip+L9077]
    call      cc_support.serror
L5823:
    mov       %rcx,	16
    call      mlib.pcm_alloc
    mov       %rdi,	%rax
    mov       [%rdi+8],	%rsi
    lea       %rax,	[%rip+cc_parse.casevaluestack]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8-8]
    mov       [%rdi],	%rax
    mov       %rax,	%rdi
    lea       %r10,	[%rip+cc_parse.casevaluestack]
    mov       %r11,	%rbx
    mov       [%r10 + %r11*8-8],	%rax
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.roundoffset
cc_parse.roundoffset:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	16
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+cc_decls.structpadding]
    test      %rax,	%rax
    jz        L5826
    cmp       %rdx,	1
    jnz       L5828
    mov       %rax,	%rcx
    jmp       L5824
L5828:
    lea       %rax,	[%rdx-1]
    mov       %rdi,	%rax
    jmp       L5830
L5829:
    inc       %rcx
L5830:
    mov       %rax,	%rcx
    and       %rax,	%rdi
    jnz       L5829
L5826:
    mov       %rax,	%rcx
L5824:
#---------------
    add       %rsp,	16
    pop       %rdi
    ret       
# End 
# Proc cc_parse.fixmemopnd
cc_parse.fixmemopnd:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	16
#---------------
#PROC3
#PROC4
    mov       %al,	[%rip+cc_parse.ingeneric]
    test      %al,	%al
    jnz       L5832
L5834:
    movsxd    %rax,	dword ptr[%rcx+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rdi,	%r10
    cmp       %r10,	1
    jz        L5836
    cmp       %r10,	2
    jz        L5836
    cmp       %r10,	6
    jz        L5836
    cmp       %r10,	7
    jz        L5836
    cmp       %r10,	5
    jz        L5836
    jmp       L5837
L5836:
    mov       [%rcx+56],	%di
    mov       %eax,	3
    mov       [%rcx+52],	%eax
L5837:
L5835:
L5832:
#---------------
    add       %rsp,	16
    pop       %rdi
    ret       
# End 
# Proc cc_parse.docast
cc_parse.docast:
#PROC1
#PROC2
#?>>
    .set cc_parse.docast.inplace, 88
    .set cc_parse.docast.$T1, -8
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
    mov       [%rbp+88],	%r9
#---------------
#PROC3
#PROC4
    movsxd    %rax,	dword ptr[%r12+52]
    mov       %rbx,	%rax
#cc_parse.docast.retry:
L5839:
    cmp       %rbx,	%r13
    jnz       L5841
    mov       %rax,	%r12
    jmp       L5838
L5841:
    xor       %rsi,	%rsi
    mov       %rax,	%rbx
    cmp       %rax,	16
    jge       L5843
    cmp       %r13,	16
    jge       L5843
    lea       %rax,	[%rip+cc_tables.conversionops]
    mov       %r10,	%rbx
    shl       %r10,	4
    lea       %rax,	[%rax + %r10]
    mov       %r10,	%r13
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %rsi,	%rax
    jmp       L5842
L5843:
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5844
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%r13
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5844
    mov       %rcx,	%rbx
    mov       %rdx,	%r13
    mov       %r8,	%r14
    call      cc_parse.checkpointertypes
    test      %rax,	%rax
    jz        L5846
    mov       [%r12+52],	%r13d
    mov       %rax,	%r12
    jmp       L5838
L5846:
    jmp       L5842
L5844:
    lea       %rax,	[%rip+cc_decls.ttconst]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5847
    lea       %rax,	[%rip+cc_decls.ttconsttype]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rbx,	%rax
    jmp       L5839
L5847:
    lea       %rax,	[%rip+cc_decls.ttconst]
    mov       %r10,	%r13
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5848
    lea       %rax,	[%rip+cc_decls.ttconsttype]
    mov       %r10,	%r13
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %r13,	%rax
    jmp       L5839
L5848:
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%r13
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5849
    mov       %rcx,	%rbx
    call      cc_lib.isintcc
    test      %rax,	%rax
    jz        L5849
    movsxd    %rax,	dword ptr[%r12+40]
    cmp       %rax,	1
    jnz       L5849
    mov       %rax,	[%r12]
    test      %rax,	%rax
    jnz       L5849
    mov       %rsi,	1
L5849:
L5842:
    test      %rsi,	%rsi
    jnz       L5851
    test      %r14,	%r14
    jnz       L5853
    call      msys.m$print_startcon
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    mov       %rcx,	%r13
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    xor       %ecx,	%ecx
    mov       %rdx,	%r12
    xor       %r8d,	%r8d
    lea       %r9,	[%rip+L9078]
    call      cc_show.printunit
    mov       %rcx,	%r13
    call      cc_lib.typename
    mov       [%rbp + cc_parse.docast.$T1],	%rax
    mov       %rcx,	%rbx
    call      cc_lib.typename
    lea       %rcx,	[%rip+L9079]
    mov       %rdx,	%rax
    mov       %r8,	[%rbp + cc_parse.docast.$T1]
    call      cc_support.terror_ss
L5853:
    mov       %rsi,	2
L5851:
    movsxd    %rax,	dword ptr[%r12+40]
    cmp       %rax,	1
    jz        L5855
    cmp       %rax,	5
    jz        L5856
    cmp       %rax,	39
    jz        L5857
    jmp       L5858
L5855:
    mov       %rcx,	%r12
    mov       %rdx,	%r13
    mov       %r8,	%rsi
    call      cc_parse.eval_convert
    test      %rax,	%rax
    jz        L5860
    mov       %rax,	%r12
    jmp       L5838
L5860:
    jmp       L5854
L5856:
    mov       [%r12+52],	%r13d
    mov       %rax,	%r12
    jmp       L5838
L5857:
    mov       %rax,	[%r12+16]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5862
    mov       %rax,	[%r12+24]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5862
    mov       %rax,	[%r12+16]
    mov       %rax,	[%rax]
    mov       %r10,	[%r12+24]
    mov       %r10,	[%r10]
    add       %rax,	%r10
    mov       [%r12],	%rax
    mov       [%r12+52],	%r13d
    mov       %eax,	1
    mov       [%r12+40],	%eax
    mov       %rax,	%r12
    jmp       L5838
L5862:
L5858:
L5854:
    mov       %rax,	[%rbp + cc_parse.docast.inplace]
    test      %rax,	%rax
    jz        L5864
    mov       %rcx,	%r12
    mov       %rdx,	56
    call      cc_parse.insertunit
    mov       [%r12+58],	%r13w
    mov       %rcx,	%r13
    call      cc_parse.getpromotedtype
    mov       [%r12+52],	%eax
    mov       [%r12+48],	%esi
    xor       %eax,	%eax
    jmp       L5838
L5864:
    mov       %rcx,	56
    mov       %rdx,	%r12
    call      cc_lib.createunit1
    mov       %rdi,	%rax
    mov       [%rdi+48],	%esi
    mov       [%rdi+58],	%r13w
    mov       %rcx,	%r13
    call      cc_parse.getpromotedtype
    mov       [%rdi+52],	%eax
L5863:
    mov       %rax,	%rdi
L5838:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.coercemode
cc_parse.coercemode:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    movsxd    %rax,	dword ptr[%rdi+52]
    cmp       %rax,	%rbx
    jnz       L5867
    mov       %rax,	%rdi
    jmp       L5865
L5867:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    mov       %r9,	1
    call      cc_parse.docast
    mov       %rax,	%rdi
L5865:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.coercemode_inplace
cc_parse.coercemode_inplace:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    movsxd    %rax,	dword ptr[%rdi+52]
    cmp       %rax,	%rbx
    jz        L5868
L5870:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    xor       %r8d,	%r8d
    mov       %r9,	1
    call      cc_parse.docast
L5868:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.createsizeofop
cc_parse.createsizeofop:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r12,	%rcx
    mov       %r13,	%rdx
#---------------
#PROC3
#PROC4
    test      %r13,	%r13
    jz        L5873
    movsxd    %rax,	dword ptr[%r12+40]
    cmp       %rax,	53
    jz        L5873
    cmp       %rax,	55
    jz        L5873
    xor       %ecx,	%ecx
    mov       %rdx,	%r12
    xor       %r8d,	%r8d
    lea       %r9,	[%rip+L9080]
    call      cc_show.printunit
    lea       %rcx,	[%rip+L9081]
    call      cc_support.serror
L5873:
    mov       %rcx,	%r12
    call      cc_parse.getmemmode
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%r12+40]
    cmp       %rax,	3
    jz        L5875
    cmp       %rax,	1
    jz        L5876
    cmp       %rax,	52
    jz        L5877
    cmp       %rax,	53
    jz        L5878
    cmp       %rax,	55
    jz        L5879
    cmp       %rax,	4
    jz        L5880
    jmp       L5881
L5875:
    mov       %eax,	[%r12+48]
    test      %eax,	%eax
    jz        L5883
    mov       %rax,	[%r12]
    movzx     %rax,	word ptr[%rax+102]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r10,	[%r10 + %rax*8]
    movsxd    %rax,	dword ptr[%r12+48]
    xchg      %r10,	%rax
    cqo       
    idiv      %r10
    mov       %rsi,	%rax
    jmp       L5882
L5883:
    mov       %rax,	[%r12]
    movzx     %rax,	word ptr[%rax+102]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rsi,	%r10
L5882:
    jmp       L5874
L5876:
    mov       %rax,	%rbx
    cmp       %rax,	[%rip+cc_decls.trefchar]
    jz        L5885
    cmp       %rax,	[%rip+cc_decls.trefwchar]
    jz        L5886
    jmp       L5887
L5885:
    movsxd    %rax,	dword ptr[%r12+48]
    inc       %rax
    mov       %rsi,	%rax
    jmp       L5884
L5886:
    movsxd    %rax,	dword ptr[%r12+48]
    inc       %rax
    shl       %rax,	1
    mov       %rsi,	%rax
    jmp       L5884
L5887:
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rbx
    mov       %rsi,	[%rax + %r10*8]
L5884:
    jmp       L5874
L5877:
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L5889
    mov       %eax,	[%r12+48]
    test      %eax,	%eax
    jz        L5889
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r10,	[%r10 + %rax*8]
    movsxd    %rax,	dword ptr[%r12+48]
    imul      %r10,	%rax
    mov       %rsi,	%r10
    jmp       L5888
L5889:
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rbx
    mov       %rsi,	[%rax + %r10*8]
L5888:
    jmp       L5874
L5878:
    mov       %eax,	[%r12+48]
    test      %eax,	%eax
    jz        L5891
    test      %r13,	%r13
    jz        L5893
    movsxd    %rax,	dword ptr[%r12+48]
    mov       %rsi,	%rax
    jmp       L5892
L5893:
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r10,	[%r10 + %rax*8]
    movsxd    %rax,	dword ptr[%r12+48]
    imul      %r10,	%rax
    mov       %rsi,	%r10
L5892:
    jmp       L5890
L5891:
    jmp       L5894
L5890:
    jmp       L5874
L5879:
    mov       %rax,	[%r12+16]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	3
    jnz       L5896
    mov       %rax,	[%r12+16]
    mov       %eax,	[%rax+48]
    test      %eax,	%eax
    jz        L5896
    test      %r13,	%r13
    jz        L5898
    mov       %rax,	[%r12+16]
    movsxd    %rax,	dword ptr[%rax+48]
    mov       %rsi,	%rax
    jmp       L5897
L5898:
    mov       %rax,	[%r12+16]
    mov       %rax,	[%rax]
    movzx     %rax,	word ptr[%rax+102]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rsi,	%r10
L5897:
    jmp       L5895
L5896:
    mov       %rsi,	8
L5895:
    jmp       L5874
L5880:
    mov       %rax,	[%r12+16]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      cc_parse.createsizeofop
    jmp       L5871
L5881:
#cc_parse.createsizeofop.cad1:
L5894:
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rbx
    mov       %rsi,	[%rax + %r10*8]
L5874:
    mov       %rcx,	%rsi
    mov       %rdx,	9
    call      cc_lib.createconstunit
    mov       %rdi,	%rax
    mov       %rax,	%rdi
L5871:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.readgeneric
cc_parse.readgeneric:
#PROC1
#PROC2
#?>>
    .set cc_parse.readgeneric.pm, -8
    .set cc_parse.readgeneric.oldingeneric, -16
    .set cc_parse.readgeneric.count, -24
    .set cc_parse.readgeneric.d, -32
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	64
#---------------
#PROC3
#PROC4
    call      cc_lex.lex
    mov       %rcx,	13
    call      cc_lib.checksymbol
    call      cc_lex.lex
    movzx     %rax,	byte ptr[%rip+cc_parse.ingeneric]
    mov       [%rbp + cc_parse.readgeneric.oldingeneric],	%rax
    mov       %al,	1
    mov       [%rip+cc_parse.ingeneric],	%al
    call      cc_parse.readassignexpr
    mov       %rdi,	%rax
    mov       %al,	[%rbp + cc_parse.readgeneric.oldingeneric]
    mov       [%rip+cc_parse.ingeneric],	%al
    movsxd    %rax,	dword ptr[%rdi+52]
    mov       %r12,	%rax
    xor       %rbx,	%rbx
    xor       %eax,	%eax
    mov       %r14,	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_parse.readgeneric.count],	%rax
    mov       %rcx,	8
    call      cc_lib.checksymbol
L5900:
    call      cc_lex.lex
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	74
    jnz       L5904
    test      %r14,	%r14
    jz        L5906
    lea       %rcx,	[%rip+L9082]
    call      cc_support.serror
L5906:
    mov       %r14,	1
    mov       %rax,	[%rbp + cc_parse.readgeneric.count]
    test      %rax,	%rax
    jnz       L5908
    mov       %r13,	-1
    jmp       L5907
L5908:
    mov       %r13,	-2
L5907:
    call      cc_lex.lex
    jmp       L5903
L5904:
    sub       %rsp,	8
    push      0
    lea       %rcx,	[%rbp + cc_parse.readgeneric.d]
    xor       %edx,	%edx
    lea       %r8,	[%rbp + cc_parse.readgeneric.pm]
    xor       %r9d,	%r9d
    sub       %rsp,	32
    call      cc_parse.readcasttype
    add       %rsp,	48
    mov       %r13,	%rax
L5903:
    mov       %rcx,	10
    call      cc_lib.checksymbol
    call      cc_lex.lex
    call      cc_parse.readassignexpr
    mov       %rsi,	%rax
    cmp       %r13,	-1
    jz        L5911
    cmp       %r13,	%r12
    jnz       L5910
L5911:
    mov       %rbx,	%rsi
    inc       qword ptr[%rbp + cc_parse.readgeneric.count]
L5910:
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	8
    jz        L5900
    mov       %rcx,	14
    call      cc_lib.checksymbol
    call      cc_lex.lex
    test      %rbx,	%rbx
    jnz       L5913
    lea       %rcx,	[%rip+L9083]
    call      cc_support.serror
L5913:
    mov       %rax,	[%rbp + cc_parse.readgeneric.count]
    cmp       %rax,	1
    jle       L5915
    lea       %rcx,	[%rip+L9084]
    call      cc_support.serror
L5915:
    mov       %rax,	%rbx
L5899:
#---------------
    add       %rsp,	64
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_parse.getmemmode
cc_parse.getmemmode:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       %ax,	[%rcx+56]
    test      %ax,	%ax
    jz        L5918
    movsx     %rax,	word ptr[%rcx+56]
    jmp       L5917
L5918:
    movsxd    %rax,	dword ptr[%rcx+52]
L5917:
L5916:
#---------------
    ret       
# End 
# Proc cc_parse.getpromotedtype
cc_parse.getpromotedtype:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    test      %rcx,	%rcx
    jnz       L5921
    xor       %eax,	%eax
    jmp       L5919
L5921:
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rcx
    mov       %rax,	[%rax + %r10*8]
    cmp       %rax,	4
    jge       L5923
    mov       %rax,	3
    jmp       L5919
L5923:
    mov       %rax,	%rcx
L5919:
#---------------
    ret       
# End 
# Proc cc_genpcl.codegen_pcl
cc_genpcl.codegen_pcl:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rip+cc_cli.fverbose]
    cmp       %rax,	3
    jnz       L5926
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L9085]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+cc_decls.inputfile]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L5926:
    xor       %ecx,	%ecx
    mov       %rdx,	[%rip+cc_decls.nunits]
    call      pc_api.pcl_start
    call      cc_genpcl.dolibs
    lea       %rcx,	[%rip+L9086]
    call      pc_api.gencomment
    mov       %rax,	[%rip+cc_decls.stmodule]
    mov       %rdi,	[%rax+16]
    jmp       L5928
L5927:
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	7
    jz        L5931
    cmp       %rax,	6
    jz        L5932
    jmp       L5933
L5931:
    mov       %rcx,	%rdi
    call      cc_genpcl.dostaticvar
    jmp       L5930
L5932:
    movzx     %rax,	byte ptr[%rdi+110]
    cmp       %rax,	4
    jz        L5935
    cmp       %rax,	2
    jz        L5936
    jmp       L5937
L5935:
    mov       %rax,	[%rdi+72]
    test      %rax,	%rax
    jnz       L5939
    mov       %al,	3
    mov       [%rdi+110],	%al
L5939:
    jmp       L5934
L5936:
    mov       %rax,	[%rdi+72]
    test      %rax,	%rax
    jnz       L5941
    mov       %rax,	[%rdi]
    lea       %rcx,	[%rip+L9087]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      cc_support.gerror_s
L5941:
L5937:
L5934:
    mov       %rbx,	[%rdi+16]
    jmp       L5943
L5942:
    movzx     %rax,	byte ptr[%rbx+109]
    cmp       %rax,	7
    jz        L5946
    cmp       %rax,	8
    jz        L5947
    jmp       L5948
L5946:
    mov       %rcx,	%rbx
    call      cc_genpcl.dostaticvar
    jmp       L5945
L5947:
    mov       %rax,	[%rbx+72]
    test      %rax,	%rax
    jz        L5950
    mov       %rax,	[%rbx+72]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	28
    jz        L5953
    movzx     %rax,	word ptr[%rbx+102]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    cmp       %r10,	17
    jnz       L5952
    mov       %rax,	[%rbx+72]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L5952
L5953:
    mov       %rcx,	%rbx
    call      cc_genpcl.dostaticvar
L5952:
L5950:
L5948:
L5945:
    mov       %rbx,	[%rbx+32]
L5943:
    test      %rbx,	%rbx
    jnz       L5942
L5933:
L5930:
    mov       %rdi,	[%rdi+32]
L5928:
    test      %rdi,	%rdi
    jnz       L5927
    lea       %rcx,	[%rip+L9088]
    call      pc_api.gencomment
    mov       %rax,	[%rip+cc_decls.stmodule]
    mov       %rdi,	[%rax+16]
    jmp       L5955
L5954:
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	6
    jnz       L5959
L5958:
    mov       %rax,	[%rdi+72]
    test      %rax,	%rax
    jz        L5961
    mov       %rcx,	%rdi
    call      cc_genpcl.genprocdef
L5961:
L5959:
L5957:
    mov       %rdi,	[%rdi+32]
L5955:
    test      %rdi,	%rdi
    jnz       L5954
    call      pc_api.pcl_end
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_genpcl.genprocdef
cc_genpcl.genprocdef:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
#PROC3
#PROC4
    xor       %rsi,	%rsi
    mov       %rax,	[%r12]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L9089]
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L5964
    mov       %rsi,	1
    lea       %rax,	[%r12+108]
    or        byte ptr[%rax],	8
L5964:
    mov       [%rip+cc_decls.currproc],	%r12
    mov       %rcx,	%r12
    call      cc_libpcl.getpsymbol
    mov       %r10,	%rax
    mov       %rbx,	%r10
    mov       %rcx,	%rax
    xor       %edx,	%edx
    mov       %r8,	%rsi
    xor       %r9d,	%r9d
    call      pc_api.pc_defproc
    mov       %rax,	[%r12+80]
    movsx     %rax,	word ptr[%rax+22]
    cmp       %rax,	3
    setz      %al
    movzx     %eax,	%al
    mov       [%rbx+113],	%al
    mov       %rdi,	[%r12+16]
    jmp       L5968
L5965:
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	9
    jz        L5970
    cmp       %rax,	8
    jz        L5971
    jmp       L5972
L5970:
    mov       %rcx,	%rdi
    call      cc_libpcl.getpsymbol
    mov       %rcx,	%rax
    call      pc_api.pc_addparam
    jmp       L5969
L5971:
    mov       %rcx,	%rdi
    call      cc_libpcl.getpsymbol
    mov       %rcx,	%rax
    call      pc_api.pc_addlocal
L5972:
L5969:
    mov       %rdi,	[%rdi+32]
L5968:
    test      %rdi,	%rdi
    jnz       L5965
    call      cc_libpcl.createfwdlabel
    mov       [%rip+cc_genpcl.retindex],	%rax
    lea       %rcx,	[%rip+L9090]
    call      pc_api.gencomment
    mov       %rcx,	[%r12+72]
    call      cc_blockpcl.do_stmt
    lea       %rcx,	[%rip+L9090]
    call      pc_api.gencomment
    mov       %rcx,	[%rip+cc_genpcl.retindex]
    call      cc_libpcl.definefwdlabel
    test      %rsi,	%rsi
    jz        L5974
    xor       %ecx,	%ecx
    call      pc_api.genint
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	3
    call      cc_libpcl.setmode
    mov       %rcx,	32
    xor       %edx,	%edx
    call      pc_api.pc_gen
L5974:
    movzx     %rax,	word ptr[%r12+102]
    test      %rax,	%rax
    jz        L5976
    mov       %rax,	23
    jmp       L5975
L5976:
    mov       %rax,	20
L5975:
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      pc_api.pc_gen
    movzx     %rax,	word ptr[%r12+102]
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    call      pc_api.pc_endproc
    lea       %rcx,	[%rip+L9091]
    call      pc_api.gencomment
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_genpcl.dostaticvar
cc_genpcl.dostaticvar:
#PROC1
#PROC2
#?>>
    .set cc_genpcl.dostaticvar.str, -256
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	288
    mov       %r12,	%rcx
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%r12+110]
    cmp       %rax,	3
    jz        L5977
L5979:
    movzx     %rax,	word ptr[%r12+102]
    mov       %rcx,	%rax
    call      cc_lib.getalignment
    mov       %rdi,	%rax
    mov       %rax,	[%r12+72]
    test      %rax,	%rax
    jz        L5981
    movzx     %rax,	byte ptr[%r12+109]
    cmp       %rax,	8
    jnz       L5983
    lea       %rcx,	[%rbp + cc_genpcl.dostaticvar.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L9092]
    call      msys.m$print_setfmt
    mov       %rax,	[%r12+8]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    mov       %rcx,	[%r12]
    call      msys.m$print_str_nf
    movzx     %rax,	word ptr[%r12+96]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + cc_genpcl.dostaticvar.str]
    call      cc_lex.addnamestr
    xor       %ecx,	%ecx
    mov       %rdx,	%rax
    mov       %r8,	7
    call      cc_lib.createdupldef
    mov       %rbx,	%rax
    mov       %rcx,	%rbx
    call      cc_libpcl.getpsymbol
    mov       %rsi,	%rax
    mov       [%r12+114],	%rsi
    mov       %rcx,	%rsi
    call      pc_api.genmem
    mov       %rcx,	123
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    jmp       L5982
L5983:
    mov       %rcx,	%r12
    call      cc_libpcl.genmem_d
    mov       %rcx,	123
    mov       %rdx,	%rax
    call      pc_api.pc_gen
L5982:
    movzx     %rax,	word ptr[%r12+102]
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    mov       %rcx,	%rdi
    call      pc_api.pc_setalign
    mov       %rax,	[%r12+72]
    mov       %rcx,	%rax
    mov       %rdx,	1
    mov       %r8,	1
    xor       %r9d,	%r9d
    call      cc_genpcl.genidata
    jmp       L5980
L5981:
    mov       %rcx,	%r12
    call      cc_libpcl.genmem_d
    mov       %rcx,	124
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    movzx     %rax,	word ptr[%r12+102]
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    mov       %rcx,	%rdi
    call      pc_api.pc_setalign
L5980:
L5977:
#---------------
    add       %rsp,	288
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_genpcl.genidata
cc_genpcl.genidata:
#PROC1
#PROC2
#?>>
    .set cc_genpcl.genidata.p, 64
    .set cc_genpcl.genidata.doterm, 72
    .set cc_genpcl.genidata.am, 80
    .set cc_genpcl.genidata.offset, 88
    .set cc_genpcl.genidata.size, -8
    .set cc_genpcl.genidata.padding, -16
    .set cc_genpcl.genidata.isunion, -24
    .set cc_genpcl.genidata.q, -32
    .set cc_genpcl.genidata.a, -40
    .set cc_genpcl.genidata.b, -48
    .set cc_genpcl.genidata.d, -56
    .set cc_genpcl.genidata.sx, -64
    .set cc_genpcl.genidata.str, -320
    .set cc_genpcl.genidata.str2, -336
    .set cc_genpcl.genidata.av_1, -344
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	384
    mov       [%rbp+64],	%rcx
    mov       [%rbp+88],	%r9
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    movsxd    %rax,	dword ptr[%rax+52]
    mov       %rdi,	%rax
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    mov       %rax,	[%rax+16]
    mov       [%rbp + cc_genpcl.genidata.a],	%rax
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    mov       %rax,	[%rax+24]
    mov       [%rbp + cc_genpcl.genidata.b],	%rax
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	28
    jz        L5986
    cmp       %rax,	1
    jz        L5987
    cmp       %rax,	3
    jz        L5988
    cmp       %rax,	5
    jz        L5988
    cmp       %rax,	39
    jz        L5989
    cmp       %rax,	55
    jz        L5990
    cmp       %rax,	53
    jz        L5991
    cmp       %rax,	54
    jz        L5991
    cmp       %rax,	56
    jz        L5992
    jmp       L5993
L5986:
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    movsxd    %rax,	dword ptr[%rax+48]
    mov       %rsi,	%rax
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jnz       L5995
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%rdi
    mov       %rbx,	[%rax + %r10*8]
    mov       %rax,	[%rbp + cc_genpcl.genidata.a]
    mov       [%rbp + cc_genpcl.genidata.q],	%rax
    mov       %r12,	1
    cmp       %rsi,	1
    jl        L5998
L5996:
    mov       %rcx,	[%rbp + cc_genpcl.genidata.q]
    mov       %rdx,	1
    mov       %r8,	1
    xor       %r9d,	%r9d
    call      cc_genpcl.genidata
    mov       %rax,	[%rbp + cc_genpcl.genidata.q]
    mov       %rax,	[%rax+8]
    mov       [%rbp + cc_genpcl.genidata.q],	%rax
    inc       %r12
    cmp       %r12,	%rsi
    jle       L5996
L5998:
    cmp       %rsi,	%rbx
    jge       L6000
    mov       %rax,	%rbx
    sub       %rax,	%rsi
    lea       %r10,	[%rip+cc_decls.tttarget]
    mov       %r11,	%rdi
    movsx     %r10,	word ptr[%r10 + %r11*2]
    lea       %r11,	[%rip+cc_decls.ttsize]
    mov       %r11,	[%r11 + %r10*8]
    imul      %rax,	%r11
    mov       %rcx,	%rax
    call      cc_genpcl.doresb
L6000:
    jmp       L5994
L5995:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	19
    setz      %al
    movzx     %eax,	%al
    mov       [%rbp + cc_genpcl.genidata.isunion],	%rax
    lea       %rax,	[%rip+cc_decls.ttnamedef]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    mov       %rax,	[%rax+16]
    mov       [%rbp + cc_genpcl.genidata.d],	%rax
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    mov       [%rbp + cc_genpcl.genidata.size],	%rax
    xor       %eax,	%eax
    mov       %r14,	%rax
    mov       %r13,	%rax
    mov       %rax,	[%rbp + cc_genpcl.genidata.a]
    mov       [%rbp + cc_genpcl.genidata.q],	%rax
    mov       %r12,	1
    cmp       %rsi,	1
    jl        L6003
L6001:
    mov       %rcx,	[%rbp + cc_genpcl.genidata.q]
    xor       %edx,	%edx
    mov       %r8,	1
    xor       %r9d,	%r9d
    call      cc_genpcl.genidata
    mov       %rax,	[%rbp + cc_genpcl.genidata.q]
    movsxd    %rax,	dword ptr[%rax+52]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r10,	[%r10 + %rax*8]
    add       %r13,	%r10
    mov       %rax,	[%rbp + cc_genpcl.genidata.d]
    mov       %rax,	[%rax+32]
    mov       [%rbp + cc_genpcl.genidata.d],	%rax
    mov       %rax,	[%rbp + cc_genpcl.genidata.d]
    test      %rax,	%rax
    jz        L6005
    mov       %rax,	[%rbp + cc_genpcl.genidata.isunion]
    test      %rax,	%rax
    jnz       L6005
    mov       %rax,	[%rbp + cc_genpcl.genidata.d]
    movsxd    %rax,	dword ptr[%rax+88]
    mov       %r14,	%rax
    jmp       L6004
L6005:
    mov       %r14,	[%rbp + cc_genpcl.genidata.size]
L6004:
    mov       %rax,	%r14
    sub       %rax,	%r13
    mov       [%rbp + cc_genpcl.genidata.padding],	%rax
    mov       %rax,	[%rbp + cc_genpcl.genidata.padding]
    cmp       %rax,	0
    jle       L6007
    mov       %rax,	%r14
    sub       %rax,	%r13
    mov       %rcx,	%rax
    call      cc_genpcl.doresb
    mov       %r13,	%r14
L6007:
    mov       %rax,	[%rbp + cc_genpcl.genidata.q]
    mov       %rax,	[%rax+8]
    mov       [%rbp + cc_genpcl.genidata.q],	%rax
    inc       %r12
    cmp       %r12,	%rsi
    jle       L6001
L6003:
    cmp       %r14,	[%rbp + cc_genpcl.genidata.size]
    jge       L6009
    mov       %rax,	[%rbp + cc_genpcl.genidata.size]
    sub       %rax,	%r14
    mov       %rcx,	%rax
    call      cc_genpcl.doresb
L6009:
L5994:
    jmp       L5984
L5987:
    mov       %rcx,	%rdi
    call      cc_lib.isintcc
    test      %rax,	%rax
    jnz       L6012
    mov       %rcx,	%rdi
    call      cc_lib.isrealcc
    test      %rax,	%rax
    jz        L6011
L6012:
    cmp       %rdi,	10
    jnz       L6014
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    movq      %XMM4,	[%rax]
    cvtsd2ss  %XMM4,	%XMM4
    movd      [%rbp + cc_genpcl.genidata.sx],	%XMM4
    mov       %eax,	[%rbp + cc_genpcl.genidata.sx]
    mov       %rcx,	%rax
    call      pc_api.genint
    mov       %rcx,	125
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    jmp       L6013
L6014:
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    call      pc_api.genint
    mov       %rcx,	125
    mov       %rdx,	%rax
    call      pc_api.pc_gen
L6013:
    mov       %rcx,	%rdi
    call      cc_libpcl.setmode
    jmp       L6010
L6011:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	13
    jnz       L6015
    xor       %eax,	%eax
    mov       [%rbp + cc_genpcl.genidata.padding],	%rax
#cc_genpcl.genidata.doref:
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    mov       %rax,	[%rax]
    test      %rax,	%rax
    jnz       L6018
    xor       %ecx,	%ecx
    call      pc_api.genint
    mov       %rcx,	125
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    jmp       L6017
L6018:
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    mov       %al,	[%rax+61]
    test      %al,	%al
    jz        L6019
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    call      pc_api.genstring
    mov       %rcx,	125
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    jmp       L6017
L6019:
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    mov       %al,	[%rax+62]
    test      %al,	%al
    jz        L6020
    lea       %rcx,	[%rip+L9093]
    xor       %edx,	%edx
    call      cc_support.gerror
    mov       %rcx,	[%rbp + cc_genpcl.genidata.padding]
    call      cc_genpcl.doresb
    jmp       L6017
L6020:
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    call      pc_api.genint
    mov       %rcx,	125
    mov       %rdx,	%rax
    call      pc_api.pc_gen
L6017:
    mov       %rcx,	%rdi
    call      cc_libpcl.setmode
    jmp       L6010
L6015:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jnz       L6021
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    mov       %r10,	[%rbp + cc_genpcl.genidata.p]
    movsxd    %r10,	dword ptr[%r10+48]
    sub       %rax,	%r10
    lea       %r10,	[%rip+cc_decls.tttarget]
    mov       %r11,	%rdi
    movsx     %r10,	word ptr[%r10 + %r11*2]
    lea       %r11,	[%rip+cc_decls.ttsize]
    mov       %r11,	[%r11 + %r10*8]
    imul      %rax,	%r11
    mov       [%rbp + cc_genpcl.genidata.padding],	%rax
    mov       %r12,	1
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    movsxd    %rax,	dword ptr[%rax+48]
    mov       [%rbp + cc_genpcl.genidata.av_1],	%rax
    mov       %rax,	[%rbp + cc_genpcl.genidata.av_1]
    cmp       %rax,	1
    jl        L6024
L6022:
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    mov       %rax,	[%rax]
    mov       %r10,	%r12
    lea       %rax,	[%rax + %r10]
    sub       %rax,	1
    movzx     %rax,	byte ptr[%rax]
    mov       %rcx,	%rax
    call      pc_api.genint
    mov       %rcx,	125
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	6
    call      cc_libpcl.setmode
    inc       %r12
    cmp       %r12,	[%rbp + cc_genpcl.genidata.av_1]
    jle       L6022
L6024:
    mov       %rcx,	[%rbp + cc_genpcl.genidata.padding]
    call      cc_genpcl.doresb
    jmp       L6010
L6021:
    call      msys.m$print_startcon
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L9094]
    xor       %edx,	%edx
    call      cc_support.gerror
L6010:
    jmp       L5984
L5988:
    mov       %rax,	[%rbp + cc_genpcl.genidata.p]
    mov       %rax,	[%rax]
    mov       [%rbp + cc_genpcl.genidata.d],	%rax
    mov       %rax,	[%rbp + cc_genpcl.genidata.d]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	7
    jz        L6026
    cmp       %rax,	6
    jnz       L6027
L6026:
    mov       %rcx,	[%rbp + cc_genpcl.genidata.d]
    call      cc_libpcl.genmemaddr_d
    mov       %rcx,	125
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	9
    call      cc_libpcl.setmode
    jmp       L6025
L6027:
    lea       %rcx,	[%rip+L9095]
    mov       %rdx,	[%rbp + cc_genpcl.genidata.p]
    call      cc_support.gerror
L6025:
    jmp       L5984
L5989:
    mov       %rax,	[%rbp + cc_genpcl.genidata.a]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	3
    jnz       L6029
    mov       %rax,	[%rbp + cc_genpcl.genidata.b]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L6029
    mov       %rax,	[%rbp + cc_genpcl.genidata.a]
    mov       %rax,	[%rax]
    mov       [%rbp + cc_genpcl.genidata.d],	%rax
    mov       %rax,	[%rbp + cc_genpcl.genidata.d]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	7
    jnz       L6032
L6031:
    lea       %rcx,	[%rbp + cc_genpcl.genidata.str]
    lea       %rdx,	[%rip+L9096]
    call      strcpy
    mov       %rax,	[%rbp + cc_genpcl.genidata.d]
    movzx     %rax,	byte ptr[%rax+110]
    cmp       %rax,	1
    jnz       L6034
    mov       %rax,	[%rip+cc_decls.currproc]
    mov       %rax,	[%rax]
    lea       %rcx,	[%rbp + cc_genpcl.genidata.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rcx,	[%rbp + cc_genpcl.genidata.str]
    lea       %rdx,	[%rip+L9097]
    call      strcat
L6034:
    mov       %rax,	[%rbp + cc_genpcl.genidata.d]
    mov       %rax,	[%rax]
    lea       %rcx,	[%rbp + cc_genpcl.genidata.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rcx,	[%rbp + cc_genpcl.genidata.str]
    lea       %rdx,	[%rip+L9098]
    call      strcat
    mov       %rax,	[%rbp + cc_genpcl.genidata.b]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    lea       %rdx,	[%rbp + cc_genpcl.genidata.str2]
    call      msys.getstrint
    lea       %rcx,	[%rbp + cc_genpcl.genidata.str]
    lea       %rdx,	[%rbp + cc_genpcl.genidata.str2]
    call      strcat
    lea       %rcx,	[%rbp + cc_genpcl.genidata.str]
    call      pc_api.genname
    mov       %rcx,	125
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    jmp       L6030
L6032:
    lea       %rcx,	[%rip+L9099]
    xor       %edx,	%edx
    call      cc_support.gerror
L6030:
    jmp       L6028
L6029:
    mov       %rax,	[%rbp + cc_genpcl.genidata.a]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L6035
    mov       %rax,	[%rbp + cc_genpcl.genidata.b]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jnz       L6035
    mov       %rax,	[%rbp + cc_genpcl.genidata.a]
    movsxd    %rax,	dword ptr[%rax+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    cmp       %r10,	13
    jnz       L6035
    lea       %rcx,	[%rbp + cc_genpcl.genidata.str]
    call      msys.m$print_startstr
    mov       %rax,	[%rbp + cc_genpcl.genidata.a]
    mov       %rcx,	[%rax]
    call      msys.m$print_i64_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L9100]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       %rax,	[%rbp + cc_genpcl.genidata.b]
    mov       %rcx,	[%rax]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + cc_genpcl.genidata.str]
    call      pc_api.genname
    mov       %rcx,	125
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    jmp       L6028
L6035:
    lea       %rcx,	[%rip+L9101]
    xor       %edx,	%edx
    call      cc_support.gerror
L6028:
    jmp       L5984
L5990:
    mov       %rax,	[%rbp + cc_genpcl.genidata.a]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	52
    jnz       L6037
    mov       %rax,	[%rbp + cc_genpcl.genidata.a]
    mov       %rax,	[%rax+16]
    mov       %rcx,	%rax
    mov       %rdx,	1
    mov       %r8,	1
    mov       %r9,	[%rbp + cc_genpcl.genidata.offset]
    call      cc_genpcl.genidata
    jmp       L6036
L6037:
    mov       %rcx,	[%rbp + cc_genpcl.genidata.a]
    mov       %rdx,	1
    xor       %r8d,	%r8d
    mov       %r9,	[%rbp + cc_genpcl.genidata.offset]
    call      cc_genpcl.genidata
L6036:
    jmp       L5985
L5991:
    mov       %rax,	[%rbp + cc_genpcl.genidata.b]
    movsxd    %rax,	dword ptr[%rax+40]
    cmp       %rax,	1
    jz        L6039
    lea       %rcx,	[%rip+L9102]
    xor       %edx,	%edx
    call      cc_support.gerror
L6039:
    mov       %rax,	[%rbp + cc_genpcl.genidata.b]
    mov       %rax,	[%rax]
    mov       %r10,	[%rbp + cc_genpcl.genidata.p]
    movsxd    %r10,	dword ptr[%r10]
    imul      %rax,	%r10
    add       %rax,	[%rbp + cc_genpcl.genidata.offset]
    mov       %rcx,	[%rbp + cc_genpcl.genidata.a]
    mov       %rdx,	1
    mov       %r8,	1
    mov       %r9,	%rax
    call      cc_genpcl.genidata
    jmp       L5985
L5992:
    mov       %rcx,	[%rbp + cc_genpcl.genidata.a]
    mov       %rdx,	1
    mov       %r8,	1
    mov       %r9,	[%rbp + cc_genpcl.genidata.offset]
    call      cc_genpcl.genidata
    jmp       L5985
L5993:
    xor       %ecx,	%ecx
    mov       %rdx,	[%rbp + cc_genpcl.genidata.p]
    xor       %r8d,	%r8d
    lea       %r9,	[%rip+L9103]
    call      cc_show.printunit
    lea       %rcx,	[%rip+L9104]
    mov       %rdx,	[%rbp + cc_genpcl.genidata.p]
    call      cc_support.gerror
L5985:
L5984:
#---------------
    add       %rsp,	384
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_genpcl.doresb
cc_genpcl.doresb:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    jmp       L6042
L6041:
    xor       %ecx,	%ecx
    call      pc_api.genint
    mov       %rcx,	125
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rax,	8
    sub       %rbx,	%rax
    mov       %rcx,	9
    call      cc_libpcl.setmode
L6042:
    cmp       %rbx,	8
    jge       L6041
    mov       %rdi,	%rbx
    cmp       %rdi,	0
    jle       L6046
L6044:
    xor       %ecx,	%ecx
    call      pc_api.genint
    mov       %rcx,	125
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	6
    call      cc_libpcl.setmode
    dec       %rdi
    jnz       L6044
L6046:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_genpcl.pushint
cc_genpcl.pushint:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    call      pc_api.genint
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_genpcl.dolibs
cc_genpcl.dolibs:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    mov       %rdi,	1
    mov       %rax,	[%rip+cc_decls.nlibfiles]
    cmp       %rax,	1
    jl        L6051
L6049:
    lea       %rax,	[%rip+cc_decls.libfiles]
    mov       %r10,	%rdi
    mov       %rcx,	[%rax + %r10*8]
    call      pc_api.pc_addplib
    inc       %rdi
    cmp       %rdi,	[%rip+cc_decls.nlibfiles]
    jle       L6049
L6051:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.do_stmt
cc_blockpcl.do_stmt:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
#PROC3
#PROC4
    test      %r12,	%r12
    jnz       L6054
    jmp       L6052
L6054:
    mov       %rdi,	[%rip+cc_decls.clineno]
    mov       %eax,	[%r12+44]
    mov       [%rip+cc_decls.clineno],	%rax
    movzx     %rax,	byte ptr[%r12+60]
    mov       [%rip+cc_decls.cfileno],	%rax
    mov       %rax,	[%rip+cc_decls.cfileno]
    shl       %rax,	24
    add       %rax,	[%rip+cc_decls.clineno]
    mov       [%rip+pc_decls.mmpos],	%rax
    mov       %rbx,	[%r12+16]
    mov       %rsi,	[%r12+24]
    movsxd    %rax,	dword ptr[%r12+40]
    sub       %rax,	6
    cmp       %rax,	69
    jae       L6057
    lea       %r10,	[%rip+L6056]
    jmp       [%r10 + %rax*8]
    .data
L6056:
    .quad     L6058
    .quad     L6057
    .quad     L6062
    .quad     L6064
    .quad     L6057
    .quad     L6065
    .quad     L6066
    .quad     L6067
    .quad     L6068
    .quad     L6069
    .quad     L6070
    .quad     L6071
    .quad     L6072
    .quad     L6073
    .quad     L6075
    .quad     L6076
    .quad     L6077
    .quad     L6074
    .quad     L6057
    .quad     L6057
    .quad     L6057
    .quad     L6057
    .quad     L6057
    .quad     L6092
    .quad     L6063
    .quad     L6066
    .quad     L6057
    .quad     L6057
    .quad     L6057
    .quad     L6057
    .quad     L6057
    .quad     L6057
    .quad     L6057
    .quad     L6057
    .quad     L6057
    .quad     L6057
    .quad     L6057
    .quad     L6057
    .quad     L6057
    .quad     L6057
    .quad     L6057
    .quad     L6057
    .quad     L6057
    .quad     L6057
    .quad     L6057
    .quad     L6057
    .quad     L6057
    .quad     L6057
    .quad     L6057
    .quad     L6057
    .quad     L6057
    .quad     L6057
    .quad     L6057
    .quad     L6057
    .quad     L6057
    .quad     L6078
    .quad     L6079
    .quad     L6080
    .quad     L6081
    .quad     L6084
    .quad     L6085
    .quad     L6086
    .quad     L6087
    .quad     L6088
    .quad     L6089
    .quad     L6090
    .quad     L6091
    .quad     L6090
    .quad     L6091
    .text
L6058:
    jmp       L6060
L6059:
    mov       %rcx,	%rbx
    call      cc_blockpcl.do_stmt
    mov       %rbx,	[%rbx+8]
L6060:
    test      %rbx,	%rbx
    jnz       L6059
    jmp       L6055
L6062:
    mov       %rcx,	[%r12]
    call      cc_blockpcl.do_decl
    jmp       L6055
L6063:
    mov       %rcx,	%r12
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    xor       %r9d,	%r9d
    call      cc_blockpcl.dx_call
    jmp       L6055
L6064:
    mov       %rcx,	%r12
    mov       %rdx,	%rbx
    call      cc_blockpcl.do_return
    jmp       L6055
L6065:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    xor       %r8d,	%r8d
    call      cc_blockpcl.do_assign
    jmp       L6055
L6066:
    mov       %rax,	[%r12+32]
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	%rax
    call      cc_blockpcl.do_if
    jmp       L6055
L6067:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      cc_blockpcl.do_for
    jmp       L6055
L6068:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      cc_blockpcl.do_while
    jmp       L6055
L6069:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      cc_blockpcl.do_dowhile
    jmp       L6055
L6070:
    mov       %rcx,	[%r12]
    call      cc_blockpcl.do_goto
    jmp       L6055
L6071:
    mov       %rcx,	[%r12]
    call      cc_blockpcl.do_labeldef
    mov       %rcx,	%rbx
    call      cc_blockpcl.do_stmt
    jmp       L6055
L6072:
    mov       %rcx,	%r12
    mov       %rdx,	%rbx
    call      cc_blockpcl.do_casestmt
    jmp       L6055
L6073:
    mov       %al,	1
    mov       [%rip+cc_blockpcl.sw_defaultseen],	%al
    mov       %rcx,	[%rip+cc_blockpcl.sw_defaultlabel]
    call      pc_api.genlabel
    mov       %rcx,	127
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	%rbx
    call      cc_blockpcl.do_stmt
    jmp       L6055
L6074:
    mov       %rcx,	[%rip+cc_blockpcl.sw_breaklabel]
    call      cc_blockpcl.genjumpl
    jmp       L6055
L6075:
    lea       %rax,	[%rip+cc_blockpcl.breakstack]
    mov       %r10,	[%rip+cc_blockpcl.loopindex]
    mov       %rcx,	[%rax + %r10*8-8]
    call      cc_blockpcl.genjumpl
    jmp       L6055
L6076:
    lea       %rax,	[%rip+cc_blockpcl.continuestack]
    mov       %r10,	[%rip+cc_blockpcl.loopindex]
    mov       %rcx,	[%rax + %r10*8-8]
    call      cc_blockpcl.genjumpl
    jmp       L6055
L6077:
    mov       %rcx,	%r12
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    call      cc_blockpcl.do_switch
    jmp       L6055
L6078:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	90
    xor       %r9d,	%r9d
    call      cc_blockpcl.dx_binto
    jmp       L6055
L6079:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	91
    xor       %r9d,	%r9d
    call      cc_blockpcl.dx_binto
    jmp       L6055
L6080:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	92
    xor       %r9d,	%r9d
    call      cc_blockpcl.dx_binto
    jmp       L6055
L6081:
    movsxd    %rax,	dword ptr[%rbx+52]
    mov       %rcx,	%rax
    call      cc_lib.isrealcc
    test      %rax,	%rax
    jz        L6083
    mov       %rax,	93
    jmp       L6082
L6083:
    mov       %rax,	94
L6082:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	%rax
    xor       %r9d,	%r9d
    call      cc_blockpcl.dx_binto
    jmp       L6055
L6084:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	95
    xor       %r9d,	%r9d
    call      cc_blockpcl.dx_binto
    jmp       L6055
L6085:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	96
    xor       %r9d,	%r9d
    call      cc_blockpcl.dx_binto
    jmp       L6055
L6086:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	97
    xor       %r9d,	%r9d
    call      cc_blockpcl.dx_binto
    jmp       L6055
L6087:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	98
    xor       %r9d,	%r9d
    call      cc_blockpcl.dx_binto
    jmp       L6055
L6088:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	99
    xor       %r9d,	%r9d
    call      cc_blockpcl.dx_binto
    jmp       L6055
L6089:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	100
    xor       %r9d,	%r9d
    call      cc_blockpcl.dx_binto
    jmp       L6055
L6090:
    mov       %rcx,	%rbx
    mov       %rdx,	84
    call      cc_blockpcl.do_preincr
    jmp       L6055
L6091:
    mov       %rcx,	%rbx
    mov       %rdx,	85
    call      cc_blockpcl.do_preincr
    jmp       L6055
L6092:
    jmp       L6094
L6093:
    mov       %rcx,	%rbx
    call      cc_blockpcl.do_stmt
    mov       %rbx,	[%rbx+8]
L6094:
    test      %rbx,	%rbx
    jnz       L6093
    jmp       L6055
L6057:
    mov       %rcx,	%r12
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	11
    xor       %edx,	%edx
    call      pc_api.pc_gen
    test      %rbx,	%rbx
    jz        L6097
    mov       %rax,	%rbx
    jmp       L6096
L6097:
    mov       %rax,	%r12
L6096:
    mov       %rcx,	%rax
    call      cc_libpcl.setmode_u
L6055:
L6052:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_expr
cc_blockpcl.dx_expr:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r13,	%rcx
    mov       %r14,	%rdx
#---------------
#PROC3
#PROC4
    test      %r13,	%r13
    jnz       L6100
    jmp       L6098
L6100:
    mov       %rdi,	[%rip+cc_decls.clineno]
    mov       %eax,	[%r13+44]
    mov       [%rip+cc_decls.clineno],	%rax
    movzx     %rax,	byte ptr[%r13+60]
    mov       [%rip+cc_decls.cfileno],	%rax
    mov       %rsi,	[%r13+16]
    mov       %r12,	[%r13+24]
    movsxd    %rax,	dword ptr[%r13+52]
    mov       %rbx,	%rax
    movsxd    %rax,	dword ptr[%r13+40]
    sub       %rax,	1
    cmp       %rax,	76
    jae       L6103
    lea       %r10,	[%rip+L6102]
    jmp       [%r10 + %rax*8]
    .data
L6102:
    .quad     L6104
    .quad     L6103
    .quad     L6105
    .quad     L6106
    .quad     L6107
    .quad     L6103
    .quad     L6103
    .quad     L6103
    .quad     L6103
    .quad     L6103
    .quad     L6108
    .quad     L6103
    .quad     L6103
    .quad     L6103
    .quad     L6103
    .quad     L6103
    .quad     L6103
    .quad     L6103
    .quad     L6103
    .quad     L6103
    .quad     L6103
    .quad     L6103
    .quad     L6103
    .quad     L6109
    .quad     L6109
    .quad     L6110
    .quad     L6113
    .quad     L6103
    .quad     L6114
    .quad     L6125
    .quad     L6126
    .quad     L6103
    .quad     L6127
    .quad     L6127
    .quad     L6127
    .quad     L6127
    .quad     L6127
    .quad     L6127
    .quad     L6128
    .quad     L6131
    .quad     L6132
    .quad     L6133
    .quad     L6136
    .quad     L6137
    .quad     L6138
    .quad     L6139
    .quad     L6140
    .quad     L6141
    .quad     L6164
    .quad     L6103
    .quad     L6103
    .quad     L6142
    .quad     L6143
    .quad     L6144
    .quad     L6163
    .quad     L6145
    .quad     L6148
    .quad     L6149
    .quad     L6103
    .quad     L6150
    .quad     L6153
    .quad     L6154
    .quad     L6155
    .quad     L6156
    .quad     L6157
    .quad     L6158
    .quad     L6159
    .quad     L6160
    .quad     L6161
    .quad     L6162
    .quad     L6151
    .quad     L6151
    .quad     L6152
    .quad     L6152
    .quad     L6165
    .quad     L6166
    .text
L6104:
    mov       %rcx,	%r13
    call      cc_blockpcl.dx_const
    jmp       L6101
L6105:
    mov       %rcx,	%r13
    mov       %rdx,	%r14
    call      cc_blockpcl.dx_name
    jmp       L6101
L6106:
    mov       %rcx,	%rsi
    mov       %rdx,	%r14
    call      cc_blockpcl.dx_expr
    jmp       L6101
L6107:
    mov       %rax,	[%r13]
    mov       %rcx,	%rax
    call      cc_libpcl.genmemaddr_d
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	9
    call      cc_libpcl.setmode
    jmp       L6101
L6108:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	1
    call      cc_blockpcl.do_assign
    jmp       L6101
L6109:
    mov       %rcx,	%r13
    call      cc_blockpcl.dx_andorl
    jmp       L6101
L6110:
    movsxd    %rax,	dword ptr[%rsi+40]
    cmp       %rax,	26
    jnz       L6112
    mov       %rax,	[%rsi+16]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	64
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	8
    call      cc_libpcl.setmode
    mov       %rax,	[%rsi+16]
    movsxd    %rax,	dword ptr[%rax+52]
    mov       %rcx,	%rax
    call      cc_libpcl.setmode2
    jmp       L6111
L6112:
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	63
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	%rsi
    call      cc_libpcl.setmode_u
L6111:
    jmp       L6101
L6113:
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	64
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	8
    call      cc_libpcl.setmode
    movsxd    %rax,	dword ptr[%rsi+52]
    mov       %rcx,	%rax
    call      cc_libpcl.setmode2
    jmp       L6101
L6114:
    jmp       L6118
L6115:
    mov       %r12,	[%rsi+8]
    test      %r12,	%r12
    jz        L6120
    movsxd    %rax,	dword ptr[%rsi+40]
    cmp       %rax,	11
    jz        L6121
    cmp       %rax,	56
    jz        L6121
    cmp       %rax,	31
    jnz       L6120
L6121:
    mov       %rcx,	%rsi
    call      cc_blockpcl.do_stmt
    jmp       L6119
L6120:
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    test      %r12,	%r12
    jz        L6123
    movsxd    %rax,	dword ptr[%rsi+52]
    test      %rax,	%rax
    jnz       L6124
    movsxd    %rax,	dword ptr[%rsi+40]
    cmp       %rax,	56
    jnz       L6123
L6124:
    mov       %rcx,	134
    xor       %edx,	%edx
    call      pc_api.pc_gen
L6123:
L6119:
    mov       %rsi,	%r12
L6118:
    test      %rsi,	%rsi
    jnz       L6115
    jmp       L6101
L6125:
    mov       %rcx,	%r13
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    mov       %r9,	1
    call      cc_blockpcl.dx_call
    jmp       L6101
L6126:
    mov       %rax,	[%r13+32]
    mov       %rcx,	%r13
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    mov       %r9,	%rax
    call      cc_blockpcl.dx_ifx
    jmp       L6101
L6127:
    mov       %rcx,	%r13
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      cc_blockpcl.dx_eq
    jmp       L6101
L6128:
    movsxd    %rax,	dword ptr[%rsi+52]
    lea       %r10,	[%rip+cc_decls.ttisref]
    mov       %r10b,	[%r10 + %rax]
    test      %r10b,	%r10b
    jz        L6130
    movsxd    %rax,	dword ptr[%r12+52]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r10,	[%r10 + %rax*8]
    cmp       %r10,	4
    jg        L6130
    mov       %eax,	9
    mov       [%r12+52],	%eax
L6130:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	43
    call      cc_blockpcl.dx_bin
    jmp       L6101
L6131:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	44
    call      cc_blockpcl.dx_bin
    jmp       L6101
L6132:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	45
    call      cc_blockpcl.dx_bin
    jmp       L6101
L6133:
    movsxd    %rax,	dword ptr[%rsi+52]
    mov       %rcx,	%rax
    call      cc_lib.isrealcc
    test      %rax,	%rax
    jz        L6135
    mov       %rax,	46
    jmp       L6134
L6135:
    mov       %rax,	47
L6134:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	%rax
    call      cc_blockpcl.dx_bin
    jmp       L6101
L6136:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	48
    call      cc_blockpcl.dx_bin
    jmp       L6101
L6137:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	50
    call      cc_blockpcl.dx_bin
    jmp       L6101
L6138:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	51
    call      cc_blockpcl.dx_bin
    jmp       L6101
L6139:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	52
    call      cc_blockpcl.dx_bin
    jmp       L6101
L6140:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	53
    call      cc_blockpcl.dx_bin
    jmp       L6101
L6141:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	54
    call      cc_blockpcl.dx_bin
    jmp       L6101
L6142:
    mov       %rcx,	%r13
    mov       %rdx,	%rsi
    mov       %r8,	%r14
    call      cc_blockpcl.dx_ptr
    jmp       L6101
L6143:
    sub       %rsp,	8
    mov       %rax,	%r14
    push      %rax
    mov       %rcx,	%r13
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    mov       %r9,	57
    sub       %rsp,	32
    call      cc_blockpcl.dx_addptr
    add       %rsp,	48
    jmp       L6101
L6144:
    sub       %rsp,	8
    mov       %rax,	%r14
    push      %rax
    mov       %rcx,	%r13
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    mov       %r9,	58
    sub       %rsp,	32
    call      cc_blockpcl.dx_addptr
    add       %rsp,	48
    jmp       L6101
L6145:
    movsx     %rax,	word ptr[%r13+58]
    test      %rax,	%rax
    jnz       L6147
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    jmp       L6146
L6147:
    movsxd    %rax,	dword ptr[%r13+48]
    movsx     %r10,	word ptr[%r13+58]
    mov       %rcx,	%r13
    mov       %rdx,	%rsi
    mov       %r8,	%r10
    mov       %r9,	%rax
    call      cc_blockpcl.dx_convert
L6146:
    jmp       L6101
L6148:
    mov       %rcx,	%r13
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      cc_blockpcl.dx_scale
    jmp       L6101
L6149:
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	60
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	%rsi
    call      cc_libpcl.setmode_u
    jmp       L6101
L6150:
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	62
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	%rsi
    call      cc_libpcl.setmode_u
    jmp       L6101
L6151:
    mov       %rcx,	%r13
    mov       %rdx,	%rsi
    call      cc_blockpcl.dx_preincrx
    jmp       L6101
L6152:
    mov       %rcx,	%r13
    mov       %rdx,	%rsi
    call      cc_blockpcl.dx_postincrx
    jmp       L6101
L6153:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	90
    mov       %r9,	1
    call      cc_blockpcl.dx_binto
    jmp       L6101
L6154:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	91
    mov       %r9,	1
    call      cc_blockpcl.dx_binto
    jmp       L6101
L6155:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	92
    mov       %r9,	1
    call      cc_blockpcl.dx_binto
    jmp       L6101
L6156:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	93
    mov       %r9,	1
    call      cc_blockpcl.dx_binto
    jmp       L6101
L6157:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	95
    mov       %r9,	1
    call      cc_blockpcl.dx_binto
    jmp       L6101
L6158:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	96
    mov       %r9,	1
    call      cc_blockpcl.dx_binto
    jmp       L6101
L6159:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	97
    mov       %r9,	1
    call      cc_blockpcl.dx_binto
    jmp       L6101
L6160:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	98
    mov       %r9,	1
    call      cc_blockpcl.dx_binto
    jmp       L6101
L6161:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	99
    mov       %r9,	1
    call      cc_blockpcl.dx_binto
    jmp       L6101
L6162:
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	100
    mov       %r9,	1
    call      cc_blockpcl.dx_binto
    jmp       L6101
L6163:
    mov       %rcx,	%r13
    mov       %rdx,	%rsi
    mov       %r8,	%r14
    call      cc_blockpcl.dx_addrof
    jmp       L6101
L6164:
    mov       %rcx,	%r13
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    mov       %r9,	%r14
    call      cc_blockpcl.dx_dot
    jmp       L6101
L6165:
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	129
    xor       %edx,	%edx
    call      pc_api.pc_gen
    jmp       L6101
L6166:
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	%r12
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	130
    xor       %edx,	%edx
    call      pc_api.pc_gen
    jmp       L6101
L6103:
    movsxd    %rax,	dword ptr[%r13+40]
    lea       %r10,	[%rip+cc_tables.jtagnames]
    mov       %r10,	[%r10 + %rax*8]
    lea       %rcx,	[%rip+L9105]
    mov       %rdx,	%r10
    xor       %r8d,	%r8d
    call      cc_support.gerror_s
L6101:
    mov       [%rip+cc_decls.clineno],	%rdi
L6098:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_const
cc_blockpcl.dx_const:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    movsxd    %rax,	dword ptr[%rbx+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    mov       %rdi,	%r10
    mov       %rax,	%rdi
    cmp       %rax,	1
    jl        L6169
    cmp       %rax,	9
    jg        L6169
    mov       %rax,	[%rbx]
    mov       %rcx,	%rax
    call      pc_api.genint
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    jmp       L6168
L6169:
    mov       %rax,	%rdi
    cmp       %rax,	10
    jz        L6171
    cmp       %rax,	11
    jz        L6172
    jmp       L6173
L6171:
    movq      %XMM4,	[%rbx]
    movq      %XMM0,	%XMM4
    mov       %rdx,	1
    call      pc_api.genreal
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    jmp       L6170
L6172:
    movq      %XMM4,	[%rbx]
    movq      %XMM0,	%XMM4
    mov       %rdx,	2
    call      pc_api.genreal
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    jmp       L6170
L6173:
    cmp       %rdi,	10
    jl        L6175
    cmp       %rdi,	11
    jg        L6175
    movq      %XMM4,	[%rbx]
    movq      %XMM0,	%XMM4
    mov       %rdx,	2
    call      pc_api.genreal
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    jmp       L6174
L6175:
    cmp       %rdi,	13
    jnz       L6176
    mov       %al,	[%rbx+61]
    test      %al,	%al
    jz        L6178
    mov       %rax,	[%rbx]
    mov       %rcx,	%rax
    call      pc_api.genstring
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    jmp       L6177
L6178:
    mov       %al,	[%rbx+62]
    test      %al,	%al
    jz        L6179
    lea       %rcx,	[%rip+L9106]
    xor       %edx,	%edx
    call      cc_support.gerror
    jmp       L6177
L6179:
    mov       %rax,	[%rbx]
    mov       %rcx,	%rax
    call      pc_api.genint
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
L6177:
    jmp       L6174
L6176:
    lea       %rcx,	[%rip+L9107]
    xor       %edx,	%edx
    call      cc_support.gerror
L6174:
L6170:
L6168:
    movsxd    %rax,	dword ptr[%rbx+52]
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_name
cc_blockpcl.dx_name:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
#PROC3
#PROC4
    mov       %rdi,	[%rbx]
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	7
    jz        L6182
    cmp       %rax,	8
    jz        L6182
    cmp       %rax,	9
    jnz       L6183
L6182:
    test      %rsi,	%rsi
    jz        L6185
    mov       %rcx,	%rdi
    call      cc_libpcl.genmemaddr_d
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	9
    call      cc_libpcl.setmode
    jmp       L6184
L6185:
    mov       %rcx,	%rdi
    call      cc_libpcl.genmem_d
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	%rbx
    call      cc_blockpcl.widen
L6184:
    jmp       L6181
L6183:
    lea       %rcx,	[%rip+L9108]
    xor       %edx,	%edx
    call      cc_support.gerror
L6181:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_bin
cc_blockpcl.dx_bin:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    call      pc_api.pc_gen
    movsxd    %rax,	dword ptr[%rdi+52]
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_binto
cc_blockpcl.dx_binto:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
    mov       %r12,	%r9
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      cc_blockpcl.dx_expr
    test      %r12,	%r12
    jnz       L6189
    mov       %rax,	%rsi
    cmp       %rax,	94
    jz        L6189
    cmp       %rax,	95
    jz        L6189
    call      cc_blockpcl.do_setinplace
L6189:
    test      %r12,	%r12
    jz        L6191
    mov       %rcx,	8
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	10
    mov       %rdx,	2
    mov       %r8,	3
    xor       %r9d,	%r9d
    call      pc_api.pc_genxy
L6191:
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	%rdi
    call      cc_parse.getmemmode
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    test      %r12,	%r12
    jz        L6193
    mov       %rcx,	2
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	%rdi
    call      cc_parse.getmemmode
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
L6193:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.do_assign
cc_blockpcl.do_assign:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      cc_blockpcl.do_fixwiden
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    test      %rsi,	%rsi
    jz        L6196
    mov       %rcx,	9
    xor       %edx,	%edx
    call      pc_api.pc_gen
L6196:
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	3
    jz        L6198
    cmp       %rax,	52
    jz        L6199
    cmp       %rax,	49
    jz        L6200
    jmp       L6201
L6198:
    mov       %rax,	[%rdi]
    mov       %rcx,	%rax
    call      cc_libpcl.genmem_d
    mov       %rcx,	4
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	%rdi
    call      cc_parse.getmemmode
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    jmp       L6197
L6199:
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      cc_blockpcl.dx_expr
    mov       %rcx,	5
    mov       %rdx,	1
    xor       %r8d,	%r8d
    call      pc_api.pc_genix
    mov       %rcx,	%rdi
    call      cc_parse.getmemmode
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    jmp       L6197
L6200:
    mov       %rax,	[%rdi+16]
    mov       %rcx,	%rax
    mov       %rdx,	1
    call      cc_blockpcl.dx_expr
    movsxd    %rax,	dword ptr[%rdi]
    mov       %rcx,	%rax
    call      pc_api.genint
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	9
    call      cc_libpcl.setmode
    mov       %rcx,	57
    mov       %rdx,	1
    xor       %r8d,	%r8d
    call      pc_api.pc_genix
    mov       %rcx,	1
    xor       %edx,	%edx
    call      pc_api.pc_setscaleoff
    mov       %rcx,	%rdi
    call      cc_parse.getmemmode
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    mov       %rcx,	5
    mov       %rdx,	1
    xor       %r8d,	%r8d
    call      pc_api.pc_genix
    mov       %rcx,	1
    xor       %edx,	%edx
    call      pc_api.pc_setscaleoff
    mov       %rcx,	%rdi
    call      cc_parse.getmemmode
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    jmp       L6197
L6201:
    movsxd    %rax,	dword ptr[%rdi+40]
    lea       %r10,	[%rip+cc_tables.jtagnames]
    mov       %r10,	[%r10 + %rax*8]
    lea       %rcx,	[%rip+L9109]
    mov       %rdx,	%r10
    xor       %r8d,	%r8d
    call      cc_support.gerror_s
L6197:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_ptr
cc_blockpcl.dx_ptr:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    test      %rsi,	%rsi
    jnz       L6204
    mov       %rcx,	2
    mov       %rdx,	1
    xor       %r8d,	%r8d
    call      pc_api.pc_genix
    mov       %rcx,	%rdi
    call      cc_blockpcl.widen
L6204:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_addptr
cc_blockpcl.dx_addptr:
#PROC1
#PROC2
#?>>
    .set cc_blockpcl.dx_addptr.am, 80
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
    mov       %r12,	%r9
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	%r12
    mov       %rdx,	1
    xor       %r8d,	%r8d
    call      pc_api.pc_genix
    movsxd    %rax,	dword ptr[%rdi]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      pc_api.pc_setscaleoff
    movsxd    %rax,	dword ptr[%rbx+52]
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_addrof
cc_blockpcl.dx_addrof:
#PROC1
#PROC2
#?>>
    .set cc_blockpcl.dx_addrof.p, 24
    .set cc_blockpcl.dx_addrof.am, 40
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rdx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      cc_blockpcl.dx_expr
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_convert
cc_blockpcl.dx_convert:
#PROC1
#PROC2
#?>>
    .set cc_blockpcl.dx_convert.p, 64
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r12,	%rdx
    mov       %r13,	%r8
    mov       %r14,	%r9
#---------------
#PROC3
#PROC4
    movsxd    %rax,	dword ptr[%r12+52]
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rdi
    mov       %rbx,	[%rax + %r10*8]
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%r13
    mov       %rsi,	[%rax + %r10*8]
    mov       %rcx,	%r12
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rax,	%r14
    cmp       %rax,	1
    jz        L6209
    cmp       %rax,	2
    jz        L6210
    cmp       %rax,	3
    jz        L6211
    cmp       %rax,	4
    jz        L6211
    cmp       %rax,	5
    jz        L6212
    cmp       %rax,	6
    jz        L6212
    cmp       %rax,	7
    jz        L6213
    cmp       %rax,	8
    jz        L6213
    cmp       %rax,	9
    jz        L6214
    cmp       %rax,	10
    jz        L6215
    cmp       %rax,	11
    jz        L6216
    cmp       %rax,	12
    jz        L6216
    jmp       L6217
L6209:
    jmp       L6207
L6210:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	10
    jz        L6220
    cmp       %rax,	11
    jnz       L6219
L6220:
    lea       %rcx,	[%rip+L9110]
    xor       %edx,	%edx
    call      cc_support.gerror
L6219:
    cmp       %rsi,	%rbx
    jle       L6222
    mov       %rcx,	114
    xor       %edx,	%edx
    call      pc_api.pc_gen
    jmp       L6221
L6222:
    cmp       %rsi,	%rbx
    jl        L6224
L6223:
L6221:
    jmp       L6208
L6211:
    cmp       %rbx,	%rsi
    jz        L6207
L6226:
    mov       %rcx,	114
    xor       %edx,	%edx
    call      pc_api.pc_gen
    jmp       L6208
L6212:
    mov       %rcx,	111
    xor       %edx,	%edx
    call      pc_api.pc_gen
    jmp       L6208
L6213:
    mov       %rcx,	112
    xor       %edx,	%edx
    call      pc_api.pc_gen
    jmp       L6208
L6214:
    mov       %rcx,	115
    xor       %edx,	%edx
    call      pc_api.pc_gen
    jmp       L6208
L6215:
    mov       %rcx,	116
    xor       %edx,	%edx
    call      pc_api.pc_gen
    jmp       L6208
L6216:
#cc_blockpcl.dx_convert.dotruncate:
L6224:
    mov       %rcx,	113
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	3
    call      cc_libpcl.setmode
    mov       %rcx,	%r13
    call      cc_libpcl.setmode2
    jmp       L6207
L6217:
    lea       %rax,	[%rip+cc_tables.convnames]
    mov       %r10,	%r14
    mov       %rax,	[%rax + %r10*8]
    lea       %rcx,	[%rip+L9111]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      cc_support.gerror_s
L6208:
    mov       %rcx,	%r13
    call      cc_libpcl.setmode
    mov       %rcx,	%rdi
    call      cc_libpcl.setmode2
L6207:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.do_if
cc_blockpcl.do_if:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
#PROC3
#PROC4
    call      cc_libpcl.createfwdlabel
    mov       %rdi,	%rax
    mov       %rcx,	28
    mov       %rdx,	%rsi
    mov       %r8,	%rdi
    call      cc_blockpcl.genjumpcond
    mov       %rcx,	%r12
    call      cc_blockpcl.do_stmt
    test      %r13,	%r13
    jz        L6229
    call      cc_libpcl.createfwdlabel
    mov       %rbx,	%rax
    mov       %rcx,	%rbx
    call      cc_blockpcl.genjumpl
    mov       %rcx,	%rdi
    call      cc_libpcl.definefwdlabel
    mov       %rcx,	%r13
    call      cc_blockpcl.do_stmt
    mov       %rcx,	%rbx
    call      cc_libpcl.definefwdlabel
    jmp       L6228
L6229:
    mov       %rcx,	%rdi
    call      cc_libpcl.definefwdlabel
L6228:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.genjumpcond
cc_blockpcl.genjumpcond:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
#---------------
#PROC3
#PROC4
    mov       %rdi,	[%r13+16]
    mov       %rbx,	[%r13+24]
    movsxd    %rax,	dword ptr[%r13+40]
    sub       %rax,	24
    cmp       %rax,	15
    jae       L6233
    lea       %r10,	[%rip+L6232]
    jmp       [%r10 + %rax*8]
    .data
L6232:
    .quad     L6234
    .quad     L6239
    .quad     L6244
    .quad     L6249
    .quad     L6233
    .quad     L6251
    .quad     L6233
    .quad     L6233
    .quad     L6233
    .quad     L6250
    .quad     L6250
    .quad     L6250
    .quad     L6250
    .quad     L6250
    .quad     L6250
    .text
L6234:
    mov       %rax,	%r12
    cmp       %rax,	28
    jz        L6236
    cmp       %rax,	27
    jz        L6237
    jmp       L6238
L6236:
    mov       %rcx,	28
    mov       %rdx,	%rdi
    mov       %r8,	%r14
    call      cc_blockpcl.genjumpcond
    mov       %rcx,	28
    mov       %rdx,	%rbx
    mov       %r8,	%r14
    call      cc_blockpcl.genjumpcond
    jmp       L6235
L6237:
    call      cc_libpcl.createfwdlabel
    mov       %rsi,	%rax
    mov       %rcx,	28
    mov       %rdx,	%rdi
    mov       %r8,	%rsi
    call      cc_blockpcl.genjumpcond
    mov       %rcx,	27
    mov       %rdx,	%rbx
    mov       %r8,	%r14
    call      cc_blockpcl.genjumpcond
    mov       %rcx,	%rsi
    call      cc_libpcl.definefwdlabel
L6238:
L6235:
    jmp       L6231
L6239:
    mov       %rax,	%r12
    cmp       %rax,	28
    jz        L6241
    cmp       %rax,	27
    jz        L6242
    jmp       L6243
L6241:
    call      cc_libpcl.createfwdlabel
    mov       %rsi,	%rax
    mov       %rcx,	27
    mov       %rdx,	%rdi
    mov       %r8,	%rsi
    call      cc_blockpcl.genjumpcond
    mov       %rcx,	28
    mov       %rdx,	%rbx
    mov       %r8,	%r14
    call      cc_blockpcl.genjumpcond
    mov       %rcx,	%rsi
    call      cc_libpcl.definefwdlabel
    jmp       L6240
L6242:
    mov       %rcx,	27
    mov       %rdx,	%rdi
    mov       %r8,	%r14
    call      cc_blockpcl.genjumpcond
    mov       %rcx,	27
    mov       %rdx,	%rbx
    mov       %r8,	%r14
    call      cc_blockpcl.genjumpcond
L6243:
L6240:
    jmp       L6231
L6244:
    mov       %rax,	%r12
    cmp       %rax,	28
    jz        L6246
    cmp       %rax,	27
    jz        L6247
    jmp       L6248
L6246:
    mov       %rcx,	27
    mov       %rdx,	%rdi
    mov       %r8,	%r14
    call      cc_blockpcl.genjumpcond
    jmp       L6245
L6247:
    mov       %rcx,	28
    mov       %rdx,	%rdi
    mov       %r8,	%r14
    call      cc_blockpcl.genjumpcond
L6248:
L6245:
    jmp       L6231
L6249:
    mov       %rcx,	%r12
    mov       %rdx,	%rdi
    mov       %r8,	%r14
    call      cc_blockpcl.genjumpcond
    jmp       L6231
L6250:
    sub       %rsp,	8
    mov       %rax,	%r14
    push      %rax
    mov       %rcx,	%r12
    mov       %rdx,	%r13
    mov       %r8,	%rdi
    mov       %r9,	%rbx
    sub       %rsp,	32
    call      cc_blockpcl.gcomparejump
    add       %rsp,	48
    jmp       L6231
L6251:
    jmp       L6253
L6252:
    mov       %rcx,	%rdi
    call      cc_blockpcl.do_stmt
    mov       %rdi,	%rbx
L6253:
    test      %rdi,	%rdi
    jz        L6255
    mov       %rax,	[%rdi+8]
    mov       %rbx,	%rax
    test      %rax,	%rax
    jnz       L6252
L6255:
    mov       %rcx,	%r12
    mov       %rdx,	%rdi
    mov       %r8,	%r14
    call      cc_blockpcl.genjumpcond
    jmp       L6231
L6233:
    mov       %rcx,	%r13
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	%r14
    call      pc_api.genlabel
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	%r13
    call      cc_libpcl.setmode_u
L6231:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.gcomparejump
cc_blockpcl.gcomparejump:
#PROC1
#PROC2
#?>>
    .set cc_blockpcl.gcomparejump.lab, 88
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
    mov       %r13,	%r9
#---------------
#PROC3
#PROC4
    movsxd    %rax,	dword ptr[%rsi+40]
    mov       %rcx,	%rax
    call      cc_blockpcl.getpclcond
    mov       %rdi,	%rax
    cmp       %rbx,	28
    jnz       L6258
    mov       %rcx,	%rdi
    call      cc_blockpcl.reversecond
    mov       %rdi,	%rax
L6258:
    mov       %rcx,	%r12
    mov       %rdx,	%r13
    call      cc_blockpcl.do_fixwiden
    mov       %rcx,	%r12
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	%r13
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	[%rbp + cc_blockpcl.gcomparejump.lab]
    call      pc_api.genlabel
    mov       %rcx,	26
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %al,	%dil
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+2],	%al
    mov       %rcx,	%r12
    call      cc_libpcl.setmode_u
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.getpclcond
cc_blockpcl.getpclcond:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       %rax,	%rcx
    cmp       %rax,	33
    jz        L6261
    cmp       %rax,	34
    jz        L6262
    cmp       %rax,	35
    jz        L6263
    cmp       %rax,	36
    jz        L6264
    cmp       %rax,	38
    jz        L6265
    cmp       %rax,	37
    jz        L6266
    jmp       L6267
L6261:
    mov       %rax,	1
    jmp       L6259
L6262:
    mov       %rax,	2
    jmp       L6259
L6263:
    mov       %rax,	3
    jmp       L6259
L6264:
    mov       %rax,	4
    jmp       L6259
L6265:
    mov       %rax,	5
    jmp       L6259
L6266:
    mov       %rax,	6
    jmp       L6259
L6267:
L6260:
    xor       %eax,	%eax
L6259:
#---------------
    ret       
# End 
# Proc cc_blockpcl.reversecond
cc_blockpcl.reversecond:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       %rax,	%rcx
    cmp       %rax,	1
    jz        L6270
    cmp       %rax,	2
    jz        L6271
    cmp       %rax,	3
    jz        L6272
    cmp       %rax,	4
    jz        L6273
    cmp       %rax,	5
    jz        L6274
    cmp       %rax,	6
    jz        L6275
    jmp       L6276
L6270:
    mov       %rax,	2
    mov       %rcx,	%rax
    jmp       L6269
L6271:
    mov       %rax,	1
    mov       %rcx,	%rax
    jmp       L6269
L6272:
    mov       %rax,	5
    mov       %rcx,	%rax
    jmp       L6269
L6273:
    mov       %rax,	6
    mov       %rcx,	%rax
    jmp       L6269
L6274:
    mov       %rax,	3
    mov       %rcx,	%rax
    jmp       L6269
L6275:
    mov       %rax,	4
    mov       %rcx,	%rax
L6276:
L6269:
    mov       %rax,	%rcx
L6268:
#---------------
    ret       
# End 
# Proc cc_blockpcl.genjumpl
cc_blockpcl.genjumpl:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    call      pc_api.genlabel
    mov       %rcx,	24
    mov       %rdx,	%rax
    call      pc_api.pc_gen
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.do_while
cc_blockpcl.do_while:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r12,	%rcx
    mov       %r13,	%rdx
#---------------
#PROC3
#PROC4
    movsxd    %rax,	dword ptr[%r12+40]
    cmp       %rax,	1
    jnz       L6280
    mov       %rax,	[%r12]
    test      %rax,	%rax
    jz        L6280
    mov       %rcx,	%r13
    call      cc_blockpcl.do_while1
    jmp       L6278
L6280:
    call      cc_libpcl.createfwdlabel
    mov       %rbx,	%rax
    call      cc_libpcl.createfwdlabel
    mov       %rsi,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      cc_blockpcl.stacklooplabels
    mov       %rcx,	%rbx
    call      cc_blockpcl.genjumpl
    call      cc_libpcl.definelabel
    mov       %rdi,	%rax
    mov       %rcx,	%r13
    call      cc_blockpcl.do_stmt
    mov       %rcx,	%rbx
    call      cc_libpcl.definefwdlabel
    mov       %rcx,	27
    mov       %rdx,	%r12
    mov       %r8,	%rdi
    call      cc_blockpcl.genjumpcond
    mov       %rcx,	%rsi
    call      cc_libpcl.definefwdlabel
    dec       qword ptr[%rip+cc_blockpcl.loopindex]
L6278:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.do_while1
cc_blockpcl.do_while1:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
#PROC3
#PROC4
    call      cc_libpcl.createfwdlabel
    mov       %rbx,	%rax
    call      cc_libpcl.createfwdlabel
    mov       %rsi,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      cc_blockpcl.stacklooplabels
    call      cc_libpcl.definelabel
    mov       %rdi,	%rax
    mov       %rcx,	%r12
    call      cc_blockpcl.do_stmt
    mov       %rcx,	%rbx
    call      cc_libpcl.definefwdlabel
    mov       %rcx,	%rdi
    call      cc_blockpcl.genjumpl
    mov       %rcx,	%rsi
    call      cc_libpcl.definefwdlabel
    dec       qword ptr[%rip+cc_blockpcl.loopindex]
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.do_dowhile
cc_blockpcl.do_dowhile:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r12,	%rcx
    mov       %r13,	%rdx
#---------------
#PROC3
#PROC4
    call      cc_libpcl.createfwdlabel
    mov       %rbx,	%rax
    call      cc_libpcl.createfwdlabel
    mov       %rsi,	%rax
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      cc_blockpcl.stacklooplabels
    call      cc_libpcl.definelabel
    mov       %rdi,	%rax
    mov       %rcx,	%r12
    call      cc_blockpcl.do_stmt
    mov       %rcx,	%rbx
    call      cc_libpcl.definefwdlabel
    mov       %rcx,	%r13
    call      cc_parse.iscondfalse
    test      %rax,	%rax
    jnz       L6284
    mov       %rcx,	27
    mov       %rdx,	%r13
    mov       %r8,	%rdi
    call      cc_blockpcl.genjumpcond
L6284:
    mov       %rcx,	%rsi
    call      cc_libpcl.definefwdlabel
    dec       qword ptr[%rip+cc_blockpcl.loopindex]
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.stacklooplabels
cc_blockpcl.stacklooplabels:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    inc       qword ptr[%rip+cc_blockpcl.loopindex]
    mov       %rax,	[%rip+cc_blockpcl.loopindex]
    mov       %r10,	%rcx
    lea       %r11,	[%rip+cc_blockpcl.continuestack]
    mov       [%r11 + %rax*8-8],	%r10
    mov       %rax,	%rdx
    lea       %r10,	[%rip+cc_blockpcl.breakstack]
    mov       %r11,	[%rip+cc_blockpcl.loopindex]
    mov       [%r10 + %r11*8-8],	%rax
#---------------
    ret       
# End 
# Proc cc_blockpcl.do_return
cc_blockpcl.do_return:
#PROC1
#PROC2
#?>>
    .set cc_blockpcl.do_return.p, 24
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rdx
#---------------
#PROC3
#PROC4
    test      %rdi,	%rdi
    jz        L6288
    mov       %rax,	[%rip+cc_decls.currproc]
    movzx     %rax,	byte ptr[%rax+108]
    shr       %eax,	3
    and       %eax,	1
    test      %rax,	%rax
    jz        L6290
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	32
    xor       %edx,	%edx
    call      pc_api.pc_gen
    jmp       L6289
L6290:
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	[%rip+cc_genpcl.retindex]
    call      pc_api.genlabel
    mov       %rcx,	29
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	%rdi
    call      cc_libpcl.setmode_u
L6289:
    jmp       L6287
L6288:
    mov       %rcx,	[%rip+cc_genpcl.retindex]
    call      cc_blockpcl.genjumpl
L6287:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_call
cc_blockpcl.dx_call:
#PROC1
#PROC2
#?>>
    .set cc_blockpcl.dx_call.b, 88
    .set cc_blockpcl.dx_call.res, 96
    .set cc_blockpcl.dx_call.retmode, -8
    .set cc_blockpcl.dx_call.m, -16
    .set cc_blockpcl.dx_call.nvariadics, -24
    .set cc_blockpcl.dx_call.nfixedparams, -32
    .set cc_blockpcl.dx_call.isfn, -40
    .set cc_blockpcl.dx_call.paramlist, -552
    .set cc_blockpcl.dx_call.paramconst, -616
    .set cc_blockpcl.dx_call.argattr, -680
    .set cc_blockpcl.dx_call.iparams, -688
    .set cc_blockpcl.dx_call.fparams, -696
    .set cc_blockpcl.dx_call.q, -704
    .set cc_blockpcl.dx_call.i, -712
    .set cc_blockpcl.dx_call.$T1, -720
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	760
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       [%rbp+88],	%r8
    mov       [%rbp+96],	%r9
#---------------
#PROC3
#PROC4
    movsxd    %rax,	dword ptr[%r13+52]
    mov       [%rbp + cc_blockpcl.dx_call.retmode],	%rax
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.retmode]
    test      %rax,	%rax
    jnz       L6293
    mov       %rax,	3
    mov       [%rbp + cc_blockpcl.dx_call.retmode],	%rax
L6293:
    xor       %eax,	%eax
    mov       [%rbp + cc_blockpcl.dx_call.isfn],	%rax
    movsxd    %rax,	dword ptr[%r14+40]
    cmp       %rax,	52
    jnz       L6296
L6295:
    movsxd    %rax,	dword ptr[%r14+52]
    mov       [%rbp + cc_blockpcl.dx_call.m],	%rax
    jmp       L6298
L6297:
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	[%rbp + cc_blockpcl.dx_call.m]
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       [%rbp + cc_blockpcl.dx_call.m],	%rax
L6298:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	[%rbp + cc_blockpcl.dx_call.m]
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	13
    jz        L6297
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	[%rbp + cc_blockpcl.dx_call.m]
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	0
    setnz     %al
    movzx     %eax,	%al
    mov       [%rbp + cc_blockpcl.dx_call.isfn],	%rax
    lea       %rax,	[%rip+cc_decls.ttparams]
    mov       %r10,	[%rbp + cc_blockpcl.dx_call.m]
    mov       %rdi,	[%rax + %r10*8]
    mov       %rbx,	1
    jmp       L6294
L6296:
    mov       %rax,	[%r14]
    mov       %rdi,	[%rax+80]
    xor       %rbx,	%rbx
    mov       %rax,	[%r14]
    movzx     %rax,	word ptr[%rax+102]
    cmp       %rax,	0
    setnz     %al
    movzx     %eax,	%al
    mov       [%rbp + cc_blockpcl.dx_call.isfn],	%rax
L6294:
    movsx     %rax,	word ptr[%rdi+22]
    cmp       %rax,	3
    setz      %al
    movzx     %eax,	%al
    mov       %rsi,	%rax
    movsx     %rax,	word ptr[%rdi+20]
    mov       [%rbp + cc_blockpcl.dx_call.nfixedparams],	%rax
    xor       %eax,	%eax
    mov       [%rbp + cc_blockpcl.dx_call.nvariadics],	%rax
    mov       %r12,	%rax
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.b]
    mov       [%rbp + cc_blockpcl.dx_call.q],	%rax
    jmp       L6303
L6300:
    cmp       %r12,	64
    jl        L6305
    lea       %rcx,	[%rip+L9112]
    xor       %edx,	%edx
    call      cc_support.gerror
L6305:
    inc       %r12
    mov       %rax,	%r12
    mov       %r10,	[%rbp + cc_blockpcl.dx_call.q]
    mov       [%rbp + %rax*8 + cc_blockpcl.dx_call.paramlist-8],	%r10
    xor       %eax,	%eax
    mov       [%rbp + %r12 + cc_blockpcl.dx_call.paramconst-1],	%al
    test      %rsi,	%rsi
    jz        L6307
    cmp       %r12,	[%rbp + cc_blockpcl.dx_call.nfixedparams]
    jle       L6307
    cmp       %r12,	4
    jg        L6307
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.nvariadics]
    test      %rax,	%rax
    jnz       L6307
    mov       [%rbp + cc_blockpcl.dx_call.nvariadics],	%r12
L6307:
    cmp       %r12,	[%rbp + cc_blockpcl.dx_call.nfixedparams]
    jg        L6309
    movsxd    %rax,	dword ptr[%rdi+16]
    lea       %r10,	[%rip+cc_decls.ttconst]
    mov       %r10b,	[%r10 + %rax]
    mov       [%rbp + %r12 + cc_blockpcl.dx_call.paramconst-1],	%r10b
    mov       %rdi,	[%rdi+8]
L6309:
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.q]
    mov       %rax,	[%rax+8]
    mov       [%rbp + cc_blockpcl.dx_call.q],	%rax
L6303:
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.q]
    test      %rax,	%rax
    jnz       L6300
    mov       %rcx,	131
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	%r13
    call      cc_libpcl.setmode_u
    mov       %eax,	%r12d
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+16],	%eax
    xor       %eax,	%eax
    mov       [%rbp + cc_blockpcl.dx_call.fparams],	%rax
    mov       [%rbp + cc_blockpcl.dx_call.iparams],	%rax
    mov       %rax,	1
    mov       [%rbp + cc_blockpcl.dx_call.i],	%rax
    cmp       %r12,	1
    jl        L6312
L6310:
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.i]
    mov       %rax,	[%rbp + %rax*8 + cc_blockpcl.dx_call.paramlist-8]
    mov       [%rbp + cc_blockpcl.dx_call.q],	%rax
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.q]
    movsxd    %rax,	dword ptr[%rax+52]
    cmp       %rax,	10
    jz        L6315
    cmp       %rax,	11
    jnz       L6314
L6315:
    inc       qword ptr[%rbp + cc_blockpcl.dx_call.fparams]
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.fparams]
    neg       %rax
    mov       %r10,	[%rbp + cc_blockpcl.dx_call.i]
    mov       [%rbp + %r10 + cc_blockpcl.dx_call.argattr-1],	%al
    jmp       L6313
L6314:
    inc       qword ptr[%rbp + cc_blockpcl.dx_call.iparams]
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.iparams]
    mov       %r10,	[%rbp + cc_blockpcl.dx_call.i]
    mov       [%rbp + %r10 + cc_blockpcl.dx_call.argattr-1],	%al
L6313:
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.i]
    inc       %rax
    mov       [%rbp + cc_blockpcl.dx_call.i],	%rax
    cmp       %rax,	%r12
    jle       L6310
L6312:
    mov       [%rbp + cc_blockpcl.dx_call.i],	%r12
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.i]
    cmp       %rax,	1
    jl        L6318
L6316:
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.i]
    mov       %rax,	[%rbp + %rax*8 + cc_blockpcl.dx_call.paramlist-8]
    mov       [%rbp + cc_blockpcl.dx_call.q],	%rax
    mov       %rcx,	[%rbp + cc_blockpcl.dx_call.q]
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.nvariadics]
    test      %rax,	%rax
    jz        L6320
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.i]
    cmp       %rax,	[%rbp + cc_blockpcl.dx_call.nvariadics]
    jl        L6320
    mov       %rax,	[%rip+pc_api.pccurr]
    movzx     %rax,	byte ptr[%rax+3]
    cmp       %rax,	1
    jnz       L6320
    mov       %rcx,	115
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %al,	2
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+3],	%al
    mov       %rax,	[%rip+pc_api.pccurr]
    lea       %rax,	[%rax+28]
    mov       %r10d,	1
    mov       %r15d,	[%rax]
    mov       %r11,	-256
    and       %r15d,	%r11d
    or        %r15d,	%r10d
    mov       [%rax],	%r15d
L6320:
    mov       %rcx,	132
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	[%rbp + cc_blockpcl.dx_call.q]
    call      cc_libpcl.setmode_u
    mov       %eax,	[%rbp + cc_blockpcl.dx_call.i]
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+16],	%eax
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.i]
    movsx     %rax,	byte ptr[%rbp + %rax + cc_blockpcl.dx_call.argattr-1]
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+20],	%eax
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.i]
    dec       %rax
    mov       [%rbp + cc_blockpcl.dx_call.i],	%rax
    cmp       %rax,	1
    jge       L6316
L6318:
    test      %rbx,	%rbx
    jnz       L6322
    mov       %rax,	[%r14]
    mov       %rcx,	%rax
    call      cc_libpcl.genmemaddr_d
    mov       [%rbp + cc_blockpcl.dx_call.$T1],	%rax
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.isfn]
    test      %rax,	%rax
    jz        L6324
    mov       %rax,	21
    jmp       L6323
L6324:
    mov       %rax,	18
L6323:
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + cc_blockpcl.dx_call.$T1]
    call      pc_api.pc_gen
    jmp       L6321
L6322:
    mov       %rax,	[%r14+16]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.isfn]
    test      %rax,	%rax
    jz        L6326
    mov       %rax,	22
    jmp       L6325
L6326:
    mov       %rax,	19
L6325:
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      pc_api.pc_gen
L6321:
    mov       %eax,	%r12d
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+16],	%eax
    mov       %eax,	[%rbp + cc_blockpcl.dx_call.nvariadics]
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+20],	%eax
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.isfn]
    test      %rax,	%rax
    jz        L6328
    mov       %rcx,	%r13
    call      cc_parse.getmemmode
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    mov       %rax,	[%rbp + cc_blockpcl.dx_call.res]
    test      %rax,	%rax
    jnz       L6330
    mov       %rcx,	11
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	%r13
    call      cc_parse.getmemmode
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    jmp       L6329
L6330:
    mov       %rcx,	%r13
    call      cc_blockpcl.widen
L6329:
L6328:
#---------------
    add       %rsp,	760
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.do_decl
cc_blockpcl.do_decl:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rdi,	[%rbx+72]
    mov       %al,	1
    mov       [%rbx+122],	%al
    mov       %rax,	[%rbx+56]
    test      %rax,	%rax
    jz        L6333
    mov       %rax,	[%rbx+56]
    mov       %r10b,	1
    mov       [%rax+92],	%r10b
L6333:
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	28
    jz        L6335
    movzx     %rax,	word ptr[%rbx+102]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    cmp       %r10,	17
    jnz       L6337
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	1
    jz        L6338
L6337:
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	%rbx
    call      cc_libpcl.genmem_d
    mov       %rcx,	4
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    movsxd    %rax,	dword ptr[%rdi+52]
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    jmp       L6331
L6335:
#cc_blockpcl.do_decl.copyl:
L6338:
    mov       %rax,	[%rbx+114]
    mov       %rcx,	%rax
    call      pc_api.genmem
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    movzx     %rax,	word ptr[%rbx+102]
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    mov       %rcx,	%rbx
    call      cc_libpcl.genmem_d
    mov       %rcx,	4
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    movzx     %rax,	word ptr[%rbx+102]
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
L6331:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.do_for
cc_blockpcl.do_for:
#PROC1
#PROC2
#?>>
    .set cc_blockpcl.do_for.pbody, 80
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %r15,	%rcx
    mov       [%rbp+80],	%rdx
#---------------
#PROC3
#PROC4
    mov       %rdi,	[%r15+8]
    mov       %rbx,	[%rdi+8]
    call      cc_libpcl.createfwdlabel
    mov       %r12,	%rax
    call      cc_libpcl.createfwdlabel
    mov       %r13,	%rax
    call      cc_libpcl.createfwdlabel
    mov       %r14,	%rax
    movsxd    %rax,	dword ptr[%r15+40]
    cmp       %rax,	2
    jz        L6341
    mov       %rcx,	%r15
    call      cc_blockpcl.do_stmt
L6341:
    mov       %rcx,	%r14
    call      cc_blockpcl.genjumpl
    mov       %rcx,	%r12
    mov       %rdx,	%r13
    call      cc_blockpcl.stacklooplabels
    call      cc_libpcl.definelabel
    mov       %rsi,	%rax
    mov       %rcx,	[%rbp + cc_blockpcl.do_for.pbody]
    call      cc_blockpcl.do_stmt
    mov       %rcx,	%r12
    call      cc_libpcl.definefwdlabel
    mov       %rcx,	%rbx
    call      cc_blockpcl.do_stmt
    mov       %rcx,	%r14
    call      cc_libpcl.definefwdlabel
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	2
    jz        L6343
    mov       %rcx,	27
    mov       %rdx,	%rdi
    mov       %r8,	%rsi
    call      cc_blockpcl.genjumpcond
    jmp       L6342
L6343:
    mov       %rcx,	%rsi
    call      cc_blockpcl.genjumpl
L6342:
    mov       %rcx,	%r13
    call      cc_libpcl.definefwdlabel
    dec       qword ptr[%rip+cc_blockpcl.loopindex]
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.do_preincr
cc_blockpcl.do_preincr:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      cc_blockpcl.dx_expr
    call      cc_blockpcl.do_setinplace
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	%rdi
    call      cc_parse.getmemmode
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    movsxd    %rax,	dword ptr[%rdi+52]
    mov       %rcx,	%rax
    call      cc_blockpcl.setincrstep
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.setincrstep
cc_blockpcl.setincrstep:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	1
    call      pc_api.pc_setincr
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%rdi
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L6347
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      pc_api.pc_setincr
L6347:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_preincrx
cc_blockpcl.dx_preincrx:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      cc_blockpcl.dx_expr
    call      cc_blockpcl.do_setinplace
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	71
    jnz       L6350
    mov       %rax,	86
    jmp       L6349
L6350:
    mov       %rax,	87
L6349:
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      pc_api.pc_gen
    movsxd    %rax,	dword ptr[%rbx+52]
    mov       %rcx,	%rax
    call      cc_blockpcl.setincrstep
    mov       %rcx,	%rbx
    call      cc_blockpcl.widen
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_postincrx
cc_blockpcl.dx_postincrx:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      cc_blockpcl.dx_expr
    call      cc_blockpcl.do_setinplace
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	73
    jnz       L6353
    mov       %rax,	88
    jmp       L6352
L6353:
    mov       %rax,	89
L6352:
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      pc_api.pc_gen
    movsxd    %rax,	dword ptr[%rbx+52]
    mov       %rcx,	%rax
    call      cc_blockpcl.setincrstep
    mov       %rcx,	%rbx
    call      cc_blockpcl.widen
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_dot
cc_blockpcl.dx_dot:
#PROC1
#PROC2
#?>>
    .set cc_blockpcl.dx_dot.b, 56
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r9
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      cc_blockpcl.dx_expr
    movsxd    %rax,	dword ptr[%rdi]
    mov       %rcx,	%rax
    call      pc_api.genint
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	9
    call      cc_libpcl.setmode
    test      %rsi,	%rsi
    jnz       L6356
    mov       %rcx,	57
    mov       %rdx,	1
    xor       %r8d,	%r8d
    call      pc_api.pc_genix
    mov       %rcx,	%rdi
    call      cc_parse.getmemmode
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    mov       %rcx,	1
    xor       %edx,	%edx
    call      pc_api.pc_setscaleoff
    mov       %rcx,	2
    mov       %rdx,	1
    xor       %r8d,	%r8d
    call      pc_api.pc_genix
    mov       %rcx,	%rdi
    call      cc_blockpcl.widen
    jmp       L6355
L6356:
    mov       %rcx,	57
    mov       %rdx,	1
    xor       %r8d,	%r8d
    call      pc_api.pc_genix
    mov       %rcx,	%rdi
    call      cc_parse.getmemmode
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    mov       %rcx,	1
    xor       %edx,	%edx
    call      pc_api.pc_setscaleoff
L6355:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_eq
cc_blockpcl.dx_eq:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    call      cc_blockpcl.do_fixwiden
    mov       %rcx,	%rbx
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	31
    xor       %edx,	%edx
    call      pc_api.pc_gen
    movsxd    %rax,	dword ptr[%rdi+40]
    mov       %rcx,	%rax
    call      cc_blockpcl.getpclcond
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+2],	%al
    mov       %rcx,	%rbx
    call      cc_libpcl.setmode_u
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.do_labeldef
cc_blockpcl.do_labeldef:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    movsxd    %rax,	dword ptr[%rdi+88]
    cmp       %rax,	0
    jg        L6360
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rax,	[%rip+pc_api.mlabelno]
    mov       [%rdi+88],	%eax
L6360:
    mov       %rcx,	[%rdi]
    call      pc_api.gencomment
    movsxd    %rax,	dword ptr[%rdi+88]
    mov       %rcx,	%rax
    call      pc_api.genlabel
    mov       %rcx,	127
    mov       %rdx,	%rax
    call      pc_api.pc_gen
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.do_goto
cc_blockpcl.do_goto:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    movsxd    %rax,	dword ptr[%rdi+88]
    test      %rax,	%rax
    jnz       L6363
    mov       %rax,	[%rdi]
    lea       %rcx,	[%rip+L9113]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      cc_support.gerror_s
    jmp       L6362
L6363:
    movsxd    %rax,	dword ptr[%rdi+88]
    cmp       %rax,	0
    jge       L6364
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rax,	[%rip+pc_api.mlabelno]
    mov       [%rdi+88],	%eax
L6364:
L6362:
    movsxd    %rax,	dword ptr[%rdi+88]
    mov       %rcx,	%rax
    call      pc_api.genlabel
    mov       %rcx,	24
    mov       %rdx,	%rax
    call      pc_api.pc_gen
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_ifx
cc_blockpcl.dx_ifx:
#PROC1
#PROC2
#?>>
    .set cc_blockpcl.dx_ifx.c, 88
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	32
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
    mov       [%rbp+88],	%r9
#---------------
#PROC3
#PROC4
    movsxd    %rax,	dword ptr[%r12+52]
    cmp       %rax,	0
    setnz     %al
    movzx     %eax,	%al
    mov       %rsi,	%rax
    call      cc_libpcl.createfwdlabel
    mov       %rdi,	%rax
    call      cc_libpcl.createfwdlabel
    mov       %rbx,	%rax
    test      %rsi,	%rsi
    jz        L6367
    mov       %rcx,	117
    xor       %edx,	%edx
    call      pc_api.pc_gen
L6367:
    mov       %rcx,	28
    mov       %rdx,	%r13
    mov       %r8,	%rdi
    call      cc_blockpcl.genjumpcond
    mov       %rcx,	%r14
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    test      %rsi,	%rsi
    jz        L6369
    mov       %rcx,	118
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	%r12
    call      cc_libpcl.setmode_u
L6369:
    mov       %rcx,	%rbx
    call      cc_blockpcl.genjumpl
    mov       %rcx,	%rdi
    call      cc_libpcl.definefwdlabel
    mov       %rcx,	[%rbp + cc_blockpcl.dx_ifx.c]
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    test      %rsi,	%rsi
    jz        L6371
    mov       %rcx,	119
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	%r12
    call      cc_libpcl.setmode_u
L6371:
    mov       %rcx,	%rbx
    call      cc_libpcl.definefwdlabel
#---------------
    add       %rsp,	32
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.do_casestmt
cc_blockpcl.do_casestmt:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+cc_blockpcl.sw_ncases]
    test      %rax,	%rax
    jnz       L6374
    mov       %rax,	[%rsi]
    sub       %rax,	[%rip+cc_blockpcl.sw_lower]
    mov       %r10,	[%rip+cc_blockpcl.sw_labeltable]
    movsxd    %r10,	dword ptr[%r10 + %rax*4]
    mov       %rcx,	%r10
    call      pc_api.genlabel
    mov       %rcx,	127
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    jmp       L6373
L6374:
    mov       %rdi,	[%rsi]
    mov       %rbx,	1
    mov       %rax,	[%rip+cc_blockpcl.sw_ncases]
    cmp       %rax,	1
    jl        L6378
L6375:
    mov       %rax,	[%rip+cc_blockpcl.sw_valuetable]
    mov       %r10,	%rbx
    movsxd    %rax,	dword ptr[%rax + %r10*4-4]
    cmp       %rax,	%rdi
    jnz       L6380
    mov       %rax,	[%rip+cc_blockpcl.sw_labeltable]
    mov       %r10,	%rbx
    movsxd    %rax,	dword ptr[%rax + %r10*4-4]
    mov       %rcx,	%rax
    call      pc_api.genlabel
    mov       %rcx,	127
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    jmp       L6377
L6380:
    inc       %rbx
    cmp       %rbx,	[%rip+cc_blockpcl.sw_ncases]
    jle       L6375
L6378:
    lea       %rcx,	[%rip+L9114]
    xor       %edx,	%edx
    call      cc_support.gerror
L6377:
L6373:
    mov       %rcx,	%r12
    call      cc_blockpcl.do_stmt
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.do_switch
cc_blockpcl.do_switch:
#PROC1
#PROC2
#?>>
    .set cc_blockpcl.do_switch.a, 80
    .set cc_blockpcl.do_switch.b, 88
    .set cc_blockpcl.do_switch.labeltable, -2000
    .set cc_blockpcl.do_switch.valuetable, -4000
    .set cc_blockpcl.do_switch.flags, -4504
    .set cc_blockpcl.do_switch.value, -4512
    .set cc_blockpcl.do_switch.ncases, -4520
    .set cc_blockpcl.do_switch.serialsw, -4528
    .set cc_blockpcl.do_switch.i, -4536
    .set cc_blockpcl.do_switch.index, -4544
    .set cc_blockpcl.do_switch.pcase, -4552
    .set cc_blockpcl.do_switch.old_labeltable, -4560
    .set cc_blockpcl.do_switch.old_valuetable, -4568
    .set cc_blockpcl.do_switch.old_ncases, -4576
    .set cc_blockpcl.do_switch.old_lower, -4584
    .set cc_blockpcl.do_switch.old_defaultseen, -4592
    .set cc_blockpcl.do_switch.old_defaultlabel, -4600
    .set cc_blockpcl.do_switch.old_breaklabel, -4608
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	4648
    mov       %r15,	%rcx
    mov       [%rbp+80],	%rdx
    mov       [%rbp+88],	%r8
#---------------
#PROC3
#PROC4
    mov       %rax,	[%r15]
    mov       [%rbp + cc_blockpcl.do_switch.pcase],	%rax
    xor       %eax,	%eax
    mov       %r14,	%rax
    mov       [%rbp + cc_blockpcl.do_switch.ncases],	%rax
    jmp       L6383
L6382:
    inc       qword ptr[%rbp + cc_blockpcl.do_switch.ncases]
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.ncases]
    cmp       %rax,	500
    jle       L6386
    lea       %rcx,	[%rip+L9115]
    xor       %edx,	%edx
    call      cc_support.gerror
L6386:
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.pcase]
    mov       %rax,	[%rax+8]
    mov       [%rbp + cc_blockpcl.do_switch.value],	%rax
    mov       %r10,	[%rbp + cc_blockpcl.do_switch.ncases]
    mov       [%rbp + %r10*4 + cc_blockpcl.do_switch.valuetable-4],	%eax
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.ncases]
    cmp       %rax,	1
    jnz       L6388
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.value]
    mov       %r13,	%rax
    mov       %r12,	%rax
    jmp       L6387
L6388:
    mov       %rax,	%r12
    mov       %r10,	[%rbp + cc_blockpcl.do_switch.value]
    cmp       %rax,	%r10
    cmovg     %rax,	%r10
    mov       %r12,	%rax
    mov       %rax,	%r13
    mov       %r10,	[%rbp + cc_blockpcl.do_switch.value]
    cmp       %rax,	%r10
    cmovl     %rax,	%r10
    mov       %r13,	%rax
L6387:
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.pcase]
    mov       %rax,	[%rax]
    mov       [%rbp + cc_blockpcl.do_switch.pcase],	%rax
L6383:
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.pcase]
    test      %rax,	%rax
    jnz       L6382
    mov       %rax,	[%r15]
    test      %rax,	%rax
    jz        L6390
    mov       %rax,	%r13
    sub       %rax,	%r12
    inc       %rax
    mov       %r14,	%rax
    jmp       L6389
L6390:
    xor       %r14,	%r14
L6389:
    call      cc_libpcl.createfwdlabel
    mov       %rdi,	%rax
    call      cc_libpcl.createfwdlabel
    mov       %rbx,	%rax
    cmp       %r14,	500
    jg        L6393
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.ncases]
    cmp       %rax,	8
    jg        L6392
L6393:
    mov       %al,	1
    mov       [%rbp + cc_blockpcl.do_switch.serialsw],	%al
    mov       %rcx,	[%rbp + cc_blockpcl.do_switch.a]
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rax,	1
    mov       [%rbp + cc_blockpcl.do_switch.i],	%rax
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.ncases]
    cmp       %rax,	1
    jl        L6396
L6394:
    call      cc_libpcl.createfwdlabel
    mov       %r10,	[%rbp + cc_blockpcl.do_switch.i]
    mov       [%rbp + %r10*4 + cc_blockpcl.do_switch.labeltable-4],	%eax
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.i]
    movsxd    %rax,	dword ptr[%rbp + %rax*4 + cc_blockpcl.do_switch.valuetable-4]
    mov       %rcx,	%rax
    call      pc_api.genint
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	3
    call      cc_libpcl.setmode
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.i]
    movsxd    %rax,	dword ptr[%rbp + %rax*4 + cc_blockpcl.do_switch.labeltable-4]
    mov       %rcx,	%rax
    call      pc_api.genlabel
    mov       %rcx,	26
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	3
    call      cc_libpcl.setmode
    mov       %al,	1
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+2],	%al
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.i]
    cmp       %rax,	[%rbp + cc_blockpcl.do_switch.ncases]
    jge       L6398
    mov       %eax,	1
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+16],	%eax
L6398:
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.i]
    inc       %rax
    mov       [%rbp + cc_blockpcl.do_switch.i],	%rax
    cmp       %rax,	[%rbp + cc_blockpcl.do_switch.ncases]
    jle       L6394
L6396:
    mov       %rcx,	%rdi
    call      cc_blockpcl.genjumpl
    jmp       L6391
L6392:
    test      %r14,	%r14
    jnz       L6399
    mov       %rcx,	%rdi
    call      cc_blockpcl.genjumpl
    jmp       L6391
L6399:
    xor       %eax,	%eax
    mov       [%rbp + cc_blockpcl.do_switch.serialsw],	%al
    lea       %rcx,	[%rbp + cc_blockpcl.do_switch.flags]
    xor       %edx,	%edx
    mov       %r8,	%r14
    call      memset
    mov       %rax,	1
    mov       [%rbp + cc_blockpcl.do_switch.i],	%rax
    cmp       %r14,	1
    jl        L6402
L6400:
    mov       %eax,	%edi
    mov       %r10,	[%rbp + cc_blockpcl.do_switch.i]
    mov       [%rbp + %r10*4 + cc_blockpcl.do_switch.labeltable-4],	%eax
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.i]
    inc       %rax
    mov       [%rbp + cc_blockpcl.do_switch.i],	%rax
    cmp       %rax,	%r14
    jle       L6400
L6402:
    mov       %rax,	1
    mov       [%rbp + cc_blockpcl.do_switch.i],	%rax
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.ncases]
    cmp       %rax,	1
    jl        L6405
L6403:
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.i]
    movsxd    %rax,	dword ptr[%rbp + %rax*4 + cc_blockpcl.do_switch.valuetable-4]
    mov       [%rbp + cc_blockpcl.do_switch.value],	%rax
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.value]
    sub       %rax,	%r12
    inc       %rax
    mov       [%rbp + cc_blockpcl.do_switch.index],	%rax
    call      cc_libpcl.createfwdlabel
    mov       %r10,	[%rbp + cc_blockpcl.do_switch.index]
    mov       [%rbp + %r10*4 + cc_blockpcl.do_switch.labeltable-4],	%eax
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.index]
    mov       %al,	[%rbp + %rax + cc_blockpcl.do_switch.flags-1]
    test      %al,	%al
    jz        L6407
    mov       %rcx,	[%rbp + cc_blockpcl.do_switch.value]
    xor       %edx,	%edx
    call      msys.strint
    lea       %rcx,	[%rip+L9116]
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    call      cc_support.gerror_s
L6407:
    mov       %al,	1
    mov       %r10,	[%rbp + cc_blockpcl.do_switch.index]
    mov       [%rbp + %r10 + cc_blockpcl.do_switch.flags-1],	%al
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.i]
    inc       %rax
    mov       [%rbp + cc_blockpcl.do_switch.i],	%rax
    cmp       %rax,	[%rbp + cc_blockpcl.do_switch.ncases]
    jle       L6403
L6405:
    call      cc_libpcl.createfwdlabel
    mov       %rsi,	%rax
    mov       %rcx,	[%rbp + cc_blockpcl.do_switch.a]
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    mov       %rcx,	%rsi
    call      pc_api.genlabel
    mov       %rcx,	37
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	3
    call      cc_libpcl.setmode
    mov       %rax,	%r12
    add       %rax,	%r14
    dec       %rax
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      pc_api.pc_setxy
    mov       %rcx,	%rdi
    call      pc_api.genlabel
    mov       %rcx,	12
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	3
    call      cc_libpcl.setmode
    mov       %rcx,	%rsi
    call      cc_libpcl.definefwdlabel
    mov       %rax,	1
    mov       [%rbp + cc_blockpcl.do_switch.i],	%rax
    cmp       %r14,	1
    jl        L6410
L6408:
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.i]
    movsxd    %rax,	dword ptr[%rbp + %rax*4 + cc_blockpcl.do_switch.labeltable-4]
    mov       %rcx,	%rax
    call      pc_api.genlabel
    mov       %rcx,	39
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.i]
    inc       %rax
    mov       [%rbp + cc_blockpcl.do_switch.i],	%rax
    cmp       %rax,	%r14
    jle       L6408
L6410:
    mov       %rcx,	40
    xor       %edx,	%edx
    call      pc_api.pc_gen
L6391:
    mov       %rax,	[%rip+cc_blockpcl.sw_labeltable]
    mov       [%rbp + cc_blockpcl.do_switch.old_labeltable],	%rax
    mov       %rax,	[%rip+cc_blockpcl.sw_valuetable]
    mov       [%rbp + cc_blockpcl.do_switch.old_valuetable],	%rax
    mov       %rax,	[%rip+cc_blockpcl.sw_lower]
    mov       [%rbp + cc_blockpcl.do_switch.old_lower],	%rax
    mov       %rax,	[%rip+cc_blockpcl.sw_ncases]
    mov       [%rbp + cc_blockpcl.do_switch.old_ncases],	%rax
    mov       %al,	[%rip+cc_blockpcl.sw_defaultseen]
    mov       [%rbp + cc_blockpcl.do_switch.old_defaultseen],	%al
    mov       %rax,	[%rip+cc_blockpcl.sw_defaultlabel]
    mov       [%rbp + cc_blockpcl.do_switch.old_defaultlabel],	%rax
    mov       %rax,	[%rip+cc_blockpcl.sw_breaklabel]
    mov       [%rbp + cc_blockpcl.do_switch.old_breaklabel],	%rax
    lea       %rax,	[%rbp + cc_blockpcl.do_switch.labeltable]
    mov       [%rip+cc_blockpcl.sw_labeltable],	%rax
    lea       %rax,	[%rbp + cc_blockpcl.do_switch.valuetable]
    mov       [%rip+cc_blockpcl.sw_valuetable],	%rax
    mov       [%rip+cc_blockpcl.sw_lower],	%r12
    mov       %al,	[%rbp + cc_blockpcl.do_switch.serialsw]
    test      %al,	%al
    jz        L6412
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.ncases]
    jmp       L6411
L6412:
    xor       %eax,	%eax
L6411:
    mov       [%rip+cc_blockpcl.sw_ncases],	%rax
    xor       %eax,	%eax
    mov       [%rip+cc_blockpcl.sw_defaultseen],	%al
    mov       [%rip+cc_blockpcl.sw_defaultlabel],	%rdi
    mov       [%rip+cc_blockpcl.sw_breaklabel],	%rbx
    mov       %rcx,	[%rbp + cc_blockpcl.do_switch.b]
    call      cc_blockpcl.do_stmt
    mov       %al,	[%rip+cc_blockpcl.sw_defaultseen]
    test      %al,	%al
    jnz       L6414
    mov       %rcx,	%rdi
    call      cc_libpcl.definefwdlabel
L6414:
    mov       %rcx,	%rbx
    call      cc_libpcl.definefwdlabel
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.old_labeltable]
    mov       [%rip+cc_blockpcl.sw_labeltable],	%rax
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.old_valuetable]
    mov       [%rip+cc_blockpcl.sw_valuetable],	%rax
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.old_lower]
    mov       [%rip+cc_blockpcl.sw_lower],	%rax
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.old_ncases]
    mov       [%rip+cc_blockpcl.sw_ncases],	%rax
    mov       %al,	[%rbp + cc_blockpcl.do_switch.old_defaultseen]
    mov       [%rip+cc_blockpcl.sw_defaultseen],	%al
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.old_defaultlabel]
    mov       [%rip+cc_blockpcl.sw_defaultlabel],	%rax
    mov       %rax,	[%rbp + cc_blockpcl.do_switch.old_breaklabel]
    mov       [%rip+cc_blockpcl.sw_breaklabel],	%rax
#---------------
    add       %rsp,	4648
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_andorl
cc_blockpcl.dx_andorl:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
#PROC3
#PROC4
    call      cc_libpcl.createfwdlabel
    mov       %rdi,	%rax
    mov       %rcx,	117
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	28
    mov       %rdx,	%rsi
    mov       %r8,	%rdi
    call      cc_blockpcl.genjumpcond
    call      cc_libpcl.createfwdlabel
    mov       %rbx,	%rax
    mov       %rcx,	1
    call      pc_api.genint
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	3
    call      cc_libpcl.setmode
    mov       %rcx,	118
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	[%rsi+16]
    call      cc_libpcl.setmode_u
    mov       %rcx,	%rbx
    call      cc_blockpcl.genjumpl
    mov       %rcx,	%rdi
    call      cc_libpcl.definefwdlabel
    xor       %ecx,	%ecx
    call      pc_api.genint
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	3
    call      cc_libpcl.setmode
    mov       %rcx,	119
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rcx,	[%rsi+16]
    call      cc_libpcl.setmode_u
    mov       %rcx,	%rbx
    call      cc_libpcl.definefwdlabel
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.dx_scale
cc_blockpcl.dx_scale:
#PROC1
#PROC2
#?>>
    .set cc_blockpcl.dx_scale.b, 56
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
#PROC3
#PROC4
    movsxd    %rax,	dword ptr[%rbx+48]
    mov       %rdi,	%rax
    mov       %rcx,	%rsi
    xor       %edx,	%edx
    call      cc_blockpcl.dx_expr
    movsxd    %rax,	dword ptr[%rbx+48]
    cmp       %rax,	0
    jl        L6418
    movsxd    %rax,	dword ptr[%rbx+48]
    mov       %rcx,	%rax
    call      pc_api.genint
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	4
    call      cc_libpcl.setmode
    mov       %rcx,	45
    xor       %edx,	%edx
    call      pc_api.pc_gen
    jmp       L6417
L6418:
    movsxd    %rax,	dword ptr[%rbx+48]
    neg       %rax
    mov       %rcx,	%rax
    call      pc_api.genint
    mov       %rcx,	1
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rcx,	4
    call      cc_libpcl.setmode
    mov       %rcx,	47
    xor       %edx,	%edx
    call      pc_api.pc_gen
L6417:
    mov       %rcx,	%rsi
    call      cc_libpcl.setmode_u
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.widen
cc_blockpcl.widen:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    movsx     %rax,	word ptr[%rbx+56]
    test      %rax,	%rax
    jnz       L6421
    movsxd    %rax,	dword ptr[%rbx+52]
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    jmp       L6419
L6421:
    mov       %rcx,	%rbx
    call      cc_parse.getmemmode
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    call      cc_libpcl.setmode
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    cmp       %rax,	4
    jge       L6423
    mov       %rax,	[%rip+pc_api.pccurr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	1
    jz        L6424
    cmp       %rax,	2
    jz        L6424
    cmp       %rax,	3
    jz        L6424
    cmp       %rax,	86
    jz        L6424
    cmp       %rax,	87
    jz        L6424
    cmp       %rax,	88
    jz        L6424
    cmp       %rax,	89
    jz        L6424
    cmp       %rax,	21
    jnz       L6423
L6424:
    mov       %rcx,	114
    xor       %edx,	%edx
    call      pc_api.pc_gen
    mov       %rax,	%rdi
    cmp       %rax,	1
    jz        L6427
    cmp       %rax,	2
    jnz       L6426
L6427:
    mov       %rax,	3
    jmp       L6425
L6426:
    mov       %rax,	8
L6425:
    mov       %rcx,	%rax
    call      cc_libpcl.setmode
    mov       %rcx,	%rdi
    call      cc_libpcl.setmode2
L6423:
L6419:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_blockpcl.do_setinplace
cc_blockpcl.do_setinplace:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+pc_api.pccurr]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	1
    jnz       L6430
    mov       %rax,	[%rip+pc_api.pccurr]
    movzx     %rax,	byte ptr[%rax+1]
    cmp       %rax,	2
    jnz       L6430
    mov       %eax,	1
    mov       %r10,	[%rip+pc_api.pccurr]
    mov       [%r10+16],	%eax
L6430:
#---------------
    ret       
# End 
# Proc cc_blockpcl.do_fixwiden
cc_blockpcl.do_fixwiden:
#PROC1
#PROC2
#?>>
    .set cc_blockpcl.do_fixwiden.a, 16
    .set cc_blockpcl.do_fixwiden.b, 24
#?]]
#---------------
#PROC3
#PROC4
L6431:
#---------------
    ret       
# End 
# Proc cc_libpcl.getpsymbol
cc_libpcl.getpsymbol:
#PROC1
#PROC2
#?>>
    .set cc_libpcl.getpsymbol.str, -256
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	296
    mov       %rsi,	%rcx
#---------------
#PROC3
#PROC4
    test      %rsi,	%rsi
    jnz       L6434
    xor       %eax,	%eax
    jmp       L6432
L6434:
    mov       %rax,	[%rsi+56]
    test      %rax,	%rax
    jz        L6436
    mov       %rax,	[%rsi+56]
    jmp       L6432
L6436:
    mov       %rbx,	[%rsi]
    movzx     %rax,	byte ptr[%rsi+109]
    cmp       %rax,	8
    jz        L6439
    cmp       %rax,	9
    jnz       L6438
L6439:
    mov       %rax,	[%rsi]
    lea       %rcx,	[%rbp + cc_libpcl.getpsymbol.str]
    mov       %rdx,	%rax
    call      strcpy
    movzx     %rax,	word ptr[%rsi+96]
    cmp       %rax,	1
    jle       L6441
    lea       %rcx,	[%rbp + cc_libpcl.getpsymbol.str]
    lea       %rdx,	[%rip+L9117]
    call      strcat
    movzx     %rax,	word ptr[%rsi+96]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.strint
    lea       %rcx,	[%rbp + cc_libpcl.getpsymbol.str]
    mov       %rdx,	%rax
    call      strcat
L6441:
    jmp       L6437
L6438:
    movzx     %rax,	byte ptr[%rsi+109]
    cmp       %rax,	7
    jnz       L6442
    mov       %rax,	[%rsi+8]
    test      %rax,	%rax
    jz        L6442
    mov       %rax,	[%rsi+8]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	6
    jnz       L6442
    mov       %rax,	[%rsi+8]
    mov       %rax,	[%rax]
    lea       %rcx,	[%rbp + cc_libpcl.getpsymbol.str]
    mov       %rdx,	%rax
    call      strcpy
    lea       %rcx,	[%rbp + cc_libpcl.getpsymbol.str]
    lea       %rdx,	[%rip+L9117]
    call      strcat
    mov       %rax,	[%rsi]
    lea       %rcx,	[%rbp + cc_libpcl.getpsymbol.str]
    mov       %rdx,	%rax
    call      strcat
    movzx     %rax,	word ptr[%rsi+96]
    cmp       %rax,	1
    jle       L6444
    lea       %rcx,	[%rbp + cc_libpcl.getpsymbol.str]
    lea       %rdx,	[%rip+L9117]
    call      strcat
    movzx     %rax,	word ptr[%rsi+96]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.strint
    lea       %rcx,	[%rbp + cc_libpcl.getpsymbol.str]
    mov       %rdx,	%rax
    call      strcat
L6444:
    jmp       L6437
L6442:
    mov       %rax,	[%rsi]
    lea       %rcx,	[%rbp + cc_libpcl.getpsymbol.str]
    mov       %rdx,	%rax
    call      strcpy
L6437:
    movzx     %rax,	byte ptr[%rsi+109]
    lea       %r10,	[%rip+cc_tables.name2pid]
    movzx     %r10,	byte ptr[%r10 + %rax]
    lea       %rcx,	[%rbp + cc_libpcl.getpsymbol.str]
    mov       %rdx,	%r10
    call      pc_api.pc_makesymbol
    mov       %rdi,	%rax
    mov       [%rsi+56],	%rax
    movzx     %rax,	word ptr[%rsi+102]
    mov       %rcx,	%rax
    call      cc_lib.getpclmode
    mov       [%rdi+82],	%al
    movzx     %rax,	word ptr[%rsi+102]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r10,	[%r10 + %rax*8]
    mov       [%rdi+84],	%r10d
    mov       %rax,	[%rsi+8]
    test      %rax,	%rax
    jz        L6446
    mov       %rax,	[%rsi+8]
    mov       %rax,	[%rax+8]
    test      %rax,	%rax
    jz        L6446
    mov       %rax,	[%rsi+8]
    mov       %rcx,	%rax
    call      cc_libpcl.getpsymbol
    mov       [%rdi+32],	%rax
L6446:
    movzx     %rax,	byte ptr[%rsi+110]
    cmp       %rax,	4
    jnz       L6448
    mov       %al,	1
    mov       [%rdi+81],	%al
L6448:
    movzx     %rax,	byte ptr[%rsi+110]
    cmp       %rax,	3
    jnz       L6450
    mov       %al,	1
    mov       [%rdi+80],	%al
    mov       %al,	1
    mov       [%rdi+72],	%al
L6450:
    mov       %al,	[%rsi+122]
    mov       [%rdi+92],	%al
    mov       %eax,	[%rsi+88]
    mov       [%rdi+100],	%eax
    movzx     %rax,	byte ptr[%rsi+109]
    cmp       %rax,	6
    jnz       L6452
    mov       %rax,	[%rsi]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L9118]
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L6452
    mov       %al,	1
    mov       [%rdi+110],	%al
    lea       %r10,	[%rsi+108]
    and       byte ptr[%r10],	247
    shl       %al,	3
    or        [%r10],	%al
L6452:
    mov       %rax,	%rdi
L6432:
#---------------
    add       %rsp,	296
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_libpcl.setmode
cc_libpcl.setmode:
#PROC1
#PROC2
#?>>
    .set cc_libpcl.setmode.$T1, -8
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	40
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    mov       [%rbp + cc_libpcl.setmode.$T1],	%rax
    mov       %rcx,	%rdi
    call      cc_lib.getpclmode
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + cc_libpcl.setmode.$T1]
    call      pc_api.pc_setmode
#---------------
    add       %rsp,	40
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc cc_libpcl.setmode2
cc_libpcl.setmode2:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    call      cc_lib.getpclmode
    mov       %rcx,	%rax
    call      pc_api.pc_setmode2
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_libpcl.setmode_u
cc_libpcl.setmode_u:
#PROC1
#PROC2
#?>>
    .set cc_libpcl.setmode_u.$T1, -8
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    movsxd    %rax,	dword ptr[%rbx+52]
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    mov       [%rbp + cc_libpcl.setmode_u.$T1],	%rax
    mov       %rcx,	%rdi
    call      cc_lib.getpclmode
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + cc_libpcl.setmode_u.$T1]
    call      pc_api.pc_setmode
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_libpcl.genmem_d
cc_libpcl.genmem_d:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    call      cc_libpcl.getpsymbol
    mov       %rcx,	%rax
    call      pc_api.genmem
L6456:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_libpcl.genmemaddr_d
cc_libpcl.genmemaddr_d:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    call      cc_libpcl.getpsymbol
    mov       %rcx,	%rax
    call      pc_api.genmemaddr
L6457:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_libpcl.definelabel
cc_libpcl.definelabel:
#PROC1
#PROC2
#?>>
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rax,	[%rip+pc_api.mlabelno]
    mov       %rcx,	%rax
    call      pc_api.genlabel
    mov       %rcx,	127
    mov       %rdx,	%rax
    call      pc_api.pc_gen
    mov       %rax,	[%rip+pc_api.mlabelno]
L6458:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_libpcl.createfwdlabel
cc_libpcl.createfwdlabel:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    inc       qword ptr[%rip+pc_api.mlabelno]
    mov       %rax,	[%rip+pc_api.mlabelno]
L6459:
#---------------
    ret       
# End 
# Proc cc_libpcl.definefwdlabel
cc_libpcl.definefwdlabel:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    call      pc_api.genlabel
    mov       %rcx,	127
    mov       %rdx,	%rax
    call      pc_api.pc_gen
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lib.newstrec
cc_lib.newstrec:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    mov       %rcx,	128
    call      mlib.pcm_alloc
    mov       %rdi,	%rax
    mov       %rax,	%rdi
    xor       %r10d,	%r10d
    mov       %r11,	4
L9119:
    mov       [%rax],	%r10
    mov       [%rax+8],	%r10
    mov       [%rax+16],	%r10
    mov       [%rax+24],	%r10
    add       %rax,	32
    dec       %r11
    jnz       L9119
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %eax,	[%rax+16]
    mov       [%rdi+92],	%eax
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %al,	[%rax+20]
    mov       [%rdi+113],	%al
    mov       %rax,	%rdi
L6461:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lib.initcclib
cc_lib.initcclib:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
#---------------
    ret       
# End 
# Proc cc_lib.createname
cc_lib.createname:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    call      cc_lib.allocunitrec
    mov       %rdi,	%rax
    mov       %eax,	3
    mov       [%rdi+40],	%eax
    mov       [%rdi],	%rbx
    mov       %rax,	%rdi
L6463:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createunit0
cc_lib.createunit0:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    call      cc_lib.allocunitrec
    mov       %rdi,	%rax
    mov       [%rdi+40],	%ebx
    mov       %rax,	%rdi
L6464:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createunit1
cc_lib.createunit1:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
#PROC3
#PROC4
    call      cc_lib.allocunitrec
    mov       %rdi,	%rax
    mov       [%rdi+40],	%ebx
    mov       [%rdi+16],	%rsi
    mov       %rax,	%rdi
L6465:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createunit2
cc_lib.createunit2:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
#PROC3
#PROC4
    call      cc_lib.allocunitrec
    mov       %rdi,	%rax
    mov       [%rdi+40],	%ebx
    mov       [%rdi+16],	%rsi
    mov       [%rdi+24],	%r12
    mov       %rax,	%rdi
L6466:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createunit3
cc_lib.createunit3:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
    mov       %r13,	%r9
#---------------
#PROC3
#PROC4
    call      cc_lib.allocunitrec
    mov       %rdi,	%rax
    mov       [%rdi+40],	%ebx
    mov       [%rdi+16],	%rsi
    mov       [%rdi+24],	%r12
    mov       [%rdi+32],	%r13
    mov       %rax,	%rdi
L6467:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createconstunit
cc_lib.createconstunit:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
#PROC3
#PROC4
    call      cc_lib.allocunitrec
    mov       %rdi,	%rax
    mov       %eax,	1
    mov       [%rdi+40],	%eax
    mov       [%rdi],	%rbx
    mov       [%rdi+52],	%esi
    mov       %rax,	%rdi
L6468:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createstringconstunit
cc_lib.createstringconstunit:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
#PROC3
#PROC4
    call      cc_lib.allocunitrec
    mov       %rdi,	%rax
    mov       %eax,	1
    mov       [%rdi+40],	%eax
    mov       [%rdi],	%rbx
    mov       %eax,	[%rip+cc_decls.trefchar]
    mov       [%rdi+52],	%eax
    cmp       %rsi,	-1
    jnz       L6471
    mov       %rcx,	%rbx
    call      strlen
    mov       [%rdi+48],	%eax
    jmp       L6470
L6471:
    mov       [%rdi+48],	%esi
L6470:
    mov       %al,	1
    mov       [%rdi+61],	%al
    mov       %rax,	%rdi
L6469:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createwstringconstunit
cc_lib.createwstringconstunit:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
#PROC3
#PROC4
    call      cc_lib.allocunitrec
    mov       %rdi,	%rax
    mov       %eax,	1
    mov       [%rdi+40],	%eax
    mov       [%rdi],	%rbx
    mov       %eax,	[%rip+cc_decls.trefwchar]
    mov       [%rdi+52],	%eax
    mov       [%rdi+48],	%esi
    mov       %al,	1
    mov       [%rdi+62],	%al
    mov       %rax,	%rdi
L6472:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.getoptocode
cc_lib.getoptocode:
#PROC1
#PROC2
#?>>
    .set cc_lib.getoptocode.str, -24
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	64
    mov       %r12,	%rcx
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rip+cc_lib.getoptocode.opctotable]
    mov       %r10,	%r12
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jz        L6475
    mov       %rax,	%rdi
    jmp       L6473
L6475:
    lea       %rax,	[%rip+cc_tables.jtagnames]
    mov       %r10,	%r12
    mov       %rax,	[%rax + %r10*8]
    lea       %rcx,	[%rbp + cc_lib.getoptocode.str]
    mov       %rdx,	%rax
    call      strcpy
    lea       %rcx,	[%rbp + cc_lib.getoptocode.str]
    lea       %rdx,	[%rip+L9120]
    call      strcat
    xor       %rbx,	%rbx
    mov       %rax,	77
    mov       %rsi,	%rax
    cmp       %rsi,	0
    jl        L6478
L6476:
    lea       %rax,	[%rip+cc_tables.jtagnames]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8]
    mov       %rcx,	%rax
    lea       %rdx,	[%rbp + cc_lib.getoptocode.str]
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L6480
    mov       %ax,	%bx
    lea       %r10,	[%rip+cc_lib.getoptocode.opctotable]
    mov       %r11,	%r12
    mov       [%r10 + %r11*2],	%ax
    mov       %rax,	%rbx
    jmp       L6473
L6480:
    inc       %rbx
    cmp       %rbx,	%rsi
    jle       L6476
L6478:
    call      msys.m$print_startcon
    lea       %rax,	[%rip+cc_tables.jtagnames]
    mov       %r10,	%r12
    mov       %rcx,	[%rax + %r10*8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L9121]
    call      cc_support.serror
    xor       %eax,	%eax
L6473:
#---------------
    add       %rsp,	64
    pop       %rbp
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.getconstvalue
cc_lib.getconstvalue:
#PROC1
#PROC2
#?>>
    .set cc_lib.getconstvalue.id, 32
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    test      %rdi,	%rdi
    jz        L6483
    movsxd    %rax,	dword ptr[%rdi+40]
    cmp       %rax,	1
    jnz       L6483
    mov       %rax,	[%rdi]
    jmp       L6481
L6483:
    lea       %rcx,	[%rip+L9122]
    call      cc_support.serror
    xor       %eax,	%eax
L6481:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lib.nextautotype
cc_lib.nextautotype:
#PROC1
#PROC2
#?>>
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    lea       %rcx,	[%rip+cc_lib.nextautotype.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L9123]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    inc       qword ptr[%rip+cc_lib.autotypeno]
    mov       %rcx,	[%rip+cc_lib.autotypeno]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rax,	[%rip+cc_lib.nextautotype.str]
L6484:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_lib.createconstmode
cc_lib.createconstmode:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rip+cc_decls.ttconst]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L6487
    mov       %rax,	%rbx
    jmp       L6485
L6487:
    lea       %rax,	[%rip+cc_decls.ttconsttype]
    mov       %r10,	%rbx
    mov       %ax,	[%rax + %r10*2]
    test      %ax,	%ax
    jz        L6489
    lea       %rax,	[%rip+cc_decls.ttconsttype]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    jmp       L6485
L6489:
    mov       %rcx,	%rbx
    call      cc_lib.copymode
    mov       %rdi,	%rax
    mov       %ax,	%di
    lea       %r10,	[%rip+cc_decls.ttconsttype]
    mov       %r11,	%rbx
    mov       [%r10 + %r11*2],	%ax
    mov       %al,	1
    lea       %r10,	[%rip+cc_decls.ttconst]
    mov       %r11,	%rdi
    mov       [%r10 + %r11],	%al
    mov       %ax,	%bx
    lea       %r10,	[%rip+cc_decls.ttconsttype]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*2],	%ax
    mov       %rax,	%rdi
L6485:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createrefmode
cc_lib.createrefmode:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rip+cc_decls.ttreftype]
    mov       %r10,	%rbx
    mov       %ax,	[%rax + %r10*2]
    test      %ax,	%ax
    jz        L6492
    lea       %rax,	[%rip+cc_decls.ttreftype]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    lea       %r10,	[%rip+cc_decls.ttshared]
    lea       %r10,	[%r10 + %rax*4]
    inc       dword ptr[%r10]
    lea       %rax,	[%rip+cc_decls.ttreftype]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    jmp       L6490
L6492:
    mov       %rcx,	13
    call      cc_lib.createnewmode
    mov       %rdi,	%rax
    mov       %ax,	%di
    lea       %r10,	[%rip+cc_decls.ttreftype]
    mov       %r11,	%rbx
    mov       [%r10 + %r11*2],	%ax
    mov       %ax,	%bx
    lea       %r10,	[%rip+cc_decls.tttarget]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*2],	%ax
    mov       %al,	1
    lea       %r10,	[%rip+cc_decls.ttisref]
    mov       %r11,	%rdi
    mov       [%r10 + %r11],	%al
    mov       %rax,	%rdi
L6490:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createprocmode
cc_lib.createprocmode:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
#PROC3
#PROC4
    mov       %rcx,	14
    call      cc_lib.createnewmode
    mov       %rdi,	%rax
    mov       %rax,	%rsi
    lea       %r10,	[%rip+cc_decls.ttparams]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*8],	%rax
    mov       %ax,	%bx
    lea       %r10,	[%rip+cc_decls.tttarget]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*2],	%ax
    mov       %rax,	%rdi
L6493:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createarraymode
cc_lib.createarraymode:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
#PROC3
#PROC4
    mov       %rcx,	17
    call      cc_lib.createnewmode
    mov       %rdi,	%rax
    mov       %ax,	%bx
    lea       %r10,	[%rip+cc_decls.tttarget]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*2],	%ax
    mov       %rax,	%rsi
    lea       %r10,	[%rip+cc_decls.ttlength]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*8],	%rax
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8]
    mov       %r10,	%rsi
    imul      %r10,	%rax
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r11,	%rdi
    mov       [%rax + %r11*8],	%r10
    mov       %al,	1
    lea       %r10,	[%rip+cc_decls.ttisblock]
    mov       %r11,	%rdi
    mov       [%r10 + %r11],	%al
    mov       %rax,	%rdi
L6494:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createenummode
cc_lib.createenummode:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	12
    call      cc_lib.createnewmode
    mov       %rdi,	%rax
    mov       %rax,	%rbx
    lea       %r10,	[%rip+cc_decls.ttnamedef]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*8],	%rax
    mov       %rax,	%rdi
L6495:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createstructmode
cc_lib.createstructmode:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rsi
    call      cc_lib.createnewmode
    mov       %rdi,	%rax
    mov       %rax,	%rbx
    lea       %r10,	[%rip+cc_decls.ttnamedef]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*8],	%rax
    mov       %al,	1
    lea       %r10,	[%rip+cc_decls.ttisblock]
    mov       %r11,	%rdi
    mov       [%r10 + %r11],	%al
    mov       %rax,	%rdi
L6496:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.setnameptr
cc_lib.setnameptr:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rcx]
    mov       %r10,	%rcx
    mov       [%rax+72],	%r10
#---------------
    ret       
# End 
# Proc cc_lib.getautofieldname
cc_lib.getautofieldname:
#PROC1
#PROC2
#?>>
    .set cc_lib.getautofieldname.str, -32
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	72
#---------------
#PROC3
#PROC4
    lea       %rcx,	[%rbp + cc_lib.getautofieldname.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L9124]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    inc       qword ptr[%rip+cc_lib.nextafindex]
    mov       %rcx,	[%rip+cc_lib.nextafindex]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + cc_lib.getautofieldname.str]
    call      mlib.pcm_copyheapstring
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    call      cc_lex.addnamestr
L6498:
#---------------
    add       %rsp,	72
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc cc_lib.convertstringc
cc_lib.convertstringc:
#PROC1
#PROC2
#?>>
    .set cc_lib.convertstringc.str, -24
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	64
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
#---------------
#PROC3
#PROC4
    cmp       %r14,	-1
    jnz       L6501
    mov       %rcx,	%r12
    call      strlen
    mov       %r14,	%rax
L6501:
    mov       %rbx,	%r13
    mov       %rsi,	%r14
    cmp       %rsi,	0
    jle       L6504
L6502:
    mov       %rax,	%r12
    inc       %r12
    movzx     %rax,	byte ptr[%rax]
    mov       %rdi,	%rax
    lea       %rax,	[%rdi-7]
    cmp       %rax,	86
    jae       L6507
    lea       %r10,	[%rip+L6506]
    jmp       [%r10 + %rax*8]
    .data
L6506:
    .quad     L6514
    .quad     L6515
    .quad     L6512
    .quad     L6510
    .quad     L6517
    .quad     L6516
    .quad     L6511
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6508
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6509
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6507
    .quad     L6513
    .text
L6508:
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	34
    mov       [%rax],	%r10b
    jmp       L6505
L6509:
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	39
    mov       [%rax],	%r10b
    jmp       L6505
L6510:
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	110
    mov       [%rax],	%r10b
    jmp       L6505
L6511:
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	114
    mov       [%rax],	%r10b
    jmp       L6505
L6512:
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	116
    mov       [%rax],	%r10b
    jmp       L6505
L6513:
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	92
    mov       [%rax],	%r10b
    jmp       L6505
L6514:
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	97
    mov       [%rax],	%r10b
    jmp       L6505
L6515:
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	98
    mov       [%rax],	%r10b
    jmp       L6505
L6516:
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	102
    mov       [%rax],	%r10b
    jmp       L6505
L6517:
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	92
    mov       [%rax],	%r10b
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	118
    mov       [%rax],	%r10b
    jmp       L6505
L6507:
    cmp       %rdi,	32
    jl        L6520
    cmp       %rdi,	127
    jl        L6519
L6520:
    lea       %rcx,	[%rbp + cc_lib.convertstringc.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L9125]
    call      msys.m$print_setfmt
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L9126]
    call      msys.m$print_i64
    call      msys.m$print_end
    mov       %al,	[%rbp + cc_lib.convertstringc.str]
    mov       %r10,	%r13
    inc       %r13
    mov       [%r10],	%al
    mov       %al,	[%rbp + cc_lib.convertstringc.str+1]
    mov       %r10,	%r13
    inc       %r13
    mov       [%r10],	%al
    mov       %al,	[%rbp + cc_lib.convertstringc.str+2]
    mov       %r10,	%r13
    inc       %r13
    mov       [%r10],	%al
    mov       %al,	[%rbp + cc_lib.convertstringc.str+3]
    mov       %r10,	%r13
    inc       %r13
    mov       [%r10],	%al
    jmp       L6518
L6519:
    mov       %rax,	%r13
    inc       %r13
    mov       %r10b,	%dil
    mov       [%rax],	%r10b
L6518:
L6505:
    dec       %rsi
    jnz       L6502
L6504:
    xor       %eax,	%eax
    mov       [%r13],	%al
    mov       %rax,	%r13
    sub       %rax,	%rbx
L6499:
#---------------
    add       %rsp,	64
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.getopcjname
cc_lib.getopcjname:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rip+cc_tables.jtagnames]
    mov       %r10,	%rsi
    mov       %rdi,	[%rax + %r10*8]
    mov       %rcx,	%rdi
    mov       %rdx,	32
    call      strchr
    mov       %rbx,	%rax
    test      %rbx,	%rbx
    jz        L6523
    mov       %rax,	%rbx
    sub       %rax,	%rdi
    lea       %rcx,	[%rip+cc_lib.getopcjname.str]
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      memcpy
    mov       %rax,	%rbx
    sub       %rax,	%rdi
    xor       %r10d,	%r10d
    lea       %r11,	[%rip+cc_lib.getopcjname.str]
    mov       [%r11 + %rax],	%r10b
    lea       %rax,	[%rip+cc_lib.getopcjname.str]
    jmp       L6522
L6523:
    mov       %rax,	%rdi
L6522:
L6521:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.strmode
cc_lib.strmode:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    lea       %r8,	[%rip+cc_lib.strmode.str]
    call      cc_lib.istrmode
    lea       %rax,	[%rip+cc_lib.strmode.str]
L6524:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.strmode2
cc_lib.strmode2:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    lea       %r8,	[%rip+cc_lib.strmode2.str]
    call      cc_lib.istrmode
    lea       %rax,	[%rip+cc_lib.strmode2.str]
L6525:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.istrmode
cc_lib.istrmode:
#PROC1
#PROC2
#?>>
    .set cc_lib.istrmode.expand, 80
    .set cc_lib.istrmode.dest, 88
    .set cc_lib.istrmode.n, -8
    .set cc_lib.istrmode.sxx, -24
    .set cc_lib.istrmode.xx, -32
    .set cc_lib.istrmode.pm, -40
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	72
    mov       %r15,	%rcx
    mov       [%rbp+80],	%rdx
    mov       [%rbp+88],	%r8
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rbp + cc_lib.istrmode.sxx]
    mov       [%rbp + cc_lib.istrmode.xx],	%rax
    cmp       %r15,	21
    jge       L6528
    mov       %rcx,	%r15
    call      cc_lib.typename
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    mov       %rdx,	%rax
    call      strcpy
    jmp       L6526
L6528:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%r15
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %r14,	%rax
    mov       %rax,	%r14
    cmp       %rax,	13
    jz        L6530
    cmp       %rax,	17
    jz        L6531
    cmp       %rax,	12
    jz        L6532
    cmp       %rax,	18
    jz        L6533
    cmp       %rax,	19
    jz        L6533
    test      %rax,	%rax
    jz        L6534
    cmp       %rax,	14
    jz        L6535
    jmp       L6536
L6530:
    lea       %rax,	[%rip+cc_decls.ttconst]
    mov       %r10,	%r15
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L6538
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    lea       %rdx,	[%rip+L9127]
    call      strcpy
    jmp       L6537
L6538:
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    lea       %rdx,	[%rip+L9128]
    call      strcpy
L6537:
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%r15
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %r13,	%rax
    cmp       %r13,	0
    jl        L6540
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%r15
    movsx     %rax,	word ptr[%rax + %r10*2]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    cmp       %r10,	18
    jnz       L6540
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%r15
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rcx,	%rax
    call      cc_lib.typename
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    mov       %rdx,	%rax
    call      strcat
    jmp       L6539
L6540:
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    call      strlen
    mov       %r10,	[%rbp + cc_lib.istrmode.dest]
    lea       %r10,	[%r10 + %rax]
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r11,	%r15
    movsx     %rax,	word ptr[%rax + %r11*2]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    mov       %r8,	%r10
    call      cc_lib.istrmode
L6539:
    jmp       L6529
L6531:
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%r15
    mov       %rax,	[%rax + %r10*8]
    test      %rax,	%rax
    jz        L6542
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L9129]
    call      msys.m$print_setfmt
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%r15
    mov       %rcx,	[%rax + %r10*8]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L6541
L6542:
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    lea       %rdx,	[%rip+L9130]
    call      strcpy
L6541:
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    call      strlen
    mov       %r10,	[%rbp + cc_lib.istrmode.dest]
    lea       %r10,	[%r10 + %rax]
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r11,	%r15
    movsx     %rax,	word ptr[%rax + %r11*2]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    mov       %r8,	%r10
    call      cc_lib.istrmode
    jmp       L6529
L6532:
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    lea       %rdx,	[%rip+L9131]
    call      strcpy
    mov       %rcx,	%r15
    call      cc_lib.typename
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    mov       %rdx,	%rax
    call      strcat
    jmp       L6529
L6533:
    mov       %rax,	[%rbp + cc_lib.istrmode.expand]
    test      %rax,	%rax
    jnz       L6544
    mov       %rcx,	%r15
    call      cc_lib.typename
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    mov       %rdx,	%rax
    call      strcpy
    jmp       L6526
L6544:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%r15
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rcx,	%rax
    call      cc_lib.typename
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    mov       %rdx,	%rax
    call      strcpy
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    lea       %rdx,	[%rip+L9132]
    call      strcat
    lea       %rax,	[%rip+cc_decls.ttnamedef]
    mov       %r10,	%r15
    mov       %rdi,	[%rax + %r10*8]
    xor       %rsi,	%rsi
    mov       %rax,	[%rdi+16]
    mov       %rbx,	%rax
    jmp       L6546
L6545:
    test      %rsi,	%rsi
    jz        L6549
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    lea       %rdx,	[%rip+L9133]
    call      strcat
L6549:
    mov       %rsi,	1
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    call      strlen
    mov       %r10,	[%rbp + cc_lib.istrmode.dest]
    lea       %r10,	[%r10 + %rax]
    movzx     %rax,	word ptr[%rbx+102]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    mov       %r8,	%r10
    call      cc_lib.istrmode
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    lea       %rdx,	[%rip+L9134]
    call      strcat
    mov       %rax,	[%rbx]
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    mov       %rdx,	%rax
    call      strcat
    mov       %rbx,	[%rbx+32]
L6546:
    test      %rbx,	%rbx
    jnz       L6545
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    lea       %rdx,	[%rip+L9135]
    call      strcat
    jmp       L6529
L6534:
    mov       %rcx,	%r15
    call      cc_lib.typename
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    mov       %rdx,	%rax
    call      strcpy
    jmp       L6529
L6535:
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    lea       %rdx,	[%rip+L9136]
    call      strcpy
    lea       %rax,	[%rip+cc_decls.ttparams]
    mov       %r10,	%r15
    mov       %rax,	[%rax + %r10*8]
    mov       [%rbp + cc_lib.istrmode.pm],	%rax
    mov       %rax,	[%rbp + cc_lib.istrmode.pm]
    movsx     %rax,	word ptr[%rax+20]
    mov       [%rbp + cc_lib.istrmode.n],	%rax
    mov       %r12,	1
    mov       %rax,	[%rbp + cc_lib.istrmode.n]
    cmp       %rax,	1
    jl        L6552
L6550:
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    call      strlen
    mov       %r10,	[%rbp + cc_lib.istrmode.dest]
    lea       %r10,	[%r10 + %rax]
    mov       %rax,	[%rbp + cc_lib.istrmode.pm]
    movsxd    %rax,	dword ptr[%rax+16]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    mov       %r8,	%r10
    call      cc_lib.istrmode
    cmp       %r12,	[%rbp + cc_lib.istrmode.n]
    jz        L6554
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    lea       %rdx,	[%rip+L9137]
    call      strcat
L6554:
    mov       %rax,	[%rbp + cc_lib.istrmode.pm]
    mov       %rax,	[%rax+8]
    mov       [%rbp + cc_lib.istrmode.pm],	%rax
    inc       %r12
    cmp       %r12,	[%rbp + cc_lib.istrmode.n]
    jle       L6550
L6552:
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    lea       %rdx,	[%rip+L9138]
    call      strcat
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    call      strlen
    mov       %r10,	[%rbp + cc_lib.istrmode.dest]
    lea       %r10,	[%r10 + %rax]
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r11,	%r15
    movsx     %rax,	word ptr[%rax + %r11*2]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    mov       %r8,	%r10
    call      cc_lib.istrmode
    jmp       L6529
L6536:
    cmp       %r14,	21
    jge       L6556
    mov       %rcx,	%r15
    call      cc_lib.typename
    mov       %rcx,	[%rbp + cc_lib.istrmode.dest]
    mov       %rdx,	%rax
    call      strcpy
    jmp       L6526
L6556:
    call      msys.m$print_startcon
    mov       %rcx,	%r15
    call      cc_lib.typename
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L9139]
    call      cc_support.mcerror
L6555:
L6529:
L6526:
#---------------
    add       %rsp,	72
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.typename
cc_lib.typename:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rdi,	%rax
    mov       %rax,	%rdi
    cmp       %rax,	18
    jz        L6559
    cmp       %rax,	19
    jz        L6559
    cmp       %rax,	17
    jz        L6560
    cmp       %rax,	12
    jz        L6561
    jmp       L6562
L6559:
    cmp       %rdi,	18
    jnz       L6564
    lea       %rax,	[%rip+L9140]
    jmp       L6563
L6564:
    lea       %rax,	[%rip+L9141]
L6563:
    lea       %rcx,	[%rip+cc_lib.typename.str]
    mov       %rdx,	%rax
    call      strcpy
    lea       %rax,	[%rip+cc_decls.ttnamedef]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8]
    test      %rax,	%rax
    jz        L6566
    lea       %rax,	[%rip+cc_decls.ttnamedef]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8]
    mov       %rax,	[%rax]
    lea       %rcx,	[%rip+cc_lib.typename.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rcx,	[%rip+cc_lib.typename.str]
    lea       %rdx,	[%rip+L9142]
    call      strcat
    lea       %rax,	[%rip+cc_decls.ttnamedef]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8]
    movzx     %rax,	word ptr[%rax+96]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.strint
    lea       %rcx,	[%rip+cc_lib.typename.str]
    mov       %rdx,	%rax
    call      strcat
L6566:
    lea       %rax,	[%rip+cc_lib.typename.str]
    jmp       L6557
L6560:
    lea       %rax,	[%rip+L9143]
    jmp       L6557
L6561:
    lea       %rax,	[%rip+cc_decls.ttnamedef]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8]
    test      %rax,	%rax
    jz        L6568
    lea       %rax,	[%rip+cc_decls.ttnamedef]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8]
    mov       %rax,	[%rax]
    jmp       L6557
L6568:
    lea       %rax,	[%rip+L9144]
    jmp       L6557
L6562:
    lea       %rax,	[%rip+cc_decls.ttconst]
    mov       %r10,	%rbx
    mov       %al,	[%rax + %r10]
    test      %al,	%al
    jz        L6570
    lea       %rcx,	[%rip+cc_lib.typename.str]
    lea       %rdx,	[%rip+L9145]
    call      strcpy
    lea       %rax,	[%rip+cc_tables.stdtypenames]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    lea       %rcx,	[%rip+cc_lib.typename.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rax,	[%rip+cc_lib.typename.str]
    jmp       L6557
L6570:
    lea       %rax,	[%rip+cc_tables.stdtypenames]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    jmp       L6557
L6558:
    lea       %rax,	[%rip+L9146]
L6557:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.allocunitrec
cc_lib.allocunitrec:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
#---------------
#PROC3
#PROC4
    inc       qword ptr[%rip+cc_decls.nunits]
    mov       %rax,	[%rip+cc_lib.remainingunits]
    dec       qword ptr[%rip+cc_lib.remainingunits]
    test      %rax,	%rax
    jz        L6573
    mov       %rdi,	[%rip+cc_lib.unitheapptr]
    add       qword ptr[%rip+cc_lib.unitheapptr],	64
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %eax,	[%rax+16]
    mov       [%rdi+44],	%eax
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+20]
    cmp       %rax,	255
    jg        L6575
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %al,	[%rax+20]
    mov       [%rdi+60],	%al
L6575:
    mov       %rax,	%rdi
    jmp       L6571
L6573:
    mov       %rcx,	3200000
    call      mlib.pcm_alloc
    mov       [%rip+cc_lib.unitheapptr],	%rax
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    xor       %edx,	%edx
    mov       %r8,	3200000
    call      memset
    mov       %rax,	49999
    mov       [%rip+cc_lib.remainingunits],	%rax
    add       qword ptr[%rip+cc_lib.unitheapptr],	64
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %eax,	[%rax+16]
    mov       [%rdi+44],	%eax
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+20]
    cmp       %rax,	255
    jg        L6577
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %al,	[%rax+20]
    mov       [%rdi+60],	%al
L6577:
    mov       %rax,	%rdi
L6571:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lib.copymode
cc_lib.copymode:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+cc_decls.ntypes]
    cmp       %rax,	80000
    jl        L6580
    lea       %rcx,	[%rip+L9147]
    call      cc_support.serror
L6580:
    inc       qword ptr[%rip+cc_decls.ntypes]
    lea       %rax,	[%rip+cc_decls.ttnamedef]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    lea       %r10,	[%rip+cc_decls.ttnamedef]
    mov       %r11,	[%rip+cc_decls.ntypes]
    mov       [%r10 + %r11*8],	%rax
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rdi
    mov       %ax,	[%rax + %r10*2]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    mov       %r11,	[%rip+cc_decls.ntypes]
    mov       [%r10 + %r11*2],	%ax
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    lea       %r10,	[%rip+cc_decls.ttlength]
    mov       %r11,	[%rip+cc_decls.ntypes]
    mov       [%r10 + %r11*8],	%rax
    lea       %rax,	[%rip+cc_decls.ttconst]
    mov       %r10,	%rdi
    mov       %al,	[%rax + %r10]
    lea       %r10,	[%rip+cc_decls.ttconst]
    mov       %r11,	[%rip+cc_decls.ntypes]
    mov       [%r10 + %r11],	%al
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r11,	[%rip+cc_decls.ntypes]
    mov       [%r10 + %r11*8],	%rax
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%rdi
    mov       %ax,	[%rax + %r10*2]
    lea       %r10,	[%rip+cc_decls.tttarget]
    mov       %r11,	[%rip+cc_decls.ntypes]
    mov       [%r10 + %r11*2],	%ax
    lea       %rax,	[%rip+cc_decls.ttparams]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    lea       %r10,	[%rip+cc_decls.ttparams]
    mov       %r11,	[%rip+cc_decls.ntypes]
    mov       [%r10 + %r11*8],	%rax
    lea       %rax,	[%rip+cc_decls.ttisref]
    mov       %r10,	%rdi
    mov       %al,	[%rax + %r10]
    lea       %r10,	[%rip+cc_decls.ttisref]
    mov       %r11,	[%rip+cc_decls.ntypes]
    mov       [%r10 + %r11],	%al
    lea       %rax,	[%rip+cc_decls.ttisblock]
    mov       %r10,	%rdi
    mov       %al,	[%rax + %r10]
    lea       %r10,	[%rip+cc_decls.ttisblock]
    mov       %r11,	[%rip+cc_decls.ntypes]
    mov       [%r10 + %r11],	%al
    mov       %rax,	[%rip+cc_decls.ntypes]
L6578:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createnewmode
cc_lib.createnewmode:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+cc_decls.ntypes]
    cmp       %rax,	80000
    jl        L6583
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L9148]
    call      msys.m$print_str_nf
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L9149]
    call      cc_support.serror
L6583:
    inc       qword ptr[%rip+cc_decls.ntypes]
    mov       %ax,	%di
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    mov       %r11,	[%rip+cc_decls.ntypes]
    mov       [%r10 + %r11*2],	%ax
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r11,	[%rip+cc_decls.ntypes]
    mov       [%r10 + %r11*8],	%rax
    mov       %rax,	[%rip+cc_decls.ntypes]
L6581:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lib.addlistunit
cc_lib.addlistunit:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rcx]
    test      %rax,	%rax
    jnz       L6586
    mov       %rax,	%r8
    mov       [%rdx],	%rax
    mov       [%rcx],	%rax
    jmp       L6585
L6586:
    mov       %rax,	[%rdx]
    mov       %r10,	%r8
    mov       [%rax+8],	%r10
L6585:
    xor       %eax,	%eax
    mov       [%r8+8],	%rax
    mov       [%rdx],	%r8
#---------------
    ret       
# End 
# Proc cc_lib.addlistdef
cc_lib.addlistdef:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rcx]
    test      %rax,	%rax
    jnz       L6589
    mov       %rax,	%r8
    mov       [%rdx],	%rax
    mov       [%rcx],	%rax
    jmp       L6588
L6589:
    mov       %rax,	[%rdx]
    mov       %r10,	%r8
    mov       [%rax+32],	%r10
L6588:
    xor       %eax,	%eax
    mov       [%r8+32],	%rax
    mov       [%rdx],	%r8
#---------------
    ret       
# End 
# Proc cc_lib.addlistparam
cc_lib.addlistparam:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rcx]
    test      %rax,	%rax
    jnz       L6592
    mov       %rax,	%r8
    mov       [%rdx],	%rax
    mov       [%rcx],	%rax
    jmp       L6591
L6592:
    mov       %rax,	[%rdx]
    mov       %r10,	%r8
    mov       [%rax+8],	%r10
L6591:
    xor       %eax,	%eax
    mov       [%r8+8],	%rax
    mov       [%rdx],	%r8
#---------------
    ret       
# End 
# Proc cc_lib.checksymbol
cc_lib.checksymbol:
#PROC1
#PROC2
#?>>
    .set cc_lib.checksymbol.str, -256
    push      %rdi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	296
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	%rdi
    jz        L6595
    lea       %rcx,	[%rbp + cc_lib.checksymbol.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L9150]
    call      msys.m$print_setfmt
    lea       %rax,	[%rip+cc_tables.symbolnames]
    mov       %r10,	%rdi
    mov       %rcx,	[%rax + %r10*8-8]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    lea       %r10,	[%rip+cc_tables.symbolnames]
    mov       %r10,	[%r10 + %rax*8-8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	67
    jnz       L6597
    lea       %rcx,	[%rbp + cc_lib.checksymbol.str]
    lea       %rdx,	[%rip+L9151]
    call      strcat
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    call      cc_lib.getstname
    lea       %rcx,	[%rbp + cc_lib.checksymbol.str]
    mov       %rdx,	%rax
    call      strcat
    lea       %rcx,	[%rbp + cc_lib.checksymbol.str]
    lea       %rdx,	[%rip+L9152]
    call      strcat
L6597:
    lea       %rcx,	[%rbp + cc_lib.checksymbol.str]
    call      cc_support.serror
L6595:
#---------------
    add       %rsp,	296
    pop       %rbp
    pop       %rdi
    ret       
# End 
# Proc cc_lib.skipsymbol
cc_lib.skipsymbol:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+21]
    cmp       %rax,	%rdi
    jz        L6600
    mov       %rcx,	%rdi
    call      cc_lib.checksymbol
L6600:
    call      cc_lex.lex
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lib.inittypetables
cc_lib.inittypetables:
#PROC1
#PROC2
#?>>
    .set cc_lib.inittypetables.av_2, -8
    .set cc_lib.inittypetables.av_3, -16
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
    push      %r15
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	56
#---------------
#PROC3
#PROC4
    xor       %rdi,	%rdi
    mov       %rax,	20
    mov       %r15,	%rax
    cmp       %r15,	0
    jl        L6604
L6602:
    mov       %ax,	%di
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*2],	%ax
    lea       %rax,	[%rip+cc_tables.stdtypewidths]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %rsi,	%rax
    mov       %rax,	%rsi
    sar       %rax,	3
    mov       %rbx,	%rax
    mov       %rax,	%rbx
    lea       %r10,	[%rip+cc_decls.ttsize]
    mov       %r11,	%rdi
    mov       [%r10 + %r11*8],	%rax
    mov       %rax,	%rdi
    cmp       %rax,	17
    jz        L6607
    cmp       %rax,	18
    jnz       L6606
L6607:
    mov       %al,	1
    lea       %r10,	[%rip+cc_decls.ttisblock]
    mov       %r11,	%rdi
    mov       [%r10 + %r11],	%al
L6606:
    inc       %rdi
    cmp       %rdi,	%r15
    jle       L6602
L6604:
    mov       %rax,	20
    mov       [%rip+cc_decls.ntypes],	%rax
    mov       %rcx,	1
    call      cc_lib.createrefmode
    mov       [%rip+cc_decls.trefchar],	%rax
    mov       %rcx,	7
    call      cc_lib.createrefmode
    mov       [%rip+cc_decls.trefwchar],	%rax
    mov       %rdi,	1
    mov       %rax,	121
    mov       [%rbp + cc_lib.inittypetables.av_2],	%rax
    mov       %rax,	[%rbp + cc_lib.inittypetables.av_2]
    cmp       %rax,	1
    jl        L6610
L6608:
    lea       %rax,	[%rip+cc_tables.dominantsetuptable]
    mov       %r10,	%rdi
    lea       %r10,	[%r10 + %r10*2]
    lea       %rax,	[%rax + %r10-3]
    movzx     %rax,	byte ptr[%rax]
    mov       %r12,	%rax
    lea       %rax,	[%rip+cc_tables.dominantsetuptable]
    mov       %r10,	%rdi
    lea       %r10,	[%r10 + %r10*2]
    lea       %rax,	[%rax + %r10-3]
    movzx     %rax,	byte ptr[%rax+1]
    mov       %r13,	%rax
    lea       %rax,	[%rip+cc_tables.dominantsetuptable]
    mov       %r10,	%rdi
    lea       %r10,	[%r10 + %r10*2]
    lea       %rax,	[%rax + %r10-3]
    movzx     %rax,	byte ptr[%rax+2]
    mov       %r14,	%rax
    lea       %rax,	[%rip+cc_tables.dominantmode]
    mov       %r10,	%r12
    shl       %r10,	5
    lea       %rax,	[%rax + %r10]
    mov       %r10b,	%r14b
    mov       %r11,	%r13
    mov       [%rax + %r11],	%r10b
    inc       %rdi
    cmp       %rdi,	[%rbp + cc_lib.inittypetables.av_2]
    jle       L6608
L6610:
    mov       %rdi,	1
    mov       %rax,	121
    mov       [%rbp + cc_lib.inittypetables.av_3],	%rax
    mov       %rax,	[%rbp + cc_lib.inittypetables.av_3]
    cmp       %rax,	1
    jl        L6613
L6611:
    lea       %rax,	[%rip+cc_tables.convsetuptable]
    mov       %r10,	%rdi
    lea       %r10,	[%r10 + %r10*2]
    lea       %rax,	[%rax + %r10-3]
    movzx     %rax,	byte ptr[%rax]
    mov       %r12,	%rax
    lea       %rax,	[%rip+cc_tables.convsetuptable]
    mov       %r10,	%rdi
    lea       %r10,	[%r10 + %r10*2]
    lea       %rax,	[%rax + %r10-3]
    movzx     %rax,	byte ptr[%rax+1]
    mov       %r13,	%rax
    lea       %rax,	[%rip+cc_tables.convsetuptable]
    mov       %r10,	%rdi
    lea       %r10,	[%r10 + %r10*2]
    lea       %rax,	[%rax + %r10-3]
    movzx     %rax,	byte ptr[%rax+2]
    mov       %r14,	%rax
    lea       %rax,	[%rip+cc_tables.conversionops]
    mov       %r10,	%r12
    shl       %r10,	4
    lea       %rax,	[%rax + %r10]
    mov       %r10b,	%r14b
    mov       %r11,	%r13
    mov       [%rax + %r11],	%r10b
    inc       %rdi
    cmp       %rdi,	[%rbp + cc_lib.inittypetables.av_3]
    jle       L6611
L6613:
#---------------
    add       %rsp,	56
    pop       %rbp
    pop       %r15
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createdupldef
cc_lib.createdupldef:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
#---------------
#PROC3
#PROC4
    call      cc_lib.newstrec
    mov       %rdi,	%rax
    mov       %rax,	[%r12]
    mov       [%rdi],	%rax
    mov       %al,	[%r12+106]
    mov       [%rdi+106],	%al
    mov       %al,	67
    mov       [%rdi+107],	%al
    mov       [%rdi+8],	%rsi
    mov       [%rdi+109],	%r13b
    lea       %rax,	[%rip+cc_tables.namespaces]
    mov       %r10,	%r13
    mov       %eax,	[%rax + %r10*4]
    mov       [%rdi+98],	%ax
    mov       %rax,	[%r12+40]
    mov       %rbx,	%rax
    test      %rax,	%rax
    jz        L6616
    mov       [%rbx+48],	%rdi
L6616:
    mov       [%rdi+40],	%rbx
    mov       [%rdi+48],	%r12
    mov       [%r12+40],	%rdi
    test      %rsi,	%rsi
    jz        L6618
    mov       %rax,	[%rsi+16]
    test      %rax,	%rax
    jnz       L6620
    mov       %rax,	%rdi
    mov       [%rsi+24],	%rax
    mov       [%rsi+16],	%rax
    jmp       L6619
L6620:
    mov       %rax,	[%rsi+24]
    mov       %r10,	%rdi
    mov       [%rax+32],	%r10
    mov       [%rsi+24],	%rdi
L6619:
L6618:
    mov       %rax,	%rdi
L6614:
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createnewmoduledef
cc_lib.createnewmoduledef:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	3
    call      cc_lib.createdupldef
    mov       %rdi,	%rax
    mov       %rax,	%rdi
L6621:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.createnewproc
cc_lib.createnewproc:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    mov       %r8,	6
    call      cc_lib.createdupldef
    mov       %rdi,	%rax
    mov       %rbx,	%rdi
    jmp       L6624
L6623:
    mov       %rax,	[%rbx+8]
    cmp       %rax,	%rsi
    jnz       L6627
    call      msys.m$print_startcon
    mov       %rcx,	[%rbx]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L9153]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rsi]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L9154]
    call      cc_support.serror
L6627:
L6624:
    mov       %rax,	[%rbx+40]
    mov       %rbx,	%rax
    test      %rax,	%rax
    jnz       L6623
    mov       %rax,	%rdi
L6622:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.resolvename
cc_lib.resolvename:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
    mov       %r13,	%r8
    mov       %r14,	%r9
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%r12+109]
    cmp       %rax,	1
    jle       L6630
    mov       %rax,	%r12
    jmp       L6628
L6630:
    cmp       %r13,	3
    jnz       L6632
    mov       %rcx,	%rsi
    mov       %rdx,	%r12
    call      cc_lib.resolvelabel
    jmp       L6628
L6632:
    test      %r14,	%r14
    jz        L6634
    lea       %rax,	[%rip+cc_decls.blockcounts]
    mov       %r10,	%r14
    movsxd    %rax,	dword ptr[%rax + %r10*4]
    test      %rax,	%rax
    jnz       L6634
    lea       %rax,	[%rip+cc_decls.blockowner]
    mov       %r10,	%r14
    movsxd    %rax,	dword ptr[%rax + %r10*4]
    mov       %r14,	%rax
L6634:
L6635:
    mov       %rax,	%r13
    shl       %rax,	16
    or        %rax,	%r14
    mov       %rdi,	%rax
    mov       %rbx,	%r12
    jmp       L6638
L6637:
    movzx     %rax,	byte ptr[%rsi+109]
    cmp       %rax,	6
    jnz       L6641
    mov       %rax,	[%rbx+8]
    cmp       %rax,	%rsi
    jz        L6641
    mov       %rax,	[%rbx+8]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	6
    jz        L6639
L6641:
    mov       %rax,	[%rbx+8]
    cmp       %rax,	%rsi
    jnz       L6643
    mov       %eax,	[%rbx+96]
    cmp       %rax,	%rdi
    jnz       L6643
    movzx     %rax,	byte ptr[%rbx+122]
    cmp       %rax,	255
    jge       L6645
    lea       %rax,	[%rbx+122]
    inc       byte ptr[%rax]
L6645:
    mov       %rax,	%rbx
    jmp       L6628
L6643:
L6638:
    mov       %rax,	[%rbx+40]
    mov       %rbx,	%rax
    test      %rax,	%rax
    jnz       L6637
L6639:
    test      %r14,	%r14
    jnz       L6647
    movzx     %rax,	byte ptr[%rsi+109]
    cmp       %rax,	6
    jz        L6649
    cmp       %rax,	13
    jz        L6650
    jmp       L6651
L6649:
    mov       %rsi,	[%rip+cc_decls.stmodule]
    jmp       L6635
L6650:
    mov       %rsi,	[%rsi+8]
    test      %rsi,	%rsi
    jnz       L6653
    xor       %eax,	%eax
    jmp       L6628
L6653:
    jmp       L6648
L6651:
    xor       %eax,	%eax
    jmp       L6628
L6648:
    jmp       L6646
L6647:
    lea       %rax,	[%rip+cc_decls.blockowner]
    mov       %r10,	%r14
    movsxd    %rax,	dword ptr[%rax + %r10*4]
    mov       %r14,	%rax
    test      %rax,	%rax
    jnz       L6654
    mov       %rsi,	[%rip+cc_decls.stmodule]
L6654:
L6646:
    jmp       L6635
    xor       %eax,	%eax
L6628:
#---------------
    add       %rsp,	40
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.resolvelabel
cc_lib.resolvelabel:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	16
#---------------
#PROC3
#PROC4
    mov       %rdi,	%rdx
    jmp       L6657
L6656:
    movzx     %rax,	byte ptr[%rcx+109]
    cmp       %rax,	6
    jnz       L6660
    mov       %rax,	[%rdi+8]
    cmp       %rax,	%rcx
    jz        L6660
    mov       %rax,	[%rdi+8]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	6
    jz        L6658
L6660:
    mov       %rax,	[%rdi+8]
    cmp       %rax,	%rcx
    jnz       L6662
    movzx     %rax,	word ptr[%rdi+98]
    cmp       %rax,	3
    jnz       L6662
    mov       %rax,	%rdi
    jmp       L6655
L6662:
L6657:
    mov       %rax,	[%rdi+40]
    mov       %rdi,	%rax
    test      %rax,	%rax
    jnz       L6656
L6658:
    xor       %eax,	%eax
L6655:
#---------------
    add       %rsp,	16
    pop       %rdi
    ret       
# End 
# Proc cc_lib.checkdupl
cc_lib.checkdupl:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
#---------------
#PROC3
#PROC4
    mov       %rbx,	%rdx
    mov       %rax,	%r8
    shl       %rax,	16
    or        %rax,	%r9
    mov       %rdi,	%rax
    jmp       L6665
L6664:
    mov       %rax,	[%rbx+8]
    cmp       %rax,	%rcx
    jnz       L6668
    mov       %eax,	[%rbx+96]
    cmp       %rax,	%rdi
    jnz       L6668
    mov       %rax,	%rbx
    jmp       L6663
L6668:
L6665:
    mov       %rax,	[%rbx+40]
    mov       %rbx,	%rax
    test      %rax,	%rax
    jnz       L6664
    xor       %eax,	%eax
L6663:
#---------------
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.checkdupl_inproc
cc_lib.checkdupl_inproc:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
#---------------
#PROC3
#PROC4
    mov       %rbx,	%rdx
    mov       %rax,	%r8
    shl       %rax,	16
    or        %rax,	%r9
    mov       %rdi,	%rax
    jmp       L6671
L6670:
    mov       %eax,	[%rbx+96]
    cmp       %rax,	%rdi
    jnz       L6674
    mov       %rax,	%rbx
    jmp       L6669
L6674:
L6671:
    mov       %rax,	[%rbx+40]
    mov       %rbx,	%rax
    test      %rax,	%rax
    jz        L6675
    mov       %rax,	[%rbx+8]
    cmp       %rax,	%rcx
    jz        L6670
L6675:
    xor       %eax,	%eax
L6669:
#---------------
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.getalignment
cc_lib.getalignment:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jz        L6678
    cmp       %rax,	18
    jz        L6679
    cmp       %rax,	19
    jz        L6679
    jmp       L6680
L6678:
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rcx,	%rax
    call      cc_lib.getalignment
    jmp       L6676
L6679:
    lea       %rax,	[%rip+cc_decls.ttnamedef]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8]
    movzx     %rax,	byte ptr[%rax+112]
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L6682
    mov       %rax,	16
    jmp       L6676
L6682:
    mov       %rax,	%rdi
    jmp       L6676
L6680:
L6677:
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rbx
    mov       %rdi,	[%rax + %r10*8]
    mov       %rax,	%rdi
    cmp       %rax,	1
    jz        L6684
    cmp       %rax,	2
    jz        L6684
    cmp       %rax,	4
    jz        L6684
    cmp       %rax,	8
    jnz       L6685
L6684:
    mov       %rax,	%rdi
    jmp       L6676
L6685:
L6683:
    call      msys.m$print_startcon
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    mov       %rcx,	%rdi
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L9155]
    call      cc_support.serror
    xor       %eax,	%eax
L6676:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.isexported
cc_lib.isexported:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rcx+109]
    cmp       %rax,	6
    jnz       L6688
    mov       %rax,	[%rcx+72]
    test      %rax,	%rax
    jz        L6690
    movzx     %rax,	byte ptr[%rcx+110]
    cmp       %rax,	3
    jz        L6691
    movzx     %rax,	byte ptr[%rcx+110]
    cmp       %rax,	4
    jnz       L6690
L6691:
    mov       %rax,	1
    jmp       L6686
L6690:
    jmp       L6687
L6688:
    movzx     %rax,	byte ptr[%rcx+110]
    cmp       %rax,	4
    jnz       L6693
    mov       %rax,	1
    jmp       L6686
L6693:
L6687:
    xor       %eax,	%eax
L6686:
#---------------
    ret       
# End 
# Proc cc_lib.isimported
cc_lib.isimported:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rcx+109]
    cmp       %rax,	6
    jnz       L6696
    mov       %rax,	[%rcx+72]
    test      %rax,	%rax
    jnz       L6698
    movzx     %rax,	byte ptr[%rcx+110]
    cmp       %rax,	3
    jz        L6699
    movzx     %rax,	byte ptr[%rcx+110]
    cmp       %rax,	4
    jnz       L6698
L6699:
    mov       %rax,	1
    jmp       L6694
L6698:
    jmp       L6695
L6696:
    movzx     %rax,	byte ptr[%rcx+110]
    cmp       %rax,	3
    jnz       L6701
    mov       %rax,	1
    jmp       L6694
L6701:
L6695:
    xor       %eax,	%eax
L6694:
#---------------
    ret       
# End 
# Proc cc_lib.getstname
cc_lib.getstname:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rdi+106]
    mov       %r10,	[%rdi]
    lea       %rcx,	[%rip+cc_lib.getstname.name]
    mov       %rdx,	%r10
    mov       %r8,	%rax
    call      memcpy
    movzx     %rax,	byte ptr[%rdi+106]
    xor       %r10d,	%r10d
    lea       %r11,	[%rip+cc_lib.getstname.name]
    mov       [%r11 + %rax],	%r10b
    lea       %rax,	[%rip+cc_lib.getstname.name]
L6702:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lib.isrealcc
cc_lib.isrealcc:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rcx
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rcx,	%rax
    mov       %rax,	%rcx
    cmp       %rax,	10
    jl        L6704
    cmp       %rax,	11
    jg        L6704
    mov       %rax,	1
    jmp       L6705
L6704:
    xor       %eax,	%eax
L6705:
L6703:
#---------------
    ret       
# End 
# Proc cc_lib.isintcc
cc_lib.isintcc:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rcx
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rcx,	%rax
    mov       %rax,	%rcx
    cmp       %rax,	1
    jl        L6707
    cmp       %rax,	9
    jg        L6707
    mov       %rax,	1
    jmp       L6708
L6707:
    xor       %eax,	%eax
L6708:
L6706:
#---------------
    ret       
# End 
# Proc cc_lib.writegsfile
cc_lib.writegsfile:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rbx
    lea       %rdx,	[%rip+L9156]
    call      fopen
    mov       %rdi,	%rax
    mov       %rcx,	%rsi
    mov       %rdx,	%rdi
    call      mlib.gs_println
    mov       %rcx,	%rdi
    call      fclose
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_lib.pause
cc_lib.pause:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    call      msys.m$print_startcon
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    call      msys.m$print_end
    call      mwindows.os_getch
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_lib.getpclmode
cc_lib.getpclmode:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	16
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rcx
    movsx     %rax,	word ptr[%rax + %r10*2]
    lea       %r10,	[%rip+cc_tables.stdpcl]
    movzx     %r10,	byte ptr[%r10 + %rax]
    mov       %rdi,	%r10
    cmp       %rdi,	11
    jnz       L6713
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rcx
    mov       %rax,	[%rax + %r10*8]
    cmp       %rax,	8
    jz        L6715
    cmp       %rax,	4
    jz        L6716
    cmp       %rax,	2
    jz        L6717
    cmp       %rax,	1
    jz        L6718
    jmp       L6719
L6715:
    mov       %rdi,	6
    jmp       L6714
L6716:
    mov       %rdi,	5
    jmp       L6714
L6717:
    mov       %rdi,	4
    jmp       L6714
L6718:
    mov       %rdi,	3
L6719:
L6714:
L6713:
    mov       %rax,	%rdi
L6711:
#---------------
    add       %rsp,	16
    pop       %rdi
    ret       
# End 
# Proc cc_lib.addtolog
cc_lib.addtolog:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rsi
    lea       %rdx,	[%rip+L9157]
    call      fopen
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L6722
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L9158]
    call      msys.m$print_str_nf
    mov       %rcx,	%rsi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L6720
L6722:
L6723:
    mov       %rcx,	%rdi
    call      fgetc
    movsxd    %r10,	%eax
    mov       %rbx,	%r10
    cmp       %rbx,	-1
    jz        L6724
L6726:
    mov       %rcx,	%rbx
    mov       %rdx,	%r12
    call      fputc
    jmp       L6723
L6724:
    mov       %rcx,	%rdi
    call      fclose
L6720:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.stopcompiler
cc_support.stopcompiler:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
#PROC3
#PROC4
    mov       %al,	[%rip+cc_cli.fwriteerrors]
    test      %al,	%al
    jz        L6729
    lea       %rcx,	[%rip+L9159]
    lea       %rdx,	[%rip+L9160]
    call      fopen
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    call      msys.m$print_startfile
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    mov       %rcx,	%rsi
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%rdi
    call      fclose
L6729:
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	1
    call      exit
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.mcerror
cc_support.mcerror:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L9161]
    call      msys.m$print_str_nf
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	40
    call      exit
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_support.serror
cc_support.serror:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    call      cc_support.serror_gen
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_support.serror_gen
cc_support.serror_gen:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+cc_decls.currproc]
    test      %rax,	%rax
    jz        L6734
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L9162]
    call      msys.m$print_str_nf
    mov       %rax,	[%rip+cc_decls.currproc]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L9163]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L6733
L6734:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L9164]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L6733:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L9165]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %eax,	[%rax+16]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    lea       %rcx,	[%rip+L9166]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+20]
    lea       %r10,	[%rip+cc_decls.sourcefilepaths]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+20]
    lea       %r10,	[%rip+cc_decls.sourcefilenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      cc_support.showmacrolineno
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L9167]
    call      msys.m$print_str_nf
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L9168]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %eax,	[%rax+16]
    lea       %r10,	[%rip+cc_decls.lx]
    movzx     %r10,	byte ptr[%r10+20]
    lea       %r11,	[%rip+cc_decls.sourcefilepaths]
    mov       %r11,	[%r11 + %r10*8]
    mov       %rcx,	%r11
    mov       %rdx,	%rax
    call      cc_support.stopcompiler
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_support.serror_ss
cc_support.serror_ss:
#PROC1
#PROC2
#?>>
    .set cc_support.serror_ss.str, -256
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	296
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
#PROC3
#PROC4
    lea       %rcx,	[%rbp + cc_support.serror_ss.str]
    call      msys.m$print_startstr
    mov       %rcx,	%rdi
    call      msys.m$print_setfmt
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    mov       %rcx,	%rsi
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + cc_support.serror_ss.str]
    call      cc_support.serror_gen
#---------------
    add       %rsp,	296
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.serror_s
cc_support.serror_s:
#PROC1
#PROC2
#?>>
    .set cc_support.serror_s.str, -256
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	288
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    lea       %rcx,	[%rbp + cc_support.serror_s.str]
    call      msys.m$print_startstr
    mov       %rcx,	%rdi
    call      msys.m$print_setfmt
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + cc_support.serror_s.str]
    call      cc_support.serror_gen
#---------------
    add       %rsp,	288
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.terror_gen
cc_support.terror_gen:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+cc_decls.currproc]
    test      %rax,	%rax
    jz        L6739
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L9169]
    call      msys.m$print_str_nf
    mov       %rax,	[%rip+cc_decls.currproc]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L6739:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L9170]
    call      msys.m$print_str_nf
    mov       %rcx,	%rdi
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L9171]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %eax,	[%rax+16]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    lea       %rax,	[%rip+cc_decls.lx]
    movzx     %rax,	byte ptr[%rax+20]
    lea       %r10,	[%rip+cc_decls.sourcefilepaths]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      cc_support.showmacrolineno
    lea       %rax,	[%rip+cc_decls.lx]
    mov       %eax,	[%rax+16]
    lea       %r10,	[%rip+cc_decls.lx]
    movzx     %r10,	byte ptr[%r10+20]
    lea       %r11,	[%rip+cc_decls.sourcefilepaths]
    mov       %r11,	[%r11 + %r10*8]
    mov       %rcx,	%r11
    mov       %rdx,	%rax
    call      cc_support.stopcompiler
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_support.terror
cc_support.terror:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    call      cc_support.terror_gen
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_support.terror_s
cc_support.terror_s:
#PROC1
#PROC2
#?>>
    .set cc_support.terror_s.str, -256
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	288
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    lea       %rcx,	[%rbp + cc_support.terror_s.str]
    call      msys.m$print_startstr
    mov       %rcx,	%rdi
    call      msys.m$print_setfmt
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + cc_support.terror_s.str]
    call      cc_support.terror_gen
#---------------
    add       %rsp,	288
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.terror_ss
cc_support.terror_ss:
#PROC1
#PROC2
#?>>
    .set cc_support.terror_ss.str, -256
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	296
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
#PROC3
#PROC4
    lea       %rcx,	[%rbp + cc_support.terror_ss.str]
    call      msys.m$print_startstr
    mov       %rcx,	%rdi
    call      msys.m$print_setfmt
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    mov       %rcx,	%rsi
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + cc_support.terror_ss.str]
    call      cc_support.terror_gen
#---------------
    add       %rsp,	296
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.gerror_gen
cc_support.gerror_gen:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rsi,	%rcx
    mov       %r12,	%rdx
#---------------
#PROC3
#PROC4
    test      %r12,	%r12
    jz        L6745
    mov       %eax,	[%r12+44]
    mov       %rdi,	%rax
    movzx     %rax,	byte ptr[%r12+60]
    mov       %rbx,	%rax
    jmp       L6744
L6745:
    mov       %rdi,	[%rip+cc_decls.clineno]
    mov       %rbx,	[%rip+cc_decls.cfileno]
L6744:
    mov       %rax,	[%rip+cc_decls.currproc]
    test      %rax,	%rax
    jz        L6747
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L9172]
    call      msys.m$print_str_nf
    mov       %rax,	[%rip+cc_decls.currproc]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L9173]
    call      msys.m$print_str_nf
    call      msys.m$print_end
L6747:
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L9174]
    call      msys.m$print_str_nf
    mov       %rax,	%rdi
    and       %rax,	16777215
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    lea       %rcx,	[%rip+L9175]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.sourcefilepaths]
    mov       %r10,	%rbx
    mov       %rcx,	[%rax + %r10*8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L9176]
    call      msys.m$print_str_nf
    mov       %rcx,	%rsi
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L9177]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rax,	[%rip+cc_decls.sourcefilepaths]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8]
    mov       %rcx,	%rax
    mov       %rdx,	%rdi
    call      cc_support.stopcompiler
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.gerror
cc_support.gerror:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    call      cc_support.gerror_gen
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.gerror_s
cc_support.gerror_s:
#PROC1
#PROC2
#?>>
    .set cc_support.gerror_s.str, -256
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	296
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
#---------------
#PROC3
#PROC4
    lea       %rcx,	[%rbp + cc_support.gerror_s.str]
    call      msys.m$print_startstr
    mov       %rcx,	%rdi
    call      msys.m$print_setfmt
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       %rcx,	[%rbp + cc_support.gerror_s.str]
    mov       %rdx,	%rsi
    call      cc_support.gerror_gen
#---------------
    add       %rsp,	296
    pop       %rbp
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.nextpoweroftwo
cc_support.nextpoweroftwo:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	16
#---------------
#PROC3
#PROC4
    test      %rcx,	%rcx
    jnz       L6752
    xor       %eax,	%eax
    jmp       L6750
L6752:
    mov       %rdi,	1
    jmp       L6754
L6753:
    shl       %rdi,	1
L6754:
    cmp       %rdi,	%rcx
    jl        L6753
    mov       %rax,	%rdi
L6750:
#---------------
    add       %rsp,	16
    pop       %rdi
    ret       
# End 
# Proc cc_support.loaderror
cc_support.loaderror:
#PROC1
#PROC2
#?>>
    .set cc_support.loaderror.str, -512
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	544
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    lea       %rcx,	[%rbp + cc_support.loaderror.str]
    call      msys.m$print_startstr
    mov       %rcx,	%rdi
    call      msys.m$print_setfmt
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L9178]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rbp + cc_support.loaderror.str]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L9179]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	45
    call      exit
#---------------
    add       %rsp,	544
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.loadsourcefile
cc_support.loadsourcefile:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+cc_decls.nsourcefiles]
    cmp       %rax,	200
    jle       L6759
    lea       %rcx,	[%rip+L9180]
    lea       %rdx,	[%rip+L9181]
    call      cc_support.loaderror
L6759:
    inc       qword ptr[%rip+cc_decls.nsourcefiles]
    mov       %rcx,	%rbx
    call      mlib.pcm_copyheapstring
    lea       %r10,	[%rip+cc_decls.sourcefilepaths]
    mov       %r11,	[%rip+cc_decls.nsourcefiles]
    mov       [%r10 + %r11*8],	%rax
    mov       %rcx,	%rsi
    call      mlib.pcm_copyheapstring
    lea       %r10,	[%rip+cc_decls.sourcefilenames]
    mov       %r11,	[%rip+cc_decls.nsourcefiles]
    mov       [%r10 + %r11*8],	%rax
    mov       %rcx,	%rbx
    call      mlib.readfile
    mov       %rdi,	%rax
    test      %rdi,	%rdi
    jnz       L6761
    lea       %rcx,	[%rip+L9182]
    mov       %rdx,	%rbx
    call      cc_support.loaderror
L6761:
    mov       %rax,	%rdi
    lea       %r10,	[%rip+cc_decls.sourcefiletext]
    mov       %r11,	[%rip+cc_decls.nsourcefiles]
    mov       [%r10 + %r11*8],	%rax
    mov       %eax,	[%rip+mlib.rfsize]
    lea       %r10,	[%rip+cc_decls.sourcefilesizes]
    mov       %r11,	[%rip+cc_decls.nsourcefiles]
    mov       [%r10 + %r11*4],	%eax
    xor       %eax,	%eax
    mov       %r10,	[%rip+mlib.rfsize]
    mov       [%rdi + %r10],	%al
    mov       %rax,	[%rip+cc_decls.nsourcefiles]
L6757:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.splicelines
cc_support.splicelines:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rsi
    call      strlen
    inc       %rax
    mov       %rcx,	%rax
    call      mlib.pcm_alloc
    mov       %rbx,	%rax
    mov       %rdi,	%rax
    jmp       L6764
L6763:
    movzx     %rax,	byte ptr[%rsi]
    cmp       %rax,	92
    jnz       L6767
    movzx     %rax,	byte ptr[%rsi+1]
    cmp       %rax,	10
    jnz       L6767
    add       %rsi,	2
    jmp       L6766
L6767:
    movzx     %rax,	byte ptr[%rsi]
    cmp       %rax,	92
    jnz       L6768
    movzx     %rax,	byte ptr[%rsi+1]
    cmp       %rax,	13
    jnz       L6768
    movzx     %rax,	byte ptr[%rsi+2]
    cmp       %rax,	10
    jnz       L6768
    add       %rsi,	3
    jmp       L6766
L6768:
    mov       %rax,	%rsi
    inc       %rsi
    mov       %al,	[%rax]
    mov       %r10,	%rdi
    inc       %rdi
    mov       [%r10],	%al
L6766:
    xor       %eax,	%eax
    mov       [%rdi],	%al
L6764:
    mov       %al,	[%rsi]
    test      %al,	%al
    jnz       L6763
    mov       %rax,	%rbx
L6762:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.loadbuiltin
cc_support.loadbuiltin:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+cc_decls.nsourcefiles]
    cmp       %rax,	200
    jle       L6771
    lea       %rcx,	[%rip+L9183]
    lea       %rdx,	[%rip+L9184]
    call      cc_support.loaderror
L6771:
    inc       qword ptr[%rip+cc_decls.nsourcefiles]
    lea       %rax,	[%rip+L9185]
    lea       %r10,	[%rip+cc_decls.sourcefilepaths]
    mov       %r11,	[%rip+cc_decls.nsourcefiles]
    mov       [%r10 + %r11*8],	%rax
    mov       %rcx,	%rdi
    call      mlib.pcm_copyheapstring
    lea       %r10,	[%rip+cc_decls.sourcefilenames]
    mov       %r11,	[%rip+cc_decls.nsourcefiles]
    mov       [%r10 + %r11*8],	%rax
    mov       %rcx,	%rbx
    call      mlib.pcm_copyheapstring
    lea       %r10,	[%rip+cc_decls.sourcefiletext]
    mov       %r11,	[%rip+cc_decls.nsourcefiles]
    mov       [%r10 + %r11*8],	%rax
    mov       %rcx,	%rbx
    call      strlen
    lea       %r10,	[%rip+cc_decls.sourcefilesizes]
    mov       %r11,	[%rip+cc_decls.nsourcefiles]
    mov       [%r10 + %r11*4],	%eax
    mov       %rax,	[%rip+cc_decls.nsourcefiles]
L6769:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.gs_copytostr
cc_support.gs_copytostr:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
#---------------
#PROC3
#PROC4
    mov       %eax,	[%rdi+8]
    test      %eax,	%eax
    jz        L6774
    movsxd    %rax,	dword ptr[%rdi+8]
    mov       %r10,	[%rdi]
    mov       %rcx,	%rbx
    mov       %rdx,	%r10
    mov       %r8,	%rax
    call      memcpy
    movsxd    %rax,	dword ptr[%rdi+8]
    xor       %r10d,	%r10d
    mov       [%rbx + %rax],	%r10b
    jmp       L6773
L6774:
    xor       %eax,	%eax
    mov       [%rbx],	%al
L6773:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.gs_additem
cc_support.gs_additem:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    sub       %rsp,	48
    mov       %r12,	%rcx
    mov       %r13,	%rdx
#---------------
#PROC3
#PROC4
    mov       %rdi,	[%r12]
    mov       %eax,	[%r12+8]
    test      %eax,	%eax
    jz        L6777
    movsxd    %rax,	dword ptr[%r12+8]
    lea       %r10,	[%rdi + %rax]
    sub       %r10,	1
    movzx     %r10,	byte ptr[%r10]
    mov       %rbx,	%r10
    movzx     %rax,	byte ptr[%r13]
    mov       %rsi,	%rax
    mov       %rcx,	%rbx
    call      cc_support.isalphanum
    test      %rax,	%rax
    jz        L6779
    mov       %rcx,	%rsi
    call      cc_support.isalphanum
    test      %rax,	%rax
    jz        L6779
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9186]
    mov       %r8,	-1
    call      mlib.strbuffer_add
L6779:
L6777:
    mov       %rcx,	%r12
    mov       %rdx,	%r13
    mov       %r8,	-1
    call      mlib.strbuffer_add
#---------------
    add       %rsp,	48
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_support.isalphanum
cc_support.isalphanum:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    cmp       %rcx,	65
    jl        L6784
    cmp       %rcx,	90
    jle       L6783
L6784:
    cmp       %rcx,	97
    jl        L6785
    cmp       %rcx,	122
    jle       L6783
L6785:
    cmp       %rcx,	48
    jl        L6782
    cmp       %rcx,	57
    jg        L6782
L6783:
    mov       %rax,	1
    jmp       L6780
L6782:
    xor       %eax,	%eax
L6780:
#---------------
    ret       
# End 
# Proc cc_support.showmacrolineno
cc_support.showmacrolineno:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rip+cc_decls.slineno]
    test      %rax,	%rax
    jz        L6788
L6788:
#---------------
    ret       
# End 
# Proc cc_headers.findheader
cc_headers.findheader:
#PROC1
#PROC2
#?>>
    .set cc_headers.findheader.newname, -256
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	296
    mov       %r13,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%r13
    mov       %rdx,	92
    call      strchr
    test      %rax,	%rax
    jz        L6791
    mov       %rbx,	%r13
    lea       %rax,	[%rbp + cc_headers.findheader.newname]
    mov       %rsi,	%rax
    jmp       L6793
L6792:
    movzx     %rax,	byte ptr[%rbx]
    cmp       %rax,	92
    jnz       L6796
    mov       %rax,	%rsi
    inc       %rsi
    mov       %r10b,	47
    mov       [%rax],	%r10b
    jmp       L6795
L6796:
    mov       %al,	[%rbx]
    mov       %r10,	%rsi
    inc       %rsi
    mov       [%r10],	%al
L6795:
    inc       %rbx
L6793:
    mov       %al,	[%rbx]
    test      %al,	%al
    jnz       L6792
    xor       %eax,	%eax
    mov       [%rsi],	%al
    lea       %rax,	[%rbp + cc_headers.findheader.newname]
    mov       %r13,	%rax
L6791:
    mov       %rdi,	1
    mov       %r12,	40
    cmp       %r12,	1
    jl        L6799
L6797:
    lea       %rax,	[%rip+cc_headers.stdhdrnames]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rcx,	%r13
    mov       %rdx,	%rax
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L6801
    lea       %rax,	[%rip+cc_headers.stdhdrtext]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rax,	[%rax]
    jmp       L6789
L6801:
    inc       %rdi
    cmp       %rdi,	%r12
    jle       L6797
L6799:
    xor       %eax,	%eax
L6789:
#---------------
    add       %rsp,	296
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_headers.writeheaders
cc_headers.writeheaders:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    mov       %rsi,	1
    mov       %r12,	40
    cmp       %r12,	1
    jl        L6805
L6803:
    lea       %rax,	[%rip+cc_headers.stdhdrnames]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L9187]
    call      mlib.changeext
    mov       %rbx,	%rax
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L9188]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_headers.stdhdrnames]
    mov       %r10,	%rsi
    mov       %rcx,	[%rax + %r10*8-8]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L9189]
    call      msys.m$print_str_nf
    mov       %rcx,	%rbx
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%rbx
    lea       %rdx,	[%rip+L9190]
    call      fopen
    mov       %rdi,	%rax
    lea       %rax,	[%rip+cc_headers.stdhdrtext]
    mov       %r10,	%rsi
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rax,	[%rax]
    mov       %rcx,	%rax
    call      strlen
    lea       %r10,	[%rip+cc_headers.stdhdrtext]
    mov       %r11,	%rsi
    mov       %r10,	[%r10 + %r11*8-8]
    mov       %r10,	[%r10]
    mov       %rcx,	%r10
    mov       %rdx,	1
    mov       %r8,	%rax
    mov       %r9,	%rdi
    call      fwrite
    mov       %rcx,	%rdi
    call      fclose
    inc       %rsi
    cmp       %rsi,	%r12
    jle       L6803
L6805:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_headers.isheaderfile
cc_headers.isheaderfile:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rsi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rbx,	1
    mov       %rdi,	40
    cmp       %rdi,	1
    jl        L6809
L6807:
    lea       %rax,	[%rip+cc_headers.stdhdrnames]
    mov       %r10,	%rbx
    mov       %rax,	[%rax + %r10*8-8]
    mov       %rcx,	%rax
    mov       %rdx,	%rsi
    call      mlib.eqstring
    test      %rax,	%rax
    jz        L6811
    mov       %rax,	1
    jmp       L6806
L6811:
    inc       %rbx
    cmp       %rbx,	%rdi
    jle       L6807
L6809:
    xor       %eax,	%eax
L6806:
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_show.printcode
cc_show.printcode:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
#?]]
    sub       %rsp,	48
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rbx
    call      msys.m$print_startfile
    mov       %rcx,	%rsi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rax,	[%rip+cc_decls.stmodule]
    mov       %rdi,	[%rax+16]
    jmp       L6814
L6813:
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	6
    jnz       L6818
L6817:
    mov       %rax,	[%rdi+72]
    test      %rax,	%rax
    jz        L6820
    mov       %rcx,	%rbx
    call      msys.m$print_startfile
    mov       %rcx,	[%rdi]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L9191]
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rdi+110]
    lea       %r10,	[%rip+cc_tables.scopenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rax,	[%rdi+72]
    mov       %rcx,	%rbx
    mov       %rdx,	%rax
    xor       %r8d,	%r8d
    lea       %r9,	[%rip+L9192]
    call      cc_show.printunit
    mov       %rcx,	%rbx
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
L6820:
L6818:
L6816:
    mov       %rdi,	[%rdi+32]
L6814:
    test      %rdi,	%rdi
    jnz       L6813
#---------------
    add       %rsp,	48
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_show.printunit
cc_show.printunit:
#PROC1
#PROC2
#?>>
    .set cc_show.printunit.level, 80
    .set cc_show.printunit.prefix, 88
    .set cc_show.printunit.idname, -8
    .set cc_show.printunit.pc, -16
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	48
    mov       %r13,	%rcx
    mov       %r14,	%rdx
    mov       [%rbp+80],	%r8
    mov       [%rbp+88],	%r9
#---------------
#PROC3
#PROC4
    test      %r14,	%r14
    jnz       L6823
    jmp       L6821
L6823:
    movsxd    %rax,	dword ptr[%r14+40]
    cmp       %rax,	77
    jl        L6825
    call      msys.m$print_startcon
    lea       %rcx,	[%rip+L9193]
    call      msys.m$print_str_nf
    movsxd    %rax,	dword ptr[%r14+40]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	30
    call      exit
L6825:
    mov       %eax,	[%r14+44]
    test      %eax,	%eax
    jz        L6827
    mov       %eax,	[%r14+44]
    mov       [%rip+cc_show.currlineno],	%rax
    movzx     %rax,	byte ptr[%r14+60]
    mov       [%rip+cc_show.currfileno],	%rax
L6827:
    mov       %r12,	1
    mov       %rax,	[%rbp + cc_show.printunit.level]
    cmp       %rax,	0
    jge       L6829
    mov       %r12,	-1
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9194]
    call      msys.m$print_str_nf
    call      msys.m$print_end
L6829:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    mov       %rax,	[%rbp + cc_show.printunit.level]
    cmp       %rax,	0
    jge       L9195
    neg       %rax
L9195:
    mov       %rcx,	%rax
    mov       %rdx,	[%rbp + cc_show.printunit.prefix]
    mov       %r8,	%r14
    call      cc_show.getprefix
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
    movsxd    %rax,	dword ptr[%r14+40]
    lea       %r10,	[%rip+cc_tables.jtagnames]
    mov       %r10,	[%r10 + %rax*8]
    mov       [%rbp + cc_show.printunit.idname],	%r10
    mov       %rax,	[%rbp + cc_show.printunit.idname]
    movzx     %rax,	byte ptr[%rax]
    cmp       %rax,	106
    jnz       L6831
    inc       qword ptr[%rbp + cc_show.printunit.idname]
L6831:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    mov       %rcx,	[%rbp + cc_show.printunit.idname]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L9196]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    movsxd    %rax,	dword ptr[%r14+40]
    cmp       %rax,	3
    jz        L6833
    cmp       %rax,	5
    jz        L6833
    cmp       %rax,	7
    jz        L6834
    cmp       %rax,	8
    jz        L6834
    cmp       %rax,	16
    jz        L6834
    cmp       %rax,	16
    jz        L6835
    cmp       %rax,	17
    jz        L6836
    cmp       %rax,	18
    jz        L6837
    cmp       %rax,	1
    jz        L6838
    cmp       %rax,	56
    jz        L6839
    cmp       %rax,	57
    jz        L6840
    cmp       %rax,	53
    jz        L6841
    cmp       %rax,	54
    jz        L6841
    cmp       %rax,	22
    jz        L6842
    cmp       %rax,	30
    jz        L6843
    cmp       %rax,	52
    jz        L6844
    cmp       %rax,	49
    jz        L6845
    jmp       L6846
L6833:
    mov       %rdi,	[%r14]
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    mov       %rcx,	[%rdi]
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rdi+109]
    lea       %r10,	[%rip+cc_tables.namenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       %rax,	[%rdi+72]
    test      %rax,	%rax
    jz        L6848
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9197]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       %rax,	[%rdi+72]
    movsxd    %rax,	dword ptr[%rax+40]
    lea       %r10,	[%rip+cc_tables.jtagnames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L9198]
    call      msys.m$print_str_nf
    call      msys.m$print_end
L6848:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9199]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       %rcx,	%rdi
    call      cc_show.getdottedname
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       %rax,	[%r14+32]
    test      %rax,	%rax
    jz        L6850
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9200]
    call      msys.m$print_str_nf
    mov       %rcx,	[%r14+32]
    call      msys.m$print_ptr_nf
    call      msys.m$print_end
L6850:
    jmp       L6832
L6834:
    mov       %rdi,	[%r14]
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    mov       %rcx,	[%rdi]
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rdi+109]
    lea       %r10,	[%rip+cc_tables.namenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rax,	[%rbp + cc_show.printunit.level]
    add       %rax,	%r12
    mov       %r10,	[%rdi+72]
    mov       %rcx,	%r13
    mov       %rdx,	%r10
    mov       %r8,	%rax
    lea       %r9,	[%rip+L9201]
    call      cc_show.printunit
    jmp       L6821
L6835:
    mov       %rdi,	[%r14]
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    mov       %rcx,	[%rdi]
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rdi+109]
    lea       %r10,	[%rip+cc_tables.namenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L6832
L6836:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    mov       %rax,	[%r14]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L6832
L6837:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9202]
    call      msys.m$print_str_nf
    mov       %rcx,	[%r14]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L6832
L6838:
    movsxd    %rax,	dword ptr[%r14+52]
    mov       %rbx,	%rax
    cmp       %rbx,	[%rip+cc_decls.trefchar]
    jnz       L6852
    mov       %al,	[%r14+61]
    test      %al,	%al
    jz        L6855
L6854:
#cc_show.printunit.dostring:
L6856:
    movsxd    %rax,	dword ptr[%r14+48]
    cmp       %rax,	256
    jle       L6858
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9203]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L9204]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L9205]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    movsxd    %rax,	dword ptr[%r14+48]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L6857
L6858:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9206]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       %rcx,	[%r14]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L9207]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    movsxd    %rax,	dword ptr[%r14+48]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
L6857:
    jmp       L6851
L6852:
    cmp       %rbx,	[%rip+cc_decls.trefwchar]
    jnz       L6859
    mov       %al,	[%r14+62]
    test      %al,	%al
    jz        L6855
L6861:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9208]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L9209]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L9210]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    movsxd    %rax,	dword ptr[%r14+48]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L6851
L6859:
    cmp       %rbx,	1
    jl        L6862
    cmp       %rbx,	4
    jg        L6862
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    mov       %rcx,	[%r14]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L6851
L6862:
    cmp       %rbx,	6
    jl        L6863
    cmp       %rbx,	9
    jg        L6863
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    mov       %rax,	[%r14]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.m$print_u64
    call      msys.m$print_end
    jmp       L6851
L6863:
    mov       %rcx,	%rbx
    call      cc_lib.isrealcc
    test      %rax,	%rax
    jz        L6864
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    movq      %XMM4,	[%r14]
    movq      %XMM0,	%XMM4
    xor       %edx,	%edx
    call      msys.m$print_r64
    call      msys.m$print_end
    jmp       L6851
L6864:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	13
    jnz       L6865
    mov       %al,	[%r14+61]
    test      %al,	%al
    jnz       L6856
L6867:
#cc_show.printunit.doref:
L6855:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    mov       %rcx,	[%r14]
    call      msys.m$print_ptr_nf
    call      msys.m$print_end
    jmp       L6851
L6865:
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rbx
    movsx     %rax,	word ptr[%rax + %r10*2]
    cmp       %rax,	17
    jnz       L6868
    mov       %al,	[%r14+61]
    test      %al,	%al
    jnz       L6856
L6870:
    lea       %rcx,	[%rip+L9211]
    call      cc_support.serror
    jmp       L6851
L6868:
    call      msys.m$print_startcon
    mov       %rcx,	%rbx
    call      cc_lib.typename
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L9212]
    call      cc_support.serror
L6851:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9213]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       %al,	[%r14+61]
    test      %al,	%al
    jz        L6872
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9214]
    call      msys.m$print_str_nf
    call      msys.m$print_end
L6872:
    mov       %al,	[%r14+62]
    test      %al,	%al
    jz        L6874
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9215]
    call      msys.m$print_str_nf
    call      msys.m$print_end
L6874:
    jmp       L6832
L6839:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    movsxd    %rax,	dword ptr[%r14+48]
    lea       %r10,	[%rip+cc_tables.convnames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9216]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    mov       %rax,	[%r14+16]
    movsxd    %rax,	dword ptr[%rax+52]
    mov       %rcx,	%rax
    call      cc_lib.typename
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9217]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    movsx     %rax,	word ptr[%r14+58]
    mov       %rcx,	%rax
    call      cc_lib.typename
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L6832
L6840:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9218]
    call      msys.m$print_str_nf
    movsxd    %rax,	dword ptr[%r14+48]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L6832
L6841:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9219]
    call      msys.m$print_str_nf
    movsxd    %rax,	dword ptr[%r14]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L6832
L6842:
    mov       %rax,	[%r14]
    mov       [%rbp + cc_show.printunit.pc],	%rax
    xor       %rsi,	%rsi
    jmp       L6876
L6875:
    inc       %rsi
    mov       %rax,	[%rbp + cc_show.printunit.pc]
    mov       %rax,	[%rax]
    mov       [%rbp + cc_show.printunit.pc],	%rax
L6876:
    mov       %rax,	[%rbp + cc_show.printunit.pc]
    test      %rax,	%rax
    jnz       L6875
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    mov       %rcx,	[%r14]
    call      msys.m$print_ptr_nf
    mov       %rcx,	%rsi
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L6832
L6843:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9220]
    call      msys.m$print_str_nf
    movsxd    %rax,	dword ptr[%r14+48]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L6832
L6844:
    jmp       L6832
L6845:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9221]
    call      msys.m$print_str_nf
    movsxd    %rax,	dword ptr[%r14]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
L6846:
L6832:
    mov       %ax,	[%r14+56]
    test      %ax,	%ax
    jz        L6879
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9222]
    call      msys.m$print_str_nf
    movsx     %rax,	word ptr[%r14+56]
    mov       %rcx,	%rax
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
L6879:
    mov       %eax,	[%r14+48]
    test      %eax,	%eax
    jz        L6881
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9223]
    call      msys.m$print_str_nf
    movsxd    %rax,	dword ptr[%r14+48]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
L6881:
    mov       %rcx,	%r13
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rax,	[%rbp + cc_show.printunit.level]
    add       %rax,	%r12
    mov       %r10,	[%r14+16]
    mov       %rcx,	%r13
    mov       %rdx,	%r10
    mov       %r8,	%rax
    lea       %r9,	[%rip+L9224]
    call      cc_show.printunitlist
    mov       %rax,	[%rbp + cc_show.printunit.level]
    add       %rax,	%r12
    mov       %r10,	[%r14+24]
    mov       %rcx,	%r13
    mov       %rdx,	%r10
    mov       %r8,	%rax
    lea       %r9,	[%rip+L9225]
    call      cc_show.printunitlist
    movsxd    %rax,	dword ptr[%r14+40]
    cmp       %rax,	6
    jz        L6883
    mov       %rax,	[%rbp + cc_show.printunit.level]
    add       %rax,	%r12
    mov       %r10,	[%r14+32]
    mov       %rcx,	%r13
    mov       %rdx,	%r10
    mov       %r8,	%rax
    lea       %r9,	[%rip+L9226]
    call      cc_show.printunitlist
L6883:
L6821:
#---------------
    add       %rsp,	48
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_show.printunitlist
cc_show.printunitlist:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rdi,	%rcx
    mov       %rbx,	%rdx
    mov       %rsi,	%r8
    mov       %r12,	%r9
#---------------
#PROC3
#PROC4
    test      %rbx,	%rbx
    jnz       L6886
    jmp       L6884
L6886:
    jmp       L6888
L6887:
    mov       %rcx,	%rdi
    mov       %rdx,	%rbx
    mov       %r8,	%rsi
    mov       %r9,	%r12
    call      cc_show.printunit
    mov       %rbx,	[%rbx+8]
L6888:
    test      %rbx,	%rbx
    jnz       L6887
L6884:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_show.getprefix
cc_show.getprefix:
#PROC1
#PROC2
#?>>
    .set cc_show.getprefix.indentstr, -512
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	544
    mov       %r12,	%rcx
    mov       %r13,	%rdx
    mov       %r14,	%r8
#---------------
#PROC3
#PROC4
    xor       %eax,	%eax
    mov       [%rbp + cc_show.getprefix.indentstr],	%al
    cmp       %r12,	10
    jle       L6892
    mov       %r12,	10
L6892:
    lea       %rcx,	[%rbp + cc_show.getprefix.indentstr]
    lea       %rdx,	[%rip+L9227]
    call      strcpy
    movsxd    %rax,	dword ptr[%r14+52]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      cc_lib.strmode
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    call      strlen
    mov       %rbx,	%rax
    lea       %rcx,	[%rbp + cc_show.getprefix.indentstr]
    call      strlen
    mov       %r10,	%rbx
    cmp       %r10,	%rax
    jge       L6894
    lea       %rcx,	[%rbp + cc_show.getprefix.indentstr]
    mov       %rdx,	%rdi
    mov       %r8,	%rbx
    call      memcpy
    jmp       L6893
L6894:
    lea       %rcx,	[%rbp + cc_show.getprefix.indentstr]
    mov       %rdx,	%rdi
    call      strcpy
L6893:
    mov       %rsi,	%r12
    cmp       %rsi,	0
    jle       L6897
L6895:
    lea       %rcx,	[%rbp + cc_show.getprefix.indentstr]
    lea       %rdx,	[%rip+L9228]
    call      strcat
    dec       %rsi
    jnz       L6895
L6897:
    call      cc_show.getlineinfok
    lea       %rcx,	[%rip+cc_show.getprefix.str]
    mov       %rdx,	%rax
    call      strcpy
    lea       %rcx,	[%rip+cc_show.getprefix.str]
    lea       %rdx,	[%rbp + cc_show.getprefix.indentstr]
    call      strcat
    lea       %rcx,	[%rip+cc_show.getprefix.str]
    mov       %rdx,	%r13
    call      strcat
    mov       %al,	[%r13]
    test      %al,	%al
    jz        L6899
    lea       %rcx,	[%rip+cc_show.getprefix.str]
    lea       %rdx,	[%rip+L9229]
    call      strcat
L6899:
    lea       %rax,	[%rip+cc_show.getprefix.str]
L6890:
#---------------
    add       %rsp,	544
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_show.getdottedname
cc_show.getdottedname:
#PROC1
#PROC2
#?>>
    .set cc_show.getdottedname.str2, -256
    push      %rdi
    push      %rbx
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	288
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rax,	[%rbx]
    lea       %rcx,	[%rip+cc_show.getdottedname.str]
    mov       %rdx,	%rax
    call      strcpy
    mov       %rdi,	[%rbx+8]
    jmp       L6902
L6901:
    lea       %rcx,	[%rbp + cc_show.getdottedname.str2]
    lea       %rdx,	[%rip+cc_show.getdottedname.str]
    call      strcpy
    mov       %rax,	[%rdi]
    lea       %rcx,	[%rip+cc_show.getdottedname.str]
    mov       %rdx,	%rax
    call      strcpy
    lea       %rcx,	[%rip+cc_show.getdottedname.str]
    lea       %rdx,	[%rip+L9230]
    call      strcat
    lea       %rcx,	[%rip+cc_show.getdottedname.str]
    lea       %rdx,	[%rbp + cc_show.getdottedname.str2]
    call      strcat
    mov       %rdi,	[%rdi+8]
L6902:
    test      %rdi,	%rdi
    jz        L6904
    movzx     %rax,	byte ptr[%rdi+109]
    cmp       %rax,	2
    jnz       L6901
L6904:
    mov       %ax,	[%rbx+96]
    test      %ax,	%ax
    jz        L6906
    lea       %rcx,	[%rbp + cc_show.getdottedname.str2]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L9230]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    movzx     %rax,	word ptr[%rbx+96]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       %rcx,	[%rip+cc_show.getdottedname.str]
    lea       %rdx,	[%rbp + cc_show.getdottedname.str2]
    call      strcat
L6906:
    lea       %rax,	[%rip+cc_show.getdottedname.str]
L6900:
#---------------
    add       %rsp,	288
    pop       %rbp
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_show.getlineinfok
cc_show.getlineinfok:
#PROC1
#PROC2
#?>>
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    lea       %rcx,	[%rip+cc_show.getlineinfok.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L9231]
    call      msys.m$print_setfmt
    mov       %rcx,	[%rip+cc_show.currfileno]
    call      msys.m$print_i64_nf
    mov       %rcx,	[%rip+cc_show.currlineno]
    lea       %rdx,	[%rip+L9232]
    call      msys.m$print_i64
    call      msys.m$print_space
    call      msys.m$print_end
    lea       %rax,	[%rip+cc_show.getlineinfok.str]
L6907:
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc cc_show.printst
cc_show.printst:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
    mov       %rsi,	%rdx
    mov       %r12,	%r8
#---------------
#PROC3
#PROC4
    movzx     %rax,	byte ptr[%rsi+107]
    cmp       %rax,	67
    jz        L6910
    lea       %rcx,	[%rip+L9233]
    call      cc_support.mcerror
L6910:
    mov       %rcx,	%rbx
    mov       %rdx,	%rsi
    mov       %r8,	%r12
    call      cc_show.printstrec
    mov       %rdi,	[%rsi+16]
    jmp       L6912
L6911:
    lea       %rax,	[%r12+1]
    mov       %rcx,	%rbx
    mov       %rdx,	%rdi
    mov       %r8,	%rax
    call      cc_show.printst
    mov       %rdi,	[%rdi+32]
L6912:
    test      %rdi,	%rdi
    jnz       L6911
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_show.printstrec
cc_show.printstrec:
#PROC1
#PROC2
#?>>
    .set cc_show.printstrec.p, 72
    .set cc_show.printstrec.level, 80
    .set cc_show.printstrec.v, -16
    .set cc_show.printstrec.str, -272
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
    push      %r14
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	304
    mov       %r14,	%rcx
    mov       [%rbp+72],	%rdx
    mov       [%rbp+80],	%r8
#---------------
#PROC3
#PROC4
    lea       %rax,	[%rbp + cc_show.printstrec.v]
    mov       %rdi,	%rax
    mov       %rcx,	%rdi
    call      mlib.gs_init
    xor       %rsi,	%rsi
    mov       %rax,	[%rbp + cc_show.printstrec.level]
    mov       %r13,	%rax
    cmp       %r13,	0
    jle       L6917
L6915:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L9234]
    call      mlib.gs_str
    mov       %rax,	4
    add       %rsi,	%rax
    dec       %r13
    jnz       L6915
L6917:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L9235]
    call      mlib.gs_str
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %ax,	[%rax+96]
    test      %ax,	%ax
    jz        L6919
    lea       %rcx,	[%rbp + cc_show.printstrec.str]
    call      msys.m$print_startstr
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L9236]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movzx     %rax,	word ptr[%rax+96]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    mov       %rax,	28
    sub       %rax,	%rsi
    mov       %rcx,	%rdi
    lea       %rdx,	[%rbp + cc_show.printstrec.str]
    mov       %r8,	%rax
    mov       %r9,	45
    call      mlib.gs_leftstr
    jmp       L6918
L6919:
    mov       %rax,	28
    sub       %rax,	%rsi
    mov       %r10,	[%rbp + cc_show.printstrec.p]
    mov       %r10,	[%r10]
    mov       %rcx,	%rdi
    mov       %rdx,	%r10
    mov       %r8,	%rax
    mov       %r9,	45
    call      mlib.gs_leftstr
L6918:
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movzx     %rax,	byte ptr[%rax+109]
    lea       %r10,	[%rip+cc_tables.namenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%rdi
    mov       %rdx,	%r10
    mov       %r8,	12
    mov       %r9,	46
    call      mlib.gs_leftstr
    mov       %rcx,	%rdi
    call      mlib.gs_getcol
    mov       %rbx,	%rax
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L9237]
    call      mlib.gs_str
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movzx     %rax,	byte ptr[%rax+110]
    lea       %r10,	[%rip+cc_tables.scopenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%rdi
    mov       %rdx,	%r10
    call      mlib.gs_str
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L9238]
    call      mlib.gs_str
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %al,	[%rax+112]
    test      %al,	%al
    jz        L6921
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L9239]
    call      mlib.gs_str
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movzx     %rax,	byte ptr[%rax+112]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mlib.gs_strint
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L9240]
    call      mlib.gs_str
L6921:
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movzx     %rax,	byte ptr[%rax+108]
    shr       %eax,	1
    and       %eax,	1
    test      %rax,	%rax
    jz        L6923
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L9241]
    call      mlib.gs_str
L6923:
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %al,	[%rax+122]
    test      %al,	%al
    jz        L6925
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L9242]
    call      mlib.gs_str
L6925:
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %al,	[%rax+111]
    test      %al,	%al
    jz        L6927
    lea       %rcx,	[%rbp + cc_show.printstrec.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L9243]
    call      msys.m$print_setfmt
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movzx     %rax,	byte ptr[%rax+111]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    mov       %rcx,	%rdi
    lea       %rdx,	[%rbp + cc_show.printstrec.str]
    call      mlib.gs_str
L6927:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L9244]
    call      mlib.gs_str
    lea       %rax,	[%rbx+10]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    mov       %r8,	61
    call      mlib.gs_padto
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %rax,	[%rax+8]
    test      %rax,	%rax
    jz        L6929
    lea       %rcx,	[%rbp + cc_show.printstrec.str]
    call      msys.m$print_startstr
    lea       %rcx,	[%rip+L9245]
    call      msys.m$print_setfmt
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %rax,	[%rax+8]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       %rcx,	%rdi
    lea       %rdx,	[%rbp + cc_show.printstrec.str]
    mov       %r8,	18
    mov       %r9,	32
    call      mlib.gs_leftstr
    jmp       L6928
L6929:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L9246]
    mov       %r8,	18
    mov       %r9,	32
    call      mlib.gs_leftstr
L6928:
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movzx     %rax,	word ptr[%rax+102]
    test      %rax,	%rax
    jnz       L6932
L6931:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L9247]
    call      mlib.gs_str
    jmp       L6930
L6932:
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movzx     %rax,	word ptr[%rax+102]
    mov       %rcx,	%rax
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mlib.gs_strsp
L6930:
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	10
    jz        L6934
    cmp       %rax,	8
    jz        L6935
    cmp       %rax,	9
    jz        L6935
    cmp       %rax,	6
    jz        L6936
    cmp       %rax,	11
    jz        L6937
    cmp       %rax,	7
    jz        L6938
    jmp       L6939
L6934:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L9248]
    call      mlib.gs_str
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movsxd    %rax,	dword ptr[%rax+88]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mlib.gs_strint
    jmp       L6933
L6935:
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %rax,	[%rax+72]
    test      %rax,	%rax
    jz        L6941
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L9249]
    call      mlib.gs_str
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %rax,	[%rax+72]
    mov       %rcx,	%rax
    call      cc_show.strexpr
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mlib.gs_strvar
L6941:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L9250]
    call      mlib.gs_str
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movsxd    %rax,	dword ptr[%rax+88]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mlib.gs_strint
    jmp       L6933
L6936:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L9251]
    call      mlib.gs_str
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movsxd    %rax,	dword ptr[%rax+88]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mlib.gs_strint
    jmp       L6933
L6937:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L9252]
    call      mlib.gs_str
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movsxd    %rax,	dword ptr[%rax+88]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mlib.gs_strint
    jmp       L6933
L6938:
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %rax,	[%rax+72]
    test      %rax,	%rax
    jz        L6943
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L9253]
    call      mlib.gs_str
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %rax,	[%rax+72]
    mov       %rcx,	%rax
    call      cc_show.strexpr
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mlib.gs_strvar
L6943:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L9254]
    call      mlib.gs_str
L6939:
L6933:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L9255]
    call      mlib.gs_str
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L9256]
    call      mlib.gs_str
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %eax,	[%rax+92]
    and       %rax,	16777215
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mlib.gs_strint
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L9257]
    call      mlib.gs_str
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %eax,	[%rax+92]
    sar       %rax,	24
    lea       %r10,	[%rip+cc_decls.sourcefilenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%rdi
    mov       %rdx,	%r10
    call      mlib.gs_str
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	6
    jnz       L6945
    mov       %rcx,	%rdi
    call      mlib.gs_line
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %r12,	[%rax+80]
    jmp       L6947
L6946:
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L9258]
    call      mlib.gs_str
    mov       %rax,	[%r12]
    test      %rax,	%rax
    jz        L6950
    mov       %rax,	[%r12]
    mov       %rax,	[%rax]
    jmp       L6949
L6950:
    lea       %rax,	[%rip+L9259]
L6949:
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    mov       %r8,	10
    mov       %r9,	45
    call      mlib.gs_leftstr
    movsx     %rax,	word ptr[%r12+22]
    lea       %r10,	[%rip+cc_tables.pmflagnames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%rdi
    mov       %rdx,	%r10
    call      mlib.gs_str
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L9260]
    call      mlib.gs_str
    movsxd    %rax,	dword ptr[%r12+16]
    mov       %rcx,	%rax
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mlib.gs_str
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L9261]
    call      mlib.gs_str
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %rax,	[%rax+72]
    mov       %rcx,	%rdi
    mov       %rdx,	%rax
    call      mlib.gs_strint
    mov       %rcx,	%rdi
    call      mlib.gs_line
    mov       %r12,	[%r12+8]
L6947:
    test      %r12,	%r12
    jnz       L6946
L6945:
    mov       %rcx,	%rdi
    mov       %rdx,	%r14
    call      mlib.gs_println
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %rax,	[%rax+72]
    test      %rax,	%rax
    jz        L6952
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    movzx     %rax,	byte ptr[%rax+109]
    cmp       %rax,	8
    jz        L6954
    cmp       %rax,	7
    jnz       L6955
L6954:
    mov       %rax,	[%rbp + cc_show.printstrec.p]
    mov       %rax,	[%rax+72]
    mov       %rcx,	%r14
    mov       %rdx,	%rax
    mov       %r8,	-3
    lea       %r9,	[%rip+L9262]
    call      cc_show.printunit
L6955:
L6953:
L6952:
#---------------
    add       %rsp,	304
    pop       %rbp
    pop       %r14
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_show.printstflat
cc_show.printstflat:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9263]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    xor       %rdi,	%rdi
    mov       %rax,	[%rip+cc_decls.hstsize]
    dec       %rax
    mov       %rsi,	%rax
    cmp       %rsi,	0
    jl        L6959
L6957:
    mov       %rax,	[%rip+cc_decls.hashtable]
    mov       %r10,	%rdi
    mov       %rbx,	[%rax + %r10*8]
    mov       %rax,	[%rbx]
    test      %rax,	%rax
    jz        L6961
    movzx     %rax,	byte ptr[%rbx+107]
    cmp       %rax,	67
    jz        L6963
    cmp       %rax,	70
    jz        L6963
    cmp       %rax,	68
    jnz       L6964
L6963:
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    mov       %rcx,	%rdi
    call      msys.m$print_i64_nf
    mov       %rcx,	%rbx
    call      msys.m$print_ptr_nf
    lea       %rcx,	[%rip+L9264]
    call      msys.m$print_str_nf
    mov       %rcx,	%rbx
    call      cc_lib.getstname
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rbx+107]
    lea       %r10,	[%rip+cc_tables.symbolnames]
    mov       %r10,	[%r10 + %rax*8-8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rbx+109]
    lea       %r10,	[%rip+cc_tables.namenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rbx,	[%rbx+40]
    jmp       L6966
L6965:
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9265]
    call      msys.m$print_str_nf
    mov       %rcx,	%rbx
    call      msys.m$print_ptr_nf
    mov       %rcx,	%rbx
    call      cc_lib.getstname
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rbx+107]
    lea       %r10,	[%rip+cc_tables.symbolnames]
    mov       %r10,	[%r10 + %rax*8-8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    movzx     %rax,	byte ptr[%rbx+109]
    lea       %r10,	[%rip+cc_tables.namenames]
    mov       %r10,	[%r10 + %rax*8]
    mov       %rcx,	%r10
    call      msys.m$print_str_nf
    mov       %rcx,	[%rbx+48]
    call      msys.m$print_ptr_nf
    call      msys.m$print_end
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9266]
    call      msys.m$print_str_nf
    mov       %rax,	[%rbx+8]
    test      %rax,	%rax
    jz        L6969
    mov       %rcx,	[%rbx+8]
    call      cc_lib.getstname
    jmp       L6968
L6969:
    lea       %rax,	[%rip+L9267]
L6968:
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L9268]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rbx,	[%rbx+40]
L6966:
    test      %rbx,	%rbx
    jnz       L6965
L6964:
L6962:
L6961:
    inc       %rdi
    cmp       %rdi,	%rsi
    jle       L6957
L6959:
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_show.strexpr
cc_show.strexpr:
#PROC1
#PROC2
#?>>
    push      %rdi
#?]]
    sub       %rsp,	48
    mov       %rdi,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	[%rip+cc_show.exprstr]
    call      mlib.gs_init
    mov       %rcx,	[%rip+cc_show.exprstr]
    mov       %rdx,	%rdi
    call      cc_show.jeval
    mov       %rax,	[%rip+cc_show.exprstr]
L6970:
#---------------
    add       %rsp,	48
    pop       %rdi
    ret       
# End 
# Proc cc_show.jeval
cc_show.jeval:
#PROC1
#PROC2
#?>>
    .set cc_show.jeval.str, -16000
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
    push      %r13
#?]]
    push      %rbp
    mov       %rbp,	%rsp
    sub       %rsp,	16040
    mov       %r12,	%rcx
    mov       %r13,	%rdx
#---------------
#PROC3
#PROC4
    movsxd    %rax,	dword ptr[%r13+40]
    cmp       %rax,	1
    jz        L6973
    cmp       %rax,	3
    jz        L6974
    cmp       %rax,	5
    jz        L6975
    cmp       %rax,	24
    jz        L6976
    cmp       %rax,	25
    jz        L6976
    cmp       %rax,	32
    jz        L6976
    cmp       %rax,	33
    jz        L6976
    cmp       %rax,	34
    jz        L6976
    cmp       %rax,	35
    jz        L6976
    cmp       %rax,	36
    jz        L6976
    cmp       %rax,	37
    jz        L6976
    cmp       %rax,	38
    jz        L6976
    cmp       %rax,	39
    jz        L6976
    cmp       %rax,	40
    jz        L6976
    cmp       %rax,	41
    jz        L6976
    cmp       %rax,	42
    jz        L6976
    cmp       %rax,	43
    jz        L6976
    cmp       %rax,	44
    jz        L6976
    cmp       %rax,	45
    jz        L6976
    cmp       %rax,	46
    jz        L6976
    cmp       %rax,	47
    jz        L6976
    cmp       %rax,	48
    jz        L6976
    cmp       %rax,	61
    jz        L6976
    cmp       %rax,	62
    jz        L6976
    cmp       %rax,	63
    jz        L6976
    cmp       %rax,	64
    jz        L6976
    cmp       %rax,	65
    jz        L6976
    cmp       %rax,	66
    jz        L6976
    cmp       %rax,	67
    jz        L6976
    cmp       %rax,	68
    jz        L6976
    cmp       %rax,	69
    jz        L6976
    cmp       %rax,	70
    jz        L6976
    cmp       %rax,	58
    jz        L6977
    cmp       %rax,	59
    jz        L6977
    cmp       %rax,	60
    jz        L6977
    cmp       %rax,	26
    jz        L6977
    cmp       %rax,	27
    jz        L6977
    cmp       %rax,	30
    jz        L6978
    cmp       %rax,	49
    jz        L6979
    cmp       %rax,	50
    jz        L6980
    cmp       %rax,	28
    jz        L6981
    cmp       %rax,	29
    jz        L6981
    cmp       %rax,	11
    jz        L6982
    cmp       %rax,	31
    jz        L6983
    cmp       %rax,	56
    jz        L6984
    cmp       %rax,	52
    jz        L6985
    cmp       %rax,	6
    jz        L6986
    cmp       %rax,	71
    jz        L6987
    cmp       %rax,	72
    jz        L6988
    cmp       %rax,	73
    jz        L6989
    cmp       %rax,	74
    jz        L6990
    cmp       %rax,	2
    jz        L6991
    cmp       %rax,	57
    jz        L6992
    cmp       %rax,	53
    jz        L6993
    cmp       %rax,	4
    jz        L6994
    jmp       L6995
L6973:
    movsxd    %rax,	dword ptr[%r13+52]
    mov       %rsi,	%rax
    cmp       %rax,	[%rip+cc_decls.trefchar]
    jnz       L6997
    movsxd    %rax,	dword ptr[%r13+48]
    test      %rax,	%rax
    jz        L7000
L6999:
    mov       %al,	[%r13+61]
    test      %al,	%al
    jz        L7000
L7002:
    movsxd    %rax,	dword ptr[%r13+48]
    cmp       %rax,	8000
    jle       L7004
    lea       %rcx,	[%rbp + cc_show.jeval.str]
    lea       %rdx,	[%rip+L9269]
    call      strcpy
    jmp       L7003
L7004:
    mov       %rax,	[%r13]
    mov       %rcx,	%rax
    lea       %rdx,	[%rbp + cc_show.jeval.str]
    call      pc_api.convertstring
L7003:
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9270]
    call      cc_support.gs_additem
    mov       %rcx,	%r12
    lea       %rdx,	[%rbp + cc_show.jeval.str]
    call      cc_support.gs_additem
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9270]
    call      cc_support.gs_additem
    jmp       L6971
L6997:
    cmp       %rsi,	1
    jl        L7005
    cmp       %rsi,	4
    jg        L7005
    mov       %rax,	[%r13]
    mov       %rcx,	%rax
    lea       %rdx,	[%rbp + cc_show.jeval.str]
    call      msys.getstrint
    jmp       L6996
L7005:
    cmp       %rsi,	6
    jl        L7006
    cmp       %rsi,	9
    jg        L7006
    mov       %rax,	[%r13]
    mov       %rcx,	%rax
    xor       %edx,	%edx
    call      msys.strword
    lea       %rcx,	[%rbp + cc_show.jeval.str]
    mov       %rdx,	%rax
    call      strcpy
    jmp       L6996
L7006:
    cmp       %rsi,	11
    jz        L7008
    cmp       %rsi,	10
    jnz       L7007
L7008:
    movq      %XMM4,	[%r13]
    movq      %XMM0,	%XMM4
    xor       %edx,	%edx
    call      msys.strreal
    lea       %rcx,	[%rbp + cc_show.jeval.str]
    mov       %rdx,	%rax
    call      strcpy
    jmp       L6996
L7007:
    movsxd    %rax,	dword ptr[%r13+52]
    lea       %r10,	[%rip+cc_decls.ttbasetype]
    movsx     %r10,	word ptr[%r10 + %rax*2]
    cmp       %r10,	13
    jz        L7010
    cmp       %r10,	17
    jz        L7011
    jmp       L7012
L7010:
#cc_show.jeval.doref:
L7000:
    lea       %rcx,	[%rbp + cc_show.jeval.str]
    call      msys.m$print_startstr
    mov       %rcx,	[%r13]
    call      msys.m$print_ptr_nf
    call      msys.m$print_end
    jmp       L7009
L7011:
    lea       %rcx,	[%rbp + cc_show.jeval.str]
    lea       %rdx,	[%rip+L9271]
    call      strcpy
    jmp       L7009
L7012:
    call      msys.m$print_startcon
    movsxd    %rax,	dword ptr[%r13+52]
    mov       %rcx,	%rax
    call      cc_lib.typename
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rcx,	[%rip+L9272]
    call      mlib.abortprogram
L7009:
L6996:
    mov       %rcx,	%r12
    lea       %rdx,	[%rbp + cc_show.jeval.str]
    call      cc_support.gs_additem
    jmp       L6972
L6974:
    mov       %rax,	[%r13]
    mov       %rax,	[%rax]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_support.gs_additem
    jmp       L6972
L6975:
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9273]
    call      mlib.gs_str
    mov       %rax,	[%r13]
    mov       %rax,	[%rax]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_support.gs_additem
    jmp       L6972
L6976:
    movsxd    %rax,	dword ptr[%r13+40]
    mov       %rcx,	%rax
    call      cc_lib.getopcjname
    lea       %rcx,	[%rbp + cc_show.jeval.str]
    mov       %rdx,	%rax
    call      strcpy
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9274]
    call      cc_support.gs_additem
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rcx,	%r12
    lea       %rdx,	[%rbp + cc_show.jeval.str]
    call      cc_support.gs_additem
    mov       %rax,	[%r13+24]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9275]
    call      cc_support.gs_additem
    jmp       L6972
L6977:
    movsxd    %rax,	dword ptr[%r13+40]
    mov       %rcx,	%rax
    call      cc_lib.getopcjname
    lea       %rcx,	[%rbp + cc_show.jeval.str]
    mov       %rdx,	%rax
    call      strcpy
    mov       %rcx,	%r12
    lea       %rdx,	[%rbp + cc_show.jeval.str]
    call      cc_support.gs_additem
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9276]
    call      cc_support.gs_additem
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9277]
    call      cc_support.gs_additem
    jmp       L6972
L6978:
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9278]
    call      cc_support.gs_additem
    mov       %rdi,	[%r13+24]
    jmp       L7014
L7013:
    mov       %rcx,	%r12
    mov       %rdx,	%rdi
    call      cc_show.jeval
    mov       %rdi,	[%rdi+8]
    test      %rdi,	%rdi
    jz        L7017
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9279]
    call      cc_support.gs_additem
L7017:
L7014:
    test      %rdi,	%rdi
    jnz       L7013
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9280]
    call      cc_support.gs_additem
    jmp       L6972
L6979:
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9281]
    call      cc_support.gs_additem
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9282]
    call      mlib.gs_str
    jmp       L6972
L6980:
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9283]
    call      cc_support.gs_additem
    mov       %rax,	[%r13+24]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    jmp       L6972
L6981:
    movsxd    %rax,	dword ptr[%r13+40]
    cmp       %rax,	29
    setz      %al
    movzx     %eax,	%al
    mov       %rbx,	%rax
    test      %rbx,	%rbx
    jz        L7019
    lea       %rax,	[%rip+L9284]
    jmp       L7018
L7019:
    lea       %rax,	[%rip+L9285]
L7018:
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_support.gs_additem
    mov       %rdi,	[%r13+16]
    jmp       L7021
L7020:
    mov       %rcx,	%r12
    mov       %rdx,	%rdi
    call      cc_show.jeval
    mov       %rdi,	[%rdi+8]
    test      %rdi,	%rdi
    jz        L7024
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9286]
    call      cc_support.gs_additem
L7024:
L7021:
    test      %rdi,	%rdi
    jnz       L7020
    test      %rbx,	%rbx
    jz        L7026
    lea       %rax,	[%rip+L9287]
    jmp       L7025
L7026:
    lea       %rax,	[%rip+L9288]
L7025:
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_support.gs_additem
    jmp       L6972
L6982:
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9289]
    call      cc_support.gs_additem
    mov       %rax,	[%r13+24]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    jmp       L6972
L6983:
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9290]
    call      cc_support.gs_additem
    mov       %rax,	[%r13+24]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9291]
    call      cc_support.gs_additem
    mov       %rax,	[%r13+32]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    jmp       L6972
L6984:
    movsxd    %rax,	dword ptr[%r13+52]
    mov       %rcx,	%rax
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_support.gs_additem
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9292]
    call      cc_support.gs_additem
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9293]
    call      cc_support.gs_additem
    jmp       L6972
L6985:
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9294]
    call      cc_support.gs_additem
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rax,	[%r13+24]
    test      %rax,	%rax
    jz        L7028
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9295]
    call      cc_support.gs_additem
    mov       %rax,	[%r13+24]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
L7028:
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9296]
    call      cc_support.gs_additem
    jmp       L6972
L6986:
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9297]
    call      cc_support.gs_additem
    jmp       L6972
L6987:
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9298]
    call      cc_support.gs_additem
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    jmp       L6972
L6988:
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9299]
    call      cc_support.gs_additem
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    jmp       L6972
L6989:
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9300]
    call      cc_support.gs_additem
    jmp       L6972
L6990:
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9301]
    call      cc_support.gs_additem
    jmp       L6972
L6991:
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9302]
    call      mlib.gs_str
    jmp       L6972
L6992:
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9303]
    call      mlib.gs_str
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    movsxd    %rax,	dword ptr[%r13+48]
    cmp       %rax,	0
    jle       L7030
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9304]
    call      mlib.gs_str
    movsxd    %rax,	dword ptr[%r13+48]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      mlib.gs_strint
    jmp       L7029
L7030:
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9305]
    call      mlib.gs_str
    movsxd    %rax,	dword ptr[%r13+48]
    neg       %rax
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      mlib.gs_strint
L7029:
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9306]
    call      mlib.gs_str
    jmp       L6972
L6993:
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9307]
    call      mlib.gs_str
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9308]
    call      mlib.gs_str
    mov       %rax,	[%r13+24]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9309]
    call      mlib.gs_str
    jmp       L6972
L6994:
    mov       %rax,	[%r13+16]
    mov       %rcx,	%r12
    mov       %rdx,	%rax
    call      cc_show.jeval
    jmp       L6972
L6995:
    mov       %rcx,	%r12
    lea       %rdx,	[%rip+L9310]
    call      mlib.gs_str
L6972:
L6971:
#---------------
    add       %rsp,	16040
    pop       %rbp
    pop       %r13
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_show.printfilelist
cc_show.printfilelist:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
#?]]
    sub       %rsp,	40
    mov       %rbx,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%rbx
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9311]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+cc_decls.nsourcefiles]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rdi,	1
    mov       %rax,	[%rip+cc_decls.nsourcefiles]
    cmp       %rax,	1
    jl        L7034
L7032:
    mov       %rcx,	%rbx
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9312]
    call      msys.m$print_setfmt
    mov       %rcx,	%rdi
    call      msys.m$print_i64_nf
    lea       %rax,	[%rip+cc_decls.sourcefilenames]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    mov       %rcx,	%rax
    lea       %rdx,	[%rip+L9313]
    call      msys.m$print_str
    lea       %rax,	[%rip+cc_decls.sourcefilepaths]
    mov       %r10,	%rdi
    mov       %rcx,	[%rax + %r10*8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    inc       %rdi
    cmp       %rdi,	[%rip+cc_decls.nsourcefiles]
    jle       L7032
L7034:
    mov       %rcx,	%rbx
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9314]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+cc_decls.inputfile]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%rbx
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9315]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+cc_decls.nlibfiles]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rdi,	1
    mov       %rax,	[%rip+cc_decls.nlibfiles]
    cmp       %rax,	1
    jl        L7037
L7035:
    mov       %rcx,	%rbx
    call      msys.m$print_startfile
    mov       %rcx,	%rdi
    call      msys.m$print_i64_nf
    lea       %rax,	[%rip+cc_decls.libfiles]
    mov       %r10,	%rdi
    mov       %rcx,	[%rax + %r10*8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    inc       %rdi
    cmp       %rdi,	[%rip+cc_decls.nlibfiles]
    jle       L7035
L7037:
#---------------
    add       %rsp,	40
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc cc_show.printmodelist
cc_show.printmodelist:
#PROC1
#PROC2
#?>>
    push      %rdi
    push      %rbx
    push      %rsi
    push      %r12
#?]]
    sub       %rsp,	40
    mov       %r12,	%rcx
#---------------
#PROC3
#PROC4
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9316]
    call      msys.m$print_str_nf
    mov       %rcx,	[%rip+cc_decls.ntypes]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    xor       %rdi,	%rdi
    mov       %rax,	[%rip+cc_decls.ntypes]
    cmp       %rax,	0
    jl        L7041
L7039:
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    mov       %rcx,	%rdi
    lea       %rdx,	[%rip+L9317]
    call      msys.m$print_i64
    mov       %rcx,	%rdi
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rax,	[%rip+cc_decls.ttbasetype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rbx,	%rax
    lea       %rax,	[%rip+cc_decls.tttypedef]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    test      %rax,	%rax
    jz        L7043
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9318]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L9319]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.tttypedef]
    mov       %r10,	%rdi
    mov       %rax,	[%rax + %r10*8]
    mov       %rcx,	[%rax]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L7043:
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9320]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L9321]
    call      msys.m$print_str_nf
    mov       %rcx,	%rbx
    call      msys.m$print_i64_nf
    mov       %rcx,	%rbx
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9322]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L9323]
    call      msys.m$print_str_nf
    mov       %rcx,	%rdi
    call      cc_lib.typename
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       %rax,	[%rip+cc_decls.ttnamedef]
    mov       %r10,	%rdi
    mov       %rsi,	[%rax + %r10*8]
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9324]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L9325]
    call      msys.m$print_str_nf
    mov       %rcx,	%rsi
    call      msys.m$print_ptr_nf
    call      msys.m$print_space
    call      msys.m$print_end
    test      %rsi,	%rsi
    jz        L7045
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    mov       %rcx,	[%rsi]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       %rcx,	[%rip+L9326]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    movzx     %rax,	word ptr[%rsi+96]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L7044
L7045:
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9327]
    call      msys.m$print_str_nf
    call      msys.m$print_end
L7044:
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9328]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L9329]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.tttarget]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rcx,	%rax
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9330]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L9331]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.ttsize]
    mov       %r10,	%rdi
    mov       %rcx,	[%rax + %r10*8]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9332]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L9333]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.ttlength]
    mov       %r10,	%rdi
    mov       %rcx,	[%rax + %r10*8]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9334]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L9335]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.ttisblock]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9336]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L9337]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.ttconst]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9338]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L9339]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.ttsigned]
    mov       %r10,	%rdi
    movzx     %rax,	byte ptr[%rax + %r10]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9340]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L9341]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.ttreftype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9342]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L9343]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.ttconsttype]
    mov       %r10,	%rdi
    movsx     %rax,	word ptr[%rax + %r10*2]
    mov       %rcx,	%rax
    mov       %rdx,	1
    call      cc_lib.strmode
    mov       %rcx,	%rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    lea       %rcx,	[%rip+L9344]
    call      msys.m$print_str_nf
    lea       %rcx,	[%rip+L9345]
    call      msys.m$print_str_nf
    lea       %rax,	[%rip+cc_decls.ttshared]
    mov       %r10,	%rdi
    movsxd    %rax,	dword ptr[%rax + %r10*4]
    mov       %rcx,	%rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
    inc       %rdi
    cmp       %rdi,	[%rip+cc_decls.ntypes]
    jle       L7039
L7041:
    mov       %rcx,	%r12
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
#---------------
    add       %rsp,	40
    pop       %r12
    pop       %rsi
    pop       %rbx
    pop       %rdi
    ret       
# End 
# Proc msyswin.start
msyswin.start:
#PROC1
#PROC2
#?>>
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    call      msys.start
#---------------
    add       %rsp,	40
    ret       
# End 
# Proc pepcl.start
pepcl.start:
#PROC1
#PROC2
#?>>
#?]]
    sub       %rsp,	40
#---------------
#PROC3
#PROC4
    call      mc_decls.start
    call      mc_writegas.start
#---------------
    add       %rsp,	40
    ret       
# End 
    .data
$procaddr:
    .quad     mc_genmcl.px_nop
    .quad     mc_genmcl.px_dupl
    .quad     mc_genmcl.px_double
    .quad     mc_genmcl.px_opnd
    .quad     mc_genmcl.px_type
    .quad     mc_genmcl.px_comment
    .quad     mc_genmcl.px_proc
    .quad     mc_genmcl.px_endproc
    .quad     mc_genmcl.px_endprog
    .quad     mc_genmcl.px_istatic
    .quad     mc_genmcl.px_zstatic
    .quad     mc_genmcl.px_data
    .quad     mc_genmcl.px_label
    .quad     mc_genmcl.px_load
    .quad     mc_genmcl.px_store
    .quad     mc_genmcl.px_add
    .quad     mc_genmcl.px_sub
    .quad     mc_genmcl.px_mul
    .quad     mc_genmcl.px_div
    .quad     mc_genmcl.px_eval
    .quad     mc_genmcl.px_widen
    .quad     mc_genmcl.px_jump
    .quad     mc_genmcl.px_ijump
    .quad     mc_genmcl.px_neg
    .quad     mc_genmcl.px_abs
    .quad     mc_genmcl.px_bitnot
    .quad     mc_genmcl.px_not
    .quad     mc_genmcl.px_toboolt
    .quad     mc_genmcl.px_sqr
    .quad     mc_genmcl.px_sqrt
    .quad     mc_genmcl.px_jumpcc
    .quad     mc_genmcl.px_jumpt
    .quad     mc_genmcl.px_jumpf
    .quad     mc_genmcl.px_bitand
    .quad     mc_genmcl.px_bitor
    .quad     mc_genmcl.px_bitxor
    .quad     mc_genmcl.px_shl
    .quad     mc_genmcl.px_shr
    .quad     mc_genmcl.px_retproc
    .quad     mc_genmcl.px_retfn
    .quad     mc_genmcl.px_setcall
    .quad     mc_genmcl.px_setarg
    .quad     mc_genmcl.px_callp
    .quad     mc_genmcl.px_jumpret
    .quad     mc_genmcl.px_jumpretm
    .quad     mc_genmcl.px_startmx
    .quad     mc_genmcl.px_resetmx
    .quad     mc_genmcl.px_stop
    .quad     mc_genmcl.px_incrto
    .quad     mc_genmcl.px_decrto
    .quad     mc_genmcl.px_incrload
    .quad     mc_genmcl.px_decrload
    .quad     mc_genmcl.px_loadincr
    .quad     mc_genmcl.px_loaddecr
    .quad     mc_genmcl.px_forup
    .quad     mc_genmcl.px_fordown
    .quad     mc_genmcl.px_iload
    .quad     mc_genmcl.px_iloadx
    .quad     mc_genmcl.px_istore
    .quad     mc_genmcl.px_istorex
    .quad     mc_genmcl.px_storem
    .quad     mc_genmcl.px_addpx
    .quad     mc_genmcl.px_subpx
    .quad     mc_genmcl.px_to
    .quad     mc_genmcl.px_iswap
    .quad     mc_genmcl.px_swapstk
    .quad     mc_genmcl.px_labeldef
    .quad     mc_genmcl.px_addto
    .quad     mc_genmcl.px_subto
    .quad     mc_genmcl.px_multo
    .quad     mc_genmcl.px_bitandto
    .quad     mc_genmcl.px_bitorto
    .quad     mc_genmcl.px_bitxorto
    .quad     mc_genmcl.px_shlto
    .quad     mc_genmcl.px_shrto
    .quad     mc_genmcl.px_fix
    .quad     mc_genmcl.px_float
    .quad     mc_genmcl.px_idiv
    .quad     mc_genmcl.px_irem
    .quad     mc_genmcl.px_idivrem
    .quad     mc_genmcl.px_clear
    .quad     mc_genmcl.px_subp
    .quad     mc_genmcl.px_switch
    .quad     mc_genmcl.px_switchu
    .quad     mc_genmcl.px_swlabel
    .quad     mc_genmcl.px_endsw
    .quad     mc_genmcl.px_fwiden
    .quad     mc_genmcl.px_fnarrow
    .quad     mc_genmcl.px_truncate
    .quad     mc_genmcl.px_typepun
    .quad     mc_genmcl.px_unload
    .quad     mc_genmcl.px_loadbit
    .quad     mc_genmcl.px_assem
    .quad     mc_genmcl.px_sin
    .quad     mc_genmcl.px_cos
    .quad     mc_genmcl.px_tan
    .quad     mc_genmcl.px_asin
    .quad     mc_genmcl.px_acos
    .quad     mc_genmcl.px_atan
    .quad     mc_genmcl.px_log
    .quad     mc_genmcl.px_log10
    .quad     mc_genmcl.px_exp
    .quad     mc_genmcl.px_round
    .quad     mc_genmcl.px_floor
    .quad     mc_genmcl.px_ceil
    .quad     mc_genmcl.px_atan2
    .quad     mc_genmcl.px_fmod
    .quad     mc_genmcl.px_setcc
    .quad     mc_genmcl.px_min
    .quad     mc_genmcl.px_max
    .quad     mc_genmcl.px_power
    .quad     mc_genmcl.px_minto
    .quad     mc_genmcl.px_maxto
    .quad     mc_genmcl.px_negto
    .quad     mc_genmcl.px_absto
    .quad     mc_genmcl.px_addpxto
    .quad     mc_genmcl.px_subpxto
    .quad     mc_genmcl.px_divto
    .quad     mc_genmcl.px_bitnotto
    .quad     mc_genmcl.px_notto
    .quad     mc_genmcl.px_toboolto
    .quad     mc_genmcl.px_sign
    .quad     mc_genmcl.px_loadbf
    .quad     mc_genmcl.px_storebit
    .quad     mc_genmcl.px_storebf
    .quad     mc_genmcl.px_loadall
    .quad     mc_genmcl.px_setjmp
    .quad     mc_genmcl.px_longjmp
    .quad     mc_genmcl.px_initdswx
    .quad     mc_auxmcl.do_addrmode
$procname:
    .quad     L9346
    .quad     L9347
    .quad     L9348
    .quad     L9349
    .quad     L9350
    .quad     L9351
    .quad     L9352
    .quad     L9353
    .quad     L9354
    .quad     L9355
    .quad     L9356
    .quad     L9357
    .quad     L9358
    .quad     L9359
    .quad     L9360
    .quad     L9361
    .quad     L9362
    .quad     L9363
    .quad     L9364
    .quad     L9365
    .quad     L9366
    .quad     L9367
    .quad     L9368
    .quad     L9369
    .quad     L9370
    .quad     L9371
    .quad     L9372
    .quad     L9373
    .quad     L9374
    .quad     L9375
    .quad     L9376
    .quad     L9377
    .quad     L9378
    .quad     L9379
    .quad     L9380
    .quad     L9381
    .quad     L9382
    .quad     L9383
    .quad     L9384
    .quad     L9385
    .quad     L9386
    .quad     L9387
    .quad     L9388
    .quad     L9389
    .quad     L9390
    .quad     L9391
    .quad     L9392
    .quad     L9393
    .quad     L9394
    .quad     L9395
    .quad     L9396
    .quad     L9397
    .quad     L9398
    .quad     L9399
    .quad     L9400
    .quad     L9401
    .quad     L9402
    .quad     L9403
    .quad     L9404
    .quad     L9405
    .quad     L9406
    .quad     L9407
    .quad     L9408
    .quad     L9409
    .quad     L9410
    .quad     L9411
    .quad     L9412
    .quad     L9413
    .quad     L9414
    .quad     L9415
    .quad     L9416
    .quad     L9417
    .quad     L9418
    .quad     L9419
    .quad     L9420
    .quad     L9421
    .quad     L9422
    .quad     L9423
    .quad     L9424
    .quad     L9425
    .quad     L9426
    .quad     L9427
    .quad     L9428
    .quad     L9429
    .quad     L9430
    .quad     L9431
    .quad     L9432
    .quad     L9433
    .quad     L9434
    .quad     L9435
    .quad     L9436
    .quad     L9437
    .quad     L9438
    .quad     L9439
    .quad     L9440
    .quad     L9441
    .quad     L9442
    .quad     L9443
    .quad     L9444
    .quad     L9445
    .quad     L9446
    .quad     L9447
    .quad     L9448
    .quad     L9449
    .quad     L9450
    .quad     L9451
    .quad     L9452
    .quad     L9453
    .quad     L9454
    .quad     L9455
    .quad     L9456
    .quad     L9457
    .quad     L9458
    .quad     L9459
    .quad     L9460
    .quad     L9461
    .quad     L9462
    .quad     L9463
    .quad     L9464
    .quad     L9465
    .quad     L9466
    .quad     L9467
    .quad     L9468
    .quad     L9469
    .quad     L9470
    .quad     L9471
    .quad     L9472
    .quad     L9473
    .quad     L9474
    .quad     L9475
$nprocs:
    .quad     0x82
#Real Table
    .align    8
L9034:
    .quad     0x3FF0000000000000
L8941:
    .quad     0x4024000000000000
L8938:
    .quad     0x4024000000000000
L8933:
    .quad     0
L8932:
    .quad     0x4000000000000000
L8817:
    .quad     0x4000000000000000
L8773:
    .quad     0x4059000000000000
L8572:
    .quad     0x7FF0000000000000
L8570:
    .quad     0x7FF0000000000000
L8553:
    .quad     0
L8431:
    .quad     0x7FF0000000000000
L8359:
    .quad     0x43E0000000000000
L8358:
    .quad     0x3FF0000000000000
L8357:
    .quad     0x43E0000000000000
L8334:
    .quad     0
L8332:
    .quad     0
#Real32 Table
    .align    16
#labneg64
L9023:
    .quad     0x8000000000000000
    .quad     0x8000000000000000
#mask63/offset64
L8936:
    .quad     0x7FFFFFFFFFFFFFFF
L8937:
    .quad     0x43E0000000000000
#String Table
    .align    8
L9475:
    .ascii    "do_addrmode"
    .byte     0
L9474:
    .ascii    "px_initdswx"
    .byte     0
L9473:
    .ascii    "px_longjmp"
    .byte     0
L9472:
    .ascii    "px_setjmp"
    .byte     0
L9471:
    .ascii    "px_loadall"
    .byte     0
L9470:
    .ascii    "px_storebf"
    .byte     0
L9469:
    .ascii    "px_storebit"
    .byte     0
L9468:
    .ascii    "px_loadbf"
    .byte     0
L9467:
    .ascii    "px_sign"
    .byte     0
L9466:
    .ascii    "px_toboolto"
    .byte     0
L9465:
    .ascii    "px_notto"
    .byte     0
L9464:
    .ascii    "px_bitnotto"
    .byte     0
L9463:
    .ascii    "px_divto"
    .byte     0
L9462:
    .ascii    "px_subpxto"
    .byte     0
L9461:
    .ascii    "px_addpxto"
    .byte     0
L9460:
    .ascii    "px_absto"
    .byte     0
L9459:
    .ascii    "px_negto"
    .byte     0
L9458:
    .ascii    "px_maxto"
    .byte     0
L9457:
    .ascii    "px_minto"
    .byte     0
L9456:
    .ascii    "px_power"
    .byte     0
L9455:
    .ascii    "px_max"
    .byte     0
L9454:
    .ascii    "px_min"
    .byte     0
L9453:
    .ascii    "px_setcc"
    .byte     0
L9452:
    .ascii    "px_fmod"
    .byte     0
L9451:
    .ascii    "px_atan2"
    .byte     0
L9450:
    .ascii    "px_ceil"
    .byte     0
L9449:
    .ascii    "px_floor"
    .byte     0
L9448:
    .ascii    "px_round"
    .byte     0
L9447:
    .ascii    "px_exp"
    .byte     0
L9446:
    .ascii    "px_log10"
    .byte     0
L9445:
    .ascii    "px_log"
    .byte     0
L9444:
    .ascii    "px_atan"
    .byte     0
L9443:
    .ascii    "px_acos"
    .byte     0
L9442:
    .ascii    "px_asin"
    .byte     0
L9441:
    .ascii    "px_tan"
    .byte     0
L9440:
    .ascii    "px_cos"
    .byte     0
L9439:
    .ascii    "px_sin"
    .byte     0
L9438:
    .ascii    "px_assem"
    .byte     0
L9437:
    .ascii    "px_loadbit"
    .byte     0
L9436:
    .ascii    "px_unload"
    .byte     0
L9435:
    .ascii    "px_typepun"
    .byte     0
L9434:
    .ascii    "px_truncate"
    .byte     0
L9433:
    .ascii    "px_fnarrow"
    .byte     0
L9432:
    .ascii    "px_fwiden"
    .byte     0
L9431:
    .ascii    "px_endsw"
    .byte     0
L9430:
    .ascii    "px_swlabel"
    .byte     0
L9429:
    .ascii    "px_switchu"
    .byte     0
L9428:
    .ascii    "px_switch"
    .byte     0
L9427:
    .ascii    "px_subp"
    .byte     0
L9426:
    .ascii    "px_clear"
    .byte     0
L9425:
    .ascii    "px_idivrem"
    .byte     0
L9424:
    .ascii    "px_irem"
    .byte     0
L9423:
    .ascii    "px_idiv"
    .byte     0
L9422:
    .ascii    "px_float"
    .byte     0
L9421:
    .ascii    "px_fix"
    .byte     0
L9420:
    .ascii    "px_shrto"
    .byte     0
L9419:
    .ascii    "px_shlto"
    .byte     0
L9418:
    .ascii    "px_bitxorto"
    .byte     0
L9417:
    .ascii    "px_bitorto"
    .byte     0
L9416:
    .ascii    "px_bitandto"
    .byte     0
L9415:
    .ascii    "px_multo"
    .byte     0
L9414:
    .ascii    "px_subto"
    .byte     0
L9413:
    .ascii    "px_addto"
    .byte     0
L9412:
    .ascii    "px_labeldef"
    .byte     0
L9411:
    .ascii    "px_swapstk"
    .byte     0
L9410:
    .ascii    "px_iswap"
    .byte     0
L9409:
    .ascii    "px_to"
    .byte     0
L9408:
    .ascii    "px_subpx"
    .byte     0
L9407:
    .ascii    "px_addpx"
    .byte     0
L9406:
    .ascii    "px_storem"
    .byte     0
L9405:
    .ascii    "px_istorex"
    .byte     0
L9404:
    .ascii    "px_istore"
    .byte     0
L9403:
    .ascii    "px_iloadx"
    .byte     0
L9402:
    .ascii    "px_iload"
    .byte     0
L9401:
    .ascii    "px_fordown"
    .byte     0
L9400:
    .ascii    "px_forup"
    .byte     0
L9399:
    .ascii    "px_loaddecr"
    .byte     0
L9398:
    .ascii    "px_loadincr"
    .byte     0
L9397:
    .ascii    "px_decrload"
    .byte     0
L9396:
    .ascii    "px_incrload"
    .byte     0
L9395:
    .ascii    "px_decrto"
    .byte     0
L9394:
    .ascii    "px_incrto"
    .byte     0
L9393:
    .ascii    "px_stop"
    .byte     0
L9392:
    .ascii    "px_resetmx"
    .byte     0
L9391:
    .ascii    "px_startmx"
    .byte     0
L9390:
    .ascii    "px_jumpretm"
    .byte     0
L9389:
    .ascii    "px_jumpret"
    .byte     0
L9388:
    .ascii    "px_callp"
    .byte     0
L9387:
    .ascii    "px_setarg"
    .byte     0
L9386:
    .ascii    "px_setcall"
    .byte     0
L9385:
    .ascii    "px_retfn"
    .byte     0
L9384:
    .ascii    "px_retproc"
    .byte     0
L9383:
    .ascii    "px_shr"
    .byte     0
L9382:
    .ascii    "px_shl"
    .byte     0
L9381:
    .ascii    "px_bitxor"
    .byte     0
L9380:
    .ascii    "px_bitor"
    .byte     0
L9379:
    .ascii    "px_bitand"
    .byte     0
L9378:
    .ascii    "px_jumpf"
    .byte     0
L9377:
    .ascii    "px_jumpt"
    .byte     0
L9376:
    .ascii    "px_jumpcc"
    .byte     0
L9375:
    .ascii    "px_sqrt"
    .byte     0
L9374:
    .ascii    "px_sqr"
    .byte     0
L9373:
    .ascii    "px_toboolt"
    .byte     0
L9372:
    .ascii    "px_not"
    .byte     0
L9371:
    .ascii    "px_bitnot"
    .byte     0
L9370:
    .ascii    "px_abs"
    .byte     0
L9369:
    .ascii    "px_neg"
    .byte     0
L9368:
    .ascii    "px_ijump"
    .byte     0
L9367:
    .ascii    "px_jump"
    .byte     0
L9366:
    .ascii    "px_widen"
    .byte     0
L9365:
    .ascii    "px_eval"
    .byte     0
L9364:
    .ascii    "px_div"
    .byte     0
L9363:
    .ascii    "px_mul"
    .byte     0
L9362:
    .ascii    "px_sub"
    .byte     0
L9361:
    .ascii    "px_add"
    .byte     0
L9360:
    .ascii    "px_store"
    .byte     0
L9359:
    .ascii    "px_load"
    .byte     0
L9358:
    .ascii    "px_label"
    .byte     0
L9357:
    .ascii    "px_data"
    .byte     0
L9356:
    .ascii    "px_zstatic"
    .byte     0
L9355:
    .ascii    "px_istatic"
    .byte     0
L9354:
    .ascii    "px_endprog"
    .byte     0
L9353:
    .ascii    "px_endproc"
    .byte     0
L9352:
    .ascii    "px_proc"
    .byte     0
L9351:
    .ascii    "px_comment"
    .byte     0
L9350:
    .ascii    "px_type"
    .byte     0
L9349:
    .ascii    "px_opnd"
    .byte     0
L9348:
    .ascii    "px_double"
    .byte     0
L9347:
    .ascii    "px_dupl"
    .byte     0
L9346:
    .ascii    "px_nop"
    .byte     0
L9345:
    .ascii    "Shared:"
    .byte     0
L9344:
    .byte     9
    .byte     0
L9343:
    .ascii    "Constver:"
    .byte     0
L9342:
    .byte     9
    .byte     0
L9341:
    .ascii    "Ref:"
    .byte     0
L9340:
    .byte     9
    .byte     0
L9339:
    .ascii    "Signed:"
    .byte     0
L9338:
    .byte     9
    .byte     0
L9337:
    .ascii    "Const:"
    .byte     0
L9336:
    .byte     9
    .byte     0
L9335:
    .ascii    "Isblock:"
    .byte     0
L9334:
    .byte     9
    .byte     0
L9333:
    .ascii    "Length:"
    .byte     0
L9332:
    .byte     9
    .byte     0
L9331:
    .ascii    "Size:"
    .byte     0
L9330:
    .byte     9
    .byte     0
L9329:
    .ascii    "Target:"
    .byte     0
L9328:
    .byte     9
    .byte     0
L9327:
    .ascii    "-"
    .byte     0
L9326:
    .ascii    "."
    .byte     0
L9325:
    .ascii    "ttnamedef:"
    .byte     0
L9324:
    .byte     9
    .byte     0
L9323:
    .ascii    "Name:"
    .byte     0
L9322:
    .byte     9
    .byte     0
L9321:
    .ascii    "Basetype:"
    .byte     0
L9320:
    .byte     9
    .byte     0
L9319:
    .ascii    "Typedef:"
    .byte     0
L9318:
    .byte     9
    .byte     0
L9317:
    .ascii    "4"
    .byte     0
L9316:
    .ascii    "PROC MODELIST"
    .byte     0
L9315:
    .byte     10
    .ascii    "Libfiles"
    .byte     0
L9314:
    .byte     10
    .ascii    "Input file:"
    .byte     0
L9313:
    .ascii    "12jl"
    .byte     0
L9312:
    .ascii    "# # (#)"
    .byte     0
L9311:
    .ascii    "Source files"
    .byte     0
L9310:
    .ascii    "<CAN'T DO JEVAL>"
    .byte     0
L9309:
    .ascii    ")"
    .byte     0
L9308:
    .ascii    "+"
    .byte     0
L9307:
    .ascii    "("
    .byte     0
L9306:
    .ascii    ")"
    .byte     0
L9305:
    .ascii    ")/"
    .byte     0
L9304:
    .ascii    ")*"
    .byte     0
L9303:
    .ascii    "scale(("
    .byte     0
L9302:
    .ascii    "<nullunit>"
    .byte     0
L9301:
    .ascii    "--"
    .byte     0
L9300:
    .ascii    "++"
    .byte     0
L9299:
    .ascii    "--"
    .byte     0
L9298:
    .ascii    "++"
    .byte     0
L9297:
    .ascii    "<JBLOCK>"
    .byte     0
L9296:
    .ascii    ")"
    .byte     0
L9295:
    .ascii    "+"
    .byte     0
L9294:
    .ascii    "*("
    .byte     0
L9293:
    .ascii    ")"
    .byte     0
L9292:
    .ascii    "("
    .byte     0
L9291:
    .ascii    ":"
    .byte     0
L9290:
    .ascii    "?"
    .byte     0
L9289:
    .ascii    "="
    .byte     0
L9288:
    .ascii    "}"
    .byte     0
L9287:
    .ascii    ")"
    .byte     0
L9286:
    .ascii    ","
    .byte     0
L9285:
    .ascii    "{"
    .byte     0
L9284:
    .ascii    "("
    .byte     0
L9283:
    .ascii    "->"
    .byte     0
L9282:
    .ascii    "???"
    .byte     0
L9281:
    .ascii    "."
    .byte     0
L9280:
    .ascii    ")"
    .byte     0
L9279:
    .ascii    ","
    .byte     0
L9278:
    .ascii    "("
    .byte     0
L9277:
    .ascii    ")"
    .byte     0
L9276:
    .ascii    "("
    .byte     0
L9275:
    .ascii    ")"
    .byte     0
L9274:
    .ascii    "("
    .byte     0
L9273:
    .ascii    "&"
    .byte     0
L9272:
    .ascii    "EVAL/C"
    .byte     0
L9271:
    .ascii    "ARRAY"
    .byte     0
L9270:
    .byte     34
    .byte     0
L9269:
    .ascii    "LONGSTR)"
    .byte     0
L9268:
    .ascii    ")"
    .byte     0
L9267:
    .ascii    "-"
    .byte     0
L9266:
    .ascii    "(From"
    .byte     0
L9265:
    .byte     9
    .byte     0
L9264:
    .ascii    ":"
    .byte     0
L9263:
    .ascii    "GLOBAL SYMBOL TABLE:"
    .byte     0
L9262:
    .ascii    "*"
    .byte     0
L9261:
    .ascii    " Code:"
    .byte     0
L9260:
    .ascii    " Mode:"
    .byte     0
L9259:
    .ascii    "Anon"
    .byte     0
L9258:
    .byte     9
    .byte     9
    .ascii    "Param: "
    .byte     0
L9257:
    .ascii    " "
    .byte     0
L9256:
    .ascii    "Lineno:"
    .byte     0
L9255:
    .ascii    " "
    .byte     0
L9254:
    .ascii    "STATIC********"
    .byte     0
L9253:
    .ascii    "="
    .byte     0
L9252:
    .ascii    "Enum:"
    .byte     0
L9251:
    .ascii    "Index:"
    .byte     0
L9250:
    .ascii    " Offset: "
    .byte     0
L9249:
    .ascii    "="
    .byte     0
L9248:
    .ascii    "Offset:"
    .byte     0
L9247:
    .ascii    "Void "
    .byte     0
L9246:
    .ascii    "()"
    .byte     0
L9245:
    .ascii    "(#)"
    .byte     0
L9244:
    .ascii    "]"
    .byte     0
L9243:
    .ascii    "Pm:# "
    .byte     0
L9242:
    .ascii    "Used "
    .byte     0
L9241:
    .ascii    "Var "
    .byte     0
L9240:
    .ascii    " "
    .byte     0
L9239:
    .ascii    "@@"
    .byte     0
L9238:
    .ascii    " "
    .byte     0
L9237:
    .ascii    "["
    .byte     0
L9236:
    .ascii    "."
    .byte     0
L9235:
    .ascii    ":"
    .byte     0
L9234:
    .ascii    "    "
    .byte     0
L9233:
    .ascii    "PRINTST not name"
    .byte     0
L9232:
    .ascii    "z5"
    .byte     0
L9231:
    .ascii    "# "
    .byte     0
L9230:
    .ascii    "."
    .byte     0
L9229:
    .ascii    " "
    .byte     0
L9228:
    .ascii    "|---"
    .byte     0
L9227:
    .ascii    "-----------------------"
    .byte     0
L9226:
    .ascii    "3"
    .byte     0
L9225:
    .ascii    "2"
    .byte     0
L9224:
    .ascii    "1"
    .byte     0
L9223:
    .ascii    " ALENGTH="
    .byte     0
L9222:
    .ascii    " Widen from:"
    .byte     0
L9221:
    .ascii    " Offset:"
    .byte     0
L9220:
    .ascii    " Aparams:"
    .byte     0
L9219:
    .ascii    "Ptrscale:"
    .byte     0
L9218:
    .ascii    "Scale:"
    .byte     0
L9217:
    .ascii    " => "
    .byte     0
L9216:
    .ascii    " "
    .byte     0
L9215:
    .ascii    "<WSTRCONST>"
    .byte     0
L9214:
    .ascii    "<STRCONST>"
    .byte     0
L9213:
    .ascii    " "
    .byte     0
L9212:
    .ascii    "PRINTUNIT BAD CONST"
    .byte     0
L9211:
    .ascii    "PRINTUNIT/CONST/aRRAY"
    .byte     0
L9210:
    .byte     34
    .ascii    " *"
    .byte     0
L9209:
    .ascii    "(WSTRING)"
    .byte     0
L9208:
    .byte     34
    .byte     0
L9207:
    .byte     34
    .ascii    " *"
    .byte     0
L9206:
    .byte     34
    .byte     0
L9205:
    .byte     34
    .ascii    " *"
    .byte     0
L9204:
    .ascii    "(LONGSTR)"
    .byte     0
L9203:
    .byte     34
    .byte     0
L9202:
    .ascii    "Value:"
    .byte     0
L9201:
    .ascii    "1"
    .byte     0
L9200:
    .ascii    " Lastcall:"
    .byte     0
L9199:
    .ascii    " "
    .byte     0
L9198:
    .ascii    "}"
    .byte     0
L9197:
    .ascii    " {"
    .byte     0
L9196:
    .ascii    ": "
    .byte     0
L9194:
    .ascii    "             "
    .byte     0
L9193:
    .ascii    "print unit: bad tag"
    .byte     0
L9192:
    .ascii    "1"
    .byte     0
L9191:
    .ascii    "="
    .byte     0
L9190:
    .ascii    "wb"
    .byte     0
L9189:
    .ascii    "as"
    .byte     0
L9188:
    .ascii    "Writing internal"
    .byte     0
L9187:
    .ascii    "hdr"
    .byte     0
L9186:
    .ascii    " "
    .byte     0
L9185:
    .ascii    "<builtin>"
    .byte     0
L9184:
    .byte     0
L9183:
    .ascii    "Too many source files"
    .byte     0
L9182:
    .ascii    "LSF can't load "
    .byte     0
L9181:
    .byte     0
L9180:
    .ascii    "Too many source files"
    .byte     0
L9179:
    .ascii    "Stopping"
    .byte     0
L9178:
    .ascii    "Load Error:"
    .byte     0
L9177:
    .ascii    "****"
    .byte     0
L9176:
    .ascii    "**** Code Gen Error:"
    .byte     0
L9175:
    .ascii    "in file"
    .byte     0
L9174:
    .ascii    "On line"
    .byte     0
L9173:
    .ascii    " "
    .byte     0
L9172:
    .ascii    "In function"
    .byte     0
L9171:
    .ascii    "on line"
    .byte     0
L9170:
    .ascii    "Type error:"
    .byte     0
L9169:
    .byte     10
    .ascii    "In function"
    .byte     0
L9168:
    .ascii    "****"
    .byte     0
L9167:
    .ascii    "**** Syntax Error:"
    .byte     0
L9166:
    .ascii    "in file"
    .byte     0
L9165:
    .ascii    "On line"
    .byte     0
L9164:
    .ascii    "OUTSIDE PROC"
    .byte     0
L9163:
    .ascii    " "
    .byte     0
L9162:
    .byte     10
    .ascii    "In function"
    .byte     0
L9161:
    .byte     10
    .ascii    "MC Error:"
    .byte     0
L9160:
    .ascii    "w"
    .byte     0
L9159:
    .ascii    "$error.tmp"
    .byte     0
L9158:
    .ascii    "ATL ERROR"
    .byte     0
L9157:
    .ascii    "rb"
    .byte     0
L9156:
    .ascii    "w"
    .byte     0
L9155:
    .ascii    "GETALIGN SIZE NOT 1248"
    .byte     0
L9154:
    .ascii    "Dupl proc name"
    .byte     0
L9153:
    .ascii    "in"
    .byte     0
L9152:
    .byte     34
    .byte     0
L9151:
    .ascii    " "
    .byte     34
    .byte     0
L9150:
    .ascii    "# expected, not #"
    .byte     0
L9149:
    .ascii    "Too many types/cnm"
    .byte     0
L9148:
    .ascii    "STRMODE(M)="
    .byte     0
L9147:
    .ascii    "Too many types"
    .byte     0
L9146:
    .byte     0
L9145:
    .ascii    "const "
    .byte     0
L9144:
    .ascii    "<enum>"
    .byte     0
L9143:
    .ascii    "<array>"
    .byte     0
L9142:
    .ascii    "."
    .byte     0
L9141:
    .ascii    "union "
    .byte     0
L9140:
    .ascii    "struct "
    .byte     0
L9139:
    .ascii    "NEWSTRMODE"
    .byte     0
L9138:
    .ascii    ")"
    .byte     0
L9137:
    .ascii    ","
    .byte     0
L9136:
    .ascii    "proc("
    .byte     0
L9135:
    .ascii    ")"
    .byte     0
L9134:
    .ascii    " "
    .byte     0
L9133:
    .ascii    ","
    .byte     0
L9132:
    .ascii    "("
    .byte     0
L9131:
    .ascii    "enum "
    .byte     0
L9130:
    .ascii    "[]"
    .byte     0
L9129:
    .ascii    "[#]"
    .byte     0
L9128:
    .ascii    "ref "
    .byte     0
L9127:
    .ascii    "const ref "
    .byte     0
L9126:
    .ascii    "z3"
    .byte     0
L9125:
    .byte     92
    .ascii    "#o"
    .byte     0
L9124:
    .ascii    "$F"
    .byte     0
L9123:
    .ascii    "$T"
    .byte     0
L9122:
    .ascii    "GCV Not constant"
    .byte     0
L9121:
    .ascii    "Can't find -to version"
    .byte     0
L9120:
    .ascii    "to"
    .byte     0
L9118:
    .ascii    "main"
    .byte     0
L9117:
    .ascii    "."
    .byte     0
L9116:
    .ascii    "Dupl case value: #"
    .byte     0
L9115:
    .ascii    "Too many cases on one switch"
    .byte     0
L9114:
    .ascii    "case: serial switch not found"
    .byte     0
L9113:
    .ascii    "Label not defined: #"
    .byte     0
L9112:
    .ascii    "maxparams"
    .byte     0
L9111:
    .ascii    "Convert op not implem: #"
    .byte     0
L9110:
    .ascii    "Bad cast"
    .byte     0
L9109:
    .ascii    "DOASSIGN not ready: #"
    .byte     0
L9108:
    .ascii    "dxname"
    .byte     0
L9107:
    .ascii    "const?"
    .byte     0
L9106:
    .ascii    "CONST/WSTRING"
    .byte     0
L9105:
    .ascii    "DX-EXPR: can't do tag: #"
    .byte     0
L9104:
    .ascii    "2:Runtime expr in static data"
    .byte     0
L9103:
    .ascii    "*"
    .byte     0
L9102:
    .ascii    "Complex ptr expr in static data"
    .byte     0
L9101:
    .ascii    "1:Runtime or unsupported expr in static data"
    .byte     0
L9100:
    .ascii    "+"
    .byte     0
L9099:
    .ascii    "Add/Idata &frame"
    .byte     0
L9098:
    .ascii    "+"
    .byte     0
L9097:
    .ascii    ","
    .byte     0
L9096:
    .ascii    "`"
    .byte     0
L9095:
    .ascii    "Idata &frame"
    .byte     0
L9094:
    .ascii    "IDATA/SCALAR"
    .byte     0
L9093:
    .ascii    "GENIDATA/WSTRING2"
    .byte     0
L9092:
    .ascii    "$#.#.#"
    .byte     0
L9091:
    .byte     0
L9090:
    .ascii    "------------------------"
    .byte     0
L9089:
    .ascii    "main"
    .byte     0
L9088:
    .byte     0
L9087:
    .ascii    "Static fn not defined: #"
    .byte     0
L9086:
    .ascii    "1:Start of code"
    .byte     0
L9085:
    .ascii    "GenPCL:"
    .byte     0
L9084:
    .ascii    "Generic: multiple types match"
    .byte     0
L9083:
    .ascii    "Generic: no type match"
    .byte     0
L9082:
    .ascii    "generic/default twice"
    .byte     0
L9081:
    .ascii    "Not array"
    .byte     0
L9080:
    .ascii    "*"
    .byte     0
L9079:
    .ascii    "Can't do conversion # => #"
    .byte     0
L9078:
    .ascii    "*"
    .byte     0
L9077:
    .ascii    "case not inside switch stmt"
    .byte     0
L9076:
    .ascii    "poploop?"
    .byte     0
L9075:
    .ascii    "Too many nested loop or switch"
    .byte     0
L9074:
    .ascii    "Not allowed on ptrs"
    .byte     0
L9073:
    .ascii    "-= refs don't match"
    .byte     0
L9072:
    .ascii    "ptr+=ptr"
    .byte     0
L9071:
    .ascii    "Not a field of struct # #"
    .byte     0
L9070:
    .ascii    ". -> not a struct"
    .byte     0
L9069:
    .ascii    "-> needs pointer"
    .byte     0
L9068:
    .ascii    "enum name reused #"
    .byte     0
L9067:
    .ascii    "Redefining enum #"
    .byte     0
L9066:
    .ascii    "Enum tag in use #"
    .byte     0
L9065:
    .ascii    "BAD REF[]"
    .byte     0
L9064:
    .ascii    "const to non-const pointer"
    .byte     0
L9063:
    .ascii    "Struct decl error #"
    .byte     0
L9062:
    .ascii    "Struct decl error"
    .byte     0
L9061:
    .ascii    "Can't use ss in struct"
    .byte     0
L9060:
    .ascii    "member name in use #"
    .byte     0
L9059:
    .ascii    "typedef or function inside struct"
    .byte     0
L9058:
    .ascii    "Field name expected"
    .byte     0
L9057:
    .ascii    "Redefining struct #"
    .byte     0
L9056:
    .ascii    "Prev"
    .byte     0
L9055:
    .ascii    "Struct tag in use #"
    .byte     0
L9054:
    .ascii    "ATP?"
    .byte     0
L9053:
    .ascii    "*"
    .byte     0
L9052:
    .ascii    "ATP:"
    .byte     0
L9051:
    .ascii    "Variadic param is void"
    .byte     0
L9050:
    .ascii    "Too many args"
    .byte     0
L9049:
    .ascii    "1:Too few args"
    .byte     0
L9048:
    .ascii    "ccall?"
    .byte     0
L9047:
    .ascii    "*"
    .byte     0
L9046:
    .ascii    "JTAGNAMES[P.TAG]="
    .byte     0
L9045:
    .ascii    "Not function pointer: #"
    .byte     0
L9044:
    .ascii    "value: #"
    .byte     0
L9043:
    .ascii    "*"
    .byte     0
L9042:
    .ascii    "CHECKLV/WIDEN"
    .byte     0
L9040:
    .ascii    "Invalid condition #"
    .byte     0
L9039:
    .ascii    "rem 0"
    .byte     0
L9038:
    .ascii    "div 0"
    .byte     0
L9037:
    .ascii    "EVALSUB/REF"
    .byte     0
L9035:
    .ascii    "Rem bad types"
    .byte     0
L9033:
    .ascii    "Div bad types"
    .byte     0
L9032:
    .ascii    "Mul bad types"
    .byte     0
L9031:
    .ascii    "Sub bad types"
    .byte     0
L9030:
    .ascii    "++ bad type"
    .byte     0
L9029:
    .ascii    "* not pointer"
    .byte     0
L9028:
    .ascii    "*"
    .byte     0
L9027:
    .ascii    "! bad type"
    .byte     0
L9026:
    .ascii    "abs bad type"
    .byte     0
L9024:
    .ascii    "neg bad type"
    .byte     0
L9022:
    .ascii    "; after function def"
    .byte     0
L9021:
    .ascii    "Can't define function twice #"
    .byte     0
L9020:
    .ascii    "fn: name in use #"
    .byte     0
L9019:
    .ascii    "NAME not allowed in cast type #"
    .byte     0
L9018:
    .ascii    "bad symbol in paramlist"
    .byte     0
L9017:
    .ascii    "Param name reused # #"
    .byte     0
L9016:
    .ascii    "Param type missing or misspelt"
    .byte     0
L9015:
    .ascii    "Typedef redefined or can't match types #"
    .byte     0
L9014:
    .ascii    "Typedef name in use #"
    .byte     0
L9013:
    .ascii    "Local decl error #"
    .byte     0
L9012:
    .ascii    "Nested function"
    .byte     0
L9011:
    .ascii    "Var name expected"
    .byte     0
L9010:
    .ascii    "Return value needed"
    .byte     0
L9009:
    .ascii    "Can't return value in void function"
    .byte     0
L9008:
    .ascii    "For decl error"
    .byte     0
L9007:
    .ascii    "Not allowed in for stmt"
    .byte     0
L9006:
    .ascii    "Var name expected"
    .byte     0
L9004:
    .ascii    "2:Duplicate label"
    .byte     0
L9003:
    .ascii    "continue outside loop"
    .byte     0
L9002:
    .ascii    "break outside loop/sw"
    .byte     0
L9001:
    .ascii    "{...} statement expected"
    .byte     0
L9000:
    .ascii    "Too many blocks"
    .byte     0
L8999:
    .ascii    "Too many block levels"
    .byte     0
L8998:
    .ascii    "Init str too long"
    .byte     0
L8997:
    .ascii    "Array init"
    .byte     0
L8996:
    .ascii    "{} initialiser expected"
    .byte     0
L8995:
    .ascii    "Too many struct elems"
    .byte     0
L8994:
    .ascii    "Too many array elems"
    .byte     0
L8993:
    .ascii    "init/Empty struct"
    .byte     0
L8992:
    .ascii    "init/0-size array"
    .byte     0
L8991:
    .ascii    "readconstint #"
    .byte     0
L8990:
    .ascii    "Negative array dim"
    .byte     0
L8989:
    .ascii    "ZERO LEN ARRAY"
    .byte     0
L8988:
    .ascii    "Can't do VLAs"
    .byte     0
L8987:
    .ascii    "rnt1"
    .byte     0
L8986:
    .ascii    "Can't init extern #"
    .byte     0
L8985:
    .ascii    "Can't init twice #"
    .byte     0
L8984:
    .ascii    "var: name in use #"
    .byte     0
L8983:
    .ascii    "Can't init extern #"
    .byte     0
L8982:
    .ascii    "Can't init twice #"
    .byte     0
L8981:
    .ascii    "var: redefining #"
    .byte     0
L8980:
    .ascii    "var: name in use # #"
    .byte     0
L8979:
    .ascii    "Readterm?"
    .byte     0
L8978:
    .ascii    "RT"
    .byte     0
L8977:
    .ascii    "rt/alignof"
    .byte     0
L8976:
    .ascii    "rt/compound lit"
    .byte     0
L8975:
    .ascii    "rt/&&label"
    .byte     0
L8974:
    .ascii    "char const too long"
    .byte     0
L8973:
    .ascii    "Undefined name "
    .byte     34
    .ascii    "#"
    .byte     34
    .byte     0
L8972:
    .ascii    "shift:Not an int"
    .byte     0
L8971:
    .ascii    "invalid rel operands"
    .byte     0
L8970:
    .ascii    "Comparing distinct pointers/rel"
    .byte     0
L8969:
    .ascii    "invalid == operands"
    .byte     0
L8968:
    .ascii    "U="
    .byte     0
L8967:
    .ascii    "Can't compare pointer to int2"
    .byte     0
L8966:
    .ascii    "Can't compare pointer to int"
    .byte     0
L8965:
    .ascii    "Comparing distinct pointers/eq"
    .byte     0
L8964:
    .ascii    "invalid & operands"
    .byte     0
L8963:
    .ascii    "float&float"
    .byte     0
L8962:
    .ascii    "invalid ^ operands"
    .byte     0
L8961:
    .ascii    "float^float"
    .byte     0
L8960:
    .ascii    "invalid | operands"
    .byte     0
L8959:
    .ascii    "float|float"
    .byte     0
L8958:
    .ascii    "?: incompatible types"
    .byte     0
L8957:
    .ascii    "Modifying constant?"
    .byte     0
L8956:
    .ascii    "Modifying read-only var"
    .byte     0
L8955:
    .ascii    "declspec/float"
    .byte     0
L8954:
    .ascii    "dbl decl?"
    .byte     0
L8953:
    .ascii    "char decl?"
    .byte     0
L8952:
    .ascii    "Implicit decls not allowed: #"
    .byte     0
L8951:
    .ascii    "enum?"
    .byte     0
L8950:
    .ascii    "struct?"
    .byte     0
L8949:
    .ascii    "Dual storage spec"
    .byte     0
L8948:
    .ascii    "declspec/ts #"
    .byte     0
L8947:
    .ascii    "PARSETEST"
    .byte     0
L8946:
    .ascii    "Parsing:"
    .byte     0
L8945:
    .ascii    "Decl error #"
    .byte     0
L8944:
    .ascii    "fn def after comma"
    .byte     0
L8943:
    .ascii    "Var name expected"
    .byte     0
L8942:
    .ascii    "Extra semicolon 2"
    .byte     0
L8931:
    .ascii    "Real too long"
    .byte     0
L8930:
    .ascii    "REGENHST FULL?"
    .byte     0
L8929:
    .ascii    "regenhst dupl?"
    .byte     0
L8928:
    .ascii    "mcc.h"
    .byte     0
L8927:
    .ascii    "TMLM"
    .byte     0
L8926:
    .ascii    "TMH"
    .byte     0
L8925:
    .ascii    "TMM"
    .byte     0
L8924:
    .ascii    "Str expected"
    .byte     0
L8923:
    .ascii    "link"
    .byte     0
L8922:
    .ascii    "header"
    .byte     0
L8921:
    .ascii    "module"
    .byte     0
L8920:
    .ascii    "Only pack(1) or () allowed"
    .byte     0
L8919:
    .ascii    "'(' expected"
    .byte     0
L8918:
    .ascii    "pack"
    .byte     0
L8917:
    .ascii    "2:Too many pasted tokens"
    .byte     0
L8916:
    .ascii    "PDM"
    .byte     0
L8915:
    .ascii    "???"
    .byte     0
L8914:
    .ascii    "(File not available)"
    .byte     0
L8913:
    .ascii    "z2"
    .byte     0
L8912:
    .ascii    "2"
    .byte     0
L8911:
    .ascii    "#:#:#"
    .byte     0
L8910:
    .ascii    "4"
    .byte     0
L8909:
    .ascii    "#-#-#"
    .byte     0
L8908:
    .ascii    "#if:Unexpected eof"
    .byte     0
L8907:
    .ascii    "EOL expected"
    .byte     0
L8906:
    .ascii    "Name expected"
    .byte     0
L8905:
    .ascii    "evalterm?"
    .byte     0
L8904:
    .ascii    ") expected"
    .byte     0
L8903:
    .ascii    "')' expected"
    .byte     0
L8902:
    .ascii    "sizeof2"
    .byte     0
L8901:
    .ascii    "name expected"
    .byte     0
L8900:
    .ascii    "'(' expected"
    .byte     0
L8899:
    .ascii    "')' expected"
    .byte     0
L8898:
    .ascii    "defined?"
    .byte     0
L8897:
    .ascii    "#if:div by zero"
    .byte     0
L8896:
    .ascii    ": expected"
    .byte     0
L8895:
    .ascii    "#if:eol expected"
    .byte     0
L8894:
    .ascii    "Too many pasted tokens"
    .byte     0
L8893:
    .ascii    ".*"
    .byte     0
L8892:
    .ascii    "v"
    .byte     0
L8891:
    .byte     0
L8890:
    .byte     10
    .byte     0
L8889:
    .ascii    "Too many ##"
    .byte     0
L8888:
    .ascii    "## at start"
    .byte     0
L8887:
    .ascii    "# not followed by param"
    .byte     0
L8886:
    .ascii    "# at end"
    .byte     0
L8885:
    .ascii    "Wrong # macro params"
    .byte     0
L8884:
    .ascii    "EOS in macro call"
    .byte     0
L8883:
    .ascii    "rmc: ')' expected"
    .byte     0
L8882:
    .ascii    "rmc: no '('"
    .byte     0
L8881:
    .ascii    ">"
    .byte     0
L8880:
    .ascii    "<"
    .byte     0
L8879:
    .ascii    "macro params?"
    .byte     0
L8878:
    .ascii    "')' expected"
    .byte     0
L8877:
    .ascii    "__VA_ARGS__"
    .byte     0
L8876:
    .ascii    "Dupl macro param"
    .byte     0
L8875:
    .ascii    "define: name expected"
    .byte     0
L8874:
    .ascii    "Local str too long"
    .byte     0
L8873:
    .ascii    "String not terminated"
    .byte     0
L8872:
    .ascii    "NEXTLX.LINENO="
    .byte     0
L8871:
    .ascii    "#define __attribute__(x)"
    .byte     10
    .ascii    "#define _WIN32"
    .byte     10
    .ascii    "#define WIN32"
    .byte     10
    .ascii    "#define __WIN32__"
    .byte     10
    .ascii    "#define __inline"
    .byte     10
    .ascii    "#define __dllimport(x)"
    .byte     10
    .ascii    "#define __declspec(x)"
    .byte     10
    .ascii    "#define __stdcall"
    .byte     10
    .ascii    "#define CALLBACK $callback"
    .byte     10
    .ascii    "#define __cdecl"
    .byte     10
    .ascii    "#define EXTERN_C extern"
    .byte     10
    .ascii    "#define DECLSPEC_IMPORT"
    .byte     10
    .ascii    "#define __32BIT__"
    .byte     10
    .ascii    "#define register"
    .byte     10
    .ascii    "#define __MCCC__"
    .byte     10
    .byte     10
    .ascii    "typedef signed char"
    .byte     9
    .byte     9
    .ascii    "i8;"
    .byte     10
    .ascii    "typedef short"
    .byte     9
    .byte     9
    .byte     9
    .ascii    "i16;"
    .byte     10
    .ascii    "typedef int"
    .byte     9
    .byte     9
    .byte     9
    .byte     9
    .ascii    "i32;"
    .byte     10
    .ascii    "typedef long long int"
    .byte     9
    .ascii    "i64;"
    .byte     10
    .ascii    "typedef unsigned char"
    .byte     9
    .byte     9
    .byte     9
    .ascii    "u8;"
    .byte     10
    .ascii    "typedef unsigned short"
    .byte     9
    .byte     9
    .byte     9
    .ascii    "u16;"
    .byte     10
    .ascii    "typedef unsigned int"
    .byte     9
    .byte     9
    .byte     9
    .ascii    "u32;"
    .byte     10
    .ascii    "typedef unsigned long long int"
    .byte     9
    .ascii    "u64;"
    .byte     10
    .byte     10
    .ascii    "typedef unsigned char byte;"
    .byte     10
    .byte     10
    .ascii    "typedef float r32;"
    .byte     10
    .ascii    "typedef double r64;"
    .byte     10
    .byte     10
    .byte     0
L8870:
    .ascii    "mcc.h"
    .byte     0
L8869:
    .ascii    "Too many nested includes"
    .byte     0
L8868:
    .ascii    "Can't find include file"
    .byte     0
L8867:
    .ascii    "Overflow in decimal number"
    .byte     0
L8866:
    .ascii    "18446744073709551615"
    .byte     0
L8865:
    .ascii    "-U?"
    .byte     0
L8864:
    .ascii    "-LL?"
    .byte     0
L8863:
    .ascii    "Overflow in octal number"
    .byte     0
L8862:
    .ascii    "1777777777777777777777"
    .byte     0
L8861:
    .ascii    "-U?"
    .byte     0
L8860:
    .ascii    "-LL?"
    .byte     0
L8859:
    .ascii    "Overflow in binary number"
    .byte     0
L8858:
    .ascii    "Binary fp"
    .byte     0
L8857:
    .ascii    "Binary bad digit"
    .byte     0
L8856:
    .ascii    "Overflow in hex number"
    .byte     0
L8855:
    .ascii    "-U?"
    .byte     0
L8854:
    .ascii    "-LL?"
    .byte     0
L8853:
    .ascii    "block comment eof"
    .byte     0
L8852:
    .ascii    ":##"
    .byte     0
L8851:
    .ascii    ":::"
    .byte     0
L8850:
    .ascii    "#endif missing"
    .byte     0
L8849:
    .ascii    "Directive not implemented"
    .byte     0
L8848:
    .ascii    "DIRECTIVE NOT IMPL:"
    .byte     0
L8847:
    .ascii    "ABORTING"
    .byte     0
L8846:
    .ascii    "#ERROR:"
    .byte     0
L8845:
    .ascii    "#if missing/endif"
    .byte     0
L8844:
    .ascii    "#if missing/elif/else"
    .byte     0
L8843:
    .ascii    "undef: name expected"
    .byte     0
L8842:
    .ascii    "NSOURCEFILES="
    .byte     0
L8841:
    .ascii    "FROM"
    .byte     0
L8840:
    .ascii    "INCLUDE"
    .byte     0
L8839:
    .ascii    "include?"
    .byte     0
L8838:
    .ascii    "include: > expected"
    .byte     0
L8837:
    .ascii    "Bad include file"
    .byte     0
L8836:
    .ascii    "Invalid # directive"
    .byte     0
L8835:
    .ascii    "Duplicate symbol table entry"
    .byte     0
L8834:
    .ascii    "HASHTABLE FULL"
    .byte     0
L8833:
    .ascii    "Digit out of range"
    .byte     0
L8832:
    .ascii    ".*"
    .byte     0
L8831:
    .ascii    "v"
    .byte     0
L8830:
    .ascii    ".*"
    .byte     0
L8829:
    .ascii    "v"
    .byte     0
L8828:
    .ascii    "#"
    .byte     0
L8827:
    .ascii    "'"
    .byte     0
L8826:
    .byte     34
    .byte     0
L8825:
    .ascii    " "
    .byte     0
L8824:
    .ascii    "%-18s"
    .byte     0
L8823:
    .ascii    "Line:"
    .byte     0
L8822:
    .ascii    "in:"
    .byte     0
L8821:
    .byte     10
    .ascii    "Lex error"
    .byte     0
L8820:
    .ascii    "Non-base-10 floats temporarily unavailable"
    .byte     0
L8819:
    .ascii    "p"
    .byte     0
L8818:
    .ascii    "e"
    .byte     0
L8816:
    .ascii    "Real too long"
    .byte     0
L8815:
    .ascii    "ERROR CHAR"
    .byte     0
L8814:
    .ascii    "@ SEEN"
    .byte     0
L8813:
    .ascii    "wb"
    .byte     0
L8812:
    .ascii    "#endif missing"
    .byte     0
L8811:
    .ascii    "mcc.h"
    .byte     0
L8810:
    .ascii    "00:35:54"
    .byte     0
L8809:
    .ascii    "28-Sep-2025"
    .byte     0
L8808:
    .ascii    "CC C Compiler"
    .byte     0
L8807:
    .ascii    "C Subset Compiler for 64-bit Windows"
    .byte     10
    .byte     10
    .ascii    "Normal use:           Compiles prog.c to:"
    .byte     10
    .byte     10
    .ascii    "    cc      prog      prog.exe (default)"
    .byte     10
    .ascii    "    cc -r   prog      in-memory native code then execute"
    .byte     10
    .ascii    "    cc -i   prog      in-memory IL then interpret"
    .byte     10
    .byte     10
    .ascii    "    cc -exe prog      prog.exe"
    .byte     10
    .ascii    "    cc -dll prog      prog.dll"
    .byte     10
    .ascii    "    cc -obj prog      prog.obj"
    .byte     10
    .ascii    "    cc -a   prog      prog.asm"
    .byte     10
    .ascii    "    cc -n   prog      prog.nasm"
    .byte     10
    .ascii    "    cc -mx  prog      prog.mx"
    .byte     10
    .ascii    "    cc -p   prog      prog.pcl (textual IL)"
    .byte     10
    .ascii    "    cc -e   prog      prog.i   (preprocess only)"
    .byte     10
    .byte     10
    .ascii    "Other options:"
    .byte     10
    .byte     10
    .ascii    "    -incl:path        Add path to search for includes"
    .byte     10
    .ascii    "    -ext              Used std headers external to compiler"
    .byte     10
    .ascii    "    -opt              Optimise native code"
    .byte     10
    .ascii    "    -out:file         Name output file (extension can be added)"
    .byte     10
    .ascii    "    -rip              Use RIP address modes"
    .byte     10
    .ascii    "    -himem            Generate PIC code (automatic with -obj/-dll)"
    .byte     10
    .ascii    "    @file             Read files and options from a file"
    .byte     10
    .ascii    "    file.dll          Include one or more extra dynamic libs"
    .byte     10
    .ascii    "    -c                Same as -obj"
    .byte     10
    .ascii    "    -s                Same as -asm"
    .byte     10
    .ascii    "    -ei               Same as -e, but when result is interpreted"
    .byte     10
    .byte     10
    .ascii    "Notes:"
    .byte     10
    .byte     10
    .ascii    "    * Compiles single module only (use bcc driver program for multiple-modules)"
    .byte     10
    .ascii    "    * For -i and -r, options and any .dlls must appear before the C source file"
    .byte     10
    .ascii    "    * .c extension is optional on input file"
    .byte     10
    .byte     0
L8806:
    .ascii    "Include paths"
    .byte     0
L8805:
    .ascii    "/"
    .byte     0
L8804:
    .byte     0
L8803:
    .ascii    "Too many include paths"
    .byte     0
L8802:
    .byte     0
L8801:
    .ascii    "-RUNP OUT OF ORDER"
    .byte     0
L8800:
    .ascii    "-help                Show all options"
    .byte     0
L8799:
    .ascii    "    "
    .byte     0
L8798:
    .ascii    "-i prog[.c]          Compile prog.c and interpret"
    .byte     0
L8797:
    .ascii    "    "
    .byte     0
L8796:
    .ascii    "-r prog[.c]          Compile prog.c and run"
    .byte     0
L8795:
    .ascii    "    "
    .byte     0
L8794:
    .ascii    "   prog[.c]          Compile prog.c to prog.exe"
    .byte     0
L8793:
    .ascii    "    "
    .byte     0
L8792:
    .ascii    "Usage:"
    .byte     0
L8791:
    .byte     0
L8790:
    .ascii    "Too many lib files"
    .byte     0
L8789:
    .byte     0
L8788:
    .ascii    "One input file only"
    .byte     0
L8787:
    .ascii    "Unknown option:"
    .byte     0
L8786:
    .ascii    ".c"
    .byte     0
L8785:
    .byte     0
L8784:
    .ascii    "cs.exe"
    .byte     0
L8783:
    .ascii    "Total:"
    .byte     0
L8782:
    .ascii    "-----------------------------"
    .byte     0
L8781:
    .ascii    "EXE:"
    .byte     0
L8780:
    .ascii    "SS:"
    .byte     0
L8779:
    .ascii    "MCL:"
    .byte     0
L8778:
    .ascii    "PCL:"
    .byte     0
L8777:
    .ascii    "Parse:"
    .byte     0
L8776:
    .ascii    "Load:"
    .byte     0
L8775:
    .ascii    "Init:"
    .byte     0
L8774:
    .ascii    "5.1jr"
    .byte     0
L8772:
    .ascii    "5"
    .byte     0
L8771:
    .ascii    "12jl"
    .byte     0
L8770:
    .ascii    "# # ms # %"
    .byte     0
L8769:
    .ascii    "Size:"
    .byte     0
L8768:
    .ascii    ":"
    .byte     0
L8767:
    .ascii    "Sourcefiles:"
    .byte     0
L8766:
    .ascii    "PROC"
    .byte     0
L8765:
    .ascii    "PROC AST"
    .byte     0
L8764:
    .ascii    ": ."
    .byte     0
L8763:
    .ascii    ":"
    .byte     0
L8762:
    .ascii    "0: Internal standard headers (disable with -ext)"
    .byte     0
L8761:
    .ascii    "Include search paths:"
    .byte     0
L8760:
    .ascii    "c:/cx/headers/"
    .byte     0
L8759:
    .byte     0
L8758:
    .ascii    "<line>"
    .byte     0
L8757:
    .ascii    "kernel32"
    .byte     0
L8756:
    .ascii    "user32"
    .byte     0
L8755:
    .ascii    "gdi32"
    .byte     0
L8754:
    .ascii    "msvcrt"
    .byte     0
L8753:
    .ascii    "mcc.log"
    .byte     0
L8752:
    .ascii    "Diagnostic outputs written to"
    .byte     0
L8751:
    .ascii    "mcc.log"
    .byte     0
L8750:
    .byte     92
    .ascii    "m"
    .byte     92
    .ascii    "scripts"
    .byte     92
    .ascii    "med.bat "
    .byte     0
L8749:
    .ascii    "PRESS KEY"
    .byte     0
L8748:
    .ascii    "cc.m"
    .byte     0
L8747:
    .ascii    "STFLAT"
    .byte     0
L8746:
    .ascii    "ST"
    .byte     0
L8745:
    .ascii    "PSYMTAB"
    .byte     0
L8744:
    .ascii    "!PROC PCL"
    .byte     0
L8743:
    .ascii    "PROC ASM"
    .byte     0
L8742:
    .ascii    "w"
    .byte     0
L8741:
    .ascii    "mcc.log"
    .byte     0
L8740:
    .ascii    "Can't load main module: #"
    .byte     0
L8739:
    .ascii    "$prog"
    .byte     0
L8738:
    .ascii    "<sourcefile0>"
    .byte     0
L8737:
    .ascii    "<dummy path>"
    .byte     0
L8736:
    .ascii    "<dummy file>"
    .byte     0
L8735:
    .ascii    "Loading:"
    .byte     0
L8734:
    .ascii    "Done."
    .byte     0
L8733:
    .ascii    "not ready"
    .byte     0
L8732:
    .ascii    "Compiling # to #"
    .byte     0
L8731:
    .ascii    "No Run"
    .byte     0
L8730:
    .byte     0
L8729:
    .ascii    "qword ptr"
    .byte     0
L8728:
    .ascii    "dword ptr"
    .byte     0
L8727:
    .ascii    "word ptr"
    .byte     0
L8726:
    .ascii    "byte ptr"
    .byte     0
L8725:
    .byte     0
L8724:
    .ascii    "%"
    .byte     0
L8723:
    .ascii    "#.$T#"
    .byte     0
L8722:
    .ascii    "T"
    .byte     0
L8721:
    .ascii    "%XMM"
    .byte     0
L8720:
    .ascii    "-"
    .byte     0
L8719:
    .byte     0
L8718:
    .ascii    "Stropnd?"
    .byte     0
L8717:
    .ascii    "L"
    .byte     0
L8716:
    .byte     34
    .byte     0
L8715:
    .ascii    "M"
    .byte     0
L8714:
    .ascii    "20.20"
    .byte     0
L8713:
    .byte     0
L8712:
    .ascii    "+"
    .byte     0
L8711:
    .byte     0
L8710:
    .ascii    "<BAD OPND>"
    .byte     0
L8709:
    .ascii    "BAD OPND"
    .byte     0
L8708:
    .ascii    "]"
    .byte     0
L8707:
    .ascii    " + "
    .byte     0
L8706:
    .ascii    "%rip+"
    .byte     0
L8705:
    .ascii    "*"
    .byte     0
L8704:
    .ascii    " + "
    .byte     0
L8703:
    .byte     0
L8702:
    .ascii    "["
    .byte     0
L8701:
    .ascii    "H"
    .byte     0
L8700:
    .ascii    "0x"
    .byte     0
L8699:
    .ascii    ","
    .byte     0
L8698:
    .ascii    ","
    .byte     9
    .byte     0
L8697:
    .ascii    " "
    .byte     0
L8696:
    .ascii    "  "
    .byte     0
L8695:
    .ascii    " "
    .byte     0
L8694:
    .ascii    ".ascii"
    .byte     0
L8693:
    .ascii    ".quad"
    .byte     0
L8692:
    .ascii    ".long"
    .byte     0
L8691:
    .ascii    ".word"
    .byte     0
L8690:
    .ascii    ".byte"
    .byte     0
L8689:
    .ascii    ".space"
    .byte     0
L8688:
    .ascii    ".align"
    .byte     0
L8687:
    .ascii    "movsxd"
    .byte     0
L8686:
    .ascii    "imul"
    .byte     0
L8685:
    .ascii    "not"
    .byte     0
L8684:
    .ascii    "xor"
    .byte     0
L8683:
    .ascii    "or"
    .byte     0
L8682:
    .ascii    "and"
    .byte     0
L8681:
    .ascii    "cmov"
    .byte     0
L8680:
    .ascii    "set"
    .byte     0
L8679:
    .ascii    "j"
    .byte     0
L8678:
    .ascii    "    .bss"
    .byte     0
L8677:
    .ascii    "    .data"
    .byte     0
L8676:
    .ascii    "    .text"
    .byte     0
L8675:
    .ascii    ", "
    .byte     0
L8674:
    .ascii    "    .set "
    .byte     0
L8673:
    .ascii    "L#:"
    .byte     0
L8672:
    .ascii    ":"
    .byte     0
L8671:
    .byte     10
    .byte     0
L8670:
    .ascii    ":"
    .byte     0
L8669:
    .byte     0
L8668:
    .ascii    "strmcl/lab"
    .byte     0
L8667:
    .ascii    "# End "
    .byte     0
L8666:
    .ascii    "# Proc "
    .byte     0
L8665:
    .byte     10
    .byte     0
L8664:
    .ascii    "    .global "
    .byte     0
L8663:
    .byte     10
    .byte     0
L8662:
    .ascii    "    .intel_syntax prefix"
    .byte     10
    .byte     0
L8661:
    .ascii    "# GAS VERSION"
    .byte     10
    .byte     0
L8660:
    .byte     0
L8659:
    .ascii    "delmcl?"
    .byte     0
L8658:
    .ascii    " ncalldepth:"
    .byte     0
L8657:
    .ascii    " noperands:"
    .byte     0
L8656:
    .ascii    ") hwstack:"
    .byte     0
L8655:
    .ascii    "0 "
    .byte     0
L8654:
    .ascii    "1 "
    .byte     0
L8653:
    .ascii    "XWR:("
    .byte     0
L8652:
    .ascii    ") "
    .byte     0
L8651:
    .ascii    "0 "
    .byte     0
L8650:
    .ascii    "1 "
    .byte     0
L8649:
    .ascii    "WR:("
    .byte     0
L8648:
    .ascii    " "
    .byte     0
L8647:
    .ascii    ") "
    .byte     0
L8646:
    .ascii    ", "
    .byte     0
L8645:
    .ascii    ">"
    .byte     0
L8644:
    .ascii    "<"
    .byte     0
L8643:
    .ascii    "@"
    .byte     0
L8642:
    .ascii    ")"
    .byte     0
L8641:
    .ascii    "(=="
    .byte     0
L8640:
    .ascii    "T"
    .byte     0
L8639:
    .ascii    "*"
    .byte     0
L8638:
    .byte     0
L8637:
    .ascii    "W:"
    .byte     0
L8636:
    .ascii    "X:"
    .byte     0
L8635:
    .ascii    "Y:"
    .byte     0
L8634:
    .ascii    "Z:"
    .byte     0
L8633:
    .ascii    "#:("
    .byte     0
L8632:
    .ascii    "========================================#:("
    .byte     0
L8631:
    .byte     0
L8630:
    .ascii    "MSA"
    .byte     0
L8629:
    .byte     0
L8628:
    .ascii    "makeopndind"
    .byte     0
L8627:
    .byte     0
L8626:
    .ascii    "SOR1"
    .byte     0
L8625:
    .byte     0
L8624:
    .ascii    "MOVE TO REG: XREG IN USE"
    .byte     0
L8623:
    .byte     0
L8622:
    .ascii    "No more work xregs"
    .byte     0
L8621:
    .byte     0
L8620:
    .ascii    "No more work regs"
    .byte     0
L8619:
    .byte     0
L8618:
    .ascii    "poppcl/underflow"
    .byte     0
L8617:
    .byte     0
L8616:
    .ascii    "PCL stack overflow"
    .byte     0
L8615:
    .byte     0
L8614:
    .ascii    "PCL stack overflow"
    .byte     0
L8613:
    .ascii    "getopnd"
    .byte     0
L8612:
    .byte     0
L8611:
    .ascii    "Ext nametab overflow"
    .byte     0
L8610:
    .ascii    "$B#"
    .byte     0
L8609:
    .byte     0
L8608:
    .ascii    "Too many block temps"
    .byte     0
L8607:
    .ascii    "Line:"
    .byte     0
L8606:
    .ascii    "AX ERROR:"
    .byte     0
L8605:
    .ascii    "MCL Opnd not supported: # (#) [#]"
    .byte     0
L8604:
    .byte     0
L8603:
    .ascii    "2:SIZE=0"
    .byte     0
L8602:
    .byte     0
L8601:
    .ascii    "1:SIZE=0"
    .byte     0
L8600:
    .byte     0
L8599:
    .ascii    "BAD SEG CODE"
    .byte     0
L8598:
    .byte     0
L8597:
    .ascii    "CAN'T DO RODATA SEG"
    .byte     0
L8596:
    .ascii    "MCLREC>64B"
    .byte     0
L8595:
    .ascii    "__getmainargs*"
    .byte     0
L8594:
    .ascii    "$info"
    .byte     0
L8593:
    .ascii    "$env"
    .byte     0
L8592:
    .ascii    "()"
    .byte     0
L8591:
    .ascii    "High block arg not copied in"
    .byte     0
L8590:
    .ascii    "No host fn:"
    .byte     0
L8589:
    .ascii    "gethostfn?"
    .byte     0
L8588:
    .ascii    "msysc.m$power_i64"
    .byte     0
L8587:
    .ascii    "msys.m$power_i64"
    .byte     0
L8586:
    .byte     0
L8585:
    .ascii    "storebf not imm"
    .byte     0
L8584:
    .byte     0
L8583:
    .ascii    "Storebit: both vars"
    .byte     0
L8582:
    .byte     0
L8581:
    .ascii    "STOREBIT/VAR"
    .byte     0
L8580:
    .byte     0
L8579:
    .ascii    "LOADBF_VAR"
    .byte     0
L8578:
    .ascii    "mask63/offset64"
    .byte     0
L8577:
    .ascii    "labzero"
    .byte     0
L8576:
    .ascii    "labneg64"
    .byte     0
L8575:
    .ascii    "labneg32"
    .byte     0
L8574:
    .ascii    "lababs64"
    .byte     0
L8573:
    .ascii    "lababs32"
    .byte     0
L8571:
    .ascii    "Real32 Table"
    .byte     0
L8569:
    .ascii    "Real Table"
    .byte     0
L8568:
    .ascii    "String Table"
    .byte     0
L8567:
    .ascii    "ENDDATA"
    .byte     0
L8566:
    .byte     0
L8565:
    .ascii    "div/u8"
    .byte     0
L8564:
    .byte     0
L8563:
    .ascii    "Divide by zero"
    .byte     0
L8562:
    .ascii    "---------------"
    .byte     0
L8561:
    .ascii    "?]]"
    .byte     0
L8560:
    .byte     0
L8559:
    .ascii    "Threaded proc has temps"
    .byte     0
L8558:
    .byte     0
L8557:
    .ascii    "Threaded proc has locals/params"
    .byte     0
L8556:
    .byte     0
L8555:
    .ascii    "@PARAM"
    .byte     0
L8554:
    .ascii    "$1x"
    .byte     0
L8552:
    .byte     0
L8551:
    .ascii    "SUBTOREF/EXTRA"
    .byte     0
L8550:
    .ascii    "pow*"
    .byte     0
L8549:
    .byte     0
L8548:
    .ascii    "setcc/block"
    .byte     0
L8547:
    .ascii    "fmod*"
    .byte     0
L8546:
    .ascii    "atan2*"
    .byte     0
L8545:
    .ascii    "ceil*"
    .byte     0
L8544:
    .ascii    "floor*"
    .byte     0
L8543:
    .ascii    "round*"
    .byte     0
L8542:
    .ascii    "exp*"
    .byte     0
L8541:
    .ascii    "log10*"
    .byte     0
L8540:
    .ascii    "log*"
    .byte     0
L8539:
    .ascii    "atan*"
    .byte     0
L8538:
    .ascii    "acos*"
    .byte     0
L8537:
    .ascii    "asin*"
    .byte     0
L8536:
    .ascii    "tan*"
    .byte     0
L8535:
    .ascii    "cos*"
    .byte     0
L8534:
    .ascii    "sin*"
    .byte     0
L8533:
    .byte     0
L8532:
    .ascii    "No Assem handler"
    .byte     0
L8531:
    .byte     0
L8530:
    .ascii    "SUB/REF NOT POWER OF xx"
    .byte     0
L8529:
    .byte     0
L8528:
    .ascii    "float/short"
    .byte     0
L8527:
    .byte     0
L8526:
    .ascii    "multo/byte"
    .byte     0
L8525:
    .ascii    ":"
    .byte     0
L8524:
    .byte     0
L8523:
    .ascii    "swap/block"
    .byte     0
L8522:
    .byte     0
L8521:
    .ascii    "SUBREF/EXTRA"
    .byte     0
L8520:
    .ascii    "EXTRA="
    .byte     0
L8519:
    .byte     0
L8518:
    .ascii    "Storem not 16"
    .byte     0
L8517:
    .ascii    "exit*"
    .byte     0
L8516:
    .byte     0
L8515:
    .ascii    "Too many nested calls"
    .byte     0
L8514:
    .ascii    "---"
    .byte     0
L8513:
    .byte     0
L8512:
    .ascii    "JUMPCC/BLOCK"
    .byte     0
L8511:
    .byte     0
L8510:
    .ascii    "DATA/not 1248"
    .byte     0
L8509:
    .ascii    "STRPMODE(P.MODE)="
    .byte     0
L8508:
    .ascii    "P.SIZE="
    .byte     0
L8507:
    .ascii    "db/dq optype? #"
    .byte     0
L8506:
    .ascii    "PCL STACK NOT EMPTY"
    .byte     0
L8505:
    .ascii    "PROC4"
    .byte     0
L8504:
    .ascii    "PROC3"
    .byte     0
L8503:
    .ascii    "?>>"
    .byte     0
L8502:
    .ascii    "PROC2"
    .byte     0
L8501:
    .ascii    "PROC1"
    .byte     0
L8500:
    .ascii    "Unimpl: # (#)"
    .byte     0
L8499:
    .ascii    "                       "
    .byte     0
L8498:
    .ascii    "Invalid handler name:"
    .byte     0
L8497:
    .ascii    "px_"
    .byte     0
L8496:
    .ascii    "MCL1"
    .byte     0
L8495:
    .ascii    "********* ASM HAS PCL INFO *********"
    .byte     0
L8494:
    .ascii    "  Loc: # used:#, addrof:#"
    .byte     0
L8493:
    .ascii    "  Pm: # used:#, addrof:#"
    .byte     0
L8492:
    .ascii    "  Hasblocks:#"
    .byte     0
L8491:
    .ascii    "  MCLdone:  #"
    .byte     0
L8490:
    .ascii    "  Assem:    #"
    .byte     0
L8489:
    .ascii    "  Nmaxargs: #"
    .byte     0
L8488:
    .ascii    "  Leaf:     #"
    .byte     0
L8487:
    .ascii    "  Locals:   #"
    .byte     0
L8486:
    .ascii    "  Params:   #"
    .byte     0
L8485:
    .ascii    "PROC INFO FOR: #"
    .byte     0
L8484:
    .ascii    " Has statics"
    .byte     0
L8483:
    .ascii    ")"
    .byte     0
L8482:
    .ascii    "H"
    .byte     0
L8481:
    .ascii    ") (D:"
    .byte     0
L8480:
    .ascii    " (Proc:"
    .byte     0
L8479:
    .ascii    ")"
    .byte     0
L8478:
    .ascii    " "
    .byte     0
L8477:
    .ascii    " ("
    .byte     0
L8476:
    .ascii    "H"
    .byte     0
L8475:
    .ascii    " .PCADDR ="
    .byte     0
L8474:
    .ascii    " ENTRY PT"
    .byte     0
L8473:
    .ascii    " Dot"
    .byte     0
L8472:
    .ascii    " TC"
    .byte     0
L8471:
    .ascii    " Var:"
    .byte     0
L8470:
    .ascii    " Imp"
    .byte     0
L8469:
    .ascii    " Exp"
    .byte     0
L8468:
    .ascii    " Loc:"
    .byte     0
L8467:
    .ascii    " Pm:"
    .byte     0
L8466:
    .ascii    " "
    .byte     0
L8465:
    .ascii    "4"
    .byte     0
L8464:
    .ascii    "21jl"
    .byte     0
L8463:
    .ascii    "    "
    .byte     0
L8462:
    .ascii    "21jl"
    .byte     0
L8461:
    .ascii    "    "
    .byte     0
L8460:
    .ascii    "25jl"
    .byte     0
L8459:
    .ascii    " "
    .byte     0
L8458:
    .ascii    "H"
    .byte     0
L8457:
    .ascii    "PROC PC Symbol table"
    .byte     0
L8456:
    .ascii    " "
    .byte     0
L8455:
    .ascii    "  "
    .byte     0
L8454:
    .ascii    "    data mem:"
    .byte     0
L8453:
    .ascii    " "
    .byte     0
L8452:
    .ascii    ":"
    .byte     0
L8451:
    .ascii    "#"
    .byte     0
L8450:
    .ascii    " "
    .byte     0
L8449:
    .byte     10
    .byte     0
L8448:
    .ascii    " 1"
    .byte     0
L8447:
    .ascii    "extproc    "
    .byte     0
L8446:
    .byte     34
    .byte     0
L8445:
    .ascii    "addlib    "
    .byte     34
    .byte     0
L8444:
    .ascii    "!PROC PCL"
    .byte     0
L8443:
    .ascii    "<BIGSTR>"
    .byte     0
L8442:
    .ascii    "<PCLOPND?>"
    .byte     0
L8441:
    .ascii    "---------"
    .byte     0
L8440:
    .ascii    "<Data * # (#)>"
    .byte     0
L8439:
    .byte     0
L8438:
    .ascii    "#"
    .byte     0
L8437:
    .ascii    "## "
    .byte     0
L8436:
    .ascii    "&"
    .byte     0
L8435:
    .ascii    ":"
    .byte     0
L8434:
    .byte     34
    .byte     0
L8433:
    .ascii    "e16.16"
    .byte     0
L8432:
    .ascii    "infinity"
    .byte     0
L8430:
    .byte     0
L8429:
    .ascii    " "
    .byte     0
L8428:
    .ascii    "/"
    .byte     0
L8427:
    .ascii    " "
    .byte     0
L8426:
    .ascii    "/"
    .byte     0
L8425:
    .ascii    "set"
    .byte     0
L8424:
    .ascii    "jump"
    .byte     0
L8423:
    .ascii    "    "
    .byte     0
L8422:
    .ascii    "endprog"
    .byte     0
L8421:
    .ascii    "endproc"
    .byte     0
L8420:
    .ascii    "    variadic"
    .byte     0
L8419:
    .ascii    "    rettype  "
    .byte     0
L8418:
    .ascii    "       "
    .byte     0
L8417:
    .ascii    "    local    "
    .byte     0
L8416:
    .ascii    "       "
    .byte     0
L8415:
    .ascii    "    param    "
    .byte     0
L8414:
    .ascii    ":"
    .byte     0
L8413:
    .ascii    "::"
    .byte     0
L8412:
    .ascii    " "
    .byte     0
L8411:
    .ascii    "proc"
    .byte     0
L8410:
    .ascii    "tcproc"
    .byte     0
L8409:
    .ascii    "! - - -"
    .byte     0
L8408:
    .ascii    "!"
    .byte     0
L8407:
    .ascii    ":"
    .byte     0
L8406:
    .ascii    "! "
    .byte     0
L8405:
    .ascii    " NOT USED"
    .byte     0
L8404:
    .ascii    "z2h"
    .byte     0
L8402:
    .ascii    "MCL Error: # (#) on Line: # in #, PCL:#"
    .byte     0
L8401:
    .ascii    "Proc:"
    .byte     0
L8400:
    .ascii    "?"
    .byte     0
L8399:
    .ascii    "FILENAME="
    .byte     0
L8398:
    .ascii    "LINENO="
    .byte     0
L8397:
    .ascii    "No proc"
    .byte     0
L8396:
    .ascii    "Dupl proc:"
    .byte     0
L8395:
    .ascii    "Nested proc"
    .byte     0
L8394:
    .byte     0
L8393:
    .ascii    "Too many libs"
    .byte     0
L8392:
    .ascii    "w"
    .byte     0
L8391:
    .ascii    "$error.tmp"
    .byte     0
L8390:
    .ascii    "."
    .byte     0
L8389:
    .ascii    "*"
    .byte     0
L8388:
    .ascii    "`"
    .byte     0
L8387:
    .ascii    "PCL Error:"
    .byte     0
L8386:
    .ascii    ":"
    .byte     0
L8385:
    .ascii    "PCL error:"
    .byte     0
L8384:
    .ascii    "---"
    .byte     0
L8383:
    .ascii    "mem:"
    .byte     0
L8382:
    .byte     0
L8381:
    .ascii    "dummy"
    .byte     0
L8380:
    .ascii    "PHIGHMEM="
    .byte     0
L8379:
    .ascii    "w"
    .byte     0
L8378:
    .ascii    "Writing"
    .byte     0
L8377:
    .ascii    "w"
    .byte     0
L8376:
    .byte     0
L8375:
    .ascii    "Writing PST"
    .byte     0
L8374:
    .byte     0
L8373:
    .ascii    "Writing PCL"
    .byte     0
L8372:
    .ascii    "PCL start?"
    .byte     0
L8371:
    .ascii    "C:@@@@"
    .byte     92
    .ascii    "m"
    .byte     92
    .byte     34
    .byte     0
L8370:
    .ascii    "wb"
    .byte     0
L8369:
    .ascii    "con"
    .byte     0
L8368:
    .ascii    "rb"
    .byte     0
L8367:
    .ascii    "con"
    .byte     0
L8366:
    .ascii    "W64"
    .byte     0
L8365:
    .ascii    "Regclass error: %lld %lld"
    .byte     10
    .byte     0
L8363:
    .ascii    "pcc001"
    .byte     0
L8361:
    .ascii    "Winexec error: %lld"
    .byte     10
    .byte     0
L8356:
    .ascii    "@file item too long"
    .byte     0
L8355:
    .ascii    "Unexpected EOF in @file"
    .byte     0
L8354:
    .ascii    "mcx"
    .byte     0
L8353:
    .ascii    "dll"
    .byte     0
L8352:
    .ascii    "Can't open"
    .byte     0
L8351:
    .byte     10
    .byte     0
L8350:
    .ascii    " "
    .byte     0
L8349:
    .byte     0
L8348:
    .ascii    "."
    .byte     0
L8347:
    .byte     0
L8346:
    .ascii    "."
    .byte     0
L8345:
    .ascii    "line too long"
    .byte     0
L8344:
    .ascii    "rb"
    .byte     0
L8343:
    .ascii    "wb"
    .byte     0
L8342:
    .ascii    "rb"
    .byte     0
L8341:
    .ascii    "ABORTING: Press key..."
    .byte     0
L8340:
    .ascii    "Realloc mem failure"
    .byte     0
L8339:
    .ascii    "Alloc mem failure"
    .byte     0
L8338:
    .ascii    "Can't alloc pc heap"
    .byte     0
L8337:
    .ascii    "pcm_alloc failure"
    .byte     0
L8336:
    .ascii    "%.*s"
    .byte     0
L8335:
    .ascii    "MCL-UNIMPL: %s"
    .byte     10
    .byte     0
L8333:
    .ascii    "%lf%n"
    .byte     0
L8331:
    .ascii    "READ CMDLINE"
    .byte     0
L8329:
    .ascii    "<mindint>"
    .byte     0
L8328:
    .ascii    "1000000000000000000000000000000000000000000000000000000000000000"
    .byte     0
L8327:
    .ascii    "8000000000000000"
    .byte     0
L8326:
    .ascii    "9223372036854775808"
    .byte     0
L8325:
    .ascii    "|"
    .byte     0
L8324:
    .ascii    "%.*s"
    .byte     0
L8323:
    .ascii    " "
    .byte     0
L8322:
    .byte     10
    .byte     0
L8321:
    .ascii    "PRTSL"
    .byte     0
L8320:
    .ascii    "<null>"
    .byte     0
L8319:
    .ascii    "%f"
    .byte     0
L8318:
    .ascii    "%llu"
    .byte     0
L8317:
    .ascii    "False"
    .byte     0
L8316:
    .ascii    "True"
    .byte     0
L8315:
    .ascii    "z8H"
    .byte     0
L8314:
    .ascii    "Too many io levels"
    .byte     10
    .byte     0
L8313:
    .ascii    "Too many params"
    .byte     10
    .byte     0
L8312:
    .ascii    "windowsx.h"
    .byte     0
L8311:
    .ascii    "_mingw.h"
    .byte     0
L8310:
    .ascii    "winsock2.h"
    .byte     0
L8309:
    .ascii    "conio.h"
    .byte     0
L8308:
    .ascii    "memory.h"
    .byte     0
L8307:
    .ascii    "process.h"
    .byte     0
L8306:
    .ascii    "direct.h"
    .byte     0
L8305:
    .ascii    "io.h"
    .byte     0
L8304:
    .ascii    "fcntl.h"
    .byte     0
L8303:
    .ascii    "malloc.h"
    .byte     0
L8302:
    .ascii    "sys/utime.h"
    .byte     0
L8301:
    .ascii    "sys/timeb.h"
    .byte     0
L8300:
    .ascii    "sys/stat.h"
    .byte     0
L8299:
    .ascii    "sys/types.h"
    .byte     0
L8298:
    .ascii    "wctype.h"
    .byte     0
L8297:
    .ascii    "wchar.h"
    .byte     0
L8296:
    .ascii    "safelib.h"
    .byte     0
L8295:
    .ascii    "unistd.h"
    .byte     0
L8294:
    .ascii    "utime.h"
    .byte     0
L8293:
    .ascii    "time.h"
    .byte     0
L8292:
    .ascii    "string.h"
    .byte     0
L8291:
    .ascii    "_syslist.h"
    .byte     0
L8290:
    .ascii    "stdlib.h"
    .byte     0
L8289:
    .ascii    "stdio.h"
    .byte     0
L8288:
    .ascii    "stddef.h"
    .byte     0
L8287:
    .ascii    "stdbool.h"
    .byte     0
L8286:
    .ascii    "stdarg.h"
    .byte     0
L8285:
    .ascii    "signal.h"
    .byte     0
L8284:
    .ascii    "setjmp.h"
    .byte     0
L8283:
    .ascii    "math.h"
    .byte     0
L8282:
    .ascii    "_ansi.h"
    .byte     0
L8281:
    .ascii    "locale.h"
    .byte     0
L8280:
    .ascii    "limits.h"
    .byte     0
L8279:
    .ascii    "stdint.h"
    .byte     0
L8278:
    .ascii    "inttypes.h"
    .byte     0
L8277:
    .ascii    "float.h"
    .byte     0
L8276:
    .ascii    "fenv.h"
    .byte     0
L8275:
    .ascii    "errno.h"
    .byte     0
L8274:
    .ascii    "ctype.h"
    .byte     0
L8273:
    .ascii    "assert.h"
    .byte     0
L8272:
    .ascii    "/* Header windowsx.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef $windowsx"
    .byte     13
    .byte     10
    .ascii    "#define $windowsx 1"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define GET_X_LPARAM(lp)                        ((int)(short)LOWORD(lp))"
    .byte     13
    .byte     10
    .ascii    "#define GET_Y_LPARAM(lp)                        ((int)(short)HIWORD(lp))"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#endif // windowsx"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     0
L8271:
    .ascii    "/*"
    .byte     13
    .byte     10
    .ascii    " * _mingw.h"
    .byte     13
    .byte     10
    .ascii    " *"
    .byte     13
    .byte     10
    .ascii    " *  This file is for TinyCC and not part of the Mingw32 package."
    .byte     13
    .byte     10
    .ascii    " *"
    .byte     13
    .byte     10
    .ascii    " *  THIS SOFTWARE IS NOT COPYRIGHTED"
    .byte     13
    .byte     10
    .ascii    " *"
    .byte     13
    .byte     10
    .ascii    " *  This source code is offered for use in the public domain. You may"
    .byte     13
    .byte     10
    .ascii    " *  use, modify or distribute it freely."
    .byte     13
    .byte     10
    .ascii    " *"
    .byte     13
    .byte     10
    .ascii    " *  This code is distributed in the hope that it will be useful but"
    .byte     13
    .byte     10
    .ascii    " *  WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY"
    .byte     13
    .byte     10
    .ascii    " *  DISCLAIMED. This includes but is not limited to warranties of"
    .byte     13
    .byte     10
    .ascii    " *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
    .byte     13
    .byte     10
    .ascii    " *"
    .byte     13
    .byte     10
    .ascii    " */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef __MINGW_H"
    .byte     13
    .byte     10
    .ascii    "#define __MINGW_H"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "/* some winapi files define these before including _mingw.h --> */"
    .byte     13
    .byte     10
    .ascii    "#undef __cdecl"
    .byte     13
    .byte     10
    .ascii    "#undef _X86_"
    .byte     13
    .byte     10
    .ascii    "#undef WIN32"
    .byte     13
    .byte     10
    .ascii    "/* <-- */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#include <stddef.h>"
    .byte     13
    .byte     10
    .ascii    "#include <stdarg.h>"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define __int8 char"
    .byte     13
    .byte     10
    .ascii    "#define __int16 short"
    .byte     13
    .byte     10
    .ascii    "#define __int32 int"
    .byte     13
    .byte     10
    .ascii    "#define __int64 long long"
    .byte     13
    .byte     10
    .ascii    "#define _HAVE_INT64"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define __cdecl"
    .byte     13
    .byte     10
    .ascii    "#define __declspec(x) __attribute__((x))"
    .byte     13
    .byte     10
    .ascii    "#define __unaligned __attribute__((packed))"
    .byte     13
    .byte     10
    .ascii    "#define __fastcall __attribute__((fastcall))"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define __MSVCRT__ 1"
    .byte     13
    .byte     10
    .ascii    "#undef _MSVCRT_"
    .byte     13
    .byte     10
    .ascii    "#define __MINGW_IMPORT extern __declspec(dllimport)"
    .byte     13
    .byte     10
    .ascii    "#define __MINGW_ATTRIB_NORETURN"
    .byte     13
    .byte     10
    .ascii    "#define __MINGW_ATTRIB_CONST"
    .byte     13
    .byte     10
    .ascii    "#define __MINGW_ATTRIB_DEPRECATED"
    .byte     13
    .byte     10
    .ascii    "#define __MINGW_ATTRIB_MALLOC"
    .byte     13
    .byte     10
    .ascii    "#define __MINGW_ATTRIB_PURE"
    .byte     13
    .byte     10
    .ascii    "#define __MINGW_ATTRIB_NONNULL(arg)"
    .byte     13
    .byte     10
    .ascii    "#define __MINGW_NOTHROW"
    .byte     13
    .byte     10
    .ascii    "#define __GNUC_VA_LIST"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define _CRTIMP extern"
    .byte     13
    .byte     10
    .ascii    "#define __CRT_INLINE extern __inline__"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define _CRT_ALIGN(x) __attribute__((aligned(x)))"
    .byte     13
    .byte     10
    .ascii    "#define DECLSPEC_ALIGN(x) __attribute__((aligned(x)))"
    .byte     13
    .byte     10
    .ascii    "#define _CRT_PACKING 8"
    .byte     13
    .byte     10
    .ascii    "#define __CRT_UNALIGNED"
    .byte     13
    .byte     10
    .ascii    "#define _CONST_RETURN"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef _TRUNCATE"
    .byte     13
    .byte     10
    .ascii    "#define _TRUNCATE ((size_t)-1)"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define __CRT_STRINGIZE(_Value) #_Value"
    .byte     13
    .byte     10
    .ascii    "#define _CRT_STRINGIZE(_Value) __CRT_STRINGIZE(_Value)"
    .byte     13
    .byte     10
    .ascii    "#define __CRT_WIDE(_String) L ## _String"
    .byte     13
    .byte     10
    .ascii    "#define _CRT_WIDE(_String) __CRT_WIDE(_String)"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifdef _WIN64"
    .byte     13
    .byte     10
    .ascii    "#define __stdcall"
    .byte     13
    .byte     10
    .ascii    "#define _AMD64_ 1"
    .byte     13
    .byte     10
    .ascii    "#define __x86_64 1"
    .byte     13
    .byte     10
    .ascii    "#define _M_X64 100 /* Visual Studio */"
    .byte     13
    .byte     10
    .ascii    "#define _M_AMD64 100 /* Visual Studio */"
    .byte     13
    .byte     10
    .ascii    "#define USE_MINGW_SETJMP_TWO_ARGS"
    .byte     13
    .byte     10
    .ascii    "#define mingw_getsp tinyc_getbp"
    .byte     13
    .byte     10
    .ascii    "#define __TRY__"
    .byte     13
    .byte     10
    .ascii    "#else"
    .byte     13
    .byte     10
    .ascii    "#define __stdcall __attribute__((__stdcall__))"
    .byte     13
    .byte     10
    .ascii    "#define _X86_ 1"
    .byte     13
    .byte     10
    .ascii    "#define _M_IX86 300 /* Visual Studio */"
    .byte     13
    .byte     10
    .ascii    "#define WIN32 1"
    .byte     13
    .byte     10
    .ascii    "#define _USE_32BIT_TIME_T"
    .byte     13
    .byte     10
    .ascii    "#ifdef __arm__"
    .byte     13
    .byte     10
    .ascii    "#define __TRY__"
    .byte     13
    .byte     10
    .ascii    "#else"
    .byte     13
    .byte     10
    .ascii    "#define __TRY__ void __try__(void**), *_sehrec[6]; __try__(_sehrec);"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "/* in stddef.h */"
    .byte     13
    .byte     10
    .ascii    "#define _SIZE_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "#define _SSIZE_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "#define _PTRDIFF_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "#define _WCHAR_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "#define _UINTPTR_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "#define _INTPTR_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "#define _INTEGRAL_MAX_BITS 64"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef _TIME32_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "#define _TIME32_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "typedef long __time32_t;"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef _TIME64_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "#define _TIME64_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "typedef long long __time64_t;"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef _TIME_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "#define _TIME_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "#ifdef _USE_32BIT_TIME_T"
    .byte     13
    .byte     10
    .ascii    "typedef __time32_t time_t;"
    .byte     13
    .byte     10
    .ascii    "#else"
    .byte     13
    .byte     10
    .ascii    "typedef __time64_t time_t;"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef _WCTYPE_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "#define _WCTYPE_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "typedef wchar_t wctype_t;"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef _WINT_T"
    .byte     13
    .byte     10
    .ascii    "#define _WINT_T"
    .byte     13
    .byte     10
    .ascii    "typedef short wint_t;"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef int errno_t;"
    .byte     13
    .byte     10
    .ascii    "#define _ERRCODE_DEFINED"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef struct threadlocaleinfostruct *pthreadlocinfo;"
    .byte     13
    .byte     10
    .ascii    "typedef struct threadmbcinfostruct *pthreadmbcinfo;"
    .byte     13
    .byte     10
    .ascii    "typedef struct localeinfo_struct _locale_tstruct,*_locale_t;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "/* for winapi */"
    .byte     13
    .byte     10
    .ascii    "#define _ANONYMOUS_UNION"
    .byte     13
    .byte     10
    .ascii    "#define _ANONYMOUS_STRUCT"
    .byte     13
    .byte     10
    .ascii    "#define DECLSPEC_NORETURN"
    .byte     13
    .byte     10
    .ascii    "#define DECLARE_STDCALL_P(type) __stdcall type"
    .byte     13
    .byte     10
    .ascii    "#define NOSERVICE 1"
    .byte     13
    .byte     10
    .ascii    "#define NOMCX 1"
    .byte     13
    .byte     10
    .ascii    "#define NOIME 1"
    .byte     13
    .byte     10
    .ascii    "#define __INTRIN_H_"
    .byte     13
    .byte     10
    .ascii    "#ifndef DUMMYUNIONNAME"
    .byte     13
    .byte     10
    .ascii    "#  define DUMMYUNIONNAME"
    .byte     13
    .byte     10
    .ascii    "#  define DUMMYUNIONNAME1"
    .byte     13
    .byte     10
    .ascii    "#  define DUMMYUNIONNAME2"
    .byte     13
    .byte     10
    .ascii    "#  define DUMMYUNIONNAME3"
    .byte     13
    .byte     10
    .ascii    "#  define DUMMYUNIONNAME4"
    .byte     13
    .byte     10
    .ascii    "#  define DUMMYUNIONNAME5"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .ascii    "#ifndef DUMMYSTRUCTNAME"
    .byte     13
    .byte     10
    .ascii    "#  define DUMMYSTRUCTNAME"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .ascii    "#ifndef WINVER"
    .byte     13
    .byte     10
    .ascii    "# define WINVER 0x0502"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .ascii    "#ifndef _WIN32_WINNT"
    .byte     13
    .byte     10
    .ascii    "# define _WIN32_WINNT 0x502"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define __C89_NAMELESS"
    .byte     13
    .byte     10
    .ascii    "#define __MINGW_EXTENSION"
    .byte     13
    .byte     10
    .ascii    "#define WINAPI_FAMILY_PARTITION(X) 1"
    .byte     13
    .byte     10
    .ascii    "#define MINGW_HAS_SECURE_API"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#endif /* __MINGW_H */"
    .byte     13
    .byte     10
    .byte     0
L8270:
    .ascii    "#ifndef _WINSOCK2_H"
    .byte     13
    .byte     10
    .ascii    "#define _WINSOCK2_H"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#include <_mingw.h>"
    .byte     13
    .byte     10
    .ascii    "#include <windows.h>"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef FD_SETSIZE"
    .byte     13
    .byte     10
    .ascii    "#define FD_SETSIZE 64"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef unsigned int SOCKET;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef struct fd_set {"
    .byte     13
    .byte     10
    .ascii    "  unsigned int   fd_count;"
    .byte     13
    .byte     10
    .ascii    "  SOCKET  fd_array[FD_SETSIZE];"
    .byte     13
    .byte     10
    .ascii    "} fd_set;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "extern int __stdcall __WSAFDIsSet(SOCKET,fd_set *);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef FD_CLR"
    .byte     13
    .byte     10
    .ascii    "#define FD_CLR(fd,set) do { unsigned int __i;"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "for (__i = 0; __i < ((fd_set *)(set))->fd_count ; __i++) {"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "    if (((fd_set *)(set))->fd_array[__i] == (fd)) {"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "    while (__i < ((fd_set *)(set))->fd_count-1) {"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "        ((fd_set*)(set))->fd_array[__i] = ((fd_set*)(set))->fd_array[__i+1];"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "        __i++;"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "    }"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "    ((fd_set*)(set))->fd_count--;"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "    break;"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "    }"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "}"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "} while (0)"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef FD_SET"
    .byte     13
    .byte     10
    .ascii    "/* this differs from the define in winsock.h and in cygwin sys/types.h */"
    .byte     13
    .byte     10
    .ascii    "#define FD_SET(fd, set) do { unsigned int __i;"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "for (__i = 0; __i < ((fd_set *)(set))->fd_count ; __i++) {"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "    if (((fd_set *)(set))->fd_array[__i] == (fd)) {"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "        break;"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "    }"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "}"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "if (__i == ((fd_set *)(set))->fd_count) {"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "    if (((fd_set *)(set))->fd_count < FD_SETSIZE) {"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "        ((fd_set *)(set))->fd_array[__i] = (fd);"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "        ((fd_set *)(set))->fd_count++;"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "    }"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "}"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "} while(0)"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef FD_ZERO"
    .byte     13
    .byte     10
    .ascii    "#define FD_ZERO(set) (((fd_set *)(set))->fd_count=0)"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef FD_ISSET"
    .byte     13
    .byte     10
    .ascii    "#define FD_ISSET(fd, set) __WSAFDIsSet((SOCKET)(fd), (fd_set *)(set))"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef _TIMEVAL_DEFINED /* also in sys/time.h */"
    .byte     13
    .byte     10
    .ascii    "#define _TIMEVAL_DEFINED"
    .byte     13
    .byte     10
    .ascii    "struct timeval {"
    .byte     13
    .byte     10
    .ascii    "    long tv_sec;"
    .byte     13
    .byte     10
    .ascii    "    long tv_usec;"
    .byte     13
    .byte     10
    .ascii    "};"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "struct in_addr {"
    .byte     13
    .byte     10
    .ascii    "    union {"
    .byte     13
    .byte     10
    .ascii    "        struct { unsigned char s_b1,s_b2,s_b3,s_b4; } S_un_b;"
    .byte     13
    .byte     10
    .ascii    "        struct { unsigned short s_w1,s_w2; } S_un_w;"
    .byte     13
    .byte     10
    .ascii    "        unsigned long S_addr;"
    .byte     13
    .byte     10
    .ascii    "    } S_un;"
    .byte     13
    .byte     10
    .ascii    "};"
    .byte     13
    .byte     10
    .ascii    "#define s_addr  S_un.S_addr"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "struct sockaddr_in {"
    .byte     13
    .byte     10
    .ascii    "    short sin_family;"
    .byte     13
    .byte     10
    .ascii    "    unsigned short sin_port;"
    .byte     13
    .byte     10
    .ascii    "    struct in_addr sin_addr;"
    .byte     13
    .byte     10
    .ascii    "    char sin_zero[8];"
    .byte     13
    .byte     10
    .ascii    "};"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "struct sockaddr {"
    .byte     13
    .byte     10
    .ascii    "    unsigned short sa_family;"
    .byte     13
    .byte     10
    .ascii    "    char sa_data[14];"
    .byte     13
    .byte     10
    .ascii    "};"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "struct hostent {"
    .byte     13
    .byte     10
    .ascii    "    char *h_name;"
    .byte     13
    .byte     10
    .ascii    "    char **h_aliases;"
    .byte     13
    .byte     10
    .ascii    "    short h_addrtype;"
    .byte     13
    .byte     10
    .ascii    "    short h_length;"
    .byte     13
    .byte     10
    .ascii    "    char **h_addr_list;"
    .byte     13
    .byte     10
    .ascii    "};"
    .byte     13
    .byte     10
    .ascii    "#define h_addr h_addr_list[0]"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define WSADESCRIPTION_LEN  256"
    .byte     13
    .byte     10
    .ascii    "#define WSASYS_STATUS_LEN   128"
    .byte     13
    .byte     10
    .ascii    "typedef struct WSAData {"
    .byte     13
    .byte     10
    .ascii    "    WORD wVersion;"
    .byte     13
    .byte     10
    .ascii    "    WORD wHighVersion;"
    .byte     13
    .byte     10
    .ascii    "    char szDescription[WSADESCRIPTION_LEN+1];"
    .byte     13
    .byte     10
    .ascii    "    char szSystemStatus[WSASYS_STATUS_LEN+1];"
    .byte     13
    .byte     10
    .ascii    "    unsigned short iMaxSockets;"
    .byte     13
    .byte     10
    .ascii    "    unsigned short iMaxUdpDg;"
    .byte     13
    .byte     10
    .ascii    "    char *lpVendorInfo;"
    .byte     13
    .byte     10
    .ascii    "} WSADATA;"
    .byte     13
    .byte     10
    .ascii    "typedef WSADATA *LPWSADATA;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define INVALID_SOCKET (SOCKET)(~0)"
    .byte     13
    .byte     10
    .ascii    "#define SOCK_STREAM  1"
    .byte     13
    .byte     10
    .ascii    "#define SO_REUSEADDR 4"
    .byte     13
    .byte     10
    .ascii    "#define AF_INET 2"
    .byte     13
    .byte     10
    .ascii    "#define MSG_PEEK 0x2"
    .byte     13
    .byte     10
    .ascii    "#define INADDR_ANY (unsigned long)0x00000000"
    .byte     13
    .byte     10
    .ascii    "#define INADDR_LOOPBACK 0x7f000001"
    .byte     13
    .byte     10
    .ascii    "#define SOL_SOCKET 0xffff"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define SD_RECEIVE  0x00"
    .byte     13
    .byte     10
    .ascii    "#define SD_SEND     0x01"
    .byte     13
    .byte     10
    .ascii    "#define SD_BOTH     0x02"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define h_errno WSAGetLastError()"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define WSABASEERR 10000"
    .byte     13
    .byte     10
    .ascii    "#define TRY_AGAIN (WSABASEERR+1002)"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "SOCKET __stdcall accept(SOCKET, struct sockaddr *, int *);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall bind(SOCKET, const struct sockaddr *, int);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall closesocket(SOCKET);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall connect(SOCKET, const struct sockaddr *, int);"
    .byte     13
    .byte     10
    .ascii    "struct hostent *__stdcall gethostbyname(const char *);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall gethostname(char *, int);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall getpeername(SOCKET, struct sockaddr *, int *);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall getsockname(SOCKET, struct sockaddr *, int *);"
    .byte     13
    .byte     10
    .ascii    "unsigned long __stdcall htonl(unsigned long);"
    .byte     13
    .byte     10
    .ascii    "unsigned short __stdcall htons(unsigned short);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall listen(SOCKET, int);"
    .byte     13
    .byte     10
    .ascii    "unsigned long __stdcall ntohl(unsigned long);"
    .byte     13
    .byte     10
    .ascii    "unsigned short __stdcall ntohs(unsigned short);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall recv(SOCKET, char *, int, int);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall recvfrom(SOCKET, char *, int, int, struct sockaddr *, int *);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall select(int nfds, fd_set *, fd_set *, fd_set *, const struct timeval *);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall send(SOCKET, const char *, int, int);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall sendto(SOCKET, const char *, int, int, const struct sockaddr *, int);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall setsockopt(SOCKET, int, int, const char *, int);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall shutdown(SOCKET, int);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall WSACleanup(void);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall WSAGetLastError(void);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall WSAStartup(WORD, LPWSADATA);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "SOCKET __stdcall socket(int, int, int);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     0
L8269:
    .ascii    "/* conio.h */"
    .byte     13
    .byte     10
    .ascii    "#include <stddef.h>"
    .byte     13
    .byte     10
    .ascii    "#include <wchar.h>"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _getch(void);"
    .byte     13
    .byte     10
    .ascii    "int _kbhit(void);"
    .byte     13
    .byte     10
    .ascii    "wint_t _getwch(void);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define getch _getch"
    .byte     13
    .byte     10
    .ascii    "#define kbhit _kbhit"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _putch(int);"
    .byte     13
    .byte     10
    .ascii    "int _cprintf(char *, ...);"
    .byte     13
    .byte     10
    .ascii    "int _getche(void);"
    .byte     13
    .byte     10
    .ascii    "int _ungetch(int);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define putch _putch"
    .byte     13
    .byte     10
    .ascii    "#define cprintf _cprintf"
    .byte     13
    .byte     10
    .ascii    "#define getche _getche"
    .byte     13
    .byte     10
    .ascii    "#define ungetch _ungetch"
    .byte     13
    .byte     10
    .byte     0
L8268:
    .ascii    "#include <stddef.h>"
    .byte     10
    .byte     10
    .ascii    "void* malloc(size_t);"
    .byte     10
    .ascii    "void* realloc(void *, size_t);"
    .byte     10
    .ascii    "void  free(void *);"
    .byte     10
    .ascii    "void *_alloca(size_t);"
    .byte     10
    .byte     10
    .ascii    "#define alloca malloc"
    .byte     10
    .byte     0
L8267:
    .ascii    "/* Header process.h */"
    .byte     13
    .byte     10
    .ascii    "#ifndef $process"
    .byte     13
    .byte     10
    .ascii    "#define $process"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#include <stdint.h>"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define P_WAIT"
    .byte     9
    .byte     9
    .ascii    "0"
    .byte     13
    .byte     10
    .ascii    "#define P_NOWAIT"
    .byte     9
    .ascii    "1"
    .byte     13
    .byte     10
    .ascii    "#define P_OVERLAY"
    .byte     9
    .ascii    "2"
    .byte     13
    .byte     10
    .ascii    "#define P_DETACH"
    .byte     9
    .ascii    "4"
    .byte     13
    .byte     10
    .ascii    "#define WAIT_CHILD 0"
    .byte     13
    .byte     10
    .ascii    "#define _P_WAIT P_WAIT"
    .byte     13
    .byte     10
    .ascii    "#define _P_NOWAIT P_NOWAIT"
    .byte     13
    .byte     10
    .ascii    "#define _P_OVERLAY P_OVERLAY"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _spawnvp(int, const char*, const char*const*);"
    .byte     13
    .byte     10
    .ascii    "#define spawnvp _spawnvp"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "void endthread(void);"
    .byte     13
    .byte     10
    .ascii    "unsigned long _beginthreadex(void *,unsigned,unsigned (*)(void *),void *,unsigned,unsigned *);"
    .byte     13
    .byte     10
    .ascii    "void _endthreadex(unsigned);"
    .byte     13
    .byte     10
    .ascii    "int _cwait(int*, int, int);"
    .byte     13
    .byte     10
    .ascii    "#define cwait _cwait"
    .byte     13
    .byte     10
    .ascii    "//int _System(const char *cmd,int nCmdShow);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "intptr_t _execve(const char*, const char*const*, const char*const*);"
    .byte     13
    .byte     10
    .ascii    "#define execve _execve"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "//#define _WAIT_CHILD"
    .byte     9
    .ascii    "0"
    .byte     13
    .byte     10
    .ascii    "//#endif"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     0
L8266:
    .ascii    "#ifndef $direct"
    .byte     13
    .byte     10
    .ascii    "#define $direct"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef struct {"
    .byte     13
    .byte     10
    .ascii    " unsigned int total_clusters;"
    .byte     13
    .byte     10
    .ascii    " unsigned int avail_clusters;"
    .byte     13
    .byte     10
    .ascii    " unsigned int sectors_per_cluster;"
    .byte     13
    .byte     10
    .ascii    " unsigned int bytes_per_sector;"
    .byte     13
    .byte     10
    .ascii    "} diskfree_t;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int chdir(const char *);"
    .byte     13
    .byte     10
    .ascii    "char* _getcwd(char *, int);"
    .byte     13
    .byte     10
    .ascii    "#define getcwd _getcwd"
    .byte     13
    .byte     10
    .ascii    "int _mkdir(const char *);"
    .byte     13
    .byte     10
    .ascii    "int _rmdir(const char *);"
    .byte     13
    .byte     10
    .ascii    "int _wrmdir(const wchar_t*);"
    .byte     13
    .byte     10
    .ascii    "int _wmkdir(const wchar_t*);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define mkdir _mkdir"
    .byte     13
    .byte     10
    .ascii    "#define rmdir _rmdir"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _chdrive(int);"
    .byte     13
    .byte     10
    .ascii    "char* _getdcwd(int, char *, int);"
    .byte     13
    .byte     10
    .ascii    "wchar_t* _wgetcwd(wchar_t*, int);"
    .byte     13
    .byte     10
    .ascii    "int _wchdir(const wchar_t*);"
    .byte     13
    .byte     10
    .ascii    "int _getdrive(void);"
    .byte     13
    .byte     10
    .ascii    "int _chdir(const char*);"
    .byte     13
    .byte     10
    .ascii    "#define chdir _chdir"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "unsigned long _getdrives(void);"
    .byte     13
    .byte     10
    .ascii    "unsigned int _getdiskfree(unsigned int, diskfree_t*);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     0
L8265:
    .byte     13
    .byte     10
    .ascii    "#ifndef $io"
    .byte     13
    .byte     10
    .ascii    "#define $io"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#include <stdint.h>"
    .byte     13
    .byte     10
    .ascii    "#include <wchar.h>"
    .byte     13
    .byte     10
    .ascii    "#include <time.h>"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "/* io.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define _A_NORMAL 0x00"
    .byte     13
    .byte     10
    .ascii    "#define _A_RDONLY 0x01"
    .byte     13
    .byte     10
    .ascii    "#define _A_HIDDEN 0x02"
    .byte     13
    .byte     10
    .ascii    "#define _A_SYSTEM 0x04"
    .byte     13
    .byte     10
    .ascii    "#define _A_SUBDIR 0x10"
    .byte     13
    .byte     10
    .ascii    "#define _A_ARCH 0x20"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "//#message "
    .byte     34
    .ascii    "IO included"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "struct _finddata_t {"
    .byte     13
    .byte     10
    .ascii    "        unsigned    attrib;"
    .byte     13
    .byte     10
    .ascii    "        time_t      time_create;"
    .byte     13
    .byte     10
    .ascii    "        time_t      time_access;"
    .byte     13
    .byte     10
    .ascii    "        time_t      time_write;"
    .byte     13
    .byte     10
    .ascii    "        unsigned long    size;"
    .byte     13
    .byte     10
    .ascii    "        char        name[260];"
    .byte     13
    .byte     10
    .ascii    "};"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _isatty(int);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _read(int, void*, unsigned int);"
    .byte     13
    .byte     10
    .ascii    "#define read _read"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _open(const char*, int, ...);"
    .byte     13
    .byte     10
    .ascii    "#define open _open"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "long _lseek(int, long, int);"
    .byte     13
    .byte     10
    .ascii    "#define lseek _lseek"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _close(int);"
    .byte     13
    .byte     10
    .ascii    "#define close _close"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "intptr_t _get_osfhandle(int);"
    .byte     13
    .byte     10
    .ascii    "int _open_osfhandle(intptr_t,int);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _setmode(int,int);"
    .byte     13
    .byte     10
    .ascii    "#define setmode _setmode"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _wchmod(const wchar_t*, int);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _chmod(const char *, int);"
    .byte     13
    .byte     10
    .ascii    "#define chmod _chmod"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _dup(int);"
    .byte     13
    .byte     10
    .ascii    "#define dup _dup"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "intptr_t _findfirst(const char*, struct _finddata_t*);"
    .byte     13
    .byte     10
    .ascii    "int _findnext(intptr_t, struct _finddata_t*);"
    .byte     13
    .byte     10
    .ascii    "int _findclose(intptr_t);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _access(const char*,int);"
    .byte     13
    .byte     10
    .ascii    "#define access _access"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _wunlink(const wchar_t*);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     0
L8264:
    .ascii    "/* FCNTL.H */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _setmode(int,int);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef _INC_FCNTL"
    .byte     13
    .byte     10
    .ascii    "#define _INC_FCNTL"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define _O_RDONLY 0x0000"
    .byte     13
    .byte     10
    .ascii    "#define _O_WRONLY 0x0001"
    .byte     13
    .byte     10
    .ascii    "#define _O_RDWR 0x0002"
    .byte     13
    .byte     10
    .ascii    "#define _O_APPEND 0x0008"
    .byte     13
    .byte     10
    .ascii    "#define _O_CREAT 0x0100"
    .byte     13
    .byte     10
    .ascii    "#define _O_TRUNC 0x0200"
    .byte     13
    .byte     10
    .ascii    "#define _O_EXCL 0x0400"
    .byte     13
    .byte     10
    .ascii    "#define _O_TEXT 0x4000"
    .byte     13
    .byte     10
    .ascii    "#define _O_BINARY 0x8000"
    .byte     13
    .byte     10
    .ascii    "#define _O_WTEXT 0x10000"
    .byte     13
    .byte     10
    .ascii    "#define _O_U16TEXT 0x20000"
    .byte     13
    .byte     10
    .ascii    "#define _O_U8TEXT 0x40000"
    .byte     13
    .byte     10
    .ascii    "#define _O_ACCMODE (_O_RDONLY|_O_WRONLY|_O_RDWR)"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define _O_RAW _O_BINARY"
    .byte     13
    .byte     10
    .ascii    "#define _O_NOINHERIT 0x0080"
    .byte     13
    .byte     10
    .ascii    "#define _O_TEMPORARY 0x0040"
    .byte     13
    .byte     10
    .ascii    "#define _O_SHORT_LIVED 0x1000"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define _O_SEQUENTIAL 0x0020"
    .byte     13
    .byte     10
    .ascii    "#define _O_RANDOM 0x0010"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#if !defined(NO_OLDNAMES) || defined(_POSIX)"
    .byte     13
    .byte     10
    .ascii    "#define O_RDONLY _O_RDONLY"
    .byte     13
    .byte     10
    .ascii    "#define O_WRONLY _O_WRONLY"
    .byte     13
    .byte     10
    .ascii    "#define O_RDWR _O_RDWR"
    .byte     13
    .byte     10
    .ascii    "#define O_APPEND _O_APPEND"
    .byte     13
    .byte     10
    .ascii    "#define O_CREAT _O_CREAT"
    .byte     13
    .byte     10
    .ascii    "#define O_TRUNC _O_TRUNC"
    .byte     13
    .byte     10
    .ascii    "#define O_EXCL _O_EXCL"
    .byte     13
    .byte     10
    .ascii    "#define O_TEXT _O_TEXT"
    .byte     13
    .byte     10
    .ascii    "#define O_BINARY _O_BINARY"
    .byte     13
    .byte     10
    .ascii    "#define O_RAW _O_BINARY"
    .byte     13
    .byte     10
    .ascii    "#define O_TEMPORARY _O_TEMPORARY"
    .byte     13
    .byte     10
    .ascii    "#define O_NOINHERIT _O_NOINHERIT"
    .byte     13
    .byte     10
    .ascii    "#define O_SEQUENTIAL _O_SEQUENTIAL"
    .byte     13
    .byte     10
    .ascii    "#define O_RANDOM _O_RANDOM"
    .byte     13
    .byte     10
    .ascii    "#define O_ACCMODE _O_ACCMODE"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     0
L8263:
    .ascii    "#include <malloc.h>"
    .byte     13
    .byte     10
    .byte     0
L8262:
    .ascii    "/* sys/utime.h header */"
    .byte     10
    .byte     10
    .ascii    "#ifndef $utime"
    .byte     10
    .ascii    "#define $utime"
    .byte     10
    .byte     10
    .ascii    "struct _utimbuf {"
    .byte     10
    .byte     9
    .ascii    "long actime;"
    .byte     10
    .byte     9
    .ascii    "long modtime;"
    .byte     10
    .ascii    "};"
    .byte     10
    .byte     10
    .byte     10
    .ascii    "struct utimbuf {"
    .byte     10
    .byte     9
    .ascii    "long actime;"
    .byte     10
    .byte     9
    .ascii    "long modtime;"
    .byte     10
    .ascii    "};"
    .byte     10
    .byte     10
    .ascii    "struct __utimbuf64 {"
    .byte     10
    .ascii    "  long long int actime;"
    .byte     10
    .ascii    "  long long int modtime;"
    .byte     10
    .ascii    "};"
    .byte     10
    .byte     10
    .ascii    "int _utime64(const char *_Filename,struct __utimbuf64 *_Time);"
    .byte     10
    .byte     10
    .ascii    "int utime(const char *_Filename,struct utimbuf *_Utimbuf) {"
    .byte     10
    .ascii    "  return _utime64(_Filename,(struct __utimbuf64 *)_Utimbuf);"
    .byte     10
    .ascii    "}"
    .byte     10
    .byte     10
    .ascii    "#endif"
    .byte     10
    .byte     0
L8261:
    .ascii    "/* timeb.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef $timeb"
    .byte     13
    .byte     10
    .ascii    "#define $timeb"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#include <time.h>"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "struct _timeb {"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "time_t time;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "unsigned short millitm;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "short timezone;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "short dstflag;"
    .byte     13
    .byte     10
    .ascii    "};"
    .byte     13
    .byte     10
    .ascii    "#define timeb _timeb"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "void _ftime64(struct _timeb*);"
    .byte     13
    .byte     10
    .ascii    "#define _ftime _ftime64"
    .byte     13
    .byte     10
    .ascii    "#define ftime _ftime64"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     0
L8260:
    .ascii    "/* stat.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef $sysstat"
    .byte     13
    .byte     10
    .ascii    "#define $sysstat"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#include <stddef.h>"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "struct _stat {"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "unsigned int"
    .byte     9
    .ascii    "st_dev;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "unsigned short"
    .byte     9
    .ascii    "st_ino;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "unsigned short"
    .byte     9
    .ascii    "st_mode;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "short"
    .byte     9
    .byte     9
    .byte     9
    .ascii    "st_nlink;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "short"
    .byte     9
    .byte     9
    .byte     9
    .ascii    "st_uid;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "short"
    .byte     9
    .byte     9
    .byte     9
    .ascii    "st_gid;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "unsigned long"
    .byte     9
    .ascii    "st_rdev;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "unsigned int"
    .byte     9
    .ascii    "st_size;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "unsigned long long int"
    .byte     9
    .ascii    "st_atime;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "unsigned long long int"
    .byte     9
    .ascii    "st_mtime;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "unsigned long long int"
    .byte     9
    .ascii    "st_ctime;"
    .byte     13
    .byte     10
    .ascii    "};"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define stat _stat"
    .byte     13
    .byte     10
    .ascii    "#define _stati64 _stat"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define _S_IFMT 0xF000"
    .byte     13
    .byte     10
    .ascii    "#define _S_IFDIR 0x4000"
    .byte     13
    .byte     10
    .ascii    "#define _S_IFCHR 0x2000"
    .byte     13
    .byte     10
    .ascii    "#define _S_IFIFO 0x1000"
    .byte     13
    .byte     10
    .ascii    "#define _S_IFREG 0x8000"
    .byte     13
    .byte     10
    .ascii    "#define _S_IREAD 0x0100"
    .byte     13
    .byte     10
    .ascii    "#define _S_IWRITE 0x0080"
    .byte     13
    .byte     10
    .ascii    "#define _S_IEXEC 0x0040"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define S_IFMT 0xF000"
    .byte     13
    .byte     10
    .ascii    "#define S_IFDIR 0x4000"
    .byte     13
    .byte     10
    .ascii    "#define S_IFCHR 0x2000"
    .byte     13
    .byte     10
    .ascii    "#define S_IFIFO 0x1000"
    .byte     13
    .byte     10
    .ascii    "#define S_IFREG 0x8000"
    .byte     13
    .byte     10
    .ascii    "#define S_IREAD 0x0100"
    .byte     13
    .byte     10
    .ascii    "#define S_IWRITE 0x0080"
    .byte     13
    .byte     10
    .ascii    "#define S_IEXEC 0x0040"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define S_ISCHR(nd) (((nd) & S_IFMT) == S_IFCHR)"
    .byte     13
    .byte     10
    .ascii    "#define S_ISDIR(nd) (((nd) & S_IFMT) == S_IFDIR)"
    .byte     13
    .byte     10
    .ascii    "#define S_ISFIFO(nd) (((nd) & S_IFMT) == S_IFIFO)"
    .byte     13
    .byte     10
    .ascii    "#define S_ISREG(nd) (((nd) & S_IFMT) == S_IFREG)"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define"
    .byte     9
    .ascii    "_S_IRWXU"
    .byte     9
    .ascii    "(_S_IREAD | _S_IWRITE | _S_IEXEC)"
    .byte     13
    .byte     10
    .ascii    "#define"
    .byte     9
    .ascii    "_S_IXUSR"
    .byte     9
    .ascii    "_S_IEXEC"
    .byte     13
    .byte     10
    .ascii    "#define"
    .byte     9
    .ascii    "_S_IWUSR"
    .byte     9
    .ascii    "_S_IWRITE"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define"
    .byte     9
    .ascii    "S_IRWXU"
    .byte     9
    .byte     9
    .ascii    "_S_IRWXU"
    .byte     13
    .byte     10
    .ascii    "#define"
    .byte     9
    .ascii    "S_IXUSR"
    .byte     9
    .byte     9
    .ascii    "_S_IXUSR"
    .byte     13
    .byte     10
    .ascii    "#define"
    .byte     9
    .ascii    "S_IWUSR"
    .byte     9
    .byte     9
    .ascii    "_S_IWUSR"
    .byte     13
    .byte     10
    .ascii    "#define"
    .byte     9
    .ascii    "S_IRUSR"
    .byte     9
    .byte     9
    .ascii    "_S_IRUSR"
    .byte     13
    .byte     10
    .ascii    "#define"
    .byte     9
    .ascii    "_S_IRUSR"
    .byte     9
    .ascii    "_S_IREAD"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define S_IRGRP    (S_IRUSR >> 3)"
    .byte     13
    .byte     10
    .ascii    "#define S_IWGRP    (S_IWUSR >> 3)"
    .byte     13
    .byte     10
    .ascii    "#define S_IXGRP    (S_IXUSR >> 3)"
    .byte     13
    .byte     10
    .ascii    "#define S_IRWXG    (S_IRWXU >> 3)"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define S_IROTH    (S_IRGRP >> 3)"
    .byte     13
    .byte     10
    .ascii    "#define S_IWOTH    (S_IWGRP >> 3)"
    .byte     13
    .byte     10
    .ascii    "#define S_IXOTH    (S_IXGRP >> 3)"
    .byte     13
    .byte     10
    .ascii    "#define S_IRWXO    (S_IRWXG >> 3)"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "//#define"
    .byte     9
    .ascii    "S_ISDIR(m)"
    .byte     9
    .ascii    "(((m) & S_IFMT) == S_IFDIR)"
    .byte     13
    .byte     10
    .ascii    "//#define"
    .byte     9
    .ascii    "S_ISFIFO(m)"
    .byte     9
    .ascii    "(((m) & S_IFMT) == S_IFIFO)"
    .byte     13
    .byte     10
    .ascii    "//#define"
    .byte     9
    .ascii    "S_ISCHR(m)"
    .byte     9
    .ascii    "(((m) & S_IFMT) == S_IFCHR)"
    .byte     13
    .byte     10
    .ascii    "#define"
    .byte     9
    .ascii    "S_IFBLK"
    .byte     9
    .ascii    "0x3000"
    .byte     9
    .ascii    "/* Block: Is this ever set under w32? */"
    .byte     13
    .byte     10
    .ascii    "#define"
    .byte     9
    .ascii    "S_ISBLK(m)"
    .byte     9
    .ascii    "(((m) & S_IFMT) == S_IFBLK)"
    .byte     13
    .byte     10
    .ascii    "#define"
    .byte     9
    .ascii    "S_ISREG(m)"
    .byte     9
    .ascii    "(((m) & S_IFMT) == S_IFREG)"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int stat(const char *, struct stat*);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _fstati64(int, struct stat*);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int fstat(int, struct stat *);"
    .byte     13
    .byte     10
    .ascii    "#define _fstat fstat"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _wstati64(const wchar_t,struct _stati64 *buffer);  "
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     0
L8259:
    .ascii    "/* types.h */"
    .byte     13
    .byte     10
    .ascii    "#ifndef $systypes"
    .byte     13
    .byte     10
    .ascii    "#define $systypes 1"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef long int off_t;"
    .byte     13
    .byte     10
    .ascii    "typedef long int ino_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned int dev_t;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef long long time_t;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     0
L8258:
    .ascii    "/* Header wctype.h */"
    .byte     13
    .byte     10
    .byte     0
L8257:
    .ascii    "/* Header wchar.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#include <stddef.h>"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define _WCHAR_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned short wint_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned short wchar_t;"
    .byte     13
    .byte     10
    .ascii    "//typedef signed short wchar_t;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "size_t wcslen(const wchar_t*);"
    .byte     13
    .byte     10
    .ascii    "wchar_t* wcscpy(wchar_t*,const wchar_t*);"
    .byte     13
    .byte     10
    .ascii    "//wchar_t* _wgetenv(constwchar_t*);"
    .byte     13
    .byte     10
    .ascii    "wchar_t* wcstok(wchar_t*,wchar_t*,wchar_t**);"
    .byte     13
    .byte     10
    .ascii    "wchar_t* wcstok_s(wchar_t*,wchar_t*,wchar_t**);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "wchar_t* wcschr(wchar_t*,wchar_t);"
    .byte     13
    .byte     10
    .ascii    "wchar_t* wcsstr(const wchar_t*,const wchar_t*);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int wcscmp(const wchar_t*,const wchar_t*);"
    .byte     13
    .byte     10
    .ascii    "typedef long _off_t;"
    .byte     13
    .byte     10
    .byte     0
L8256:
    .ascii    "/* Header safelib.h */"
    .byte     13
    .byte     10
    .byte     0
L8255:
    .ascii    "/* unistd.h header */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "unsigned int _sleep(unsigned int);"
    .byte     13
    .byte     10
    .ascii    "#define sleep _sleep"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define alarm(x) {puts("
    .byte     34
    .ascii    "ALARM"
    .byte     34
    .ascii    "); exit(1);}"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _write(int,void*,unsigned int);"
    .byte     13
    .byte     10
    .ascii    "#define write _write"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _close(int);"
    .byte     13
    .byte     10
    .ascii    "#define close _close"
    .byte     13
    .byte     10
    .byte     0
L8254:
    .ascii    "/* sys/utime.h header */"
    .byte     10
    .byte     10
    .ascii    "#ifndef $utime"
    .byte     10
    .ascii    "#define $utime"
    .byte     10
    .byte     10
    .ascii    "struct _utimbuf {"
    .byte     10
    .byte     9
    .ascii    "long actime;"
    .byte     10
    .byte     9
    .ascii    "long modtime;"
    .byte     10
    .ascii    "};"
    .byte     10
    .byte     10
    .byte     10
    .ascii    "struct utimbuf {"
    .byte     10
    .byte     9
    .ascii    "long actime;"
    .byte     10
    .byte     9
    .ascii    "long modtime;"
    .byte     10
    .ascii    "};"
    .byte     10
    .byte     10
    .ascii    "struct __utimbuf64 {"
    .byte     10
    .ascii    "  long long int actime;"
    .byte     10
    .ascii    "  long long int modtime;"
    .byte     10
    .ascii    "};"
    .byte     10
    .byte     10
    .ascii    "int _utime64(const char *_Filename,struct __utimbuf64 *_Time);"
    .byte     10
    .byte     10
    .ascii    "int utime(const char *_Filename,struct utimbuf *_Utimbuf) {"
    .byte     10
    .ascii    "  return _utime64(_Filename,(struct __utimbuf64 *)_Utimbuf);"
    .byte     10
    .ascii    "}"
    .byte     10
    .byte     10
    .ascii    "#endif"
    .byte     10
    .byte     0
L8253:
    .ascii    "/* Header time.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef $time"
    .byte     13
    .byte     10
    .ascii    "#define $time"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#include <stddef.h>"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef long clock_t;"
    .byte     13
    .byte     10
    .ascii    "clock_t clock(void);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "//typedef long time_t;"
    .byte     13
    .byte     10
    .ascii    "#ifndef _TIME_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "#define _TIME_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "typedef long long int time_t;"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "struct tm"
    .byte     13
    .byte     10
    .ascii    "{"
    .byte     13
    .byte     10
    .ascii    "  int"
    .byte     9
    .ascii    "tm_sec;"
    .byte     13
    .byte     10
    .ascii    "  int"
    .byte     9
    .ascii    "tm_min;"
    .byte     13
    .byte     10
    .ascii    "  int"
    .byte     9
    .ascii    "tm_hour;"
    .byte     13
    .byte     10
    .ascii    "  int"
    .byte     9
    .ascii    "tm_mday;"
    .byte     13
    .byte     10
    .ascii    "  int"
    .byte     9
    .ascii    "tm_mon;"
    .byte     13
    .byte     10
    .ascii    "  int"
    .byte     9
    .ascii    "tm_year;"
    .byte     13
    .byte     10
    .ascii    "  int"
    .byte     9
    .ascii    "tm_wday;"
    .byte     13
    .byte     10
    .ascii    "  int"
    .byte     9
    .ascii    "tm_yday;"
    .byte     13
    .byte     10
    .ascii    "  int"
    .byte     9
    .ascii    "tm_isdst;"
    .byte     13
    .byte     10
    .ascii    "};"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "//struct tm *localtime(time_t*);"
    .byte     13
    .byte     10
    .ascii    "struct tm* _localtime32(time_t*);"
    .byte     13
    .byte     10
    .ascii    "#define localtime _localtime32"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "time_t _time64(time_t *_timer);"
    .byte     13
    .byte     10
    .ascii    "#define time _time64"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define CLOCKS_PER_SEC 1000"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "struct tm *gmtime(const time_t*);"
    .byte     13
    .byte     10
    .ascii    "size_t strftime(char *, size_t, const char *, const struct tm *);"
    .byte     13
    .byte     10
    .ascii    "time_t mktime(struct tm *);"
    .byte     13
    .byte     10
    .ascii    "double difftime(time_t, time_t);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "char* asctime(const struct tm*);"
    .byte     13
    .byte     10
    .ascii    "//char* ctime(const time_t *_time);"
    .byte     13
    .byte     10
    .ascii    "char* _ctime64(const time_t *_time);"
    .byte     13
    .byte     10
    .ascii    "#define ctime _ctime64"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     0
L8252:
    .ascii    "/* Header string.h */"
    .byte     10
    .byte     10
    .ascii    "#include <stddef.h>"
    .byte     10
    .byte     10
    .ascii    "void* memcpy(void*, const void*, size_t);"
    .byte     10
    .ascii    "void* memmove(const void*, const void*, size_t);"
    .byte     10
    .ascii    "void* memset(void*, int, size_t);"
    .byte     10
    .ascii    "int memcmp(const void*, const void*, size_t);"
    .byte     10
    .ascii    "void* memchr(const void *, int, size_t);"
    .byte     10
    .byte     10
    .ascii    "size_t strlen(const char*);"
    .byte     10
    .ascii    "char* strcpy(char*, const char*);"
    .byte     10
    .ascii    "char* strncpy(char*, const char*, size_t);"
    .byte     10
    .ascii    "char* strcat(char*, const char*);"
    .byte     10
    .ascii    "int strcmp(const char*, const char*);"
    .byte     10
    .ascii    "int strncmp(const char*, const char*, size_t);"
    .byte     10
    .ascii    "char* strchr(const char*, int);"
    .byte     10
    .ascii    "char* strstr(const char*, const char*);"
    .byte     10
    .ascii    "char* strrchr(const char*, int);"
    .byte     10
    .ascii    "int _stricmp(const char*, const char*);"
    .byte     10
    .ascii    "#define stricmp _stricmp"
    .byte     10
    .ascii    "#define strcasecmp _stricmp"
    .byte     10
    .byte     10
    .byte     10
    .byte     10
    .ascii    "int _strnicmp(const char*, const char*, size_t);"
    .byte     10
    .ascii    "#define strnicmp _strnicmp"
    .byte     10
    .ascii    "char* strncat(char*, const char*, size_t);"
    .byte     10
    .ascii    "char* strtok(char*, const char*);"
    .byte     10
    .byte     10
    .ascii    "size_t strcspn(const char*, const char*);"
    .byte     10
    .ascii    "size_t strspn(const char*, const char*);"
    .byte     10
    .ascii    "int strcoll(const char *, const char *);"
    .byte     10
    .byte     10
    .ascii    "unsigned long strtoul(const char*, char**, int);"
    .byte     10
    .byte     10
    .ascii    "char* strerror(int);"
    .byte     10
    .ascii    "char* strpbrk(const char*, const char*);"
    .byte     10
    .ascii    "size_t strxfrm(char*, const char *, size_t);"
    .byte     10
    .byte     10
    .ascii    "char* _strupr(char*);"
    .byte     10
    .ascii    "char* _strlwr(char*);"
    .byte     10
    .ascii    "#define strupr _strupr"
    .byte     10
    .ascii    "#define strlwr _strlwr"
    .byte     10
    .byte     10
    .ascii    "char*strnupr(char*,size_t);"
    .byte     10
    .ascii    "char*strnlwr(char*,size_t);"
    .byte     10
    .ascii    "int strtrim(char*);"
    .byte     10
    .ascii    "char*strrev(char*);"
    .byte     10
    .byte     10
    .ascii    "char* _strdup(const char*);"
    .byte     10
    .ascii    "#define strdup _strdup"
    .byte     10
    .byte     10
    .ascii    "int _wcsicmp(const wchar_t *,const wchar_t *);"
    .byte     10
    .byte     10
    .ascii    "wchar_t *wcspbrk(const wchar_t*,const wchar_t*);"
    .byte     10
    .byte     10
    .ascii    "size_t wcslen(const wchar_t*);"
    .byte     10
    .byte     0
L8251:
    .ascii    "/* Header _syslist.h */"
    .byte     13
    .byte     10
    .byte     0
L8250:
    .ascii    "/* Header stdlib.h */"
    .byte     10
    .byte     10
    .ascii    "#ifndef $stdlib"
    .byte     10
    .ascii    "#define $stdlib 1"
    .byte     10
    .byte     10
    .ascii    "#include <stddef.h>"
    .byte     10
    .byte     10
    .ascii    "#define EXIT_FAILURE 1"
    .byte     10
    .ascii    "#define EXIT_SUCCESS 0"
    .byte     10
    .byte     10
    .ascii    "#define RAND_MAX 32767"
    .byte     10
    .byte     10
    .ascii    "void* malloc(size_t);"
    .byte     10
    .ascii    "void* realloc(void*, size_t);"
    .byte     10
    .ascii    "void* calloc(size_t, size_t);"
    .byte     10
    .byte     10
    .ascii    "void free(void*);"
    .byte     10
    .byte     10
    .ascii    "void exit(int);"
    .byte     10
    .byte     10
    .ascii    "int system(const char*);"
    .byte     10
    .ascii    "int _wsystem(const wchar_t*);"
    .byte     10
    .byte     10
    .ascii    "int abs(int);"
    .byte     10
    .ascii    "long labs(long);"
    .byte     10
    .ascii    "long long llabs(long);"
    .byte     10
    .ascii    "int rand(void);"
    .byte     10
    .ascii    "void srand(unsigned int);"
    .byte     10
    .ascii    "int atoi(const char*);"
    .byte     10
    .ascii    "long atol(const char*);"
    .byte     10
    .ascii    "long long atoll(const char*);"
    .byte     10
    .ascii    "long long atoi64(const char*);"
    .byte     10
    .ascii    "double atof(const char *);"
    .byte     10
    .ascii    "int"
    .byte     9
    .ascii    "atexit(void (*)(void));"
    .byte     10
    .ascii    "char *_itoa(int,char *,int);"
    .byte     10
    .byte     10
    .ascii    "#define itoa _itoa"
    .byte     10
    .byte     10
    .ascii    "void qsort(void*, size_t, size_t, int (*)(void*, void*));"
    .byte     10
    .byte     10
    .ascii    "typedef struct {"
    .byte     10
    .byte     9
    .ascii    "long long int quot;"
    .byte     10
    .byte     9
    .ascii    "long long int rem;"
    .byte     10
    .ascii    "} lldiv_t;"
    .byte     10
    .byte     10
    .ascii    "lldiv_t lldiv(long long int, long long int);"
    .byte     10
    .byte     10
    .ascii    "char* getenv(const char*);"
    .byte     10
    .ascii    "wchar_t* _wgetenv(const wchar_t*);"
    .byte     10
    .ascii    "int _wputenv(const wchar_t*);"
    .byte     10
    .byte     10
    .byte     10
    .ascii    "double strtod(const char*, char**);"
    .byte     10
    .byte     10
    .ascii    "//float strtof(const char *, char**);"
    .byte     10
    .ascii    "#define strtof strtod"
    .byte     10
    .byte     10
    .ascii    "long double strtold(const char*, char**);"
    .byte     10
    .ascii    "void abort(void);"
    .byte     10
    .ascii    "long int strtol(const char*, char**, int);"
    .byte     10
    .byte     10
    .ascii    "long double strtold(const char *,char **);"
    .byte     10
    .byte     10
    .ascii    "long long int _strtoi64(const char *,char **,int);"
    .byte     10
    .ascii    "#define strtoll _strtoi64"
    .byte     10
    .byte     10
    .ascii    "unsigned long long int _strtoui64(const char *,char **,int);"
    .byte     10
    .byte     10
    .ascii    "unsigned long long int _strtoui64(const char*, char**, int);"
    .byte     10
    .ascii    "#define strtoull _strtoui64"
    .byte     10
    .ascii    "unsigned long strtoul(const char*, char**, int);"
    .byte     10
    .byte     10
    .ascii    "size_t _msize(void *);"
    .byte     10
    .ascii    "#define msize _msize"
    .byte     10
    .byte     10
    .ascii    "void* bsearch(const void *,const void *, size_t, size_t,"
    .byte     10
    .byte     9
    .byte     9
    .ascii    "int (*_compar)(const void *,const void *));"
    .byte     10
    .byte     10
    .byte     10
    .ascii    "char* _fullpath(char*, const char*, size_t);"
    .byte     10
    .byte     10
    .byte     10
    .ascii    "#endif"
    .byte     10
    .byte     0
L8249:
    .ascii    "/* Header stdio.h */"
    .byte     10
    .byte     10
    .ascii    "#ifndef $stdio"
    .byte     10
    .ascii    "#define $stdio 1"
    .byte     10
    .byte     10
    .ascii    "#define __attribute__(x)"
    .byte     10
    .byte     10
    .ascii    "#ifndef $valist"
    .byte     10
    .byte     9
    .ascii    "typedef char* va_list;"
    .byte     10
    .byte     9
    .ascii    "#define $valist"
    .byte     10
    .ascii    "#endif"
    .byte     10
    .byte     10
    .ascii    "#include <stddef.h>"
    .byte     10
    .byte     10
    .ascii    "typedef long long int fpos_t;"
    .byte     10
    .byte     10
    .ascii    "#define SEEK_SET 0"
    .byte     10
    .ascii    "#define SEEK_CUR 1"
    .byte     10
    .ascii    "#define SEEK_END 2"
    .byte     10
    .byte     10
    .ascii    "#define"
    .byte     9
    .ascii    "STDIN_FILENO"
    .byte     9
    .ascii    "0"
    .byte     10
    .ascii    "#define"
    .byte     9
    .ascii    "STDOUT_FILENO"
    .byte     9
    .ascii    "1"
    .byte     10
    .ascii    "#define"
    .byte     9
    .ascii    "STDERR_FILENO"
    .byte     9
    .ascii    "2"
    .byte     10
    .byte     10
    .ascii    "#define EOF (-1)"
    .byte     10
    .ascii    "#define FILENAME_MAX 260"
    .byte     10
    .byte     10
    .ascii    "#define L_tmpnam 10"
    .byte     10
    .byte     10
    .ascii    "typedef struct {"
    .byte     10
    .byte     9
    .ascii    "char *_ptr;"
    .byte     10
    .byte     9
    .ascii    "int   _cnt;"
    .byte     10
    .byte     9
    .ascii    "char *_base;"
    .byte     10
    .byte     9
    .ascii    "int   _flag;"
    .byte     10
    .byte     9
    .ascii    "int   _file;"
    .byte     10
    .byte     9
    .ascii    "int   _charbuf;"
    .byte     10
    .byte     9
    .ascii    "int   _bufsiz;"
    .byte     10
    .byte     9
    .ascii    "char *_tmpfname;"
    .byte     10
    .ascii    "} FILE;"
    .byte     10
    .byte     10
    .ascii    "extern char* __iob_func(void);"
    .byte     10
    .byte     10
    .ascii    "#define stdin ((FILE*)(__iob_func()))"
    .byte     10
    .ascii    "#define stdout ((FILE*)(__iob_func()+sizeof(FILE)))"
    .byte     10
    .ascii    "#define stderr ((FILE*)(__iob_func()+sizeof(FILE)*2))"
    .byte     10
    .byte     10
    .ascii    "#define _IOREAD 0x0001"
    .byte     10
    .ascii    "#define _IOWRT 0x0002"
    .byte     10
    .byte     10
    .ascii    "#define _IOFBF 0x0000"
    .byte     10
    .ascii    "#define _IOLBF 0x0040"
    .byte     10
    .ascii    "#define _IONBF 0x0004"
    .byte     10
    .byte     10
    .ascii    "#define _IOMYBUF 0x0008"
    .byte     10
    .ascii    "#define _IOEOF 0x0010"
    .byte     10
    .ascii    "#define _IOERR 0x0020"
    .byte     10
    .ascii    "#define _IOSTRG 0x0040"
    .byte     10
    .ascii    "#define _IORW 0x0080"
    .byte     10
    .byte     10
    .ascii    "#define BUFSIZ 512"
    .byte     10
    .byte     10
    .ascii    "FILE* fopen(const char*, const char*);"
    .byte     10
    .ascii    "int fclose(FILE*);"
    .byte     10
    .ascii    "long ftell(FILE*);"
    .byte     10
    .ascii    "//long long int _ftelli64(FILE*);"
    .byte     10
    .ascii    "int fseek(FILE*,long,int);"
    .byte     10
    .ascii    "int _fseeki64(FILE*,long long int,int);"
    .byte     10
    .byte     10
    .ascii    "size_t fread(void*, size_t, size_t, FILE*);"
    .byte     10
    .ascii    "size_t fwrite(const void*, size_t, size_t, FILE*);"
    .byte     10
    .ascii    "int remove(const char*);"
    .byte     10
    .ascii    "int rename(const char *,const char *);"
    .byte     10
    .ascii    "FILE* freopen(const char*, const char*, FILE*);"
    .byte     10
    .ascii    "FILE* _wfopen(const wchar_t*,const wchar_t *);"
    .byte     10
    .byte     10
    .ascii    "int printf(const char*, ...);"
    .byte     10
    .ascii    "int sprintf(char*,const char*, ...);"
    .byte     10
    .ascii    "int fprintf(FILE*,const char*, ...);"
    .byte     10
    .ascii    "int sscanf(const char*, const char*, ...);"
    .byte     10
    .ascii    "int scanf(const char*, ...);"
    .byte     10
    .ascii    "int fscanf(FILE *,const char *, ...);"
    .byte     10
    .ascii    "int _snprintf(char *,size_t,const char*,...);"
    .byte     10
    .ascii    "#define snprintf _snprintf"
    .byte     10
    .ascii    "int _vsnprintf(char*, size_t, const char*, va_list);"
    .byte     10
    .ascii    "int vsnprintf(char*,size_t,const char*,va_list);"
    .byte     10
    .ascii    "int vsprintf(char*, const char*, va_list);"
    .byte     10
    .ascii    "int _wremove(const wchar_t*);"
    .byte     10
    .ascii    "int _wrename(const wchar_t*,const wchar_t*);"
    .byte     10
    .byte     10
    .ascii    "typedef char* va_list;"
    .byte     10
    .byte     10
    .ascii    "int vfprintf(FILE*, const char*, va_list);"
    .byte     10
    .ascii    "int vprintf(const char*, va_list);"
    .byte     10
    .byte     10
    .ascii    "int puts(const char*);"
    .byte     10
    .ascii    "char* fgets(char*, int, FILE*);"
    .byte     10
    .ascii    "int fputs(const char*, FILE*);"
    .byte     10
    .ascii    "int fgetc(FILE*);"
    .byte     10
    .ascii    "int fputc(int, FILE*);"
    .byte     10
    .ascii    "int ungetc(int, FILE*);"
    .byte     10
    .ascii    "int getchar(void);"
    .byte     10
    .ascii    "int putchar(int);"
    .byte     10
    .ascii    "int fflush(FILE *);"
    .byte     10
    .ascii    "int getc(FILE *);"
    .byte     10
    .ascii    "int putc(int, FILE *);"
    .byte     10
    .byte     10
    .ascii    "int feof(FILE*);"
    .byte     10
    .ascii    "int ferror(FILE*);"
    .byte     10
    .ascii    "void clearerr(FILE*);"
    .byte     10
    .byte     10
    .ascii    "int fileno(FILE*);"
    .byte     10
    .ascii    "int _fileno(FILE*);"
    .byte     10
    .ascii    "int setvbuf(FILE*,char*,int,size_t);"
    .byte     10
    .ascii    "FILE* _popen(const char*, const char*);"
    .byte     10
    .ascii    "int _pclose(FILE*);"
    .byte     10
    .ascii    "int _unlink(const char *);"
    .byte     10
    .ascii    "#define unlink _unlink;"
    .byte     10
    .ascii    "FILE* _fdopen(int, const char *);"
    .byte     10
    .ascii    "#define fdopen _fdopen"
    .byte     10
    .ascii    "int fgetpos(FILE*, fpos_t*);"
    .byte     10
    .ascii    "int fsetpos(FILE*, const fpos_t*);"
    .byte     10
    .ascii    "void perror(char*);"
    .byte     10
    .ascii    "void setbuf(FILE*, char*);"
    .byte     10
    .byte     10
    .ascii    "void rewind(FILE*);"
    .byte     10
    .byte     10
    .ascii    "FILE* tmpfile(void);"
    .byte     10
    .byte     10
    .ascii    "char* tmpnam(char*);"
    .byte     10
    .ascii    "wchar_t getwc(FILE *);"
    .byte     10
    .byte     10
    .ascii    "extern void* _wenviron;"
    .byte     10
    .byte     10
    .ascii    "#endif"
    .byte     10
    .byte     10
    .byte     0
L8248:
    .ascii    "/* Header stddef.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef $stddef"
    .byte     13
    .byte     10
    .ascii    "#define $stddef"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef signed long long int ssize_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned long long int size_t;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define _WCHAR_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned short wchar_t;"
    .byte     13
    .byte     10
    .ascii    "//typedef signed short wchar_t;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define NULL ((void*)0)"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define offsetof(a,b) (size_t) &( ((a*)0) -> b)"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef long long int ptrdiff_t;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#endif // stddef"
    .byte     13
    .byte     10
    .byte     0
L8247:
    .ascii    "/* Header stdbool.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define bool unsigned char"
    .byte     13
    .byte     10
    .ascii    "#define true 1"
    .byte     13
    .byte     10
    .ascii    "#define false 0"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     0
L8246:
    .ascii    "/* Header stdarg.h */"
    .byte     10
    .byte     10
    .ascii    "#ifndef $STDARG"
    .byte     10
    .ascii    " #define $STDARG"
    .byte     10
    .byte     10
    .ascii    "//coded for x64 target as used by mcc (with first four params also on stack)"
    .byte     10
    .byte     10
    .ascii    " typedef char *"
    .byte     9
    .ascii    "va_list;"
    .byte     10
    .byte     10
    .ascii    " #if __MCCI__"
    .byte     10
    .ascii    "  #define va_start(ap,v) ap=((va_list)&v-8)"
    .byte     10
    .ascii    "  #define va_arg(ap,t) *(t*)((ap-=8)+8)"
    .byte     10
    .ascii    "  #define va_copy(dest,src) (dest=src)"
    .byte     10
    .ascii    "  #define va_end(ap)"
    .byte     9
    .ascii    "( ap = (va_list)0 )"
    .byte     10
    .byte     10
    .ascii    " #else"
    .byte     10
    .ascii    "  #define va_start(ap,v) ap=((va_list)&v+8)"
    .byte     10
    .ascii    "  #define va_arg(ap,t) *(t*)((ap+=8)-8)"
    .byte     10
    .ascii    "  #define va_copy(dest,src) (dest=src)"
    .byte     10
    .ascii    "  #define va_end(ap)"
    .byte     9
    .ascii    "( ap = (va_list)0 )"
    .byte     10
    .byte     10
    .ascii    " #endif"
    .byte     10
    .byte     10
    .ascii    "#endif"
    .byte     10
    .byte     0
L8245:
    .ascii    "/* Header signal.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define SIGINT    2"
    .byte     13
    .byte     10
    .ascii    "#define SIGILL    4"
    .byte     13
    .byte     10
    .ascii    "#define SIGFPE    8"
    .byte     13
    .byte     10
    .ascii    "#define SIGSEGV  11"
    .byte     13
    .byte     10
    .ascii    "#define SIGTERM  15"
    .byte     13
    .byte     10
    .ascii    "#define SIGBREAK 21"
    .byte     13
    .byte     10
    .ascii    "#define SIGABRT  22"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define SIG_DFL (void (*)(int))0"
    .byte     13
    .byte     10
    .ascii    "#define SIG_IGN (void (*)(int))1"
    .byte     13
    .byte     10
    .ascii    "#define SIG_SGE (void (*)(int))3"
    .byte     13
    .byte     10
    .ascii    "#define SIG_ACK (void (*)(int))4"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define SIG_ERR (void (*)(int))-1"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "extern void (*signal(int, void (*)(int)))(int);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "extern int raise(int);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef int sig_atomic_t;"
    .byte     13
    .byte     10
    .byte     0
L8244:
    .ascii    "/* Header setjmp.h */"
    .byte     10
    .byte     10
    .byte     10
    .ascii    "#ifndef $setjmphdr"
    .byte     10
    .ascii    "#define $setjmphdr 1"
    .byte     10
    .byte     10
    .ascii    "typedef int jmp_buf[128];"
    .byte     10
    .byte     10
    .ascii    "//void $mcclongjmp(jmp_buf, int);"
    .byte     10
    .ascii    "//int $mccsetjmp(jmp_buf);"
    .byte     10
    .byte     10
    .ascii    "#define setjmp $setjmp"
    .byte     10
    .ascii    "#define longjmp $longjmp"
    .byte     10
    .byte     10
    .ascii    "#endif"
    .byte     10
    .byte     10
    .byte     0
L8243:
    .ascii    "/* Header math.h */"
    .byte     10
    .byte     10
    .ascii    "#define HUGE_VAL 1.7976931348623156e+308"
    .byte     10
    .byte     10
    .ascii    "double floor(double);"
    .byte     10
    .ascii    "double ceil(double);"
    .byte     10
    .ascii    "double sqrt(double);"
    .byte     10
    .ascii    "double sin(double);"
    .byte     10
    .ascii    "double cos(double);"
    .byte     10
    .ascii    "double tan(double);"
    .byte     10
    .ascii    "double fmod(double,double);"
    .byte     10
    .ascii    "double asin(double);"
    .byte     10
    .ascii    "double acos(double);"
    .byte     10
    .ascii    "double atan(double);"
    .byte     10
    .ascii    "double log(double);"
    .byte     10
    .ascii    "double log10(double);"
    .byte     10
    .ascii    "double exp(double);"
    .byte     10
    .ascii    "double modf(double,double*);"
    .byte     10
    .ascii    "double atan2(double,double);"
    .byte     10
    .ascii    "double pow(double,double);"
    .byte     10
    .ascii    "double fabs(double);"
    .byte     10
    .ascii    "double sinh(double);"
    .byte     10
    .ascii    "double cosh(double);"
    .byte     10
    .ascii    "double tanh(double);"
    .byte     10
    .ascii    "double frexp(double,int*);"
    .byte     10
    .ascii    "double ldexp(double,int);"
    .byte     10
    .ascii    "int isnan(double);"
    .byte     10
    .byte     10
    .ascii    "#define ldexpl ldexp"
    .byte     10
    .byte     10
    .ascii    "float sinf(float);"
    .byte     10
    .ascii    "float cosf(float);"
    .byte     10
    .ascii    "float tanf(float);"
    .byte     10
    .ascii    "float expf(float);"
    .byte     10
    .ascii    "float powf(float, float);"
    .byte     10
    .ascii    "float logf(float);"
    .byte     10
    .byte     10
    .ascii    "float sqrtf(float);"
    .byte     10
    .ascii    "float acosf(float);"
    .byte     10
    .ascii    "float atan2f(float,float);"
    .byte     10
    .ascii    "float ceilf(float);"
    .byte     10
    .byte     10
    .ascii    "double acosh (double);"
    .byte     10
    .ascii    "long double acoshl(long double);"
    .byte     10
    .ascii    "long double acoshl(long double);"
    .byte     10
    .ascii    "float acoshf(float);"
    .byte     10
    .byte     10
    .ascii    "double asinh (double);"
    .byte     10
    .ascii    "long double asinhl(long double);"
    .byte     10
    .ascii    "long double sinhl(long double);"
    .byte     10
    .ascii    "float asinhf(float);"
    .byte     10
    .byte     10
    .ascii    "double atanh(double);"
    .byte     10
    .ascii    "long double atanhl(long double);"
    .byte     10
    .ascii    "float atanhf(float);"
    .byte     10
    .byte     10
    .ascii    "long double expm1l(long double);"
    .byte     10
    .ascii    "double expm1(double);"
    .byte     10
    .ascii    "float expm1f(float);"
    .byte     10
    .ascii    "double _expm1i(int);"
    .byte     10
    .byte     10
    .ascii    "double cbrt(double);"
    .byte     10
    .ascii    "long double cbrtl(long double);"
    .byte     10
    .ascii    "float cbrtf(float);"
    .byte     10
    .byte     10
    .ascii    "double trunc(double x);"
    .byte     10
    .ascii    "long double truncl(long double);"
    .byte     10
    .ascii    "float truncf(float);"
    .byte     10
    .byte     10
    .ascii    "double round(double);"
    .byte     10
    .ascii    "float roundf(float);"
    .byte     10
    .ascii    "long double roundl(long double);"
    .byte     10
    .ascii    "double _roundi(int);"
    .byte     10
    .byte     10
    .ascii    "long double fminl(long double,long double);"
    .byte     10
    .ascii    "float fminf(float ,float);"
    .byte     10
    .ascii    "double fmin(double,double);"
    .byte     10
    .byte     10
    .ascii    "//float fabsf(float);"
    .byte     10
    .ascii    "#define fabsf fabs"
    .byte     10
    .byte     10
    .ascii    "double lgamma (double);"
    .byte     10
    .ascii    "long double lgammal(long double);"
    .byte     10
    .ascii    "float lgammaf(float);"
    .byte     10
    .byte     10
    .ascii    "long double tgammal(long double);"
    .byte     10
    .ascii    "double tgamma(double);"
    .byte     10
    .ascii    "float tgammaf(float);"
    .byte     10
    .byte     10
    .ascii    "double log1p(double);"
    .byte     10
    .ascii    "long double log1pl(long double);"
    .byte     10
    .ascii    "float log1pf(float);"
    .byte     10
    .byte     10
    .ascii    "long double log10l(long double);"
    .byte     10
    .ascii    "float log10f(float);"
    .byte     10
    .ascii    "double _log10i(int);"
    .byte     10
    .ascii    "double log10(double);"
    .byte     10
    .byte     10
    .ascii    "double erf(double);"
    .byte     10
    .ascii    "long double erfl(long double);"
    .byte     10
    .ascii    "float erff(float);"
    .byte     10
    .byte     10
    .ascii    "double hypot (double, double);"
    .byte     10
    .ascii    "double _hypot(double,double);"
    .byte     10
    .ascii    "long double hypotl(long double,long double);"
    .byte     10
    .ascii    "float hypotf(float,float);"
    .byte     10
    .byte     10
    .ascii    "double nextafter (double, double);"
    .byte     10
    .ascii    "long double nextafterl(long double,long double);"
    .byte     10
    .ascii    "float nextafterf(float,float);"
    .byte     10
    .byte     10
    .ascii    "double nexttoward(double,long double);"
    .byte     10
    .ascii    "long double nexttowardl(long double,long double);"
    .byte     10
    .ascii    "float nexttowardf(float,long double);"
    .byte     10
    .byte     10
    .ascii    "double erfc(double);"
    .byte     10
    .ascii    "long double erfcl(long double);"
    .byte     10
    .ascii    "float erfcf(float);"
    .byte     10
    .byte     10
    .ascii    "int _finite(double);"
    .byte     10
    .ascii    "#define finite _finite"
    .byte     10
    .byte     10
    .ascii    "float floorf(float);"
    .byte     10
    .byte     10
    .ascii    "double _copysign(double,double);"
    .byte     10
    .ascii    "#define copysign _copysign"
    .byte     10
    .byte     10
    .ascii    "long double fmaxl(long double,long double);"
    .byte     10
    .ascii    "double fmax(double,double);"
    .byte     10
    .ascii    "float fmaxf(float,float);"
    .byte     10
    .ascii    "float fmodf(float,float);"
    .byte     10
    .byte     10
    .ascii    "//long double exp2l(long double);"
    .byte     10
    .ascii    "double exp2(double);"
    .byte     10
    .ascii    "float exp2f(float);"
    .byte     10
    .byte     10
    .ascii    "//double log2(double);"
    .byte     10
    .ascii    "#define log2(x) (log(x)*1.442695041)"
    .byte     10
    .byte     10
    .ascii    "#define M_PI 3.1415926535897932384625433"
    .byte     10
    .ascii    "#define M_PI_2 (M_PI/2.0)"
    .byte     10
    .ascii    "#define M_2_PI 0.63661977236758134308"
    .byte     10
    .byte     10
    .ascii    "int isinf(double);"
    .byte     10
    .byte     10
    .ascii    "int _finite(double);"
    .byte     10
    .byte     10
    .ascii    "#define isfinite _finite"
    .byte     10
    .byte     10
    .ascii    "int isfinitef(float);"
    .byte     10
    .ascii    "int isfinitel(long double);"
    .byte     10
    .byte     10
    .byte     0
L8242:
    .ascii    "/* Header _ansi.h */"
    .byte     13
    .byte     10
    .byte     0
L8241:
    .ascii    "/* Header locale.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef $locale"
    .byte     13
    .byte     10
    .ascii    "#define $locale"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define LC_ALL 0"
    .byte     13
    .byte     10
    .ascii    "#define LC_COLLATE 1"
    .byte     13
    .byte     10
    .ascii    "#define LC_CTYPE 2"
    .byte     13
    .byte     10
    .ascii    "#define LC_MONETARY 3"
    .byte     13
    .byte     10
    .ascii    "#define LC_NUMERIC 4"
    .byte     13
    .byte     10
    .ascii    "#define LC_TIME 5"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "struct lconv {"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char *decimal_point;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char *thousands_sep;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char *grouping;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char *int_curr_symbol;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char *currency_symbol;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char *mon_decimal_point;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char *mon_thousands_sep;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char *mon_grouping;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char *positive_sign;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char *negative_sign;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char int_frac_digits;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char frac_digits;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char p_cs_precedes;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char p_sep_by_space;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char n_cs_precedes;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char n_sep_by_space;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char p_sign_posn;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char n_sign_posn;"
    .byte     13
    .byte     10
    .ascii    "};"
    .byte     13
    .byte     10
    .ascii    "char *setlocale(int category, const char *locale);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "struct lconv *localeconv(void);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "char * setlocale(int,const char *);"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     0
L8240:
    .ascii    "/* Header limits.h */"
    .byte     10
    .byte     10
    .ascii    "#define CHAR_BIT 8"
    .byte     10
    .byte     10
    .ascii    "#define CHAR_MIN 0"
    .byte     10
    .ascii    "#define CHAR_MAX 255"
    .byte     10
    .byte     10
    .ascii    "#define UCHAR_MIN 0"
    .byte     10
    .ascii    "#define UCHAR_MAX 255"
    .byte     10
    .byte     10
    .ascii    "#define SCHAR_MIN -128"
    .byte     10
    .ascii    "#define SCHAR_MAX 127"
    .byte     10
    .byte     10
    .ascii    "#define SHRT_MIN -32768"
    .byte     10
    .ascii    "#define SHRT_MAX 32767"
    .byte     10
    .byte     10
    .ascii    "#define USHRT_MIN 0"
    .byte     10
    .ascii    "#define USHRT_MAX 65535"
    .byte     10
    .byte     10
    .ascii    "#define INT_MIN -2147483648"
    .byte     10
    .ascii    "#define INT_MAX  2147483647"
    .byte     10
    .byte     10
    .ascii    "#define UINT_MIN 0"
    .byte     10
    .ascii    "#define UINT_MAX 4294967295"
    .byte     10
    .byte     10
    .ascii    "#define LONG_MIN -2147483648"
    .byte     10
    .ascii    "#define LONG_MAX  2147483647"
    .byte     10
    .byte     10
    .ascii    "#define ULONG_MIN 0"
    .byte     10
    .ascii    "#define ULONG_MAX 4294967295"
    .byte     10
    .byte     10
    .ascii    "#define LLONG_MIN -9223372036854775808LL"
    .byte     10
    .ascii    "#define LLONG_MAX  9223372036854775807LL"
    .byte     10
    .byte     10
    .ascii    "#define ULLONG_MIN 0"
    .byte     10
    .ascii    "#define ULLONG_MAX 0xFFFFFFFFFFFFFFFFLL"
    .byte     10
    .byte     10
    .ascii    "#define SIZE_MAX ULLONG_MAX"
    .byte     10
    .byte     0
L8239:
    .ascii    "/* Header stdint.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef $stdint"
    .byte     13
    .byte     10
    .ascii    "#define $stdint"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef signed char int8_t;"
    .byte     13
    .byte     10
    .ascii    "typedef short int16_t;"
    .byte     13
    .byte     10
    .ascii    "typedef int int32_t;"
    .byte     13
    .byte     10
    .ascii    "typedef long long int int64_t;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef unsigned char uint8_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned short uint16_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned int uint32_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned long long int uint64_t;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef long long int intptr_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned long long int uintptr_t;"
    .byte     13
    .byte     10
    .ascii    "typedef long long intmax_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned long long uintmax_t;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef char int_least8_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned char uint_least8_t;"
    .byte     13
    .byte     10
    .ascii    "typedef short int_least16_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned short uint_least16_t;"
    .byte     13
    .byte     10
    .ascii    "typedef int int_least32_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned int uint_least32_t;"
    .byte     13
    .byte     10
    .ascii    "typedef long long int_least64_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned long long uint_least64_t;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define INTMAX_C(a) (a##LL)"
    .byte     13
    .byte     10
    .ascii    "#define UINTMAX_C(a) (a##ULL)"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef char int_fast8_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned char uint_fast8_t;"
    .byte     13
    .byte     10
    .ascii    "typedef short int_fast16_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned short uint_fast16_t;"
    .byte     13
    .byte     10
    .ascii    "typedef int int_fast32_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned int uint_fast32_t;"
    .byte     13
    .byte     10
    .ascii    "typedef long long int_fast64_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned long long uint_fast64_t;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define INT8_MIN -128"
    .byte     13
    .byte     10
    .ascii    "#define INT8_MAX 127"
    .byte     13
    .byte     10
    .ascii    "#define INT16_MIN -32768"
    .byte     13
    .byte     10
    .ascii    "#define INT16_MAX 32767"
    .byte     13
    .byte     10
    .ascii    "#define INT32_MIN 0x80000000"
    .byte     13
    .byte     10
    .ascii    "#define INT32_MAX 0x7FFFFFFF"
    .byte     13
    .byte     10
    .ascii    "#define INT64_MIN 0x8000000000000000"
    .byte     13
    .byte     10
    .ascii    "#define INT64_MAX 0x7FFFFFFFFFFFFFFF"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define UINT8_MAX 255"
    .byte     13
    .byte     10
    .ascii    "#define UINT16_MAX 65535"
    .byte     13
    .byte     10
    .ascii    "#define UINT32_MAX 0xFFFFFFFF"
    .byte     13
    .byte     10
    .ascii    "#define UINT64_MAX 0xFFFFFFFFFFFFFFFF"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define INTPTR_MIN 0x8000000000000000"
    .byte     13
    .byte     10
    .ascii    "#define INTPTR_MAX 0x7FFFFFFFFFFFFFFF"
    .byte     13
    .byte     10
    .ascii    "#define UINTPTR_MAX 0xFFFFFFFFFFFFFFFF"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define UINT64_MAX 0xFFFFFFFFFFFFFFFF"
    .byte     13
    .byte     10
    .ascii    "#define SIZE_MAX 0xFFFFFFFFFFFFFFFF"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PTRDIFF_MIN 0x8000000000000000"
    .byte     13
    .byte     10
    .ascii    "#define PTRDIFF_MAX 0x7FFFFFFFFFFFFFFF"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define WCHAR_MIN 0"
    .byte     13
    .byte     10
    .ascii    "#define WCHAR_MAX 65535"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define WINT_MIN 0"
    .byte     13
    .byte     10
    .ascii    "#define WINT_MAX 65535"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define UINT64_C(x) (x##ull)"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     0
L8238:
    .ascii    "/* Header inttypes.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#include <stdint.h>"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "/* fprintf macros for signed types */"
    .byte     13
    .byte     10
    .ascii    "#define PRId8 "
    .byte     34
    .ascii    "d"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRId16 "
    .byte     34
    .ascii    "d"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRId32 "
    .byte     34
    .ascii    "d"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRId64 "
    .byte     34
    .ascii    "I64d"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIdLEAST8 "
    .byte     34
    .ascii    "d"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIdLEAST16 "
    .byte     34
    .ascii    "d"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIdLEAST32 "
    .byte     34
    .ascii    "d"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIdLEAST64 "
    .byte     34
    .ascii    "I64d"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIdFAST8 "
    .byte     34
    .ascii    "d"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIdFAST16 "
    .byte     34
    .ascii    "d"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIdFAST32 "
    .byte     34
    .ascii    "d"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIdFAST64 "
    .byte     34
    .ascii    "I64d"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIdMAX "
    .byte     34
    .ascii    "I64d"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIi8 "
    .byte     34
    .ascii    "i"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIi16 "
    .byte     34
    .ascii    "i"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIi32 "
    .byte     34
    .ascii    "i"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIi64 "
    .byte     34
    .ascii    "I64i"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIiLEAST8 "
    .byte     34
    .ascii    "i"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIiLEAST16 "
    .byte     34
    .ascii    "i"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIiLEAST32 "
    .byte     34
    .ascii    "i"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIiLEAST64 "
    .byte     34
    .ascii    "I64i"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIiFAST8 "
    .byte     34
    .ascii    "i"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIiFAST16 "
    .byte     34
    .ascii    "i"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIiFAST32 "
    .byte     34
    .ascii    "i"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIiFAST64 "
    .byte     34
    .ascii    "I64i"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIiMAX "
    .byte     34
    .ascii    "I64i"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIo8 "
    .byte     34
    .ascii    "o"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIo16 "
    .byte     34
    .ascii    "o"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIo32 "
    .byte     34
    .ascii    "o"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIo64 "
    .byte     34
    .ascii    "I64o"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIoLEAST8 "
    .byte     34
    .ascii    "o"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIoLEAST16 "
    .byte     34
    .ascii    "o"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIoLEAST32 "
    .byte     34
    .ascii    "o"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIoLEAST64 "
    .byte     34
    .ascii    "I64o"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIoFAST8 "
    .byte     34
    .ascii    "o"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIoFAST16 "
    .byte     34
    .ascii    "o"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIoFAST32 "
    .byte     34
    .ascii    "o"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIoFAST64 "
    .byte     34
    .ascii    "I64o"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIoMAX "
    .byte     34
    .ascii    "I64o"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "/* fprintf macros for unsigned types */"
    .byte     13
    .byte     10
    .ascii    "#define PRIu8 "
    .byte     34
    .ascii    "u"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIu16 "
    .byte     34
    .ascii    "u"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIu32 "
    .byte     34
    .ascii    "u"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIu64 "
    .byte     34
    .ascii    "I64u"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIuLEAST8 "
    .byte     34
    .ascii    "u"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIuLEAST16 "
    .byte     34
    .ascii    "u"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIuLEAST32 "
    .byte     34
    .ascii    "u"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIuLEAST64 "
    .byte     34
    .ascii    "I64u"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIuFAST8 "
    .byte     34
    .ascii    "u"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIuFAST16 "
    .byte     34
    .ascii    "u"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIuFAST32 "
    .byte     34
    .ascii    "u"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIuFAST64 "
    .byte     34
    .ascii    "I64u"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIuMAX "
    .byte     34
    .ascii    "I64u"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIx8 "
    .byte     34
    .ascii    "x"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIx16 "
    .byte     34
    .ascii    "x"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIx32 "
    .byte     34
    .ascii    "x"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIx64 "
    .byte     34
    .ascii    "I64x"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIxLEAST8 "
    .byte     34
    .ascii    "x"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIxLEAST16 "
    .byte     34
    .ascii    "x"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIxLEAST32 "
    .byte     34
    .ascii    "x"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIxLEAST64 "
    .byte     34
    .ascii    "I64x"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIxFAST8 "
    .byte     34
    .ascii    "x"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIxFAST16 "
    .byte     34
    .ascii    "x"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIxFAST32 "
    .byte     34
    .ascii    "x"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIxFAST64 "
    .byte     34
    .ascii    "I64x"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIxMAX "
    .byte     34
    .ascii    "I64x"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIX8 "
    .byte     34
    .ascii    "X"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIX16 "
    .byte     34
    .ascii    "X"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIX32 "
    .byte     34
    .ascii    "X"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIX64 "
    .byte     34
    .ascii    "I64X"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIXLEAST8 "
    .byte     34
    .ascii    "X"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIXLEAST16 "
    .byte     34
    .ascii    "X"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIXLEAST32 "
    .byte     34
    .ascii    "X"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIXLEAST64 "
    .byte     34
    .ascii    "I64X"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIXFAST8 "
    .byte     34
    .ascii    "X"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIXFAST16 "
    .byte     34
    .ascii    "X"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIXFAST32 "
    .byte     34
    .ascii    "X"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIXFAST64 "
    .byte     34
    .ascii    "I64X"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIXMAX "
    .byte     34
    .ascii    "I64X"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     0
L8237:
    .ascii    "/* Header float.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "//#define DBL_MAX_10_EXP 308"
    .byte     13
    .byte     10
    .ascii    "//#define DBL_MANT_DIG 53"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define FLT_RADIX 2"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define FLT_DIG 6"
    .byte     13
    .byte     10
    .ascii    "#define FLT_MIN_EXP -125"
    .byte     13
    .byte     10
    .ascii    "#define FLT_MIN 1.17549435E-38F // decimal constant"
    .byte     13
    .byte     10
    .ascii    "#define FLT_MIN 0X1P-126F // hex constant"
    .byte     13
    .byte     10
    .ascii    "#define FLT_TRUE_MIN 1.40129846E-45F // decimal constant"
    .byte     13
    .byte     10
    .ascii    "#define FLT_TRUE_MIN 0X1P-149F // hex constant"
    .byte     13
    .byte     10
    .ascii    "#define FLT_HAS_SUBNORM 1"
    .byte     13
    .byte     10
    .ascii    "#define FLT_MIN_10_EXP -37"
    .byte     13
    .byte     10
    .ascii    "#define FLT_MAX_EXP +128"
    .byte     13
    .byte     10
    .ascii    "#define FLT_MAX 3.40282347E+38F // decimal constant"
    .byte     13
    .byte     10
    .ascii    "#define FLT_MAX 0X1.fffffeP127F // hex constant"
    .byte     13
    .byte     10
    .ascii    "#define FLT_MAX_10_EXP +38"
    .byte     13
    .byte     10
    .ascii    "#define FLT_EPSILON 1.19209290e-07F"
    .byte     13
    .byte     10
    .ascii    "#define FLT_MANT_DIG 23"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define DBL_MANT_DIG 53"
    .byte     13
    .byte     10
    .ascii    "#define DBL_EPSILON 2.2204460492503131E-16 // decimal constant"
    .byte     13
    .byte     10
    .ascii    "//#define DBL_EPSILON 0X1P-52 // hex constant"
    .byte     13
    .byte     10
    .ascii    "#define DBL_DECIMAL_DIG 17"
    .byte     13
    .byte     10
    .ascii    "#define DBL_DIG 15"
    .byte     13
    .byte     10
    .ascii    "#define DBL_MIN_EXP -1021"
    .byte     13
    .byte     10
    .ascii    "#define DBL_MIN 2.2250738585072014E-308 // decimal constant"
    .byte     13
    .byte     10
    .ascii    "//#define DBL_MIN 0X1P-1022 // hex constant"
    .byte     13
    .byte     10
    .ascii    "#define DBL_TRUE_MIN 4.9406564584124654E-324 // decimal constant"
    .byte     13
    .byte     10
    .ascii    "//#define DBL_TRUE_MIN 0X1P-1074 // hex constant"
    .byte     13
    .byte     10
    .ascii    "#define DBL_HAS_SUBNORM 1"
    .byte     13
    .byte     10
    .ascii    "#define DBL_MIN_10_EXP -307"
    .byte     13
    .byte     10
    .ascii    "#define DBL_MAX_EXP +1024"
    .byte     13
    .byte     10
    .ascii    "#define DBL_MAX 1.7976931348623157E+308 // decimal constant"
    .byte     13
    .byte     10
    .ascii    "//#define DBL_MAX 0X1.fffffffffffffP1023 // h"
    .byte     13
    .byte     10
    .ascii    "#define DBL_MAX_10_EXP +308"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define LDBL_MIN DBL_MIN"
    .byte     13
    .byte     10
    .ascii    "#define LDBL_MAX DBL_MAX"
    .byte     13
    .byte     10
    .ascii    "#define LDBL_EPSILON 2.2204460492503131E-16"
    .byte     13
    .byte     10
    .ascii    "#define LDBL_MANT_DIG 53"
    .byte     13
    .byte     10
    .ascii    "#define LDBL_MIN_EXP -1021"
    .byte     13
    .byte     10
    .ascii    "#define LDBL_MAX_EXP +1024"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int     _isnan(double);"
    .byte     13
    .byte     10
    .ascii    "#define isnan _isnan"
    .byte     13
    .byte     10
    .byte     0
L8236:
    .ascii    "/* Header fenv.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int feclearexcept(int);"
    .byte     13
    .byte     10
    .ascii    "int fetestexcept(int);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define FE_INVALID 1"
    .byte     13
    .byte     10
    .ascii    "#define FE_DENORMAL 2"
    .byte     13
    .byte     10
    .ascii    "#define FE_INEXACT 32"
    .byte     13
    .byte     10
    .ascii    "#define FE_DIVBYZERO 4 "
    .byte     13
    .byte     10
    .ascii    "#define FE_OVERFLOW 8"
    .byte     13
    .byte     10
    .ascii    "#define FE_UNDERFLOW 16"
    .byte     13
    .byte     10
    .ascii    "#define FE_STACKFAULT 64"
    .byte     13
    .byte     10
    .ascii    "#define FE_ALL_EXCEPT (FE_INVALID|FE_DENORMAL|FE_INEXACT|FE_DIVBYZERO|FE_OVERFLOW|FE_UNDERFLOW)"
    .byte     13
    .byte     10
    .byte     0
L8235:
    .ascii    "/* Header errno.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef $errno"
    .byte     13
    .byte     10
    .ascii    "#define $errno"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "extern int* _errno(void);"
    .byte     13
    .byte     10
    .ascii    "#define errno (*_errno())"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define EPERM 1"
    .byte     13
    .byte     10
    .ascii    "#define ENOENT 2"
    .byte     13
    .byte     10
    .ascii    "#define ESRCH 3"
    .byte     13
    .byte     10
    .ascii    "#define EINTR 4"
    .byte     13
    .byte     10
    .ascii    "#define EIO 5"
    .byte     13
    .byte     10
    .ascii    "#define ENXIO 6"
    .byte     13
    .byte     10
    .ascii    "#define E2BIG 7"
    .byte     13
    .byte     10
    .ascii    "#define ENOEXEC 8"
    .byte     13
    .byte     10
    .ascii    "#define EBADF 9"
    .byte     13
    .byte     10
    .ascii    "#define ECHILD 10"
    .byte     13
    .byte     10
    .ascii    "#define EAGAIN 11"
    .byte     13
    .byte     10
    .ascii    "#define ENOMEM 12"
    .byte     13
    .byte     10
    .ascii    "#define EACCES 13"
    .byte     13
    .byte     10
    .ascii    "#define EFAULT 14"
    .byte     13
    .byte     10
    .ascii    "#define ENOTBLK 15"
    .byte     13
    .byte     10
    .ascii    "#define EBUSY 16"
    .byte     13
    .byte     10
    .ascii    "#define EEXIST 17"
    .byte     13
    .byte     10
    .ascii    "#define EXDEV 18"
    .byte     13
    .byte     10
    .ascii    "#define ENODEV 19"
    .byte     13
    .byte     10
    .ascii    "#define ENOTDIR 20"
    .byte     13
    .byte     10
    .ascii    "#define EISDIR 21"
    .byte     13
    .byte     10
    .ascii    "#define EINVAL 22"
    .byte     13
    .byte     10
    .ascii    "#define ENFILE 23"
    .byte     13
    .byte     10
    .ascii    "#define EMFILE 24"
    .byte     13
    .byte     10
    .ascii    "#define ENOTTY 25"
    .byte     13
    .byte     10
    .ascii    "#define ETXTBSY 26"
    .byte     13
    .byte     10
    .ascii    "#define EFBIG 27"
    .byte     13
    .byte     10
    .ascii    "#define ENOSPC 28"
    .byte     13
    .byte     10
    .ascii    "#define ESPIPE 29"
    .byte     13
    .byte     10
    .ascii    "#define EROFS 30"
    .byte     13
    .byte     10
    .ascii    "#define EMLINK 31"
    .byte     13
    .byte     10
    .ascii    "#define EPIPE 32"
    .byte     13
    .byte     10
    .ascii    "#define EDOM 33"
    .byte     13
    .byte     10
    .ascii    "#define ERANGE 34"
    .byte     13
    .byte     10
    .ascii    "#define ENOMSG 35"
    .byte     13
    .byte     10
    .ascii    "#define EIDRM 36"
    .byte     13
    .byte     10
    .ascii    "#define ECHRNG 37"
    .byte     13
    .byte     10
    .ascii    "#define EL2NSYNC 38"
    .byte     13
    .byte     10
    .ascii    "#define EL3HLT 39"
    .byte     13
    .byte     10
    .ascii    "#define EL3RST 40"
    .byte     13
    .byte     10
    .ascii    "#define ELNRNG 41"
    .byte     13
    .byte     10
    .ascii    "#define EUNATCH 42"
    .byte     13
    .byte     10
    .ascii    "#define ENOCSI 43"
    .byte     13
    .byte     10
    .ascii    "#define EL2HLT 44"
    .byte     13
    .byte     10
    .ascii    "#define EDEADLK 45"
    .byte     13
    .byte     10
    .ascii    "#define ENOLCK 46"
    .byte     13
    .byte     10
    .ascii    "#define EBADE 50"
    .byte     13
    .byte     10
    .ascii    "#define EBADR 51"
    .byte     13
    .byte     10
    .ascii    "#define EXFULL 52"
    .byte     13
    .byte     10
    .ascii    "#define ENOANO 53"
    .byte     13
    .byte     10
    .ascii    "#define EBADRQC 54"
    .byte     13
    .byte     10
    .ascii    "#define EBADSLT 55"
    .byte     13
    .byte     10
    .ascii    "#define EDEADLOCK 56"
    .byte     13
    .byte     10
    .ascii    "#define EBFONT 57"
    .byte     13
    .byte     10
    .ascii    "#define ENOSTR 60"
    .byte     13
    .byte     10
    .ascii    "#define ENODATA 61"
    .byte     13
    .byte     10
    .ascii    "#define ETIME 62"
    .byte     13
    .byte     10
    .ascii    "#define ENOSR 63"
    .byte     13
    .byte     10
    .ascii    "#define ENONET 64"
    .byte     13
    .byte     10
    .ascii    "#define ENOPKG 65"
    .byte     13
    .byte     10
    .ascii    "#define EREMOTE 66"
    .byte     13
    .byte     10
    .ascii    "#define ENOLINK 67"
    .byte     13
    .byte     10
    .ascii    "#define EADV 68"
    .byte     13
    .byte     10
    .ascii    "#define ESRMNT 69"
    .byte     13
    .byte     10
    .ascii    "#define ECOMM 70"
    .byte     13
    .byte     10
    .ascii    "#define EPROTO 71"
    .byte     13
    .byte     10
    .ascii    "#define EMULTIHOP 74"
    .byte     13
    .byte     10
    .ascii    "#define ELBIN 75"
    .byte     13
    .byte     10
    .ascii    "#define EOVERFLOW 76"
    .byte     13
    .byte     10
    .ascii    "#define EBADMSG 77"
    .byte     13
    .byte     10
    .ascii    "#define ENOTUNIQ 80"
    .byte     13
    .byte     10
    .ascii    "#define EBADFD 81"
    .byte     13
    .byte     10
    .ascii    "#define EREMCHG 82"
    .byte     13
    .byte     10
    .ascii    "#define ELIBACC 83"
    .byte     13
    .byte     10
    .ascii    "#define ELIBBAD 84"
    .byte     13
    .byte     10
    .ascii    "#define ELIBSCN 85"
    .byte     13
    .byte     10
    .ascii    "#define ELIBMAX 86"
    .byte     13
    .byte     10
    .ascii    "#define ELIBEXEC 87"
    .byte     13
    .byte     10
    .ascii    "#define ENOSYS 88"
    .byte     13
    .byte     10
    .ascii    "#define ENMFILE 89"
    .byte     13
    .byte     10
    .ascii    "#define ENOTEMPTY 90"
    .byte     13
    .byte     10
    .ascii    "#define ENAMETOOLONG 91"
    .byte     13
    .byte     10
    .ascii    "#define EILSEQ 92"
    .byte     13
    .byte     10
    .ascii    "#define __ELASTERROR 2000"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     0
L8234:
    .ascii    "/* Header ctype.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int tolower(int);"
    .byte     13
    .byte     10
    .ascii    "int toupper(int);"
    .byte     13
    .byte     10
    .ascii    "int isalpha(int);"
    .byte     13
    .byte     10
    .ascii    "int isdigit(int);"
    .byte     13
    .byte     10
    .ascii    "int isspace(int);"
    .byte     13
    .byte     10
    .ascii    "int isalnum(int);"
    .byte     13
    .byte     10
    .ascii    "int isupper(int);"
    .byte     13
    .byte     10
    .ascii    "int islower(int);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int isxdigit(int);"
    .byte     13
    .byte     10
    .ascii    "int iscntrl(int);"
    .byte     13
    .byte     10
    .ascii    "int isgraph(int);"
    .byte     13
    .byte     10
    .ascii    "int ispunct(int);"
    .byte     13
    .byte     10
    .ascii    "int isprint(int);"
    .byte     13
    .byte     10
    .ascii    "int __isascii(int);"
    .byte     13
    .byte     10
    .ascii    "#define isascii __isascii"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int __toascii(int);"
    .byte     13
    .byte     10
    .ascii    "#define toascii __toascii"
    .byte     13
    .byte     10
    .byte     0
L8233:
    .ascii    "/* Header assert.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "//#define assert(x) 0"
    .byte     13
    .byte     10
    .ascii    "#define assert(x)"
    .byte     13
    .byte     10
    .byte     0
L8232:
    .ascii    "stderr"
    .byte     0
L8231:
    .ascii    "stdout"
    .byte     0
L8230:
    .ascii    "stdin"
    .byte     0
L8229:
    .ascii    "Dec"
    .byte     0
L8228:
    .ascii    "Nov"
    .byte     0
L8227:
    .ascii    "Oct"
    .byte     0
L8226:
    .ascii    "Sep"
    .byte     0
L8225:
    .ascii    "Aug"
    .byte     0
L8224:
    .ascii    "Jul"
    .byte     0
L8223:
    .ascii    "Jun"
    .byte     0
L8222:
    .ascii    "May"
    .byte     0
L8221:
    .ascii    "Apr"
    .byte     0
L8220:
    .ascii    "Mar"
    .byte     0
L8219:
    .ascii    "Feb"
    .byte     0
L8218:
    .ascii    "Jan"
    .byte     0
L8217:
    .ascii    "bool_c"
    .byte     0
L8216:
    .ascii    "truncate_c"
    .byte     0
L8215:
    .ascii    "narrow_c"
    .byte     0
L8214:
    .ascii    "fnarrow_c"
    .byte     0
L8213:
    .ascii    "fwiden_c"
    .byte     0
L8212:
    .ascii    "ufix_c"
    .byte     0
L8211:
    .ascii    "sfix_c"
    .byte     0
L8210:
    .ascii    "ufloat_c"
    .byte     0
L8209:
    .ascii    "sfloat_c"
    .byte     0
L8208:
    .ascii    "uwiden_c"
    .byte     0
L8207:
    .ascii    "swiden_c"
    .byte     0
L8206:
    .ascii    "hard_c"
    .byte     0
L8205:
    .ascii    "soft_c"
    .byte     0
L8204:
    .ascii    "no_conv"
    .byte     0
L8203:
    .ascii    "$$dummy"
    .byte     0
L8202:
    .ascii    "$longjmp"
    .byte     0
L8201:
    .ascii    "$setjmp"
    .byte     0
L8200:
    .ascii    "_Alignof"
    .byte     0
L8199:
    .ascii    "_Generic"
    .byte     0
L8198:
    .ascii    "defined"
    .byte     0
L8197:
    .ascii    "lengthof"
    .byte     0
L8196:
    .ascii    "sizeof"
    .byte     0
L8195:
    .ascii    "__FUNCTION__"
    .byte     0
L8194:
    .ascii    "__func__"
    .byte     0
L8193:
    .ascii    "__MCCI__"
    .byte     0
L8192:
    .ascii    "__MCC__"
    .byte     0
L8191:
    .ascii    "__TIME__"
    .byte     0
L8190:
    .ascii    "__LINE__"
    .byte     0
L8189:
    .ascii    "__FILE__"
    .byte     0
L8188:
    .ascii    "__DATE__"
    .byte     0
L8187:
    .ascii    "_Bool"
    .byte     0
L8186:
    .ascii    "unsigned"
    .byte     0
L8185:
    .ascii    "signed"
    .byte     0
L8184:
    .ascii    "double"
    .byte     0
L8183:
    .ascii    "float"
    .byte     0
L8182:
    .ascii    "int"
    .byte     0
L8181:
    .ascii    "long"
    .byte     0
L8180:
    .ascii    "short"
    .byte     0
L8179:
    .ascii    "char"
    .byte     0
L8178:
    .ascii    "void"
    .byte     0
L8177:
    .ascii    "enum"
    .byte     0
L8176:
    .ascii    "_Alignas"
    .byte     0
L8175:
    .ascii    "_Noreturn"
    .byte     0
L8174:
    .ascii    "inline"
    .byte     0
L8173:
    .ascii    "_Atomic"
    .byte     0
L8172:
    .ascii    "restrict"
    .byte     0
L8171:
    .ascii    "volatile"
    .byte     0
L8170:
    .ascii    "const"
    .byte     0
L8169:
    .ascii    "typedef"
    .byte     0
L8168:
    .ascii    "extern"
    .byte     0
L8167:
    .ascii    "static"
    .byte     0
L8166:
    .ascii    "register"
    .byte     0
L8165:
    .ascii    "auto"
    .byte     0
L8164:
    .ascii    "line"
    .byte     0
L8163:
    .ascii    "pragma"
    .byte     0
L8162:
    .ascii    "error"
    .byte     0
L8161:
    .ascii    "undef"
    .byte     0
L8160:
    .ascii    "endif"
    .byte     0
L8159:
    .ascii    "ifndef"
    .byte     0
L8158:
    .ascii    "ifdef"
    .byte     0
L8157:
    .ascii    "elif"
    .byte     0
L8156:
    .ascii    "define"
    .byte     0
L8155:
    .ascii    "include"
    .byte     0
L8154:
    .ascii    "union"
    .byte     0
L8153:
    .ascii    "struct"
    .byte     0
L8152:
    .ascii    "switch"
    .byte     0
L8151:
    .ascii    "goto"
    .byte     0
L8150:
    .ascii    "continue"
    .byte     0
L8149:
    .ascii    "break"
    .byte     0
L8148:
    .ascii    "return"
    .byte     0
L8147:
    .ascii    "while"
    .byte     0
L8146:
    .ascii    "do"
    .byte     0
L8145:
    .ascii    "for"
    .byte     0
L8144:
    .ascii    "default"
    .byte     0
L8143:
    .ascii    "case"
    .byte     0
L8142:
    .ascii    "else"
    .byte     0
L8141:
    .ascii    "if"
    .byte     0
L8140:
    .ascii    "labelid"
    .byte     0
L8139:
    .ascii    "structtagid"
    .byte     0
L8138:
    .ascii    "enumtagid"
    .byte     0
L8137:
    .ascii    "enumid"
    .byte     0
L8136:
    .ascii    "fieldid"
    .byte     0
L8135:
    .ascii    "paramid"
    .byte     0
L8134:
    .ascii    "frameid"
    .byte     0
L8133:
    .ascii    "staticid"
    .byte     0
L8132:
    .ascii    "procid"
    .byte     0
L8131:
    .ascii    "typeid"
    .byte     0
L8130:
    .ascii    "extmoduleid"
    .byte     0
L8129:
    .ascii    "moduleid"
    .byte     0
L8128:
    .ascii    "programid"
    .byte     0
L8127:
    .ascii    "macroid"
    .byte     0
L8126:
    .ascii    "nullid"
    .byte     0
L8125:
    .ascii    "ns_fields"
    .byte     0
L8124:
    .ascii    "ns_labels"
    .byte     0
L8123:
    .ascii    "ns_tags"
    .byte     0
L8122:
    .ascii    "ns_general"
    .byte     0
L8121:
    .ascii    "ns_none"
    .byte     0
L8120:
    .ascii    "pragmadir"
    .byte     0
L8119:
    .ascii    "linedir"
    .byte     0
L8118:
    .ascii    "blankdir"
    .byte     0
L8117:
    .ascii    "messagedir"
    .byte     0
L8116:
    .ascii    "errordir"
    .byte     0
L8115:
    .ascii    "undefdir"
    .byte     0
L8114:
    .ascii    "ifndefdir"
    .byte     0
L8113:
    .ascii    "ifdefdir"
    .byte     0
L8112:
    .ascii    "includedir"
    .byte     0
L8111:
    .ascii    "endifdir"
    .byte     0
L8110:
    .ascii    "elsedir"
    .byte     0
L8109:
    .ascii    "elifdir"
    .byte     0
L8108:
    .ascii    "ifdir"
    .byte     0
L8107:
    .ascii    "emitdir"
    .byte     0
L8106:
    .ascii    "definedir"
    .byte     0
L8105:
    .byte     0
L8104:
    .ascii    "k"
    .byte     0
L8103:
    .byte     0
L8102:
    .ascii    "w"
    .byte     0
L8101:
    .ascii    "s"
    .byte     0
L8100:
    .ascii    "n"
    .byte     0
L8099:
    .byte     0
L8098:
    .ascii    ">>="
    .byte     0
L8097:
    .ascii    "<<="
    .byte     0
L8096:
    .ascii    "^="
    .byte     0
L8095:
    .ascii    "&="
    .byte     0
L8094:
    .ascii    "|="
    .byte     0
L8093:
    .ascii    "%="
    .byte     0
L8092:
    .ascii    "/="
    .byte     0
L8091:
    .ascii    "*="
    .byte     0
L8090:
    .ascii    "-="
    .byte     0
L8089:
    .ascii    "+="
    .byte     0
L8088:
    .ascii    ">"
    .byte     0
L8087:
    .ascii    ">="
    .byte     0
L8086:
    .ascii    "<="
    .byte     0
L8085:
    .ascii    "<"
    .byte     0
L8084:
    .ascii    "!="
    .byte     0
L8083:
    .ascii    "=="
    .byte     0
L8082:
    .ascii    "abs"
    .byte     0
L8081:
    .ascii    "--"
    .byte     0
L8080:
    .ascii    "++"
    .byte     0
L8079:
    .ascii    "!"
    .byte     0
L8078:
    .ascii    "~"
    .byte     0
L8077:
    .ascii    ">>"
    .byte     0
L8076:
    .ascii    "<<"
    .byte     0
L8075:
    .ascii    "&&"
    .byte     0
L8074:
    .ascii    "||"
    .byte     0
L8073:
    .ascii    "^"
    .byte     0
L8072:
    .ascii    "&"
    .byte     0
L8071:
    .ascii    "|"
    .byte     0
L8070:
    .ascii    "%"
    .byte     0
L8069:
    .ascii    "/"
    .byte     0
L8068:
    .ascii    "*"
    .byte     0
L8067:
    .ascii    "-"
    .byte     0
L8066:
    .ascii    "+"
    .byte     0
L8065:
    .byte     92
    .byte     0
L8064:
    .ascii    "..."
    .byte     0
L8063:
    .ascii    "~"
    .byte     0
L8062:
    .ascii    "?"
    .byte     0
L8061:
    .ascii    "}"
    .byte     0
L8060:
    .ascii    "{"
    .byte     0
L8059:
    .ascii    "]"
    .byte     0
L8058:
    .ascii    "["
    .byte     0
L8057:
    .ascii    ")"
    .byte     0
L8056:
    .ascii    "("
    .byte     0
L8055:
    .ascii    ":="
    .byte     0
L8054:
    .ascii    "="
    .byte     0
L8053:
    .ascii    ":"
    .byte     0
L8052:
    .ascii    ";"
    .byte     0
L8051:
    .ascii    ","
    .byte     0
L8050:
    .ascii    "##"
    .byte     0
L8049:
    .ascii    "#"
    .byte     0
L8048:
    .ascii    "->"
    .byte     0
L8047:
    .ascii    "."
    .byte     0
L8046:
    .byte     0
L8045:
    .ascii    "kdummysym"
    .byte     0
L8044:
    .ascii    "ksetjmpsym"
    .byte     0
L8043:
    .ascii    "kalignofsym"
    .byte     0
L8042:
    .ascii    "kgenericsym"
    .byte     0
L8041:
    .ascii    "kdefinedsym"
    .byte     0
L8040:
    .ascii    "ksizeofsym"
    .byte     0
L8039:
    .ascii    "kenumsym"
    .byte     0
L8038:
    .ascii    "kalignassym"
    .byte     0
L8037:
    .ascii    "kfnspecsym"
    .byte     0
L8036:
    .ascii    "kstdtypesym"
    .byte     0
L8035:
    .ascii    "ktypequalsym"
    .byte     0
L8034:
    .ascii    "klinkagesym"
    .byte     0
L8033:
    .ascii    "kunionsym"
    .byte     0
L8032:
    .ascii    "kstructsym"
    .byte     0
L8031:
    .ascii    "kswitchsym"
    .byte     0
L8030:
    .ascii    "kgotosym"
    .byte     0
L8029:
    .ascii    "kcontinuesym"
    .byte     0
L8028:
    .ascii    "kbreaksym"
    .byte     0
L8027:
    .ascii    "kreturnsym"
    .byte     0
L8026:
    .ascii    "kdosym"
    .byte     0
L8025:
    .ascii    "kwhilesym"
    .byte     0
L8024:
    .ascii    "kforsym"
    .byte     0
L8023:
    .ascii    "kdefaultsym"
    .byte     0
L8022:
    .ascii    "kcasesym"
    .byte     0
L8021:
    .ascii    "kelsesym"
    .byte     0
L8020:
    .ascii    "kifsym"
    .byte     0
L8019:
    .ascii    "ktypespecsym"
    .byte     0
L8018:
    .ascii    "predefmacrosym"
    .byte     0
L8017:
    .ascii    "ksourcedirsym"
    .byte     0
L8016:
    .ascii    "namesym"
    .byte     0
L8015:
    .ascii    "placeholdersym"
    .byte     0
L8014:
    .ascii    "whitespacesym"
    .byte     0
L8013:
    .ascii    "wstringconstsym"
    .byte     0
L8012:
    .ascii    "stringconstsym"
    .byte     0
L8011:
    .ascii    "wcharconstsym"
    .byte     0
L8010:
    .ascii    "charconstsym"
    .byte     0
L8009:
    .ascii    "realconstsym"
    .byte     0
L8008:
    .ascii    "intconstsym"
    .byte     0
L8007:
    .ascii    "rawnumbersym"
    .byte     0
L8006:
    .ascii    "eofsym"
    .byte     0
L8005:
    .ascii    "eolsym"
    .byte     0
L8004:
    .ascii    "shrtosym"
    .byte     0
L8003:
    .ascii    "shltosym"
    .byte     0
L8002:
    .ascii    "ixortosym"
    .byte     0
L8001:
    .ascii    "iandtosym"
    .byte     0
L8000:
    .ascii    "iortosym"
    .byte     0
L7999:
    .ascii    "remtosym"
    .byte     0
L7998:
    .ascii    "divtosym"
    .byte     0
L7997:
    .ascii    "multosym"
    .byte     0
L7996:
    .ascii    "subtosym"
    .byte     0
L7995:
    .ascii    "addtosym"
    .byte     0
L7994:
    .ascii    "gtsym"
    .byte     0
L7993:
    .ascii    "gesym"
    .byte     0
L7992:
    .ascii    "lesym"
    .byte     0
L7991:
    .ascii    "ltsym"
    .byte     0
L7990:
    .ascii    "nesym"
    .byte     0
L7989:
    .ascii    "eqsym"
    .byte     0
L7988:
    .ascii    "abssym"
    .byte     0
L7987:
    .ascii    "decrsym"
    .byte     0
L7986:
    .ascii    "incrsym"
    .byte     0
L7985:
    .ascii    "notlsym"
    .byte     0
L7984:
    .ascii    "inotsym"
    .byte     0
L7983:
    .ascii    "shrsym"
    .byte     0
L7982:
    .ascii    "shlsym"
    .byte     0
L7981:
    .ascii    "andlsym"
    .byte     0
L7980:
    .ascii    "orlsym"
    .byte     0
L7979:
    .ascii    "ixorsym"
    .byte     0
L7978:
    .ascii    "iandsym"
    .byte     0
L7977:
    .ascii    "iorsym"
    .byte     0
L7976:
    .ascii    "remsym"
    .byte     0
L7975:
    .ascii    "divsym"
    .byte     0
L7974:
    .ascii    "mulsym"
    .byte     0
L7973:
    .ascii    "subsym"
    .byte     0
L7972:
    .ascii    "addsym"
    .byte     0
L7971:
    .ascii    "backslashsym"
    .byte     0
L7970:
    .ascii    "ellipsissym"
    .byte     0
L7969:
    .ascii    "curlsym"
    .byte     0
L7968:
    .ascii    "questionsym"
    .byte     0
L7967:
    .ascii    "rcurlysym"
    .byte     0
L7966:
    .ascii    "lcurlysym"
    .byte     0
L7965:
    .ascii    "rsqsym"
    .byte     0
L7964:
    .ascii    "lsqsym"
    .byte     0
L7963:
    .ascii    "rbracksym"
    .byte     0
L7962:
    .ascii    "lbracksym"
    .byte     0
L7961:
    .ascii    "assignsym2"
    .byte     0
L7960:
    .ascii    "assignsym"
    .byte     0
L7959:
    .ascii    "colonsym"
    .byte     0
L7958:
    .ascii    "semisym"
    .byte     0
L7957:
    .ascii    "commasym"
    .byte     0
L7956:
    .ascii    "hashhashsym"
    .byte     0
L7955:
    .ascii    "lithashsym"
    .byte     0
L7954:
    .ascii    "hashsym"
    .byte     0
L7953:
    .ascii    "lexhashsym"
    .byte     0
L7952:
    .ascii    "idotsym"
    .byte     0
L7951:
    .ascii    "dotsym"
    .byte     0
L7950:
    .ascii    "errorsym"
    .byte     0
L7949:
    .ascii    "jdummy"
    .byte     0
L7948:
    .ascii    "longjmp"
    .byte     0
L7947:
    .ascii    "setjmp"
    .byte     0
L7946:
    .ascii    "-- postdecr"
    .byte     0
L7945:
    .ascii    "++ postincr"
    .byte     0
L7944:
    .ascii    "-- preincr"
    .byte     0
L7943:
    .ascii    "++ preincr"
    .byte     0
L7942:
    .ascii    ">>="
    .byte     0
L7941:
    .ascii    "<<="
    .byte     0
L7940:
    .ascii    "^="
    .byte     0
L7939:
    .ascii    "|="
    .byte     0
L7938:
    .ascii    "&="
    .byte     0
L7937:
    .ascii    "%="
    .byte     0
L7936:
    .ascii    "/="
    .byte     0
L7935:
    .ascii    "*="
    .byte     0
L7934:
    .ascii    "-="
    .byte     0
L7933:
    .ascii    "+="
    .byte     0
L7932:
    .ascii    "~ inot"
    .byte     0
L7931:
    .ascii    "abs"
    .byte     0
L7930:
    .ascii    "- neg"
    .byte     0
L7929:
    .ascii    "jscale"
    .byte     0
L7928:
    .ascii    "jconvert"
    .byte     0
L7927:
    .ascii    "addrof &"
    .byte     0
L7926:
    .ascii    "subptr"
    .byte     0
L7925:
    .ascii    "addptr"
    .byte     0
L7924:
    .ascii    "ptr"
    .byte     0
L7923:
    .ascii    "jindex"
    .byte     0
L7922:
    .ascii    "jidot"
    .byte     0
L7921:
    .ascii    "jdot"
    .byte     0
L7920:
    .ascii    ">>"
    .byte     0
L7919:
    .ascii    "<<"
    .byte     0
L7918:
    .ascii    "^ ixor"
    .byte     0
L7917:
    .ascii    "| ior"
    .byte     0
L7916:
    .ascii    "& iand"
    .byte     0
L7915:
    .ascii    "% mod"
    .byte     0
L7914:
    .ascii    "/ div"
    .byte     0
L7913:
    .ascii    "* mul"
    .byte     0
L7912:
    .ascii    "- sub"
    .byte     0
L7911:
    .ascii    "+ add"
    .byte     0
L7910:
    .ascii    ">="
    .byte     0
L7909:
    .ascii    ">"
    .byte     0
L7908:
    .ascii    "<="
    .byte     0
L7907:
    .ascii    "<"
    .byte     0
L7906:
    .ascii    "!="
    .byte     0
L7905:
    .ascii    "=="
    .byte     0
L7904:
    .ascii    "&&"
    .byte     0
L7903:
    .ascii    "jifx"
    .byte     0
L7902:
    .ascii    "jcallfn"
    .byte     0
L7901:
    .ascii    "jexprlist"
    .byte     0
L7900:
    .ascii    "jmakelist"
    .byte     0
L7899:
    .ascii    "jistruel"
    .byte     0
L7898:
    .ascii    "! notl"
    .byte     0
L7897:
    .ascii    "|| orl"
    .byte     0
L7896:
    .ascii    "&& andl"
    .byte     0
L7895:
    .ascii    "jbreaksw"
    .byte     0
L7894:
    .ascii    "jswitch"
    .byte     0
L7893:
    .ascii    "jcontinue"
    .byte     0
L7892:
    .ascii    "jbreak"
    .byte     0
L7891:
    .ascii    "jdefaultstmt"
    .byte     0
L7890:
    .ascii    "jcasestmt"
    .byte     0
L7889:
    .ascii    "jlabelstmt"
    .byte     0
L7888:
    .ascii    "jgoto"
    .byte     0
L7887:
    .ascii    "jdowhile"
    .byte     0
L7886:
    .ascii    "jwhile"
    .byte     0
L7885:
    .ascii    "jfor"
    .byte     0
L7884:
    .ascii    "jif"
    .byte     0
L7883:
    .ascii    "jassign"
    .byte     0
L7882:
    .ascii    "jreturnx"
    .byte     0
L7881:
    .ascii    "jreturn"
    .byte     0
L7880:
    .ascii    "jdecl"
    .byte     0
L7879:
    .ascii    "jtempdecl"
    .byte     0
L7878:
    .ascii    "jblock"
    .byte     0
L7877:
    .ascii    "jfuncname"
    .byte     0
L7876:
    .ascii    "jwidenmem"
    .byte     0
L7875:
    .ascii    "jname"
    .byte     0
L7874:
    .ascii    "jnull"
    .byte     0
L7873:
    .ascii    "jconst"
    .byte     0
L7872:
    .ascii    "jnone"
    .byte     0
L7871:
    .ascii    "callback_fnspec"
    .byte     0
L7870:
    .ascii    "noreturn_fnspec"
    .byte     0
L7869:
    .ascii    "inline_fnspec"
    .byte     0
L7868:
    .ascii    "atomic_qual"
    .byte     0
L7867:
    .ascii    "restrict_qual"
    .byte     0
L7866:
    .ascii    "volatile_qual"
    .byte     0
L7865:
    .ascii    "const_qual"
    .byte     0
L7864:
    .ascii    "typedef_ss"
    .byte     0
L7863:
    .ascii    "extern_ss"
    .byte     0
L7862:
    .ascii    "register_ss"
    .byte     0
L7861:
    .ascii    "auto_ss"
    .byte     0
L7860:
    .ascii    "static_ss"
    .byte     0
L7859:
    .ascii    "none_ss"
    .byte     0
L7858:
    .ascii    "dummy_cc"
    .byte     0
L7857:
    .ascii    "callback_cc"
    .byte     0
L7856:
    .ascii    "stdcall_cc"
    .byte     0
L7855:
    .ascii    "clang_cc"
    .byte     0
L7854:
    .ascii    "own_cc"
    .byte     0
L7853:
    .ascii    "open_cc"
    .byte     0
L7852:
    .ascii    "Exp"
    .byte     0
L7851:
    .ascii    "Imp"
    .byte     0
L7850:
    .ascii    "Loc"
    .byte     0
L7849:
    .ascii    "Fn"
    .byte     0
L7848:
    .ascii    "-"
    .byte     0
L7847:
    .ascii    "pm_variadic"
    .byte     0
L7846:
    .ascii    "pm_empty"
    .byte     0
L7845:
    .ascii    "pm_notset"
    .byte     0
L7844:
    .ascii    "pm_normal"
    .byte     0
L7843:
    .ascii    "ts_atomic"
    .byte     0
L7842:
    .ascii    "ts_enum"
    .byte     0
L7841:
    .ascii    "ts_union"
    .byte     0
L7840:
    .ascii    "ts_struct"
    .byte     0
L7839:
    .ascii    "ts_user"
    .byte     0
L7838:
    .ascii    "ts_bool"
    .byte     0
L7837:
    .ascii    "ts_unsigned"
    .byte     0
L7836:
    .ascii    "ts_signed"
    .byte     0
L7835:
    .ascii    "ts_double"
    .byte     0
L7834:
    .ascii    "ts_float"
    .byte     0
L7833:
    .ascii    "ts_int"
    .byte     0
L7832:
    .ascii    "ts_long"
    .byte     0
L7831:
    .ascii    "ts_short"
    .byte     0
L7830:
    .ascii    "ts_char"
    .byte     0
L7829:
    .ascii    "ts_void"
    .byte     0
L7828:
    .ascii    "blockcat"
    .byte     0
L7827:
    .ascii    "shortcat"
    .byte     0
L7826:
    .ascii    "realcat"
    .byte     0
L7825:
    .ascii    "intcat"
    .byte     0
L7824:
    .ascii    "voidcat"
    .byte     0
L7823:
    .ascii    "tlast"
    .byte     0
L7822:
    .ascii    "notset"
    .byte     0
L7821:
    .ascii    "union"
    .byte     0
L7820:
    .ascii    "struct"
    .byte     0
L7819:
    .ascii    "array"
    .byte     0
L7818:
    .ascii    "block"
    .byte     0
L7817:
    .ascii    "label"
    .byte     0
L7816:
    .ascii    "proc"
    .byte     0
L7815:
    .ascii    "ref"
    .byte     0
L7814:
    .ascii    "enum"
    .byte     0
L7813:
    .ascii    "r64"
    .byte     0
L7812:
    .ascii    "r32"
    .byte     0
L7811:
    .ascii    "u64"
    .byte     0
L7810:
    .ascii    "u32"
    .byte     0
L7809:
    .ascii    "u16"
    .byte     0
L7808:
    .ascii    "u8"
    .byte     0
L7807:
    .ascii    "bool"
    .byte     0
L7806:
    .ascii    "i64"
    .byte     0
L7805:
    .ascii    "i32"
    .byte     0
L7804:
    .ascii    "i16"
    .byte     0
L7803:
    .ascii    "i8"
    .byte     0
L7802:
    .ascii    "void"
    .byte     0
L7801:
    .ascii    "MCC"
    .byte     0
L7800:
    .ascii    "    The 'MCC' C Compiler comprises:"
    .byte     10
    .byte     10
    .ascii    "    mcc.exe            Compiles to .asm files"
    .byte     10
    .ascii    "    aa.exe             Assembles .asm files to .obj files"
    .byte     10
    .ascii    "                       Assemblers and links .asm/.dll files to .exe"
    .byte     10
    .ascii    "    Standard headers   A minimal set inside mcc.exe"
    .byte     10
    .ascii    "    windows.h          As a standalone file"
    .byte     10
    .byte     10
    .ascii    "    Input files:"
    .byte     10
    .byte     10
    .ascii    "      prog             This is prog.c as the extension is optional"
    .byte     10
    .ascii    "      prog.c"
    .byte     10
    .ascii    "      lib.dll          Include .dll library when generating .exe"
    .byte     10
    .ascii    "      @file            Read parameters and optons from given file"
    .byte     10
    .byte     10
    .ascii    "    Options:"
    .byte     10
    .byte     10
    .ascii    "      -exe             (DEFAULT) Compile all modules to one .exe file via .asm files"
    .byte     10
    .ascii    "      -e               Preprocess each module to .i file"
    .byte     10
    .ascii    "      -s               Compile each module to .asm file"
    .byte     10
    .ascii    "      -c               Compile each module .obj via .asm"
    .byte     10
    .byte     10
    .ascii    "      -out:file        Specify output file for -exe only"
    .byte     10
    .byte     10
    .ascii    "    For .exe output, it will be named based on the first input file. Otherwise"
    .byte     10
    .ascii    "    use -out option"
    .byte     10
    .byte     10
    .ascii    "    .obj files can be linked using gcc on Windows. This option is"
    .byte     10
    .ascii    "    needed to be able to generate .dll files. However, this will not"
    .byte     10
    .ascii    "    work on newer gcc versions because mcc's generated code is not position"
    .byte     10
    .ascii    "    independent, and will only work loaded in the low 2GB of address space."
    .byte     10
    .byte     10
    .ascii    "    Libraries msvcrt.dll, gdi32.dll, user32.dll and kernel32.dll are"
    .byte     10
    .ascii    "    automatically included as search libraries for imported functions."
    .byte     10
    .byte     10
    .ascii    "    Other kinds of binary libraries or files (.a, .lib, .obj etc) are not supported."
    .byte     10
    .byte     10
    .ascii    "    Omissions, Restrictions and Bugs (highlights only as there are dozens):"
    .byte     10
    .byte     10
    .ascii    "      * No VLAs, compound literals, designated initialisers"
    .byte     10
    .ascii    "      * Restrictions on complexity of data initialisers"
    .byte     10
    .byte     0
L7799:
    .ascii    "himem"
    .byte     0
L7798:
    .ascii    "norip"
    .byte     0
L7797:
    .ascii    "shortnames"
    .byte     0
L7796:
    .ascii    "stdout"
    .byte     0
L7795:
    .ascii    "o"
    .byte     0
L7794:
    .ascii    "writeheaders"
    .byte     0
L7793:
    .ascii    "ext"
    .byte     0
L7792:
    .ascii    "help"
    .byte     0
L7791:
    .ascii    "h"
    .byte     0
L7790:
    .ascii    "ss"
    .byte     0
L7789:
    .ascii    "cs"
    .byte     0
L7788:
    .ascii    "q"
    .byte     0
L7787:
    .ascii    "vv"
    .byte     0
L7786:
    .ascii    "v"
    .byte     0
L7785:
    .ascii    "time2"
    .byte     0
L7784:
    .ascii    "time"
    .byte     0
L7783:
    .ascii    "showfiles"
    .byte     0
L7782:
    .ascii    "showtypes"
    .byte     0
L7781:
    .ascii    "showss"
    .byte     0
L7780:
    .ascii    "showmcl"
    .byte     0
L7779:
    .ascii    "showpst"
    .byte     0
L7778:
    .ascii    "showpcl"
    .byte     0
L7777:
    .ascii    "showast"
    .byte     0
L7776:
    .ascii    "showstflat"
    .byte     0
L7775:
    .ascii    "showst"
    .byte     0
L7774:
    .ascii    "includes"
    .byte     0
L7773:
    .ascii    "incl"
    .byte     0
L7772:
    .ascii    "headers"
    .byte     0
L7771:
    .ascii    "paths"
    .byte     0
L7770:
    .ascii    "no"
    .byte     0
L7769:
    .ascii    "nopeep"
    .byte     0
L7768:
    .ascii    "noregs"
    .byte     0
L7767:
    .ascii    "r"
    .byte     0
L7766:
    .ascii    "exe"
    .byte     0
L7765:
    .ascii    "dll"
    .byte     0
L7764:
    .ascii    "mx"
    .byte     0
L7763:
    .ascii    "obj"
    .byte     0
L7762:
    .ascii    "c"
    .byte     0
L7761:
    .ascii    "a"
    .byte     0
L7760:
    .ascii    "s"
    .byte     0
L7759:
    .ascii    "mcl"
    .byte     0
L7758:
    .ascii    "i"
    .byte     0
L7757:
    .ascii    "pi"
    .byte     0
L7756:
    .ascii    "p"
    .byte     0
L7755:
    .ascii    "type"
    .byte     0
L7754:
    .ascii    "parse"
    .byte     0
L7753:
    .ascii    "ei"
    .byte     0
L7752:
    .ascii    "e"
    .byte     0
L7751:
    .ascii    "load"
    .byte     0
L7750:
    .ascii    "exe"
    .byte     0
L7749:
    .ascii    "(run)"
    .byte     0
L7748:
    .ascii    "exe"
    .byte     0
L7747:
    .ascii    "dll"
    .byte     0
L7746:
    .ascii    "obj"
    .byte     0
L7745:
    .ascii    "mx"
    .byte     0
L7744:
    .ascii    "asm"
    .byte     0
L7743:
    .ascii    "(int)"
    .byte     0
L7742:
    .ascii    "pcl"
    .byte     0
L7741:
    .byte     0
L7740:
    .ascii    "i"
    .byte     0
L7739:
    .byte     0
L7738:
    .ascii    "run_pass"
    .byte     0
L7737:
    .ascii    "exe_pass"
    .byte     0
L7736:
    .ascii    "dll_pass"
    .byte     0
L7735:
    .ascii    "obj_pass"
    .byte     0
L7734:
    .ascii    "mx_pass"
    .byte     0
L7733:
    .ascii    "asm_pass"
    .byte     0
L7732:
    .ascii    "mcl_pass"
    .byte     0
L7731:
    .ascii    "runpcl_pass"
    .byte     0
L7730:
    .ascii    "pcl_pass"
    .byte     0
L7729:
    .ascii    "type_pass"
    .byte     0
L7728:
    .ascii    "parse_pass"
    .byte     0
L7727:
    .ascii    "pp_pass"
    .byte     0
L7726:
    .ascii    "load_pass"
    .byte     0
L7725:
    .ascii    "asm"
    .byte     0
L7724:
    .ascii    "rel8_rel"
    .byte     0
L7723:
    .ascii    "rel321_rel"
    .byte     0
L7722:
    .ascii    "rel32_rel"
    .byte     0
L7721:
    .ascii    "addr32nb_rel"
    .byte     0
L7720:
    .ascii    "addr32_rel"
    .byte     0
L7719:
    .ascii    "addr64_rel"
    .byte     0
L7718:
    .ascii    "abs_rel"
    .byte     0
L7717:
    .ascii    "xmm15"
    .byte     0
L7716:
    .ascii    "xmm13"
    .byte     0
L7715:
    .ascii    "xmm12"
    .byte     0
L7714:
    .ascii    "xmm11"
    .byte     0
L7713:
    .ascii    "xmm10"
    .byte     0
L7712:
    .ascii    "xmm9"
    .byte     0
L7711:
    .ascii    "xmm8"
    .byte     0
L7710:
    .ascii    "xmm7"
    .byte     0
L7709:
    .ascii    "xmm6"
    .byte     0
L7708:
    .ascii    "xmm5"
    .byte     0
L7707:
    .ascii    "xmm4"
    .byte     0
L7706:
    .ascii    "xmm3"
    .byte     0
L7705:
    .ascii    "xmm2"
    .byte     0
L7704:
    .ascii    "xmm1"
    .byte     0
L7703:
    .ascii    "xmm0"
    .byte     0
L7702:
    .ascii    "-"
    .byte     0
L7701:
    .ascii    "temp"
    .byte     0
L7700:
    .ascii    "regvar"
    .byte     0
L7699:
    .ascii    "reg"
    .byte     0
L7698:
    .ascii    "pend"
    .byte     0
L7697:
    .ascii    "a_xreg"
    .byte     0
L7696:
    .ascii    "a_cond"
    .byte     0
L7695:
    .ascii    "a_mem"
    .byte     0
L7694:
    .ascii    "a_imm"
    .byte     0
L7693:
    .ascii    "a_reg"
    .byte     0
L7692:
    .ascii    "a_none"
    .byte     0
L7691:
    .ascii    "back_ref"
    .byte     0
L7690:
    .ascii    "fwd_ref"
    .byte     0
L7689:
    .ascii    "extern_ref"
    .byte     0
L7688:
    .ascii    "impdata_seg"
    .byte     0
L7687:
    .ascii    "rodata_seg"
    .byte     0
L7686:
    .ascii    "zdata_seg"
    .byte     0
L7685:
    .ascii    "idata_seg"
    .byte     0
L7684:
    .ascii    "code_seg"
    .byte     0
L7683:
    .ascii    "no_seg"
    .byte     0
L7682:
    .ascii    "cmovg"
    .byte     0
L7681:
    .ascii    "cmovle"
    .byte     0
L7680:
    .ascii    "cmovge"
    .byte     0
L7679:
    .ascii    "cmovl"
    .byte     0
L7678:
    .ascii    "cmovnp"
    .byte     0
L7677:
    .ascii    "cmovp"
    .byte     0
L7676:
    .ascii    "cmovns"
    .byte     0
L7675:
    .ascii    "cmovs"
    .byte     0
L7674:
    .ascii    "cmova"
    .byte     0
L7673:
    .ascii    "cmovbe"
    .byte     0
L7672:
    .ascii    "cmovnz"
    .byte     0
L7671:
    .ascii    "cmovz"
    .byte     0
L7670:
    .ascii    "cmovae"
    .byte     0
L7669:
    .ascii    "cmovb"
    .byte     0
L7668:
    .ascii    "cmovno"
    .byte     0
L7667:
    .ascii    "cmovo"
    .byte     0
L7666:
    .ascii    "setg"
    .byte     0
L7665:
    .ascii    "setle"
    .byte     0
L7664:
    .ascii    "setge"
    .byte     0
L7663:
    .ascii    "setl"
    .byte     0
L7662:
    .ascii    "setnp"
    .byte     0
L7661:
    .ascii    "setp"
    .byte     0
L7660:
    .ascii    "setns"
    .byte     0
L7659:
    .ascii    "sets"
    .byte     0
L7658:
    .ascii    "seta"
    .byte     0
L7657:
    .ascii    "setbe"
    .byte     0
L7656:
    .ascii    "setnz"
    .byte     0
L7655:
    .ascii    "setz"
    .byte     0
L7654:
    .ascii    "setae"
    .byte     0
L7653:
    .ascii    "setb"
    .byte     0
L7652:
    .ascii    "setno"
    .byte     0
L7651:
    .ascii    "seto"
    .byte     0
L7650:
    .ascii    "jnc"
    .byte     0
L7649:
    .ascii    "jc"
    .byte     0
L7648:
    .ascii    "jg"
    .byte     0
L7647:
    .ascii    "jle"
    .byte     0
L7646:
    .ascii    "jge"
    .byte     0
L7645:
    .ascii    "jl"
    .byte     0
L7644:
    .ascii    "jnp"
    .byte     0
L7643:
    .ascii    "jp"
    .byte     0
L7642:
    .ascii    "jns"
    .byte     0
L7641:
    .ascii    "js"
    .byte     0
L7640:
    .ascii    "ja"
    .byte     0
L7639:
    .ascii    "jbe"
    .byte     0
L7638:
    .ascii    "jnz"
    .byte     0
L7637:
    .ascii    "jz"
    .byte     0
L7636:
    .ascii    "jae"
    .byte     0
L7635:
    .ascii    "jb"
    .byte     0
L7634:
    .ascii    "jno"
    .byte     0
L7633:
    .ascii    "jo"
    .byte     0
L7632:
    .ascii    "mmx7"
    .byte     0
L7631:
    .ascii    "mmx6"
    .byte     0
L7630:
    .ascii    "mmx5"
    .byte     0
L7629:
    .ascii    "mmx4"
    .byte     0
L7628:
    .ascii    "mmx3"
    .byte     0
L7627:
    .ascii    "mmx2"
    .byte     0
L7626:
    .ascii    "mmx1"
    .byte     0
L7625:
    .ascii    "mmx0"
    .byte     0
L7624:
    .ascii    "st7"
    .byte     0
L7623:
    .ascii    "st6"
    .byte     0
L7622:
    .ascii    "st5"
    .byte     0
L7621:
    .ascii    "st4"
    .byte     0
L7620:
    .ascii    "st3"
    .byte     0
L7619:
    .ascii    "st2"
    .byte     0
L7618:
    .ascii    "st1"
    .byte     0
L7617:
    .ascii    "st0"
    .byte     0
L7616:
    .ascii    "xmm15"
    .byte     0
L7615:
    .ascii    "xmm14"
    .byte     0
L7614:
    .ascii    "xmm13"
    .byte     0
L7613:
    .ascii    "xmm12"
    .byte     0
L7612:
    .ascii    "xmm11"
    .byte     0
L7611:
    .ascii    "xmm10"
    .byte     0
L7610:
    .ascii    "xmm9"
    .byte     0
L7609:
    .ascii    "xmm8"
    .byte     0
L7608:
    .ascii    "xmm7"
    .byte     0
L7607:
    .ascii    "xmm6"
    .byte     0
L7606:
    .ascii    "xmm5"
    .byte     0
L7605:
    .ascii    "xmm4"
    .byte     0
L7604:
    .ascii    "xmm3"
    .byte     0
L7603:
    .ascii    "xmm2"
    .byte     0
L7602:
    .ascii    "xmm1"
    .byte     0
L7601:
    .ascii    "xmm0"
    .byte     0
L7600:
    .ascii    "r15b"
    .byte     0
L7599:
    .ascii    "r14b"
    .byte     0
L7598:
    .ascii    "r13b"
    .byte     0
L7597:
    .ascii    "r12b"
    .byte     0
L7596:
    .ascii    "r11b"
    .byte     0
L7595:
    .ascii    "r10b"
    .byte     0
L7594:
    .ascii    "r9b"
    .byte     0
L7593:
    .ascii    "r8b"
    .byte     0
L7592:
    .ascii    "spl"
    .byte     0
L7591:
    .ascii    "bpl"
    .byte     0
L7590:
    .ascii    "dil"
    .byte     0
L7589:
    .ascii    "sil"
    .byte     0
L7588:
    .ascii    "dh"
    .byte     0
L7587:
    .ascii    "ch"
    .byte     0
L7586:
    .ascii    "bh"
    .byte     0
L7585:
    .ascii    "ah"
    .byte     0
L7584:
    .ascii    "dl"
    .byte     0
L7583:
    .ascii    "cl"
    .byte     0
L7582:
    .ascii    "bl"
    .byte     0
L7581:
    .ascii    "al"
    .byte     0
L7580:
    .ascii    "r15w"
    .byte     0
L7579:
    .ascii    "r14w"
    .byte     0
L7578:
    .ascii    "r13w"
    .byte     0
L7577:
    .ascii    "r12w"
    .byte     0
L7576:
    .ascii    "r11w"
    .byte     0
L7575:
    .ascii    "r10w"
    .byte     0
L7574:
    .ascii    "r9w"
    .byte     0
L7573:
    .ascii    "r8w"
    .byte     0
L7572:
    .ascii    "sp"
    .byte     0
L7571:
    .ascii    "bp"
    .byte     0
L7570:
    .ascii    "di"
    .byte     0
L7569:
    .ascii    "si"
    .byte     0
L7568:
    .ascii    "dx"
    .byte     0
L7567:
    .ascii    "cx"
    .byte     0
L7566:
    .ascii    "bx"
    .byte     0
L7565:
    .ascii    "ax"
    .byte     0
L7564:
    .ascii    "r15d"
    .byte     0
L7563:
    .ascii    "r14d"
    .byte     0
L7562:
    .ascii    "r13d"
    .byte     0
L7561:
    .ascii    "r12d"
    .byte     0
L7560:
    .ascii    "r11d"
    .byte     0
L7559:
    .ascii    "r10d"
    .byte     0
L7558:
    .ascii    "r9d"
    .byte     0
L7557:
    .ascii    "r8d"
    .byte     0
L7556:
    .ascii    "esp"
    .byte     0
L7555:
    .ascii    "ebp"
    .byte     0
L7554:
    .ascii    "edi"
    .byte     0
L7553:
    .ascii    "esi"
    .byte     0
L7552:
    .ascii    "edx"
    .byte     0
L7551:
    .ascii    "ecx"
    .byte     0
L7550:
    .ascii    "ebx"
    .byte     0
L7549:
    .ascii    "eax"
    .byte     0
L7548:
    .ascii    "r15"
    .byte     0
L7547:
    .ascii    "r14"
    .byte     0
L7546:
    .ascii    "r13"
    .byte     0
L7545:
    .ascii    "r12"
    .byte     0
L7544:
    .ascii    "r11"
    .byte     0
L7543:
    .ascii    "r10"
    .byte     0
L7542:
    .ascii    "r9"
    .byte     0
L7541:
    .ascii    "r8"
    .byte     0
L7540:
    .ascii    "rsp"
    .byte     0
L7539:
    .ascii    "rbp"
    .byte     0
L7538:
    .ascii    "rdi"
    .byte     0
L7537:
    .ascii    "rsi"
    .byte     0
L7536:
    .ascii    "rdx"
    .byte     0
L7535:
    .ascii    "rcx"
    .byte     0
L7534:
    .ascii    "rbx"
    .byte     0
L7533:
    .ascii    "rax"
    .byte     0
L7532:
    .ascii    "_b20"
    .byte     0
L7531:
    .ascii    "b19"
    .byte     0
L7530:
    .ascii    "b18"
    .byte     0
L7529:
    .ascii    "b17"
    .byte     0
L7528:
    .ascii    "b16"
    .byte     0
L7527:
    .ascii    "b15"
    .byte     0
L7526:
    .ascii    "b14"
    .byte     0
L7525:
    .ascii    "b13"
    .byte     0
L7524:
    .ascii    "b12"
    .byte     0
L7523:
    .ascii    "b11"
    .byte     0
L7522:
    .ascii    "b10"
    .byte     0
L7521:
    .ascii    "b9"
    .byte     0
L7520:
    .ascii    "b8"
    .byte     0
L7519:
    .ascii    "b7"
    .byte     0
L7518:
    .ascii    "b6"
    .byte     0
L7517:
    .ascii    "b5"
    .byte     0
L7516:
    .ascii    "b4"
    .byte     0
L7515:
    .ascii    "b3"
    .byte     0
L7514:
    .ascii    "b2"
    .byte     0
L7513:
    .ascii    "b1"
    .byte     0
L7512:
    .ascii    "b0"
    .byte     0
L7511:
    .ascii    "w15"
    .byte     0
L7510:
    .ascii    "w14"
    .byte     0
L7509:
    .ascii    "w13"
    .byte     0
L7508:
    .ascii    "w12"
    .byte     0
L7507:
    .ascii    "w11"
    .byte     0
L7506:
    .ascii    "w10"
    .byte     0
L7505:
    .ascii    "w9"
    .byte     0
L7504:
    .ascii    "w8"
    .byte     0
L7503:
    .ascii    "w7"
    .byte     0
L7502:
    .ascii    "w6"
    .byte     0
L7501:
    .ascii    "w5"
    .byte     0
L7500:
    .ascii    "w4"
    .byte     0
L7499:
    .ascii    "w3"
    .byte     0
L7498:
    .ascii    "w2"
    .byte     0
L7497:
    .ascii    "w1"
    .byte     0
L7496:
    .ascii    "w0"
    .byte     0
L7495:
    .ascii    "a15"
    .byte     0
L7494:
    .ascii    "a14"
    .byte     0
L7493:
    .ascii    "a13"
    .byte     0
L7492:
    .ascii    "a12"
    .byte     0
L7491:
    .ascii    "a11"
    .byte     0
L7490:
    .ascii    "a10"
    .byte     0
L7489:
    .ascii    "a9"
    .byte     0
L7488:
    .ascii    "a8"
    .byte     0
L7487:
    .ascii    "a7"
    .byte     0
L7486:
    .ascii    "a6"
    .byte     0
L7485:
    .ascii    "a5"
    .byte     0
L7484:
    .ascii    "a4"
    .byte     0
L7483:
    .ascii    "a3"
    .byte     0
L7482:
    .ascii    "a2"
    .byte     0
L7481:
    .ascii    "a1"
    .byte     0
L7480:
    .ascii    "a0"
    .byte     0
L7479:
    .ascii    "d15"
    .byte     0
L7478:
    .ascii    "d14"
    .byte     0
L7477:
    .ascii    "d13"
    .byte     0
L7476:
    .ascii    "d12"
    .byte     0
L7475:
    .ascii    "d11"
    .byte     0
L7474:
    .ascii    "d10"
    .byte     0
L7473:
    .ascii    "d9"
    .byte     0
L7472:
    .ascii    "d8"
    .byte     0
L7471:
    .ascii    "d7"
    .byte     0
L7470:
    .ascii    "d6"
    .byte     0
L7469:
    .ascii    "d5"
    .byte     0
L7468:
    .ascii    "d4"
    .byte     0
L7467:
    .ascii    "d3"
    .byte     0
L7466:
    .ascii    "d2"
    .byte     0
L7465:
    .ascii    "d1"
    .byte     0
L7464:
    .ascii    "d0"
    .byte     0
L7463:
    .ascii    "a"
    .byte     0
L7462:
    .ascii    "be"
    .byte     0
L7461:
    .ascii    "ae"
    .byte     0
L7460:
    .ascii    "b"
    .byte     0
L7459:
    .ascii    "g"
    .byte     0
L7458:
    .ascii    "le"
    .byte     0
L7457:
    .ascii    "ge"
    .byte     0
L7456:
    .ascii    "l"
    .byte     0
L7455:
    .ascii    "np"
    .byte     0
L7454:
    .ascii    "p"
    .byte     0
L7453:
    .ascii    "ns"
    .byte     0
L7452:
    .ascii    "s"
    .byte     0
L7451:
    .ascii    "a"
    .byte     0
L7450:
    .ascii    "be"
    .byte     0
L7449:
    .ascii    "nz"
    .byte     0
L7448:
    .ascii    "z"
    .byte     0
L7447:
    .ascii    "ae"
    .byte     0
L7446:
    .ascii    "b"
    .byte     0
L7445:
    .ascii    "no"
    .byte     0
L7444:
    .ascii    "o"
    .byte     0
L7443:
    .ascii    "fgt"
    .byte     0
L7442:
    .ascii    "fle"
    .byte     0
L7441:
    .ascii    "fge"
    .byte     0
L7440:
    .ascii    "flt"
    .byte     0
L7439:
    .ascii    "gt"
    .byte     0
L7438:
    .ascii    "le"
    .byte     0
L7437:
    .ascii    "ge"
    .byte     0
L7436:
    .ascii    "lt"
    .byte     0
L7435:
    .ascii    "np"
    .byte     0
L7434:
    .ascii    "p"
    .byte     0
L7433:
    .ascii    "ns"
    .byte     0
L7432:
    .ascii    "s"
    .byte     0
L7431:
    .ascii    "gtu"
    .byte     0
L7430:
    .ascii    "leu"
    .byte     0
L7429:
    .ascii    "ne"
    .byte     0
L7428:
    .ascii    "eq"
    .byte     0
L7427:
    .ascii    "geu"
    .byte     0
L7426:
    .ascii    "ltu"
    .byte     0
L7425:
    .ascii    "nov"
    .byte     0
L7424:
    .ascii    "ov"
    .byte     0
L7423:
    .ascii    "r19"
    .byte     0
L7422:
    .ascii    "r18"
    .byte     0
L7421:
    .ascii    "r17"
    .byte     0
L7420:
    .ascii    "r16"
    .byte     0
L7419:
    .ascii    "r15"
    .byte     0
L7418:
    .ascii    "r14"
    .byte     0
L7417:
    .ascii    "r13"
    .byte     0
L7416:
    .ascii    "r12"
    .byte     0
L7415:
    .ascii    "r11"
    .byte     0
L7414:
    .ascii    "r10"
    .byte     0
L7413:
    .ascii    "r9"
    .byte     0
L7412:
    .ascii    "r8"
    .byte     0
L7411:
    .ascii    "r7"
    .byte     0
L7410:
    .ascii    "r6"
    .byte     0
L7409:
    .ascii    "r5"
    .byte     0
L7408:
    .ascii    "r4"
    .byte     0
L7407:
    .ascii    "r3"
    .byte     0
L7406:
    .ascii    "r2"
    .byte     0
L7405:
    .ascii    "r1"
    .byte     0
L7404:
    .ascii    "r0"
    .byte     0
L7403:
    .ascii    "rnone"
    .byte     0
L7402:
    .ascii    "m_halt"
    .byte     0
L7401:
    .ascii    "m_xxxx"
    .byte     0
L7400:
    .ascii    "m_cpuid"
    .byte     0
L7399:
    .ascii    "m_fldln2"
    .byte     0
L7398:
    .ascii    "m_fldlg2"
    .byte     0
L7397:
    .ascii    "m_fld2e"
    .byte     0
L7396:
    .ascii    "m_fld2t"
    .byte     0
L7395:
    .ascii    "m_fldpi"
    .byte     0
L7394:
    .ascii    "m_fld1"
    .byte     0
L7393:
    .ascii    "m_fldz"
    .byte     0
L7392:
    .ascii    "m_finit"
    .byte     0
L7391:
    .ascii    "m_bswap"
    .byte     0
L7390:
    .ascii    "m_popcnt"
    .byte     0
L7389:
    .ascii    "m_rdtsc"
    .byte     0
L7388:
    .ascii    "m_cmpsq"
    .byte     0
L7387:
    .ascii    "m_cmpsd"
    .byte     0
L7386:
    .ascii    "m_cmpsw"
    .byte     0
L7385:
    .ascii    "m_cmpsb"
    .byte     0
L7384:
    .ascii    "m_jrcxz"
    .byte     0
L7383:
    .ascii    "m_jecxz"
    .byte     0
L7382:
    .ascii    "m_loopcx"
    .byte     0
L7381:
    .ascii    "m_loopz"
    .byte     0
L7380:
    .ascii    "m_loopnz"
    .byte     0
L7379:
    .ascii    "m_xlat"
    .byte     0
L7378:
    .ascii    "m_resq"
    .byte     0
L7377:
    .ascii    "m_resd"
    .byte     0
L7376:
    .ascii    "m_resw"
    .byte     0
L7375:
    .ascii    "m_resb"
    .byte     0
L7374:
    .ascii    "m_align"
    .byte     0
L7373:
    .ascii    "m_csegment"
    .byte     0
L7372:
    .ascii    "m_zsegment"
    .byte     0
L7371:
    .ascii    "m_isegment"
    .byte     0
L7370:
    .ascii    "m_ascii"
    .byte     0
L7369:
    .ascii    "m_dq"
    .byte     0
L7368:
    .ascii    "m_dd"
    .byte     0
L7367:
    .ascii    "m_dw"
    .byte     0
L7366:
    .ascii    "m_db"
    .byte     0
L7365:
    .ascii    "m_maxsd"
    .byte     0
L7364:
    .ascii    "m_minsd"
    .byte     0
L7363:
    .ascii    "m_maxss"
    .byte     0
L7362:
    .ascii    "m_minss"
    .byte     0
L7361:
    .ascii    "m_fchs"
    .byte     0
L7360:
    .ascii    "m_fabs"
    .byte     0
L7359:
    .ascii    "m_fpatan"
    .byte     0
L7358:
    .ascii    "m_fptan"
    .byte     0
L7357:
    .ascii    "m_fsincos"
    .byte     0
L7356:
    .ascii    "m_fcos"
    .byte     0
L7355:
    .ascii    "m_fsin"
    .byte     0
L7354:
    .ascii    "m_fsqrt"
    .byte     0
L7353:
    .ascii    "m_fdiv"
    .byte     0
L7352:
    .ascii    "m_fmul"
    .byte     0
L7351:
    .ascii    "m_fsub"
    .byte     0
L7350:
    .ascii    "m_fadd"
    .byte     0
L7349:
    .ascii    "m_fistp"
    .byte     0
L7348:
    .ascii    "m_fist"
    .byte     0
L7347:
    .ascii    "m_fild"
    .byte     0
L7346:
    .ascii    "m_fstp"
    .byte     0
L7345:
    .ascii    "m_fst"
    .byte     0
L7344:
    .ascii    "m_fld"
    .byte     0
L7343:
    .ascii    "m_pcmpistrm"
    .byte     0
L7342:
    .ascii    "m_pcmpistri"
    .byte     0
L7341:
    .ascii    "m_movdqu"
    .byte     0
L7340:
    .ascii    "m_movdqa"
    .byte     0
L7339:
    .ascii    "m_cvtss2sd"
    .byte     0
L7338:
    .ascii    "m_cvtsd2ss"
    .byte     0
L7337:
    .ascii    "m_cvtsi2sd"
    .byte     0
L7336:
    .ascii    "m_cvtsi2ss"
    .byte     0
L7335:
    .ascii    "m_cvttsd2si"
    .byte     0
L7334:
    .ascii    "m_cvttss2si"
    .byte     0
L7333:
    .ascii    "m_cvtsd2si"
    .byte     0
L7332:
    .ascii    "m_cvtss2si"
    .byte     0
L7331:
    .ascii    "m_pand"
    .byte     0
L7330:
    .ascii    "m_pxor"
    .byte     0
L7329:
    .ascii    "m_andpd"
    .byte     0
L7328:
    .ascii    "m_andps"
    .byte     0
L7327:
    .ascii    "m_xorpd"
    .byte     0
L7326:
    .ascii    "m_xorps"
    .byte     0
L7325:
    .ascii    "m_ucomisd"
    .byte     0
L7324:
    .ascii    "m_comisd"
    .byte     0
L7323:
    .ascii    "m_comiss"
    .byte     0
L7322:
    .ascii    "m_divsd"
    .byte     0
L7321:
    .ascii    "m_divss"
    .byte     0
L7320:
    .ascii    "m_mulsd"
    .byte     0
L7319:
    .ascii    "m_mulss"
    .byte     0
L7318:
    .ascii    "m_subsd"
    .byte     0
L7317:
    .ascii    "m_subss"
    .byte     0
L7316:
    .ascii    "m_addsd"
    .byte     0
L7315:
    .ascii    "m_addss"
    .byte     0
L7314:
    .ascii    "m_sqrtsd"
    .byte     0
L7313:
    .ascii    "m_sqrtss"
    .byte     0
L7312:
    .ascii    "m_shrd"
    .byte     0
L7311:
    .ascii    "m_shld"
    .byte     0
L7310:
    .ascii    "m_bsr"
    .byte     0
L7309:
    .ascii    "m_bsf"
    .byte     0
L7308:
    .ascii    "m_setcc"
    .byte     0
L7307:
    .ascii    "m_cqo"
    .byte     0
L7306:
    .ascii    "m_cdq"
    .byte     0
L7305:
    .ascii    "m_cwd"
    .byte     0
L7304:
    .ascii    "m_cbw"
    .byte     0
L7303:
    .ascii    "m_dec"
    .byte     0
L7302:
    .ascii    "m_inc"
    .byte     0
L7301:
    .ascii    "m_notx"
    .byte     0
L7300:
    .ascii    "m_neg"
    .byte     0
L7299:
    .ascii    "m_rcr"
    .byte     0
L7298:
    .ascii    "m_rcl"
    .byte     0
L7297:
    .ascii    "m_ror"
    .byte     0
L7296:
    .ascii    "m_rol"
    .byte     0
L7295:
    .ascii    "m_shr"
    .byte     0
L7294:
    .ascii    "m_sar"
    .byte     0
L7293:
    .ascii    "m_shl"
    .byte     0
L7292:
    .ascii    "m_cmp"
    .byte     0
L7291:
    .ascii    "m_test"
    .byte     0
L7290:
    .ascii    "m_xorx"
    .byte     0
L7289:
    .ascii    "m_orx"
    .byte     0
L7288:
    .ascii    "m_andx"
    .byte     0
L7287:
    .ascii    "m_div"
    .byte     0
L7286:
    .ascii    "m_idiv"
    .byte     0
L7285:
    .ascii    "m_imul3"
    .byte     0
L7284:
    .ascii    "m_imul2"
    .byte     0
L7283:
    .ascii    "m_mul"
    .byte     0
L7282:
    .ascii    "m_imul"
    .byte     0
L7281:
    .ascii    "m_sbb"
    .byte     0
L7280:
    .ascii    "m_adc"
    .byte     0
L7279:
    .ascii    "m_sub"
    .byte     0
L7278:
    .ascii    "m_add"
    .byte     0
L7277:
    .ascii    "m_xchg"
    .byte     0
L7276:
    .ascii    "m_jmpcc"
    .byte     0
L7275:
    .ascii    "m_jmp"
    .byte     0
L7274:
    .ascii    "m_retn"
    .byte     0
L7273:
    .ascii    "m_leave"
    .byte     0
L7272:
    .ascii    "m_ret"
    .byte     0
L7271:
    .ascii    "m_call"
    .byte     0
L7270:
    .ascii    "m_movsxd"
    .byte     0
L7269:
    .ascii    "m_movzx"
    .byte     0
L7268:
    .ascii    "m_movsx"
    .byte     0
L7267:
    .ascii    "m_movq"
    .byte     0
L7266:
    .ascii    "m_movd"
    .byte     0
L7265:
    .ascii    "m_cmovcc"
    .byte     0
L7264:
    .ascii    "m_lea"
    .byte     0
L7263:
    .ascii    "m_pop"
    .byte     0
L7262:
    .ascii    "m_push"
    .byte     0
L7261:
    .ascii    "m_mov"
    .byte     0
L7260:
    .ascii    "m_nop"
    .byte     0
L7259:
    .ascii    "m_labelx"
    .byte     0
L7258:
    .ascii    "m_endx"
    .byte     0
L7257:
    .ascii    "m_trace"
    .byte     0
L7256:
    .ascii    "m_definereg"
    .byte     0
L7255:
    .ascii    "m_define"
    .byte     0
L7254:
    .ascii    "m_labelname"
    .byte     0
L7253:
    .ascii    "m_comment"
    .byte     0
L7252:
    .ascii    "m_procend"
    .byte     0
L7251:
    .ascii    "m_procstart"
    .byte     0
L7250:
    .ascii    "temp_val"
    .byte     0
L7249:
    .ascii    "name_val"
    .byte     0
L7248:
    .ascii    "label_val"
    .byte     0
L7247:
    .ascii    "def_val"
    .byte     0
L7246:
    .ascii    "stringimm_val"
    .byte     0
L7245:
    .ascii    "realmem_val"
    .byte     0
L7244:
    .ascii    "realimm_val"
    .byte     0
L7243:
    .ascii    "intimm_val"
    .byte     0
L7242:
    .ascii    "no_val"
    .byte     0
L7241:
    .ascii    "Program"
    .byte     0
L7240:
    .ascii    "Misc"
    .byte     0
L7239:
    .ascii    "Export"
    .byte     0
L7238:
    .ascii    "Label"
    .byte     0
L7237:
    .ascii    "Param"
    .byte     0
L7236:
    .ascii    "Local"
    .byte     0
L7235:
    .ascii    "Static"
    .byte     0
L7234:
    .ascii    "Proc"
    .byte     0
L7233:
    .ascii    "Import"
    .byte     0
L7232:
    .ascii    "--"
    .byte     0
L7231:
    .ascii    "gt"
    .byte     0
L7230:
    .ascii    "ge"
    .byte     0
L7229:
    .ascii    "le"
    .byte     0
L7228:
    .ascii    "lt"
    .byte     0
L7227:
    .ascii    "ne"
    .byte     0
L7226:
    .ascii    "eq"
    .byte     0
L7225:
    .ascii    "xx"
    .byte     0
L7224:
    .ascii    "extproc"
    .byte     0
L7223:
    .ascii    "addlib"
    .byte     0
L7222:
    .ascii    "variadic"
    .byte     0
L7221:
    .ascii    "rettype"
    .byte     0
L7220:
    .ascii    "local"
    .byte     0
L7219:
    .ascii    "param"
    .byte     0
L7218:
    .ascii    "endprog"
    .byte     0
L7217:
    .ascii    "comment"
    .byte     0
L7216:
    .ascii    "eval"
    .byte     0
L7215:
    .ascii    "loadall"
    .byte     0
L7214:
    .ascii    "setarg"
    .byte     0
L7213:
    .ascii    "setcall"
    .byte     0
L7212:
    .ascii    "longjmp"
    .byte     0
L7211:
    .ascii    "setjmp"
    .byte     0
L7210:
    .ascii    "labeldef"
    .byte     0
L7209:
    .ascii    "label"
    .byte     0
L7208:
    .ascii    "initdswx"
    .byte     0
L7207:
    .ascii    "data"
    .byte     0
L7206:
    .ascii    "zstatic"
    .byte     0
L7205:
    .ascii    "istatic"
    .byte     0
L7204:
    .ascii    "endproc"
    .byte     0
L7203:
    .ascii    "tcproc"
    .byte     0
L7202:
    .ascii    "proc"
    .byte     0
L7201:
    .ascii    "endmx"
    .byte     0
L7200:
    .ascii    "resetmx"
    .byte     0
L7199:
    .ascii    "startmx"
    .byte     0
L7198:
    .ascii    "fnarrow"
    .byte     0
L7197:
    .ascii    "fwiden"
    .byte     0
L7196:
    .ascii    "widen"
    .byte     0
L7195:
    .ascii    "truncate"
    .byte     0
L7194:
    .ascii    "fix"
    .byte     0
L7193:
    .ascii    "float"
    .byte     0
L7192:
    .ascii    "typepun"
    .byte     0
L7191:
    .ascii    "toboolto"
    .byte     0
L7190:
    .ascii    "notto"
    .byte     0
L7189:
    .ascii    "bitnotto"
    .byte     0
L7188:
    .ascii    "absto"
    .byte     0
L7187:
    .ascii    "negto"
    .byte     0
L7186:
    .ascii    "subpxto"
    .byte     0
L7185:
    .ascii    "addpxto"
    .byte     0
L7184:
    .ascii    "maxto"
    .byte     0
L7183:
    .ascii    "minto"
    .byte     0
L7182:
    .ascii    "shrto"
    .byte     0
L7181:
    .ascii    "shlto"
    .byte     0
L7180:
    .ascii    "bitxorto"
    .byte     0
L7179:
    .ascii    "bitorto"
    .byte     0
L7178:
    .ascii    "bitandto"
    .byte     0
L7177:
    .ascii    "iremto"
    .byte     0
L7176:
    .ascii    "idivto"
    .byte     0
L7175:
    .ascii    "divto"
    .byte     0
L7174:
    .ascii    "multo"
    .byte     0
L7173:
    .ascii    "subto"
    .byte     0
L7172:
    .ascii    "addto"
    .byte     0
L7171:
    .ascii    "loaddecr"
    .byte     0
L7170:
    .ascii    "loadincr"
    .byte     0
L7169:
    .ascii    "decrload"
    .byte     0
L7168:
    .ascii    "incrload"
    .byte     0
L7167:
    .ascii    "decrto"
    .byte     0
L7166:
    .ascii    "incrto"
    .byte     0
L7165:
    .ascii    "fmod"
    .byte     0
L7164:
    .ascii    "power"
    .byte     0
L7163:
    .ascii    "atan2"
    .byte     0
L7162:
    .ascii    "sign"
    .byte     0
L7161:
    .ascii    "ceil"
    .byte     0
L7160:
    .ascii    "floor"
    .byte     0
L7159:
    .ascii    "round"
    .byte     0
L7158:
    .ascii    "exp"
    .byte     0
L7157:
    .ascii    "log10"
    .byte     0
L7156:
    .ascii    "log"
    .byte     0
L7155:
    .ascii    "atan"
    .byte     0
L7154:
    .ascii    "acos"
    .byte     0
L7153:
    .ascii    "asin"
    .byte     0
L7152:
    .ascii    "tan"
    .byte     0
L7151:
    .ascii    "cos"
    .byte     0
L7150:
    .ascii    "sin"
    .byte     0
L7149:
    .ascii    "sqrt"
    .byte     0
L7148:
    .ascii    "sqr"
    .byte     0
L7147:
    .ascii    "toboolf"
    .byte     0
L7146:
    .ascii    "toboolt"
    .byte     0
L7145:
    .ascii    "not"
    .byte     0
L7144:
    .ascii    "bitnot"
    .byte     0
L7143:
    .ascii    "abs"
    .byte     0
L7142:
    .ascii    "neg"
    .byte     0
L7141:
    .ascii    "subp"
    .byte     0
L7140:
    .ascii    "subpx"
    .byte     0
L7139:
    .ascii    "addpx"
    .byte     0
L7138:
    .ascii    "max"
    .byte     0
L7137:
    .ascii    "min"
    .byte     0
L7136:
    .ascii    "shr"
    .byte     0
L7135:
    .ascii    "shl"
    .byte     0
L7134:
    .ascii    "bitxor"
    .byte     0
L7133:
    .ascii    "bitor"
    .byte     0
L7132:
    .ascii    "bitand"
    .byte     0
L7131:
    .ascii    "idivrem"
    .byte     0
L7130:
    .ascii    "irem"
    .byte     0
L7129:
    .ascii    "idiv"
    .byte     0
L7128:
    .ascii    "div"
    .byte     0
L7127:
    .ascii    "mul"
    .byte     0
L7126:
    .ascii    "sub"
    .byte     0
L7125:
    .ascii    "add"
    .byte     0
L7124:
    .ascii    "assem"
    .byte     0
L7123:
    .ascii    "clear"
    .byte     0
L7122:
    .ascii    "endsw"
    .byte     0
L7121:
    .ascii    "swlabel"
    .byte     0
L7120:
    .ascii    "switchu"
    .byte     0
L7119:
    .ascii    "switch"
    .byte     0
L7118:
    .ascii    "iswap"
    .byte     0
L7117:
    .ascii    "fordown"
    .byte     0
L7116:
    .ascii    "forup"
    .byte     0
L7115:
    .ascii    "to"
    .byte     0
L7114:
    .ascii    "stop"
    .byte     0
L7113:
    .ascii    "setcc"
    .byte     0
L7112:
    .ascii    "jumpretm"
    .byte     0
L7111:
    .ascii    "jumpret"
    .byte     0
L7110:
    .ascii    "jumpf"
    .byte     0
L7109:
    .ascii    "jumpt"
    .byte     0
L7108:
    .ascii    "jumpcc"
    .byte     0
L7107:
    .ascii    "ijump"
    .byte     0
L7106:
    .ascii    "jump"
    .byte     0
L7105:
    .ascii    "retfn"
    .byte     0
L7104:
    .ascii    "icallf"
    .byte     0
L7103:
    .ascii    "callf"
    .byte     0
L7102:
    .ascii    "retproc"
    .byte     0
L7101:
    .ascii    "icallp"
    .byte     0
L7100:
    .ascii    "callp"
    .byte     0
L7099:
    .ascii    "storebf"
    .byte     0
L7098:
    .ascii    "storebit"
    .byte     0
L7097:
    .ascii    "loadbf"
    .byte     0
L7096:
    .ascii    "loadbit"
    .byte     0
L7095:
    .ascii    "type"
    .byte     0
L7094:
    .ascii    "opnd"
    .byte     0
L7093:
    .ascii    "unload"
    .byte     0
L7092:
    .ascii    "swapstk"
    .byte     0
L7091:
    .ascii    "double"
    .byte     0
L7090:
    .ascii    "dupl"
    .byte     0
L7089:
    .ascii    "storem"
    .byte     0
L7088:
    .ascii    "istorex"
    .byte     0
L7087:
    .ascii    "istore"
    .byte     0
L7086:
    .ascii    "store"
    .byte     0
L7085:
    .ascii    "iloadx"
    .byte     0
L7084:
    .ascii    "iload"
    .byte     0
L7083:
    .ascii    "load"
    .byte     0
L7082:
    .ascii    "nop"
    .byte     0
L7081:
    .ascii    "any_opnd"
    .byte     0
L7080:
    .ascii    "data_opnd"
    .byte     0
L7079:
    .ascii    "realimm32_opnd"
    .byte     0
L7078:
    .ascii    "realimm_opnd"
    .byte     0
L7077:
    .ascii    "assem_opnd"
    .byte     0
L7076:
    .ascii    "strimm_opnd"
    .byte     0
L7075:
    .ascii    "string_opnd"
    .byte     0
L7074:
    .ascii    "r32_opnd"
    .byte     0
L7073:
    .ascii    "real_opnd"
    .byte     0
L7072:
    .ascii    "int_opnd"
    .byte     0
L7071:
    .ascii    "label_opnd"
    .byte     0
L7070:
    .ascii    "memaddr_opnd"
    .byte     0
L7069:
    .ascii    "mem_opnd"
    .byte     0
L7068:
    .ascii    "no_opnd"
    .byte     0
L7067:
    .ascii    "$last"
    .byte     0
L7066:
    .ascii    "vec"
    .byte     0
L7065:
    .ascii    "mem"
    .byte     0
L7064:
    .ascii    "i64"
    .byte     0
L7063:
    .ascii    "i32"
    .byte     0
L7062:
    .ascii    "i16"
    .byte     0
L7061:
    .ascii    "i8"
    .byte     0
L7060:
    .ascii    "u64"
    .byte     0
L7059:
    .ascii    "u32"
    .byte     0
L7058:
    .ascii    "u16"
    .byte     0
L7057:
    .ascii    "u8"
    .byte     0
L7056:
    .ascii    "r64"
    .byte     0
L7055:
    .ascii    "r32"
    .byte     0
L7054:
    .ascii    "void"
    .byte     0
L7053:
    .ascii    "pm_extra"
    .byte     0
L7052:
    .ascii    "pm_colon"
    .byte     0
L7051:
    .ascii    "pm_libfile"
    .byte     0
L7050:
    .ascii    "pm_sourcefile"
    .byte     0
L7049:
    .ascii    "pm_option"
    .byte     0
L7048:
    .ascii    "pm_end"
    .byte     0



