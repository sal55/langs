;NASM VERSION
    default rel
    extern fmod
    extern sin
    extern cos
    extern tan
    extern asin
    extern acos
    extern atan
    extern log
    extern log10
    extern exp
    extern floor
    extern ceil
    extern pow
    extern exit
    extern __getmainargs
    global main

    global msys.$cmdskip
    extern malloc
    extern realloc
    extern free
    extern memset
    extern memcpy
    extern memmove
    extern clock
    extern ftell
    extern fseek
    extern fread
    extern fwrite
    extern getc
    extern ungetc
    extern fopen
    extern fclose
    extern fgets
    extern remove
    extern rename
    extern getchar
    extern putchar
    extern setbuf
    extern strlen
    extern strcpy
    extern strcmp
    extern strncmp
    extern strncpy
    extern memcmp
    extern strcat
    extern tolower
    extern toupper
    extern isalpha
    extern isupper
    extern islower
    extern isalnum
    extern isspace
    extern strstr
    extern atol
    extern atoi
    extern strtod
    extern _strdup
    extern puts
    extern printf
    extern sprintf
    extern sscanf
    extern scanf
    extern rand
    extern srand
    extern system
    extern fgetc
    extern fputc
    extern fprintf
    extern fputs
    extern feof
    extern getch
    extern _getch
    extern kbhit
    extern _mkdir
    extern mkdir
    extern strchr
    extern _setmode
    extern _exit
    extern exit
    extern pow
    extern sin
    extern cos
    extern tan
    extern asin
    extern acos
    extern atan
    extern log
    extern log10
    extern exp
    extern floor
    extern ceil
    extern qsort
    extern __getmainargs
    extern GetStdHandle
    extern GetConsoleScreenBufferInfo
    extern SetConsoleCtrlHandler
    extern SetConsoleMode
    extern CreateProcessA
    extern GetLastError
    extern WaitForSingleObject
    extern GetExitCodeProcess
    extern CloseHandle
    extern GetNumberOfConsoleInputEvents
    extern FlushConsoleInputBuffer
    extern LoadLibraryA
    extern GetProcAddress
    extern LoadCursorA
    extern RegisterClassExA
    extern DefWindowProcA
    extern ReadConsoleInputA
    extern Sleep
    extern GetModuleFileNameA
    extern ExitProcess
    extern PostQuitMessage
    extern MessageBoxA
    extern QueryPerformanceCounter
    extern QueryPerformanceFrequency
    extern CreateFileA
    extern GetFileTime
    extern GetSystemTime
    extern GetLocalTime
    extern GetTickCount64
    extern PeekMessageA
    extern GetCommandLineA
    extern VirtualAlloc
    extern VirtualProtect
    extern WriteConsoleA
    extern FindFirstFileA
    extern FindNextFileA
    extern FindClose
    extern MessageBeep
    extern Beep
    global mm.main

    segment .bss
    alignb    8
msys.fmtparam:
    resb      8
    alignb    8
msys.$cmdskip:
$cmdskip:
    resb      8
    segment .data
    align     8
msys.needgap:
    dq  0
    align     8
msys.outdev:
    dq  1
    align     8
msys.outchan:
    dq  0
    align     8
msys.fmtstr:
    dq  0
    segment .bss
    alignb    8
msys.outchan_stack:
    resb      80
    alignb    8
msys.outdev_stack:
    resb      80
    alignb    8
msys.fmtstr_stack:
    resb      80
msys.needgap_stack:
    resb      10
    alignb    8
msys.ptr_stack:
    resb      80
    segment .data
    align     8
msys.niostack:
    dq  0
msys.digits:
    dq  0x3736353433323130
    dq  0x4645444342413938
    db        0
;ENDDATA
msys.defaultfmt:
    db        0
    db        0
    db        10
    db        0
    db        32
    db        102
    db        0
    db        0
    db        0
    db        82
    db        0
    db        0
    db        0
    db        0
    db        0
    db        0
    segment .bss
    alignb    8
msys.rd_buffer:
    resb      8
    alignb    8
msys.rd_length:
    resb      8
    alignb    8
msys.rd_pos:
    resb      8
    alignb    8
msys.rd_lastpos:
    resb      8
    alignb    8
msys.termchar:
    resb      8
    alignb    8
msys.itemerror:
    resb      8
msys.printbuffer:
    resb      4096
    alignb    8
msys.printptr:
    resb      8
    alignb    8
msys.printlen:
    resb      8
    alignb    8
msys.nsysparams:
    resb      8
    alignb    8
msys.ncmdparams:
    resb      8
    alignb    8
msys.nenvstrings:
    resb      8
    alignb    8
msys.sysparams:
    resb      1024
    alignb    8
msys.cmdparams:
    resb      8
    alignb    8
msys.envstrings:
    resb      8
msys.start.startupinfo:
    resb      128
msys.getfmt.fmt:
    resb      16
msys.strint.str:
    resb      100
msys.strword.str:
    resb      100
msys.strreal.str:
    resb      320
    alignb    8
mlib.allocupper:
    resb      2408
    alignb    8
mlib.alloccode:
    resb      8
    alignb    8
mlib.allocbytes:
    resb      8
    segment .data
    align     8
mlib.fdebug:
    dq  0
    segment .bss
    alignb    8
mlib.rfsize:
    resb      8
    alignb    8
mlib.maxmemory:
    resb      8
    alignb    8
mlib.maxalloccode:
    resb      8
    segment .data
mlib.pcm_setup:
    db        0
    align     8
mlib.show:
    dq  0
    align     8
mlib.memtotal:
    dq  0
    align     8
mlib.smallmemtotal:
    dq  0
    align     8
mlib.smallmemobjs:
    dq  0
    align     8
mlib.maxmemtotal:
    dq  0
    segment .bss
    alignb    8
mlib.memalloctable:
    resb      24
    alignb    4
mlib.memallocsize:
    resb      12
    alignb    8
mlib.pcheapstart:
    resb      8
    alignb    8
mlib.pcheapend:
    resb      8
    alignb    8
mlib.pcheapptr:
    resb      8
mlib.sizeindextable:
    resb      2049
    alignb    8
mlib.freelist:
    resb      72
    segment .data
    align     8
mlib.pmnames:
    dq  L10678
    dq  L10679
    dq  L10680
    dq  L10681
    dq  L10682
    dq  L10683
    align     8
mlib.seed:
    dq  0x2989881111111272
    dq  0x1673267373358264
    segment .bss
    alignb    8
mlib.pcm_newblock.totalheapsize:
    resb      8
    segment .data
    align     4
mlib.pcm_round.allocbytes:
    dd        0
    dd        16
    dd        32
    dd        64
    dd        128
    dd        256
    dd        512
    dd        1024
    dd        2048
    segment .bss
mlib.changeext.newfile:
    resb      260
mlib.extractpath.str:
    resb      260
mlib.extractbasefile.str:
    resb      100
    segment .data
    align     8
mlib.nextcmdparamnew.infile:
    dq  0
    align     8
mlib.nextcmdparamnew.filestart:
    dq  0
    align     8
mlib.nextcmdparamnew.fileptr:
    dq  0
mlib.nextcmdparamnew.colonseen:
    db        0
    segment .bss
mlib.nextcmdparamnew.str:
    resb      300
mlib.readnextfileitem.str:
    resb      256
mlib.padstr.str:
    resb      256
mlib.chr.str:
    resb      8
    alignb    8
mwindows.hconsole:
    resb      8
    alignb    8
mwindows.hconsolein:
    resb      8
    alignb    4
mwindows.lastkey:
    resb      20
    alignb    4
mwindows.pendkey:
    resb      20
    alignb    8
mwindows.keypending:
    resb      8
    alignb    8
mwindows.hpfreq:
    resb      8
    segment .data
    align     8
mwindows.wndproc_callbackfn:
    dq  0
    align     8
mwindows.init_flag:
    dq  0
    segment .bss
mwindows.os_gxregisterclass.registered:
    resb      1
    segment .data
    align     8
mwindows.mainwndproc.count:
    dq  0
    segment .bss
mwindows.os_gethostname.name:
    resb      300
    alignb    8
mwindows.os_gethostname.n:
    resb      8
    alignb    8
mwindows.os_peek.lastticks:
    resb      8
    segment .data
pcl.pc_userunpcl:
    db        0
    segment .bss
    alignb    8
pc_api.pclseqno:
    resb      8
    alignb    8
pc_api.stseqno:
    resb      8
    alignb    8
pc_api.pcstart:
    resb      8
    alignb    8
pc_api.pccurr:
    resb      8
    alignb    8
pc_api.pcend:
    resb      8
    alignb    8
pc_api.pcalloc:
    resb      8
pc_api.pcfixed:
    resb      1
    alignb    8
pc_api.pcseqno:
    resb      8
    alignb    8
pc_api.pcneedfntable:
    resb      8
    segment .data
    align     8
pc_api.initpcalloc:
    dq  0x10000
    segment .bss
    alignb    8
pc_api.longstring:
    resb      8
    alignb    8
pc_api.longstringlen:
    resb      8
    alignb    8
pc_api.mlabelno:
    resb      8
pc_api.phighmem:
    resb      1
pc_api.pfullsys:
    resb      1
pc_api.fpshortnames:
    resb      1
    alignb    8
pc_api.idomcl_assem:
    resb      8
    alignb    8
pc_api.icheckasmlabel:
    resb      8
    alignb    8
pc_api.igethostfn:
    resb      8
pc_api.strpmode.str:
    resb      32
pc_api.getfullname.str:
    resb      256
pc_api.addstr.str:
    resb      256
    alignb    8
pc_decls.pinfo:
    resb      8
    alignb    8
pc_decls.bspill:
    resb      8
    alignb    8
pc_decls.bxspill:
    resb      8
pc_decls.r10used:
    resb      1
pc_decls.r11used:
    resb      1
pc_decls.localshadow:
    resb      1
    alignb    8
pc_decls.mmpos:
    resb      8
    alignb    8
pc_decls.psymboltable:
    resb      8
    alignb    8
pc_decls.psymboltablex:
    resb      8
    alignb    8
pc_decls.currprog:
    resb      8
    alignb    8
pc_decls.currfunc:
    resb      8
    alignb    8
pc_decls.blockretname:
    resb      8
    alignb    8
pc_decls.entryproc:
    resb      8
pc_decls.sbuffer:
    resb      16
    segment .data
    align     8
pc_decls.pdest:
    dq  pc_decls.sbuffer
    segment .bss
    alignb    8
pc_decls.plibfiles:
    resb      400
    alignb    8
pc_decls.plibinst:
    resb      400
    alignb    8
pc_decls.nplibfiles:
    resb      8
    alignb    8
pc_decls.igetmsourceinfo:
    resb      8
pc_decls.pcldone:
    resb      1
pc_decls.mcldone:
    resb      1
pc_decls.ssdone:
    resb      1
pc_decls.objdone:
    resb      1
pc_decls.exedone:
    resb      1
pc_decls.pverbose:
    resb      1
    alignb    8
pc_decls.pcmdskip:
    resb      8
    segment .data
    align     8
pc_decls.assemtype:
    dq  0x4141
    segment .bss
    alignb    8
pc_decls.ppseqno:
    resb      8
    segment .data
pc_decls.fpeephole:
    db        1
pc_decls.fregoptim:
    db        1
    segment .bss
    alignb    8
pc_decls.mcltime:
    resb      8
    alignb    8
pc_decls.sstime:
    resb      8
    alignb    8
pc_decls.objtime:
    resb      8
    alignb    8
pc_decls.exetime:
    resb      8
    alignb    8
pc_decls.$pmodulename:
    resb      8
    alignb    8
pc_decls.pclflags:
    resb      1144
    alignb    8
pc_decls.pstartclock:
    resb      8
pc_diags.sbuffer:
    resb      16
    segment .data
    align     8
pc_diags.dest:
    dq  pc_diags.sbuffer
    segment .bss
    alignb    8
pc_diags.destlinestart:
    resb      8
pc_diags.stropnd.str:
    resb      512
    alignb    8
pc_diags.stropnd.longstring:
    resb      8
    segment .data
    align     8
pc_run.dotrace:
    dq  0
    align     8
pc_run.dostep:
    dq  1
    segment .bss
    alignb    8
pc_run.go:
    resb      8
    alignb    8
pc_run.seqno:
    resb      8
    alignb    8
pc_run.emptyst:
    resb      128
    alignb    8
pc_run.labeltable:
    resb      8
    segment .data
    align     8
pc_tables.pstdnames:
    dq  L10684
    dq  L10685
    dq  L10686
    dq  L10687
    dq  L10688
    dq  L10689
    dq  L10690
    dq  L10691
    dq  L10692
    dq  L10693
    dq  L10694
    dq  L10695
    dq  L10696
    dq  L10697
pc_tables.psize:
    dq  0x108040201080400
    db        2
    db        4
    db        8
    db        0
    db        0
    db        0
;ENDDATA
pc_tables.psigned:
    dq  0x100000000000000
    db        1
    db        1
    db        1
    db        0
    db        0
    db        0
;ENDDATA
pc_tables.pint:
    dq  0x101010101000000
    db        1
    db        1
    db        1
    db        0
    db        0
    db        0
;ENDDATA
pc_tables.pfloat:
    dq  0x10100
    db        0
    db        0
    db        0
    db        0
    db        0
    db        0
;ENDDATA
pc_tables.pmin:
    dq  0x906050505020100
    db        9
    db        9
    db        10
    db        11
    db        12
    db        0
;ENDDATA
pc_tables.piwrb:
    dq  0xA06060606020100
    db        10
    db        10
    db        10
    db        0
    db        0
    db        0
;ENDDATA
    align     8
pc_tables.opndnames:
    dq  L10698
    dq  L10699
    dq  L10700
    dq  L10701
    dq  L10702
    dq  L10703
    dq  L10704
    dq  L10705
    dq  L10706
    dq  L10707
    dq  L10708
    dq  L10709
    dq  L10710
    dq  L10711
    align     8
pc_tables.pclnames:
    dq  L10712
    dq  L10713
    dq  L10714
    dq  L10715
    dq  L10716
    dq  L10717
    dq  L10718
    dq  L10719
    dq  L10720
    dq  L10721
    dq  L10722
    dq  L10723
    dq  L10724
    dq  L10725
    dq  L10726
    dq  L10727
    dq  L10728
    dq  L10729
    dq  L10730
    dq  L10731
    dq  L10732
    dq  L10733
    dq  L10734
    dq  L10735
    dq  L10736
    dq  L10737
    dq  L10738
    dq  L10739
    dq  L10740
    dq  L10741
    dq  L10742
    dq  L10743
    dq  L10744
    dq  L10745
    dq  L10746
    dq  L10747
    dq  L10748
    dq  L10749
    dq  L10750
    dq  L10751
    dq  L10752
    dq  L10753
    dq  L10754
    dq  L10755
    dq  L10756
    dq  L10757
    dq  L10758
    dq  L10759
    dq  L10760
    dq  L10761
    dq  L10762
    dq  L10763
    dq  L10764
    dq  L10765
    dq  L10766
    dq  L10767
    dq  L10768
    dq  L10769
    dq  L10770
    dq  L10771
    dq  L10772
    dq  L10773
    dq  L10774
    dq  L10775
    dq  L10776
    dq  L10777
    dq  L10778
    dq  L10779
    dq  L10780
    dq  L10781
    dq  L10782
    dq  L10783
    dq  L10784
    dq  L10785
    dq  L10786
    dq  L10787
    dq  L10788
    dq  L10789
    dq  L10790
    dq  L10791
    dq  L10792
    dq  L10793
    dq  L10794
    dq  L10795
    dq  L10796
    dq  L10797
    dq  L10798
    dq  L10799
    dq  L10800
    dq  L10801
    dq  L10802
    dq  L10803
    dq  L10804
    dq  L10805
    dq  L10806
    dq  L10807
    dq  L10808
    dq  L10809
    dq  L10810
    dq  L10811
    dq  L10812
    dq  L10813
    dq  L10814
    dq  L10815
    dq  L10816
    dq  L10817
    dq  L10818
    dq  L10819
    dq  L10820
    dq  L10821
    dq  L10822
    dq  L10823
    dq  L10824
    dq  L10825
    dq  L10826
    dq  L10827
    dq  L10828
    dq  L10829
    dq  L10830
    dq  L10831
    dq  L10832
    dq  L10833
    dq  L10834
    dq  L10835
    dq  L10836
    dq  L10837
    dq  L10838
    dq  L10839
    dq  L10840
    dq  L10841
    dq  L10842
    dq  L10843
    dq  L10844
    dq  L10845
    dq  L10846
    dq  L10847
    dq  L10848
    dq  L10849
    dq  L10850
    dq  L10851
    dq  L10852
    dq  L10853
    dq  L10854
pc_tables.pclhastype:
    dq  0x101010101010100
    dq  0x101010101000000
    dq  0x101010000000101
    dq  0x101010101010100
    dq  0x10101010100
    dq  0x101010101000100
    dq  0x101010101010101
    dq  0x101010101010101
    dq  0x101010101010202
    dq  0x101010101010101
    dq  0x101010101010101
    dq  0x101010101010101
    dq  0x101010101010101
    dq  0x202010101010101
    dq  0x101000202020202
    dq  0x10101000000
    dq  0
    db        0
    db        1
    db        1
    db        1
    db        0
    db        0
    db        0
;ENDDATA
pc_tables.pclextra:
    dq  0x2000002000100
    dq  0x20000
    dq  0x2020002020000
    dq  0x10000
    dq  0x2020001010000
    dq  0
    dq  0
    dq  0x1020200
    dq  0
    dq  0
    dq  0x101010100000000
    dq  0x101
    dq  0x100000000000000
    dq  1
    dq  0
    dq  0
    dq  0x201000000
    db        0
    db        0
    db        0
    db        0
    db        0
    db        0
    db        0
;ENDDATA
pc_tables.pclhasopnd:
    dq  0x100000D00
    dq  0xD00000000
    dq  0x20000020000
    dq  0x3030303030003
    dq  0x303030003030300
    dq  0xD0000
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0x3000D0101000101
    dq  2
    db        0
    db        1
    db        1
    db        0
    db        0
    db        7
    db        1
;ENDDATA
pc_tables.pclargs:
    dq  0
    dq  0x202000000000000
    dq  0x9090009090202
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0x101010100000000
    dq  0x101010101010101
    dq  0x2020201
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    db        0
    db        0
    db        0
    db        0
    db        0
    db        0
    db        0
;ENDDATA
    align     8
pc_tables.ccnames:
    dq  L10855
    dq  L10856
    dq  L10857
    dq  L10858
    dq  L10859
    dq  L10860
    dq  L10861
    align     8
pc_tables.idnames:
    dq  L10862
    dq  L10863
    dq  L10864
    dq  L10865
    dq  L10866
    dq  L10867
    dq  L10868
    dq  L10869
    dq  L10870
    dq  L10871
    segment .bss
    alignb    8
mc_genmcl.debug:
    resb      8
    alignb    8
mc_genmcl.frameoffset:
    resb      8
    alignb    8
mc_genmcl.paramoffset:
    resb      8
    alignb    8
mc_genmcl.framebytes:
    resb      8
    alignb    8
mc_genmcl.px_handlertable:
    resb      1144
    segment .data
mc_genmcl.scondcodes:
    db        4
    db        5
    db        12
    db        14
    db        13
    db        15
;ENDDATA
mc_genmcl.ucondcodes:
    db        4
    db        5
    db        2
    db        6
    db        3
    db        7
;ENDDATA
mc_genmcl.inithandlers.initdone:
    db        0
mc_genmcl.inithandlers.dupltable:
    db        "A@"
;ENDDATA
    db        21
    db        18
;ENDDATA
    db        19
    db        18
;ENDDATA
    db        22
    db        18
;ENDDATA
    db        "wv"
;ENDDATA
    db        "yx"
;ENDDATA
    db        "^/"
;ENDDATA
    db        "_0"
;ENDDATA
    segment .bss
    alignb    8
mc_auxmcl.nnn:
    resb      8
    alignb    8
mc_auxmcl.nauxprocs:
    resb      8
    alignb    8
mc_auxmcl.nauxnoframe:
    resb      8
    alignb    8
mc_auxmcl.mclframesetup:
    resb      8
    alignb    8
mc_libmcl.mclseqno:
    resb      8
    alignb    8
mc_libmcl.nmclopnd:
    resb      8
    alignb    8
mc_libmcl.smallinttable:
    resb      96
    alignb    8
mc_libmcl.nametable:
    resb      160
    alignb    8
mc_libmcl.nnametable:
    resb      8
    alignb    8
mc_libmcl.mgenextname.table:
    resb      160
    alignb    8
mc_libmcl.mgenextname.ntable:
    resb      8
mc_stackmcl.stropndstack.str:
    resb      512
mc_genss.rex:
    resb      1
mc_genss.sizeoverride:
    resb      1
mc_genss.addroverride:
    resb      1
mc_genss.f2override:
    resb      1
mc_genss.f3override:
    resb      1
mc_genss.nowmask:
    resb      1
mc_genss.usesizeb:
    resb      1
    alignb    8
mc_genss.extraparam:
    resb      8
    segment .data
    align     8
mc_genss.currseg:
    dq  0
    segment .bss
    alignb    8
mc_genss.currdata:
    resb      8
    alignb    8
mc_genss.currrelocs:
    resb      8
    alignb    8
mc_genss.nrelocs:
    resb      8
mc_genss.ishighreg:
    resb      16
    alignb    8
mc_genss.currmcl:
    resb      8
    alignb    8
mc_genss.ripentry:
    resb      8
    segment .data
    align     8
mc_genss.genrm.scaletable:
    dq  0
    dq  1
    dq  0
    dq  2
    dq  0
    dq  0
    dq  0
    dq  3
    align     8
mc_decls.valtypenames:
    dq  L10872
    dq  L10873
    dq  L10874
    dq  L10875
    dq  L10876
    dq  L10877
    dq  L10878
    dq  L10879
    dq  L10880
    align     8
mc_decls.mclnames:
    dq  L10881
    dq  L10882
    dq  L10883
    dq  L10884
    dq  L10885
    dq  L10886
    dq  L10887
    dq  L10888
    dq  L10889
    dq  L10890
    dq  L10891
    dq  L10892
    dq  L10893
    dq  L10894
    dq  L10895
    dq  L10896
    dq  L10897
    dq  L10898
    dq  L10899
    dq  L10900
    dq  L10901
    dq  L10902
    dq  L10903
    dq  L10904
    dq  L10905
    dq  L10906
    dq  L10907
    dq  L10908
    dq  L10909
    dq  L10910
    dq  L10911
    dq  L10912
    dq  L10913
    dq  L10914
    dq  L10915
    dq  L10916
    dq  L10917
    dq  L10918
    dq  L10919
    dq  L10920
    dq  L10921
    dq  L10922
    dq  L10923
    dq  L10924
    dq  L10925
    dq  L10926
    dq  L10927
    dq  L10928
    dq  L10929
    dq  L10930
    dq  L10931
    dq  L10932
    dq  L10933
    dq  L10934
    dq  L10935
    dq  L10936
    dq  L10937
    dq  L10938
    dq  L10939
    dq  L10940
    dq  L10941
    dq  L10942
    dq  L10943
    dq  L10944
    dq  L10945
    dq  L10946
    dq  L10947
    dq  L10948
    dq  L10949
    dq  L10950
    dq  L10951
    dq  L10952
    dq  L10953
    dq  L10954
    dq  L10955
    dq  L10956
    dq  L10957
    dq  L10958
    dq  L10959
    dq  L10960
    dq  L10961
    dq  L10962
    dq  L10963
    dq  L10964
    dq  L10965
    dq  L10966
    dq  L10967
    dq  L10968
    dq  L10969
    dq  L10970
    dq  L10971
    dq  L10972
    dq  L10973
    dq  L10974
    dq  L10975
    dq  L10976
    dq  L10977
    dq  L10978
    dq  L10979
    dq  L10980
    dq  L10981
    dq  L10982
    dq  L10983
    dq  L10984
    dq  L10985
    dq  L10986
    dq  L10987
    dq  L10988
    dq  L10989
    dq  L10990
    dq  L10991
    dq  L10992
    dq  L10993
    dq  L10994
    dq  L10995
    dq  L10996
    dq  L10997
    dq  L10998
    dq  L10999
    dq  L11000
    dq  L11001
    dq  L11002
    dq  L11003
    dq  L11004
    dq  L11005
    dq  L11006
    dq  L11007
    dq  L11008
    dq  L11009
    dq  L11010
    dq  L11011
    dq  L11012
    dq  L11013
    dq  L11014
    dq  L11015
    dq  L11016
    dq  L11017
    dq  L11018
    dq  L11019
    dq  L11020
    dq  L11021
    dq  L11022
    dq  L11023
    dq  L11024
    dq  L11025
    dq  L11026
    dq  L11027
    dq  L11028
    dq  L11029
    dq  L11030
    dq  L11031
mc_decls.mclnopnds:
    dq  0
    dq  0x202020101020001
    dq  0x100000102020202
    dq  0x102020202020101
    dq  0x202020101030201
    dq  0x202020202020202
    dq  0x101010102
    dq  0x202020202020100
    dq  0x202020202020202
    dq  0x202020202020202
    dq  0x202020202020202
    dq  0x101010303020202
    dq  0x10101
    dq  0x200000000000000
    dq  0x1010101020202
    dq  0x1010101010000
    dq  0x101010101
    dq  0x1020000
    db        0
    db        0
    db        0
    db        0
    db        0
    db        0
    db        0
;ENDDATA
mc_decls.mclcodes:
    dq  0
    dq  0x9000
    dq  0xC9C3E800000000
    dq  0x5030205000000E9
    dq  0x601040607000004
    dq  0x201000507040700
    dq  0x100020303
    dq  0x5151ACA4BDBC0000
    dq  0x5E5E59595C5C5858
    dq  0xEF545457572E2F00
    dq  0xDB
    dq  0x302006263F36600
    dq  0xFAF9C9E9C1030200
    dq  0x5DE0E1F3F2FBFFFE
    dq  0x5F5D5F
    dq  0xD708040201000000
    dq  0xE3E3E2E1E0
    dq  0xEBE8EE0000003100
    db        233
    db        234
    db        236
    db        237
    db        0
    db        244
    db        244
;ENDDATA
    align     8
mc_decls.regnames:
    dq  L11032
    dq  L11033
    dq  L11034
    dq  L11035
    dq  L11036
    dq  L11037
    dq  L11038
    dq  L11039
    dq  L11040
    dq  L11041
    dq  L11042
    dq  L11043
    dq  L11044
    dq  L11045
    dq  L11046
    dq  L11047
    dq  L11048
    dq  L11049
    dq  L11050
    dq  L11051
    dq  L11052
mc_decls.regcodes:
    dq  0xC0603070B0A0000
    dq  0x5090802010F0E0D
    db        4
    db        4
    db        7
    db        5
    db        6
;ENDDATA
    align     8
mc_decls.condnames:
    dq  L11053
    dq  L11054
    dq  L11055
    dq  L11056
    dq  L11057
    dq  L11058
    dq  L11059
    dq  L11060
    dq  L11061
    dq  L11062
    dq  L11063
    dq  L11064
    dq  L11065
    dq  L11066
    dq  L11067
    dq  L11068
    dq  L11069
    dq  L11070
    dq  L11071
    dq  L11072
    align     8
mc_decls.asmcondnames:
    dq  L11073
    dq  L11074
    dq  L11075
    dq  L11076
    dq  L11077
    dq  L11078
    dq  L11079
    dq  L11080
    dq  L11081
    dq  L11082
    dq  L11083
    dq  L11084
    dq  L11085
    dq  L11086
    dq  L11087
    dq  L11088
    dq  L11089
    dq  L11090
    dq  L11091
    dq  L11092
    align     8
mc_decls.asmrevcond:
    dq  1
    dq  0
    dq  3
    dq  2
    dq  5
    dq  4
    dq  7
    dq  6
    dq  9
    dq  8
    dq  0xB
    dq  0xA
    dq  0xD
    dq  0xC
    dq  0xF
    dq  0xE
    dq  0x11
    dq  0x10
    dq  0x13
    dq  0x12
    align     8
mc_decls.dregnames:
    dq  L11093
    dq  L11094
    dq  L11095
    dq  L11096
    dq  L11097
    dq  L11098
    dq  L11099
    dq  L11100
    dq  L11101
    dq  L11102
    dq  L11103
    dq  L11104
    dq  L11105
    dq  L11106
    dq  L11107
    dq  L11108
    dq  L11109
    dq  L11110
    dq  L11111
    dq  L11112
    dq  L11113
    dq  L11114
    dq  L11115
    dq  L11116
    dq  L11117
    dq  L11118
    dq  L11119
    dq  L11120
    dq  L11121
    dq  L11122
    dq  L11123
    dq  L11124
    dq  L11125
    dq  L11126
    dq  L11127
    dq  L11128
    dq  L11129
    dq  L11130
    dq  L11131
    dq  L11132
    dq  L11133
    dq  L11134
    dq  L11135
    dq  L11136
    dq  L11137
    dq  L11138
    dq  L11139
    dq  L11140
    dq  L11141
    dq  L11142
    dq  L11143
    dq  L11144
    dq  L11145
    dq  L11146
    dq  L11147
    dq  L11148
    dq  L11149
    dq  L11150
    dq  L11151
    dq  L11152
    dq  L11153
    dq  L11154
    dq  L11155
    dq  L11156
    dq  L11157
    dq  L11158
    dq  L11159
    dq  L11160
    dq  L11161
    dq  L11162
    dq  L11163
    dq  L11164
    dq  L11165
    dq  L11166
    dq  L11167
    dq  L11168
    dq  L11169
    dq  L11170
    dq  L11171
    dq  L11172
    dq  L11173
    dq  L11174
    dq  L11175
    dq  L11176
    dq  L11177
    dq  L11178
    dq  L11179
    dq  L11180
    dq  L11181
    dq  L11182
    dq  L11183
    dq  L11184
    dq  L11185
    dq  L11186
    dq  L11187
    dq  L11188
    dq  L11189
    dq  L11190
    dq  L11191
    dq  L11192
    dq  L11193
    dq  L11194
    dq  L11195
    dq  L11196
    dq  L11197
    dq  L11198
    dq  L11199
    dq  L11200
    dq  L11201
    dq  L11202
    dq  L11203
    dq  L11204
    dq  L11205
    dq  L11206
    dq  L11207
    dq  L11208
    dq  L11209
    dq  L11210
    dq  L11211
    dq  L11212
    dq  L11213
    dq  L11214
    dq  L11215
    dq  L11216
    dq  L11217
    dq  L11218
    dq  L11219
    dq  L11220
    dq  L11221
    dq  L11222
    dq  L11223
    dq  L11224
    dq  L11225
    dq  L11226
    dq  L11227
    dq  L11228
    dq  L11229
mc_decls.regsizes:
    dq  0x808080808080808
    dq  0x808080808080808
    dq  0x404040404040404
    dq  0x404040404040404
    dq  0x202020202020202
    dq  0x202020202020202
    dq  0x101010101010101
    dq  0x101010101010101
    dq  0x808080001010101
    dq  0x808080808080808
    dq  0x404040808080808
    dq  0x404040404040404
    dq  0x202020404040404
    dq  0x202020202020202
    dq  0x101010202020202
    dq  0x101010101010101
    dq  0x101010101010101
    db        1
;ENDDATA
mc_decls.regindices:
    dq  0x807060504030201
    dq  0x100F0E0D0C0B0A09
    dq  0x807060504030201
    dq  0x100F0E0D0C0B0A09
    dq  0x807060504030201
    dq  0x100F0E0D0C0B0A09
    dq  0x807060504030201
    dq  0x100F0E0D0C0B0A09
    dq  0xB05010014131211
    dq  0x20E0D100F04060C
    dq  0xB05010A09080703
    dq  0x20E0D100F04060C
    dq  0xB05010A09080703
    dq  0x20E0D100F04060C
    dq  0xB05010A09080703
    dq  0xF0406141312110C
    dq  0x9080703020E0D10
    db        10
;ENDDATA
    align     8
mc_decls.xmmregnames:
    dq  L11230
    dq  L11231
    dq  L11232
    dq  L11233
    dq  L11234
    dq  L11235
    dq  L11236
    dq  L11237
    dq  L11238
    dq  L11239
    dq  L11240
    dq  L11241
    dq  L11242
    dq  L11243
    dq  L11244
    dq  L11245
    align     8
mc_decls.fregnames:
    dq  L11246
    dq  L11247
    dq  L11248
    dq  L11249
    dq  L11250
    dq  L11251
    dq  L11252
    dq  L11253
    align     8
mc_decls.mregnames:
    dq  L11254
    dq  L11255
    dq  L11256
    dq  L11257
    dq  L11258
    dq  L11259
    dq  L11260
    dq  L11261
    align     8
mc_decls.jmpccnames:
    dq  L11262
    dq  L11263
    dq  L11264
    dq  L11265
    dq  L11266
    dq  L11267
    dq  L11268
    dq  L11269
    dq  L11270
    dq  L11271
    dq  L11272
    dq  L11273
    dq  L11274
    dq  L11275
    dq  L11276
    dq  L11277
    dq  L11278
    dq  L11279
mc_decls.jmpcccodes:
    dq  0x706050403020100
    dq  0xF0E0D0C0B0A0908
    db        2
    db        3
;ENDDATA
    align     8
mc_decls.setccnames:
    dq  L11280
    dq  L11281
    dq  L11282
    dq  L11283
    dq  L11284
    dq  L11285
    dq  L11286
    dq  L11287
    dq  L11288
    dq  L11289
    dq  L11290
    dq  L11291
    dq  L11292
    dq  L11293
    dq  L11294
    dq  L11295
mc_decls.setcccodes:
    dq  0x706050403020100
    dq  0xF0E0D0C0B0A0908
;ENDDATA
    align     8
mc_decls.cmovccnames:
    dq  L11296
    dq  L11297
    dq  L11298
    dq  L11299
    dq  L11300
    dq  L11301
    dq  L11302
    dq  L11303
    dq  L11304
    dq  L11305
    dq  L11306
    dq  L11307
    dq  L11308
    dq  L11309
    dq  L11310
    dq  L11311
mc_decls.cmovcccodes:
    dq  0x706050403020100
    dq  0xF0E0D0C0B0A0908
;ENDDATA
    align     8
mc_decls.segmentnames:
    dq  L11312
    dq  L11313
    dq  L11314
    dq  L11315
    dq  L11316
    dq  L11317
    align     8
mc_decls.reftypenames:
    dq  L11318
    dq  L11319
    dq  L11320
    align     8
mc_decls.opndnames_ma:
    dq  L11321
    dq  L11322
    dq  L11323
    dq  L11324
    dq  L11325
    dq  L11326
    segment .bss
    alignb    8
mc_decls.pclopnd:
    resb      160
mc_decls.pclreg:
    resb      20
mc_decls.pclmode:
    resb      20
mc_decls.pclcount:
    resb      20
mc_decls.pclloc:
    resb      20
mc_decls.pcltempflags:
    resb      20
    alignb    8
mc_decls.pcltempopnds:
    resb      160
    alignb    8
mc_decls.noperands:
    resb      8
    alignb    8
mc_decls.mstackdepth:
    resb      8
    segment .data
    align     8
mc_decls.locnames:
    dq  L11327
    dq  L11328
    dq  L11329
    dq  L11330
    segment .bss
mc_decls.workregs:
    resb      16
mc_decls.workxregs:
    resb      16
    alignb    8
mc_decls.nworkregs:
    resb      8
    alignb    8
mc_decls.nworkxregs:
    resb      8
    alignb    8
mc_decls.nregvars:
    resb      8
    alignb    8
mc_decls.nxregvars:
    resb      8
    alignb    8
mc_decls.maxregvars:
    resb      8
    alignb    8
mc_decls.maxxregvars:
    resb      8
    alignb    8
mc_decls.xregmax:
    resb      8
mc_decls.regset:
    resb      16
mc_decls.xregset:
    resb      16
mc_decls.isregvar:
    resb      16
mc_decls.isxregvar:
    resb      16
mc_decls.usedregs:
    resb      16
mc_decls.usedxregs:
    resb      16
mc_decls.noxorclear:
    resb      1
    segment .data
    align     8
mc_decls.xregnames:
    dq  L11331
    dq  L11332
    dq  L11333
    dq  L11334
    dq  L11335
    dq  L11336
    dq  L11337
    dq  L11338
    dq  L11339
    dq  L11340
    dq  L11341
    dq  L11342
    dq  L11343
    dq  L11344
    dq  L11345
    dq  L11346
    dq  L11346
    segment .bss
mc_decls.callalign:
    resb      16
mc_decls.callblockret:
    resb      16
    alignb    4
mc_decls.callblocksize:
    resb      64
    alignb    4
mc_decls.callargsize:
    resb      256
    alignb    8
mc_decls.ncalldepth:
    resb      8
    alignb    8
mc_decls.lababs32:
    resb      8
    alignb    8
mc_decls.lababs64:
    resb      8
    alignb    8
mc_decls.labneg32:
    resb      8
    alignb    8
mc_decls.labneg64:
    resb      8
    alignb    8
mc_decls.labmask63:
    resb      8
    alignb    8
mc_decls.laboffset64:
    resb      8
    alignb    8
mc_decls.labzero:
    resb      8
    segment .data
    align     8
mc_decls.kk0used:
    dq  0
    segment .bss
    alignb    8
mc_decls.mccode:
    resb      8
    alignb    8
mc_decls.mccodex:
    resb      8
    segment .data
    align     8
mc_decls.currsegment:
    dq  0
    segment .bss
    alignb    8
mc_decls.dstackopnd:
    resb      8
    alignb    8
mc_decls.dframeopnd:
    resb      8
    alignb    8
mc_decls.regtable:
    resb      1024
    alignb    8
mc_decls.frameregtable:
    resb      1544
    alignb    8
mc_decls.cstringlist:
    resb      8
    alignb    8
mc_decls.vstringlist:
    resb      8
    alignb    8
mc_decls.creallist:
    resb      8
    alignb    8
mc_decls.cr32list:
    resb      8
    alignb    8
mc_decls.currasmproc:
    resb      8
    alignb    8
mc_decls.lab_funcnametable:
    resb      8
    alignb    8
mc_decls.lab_funcaddrtable:
    resb      8
    alignb    8
mc_decls.lab_funcnprocs:
    resb      8
    alignb    8
mc_decls.ss_zdatalen:
    resb      8
    alignb    8
mc_decls.ss_zdata:
    resb      8
    alignb    8
mc_decls.ss_idata:
    resb      8
    alignb    8
mc_decls.ss_code:
    resb      8
    alignb    8
mc_decls.ss_idatarelocs:
    resb      8
    alignb    8
mc_decls.ss_coderelocs:
    resb      8
    alignb    8
mc_decls.ss_nidatarelocs:
    resb      8
    alignb    8
mc_decls.ss_ncoderelocs:
    resb      8
    alignb    8
mc_decls.ss_symboltable:
    resb      8
    alignb    8
mc_decls.ss_nsymbols:
    resb      8
    alignb    8
mc_decls.ss_symboltablesize:
    resb      8
    alignb    8
mc_decls.labeldeftable:
    resb      8
    alignb    8
mc_decls.aaseqno:
    resb      8
    segment .data
mc_decls.regmodes:
    dq  0x600000005000403
;ENDDATA
    segment .bss
mc_decls.pmode:
    resb      1
    alignb    8
mc_decls.currpcl:
    resb      8
    alignb    8
mc_decls.mclprocentry:
    resb      8
    alignb    8
mc_decls.mce_oldmccodex:
    resb      8
    alignb    8
mc_decls.mce_lastmcl:
    resb      8
    alignb    8
mc_decls.mce_nextmcl:
    resb      8
    alignb    8
mc_decls.mcf_oldmccodex:
    resb      8
    alignb    8
mc_decls.mcf_lastmcl:
    resb      8
    alignb    8
mc_decls.mcf_nextmcl:
    resb      8
mc_decls.fpcheckunusedlocals:
    resb      1
    alignb    8
mc_decls.riplist:
    resb      8
    alignb    8
mc_decls.blockdefs:
    resb      400
    alignb    8
mc_decls.nblocktemps:
    resb      8
    segment .data
    align     8
mc_decls.multregs:
    dq  1
    dq  2
    dq  3
    dq  0xB
    dq  0xC
    dq  0xD
    align     8
mc_decls.multxregs:
    dq  1
    dq  2
    dq  3
    dq  4
    dq  5
    dq  6
    segment .bss
mc_decls.ploadopx:
    resb      14
mc_decls.ploadop:
    resb      14
    segment .data
    align     8
mc_objdecls.relocnames:
    dq  L11347
    dq  L11348
    dq  L11349
    dq  L11350
    dq  L11351
    dq  L11352
    dq  L11353
    segment .bss
    alignb    8
mc_writenasm.nregnames:
    resb      1024
mc_writenasm.currseg:
    resb      1
mc_writenasm.strmcl.str:
    resb      512
mc_writenasm.mstropnd.str:
    resb      512
mc_writenasm.strvalue.str:
    resb      512
mc_writenasm.getxregname.str:
    resb      32
mc_writenasm.getdispname.str:
    resb      256
mc_writenasm.gettempname.str:
    resb      128
    alignb    8
mc_writeexe.libinsttable:
    resb      400
    alignb    8
mc_writeexe.libinstnames:
    resb      400
    alignb    8
mc_writeexe.libnotable:
    resb      400
    alignb    8
mc_writeexe.basereloclist:
    resb      8
    alignb    8
mc_writeexe.nbaserelocs:
    resb      8
    alignb    8
mc_writeexe.maxrelocaddr:
    resb      8
    alignb    8
mc_writeexe.blockbases:
    resb      4000
    alignb    4
mc_writeexe.blockcounts:
    resb      2000
    alignb    4
mc_writeexe.blockbytes:
    resb      2000
mc_writeexe.blockpadding:
    resb      500
    alignb    8
mc_writeexe.nbaseblocks:
    resb      8
    alignb    8
mc_writeexe.basetablesize:
    resb      8
    alignb    8
mc_writeexe.imagebase:
    resb      8
    alignb    8
mc_writeexe.imagesize:
    resb      8
    alignb    8
mc_writeexe.filesize:
    resb      8
    alignb    8
mc_writeexe.thunktable:
    resb      8
    alignb    8
mc_writeexe.fileiatoffset:
    resb      8
    alignb    8
mc_writeexe.fileiatsize:
    resb      8
    alignb    8
mc_writeexe.stentrypoint:
    resb      8
    alignb    8
mc_writeexe.stentrypoint2:
    resb      8
    alignb    8
mc_writeexe.stentrypoint3:
    resb      8
mc_writeexe.sectiontable:
    resb      720
    alignb    8
mc_writeexe.nsections:
    resb      8
    alignb    8
mc_writeexe.importdir:
    resb      8
mc_writeexe.importtable:
    resb      144048
    alignb    8
mc_writeexe.nimports:
    resb      8
mc_writeexe.exporttable:
    resb      16000
    alignb    8
mc_writeexe.nexports:
    resb      8
    alignb    8
mc_writeexe.dllfilename:
    resb      8
    alignb    8
mc_writeexe.isdll:
    resb      8
mc_writeexe.dlltable:
    resb      2400
    alignb    8
mc_writeexe.ndlls:
    resb      8
    alignb    8
mc_writeexe.datastart:
    resb      8
    alignb    8
mc_writeexe.dataptr:
    resb      8
    alignb    8
mc_writeexe.userentrypoint:
    resb      8
    alignb    8
mc_writeexe.exportdirvirtaddr:
    resb      8
    alignb    8
mc_writeexe.exportdirvirtsize:
    resb      8
    alignb    8
mc_writeexe.exportdiroffset:
    resb      8
    alignb    8
mc_writeexe.blockdirvirtaddr:
    resb      8
    alignb    8
mc_writeexe.blockdirvirtsize:
    resb      8
    alignb    8
mc_writeexe.blockdiroffset:
    resb      8
    segment .data
mc_writeexe.writedosstub.stubdata:
    dq  0x300905A4D
    dq  0xFFFF00000004
    dq  0xB8
    dq  0x40
    dq  0
    dq  0
    dq  0
    dq  0x8000000000
    dq  0xCD09B4000EBA1F0E
    dq  0x685421CD4C01B821
    dq  0x72676F7270207369
    dq  0x6F6E6E6163206D61
    dq  0x6E75722065622074
    dq  0x20534F44206E6920
    dq  0xA0D0D2E65646F6D
    dq  0x24
;ENDDATA
    segment .bss
    alignb    8
mc_writeobj.symtaboffset:
    resb      8
    alignb    8
mc_writeobj.datastart:
    resb      8
    alignb    8
mc_writeobj.dataptr:
    resb      8
mc_writeobj.symboltable:
    resb      234018
    alignb    8
mc_writeobj.nsymbols:
    resb      8
    segment .data
    align     8
mc_writeobj.stoffset:
    dq  0
    segment .bss
    alignb    8
mc_writeobj.stringtable:
    resb      40000
    alignb    8
mc_writeobj.stringlengths:
    resb      40000
    segment .data
    align     8
mc_writeobj.nextstringoffset:
    dq  0
    align     8
mc_writeobj.nstrings:
    dq  0
    segment .bss
mc_writeobj.writerelocs.s:
    resb      10
mc_writeobj.makesymbol.r:
    resb      18
mc_writeobj.strtoaux.r:
    resb      18
mc_writeobj.sectiontoaux.r:
    resb      18
    segment .data
    align     8
mx_decls.mcxdirnames:
    dq  L11354
    dq  L11355
    dq  L11356
    dq  L11357
    dq  L11358
    dq  L11359
    dq  L11360
    dq  L11361
    dq  L11362
    dq  L11363
    dq  L11364
    dq  L11365
    dq  L11366
    dq  L11367
    align     8
mx_decls.mcxrelocnames:
    dq  L11368
    dq  L11369
    dq  L11370
    dq  L11371
    dq  L11372
    dq  L11373
    segment .bss
    alignb    8
mx_decls.dllnametable:
    resb      160
    alignb    8
mx_decls.dllinsttable:
    resb      160
    alignb    8
mx_decls.ndlllibs:
    resb      8
    alignb    8
mx_decls.libnametable:
    resb      160
    alignb    8
mx_decls.libtable:
    resb      160
mx_decls.librelocated:
    resb      20
mx_decls.libinitdone:
    resb      20
    alignb    8
mx_decls.nlibs:
    resb      8
    alignb    8
mx_decls.symbolnametable:
    resb      24000
mx_decls.symboldefined:
    resb      3000
    alignb    8
mx_decls.symboladdress:
    resb      24000
    alignb    2
mx_decls.symbollibindex:
    resb      6000
mx_decls.symboldllindex:
    resb      3000
    alignb    8
mx_decls.nsymbols:
    resb      8
    segment .data
    align     8
mx_decls.nsymimports:
    dq  0
    align     8
mx_decls.nsymexports:
    dq  0
    align     8
mx_lib.rsegmentnames:
    dq  L11374
    dq  L11375
    dq  L11376
    dq  L11377
    dq  L11378
    dq  L11379
    segment .bss
    alignb    8
mx_write.dest:
    resb      8
    alignb    8
mx_write.entrypoint:
    resb      8
    segment .data
    align     8
mm_cli.syslibname:
    dq  L11380
    align     8
mm_cli.passnames:
    dq  L11381
    dq  L11382
    dq  L11383
    dq  L11384
    dq  L11385
    dq  L11386
    dq  L11387
    dq  L11388
    dq  L11389
    dq  L11390
    dq  L11391
    align     8
mm_cli.dpassnames:
    dq  L11392
    dq  L11393
    dq  L11394
    dq  L11395
    dq  L11396
    dq  L11397
    dq  L11398
    dq  L11399
    align     8
mm_cli.optionnames:
    dq  L11400
    dq  L11401
    dq  L11402
    dq  L11403
    dq  L11404
    dq  L11405
    dq  L11406
    dq  L11407
    dq  L11408
    dq  L11409
    dq  L11410
    dq  L11411
    dq  L11412
    dq  L11413
    dq  L11414
    dq  L11415
    dq  L11416
    dq  L11417
    dq  L11418
    dq  L11419
    dq  L11420
    dq  L11421
    dq  L11422
    dq  L11423
    dq  L11424
    dq  L11425
    dq  L11426
    dq  L11427
    dq  L11428
    dq  L11429
    dq  L11430
    dq  L11431
    dq  L11432
    dq  L11433
    dq  L11434
    dq  L11435
    dq  L11436
    dq  L11437
    dq  L11438
    dq  L11439
    dq  L11440
    dq  L11441
    dq  L11442
    dq  L11443
    dq  L11444
    dq  L11445
    dq  L11446
    dq  L11447
    dq  L11448
    dq  L11449
    dq  L11450
    dq  L11451
    dq  L11452
    dq  L11453
    dq  L11454
mm_cli.optionvalues:
    dq  0x706060504030201
    dq  0x302010B0A090808
    dq  0x1020807060504
    dq  0
    dq  0
    dq  0x2010003020000
    db        0
    db        0
    db        0
    db        0
    db        0
    db        0
    db        2
;ENDDATA
    segment .bss
mm_cli.msfile:
    resb      1
    segment .data
    align     8
mm_cli.outext:
    dq  L11455
    segment .bss
    alignb    8
mm_cli.startclock:
    resb      8
    alignb    8
mm_cli.endclock:
    resb      8
    alignb    8
mm_cli.cmdskip:
    resb      8
    alignb    8
mm_cli.inputfile:
    resb      8
    alignb    8
mm_cli.loadtime:
    resb      8
    alignb    8
mm_cli.parsetime:
    resb      8
    alignb    8
mm_cli.resolvetime:
    resb      8
    alignb    8
mm_cli.typetime:
    resb      8
    alignb    8
mm_cli.ctime:
    resb      8
    alignb    8
mm_cli.pcltime:
    resb      8
    alignb    8
mm_cli.compiletime:
    resb      8
mm_cli.do_option.outused:
    resb      1
mm_cli.do_option.outpathused:
    resb      1
    alignb    8
mm_genpcl.retindex:
    resb      8
    alignb    8
mm_genpcl.initstaticsindex:
    resb      8
    alignb    8
mm_genpcl.pcldoswx:
    resb      8
    alignb    8
mm_genpcl.loopstack:
    resb      1600
    alignb    8
mm_genpcl.loopindex:
    resb      8
mm_genpcl.zero_unit:
    resb      65
    segment .data
    align     8
mm_genpcl.pzero:
    dq  mm_genpcl.zero_unit
    segment .bss
    alignb    8
mm_genpcl.nvarlocals:
    resb      8
    alignb    8
mm_genpcl.nvarparams:
    resb      8
    alignb    8
mm_blockpcl.nnn:
    resb      8
    alignb    8
mm_blockpcl.casestmt:
    resb      160
    alignb    8
mm_blockpcl.caseelse:
    resb      160
    alignb    8
mm_blockpcl.casedepth:
    resb      8
    alignb    8
mm_blockpcl.sw_labeltable:
    resb      8
    alignb    8
mm_blockpcl.sw_valuetable:
    resb      8
    alignb    8
mm_blockpcl.sw_lower:
    resb      8
    alignb    8
mm_blockpcl.sw_ncases:
    resb      8
mm_blockpcl.sw_defaultseen:
    resb      1
    alignb    8
mm_blockpcl.sw_defaultlabel:
    resb      8
    alignb    8
mm_blockpcl.sw_breaklabel:
    resb      8
    segment .data
    align     8
mm_blockpcl.maxreg:
    dq  0
    segment .bss
    alignb    8
mm_blockpcl.pnprocs:
    resb      8
    alignb    8
mm_blockpcl.pprocname:
    resb      8
    alignb    8
mm_blockpcl.pprocaddr:
    resb      8
    segment .data
    align     8
mm_assem.initassemsymbols.regnames:
    dq  L11456
    dq  L11457
    dq  L11458
    dq  L11459
    dq  L11460
    dq  L11461
mm_assem.initassemsymbols.regnos:
    db        15
    db        15
    db        16
    db        16
    db        9
    db        10
;ENDDATA
mm_assem.initassemsymbols.sizes:
    db        4
    db        8
    db        4
    db        8
    db        8
    db        8
;ENDDATA
    segment .bss
    alignb    8
mm_decls.modules:
    resb      2408
mm_decls.moduletosub:
    resb      301
    alignb    8
mm_decls.subprogs:
    resb      248
    alignb    8
mm_decls.sources:
    resb      2408
mm_decls.subproghasstart:
    resb      31
    alignb    8
mm_decls.nmodules:
    resb      8
    alignb    8
mm_decls.nsubprogs:
    resb      8
    alignb    8
mm_decls.nsourcefiles:
    resb      8
    alignb    8
mm_decls.nlibfiles:
    resb      8
    alignb    8
mm_decls.stprogram:
    resb      8
    alignb    8
mm_decls.stmodule:
    resb      8
    alignb    8
mm_decls.currmoduleno:
    resb      8
mm_decls.loadedfromma:
    resb      1
mm_decls.lx:
    resb      16
mm_decls.nextlx:
    resb      16
    alignb    8
mm_decls.libfiles:
    resb      408
    alignb    8
mm_decls.mainsubprogno:
    resb      8
    alignb    8
mm_decls.ntypes:
    resb      8
    alignb    8
mm_decls.ttnamedef:
    resb      128008
    alignb    8
mm_decls.ttowner:
    resb      128008
    alignb    4
mm_decls.ttbasetype:
    resb      64004
    alignb    8
mm_decls.ttname:
    resb      128008
    alignb    4
mm_decls.ttsize:
    resb      64004
mm_decls.ttsizeset:
    resb      16001
    alignb    4
mm_decls.ttlower:
    resb      64004
    alignb    4
mm_decls.ttlength:
    resb      64004
    alignb    8
mm_decls.ttmult:
    resb      128008
    alignb    8
mm_decls.ttdimexpr:
    resb      128008
    alignb    4
mm_decls.tttarget:
    resb      64004
mm_decls.ttusercat:
    resb      16001
    alignb    4
mm_decls.ttlineno:
    resb      64004
mm_decls.ttsigned:
    resb      16001
mm_decls.ttisreal:
    resb      16001
mm_decls.ttisinteger:
    resb      16001
mm_decls.ttisshort:
    resb      16001
mm_decls.ttisref:
    resb      16001
mm_decls.ttisblock:
    resb      16001
mm_decls.typenames:
    resb      1216032
mm_decls.typenamepos:
    resb      152004
    alignb    8
mm_decls.ntypenames:
    resb      8
mm_decls.typestarterset:
    resb      137
    alignb    8
mm_decls.currproc:
    resb      8
    segment .data
    align     8
mm_decls.assemmode:
    dq  0
    align     8
mm_decls.headermode:
    dq  0
    segment .bss
    alignb    8
mm_decls.proclist:
    resb      8
    alignb    8
mm_decls.proclistx:
    resb      8
    alignb    8
mm_decls.staticlist:
    resb      8
    alignb    8
mm_decls.staticlistx:
    resb      8
    alignb    8
mm_decls.constlist:
    resb      8
    alignb    8
mm_decls.constlistx:
    resb      8
    alignb    8
mm_decls.nullunit:
    resb      8
    alignb    8
mm_decls.ndllproctable:
    resb      8
    alignb    8
mm_decls.dllproctable:
    resb      8000
    segment .data
    align     8
mm_decls.fverbose:
    dq  1
mm_decls.msyslevel:
    db        2
mm_decls.mvarlib:
    db        0
mm_decls.fvarnames:
    db        0
    segment .bss
mm_decls.fshowtiming:
    resb      1
mm_decls.fshowss:
    resb      1
mm_decls.fshowc:
    resb      1
mm_decls.fshowpcl:
    resb      1
mm_decls.fshowasm:
    resb      1
mm_decls.fshowast1:
    resb      1
mm_decls.fshowast2:
    resb      1
mm_decls.fshowast3:
    resb      1
mm_decls.fshowst:
    resb      1
mm_decls.fshowpst:
    resb      1
mm_decls.fshowstflat:
    resb      1
mm_decls.fshowtypes:
    resb      1
mm_decls.fshowmodules:
    resb      1
    segment .data
mm_decls.fcheckunusedlocals:
    db        0
mm_decls.highmem:
    db        1
    segment .bss
mm_decls.clinux:
    resb      1
    segment .data
mm_decls.dointlibs:
    db        1
    align     8
mm_decls.passlevel:
    dq  0
    align     8
mm_decls.dpasslevel:
    dq  0
    align     8
mm_decls.prodmode:
    dq  0
    align     8
mm_decls.debugmode:
    dq  0
    align     8
mm_decls.libmode:
    dq  0
    segment .bss
    alignb    8
mm_decls.fshortnames:
    resb      8
    alignb    8
mm_decls.outfile:
    resb      8
    alignb    8
mm_decls.destfilename:
    resb      8
    alignb    8
mm_decls.destfilepath:
    resb      8
    alignb    8
mm_decls.nunits:
    resb      8
    alignb    8
mm_decls.nunitsmem:
    resb      8
    alignb    8
mm_diags.currlineno:
    resb      8
    alignb    8
mm_diags.currfileno:
    resb      8
mm_diags.sbuffer:
    resb      16
    segment .data
    align     8
mm_diags.dest:
    dq  mm_diags.sbuffer
    align     8
mm_diags.printunit.cmpchain:
    dq  0
    segment .bss
mm_diags.getprefix.str:
    resb      1024
mm_diags.getlineinfok.str:
    resb      40
    segment .data
    align     8
mm_diags.printmodelist.tab:
    dq  L11462
    align     8
mm_diags.showprojectinfo.tab:
    dq  L11463
    segment .bss
    alignb    8
mm_lex.lxstart_stack:
    resb      160
    alignb    8
mm_lex.lxsource_stack:
    resb      160
    alignb    8
mm_lex.lxsptr_stack:
    resb      160
    alignb    8
mm_lex.lxfileno_stack:
    resb      160
mm_lex.lxnextlx_stack:
    resb      320
mm_lex.lximport_stack:
    resb      20
    segment .data
    align     8
mm_lex.sourcelevel:
    dq  0
    segment .bss
    alignb    8
mm_lex.lximport:
    resb      8
    alignb    8
mm_lex.lxsource:
    resb      8
    alignb    8
mm_lex.lxstart:
    resb      8
    alignb    8
mm_lex.lxsptr:
    resb      8
    alignb    8
mm_lex.lxifcond:
    resb      8
    alignb    8
mm_lex.lxfileno:
    resb      8
    alignb    8
mm_lex.hashtable:
    resb      524288
mm_lex.namemap:
    resb      256
    segment .data
    align     8
mm_lex.u64maxstr:
    dq  L11464
    align     8
mm_lib.autotypeno:
    dq  0
    align     8
mm_lib.nextavindex:
    dq  0
    align     8
mm_lib.nextsvindex:
    dq  0
    segment .bss
mm_lib.exprstrvar:
    resb      16
    segment .data
    align     8
mm_lib.exprstr:
    dq  mm_lib.exprstrvar
    align     8
mm_lib.unitheapptr:
    dq  0
    align     8
mm_lib.remainingunits:
    dq  0
    segment .bss
mm_lib.sbuffer:
    resb      16
    segment .data
    align     8
mm_lib.dest:
    dq  mm_lib.sbuffer
    segment .bss
    alignb    8
mm_lib.jdest:
    resb      8
    alignb    8
mm_lib.framevarname:
    resb      8
mm_lib.nextautotype.str:
    resb      32
mm_lib.getdottedname.str:
    resb      256
mm_lib.strmode.str:
    resb      4096
mm_lib.strmode2.str:
    resb      4096
    segment .data
    align     8
mm_libsources.syslibnames:
    dq  L11465
    dq  L11466
    dq  L11467
    dq  L11468
    dq  L11469
    dq  L11470
    dq  L11471
    dq  L11472
    dq  L11473
    dq  L11474
    dq  L11475
    dq  L11476
    dq  L11477
    align     8
mm_libsources.syslibtext:
    dq  L11478
    dq  L11479
    dq  L11480
    dq  L11481
    dq  L11482
    dq  L11483
    dq  L11484
    dq  L11485
    dq  L11486
    dq  L11487
    dq  L11488
    dq  L11489
    dq  L11490
    align     8
mm_modules.fileext:
    dq  L11491
    segment .bss
mm_modules.getmodulefilename.str:
    resb      300
    alignb    8
mm_name.currstproc:
    resb      8
    segment .data
    align     8
mm_name.allowmodname:
    dq  0
    segment .bss
    alignb    8
mm_name.noexpand:
    resb      8
    alignb    8
mm_name.noassem:
    resb      8
    alignb    8
mm_name.macrolevels:
    resb      8
    alignb    8
mm_name.macroparams:
    resb      400
    alignb    8
mm_name.macroparamsgen:
    resb      400
    alignb    8
mm_name.macroargs:
    resb      400
    alignb    8
mm_name.nmacroparams:
    resb      8
    alignb    8
mm_name.nmacroargs:
    resb      8
    segment .data
    align     8
mm_parse.intabledata:
    dq  0
    align     8
mm_parse.inreadprint:
    dq  0
    align     8
mm_parse.inparamlist:
    dq  0
    align     8
mm_parse.inrecordbody:
    dq  0
    align     8
mm_parse.inimportmodule:
    dq  0
    align     8
mm_parse.labelseen:
    dq  0
    align     8
mm_parse.tabledataname:
    dq  0
    segment .bss
    alignb    8
mm_parse.procstack:
    resb      80
    segment .data
    align     8
mm_parse.nprocstack:
    dq  0
    segment .bss
mm_parse.unionstring:
    resb      8
mm_parse.unionpend:
    resb      8
    segment .data
    align     8
mm_parse.unionlastvar:
    dq  0
    segment .bss
    alignb    8
mm_parse.dretvar:
    resb      8
    segment .data
    align     8
mm_parse.varattribs:
    dq  0
    segment .bss
    alignb    8
mm_parse.dollarstack:
    resb      80
    segment .data
    align     8
mm_parse.ndollar:
    dq  0
    align     8
mm_parse.insiderecord:
    dq  0
    align     8
mm_parse.insidedllimport:
    dq  0
    segment .bss
    alignb    8
mm_parse.forindexvars:
    resb      80
    alignb    8
mm_parse.nforloops:
    resb      8
    segment .data
    align     8
mm_parse.readcompilervar.monthnames:
    dq  L11492
    dq  L11493
    dq  L11494
    dq  L11495
    dq  L11496
    dq  L11497
    dq  L11498
    dq  L11499
    dq  L11500
    dq  L11501
    dq  L11502
    dq  L11503
mm_support.bytemasks:
    dq  0x8040201008040201
;ENDDATA
    align     8
mm_tables.stdnames:
    dq  L11504
    dq  L11505
    dq  L11506
    dq  L11507
    dq  L11508
    dq  L11509
    dq  L11510
    dq  L11511
    dq  L11512
    dq  L11513
    dq  L11514
    dq  L11515
    dq  L11516
    dq  L11517
    dq  L11518
    dq  L11519
    dq  L11520
    dq  L11521
    dq  L11522
    dq  L11523
    dq  L11524
    dq  L11525
    dq  L11526
    dq  L11527
    dq  L11528
    dq  L11529
    dq  L11530
    dq  L11531
    dq  L11532
    dq  L11533
    dq  L11534
    dq  L11535
mm_tables.stdsize:
    dq  0x808080808040800
    dq  0x201010110001000
    dq  0x100804020104
    dq  0x8000008080000
;ENDDATA
mm_tables.stdpcl:
    dq  0x60406060A010200
    dq  0x80703030B0B0B0B
    dq  0x606060605040309
    dq  0xB060606060606
;ENDDATA
    segment .bss
    alignb    8
mm_tables.trefproc:
    resb      8
    alignb    8
mm_tables.treflabel:
    resb      8
    segment .data
    align     8
mm_tables.sysfnnames:
    dq  L11536
    dq  L11537
    dq  L11538
    dq  L11539
    dq  L11540
    dq  L11541
    dq  L11542
    dq  L11543
    dq  L11544
    dq  L11545
    dq  L11546
    dq  L11547
    dq  L11548
    dq  L11549
    dq  L11550
    dq  L11551
    dq  L11552
    dq  L11553
    dq  L11554
    dq  L11555
    dq  L11556
    dq  L11557
    dq  L11558
    dq  L11559
    dq  L11560
    dq  L11561
    dq  L11562
    dq  L11563
    dq  L11564
    dq  L11565
    dq  L11566
    dq  L11567
    dq  L11568
mm_tables.sysfnparams:
    dq  0
    dq  0
    dq  0
    dq  0
    db        0
;ENDDATA
mm_tables.sysfnres:
    dq  0
    dq  0
    dq  0
    dq  0x101010100000000
    db        1
;ENDDATA
    segment .bss
    alignb    8
mm_tables.sysfnhandlers:
    resb      264
    segment .data
    align     8
mm_tables.jtagnames:
    dq  L11569
    dq  L11570
    dq  L11571
    dq  L11572
    dq  L11573
    dq  L11574
    dq  L11575
    dq  L11576
    dq  L11577
    dq  L11578
    dq  L11579
    dq  L11580
    dq  L11581
    dq  L11582
    dq  L11583
    dq  L11584
    dq  L11585
    dq  L11586
    dq  L11587
    dq  L11588
    dq  L11589
    dq  L11590
    dq  L11591
    dq  L11592
    dq  L11593
    dq  L11594
    dq  L11595
    dq  L11596
    dq  L11597
    dq  L11598
    dq  L11599
    dq  L11600
    dq  L11601
    dq  L11602
    dq  L11603
    dq  L11604
    dq  L11605
    dq  L11606
    dq  L11607
    dq  L11608
    dq  L11609
    dq  L11610
    dq  L11611
    dq  L11612
    dq  L11613
    dq  L11614
    dq  L11615
    dq  L11616
    dq  L11617
    dq  L11618
    dq  L11619
    dq  L11620
    dq  L11621
    dq  L11622
    dq  L11623
    dq  L11624
    dq  L11625
    dq  L11626
    dq  L11627
    dq  L11628
    dq  L11629
    dq  L11630
    dq  L11631
    dq  L11632
    dq  L11633
    dq  L11634
    dq  L11635
    dq  L11636
    dq  L11637
    dq  L11638
    dq  L11639
    dq  L11640
    dq  L11641
    dq  L11642
    dq  L11643
    dq  L11644
    dq  L11645
    dq  L11646
    dq  L11647
    dq  L11648
    dq  L11649
    dq  L11650
    dq  L11651
    dq  L11652
    dq  L11653
    dq  L11654
    dq  L11655
    dq  L11656
    dq  L11657
    dq  L11658
    dq  L11659
    dq  L11660
    dq  L11661
    dq  L11662
    dq  L11663
    dq  L11664
    dq  L11665
    dq  L11666
    dq  L11667
    dq  L11668
    dq  L11669
    dq  L11670
    dq  L11671
    dq  L11672
    dq  L11673
    dq  L11674
    dq  L11675
    dq  L11676
    dq  L11677
    dq  L11678
    dq  L11679
    dq  L11680
    dq  L11681
    dq  L11682
    dq  L11683
    dq  L11684
    dq  L11685
    dq  L11686
    dq  L11687
    dq  L11688
    dq  L11689
    dq  L11690
    dq  L11691
mm_tables.jsubs:
    dq  0x1000000000000
    dq  0x201010100000003
    dq  0x101020201010102
    dq  0x202020202010002
    dq  0x102020202020202
    dq  0x202000202020201
    dq  0x101010202020202
    dq  0x10101010101
    dq  0x1010100010101
    dq  0
    dq  0x2020000000000
    dq  0x303030303010100
    dq  0x1020303
    dq  0x203030303030301
    dq  0x202030302020103
    db        1
    db        1
    db        1
;ENDDATA
mm_tables.jisexpr:
    dq  0x300030303030300
    dq  0x203030000000000
    dq  0x303030301010102
    dq  0x303030303030303
    dq  0x102010102010203
    dq  0x303030202020203
    dq  0x303030303030303
    dq  0x303030303030303
    dq  0x303030301010103
    dq  0x303030303030303
    dq  0x303000303030303
    dq  0x300030003
    dq  0
    dq  0x3000300
    dq  3
    db        0
    db        3
    db        1
;ENDDATA
mm_tables.jsolo:
    dq  0x1000000000000
    dq  1
    dq  0
    dq  0x101010100000000
    dq  1
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0x100010000
    dq  0x101010001010100
    dq  0x101010101010101
    dq  0x101010101010001
    db        0
    db        1
    db        1
;ENDDATA
    align     8
mm_tables.bitfieldnames:
    dq  L11692
    dq  L11693
    dq  L11694
    dq  L11695
    dq  L11696
    dq  L11697
    dq  L11698
    dq  L11699
    align     8
mm_tables.optypenames:
    dq  L11700
    dq  L11701
    dq  L11702
    dq  L11703
    align     8
mm_tables.symbolnames:
    dq  L11704
    dq  L11705
    dq  L11706
    dq  L11707
    dq  L11708
    dq  L11709
    dq  L11710
    dq  L11711
    dq  L11712
    dq  L11713
    dq  L11714
    dq  L11715
    dq  L11716
    dq  L11717
    dq  L11718
    dq  L11719
    dq  L11720
    dq  L11721
    dq  L11722
    dq  L11723
    dq  L11724
    dq  L11725
    dq  L11726
    dq  L11727
    dq  L11728
    dq  L11729
    dq  L11730
    dq  L11731
    dq  L11732
    dq  L11733
    dq  L11734
    dq  L11735
    dq  L11736
    dq  L11737
    dq  L11738
    dq  L11739
    dq  L11740
    dq  L11741
    dq  L11742
    dq  L11743
    dq  L11744
    dq  L11745
    dq  L11746
    dq  L11747
    dq  L11748
    dq  L11749
    dq  L11750
    dq  L11751
    dq  L11752
    dq  L11753
    dq  L11754
    dq  L11755
    dq  L11756
    dq  L11757
    dq  L11758
    dq  L11759
    dq  L11760
    dq  L11761
    dq  L11762
    dq  L11763
    dq  L11764
    dq  L11765
    dq  L11766
    dq  L11767
    dq  L11768
    dq  L11769
    dq  L11770
    dq  L11771
    dq  L11772
    dq  L11773
    dq  L11774
    dq  L11775
    dq  L11776
    dq  L11777
    dq  L11778
    dq  L11779
    dq  L11780
    dq  L11781
    dq  L11782
    dq  L11783
    dq  L11784
    dq  L11785
    dq  L11786
    dq  L11787
    dq  L11788
    dq  L11789
    dq  L11790
    dq  L11791
    dq  L11792
    dq  L11793
    dq  L11794
    dq  L11795
    dq  L11796
    dq  L11797
    dq  L11798
    dq  L11799
    dq  L11800
    dq  L11801
    dq  L11802
    dq  L11803
    dq  L11804
    dq  L11805
    dq  L11806
    dq  L11807
    dq  L11808
    dq  L11809
    dq  L11810
    dq  L11811
    dq  L11812
    dq  L11813
    dq  L11814
    dq  L11815
    dq  L11816
    dq  L11817
    dq  L11818
    dq  L11819
    dq  L11820
    dq  L11821
    dq  L11822
    dq  L11823
    dq  L11824
    dq  L11825
    dq  L11826
    dq  L11827
    dq  L11828
    dq  L11829
    dq  L11830
    dq  L11831
    dq  L11832
    dq  L11833
    dq  L11834
    dq  L11835
    dq  L11836
    dq  L11837
    dq  L11838
    dq  L11839
mm_tables.symboloptypes:
    dq  0x10000000000
    dq  0
    dq  0x100000100000000
    dq  0x101010101010101
    dq  0x101010101010101
    dq  0x202000101010101
    dq  0x30202020202
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
;ENDDATA
mm_tables.symbolgenops:
    dq  0
    dq  0
    dq  0x2B00000000000000
    dq  0x333231302F2E2D2C
    dq  0x3837363534
    dq  0x3F000000520000
    dq  0x4243503D3E
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
;ENDDATA
mm_tables.symbolgentoops:
    dq  0
    dq  0
    dq  0x5A00000000000000
    dq  0x6160005F5E5D5C5B
    dq  0x6665646362
    dq  0x6C000000000000
    dq  0x6A6B
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
;ENDDATA
mm_tables.symbolopprios:
    dq  0x10000000000
    dq  0
    dq  0x400000500000000
    dq  0x404030303030304
    dq  0x808070404030304
    dq  0x606020606
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
    dq  0
;ENDDATA
mm_tables.exprstarter:
    dq  0x100
    dq  0x1000000010001
    dq  0x100000000010000
    dq  1
    dq  0x101000000
    dq  0x101000000000101
    dq  0x101000101010101
    dq  0x101010100000000
    dq  0x100010001
    dq  0x101000000000000
    dq  1
    dq  1
    dq  0
    dq  0
    dq  0x10100000000
    dq  0x100000000000000
    dq  0x100000100000101
;ENDDATA
    align     8
mm_tables.headerdirnames:
    dq  L11840
    dq  L11841
    dq  L11842
    dq  L11843
    align     8
mm_tables.scopenames:
    dq  L11844
    dq  L11845
    dq  L11846
    dq  L11847
    align     8
mm_tables.parammodenames:
    dq  L11848
    dq  L11849
    align     8
mm_tables.namenames:
    dq  L11850
    dq  L11851
    dq  L11852
    dq  L11853
    dq  L11854
    dq  L11855
    dq  L11856
    dq  L11857
    dq  L11858
    dq  L11859
    dq  L11860
    dq  L11861
    dq  L11862
    dq  L11863
    dq  L11864
    dq  L11865
    dq  L11866
    dq  L11867
mm_tables.name2pid:
    dq  0x102000009000000
    dq  0x6000504030000
    db        0
    db        0
;ENDDATA
    align     8
mm_tables.propnames:
    dq  L11868
    dq  L11869
    dq  L11870
    dq  L11871
    dq  L11872
    dq  L11873
    dq  L11874
    dq  L11875
    dq  L11876
    dq  L11877
    align     8
mm_tables.stnames:
    dq  L11878
    dq  L11879
    dq  L11880
    dq  L11881
    dq  L11882
    dq  L11883
    dq  L11884
    dq  L11885
    dq  L11886
    dq  L11887
    dq  L11888
    dq  L11889
    dq  L11890
    dq  L11891
    dq  L11892
    dq  L11893
    dq  L11894
    dq  L11895
    dq  L11896
    dq  L11897
    dq  L11898
    dq  L11899
    dq  L11900
    dq  L11901
    dq  L11902
    dq  L11903
    dq  L11904
    dq  L11905
    dq  L11906
    dq  L11907
    dq  L11908
    dq  L11909
    dq  L11910
    dq  L11911
    dq  L11912
    dq  L11913
    dq  L11914
    dq  L11915
    dq  L11916
    dq  L11917
    dq  L11918
    dq  L11919
    dq  L11920
    dq  L11921
    dq  L11922
    dq  L11923
    dq  L11924
    dq  L11925
    dq  L11926
    dq  L11927
    dq  L11928
    dq  L11929
    dq  L11930
    dq  L11931
    dq  L11932
    dq  L11933
    dq  L11934
    dq  L11935
    dq  L11936
    dq  L11937
    dq  L11938
    dq  L11939
    dq  L11940
    dq  L11941
    dq  L11942
    dq  L11943
    dq  L11944
    dq  L11945
    dq  L11946
    dq  L11947
    dq  L11948
    dq  L11949
    dq  L11950
    dq  L11951
    dq  L11952
    dq  L11953
    dq  L11954
    dq  L11955
    dq  L11956
    dq  L11957
    dq  L11958
    dq  L11959
    dq  L11960
    dq  L11961
    dq  L11962
    dq  L11963
    dq  L11964
    dq  L11965
    dq  L11966
    dq  L11967
    dq  L11968
    dq  L11969
    dq  L11970
    dq  L11971
    dq  L11972
    dq  L11973
    dq  L11974
    dq  L11975
    dq  L11976
    dq  L11977
    dq  L11978
    dq  L11979
    dq  L11980
    dq  L11981
    dq  L11982
    dq  L11983
    dq  L11984
    dq  L11985
    dq  L11986
    dq  L11987
    dq  L11988
    dq  L11989
    dq  L11990
    dq  L11991
    dq  L11992
    dq  L11993
    dq  L11994
    dq  L11995
    dq  L11996
    dq  L11997
    dq  L11998
    dq  L11999
    dq  L12000
    dq  L12001
    dq  L12002
    dq  L12003
    dq  L12004
    dq  L12005
    dq  L12006
    dq  L12007
    dq  L12008
    dq  L12009
    dq  L12010
    dq  L12011
    dq  L12012
    dq  L12013
    dq  L12014
    dq  L12015
    dq  L12016
    dq  L12017
    dq  L12018
    dq  L12019
    dq  L12020
    dq  L12021
    dq  L12022
    dq  L12023
    dq  L12024
    dq  L12025
    dq  L12026
    dq  L12027
    dq  L12028
    dq  L12029
    dq  L12030
    dq  L12031
    dq  L12032
    dq  L12033
    dq  L12034
    dq  L12035
    dq  L12036
    dq  L12037
    dq  L12038
    dq  L12039
    dq  L12040
    dq  L12041
    dq  L12042
    dq  L12043
    dq  L12044
    dq  L12045
    dq  L12046
    dq  L12047
    dq  L12048
    dq  L12049
    dq  L12050
    dq  L12051
mm_tables.stsymbols:
    dq  0x5956555454535251
    dq  0x605F5E5E5D5C5B5A
    dq  0x6666656463626157
    dq  0x8484696969686766
    dq  0x6A6A6A6A6A6A8385
    dq  0x6C6D6C6D6D806B6B
    dq  0x4478777571706F74
    dq  0x7B7F87877A454545
    dq  0x7E7E587372888888
    dq  0x4F50504F4F4F7686
    dq  0x4F4F4F4F4F4F4F4F
    dq  0x4F4F4F4F4F4F4F4F
    dq  0x818181814242794F
    dq  0x8181818181818181
    dq  0x201F282726828181
    dq  0x25241E1D2E2D2C21
    dq  0x373334353230312F
    dq  0x3737373737373737
    dq  0x3636363838373737
    dq  0x3939393636363636
    dq  0x5757573939393939
    db        17
    db        "|}}}}"
;ENDDATA
    align     2
mm_tables.stsubcodes:
    dw        92
    dw        0
    dw        92
    dw        0
    dw        1
    dw        105
    dw        107
    dw        105
    dw        106
    dw        113
    dw        0
    dw        0
    dw        0
    dw        1
    dw        0
    dw        0
    dw        0
    dw        0
    dw        0
    dw        0
    dw        0
    dw        0
    dw        101
    dw        102
    dw        103
    dw        0
    dw        107
    dw        108
    dw        109
    dw        110
    dw        0
    dw        1
    dw        0
    dw        0
    dw        114
    dw        115
    dw        116
    dw        117
    dw        114
    dw        115
    dw        118
    dw        119
    dw        58
    dw        0
    dw        0
    dw        0
    dw        1
    dw        2
    dw        0
    dw        0
    dw        0
    dw        0
    dw        0
    dw        0
    dw        0
    dw        0
    dw        66
    dw        83
    dw        83
    dw        0
    dw        1
    dw        0
    dw        0
    dw        0
    dw        29
    dw        30
    dw        31
    dw        0
    dw        0
    dw        0
    dw        1
    dw        3
    dw        0
    dw        0
    dw        3
    dw        4
    dw        1
    dw        12
    dw        0
    dw        14
    dw        15
    dw        16
    dw        3
    dw        2
    dw        1
    dw        17
    dw        17
    dw        18
    dw        19
    dw        4
    dw        12
    dw        12
    dw        5
    dw        6
    dw        6
    dw        13
    dw        25
    dw        11
    dw        1
    dw        2
    dw        71
    dw        72
    dw        74
    dw        73
    dw        75
    dw        76
    dw        77
    dw        78
    dw        79
    dw        80
    dw        81
    dw        83
    dw        84
    dw        82
    dw        0
    dw        0
    dw        0
    dw        0
    dw        0
    dw        0
    dw        0
    dw        0
    dw        1
    dw        0
    dw        0
    dw        0
    dw        0
    dw        0
    dw        0
    dw        0
    dw        0
    dw        61
    dw        0
    dw        0
    dw        0
    dw        68
    dw        69
    dw        70
    dw        71
    dw        72
    dw        73
    dw        74
    dw        75
    dw        76
    dw        77
    dw        78
    dw        79
    dw        81
    dw        83
    dw        1
    dw        2
    dw        3
    dw        4
    dw        5
    dw        6
    dw        7
    dw        8
    dw        1
    dw        2
    dw        3
    dw        4
    dw        5
    dw        6
    dw        7
    dw        8
    dw        81
    dw        89
    dw        96
    dw        1
    dw        0
    dw        1
    dw        2
    dw        3
    dw        4
    align     8
mm_tables.convnames:
    dq  L12052
    dq  L12053
    dq  L12054
    dq  L12055
    dq  L12056
    dq  L12057
    dq  L12058
    dq  L12059
    dq  L12060
    dq  L12061
    dq  L12062
    dq  L12063
    dq  L12064
    dq  L12065
mm_tables.convtopcl:
    dq  0x74737271706F00
    db        "@"
    db        0
    db        0
    db        0
    db        0
    db        0
;ENDDATA
    align     8
mm_tables.d_typestarterset:
    dq  0x4F
    dq  0xB
    dq  0x75
    dq  0x6F
    dq  0x50
    dq  0x79
    align     2
mm_tables.softconvtable:
    dw        7
    dw        6
    dw        2
    dw        2
    dw        2
    dw        5
    dw        7
    dw        2
    dw        2
    dw        2
    dw        1
    dw        1
    dw        7
    dw        7
    dw        7
    dw        1
    dw        1
    dw        7
    dw        7
    dw        7
    dw        1
    dw        1
    dw        7
    dw        7
    dw        7
    segment .bss
mm_tables.endsexpr:
    resb      136
    segment .data
mm_tables.exprendsymbols:
    dq  0x5760635453520C0A
    db        3
    db        16
    db        4
    db        "^"
;ENDDATA
    segment .bss
mm_tables.isbooltag:
    resb      123
    alignb    8
mm_type.countedfields:
    resb      8
    alignb    8
mm_type.inassem:
    resb      8
    alignb    8
mm_type.inidata:
    resb      8
    alignb    8
mm_type.tpass.depth:
    resb      8
    alignb    8
mm_type.setrecordsize.depth:
    resb      8
    alignb    8
mm_type.tx_assign.nn:
    resb      8
    segment .text
;Proc msys.start
msys.start:
;?>>
    %define msys.start.nargs -8
   %define R.nargs64 rdi
    %define msys.start.args -16
   %define R.res rbx
   %define R.j rsi
   %define R.i r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    sub       rsp,	8
    lea       rax,	[msys.start.startupinfo]
    push      rax
    lea       rcx,	[rbp + msys.start.nargs]
    lea       rdx,	[rbp + msys.start.args]
    lea       r8,	[msys.envstrings]
    xor       r9d,	r9d
    sub       rsp,	32
    call      __getmainargs
    add       rsp,	48
    movsxd    r10,	eax
    mov       rbx,	r10
    movsxd    rax,	dword [rbp + msys.start.nargs]
    mov       [msys.nsysparams],	rax
    mov       rax,	[msys.nsysparams]
    cmp       rax,	128
    jle       L3
    lea       rcx,	[L12066]
    call      printf
    mov       rcx,	50
    call      exit
L3:
    movsxd    rax,	dword [rbp + msys.start.nargs]
    mov       rdi,	rax
    mov       r12,	1
    cmp       rdi,	1
    jl        L6
L4:
    mov       rax,	[rbp + msys.start.args]
    mov       r10,	r12
    mov       rax,	[rax + r10*8-8]
    lea       r10,	[msys.sysparams]
    mov       r11,	r12
    mov       [r10 + r11*8-8],	rax
    inc       r12
    cmp       r12,	rdi
    jle       L4
L6:
    mov       rax,	[msys.$cmdskip]
    inc       rax
    mov       r10,	[msys.nsysparams]
    sub       r10,	rax
    mov       [msys.ncmdparams],	r10
    lea       rax,	[msys.sysparams]
    mov       r10,	[msys.$cmdskip]
    lea       rax,	[rax + r10*8]
    mov       [msys.cmdparams],	rax
    mov       rsi,	1
    xor       eax,	eax
    mov       [msys.nenvstrings],	rax
    jmp       L8
L7:
    inc       qword [msys.nenvstrings]
    inc       rsi
L8:
    mov       rax,	[msys.envstrings]
    mov       r10,	rsi
    mov       rax,	[rax + r10*8-8]
    test      rax,	rax
    jnz       L7
;---------------
    add       rsp,	48
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.pushio
msys.pushio:
;?>>
;?]]
    sub       rsp,	40
;---------------
    mov       rax,	[msys.niostack]
    cmp       rax,	10
    jl        L12
    lea       rcx,	[L12067]
    call      printf
    mov       rcx,	53
    call      exit
L12:
    inc       qword [msys.niostack]
    mov       rax,	[msys.outchan]
    lea       r10,	[msys.outchan_stack]
    mov       r11,	[msys.niostack]
    mov       [r10 + r11*8-8],	rax
    mov       rax,	[msys.outdev]
    lea       r10,	[msys.outdev_stack]
    mov       r11,	[msys.niostack]
    mov       [r10 + r11*8-8],	rax
    mov       rax,	[msys.fmtstr]
    lea       r10,	[msys.fmtstr_stack]
    mov       r11,	[msys.niostack]
    mov       [r10 + r11*8-8],	rax
    mov       al,	[msys.needgap]
    lea       r10,	[msys.needgap_stack]
    mov       r11,	[msys.niostack]
    mov       [r10 + r11-1],	al
    xor       eax,	eax
    mov       [msys.needgap],	rax
    xor       eax,	eax
    mov       [msys.fmtstr],	rax
    xor       eax,	eax
    mov       [msys.outchan],	rax
;---------------
    add       rsp,	40
    ret       
;End 
;Proc msys.m$print_startfile
msys.m$print_startfile:
;?>>
   %define R.dev rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    call      msys.pushio
    mov       [msys.outchan],	rdi
    test      rdi,	rdi
    jz        L15
    mov       rax,	2
    mov       [msys.outdev],	rax
    jmp       L14
L15:
    mov       rax,	1
    mov       [msys.outdev],	rax
L14:
    call      msys.resetprintbuffer
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc msys.m$print_startstr
msys.m$print_startstr:
;?>>
   %define R.s rbx
   %define R.p rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    call      msys.pushio
    mov       rax,	rbx
    lea       r10,	[msys.ptr_stack]
    mov       r11,	[msys.niostack]
    mov       [r10 + r11*8-8],	rax
    lea       rax,	[msys.ptr_stack]
    mov       r10,	[msys.niostack]
    lea       rax,	[rax + r10*8-8]
    mov       rdi,	rax
    mov       [msys.outchan],	rdi
    mov       rax,	3
    mov       [msys.outdev],	rax
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.m$print_startptr
msys.m$print_startptr:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    call      msys.pushio
    mov       [msys.outchan],	rdi
    mov       rax,	3
    mov       [msys.outdev],	rax
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc msys.m$print_startcon
msys.m$print_startcon:
;?>>
;?]]
    sub       rsp,	40
;---------------
    call      msys.pushio
    mov       rax,	1
    mov       [msys.outdev],	rax
    call      msys.resetprintbuffer
;---------------
    add       rsp,	40
    ret       
;End 
;Proc msys.m$print_setfmt
msys.m$print_setfmt:
;?>>
   %define R.format rcx
;?]]
;---------------
    mov       [msys.fmtstr],	rcx
;---------------
    ret       
;End 
;Proc msys.m$print_end
msys.m$print_end:
;?>>
;?]]
    sub       rsp,	40
;---------------
    xor       eax,	eax
    mov       [msys.needgap],	rax
    mov       rcx,	1
    call      msys.nextfmtchars
    mov       rax,	[msys.niostack]
    cmp       rax,	1
    jnz       L22
    mov       rax,	[msys.outdev]
    cmp       rax,	1
    jz        L23
    cmp       rax,	2
    jnz       L22
L23:
    call      msys.dumpprintbuffer
L22:
    mov       rax,	[msys.niostack]
    test      rax,	rax
    jz        L20
L25:
    lea       rax,	[msys.outchan_stack]
    mov       r10,	[msys.niostack]
    mov       rax,	[rax + r10*8-8]
    mov       [msys.outchan],	rax
    lea       rax,	[msys.outdev_stack]
    mov       r10,	[msys.niostack]
    mov       rax,	[rax + r10*8-8]
    mov       [msys.outdev],	rax
    lea       rax,	[msys.fmtstr_stack]
    mov       r10,	[msys.niostack]
    mov       rax,	[rax + r10*8-8]
    mov       [msys.fmtstr],	rax
    lea       rax,	[msys.needgap_stack]
    mov       r10,	[msys.niostack]
    movzx     rax,	byte [rax + r10-1]
    mov       [msys.needgap],	rax
    dec       qword [msys.niostack]
L20:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc msys.m$print_ptr
msys.m$print_ptr:
;?>>
   %define R.a rdi
   %define R.fmtstyle rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    test      rbx,	rbx
    jnz       L28
    lea       rax,	[L12068]
    mov       rbx,	rax
L28:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      msys.m$print_u64
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.m$print_ptr_nf
msys.m$print_ptr_nf:
;?>>
   %define R.a rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    xor       edx,	edx
    call      msys.m$print_ptr
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc msys.m$print_i64
msys.m$print_i64:
;?>>
   %define R.a rbx
   %define R.fmtstyle rsi
    %define msys.m$print_i64.s -40
    %define msys.m$print_i64.fmt -56
   %define R.n rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	88
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    xor       ecx,	ecx
    call      msys.nextfmtchars
    test      rsi,	rsi
    jnz       L32
    cmp       rbx,	0
    jl        L34
    mov       rcx,	rbx
    lea       rdx,	[rbp + msys.m$print_i64.s]
    mov       r8,	10
    xor       r9d,	r9d
    call      msys.u64tostr
    mov       rdi,	rax
    jmp       L33
L34:
    mov       rax,	rbx
    mov       r10,	-9223372036854775808
    cmp       rax,	r10
    jnz       L35
    lea       rax,	[msys.defaultfmt]
    lea       r10,	[rbp + msys.m$print_i64.fmt]
    movdqu    XMM4,	[rax]
    movdqu    [r10],	XMM4
    jmp       L36
L35:
    mov       al,	45
    mov       [rbp + msys.m$print_i64.s],	al
    lea       rax,	[rbp + msys.m$print_i64.s+1]
    mov       r10,	rbx
    neg       r10
    mov       rcx,	r10
    mov       rdx,	rax
    mov       r8,	10
    xor       r9d,	r9d
    call      msys.u64tostr
    inc       rax
    mov       rdi,	rax
L33:
    lea       rcx,	[rbp + msys.m$print_i64.s]
    mov       rdx,	rdi
    call      msys.printstr_n
    jmp       L31
L32:
    mov       rcx,	rsi
    mov       rdx,	-1
    lea       r8,	[rbp + msys.m$print_i64.fmt]
    call      msys.strtofmt
    movzx     rax,	byte [rbp + msys.m$print_i64.fmt+14]
    cmp       rax,	86
    jnz       L38
    mov       [msys.fmtparam],	rbx
    xor       eax,	eax
    mov       [msys.needgap],	rax
    jmp       L37
L38:
;msys.m$print_i64.dofmt:
L36:
    mov       rcx,	rbx
    lea       rdx,	[rbp + msys.m$print_i64.fmt]
    call      msys.tostr_i64
L37:
L31:
    mov       rax,	1
    mov       [msys.needgap],	rax
;---------------
    add       rsp,	88
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.m$print_i64_nf
msys.m$print_i64_nf:
;?>>
   %define R.a rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    xor       edx,	edx
    call      msys.m$print_i64
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc msys.m$print_bool
msys.m$print_bool:
;?>>
   %define R.a rdi
   %define R.fmtstyle rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    test      rdi,	rdi
    jz        L42
    lea       rcx,	[L12069]
    mov       rdx,	rbx
    call      msys.m$print_str
    jmp       L41
L42:
    lea       rcx,	[L12070]
    mov       rdx,	rbx
    call      msys.m$print_str
L41:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.m$print_u64
msys.m$print_u64:
;?>>
   %define R.a rdi
   %define R.fmtstyle rbx
    %define msys.m$print_u64.s -40
    %define msys.m$print_u64.fmt -56
    push      rdi
    push      rbx
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	96
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    xor       ecx,	ecx
    call      msys.nextfmtchars
    test      rbx,	rbx
    jnz       L45
    lea       rcx,	[rbp + msys.m$print_u64.s]
    lea       rdx,	[L12071]
    mov       r8,	rdi
    call      sprintf
    lea       rcx,	[rbp + msys.m$print_u64.s]
    call      msys.printstr
    jmp       L44
L45:
    mov       rcx,	rbx
    mov       rdx,	-1
    lea       r8,	[rbp + msys.m$print_u64.fmt]
    call      msys.strtofmt
    mov       rcx,	rdi
    lea       rdx,	[rbp + msys.m$print_u64.fmt]
    call      msys.tostr_u64
L44:
    mov       rax,	1
    mov       [msys.needgap],	rax
;---------------
    add       rsp,	96
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.m$print_r64
msys.m$print_r64:
;?>>
   %define R.x XMM15
   %define R.fmtstyle rdi
    %define msys.m$print_r64.s -360
    %define msys.m$print_r64.fmt -376
    push      rdi
    movq      rax,	XMM15
    push      rax
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	416
    movq      XMM15,	XMM0
    mov       rdi,	rdx
;---------------
    xor       ecx,	ecx
    call      msys.nextfmtchars
    test      rdi,	rdi
    jnz       L48
    lea       rcx,	[rbp + msys.m$print_r64.s]
    lea       rdx,	[L12072]
    movq      XMM2,	XMM15
    movq      r8,	XMM2
    call      sprintf
    lea       rcx,	[rbp + msys.m$print_r64.s]
    call      msys.printstr
    jmp       L47
L48:
    mov       rcx,	rdi
    mov       rdx,	-1
    lea       r8,	[rbp + msys.m$print_r64.fmt]
    call      msys.strtofmt
    movq      XMM0,	XMM15
    lea       rdx,	[rbp + msys.m$print_r64.fmt]
    call      msys.tostr_r64
L47:
    mov       rax,	1
    mov       [msys.needgap],	rax
;---------------
    add       rsp,	416
    pop       rbp
    pop       rcx
    movq      XMM15,	rcx
    pop       rdi
    ret       
;End 
;Proc msys.m$print_r32
msys.m$print_r32:
;?>>
   %define R.x XMM15
   %define R.fmtstyle rdi
    push      rdi
    movq      rax,	XMM15
    push      rax
;?]]
    sub       rsp,	40
    movq      XMM15,	XMM0
    mov       rdi,	rdx
;---------------
    movq      XMM4,	XMM15
    cvtss2sd  XMM4,	XMM4
    movq      XMM0,	XMM4
    mov       rdx,	rdi
    call      msys.m$print_r64
;---------------
    add       rsp,	40
    pop       rcx
    movq      XMM15,	rcx
    pop       rdi
    ret       
;End 
;Proc msys.m$print_c8
msys.m$print_c8:
;?>>
    %define msys.m$print_c8.a 40
   %define R.fmtstyle rsi
    %define msys.m$print_c8.s -32
    %define msys.m$print_c8.fmt -48
   %define R.n rdi
   %define R.charmode bl
    push      rdi
    push      rbx
    push      rsi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	88
    mov       [rbp+40],	rcx
    mov       rsi,	rdx
;---------------
    xor       bl,	bl
    xor       ecx,	ecx
    call      msys.nextfmtchars
    test      rsi,	rsi
    jz        L52
    mov       rcx,	rsi
    mov       rdx,	-1
    lea       r8,	[rbp + msys.m$print_c8.fmt]
    call      msys.strtofmt
    mov       bl,	[rbp + msys.m$print_c8.fmt+12]
L52:
    movzx     rax,	bl
    cmp       rax,	77
    jnz       L54
    lea       rcx,	[rbp + msys.m$print_c8.a]
    mov       rdx,	8
    lea       r8,	[rbp + msys.m$print_c8.s]
    lea       r9,	[rbp + msys.m$print_c8.fmt]
    call      msys.domultichar
    mov       rdi,	rax
    jmp       L53
L54:
    mov       rax,	[rbp + msys.m$print_c8.a]
    mov       [rbp + msys.m$print_c8.s],	rax
    xor       eax,	eax
    mov       [rbp + msys.m$print_c8.s+8],	al
    lea       rcx,	[rbp + msys.m$print_c8.s]
    call      msys.getutfsize
    mov       rdi,	rax
L53:
    lea       rcx,	[rbp + msys.m$print_c8.s]
    mov       rdx,	rdi
    call      msys.printstr_n
    mov       rax,	1
    mov       [msys.needgap],	rax
;---------------
    add       rsp,	88
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.m$print_str
msys.m$print_str:
;?>>
   %define R.s rdi
   %define R.fmtstyle rbx
    %define msys.m$print_str.fmt -16
    push      rdi
    push      rbx
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    xor       ecx,	ecx
    call      msys.nextfmtchars
    test      rdi,	rdi
    jnz       L57
    lea       rcx,	[L12073]
    call      msys.printstr
    jmp       L55
L57:
    test      rbx,	rbx
    jnz       L59
    mov       rcx,	rdi
    call      msys.printstr
    jmp       L58
L59:
    mov       rcx,	rbx
    mov       rdx,	-1
    lea       r8,	[rbp + msys.m$print_str.fmt]
    call      msys.strtofmt
    mov       rcx,	rdi
    mov       rdx,	-1
    lea       r8,	[rbp + msys.m$print_str.fmt]
    call      msys.tostr_str
L58:
    mov       rax,	1
    mov       [msys.needgap],	rax
L55:
;---------------
    add       rsp,	48
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.m$print_strn
msys.m$print_strn:
;?>>
   %define R.s rdi
   %define R.length rbx
   %define R.fmtstyle rsi
    %define msys.m$print_strn.fmt -16
    push      rdi
    push      rbx
    push      rsi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    xor       ecx,	ecx
    call      msys.nextfmtchars
    test      rdi,	rdi
    jnz       L62
    lea       rcx,	[L12073]
    call      msys.printstr
    jmp       L60
L62:
    test      rsi,	rsi
    jnz       L64
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      msys.printstr_n
    jmp       L63
L64:
    mov       rcx,	rsi
    mov       rdx,	-1
    lea       r8,	[rbp + msys.m$print_strn.fmt]
    call      msys.strtofmt
    mov       rcx,	rdi
    mov       rdx,	rbx
    lea       r8,	[rbp + msys.m$print_strn.fmt]
    call      msys.tostr_str
L63:
    mov       rax,	1
    mov       [msys.needgap],	rax
L60:
;---------------
    add       rsp,	56
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.m$print_str_nf
msys.m$print_str_nf:
;?>>
   %define R.s rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    xor       edx,	edx
    call      msys.m$print_str
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc msys.m$print_strsl
msys.m$print_strsl:
;?>>
    %define msys.m$print_strsl.s 16
    %define msys.m$print_strsl.fmtstyle 24
;?]]
    sub       rsp,	40
;---------------
    lea       rcx,	[L12074]
    call      mlib.abortprogram
;---------------
    add       rsp,	40
    ret       
;End 
;Proc msys.m$print_newline
msys.m$print_newline:
;?>>
;?]]
    sub       rsp,	40
;---------------
    xor       eax,	eax
    mov       [msys.needgap],	rax
    mov       rcx,	1
    call      msys.nextfmtchars
    lea       rcx,	[L12075]
    call      msys.printstr
;---------------
    add       rsp,	40
    ret       
;End 
;Proc msys.m$print_nogap
msys.m$print_nogap:
;?>>
;?]]
;---------------
    xor       eax,	eax
    mov       [msys.needgap],	rax
;---------------
    ret       
;End 
;Proc msys.m$print_space
msys.m$print_space:
;?>>
;?]]
    sub       rsp,	40
;---------------
    xor       eax,	eax
    mov       [msys.needgap],	rax
    lea       rcx,	[L12076]
    call      msys.printstr
;---------------
    add       rsp,	40
    ret       
;End 
;Proc msys.printstr
msys.printstr:
;?>>
   %define R.s rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      strlen
    mov       rcx,	rdi
    mov       rdx,	rax
    call      msys.printstr_n
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc msys.printstr_n
msys.printstr_n:
;?>>
   %define R.s rdi
   %define R.n rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rdi
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      msys.dumpstr
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.printstrn_app
msys.printstrn_app:
;?>>
   %define R.s rdi
   %define R.length rbx
   %define R.f rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    test      rbx,	rbx
    jz        L74
    test      rsi,	rsi
    jnz       L76
    lea       rcx,	[L12077]
    mov       rdx,	rbx
    mov       r8,	rdi
    call      printf
    jmp       L75
L76:
    mov       rcx,	rsi
    lea       rdx,	[L12077]
    mov       r8,	rbx
    mov       r9,	rdi
    call      fprintf
L75:
L74:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.printchar
msys.printchar:
;?>>
   %define R.ch rdi
    %define msys.printchar.str -8
    push      rdi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       rdi,	rcx
;---------------
    mov       [rbp + msys.printchar.str],	dil
    xor       eax,	eax
    mov       [rbp + msys.printchar.str+1],	al
    lea       rcx,	[rbp + msys.printchar.str]
    mov       rdx,	1
    call      msys.printstr_n
;---------------
    add       rsp,	40
    pop       rbp
    pop       rdi
    ret       
;End 
;Proc msys.nextfmtchars
msys.nextfmtchars:
;?>>
   %define R.lastx r12
   %define R.c dil
   %define R.pstart rbx
   %define R.n rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       r12,	rcx
;---------------
    mov       rax,	[msys.fmtstr]
    test      rax,	rax
    jnz       L80
    mov       rax,	[msys.needgap]
    test      rax,	rax
    jz        L82
    mov       rcx,	32
    call      msys.printchar
L82:
    xor       eax,	eax
    mov       [msys.needgap],	rax
    jmp       L78
L80:
    mov       rbx,	[msys.fmtstr]
    xor       rsi,	rsi
L83:
    mov       rax,	[msys.fmtstr]
    mov       dil,	[rax]
    movzx     rax,	dil
    cmp       rax,	35
    jz        L86
    test      rax,	rax
    jz        L87
    cmp       rax,	126
    jz        L88
    jmp       L89
L86:
    test      r12,	r12
    jz        L91
    jmp       L92
L91:
    inc       qword [msys.fmtstr]
    test      rsi,	rsi
    jz        L94
    mov       rcx,	rbx
    mov       rdx,	rsi
    call      msys.printstr_n
L94:
    jmp       L78
L87:
    test      rsi,	rsi
    jz        L96
    mov       rcx,	rbx
    mov       rdx,	rsi
    call      msys.printstr_n
    jmp       L95
L96:
    test      r12,	r12
    jnz       L97
    lea       rcx,	[L12078]
    mov       rdx,	1
    call      msys.printstr_n
L97:
L95:
    jmp       L78
L88:
    test      rsi,	rsi
    jz        L99
    mov       rcx,	rbx
    mov       rdx,	rsi
    call      msys.printstr_n
    xor       rsi,	rsi
L99:
    inc       qword [msys.fmtstr]
    mov       rax,	[msys.fmtstr]
    mov       dil,	[rax]
    test      dil,	dil
    jz        L101
    inc       qword [msys.fmtstr]
    movzx     rax,	dil
    mov       rcx,	rax
    call      msys.printchar
L101:
    mov       rbx,	[msys.fmtstr]
    jmp       L85
L89:
;msys.nextfmtchars.skip:
L92:
    inc       rsi
    inc       qword [msys.fmtstr]
L85:
    jmp       L83
L78:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.strtofmt
msys.strtofmt:
;?>>
   %define R.s r13
   %define R.slen r14
   %define R.fmt r15
   %define R.c rdi
   %define R.base rbx
   %define R.wset sil
   %define R.n r12
    %define msys.strtofmt.str -104
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	136
    mov       r13,	rcx
    mov       r14,	rdx
    mov       r15,	r8
;---------------
    lea       rax,	[msys.defaultfmt]
    movdqu    XMM4,	[rax]
    movdqu    [r15],	XMM4
    test      r13,	r13
    jnz       L104
    jmp       L102
L104:
    cmp       r14,	-1
    jnz       L106
    mov       rcx,	r13
    call      strlen
    mov       r14,	rax
L106:
    lea       rcx,	[rbp + msys.strtofmt.str]
    mov       rdx,	r13
    mov       r8,	r14
    call      memcpy
    xor       eax,	eax
    mov       [rbp + r14 + msys.strtofmt.str],	al
    lea       rax,	[rbp + msys.strtofmt.str]
    mov       r13,	rax
    xor       sil,	sil
    jmp       L108
L107:
    movzx     rax,	byte [r13]
    mov       rdi,	rax
    inc       r13
    cmp       rdi,	65
    jnz       L111
    mov       al,	65
    mov       [r15+8],	al
    jmp       L110
L111:
    cmp       rdi,	97
    jnz       L112
    mov       al,	97
    mov       [r15+8],	al
    jmp       L110
L112:
    mov       rcx,	rdi
    call      toupper
    movsxd    r10,	eax
    sub       r10,	66
    cmp       r10,	25
    jae       L115
    lea       rax,	[L114]
    jmp       [rax + r10*8]
    segment .data
L114:
    dq  L116
    dq  L145
    dq  L144
    dq  L141
    dq  L142
    dq  L143
    dq  L117
    dq  L115
    dq  L127
    dq  L115
    dq  L115
    dq  L146
    dq  L149
    dq  L118
    dq  L134
    dq  L126
    dq  L115
    dq  L131
    dq  L137
    dq  L140
    dq  L147
    dq  L115
    dq  L119
    dq  L148
    dq  L130
    segment .text
L116:
    mov       al,	2
    mov       [r15+2],	al
    jmp       L113
L117:
    mov       al,	16
    mov       [r15+2],	al
    jmp       L113
L118:
    mov       al,	8
    mov       [r15+2],	al
    jmp       L113
L119:
    xor       rbx,	rbx
L120:
    movzx     rax,	byte [r13]
    mov       rdi,	rax
    mov       rax,	rdi
    cmp       rax,	48
    jl        L123
    cmp       rax,	57
    jg        L123
    mov       rax,	rbx
    shl       rax,	1
    lea       rax,	[rax + rax*4]
    add       rax,	rdi
    sub       rax,	48
    mov       rbx,	rax
    inc       r13
    jmp       L122
L123:
    jmp       L121
L122:
    jmp       L120
L121:
    mov       rax,	rbx
    cmp       rax,	2
    jl        L125
    cmp       rax,	16
    jg        L125
    mov       [r15+2],	bl
L125:
    jmp       L113
L126:
    mov       al,	34
    mov       [r15+3],	al
    jmp       L113
L127:
    movzx     rax,	byte [r13]
    mov       rcx,	rax
    call      toupper
    mov       [r15+9],	al
    mov       al,	[r13]
    test      al,	al
    jz        L129
    inc       r13
L129:
    jmp       L113
L130:
    mov       al,	48
    mov       [r15+4],	al
    jmp       L113
L131:
    mov       al,	[r13]
    mov       [r15+7],	al
    mov       al,	[r13]
    test      al,	al
    jz        L133
    inc       r13
L133:
    jmp       L113
L134:
    mov       al,	[r13]
    mov       [r15+4],	al
    mov       al,	[r13]
    test      al,	al
    jz        L136
    inc       r13
L136:
    jmp       L113
L137:
    mov       al,	[r13]
    mov       [r15+10],	al
    mov       al,	[r13]
    test      al,	al
    jz        L139
    inc       r13
L139:
    jmp       L113
L140:
    mov       al,	87
    mov       [r15+11],	al
    jmp       L113
L141:
    mov       al,	101
    mov       [r15+5],	al
    jmp       L113
L142:
    mov       al,	102
    mov       [r15+5],	al
    jmp       L113
L143:
    mov       al,	103
    mov       [r15+5],	al
    jmp       L113
L144:
    mov       al,	68
    mov       [r15+13],	al
    jmp       L113
L145:
    mov       al,	67
    mov       [r15+12],	al
    jmp       L113
L146:
    mov       al,	77
    mov       [r15+12],	al
    jmp       L113
L147:
    mov       al,	86
    mov       [r15+14],	al
    jmp       L113
L148:
    lea       rax,	[r15+15]
    or        byte [rax],	1
    jmp       L113
L149:
    lea       rax,	[r15+15]
    or        byte [rax],	2
    jmp       L113
L115:
    mov       rax,	rdi
    cmp       rax,	46
    jz        L151
    cmp       rax,	44
    jz        L152
    cmp       rax,	95
    jz        L152
    cmp       rax,	43
    jz        L153
    cmp       rax,	126
    jz        L154
    cmp       rax,	42
    jz        L155
    jmp       L156
L151:
    mov       sil,	1
    jmp       L150
L152:
    mov       [r15+7],	dil
    jmp       L150
L153:
    mov       al,	43
    mov       [r15+6],	al
    jmp       L150
L154:
    mov       al,	126
    mov       [r15+3],	al
    jmp       L150
L155:
    mov       r12,	[msys.fmtparam]
    jmp       L157
L156:
    cmp       rdi,	48
    jl        L159
    cmp       rdi,	57
    jg        L159
    lea       rax,	[rdi-48]
    mov       r12,	rax
L160:
    movzx     rax,	byte [r13]
    mov       rdi,	rax
    movzx     rax,	byte [r13]
    test      rax,	rax
    jz        L161
L163:
    cmp       rdi,	48
    jl        L165
    cmp       rdi,	57
    jg        L165
    inc       r13
    mov       rax,	r12
    shl       rax,	1
    lea       rax,	[rax + rax*4]
    add       rax,	rdi
    sub       rax,	48
    mov       r12,	rax
    jmp       L164
L165:
    jmp       L161
L164:
    jmp       L160
L161:
;msys.strtofmt.gotwidth:
L157:
    test      sil,	sil
    jnz       L167
    mov       [r15],	r12b
    mov       sil,	1
    jmp       L166
L167:
    mov       [r15+1],	r12b
L166:
L159:
L150:
L113:
L110:
L108:
    mov       al,	[r13]
    test      al,	al
    jnz       L107
L102:
;---------------
    add       rsp,	136
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.domultichar
msys.domultichar:
;?>>
   %define R.p r12
   %define R.n r13
   %define R.dest r14
    %define msys.domultichar.fmt 88
    %define msys.domultichar.str -24
   %define R.q rdi
   %define R.nchars rbx
   %define R.av_1 rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       r12,	rcx
    mov       r13,	rdx
    mov       r14,	r8
    mov       [rbp+88],	r9
;---------------
    lea       rax,	[rbp + msys.domultichar.str]
    mov       rdi,	rax
    mov       rbx,	r13
    mov       rsi,	r13
    cmp       rsi,	0
    jle       L171
L169:
    movzx     rax,	byte [r12]
    test      rax,	rax
    jz        L171
L173:
    mov       al,	[r12]
    mov       [rdi],	al
    inc       rdi
    inc       r12
    dec       rsi
    jnz       L169
L171:
    xor       eax,	eax
    mov       [rdi],	al
    lea       rcx,	[rbp + msys.domultichar.str]
    call      strlen
    lea       rcx,	[rbp + msys.domultichar.str]
    mov       rdx,	r14
    mov       r8,	rax
    mov       r9,	[rbp + msys.domultichar.fmt]
    call      msys.expandstr
L168:
;---------------
    add       rsp,	64
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.expandstr
msys.expandstr:
;?>>
   %define R.s r13
   %define R.t r14
    %define msys.expandstr.n 80
    %define msys.expandstr.fmt 88
   %define R.i rdi
   %define R.w rbx
   %define R.m rsi
   %define R.av_1 r12
    %define msys.expandstr.av_2 -8
    %define msys.expandstr.av_3 -16
    %define msys.expandstr.av_4 -24
    %define msys.expandstr.av_5 -32
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       r13,	rcx
    mov       r14,	rdx
    mov       [rbp+80],	r8
    mov       [rbp+88],	r9
;---------------
    mov       rax,	[rbp + msys.expandstr.fmt]
    movzx     rax,	byte [rax]
    mov       rbx,	rax
    test      rbx,	rbx
    jz        L177
    cmp       rbx,	[rbp + msys.expandstr.n]
    jg        L176
L177:
    mov       rcx,	r14
    mov       rdx,	r13
    mov       r8,	[rbp + msys.expandstr.n]
    call      strncpy
    xor       eax,	eax
    mov       r10,	[rbp + msys.expandstr.n]
    mov       [r14 + r10],	al
    mov       rax,	[rbp + msys.expandstr.n]
    jmp       L174
L176:
    mov       rax,	[rbp + msys.expandstr.fmt]
    movzx     rax,	byte [rax+9]
    cmp       rax,	76
    jnz       L179
    mov       rcx,	r14
    mov       rdx,	r13
    mov       r8,	[rbp + msys.expandstr.n]
    call      strncpy
    mov       rax,	[rbp + msys.expandstr.n]
    add       r14,	rax
    mov       rdi,	1
    mov       rax,	rbx
    sub       rax,	[rbp + msys.expandstr.n]
    mov       r12,	rax
    cmp       r12,	1
    jl        L182
L180:
    mov       rax,	[rbp + msys.expandstr.fmt]
    mov       al,	[rax+4]
    mov       [r14],	al
    inc       r14
    inc       rdi
    cmp       rdi,	r12
    jle       L180
L182:
    xor       eax,	eax
    mov       [r14],	al
    jmp       L178
L179:
    mov       rax,	[rbp + msys.expandstr.fmt]
    movzx     rax,	byte [rax+9]
    cmp       rax,	82
    jnz       L183
    mov       rax,	[rbp + msys.expandstr.fmt]
    movzx     rax,	byte [rax+4]
    cmp       rax,	48
    jnz       L185
    mov       rax,	[rbp + msys.expandstr.fmt]
    mov       al,	[rax+2]
    test      al,	al
    jz        L185
    movzx     rax,	byte [r13]
    cmp       rax,	45
    jz        L186
    movzx     rax,	byte [r13]
    cmp       rax,	43
    jnz       L185
L186:
    mov       al,	[r13]
    mov       [r14],	al
    inc       r14
    mov       rax,	rbx
    sub       rax,	[rbp + msys.expandstr.n]
    mov       [rbp + msys.expandstr.av_2],	rax
    mov       rax,	[rbp + msys.expandstr.av_2]
    cmp       rax,	0
    jle       L189
L187:
    mov       rax,	[rbp + msys.expandstr.fmt]
    mov       al,	[rax+4]
    mov       [r14],	al
    inc       r14
    dec       qword [rbp + msys.expandstr.av_2]
    jnz       L187
L189:
    mov       rax,	[rbp + msys.expandstr.n]
    dec       rax
    lea       r10,	[r13+1]
    mov       rcx,	r14
    mov       rdx,	r10
    mov       r8,	rax
    call      strncpy
    mov       rax,	[rbp + msys.expandstr.n]
    lea       r10,	[r14 + rax]
    sub       r10,	1
    xor       eax,	eax
    mov       [r10],	al
    jmp       L184
L185:
    mov       rax,	rbx
    sub       rax,	[rbp + msys.expandstr.n]
    mov       [rbp + msys.expandstr.av_3],	rax
    mov       rax,	[rbp + msys.expandstr.av_3]
    cmp       rax,	0
    jle       L192
L190:
    mov       rax,	[rbp + msys.expandstr.fmt]
    mov       al,	[rax+4]
    mov       [r14],	al
    inc       r14
    dec       qword [rbp + msys.expandstr.av_3]
    jnz       L190
L192:
    mov       rcx,	r14
    mov       rdx,	r13
    mov       r8,	[rbp + msys.expandstr.n]
    call      strncpy
    xor       eax,	eax
    mov       r10,	[rbp + msys.expandstr.n]
    mov       [r14 + r10],	al
L184:
    jmp       L178
L183:
    mov       rax,	rbx
    sub       rax,	[rbp + msys.expandstr.n]
    inc       rax
    sar       rax,	1
    mov       rsi,	rax
    mov       [rbp + msys.expandstr.av_4],	rsi
    mov       rax,	[rbp + msys.expandstr.av_4]
    cmp       rax,	0
    jle       L195
L193:
    mov       rax,	[rbp + msys.expandstr.fmt]
    mov       al,	[rax+4]
    mov       [r14],	al
    inc       r14
    dec       qword [rbp + msys.expandstr.av_4]
    jnz       L193
L195:
    mov       rcx,	r14
    mov       rdx,	r13
    mov       r8,	[rbp + msys.expandstr.n]
    call      strncpy
    mov       rax,	[rbp + msys.expandstr.n]
    add       r14,	rax
    mov       rax,	rbx
    sub       rax,	[rbp + msys.expandstr.n]
    sub       rax,	rsi
    mov       [rbp + msys.expandstr.av_5],	rax
    mov       rax,	[rbp + msys.expandstr.av_5]
    cmp       rax,	0
    jle       L198
L196:
    mov       rax,	[rbp + msys.expandstr.fmt]
    mov       al,	[rax+4]
    mov       [r14],	al
    inc       r14
    dec       qword [rbp + msys.expandstr.av_5]
    jnz       L196
L198:
    xor       eax,	eax
    mov       [r14],	al
L178:
    mov       rax,	rbx
L174:
;---------------
    add       rsp,	64
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.u64tostr
msys.u64tostr:
;?>>
   %define R.aa rcx
   %define R.s rdx
   %define R.base r8
   %define R.sep r9
    %define msys.u64tostr.t -360
   %define R.dd rdi
   %define R.i rbx
   %define R.j rsi
   %define R.k r12
   %define R.g r13
   %define R.s0 r14
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	368
;---------------
    xor       rbx,	rbx
    xor       eax,	eax
    mov       r12,	rax
    cmp       r8,	10
    jnz       L201
    mov       rax,	3
    jmp       L200
L201:
    mov       rax,	4
L200:
    mov       r13,	rax
L202:
    mov       rax,	rcx
    mov       r10,	r8
    push      rdx
    xor       edx,	edx
    div       r10
    xchg      rax,	rdx
    pop       rdx
    mov       rdi,	rax
    mov       rax,	rcx
    mov       r10,	r8
    push      rdx
    xor       edx,	edx
    div       r10
    pop       rdx
    mov       rcx,	rax
    lea       rax,	[msys.digits]
    mov       r10,	rdi
    mov       al,	[rax + r10]
    inc       rbx
    mov       r10,	rbx
    mov       [rbp + r10 + msys.u64tostr.t],	al
    inc       r12
    test      r9,	r9
    jz        L206
    test      rcx,	rcx
    jz        L206
    cmp       r12,	r13
    jnz       L206
    inc       rbx
    mov       rax,	rbx
    mov       r10b,	r9b
    mov       [rbp + rax + msys.u64tostr.t],	r10b
    xor       r12,	r12
L206:
    test      rcx,	rcx
    jnz       L202
    mov       rsi,	rbx
    mov       r14,	rdx
    jmp       L208
L207:
    mov       rax,	rbx
    dec       rbx
    mov       al,	[rbp + rax + msys.u64tostr.t]
    mov       [rdx],	al
    inc       rdx
L208:
    test      rbx,	rbx
    jnz       L207
    xor       eax,	eax
    mov       [rdx],	al
    mov       rax,	rsi
L199:
;---------------
    add       rsp,	368
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.i64tostrfmt
msys.i64tostrfmt:
;?>>
   %define R.aa rsi
   %define R.s r12
   %define R.fmt r13
    %define msys.i64tostrfmt.str -360
   %define R.n rdi
   %define R.usigned rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	392
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
;---------------
    xor       rbx,	rbx
    mov       al,	[r13+11]
    test      al,	al
    jz        L212
    mov       rbx,	1
L212:
    mov       rax,	rsi
    mov       r10,	-9223372036854775808
    cmp       rax,	r10
    jnz       L214
    test      rbx,	rbx
    jnz       L214
    mov       al,	45
    mov       [rbp + msys.i64tostrfmt.str],	al
    movzx     rax,	byte [r13+7]
    movzx     r10,	byte [r13+2]
    lea       r11,	[rbp + msys.i64tostrfmt.str+1]
    mov       rcx,	r11
    mov       rdx,	r10
    mov       r8,	rax
    call      msys.i64mintostr
    inc       rax
    mov       rdi,	rax
    jmp       L213
L214:
    test      rbx,	rbx
    jnz       L218
    cmp       rsi,	0
    jl        L217
L218:
    mov       al,	[r13+6]
    test      al,	al
    jz        L216
L217:
    cmp       rsi,	0
    jge       L220
    mov       rax,	rsi
    neg       rax
    mov       rsi,	rax
    mov       al,	45
    mov       [rbp + msys.i64tostrfmt.str],	al
    jmp       L219
L220:
    mov       al,	43
    mov       [rbp + msys.i64tostrfmt.str],	al
L219:
    movzx     rax,	byte [r13+7]
    movzx     r10,	byte [r13+2]
    lea       r11,	[rbp + msys.i64tostrfmt.str+1]
    mov       rcx,	rsi
    mov       rdx,	r11
    mov       r8,	r10
    mov       r9,	rax
    call      msys.u64tostr
    inc       rax
    mov       rdi,	rax
    jmp       L215
L216:
    movzx     rax,	byte [r13+7]
    movzx     r10,	byte [r13+2]
    mov       rcx,	rsi
    lea       rdx,	[rbp + msys.i64tostrfmt.str]
    mov       r8,	r10
    mov       r9,	rax
    call      msys.u64tostr
    mov       rdi,	rax
L215:
L213:
    mov       al,	[r13+10]
    test      al,	al
    jz        L222
    mov       al,	[r13+10]
    mov       [rbp + rdi + msys.i64tostrfmt.str],	al
    inc       rdi
    mov       rax,	rdi
    xor       r10d,	r10d
    mov       [rbp + rax + msys.i64tostrfmt.str],	r10b
L222:
    movzx     rax,	byte [r13+2]
    cmp       rax,	10
    jg        L225
    mov       al,	[r13+10]
    test      al,	al
    jz        L224
L225:
    movzx     rax,	byte [r13+8]
    cmp       rax,	97
    jnz       L224
    lea       rcx,	[rbp + msys.i64tostrfmt.str]
    call      mlib.convlcstring
L224:
    lea       rcx,	[rbp + msys.i64tostrfmt.str]
    mov       rdx,	r12
    mov       r8,	rdi
    mov       r9,	r13
    call      msys.expandstr
L210:
;---------------
    add       rsp,	392
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.u64tostrfmt
msys.u64tostrfmt:
;?>>
   %define R.aa rbx
   %define R.s rsi
   %define R.fmt r12
    %define msys.u64tostrfmt.str -360
   %define R.n rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	400
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
;---------------
    movzx     rax,	byte [r12+7]
    movzx     r10,	byte [r12+2]
    mov       rcx,	rbx
    lea       rdx,	[rbp + msys.u64tostrfmt.str]
    mov       r8,	r10
    mov       r9,	rax
    call      msys.u64tostr
    mov       rdi,	rax
    mov       al,	[r12+10]
    test      al,	al
    jz        L228
    mov       al,	[r12+10]
    mov       [rbp + rdi + msys.u64tostrfmt.str],	al
    inc       rdi
    mov       rax,	rdi
    xor       r10d,	r10d
    mov       [rbp + rax + msys.u64tostrfmt.str],	r10b
L228:
    movzx     rax,	byte [r12+2]
    cmp       rax,	10
    jg        L231
    mov       al,	[r12+10]
    test      al,	al
    jz        L230
    movzx     rax,	byte [r12+8]
    cmp       rax,	97
    jnz       L230
L231:
L230:
    lea       rcx,	[rbp + msys.u64tostrfmt.str]
    mov       rdx,	rsi
    mov       r8,	rdi
    mov       r9,	r12
    call      msys.expandstr
L226:
;---------------
    add       rsp,	400
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.i64mintostr
msys.i64mintostr:
;?>>
   %define R.s r13
   %define R.base r14
   %define R.sep r15
    %define msys.i64mintostr.t -360
   %define R.i rdi
   %define R.j rbx
   %define R.k rsi
   %define R.g r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	392
    mov       r13,	rcx
    mov       r14,	rdx
    mov       r15,	r8
;---------------
    mov       rax,	r14
    cmp       rax,	10
    jz        L234
    cmp       rax,	16
    jz        L235
    cmp       rax,	2
    jz        L236
    jmp       L237
L234:
    lea       rax,	[rbp + msys.i64mintostr.t]
    mov       rcx,	rax
    lea       rdx,	[L12079]
    call      strcpy
    mov       rbx,	3
    jmp       L233
L235:
    lea       rax,	[rbp + msys.i64mintostr.t]
    mov       rcx,	rax
    lea       rdx,	[L12080]
    call      strcpy
    mov       rbx,	1
    jmp       L233
L236:
    lea       rax,	[rbp + msys.i64mintostr.t]
    mov       rcx,	rax
    lea       rdx,	[L12081]
    call      strcpy
    mov       rbx,	7
    jmp       L233
L237:
    lea       rax,	[rbp + msys.i64mintostr.t]
    mov       rcx,	rax
    lea       rdx,	[L12082]
    call      strcpy
L233:
    lea       rax,	[rbp + msys.i64mintostr.t]
    mov       rcx,	rax
    call      strlen
    mov       rdi,	rax
    mov       rax,	rdi
    add       r13,	rax
    test      r15,	r15
    jz        L239
    mov       rax,	rbx
    add       r13,	rax
L239:
    xor       eax,	eax
    mov       [r13],	al
    xor       rsi,	rsi
    mov       rax,	r14
    cmp       rax,	10
    jnz       L241
    mov       rax,	3
    jmp       L240
L241:
    mov       rax,	4
L240:
    mov       r12,	rax
    jmp       L243
L242:
    dec       r13
    mov       rax,	rdi
    dec       rdi
    mov       al,	[rbp + rax + msys.i64mintostr.t-1]
    mov       [r13],	al
    test      r15,	r15
    jz        L246
    test      rdi,	rdi
    jz        L246
    inc       rsi
    cmp       rsi,	r12
    jnz       L246
    dec       r13
    mov       [r13],	r15b
    xor       rsi,	rsi
L246:
L243:
    test      rdi,	rdi
    jnz       L242
    mov       rcx,	r13
    call      strlen
L232:
;---------------
    add       rsp,	392
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.strtostrfmt
msys.strtostrfmt:
;?>>
   %define R.s r13
   %define R.t r14
    %define msys.strtostrfmt.n 80
    %define msys.strtostrfmt.fmt 88
   %define R.u rdi
   %define R.v rbx
    %define msys.strtostrfmt.str -256
   %define R.w rsi
   %define R.nheap r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	288
    mov       r13,	rcx
    mov       r14,	rdx
    mov       [rbp+80],	r8
    mov       [rbp+88],	r9
;---------------
    xor       r12,	r12
    mov       rax,	[rbp + msys.strtostrfmt.fmt]
    mov       al,	[rax+3]
    test      al,	al
    jnz       L250
    mov       rax,	[rbp + msys.strtostrfmt.fmt]
    mov       al,	[rax+8]
    test      al,	al
    jz        L249
L250:
    mov       rax,	[rbp + msys.strtostrfmt.n]
    cmp       rax,	256
    jge       L252
    lea       rax,	[rbp + msys.strtostrfmt.str]
    mov       rdi,	rax
    jmp       L251
L252:
    mov       rax,	[rbp + msys.strtostrfmt.n]
    add       rax,	3
    mov       r12,	rax
    mov       rcx,	r12
    call      mlib.pcm_alloc
    mov       rdi,	rax
L251:
    mov       rax,	[rbp + msys.strtostrfmt.fmt]
    mov       al,	[rax+3]
    test      al,	al
    jz        L254
    mov       rbx,	rdi
    mov       rax,	[rbp + msys.strtostrfmt.fmt]
    mov       al,	[rax+3]
    mov       [rbx],	al
    inc       rbx
    mov       rax,	[rbp + msys.strtostrfmt.n]
    test      rax,	rax
    jz        L256
    mov       rcx,	rbx
    mov       rdx,	r13
    call      strcpy
    mov       rax,	[rbp + msys.strtostrfmt.n]
    add       rbx,	rax
L256:
    mov       rax,	[rbp + msys.strtostrfmt.fmt]
    mov       al,	[rax+3]
    mov       [rbx],	al
    inc       rbx
    xor       eax,	eax
    mov       [rbx],	al
    mov       rax,	2
    add       [rbp + msys.strtostrfmt.n],	rax
    jmp       L253
L254:
    mov       rcx,	rdi
    mov       rdx,	r13
    mov       r8,	[rbp + msys.strtostrfmt.n]
    call      memcpy
L253:
    mov       rax,	[rbp + msys.strtostrfmt.fmt]
    movzx     rax,	byte [rax+8]
    cmp       rax,	97
    jz        L258
    cmp       rax,	65
    jz        L259
    jmp       L260
L258:
    mov       rcx,	rdi
    call      mlib.convlcstring
    jmp       L257
L259:
    mov       rcx,	rdi
    call      mlib.convucstring
L260:
L257:
    mov       r13,	rdi
L249:
    mov       rax,	[rbp + msys.strtostrfmt.fmt]
    movzx     rax,	byte [rax]
    mov       rsi,	rax
    cmp       rsi,	[rbp + msys.strtostrfmt.n]
    jle       L262
    mov       rcx,	r13
    mov       rdx,	r14
    mov       r8,	[rbp + msys.strtostrfmt.n]
    mov       r9,	[rbp + msys.strtostrfmt.fmt]
    call      msys.expandstr
    mov       [rbp + msys.strtostrfmt.n],	rax
    jmp       L261
L262:
    mov       rcx,	r14
    mov       rdx,	r13
    mov       r8,	[rbp + msys.strtostrfmt.n]
    call      memcpy
L261:
    test      r12,	r12
    jz        L264
    mov       rcx,	rdi
    mov       rdx,	r12
    call      mlib.pcm_free
L264:
    mov       rax,	[rbp + msys.strtostrfmt.n]
L247:
;---------------
    add       rsp,	288
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.tostr_i64
msys.tostr_i64:
;?>>
    %define msys.tostr_i64.a 32
   %define R.fmt rbx
    %define msys.tostr_i64.str -360
   %define R.n rdi
    push      rdi
    push      rbx
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	400
    mov       [rbp+32],	rcx
    mov       rbx,	rdx
;---------------
    movzx     rax,	byte [rbx+12]
    test      rax,	rax
    jz        L267
    cmp       rax,	77
    jz        L268
    jmp       L269
L267:
    mov       rcx,	[rbp + msys.tostr_i64.a]
    lea       rdx,	[rbp + msys.tostr_i64.str]
    mov       r8,	rbx
    call      msys.i64tostrfmt
    mov       rdi,	rax
    jmp       L266
L268:
    lea       rcx,	[rbp + msys.tostr_i64.a]
    mov       rdx,	8
    lea       r8,	[rbp + msys.tostr_i64.str]
    mov       r9,	rbx
    call      msys.domultichar
    mov       rdi,	rax
    jmp       L266
L269:
    mov       rcx,	[rbp + msys.tostr_i64.a]
    xor       edx,	edx
    call      msys.m$print_c8
    jmp       L265
L266:
    lea       rcx,	[rbp + msys.tostr_i64.str]
    mov       rdx,	rdi
    call      msys.printstr_n
L265:
;---------------
    add       rsp,	400
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.tostr_u64
msys.tostr_u64:
;?>>
    %define msys.tostr_u64.a 32
   %define R.fmt rbx
    %define msys.tostr_u64.str -360
   %define R.n rdi
    push      rdi
    push      rbx
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	400
    mov       [rbp+32],	rcx
    mov       rbx,	rdx
;---------------
    movzx     rax,	byte [rbx+12]
    cmp       rax,	77
    jz        L272
    cmp       rax,	67
    jz        L273
    jmp       L274
L272:
    lea       rcx,	[rbp + msys.tostr_u64.a]
    mov       rdx,	8
    lea       r8,	[rbp + msys.tostr_u64.str]
    mov       r9,	rbx
    call      msys.domultichar
    mov       rdi,	rax
    jmp       L271
L273:
    mov       rcx,	[rbp + msys.tostr_u64.a]
    xor       edx,	edx
    call      msys.m$print_c8
    jmp       L270
L274:
    mov       rcx,	[rbp + msys.tostr_u64.a]
    lea       rdx,	[rbp + msys.tostr_u64.str]
    mov       r8,	rbx
    call      msys.u64tostrfmt
    mov       rdi,	rax
L271:
    lea       rcx,	[rbp + msys.tostr_u64.str]
    mov       rdx,	rdi
    call      msys.printstr_n
L270:
;---------------
    add       rsp,	400
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.tostr_r64
msys.tostr_r64:
;?>>
   %define R.x XMM15
   %define R.fmt rbx
    %define msys.tostr_r64.str -360
    %define msys.tostr_r64.str2 -720
    %define msys.tostr_r64.cfmt -736
   %define R.n rdi
    push      rdi
    push      rbx
    movq      rax,	XMM15
    push      rax
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	776
    movq      XMM15,	XMM0
    mov       rbx,	rdx
;---------------
    mov       al,	37
    mov       [rbp + msys.tostr_r64.cfmt],	al
    mov       al,	[rbx+1]
    test      al,	al
    jz        L277
    mov       al,	46
    mov       [rbp + msys.tostr_r64.cfmt+1],	al
    mov       al,	42
    mov       [rbp + msys.tostr_r64.cfmt+2],	al
    mov       al,	[rbx+5]
    mov       [rbp + msys.tostr_r64.cfmt+3],	al
    xor       eax,	eax
    mov       [rbp + msys.tostr_r64.cfmt+4],	al
    movsx     rax,	byte [rbx+1]
    lea       rcx,	[rbp + msys.tostr_r64.str]
    lea       rdx,	[rbp + msys.tostr_r64.cfmt]
    mov       r8,	rax
    movq      XMM3,	XMM15
    movq      r9,	XMM3
    call      sprintf
    jmp       L276
L277:
    mov       al,	[rbx+5]
    mov       [rbp + msys.tostr_r64.cfmt+1],	al
    xor       eax,	eax
    mov       [rbp + msys.tostr_r64.cfmt+2],	al
    lea       rcx,	[rbp + msys.tostr_r64.str]
    lea       rdx,	[rbp + msys.tostr_r64.cfmt]
    movq      XMM2,	XMM15
    movq      r8,	XMM2
    call      sprintf
L276:
    lea       rcx,	[rbp + msys.tostr_r64.str]
    call      strlen
    mov       rdi,	rax
    movzx     rax,	byte [rbx]
    mov       r10,	rdi
    cmp       r10,	rax
    jge       L279
    lea       rcx,	[rbp + msys.tostr_r64.str]
    lea       rdx,	[rbp + msys.tostr_r64.str2]
    mov       r8,	rdi
    mov       r9,	rbx
    call      msys.expandstr
    mov       rdi,	rax
    lea       rcx,	[rbp + msys.tostr_r64.str]
    lea       rdx,	[rbp + msys.tostr_r64.str2]
    call      strcpy
L279:
    lea       rcx,	[rbp + msys.tostr_r64.str]
    mov       rdx,	rdi
    call      msys.printstr_n
;---------------
    add       rsp,	776
    pop       rbp
    pop       rcx
    movq      XMM15,	rcx
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.tostr_str
msys.tostr_str:
;?>>
   %define R.s r12
   %define R.oldlen r13
   %define R.fmt r14
   %define R.newlen rdi
   %define R.n rbx
   %define R.t rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       r12,	rcx
    mov       r13,	rdx
    mov       r14,	r8
;---------------
    cmp       r13,	-1
    jnz       L282
    mov       rcx,	r12
    call      strlen
    mov       r13,	rax
L282:
    mov       rdi,	r13
    mov       al,	[r14+3]
    test      al,	al
    jnz       L285
    movzx     rax,	byte [r14]
    cmp       rax,	rdi
    jg        L285
    mov       al,	[r14+8]
    test      al,	al
    jnz       L285
    mov       al,	[r14+1]
    test      al,	al
    jz        L284
L285:
    mov       al,	[r14+3]
    test      al,	al
    jz        L287
    mov       rax,	2
    add       rdi,	rax
L287:
    movzx     rax,	byte [r14]
    cmp       rax,	rdi
    jle       L289
    movzx     rax,	byte [r14]
    mov       rdi,	rax
L289:
    lea       rax,	[rdi+1]
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       rsi,	rax
    mov       rcx,	r12
    mov       rdx,	rsi
    mov       r8,	r13
    mov       r9,	r14
    call      msys.strtostrfmt
    mov       rbx,	rax
    mov       al,	[r14+1]
    test      al,	al
    jz        L291
    movsx     rax,	byte [r14+1]
    cmp       rbx,	rax
    jle       L12083
    mov       rbx,	rax
L12083:
L291:
    mov       rcx,	rsi
    mov       rdx,	rbx
    call      msys.printstr_n
    lea       rax,	[rdi+1]
    mov       rcx,	rsi
    mov       rdx,	rax
    call      mlib.pcm_free
    jmp       L283
L284:
    mov       rcx,	r12
    mov       rdx,	r13
    call      msys.printstr_n
L283:
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.getfmt
msys.getfmt:
;?>>
   %define R.fmtstyle rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    test      rdi,	rdi
    jz        L294
    mov       rcx,	rdi
    mov       rdx,	-1
    lea       r8,	[msys.getfmt.fmt]
    call      msys.strtofmt
    lea       rax,	[msys.getfmt.fmt]
    jmp       L293
L294:
    lea       rax,	[msys.defaultfmt]
L293:
L292:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc msys.strint
msys.strint:
;?>>
   %define R.a rbx
   %define R.fmtstyle rsi
   %define R.fmt rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    lea       rcx,	[msys.strint.str]
    call      msys.m$print_startstr
    mov       rcx,	rsi
    call      msys.getfmt
    mov       r10,	rax
    mov       rdi,	r10
    mov       rcx,	rbx
    mov       rdx,	rax
    call      msys.tostr_i64
    call      msys.m$print_end
    lea       rcx,	[msys.strint.str]
    mov       rdx,	rdi
    call      msys.getstr
L295:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.getstrint
msys.getstrint:
;?>>
   %define R.a rdi
   %define R.dest rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rbx
    call      msys.m$print_startstr
    xor       ecx,	ecx
    call      msys.getfmt
    mov       rcx,	rdi
    mov       rdx,	rax
    call      msys.tostr_i64
    call      msys.m$print_end
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.strword
msys.strword:
;?>>
   %define R.a rbx
   %define R.fmtstyle rsi
   %define R.fmt rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    lea       rcx,	[msys.strword.str]
    call      msys.m$print_startstr
    mov       rcx,	rsi
    call      msys.getfmt
    mov       r10,	rax
    mov       rdi,	r10
    mov       rcx,	rbx
    mov       rdx,	rax
    call      msys.tostr_u64
    call      msys.m$print_end
    lea       rcx,	[msys.strword.str]
    mov       rdx,	rdi
    call      msys.getstr
L297:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.strreal
msys.strreal:
;?>>
   %define R.a XMM15
   %define R.fmtstyle rbx
   %define R.fmt rdi
    push      rdi
    push      rbx
    movq      rax,	XMM15
    push      rax
;?]]
    sub       rsp,	48
    movq      XMM15,	XMM0
    mov       rbx,	rdx
;---------------
    lea       rcx,	[msys.strreal.str]
    call      msys.m$print_startstr
    mov       rcx,	rbx
    call      msys.getfmt
    mov       r10,	rax
    mov       rdi,	r10
    movq      XMM0,	XMM15
    mov       rdx,	rax
    call      msys.tostr_r64
    call      msys.m$print_end
    lea       rcx,	[msys.strreal.str]
    mov       rdx,	rdi
    call      msys.getstr
L298:
;---------------
    add       rsp,	48
    pop       rcx
    movq      XMM15,	rcx
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.getstr
msys.getstr:
;?>>
   %define R.s rdi
   %define R.fmt rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       al,	[rbx+13]
    test      al,	al
    jz        L301
    mov       rcx,	rdi
    call      mlib.pcm_copyheapstring
    jmp       L300
L301:
    mov       rax,	rdi
L300:
L299:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.initreadbuffer
msys.initreadbuffer:
;?>>
;?]]
    sub       rsp,	40
;---------------
    mov       rax,	[msys.rd_buffer]
    test      rax,	rax
    jnz       L302
L304:
    mov       rcx,	16384
    call      mlib.pcm_alloc
    mov       [msys.rd_buffer],	rax
    xor       eax,	eax
    mov       r10,	[msys.rd_buffer]
    mov       [r10],	al
    mov       rax,	[msys.rd_buffer]
    mov       [msys.rd_lastpos],	rax
    mov       [msys.rd_pos],	rax
L302:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc msys.m$read_conline
msys.m$read_conline:
;?>>
;?]]
    sub       rsp,	40
;---------------
    call      msys.initreadbuffer
    xor       ecx,	ecx
    mov       rdx,	[msys.rd_buffer]
    mov       r8,	16384
    call      mlib.readlinen
    mov       rcx,	[msys.rd_buffer]
    call      strlen
    mov       [msys.rd_length],	rax
    mov       rax,	[msys.rd_buffer]
    mov       [msys.rd_pos],	rax
    xor       eax,	eax
    mov       [msys.rd_lastpos],	rax
;---------------
    add       rsp,	40
    ret       
;End 
;Proc msys.m$read_fileline
msys.m$read_fileline:
;?>>
   %define R.f rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    call      msys.initreadbuffer
    cmp       rdi,	1
    jnz       L308
    lea       rcx,	[L12084]
    call      mlib.abortprogram
    jmp       L306
L308:
    mov       rcx,	rdi
    mov       rdx,	[msys.rd_buffer]
    mov       r8,	16384
    call      mlib.readlinen
    mov       rcx,	[msys.rd_buffer]
    call      strlen
    mov       [msys.rd_length],	rax
    mov       rax,	[msys.rd_buffer]
    mov       [msys.rd_pos],	rax
    xor       eax,	eax
    mov       [msys.rd_lastpos],	rax
L306:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc msys.m$read_strline
msys.m$read_strline:
;?>>
   %define R.s rbx
   %define R.n rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    call      msys.initreadbuffer
    mov       rcx,	rbx
    call      strlen
    mov       rdi,	rax
    cmp       rdi,	16384
    jge       L311
    mov       rcx,	[msys.rd_buffer]
    mov       rdx,	rbx
    call      strcpy
    jmp       L310
L311:
    mov       rcx,	[msys.rd_buffer]
    mov       rdx,	rbx
    mov       r8,	16383
    call      memcpy
    mov       rax,	[msys.rd_buffer]
    lea       rax,	[rax+16384]
    sub       rax,	1
    xor       r10d,	r10d
    mov       [rax],	r10b
L310:
    mov       [msys.rd_length],	rdi
    mov       rax,	[msys.rd_buffer]
    mov       [msys.rd_pos],	rax
    xor       eax,	eax
    mov       [msys.rd_lastpos],	rax
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.readitem
msys.readitem:
;?>>
   %define R.itemlength r14
   %define R.p rdi
   %define R.s rbx
   %define R.itemstr rsi
   %define R.quotechar r12b
   %define R.c r13b
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       r14,	rcx
;---------------
    mov       rax,	[msys.rd_buffer]
    test      rax,	rax
    jnz       L314
    call      msys.initreadbuffer
L314:
    mov       rbx,	[msys.rd_pos]
    jmp       L316
L315:
    inc       rbx
L316:
    movzx     rax,	byte [rbx]
    cmp       rax,	32
    jz        L315
    movzx     rax,	byte [rbx]
    cmp       rax,	9
    jz        L315
    mov       rsi,	rbx
    mov       rax,	rbx
    mov       [msys.rd_pos],	rax
    mov       [msys.rd_lastpos],	rax
    movzx     rax,	byte [rbx]
    test      rax,	rax
    jnz       L319
    xor       eax,	eax
    mov       [msys.termchar],	rax
    xor       eax,	eax
    mov       [r14],	rax
    mov       rax,	rbx
    jmp       L312
L319:
    xor       r12b,	r12b
    movzx     rax,	byte [rbx]
    cmp       rax,	34
    jnz       L321
    mov       r12b,	34
    inc       rbx
    jmp       L320
L321:
    movzx     rax,	byte [rbx]
    cmp       rax,	39
    jnz       L322
    mov       r12b,	39
    inc       rbx
L322:
L320:
    mov       rax,	rbx
    mov       rsi,	rax
    mov       rdi,	rax
    jmp       L324
L323:
    mov       rax,	rbx
    inc       rbx
    mov       r13b,	[rax]
    movzx     rax,	r13b
    cmp       rax,	32
    jz        L327
    cmp       rax,	9
    jz        L327
    cmp       rax,	44
    jz        L327
    cmp       rax,	61
    jnz       L328
L327:
    test      r12b,	r12b
    jnz       L331
    cmp       rdi,	rbx
    jnz       L330
L331:
    jmp       L332
L330:
    movzx     rax,	r13b
    mov       [msys.termchar],	rax
    jmp       L325
L328:
;msys.readitem.normalchar:
L332:
    movzx     rax,	r13b
    movzx     r10,	r12b
    cmp       rax,	r10
    jnz       L334
    movzx     rax,	byte [rbx]
    movzx     r10,	r12b
    cmp       rax,	r10
    jnz       L336
    mov       [rdi],	r13b
    inc       rbx
    inc       rdi
    jmp       L335
L336:
    movzx     rax,	byte [rbx]
    mov       [msys.termchar],	rax
    mov       rax,	[msys.termchar]
    cmp       rax,	44
    jz        L339
    cmp       rax,	61
    jnz       L338
L339:
    inc       rbx
    movzx     rax,	byte [rbx]
    mov       [msys.termchar],	rax
L338:
    jmp       L325
L335:
    jmp       L333
L334:
    mov       [rdi],	r13b
    inc       rdi
L333:
L326:
L324:
    mov       al,	[rbx]
    test      al,	al
    jnz       L323
L325:
    movzx     rax,	byte [rbx]
    test      rax,	rax
    jnz       L341
    xor       eax,	eax
    mov       [msys.termchar],	rax
L341:
    mov       rax,	rdi
    sub       rax,	rsi
    mov       [r14],	rax
    mov       [msys.rd_pos],	rbx
    mov       rax,	rsi
L312:
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.strtoint
msys.strtoint:
;?>>
   %define R.s r13
   %define R.length r14
   %define R.base r15
   %define R.signd dil
   %define R.aa rbx
   %define R.c rsi
   %define R.d r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    sub       rsp,	48
    mov       r13,	rcx
    mov       r14,	rdx
    mov       r15,	r8
;---------------
    xor       eax,	eax
    mov       [msys.itemerror],	rax
    cmp       r14,	-1
    jnz       L344
    mov       rcx,	r13
    call      strlen
    mov       r14,	rax
L344:
    xor       dil,	dil
    mov       rax,	r14
    test      rax,	rax
    jz        L346
    movzx     rax,	byte [r13]
    cmp       rax,	45
    jnz       L346
    mov       dil,	1
    inc       r13
    dec       r14
    jmp       L345
L346:
    test      r14,	r14
    jz        L347
    movzx     rax,	byte [r13]
    cmp       rax,	43
    jnz       L347
    inc       r13
    dec       r14
L347:
L345:
    xor       rbx,	rbx
    jmp       L349
L348:
    mov       rax,	r13
    inc       r13
    movzx     rax,	byte [rax]
    mov       rsi,	rax
    dec       r14
    mov       rax,	rsi
    cmp       rax,	65
    jl        L352
    cmp       rax,	70
    jg        L352
    lea       rax,	[rsi-65]
    add       rax,	10
    mov       r12,	rax
    jmp       L351
L352:
    mov       rax,	rsi
    cmp       rax,	97
    jl        L353
    cmp       rax,	102
    jg        L353
    lea       rax,	[rsi-97]
    add       rax,	10
    mov       r12,	rax
    jmp       L351
L353:
    mov       rax,	rsi
    cmp       rax,	48
    jl        L354
    cmp       rax,	57
    jg        L354
    lea       rax,	[rsi-48]
    mov       r12,	rax
    jmp       L351
L354:
    mov       rax,	rsi
    cmp       rax,	95
    jz        L356
    cmp       rax,	39
    jnz       L355
L356:
    jmp       L349
L355:
    mov       rax,	1
    mov       [msys.itemerror],	rax
    jmp       L350
L351:
    cmp       r12,	r15
    jb        L358
    mov       rax,	1
    mov       [msys.itemerror],	rax
    jmp       L350
L358:
    mov       rax,	rbx
    imul      rax,	r15
    add       rax,	r12
    mov       rbx,	rax
L349:
    test      r14,	r14
    jnz       L348
L350:
    test      dil,	dil
    jz        L360
    mov       rax,	rbx
    neg       rax
    jmp       L359
L360:
    mov       rax,	rbx
L359:
L342:
;---------------
    add       rsp,	48
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.m$read_i64
msys.m$read_i64:
;?>>
   %define R.fmt rbx
   %define R.s rdi
    %define msys.m$read_i64.length -8
    push      rdi
    push      rbx
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       rbx,	rcx
;---------------
    mov       rcx,	rbx
    call      toupper
    movsxd    r10,	eax
    mov       rbx,	r10
    mov       rax,	rbx
    cmp       rax,	67
    jz        L363
    cmp       rax,	84
    jz        L364
    cmp       rax,	69
    jz        L365
    jmp       L366
L363:
    mov       rax,	[msys.rd_pos]
    mov       [msys.rd_lastpos],	rax
    mov       rax,	[msys.rd_pos]
    mov       al,	[rax]
    test      al,	al
    jz        L368
    mov       rax,	[msys.rd_pos]
    inc       qword [msys.rd_pos]
    movzx     rax,	byte [rax]
    jmp       L361
L368:
    xor       eax,	eax
    jmp       L361
L367:
    jmp       L362
L364:
    mov       rax,	[msys.termchar]
    jmp       L361
L365:
    mov       rax,	[msys.itemerror]
    jmp       L361
L366:
L362:
    lea       rcx,	[rbp + msys.m$read_i64.length]
    call      msys.readitem
    mov       rdi,	rax
    mov       rax,	rbx
    test      rax,	rax
    jz        L370
    cmp       rax,	73
    jz        L370
    cmp       rax,	66
    jz        L371
    cmp       rax,	72
    jz        L372
    jmp       L373
L370:
    mov       rcx,	rdi
    mov       rdx,	[rbp + msys.m$read_i64.length]
    mov       r8,	10
    call      msys.strtoint
    jmp       L361
L371:
    mov       rcx,	rdi
    mov       rdx,	[rbp + msys.m$read_i64.length]
    mov       r8,	2
    call      msys.strtoint
    jmp       L361
L372:
    mov       rcx,	rdi
    mov       rdx,	[rbp + msys.m$read_i64.length]
    mov       r8,	16
    call      msys.strtoint
    jmp       L361
L373:
L369:
    xor       eax,	eax
L361:
;---------------
    add       rsp,	48
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.m$read_r64
msys.m$read_r64:
;?>>
    %define msys.m$read_r64.fmt 24
    %define msys.m$read_r64.str -512
   %define R.s rdi
    %define msys.m$read_r64.length -520
    %define msys.m$read_r64.numlength -528
    %define msys.m$read_r64.x -536
    push      rdi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	568
;---------------
    lea       rcx,	[rbp + msys.m$read_r64.length]
    call      msys.readitem
    mov       rdi,	rax
    mov       rax,	[rbp + msys.m$read_r64.length]
    test      rax,	rax
    jz        L377
    mov       rax,	[rbp + msys.m$read_r64.length]
    cmp       rax,	512
    jl        L376
L377:
    movq      XMM0,	[L12085]
    jmp       L374
L376:
    lea       rcx,	[rbp + msys.m$read_r64.str]
    mov       rdx,	rdi
    mov       r8,	[rbp + msys.m$read_r64.length]
    call      memcpy
    xor       eax,	eax
    mov       r10,	[rbp + msys.m$read_r64.length]
    mov       [rbp + r10 + msys.m$read_r64.str],	al
    xor       eax,	eax
    mov       [msys.itemerror],	rax
    lea       rcx,	[rbp + msys.m$read_r64.str]
    lea       rdx,	[L12086]
    lea       r8,	[rbp + msys.m$read_r64.x]
    lea       r9,	[rbp + msys.m$read_r64.numlength]
    call      sscanf
    movsxd    r10,	eax
    test      r10,	r10
    jz        L380
    movsxd    rax,	dword [rbp + msys.m$read_r64.numlength]
    cmp       rax,	[rbp + msys.m$read_r64.length]
    jz        L379
L380:
    movq      XMM4,	[L12087]
    movq      [rbp + msys.m$read_r64.x],	XMM4
    mov       rax,	1
    mov       [msys.itemerror],	rax
L379:
    movq      XMM0,	[rbp + msys.m$read_r64.x]
L374:
;---------------
    add       rsp,	568
    pop       rbp
    pop       rdi
    ret       
;End 
;Proc msys.m$read_str
msys.m$read_str:
;?>>
   %define R.dest rbx
   %define R.destlen rsi
   %define R.fmt r12
   %define R.s rdi
    %define msys.m$read_str.length -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
;---------------
    xor       eax,	eax
    mov       [msys.itemerror],	rax
    mov       rax,	r12
    cmp       rax,	76
    jz        L384
    cmp       rax,	108
    jnz       L383
L384:
    mov       rdi,	[msys.rd_pos]
    mov       rax,	[msys.rd_buffer]
    mov       r10,	[msys.rd_length]
    lea       rax,	[rax + r10]
    sub       rax,	[msys.rd_pos]
    mov       [rbp + msys.m$read_str.length],	rax
    jmp       L382
L383:
    lea       rcx,	[rbp + msys.m$read_str.length]
    call      msys.readitem
    mov       rdi,	rax
    mov       rax,	r12
    cmp       rax,	78
    jz        L387
    cmp       rax,	110
    jnz       L386
L387:
    mov       rcx,	rdi
    mov       rdx,	[rbp + msys.m$read_str.length]
    call      mlib.iconvlcn
L386:
L382:
    cmp       rsi,	0
    jle       L389
    mov       rax,	[rbp + msys.m$read_str.length]
    cmp       rax,	rsi
    jl        L391
    lea       rax,	[rsi-1]
    mov       [rbp + msys.m$read_str.length],	rax
    mov       rax,	1
    mov       [msys.itemerror],	rax
L391:
L389:
    mov       rcx,	rbx
    mov       rdx,	rdi
    mov       r8,	[rbp + msys.m$read_str.length]
    call      memcpy
    xor       eax,	eax
    mov       r10,	[rbp + msys.m$read_str.length]
    mov       [rbx + r10],	al
;---------------
    add       rsp,	48
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.readstr
msys.readstr:
;?>>
   %define R.dest rdi
   %define R.fmt rbx
   %define R.destlen rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    mov       rcx,	rdi
    mov       rdx,	rsi
    mov       r8,	rbx
    call      msys.m$read_str
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.rereadln
msys.rereadln:
;?>>
;?]]
;---------------
    mov       rax,	[msys.rd_buffer]
    mov       [msys.rd_pos],	rax
    mov       rax,	[msys.rd_pos]
    mov       [msys.rd_lastpos],	rax
;---------------
    ret       
;End 
;Proc msys.reread
msys.reread:
;?>>
;?]]
;---------------
    mov       rax,	[msys.rd_lastpos]
    mov       [msys.rd_pos],	rax
;---------------
    ret       
;End 
;Proc msys.valint
msys.valint:
;?>>
   %define R.s r12
   %define R.fmt r13
   %define R.old_pos rdi
   %define R.old_lastpos rbx
   %define R.aa rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r12,	rcx
    mov       r13,	rdx
;---------------
    call      msys.initreadbuffer
    mov       rdi,	[msys.rd_pos]
    mov       rbx,	[msys.rd_lastpos]
    mov       [msys.rd_pos],	r12
    mov       rcx,	r13
    call      msys.m$read_i64
    mov       rsi,	rax
    mov       [msys.rd_pos],	rdi
    mov       [msys.rd_lastpos],	rbx
    mov       rax,	rsi
L395:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.valreal
msys.valreal:
;?>>
   %define R.s rsi
   %define R.old_pos rdi
   %define R.old_lastpos rbx
   %define R.x XMM15
    push      rdi
    push      rbx
    push      rsi
    movq      rax,	XMM15
    push      rax
;?]]
    sub       rsp,	40
    mov       rsi,	rcx
;---------------
    call      msys.initreadbuffer
    mov       rdi,	[msys.rd_pos]
    mov       rbx,	[msys.rd_lastpos]
    mov       [msys.rd_pos],	rsi
    xor       ecx,	ecx
    call      msys.m$read_r64
    movq      XMM15,	XMM0
    mov       [msys.rd_pos],	rdi
    mov       [msys.rd_lastpos],	rbx
    movq      XMM0,	XMM15
L396:
;---------------
    add       rsp,	40
    pop       rcx
    movq      XMM15,	rcx
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.mclunimpl
msys.mclunimpl:
;?>>
   %define R.mess rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    lea       rcx,	[L12088]
    mov       rdx,	rdi
    call      printf
    mov       rcx,	1
    call      exit
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc msys.dumpstr
msys.dumpstr:
;?>>
   %define R.s rbx
   %define R.n rsi
   %define R.fbuffer r12
   %define R.p rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
;---------------
    mov       rax,	[msys.outdev]
    cmp       rax,	3
    jnz       L400
    mov       rdi,	[msys.outchan]
    test      rsi,	rsi
    jz        L402
    mov       rax,	[rdi]
    mov       rcx,	rax
    mov       rdx,	rbx
    mov       r8,	rsi
    call      memcpy
    mov       rax,	rdi
    mov       r10,	rsi
    add       [rax],	r10
L402:
    mov       rax,	[rdi]
    xor       r10d,	r10d
    mov       [rax],	r10b
    jmp       L398
L400:
    test      rsi,	rsi
    jnz       L404
    jmp       L398
L404:
    test      r12,	r12
    jz        L406
    cmp       rsi,	2
    jl        L406
    mov       rax,	[msys.outdev]
    cmp       rax,	1
    jnz       L406
    dec       qword [msys.printptr]
    mov       rax,	[msys.printptr]
    movzx     rax,	byte [rax]
    cmp       rax,	10
    jnz       L408
    mov       rax,	[msys.printptr]
    sub       rax,	1
    movzx     rax,	byte [rax]
    cmp       rax,	13
    jnz       L410
    mov       rax,	[msys.printptr]
    sub       rax,	1
    xor       r10d,	r10d
    mov       [rax],	r10b
    jmp       L409
L410:
    xor       eax,	eax
    mov       r10,	[msys.printptr]
    mov       [r10],	al
L409:
    lea       rcx,	[msys.printbuffer]
    call      puts
    jmp       L398
L408:
L406:
    mov       rax,	[msys.outdev]
    cmp       rax,	1
    jz        L412
    cmp       rax,	2
    jz        L413
    jmp       L414
L412:
    lea       rcx,	[L12089]
    mov       rdx,	rsi
    mov       r8,	rbx
    call      printf
    jmp       L411
L413:
    mov       rcx,	[msys.outchan]
    lea       rdx,	[L12089]
    mov       r8,	rsi
    mov       r9,	rbx
    call      fprintf
L414:
L411:
L398:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.dumpprintbuffer
msys.dumpprintbuffer:
;?>>
;?]]
    sub       rsp,	40
;---------------
    mov       rax,	[msys.printlen]
    test      rax,	rax
    jz        L417
    lea       rcx,	[msys.printbuffer]
    mov       rdx,	[msys.printlen]
    mov       r8,	1
    call      msys.dumpstr
L417:
    call      msys.resetprintbuffer
;---------------
    add       rsp,	40
    ret       
;End 
;Proc msys.resetprintbuffer
msys.resetprintbuffer:
;?>>
;?]]
;---------------
    lea       rax,	[msys.printbuffer]
    mov       [msys.printptr],	rax
    xor       eax,	eax
    mov       [msys.printlen],	rax
;---------------
    ret       
;End 
;Proc msys.addtobuffer
msys.addtobuffer:
;?>>
   %define R.s rdi
   %define R.n rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rax,	[msys.printlen]
    add       rax,	rbx
    cmp       rax,	4088
    jl        L421
    call      msys.dumpprintbuffer
L421:
    cmp       rbx,	4096
    jge       L423
    mov       rcx,	[msys.printptr]
    mov       rdx,	rdi
    mov       r8,	rbx
    call      memcpy
    mov       rax,	rbx
    add       [msys.printptr],	rax
    mov       rax,	rbx
    add       [msys.printlen],	rax
    jmp       L419
L423:
    mov       rcx,	rdi
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      msys.dumpstr
L419:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.m$power_i64
msys.m$power_i64:
;?>>
   %define R.a rdi
   %define R.n rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    cmp       rbx,	0
    jge       L426
    xor       eax,	eax
    jmp       L425
L426:
    test      rbx,	rbx
    jnz       L427
    mov       rax,	1
    jmp       L425
L427:
    cmp       rbx,	1
    jnz       L428
    mov       rax,	rdi
    jmp       L425
L428:
    mov       rax,	rbx
    and       rax,	1
    jnz       L429
    mov       rax,	rbx
    sar       rax,	1
    mov       r10,	rdi
    imul      r10,	r10
    mov       rcx,	r10
    mov       rdx,	rax
    call      msys.m$power_i64
    jmp       L425
L429:
    lea       rax,	[rbx-1]
    sar       rax,	1
    mov       r10,	rdi
    imul      r10,	r10
    mov       rcx,	r10
    mov       rdx,	rax
    call      msys.m$power_i64
    imul      rax,	rdi
L425:
L424:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msys.getutfsize
msys.getutfsize:
;?>>
   %define R.s rcx
   %define R.a rdi
    push      rdi
;?]]
    sub       rsp,	16
;---------------
    mov       rax,	rcx
    inc       rcx
    movzx     rax,	byte [rax]
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L432
    xor       eax,	eax
    jmp       L431
L432:
    mov       eax,	edi
    shr       eax,	7
    and       eax,	1
    test      rax,	rax
    jnz       L433
    mov       rax,	1
    jmp       L431
L433:
    mov       rax,	rdi
    shr       rax,	5
    and       rax,	7
    cmp       rax,	6
    jnz       L434
    mov       rax,	2
    jmp       L431
L434:
    mov       rax,	rdi
    shr       rax,	4
    and       rax,	15
    cmp       rax,	14
    jnz       L435
    mov       rax,	3
    jmp       L431
L435:
    mov       rax,	rdi
    shr       rax,	3
    and       rax,	31
    cmp       rax,	30
    jnz       L436
    mov       rax,	4
    jmp       L431
L436:
    mov       rax,	1
L431:
L430:
;---------------
    add       rsp,	16
    pop       rdi
    ret       
;End 
;Proc msys.m$sign_i64
msys.m$sign_i64:
;?>>
   %define R.a rcx
;?]]
;---------------
    cmp       rcx,	0
    jge       L439
    mov       rax,	-1
    jmp       L438
L439:
    cmp       rcx,	0
    jle       L441
    mov       rax,	1
    jmp       L440
L441:
    xor       eax,	eax
L440:
L438:
L437:
;---------------
    ret       
;End 
;Proc msys.m$sign_r64
msys.m$sign_r64:
;?>>
   %define R.x XMM0
;?]]
;---------------
    movq      XMM4,	XMM0
    comisd    XMM4,	[L12090]
    jae       L444
    movq      XMM0,	[L12091]
    jmp       L442
L444:
    movq      XMM4,	XMM0
    comisd    XMM4,	[L12092]
    jbe       L446
    movq      XMM0,	[L12093]
    jmp       L442
L446:
    movq      XMM0,	[L12094]
L442:
;---------------
    ret       
;End 
;Proc mlib.pcm_alloc
mlib.pcm_alloc:
;?>>
   %define R.n rbx
   %define R.p rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       al,	[mlib.pcm_setup]
    test      al,	al
    jnz       L449
    call      mlib.pcm_init
L449:
    cmp       rbx,	2048
    jle       L451
    mov       rcx,	rbx
    call      mlib.pcm_getac
    mov       [mlib.alloccode],	rax
    lea       rax,	[mlib.allocupper]
    mov       r10,	[mlib.alloccode]
    mov       rax,	[rax + r10*8]
    mov       [mlib.allocbytes],	rax
    mov       rcx,	[mlib.allocbytes]
    call      mlib.allocmem
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L453
    lea       rcx,	[L12095]
    call      mlib.abortprogram
L453:
    mov       rax,	rdi
    jmp       L447
L451:
    lea       rax,	[mlib.sizeindextable]
    mov       r10,	rbx
    movzx     rax,	byte [rax + r10]
    mov       [mlib.alloccode],	rax
    lea       rax,	[mlib.allocupper]
    mov       r10,	[mlib.alloccode]
    mov       rax,	[rax + r10*8]
    mov       [mlib.allocbytes],	rax
    lea       rax,	[mlib.freelist]
    mov       r10,	[mlib.alloccode]
    mov       rax,	[rax + r10*8]
    mov       rdi,	rax
    test      rax,	rax
    jz        L455
    lea       rax,	[mlib.freelist]
    mov       r10,	[mlib.alloccode]
    mov       rax,	[rax + r10*8]
    mov       rax,	[rax]
    lea       r10,	[mlib.freelist]
    mov       r11,	[mlib.alloccode]
    mov       [r10 + r11*8],	rax
    mov       rax,	rdi
    jmp       L447
L455:
    mov       rdi,	[mlib.pcheapptr]
    mov       rax,	[mlib.allocbytes]
    add       [mlib.pcheapptr],	rax
    mov       rax,	[mlib.pcheapptr]
    cmp       rax,	[mlib.pcheapend]
    jb        L457
    mov       rcx,	[mlib.allocbytes]
    call      mlib.pcm_newblock
    mov       rdi,	rax
    mov       rax,	rdi
    jmp       L447
L457:
    mov       rax,	rdi
L447:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.pcm_free
mlib.pcm_free:
;?>>
   %define R.p rbx
   %define R.n rsi
   %define R.acode rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    test      rsi,	rsi
    jz        L461
    test      rbx,	rbx
    jnz       L460
L461:
    jmp       L458
L460:
    cmp       rsi,	2048
    jle       L463
    mov       rcx,	rbx
    call      free
    jmp       L462
L463:
    lea       rax,	[mlib.sizeindextable]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10]
    mov       rdi,	rax
    lea       rax,	[mlib.freelist]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8]
    mov       [rbx],	rax
    mov       rax,	rbx
    lea       r10,	[mlib.freelist]
    mov       r11,	rdi
    mov       [r10 + r11*8],	rax
L462:
L458:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.pcm_freeac
mlib.pcm_freeac:
;?>>
   %define R.p rdi
   %define R.alloc rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    lea       rax,	[mlib.allocupper]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.pcm_free
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.pcm_clearmem
mlib.pcm_clearmem:
;?>>
   %define R.p rdi
   %define R.n rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rdi
    xor       edx,	edx
    mov       r8,	rbx
    call      memset
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.pcm_init
mlib.pcm_init:
;?>>
   %define R.j rdi
   %define R.k rbx
   %define R.size rsi
   %define R.av_1 r12
   %define R.i r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
;---------------
    xor       eax,	eax
    mov       [mlib.alloccode],	rax
    mov       al,	[mlib.pcm_setup]
    test      al,	al
    jnz       L466
L468:
    xor       ecx,	ecx
    call      mlib.pcm_newblock
    mov       r13,	1
L469:
    mov       rdi,	1
    mov       rbx,	16
    jmp       L473
L472:
    mov       rax,	rbx
    shl       rax,	1
    mov       rbx,	rax
    inc       rdi
L473:
    cmp       r13,	rbx
    jg        L472
    mov       al,	dil
    lea       r10,	[mlib.sizeindextable]
    mov       r11,	r13
    mov       [r10 + r11],	al
    inc       r13
    cmp       r13,	2048
    jle       L469
    mov       rax,	16
    lea       r10,	[mlib.allocupper]
    mov       [r10+8],	rax
    mov       rsi,	16
    mov       r13,	2
L475:
    mov       rax,	rsi
    shl       rax,	1
    mov       rsi,	rax
    mov       rax,	rsi
    lea       r10,	[mlib.allocupper]
    mov       r11,	r13
    mov       [r10 + r11*8],	rax
    cmp       rsi,	33554432
    jl        L479
    mov       rbx,	r13
    jmp       L477
L479:
    inc       r13
    cmp       r13,	27
    jle       L475
L477:
    lea       rax,	[rbx+1]
    mov       r13,	rax
    mov       r12,	300
    cmp       r13,	r12
    jg        L482
L480:
    mov       rax,	33554432
    add       rsi,	rax
    mov       rax,	rsi
    mov       r10,	8589934592
    cmp       rax,	r10
    jge       L484
    mov       rax,	rsi
    lea       r10,	[mlib.allocupper]
    mov       r11,	r13
    mov       [r10 + r11*8],	rax
    mov       [mlib.maxmemory],	rsi
    jmp       L483
L484:
    lea       rax,	[r13-1]
    mov       [mlib.maxalloccode],	rax
    jmp       L482
L483:
    inc       r13
    cmp       r13,	r12
    jle       L480
L482:
    mov       al,	1
    mov       [mlib.pcm_setup],	al
L466:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.pcm_getac
mlib.pcm_getac:
;?>>
   %define R.size rcx
;?]]
;---------------
    cmp       rcx,	2048
    jg        L487
    lea       rax,	[mlib.sizeindextable]
    mov       r10,	rcx
    movzx     rax,	byte [rax + r10]
    jmp       L485
L487:
    lea       rax,	[rcx+255]
    sar       rax,	8
    mov       rcx,	rax
    cmp       rcx,	2048
    jg        L489
    lea       rax,	[mlib.sizeindextable]
    mov       r10,	rcx
    movzx     rax,	byte [rax + r10]
    add       rax,	8
    jmp       L485
L489:
    lea       rax,	[rcx+63]
    sar       rax,	6
    mov       rcx,	rax
    cmp       rcx,	2048
    jg        L491
    lea       rax,	[mlib.sizeindextable]
    mov       r10,	rcx
    movzx     rax,	byte [rax + r10]
    add       rax,	14
    jmp       L485
L491:
    lea       rax,	[rcx-2048]
    add       rax,	2047
    sar       rax,	11
    add       rax,	22
    mov       rcx,	rax
    mov       rax,	rcx
L485:
;---------------
    ret       
;End 
;Proc mlib.pcm_newblock
mlib.pcm_newblock:
;?>>
   %define R.itemsize rbx
   %define R.p rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rax,	2097152
    add       [mlib.pcm_newblock.totalheapsize],	rax
    xor       eax,	eax
    mov       [mlib.alloccode],	rax
    mov       rcx,	2097152
    call      mlib.allocmem
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L494
    lea       rcx,	[L12096]
    call      mlib.abortprogram
L494:
    mov       rcx,	rdi
    xor       edx,	edx
    mov       r8,	2097152
    call      memset
    mov       [mlib.pcheapptr],	rdi
    lea       rax,	[rdi+2097152]
    mov       [mlib.pcheapend],	rax
    mov       rax,	[mlib.pcheapstart]
    test      rax,	rax
    jnz       L496
    mov       [mlib.pcheapstart],	rdi
L496:
    mov       rax,	rbx
    add       [mlib.pcheapptr],	rax
    mov       rax,	rdi
L492:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.pcm_round
mlib.pcm_round:
;?>>
   %define R.n rcx
;?]]
;---------------
    cmp       rcx,	2048
    jle       L499
    mov       rax,	rcx
    jmp       L498
L499:
    lea       rax,	[mlib.sizeindextable]
    mov       r10,	rcx
    movzx     rax,	byte [rax + r10]
    lea       r10,	[mlib.pcm_round.allocbytes]
    movsxd    r10,	dword [r10 + rax*4]
    mov       rax,	r10
L498:
L497:
;---------------
    ret       
;End 
;Proc mlib.pcm_allocz
mlib.pcm_allocz:
;?>>
   %define R.n rbx
   %define R.p rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rcx,	rbx
    call      mlib.pcm_alloc
    mov       rdi,	rax
    mov       rcx,	rdi
    xor       edx,	edx
    mov       r8,	rbx
    call      memset
    mov       rax,	rdi
L500:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.pcm_copyheapstring
mlib.pcm_copyheapstring:
;?>>
   %define R.s rsi
   %define R.q rdi
   %define R.n rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    test      rsi,	rsi
    jnz       L503
    xor       eax,	eax
    jmp       L501
L503:
    mov       rcx,	rsi
    call      strlen
    inc       rax
    mov       rbx,	rax
    mov       rcx,	rbx
    call      mlib.pcm_alloc
    mov       rdi,	rax
    mov       rcx,	rdi
    mov       rdx,	rsi
    mov       r8,	rbx
    call      memcpy
    mov       rax,	rdi
L501:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.pcm_copyheapstringn
mlib.pcm_copyheapstringn:
;?>>
   %define R.s rbx
   %define R.n rsi
   %define R.q rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    test      rbx,	rbx
    jnz       L506
    xor       eax,	eax
    jmp       L504
L506:
    lea       rax,	[rsi+1]
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       rdi,	rax
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	rsi
    call      memcpy
    xor       eax,	eax
    mov       [rdi + rsi],	al
    mov       rax,	rdi
L504:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.pcm_copyheapblock
mlib.pcm_copyheapblock:
;?>>
   %define R.s rbx
   %define R.length rsi
   %define R.q rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    test      rsi,	rsi
    jnz       L509
    xor       eax,	eax
    jmp       L507
L509:
    mov       rcx,	rsi
    call      mlib.pcm_alloc
    mov       rdi,	rax
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	rsi
    call      memcpy
    mov       rax,	rdi
L507:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.allocmem
mlib.allocmem:
;?>>
   %define R.n rbx
   %define R.p rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rcx,	rbx
    call      malloc
    mov       rdi,	rax
    test      rdi,	rdi
    jz        L512
    mov       rax,	rdi
    jmp       L510
L512:
    call      msys.m$print_startcon
    mov       rcx,	rbx
    call      msys.m$print_i64_nf
    mov       rcx,	[mlib.memtotal]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L12097]
    call      mlib.abortprogram
    xor       eax,	eax
L510:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.reallocmem
mlib.reallocmem:
;?>>
   %define R.p rdi
   %define R.n rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      realloc
    mov       rdi,	rax
    test      rdi,	rdi
    jz        L515
    mov       rax,	rdi
    jmp       L513
L515:
    call      msys.m$print_startcon
    mov       rcx,	rbx
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L12098]
    call      mlib.abortprogram
    xor       eax,	eax
L513:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.abortprogram
mlib.abortprogram:
;?>>
   %define R.s rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    call      msys.m$print_startcon
    mov       rcx,	rdi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       rcx,	[L12099]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       rcx,	5
    call      exit
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mlib.getfilesize
mlib.getfilesize:
;?>>
   %define R.handlex rsi
   %define R.p edi
   %define R.size ebx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    mov       rcx,	rsi
    call      ftell
    mov       edi,	eax
    mov       rcx,	rsi
    xor       edx,	edx
    mov       r8,	2
    call      fseek
    mov       rcx,	rsi
    call      ftell
    mov       ebx,	eax
    mov       eax,	edi
    mov       rcx,	rsi
    mov       rdx,	rax
    xor       r8d,	r8d
    call      fseek
    mov       eax,	ebx
L517:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.readrandom
mlib.readrandom:
;?>>
   %define R.handlex rbx
   %define R.memx rsi
   %define R.offset r12
   %define R.size r13
   %define R.a rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
    mov       r13,	r9
;---------------
    mov       rcx,	rbx
    mov       rdx,	r12
    xor       r8d,	r8d
    call      fseek
    mov       rcx,	rsi
    mov       rdx,	1
    mov       r8,	r13
    mov       r9,	rbx
    call      fread
    mov       rdi,	rax
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.writerandom
mlib.writerandom:
;?>>
   %define R.handlex rdi
   %define R.memx rbx
   %define R.offset rsi
   %define R.size r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
    mov       r12,	r9
;---------------
    mov       rcx,	rdi
    mov       rdx,	rsi
    xor       r8d,	r8d
    call      fseek
    mov       rcx,	rbx
    mov       rdx,	1
    mov       r8,	r12
    mov       r9,	rdi
    call      fwrite
L519:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.setfilepos
mlib.setfilepos:
;?>>
   %define R.file rdi
   %define R.offset rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rdi
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      fseek
    movsxd    r10,	eax
    mov       rax,	r10
L520:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.getfilepos
mlib.getfilepos:
;?>>
   %define R.file rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      ftell
    movsxd    r10,	eax
    mov       rax,	r10
L521:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mlib.readfile
mlib.readfile:
;?>>
   %define R.filename r13
   %define R.f rdi
   %define R.size rbx
   %define R.m rsi
   %define R.p r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r13,	rcx
;---------------
    mov       rcx,	r13
    lea       rdx,	[L12100]
    call      fopen
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L524
    xor       eax,	eax
    jmp       L522
L524:
    mov       rcx,	rdi
    call      mlib.getfilesize
    mov       rbx,	rax
    mov       [mlib.rfsize],	rax
    lea       rax,	[rbx+2]
    mov       rcx,	rax
    call      malloc
    mov       rsi,	rax
    test      rsi,	rsi
    jnz       L526
    xor       eax,	eax
    jmp       L522
L526:
    mov       rcx,	rdi
    mov       rdx,	rsi
    xor       r8d,	r8d
    mov       r9,	rbx
    call      mlib.readrandom
    lea       rax,	[rsi + rbx]
    mov       r12,	rax
    xor       eax,	eax
    mov       [r12],	ax
    mov       rcx,	rdi
    call      fclose
    mov       rax,	rsi
L522:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.writefile
mlib.writefile:
;?>>
   %define R.filename rsi
   %define R.data r12
   %define R.size r13
   %define R.f rdi
   %define R.n rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
;---------------
    mov       rcx,	rsi
    lea       rdx,	[L12101]
    call      fopen
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L529
    xor       eax,	eax
    jmp       L527
L529:
    mov       rcx,	rdi
    mov       rdx,	r12
    xor       r8d,	r8d
    mov       r9,	r13
    call      mlib.writerandom
    mov       rbx,	rax
    mov       rcx,	rdi
    call      fclose
    mov       rax,	rbx
L527:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.checkfile
mlib.checkfile:
;?>>
   %define R.file rbx
   %define R.f rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rcx,	rbx
    lea       rdx,	[L12102]
    call      fopen
    mov       rdi,	rax
    test      rax,	rax
    jz        L532
    mov       rcx,	rdi
    call      fclose
    mov       rax,	1
    jmp       L530
L532:
    xor       eax,	eax
L530:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.readlinen
mlib.readlinen:
;?>>
   %define R.handlex r13
   %define R.buffer r14
   %define R.size r15
   %define R.ch rdi
   %define R.p rbx
   %define R.n rsi
   %define R.crseen r12b
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    sub       rsp,	48
    mov       r13,	rcx
    mov       r14,	rdx
    mov       r15,	r8
;---------------
    test      r13,	r13
    jnz       L535
    call      mwindows.os_getstdin
    mov       r13,	rax
L535:
    test      r13,	r13
    jnz       L537
    xor       rsi,	rsi
    mov       rax,	r14
    mov       rbx,	rax
L538:
    call      getchar
    movsxd    r10,	eax
    mov       rdi,	r10
    cmp       rdi,	13
    jz        L542
    cmp       rdi,	10
    jz        L542
    cmp       rdi,	-1
    jnz       L541
L542:
    xor       eax,	eax
    mov       [rbx],	al
    jmp       L533
L541:
    mov       rax,	rbx
    inc       rbx
    mov       r10b,	dil
    mov       [rax],	r10b
    inc       rsi
    lea       rax,	[r15-2]
    mov       r10,	rsi
    cmp       r10,	rax
    jl        L544
    xor       eax,	eax
    mov       [rbx],	al
    jmp       L533
L544:
    jmp       L538
L537:
    xor       eax,	eax
    mov       [r14],	al
    lea       rax,	[r15-2]
    mov       rcx,	r14
    mov       rdx,	rax
    mov       r8,	r13
    call      fgets
    test      rax,	rax
    jz        L533
L546:
    mov       rcx,	r14
    call      strlen
    mov       rsi,	rax
    test      rsi,	rsi
    jnz       L548
    jmp       L533
L548:
    lea       rax,	[r14 + rsi]
    sub       rax,	1
    mov       rbx,	rax
    xor       r12b,	r12b
    jmp       L550
L549:
    movzx     rax,	byte [rbx]
    cmp       rax,	13
    jz        L554
    movzx     rax,	byte [rbx]
    cmp       rax,	10
    jnz       L553
L554:
    mov       r12b,	1
L553:
    mov       rax,	rbx
    dec       rbx
    xor       r10d,	r10d
    mov       [rax],	r10b
L550:
    cmp       rbx,	r14
    jb        L555
    movzx     rax,	byte [rbx]
    cmp       rax,	13
    jz        L549
    movzx     rax,	byte [rbx]
    cmp       rax,	10
    jz        L549
L555:
    test      r12b,	r12b
    jnz       L557
    lea       rax,	[rsi+4]
    cmp       rax,	r15
    jle       L557
    call      msys.m$print_startcon
    mov       rcx,	r15
    call      msys.m$print_i64_nf
    mov       rcx,	rsi
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L12103]
    call      mlib.abortprogram
L557:
L533:
;---------------
    add       rsp,	48
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.iconvlcn
mlib.iconvlcn:
;?>>
   %define R.s rbx
   %define R.n rsi
   %define R.av_1 rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    mov       rdi,	rsi
    cmp       rdi,	0
    jle       L561
L559:
    movzx     rax,	byte [rbx]
    mov       rcx,	rax
    call      tolower
    mov       [rbx],	al
    inc       rbx
    dec       rdi
    jnz       L559
L561:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.iconvucn
mlib.iconvucn:
;?>>
   %define R.s rbx
   %define R.n rsi
   %define R.av_1 rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    mov       rdi,	rsi
    cmp       rdi,	0
    jle       L565
L563:
    movzx     rax,	byte [rbx]
    mov       rcx,	rax
    call      toupper
    mov       [rbx],	al
    inc       rbx
    dec       rdi
    jnz       L563
L565:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.convlcstring
mlib.convlcstring:
;?>>
   %define R.s rbx
   %define R.s0 rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rdi,	rbx
    jmp       L568
L567:
    movzx     rax,	byte [rbx]
    mov       rcx,	rax
    call      tolower
    mov       [rbx],	al
    inc       rbx
L568:
    mov       al,	[rbx]
    test      al,	al
    jnz       L567
    mov       rax,	rdi
L566:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.convucstring
mlib.convucstring:
;?>>
   %define R.s rbx
   %define R.s0 rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rdi,	rbx
    jmp       L572
L571:
    movzx     rax,	byte [rbx]
    mov       rcx,	rax
    call      toupper
    mov       [rbx],	al
    inc       rbx
L572:
    mov       al,	[rbx]
    test      al,	al
    jnz       L571
    mov       rax,	rdi
L570:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.changeext
mlib.changeext:
;?>>
   %define R.s rsi
   %define R.newext r12
    %define mlib.changeext.newext2 -32
   %define R.sext rdi
   %define R.n rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    lea       rax,	[mlib.changeext.newfile]
    mov       rcx,	rax
    mov       rdx,	rsi
    call      strcpy
    movzx     rax,	byte [r12]
    test      rax,	rax
    jz        L576
    cmp       rax,	46
    jz        L577
    jmp       L578
L576:
    xor       eax,	eax
    mov       [rbp + mlib.changeext.newext2],	al
    xor       eax,	eax
    mov       [rbp + mlib.changeext.newext2+1],	al
    jmp       L575
L577:
    lea       rax,	[rbp + mlib.changeext.newext2]
    mov       rcx,	rax
    mov       rdx,	r12
    call      strcpy
    jmp       L575
L578:
    lea       rax,	[rbp + mlib.changeext.newext2]
    mov       rcx,	rax
    lea       rdx,	[L12104]
    call      strcpy
    lea       rax,	[rbp + mlib.changeext.newext2]
    mov       rcx,	rax
    mov       rdx,	r12
    call      strcat
L575:
    mov       rcx,	rsi
    mov       rdx,	1
    call      mlib.extractext
    mov       rdi,	rax
    movzx     rax,	byte [rdi]
    test      rax,	rax
    jz        L580
    cmp       rax,	46
    jz        L581
    jmp       L582
L580:
    lea       rax,	[rbp + mlib.changeext.newext2]
    lea       r10,	[mlib.changeext.newfile]
    mov       rcx,	r10
    mov       rdx,	rax
    call      strcat
    jmp       L579
L581:
    lea       rax,	[rbp + mlib.changeext.newext2+1]
    lea       r10,	[mlib.changeext.newfile]
    mov       rcx,	r10
    mov       rdx,	rax
    call      strcat
    jmp       L579
L582:
    mov       rax,	rdi
    sub       rax,	rsi
    sub       rax,	2
    mov       rbx,	rax
    lea       rax,	[rbp + mlib.changeext.newext2]
    lea       r10,	[mlib.changeext.newfile]
    mov       r11,	rbx
    lea       r10,	[r10 + r11+1]
    mov       rcx,	r10
    mov       rdx,	rax
    call      strcpy
L579:
    lea       rax,	[mlib.changeext.newfile]
L574:
;---------------
    add       rsp,	64
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.extractext
mlib.extractext:
;?>>
   %define R.s rsi
   %define R.period r12
   %define R.t rdi
   %define R.u rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    mov       rcx,	rsi
    call      mlib.extractfile
    mov       rdi,	rax
    movzx     rax,	byte [rdi]
    test      rax,	rax
    jnz       L585
    lea       rax,	[L12105]
    jmp       L583
L585:
    mov       rcx,	rdi
    call      strlen
    lea       r10,	[rdi + rax]
    sub       r10,	1
    mov       rbx,	r10
    jmp       L587
L586:
    movzx     rax,	byte [rbx]
    cmp       rax,	46
    jnz       L590
    movzx     rax,	byte [rbx+1]
    test      rax,	rax
    jnz       L592
    test      r12,	r12
    jz        L594
    lea       rax,	[L12106]
    jmp       L593
L594:
    lea       rax,	[L12107]
L593:
    jmp       L583
L592:
    lea       rax,	[rbx+1]
    jmp       L583
L590:
    dec       rbx
L587:
    cmp       rbx,	rdi
    jae       L586
    lea       rax,	[L12107]
L583:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.extractpath
mlib.extractpath:
;?>>
   %define R.s rsi
   %define R.t rdi
   %define R.n rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    mov       rcx,	rsi
    call      strlen
    lea       r10,	[rsi + rax]
    sub       r10,	1
    mov       rdi,	r10
    jmp       L597
L596:
    movzx     rax,	byte [rdi]
    cmp       rax,	92
    jz        L600
    cmp       rax,	47
    jz        L600
    cmp       rax,	58
    jnz       L601
L600:
    mov       rax,	rdi
    sub       rax,	rsi
    inc       rax
    mov       rbx,	rax
    lea       rcx,	[mlib.extractpath.str]
    mov       rdx,	rsi
    mov       r8,	rbx
    call      memcpy
    xor       eax,	eax
    lea       r10,	[mlib.extractpath.str]
    mov       r11,	rbx
    mov       [r10 + r11],	al
    lea       rax,	[mlib.extractpath.str]
    jmp       L595
L601:
L599:
    dec       rdi
L597:
    cmp       rdi,	rsi
    jae       L596
    lea       rax,	[L12107]
L595:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.extractfile
mlib.extractfile:
;?>>
   %define R.s rbx
   %define R.t rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rcx,	rbx
    call      mlib.extractpath
    mov       rdi,	rax
    movzx     rax,	byte [rdi]
    test      rax,	rax
    jnz       L604
    mov       rax,	rbx
    jmp       L602
L604:
    mov       rcx,	rdi
    call      strlen
    lea       r10,	[rbx + rax]
    mov       rax,	r10
L602:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.extractbasefile
mlib.extractbasefile:
;?>>
   %define R.s r13
   %define R.f rdi
   %define R.e rbx
   %define R.n rsi
   %define R.flen r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r13,	rcx
;---------------
    mov       rcx,	r13
    call      mlib.extractfile
    mov       rdi,	rax
    mov       rcx,	rdi
    call      strlen
    mov       r12,	rax
    test      r12,	r12
    jnz       L607
    lea       rax,	[L12107]
    jmp       L605
L607:
    mov       rcx,	rdi
    xor       edx,	edx
    call      mlib.extractext
    mov       rbx,	rax
    mov       al,	[rbx]
    test      al,	al
    jz        L609
    mov       rcx,	rbx
    call      strlen
    mov       r10,	r12
    sub       r10,	rax
    dec       r10
    mov       rsi,	r10
    lea       rcx,	[mlib.extractbasefile.str]
    mov       rdx,	rdi
    mov       r8,	rsi
    call      memcpy
    xor       eax,	eax
    lea       r10,	[mlib.extractbasefile.str]
    mov       r11,	rsi
    mov       [r10 + r11],	al
    lea       rax,	[mlib.extractbasefile.str]
    jmp       L605
L609:
    lea       rax,	[rdi + r12]
    sub       rax,	1
    movzx     rax,	byte [rax]
    cmp       rax,	46
    jnz       L611
    lea       rax,	[r12-1]
    lea       rcx,	[mlib.extractbasefile.str]
    mov       rdx,	rdi
    mov       r8,	rax
    call      memcpy
    xor       eax,	eax
    lea       r10,	[mlib.extractbasefile.str]
    mov       r11,	r12
    mov       [r10 + r11-1],	al
    lea       rax,	[mlib.extractbasefile.str]
    jmp       L605
L611:
    mov       rax,	rdi
L605:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.addext
mlib.addext:
;?>>
   %define R.s rbx
   %define R.newext rsi
   %define R.sext rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    mov       rcx,	rbx
    mov       rdx,	1
    call      mlib.extractext
    mov       rdi,	rax
    movzx     rax,	byte [rdi]
    test      rax,	rax
    jnz       L614
    mov       rcx,	rbx
    mov       rdx,	rsi
    call      mlib.changeext
    jmp       L612
L614:
    mov       rax,	rbx
L612:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.pcm_alloc32
mlib.pcm_alloc32:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
;---------------
    mov       rax,	32
    mov       [mlib.allocbytes],	rax
    lea       rax,	[mlib.freelist]
    mov       rax,	[rax+16]
    mov       rdi,	rax
    test      rax,	rax
    jz        L617
    lea       rax,	[mlib.freelist]
    mov       rax,	[rax+16]
    mov       rax,	[rax]
    lea       r10,	[mlib.freelist]
    mov       [r10+16],	rax
    mov       rax,	rdi
    jmp       L615
L617:
    mov       rcx,	32
    call      mlib.pcm_alloc
L615:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mlib.pcm_free32
mlib.pcm_free32:
;?>>
   %define R.p rcx
;?]]
;---------------
    lea       rax,	[mlib.freelist]
    mov       rax,	[rax+16]
    mov       [rcx],	rax
    mov       rax,	rcx
    lea       r10,	[mlib.freelist]
    mov       [r10+16],	rax
;---------------
    ret       
;End 
;Proc mlib.outbyte
mlib.outbyte:
;?>>
   %define R.f rdi
    %define mlib.outbyte.x 32
    push      rdi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       rdi,	rcx
    mov       [rbp+32],	rdx
;---------------
    lea       rcx,	[rbp + mlib.outbyte.x]
    mov       rdx,	1
    mov       r8,	1
    mov       r9,	rdi
    call      fwrite
;---------------
    add       rsp,	40
    pop       rbp
    pop       rdi
    ret       
;End 
;Proc mlib.outu16
mlib.outu16:
;?>>
   %define R.f rdi
    %define mlib.outu16.x 32
    push      rdi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       rdi,	rcx
    mov       [rbp+32],	rdx
;---------------
    lea       rcx,	[rbp + mlib.outu16.x]
    mov       rdx,	2
    mov       r8,	1
    mov       r9,	rdi
    call      fwrite
;---------------
    add       rsp,	40
    pop       rbp
    pop       rdi
    ret       
;End 
;Proc mlib.outu32
mlib.outu32:
;?>>
   %define R.f rdi
    %define mlib.outu32.x 32
    push      rdi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       rdi,	rcx
    mov       [rbp+32],	rdx
;---------------
    lea       rcx,	[rbp + mlib.outu32.x]
    mov       rdx,	4
    mov       r8,	1
    mov       r9,	rdi
    call      fwrite
;---------------
    add       rsp,	40
    pop       rbp
    pop       rdi
    ret       
;End 
;Proc mlib.outu64
mlib.outu64:
;?>>
   %define R.f rdi
    %define mlib.outu64.x 32
    push      rdi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       rdi,	rcx
    mov       [rbp+32],	rdx
;---------------
    lea       rcx,	[rbp + mlib.outu64.x]
    mov       rdx,	8
    mov       r8,	1
    mov       r9,	rdi
    call      fwrite
;---------------
    add       rsp,	40
    pop       rbp
    pop       rdi
    ret       
;End 
;Proc mlib.outstring
mlib.outstring:
;?>>
   %define R.f rdi
   %define R.s rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rbx
    call      strlen
    inc       rax
    mov       rcx,	rbx
    mov       rdx,	rax
    mov       r8,	1
    mov       r9,	rdi
    call      fwrite
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.outblock
mlib.outblock:
;?>>
   %define R.f rdi
   %define R.p rbx
   %define R.n rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    mov       rcx,	rbx
    mov       rdx,	rsi
    mov       r8,	1
    mov       r9,	rdi
    call      fwrite
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.myeof
mlib.myeof:
;?>>
   %define R.f rbx
   %define R.c rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rcx,	rbx
    call      fgetc
    movsxd    r10,	eax
    mov       rdi,	r10
    cmp       rdi,	-1
    jnz       L627
    mov       rax,	1
    jmp       L625
L627:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      ungetc
    xor       eax,	eax
L625:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.strbuffer_add
mlib.strbuffer_add:
;?>>
   %define R.dest r12
   %define R.s r13
   %define R.n r14
   %define R.newlen rdi
   %define R.oldlen rbx
   %define R.newptr rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       r12,	rcx
    mov       r13,	rdx
    mov       r14,	r8
;---------------
    cmp       r14,	-1
    jnz       L630
    mov       rcx,	r13
    call      strlen
    mov       r14,	rax
L630:
    movsxd    rax,	dword [r12+8]
    mov       rbx,	rax
    test      rbx,	rbx
    jnz       L632
    lea       rax,	[r14+1]
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [r12],	rax
    mov       eax,	[mlib.allocbytes]
    mov       [r12+12],	eax
    mov       [r12+8],	r14d
    mov       rax,	[r12]
    mov       rcx,	rax
    mov       rdx,	r13
    mov       r8,	r14
    call      memcpy
    mov       rax,	[r12]
    xor       r10d,	r10d
    mov       r11,	r14
    mov       [rax + r11],	r10b
    jmp       L628
L632:
    mov       rax,	rbx
    add       rax,	r14
    mov       rdi,	rax
    lea       rax,	[rdi+1]
    movsxd    r10,	dword [r12+12]
    cmp       rax,	r10
    jle       L634
    lea       rax,	[rdi+1]
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       rsi,	rax
    mov       rax,	[r12]
    mov       rcx,	rsi
    mov       rdx,	rax
    mov       r8,	rbx
    call      memcpy
    mov       [r12],	rsi
    mov       eax,	[mlib.allocbytes]
    mov       [r12+12],	eax
L634:
    mov       rax,	[r12]
    mov       r10,	rbx
    lea       rax,	[rax + r10]
    mov       rcx,	rax
    mov       rdx,	r13
    mov       r8,	r14
    call      memcpy
    mov       rax,	[r12]
    xor       r10d,	r10d
    mov       r11,	rdi
    mov       [rax + r11],	r10b
    mov       [r12+8],	edi
L628:
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.gs_init
mlib.gs_init:
;?>>
   %define R.dest rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    mov       rdx,	16
    call      mlib.pcm_clearmem
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mlib.gs_free
mlib.gs_free:
;?>>
   %define R.dest rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       eax,	[rdi+12]
    test      eax,	eax
    jz        L638
    movsxd    rax,	dword [rdi+12]
    mov       r10,	[rdi]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mlib.pcm_free
L638:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mlib.gs_str
mlib.gs_str:
;?>>
   %define R.dest rdi
   %define R.s rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	-1
    call      mlib.strbuffer_add
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.gs_char
mlib.gs_char:
;?>>
   %define R.dest rdi
   %define R.c rbx
    %define mlib.gs_char.s -16
    push      rdi
    push      rbx
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       [rbp + mlib.gs_char.s],	bl
    xor       eax,	eax
    mov       [rbp + mlib.gs_char.s+1],	al
    mov       rcx,	rdi
    lea       rdx,	[rbp + mlib.gs_char.s]
    mov       r8,	1
    call      mlib.strbuffer_add
;---------------
    add       rsp,	48
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.gs_strn
mlib.gs_strn:
;?>>
   %define R.dest rdi
   %define R.s rbx
   %define R.length rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mlib.strbuffer_add
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.gs_strvar
mlib.gs_strvar:
;?>>
   %define R.dest rdi
   %define R.s rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rax,	[rbx]
    mov       rcx,	rdi
    mov       rdx,	rax
    mov       r8,	-1
    call      mlib.strbuffer_add
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.gs_strint
mlib.gs_strint:
;?>>
   %define R.dest rdi
   %define R.a rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rbx
    xor       edx,	edx
    call      msys.strint
    mov       rcx,	rdi
    mov       rdx,	rax
    mov       r8,	-1
    call      mlib.strbuffer_add
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.gs_strln
mlib.gs_strln:
;?>>
   %define R.dest rdi
   %define R.s rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mlib.gs_str
    mov       rcx,	rdi
    call      mlib.gs_line
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.gs_strsp
mlib.gs_strsp:
;?>>
   %define R.dest rdi
   %define R.s rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mlib.gs_str
    mov       rcx,	rdi
    lea       rdx,	[L12108]
    call      mlib.gs_str
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.gs_line
mlib.gs_line:
;?>>
   %define R.dest rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    lea       rdx,	[L12109]
    mov       r8,	-1
    call      mlib.strbuffer_add
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mlib.gs_getcol
mlib.gs_getcol:
;?>>
   %define R.dest rcx
;?]]
;---------------
    movsxd    rax,	dword [rcx+8]
L647:
;---------------
    ret       
;End 
;Proc mlib.gs_leftstr
mlib.gs_leftstr:
;?>>
   %define R.dest r13
   %define R.s r14
    %define mlib.gs_leftstr.w 80
    %define mlib.gs_leftstr.padch 88
   %define R.col rdi
   %define R.i rbx
   %define R.n rsi
   %define R.slen r12
    %define mlib.gs_leftstr.str -2560
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	2592
    mov       r13,	rcx
    mov       r14,	rdx
    mov       [rbp+80],	r8
    mov       [rbp+88],	r9
;---------------
    movsxd    rax,	dword [r13+8]
    mov       rdi,	rax
    lea       rcx,	[rbp + mlib.gs_leftstr.str]
    mov       rdx,	r14
    call      strcpy
    mov       rcx,	r14
    call      strlen
    mov       r12,	rax
    mov       rax,	[rbp + mlib.gs_leftstr.w]
    sub       rax,	r12
    mov       rsi,	rax
    cmp       rsi,	0
    jle       L650
    mov       rbx,	1
    cmp       rsi,	1
    jl        L653
L651:
    mov       rax,	r12
    add       rax,	rbx
    mov       r10b,	[rbp + mlib.gs_leftstr.padch]
    mov       [rbp + rax + mlib.gs_leftstr.str-1],	r10b
    inc       rbx
    cmp       rbx,	rsi
    jle       L651
L653:
    mov       rax,	r12
    add       rax,	rsi
    xor       r10d,	r10d
    mov       [rbp + rax + mlib.gs_leftstr.str],	r10b
L650:
    mov       rcx,	r13
    lea       rdx,	[rbp + mlib.gs_leftstr.str]
    call      mlib.gs_str
;---------------
    add       rsp,	2592
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.gs_leftint
mlib.gs_leftint:
;?>>
   %define R.dest rdi
   %define R.a rbx
   %define R.w rsi
   %define R.padch r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
    mov       r12,	r9
;---------------
    mov       rcx,	rbx
    xor       edx,	edx
    call      msys.strint
    mov       rcx,	rdi
    mov       rdx,	rax
    mov       r8,	rsi
    mov       r9,	r12
    call      mlib.gs_leftstr
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.gs_padto
mlib.gs_padto:
;?>>
   %define R.dest rsi
   %define R.col r12
   %define R.ch r13
   %define R.n rdi
    %define mlib.gs_padto.str -2560
   %define R.i rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	2600
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
;---------------
    movsxd    rax,	dword [rsi+8]
    mov       r10,	r12
    sub       r10,	rax
    mov       rdi,	r10
    cmp       rdi,	0
    jle       L655
L657:
    mov       rbx,	1
    cmp       rdi,	1
    jl        L660
L658:
    mov       [rbp + rbx + mlib.gs_padto.str-1],	r13b
    inc       rbx
    cmp       rbx,	rdi
    jle       L658
L660:
    xor       eax,	eax
    mov       [rbp + rdi + mlib.gs_padto.str],	al
    mov       rcx,	rsi
    lea       rdx,	[rbp + mlib.gs_padto.str]
    call      mlib.gs_str
L655:
;---------------
    add       rsp,	2600
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.gs_println
mlib.gs_println:
;?>>
   %define R.dest rdi
   %define R.f rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    movsxd    rax,	dword [rdi+8]
    test      rax,	rax
    jz        L661
L663:
    mov       rax,	[rdi]
    movsxd    r10,	dword [rdi+8]
    xor       r11d,	r11d
    mov       [rax + r10],	r11b
    test      rbx,	rbx
    jnz       L665
    call      msys.m$print_startcon
    mov       rcx,	[rdi]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rcx,	[L12110]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L664
L665:
    mov       rcx,	rbx
    call      msys.m$print_startfile
    mov       rcx,	[rdi]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rcx,	[L12110]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L664:
L661:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.nextcmdparamnew
mlib.nextcmdparamnew:
;?>>
   %define R.paramno r12
   %define R.name r13
   %define R.value r14
    %define mlib.nextcmdparamnew.defext 88
   %define R.q rdi
    %define mlib.nextcmdparamnew.item -8
   %define R.fileext rbx
   %define R.length rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       r12,	rcx
    mov       r13,	rdx
    mov       r14,	r8
    mov       [rbp+88],	r9
;---------------
;mlib.nextcmdparamnew.reenter:
L667:
    xor       eax,	eax
    mov       [r14],	rax
    xor       eax,	eax
    mov       [r13],	rax
    mov       rax,	[mlib.nextcmdparamnew.infile]
    test      rax,	rax
    jz        L669
    lea       rcx,	[mlib.nextcmdparamnew.fileptr]
    lea       rdx,	[rbp + mlib.nextcmdparamnew.item]
    call      mlib.readnextfileitem
    test      rax,	rax
    jnz       L671
    mov       rcx,	[mlib.nextcmdparamnew.filestart]
    call      free
    xor       eax,	eax
    mov       [mlib.nextcmdparamnew.infile],	rax
    jmp       L667
L671:
    jmp       L668
L669:
    mov       rax,	[r12]
    cmp       rax,	[msys.ncmdparams]
    jle       L673
    xor       eax,	eax
    jmp       L666
L673:
    mov       rax,	[r12]
    mov       r10,	[msys.cmdparams]
    mov       r10,	[r10 + rax*8]
    mov       [rbp + mlib.nextcmdparamnew.item],	r10
    mov       rax,	r12
    inc       qword [rax]
    mov       rcx,	[rbp + mlib.nextcmdparamnew.item]
    call      strlen
    mov       rsi,	rax
    mov       rax,	[rbp + mlib.nextcmdparamnew.item]
    movzx     rax,	byte [rax]
    cmp       rax,	64
    jnz       L675
    mov       rax,	[rbp + mlib.nextcmdparamnew.item]
    lea       rax,	[rax+1]
    mov       rcx,	rax
    call      mlib.readfile
    mov       [mlib.nextcmdparamnew.fileptr],	rax
    mov       [mlib.nextcmdparamnew.filestart],	rax
    mov       rax,	[mlib.nextcmdparamnew.filestart]
    test      rax,	rax
    jnz       L677
    call      msys.m$print_startcon
    lea       rcx,	[L12111]
    call      msys.m$print_str_nf
    mov       rcx,	[rbp + mlib.nextcmdparamnew.item]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	7
    call      exit
L677:
    mov       rax,	1
    mov       [mlib.nextcmdparamnew.infile],	rax
    jmp       L667
L675:
    mov       rax,	[rbp + mlib.nextcmdparamnew.item]
    movzx     rax,	byte [rax]
    cmp       rax,	58
    jnz       L679
    mov       al,	1
    mov       [mlib.nextcmdparamnew.colonseen],	al
    mov       rax,	4
    jmp       L666
L679:
L668:
    xor       eax,	eax
    mov       [r14],	rax
    mov       rax,	[rbp + mlib.nextcmdparamnew.item]
    movzx     rax,	byte [rax]
    cmp       rax,	45
    jnz       L681
    mov       al,	[mlib.nextcmdparamnew.colonseen]
    test      al,	al
    jz        L683
    xor       eax,	eax
    jmp       L682
L683:
    mov       rax,	1
L682:
    mov       r10,	[rbp + mlib.nextcmdparamnew.item]
    lea       r10,	[r10 + rax]
    mov       [r13],	r10
    mov       rcx,	[rbp + mlib.nextcmdparamnew.item]
    mov       rdx,	58
    call      strchr
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L685
    mov       rcx,	[rbp + mlib.nextcmdparamnew.item]
    mov       rdx,	61
    call      strchr
    mov       rdi,	rax
L685:
    test      rdi,	rdi
    jz        L687
    lea       rax,	[rdi+1]
    mov       [r14],	rax
    xor       eax,	eax
    mov       [rdi],	al
L687:
    mov       al,	[mlib.nextcmdparamnew.colonseen]
    test      al,	al
    jz        L689
    mov       rax,	5
    jmp       L688
L689:
    mov       rax,	1
L688:
    jmp       L666
L681:
    mov       rcx,	[rbp + mlib.nextcmdparamnew.item]
    xor       edx,	edx
    call      mlib.extractext
    mov       rbx,	rax
    mov       rax,	[rbp + mlib.nextcmdparamnew.item]
    mov       [r13],	rax
    movzx     rax,	byte [rbx]
    test      rax,	rax
    jnz       L691
    mov       rax,	[r13]
    lea       rcx,	[mlib.nextcmdparamnew.str]
    mov       rdx,	rax
    call      strcpy
    mov       rax,	[rbp + mlib.nextcmdparamnew.defext]
    test      rax,	rax
    jz        L693
    mov       al,	[mlib.nextcmdparamnew.colonseen]
    test      al,	al
    jnz       L693
    lea       rcx,	[mlib.nextcmdparamnew.str]
    mov       rdx,	[rbp + mlib.nextcmdparamnew.defext]
    call      mlib.addext
    mov       [r13],	rax
L693:
    jmp       L690
L691:
    mov       rcx,	rbx
    lea       rdx,	[L12112]
    call      mlib.eqstring
    test      rax,	rax
    jnz       L695
    mov       rcx,	rbx
    lea       rdx,	[L12113]
    call      mlib.eqstring
    test      rax,	rax
    jz        L694
L695:
    mov       al,	[mlib.nextcmdparamnew.colonseen]
    test      al,	al
    jz        L697
    mov       rax,	5
    jmp       L696
L697:
    mov       rax,	3
L696:
    jmp       L666
L694:
L690:
    mov       al,	[mlib.nextcmdparamnew.colonseen]
    test      al,	al
    jz        L699
    mov       rax,	5
    jmp       L698
L699:
    mov       rax,	2
L698:
L666:
;---------------
    add       rsp,	48
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.readnextfileitem
mlib.readnextfileitem:
;?>>
   %define R.fileptr r13
   %define R.item r14
   %define R.p rdi
   %define R.pstart rbx
   %define R.pend rsi
   %define R.n r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       r13,	rcx
    mov       r14,	rdx
;---------------
    mov       rdi,	[r13]
;mlib.readnextfileitem.reenter:
L701:
L702:
    movzx     rax,	byte [rdi]
    cmp       rax,	32
    jz        L705
    cmp       rax,	9
    jz        L705
    cmp       rax,	13
    jz        L705
    cmp       rax,	10
    jz        L705
    cmp       rax,	26
    jz        L706
    test      rax,	rax
    jz        L706
    jmp       L707
L705:
    inc       rdi
    jmp       L704
L706:
    xor       eax,	eax
    jmp       L700
L707:
    jmp       L703
L704:
    jmp       L702
L703:
    movzx     rax,	byte [rdi]
    cmp       rax,	33
    jz        L709
    cmp       rax,	35
    jnz       L710
L709:
    inc       rdi
L711:
    mov       rax,	rdi
    inc       rdi
    movzx     rax,	byte [rax]
    cmp       rax,	10
    jz        L713
    cmp       rax,	26
    jz        L714
    test      rax,	rax
    jz        L714
    jmp       L715
L713:
    jmp       L701
L714:
    lea       rax,	[rdi-1]
    mov       [r13],	rax
    xor       eax,	eax
    jmp       L700
L715:
    jmp       L711
L710:
L708:
    movzx     rax,	byte [rdi]
    cmp       rax,	34
    jnz       L718
L717:
    inc       rdi
    mov       rbx,	rdi
L719:
    movzx     rax,	byte [rdi]
    test      rax,	rax
    jz        L722
    cmp       rax,	26
    jz        L722
    cmp       rax,	34
    jz        L723
    jmp       L724
L722:
    call      msys.m$print_startcon
    lea       rcx,	[L12114]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	8
    call      exit
    jmp       L721
L723:
    mov       rax,	rdi
    inc       rdi
    mov       rsi,	rax
    movzx     rax,	byte [rdi]
    cmp       rax,	44
    jnz       L726
    inc       rdi
L726:
    jmp       L720
L724:
L721:
    inc       rdi
    jmp       L719
L720:
    jmp       L716
L718:
    mov       rbx,	rdi
L727:
    movzx     rax,	byte [rdi]
    test      rax,	rax
    jz        L730
    cmp       rax,	26
    jz        L730
    cmp       rax,	32
    jz        L731
    cmp       rax,	9
    jz        L731
    cmp       rax,	44
    jz        L731
    cmp       rax,	13
    jz        L731
    cmp       rax,	10
    jz        L731
    jmp       L732
L730:
    mov       rsi,	rdi
    jmp       L728
L731:
    mov       rax,	rdi
    inc       rdi
    mov       rsi,	rax
    jmp       L728
L732:
L729:
    inc       rdi
    jmp       L727
L728:
L716:
    mov       rax,	rsi
    sub       rax,	rbx
    mov       r12,	rax
    cmp       r12,	256
    jl        L734
    call      msys.m$print_startcon
    lea       rcx,	[L12115]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	9
    call      exit
L734:
    lea       rcx,	[mlib.readnextfileitem.str]
    mov       rdx,	rbx
    mov       r8,	r12
    call      memcpy
    xor       eax,	eax
    lea       r10,	[mlib.readnextfileitem.str]
    mov       r11,	r12
    mov       [r10 + r11],	al
    lea       rax,	[mlib.readnextfileitem.str]
    mov       [r14],	rax
    mov       [r13],	rdi
    mov       rax,	1
L700:
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.ipadstr
mlib.ipadstr:
;?>>
   %define R.s rsi
   %define R.width r12
   %define R.padchar r13
   %define R.n rdi
   %define R.av_1 rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
;---------------
    mov       rcx,	rsi
    call      strlen
    mov       rdi,	rax
    mov       rax,	r12
    sub       rax,	rdi
    mov       rbx,	rax
    cmp       rbx,	0
    jle       L738
L736:
    mov       rcx,	rsi
    mov       rdx,	r13
    call      strcat
    dec       rbx
    jnz       L736
L738:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.padstr
mlib.padstr:
;?>>
   %define R.s rdi
   %define R.width rbx
   %define R.padchar rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    lea       rcx,	[mlib.padstr.str]
    mov       rdx,	rdi
    call      strcpy
    lea       rcx,	[mlib.padstr.str]
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mlib.ipadstr
    lea       rax,	[mlib.padstr.str]
L739:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.chr
mlib.chr:
;?>>
   %define R.c rcx
;?]]
;---------------
    mov       al,	cl
    lea       r10,	[mlib.chr.str]
    mov       [r10],	al
    xor       eax,	eax
    lea       r10,	[mlib.chr.str]
    mov       [r10+1],	al
    lea       rax,	[mlib.chr.str]
L740:
;---------------
    ret       
;End 
;Proc mlib.cmpstring
mlib.cmpstring:
;?>>
   %define R.s rbx
   %define R.t rsi
   %define R.res rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    mov       rcx,	rbx
    mov       rdx,	rsi
    call      strcmp
    movsxd    r10,	eax
    mov       rdi,	r10
    cmp       r10,	0
    jge       L743
    mov       rax,	-1
    jmp       L742
L743:
    cmp       rdi,	0
    jle       L744
    mov       rax,	1
    jmp       L742
L744:
    xor       eax,	eax
L742:
L741:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.cmpstringn
mlib.cmpstringn:
;?>>
   %define R.s rbx
   %define R.t rsi
   %define R.n r12
   %define R.res rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
;---------------
    mov       rcx,	rbx
    mov       rdx,	rsi
    mov       r8,	r12
    call      strncmp
    movsxd    r10,	eax
    mov       rdi,	r10
    cmp       r10,	0
    jge       L747
    mov       rax,	-1
    jmp       L746
L747:
    cmp       rdi,	0
    jle       L748
    mov       rax,	1
    jmp       L746
L748:
    xor       eax,	eax
L746:
L745:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.eqstring
mlib.eqstring:
;?>>
   %define R.s rdi
   %define R.t rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      strcmp
    movsxd    r10,	eax
    cmp       r10,	0
    setz      r10b
    movzx     r10d,	r10b
    mov       rax,	r10
L749:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.cmpbytes
mlib.cmpbytes:
;?>>
   %define R.p rbx
   %define R.q rsi
   %define R.n r12
   %define R.res rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
;---------------
    mov       rcx,	rbx
    mov       rdx,	rsi
    mov       r8,	r12
    call      memcmp
    movsxd    r10,	eax
    mov       rdi,	r10
    cmp       r10,	0
    jge       L752
    mov       rax,	-1
    jmp       L751
L752:
    cmp       rdi,	0
    jle       L753
    mov       rax,	1
    jmp       L751
L753:
    xor       eax,	eax
L751:
L750:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.eqbytes
mlib.eqbytes:
;?>>
   %define R.p rdi
   %define R.q rbx
   %define R.n rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	rsi
    call      memcmp
    movsxd    r10,	eax
    cmp       r10,	0
    setz      r10b
    movzx     r10d,	r10b
    mov       rax,	r10
L754:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.mseed
mlib.mseed:
;?>>
   %define R.a rcx
   %define R.b rdx
;?]]
;---------------
    mov       rax,	rcx
    lea       r10,	[mlib.seed]
    mov       [r10],	rax
    test      rdx,	rdx
    jz        L757
    mov       rax,	rdx
    lea       r10,	[mlib.seed]
    mov       [r10+8],	rax
    jmp       L756
L757:
    lea       rax,	[mlib.seed]
    lea       rax,	[rax+8]
    mov       r10,	rcx
    xor       [rax],	r10
L756:
;---------------
    ret       
;End 
;Proc mlib.mrandom
mlib.mrandom:
;?>>
   %define R.x rdi
   %define R.y rbx
    push      rdi
    push      rbx
;?]]
;---------------
    lea       rax,	[mlib.seed]
    mov       rdi,	[rax]
    lea       rax,	[mlib.seed]
    mov       rbx,	[rax+8]
    mov       rax,	rbx
    lea       r10,	[mlib.seed]
    mov       [r10],	rax
    mov       rax,	rdi
    shl       rax,	23
    xor       rdi,	rax
    mov       rax,	rdi
    xor       rax,	rbx
    mov       r10,	rdi
    sar       r10,	17
    xor       rax,	r10
    mov       r10,	rbx
    sar       r10,	26
    xor       rax,	r10
    lea       r10,	[mlib.seed]
    mov       [r10+8],	rax
    lea       rax,	[mlib.seed]
    mov       rax,	[rax+8]
    add       rax,	rbx
L758:
;---------------
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.mrandomp
mlib.mrandomp:
;?>>
;?]]
    sub       rsp,	40
;---------------
    call      mlib.mrandom
    mov       r10,	9223372036854775807
    and       rax,	r10
L759:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mlib.mrandomint
mlib.mrandomint:
;?>>
   %define R.n rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    call      mlib.mrandomp
    mov       r10,	rdi
    cqo       
    idiv      r10
    xchg      rax,	rdx
L760:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mlib.mrandomrange
mlib.mrandomrange:
;?>>
   %define R.a rbx
   %define R.b rsi
   %define R.span rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    mov       rax,	rsi
    sub       rax,	rbx
    inc       rax
    mov       rdi,	rax
    cmp       rdi,	0
    jg        L763
    xor       eax,	eax
    jmp       L761
L763:
    call      mlib.mrandomp
    mov       r10,	rdi
    cqo       
    idiv      r10
    xchg      rax,	rdx
    add       rax,	rbx
L761:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.mrandomreal
mlib.mrandomreal:
;?>>
   %define R.x XMM15
    movq      rax,	XMM15
    push      rax
;?]]
    sub       rsp,	48
;---------------
L765:
    call      mlib.mrandomp
    cvtsi2sd  XMM4,	rax
    divsd     XMM4,	[L12116]
    movq      XMM15,	XMM4
    movq      XMM4,	XMM15
    comisd    XMM4,	[L12117]
    jz        L765
    movq      XMM0,	XMM15
L764:
;---------------
    add       rsp,	48
    pop       rcx
    movq      XMM15,	rcx
    ret       
;End 
;Proc mlib.mrandomreal1
mlib.mrandomreal1:
;?>>
;?]]
    sub       rsp,	40
;---------------
    call      mlib.mrandomp
    cvtsi2sd  XMM4,	rax
    divsd     XMM4,	[L12118]
    movq      XMM0,	XMM4
L768:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mlib.readline
mlib.readline:
;?>>
;?]]
    sub       rsp,	40
;---------------
    call      msys.m$read_conline
    mov       rax,	[msys.rd_buffer]
L769:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mlib.findfunction
mlib.findfunction:
;?>>
   %define R.name rsi
   %define R.av_1 rdi
   %define R.i rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    mov       rbx,	1
    mov       rdi,	[$nprocs]
    cmp       rdi,	1
    jl        L773
L771:
    lea       rax,	[$procname]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rax
    mov       rdx,	rsi
    call      mlib.eqstring
    test      rax,	rax
    jz        L775
    lea       rax,	[$procaddr]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8-8]
    jmp       L770
L775:
    inc       rbx
    cmp       rbx,	rdi
    jle       L771
L773:
    xor       eax,	eax
L770:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mlib.roundtoblock
mlib.roundtoblock:
;?>>
   %define R.n rcx
   %define R.align rdx
;?]]
;---------------
    lea       rax,	[rdx-1]
    mov       r10,	rcx
    and       r10,	rax
    test      r10,	r10
    jnz       L778
    mov       rax,	rcx
    jmp       L776
L778:
    lea       rax,	[rdx-1]
    mov       r10,	rcx
    and       r10,	rax
    mov       rax,	rdx
    sub       rax,	r10
    mov       r10,	rcx
    add       r10,	rax
    mov       rax,	r10
L776:
;---------------
    ret       
;End 
;Proc mlib.pcm_allocnfz
mlib.pcm_allocnfz:
;?>>
   %define R.n rbx
   %define R.p rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rax,	rbx
    and       rax,	7
    jz        L781
    mov       rax,	rbx
    and       rax,	7
    mov       r10,	8
    sub       r10,	rax
    mov       rax,	rbx
    add       rax,	r10
    mov       rbx,	rax
L781:
    mov       rdi,	[mlib.pcheapptr]
    mov       rax,	rbx
    add       [mlib.pcheapptr],	rax
    mov       rax,	[mlib.pcheapptr]
    cmp       rax,	[mlib.pcheapend]
    jb        L783
    mov       rcx,	rbx
    call      mlib.pcm_newblock
    mov       rdi,	rax
L783:
    mov       rax,	rdi
L779:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mwindows.os_init
mwindows.os_init:
;?>>
;?]]
    sub       rsp,	40
;---------------
    mov       eax,	4294967285
    mov       eax,	eax
    mov       rcx,	rax
    call      GetStdHandle
    mov       [mwindows.hconsole],	rax
    mov       eax,	4294967286
    mov       eax,	eax
    mov       rcx,	rax
    call      GetStdHandle
    mov       [mwindows.hconsolein],	rax
    xor       eax,	eax
    lea       r10,	[mwindows.lastkey]
    mov       [r10+8],	ax
    xor       eax,	eax
    mov       [mwindows.keypending],	rax
    xor       ecx,	ecx
    mov       rdx,	1
    call      SetConsoleCtrlHandler
    mov       rcx,	[mwindows.hconsole]
    mov       rdx,	3
    call      SetConsoleMode
    mov       rax,	1
    mov       [mwindows.init_flag],	rax
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mwindows.os_execwait
mwindows.os_execwait:
;?>>
   %define R.cmdline rsi
   %define R.newconsole r12
    %define mwindows.os_execwait.workdir 64
    %define mwindows.os_execwait.exitcode -8
   %define R.status rdi
   %define R.cflags rbx
    %define mwindows.os_execwait.si -112
    %define mwindows.os_execwait.xpi -136
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	176
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    xor       rbx,	rbx
    lea       rax,	[rbp + mwindows.os_execwait.si]
    xor       r10d,	r10d
    mov       r11,	13
L12119:
    mov       [rax],	r10
    add       rax,	8
    dec       r11
    jnz       L12119
    lea       rax,	[rbp + mwindows.os_execwait.xpi]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    mov       [rax+16],	r10
    mov       rax,	r12
    test      rax,	rax
    jz        L787
    cmp       rax,	1
    jz        L788
    cmp       rax,	2
    jz        L789
    jmp       L790
L787:
    mov       rbx,	32
    jmp       L786
L788:
    mov       rbx,	48
    jmp       L786
L789:
    mov       rbx,	48
L790:
L786:
    mov       eax,	104
    mov       [rbp + mwindows.os_execwait.si],	eax
    lea       rax,	[rbp + mwindows.os_execwait.xpi]
    push      rax
    lea       rax,	[rbp + mwindows.os_execwait.si]
    push      rax
    push      0
    push      0
    mov       eax,	ebx
    push      rax
    push      1
    xor       ecx,	ecx
    mov       rdx,	rsi
    xor       r8d,	r8d
    xor       r9d,	r9d
    sub       rsp,	32
    call      CreateProcessA
    add       rsp,	80
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L792
    call      GetLastError
    mov       r10d,	eax
    mov       rdi,	r10
    lea       rcx,	[L12120]
    mov       rdx,	rdi
    call      printf
    mov       rax,	-1
    jmp       L785
L792:
    mov       rax,	[rbp + mwindows.os_execwait.xpi]
    mov       rcx,	rax
    mov       rdx,	4294967295
    call      WaitForSingleObject
    mov       rax,	[rbp + mwindows.os_execwait.xpi]
    mov       rcx,	rax
    lea       rdx,	[rbp + mwindows.os_execwait.exitcode]
    call      GetExitCodeProcess
    mov       rcx,	[rbp + mwindows.os_execwait.xpi]
    call      CloseHandle
    mov       rcx,	[rbp + mwindows.os_execwait.xpi+8]
    call      CloseHandle
    mov       eax,	[rbp + mwindows.os_execwait.exitcode]
L785:
;---------------
    add       rsp,	176
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mwindows.os_execcmd
mwindows.os_execcmd:
;?>>
   %define R.cmdline rdi
   %define R.newconsole rbx
    %define mwindows.os_execcmd.si -104
    %define mwindows.os_execcmd.xpi -128
    push      rdi
    push      rbx
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	160
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    lea       rax,	[rbp + mwindows.os_execcmd.si]
    xor       r10d,	r10d
    mov       r11,	13
L12121:
    mov       [rax],	r10
    add       rax,	8
    dec       r11
    jnz       L12121
    lea       rax,	[rbp + mwindows.os_execcmd.xpi]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    mov       [rax+16],	r10
    mov       eax,	104
    mov       [rbp + mwindows.os_execcmd.si],	eax
    lea       rax,	[rbp + mwindows.os_execcmd.xpi]
    push      rax
    lea       rax,	[rbp + mwindows.os_execcmd.si]
    push      rax
    push      0
    push      0
    test      rbx,	rbx
    jz        L795
    mov       rax,	16
    jmp       L794
L795:
    xor       eax,	eax
L794:
    mov       r10,	32
    or        r10,	rax
    push      r10
    push      1
    xor       ecx,	ecx
    mov       rdx,	rdi
    xor       r8d,	r8d
    xor       r9d,	r9d
    sub       rsp,	32
    call      CreateProcessA
    add       rsp,	80
    mov       rcx,	[rbp + mwindows.os_execcmd.xpi]
    call      CloseHandle
    mov       rcx,	[rbp + mwindows.os_execcmd.xpi+8]
    call      CloseHandle
    mov       rax,	1
L793:
;---------------
    add       rsp,	160
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mwindows.os_getch
mwindows.os_getch:
;?>>
   %define R.k rdi
    push      rdi
;?]]
    sub       rsp,	48
;---------------
    call      mwindows.os_getchx
    and       rax,	255
    mov       rdi,	rax
    mov       rax,	rdi
L796:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mwindows.os_kbhit
mwindows.os_kbhit:
;?>>
    %define mwindows.os_kbhit.count -8
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    mov       rax,	[mwindows.init_flag]
    test      rax,	rax
    jnz       L799
    call      mwindows.os_init
L799:
    mov       rcx,	[mwindows.hconsolein]
    lea       rdx,	[rbp + mwindows.os_kbhit.count]
    call      GetNumberOfConsoleInputEvents
    mov       eax,	[rbp + mwindows.os_kbhit.count]
    cmp       rax,	1
    setg      al
    movzx     eax,	al
L797:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc mwindows.os_getdllinst
mwindows.os_getdllinst:
;?>>
   %define R.name rbx
   %define R.hinst rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rcx,	rbx
    call      LoadLibraryA
    mov       rdi,	rax
    mov       rax,	rdi
L800:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mwindows.os_getdllprocaddr
mwindows.os_getdllprocaddr:
;?>>
   %define R.hinst rdi
   %define R.name rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      GetProcAddress
L801:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mwindows.os_initwindows
mwindows.os_initwindows:
;?>>
;?]]
    sub       rsp,	40
;---------------
    call      mwindows.os_init
    lea       rcx,	[L12122]
    call      mwindows.os_gxregisterclass
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mwindows.os_gxregisterclass
mwindows.os_gxregisterclass:
;?>>
   %define R.classname rdi
    %define mwindows.os_gxregisterclass.r -80
    push      rdi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	120
    mov       rdi,	rcx
;---------------
    mov       al,	[mwindows.os_gxregisterclass.registered]
    test      al,	al
    jnz       L803
L805:
    lea       rax,	[rbp + mwindows.os_gxregisterclass.r]
    xor       r10d,	r10d
    mov       r11,	10
L12123:
    mov       [rax],	r10
    add       rax,	8
    dec       r11
    jnz       L12123
    mov       eax,	80
    mov       [rbp + mwindows.os_gxregisterclass.r],	eax
    mov       eax,	40
    mov       [rbp + mwindows.os_gxregisterclass.r+4],	eax
    lea       rax,	[mwindows.mainwndproc]
    mov       [rbp + mwindows.os_gxregisterclass.r+8],	rax
    xor       eax,	eax
    mov       [rbp + mwindows.os_gxregisterclass.r+24],	rax
    xor       eax,	eax
    mov       [rbp + mwindows.os_gxregisterclass.r+32],	rax
    xor       ecx,	ecx
    mov       rdx,	32512
    call      LoadCursorA
    mov       [rbp + mwindows.os_gxregisterclass.r+40],	rax
    mov       rax,	16
    mov       [rbp + mwindows.os_gxregisterclass.r+48],	rax
    xor       eax,	eax
    mov       [rbp + mwindows.os_gxregisterclass.r+56],	rax
    mov       [rbp + mwindows.os_gxregisterclass.r+64],	rdi
    xor       eax,	eax
    mov       [rbp + mwindows.os_gxregisterclass.r+72],	rax
    lea       rcx,	[rbp + mwindows.os_gxregisterclass.r]
    call      RegisterClassExA
    mov       r10d,	eax
    test      r10,	r10
    jnz       L807
    call      GetLastError
    mov       r10d,	eax
    lea       rcx,	[L12124]
    mov       rdx,	rdi
    mov       r8,	r10
    call      printf
    mov       rcx,	1
    call      exit
L807:
    mov       al,	1
    mov       [mwindows.os_gxregisterclass.registered],	al
L803:
;---------------
    add       rsp,	120
    pop       rbp
    pop       rdi
    ret       
;End 
;Proc mwindows.mainwndproc
mwindows.mainwndproc:
;?>>
   %define R.hwnd rbx
   %define R.message esi
   %define R.wparam r12
   %define R.lparam r13
    %define mwindows.mainwndproc.m -48
   %define R.result rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	88
    mov       rbx,	rcx
    mov       esi,	edx
    mov       r12,	r8
    mov       r13,	r9
;---------------
    mov       [rbp + mwindows.mainwndproc.m],	rbx
    mov       [rbp + mwindows.mainwndproc.m+8],	esi
    mov       [rbp + mwindows.mainwndproc.m+16],	r12
    mov       [rbp + mwindows.mainwndproc.m+24],	r13
    xor       eax,	eax
    mov       [rbp + mwindows.mainwndproc.m+40],	eax
    xor       eax,	eax
    mov       [rbp + mwindows.mainwndproc.m+44],	eax
    mov       rax,	[mwindows.wndproc_callbackfn]
    test      rax,	rax
    jz        L810
    lea       rcx,	[rbp + mwindows.mainwndproc.m]
    mov       rax,	[mwindows.wndproc_callbackfn]
    call      rax
    mov       rdi,	rax
    jmp       L809
L810:
    xor       rdi,	rdi
L809:
    mov       eax,	[rbp + mwindows.mainwndproc.m+8]
    cmp       rax,	2
    jnz       L812
    xor       eax,	eax
    jmp       L808
L812:
    test      rdi,	rdi
    jnz       L814
    mov       eax,	esi
    mov       rcx,	rbx
    mov       rdx,	rax
    mov       r8,	r12
    mov       r9,	r13
    call      DefWindowProcA
    jmp       L813
L814:
    xor       eax,	eax
L813:
L808:
;---------------
    add       rsp,	88
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mwindows.os_setmesshandler
mwindows.os_setmesshandler:
;?>>
   %define R.addr rcx
;?]]
;---------------
    mov       [mwindows.wndproc_callbackfn],	rcx
;---------------
    ret       
;End 
;Proc mwindows.os_getchx
mwindows.os_getchx:
;?>>
    %define mwindows.os_getchx.count -8
   %define R.charcode rdi
   %define R.keyshift rbx
   %define R.keycode rsi
   %define R.altdown r12
   %define R.ctrldown r13
    %define mwindows.os_getchx.shiftdown -16
    %define mwindows.os_getchx.capslock -24
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
;---------------
    mov       rax,	[mwindows.init_flag]
    test      rax,	rax
    jnz       L818
    call      mwindows.os_init
L818:
    mov       rax,	[mwindows.keypending]
    test      rax,	rax
    jz        L820
    lea       rax,	[mwindows.pendkey]
    lea       r10,	[mwindows.lastkey]
    mov       r11,	[rax]
    mov       [r10],	r11
    mov       r11,	[rax+8]
    mov       [r10+8],	r11
    mov       r11d,	[rax+16]
    mov       [r10+16],	r11d
    xor       eax,	eax
    mov       [mwindows.keypending],	rax
    jmp       L819
L820:
    lea       rax,	[mwindows.lastkey]
    movzx     rax,	word [rax+8]
    test      rax,	rax
    jnz       L822
L823:
    xor       eax,	eax
    mov       [rbp + mwindows.os_getchx.count],	rax
    mov       rcx,	[mwindows.hconsolein]
    lea       rdx,	[mwindows.lastkey]
    mov       r8,	1
    lea       r9,	[rbp + mwindows.os_getchx.count]
    call      ReadConsoleInputA
    lea       rax,	[mwindows.lastkey]
    movzx     rax,	word [rax]
    cmp       rax,	1
    jnz       L823
    lea       rax,	[mwindows.lastkey]
    mov       eax,	[rax+4]
    cmp       rax,	1
    jnz       L823
L822:
L819:
    lea       rax,	[mwindows.lastkey]
    mov       eax,	[rax+16]
    and       rax,	3
    jz        L827
    mov       rax,	1
    jmp       L826
L827:
    xor       eax,	eax
L826:
    mov       r12,	rax
    lea       rax,	[mwindows.lastkey]
    mov       eax,	[rax+16]
    and       rax,	12
    jz        L829
    mov       rax,	1
    jmp       L828
L829:
    xor       eax,	eax
L828:
    mov       r13,	rax
    lea       rax,	[mwindows.lastkey]
    mov       eax,	[rax+16]
    and       rax,	16
    jz        L831
    mov       rax,	1
    jmp       L830
L831:
    xor       eax,	eax
L830:
    mov       [rbp + mwindows.os_getchx.shiftdown],	rax
    lea       rax,	[mwindows.lastkey]
    mov       eax,	[rax+16]
    and       rax,	128
    jz        L833
    mov       rax,	1
    jmp       L832
L833:
    xor       eax,	eax
L832:
    mov       [rbp + mwindows.os_getchx.capslock],	rax
    lea       rax,	[mwindows.lastkey]
    lea       rax,	[rax+8]
    dec       word [rax]
    lea       rax,	[mwindows.lastkey]
    movzx     rax,	byte [rax+14]
    mov       rdi,	rax
    lea       rax,	[mwindows.lastkey]
    movzx     rax,	word [rax+10]
    and       rax,	255
    mov       rsi,	rax
    cmp       rdi,	0
    jge       L835
    cmp       rdi,	-128
    jge       L837
    xor       rdi,	rdi
    jmp       L836
L837:
    mov       rax,	256
    add       rdi,	rax
L836:
L835:
    test      r12,	r12
    jz        L839
    test      r13,	r13
    jz        L839
    cmp       rdi,	166
    jnz       L839
    xor       eax,	eax
    mov       r13,	rax
    mov       r12,	rax
    jmp       L838
L839:
    test      r12,	r12
    jnz       L842
    test      r13,	r13
    jz        L841
L842:
    xor       rdi,	rdi
    mov       rax,	rsi
    cmp       rax,	65
    jl        L844
    cmp       rsi,	90
    jg        L844
    lea       rax,	[rsi-64]
    mov       rdi,	rax
L844:
L841:
L838:
    mov       rax,	[rbp + mwindows.os_getchx.capslock]
    shl       rax,	3
    mov       r10,	r12
    shl       r10,	2
    or        rax,	r10
    mov       r10,	r13
    shl       r10,	1
    or        rax,	r10
    or        rax,	[rbp + mwindows.os_getchx.shiftdown]
    mov       rbx,	rax
    mov       rax,	rbx
    shl       rax,	24
    mov       r10,	rsi
    shl       r10,	16
    or        rax,	r10
    or        rax,	rdi
L816:
;---------------
    add       rsp,	56
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mwindows.os_getos
mwindows.os_getos:
;?>>
;?]]
;---------------
    lea       rax,	[L12125]
L845:
;---------------
    ret       
;End 
;Proc mwindows.os_gethostsize
mwindows.os_gethostsize:
;?>>
;?]]
;---------------
    mov       rax,	64
L846:
;---------------
    ret       
;End 
;Proc mwindows.os_shellexec
mwindows.os_shellexec:
;?>>
    %define mwindows.os_shellexec.opc 24
   %define R.file rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rdx
;---------------
    mov       rcx,	rdi
    call      system
    movsxd    r10,	eax
    mov       rax,	r10
L847:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mwindows.os_sleep
mwindows.os_sleep:
;?>>
   %define R.a rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      Sleep
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mwindows.os_getstdin
mwindows.os_getstdin:
;?>>
;?]]
    sub       rsp,	40
;---------------
    lea       rcx,	[L12126]
    lea       rdx,	[L12127]
    call      fopen
L849:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mwindows.os_getstdout
mwindows.os_getstdout:
;?>>
;?]]
    sub       rsp,	40
;---------------
    lea       rcx,	[L12128]
    lea       rdx,	[L12129]
    call      fopen
L850:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mwindows.os_gethostname
mwindows.os_gethostname:
;?>>
;?]]
    sub       rsp,	40
;---------------
    xor       ecx,	ecx
    lea       rdx,	[mwindows.os_gethostname.name]
    mov       r8,	300
    call      GetModuleFileNameA
    lea       rax,	[mwindows.os_gethostname.name]
L851:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mwindows.os_getmpath
mwindows.os_getmpath:
;?>>
;?]]
;---------------
    lea       rax,	[L12130]
L852:
;---------------
    ret       
;End 
;Proc mwindows.os_clock
mwindows.os_clock:
;?>>
;?]]
    sub       rsp,	40
;---------------
    call      mwindows.os_hpcounter
L853:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mwindows.os_ticks
mwindows.os_ticks:
;?>>
;?]]
    sub       rsp,	40
;---------------
    call      GetTickCount64
L854:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mwindows.os_iswindows
mwindows.os_iswindows:
;?>>
;?]]
;---------------
    mov       rax,	1
L855:
;---------------
    ret       
;End 
;Proc mwindows.os_getsystime
mwindows.os_getsystime:
;?>>
   %define R.tm rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      GetLocalTime
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mwindows.os_peek
mwindows.os_peek:
;?>>
   %define R.ticks rdi
    %define mwindows.os_peek.m -104
    push      rdi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	136
;---------------
    call      GetTickCount64
    mov       rdi,	rax
    mov       rax,	rdi
    sub       rax,	[mwindows.os_peek.lastticks]
    cmp       rax,	1000
    jl        L859
    mov       [mwindows.os_peek.lastticks],	rdi
    sub       rsp,	8
    push      0
    lea       rcx,	[rbp + mwindows.os_peek.m]
    xor       edx,	edx
    xor       r8d,	r8d
    xor       r9d,	r9d
    sub       rsp,	32
    call      PeekMessageA
    add       rsp,	48
L859:
;---------------
    add       rsp,	136
    pop       rbp
    pop       rdi
    ret       
;End 
;Proc mwindows.os_allocexecmem
mwindows.os_allocexecmem:
;?>>
   %define R.n rsi
   %define R.p rdi
    %define mwindows.os_allocexecmem.oldprot -8
   %define R.status rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       rsi,	rcx
;---------------
    xor       ecx,	ecx
    mov       rdx,	rsi
    mov       r8,	12288
    mov       r9,	1
    call      VirtualAlloc
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L862
    xor       eax,	eax
    jmp       L860
L862:
    mov       rcx,	rdi
    mov       rdx,	rsi
    mov       r8,	64
    lea       r9,	[rbp + mwindows.os_allocexecmem.oldprot]
    call      VirtualProtect
    mov       r10d,	eax
    mov       rbx,	r10
    test      rbx,	rbx
    jnz       L864
    xor       eax,	eax
    jmp       L860
L864:
    mov       rax,	rdi
L860:
;---------------
    add       rsp,	40
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mwindows.dirlist
mwindows.dirlist:
;?>>
   %define R.filespec rsi
   %define R.dest r12
   %define R.capacity r13
   %define R.t r14
   %define R.hfind rdi
    %define mwindows.dirlist.file -328
   %define R.nfiles rbx
    %define mwindows.dirlist.path -632
    %define mwindows.dirlist.fullfilename -936
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	976
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
    mov       r14,	r9
;---------------
    xor       rbx,	rbx
    mov       rcx,	rsi
    call      mlib.extractpath
    lea       rcx,	[rbp + mwindows.dirlist.path]
    mov       rdx,	rax
    call      strcpy
    mov       rcx,	rsi
    lea       rdx,	[rbp + mwindows.dirlist.file]
    call      FindFirstFileA
    mov       rdi,	rax
    cmp       rax,	-1
    jz        L867
L868:
    mov       eax,	[rbp + mwindows.dirlist.file]
    and       rax,	16
    jz        L872
    mov       rax,	r14
    and       rax,	2
    jnz       L874
    jmp       L869
L874:
    jmp       L871
L872:
    mov       rax,	r14
    and       rax,	1
    jnz       L876
    jmp       L869
L876:
L871:
    cmp       rbx,	r13
    jl        L878
    mov       rbx,	-1
    jmp       L870
L878:
    mov       rax,	r14
    and       rax,	4
    jz        L880
    lea       rax,	[rbp + mwindows.dirlist.file+44]
    mov       rcx,	rax
    call      mlib.convlcstring
L880:
    lea       rcx,	[rbp + mwindows.dirlist.fullfilename]
    lea       rdx,	[rbp + mwindows.dirlist.path]
    call      strcpy
    lea       rax,	[rbp + mwindows.dirlist.file+44]
    lea       rcx,	[rbp + mwindows.dirlist.fullfilename]
    mov       rdx,	rax
    call      strcat
    lea       rcx,	[rbp + mwindows.dirlist.fullfilename]
    call      mlib.pcm_copyheapstring
    inc       rbx
    mov       r10,	rbx
    mov       [r12 + r10*8-8],	rax
L869:
    mov       rcx,	rdi
    lea       rdx,	[rbp + mwindows.dirlist.file]
    call      FindNextFileA
    test      eax,	eax
    jnz       L868
L870:
    mov       rcx,	rdi
    call      FindClose
L867:
    mov       rax,	rbx
L865:
;---------------
    add       rsp,	976
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mwindows.os_hpcounter
mwindows.os_hpcounter:
;?>>
    %define mwindows.os_hpcounter.a -8
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    mov       rax,	[mwindows.hpfreq]
    test      rax,	rax
    jnz       L883
    call      mwindows.os_hpfreq
    mov       r10,	1000
    cqo       
    idiv      r10
    mov       [mwindows.hpfreq],	rax
L883:
    lea       rcx,	[rbp + mwindows.os_hpcounter.a]
    call      QueryPerformanceCounter
    mov       rax,	[rbp + mwindows.os_hpcounter.a]
    mov       r10,	[mwindows.hpfreq]
    cqo       
    idiv      r10
L881:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc mwindows.os_hpfreq
mwindows.os_hpfreq:
;?>>
    %define mwindows.os_hpfreq.a -8
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    lea       rcx,	[rbp + mwindows.os_hpfreq.a]
    call      QueryPerformanceFrequency
    mov       rax,	[rbp + mwindows.os_hpfreq.a]
L884:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc mwindll.os_calldllfunction
mwindll.os_calldllfunction:
;?>>
    %define mwindll.os_calldllfunction.fnaddr 16
    %define mwindll.os_calldllfunction.retcode 24
    %define mwindll.os_calldllfunction.nargs 32
    %define mwindll.os_calldllfunction.args 40
    %define mwindll.os_calldllfunction.argcodes 48
    %define mwindll.os_calldllfunction.a -8
    %define mwindll.os_calldllfunction.x -16
    %define mwindll.os_calldllfunction.nextra -24
    %define mwindll.os_calldllfunction.pushedbytes -32
    %define mwindll.os_calldllfunction.av_1 -40
    %define mwindll.os_calldllfunction.i -48
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	80
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
    mov       [rbp+40],	r9
;---------------
    xor       eax,	eax
    mov       [rbp + mwindll.os_calldllfunction.nextra],	rax
    mov       rax,	[rbp + mwindll.os_calldllfunction.nargs]
    cmp       rax,	4
    jge       L887
    mov       rax,	4
    sub       rax,	[rbp + mwindll.os_calldllfunction.nargs]
    mov       [rbp + mwindll.os_calldllfunction.nextra],	rax
    jmp       L886
L887:
    mov       eax,	[rbp + mwindll.os_calldllfunction.nargs]
    and       eax,	1
    test      rax,	rax
    jz        L888
    mov       rax,	1
    mov       [rbp + mwindll.os_calldllfunction.nextra],	rax
L888:
L886:
    mov       rax,	[rbp + mwindll.os_calldllfunction.nextra]
    add       rax,	[rbp + mwindll.os_calldllfunction.nargs]
    shl       rax,	3
    mov       [rbp + mwindll.os_calldllfunction.pushedbytes],	rax
    mov       rax,	[rbp + mwindll.os_calldllfunction.nextra]
    mov       [rbp + mwindll.os_calldllfunction.av_1],	rax
    mov       rax,	[rbp + mwindll.os_calldllfunction.av_1]
    cmp       rax,	0
    jle       L891
L889:
    push      0
    dec       qword [rbp + mwindll.os_calldllfunction.av_1]
    jnz       L889
L891:
    mov       rax,	[rbp + mwindll.os_calldllfunction.nargs]
    mov       [rbp + mwindll.os_calldllfunction.i],	rax
    mov       rax,	[rbp + mwindll.os_calldllfunction.i]
    cmp       rax,	1
    jl        L894
L892:
    mov       rax,	[rbp + mwindll.os_calldllfunction.args]
    mov       r10,	[rbp + mwindll.os_calldllfunction.i]
    mov       rax,	[rax + r10*8-8]
    mov       [rbp + mwindll.os_calldllfunction.a],	rax
    push      qword [rbp + mwindll.os_calldllfunction.a]
    mov       rax,	[rbp + mwindll.os_calldllfunction.i]
    dec       rax
    mov       [rbp + mwindll.os_calldllfunction.i],	rax
    cmp       rax,	1
    jge       L892
L894:
    mov       rcx,	[rsp]
    movq      XMM0,	[rsp]
    mov       rdx,	[rsp+8]
    movq      XMM1,	[rsp+8]
    mov       r8,	[rsp+16]
    movq      XMM2,	[rsp+16]
    mov       r9,	[rsp+24]
    movq      XMM3,	[rsp+24]
    mov       rax,	[rbp + mwindll.os_calldllfunction.retcode]
    cmp       rax,	73
    jnz       L896
    mov       rax,	[rbp + mwindll.os_calldllfunction.fnaddr]
    call      rax
    mov       [rbp + mwindll.os_calldllfunction.a],	rax
    add       rsp,	[rbp + mwindll.os_calldllfunction.pushedbytes]
    mov       rax,	[rbp + mwindll.os_calldllfunction.a]
    jmp       L895
L896:
    mov       rax,	[rbp + mwindll.os_calldllfunction.fnaddr]
    call      rax
    movq      [rbp + mwindll.os_calldllfunction.x],	XMM0
    add       rsp,	[rbp + mwindll.os_calldllfunction.pushedbytes]
    movq      XMM4,	[rbp + mwindll.os_calldllfunction.x]
    movq      rax,	XMM4
L895:
L885:
;---------------
    add       rsp,	80
    pop       rbp
    ret       
;End 
;Proc pc_api.start
pc_api.start:
;?>>
;?]]
    sub       rsp,	40
;---------------
    call      msys.m$print_startcon
    lea       rcx,	[L12131]
    call      msys.m$print_str_nf
    mov       rcx,	143
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
;---------------
    add       rsp,	40
    ret       
;End 
;Proc pc_api.pcl_start
pc_api.pcl_start:
;?>>
   %define R.name rdi
   %define R.nunits rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       al,	[pc_decls.pcldone]
    test      al,	al
    jz        L900
    lea       rcx,	[L12132]
    call      pc_api.pclerror
L900:
    test      rdi,	rdi
    jz        L902
    mov       rcx,	rdi
    mov       rdx,	9
    call      pc_api.pc_makesymbol
    mov       [pc_decls.currprog],	rax
L902:
    mov       rax,	[pc_api.initpcalloc]
    mov       [pc_api.pcalloc],	rax
    test      rbx,	rbx
    jz        L904
    mov       rax,	rbx
    lea       rax,	[rax + rax*8]
    sar       rax,	3
    mov       rbx,	rax
    jmp       L906
L905:
    mov       rax,	[pc_api.pcalloc]
    shl       rax,	1
    mov       [pc_api.pcalloc],	rax
L906:
    mov       rax,	[pc_api.pcalloc]
    cmp       rax,	rbx
    jl        L905
L904:
    mov       rax,	[pc_api.pcalloc]
    shl       rax,	5
    mov       rcx,	rax
    call      mlib.pcm_allocz
    mov       [pc_api.pcstart],	rax
    mov       rax,	[pc_api.pcstart]
    mov       r10,	[pc_api.pcalloc]
    shl       r10,	5
    lea       rax,	[rax + r10]
    sub       rax,	256
    mov       [pc_api.pcend],	rax
    mov       rax,	[pc_api.pcstart]
    sub       rax,	32
    mov       [pc_api.pccurr],	rax
    xor       eax,	eax
    mov       [pc_api.pcfixed],	al
    xor       eax,	eax
    mov       [pc_api.pcseqno],	rax
    xor       eax,	eax
    mov       [pc_api.pcneedfntable],	rax
    xor       eax,	eax
    mov       [pc_api.mlabelno],	rax
    mov       rax,	[pc_decls.currprog]
L898:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.pcl_end
pc_api.pcl_end:
;?>>
;?]]
    sub       rsp,	40
;---------------
    mov       rax,	[pc_api.pccurr]
    cmp       rax,	[pc_api.pccurr]
    jb        L910
    mov       rax,	[pc_api.pccurr]
    movzx     rax,	byte [rax]
    cmp       rax,	136
    jz        L910
    mov       rcx,	136
    xor       edx,	edx
    call      pc_api.pc_gen
L910:
    mov       al,	1
    mov       [pc_decls.pcldone],	al
;---------------
    add       rsp,	40
    ret       
;End 
;Proc pc_api.pcl_writepcl
pc_api.pcl_writepcl:
;?>>
   %define R.filename rbx
   %define R.d rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    call      pc_diags.writeallpcl
    mov       rdi,	rax
    test      rbx,	rbx
    jz        L913
    mov       al,	[pc_decls.pverbose]
    test      al,	al
    jz        L915
    call      msys.m$print_startcon
    lea       rcx,	[L12133]
    call      msys.m$print_str_nf
    mov       rcx,	rbx
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L915:
    movsxd    rax,	dword [rdi+8]
    mov       r10,	[rdi]
    mov       rcx,	rbx
    mov       rdx,	r10
    mov       r8,	rax
    call      mlib.writefile
    lea       rax,	[L12134]
    jmp       L912
L913:
    mov       rax,	[rdi]
L912:
L911:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.pcl_writepst
pc_api.pcl_writepst:
;?>>
   %define R.filename rbx
   %define R.d rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    call      pc_diags.writepst
    mov       rdi,	rax
    test      rbx,	rbx
    jz        L918
    mov       al,	[pc_decls.pverbose]
    test      al,	al
    jz        L920
    call      msys.m$print_startcon
    lea       rcx,	[L12135]
    call      msys.m$print_str_nf
    mov       rcx,	rbx
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L920:
    movsxd    rax,	dword [rdi+8]
    mov       r10,	[rdi]
    mov       rcx,	rbx
    mov       rdx,	r10
    mov       r8,	rax
    call      mlib.writefile
    lea       rax,	[L12136]
    jmp       L917
L918:
    mov       rax,	[rdi]
L917:
L916:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.pcl_genmcl
pc_api.pcl_genmcl:
;?>>
;?]]
    sub       rsp,	40
;---------------
    xor       ecx,	ecx
    call      mc_genmcl.genmcl
;---------------
    add       rsp,	40
    ret       
;End 
;Proc pc_api.pcl_genss
pc_api.pcl_genss:
;?>>
   %define R.obj rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    xor       ecx,	ecx
    call      mc_genmcl.genmcl
    mov       rcx,	rdi
    call      mc_genss.genss
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc pc_api.pcl_writess
pc_api.pcl_writess:
;?>>
   %define R.filename rsi
   %define R.obj r12
   %define R.ssstr rdi
   %define R.f rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    xor       ecx,	ecx
    call      mc_genmcl.genmcl
    mov       rcx,	r12
    call      mc_genss.genss
    mov       rax,	r12
    test      rax,	rax
    setz      al
    movzx     eax,	al
    mov       rcx,	rax
    call      mc_writess_dummy.writessdata
    mov       rdi,	rax
    test      rsi,	rsi
    jz        L925
    mov       rcx,	rsi
    lea       rdx,	[L12137]
    call      fopen
    mov       rbx,	rax
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mlib.gs_println
    mov       rcx,	rbx
    call      fclose
    mov       rcx,	rdi
    call      mlib.gs_free
    xor       eax,	eax
    jmp       L924
L925:
    mov       rax,	[rdi]
L924:
L923:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.pcl_writeasm
pc_api.pcl_writeasm:
;?>>
   %define R.filename rsi
    %define pc_api.pcl_writeasm.atype 48
   %define R.asmstr rdi
   %define R.f rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    mov       rax,	[pc_decls.assemtype]
    cmp       rax,	1297301838
    jnz       L928
    mov       al,	2
    mov       [pc_api.phighmem],	al
L928:
    xor       ecx,	ecx
    call      mc_genmcl.genmcl
    call      mc_writenasm.getassemstr
    mov       rdi,	rax
    test      rsi,	rsi
    jz        L930
    mov       al,	[pc_decls.pverbose]
    test      al,	al
    jz        L932
    call      msys.m$print_startcon
    lea       rcx,	[L12138]
    call      msys.m$print_str_nf
    mov       rcx,	rsi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L932:
    mov       rcx,	rsi
    lea       rdx,	[L12139]
    call      fopen
    mov       rbx,	rax
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mlib.gs_println
    mov       rcx,	rbx
    call      fclose
    mov       rcx,	rdi
    call      mlib.gs_free
    xor       eax,	eax
    jmp       L929
L930:
    mov       rax,	[rdi]
L929:
L926:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.pcl_writeobj
pc_api.pcl_writeobj:
;?>>
   %define R.filename rbx
   %define R.tt rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    xor       ecx,	ecx
    call      mc_genmcl.genmcl
    mov       rcx,	1
    call      mc_genss.genss
    xor       eax,	eax
    mov       [pc_api.phighmem],	al
    call      msys.m$print_startcon
    lea       rcx,	[L12140]
    call      msys.m$print_str_nf
    movzx     rax,	byte [pc_api.phighmem]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      mwindows.os_clock
    mov       rdi,	rax
    mov       rcx,	rbx
    call      mc_writeobj.writecoff
    call      mwindows.os_clock
    sub       rax,	rdi
    mov       [pc_decls.objtime],	rax
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.pcl_writedll
pc_api.pcl_writedll:
;?>>
   %define R.filename rbx
   %define R.tt rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       al,	2
    mov       [pc_api.phighmem],	al
    xor       ecx,	ecx
    call      mc_genmcl.genmcl
    xor       ecx,	ecx
    call      mc_genss.genss
    call      mwindows.os_clock
    mov       rdi,	rax
    mov       rcx,	rbx
    mov       rdx,	1
    xor       r8d,	r8d
    call      mc_writeexe.writeexe
    call      mwindows.os_clock
    sub       rax,	rdi
    mov       [pc_decls.exetime],	rax
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.pcl_writeexe
pc_api.pcl_writeexe:
;?>>
   %define R.filename rbx
   %define R.tt rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    xor       ecx,	ecx
    call      mc_genmcl.genmcl
    xor       ecx,	ecx
    call      mc_genss.genss
    call      mwindows.os_clock
    mov       rdi,	rax
    mov       rcx,	rbx
    xor       edx,	edx
    xor       r8d,	r8d
    call      mc_writeexe.writeexe
    call      mwindows.os_clock
    sub       rax,	rdi
    mov       [pc_decls.exetime],	rax
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.pcl_writemx
pc_api.pcl_writemx:
;?>>
   %define R.filename rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    xor       ecx,	ecx
    call      mc_genmcl.genmcl
    xor       ecx,	ecx
    call      mc_genss.genss
    mov       rcx,	rdi
    call      mx_write.writemcx
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc pc_api.pcl_exec
pc_api.pcl_exec:
;?>>
;?]]
    sub       rsp,	40
;---------------
    xor       ecx,	ecx
    call      mc_genmcl.genmcl
    xor       ecx,	ecx
    call      mc_genss.genss
    lea       rcx,	[L12141]
    mov       rdx,	[pc_decls.pcmdskip]
    call      mx_run.runlibfile
;---------------
    add       rsp,	40
    ret       
;End 
;Proc pc_api.pcl_setflags
pc_api.pcl_setflags:
;?>>
   %define R.highmem rcx
   %define R.verbose rdx
   %define R.shortnames r8
;?]]
;---------------
    cmp       rcx,	0
    jl        L940
    mov       [pc_api.phighmem],	cl
L940:
    cmp       rdx,	0
    jl        L942
    mov       [pc_decls.pverbose],	dl
L942:
    cmp       r8,	0
    jl        L944
    mov       [pc_api.fpshortnames],	r8b
L944:
;---------------
    ret       
;End 
;Proc pc_api.extendpclblock
pc_api.extendpclblock:
;?>>
   %define R.newpcalloc rdi
   %define R.lengthused rbx
   %define R.newpcstart rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
;---------------
    mov       rax,	[pc_api.pcalloc]
    shl       rax,	1
    mov       rdi,	rax
    mov       rax,	[pc_api.pccurr]
    sub       rax,	[pc_api.pcstart]
    shr       rax,	5
    inc       rax
    mov       rbx,	rax
    mov       rax,	32
    imul      rax,	rdi
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       rsi,	rax
    mov       rax,	rbx
    shl       rax,	5
    mov       rcx,	rsi
    mov       rdx,	[pc_api.pcstart]
    mov       r8,	rax
    call      memcpy
    mov       rax,	rdi
    sub       rax,	rbx
    shl       rax,	5
    mov       r10,	rbx
    shl       r10,	5
    lea       r11,	[rsi + r10]
    mov       rcx,	r11
    mov       rdx,	rax
    call      mlib.pcm_clearmem
    mov       rax,	[pc_api.pccurr]
    sub       rax,	[pc_api.pcstart]
    shr       rax,	5
    shl       rax,	5
    lea       r10,	[rsi + rax]
    mov       [pc_api.pccurr],	r10
    mov       rax,	rdi
    shl       rax,	5
    lea       r10,	[rsi + rax]
    sub       r10,	256
    mov       [pc_api.pcend],	r10
    mov       rax,	[pc_api.pcalloc]
    shl       rax,	5
    mov       rcx,	[pc_api.pcstart]
    mov       rdx,	rax
    call      mlib.pcm_free
    mov       [pc_api.pcstart],	rsi
    mov       [pc_api.pcalloc],	rdi
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.newpcl
pc_api.newpcl:
;?>>
;?]]
    sub       rsp,	40
;---------------
    mov       rax,	[pc_api.pccurr]
    cmp       rax,	[pc_api.pcend]
    jb        L948
    call      pc_api.extendpclblock
L948:
    add       qword [pc_api.pccurr],	32
    mov       eax,	[pc_decls.mmpos]
    mov       r10,	[pc_api.pccurr]
    mov       [r10+24],	eax
    inc       qword [pc_api.pclseqno]
    mov       rax,	[pc_api.pclseqno]
    mov       r10,	[pc_api.pccurr]
    lea       r10,	[r10+28]
    mov       r9d,	[r10]
    mov       r11,	-4294967041
    shl       eax,	8
    and       r9d,	r11d
    or        r9d,	eax
    mov       [r10],	r9d
    mov       rax,	[pc_api.pccurr]
L946:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc pc_api.pc_gen
pc_api.pc_gen:
;?>>
   %define R.opcode rdi
   %define R.p rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    test      rbx,	rbx
    jnz       L951
    call      pc_api.newpcl
    mov       rbx,	rax
L951:
    mov       [rbx],	dil
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.pc_genix
pc_api.pc_genix:
;?>>
   %define R.opcode rbx
   %define R.scale rsi
   %define R.offset r12
   %define R.p rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
;---------------
    call      pc_api.newpcl
    mov       rdi,	rax
    mov       [rdi],	bl
    mov       [rdi+16],	esi
    mov       [rdi+20],	r12d
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.pc_genx
pc_api.pc_genx:
;?>>
   %define R.opcode rdi
   %define R.x rbx
   %define R.p rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    test      rsi,	rsi
    jnz       L955
    call      pc_api.newpcl
    mov       rsi,	rax
L955:
    mov       [rsi],	dil
    mov       [rsi+16],	ebx
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.pc_genxy
pc_api.pc_genxy:
;?>>
   %define R.opcode rdi
   %define R.x rbx
   %define R.y rsi
   %define R.p r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
    mov       r12,	r9
;---------------
    test      r12,	r12
    jnz       L958
    call      pc_api.newpcl
    mov       r12,	rax
L958:
    mov       [r12],	dil
    mov       [r12+16],	ebx
    mov       [r12+20],	esi
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.pc_gencond
pc_api.pc_gencond:
;?>>
   %define R.opcode rdi
   %define R.cond rbx
   %define R.p rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    test      rsi,	rsi
    jnz       L961
    call      pc_api.newpcl
    mov       rsi,	rax
L961:
    mov       [rsi],	dil
    mov       [rsi+2],	bl
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.genint
pc_api.genint:
;?>>
   %define R.a rbx
   %define R.p rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    call      pc_api.newpcl
    mov       rdi,	rax
    mov       [rdi+8],	rbx
    mov       al,	4
    mov       [rdi+1],	al
    mov       rax,	rdi
L962:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.genreal
pc_api.genreal:
;?>>
   %define R.x XMM15
   %define R.mode rbx
   %define R.p rdi
    push      rdi
    push      rbx
    movq      rax,	XMM15
    push      rax
;?]]
    sub       rsp,	48
    movq      XMM15,	XMM0
    mov       rbx,	rdx
;---------------
    call      pc_api.newpcl
    mov       rdi,	rax
    movq      XMM4,	XMM15
    movq      [rdi+8],	XMM4
    cmp       rbx,	2
    jnz       L965
    mov       rax,	5
    jmp       L964
L965:
    mov       rax,	6
L964:
    mov       [rdi+1],	al
    mov       rax,	rdi
L963:
;---------------
    add       rsp,	48
    pop       rcx
    movq      XMM15,	rcx
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.genrealimm
pc_api.genrealimm:
;?>>
   %define R.x XMM15
   %define R.mode rbx
   %define R.p rdi
    push      rdi
    push      rbx
    movq      rax,	XMM15
    push      rax
;?]]
    sub       rsp,	48
    movq      XMM15,	XMM0
    mov       rbx,	rdx
;---------------
    call      pc_api.newpcl
    mov       rdi,	rax
    movq      XMM4,	XMM15
    movq      [rdi+8],	XMM4
    cmp       rbx,	2
    jnz       L968
    mov       rax,	10
    jmp       L967
L968:
    mov       rax,	11
L967:
    mov       [rdi+1],	al
    mov       rax,	rdi
L966:
;---------------
    add       rsp,	48
    pop       rcx
    movq      XMM15,	rcx
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.genstring
pc_api.genstring:
;?>>
   %define R.s rbx
   %define R.p rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    call      pc_api.newpcl
    mov       rdi,	rax
    mov       rcx,	rbx
    call      mlib.pcm_copyheapstring
    mov       [rdi+8],	rax
    mov       al,	7
    mov       [rdi+1],	al
    mov       rax,	rdi
L969:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.genpcstrimm
pc_api.genpcstrimm:
;?>>
   %define R.s rbx
   %define R.p rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    call      pc_api.newpcl
    mov       rdi,	rax
    mov       rcx,	rbx
    call      mlib.pcm_copyheapstring
    mov       [rdi+8],	rax
    mov       al,	8
    mov       [rdi+1],	al
    mov       rax,	rdi
L970:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.genlabel
pc_api.genlabel:
;?>>
   %define R.a rbx
   %define R.p rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    call      pc_api.newpcl
    mov       rdi,	rax
    mov       [rdi+8],	rbx
    mov       al,	3
    mov       [rdi+1],	al
    mov       rax,	rdi
L971:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.genmem
pc_api.genmem:
;?>>
   %define R.d rbx
   %define R.p rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    call      pc_api.newpcl
    mov       rdi,	rax
    mov       [rdi+8],	rbx
    mov       al,	1
    mov       [rdi+1],	al
    mov       rax,	rdi
L972:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.genmemaddr
pc_api.genmemaddr:
;?>>
   %define R.d rbx
   %define R.p rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    call      pc_api.newpcl
    mov       rdi,	rax
    mov       [rdi+8],	rbx
    mov       al,	2
    mov       [rdi+1],	al
    mov       rax,	rdi
L973:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.gendata
pc_api.gendata:
;?>>
   %define R.s rbx
   %define R.length rsi
   %define R.p rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    call      pc_api.newpcl
    mov       rdi,	rax
    mov       [rdi+8],	rbx
    mov       al,	12
    mov       [rdi+1],	al
    mov       al,	11
    mov       [rdi+3],	al
    mov       [rdi+4],	esi
    mov       rax,	rdi
L974:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.gencomment
pc_api.gencomment:
;?>>
   %define R.s rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       al,	[pc_decls.fregoptim]
    test      al,	al
    jnz       L978
    mov       al,	[pc_decls.fpeephole]
    test      al,	al
    jz        L977
L978:
    jmp       L975
L977:
    mov       rcx,	rdi
    call      pc_api.genpcstrimm
    mov       rcx,	135
    mov       rdx,	rax
    call      pc_api.pc_gen
L975:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc pc_api.genname
pc_api.genname:
;?>>
   %define R.s rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    mov       rdx,	8
    call      pc_api.pc_makesymbol
    mov       rcx,	rax
    call      pc_api.genmem
L979:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc pc_api.gennameaddr
pc_api.gennameaddr:
;?>>
   %define R.s rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    mov       rdx,	8
    call      pc_api.pc_makesymbol
    mov       rcx,	rax
    call      pc_api.genmemaddr
L980:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc pc_api.genassem
pc_api.genassem:
;?>>
   %define R.code rbx
   %define R.p rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    call      pc_api.newpcl
    mov       rdi,	rax
    mov       [rdi+8],	rbx
    mov       al,	9
    mov       [rdi+1],	al
    mov       rax,	rdi
L981:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.strpmode
pc_api.strpmode:
;?>>
   %define R.mode rdi
   %define R.size rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    lea       rcx,	[pc_api.strpmode.str]
    lea       rdx,	[L12142]
    call      strcpy
    mov       rax,	rdi
    cmp       rax,	11
    jz        L984
    test      rax,	rax
    jz        L985
    jmp       L986
L984:
    lea       rcx,	[pc_api.strpmode.str]
    lea       rdx,	[L12143]
    call      strcpy
    mov       rcx,	rbx
    xor       edx,	edx
    call      msys.strint
    lea       rcx,	[pc_api.strpmode.str]
    mov       rdx,	rax
    call      strcat
    lea       rax,	[pc_api.strpmode.str]
    jmp       L983
L985:
    lea       rax,	[L12144]
    jmp       L983
L986:
    lea       rax,	[pc_tables.pstdnames]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8]
L983:
L982:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.pc_setmode
pc_api.pc_setmode:
;?>>
   %define R.m rcx
   %define R.size rdx
;?]]
;---------------
    mov       al,	cl
    mov       r10,	[pc_api.pccurr]
    mov       [r10+3],	al
    test      rdx,	rdx
    jz        L989
    mov       eax,	edx
    mov       r10,	[pc_api.pccurr]
    mov       [r10+4],	eax
    jmp       L988
L989:
    mov       rax,	[pc_api.pccurr]
    movzx     rax,	byte [rax+3]
    lea       r10,	[pc_tables.psize]
    movzx     r10,	byte [r10 + rax]
    mov       rax,	[pc_api.pccurr]
    mov       [rax+4],	r10d
L988:
    mov       rax,	[pc_api.pccurr]
    movzx     rax,	byte [rax]
    lea       r10,	[pc_tables.pclhastype]
    movzx     r10,	byte [r10 + rax]
    cmp       r10,	2
    jnz       L991
    mov       rax,	[pc_api.pccurr]
    movzx     rax,	byte [rax+3]
    mov       r10,	[pc_api.pccurr]
    lea       r10,	[r10+28]
    mov       r9d,	[r10]
    mov       r11,	-256
    and       r9d,	r11d
    or        r9d,	eax
    mov       [r10],	r9d
L991:
;---------------
    ret       
;End 
;Proc pc_api.pc_setmode2
pc_api.pc_setmode2:
;?>>
   %define R.m rcx
;?]]
;---------------
    mov       rax,	[pc_api.pccurr]
    lea       rax,	[rax+28]
    mov       r10d,	ecx
    mov       r9d,	[rax]
    mov       r11,	-256
    and       r9d,	r11d
    or        r9d,	r10d
    mov       [rax],	r9d
;---------------
    ret       
;End 
;Proc pc_api.pc_setxy
pc_api.pc_setxy:
;?>>
   %define R.x rcx
   %define R.y rdx
;?]]
;---------------
    mov       eax,	ecx
    mov       r10,	[pc_api.pccurr]
    mov       [r10+16],	eax
    mov       eax,	edx
    mov       r10,	[pc_api.pccurr]
    mov       [r10+20],	eax
;---------------
    ret       
;End 
;Proc pc_api.pc_setscaleoff
pc_api.pc_setscaleoff:
;?>>
   %define R.scale rcx
   %define R.offset rdx
;?]]
;---------------
    mov       eax,	ecx
    mov       r10,	[pc_api.pccurr]
    mov       [r10+16],	eax
    mov       eax,	edx
    mov       r10,	[pc_api.pccurr]
    mov       [r10+20],	eax
;---------------
    ret       
;End 
;Proc pc_api.pc_setoffset
pc_api.pc_setoffset:
;?>>
   %define R.offset rcx
;?]]
;---------------
    mov       eax,	ecx
    mov       r10,	[pc_api.pccurr]
    mov       [r10+20],	eax
;---------------
    ret       
;End 
;Proc pc_api.pc_addoffset
pc_api.pc_addoffset:
;?>>
   %define R.offset rcx
;?]]
;---------------
    mov       rax,	[pc_api.pccurr]
    lea       rax,	[rax+20]
    mov       r10d,	ecx
    add       [rax],	r10d
;---------------
    ret       
;End 
;Proc pc_api.pc_setincr
pc_api.pc_setincr:
;?>>
   %define R.n rcx
;?]]
;---------------
    mov       eax,	ecx
    mov       r10,	[pc_api.pccurr]
    mov       [r10+16],	eax
;---------------
    ret       
;End 
;Proc pc_api.pc_setnargs
pc_api.pc_setnargs:
;?>>
   %define R.n rcx
;?]]
;---------------
    mov       eax,	ecx
    mov       r10,	[pc_api.pccurr]
    mov       [r10+16],	eax
;---------------
    ret       
;End 
;Proc pc_api.pc_setnvariadics
pc_api.pc_setnvariadics:
;?>>
   %define R.n rcx
;?]]
;---------------
    mov       eax,	ecx
    mov       r10,	[pc_api.pccurr]
    mov       [r10+20],	eax
;---------------
    ret       
;End 
;Proc pc_api.pc_setalign
pc_api.pc_setalign:
;?>>
   %define R.n rcx
;?]]
;---------------
    mov       eax,	ecx
    mov       r10,	[pc_api.pccurr]
    mov       [r10+16],	eax
;---------------
    ret       
;End 
;Proc pc_api.perror
pc_api.perror:
;?>>
   %define R.mess rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    xor       edx,	edx
    call      pc_api.perror_s
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc pc_api.perror_s
pc_api.perror_s:
;?>>
   %define R.mess rdi
   %define R.param rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    call      msys.m$print_startcon
    lea       rcx,	[L12145]
    call      msys.m$print_str_nf
    mov       rcx,	rdi
    call      msys.m$print_str_nf
    call      msys.m$print_end
    test      rbx,	rbx
    jz        L1004
    call      msys.m$print_startcon
    lea       rcx,	[L12146]
    call      msys.m$print_str_nf
    mov       rcx,	rbx
    call      msys.m$print_str_nf
    call      msys.m$print_end
L1004:
    mov       rcx,	1
    call      exit
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.getbasename
pc_api.getbasename:
;?>>
   %define R.s rbx
   %define R.t rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rcx,	rbx
    call      strlen
    lea       r10,	[rbx + rax]
    sub       r10,	1
    mov       rdi,	r10
    jmp       L1007
L1006:
    dec       rdi
L1007:
    cmp       rdi,	rbx
    jbe       L1009
    lea       rax,	[rdi-1]
    movzx     rax,	byte [rax]
    cmp       rax,	46
    jnz       L1006
L1009:
    mov       rax,	rdi
L1005:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.pclerror
pc_api.pclerror:
;?>>
   %define R.mess rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    call      msys.m$print_startcon
    lea       rcx,	[L12147]
    call      msys.m$print_str_nf
    mov       rcx,	rdi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	1
    call      exit
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc pc_api.pc_addsymbol
pc_api.pc_addsymbol:
;?>>
   %define R.d rcx
;?]]
;---------------
    mov       rax,	[pc_decls.psymboltable]
    test      rax,	rax
    jnz       L1013
    mov       rax,	rcx
    mov       [pc_decls.psymboltablex],	rax
    mov       [pc_decls.psymboltable],	rax
    jmp       L1012
L1013:
    mov       rax,	rcx
    mov       r10,	[pc_decls.psymboltablex]
    mov       [r10+8],	rax
    mov       [pc_decls.psymboltablex],	rcx
L1012:
;---------------
    ret       
;End 
;Proc pc_api.pc_makesymbol
pc_api.pc_makesymbol:
;?>>
   %define R.s rbx
   %define R.id rsi
   %define R.d rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    mov       rcx,	128
    call      mlib.pcm_allocnfz
    mov       rdi,	rax
    mov       rcx,	rbx
    call      mlib.pcm_copyheapstring
    mov       [rdi],	rax
    inc       qword [pc_api.stseqno]
    mov       rax,	[pc_api.stseqno]
    mov       [rdi+120],	eax
    mov       rax,	rsi
    cmp       rax,	1
    jz        L1016
    cmp       rax,	7
    jz        L1017
    jmp       L1018
L1016:
    mov       al,	1
    mov       [rdi+80],	al
    jmp       L1015
L1017:
    mov       al,	1
    mov       [rdi+81],	al
    mov       rsi,	2
L1018:
L1015:
    mov       [rdi+72],	sil
    mov       rax,	rsi
    cmp       rax,	4
    jz        L1021
    cmp       rax,	5
    jnz       L1020
L1021:
    mov       rax,	[pc_decls.currfunc]
    mov       [rdi+32],	rax
    jmp       L1019
L1020:
    test      rsi,	rsi
    jz        L1022
    mov       rcx,	rdi
    call      pc_api.pc_addsymbol
L1022:
L1019:
    mov       rax,	rdi
L1014:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.getfullname
pc_api.getfullname:
;?>>
   %define R.d rsi
   %define R.backtick r12
   %define R.n rdi
   %define R.e rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    xor       rdi,	rdi
    mov       rax,	rsi
    mov       rbx,	rax
    xor       eax,	eax
    lea       r10,	[pc_api.getfullname.str]
    mov       [r10],	al
    test      r12,	r12
    jz        L1025
    lea       rcx,	[pc_api.getfullname.str]
    lea       rdx,	[L12148]
    call      strcpy
L1025:
    mov       al,	[rsi+80]
    test      al,	al
    jz        L1027
    test      r12,	r12
    jz        L1029
    mov       rax,	[rsi]
    lea       rcx,	[pc_api.getfullname.str]
    mov       rdx,	rax
    call      strcat
    lea       rcx,	[pc_api.getfullname.str]
    lea       rdx,	[L12149]
    call      strcat
    jmp       L1028
L1029:
    mov       rax,	[rsi]
    lea       rcx,	[pc_api.getfullname.str]
    mov       rdx,	rax
    call      strcat
L1028:
    lea       rax,	[pc_api.getfullname.str]
    jmp       L1023
L1027:
    movzx     rax,	byte [rsi+72]
    cmp       rax,	4
    jz        L1032
    cmp       rax,	5
    jnz       L1031
L1032:
    mov       rax,	[rsi+32]
    mov       rax,	[rax]
    lea       rcx,	[pc_api.getfullname.str]
    mov       rdx,	rax
    call      strcat
    lea       rcx,	[pc_api.getfullname.str]
    lea       rdx,	[L12150]
    call      strcat
    mov       rax,	[rsi]
    lea       rcx,	[pc_api.getfullname.str]
    mov       rdx,	rax
    call      strcat
    lea       rax,	[pc_api.getfullname.str]
    jmp       L1023
L1031:
    test      r12,	r12
    jz        L1034
    mov       rax,	[rsi]
    lea       rcx,	[pc_api.getfullname.str]
    mov       rdx,	rax
    call      strcat
    jmp       L1033
L1034:
    mov       rax,	[rsi]
L1033:
L1023:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.pcerrorstop
pc_api.pcerrorstop:
;?>>
   %define R.filename rbx
   %define R.lineno rsi
   %define R.f rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    lea       rcx,	[L12151]
    lea       rdx,	[L12152]
    call      fopen
    mov       rdi,	rax
    mov       rcx,	rdi
    call      msys.m$print_startfile
    mov       rcx,	rbx
    call      msys.m$print_str_nf
    mov       rcx,	rsi
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	rdi
    call      fclose
    mov       rcx,	1
    call      exit
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.pc_addplib
pc_api.pc_addplib:
;?>>
   %define R.name rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rax,	[pc_decls.nplibfiles]
    cmp       rax,	50
    jl        L1038
    lea       rcx,	[L12153]
    call      pc_api.perror
L1038:
    mov       rcx,	rdi
    lea       rdx,	[L12154]
    call      mlib.changeext
    mov       rcx,	rax
    call      mlib.pcm_copyheapstring
    inc       qword [pc_decls.nplibfiles]
    mov       r10,	[pc_decls.nplibfiles]
    lea       r11,	[pc_decls.plibfiles]
    mov       [r11 + r10*8-8],	rax
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc pc_api.pc_defproc
pc_api.pc_defproc:
;?>>
   %define R.d rdi
   %define R.mode rbx
   %define R.isentry rsi
   %define R.threaded r12
    %define pc_api.pc_defproc.$T1 -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
    mov       r12,	r9
;---------------
    mov       rax,	[pc_decls.currfunc]
    test      rax,	rax
    jz        L1041
    lea       rcx,	[L12155]
    call      pc_api.pclerror
L1041:
    mov       rcx,	rdi
    call      pc_api.genmem
    mov       [rbp + pc_api.pc_defproc.$T1],	rax
    test      r12,	r12
    jz        L1043
    mov       rax,	121
    jmp       L1042
L1043:
    mov       rax,	120
L1042:
    mov       rcx,	rax
    mov       rdx,	[rbp + pc_api.pc_defproc.$T1]
    call      pc_api.pc_gen
    test      rbx,	rbx
    jnz       L1045
    movzx     rax,	byte [rdi+82]
    mov       rbx,	rax
L1045:
    mov       rcx,	rbx
    xor       edx,	edx
    call      pc_api.pc_setmode
    mov       rax,	[rdi+56]
    test      rax,	rax
    jz        L1047
    mov       rax,	[rdi]
    lea       rcx,	[L12156]
    mov       rdx,	rax
    call      pc_api.addstr
    mov       rcx,	rax
    call      pc_api.pclerror
L1047:
    mov       rax,	[pc_api.pccurr]
    mov       [rdi+56],	rax
    mov       rax,	[pc_decls.entryproc]
    test      rax,	rax
    jnz       L1049
    test      rsi,	rsi
    jz        L1049
    mov       [pc_decls.entryproc],	rdi
    mov       al,	1
    mov       [rdi+83],	al
L1049:
    mov       [pc_decls.currfunc],	rdi
;---------------
    add       rsp,	48
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.pc_setimport
pc_api.pc_setimport:
;?>>
   %define R.d rcx
;?]]
;---------------
    mov       [pc_decls.currfunc],	rcx
;---------------
    ret       
;End 
;Proc pc_api.pc_addparam
pc_api.pc_addparam:
;?>>
   %define R.d rsi
   %define R.p rdi
   %define R.q rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    mov       rdi,	[pc_decls.currfunc]
    test      rdi,	rdi
    jnz       L1053
    lea       rcx,	[L12157]
    call      pc_api.pclerror
L1053:
    mov       rbx,	[rdi+16]
    test      rbx,	rbx
    jnz       L1055
    mov       [rdi+16],	rsi
    jmp       L1054
L1055:
    jmp       L1057
L1056:
    mov       rbx,	[rbx+16]
L1057:
    mov       rax,	[rbx+16]
    test      rax,	rax
    jnz       L1056
    mov       [rbx+16],	rsi
L1054:
    mov       rax,	[rsi+32]
    test      rax,	rax
    jnz       L1060
    mov       rax,	[pc_decls.currfunc]
    mov       [rsi+32],	rax
L1060:
    mov       rax,	[pc_decls.currfunc]
    lea       rax,	[rax+112]
    inc       byte [rax]
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.pc_addlocal
pc_api.pc_addlocal:
;?>>
   %define R.d rsi
   %define R.p rdi
   %define R.q rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    mov       rdi,	[pc_decls.currfunc]
    test      rdi,	rdi
    jnz       L1063
    lea       rcx,	[L12157]
    call      pc_api.pclerror
L1063:
    mov       rbx,	[rdi+24]
    test      rbx,	rbx
    jnz       L1065
    mov       [rdi+24],	rsi
    jmp       L1064
L1065:
    jmp       L1067
L1066:
    mov       rbx,	[rbx+24]
L1067:
    mov       rax,	[rbx+24]
    test      rax,	rax
    jnz       L1066
    mov       [rbx+24],	rsi
L1064:
    mov       rax,	[rsi+32]
    test      rax,	rax
    jnz       L1070
    mov       rax,	[pc_decls.currfunc]
    mov       [rsi+32],	rax
L1070:
    mov       rax,	[pc_decls.currfunc]
    lea       rax,	[rax+114]
    inc       word [rax]
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.pc_endproc
pc_api.pc_endproc:
;?>>
;?]]
    sub       rsp,	40
;---------------
    mov       rax,	[pc_decls.currfunc]
    test      rax,	rax
    jnz       L1073
    lea       rcx,	[L12157]
    call      pc_api.pclerror
L1073:
    mov       rcx,	122
    xor       edx,	edx
    call      pc_api.pc_gen
    xor       eax,	eax
    mov       [pc_decls.currfunc],	rax
;---------------
    add       rsp,	40
    ret       
;End 
;Proc pc_api.addstr
pc_api.addstr:
;?>>
   %define R.s rdi
   %define R.t rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    lea       rcx,	[pc_api.addstr.str]
    mov       rdx,	rdi
    call      strcpy
    lea       rcx,	[pc_api.addstr.str]
    mov       rdx,	rbx
    call      strcat
    lea       rax,	[pc_api.addstr.str]
L1074:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.merror
pc_api.merror:
;?>>
   %define R.mess rbx
   %define R.param rsi
   %define R.lineno rdi
    %define pc_api.merror.filename -8
    %define pc_api.merror.sourceline -16
    push      rdi
    push      rbx
    push      rsi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    mov       rax,	[pc_decls.igetmsourceinfo]
    test      rax,	rax
    jz        L1077
    mov       rcx,	[pc_decls.mmpos]
    lea       rdx,	[rbp + pc_api.merror.filename]
    lea       r8,	[rbp + pc_api.merror.sourceline]
    mov       rax,	[pc_decls.igetmsourceinfo]
    call      rax
    mov       rdi,	rax
    call      msys.m$print_startcon
    lea       rcx,	[L12158]
    call      msys.m$print_str_nf
    mov       rcx,	rdi
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       rcx,	[L12159]
    call      msys.m$print_str_nf
    mov       rcx,	[rbp + pc_api.merror.filename]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L1076
L1077:
    xor       rdi,	rdi
    lea       rax,	[L12160]
    mov       [rbp + pc_api.merror.filename],	rax
L1076:
    mov       rax,	[pc_decls.currfunc]
    test      rax,	rax
    jz        L1079
    call      msys.m$print_startcon
    lea       rcx,	[L12161]
    call      msys.m$print_str_nf
    mov       rax,	[pc_decls.currfunc]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L1079:
    call      msys.m$print_startcon
    lea       rcx,	[L12162]
    call      msys.m$print_setfmt
    mov       rcx,	rbx
    call      msys.m$print_str_nf
    mov       rcx,	rsi
    call      msys.m$print_str_nf
    mov       rcx,	rdi
    call      msys.m$print_i64_nf
    mov       rcx,	[rbp + pc_api.merror.filename]
    call      msys.m$print_str_nf
    mov       rcx,	[pc_decls.ppseqno]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	[rbp + pc_api.merror.filename]
    mov       rdx,	rdi
    call      pc_api.pcerrorstop
;---------------
    add       rsp,	56
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.pc_duplpst
pc_api.pc_duplpst:
;?>>
   %define R.d rbx
   %define R.e rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rcx,	128
    call      mlib.pcm_allocnfz
    mov       rdi,	rax
    mov       rax,	rbx
    push      rdi
    mov       r11,	16
L12163:
    mov       r10,	[rax]
    mov       [rdi],	r10
    add       rdi,	8
    add       rax,	8
    dec       r11
    jnz       L12163
    pop       rdi
    mov       [rdi+40],	rbx
    inc       qword [pc_api.stseqno]
    mov       rax,	[pc_api.stseqno]
    mov       [rdi+120],	eax
    xor       eax,	eax
    mov       [rdi+8],	rax
    mov       rax,	rdi
L1080:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_api.pcl_cmdskip
pc_api.pcl_cmdskip:
;?>>
   %define R.cmdskip rcx
    %define pc_api.pcl_cmdskip.dcmdskip 24
;?]]
;---------------
    mov       [pc_decls.pcmdskip],	rcx
;---------------
    ret       
;End 
;Proc pc_api.convertstring
pc_api.convertstring:
;?>>
   %define R.s rsi
   %define R.t r12
   %define R.c rdi
   %define R.t0 rbx
    %define pc_api.convertstring.str -16
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    mov       rbx,	r12
    jmp       L1084
L1083:
    mov       rax,	rdi
    cmp       rax,	34
    jz        L1087
    cmp       rax,	10
    jz        L1088
    cmp       rax,	13
    jz        L1089
    cmp       rax,	9
    jz        L1090
    cmp       rax,	92
    jz        L1091
    cmp       rax,	7
    jz        L1092
    cmp       rax,	8
    jz        L1092
    cmp       rax,	26
    jz        L1092
    cmp       rax,	27
    jz        L1092
    jmp       L1093
L1087:
    mov       rax,	r12
    inc       r12
    mov       r10b,	92
    mov       [rax],	r10b
    mov       rax,	r12
    inc       r12
    mov       r10b,	34
    mov       [rax],	r10b
    jmp       L1086
L1088:
    mov       rax,	r12
    inc       r12
    mov       r10b,	92
    mov       [rax],	r10b
    mov       rax,	r12
    inc       r12
    mov       r10b,	110
    mov       [rax],	r10b
    jmp       L1086
L1089:
    mov       rax,	r12
    inc       r12
    mov       r10b,	92
    mov       [rax],	r10b
    mov       rax,	r12
    inc       r12
    mov       r10b,	114
    mov       [rax],	r10b
    jmp       L1086
L1090:
    mov       rax,	r12
    inc       r12
    mov       r10b,	92
    mov       [rax],	r10b
    mov       rax,	r12
    inc       r12
    mov       r10b,	116
    mov       [rax],	r10b
    jmp       L1086
L1091:
    mov       rax,	r12
    inc       r12
    mov       r10b,	92
    mov       [rax],	r10b
    mov       rax,	r12
    inc       r12
    mov       r10b,	92
    mov       [rax],	r10b
    jmp       L1086
L1092:
    mov       rax,	r12
    inc       r12
    mov       r10b,	60
    mov       [rax],	r10b
    mov       rax,	rdi
    mov       r10,	10
    cqo       
    idiv      r10
    add       rax,	48
    mov       r10,	r12
    inc       r12
    mov       [r10],	al
    mov       rax,	rdi
    mov       r10,	10
    cqo       
    idiv      r10
    xchg      rax,	rdx
    add       rax,	48
    mov       r10,	r12
    inc       r12
    mov       [r10],	al
    mov       rax,	r12
    inc       r12
    mov       r10b,	62
    mov       [rax],	r10b
    jmp       L1086
L1093:
    mov       rax,	rdi
    cmp       rax,	32
    jl        L1095
    cmp       rax,	126
    jg        L1095
    mov       rax,	r12
    inc       r12
    mov       r10b,	dil
    mov       [rax],	r10b
    jmp       L1094
L1095:
    mov       rax,	r12
    inc       r12
    mov       r10b,	92
    mov       [rax],	r10b
    mov       rax,	r12
    inc       r12
    mov       r10b,	120
    mov       [rax],	r10b
    lea       rcx,	[rbp + pc_api.convertstring.str]
    call      msys.m$print_startstr
    mov       rcx,	rdi
    lea       rdx,	[L12164]
    call      msys.m$print_i64
    call      msys.m$print_end
    mov       al,	[rbp + pc_api.convertstring.str]
    mov       r10,	r12
    inc       r12
    mov       [r10],	al
    mov       al,	[rbp + pc_api.convertstring.str+1]
    mov       r10,	r12
    inc       r12
    mov       [r10],	al
L1094:
L1086:
L1084:
    mov       rax,	rsi
    inc       rsi
    movzx     rax,	byte [rax]
    mov       rdi,	rax
    test      rax,	rax
    jnz       L1083
    xor       eax,	eax
    mov       [r12],	al
    mov       rax,	r12
    sub       rax,	rbx
L1082:
;---------------
    add       rsp,	48
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_diags.strpcl
pc_diags.strpcl:
;?>>
    %define pc_diags.strpcl.p 64
    %define pc_diags.strpcl.str -256
   %define R.opcode rdi
   %define R.n rbx
   %define R.x rsi
   %define R.y r12
   %define R.d r13
   %define R.e r14
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	288
    mov       [rbp+64],	rcx
;---------------
    mov       rax,	[rbp + pc_diags.strpcl.p]
    movzx     rax,	byte [rax]
    mov       rdi,	rax
    mov       rax,	rdi
    cmp       rax,	127
    jz        L1098
    cmp       rax,	128
    jz        L1099
    cmp       rax,	135
    jz        L1100
    cmp       rax,	120
    jz        L1101
    cmp       rax,	121
    jz        L1101
    cmp       rax,	122
    jz        L1102
    cmp       rax,	136
    jz        L1103
    cmp       rax,	125
    jz        L1104
    cmp       rax,	123
    jz        L1105
    cmp       rax,	124
    jz        L1105
    jmp       L1106
L1098:
    mov       rax,	[rbp + pc_diags.strpcl.p]
    mov       rax,	[rax+8]
    mov       rcx,	rax
    mov       rdx,	1
    call      pc_diags.strlabel
    mov       rax,	[rbp + pc_diags.strpcl.p]
    mov       eax,	[rax+16]
    test      eax,	eax
    jz        L1108
    lea       rcx,	[L12165]
    call      pc_diags.psstr
L1108:
    jmp       L1096
L1099:
    lea       rcx,	[L12166]
    call      pc_diags.psstr
    mov       rax,	[rbp + pc_diags.strpcl.p]
    mov       rax,	[rax+8]
    mov       rcx,	[rax]
    call      pc_diags.psstr
    lea       rcx,	[L12167]
    call      pc_diags.psstr
    jmp       L1096
L1100:
    mov       rax,	[rbp + pc_diags.strpcl.p]
    mov       rax,	[rax+8]
    mov       al,	[rax]
    test      al,	al
    jz        L1110
    lea       rcx,	[L12168]
    call      pc_diags.psstr
    mov       rax,	[rbp + pc_diags.strpcl.p]
    mov       rcx,	[rax+8]
    call      pc_diags.psstr
    jmp       L1109
L1110:
    lea       rcx,	[L12169]
    call      pc_diags.psstr
L1109:
    jmp       L1096
L1101:
    mov       rax,	[rbp + pc_diags.strpcl.p]
    mov       r13,	[rax+8]
    cmp       rdi,	121
    jnz       L1112
    lea       rcx,	[L12170]
    call      pc_diags.psstr
    jmp       L1111
L1112:
    lea       rcx,	[L12171]
    call      pc_diags.psstr
L1111:
    lea       rcx,	[L12172]
    call      pc_diags.psstr
    mov       rcx,	r13
    call      pc_diags.psname
    mov       rax,	[rbp + pc_diags.strpcl.p]
    mov       rax,	[rax+8]
    mov       al,	[rax+81]
    test      al,	al
    jz        L1114
    lea       rax,	[L12173]
    jmp       L1113
L1114:
    lea       rax,	[L12174]
L1113:
    mov       rcx,	rax
    call      pc_diags.psstr
    mov       al,	[r13+83]
    test      al,	al
    jz        L1116
    lea       rcx,	[L12174]
    call      pc_diags.psstr
L1116:
    call      pc_diags.psline
    mov       r14,	[r13+16]
    jmp       L1120
L1117:
    lea       rcx,	[L12175]
    call      pc_diags.psstr
    mov       eax,	[r14+84]
    movzx     r10,	byte [r14+82]
    mov       rcx,	r10
    mov       rdx,	rax
    call      pc_api.strpmode
    mov       rcx,	rax
    call      pc_diags.psstr
    lea       rcx,	[L12176]
    call      pc_diags.psstr
    mov       rcx,	[r14]
    call      pc_diags.psstr
    call      pc_diags.psline
    mov       r14,	[r14+16]
L1120:
    test      r14,	r14
    jnz       L1117
    mov       r14,	[r13+24]
    jmp       L1124
L1121:
    lea       rcx,	[L12177]
    call      pc_diags.psstr
    mov       eax,	[r14+84]
    movzx     r10,	byte [r14+82]
    mov       rcx,	r10
    mov       rdx,	rax
    call      pc_api.strpmode
    mov       rcx,	rax
    call      pc_diags.psstr
    lea       rcx,	[L12178]
    call      pc_diags.psstr
    mov       rcx,	[r14]
    call      pc_diags.psstr
    call      pc_diags.psline
    mov       r14,	[r14+24]
L1124:
    test      r14,	r14
    jnz       L1121
    mov       rax,	[rbp + pc_diags.strpcl.p]
    mov       al,	[rax+3]
    test      al,	al
    jz        L1126
    lea       rcx,	[L12179]
    call      pc_diags.psstr
    mov       rax,	[rbp + pc_diags.strpcl.p]
    movzx     rax,	byte [rax+3]
    mov       rcx,	rax
    xor       edx,	edx
    call      pc_api.strpmode
    mov       rcx,	rax
    call      pc_diags.psstr
    call      pc_diags.psline
L1126:
    mov       al,	[r13+113]
    test      al,	al
    jz        L1128
    lea       rcx,	[L12180]
    call      pc_diags.psstrline
L1128:
    jmp       L1096
L1102:
    lea       rcx,	[L12181]
    call      pc_diags.psstr
    call      pc_diags.psline
    jmp       L1096
L1103:
    lea       rcx,	[L12182]
    call      pc_diags.psstr
    jmp       L1096
L1104:
    mov       rax,	[rbp + pc_diags.strpcl.p]
    movzx     rax,	byte [rax+3]
    cmp       rax,	11
    jnz       L1130
    mov       rcx,	[rbp + pc_diags.strpcl.p]
    call      pc_diags.psdata
    jmp       L1096
L1130:
    jmp       L1097
L1105:
    jmp       L1131
L1106:
L1097:
    lea       rcx,	[L12183]
    call      pc_diags.psstr
;pc_diags.strpcl.skiptab:
L1131:
    mov       rax,	rdi
    cmp       rax,	26
    jz        L1133
    cmp       rax,	31
    jz        L1134
    jmp       L1135
L1133:
    lea       rcx,	[rbp + pc_diags.strpcl.str]
    lea       rdx,	[L12184]
    call      strcpy
    mov       rax,	[rbp + pc_diags.strpcl.p]
    movzx     rax,	byte [rax+2]
    lea       r10,	[pc_tables.ccnames]
    mov       r10,	[r10 + rax*8]
    lea       rcx,	[rbp + pc_diags.strpcl.str]
    mov       rdx,	r10
    call      strcat
    jmp       L1132
L1134:
    lea       rcx,	[rbp + pc_diags.strpcl.str]
    lea       rdx,	[L12185]
    call      strcpy
    mov       rax,	[rbp + pc_diags.strpcl.p]
    movzx     rax,	byte [rax+2]
    lea       r10,	[pc_tables.ccnames]
    mov       r10,	[r10 + rax*8]
    lea       rcx,	[rbp + pc_diags.strpcl.str]
    mov       rdx,	r10
    call      strcat
    jmp       L1132
L1135:
    lea       rax,	[pc_tables.pclnames]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8]
    lea       rcx,	[rbp + pc_diags.strpcl.str]
    mov       rdx,	rax
    call      strcpy
L1132:
    mov       rcx,	[pc_diags.dest]
    lea       rdx,	[rbp + pc_diags.strpcl.str]
    mov       r8,	9
    mov       r9,	32
    call      mlib.gs_leftstr
    xor       eax,	eax
    mov       [rbp + pc_diags.strpcl.str],	al
    mov       rax,	[rbp + pc_diags.strpcl.p]
    mov       al,	[rax+3]
    test      al,	al
    jz        L1137
    mov       rax,	[rbp + pc_diags.strpcl.p]
    mov       eax,	[rax+4]
    mov       r10,	[rbp + pc_diags.strpcl.p]
    movzx     r10,	byte [r10+3]
    mov       rcx,	r10
    mov       rdx,	rax
    call      pc_api.strpmode
    lea       rcx,	[rbp + pc_diags.strpcl.str]
    mov       rdx,	rax
    call      strcat
    lea       rax,	[pc_tables.pclhastype]
    mov       r10,	rdi
    movzx     rax,	byte [rax + r10]
    cmp       rax,	2
    jnz       L1139
    lea       rcx,	[rbp + pc_diags.strpcl.str]
    lea       rdx,	[L12186]
    call      strcat
    mov       rax,	[rbp + pc_diags.strpcl.p]
    movsxd    rax,	dword [rax+28]
    and       rax,	255
    mov       rcx,	rax
    xor       edx,	edx
    call      pc_api.strpmode
    lea       rcx,	[rbp + pc_diags.strpcl.str]
    mov       rdx,	rax
    call      strcat
L1139:
    lea       rcx,	[rbp + pc_diags.strpcl.str]
    lea       rdx,	[L12187]
    call      strcat
L1137:
    mov       rcx,	[pc_diags.dest]
    lea       rdx,	[rbp + pc_diags.strpcl.str]
    mov       r8,	4
    mov       r9,	32
    call      mlib.gs_leftstr
    xor       eax,	eax
    mov       [rbp + pc_diags.strpcl.str],	al
    lea       rax,	[pc_tables.pclextra]
    mov       r10,	rdi
    movzx     rax,	byte [rax + r10]
    mov       rbx,	rax
    test      rbx,	rbx
    jz        L1141
    mov       rax,	[rbp + pc_diags.strpcl.p]
    movsxd    rax,	dword [rax+16]
    mov       rsi,	rax
    mov       rax,	[rbp + pc_diags.strpcl.p]
    movsxd    rax,	dword [rax+20]
    mov       r12,	rax
    test      rsi,	rsi
    jnz       L1144
    cmp       rbx,	2
    jnz       L1143
L1144:
    lea       rcx,	[rbp + pc_diags.strpcl.str]
    lea       rdx,	[L12188]
    call      strcat
    mov       rax,	[rbp + pc_diags.strpcl.p]
    movsxd    rax,	dword [rax+16]
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.strint
    lea       rcx,	[rbp + pc_diags.strpcl.str]
    mov       rdx,	rax
    call      strcat
L1143:
    cmp       rbx,	2
    jnz       L1146
    test      r12,	r12
    jz        L1146
    lea       rcx,	[rbp + pc_diags.strpcl.str]
    lea       rdx,	[L12188]
    call      strcat
    mov       rcx,	r12
    xor       edx,	edx
    call      msys.strint
    lea       rcx,	[rbp + pc_diags.strpcl.str]
    mov       rdx,	rax
    call      strcat
L1146:
    lea       rcx,	[rbp + pc_diags.strpcl.str]
    lea       rdx,	[L12189]
    call      strcat
L1141:
    mov       rcx,	[pc_diags.dest]
    lea       rdx,	[rbp + pc_diags.strpcl.str]
    mov       r8,	5
    mov       r9,	32
    call      mlib.gs_leftstr
    mov       rax,	[rbp + pc_diags.strpcl.p]
    movzx     rax,	byte [rax+1]
    test      rax,	rax
    jz        L1148
    lea       rcx,	[L12189]
    call      pc_diags.psstr
    mov       rcx,	[rbp + pc_diags.strpcl.p]
    call      pc_diags.stropnd
    mov       rcx,	rax
    call      pc_diags.psstr
L1148:
    mov       rcx,	40
    call      pc_diags.pstabto
L1096:
;---------------
    add       rsp,	288
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_diags.stropnd
pc_diags.stropnd:
;?>>
   %define R.p rsi
   %define R.length rdi
   %define R.d rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    test      rsi,	rsi
    jnz       L1151
    lea       rax,	[L12190]
    jmp       L1149
L1151:
    xor       eax,	eax
    lea       r10,	[pc_diags.stropnd.str]
    mov       [r10],	al
    movzx     rax,	byte [rsi+1]
    cmp       rax,	4
    jz        L1153
    cmp       rax,	5
    jz        L1154
    cmp       rax,	10
    jz        L1154
    cmp       rax,	11
    jz        L1154
    cmp       rax,	6
    jz        L1154
    cmp       rax,	7
    jz        L1155
    cmp       rax,	1
    jz        L1156
    cmp       rax,	2
    jz        L1157
    cmp       rax,	3
    jz        L1158
    test      rax,	rax
    jz        L1159
    cmp       rax,	9
    jz        L1160
    cmp       rax,	12
    jz        L1161
    jmp       L1162
L1153:
    mov       rax,	[rsi+8]
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.strint
    jmp       L1149
L1154:
    movq      XMM4,	[rsi+8]
    comisd    XMM4,	[L12191]
    jnz       L1164
    lea       rcx,	[pc_diags.stropnd.str]
    call      msys.m$print_startstr
    lea       rcx,	[L12192]
    call      msys.m$print_setfmt
    call      msys.m$print_end
    jmp       L1163
L1164:
    lea       rcx,	[pc_diags.stropnd.str]
    call      msys.m$print_startstr
    movq      XMM4,	[rsi+8]
    movq      XMM0,	XMM4
    lea       rdx,	[L12193]
    call      msys.m$print_r64
    call      msys.m$print_end
L1163:
    jmp       L1152
L1155:
    mov       rax,	[rsi+8]
    mov       rcx,	rax
    call      strlen
    mov       rdi,	rax
    cmp       rax,	256
    jge       L1166
    lea       rcx,	[pc_diags.stropnd.str]
    lea       rdx,	[L12194]
    call      strcpy
    lea       rax,	[pc_diags.stropnd.str]
    lea       rax,	[rax+1]
    mov       r10,	[rsi+8]
    mov       rcx,	r10
    mov       rdx,	rax
    call      pc_api.convertstring
    lea       rcx,	[pc_diags.stropnd.str]
    lea       rdx,	[L12194]
    call      strcat
    jmp       L1165
L1166:
    mov       rax,	[pc_diags.stropnd.longstring]
    test      rax,	rax
    jz        L1168
    mov       rcx,	[pc_diags.stropnd.longstring]
    mov       rdx,	[pc_api.longstringlen]
    call      mlib.pcm_free
L1168:
    mov       rax,	rdi
    shl       rax,	1
    mov       [pc_api.longstringlen],	rax
    mov       rcx,	[pc_api.longstringlen]
    call      mlib.pcm_alloc
    mov       [pc_diags.stropnd.longstring],	rax
    mov       al,	34
    mov       r10,	[pc_diags.stropnd.longstring]
    mov       [r10],	al
    mov       rax,	[pc_diags.stropnd.longstring]
    lea       rax,	[rax+1]
    mov       r10,	[rsi+8]
    mov       rcx,	r10
    mov       rdx,	rax
    call      pc_api.convertstring
    mov       rdi,	rax
    mov       al,	34
    mov       r10,	[pc_diags.stropnd.longstring]
    mov       r11,	rdi
    mov       [r10 + r11+1],	al
    xor       eax,	eax
    mov       r10,	[pc_diags.stropnd.longstring]
    mov       r11,	rdi
    mov       [r10 + r11+2],	al
    mov       rax,	[pc_diags.stropnd.longstring]
    jmp       L1149
L1165:
    jmp       L1152
L1156:
    mov       rbx,	[rsi+8]
    mov       rax,	[rsi+8]
    mov       rax,	[rax]
    lea       rcx,	[pc_diags.stropnd.str]
    mov       rdx,	rax
    call      strcat
    movzx     rax,	byte [rsi]
    cmp       rax,	123
    jz        L1171
    cmp       rax,	124
    jnz       L1170
L1171:
    lea       rcx,	[pc_diags.stropnd.str]
    lea       rdx,	[L12195]
    call      strcat
    mov       al,	[rbx+81]
    test      al,	al
    jz        L1173
    lea       rcx,	[pc_diags.stropnd.str]
    lea       rdx,	[L12195]
    call      strcat
L1173:
L1170:
    jmp       L1152
L1157:
    lea       rcx,	[pc_diags.stropnd.str]
    lea       rdx,	[L12196]
    call      strcpy
    jmp       L1156
L1158:
    lea       rcx,	[pc_diags.stropnd.str]
    call      msys.m$print_startstr
    lea       rcx,	[L12197]
    call      msys.m$print_setfmt
    lea       rcx,	[L12198]
    call      msys.m$print_str_nf
    mov       rcx,	[rsi+8]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L1152
L1159:
    lea       rax,	[L12199]
    jmp       L1149
L1160:
    mov       rax,	[rsi+8]
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.strint
    jmp       L1149
L1161:
    lea       rcx,	[pc_diags.stropnd.str]
    call      msys.m$print_startstr
    lea       rcx,	[L12200]
    call      msys.m$print_setfmt
    mov       eax,	[rsi+4]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    mov       rcx,	[rsi+8]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L1152
L1162:
    call      msys.m$print_startcon
    lea       rcx,	[L12201]
    call      msys.m$print_str_nf
    movzx     rax,	byte [rsi+1]
    lea       r10,	[pc_tables.opndnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rax,	[L12202]
    jmp       L1149
L1152:
    lea       rax,	[pc_diags.stropnd.str]
L1149:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_diags.strpclstr
pc_diags.strpclstr:
;?>>
   %define R.p rdi
   %define R.buffsize rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	[pc_diags.dest]
    call      mlib.gs_free
    mov       rcx,	[pc_diags.dest]
    call      mlib.gs_init
    xor       eax,	eax
    mov       [pc_diags.destlinestart],	rax
    mov       rcx,	rdi
    call      pc_diags.strpcl
    mov       rcx,	[pc_diags.dest]
    xor       edx,	edx
    call      mlib.gs_char
    mov       rax,	[pc_diags.dest]
    movsxd    rax,	dword [rax+8]
    cmp       rax,	rbx
    jl        L1176
    lea       rax,	[L12203]
    jmp       L1174
L1176:
    mov       rax,	[pc_diags.dest]
    mov       rax,	[rax]
L1174:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_diags.writepcl
pc_diags.writepcl:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      pc_diags.strpcl
    movzx     rax,	byte [rdi]
    cmp       rax,	120
    jnz       L1180
L1179:
    jmp       L1178
L1180:
    mov       rcx,	[pc_diags.dest]
    call      mlib.gs_line
L1178:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc pc_diags.writeallpcl
pc_diags.writeallpcl:
;?>>
   %define R.p rdi
   %define R.d rbx
   %define R.i rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
;---------------
    mov       rcx,	[pc_diags.dest]
    call      mlib.gs_init
    mov       rax,	[pc_diags.dest]
    movsxd    rax,	dword [rax+8]
    mov       [pc_diags.destlinestart],	rax
    mov       rcx,	[pc_diags.dest]
    lea       rdx,	[L12204]
    call      mlib.gs_strln
    mov       rsi,	1
    mov       rax,	[pc_decls.nplibfiles]
    cmp       rax,	1
    jl        L1184
L1182:
    lea       rcx,	[L12205]
    call      pc_diags.psstr
    lea       rax,	[pc_decls.plibfiles]
    mov       r10,	rsi
    mov       rcx,	[rax + r10*8-8]
    call      pc_diags.psstr
    lea       rcx,	[L12206]
    call      pc_diags.psstr
    call      pc_diags.psline
    inc       rsi
    cmp       rsi,	[pc_decls.nplibfiles]
    jle       L1182
L1184:
    mov       rax,	[pc_decls.nplibfiles]
    test      rax,	rax
    jz        L1186
    call      pc_diags.psline
L1186:
    mov       rbx,	[pc_decls.psymboltable]
    jmp       L1190
L1187:
    movzx     rax,	byte [rbx+72]
    cmp       rax,	1
    jnz       L1192
    lea       rcx,	[L12207]
    call      pc_diags.psstr
    mov       rcx,	[rbx]
    call      pc_diags.psstr
    mov       al,	[rbx+113]
    test      al,	al
    jz        L1194
    lea       rcx,	[L12208]
    call      pc_diags.psstr
L1194:
    call      pc_diags.psline
L1192:
    mov       rbx,	[rbx+8]
L1190:
    test      rbx,	rbx
    jnz       L1187
    mov       rdi,	[pc_api.pcstart]
    jmp       L1196
L1195:
    mov       rcx,	rdi
    call      pc_diags.writepcl
    mov       rax,	[pc_diags.dest]
    movsxd    rax,	dword [rax+8]
    mov       [pc_diags.destlinestart],	rax
    add       rdi,	32
L1196:
    cmp       rdi,	[pc_api.pccurr]
    jbe       L1195
    call      pc_diags.psline
    mov       rax,	[pc_api.longstring]
    test      rax,	rax
    jz        L1199
    mov       rcx,	[pc_api.longstring]
    mov       rdx,	[pc_api.longstringlen]
    call      mlib.pcm_free
L1199:
    mov       rax,	[pc_diags.dest]
L1181:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_diags.psstr
pc_diags.psstr:
;?>>
   %define R.s rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	[pc_diags.dest]
    mov       rdx,	rdi
    call      mlib.gs_str
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc pc_diags.psstrline
pc_diags.psstrline:
;?>>
   %define R.s rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	[pc_diags.dest]
    mov       rdx,	rdi
    call      mlib.gs_str
    mov       rcx,	[pc_diags.dest]
    call      mlib.gs_line
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc pc_diags.psline
pc_diags.psline:
;?>>
;?]]
    sub       rsp,	40
;---------------
    mov       rcx,	[pc_diags.dest]
    lea       rdx,	[L12209]
    call      mlib.gs_str
;---------------
    add       rsp,	40
    ret       
;End 
;Proc pc_diags.psint
pc_diags.psint:
;?>>
   %define R.a rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    xor       edx,	edx
    call      msys.strint
    mov       rcx,	[pc_diags.dest]
    mov       rdx,	rax
    call      mlib.gs_str
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc pc_diags.psname
pc_diags.psname:
;?>>
   %define R.d rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rax,	[rdi]
    mov       rcx,	[pc_diags.dest]
    mov       rdx,	rax
    call      mlib.gs_str
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc pc_diags.pstabto
pc_diags.pstabto:
;?>>
   %define R.n rbx
   %define R.col rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rax,	[pc_diags.dest]
    movsxd    rax,	dword [rax+8]
    sub       rax,	[pc_diags.destlinestart]
    mov       rdi,	rax
    jmp       L1207
L1206:
    lea       rcx,	[L12210]
    call      pc_diags.psstr
    inc       rdi
L1207:
    cmp       rbx,	rdi
    jg        L1206
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_diags.strlabel
pc_diags.strlabel:
;?>>
   %define R.labelno rdi
   %define R.colon rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    lea       rcx,	[L12211]
    call      pc_diags.psstr
    mov       rcx,	rdi
    call      pc_diags.psint
    test      rbx,	rbx
    jz        L1211
    lea       rcx,	[L12212]
    call      pc_diags.psstr
L1211:
    lea       rcx,	[L12213]
    call      pc_diags.psstr
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_diags.psopnd
pc_diags.psopnd:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      pc_diags.stropnd
    mov       rcx,	rax
    call      pc_diags.psstr
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc pc_diags.psdata
pc_diags.psdata:
;?>>
   %define R.p r13
   %define R.n rdi
   %define R.m rbx
   %define R.q rsi
   %define R.av_1 r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r13,	rcx
;---------------
    mov       eax,	[r13+4]
    mov       rdi,	rax
    mov       rsi,	[r13+8]
    test      rdi,	rdi
    jnz       L1215
    jmp       L1213
L1215:
    jmp       L1217
L1216:
    mov       rbx,	rdi
    cmp       rbx,	20
    jl        L1220
    mov       rbx,	20
L1220:
    mov       rax,	rbx
    sub       rdi,	rax
    lea       rcx,	[L12214]
    call      pc_diags.psstr
    mov       rcx,	rbx
    call      pc_diags.psint
    lea       rcx,	[L12215]
    call      pc_diags.psstr
    cmp       rbx,	10
    jge       L1222
    lea       rcx,	[L12216]
    call      pc_diags.psstr
L1222:
    mov       r12,	rbx
    cmp       r12,	0
    jle       L1225
L1223:
    movzx     rax,	byte [rsi]
    mov       rcx,	rax
    call      pc_diags.psint
    lea       rcx,	[L12216]
    call      pc_diags.psstr
    inc       rsi
    dec       r12
    jnz       L1223
L1225:
    test      rdi,	rdi
    jz        L1227
    call      pc_diags.psline
L1227:
L1217:
    cmp       rdi,	0
    jg        L1216
L1213:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_diags.writepst
pc_diags.writepst:
;?>>
   %define R.localfile dil
   %define R.i rbx
   %define R.j rsi
   %define R.d r12
   %define R.e r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
;---------------
    xor       dil,	dil
    xor       eax,	eax
    mov       rbx,	rax
    mov       rcx,	[pc_diags.dest]
    call      mlib.gs_init
    lea       rcx,	[L12217]
    call      pc_diags.psstrline
    call      pc_diags.psline
    mov       r12,	[pc_decls.psymboltable]
    jmp       L1232
L1229:
    mov       al,	[r12+73]
    test      al,	al
    jnz       L1234
    mov       rcx,	r12
    lea       rdx,	[L12218]
    call      msys.strint
    mov       rcx,	rax
    call      pc_diags.psstr
    lea       rcx,	[L12219]
    call      pc_diags.psstr
    mov       rcx,	r12
    lea       rdx,	[L12220]
    call      pc_diags.writepsymbol
    movzx     rax,	byte [r12+72]
    cmp       rax,	2
    jz        L1237
    cmp       rax,	1
    jnz       L1236
L1237:
    mov       r13,	[r12+16]
    xor       rsi,	rsi
    jmp       L1241
L1238:
    lea       rcx,	[L12221]
    call      pc_diags.psstr
    mov       rcx,	r13
    lea       rdx,	[L12222]
    call      pc_diags.writepsymbol
    mov       r13,	[r13+16]
L1241:
    test      r13,	r13
    jnz       L1238
    mov       r13,	[r12+24]
    xor       rsi,	rsi
    jmp       L1245
L1242:
    lea       rcx,	[L12223]
    call      pc_diags.psstr
    mov       rcx,	r13
    lea       rdx,	[L12224]
    call      pc_diags.writepsymbol
    mov       r13,	[r13+24]
L1245:
    test      r13,	r13
    jnz       L1242
L1236:
    call      pc_diags.psline
L1234:
    mov       r12,	[r12+8]
L1232:
    test      r12,	r12
    jnz       L1229
    call      pc_diags.psline
    mov       rax,	[pc_diags.dest]
L1228:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_diags.writepsymbol
pc_diags.writepsymbol:
;?>>
   %define R.d rsi
   %define R.fmt r12
   %define R.localfile dil
    %define pc_diags.writepsymbol.str -256
   %define R.av_1 rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	288
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    xor       dil,	dil
    lea       rcx,	[rbp + pc_diags.writepsymbol.str]
    call      msys.m$print_startstr
    mov       eax,	[rsi+120]
    mov       rcx,	rax
    lea       rdx,	[L12225]
    call      msys.m$print_i64
    movzx     rax,	byte [rsi+72]
    lea       r10,	[pc_tables.idnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       rcx,	[rbp + pc_diags.writepsymbol.str]
    call      pc_diags.psstr
    movzx     rax,	byte [rsi+72]
    lea       r10,	[pc_tables.idnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      strlen
    mov       r10,	8
    sub       r10,	rax
    mov       rbx,	r10
    cmp       rbx,	0
    jle       L1249
L1247:
    lea       rcx,	[L12226]
    call      pc_diags.psstr
    dec       rbx
    jnz       L1247
L1249:
    xor       eax,	eax
    mov       [rbp + pc_diags.writepsymbol.str],	al
    lea       rcx,	[rbp + pc_diags.writepsymbol.str]
    call      msys.m$print_startstr
    mov       rax,	[rsi]
    mov       rcx,	rax
    mov       rdx,	r12
    call      msys.m$print_str
    call      msys.m$print_end
    lea       rcx,	[rbp + pc_diags.writepsymbol.str]
    call      pc_diags.psstr
    mov       eax,	[rsi+84]
    movzx     r10,	byte [rsi+82]
    mov       rcx,	r10
    mov       rdx,	rax
    call      pc_api.strpmode
    mov       rcx,	rax
    call      pc_diags.psstr
    movzx     rax,	byte [rsi+72]
    cmp       rax,	2
    jnz       L1251
    lea       rcx,	[L12227]
    call      pc_diags.psstr
    movzx     rax,	byte [rsi+112]
    mov       rcx,	rax
    call      pc_diags.psint
    lea       rcx,	[L12228]
    call      pc_diags.psstr
    movsx     rax,	word [rsi+114]
    mov       rcx,	rax
    call      pc_diags.psint
L1251:
    mov       al,	[rsi+81]
    test      al,	al
    jz        L1253
    lea       rcx,	[L12229]
    call      pc_diags.psstr
L1253:
    mov       al,	[rsi+80]
    test      al,	al
    jz        L1255
    lea       rcx,	[L12230]
    call      pc_diags.psstr
L1255:
    mov       al,	[rsi+107]
    test      al,	al
    jz        L1257
    lea       rcx,	[L12231]
    call      pc_diags.psstr
    movzx     rax,	byte [rsi+107]
    mov       rcx,	rax
    call      pc_diags.psint
L1257:
    mov       al,	[rsi+108]
    test      al,	al
    jz        L1259
    lea       rcx,	[L12232]
    call      pc_diags.psstr
L1259:
    mov       al,	[rsi+95]
    test      al,	al
    jz        L1261
    lea       rcx,	[L12233]
    call      pc_diags.psstr
L1261:
    mov       al,	[rsi+83]
    test      al,	al
    jz        L1263
    lea       rcx,	[L12234]
    call      pc_diags.psstr
L1263:
    movzx     rax,	byte [rsi+72]
    cmp       rax,	2
    jnz       L1265
    lea       rcx,	[L12235]
    call      pc_diags.psstr
    mov       rax,	[rsi+56]
    mov       rcx,	rax
    lea       rdx,	[L12236]
    call      msys.strint
    mov       rcx,	rax
    call      pc_diags.psstr
L1265:
    mov       rax,	[rsi+32]
    test      rax,	rax
    jz        L1267
    lea       rcx,	[L12237]
    call      pc_diags.psstr
    mov       rax,	[rsi+32]
    mov       eax,	[rax+120]
    mov       rcx,	rax
    call      pc_diags.psint
    lea       rcx,	[L12238]
    call      pc_diags.psstr
    mov       rax,	[rsi+32]
    mov       rcx,	[rax]
    call      pc_diags.psstr
    lea       rcx,	[L12239]
    call      pc_diags.psstr
L1267:
    xor       eax,	eax
    test      ax,	ax
    jz        L1269
    movzx     rax,	byte [rsi+72]
    cmp       rax,	3
    jnz       L1269
    mov       rax,	[rsi+56]
    test      rax,	rax
    jz        L1269
    lea       rcx,	[L12240]
    call      pc_diags.psstr
    mov       rax,	[rsi+56]
    mov       rcx,	[rax]
    call      pc_diags.psstr
    lea       rcx,	[L12241]
    call      pc_diags.psstr
    mov       rax,	[rsi+24]
    mov       rcx,	rax
    lea       rdx,	[L12242]
    call      msys.strint
    mov       rcx,	rax
    call      pc_diags.psstr
    lea       rcx,	[L12243]
    call      pc_diags.psstr
L1269:
    xor       eax,	eax
    test      ax,	ax
    jz        L1271
    movzx     rax,	byte [rsi+72]
    cmp       rax,	2
    jnz       L1271
    movzx     rax,	byte [rsi+104]
    shr       eax,	1
    and       eax,	1
    test      rax,	rax
    jz        L1271
    lea       rcx,	[L12244]
    call      pc_diags.psstr
L1271:
    call      pc_diags.psline
;---------------
    add       rsp,	288
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_diags.showprocinfo
pc_diags.showprocinfo:
;?>>
   %define R.d rsi
    %define pc_diags.showprocinfo.str -256
   %define R.p rdi
   %define R.e rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	296
    mov       rsi,	rcx
;---------------
    mov       rdi,	[rsi+48]
    test      rdi,	rdi
    jnz       L1274
    jmp       L1272
L1274:
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       rcx,	[L12245]
    call      msys.m$print_setfmt
    mov       rcx,	[rsi]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       rcx,	[L12246]
    call      msys.m$print_setfmt
    movzx     rax,	byte [rdi+1]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       rcx,	[L12247]
    call      msys.m$print_setfmt
    movzx     rax,	byte [rdi+2]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       rcx,	[L12248]
    call      msys.m$print_setfmt
    movzx     rax,	byte [rdi+3]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       rcx,	[L12249]
    call      msys.m$print_setfmt
    movzx     rax,	byte [rdi+4]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       rcx,	[L12250]
    call      msys.m$print_setfmt
    movzx     rax,	byte [rdi+5]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       rcx,	[L12251]
    call      msys.m$print_setfmt
    movzx     rax,	byte [rdi+6]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       rcx,	[L12252]
    call      msys.m$print_setfmt
    movzx     rax,	byte [rdi+7]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    call      pc_diags.psline
    mov       rbx,	[rsi+16]
    jmp       L1278
L1275:
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       rcx,	[L12253]
    call      msys.m$print_setfmt
    mov       rcx,	[rbx]
    call      msys.m$print_str_nf
    movzx     rax,	byte [rbx+92]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    movzx     rax,	byte [rbx+88]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    mov       rbx,	[rbx+16]
L1278:
    test      rbx,	rbx
    jnz       L1275
    mov       rbx,	[rsi+24]
    jmp       L1282
L1279:
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       rcx,	[L12254]
    call      msys.m$print_setfmt
    mov       rcx,	[rbx]
    call      msys.m$print_str_nf
    movzx     rax,	byte [rbx+92]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    movzx     rax,	byte [rbx+88]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    mov       rbx,	[rbx+24]
L1282:
    test      rbx,	rbx
    jnz       L1279
    call      pc_diags.psline
L1272:
;---------------
    add       rsp,	296
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_reduce.pcl_reducetest
pc_reduce.pcl_reducetest:
;?>>
   %define R.nn rdi
   %define R.seqno rbx
   %define R.lab rsi
   %define R.nargs r12
   %define R.pc r13
   %define R.newpc r14
   %define R.pcnext r15
    %define pc_reduce.pcl_reducetest.pcproc -8
    %define pc_reduce.pcl_reducetest.labelmap -16
    %define pc_reduce.pcl_reducetest.pdef -24
    %define pc_reduce.pcl_reducetest.callstack -152
    %define pc_reduce.pcl_reducetest.ncall -160
    %define pc_reduce.pcl_reducetest.nprocs -168
    %define pc_reduce.pcl_reducetest.nleaf -176
    %define pc_reduce.pcl_reducetest.nallparams -184
    %define pc_reduce.pcl_reducetest.nalllocals -192
    %define pc_reduce.pcl_reducetest.av_1 -200
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	232
;---------------
    xor       eax,	eax
    mov       [rbp + pc_reduce.pcl_reducetest.nprocs],	rax
    xor       eax,	eax
    mov       [rbp + pc_reduce.pcl_reducetest.nleaf],	rax
    xor       eax,	eax
    mov       [rbp + pc_reduce.pcl_reducetest.nallparams],	rax
    xor       eax,	eax
    mov       [rbp + pc_reduce.pcl_reducetest.nalllocals],	rax
    mov       rax,	[pc_api.pccurr]
    sub       rax,	[pc_api.pcstart]
    shr       rax,	5
    inc       rax
    mov       rdi,	rax
    mov       r13,	[pc_api.pcstart]
    mov       rax,	[pc_api.mlabelno]
    shl       rax,	1
    mov       rcx,	rax
    call      mlib.pcm_allocz
    mov       [rbp + pc_reduce.pcl_reducetest.labelmap],	rax
    jmp       L1287
L1284:
    movzx     rax,	byte [r13]
    cmp       rax,	127
    jz        L1289
    cmp       rax,	42
    jz        L1290
    jmp       L1291
L1289:
    jmp       L1288
L1290:
    mov       rax,	[pc_api.icheckasmlabel]
    test      rax,	rax
    jz        L1293
    mov       rax,	[r13+8]
    mov       rcx,	rax
    mov       r10,	[pc_api.icheckasmlabel]
    call      r10
    mov       rsi,	rax
    test      rsi,	rsi
    jz        L1295
    mov       rax,	[rbp + pc_reduce.pcl_reducetest.labelmap]
    mov       r10,	rsi
    lea       rax,	[rax + r10*2-2]
    inc       word [rax]
L1295:
L1293:
    jmp       L1288
L1291:
    movzx     rax,	byte [r13+1]
    cmp       rax,	3
    jnz       L1297
    mov       rax,	[r13+8]
    mov       r10,	[rbp + pc_reduce.pcl_reducetest.labelmap]
    lea       r10,	[r10 + rax*2-2]
    inc       word [r10]
L1297:
L1288:
    add       r13,	32
L1287:
    cmp       r13,	[pc_api.pccurr]
    jbe       L1284
;pc_reduce.pcl_reducetest.skip:
    mov       r13,	[pc_api.pcstart]
    mov       rax,	[pc_api.pcstart]
    sub       rax,	32
    mov       r14,	rax
    xor       rbx,	rbx
    mov       rax,	rdi
    mov       [rbp + pc_reduce.pcl_reducetest.av_1],	rax
    mov       rax,	[rbp + pc_reduce.pcl_reducetest.av_1]
    cmp       rax,	0
    jle       L1301
L1299:
    lea       rax,	[r13+32]
    mov       r15,	rax
    movzx     rax,	byte [r13]
    lea       r10,	[pc_tables.pclargs]
    movzx     r10,	byte [r10 + rax]
    mov       r12,	r10
    test      r10,	r10
    jz        L1303
    cmp       r12,	9
    jnz       L1305
    movsxd    rax,	dword [r13+16]
    mov       r12,	rax
L1305:
    mov       rax,	[pc_decls.pinfo]
    movzx     rax,	byte [rax+4]
    mov       r10,	r12
    cmp       rax,	r10
    cmovl     rax,	r10
    mov       r10,	[pc_decls.pinfo]
    mov       [r10+4],	al
L1303:
    movzx     rax,	byte [r13+3]
    cmp       rax,	11
    jnz       L1307
    mov       rax,	[pc_decls.pinfo]
    test      rax,	rax
    jz        L1307
    mov       eax,	[r13+4]
    cmp       rax,	16
    jz        L1307
    mov       al,	1
    mov       r10,	[pc_decls.pinfo]
    mov       [r10+7],	al
L1307:
    movzx     rax,	byte [r13]
    cmp       rax,	135
    jz        L1309
    cmp       rax,	127
    jz        L1310
    cmp       rax,	120
    jz        L1311
    cmp       rax,	121
    jz        L1311
    cmp       rax,	18
    jz        L1312
    cmp       rax,	21
    jz        L1312
    cmp       rax,	19
    jz        L1312
    cmp       rax,	22
    jz        L1312
    cmp       rax,	131
    jz        L1313
    cmp       rax,	122
    jz        L1314
    cmp       rax,	42
    jz        L1315
    cmp       rax,	2
    jz        L1316
    cmp       rax,	5
    jz        L1316
    cmp       rax,	114
    jz        L1317
    cmp       rax,	113
    jz        L1318
    cmp       rax,	1
    jz        L1319
    jmp       L1320
L1309:
    jmp       L1308
L1310:
    mov       rax,	[r13+8]
    mov       r10,	[rbp + pc_reduce.pcl_reducetest.labelmap]
    mov       r10w,	[r10 + rax*2-2]
    test      r10w,	r10w
    jz        L1322
    jmp       L1320
L1322:
    jmp       L1308
L1311:
    inc       qword [rbp + pc_reduce.pcl_reducetest.nprocs]
    mov       rax,	[r13+8]
    mov       [rbp + pc_reduce.pcl_reducetest.pdef],	rax
    lea       rax,	[r14+32]
    mov       r10,	[rbp + pc_reduce.pcl_reducetest.pdef]
    mov       [r10+56],	rax
    mov       rcx,	8
    call      mlib.pcm_alloc
    mov       [pc_decls.pinfo],	rax
    mov       rax,	[pc_decls.pinfo]
    mov       r10,	[rbp + pc_reduce.pcl_reducetest.pdef]
    mov       [r10+48],	rax
    mov       al,	1
    mov       r10,	[pc_decls.pinfo]
    mov       [r10+3],	al
    mov       rax,	[rbp + pc_reduce.pcl_reducetest.pdef]
    mov       al,	[rax+112]
    mov       r10,	[pc_decls.pinfo]
    mov       [r10+1],	al
    mov       rax,	[rbp + pc_reduce.pcl_reducetest.pdef]
    mov       ax,	[rax+114]
    mov       r10,	[pc_decls.pinfo]
    mov       [r10+2],	al
    mov       rax,	[rbp + pc_reduce.pcl_reducetest.pdef]
    movzx     rax,	byte [rax+112]
    add       [rbp + pc_reduce.pcl_reducetest.nallparams],	rax
    mov       rax,	[rbp + pc_reduce.pcl_reducetest.pdef]
    movsx     rax,	word [rax+114]
    add       [rbp + pc_reduce.pcl_reducetest.nalllocals],	rax
    xor       eax,	eax
    mov       [rbp + pc_reduce.pcl_reducetest.ncall],	rax
    lea       rax,	[r14+32]
    mov       [rbp + pc_reduce.pcl_reducetest.pcproc],	rax
    jmp       L1320
    jmp       L1308
L1312:
    xor       eax,	eax
    mov       r10,	[pc_decls.pinfo]
    mov       [r10+3],	al
    dec       qword [rbp + pc_reduce.pcl_reducetest.ncall]
    jmp       L1320
    jmp       L1308
L1313:
    add       r14,	32
    mov       rax,	r13
    mov       r10,	[rax]
    mov       [r14],	r10
    mov       r10,	[rax+8]
    mov       [r14+8],	r10
    mov       r10,	[rax+16]
    mov       [r14+16],	r10
    mov       r10,	[rax+24]
    mov       [r14+24],	r10
    inc       rbx
    mov       rax,	rbx
    lea       r10,	[r14+28]
    mov       r8d,	[r10]
    mov       r11,	-4294967041
    shl       eax,	8
    and       r8d,	r11d
    or        r8d,	eax
    mov       [r10],	r8d
    inc       qword [rbp + pc_reduce.pcl_reducetest.ncall]
    mov       rax,	[rbp + pc_reduce.pcl_reducetest.ncall]
    mov       r10,	r14
    mov       [rbp + rax*8 + pc_reduce.pcl_reducetest.callstack-8],	r10
    jmp       L1308
L1314:
    mov       rax,	[pc_decls.pinfo]
    mov       al,	[rax+3]
    test      al,	al
    jz        L1324
    inc       qword [rbp + pc_reduce.pcl_reducetest.nleaf]
L1324:
    xor       eax,	eax
    mov       [pc_decls.pinfo],	rax
    jmp       L1320
    jmp       L1308
L1315:
    mov       al,	1
    mov       r10,	[pc_decls.pinfo]
    mov       [r10+5],	al
    jmp       L1320
    jmp       L1308
L1316:
    movzx     rax,	byte [r14]
    cmp       rax,	57
    jnz       L1326
    movzx     rax,	byte [r13+3]
    cmp       rax,	11
    jz        L1326
    mov       al,	[r13+3]
    mov       [r14+3],	al
    movzx     rax,	byte [r13]
    cmp       rax,	2
    jnz       L1328
    mov       rax,	3
    jmp       L1327
L1328:
    mov       rax,	6
L1327:
    mov       [r14],	al
    jmp       L1325
L1326:
    jmp       L1320
L1325:
    jmp       L1308
L1317:
    movzx     rax,	byte [r15]
    cmp       rax,	113
    jnz       L1330
    movsxd    rax,	dword [r13+28]
    and       rax,	255
    movsxd    r10,	dword [r15+28]
    and       r10,	255
    cmp       rax,	r10
    jnz       L1330
    add       r13,	32
    jmp       L1329
L1330:
    movzx     rax,	byte [r15]
    cmp       rax,	28
    jz        L1332
    cmp       rax,	27
    jnz       L1331
L1332:
    movsxd    rax,	dword [r13+28]
    and       rax,	255
    mov       [r15+3],	al
    jmp       L1329
L1331:
    jmp       L1320
L1329:
    jmp       L1308
L1318:
    movzx     rax,	byte [r14]
    cmp       rax,	1
    jz        L1335
    cmp       rax,	2
    jz        L1335
    cmp       rax,	3
    jnz       L1334
L1335:
    movzx     rax,	byte [r14+3]
    movsxd    r10,	dword [r13+28]
    and       r10,	255
    cmp       rax,	r10
    jz        L1333
L1334:
    jmp       L1320
L1333:
    jmp       L1308
L1319:
    movzx     rax,	byte [r13+1]
    cmp       rax,	4
    jnz       L1337
    movzx     rax,	byte [r15]
    movzx     r10,	byte [r14]
    cmp       r10,	rax
    jnz       L1338
    cmp       r10,	57
    jnz       L1338
    mov       rax,	1
    jmp       L1339
L1338:
    xor       eax,	eax
L1339:
    test      rax,	rax
    setnz     al
    movzx     eax,	al
    test      ax,	ax
    jz        L1337
    mov       rax,	[r13+8]
    movsxd    r10,	dword [r15+16]
    imul      rax,	r10
    movsxd    r10,	dword [r15+20]
    add       rax,	r10
    lea       r10,	[r14+20]
    add       [r10],	eax
    add       r13,	32
    jmp       L1336
L1337:
    movzx     rax,	byte [r15]
    cmp       rax,	11
    jnz       L1340
    add       r13,	32
    jmp       L1336
L1340:
    jmp       L1320
L1336:
    jmp       L1308
L1320:
    add       r14,	32
    mov       rax,	r13
    mov       r10,	[rax]
    mov       [r14],	r10
    mov       r10,	[rax+8]
    mov       [r14+8],	r10
    mov       r10,	[rax+16]
    mov       [r14+16],	r10
    mov       r10,	[rax+24]
    mov       [r14+24],	r10
    inc       rbx
    mov       rax,	rbx
    lea       r10,	[r14+28]
    mov       r8d,	[r10]
    mov       r11,	-4294967041
    shl       eax,	8
    and       r8d,	r11d
    or        r8d,	eax
    mov       [r10],	r8d
    movzx     rax,	byte [r14+1]
    cmp       rax,	2
    jnz       L1342
    movzx     rax,	byte [r14]
    cmp       rax,	1
    jnz       L1345
    mov       eax,	[r14+16]
    test      eax,	eax
    jnz       L1344
L1345:
    mov       rax,	[r14+8]
    mov       r10b,	1
    mov       [rax+88],	r10b
L1344:
L1342:
L1308:
    add       r13,	32
    dec       qword [rbp + pc_reduce.pcl_reducetest.av_1]
    jnz       L1299
L1301:
    mov       [pc_api.pccurr],	r14
    mov       rcx,	[rbp + pc_reduce.pcl_reducetest.labelmap]
    mov       rdx,	[pc_api.mlabelno]
    call      mlib.pcm_free
;---------------
    add       rsp,	232
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_run.dispatch_loop
pc_run.dispatch_loop:
;?>>
    %define pc_run.dispatch_loop.pcentry 72
    %define pc_run.dispatch_loop.cmain 80
   %define R.stack rdi
   %define R.pc rbx
   %define R.sp rsi
   %define R.fp r12
    %define pc_run.dispatch_loop.a -8
   %define R.ptr r13
   %define R.b r14
    %define pc_run.dispatch_loop.ptrb -16
    %define pc_run.dispatch_loop.n -24
    %define pc_run.dispatch_loop.d -32
    %define pc_run.dispatch_loop.callstack -40032
    %define pc_run.dispatch_loop.callstackst -120032
    %define pc_run.dispatch_loop.callsp -120040
    %define pc_run.dispatch_loop.str -120296
    %define pc_run.dispatch_loop.oldsp -120304
    %define pc_run.dispatch_loop.ncmd -120312
    %define pc_run.dispatch_loop.cmd -120320
    %define pc_run.dispatch_loop.lastpos -120328
    %define pc_run.dispatch_loop.count -120336
    %define pc_run.dispatch_loop.av_1 -120344
    %define pc_run.dispatch_loop.av_2 -120352
    %define pc_run.dispatch_loop.$T1 -120360
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	120392
    mov       [rbp+72],	rcx
    mov       [rbp+80],	rdx
;---------------
    mov       rbx,	[rbp + pc_run.dispatch_loop.pcentry]
    xor       rsi,	rsi
    xor       eax,	eax
    mov       r12,	rax
    xor       eax,	eax
    mov       [rbp + pc_run.dispatch_loop.callsp],	rax
    mov       rcx,	560000
    call      mlib.pcm_alloc
    mov       rdi,	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.cmain]
    test      rax,	rax
    jz        L1348
    mov       rax,	[msys.ncmdparams]
    mov       [rbp + pc_run.dispatch_loop.ncmd],	rax
    mov       rax,	[msys.cmdparams]
    mov       [rbp + pc_run.dispatch_loop.cmd],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.ncmd]
    sub       rax,	[pc_decls.pcmdskip]
    mov       [rbp + pc_run.dispatch_loop.ncmd],	rax
    mov       rax,	[pc_decls.pcmdskip]
    shl       rax,	3
    mov       r10,	[rbp + pc_run.dispatch_loop.cmd]
    lea       r10,	[r10 + rax]
    mov       [rbp + pc_run.dispatch_loop.cmd],	r10
    inc       rsi
    mov       rax,	rsi
    mov       r10,	[rbp + pc_run.dispatch_loop.cmd]
    mov       [rdi + rax*8-8],	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.ncmd]
    inc       rax
    inc       rsi
    mov       r10,	rsi
    mov       [rdi + r10*8-8],	rax
    inc       rsi
    mov       rax,	rsi
    xor       r10d,	r10d
    mov       [rdi + rax*8-8],	r10
L1348:
    xor       eax,	eax
    mov       [rbp + pc_run.dispatch_loop.lastpos],	rax
    xor       eax,	eax
    mov       [rbp + pc_run.dispatch_loop.count],	rax
    mov       rax,	[pc_run.dotrace]
    test      rax,	rax
    jz        L1350
    lea       rax,	[L12255]
    lea       r10,	[pc_run.emptyst]
    mov       [r10],	rax
L1350:
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1353:
    dq  L1355
    dq  L1356
    dq  L1359
    dq  L1360
    dq  L1361
    dq  L1368
    dq  L1369
    dq  L1354
    dq  L1370
    dq  L1370
    dq  L1371
    dq  L1372
    dq  L1373
    dq  L1375
    dq  L1376
    dq  L1377
    dq  L1378
    dq  L1381
    dq  L1382
    dq  L1407
    dq  L1397
    dq  L1382
    dq  L1415
    dq  L1402
    dq  L1420
    dq  L1421
    dq  L1422
    dq  L1430
    dq  L1433
    dq  L1436
    dq  L1437
    dq  L1438
    dq  L1445
    dq  L1446
    dq  L1449
    dq  L1452
    dq  L1455
    dq  L1458
    dq  L1458
    dq  L1461
    dq  L1462
    dq  L1463
    dq  L1464
    dq  L1465
    dq  L1468
    dq  L1471
    dq  L1474
    dq  L1475
    dq  L1478
    dq  L1481
    dq  L1482
    dq  L1483
    dq  L1484
    dq  L1485
    dq  L1486
    dq  L1489
    dq  L1493
    dq  L1497
    dq  L1498
    dq  L1499
    dq  L1500
    dq  L1503
    dq  L1506
    dq  L1507
    dq  L1508
    dq  L1509
    dq  L1510
    dq  L1513
    dq  L1514
    dq  L1515
    dq  L1516
    dq  L1517
    dq  L1518
    dq  L1519
    dq  L1520
    dq  L1521
    dq  L1522
    dq  L1523
    dq  L1524
    dq  L1525
    dq  L1526
    dq  L1527
    dq  L1528
    dq  L1531
    dq  L1532
    dq  L1533
    dq  L1534
    dq  L1535
    dq  L1536
    dq  L1537
    dq  L1538
    dq  L1541
    dq  L1544
    dq  L1547
    dq  L1547
    dq  L1550
    dq  L1551
    dq  L1552
    dq  L1553
    dq  L1554
    dq  L1555
    dq  L1558
    dq  L1562
    dq  L1566
    dq  L1567
    dq  L1568
    dq  L1569
    dq  L1570
    dq  L1571
    dq  L1572
    dq  L1573
    dq  L1574
    dq  L1577
    dq  L1578
    dq  L1579
    dq  L1580
    dq  L1581
    dq  L1582
    dq  L1583
    dq  L1584
    dq  L1585
    dq  L1591
    dq  L1592
    dq  L1593
    dq  L1594
    dq  L1595
    dq  L1606
    dq  L1596
    dq  L1597
    dq  L1598
    dq  L1599
    dq  L1600
    dq  L1601
    dq  L1602
    dq  L1603
    dq  L1604
    dq  L1605
L1355:
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1356:
    movzx     rax,	byte [rbx+1]
    cmp       rax,	4
    jnz       L1358
    mov       rax,	[rbx+8]
    inc       rsi
    mov       r10,	rsi
    mov       [rdi + r10*8-8],	rax
    jmp       L1357
L1358:
    lea       rax,	[rdi + r12*8-8]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      pc_runaux.pci_getopnd
    inc       rsi
    mov       r10,	rsi
    mov       [rdi + r10*8-8],	rax
L1357:
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1359:
    movzx     rax,	byte [rbx+3]
    mov       r10,	[rdi + rsi*8-8]
    mov       rcx,	r10
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rdi + rsi*8-8],	rax
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1360:
    mov       rax,	rsi
    dec       rsi
    mov       rax,	[rdi + rax*8-8]
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	[rdi + rsi*8-8]
    movsxd    r10,	dword [rbx+16]
    mov       r11,	[rbp + pc_run.dispatch_loop.a]
    imul      r11,	r10
    lea       rax,	[rax + r11]
    movsxd    r10,	dword [rbx+20]
    lea       rax,	[rax + r10]
    mov       r13,	rax
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rdi + rsi*8-8],	rax
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1361:
    movzx     rax,	byte [rbx+1]
    cmp       rax,	1
    jnz       L1364
L1363:
    mov       rax,	[rbx+8]
    mov       [rbp + pc_run.dispatch_loop.d],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.d]
    movzx     rax,	byte [rax+72]
    cmp       rax,	3
    jnz       L1366
    mov       rax,	[rbp + pc_run.dispatch_loop.d]
    mov       r13,	[rax+56]
    jmp       L1365
L1366:
    movzx     rax,	byte [rbx+3]
    cmp       rax,	11
    jnz       L1367
    mov       rax,	[rbp + pc_run.dispatch_loop.d]
    movzx     rax,	byte [rax+72]
    cmp       rax,	5
    jnz       L1367
    mov       rax,	[rbp + pc_run.dispatch_loop.d]
    movsxd    rax,	dword [rax+76]
    mov       r10,	r12
    add       r10,	rax
    mov       r10,	[rdi + r10*8-8]
    mov       r13,	r10
    jmp       L1365
L1367:
    mov       rax,	[rbp + pc_run.dispatch_loop.d]
    movsxd    rax,	dword [rax+76]
    mov       r10,	r12
    add       r10,	rax
    lea       rax,	[rdi + r10*8-8]
    mov       r13,	rax
L1365:
    mov       eax,	[rbx+4]
    movzx     r10,	byte [rbx+3]
    mov       r11,	rsi
    dec       rsi
    mov       r11,	[rdi + r11*8-8]
    mov       rcx,	r13
    mov       rdx,	r11
    mov       r8,	r10
    mov       r9,	rax
    call      pc_runaux.pci_storeptr
    jmp       L1362
L1364:
    mov       rcx,	rbx
    call      pc_runaux.pcusopnd
L1362:
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1368:
    mov       rax,	rsi
    dec       rsi
    mov       r13,	[rdi + rax*8-8]
    mov       eax,	[rbx+4]
    movzx     r10,	byte [rbx+3]
    mov       r11,	rsi
    dec       rsi
    mov       r11,	[rdi + r11*8-8]
    mov       rcx,	r13
    mov       rdx,	r11
    mov       r8,	r10
    mov       r9,	rax
    call      pc_runaux.pci_storeptr
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1369:
    mov       rax,	rsi
    dec       rsi
    mov       rax,	[rdi + rax*8-8]
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	rsi
    dec       rsi
    mov       rax,	[rdi + rax*8-8]
    movsxd    r10,	dword [rbx+16]
    mov       r11,	[rbp + pc_run.dispatch_loop.a]
    imul      r11,	r10
    lea       rax,	[rax + r11]
    movsxd    r10,	dword [rbx+20]
    lea       rax,	[rax + r10]
    mov       r13,	rax
    mov       eax,	[rbx+4]
    movzx     r10,	byte [rbx+3]
    mov       r11,	rsi
    dec       rsi
    mov       r11,	[rdi + r11*8-8]
    mov       rcx,	r13
    mov       rdx,	r11
    mov       r8,	r10
    mov       r9,	rax
    call      pc_runaux.pci_storeptr
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1370:
    mov       rax,	[rdi + rsi*8-8]
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    inc       rsi
    mov       rax,	rsi
    mov       r10,	[rbp + pc_run.dispatch_loop.a]
    mov       [rdi + rax*8-8],	r10
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1371:
    movsxd    rax,	dword [rbx+16]
    dec       rax
    mov       r10,	rsi
    sub       r10,	rax
    lea       rax,	[rdi + r10*8-8]
    movsxd    r10,	dword [rbx+20]
    dec       r10
    mov       r11,	rsi
    sub       r11,	r10
    lea       r10,	[rdi + r11*8-8]
    mov       r11,	[rax]
    mov       r15,	[r10]
    mov       [r10],	r11
    mov       [rax],	r15
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1372:
    dec       rsi
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1373:
    jmp       L1374
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1375:
    jmp       L1374
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1376:
    mov       rax,	[rdi + rsi*8-16]
    mov       r10,	[rdi + rsi*8-8]
    mov       cl,	r10b
    shr       rax,	cl
    and       eax,	1
    mov       [rdi + rsi*8-16],	rax
    dec       rsi
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1377:
    mov       rax,	[rdi + rsi*8-8]
    mov       r10,	[rdi + rsi*8-16]
    mov       r11,	[rdi + rsi*8-24]
    mov       rcx,	r11
    mov       rdx,	r10
    mov       r8,	rax
    call      pc_runaux.pci_loadbf
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	2
    sub       rsi,	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.a]
    mov       [rdi + rsi*8-8],	rax
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1378:
    mov       r13,	[rdi + rsi*8-16]
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	[rdi + rsi*8-24]
    test      rax,	rax
    jz        L1380
    mov       rax,	[rdi + rsi*8-8]
    mov       r10,	1
    mov       rcx,	rax
    shl       r10,	cl
    or        [rbp + pc_run.dispatch_loop.a],	r10
    jmp       L1379
L1380:
    mov       rax,	[rdi + rsi*8-8]
    mov       r10,	1
    mov       rcx,	rax
    shl       r10,	cl
    not       r10
    and       [rbp + pc_run.dispatch_loop.a],	r10
L1379:
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	[rbp + pc_run.dispatch_loop.a]
    mov       r8,	rax
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    mov       rax,	3
    sub       rsi,	rax
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1381:
    mov       r13,	[rdi + rsi*8-24]
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	[rdi + rsi*8-32]
    mov       r10,	[rdi + rsi*8-8]
    mov       r11,	[rdi + rsi*8-16]
    mov       rcx,	[rbp + pc_run.dispatch_loop.a]
    mov       rdx,	r11
    mov       r8,	r10
    mov       r9,	rax
    call      pc_runaux.pci_storebf
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	[rbp + pc_run.dispatch_loop.a]
    mov       r8,	rax
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    mov       rax,	4
    sub       rsi,	rax
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1382:
    mov       rax,	[rbx+8]
    mov       [rbp + pc_run.dispatch_loop.d],	rax
    mov       rax,	[pc_run.dotrace]
    test      rax,	rax
    jz        L1384
    mov       rax,	[rbp + pc_run.dispatch_loop.callsp]
    mov       [rbp + pc_run.dispatch_loop.av_1],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.av_1]
    cmp       rax,	0
    jle       L1387
L1385:
    call      msys.m$print_startcon
    lea       rcx,	[L12256]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    dec       qword [rbp + pc_run.dispatch_loop.av_1]
    jnz       L1385
L1387:
    call      msys.m$print_startcon
    lea       rcx,	[L12257]
    call      msys.m$print_setfmt
    inc       qword [pc_run.seqno]
    mov       rcx,	[pc_run.seqno]
    call      msys.m$print_i64_nf
    mov       rax,	[rbp + pc_run.dispatch_loop.d]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    mov       rcx,	rbx
    call      pc_run.getlineno
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L1384:
    cmp       rsi,	69900
    jle       L1389
    mov       rcx,	rbx
    lea       rdx,	[L12258]
    lea       r8,	[L12259]
    call      pc_runaux.pcerrorx
L1389:
    mov       rax,	[rbp + pc_run.dispatch_loop.d]
    mov       al,	[rax+80]
    test      al,	al
    jz        L1391
    movsxd    rax,	dword [rbx+16]
    mov       [rbp + pc_run.dispatch_loop.n],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.n]
    dec       rax
    sub       rsi,	rax
    movzx     rax,	byte [rbx+3]
    push      rax
    movsxd    rax,	dword [rbx+20]
    push      rax
    lea       rax,	[rdi + rsi*8-8]
    mov       rcx,	[rbp + pc_run.dispatch_loop.d]
    xor       edx,	edx
    mov       r8,	rax
    mov       r9,	[rbp + pc_run.dispatch_loop.n]
    sub       rsp,	32
    call      pc_runaux.docalldll
    add       rsp,	48
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    movzx     rax,	byte [rbx]
    cmp       rax,	18
    jnz       L1393
    dec       rsi
    jmp       L1392
L1393:
    mov       rax,	[rbp + pc_run.dispatch_loop.a]
    mov       [rdi + rsi*8-8],	rax
L1392:
    add       rbx,	32
    jmp       L1390
L1391:
    mov       rax,	[rbp + pc_run.dispatch_loop.d]
    mov       rax,	[rax+56]
    test      rax,	rax
    jnz       L1394
    mov       rax,	[rbp + pc_run.dispatch_loop.d]
    mov       rax,	[rax]
    mov       rcx,	rbx
    lea       rdx,	[L12260]
    mov       r8,	rax
    call      pc_runaux.pcerrorx
    jmp       L1390
L1394:
    movsxd    rax,	dword [rbx+16]
    mov       r10,	rsi
    sub       r10,	rax
    mov       [rbp + pc_run.dispatch_loop.$T1],	r10
    movzx     rax,	byte [rbx]
    cmp       rax,	21
    jnz       L1396
    mov       rax,	1
    jmp       L1395
L1396:
    xor       eax,	eax
L1395:
    mov       r10,	[rbp + pc_run.dispatch_loop.$T1]
    add       r10,	rax
    inc       qword [rbp + pc_run.dispatch_loop.callsp]
    mov       rax,	[rbp + pc_run.dispatch_loop.callsp]
    mov       [rbp + rax*4 + pc_run.dispatch_loop.callstack-4],	r10d
    mov       rax,	[rbp + pc_run.dispatch_loop.d]
    mov       r10,	[rbp + pc_run.dispatch_loop.callsp]
    mov       [rbp + r10*8 + pc_run.dispatch_loop.callstackst-8],	rax
    lea       rax,	[rbx+32]
    movsxd    r10,	dword [rbx+16]
    or        rax,	r10
    inc       rsi
    mov       r10,	rsi
    mov       [rdi + r10*8-8],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.d]
    mov       rbx,	[rax+56]
L1390:
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1397:
    movsxd    rax,	dword [rbx+16]
    mov       [rbp + pc_run.dispatch_loop.n],	rax
    movsxd    rax,	dword [rbx+20]
    sub       rsi,	rax
    mov       rax,	rsi
    dec       rsi
    mov       r12,	[rdi + rax*8-8]
    mov       rax,	rsi
    dec       rsi
    mov       r13,	[rdi + rax*8-8]
    mov       rax,	r13
    and       rax,	15
    sub       rsi,	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.callsp]
    cmp       rax,	1
    jge       L1399
    mov       rcx,	rbx
    lea       rdx,	[L12261]
    lea       r8,	[L12262]
    call      pc_runaux.pcerrorx
L1399:
    mov       rax,	[rbp + pc_run.dispatch_loop.callsp]
    dec       qword [rbp + pc_run.dispatch_loop.callsp]
    mov       eax,	[rbp + rax*4 + pc_run.dispatch_loop.callstack-4]
    mov       [rbp + pc_run.dispatch_loop.oldsp],	rax
    cmp       rsi,	[rbp + pc_run.dispatch_loop.oldsp]
    jz        L1401
    lea       rcx,	[rbp + pc_run.dispatch_loop.str]
    call      msys.m$print_startstr
    lea       rcx,	[L12263]
    call      msys.m$print_setfmt
    mov       rcx,	[rbp + pc_run.dispatch_loop.oldsp]
    call      msys.m$print_i64_nf
    mov       rcx,	rsi
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    mov       rcx,	rbx
    lea       rdx,	[rbp + pc_run.dispatch_loop.str]
    lea       r8,	[L12264]
    call      pc_runaux.pcerrorx
L1401:
    mov       rax,	r13
    and       rax,	-16
    mov       rbx,	rax
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1402:
    mov       rax,	[rdi + rsi*8-8]
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    movsxd    rax,	dword [rbx+16]
    mov       [rbp + pc_run.dispatch_loop.n],	rax
    movsxd    rax,	dword [rbx+20]
    sub       rsi,	rax
    dec       rsi
    mov       rax,	rsi
    mov       r12,	[rdi + rax*8-8]
    dec       rsi
    mov       rax,	rsi
    mov       r13,	[rdi + rax*8-8]
    mov       rax,	r13
    and       rax,	15
    sub       rsi,	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.a]
    mov       [rdi + rsi*8-8],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.callsp]
    cmp       rax,	1
    jge       L1404
    mov       rcx,	rbx
    lea       rdx,	[L12265]
    lea       r8,	[L12266]
    call      pc_runaux.pcerrorx
L1404:
    mov       rax,	[rbp + pc_run.dispatch_loop.callsp]
    dec       qword [rbp + pc_run.dispatch_loop.callsp]
    mov       eax,	[rbp + rax*4 + pc_run.dispatch_loop.callstack-4]
    mov       [rbp + pc_run.dispatch_loop.oldsp],	rax
    cmp       rsi,	[rbp + pc_run.dispatch_loop.oldsp]
    jz        L1406
    lea       rcx,	[rbp + pc_run.dispatch_loop.str]
    call      msys.m$print_startstr
    lea       rcx,	[L12267]
    call      msys.m$print_setfmt
    mov       rcx,	[rbp + pc_run.dispatch_loop.oldsp]
    call      msys.m$print_i64_nf
    mov       rcx,	rsi
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    mov       rcx,	rbx
    lea       rdx,	[rbp + pc_run.dispatch_loop.str]
    lea       r8,	[L12268]
    call      pc_runaux.pcerrorx
L1406:
    mov       rax,	r13
    and       rax,	-16
    mov       rbx,	rax
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1407:
    mov       r13,	[rdi + rsi*8-8]
    test      r13,	r13
    jnz       L1409
    mov       rcx,	rbx
    lea       rdx,	[L12269]
    lea       r8,	[L12270]
    call      pc_runaux.pcerrorx
L1409:
    cmp       r13,	[pc_api.pcstart]
    jb        L1411
    cmp       r13,	[pc_api.pccurr]
    ja        L1411
;pc_run.dispatch_loop.icallp:
L1412:
    lea       rax,	[rsi-1]
    movsxd    r10,	dword [rbx+16]
    sub       rax,	r10
    mov       [rbp + pc_run.dispatch_loop.$T1],	rax
    movzx     rax,	byte [rbx]
    cmp       rax,	22
    jnz       L1414
    mov       rax,	1
    jmp       L1413
L1414:
    xor       eax,	eax
L1413:
    mov       r10,	[rbp + pc_run.dispatch_loop.$T1]
    add       r10,	rax
    inc       qword [rbp + pc_run.dispatch_loop.callsp]
    mov       rax,	[rbp + pc_run.dispatch_loop.callsp]
    mov       [rbp + rax*4 + pc_run.dispatch_loop.callstack-4],	r10d
    lea       rax,	[pc_run.emptyst]
    mov       r10,	[rbp + pc_run.dispatch_loop.callsp]
    mov       [rbp + r10*8 + pc_run.dispatch_loop.callstackst-8],	rax
    lea       rax,	[rbx+32]
    movsxd    r10,	dword [rbx+16]
    or        rax,	r10
    mov       [rdi + rsi*8-8],	rax
    mov       rbx,	r13
    jmp       L1410
L1411:
    movsxd    rax,	dword [rbx+16]
    mov       [rbp + pc_run.dispatch_loop.n],	rax
    dec       rsi
    mov       rax,	[rbp + pc_run.dispatch_loop.n]
    dec       rax
    sub       rsi,	rax
    movzx     rax,	byte [rbx+3]
    push      rax
    movsxd    rax,	dword [rbx+20]
    push      rax
    lea       rax,	[rdi + rsi*8-8]
    xor       ecx,	ecx
    mov       rdx,	r13
    mov       r8,	rax
    mov       r9,	[rbp + pc_run.dispatch_loop.n]
    sub       rsp,	32
    call      pc_runaux.docalldll
    add       rsp,	48
    dec       rsi
    add       rbx,	32
L1410:
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1415:
    mov       r13,	[rdi + rsi*8-8]
    test      r13,	r13
    jnz       L1417
    mov       rcx,	rbx
    lea       rdx,	[L12271]
    lea       r8,	[L12272]
    call      pc_runaux.pcerrorx
L1417:
    cmp       r13,	[pc_api.pcstart]
    jb        L1419
    cmp       r13,	[pc_api.pccurr]
    jbe       L1412
L1419:
    movsxd    rax,	dword [rbx+16]
    mov       [rbp + pc_run.dispatch_loop.n],	rax
    dec       rsi
    mov       rax,	[rbp + pc_run.dispatch_loop.n]
    dec       rax
    sub       rsi,	rax
    movzx     rax,	byte [rbx+3]
    push      rax
    movsxd    rax,	dword [rbx+20]
    push      rax
    lea       rax,	[rdi + rsi*8-8]
    xor       ecx,	ecx
    mov       rdx,	r13
    mov       r8,	rax
    mov       r9,	[rbp + pc_run.dispatch_loop.n]
    sub       rsp,	32
    call      pc_runaux.docalldll
    add       rsp,	48
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.a]
    mov       [rdi + rsi*8-8],	rax
    add       rbx,	32
L1418:
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1420:
    mov       rax,	[rbx+8]
    mov       r10,	[pc_run.labeltable]
    mov       r10,	[r10 + rax*8-8]
    mov       rbx,	r10
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1421:
    mov       rax,	rsi
    dec       rsi
    mov       rbx,	[rdi + rax*8-8]
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1422:
    movzx     rax,	byte [rbx+3]
    cmp       rax,	2
    jg        L1424
    movq      XMM4,	[rdi + rsi*8-8]
    movq      XMM5,	[rdi + rsi*8-16]
    movzx     rax,	byte [rbx+2]
    mov       rcx,	rax
    movq      XMM1,	XMM5
    movq      XMM2,	XMM4
    call      pc_runaux.cmpreal
    mov       [rbp + pc_run.dispatch_loop.n],	rax
    jmp       L1423
L1424:
    movzx     rax,	byte [rbx+3]
    lea       r10,	[pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L1425
    mov       rax,	[rdi + rsi*8-8]
    mov       r10,	[rdi + rsi*8-16]
    movzx     r11,	byte [rbx+2]
    mov       rcx,	r11
    mov       rdx,	r10
    mov       r8,	rax
    call      pc_runaux.cmpint
    mov       [rbp + pc_run.dispatch_loop.n],	rax
    jmp       L1423
L1425:
    mov       rax,	[rdi + rsi*8-8]
    mov       r10,	[rdi + rsi*8-16]
    movzx     r11,	byte [rbx+2]
    mov       rcx,	r11
    mov       rdx,	r10
    mov       r8,	rax
    call      pc_runaux.cmpword
    mov       [rbp + pc_run.dispatch_loop.n],	rax
L1423:
    mov       eax,	[rbx+16]
    test      eax,	eax
    jz        L1427
    mov       rax,	[rbp + pc_run.dispatch_loop.n]
    test      rax,	rax
    jnz       L1427
    dec       rsi
    jmp       L1426
L1427:
    mov       rax,	2
    sub       rsi,	rax
L1426:
    mov       rax,	[rbp + pc_run.dispatch_loop.n]
    test      rax,	rax
    jz        L1429
    mov       rax,	[rbx+8]
    mov       r10,	[pc_run.labeltable]
    mov       r10,	[r10 + rax*8-8]
    mov       rbx,	r10
    jmp       L1428
L1429:
    add       rbx,	32
L1428:
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1430:
    mov       rax,	rsi
    dec       rsi
    mov       rax,	[rdi + rax*8-8]
    test      rax,	rax
    jz        L1432
    mov       rax,	[rbx+8]
    mov       r10,	[pc_run.labeltable]
    mov       r10,	[r10 + rax*8-8]
    mov       rbx,	r10
    jmp       L1431
L1432:
    add       rbx,	32
L1431:
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1433:
    mov       rax,	rsi
    dec       rsi
    mov       rax,	[rdi + rax*8-8]
    test      rax,	rax
    jnz       L1435
    mov       rax,	[rbx+8]
    mov       r10,	[pc_run.labeltable]
    mov       r10,	[r10 + rax*8-8]
    mov       rbx,	r10
    jmp       L1434
L1435:
    add       rbx,	32
L1434:
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1436:
    mov       rax,	[rbx+8]
    mov       r10,	[pc_run.labeltable]
    mov       r10,	[r10 + rax*8-8]
    mov       rbx,	r10
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1437:
    jmp       L1374
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1438:
    movzx     rax,	byte [rbx+3]
    cmp       rax,	2
    jz        L1440
    cmp       rax,	1
    jz        L1441
    jmp       L1442
L1440:
    mov       rcx,	rbx
    lea       rdx,	[L12273]
    lea       r8,	[L12274]
    call      pc_runaux.pcerrorx
    jmp       L1439
L1441:
    mov       rcx,	rbx
    lea       rdx,	[L12275]
    lea       r8,	[L12276]
    call      pc_runaux.pcerrorx
    jmp       L1439
L1442:
    movzx     rax,	byte [rbx+3]
    lea       r10,	[pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L1444
    mov       rax,	[rdi + rsi*8-8]
    mov       r10,	[rdi + rsi*8-16]
    movzx     r11,	byte [rbx+2]
    mov       rcx,	r11
    mov       rdx,	r10
    mov       r8,	rax
    call      pc_runaux.cmpint
    mov       [rbp + pc_run.dispatch_loop.n],	rax
    jmp       L1443
L1444:
    mov       rax,	[rdi + rsi*8-8]
    mov       r10,	[rdi + rsi*8-16]
    movzx     r11,	byte [rbx+2]
    mov       rcx,	r11
    mov       rdx,	r10
    mov       r8,	rax
    call      pc_runaux.cmpword
    mov       [rbp + pc_run.dispatch_loop.n],	rax
L1443:
L1439:
    dec       rsi
    mov       rax,	[rbp + pc_run.dispatch_loop.n]
    mov       [rdi + rsi*8-8],	rax
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1445:
    mov       rax,	rsi
    dec       rsi
    mov       rax,	[rdi + rax*8-8]
    jmp       L1346
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1446:
    lea       rax,	[rdi + r12*8-8]
    lea       r10,	[rbx+32]
    mov       rcx,	r10
    mov       rdx,	rax
    call      pc_runaux.pci_getopndaddr
    mov       r13,	rax
    mov       rax,	r13
    dec       qword [rax]
    mov       rax,	[r13]
    test      rax,	rax
    jz        L1448
    mov       rax,	[rbx+8]
    mov       r10,	[pc_run.labeltable]
    mov       r10,	[r10 + rax*8-8]
    mov       rbx,	r10
    jmp       L1447
L1448:
    add       rbx,	64
L1447:
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1449:
    lea       rax,	[rdi + r12*8-8]
    lea       r10,	[rbx+32]
    mov       rcx,	r10
    mov       rdx,	rax
    call      pc_runaux.pci_getopndaddr
    mov       r13,	rax
    lea       rax,	[rdi + r12*8-8]
    lea       r10,	[rbx+64]
    mov       rcx,	r10
    mov       rdx,	rax
    call      pc_runaux.pci_getopnd
    mov       [rbp + pc_run.dispatch_loop.n],	rax
    movsxd    rax,	dword [rbx+16]
    mov       r10,	r13
    add       [r10],	rax
    mov       rax,	[r13]
    cmp       rax,	[rbp + pc_run.dispatch_loop.n]
    jg        L1451
    mov       rax,	[rbx+8]
    mov       r10,	[pc_run.labeltable]
    mov       r10,	[r10 + rax*8-8]
    mov       rbx,	r10
    jmp       L1450
L1451:
    add       rbx,	96
L1450:
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1452:
    lea       rax,	[rdi + r12*8-8]
    lea       r10,	[rbx+32]
    mov       rcx,	r10
    mov       rdx,	rax
    call      pc_runaux.pci_getopndaddr
    mov       r13,	rax
    lea       rax,	[rdi + r12*8-8]
    lea       r10,	[rbx+64]
    mov       rcx,	r10
    mov       rdx,	rax
    call      pc_runaux.pci_getopnd
    mov       [rbp + pc_run.dispatch_loop.n],	rax
    movsxd    rax,	dword [rbx+16]
    mov       r10,	r13
    sub       [r10],	rax
    mov       rax,	[r13]
    cmp       rax,	[rbp + pc_run.dispatch_loop.n]
    jl        L1454
    mov       rax,	[rbx+8]
    mov       r10,	[pc_run.labeltable]
    mov       r10,	[r10 + rax*8-8]
    mov       rbx,	r10
    jmp       L1453
L1454:
    add       rbx,	96
L1453:
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1455:
    movzx     rax,	byte [rbx+3]
    cmp       rax,	11
    jnz       L1457
    mov       rcx,	rbx
    lea       rdx,	[L12277]
    lea       r8,	[L12278]
    call      pc_runaux.pcerrorx
L1457:
    mov       rax,	rsi
    dec       rsi
    mov       r13,	[rdi + rax*8-8]
    mov       rax,	rsi
    dec       rsi
    mov       rax,	[rdi + rax*8-8]
    mov       [rbp + pc_run.dispatch_loop.ptrb],	rax
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    movzx     rax,	byte [rbx+3]
    mov       rcx,	[rbp + pc_run.dispatch_loop.ptrb]
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       r14,	rax
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	r14
    mov       r8,	rax
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    movzx     rax,	byte [rbx+3]
    mov       rcx,	[rbp + pc_run.dispatch_loop.ptrb]
    mov       rdx,	[rbp + pc_run.dispatch_loop.a]
    mov       r8,	rax
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1458:
    mov       rax,	rsi
    dec       rsi
    mov       rax,	[rdi + rax*8-8]
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    movsxd    rax,	dword [rbx+16]
    mov       r10,	[rbp + pc_run.dispatch_loop.a]
    cmp       r10,	rax
    jl        L1460
    movsxd    rax,	dword [rbx+20]
    cmp       r10,	rax
    jg        L1460
    mov       rax,	[rbx+8]
    mov       r10,	[pc_run.labeltable]
    mov       r10,	[r10 + rax*8-8]
    lea       r10,	[r10+32]
    mov       rax,	[rbp + pc_run.dispatch_loop.a]
    shl       rax,	5
    lea       r10,	[r10 + rax]
    movsxd    rax,	dword [rbx+16]
    shl       rax,	5
    sub       r10,	rax
    mov       rbx,	r10
    mov       rax,	[rbx+8]
    mov       r10,	[pc_run.labeltable]
    mov       r10,	[r10 + rax*8-8]
    mov       rbx,	r10
    jmp       L1459
L1460:
    lea       rax,	[rbx+32]
    mov       rax,	[rax+8]
    mov       r10,	[pc_run.labeltable]
    mov       r10,	[r10 + rax*8-8]
    mov       rbx,	r10
L1459:
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1461:
    jmp       L1374
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1462:
    jmp       L1374
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1463:
    mov       eax,	[rbx+4]
    mov       r10,	rsi
    dec       rsi
    mov       r10,	[rdi + r10*8-8]
    mov       rcx,	r10
    xor       edx,	edx
    mov       r8,	rax
    call      memset
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1464:
    jmp       L1374
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1465:
    movzx     rax,	byte [rbx+3]
    cmp       rax,	2
    jg        L1467
    movq      XMM4,	[rdi + rsi*8-8]
    lea       rax,	[rdi + rsi*8-16]
    movq      XMM5,	[rax]
    addsd     XMM5,	XMM4
    movq      [rax],	XMM5
    jmp       L1466
L1467:
    mov       rax,	[rdi + rsi*8-8]
    lea       r10,	[rdi + rsi*8-16]
    add       [r10],	rax
L1466:
    dec       rsi
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1468:
    movzx     rax,	byte [rbx+3]
    cmp       rax,	2
    jg        L1470
    movq      XMM4,	[rdi + rsi*8-8]
    lea       rax,	[rdi + rsi*8-16]
    movq      XMM5,	[rax]
    subsd     XMM5,	XMM4
    movq      [rax],	XMM5
    jmp       L1469
L1470:
    mov       rax,	[rdi + rsi*8-8]
    lea       r10,	[rdi + rsi*8-16]
    sub       [r10],	rax
L1469:
    dec       rsi
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1471:
    movzx     rax,	byte [rbx+3]
    cmp       rax,	2
    jg        L1473
    movq      XMM4,	[rdi + rsi*8-8]
    lea       rax,	[rdi + rsi*8-16]
    movq      XMM5,	[rax]
    mulsd     XMM5,	XMM4
    movq      [rax],	XMM5
    jmp       L1472
L1473:
    mov       rax,	[rdi + rsi*8-8]
    lea       r10,	[rdi + rsi*8-16]
    mov       r11,	[r10]
    imul      r11,	rax
    mov       [r10],	r11
L1472:
    dec       rsi
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1474:
    movq      XMM4,	[rdi + rsi*8-16]
    movq      XMM5,	[rdi + rsi*8-8]
    divsd     XMM4,	XMM5
    movq      [rdi + rsi*8-16],	XMM4
    dec       rsi
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1475:
    movzx     rax,	byte [rbx+3]
    lea       r10,	[pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L1477
    mov       rax,	[rdi + rsi*8-16]
    mov       r10,	[rdi + rsi*8-8]
    cqo       
    idiv      r10
    mov       [rdi + rsi*8-16],	rax
    jmp       L1476
L1477:
    mov       rax,	[rdi + rsi*8-16]
    mov       r10,	[rdi + rsi*8-8]
    xor       edx,	edx
    div       r10
    mov       [rdi + rsi*8-16],	rax
L1476:
    dec       rsi
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1478:
    movzx     rax,	byte [rbx+3]
    lea       r10,	[pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L1480
    mov       rax,	[rdi + rsi*8-16]
    mov       r10,	[rdi + rsi*8-8]
    cqo       
    idiv      r10
    xchg      rax,	rdx
    mov       [rdi + rsi*8-16],	rax
    jmp       L1479
L1480:
    mov       rax,	[rdi + rsi*8-16]
    mov       r10,	[rdi + rsi*8-8]
    xor       edx,	edx
    div       r10
    xchg      rax,	rdx
    mov       [rdi + rsi*8-16],	rax
L1479:
    dec       rsi
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1481:
    jmp       L1374
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1482:
    mov       rax,	[rdi + rsi*8-8]
    lea       r10,	[rdi + rsi*8-16]
    and       [r10],	rax
    dec       rsi
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1483:
    mov       rax,	[rdi + rsi*8-8]
    lea       r10,	[rdi + rsi*8-16]
    or        [r10],	rax
    dec       rsi
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1484:
    mov       rax,	[rdi + rsi*8-8]
    lea       r10,	[rdi + rsi*8-16]
    xor       [r10],	rax
    dec       rsi
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1485:
    mov       rax,	[rdi + rsi*8-8]
    lea       r10,	[rdi + rsi*8-16]
    mov       cl,	al
    shl       qword [r10],	cl
    dec       rsi
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1486:
    movzx     rax,	byte [rbx+3]
    lea       r10,	[pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L1488
    mov       rax,	[rdi + rsi*8-8]
    lea       r10,	[rdi + rsi*8-16]
    mov       cl,	al
    sar       qword [r10],	cl
    jmp       L1487
L1488:
    mov       rax,	[rdi + rsi*8-8]
    lea       r10,	[rdi + rsi*8-16]
    mov       cl,	al
    shr       qword [r10],	cl
L1487:
    dec       rsi
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1489:
    movzx     rax,	byte [rbx+3]
    cmp       rax,	2
    jg        L1491
    movq      XMM4,	[rdi + rsi*8-8]
    lea       rax,	[rdi + rsi*8-16]
    movq      XMM0,	[rax]
    comisd    XMM0,	XMM4
    jbe       L12279
    movq      [rax],	XMM4
L12279:
    jmp       L1490
L1491:
    movzx     rax,	byte [rbx+3]
    lea       r10,	[pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L1492
    mov       rax,	[rdi + rsi*8-8]
    lea       r10,	[rdi + rsi*8-16]
    cmp       [r10],	rax
    jle       L12280
    mov       [r10],	rax
L12280:
    jmp       L1490
L1492:
    mov       rax,	[rdi + rsi*8-8]
    lea       r10,	[rdi + rsi*8-16]
    cmp       [r10],	rax
    jbe       L12281
    mov       [r10],	rax
L12281:
L1490:
    dec       rsi
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1493:
    movzx     rax,	byte [rbx+3]
    cmp       rax,	2
    jg        L1495
    movq      XMM4,	[rdi + rsi*8-8]
    lea       rax,	[rdi + rsi*8-16]
    movq      XMM0,	[rax]
    comisd    XMM0,	XMM4
    jae       L12282
    movq      [rax],	XMM4
L12282:
    jmp       L1494
L1495:
    movzx     rax,	byte [rbx+3]
    lea       r10,	[pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L1496
    mov       rax,	[rdi + rsi*8-8]
    lea       r10,	[rdi + rsi*8-16]
    cmp       [r10],	rax
    jge       L12283
    mov       [r10],	rax
L12283:
    jmp       L1494
L1496:
    mov       rax,	[rdi + rsi*8-8]
    lea       r10,	[rdi + rsi*8-16]
    cmp       [r10],	rax
    jae       L12284
    mov       [r10],	rax
L12284:
L1494:
    dec       rsi
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1497:
    mov       rax,	rsi
    dec       rsi
    mov       rax,	[rdi + rax*8-8]
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	[rdi + rsi*8-8]
    movsxd    r10,	dword [rbx+16]
    mov       r11,	[rbp + pc_run.dispatch_loop.a]
    imul      r11,	r10
    lea       rax,	[rax + r11]
    movsxd    r10,	dword [rbx+20]
    lea       rax,	[rax + r10]
    mov       [rdi + rsi*8-8],	rax
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1498:
    mov       rax,	rsi
    dec       rsi
    mov       rax,	[rdi + rax*8-8]
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	[rdi + rsi*8-8]
    movsxd    r10,	dword [rbx+16]
    mov       r11,	[rbp + pc_run.dispatch_loop.a]
    imul      r11,	r10
    sub       rax,	r11
    movsxd    r10,	dword [rbx+20]
    lea       rax,	[rax + r10]
    mov       [rdi + rsi*8-8],	rax
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1499:
    mov       rax,	[rdi + rsi*8-16]
    mov       r10,	[rdi + rsi*8-8]
    sub       rax,	r10
    movsxd    r10,	dword [rbx+16]
    cqo       
    idiv      r10
    mov       [rdi + rsi*8-16],	rax
    dec       rsi
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1500:
    movzx     rax,	byte [rbx+3]
    cmp       rax,	2
    jg        L1502
    movq      XMM4,	[rdi + rsi*8-8]
    xorpd     XMM4,	[L12285]
    movq      [rdi + rsi*8-8],	XMM4
    jmp       L1501
L1502:
    mov       rax,	[rdi + rsi*8-8]
    neg       rax
    mov       [rdi + rsi*8-8],	rax
L1501:
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1503:
    movzx     rax,	byte [rbx+3]
    cmp       rax,	2
    jg        L1505
    movq      XMM4,	[rdi + rsi*8-8]
    andpd     XMM4,	[L12286]
    movq      [rdi + rsi*8-8],	XMM4
    jmp       L1504
L1505:
    mov       rax,	[rdi + rsi*8-8]
    cmp       rax,	0
    jge       L12287
    neg       rax
L12287:
    mov       [rdi + rsi*8-8],	rax
L1504:
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1506:
    mov       rax,	[rdi + rsi*8-8]
    not       rax
    mov       [rdi + rsi*8-8],	rax
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1507:
    mov       rax,	[rdi + rsi*8-8]
    xor       rax,	1
    mov       [rdi + rsi*8-8],	rax
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1508:
    mov       rax,	[rdi + rsi*8-8]
    test      rax,	rax
    setnz     al
    movzx     eax,	al
    mov       [rdi + rsi*8-8],	rax
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1509:
    mov       rax,	[rdi + rsi*8-8]
    test      rax,	rax
    setz      al
    movzx     eax,	al
    mov       [rdi + rsi*8-8],	rax
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1510:
    movzx     rax,	byte [rbx+3]
    cmp       rax,	2
    jg        L1512
    movq      XMM4,	[rdi + rsi*8-8]
    lea       rax,	[rdi + rsi*8-8]
    movq      XMM5,	[rax]
    mulsd     XMM5,	XMM4
    movq      [rax],	XMM5
    jmp       L1511
L1512:
    mov       rax,	[rdi + rsi*8-8]
    imul      rax,	rax
    mov       [rdi + rsi*8-8],	rax
L1511:
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1513:
    movq      XMM4,	[rdi + rsi*8-8]
    sqrtsd    XMM4,	XMM4
    movq      [rdi + rsi*8-8],	XMM4
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1514:
    jmp       L1374
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1515:
    jmp       L1374
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1516:
    jmp       L1374
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1517:
    jmp       L1374
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1518:
    jmp       L1374
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1519:
    jmp       L1374
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1520:
    jmp       L1374
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1521:
    jmp       L1374
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1522:
    jmp       L1374
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1523:
    jmp       L1374
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1524:
    jmp       L1374
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1525:
    jmp       L1374
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1526:
    jmp       L1374
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1527:
    jmp       L1374
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1528:
    movzx     rax,	byte [rbx+3]
    cmp       rax,	2
    jg        L1530
    movq      XMM4,	[rdi + rsi*8-16]
    movq      XMM5,	[rdi + rsi*8-8]
    movq      XMM0,	XMM4
    movq      XMM1,	XMM5
    call      pow
    movq      [rdi + rsi*8-16],	XMM0
    jmp       L1529
L1530:
    mov       rax,	[rdi + rsi*8-16]
    mov       r10,	[rdi + rsi*8-8]
    mov       rcx,	rax
    mov       rdx,	r10
    call      msys.m$power_i64
    mov       [rdi + rsi*8-16],	rax
L1529:
    dec       rsi
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1531:
    jmp       L1374
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1532:
    movzx     rax,	byte [rbx+3]
    movsxd    r10,	dword [rbx+16]
    mov       r11,	rsi
    dec       rsi
    mov       r11,	[rdi + r11*8-8]
    mov       rcx,	r11
    mov       rdx,	r10
    mov       r8,	rax
    call      pc_runaux.doincr
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1533:
    movzx     rax,	byte [rbx+3]
    movsxd    r10,	dword [rbx+16]
    neg       r10
    mov       r11,	rsi
    dec       rsi
    mov       r11,	[rdi + r11*8-8]
    mov       rcx,	r11
    mov       rdx,	r10
    mov       r8,	rax
    call      pc_runaux.doincr
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1534:
    mov       r13,	[rdi + rsi*8-8]
    movzx     rax,	byte [rbx+3]
    movsxd    r10,	dword [rbx+16]
    mov       rcx,	r13
    mov       rdx,	r10
    mov       r8,	rax
    call      pc_runaux.doincr
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rdi + rsi*8-8],	rax
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1535:
    mov       r13,	[rdi + rsi*8-8]
    movzx     rax,	byte [rbx+3]
    movsxd    r10,	dword [rbx+16]
    neg       r10
    mov       rcx,	r13
    mov       rdx,	r10
    mov       r8,	rax
    call      pc_runaux.doincr
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rdi + rsi*8-8],	rax
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1536:
    mov       r13,	[rdi + rsi*8-8]
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rdi + rsi*8-8],	rax
    movzx     rax,	byte [rbx+3]
    movsxd    r10,	dword [rbx+16]
    mov       rcx,	r13
    mov       rdx,	r10
    mov       r8,	rax
    call      pc_runaux.doincr
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1537:
    mov       r13,	[rdi + rsi*8-8]
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rdi + rsi*8-8],	rax
    movzx     rax,	byte [rbx+3]
    movsxd    r10,	dword [rbx+16]
    neg       r10
    mov       rcx,	r13
    mov       rdx,	r10
    mov       r8,	rax
    call      pc_runaux.doincr
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1538:
    mov       rax,	rsi
    dec       rsi
    mov       r13,	[rdi + rax*8-8]
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	rsi
    dec       rsi
    mov       r14,	[rdi + rax*8-8]
    movzx     rax,	byte [rbx+3]
    cmp       rax,	2
    jg        L1540
    mov       rax,	[rbp + pc_run.dispatch_loop.a]
    movq      XMM4,	rax
    mov       rax,	r14
    movq      XMM5,	rax
    addsd     XMM4,	XMM5
    movq      rax,	XMM4
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    jmp       L1539
L1540:
    mov       rax,	r14
    add       [rbp + pc_run.dispatch_loop.a],	rax
L1539:
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	[rbp + pc_run.dispatch_loop.a]
    mov       r8,	rax
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1541:
    mov       rax,	rsi
    dec       rsi
    mov       r13,	[rdi + rax*8-8]
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	rsi
    dec       rsi
    mov       r14,	[rdi + rax*8-8]
    movzx     rax,	byte [rbx+3]
    cmp       rax,	2
    jg        L1543
    mov       rax,	[rbp + pc_run.dispatch_loop.a]
    movq      XMM4,	rax
    mov       rax,	r14
    movq      XMM5,	rax
    subsd     XMM4,	XMM5
    movq      rax,	XMM4
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    jmp       L1542
L1543:
    mov       rax,	r14
    sub       [rbp + pc_run.dispatch_loop.a],	rax
L1542:
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	[rbp + pc_run.dispatch_loop.a]
    mov       r8,	rax
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1544:
    mov       rax,	rsi
    dec       rsi
    mov       r13,	[rdi + rax*8-8]
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	rsi
    dec       rsi
    mov       r14,	[rdi + rax*8-8]
    movzx     rax,	byte [rbx+3]
    cmp       rax,	2
    jg        L1546
    mov       rax,	[rbp + pc_run.dispatch_loop.a]
    movq      XMM4,	rax
    mov       rax,	r14
    movq      XMM5,	rax
    mulsd     XMM4,	XMM5
    movq      rax,	XMM4
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    jmp       L1545
L1546:
    mov       rax,	[rbp + pc_run.dispatch_loop.a]
    imul      rax,	r14
    mov       [rbp + pc_run.dispatch_loop.a],	rax
L1545:
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	[rbp + pc_run.dispatch_loop.a]
    mov       r8,	rax
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1547:
    mov       rax,	rsi
    dec       rsi
    mov       r13,	[rdi + rax*8-8]
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	rsi
    dec       rsi
    mov       r14,	[rdi + rax*8-8]
    movzx     rax,	byte [rbx+3]
    cmp       rax,	2
    jg        L1549
    mov       rax,	[rbp + pc_run.dispatch_loop.a]
    movq      XMM4,	rax
    mov       rax,	r14
    movq      XMM5,	rax
    divsd     XMM4,	XMM5
    movq      rax,	XMM4
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    jmp       L1548
L1549:
    mov       rax,	[rbp + pc_run.dispatch_loop.a]
    mov       r10,	r14
    cqo       
    idiv      r10
    mov       [rbp + pc_run.dispatch_loop.a],	rax
L1548:
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	[rbp + pc_run.dispatch_loop.a]
    mov       r8,	rax
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1550:
    mov       rax,	rsi
    dec       rsi
    mov       r13,	[rdi + rax*8-8]
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	rsi
    dec       rsi
    mov       r14,	[rdi + rax*8-8]
    mov       rax,	[rbp + pc_run.dispatch_loop.a]
    mov       r10,	r14
    cqo       
    idiv      r10
    xchg      rax,	rdx
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	[rbp + pc_run.dispatch_loop.a]
    mov       r8,	rax
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1551:
    mov       rax,	rsi
    dec       rsi
    mov       r13,	[rdi + rax*8-8]
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	rsi
    dec       rsi
    mov       r14,	[rdi + rax*8-8]
    mov       rax,	r14
    and       [rbp + pc_run.dispatch_loop.a],	rax
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	[rbp + pc_run.dispatch_loop.a]
    mov       r8,	rax
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1552:
    mov       rax,	rsi
    dec       rsi
    mov       r13,	[rdi + rax*8-8]
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	rsi
    dec       rsi
    mov       r14,	[rdi + rax*8-8]
    mov       rax,	r14
    or        [rbp + pc_run.dispatch_loop.a],	rax
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	[rbp + pc_run.dispatch_loop.a]
    mov       r8,	rax
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1553:
    mov       rax,	rsi
    dec       rsi
    mov       r13,	[rdi + rax*8-8]
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	rsi
    dec       rsi
    mov       r14,	[rdi + rax*8-8]
    mov       rax,	r14
    xor       [rbp + pc_run.dispatch_loop.a],	rax
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	[rbp + pc_run.dispatch_loop.a]
    mov       r8,	rax
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1554:
    mov       rax,	rsi
    dec       rsi
    mov       r13,	[rdi + rax*8-8]
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	rsi
    dec       rsi
    mov       r14,	[rdi + rax*8-8]
    mov       cl,	r14b
    shl       qword [rbp + pc_run.dispatch_loop.a],	cl
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	[rbp + pc_run.dispatch_loop.a]
    mov       r8,	rax
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1555:
    mov       rax,	rsi
    dec       rsi
    mov       r13,	[rdi + rax*8-8]
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	rsi
    dec       rsi
    mov       r14,	[rdi + rax*8-8]
    movzx     rax,	byte [rbx+3]
    lea       r10,	[pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L1557
    mov       cl,	r14b
    sar       qword [rbp + pc_run.dispatch_loop.a],	cl
    jmp       L1556
L1557:
    mov       cl,	r14b
    shr       qword [rbp + pc_run.dispatch_loop.a],	cl
L1556:
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	[rbp + pc_run.dispatch_loop.a]
    mov       r8,	rax
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1558:
    mov       rax,	rsi
    dec       rsi
    mov       r13,	[rdi + rax*8-8]
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	rsi
    dec       rsi
    mov       r14,	[rdi + rax*8-8]
    movzx     rax,	byte [rbx+3]
    cmp       rax,	2
    jg        L1560
    mov       rax,	[rbp + pc_run.dispatch_loop.a]
    movq      XMM4,	rax
    mov       rax,	r14
    movq      XMM5,	rax
    maxss     XMM4,	XMM5
    movq      rax,	XMM4
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    jmp       L1559
L1560:
    movzx     rax,	byte [rbx+3]
    lea       r10,	[pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L1561
    mov       rax,	r14
    cmp       [rbp + pc_run.dispatch_loop.a],	rax
    jle       L12288
    mov       [rbp + pc_run.dispatch_loop.a],	rax
L12288:
    jmp       L1559
L1561:
    mov       rax,	r14
    cmp       [rbp + pc_run.dispatch_loop.a],	rax
    jbe       L12289
    mov       [rbp + pc_run.dispatch_loop.a],	rax
L12289:
L1559:
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	[rbp + pc_run.dispatch_loop.a]
    mov       r8,	rax
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1562:
    mov       rax,	rsi
    dec       rsi
    mov       r13,	[rdi + rax*8-8]
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	rsi
    dec       rsi
    mov       r14,	[rdi + rax*8-8]
    movzx     rax,	byte [rbx+3]
    cmp       rax,	2
    jg        L1564
    mov       rax,	[rbp + pc_run.dispatch_loop.a]
    movq      XMM4,	rax
    mov       rax,	r14
    movq      XMM5,	rax
    minsd     XMM4,	XMM5
    movq      rax,	XMM4
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    jmp       L1563
L1564:
    movzx     rax,	byte [rbx+3]
    lea       r10,	[pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L1565
    mov       rax,	r14
    cmp       [rbp + pc_run.dispatch_loop.a],	rax
    jge       L12290
    mov       [rbp + pc_run.dispatch_loop.a],	rax
L12290:
    jmp       L1563
L1565:
    mov       rax,	r14
    cmp       [rbp + pc_run.dispatch_loop.a],	rax
    jae       L12291
    mov       [rbp + pc_run.dispatch_loop.a],	rax
L12291:
L1563:
    movzx     rax,	byte [rbx+3]
    mov       rcx,	r13
    mov       rdx,	[rbp + pc_run.dispatch_loop.a]
    mov       r8,	rax
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1566:
    mov       rax,	rsi
    dec       rsi
    mov       r13,	[rdi + rax*8-8]
    mov       rax,	rsi
    dec       rsi
    mov       rax,	[rdi + rax*8-8]
    movsxd    r10,	dword [rbx+16]
    imul      rax,	r10
    mov       r10,	r13
    add       [r10],	rax
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1567:
    mov       rax,	rsi
    dec       rsi
    mov       r13,	[rdi + rax*8-8]
    mov       rax,	rsi
    dec       rsi
    mov       rax,	[rdi + rax*8-8]
    movsxd    r10,	dword [rbx+16]
    imul      rax,	r10
    mov       r10,	r13
    sub       [r10],	rax
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1568:
    jmp       L1374
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1569:
    jmp       L1374
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1570:
    jmp       L1374
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1571:
    jmp       L1374
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1572:
    jmp       L1374
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1573:
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1574:
    movsxd    rax,	dword [rbx+28]
    and       rax,	255
    lea       r10,	[pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L1576
    mov       rax,	[rdi + rsi*8-8]
    cvtsi2sd  XMM4,	rax
    movq      [rdi + rsi*8-8],	XMM4
    jmp       L1575
L1576:
    mov       rax,	[rdi + rsi*8-8]
    cmp       rax,	0
    jl        L12292
    cvtsi2sd  XMM4,	rax
    jmp       L12293
L12292:
    and       rax,	[L12294]
    cvtsi2sd  XMM4,	rax
    addsd     XMM4,	[L12295]
L12293:
    movq      [rdi + rsi*8-8],	XMM4
L1575:
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1577:
    movq      XMM4,	[rdi + rsi*8-8]
    cvttsd2si rax,	XMM4
    mov       [rdi + rsi*8-8],	rax
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1578:
    movsxd    rax,	dword [rbx+28]
    and       rax,	255
    lea       r10,	[rdi + rsi*8-8]
    mov       rcx,	r10
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rdi + rsi*8-8],	rax
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1579:
    movsxd    rax,	dword [rbx+28]
    and       rax,	255
    lea       r10,	[rdi + rsi*8-8]
    mov       rcx,	r10
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rdi + rsi*8-8],	rax
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1580:
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1581:
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1582:
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1583:
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1584:
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1585:
    inc       rsi
    mov       rax,	rsi
    mov       r10,	r12
    mov       [rdi + rax*8-8],	r10
    mov       r12,	rsi
    movsxd    rax,	dword [rbx+20]
    add       rsi,	rax
    mov       rax,	[pc_run.dotrace]
    test      rax,	rax
    jz        L1587
    mov       rax,	[rbp + pc_run.dispatch_loop.callsp]
    mov       [rbp + pc_run.dispatch_loop.av_2],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.av_2]
    cmp       rax,	0
    jle       L1590
L1588:
    call      msys.m$print_startcon
    lea       rcx,	[L12296]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    dec       qword [rbp + pc_run.dispatch_loop.av_2]
    jnz       L1588
L1590:
    call      msys.m$print_startcon
    lea       rcx,	[L12297]
    call      msys.m$print_setfmt
    mov       rcx,	[pc_run.seqno]
    call      msys.m$print_i64_nf
    mov       rax,	[rbx+8]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    mov       rcx,	rsi
    call      msys.m$print_i64_nf
    mov       rcx,	r12
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L1587:
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1591:
    jmp       L1374
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1592:
    jmp       L1374
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1593:
    jmp       L1374
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1594:
    jmp       L1374
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1595:
    jmp       L1374
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1596:
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1597:
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1598:
    mov       r13,	[rdi + rsi*8-8]
    lea       rax,	[rbx+32]
    mov       [r13],	rax
    mov       [r13+8],	rsi
    mov       [r13+16],	r12
    xor       eax,	eax
    mov       [rdi + rsi*8-8],	rax
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1599:
    mov       rax,	rsi
    dec       rsi
    mov       rax,	[rdi + rax*8-8]
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	rsi
    dec       rsi
    mov       r13,	[rdi + rax*8-8]
    mov       rbx,	[r13]
    mov       rsi,	[r13+8]
    mov       r12,	[r13+16]
    inc       rsi
    mov       rax,	rsi
    mov       r10,	[rbp + pc_run.dispatch_loop.a]
    mov       [rdi + rax*8-8],	r10
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1600:
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1601:
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1602:
    jmp       L1374
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1603:
    dec       rsi
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1604:
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1605:
    jmp       L1374
    add       rbx,	32
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1606:
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
L1354:
;pc_run.dispatch_loop.unimpl:
L1374:
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       rcx,	[L12298]
    call      msys.m$print_str_nf
    movzx     rax,	byte [rbx]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       rcx,	[L12299]
    call      msys.m$print_setfmt
    movzx     rax,	byte [rbx]
    lea       r10,	[pc_tables.pclnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    movsxd    rax,	dword [rbx+28]
    shr       rax,	8
    and       rax,	16777215
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.m$print_u64
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	1
    call      exit
    movzx     rax,	byte [rbx]
    lea       r10,	[L1353]
    jmp       [r10 + rax*8]
    xor       eax,	eax
L1346:
;---------------
    add       rsp,	120392
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_run.fixuppcl
pc_run.fixuppcl:
;?>>
   %define R.p rdi
   %define R.d rbx
   %define R.e rsi
   %define R.dproc r12
   %define R.pdata r13
   %define R.parambytes r14
   %define R.framebytes r15
    %define pc_run.fixuppcl.paramslots -8
    %define pc_run.fixuppcl.localslots -16
    %define pc_run.fixuppcl.a -24
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
;---------------
    mov       rax,	[pc_api.mlabelno]
    inc       rax
    shl       rax,	3
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [pc_run.labeltable],	rax
    mov       rdi,	[pc_api.pcstart]
    jmp       L1611
L1608:
    movzx     rax,	byte [rdi]
    cmp       rax,	120
    jz        L1613
    cmp       rax,	121
    jnz       L1614
L1613:
    mov       rax,	[rdi+8]
    mov       r10,	rdi
    mov       [rax+56],	r10
L1614:
L1612:
    add       rdi,	32
L1611:
    cmp       rdi,	[pc_api.pccurr]
    jbe       L1608
    mov       rdi,	[pc_api.pcstart]
    jmp       L1618
L1615:
    movzx     rax,	byte [rdi]
    cmp       rax,	123
    jz        L1620
    cmp       rax,	124
    jnz       L1621
L1620:
    mov       rbx,	[rdi+8]
    mov       eax,	[rdi+4]
    mov       rcx,	rax
    call      mlib.pcm_allocz
    mov       [rbx+56],	rax
L1621:
L1619:
    add       rdi,	32
L1618:
    cmp       rdi,	[pc_api.pccurr]
    jbe       L1615
    mov       rdi,	[pc_api.pcstart]
    jmp       L1625
L1622:
    movzx     rax,	byte [rdi]
    cmp       rax,	123
    jz        L1627
    cmp       rax,	124
    jz        L1627
    cmp       rax,	125
    jz        L1628
    cmp       rax,	120
    jz        L1629
    cmp       rax,	127
    jz        L1630
    cmp       rax,	20
    jz        L1631
    cmp       rax,	23
    jz        L1631
    jmp       L1632
L1627:
    mov       rax,	[rdi+8]
    mov       r13,	[rax+56]
    jmp       L1626
L1628:
    movzx     rax,	byte [rdi+3]
    cmp       rax,	11
    jz        L1634
    movzx     rax,	byte [rdi+1]
    cmp       rax,	1
    jz        L1636
    cmp       rax,	2
    jz        L1637
    jmp       L1638
L1636:
    mov       rcx,	rdi
    lea       rdx,	[L12300]
    lea       r8,	[L12301]
    call      pc_runaux.pcerrorx
    jmp       L1635
L1637:
    mov       rbx,	[rdi+8]
    movzx     rax,	byte [rbx+72]
    cmp       rax,	3
    jz        L1640
    cmp       rax,	2
    jz        L1641
    cmp       rax,	1
    jz        L1642
    jmp       L1643
L1640:
    mov       rax,	[rbx+56]
    mov       [rbp + pc_run.fixuppcl.a],	rax
    jmp       L1639
L1641:
    mov       rax,	[rbx+56]
    mov       [rbp + pc_run.fixuppcl.a],	rax
    jmp       L1639
L1642:
    mov       rcx,	rbx
    call      pc_runaux.getdllfnptr
    mov       [rbp + pc_run.fixuppcl.a],	rax
    jmp       L1639
L1643:
    mov       rcx,	rdi
    lea       rdx,	[L12302]
    lea       r8,	[L12303]
    call      pc_runaux.pcerrorx
L1639:
    mov       rax,	[rbp + pc_run.fixuppcl.a]
    test      rax,	rax
    jnz       L1645
    mov       rcx,	rdi
    lea       rdx,	[L12304]
    lea       r8,	[L12305]
    call      pc_runaux.pcerrorx
L1645:
    jmp       L1635
L1638:
    mov       rax,	[rdi+8]
    mov       [rbp + pc_run.fixuppcl.a],	rax
L1635:
    mov       eax,	[rdi+4]
    mov       rcx,	r13
    lea       rdx,	[rbp + pc_run.fixuppcl.a]
    mov       r8,	rax
    call      memcpy
    jmp       L1633
L1634:
    mov       eax,	[rdi+4]
    mov       r10,	[rdi+8]
    mov       rcx,	r13
    mov       rdx,	r10
    mov       r8,	rax
    call      memcpy
L1633:
    mov       eax,	[rdi+4]
    add       r13,	rax
    jmp       L1626
L1629:
    mov       rax,	[rdi+8]
    mov       rbx,	rax
    mov       r12,	rax
    mov       rsi,	[rbx+16]
    xor       r14,	r14
    jmp       L1649
L1646:
    mov       rax,	8
    add       r14,	rax
    mov       rax,	r14
    sar       rax,	3
    inc       rax
    neg       rax
    mov       [rsi+76],	eax
    mov       rsi,	[rsi+16]
L1649:
    test      rsi,	rsi
    jnz       L1646
    mov       rsi,	[rbx+24]
    xor       r15,	r15
    jmp       L1653
L1650:
    mov       rax,	r15
    sar       rax,	3
    inc       rax
    mov       [rsi+76],	eax
    mov       eax,	[rsi+84]
    mov       rcx,	rax
    mov       rdx,	8
    call      mlib.roundtoblock
    add       r15,	rax
    mov       rsi,	[rsi+24]
L1653:
    test      rsi,	rsi
    jnz       L1650
    mov       rax,	r14
    sar       rax,	3
    mov       [rbp + pc_run.fixuppcl.paramslots],	rax
    mov       [rdi+16],	eax
    mov       rax,	r15
    sar       rax,	3
    mov       [rbp + pc_run.fixuppcl.localslots],	rax
    mov       [rdi+20],	eax
    jmp       L1626
L1630:
    mov       rax,	[rdi+8]
    mov       r10,	rdi
    mov       r11,	[pc_run.labeltable]
    mov       [r11 + rax*8-8],	r10
    jmp       L1626
L1631:
    mov       eax,	[rbp + pc_run.fixuppcl.paramslots]
    mov       [rdi+16],	eax
    mov       eax,	[rbp + pc_run.fixuppcl.localslots]
    mov       [rdi+20],	eax
L1632:
L1626:
    add       rdi,	32
L1625:
    cmp       rdi,	[pc_api.pccurr]
    jbe       L1622
;---------------
    add       rsp,	56
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_run.pcl_runpcl
pc_run.pcl_runpcl:
;?>>
   %define R.stopcode rdi
    push      rdi
;?]]
    sub       rsp,	48
;---------------
    call      pc_runaux.loadlibs
    call      pc_run.fixuppcl
    mov       rax,	[pc_decls.entryproc]
    test      rax,	rax
    jnz       L1656
    mov       rcx,	[pc_api.pcstart]
    lea       rdx,	[L12306]
    lea       r8,	[L12307]
    call      pc_runaux.pcerrorx
L1656:
    call      pc_runaux.docmdskip
    mov       al,	[pc_decls.pverbose]
    test      al,	al
    jz        L1658
    call      msys.m$print_startcon
    lea       rcx,	[L12308]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L1658:
    mov       rax,	[pc_decls.entryproc]
    movzx     rax,	byte [rax+112]
    cmp       rax,	2
    setz      al
    movzx     eax,	al
    mov       r10,	[pc_decls.entryproc]
    mov       r10,	[r10+56]
    mov       rcx,	r10
    mov       rdx,	rax
    call      pc_run.dispatch_loop
    mov       rdi,	rax
    mov       al,	[pc_decls.pverbose]
    test      al,	al
    jz        L1660
    call      msys.m$print_startcon
    lea       rcx,	[L12309]
    call      msys.m$print_str_nf
    mov       rcx,	rdi
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
L1660:
    mov       rcx,	rdi
    call      exit
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc pc_run.getlineno
pc_run.getlineno:
;?>>
   %define R.pc rdi
    %define pc_run.getlineno.filename -8
    %define pc_run.getlineno.sourceline -16
    push      rdi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
    mov       rdi,	rcx
;---------------
    mov       rax,	[pc_decls.igetmsourceinfo]
    test      rax,	rax
    jz        L1663
    mov       eax,	[rdi+24]
    mov       rcx,	rax
    lea       rdx,	[rbp + pc_run.getlineno.filename]
    lea       r8,	[rbp + pc_run.getlineno.sourceline]
    mov       r10,	[pc_decls.igetmsourceinfo]
    call      r10
    jmp       L1662
L1663:
    xor       eax,	eax
L1662:
L1661:
;---------------
    add       rsp,	56
    pop       rbp
    pop       rdi
    ret       
;End 
;Proc pc_runaux.pci_getopnd
pc_runaux.pci_getopnd:
;?>>
   %define R.p r12
   %define R.locals r13
   %define R.a rdi
   %define R.d rbx
   %define R.ptr rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r12,	rcx
    mov       r13,	rdx
;---------------
    movzx     rax,	byte [r12+1]
    cmp       rax,	4
    jz        L1666
    cmp       rax,	1
    jz        L1667
    cmp       rax,	2
    jz        L1668
    cmp       rax,	7
    jz        L1669
    cmp       rax,	5
    jz        L1670
    cmp       rax,	6
    jz        L1670
    cmp       rax,	3
    jz        L1671
    jmp       L1672
L1666:
    mov       rdi,	[r12+8]
    jmp       L1665
L1667:
    mov       rbx,	[r12+8]
    movzx     rax,	byte [rbx+72]
    cmp       rax,	3
    jnz       L1675
L1674:
    mov       rsi,	[rbx+56]
    jmp       L1673
L1675:
    movsxd    rax,	dword [rbx+76]
    lea       r10,	[r13 + rax*8]
    mov       rsi,	r10
    movzx     rax,	byte [rbx+82]
    cmp       rax,	11
    jnz       L1677
    movzx     rax,	byte [rbx+72]
    cmp       rax,	5
    jnz       L1677
    mov       rsi,	[rsi]
L1677:
L1673:
    movzx     rax,	byte [r12+3]
    mov       rcx,	rsi
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       rdi,	rax
    jmp       L1665
L1668:
    mov       rbx,	[r12+8]
    movzx     rax,	byte [rbx+72]
    cmp       rax,	4
    jz        L1679
    cmp       rax,	5
    jz        L1680
    cmp       rax,	1
    jz        L1681
    jmp       L1682
L1679:
    movsxd    rax,	dword [rbx+76]
    lea       r10,	[r13 + rax*8]
    mov       rdi,	r10
    jmp       L1678
L1680:
    movsxd    rax,	dword [rbx+76]
    lea       r10,	[r13 + rax*8]
    mov       rdi,	r10
    movzx     rax,	byte [rbx+82]
    cmp       rax,	11
    jnz       L1684
    mov       rsi,	rdi
    mov       rdi,	[rsi]
L1684:
    jmp       L1678
L1681:
    mov       rcx,	rbx
    call      pc_runaux.getdllfnptr
    mov       rdi,	rax
    jmp       L1678
L1682:
    mov       rdi,	[rbx+56]
L1678:
    jmp       L1665
L1669:
    mov       rdi,	[r12+8]
    jmp       L1665
L1670:
    movq      XMM4,	[r12+8]
    movq      rax,	XMM4
    mov       rdi,	rax
    jmp       L1665
L1671:
    mov       rax,	[r12+8]
    mov       r10,	[pc_run.labeltable]
    mov       r10,	[r10 + rax*8-8]
    mov       rdi,	r10
    jmp       L1665
L1672:
    mov       rcx,	r12
    call      pc_runaux.pcusopnd
L1665:
    mov       rax,	rdi
L1664:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_runaux.pci_loadptr
pc_runaux.pci_loadptr:
;?>>
   %define R.p rdi
   %define R.mode rbx
   %define R.x XMM15
    push      rdi
    push      rbx
    movq      rax,	XMM15
    push      rax
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    test      rdi,	rdi
    jnz       L1687
    lea       rcx,	[L12310]
    call      pc_api.pclerror
L1687:
    lea       rax,	[rbx-1]
    cmp       rax,	11
    jae       L1690
    lea       r10,	[L1689]
    jmp       [r10 + rax*8]
    segment .data
L1689:
    dq  L1693
    dq  L1692
    dq  L1701
    dq  L1700
    dq  L1699
    dq  L1698
    dq  L1697
    dq  L1696
    dq  L1695
    dq  L1694
    dq  L1691
    segment .text
L1691:
    mov       rax,	rdi
    jmp       L1688
L1692:
    mov       rax,	[rdi]
    jmp       L1688
L1693:
    movd      XMM4,	[rdi]
    cvtss2sd  XMM4,	XMM4
    movq      XMM15,	XMM4
    movq      XMM4,	XMM15
    movq      rax,	XMM4
    jmp       L1688
L1694:
    mov       rax,	[rdi]
    jmp       L1688
L1695:
    movsxd    rax,	dword [rdi]
    jmp       L1688
L1696:
    movsx     rax,	word [rdi]
    jmp       L1688
L1697:
    movsx     rax,	byte [rdi]
    jmp       L1688
L1698:
    mov       rax,	[rdi]
    jmp       L1688
L1699:
    mov       eax,	[rdi]
    jmp       L1688
L1700:
    movzx     rax,	word [rdi]
    jmp       L1688
L1701:
    movzx     rax,	byte [rdi]
    jmp       L1688
L1690:
    xor       eax,	eax
L1688:
L1685:
;---------------
    add       rsp,	48
    pop       rcx
    movq      XMM15,	rcx
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_runaux.pci_storeptr
pc_runaux.pci_storeptr:
;?>>
   %define R.p rdi
   %define R.a rbx
   %define R.mode rsi
   %define R.size r12
   %define R.x XMM15
    push      rdi
    push      rbx
    push      rsi
    push      r12
    movq      rax,	XMM15
    push      rax
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
    mov       r12,	r9
;---------------
    test      rdi,	rdi
    jnz       L1704
    lea       rcx,	[L12310]
    call      pc_api.pclerror
L1704:
    mov       rax,	rsi
    cmp       rax,	11
    jz        L1706
    cmp       rax,	1
    jz        L1707
    jmp       L1708
L1706:
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	r12
    call      memcpy
    jmp       L1705
L1707:
    mov       rax,	rbx
    movq      XMM4,	rax
    movq      XMM15,	XMM4
    movq      XMM4,	XMM15
    cvtsd2ss  XMM4,	XMM4
    movd      [rdi],	XMM4
    jmp       L1705
L1708:
    lea       rax,	[pc_tables.psize]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10]
    cmp       rax,	8
    jz        L1710
    cmp       rax,	4
    jz        L1711
    cmp       rax,	2
    jz        L1712
    jmp       L1713
L1710:
    mov       [rdi],	rbx
    jmp       L1709
L1711:
    mov       [rdi],	ebx
    jmp       L1709
L1712:
    mov       [rdi],	bx
    jmp       L1709
L1713:
    mov       [rdi],	bl
L1709:
L1705:
;---------------
    add       rsp,	48
    pop       rcx
    movq      XMM15,	rcx
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_runaux.pci_getopndaddr
pc_runaux.pci_getopndaddr:
;?>>
   %define R.p rbx
   %define R.locals rsi
   %define R.d rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    movzx     rax,	byte [rbx+1]
    cmp       rax,	1
    jz        L1716
    mov       rcx,	rbx
    lea       rdx,	[L12311]
    lea       r8,	[L12312]
    call      pc_runaux.pcerrorx
L1716:
    mov       rdi,	[rbx+8]
    movzx     rax,	byte [rdi+72]
    cmp       rax,	3
    jnz       L1718
    mov       rax,	[rdi+56]
    jmp       L1717
L1718:
    movsxd    rax,	dword [rdi+76]
    lea       r10,	[rsi + rax*8]
    mov       rax,	r10
L1717:
L1714:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_runaux.pcerrorx
pc_runaux.pcerrorx:
;?>>
   %define R.p rdi
   %define R.mess rbx
   %define R.param rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    call      msys.m$print_startcon
    lea       rcx,	[L12313]
    call      msys.m$print_str_nf
    mov       rcx,	rbx
    call      msys.m$print_str_nf
    mov       rcx,	rsi
    call      msys.m$print_str_nf
    lea       rcx,	[L12314]
    call      msys.m$print_str_nf
    test      rdi,	rdi
    jz        L1721
    movsxd    rax,	dword [rdi+28]
    shr       rax,	8
    and       rax,	16777215
    jmp       L1720
L1721:
    xor       eax,	eax
L1720:
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.m$print_u64
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	1
    call      exit
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_runaux.pcusopnd
pc_runaux.pcusopnd:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    call      msys.m$print_startcon
    lea       rcx,	[L12315]
    call      msys.m$print_str_nf
    movzx     rax,	byte [rdi+1]
    lea       r10,	[pc_tables.opndnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    lea       rcx,	[L12316]
    call      msys.m$print_str_nf
    movzx     rax,	byte [rdi]
    lea       r10,	[pc_tables.pclnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    movsxd    rax,	dword [rdi+28]
    shr       rax,	8
    and       rax,	16777215
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.m$print_u64
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	1
    call      exit
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc pc_runaux.docalldll
pc_runaux.docalldll:
;?>>
   %define R.d rsi
   %define R.fnaddr r12
   %define R.revargs r13
   %define R.nargs r14
    %define pc_runaux.docalldll.nvars 96
    %define pc_runaux.docalldll.retmode 104
    %define pc_runaux.docalldll.args -800
   %define R.retval rdi
   %define R.i rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	832
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
    mov       r14,	r9
;---------------
    test      r12,	r12
    jnz       L1725
    mov       rcx,	rsi
    call      pc_runaux.getdllfnptr
    mov       r12,	rax
L1725:
    mov       rbx,	r14
    cmp       rbx,	1
    jl        L1728
L1726:
    mov       rax,	[r13 + rbx*8-8]
    mov       r10,	r14
    sub       r10,	rbx
    mov       [rbp + r10*8 + pc_runaux.docalldll.args],	rax
    dec       rbx
    cmp       rbx,	1
    jge       L1726
L1728:
    sub       rsp,	8
    push      0
    mov       rax,	[rbp + pc_runaux.docalldll.retmode]
    cmp       rax,	1
    jz        L1731
    cmp       rax,	2
    jnz       L1730
L1731:
    mov       rax,	82
    jmp       L1729
L1730:
    mov       rax,	73
L1729:
    mov       rcx,	r12
    mov       rdx,	rax
    mov       r8,	r14
    lea       r9,	[rbp + pc_runaux.docalldll.args]
    sub       rsp,	32
    call      mwindll.os_calldllfunction
    add       rsp,	48
    mov       rdi,	rax
    mov       rax,	rdi
L1723:
;---------------
    add       rsp,	832
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_runaux.getdllfnptr
pc_runaux.getdllfnptr:
;?>>
   %define R.d r12
   %define R.fnaddr rdi
   %define R.procname rbx
   %define R.i rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       r12,	rcx
;---------------
    mov       rdi,	[r12+56]
    test      rdi,	rdi
    jz        L1734
    mov       rax,	rdi
    jmp       L1732
L1734:
    mov       rbx,	[r12]
    mov       rsi,	1
    mov       rax,	[pc_decls.nplibfiles]
    cmp       rax,	1
    jl        L1738
L1735:
    lea       rax,	[pc_decls.plibinst]
    mov       r10,	rsi
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rax
    mov       rdx,	rbx
    call      mwindows.os_getdllprocaddr
    mov       rdi,	rax
    test      rdi,	rdi
    jz        L1740
    jmp       L1737
L1740:
    inc       rsi
    cmp       rsi,	[pc_decls.nplibfiles]
    jle       L1735
L1738:
    xor       ecx,	ecx
    lea       rdx,	[L12317]
    mov       r8,	rbx
    call      pc_runaux.pcerrorx
L1737:
    mov       [r12+56],	rdi
    mov       rax,	rdi
L1732:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_runaux.loadlibs
pc_runaux.loadlibs:
;?>>
   %define R.i rdi
    push      rdi
;?]]
    sub       rsp,	48
;---------------
    mov       rdi,	1
    mov       rax,	[pc_decls.nplibfiles]
    cmp       rax,	1
    jl        L1744
L1742:
    lea       rax,	[pc_decls.plibfiles]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rax
    call      mwindows.os_getdllinst
    lea       r10,	[pc_decls.plibinst]
    mov       r11,	rdi
    mov       [r10 + r11*8-8],	rax
    lea       rax,	[pc_decls.plibinst]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    test      rax,	rax
    jnz       L1746
    lea       rax,	[pc_decls.plibfiles]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    xor       ecx,	ecx
    lea       rdx,	[L12318]
    mov       r8,	rax
    call      pc_runaux.pcerrorx
L1746:
    inc       rdi
    cmp       rdi,	[pc_decls.nplibfiles]
    jle       L1742
L1744:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc pc_runaux.cmpreal
pc_runaux.cmpreal:
;?>>
   %define R.cond rcx
   %define R.x XMM1
   %define R.y XMM2
;?]]
;---------------
    mov       rax,	rcx
    cmp       rax,	1
    jz        L1749
    cmp       rax,	2
    jz        L1750
    cmp       rax,	3
    jz        L1751
    cmp       rax,	4
    jz        L1752
    cmp       rax,	5
    jz        L1753
    jmp       L1754
L1749:
    movq      XMM4,	XMM1
    comisd    XMM4,	XMM2
    setz      al
    movzx     eax,	al
    jmp       L1748
L1750:
    movq      XMM4,	XMM1
    comisd    XMM4,	XMM2
    setnz     al
    movzx     eax,	al
    jmp       L1748
L1751:
    movq      XMM4,	XMM1
    comisd    XMM4,	XMM2
    setb      al
    movzx     eax,	al
    jmp       L1748
L1752:
    movq      XMM4,	XMM1
    comisd    XMM4,	XMM2
    setbe     al
    movzx     eax,	al
    jmp       L1748
L1753:
    movq      XMM4,	XMM1
    comisd    XMM4,	XMM2
    setae     al
    movzx     eax,	al
    jmp       L1748
L1754:
    movq      XMM4,	XMM1
    comisd    XMM4,	XMM2
    seta      al
    movzx     eax,	al
L1748:
L1747:
;---------------
    ret       
;End 
;Proc pc_runaux.cmpint
pc_runaux.cmpint:
;?>>
   %define R.cond rcx
   %define R.x rdx
   %define R.y r8
;?]]
;---------------
    mov       rax,	rcx
    cmp       rax,	1
    jz        L1757
    cmp       rax,	2
    jz        L1758
    cmp       rax,	3
    jz        L1759
    cmp       rax,	4
    jz        L1760
    cmp       rax,	5
    jz        L1761
    jmp       L1762
L1757:
    mov       rax,	rdx
    cmp       rax,	r8
    setz      al
    movzx     eax,	al
    jmp       L1756
L1758:
    mov       rax,	rdx
    cmp       rax,	r8
    setnz     al
    movzx     eax,	al
    jmp       L1756
L1759:
    mov       rax,	rdx
    cmp       rax,	r8
    setl      al
    movzx     eax,	al
    jmp       L1756
L1760:
    mov       rax,	rdx
    cmp       rax,	r8
    setle     al
    movzx     eax,	al
    jmp       L1756
L1761:
    mov       rax,	rdx
    cmp       rax,	r8
    setge     al
    movzx     eax,	al
    jmp       L1756
L1762:
    mov       rax,	rdx
    cmp       rax,	r8
    setg      al
    movzx     eax,	al
L1756:
L1755:
;---------------
    ret       
;End 
;Proc pc_runaux.cmpword
pc_runaux.cmpword:
;?>>
   %define R.cond rcx
   %define R.x rdx
   %define R.y r8
;?]]
;---------------
    mov       rax,	rcx
    cmp       rax,	1
    jz        L1765
    cmp       rax,	2
    jz        L1766
    cmp       rax,	3
    jz        L1767
    cmp       rax,	4
    jz        L1768
    cmp       rax,	5
    jz        L1769
    jmp       L1770
L1765:
    mov       rax,	rdx
    cmp       rax,	r8
    setz      al
    movzx     eax,	al
    jmp       L1764
L1766:
    mov       rax,	rdx
    cmp       rax,	r8
    setnz     al
    movzx     eax,	al
    jmp       L1764
L1767:
    mov       rax,	rdx
    cmp       rax,	r8
    setb      al
    movzx     eax,	al
    jmp       L1764
L1768:
    mov       rax,	rdx
    cmp       rax,	r8
    setbe     al
    movzx     eax,	al
    jmp       L1764
L1769:
    mov       rax,	rdx
    cmp       rax,	r8
    setae     al
    movzx     eax,	al
    jmp       L1764
L1770:
    mov       rax,	rdx
    cmp       rax,	r8
    seta      al
    movzx     eax,	al
L1764:
L1763:
;---------------
    ret       
;End 
;Proc pc_runaux.doincr
pc_runaux.doincr:
;?>>
   %define R.pu8 rcx
   %define R.incr rdx
   %define R.mode r8
;?]]
;---------------
    lea       rax,	[pc_tables.psize]
    mov       r10,	r8
    movzx     rax,	byte [rax + r10]
    cmp       rax,	8
    jz        L1773
    cmp       rax,	4
    jz        L1774
    cmp       rax,	2
    jz        L1775
    jmp       L1776
L1773:
    mov       rax,	rcx
    mov       r10,	rdx
    add       [rax],	r10
    jmp       L1772
L1774:
    mov       rax,	rcx
    mov       r10d,	edx
    add       [rax],	r10d
    jmp       L1772
L1775:
    mov       rax,	rcx
    mov       r10w,	dx
    add       [rax],	r10w
    jmp       L1772
L1776:
    mov       rax,	rcx
    mov       r10b,	dl
    add       [rax],	r10b
L1772:
;---------------
    ret       
;End 
;Proc pc_runaux.docmdskip
pc_runaux.docmdskip:
;?>>
   %define R.d rdi
    push      rdi
;?]]
    sub       rsp,	48
;---------------
    mov       rdi,	[pc_decls.psymboltable]
    jmp       L1781
L1778:
    mov       rax,	[rdi]
    mov       rcx,	rax
    call      pc_api.getbasename
    mov       rcx,	rax
    lea       rdx,	[L12319]
    call      mlib.eqstring
    test      rax,	rax
    jz        L1783
    mov       rax,	[rdi+56]
    mov       r10b,	[pc_decls.pcmdskip]
    mov       [rax],	r10b
    jmp       L1780
L1783:
    mov       rdi,	[rdi+8]
L1781:
    test      rdi,	rdi
    jnz       L1778
L1780:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc pc_runaux.pci_loadbf
pc_runaux.pci_loadbf:
;?>>
   %define R.a rcx
   %define R.i rdx
   %define R.j r8
   %define R.mask rdi
   %define R.n rbx
    push      rdi
    push      rbx
;?]]
;---------------
    cmp       r8,	rdx
    jae       L1786
    mov       rax,	rdx
    mov       r10,	r8
    mov       r8,	rax
    mov       rdx,	r10
L1786:
    mov       rax,	r8
    sub       rax,	rdx
    inc       rax
    mov       rbx,	rax
    mov       rax,	-1
    push      rcx
    mov       cl,	bl
    shl       rax,	cl
    pop       rcx
    not       rax
    push      rcx
    mov       cl,	dl
    shl       rax,	cl
    pop       rcx
    mov       rdi,	rax
    mov       rax,	rcx
    and       rax,	rdi
    push      rcx
    mov       cl,	dl
    shr       rax,	cl
    pop       rcx
L1784:
;---------------
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc pc_runaux.pci_storebf
pc_runaux.pci_storebf:
;?>>
   %define R.a rcx
   %define R.i rdx
   %define R.j r8
   %define R.x r9
   %define R.mask rdi
   %define R.n rbx
    push      rdi
    push      rbx
;?]]
;---------------
    cmp       r8,	rdx
    jae       L1789
    mov       rax,	rdx
    mov       r10,	r8
    mov       r8,	rax
    mov       rdx,	r10
L1789:
    mov       rax,	r8
    sub       rax,	rdx
    inc       rax
    mov       rbx,	rax
    mov       rax,	-1
    push      rcx
    mov       cl,	bl
    shl       rax,	cl
    pop       rcx
    not       rax
    push      rcx
    mov       cl,	dl
    shl       rax,	cl
    pop       rcx
    mov       rdi,	rax
    mov       rax,	r9
    push      rcx
    mov       cl,	dl
    shl       rax,	cl
    pop       rcx
    and       rax,	rdi
    mov       r9,	rax
    mov       rax,	rdi
    not       rax
    mov       r10,	rcx
    and       r10,	rax
    or        r10,	r9
    mov       rax,	r10
L1787:
;---------------
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.genmcl
mc_genmcl.genmcl:
;?>>
    %define mc_genmcl.genmcl.dummy 32
   %define R.tt rdi
   %define R.i rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
;---------------
    mov       al,	[pc_decls.mcldone]
    test      al,	al
    jnz       L1790
L1792:
    xor       eax,	eax
    test      ax,	ax
    jnz       L1795
    xor       eax,	eax
    test      ax,	ax
    jz        L1794
L1795:
    call      msys.m$print_startcon
    lea       rcx,	[L12320]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L1794:
    call      mwindows.os_clock
    mov       rdi,	rax
    call      mc_genmcl.inithandlers
    xor       ecx,	ecx
    call      mc_libmcl.mclinit
    mov       rax,	[pc_api.pcstart]
    mov       [mc_decls.currpcl],	rax
    xor       rbx,	rbx
L1796:
    mov       rcx,	[mc_decls.currpcl]
    call      mc_genmcl.convertpcl
    xor       eax,	eax
    test      ax,	ax
    jz        L1800
    mov       rax,	[mc_decls.currpcl]
    movzx     rax,	byte [rax]
    cmp       rax,	127
    jz        L1800
    cmp       rax,	135
    jz        L1800
    cmp       rax,	120
    jz        L1800
    cmp       rax,	121
    jz        L1800
    cmp       rax,	20
    jz        L1800
    cmp       rax,	122
    jz        L1800
    call      mc_stackmcl.showopndstack
L1800:
    add       qword [mc_decls.currpcl],	32
    mov       rax,	[mc_decls.currpcl]
    cmp       rax,	[pc_api.pccurr]
    ja        L1801
    mov       rax,	[mc_decls.currpcl]
    movzx     rax,	byte [rax]
    cmp       rax,	136
    jnz       L1796
L1801:
    call      mc_auxmcl.genrealtable
    call      mc_auxmcl.genabsneg
    call      mc_auxmcl.genstringtable
    mov       rcx,	8
    xor       edx,	edx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	8
    xor       edx,	edx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       al,	[pc_decls.fpeephole]
    test      al,	al
    jz        L1803
    call      mc_optim.peephole
L1803:
    mov       al,	1
    mov       [pc_decls.mcldone],	al
    call      mwindows.os_clock
    sub       rax,	rdi
    mov       [pc_decls.mcltime],	rax
L1790:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.convertpcl
mc_genmcl.convertpcl:
;?>>
   %define R.p rsi
    %define mc_genmcl.convertpcl.oldregset -16
   %define R.reg rdi
   %define R.i rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
    mov       rsi,	rcx
;---------------
    mov       al,	[rsi+3]
    mov       [mc_decls.pmode],	al
    mov       [mc_decls.currpcl],	rsi
    mov       eax,	[rsi+24]
    mov       [pc_decls.mmpos],	rax
    movsxd    rax,	dword [rsi+28]
    shr       rax,	8
    and       rax,	16777215
    mov       [pc_decls.ppseqno],	rax
    movzx     rax,	byte [rsi]
    lea       r10,	[mc_genmcl.px_handlertable]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	rsi
    call      r10
    lea       rax,	[mc_decls.regset]
    lea       r10,	[rbp + mc_genmcl.convertpcl.oldregset]
    movdqu    XMM4,	[rax]
    movdqu    [r10],	XMM4
    lea       rax,	[mc_decls.regset]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    lea       rax,	[mc_decls.xregset]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    mov       rbx,	1
    mov       rax,	[mc_decls.noperands]
    cmp       rax,	1
    jl        L1807
L1805:
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	rbx
    movzx     rax,	byte [rax + r10-1]
    mov       rdi,	rax
    test      rdi,	rdi
    jz        L1809
    lea       rax,	[mc_decls.pclmode]
    mov       r10,	rbx
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	2
    jg        L1811
    mov       al,	1
    lea       r10,	[mc_decls.xregset]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
    jmp       L1810
L1811:
    mov       al,	1
    lea       r10,	[mc_decls.regset]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
L1810:
L1809:
    inc       rbx
    cmp       rbx,	[mc_decls.noperands]
    jle       L1805
L1807:
    mov       rax,	[rbp + mc_genmcl.convertpcl.oldregset]
    lea       r10,	[mc_decls.regset]
    mov       r10,	[r10]
    lea       r11,	[mc_decls.isregvar]
    mov       r11,	[r11]
    or        r10,	r11
    mov       r11,	72340172838076673
    xor       r10,	r11
    and       rax,	r10
    mov       r10,	[mc_decls.mccodex]
    lea       r10,	[r10+48]
    or        [r10],	rax
    mov       rax,	[rbp + mc_genmcl.convertpcl.oldregset+8]
    lea       r10,	[mc_decls.regset]
    mov       r10,	[r10+8]
    lea       r11,	[mc_decls.isregvar]
    mov       r11,	[r11+8]
    or        r10,	r11
    mov       r11,	72340172838076673
    xor       r10,	r11
    and       rax,	r10
    mov       r10,	[mc_decls.mccodex]
    lea       r10,	[r10+56]
    or        [r10],	rax
;---------------
    add       rsp,	56
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.inithandlers
mc_genmcl.inithandlers:
;?>>
   %define R.name rdi
   %define R.s rbx
   %define R.n rsi
   %define R.av_1 r12
   %define R.av_2 r13
   %define R.av_3 r14
   %define R.i r15
    %define mc_genmcl.inithandlers.k -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
;---------------
    mov       al,	[mc_genmcl.inithandlers.initdone]
    test      al,	al
    jnz       L1812
L1814:
    mov       rsi,	[$nprocs]
    mov       r15,	1
    cmp       rsi,	1
    jl        L1817
L1815:
    lea       rax,	[$procname]
    mov       r10,	r15
    mov       rdi,	[rax + r10*8-8]
    mov       rcx,	rdi
    lea       rdx,	[L12321]
    mov       r8,	3
    call      mlib.eqbytes
    test      rax,	rax
    jz        L1819
    xor       eax,	eax
    mov       [rbp + mc_genmcl.inithandlers.k],	rax
    mov       r12,	142
    cmp       r12,	0
    jl        L1823
L1820:
    lea       rax,	[pc_tables.pclnames]
    mov       r10,	[rbp + mc_genmcl.inithandlers.k]
    mov       rbx,	[rax + r10*8]
    movzx     rax,	byte [rbx]
    cmp       rax,	107
    jnz       L1825
    inc       rbx
L1825:
    lea       rax,	[rdi+3]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mlib.eqstring
    test      rax,	rax
    jz        L1827
    lea       rax,	[$procaddr]
    mov       r10,	r15
    mov       rax,	[rax + r10*8-8]
    lea       r10,	[mc_genmcl.px_handlertable]
    mov       r11,	[rbp + mc_genmcl.inithandlers.k]
    mov       [r10 + r11*8],	rax
    jmp       L1822
L1827:
    mov       rax,	[rbp + mc_genmcl.inithandlers.k]
    inc       rax
    mov       [rbp + mc_genmcl.inithandlers.k],	rax
    cmp       rax,	r12
    jle       L1820
L1823:
    lea       rcx,	[L12322]
    mov       rdx,	rdi
    call      pc_api.merror
L1822:
L1819:
    inc       r15
    cmp       r15,	rsi
    jle       L1815
L1817:
    mov       r15,	1
    mov       r13,	8
    cmp       r13,	1
    jl        L1830
L1828:
    lea       rax,	[mc_genmcl.inithandlers.dupltable]
    mov       r10,	r15
    lea       rax,	[rax + r10*2-2]
    movzx     rax,	byte [rax+1]
    lea       r10,	[mc_genmcl.px_handlertable]
    mov       r10,	[r10 + rax*8]
    lea       rax,	[mc_genmcl.inithandlers.dupltable]
    mov       r11,	r15
    lea       rax,	[rax + r11*2-2]
    movzx     rax,	byte [rax]
    lea       r11,	[mc_genmcl.px_handlertable]
    mov       [r11 + rax*8],	r10
    inc       r15
    cmp       r15,	r13
    jle       L1828
L1830:
    xor       r15,	r15
    mov       rax,	142
    mov       r14,	rax
    cmp       r14,	0
    jl        L1833
L1831:
    lea       rax,	[mc_genmcl.px_handlertable]
    mov       r10,	r15
    mov       rax,	[rax + r10*8]
    test      rax,	rax
    jnz       L1835
    lea       rax,	[mc_genmcl.unimpl]
    lea       r10,	[mc_genmcl.px_handlertable]
    mov       r11,	r15
    mov       [r10 + r11*8],	rax
L1835:
    inc       r15
    cmp       r15,	r14
    jle       L1831
L1833:
    mov       al,	1
    mov       [mc_genmcl.inithandlers.initdone],	al
L1812:
;---------------
    add       rsp,	40
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.doshowpcl
mc_genmcl.doshowpcl:
;?>>
   %define R.p rdi
    %define mc_genmcl.doshowpcl.str -1256
    push      rdi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	1288
    mov       rdi,	rcx
;---------------
    jmp       L1836
    movzx     rax,	byte [rdi]
    cmp       rax,	120
    jz        L1838
    cmp       rax,	121
    jz        L1838
    cmp       rax,	20
    jz        L1838
    cmp       rax,	122
    jz        L1838
    cmp       rax,	123
    jz        L1838
    cmp       rax,	124
    jz        L1838
    cmp       rax,	125
    jnz       L1839
L1838:
    jmp       L1837
L1839:
    lea       rcx,	[rbp + mc_genmcl.doshowpcl.str]
    lea       rdx,	[L12323]
    call      strcpy
    mov       rcx,	rdi
    mov       rdx,	1256
    call      pc_diags.strpclstr
    lea       rcx,	[rbp + mc_genmcl.doshowpcl.str]
    mov       rdx,	rax
    call      strcat
    lea       rcx,	[rbp + mc_genmcl.doshowpcl.str]
    call      mlib.pcm_copyheapstring
    mov       rcx,	rax
    call      mc_libmcl.mgencomment
L1837:
L1836:
;---------------
    add       rsp,	1288
    pop       rbp
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.unimpl
mc_genmcl.unimpl:
;?>>
   %define R.p rdi
    %define mc_genmcl.unimpl.str -104
    push      rdi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	136
    mov       rdi,	rcx
;---------------
    lea       rcx,	[rbp + mc_genmcl.unimpl.str]
    call      msys.m$print_startstr
    lea       rcx,	[L12324]
    call      msys.m$print_setfmt
    movzx     rax,	byte [rdi]
    lea       r10,	[pc_tables.pclnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	rax
    xor       edx,	edx
    call      pc_api.strpmode
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       rcx,	[rbp + mc_genmcl.unimpl.str]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rbp + mc_genmcl.unimpl.str]
    call      mlib.pcm_copyheapstring
    mov       rcx,	rax
    call      mc_libmcl.mgencomment
;---------------
    add       rsp,	136
    pop       rbp
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_nop
mc_genmcl.px_nop:
;?>>
    %define mc_genmcl.px_nop.p 16
;?]]
;---------------
;---
;---------------
    ret       
;End 
;Proc mc_genmcl.px_dupl
mc_genmcl.px_dupl:
;?>>
    %define mc_genmcl.px_dupl.p 16
;?]]
    sub       rsp,	40
;---------------
    call      mc_stackmcl.duplpcl
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mc_genmcl.px_double
mc_genmcl.px_double:
;?>>
    %define mc_genmcl.px_double.p 16
;?]]
    sub       rsp,	40
;---------------
    mov       rax,	[mc_decls.ncalldepth]
    test      rax,	rax
    jz        L1845
    call      mc_stackmcl.duplpcl
    jmp       L1844
L1845:
    lea       rax,	[mc_decls.pclcount]
    mov       r10,	[mc_decls.noperands]
    lea       rax,	[rax + r10-1]
    inc       byte [rax]
L1844:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mc_genmcl.px_opnd
mc_genmcl.px_opnd:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      mc_genmcl.unimpl
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_type
mc_genmcl.px_type:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      mc_genmcl.unimpl
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_comment
mc_genmcl.px_comment:
;?>>
    %define mc_genmcl.px_comment.p 16
;?]]
;---------------
;---
;---------------
    ret       
;End 
;Proc mc_genmcl.px_proc
mc_genmcl.px_proc:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rax,	[rdi+8]
    mov       [pc_decls.currfunc],	rax
    mov       rcx,	67
    mov       rdx,	1
    call      mc_libmcl.setsegment
    mov       rcx,	[pc_decls.currfunc]
    call      mc_libmcl.mgenmemaddr
    mov       rcx,	1
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	[pc_decls.currfunc]
    call      mc_libmcl.mgenmemaddr
    mov       rcx,	4
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	[pc_decls.currfunc]
    call      mc_auxmcl.initproc
    lea       rcx,	[L12325]
    call      mc_libmcl.mgencomment
    mov       rax,	[mc_decls.mccodex]
    mov       [mc_decls.mclprocentry],	rax
    mov       rax,	[pc_decls.currfunc]
    movzx     rax,	byte [rax+112]
    cmp       rax,	2
    jnz       L1851
    mov       rax,	[pc_decls.currfunc]
    mov       al,	[rax+83]
    test      al,	al
    jz        L1851
    call      mc_auxmcl.fixmain
L1851:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_endproc
mc_genmcl.px_endproc:
;?>>
    %define mc_genmcl.px_endproc.p 16
;?]]
    sub       rsp,	40
;---------------
    mov       rax,	[mc_decls.noperands]
    test      rax,	rax
    jz        L1854
    call      msys.m$print_startcon
    lea       rcx,	[L12326]
    call      msys.m$print_str_nf
    mov       rax,	[pc_decls.currfunc]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L12326]
    call      mc_libmcl.mgencomment
L1854:
    mov       rcx,	2
    xor       edx,	edx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mc_genmcl.px_endprog
mc_genmcl.px_endprog:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      mc_genmcl.unimpl
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_istatic
mc_genmcl.px_istatic:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    movsxd    rax,	dword [rdi+16]
    mov       rcx,	73
    mov       rdx,	rax
    call      mc_libmcl.setsegment
    mov       rax,	[rdi+8]
    mov       rcx,	rax
    call      mc_libmcl.mgenmemaddr
    mov       rcx,	4
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_zstatic
mc_genmcl.px_zstatic:
;?>>
   %define R.p rbx
   %define R.d rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rdi,	[rbx+8]
    movsxd    rax,	dword [rbx+16]
    mov       rcx,	90
    mov       rdx,	rax
    call      mc_libmcl.setsegment
    mov       rcx,	rdi
    call      mc_libmcl.mgenmemaddr
    mov       rcx,	4
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       eax,	[rbx+4]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	124
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_data
mc_genmcl.px_data:
;?>>
   %define R.p rsi
   %define R.ax rdi
   %define R.opc rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    movzx     rax,	byte [rsi+3]
    cmp       rax,	11
    jnz       L1860
    mov       rcx,	rsi
    call      mc_auxmcl.do_blockdata
    jmp       L1858
L1860:
    movzx     rax,	byte [rsi+1]
    cmp       rax,	4
    jz        L1862
    cmp       rax,	10
    jz        L1863
    cmp       rax,	11
    jz        L1864
    cmp       rax,	6
    jz        L1865
    cmp       rax,	7
    jz        L1866
    cmp       rax,	2
    jz        L1867
    cmp       rax,	3
    jz        L1868
    jmp       L1869
L1862:
    mov       rax,	[rsi+8]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rdi,	rax
    jmp       L1861
L1863:
    movq      XMM4,	[rsi+8]
    movq      XMM0,	XMM4
    mov       rdx,	2
    call      mc_libmcl.mgenrealimm
    mov       rdi,	rax
    jmp       L1861
L1864:
    movq      XMM4,	[rsi+8]
    movq      XMM0,	XMM4
    mov       rdx,	1
    call      mc_libmcl.mgenrealimm
    mov       rdi,	rax
    jmp       L1861
L1865:
    movq      XMM4,	[rsi+8]
    movq      XMM0,	XMM4
    mov       rdx,	1
    call      mc_libmcl.mgenrealimm
    mov       rdi,	rax
    jmp       L1861
L1866:
    mov       rax,	[rsi+8]
    mov       rcx,	rax
    call      mc_libmcl.getstringindex
    mov       rcx,	rax
    call      mc_libmcl.mgenlabel
    mov       rdi,	rax
    jmp       L1861
L1867:
    mov       rax,	[rsi+8]
    mov       rcx,	rax
    call      mc_libmcl.mgenmemaddr
    mov       rdi,	rax
    mov       eax,	[rsi+20]
    mov       [rdi+12],	eax
    jmp       L1861
L1868:
    mov       rax,	[rsi+8]
    mov       rcx,	rax
    call      mc_libmcl.mgenlabel
    mov       rdi,	rax
    jmp       L1861
L1869:
    movzx     rax,	byte [rsi+1]
    lea       r10,	[pc_tables.opndnames]
    mov       r10,	[r10 + rax*8]
    lea       rcx,	[L12327]
    mov       rdx,	r10
    call      pc_api.merror
L1861:
    mov       eax,	[rsi+4]
    cmp       rax,	1
    jz        L1871
    cmp       rax,	2
    jz        L1872
    cmp       rax,	4
    jz        L1873
    cmp       rax,	8
    jz        L1874
    jmp       L1875
L1871:
    mov       rbx,	116
    jmp       L1870
L1872:
    mov       rbx,	117
    jmp       L1870
L1873:
    mov       rbx,	118
    jmp       L1870
L1874:
    mov       rbx,	119
    jmp       L1870
L1875:
    call      msys.m$print_startcon
    lea       rcx,	[L12328]
    call      msys.m$print_str_nf
    mov       eax,	[rsi+4]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    lea       rcx,	[L12329]
    call      msys.m$print_str_nf
    movzx     rax,	byte [rsi+3]
    mov       rcx,	rax
    xor       edx,	edx
    call      pc_api.strpmode
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L12330]
    lea       rdx,	[L12331]
    call      pc_api.merror
L1870:
    mov       rcx,	rbx
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L1858:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_label
mc_genmcl.px_label:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rax,	[rdi+8]
    mov       rcx,	rax
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_load
mc_genmcl.px_load:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      mc_stackmcl.pushpcl
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_store
mc_genmcl.px_store:
;?>>
   %define R.p rsi
   %define R.ax rdi
   %define R.bx rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    movzx     rax,	byte [rsi+3]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rbx,	rax
    movzx     rax,	byte [rsi+3]
    cmp       rax,	11
    jz        L1880
    movzx     rax,	byte [rsi+3]
    mov       r10,	[rsi+8]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_libmcl.mgenmem
    mov       rdi,	rax
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    jmp       L1879
L1880:
    mov       rcx,	6
    call      mc_stackmcl.getworkregm
    mov       rdi,	rax
    mov       rax,	[rsi+8]
    mov       rcx,	rax
    mov       rdx,	6
    call      mc_libmcl.mgenmem
    mov       rcx,	14
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	rdi
    mov       rdx,	6
    call      mc_stackmcl.makeopndind
    mov       rdi,	rax
    mov       rcx,	rbx
    mov       rdx,	6
    call      mc_stackmcl.makeopndind
    mov       rbx,	rax
    mov       eax,	[rsi+4]
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	rax
    mov       r9,	1
    call      mc_auxmcl.copyblock
L1879:
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_add
mc_genmcl.px_add:
;?>>
   %define R.p rsi
   %define R.ax rdi
   %define R.bx rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    movzx     rax,	byte [rsi+3]
    mov       r10,	[mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    movzx     rax,	byte [rsi+3]
    cmp       rax,	2
    jle       L1883
    mov       rcx,	[mc_decls.noperands]
    call      mc_stackmcl.isimmload
    test      rax,	rax
    jz        L1885
    lea       rax,	[mc_decls.pclopnd]
    mov       r10,	[mc_decls.noperands]
    mov       rax,	[rax + r10*8-8]
    mov       rax,	[rax+8]
    cmp       rax,	1
    jnz       L1885
    mov       rcx,	52
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L1884
L1885:
    movzx     rax,	byte [rsi+3]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rbx,	rax
    mov       rcx,	28
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
L1884:
    jmp       L1882
L1883:
    movzx     rax,	byte [rsi+3]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rbx,	rax
    movzx     rax,	byte [rsi+3]
    dec       rax
    mov       r10,	65
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
L1882:
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_sub
mc_genmcl.px_sub:
;?>>
   %define R.p rsi
   %define R.ax rdi
   %define R.bx rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    movzx     rax,	byte [rsi+3]
    mov       r10,	[mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    movzx     rax,	byte [rsi+3]
    cmp       rax,	2
    jle       L1888
    mov       rcx,	[mc_decls.noperands]
    call      mc_stackmcl.isimmload
    test      rax,	rax
    jz        L1890
    lea       rax,	[mc_decls.pclopnd]
    mov       r10,	[mc_decls.noperands]
    mov       rax,	[rax + r10*8-8]
    mov       rax,	[rax+8]
    cmp       rax,	1
    jnz       L1890
    mov       rcx,	53
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L1889
L1890:
    movzx     rax,	byte [rsi+3]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rbx,	rax
    mov       rcx,	29
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
L1889:
    jmp       L1887
L1888:
    movzx     rax,	byte [rsi+3]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rbx,	rax
    movzx     rax,	byte [rsi+3]
    dec       rax
    mov       r10,	67
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
L1887:
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_mul
mc_genmcl.px_mul:
;?>>
   %define R.p rsi
   %define R.ax rdi
   %define R.bx rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    movzx     rax,	byte [rsi+3]
    mov       r10,	[mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    movzx     rax,	byte [rsi+3]
    cmp       rax,	2
    jle       L1893
    mov       rcx,	[mc_decls.noperands]
    call      mc_stackmcl.isimmload
    test      rax,	rax
    jz        L1895
    lea       rax,	[mc_decls.pclopnd]
    mov       r10,	[mc_decls.noperands]
    mov       rax,	[rax + r10*8-8]
    mov       rax,	[rax+8]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mc_auxmcl.mulimm
    jmp       L1894
L1895:
    movzx     rax,	byte [rsi+3]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rbx,	rax
    mov       rcx,	34
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
L1894:
    jmp       L1892
L1893:
    movzx     rax,	byte [rsi+3]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rbx,	rax
    movzx     rax,	byte [rsi+3]
    dec       rax
    mov       r10,	69
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
L1892:
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_div
mc_genmcl.px_div:
;?>>
    %define mc_genmcl.px_div.p 32
   %define R.ax rdi
   %define R.bx rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rbx,	rax
    movzx     rax,	byte [mc_decls.pmode]
    dec       rax
    mov       r10,	71
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_eval
mc_genmcl.px_eval:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    movzx     rax,	byte [rdi+3]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_widen
mc_genmcl.px_widen:
;?>>
   %define R.p rsi
   %define R.ax rdi
   %define R.bx rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	6
    jnz       L1900
    movsxd    rax,	dword [rsi+28]
    and       rax,	255
    cmp       rax,	5
    jnz       L1900
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	5
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    mov       rax,	[mc_decls.mccodex]
    movzx     rax,	byte [rax+33]
    cmp       rax,	11
    jz        L1902
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rdi
    call      mc_libmcl.genmc
L1902:
    jmp       L1899
L1900:
    movsxd    rax,	dword [rsi+28]
    and       rax,	255
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rbx,	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	rax
    call      mc_stackmcl.getworkregm
    mov       rdi,	rax
    movsxd    rax,	dword [rsi+28]
    and       rax,	255
    lea       r10,	[pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L1904
    mov       rax,	18
    jmp       L1903
L1904:
    mov       rax,	19
L1903:
    mov       rcx,	rax
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    movzx     rax,	byte [mc_decls.pmode]
    movzx     r10,	byte [rdi+10]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_stackmcl.setnewzz
L1899:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_jump
mc_genmcl.px_jump:
;?>>
   %define R.p rsi
   %define R.labno rdi
   %define R.q rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    mov       rdi,	[rsi+8]
    lea       rax,	[rsi+32]
    mov       rbx,	rax
    jmp       L1907
L1906:
    add       rbx,	32
L1907:
    movzx     rax,	byte [rbx]
    cmp       rax,	135
    jz        L1906
    movzx     rax,	byte [rbx]
    cmp       rax,	127
    jz        L1910
    cmp       rax,	24
    jz        L1911
    jmp       L1912
L1910:
    mov       rax,	[rbx+8]
    cmp       rax,	rdi
    jz        L1905
L1914:
    add       rbx,	32
    movzx     rax,	byte [rbx]
    cmp       rax,	127
    jnz       L1916
    mov       rax,	[rbx+8]
    cmp       rax,	rdi
    jz        L1905
L1916:
    jmp       L1909
L1911:
    xor       eax,	eax
    mov       [rbx],	al
L1912:
L1909:
    mov       rcx,	rdi
    call      mc_libmcl.mgenlabel
    mov       rcx,	25
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L1905:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_ijump
mc_genmcl.px_ijump:
;?>>
    %define mc_genmcl.px_ijump.p 16
;?]]
    sub       rsp,	40
;---------------
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rcx,	25
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mc_genmcl.px_neg
mc_genmcl.px_neg:
;?>>
    %define mc_genmcl.px_neg.p 24
   %define R.ax rdi
    push      rdi
;?]]
    sub       rsp,	48
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	2
    jle       L1920
    mov       rcx,	50
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L1919
L1920:
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mc_auxmcl.do_negreal
L1919:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_abs
mc_genmcl.px_abs:
;?>>
    %define mc_genmcl.px_abs.p 32
   %define R.ax rdi
   %define R.lx rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	2
    jle       L1923
    xor       ecx,	ecx
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	42
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    inc       qword [pc_api.mlabelno]
    mov       rax,	[pc_api.mlabelno]
    mov       rcx,	rax
    call      mc_libmcl.mgenlabel
    mov       r10,	rax
    mov       rbx,	r10
    mov       rcx,	26
    mov       rdx,	13
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    mov       rcx,	50
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	9
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L1922
L1923:
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mc_auxmcl.do_absreal
L1922:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_bitnot
mc_genmcl.px_bitnot:
;?>>
    %define mc_genmcl.px_bitnot.p 24
   %define R.ax rdi
    push      rdi
;?]]
    sub       rsp,	48
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    mov       rcx,	51
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mc_libmcl.genmc
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_not
mc_genmcl.px_not:
;?>>
    %define mc_genmcl.px_not.p 24
   %define R.ax rdi
    %define mc_genmcl.px_not.$T1 -8
    push      rdi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    mov       rcx,	1
    mov       rdx,	3
    call      mc_libmcl.mgenint
    mov       [rbp + mc_genmcl.px_not.$T1],	rax
    mov       rcx,	rdi
    mov       rdx,	1
    call      mc_libmcl.changeopndsize
    mov       rcx,	40
    mov       rdx,	rax
    mov       r8,	[rbp + mc_genmcl.px_not.$T1]
    call      mc_libmcl.genmc
;---------------
    add       rsp,	40
    pop       rbp
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_toboolt
mc_genmcl.px_toboolt:
;?>>
   %define R.p r13
   %define R.ax rdi
   %define R.bx rbx
   %define R.cx rsi
   %define R.pmode2 r12b
    %define mc_genmcl.px_toboolt.$T2 -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       r13,	rcx
;---------------
    movsxd    rax,	dword [r13+28]
    and       rax,	255
    mov       r12b,	al
    movzx     rax,	r12b
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    movzx     rax,	r12b
    cmp       rax,	2
    jg        L1928
    movzx     rax,	r12b
    mov       rcx,	rax
    call      mc_stackmcl.getworkregm
    mov       rbx,	rax
    mov       rcx,	3
    call      mc_stackmcl.getworkregm
    mov       rsi,	rax
    movzx     rax,	r12b
    dec       rax
    mov       r10,	76
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	rbx
    mov       r8,	rbx
    call      mc_libmcl.genmc
    movzx     rax,	r12b
    dec       rax
    mov       r10,	73
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    movzx     rax,	byte [r13]
    cmp       rax,	64
    jnz       L1930
    mov       rax,	5
    jmp       L1929
L1930:
    mov       rax,	4
L1929:
    mov       rcx,	58
    mov       rdx,	rax
    mov       r8,	rsi
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    mov       rcx,	rsi
    mov       rdx,	4
    call      mc_libmcl.changeopndsize
    mov       rcx,	19
    mov       rdx,	rax
    mov       r8,	rsi
    call      mc_libmcl.genmc
    movzx     rax,	byte [mc_decls.pmode]
    movzx     r10,	byte [rsi+10]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_stackmcl.setnewzz
    jmp       L1927
L1928:
    mov       rcx,	41
    mov       rdx,	rdi
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rcx,	rdi
    mov       rdx,	1
    call      mc_libmcl.changeopndsize
    mov       r10,	rax
    mov       rbx,	r10
    mov       [rbp + mc_genmcl.px_toboolt.$T2],	rax
    movzx     rax,	byte [r13]
    cmp       rax,	64
    jnz       L1932
    mov       rax,	5
    jmp       L1931
L1932:
    mov       rax,	4
L1931:
    mov       rcx,	58
    mov       rdx,	rax
    mov       r8,	[rbp + mc_genmcl.px_toboolt.$T2]
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    mov       rcx,	rdi
    mov       rdx,	4
    call      mc_libmcl.changeopndsize
    mov       rcx,	19
    mov       rdx,	rax
    mov       r8,	rbx
    call      mc_libmcl.genmc
    mov       al,	[mc_decls.pmode]
    lea       r10,	[mc_decls.pclmode]
    mov       r11,	[mc_decls.noperands]
    mov       [r10 + r11-3],	al
L1927:
;---------------
    add       rsp,	40
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_sqr
mc_genmcl.px_sqr:
;?>>
    %define mc_genmcl.px_sqr.p 24
   %define R.ax rdi
    push      rdi
;?]]
    sub       rsp,	48
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	2
    jle       L1935
    mov       rcx,	34
    mov       rdx,	rdi
    mov       r8,	rdi
    call      mc_libmcl.genmc
    jmp       L1934
L1935:
    movzx     rax,	byte [mc_decls.pmode]
    dec       rax
    mov       r10,	69
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	rdi
    mov       r8,	rdi
    call      mc_libmcl.genmc
L1934:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_sqrt
mc_genmcl.px_sqrt:
;?>>
    %define mc_genmcl.px_sqrt.p 24
   %define R.ax rdi
    push      rdi
;?]]
    sub       rsp,	48
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    movzx     rax,	byte [mc_decls.pmode]
    dec       rax
    mov       r10,	63
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	rdi
    mov       r8,	rdi
    call      mc_libmcl.genmc
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_jumpcc
mc_genmcl.px_jumpcc:
;?>>
   %define R.p r13
   %define R.mcond rdi
   %define R.ax rbx
   %define R.bx rsi
   %define R.lx r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r13,	rcx
;---------------
    movzx     rax,	byte [r13+2]
    lea       r10,	[mc_genmcl.ucondcodes]
    movzx     r10,	byte [r10 + rax-1]
    mov       rdi,	r10
    mov       rax,	[r13+8]
    mov       rcx,	rax
    call      mc_libmcl.mgenlabel
    mov       r12,	rax
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	11
    jnz       L1939
    lea       rcx,	[L12332]
    lea       rdx,	[L12333]
    call      pc_api.merror
    jmp       L1938
L1939:
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rbx,	rax
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	2
    jle       L1941
    mov       rcx,	[mc_decls.noperands]
    call      mc_stackmcl.isimmload
    test      rax,	rax
    jz        L1943
    lea       rax,	[mc_decls.pclopnd]
    mov       r10,	[mc_decls.noperands]
    mov       rax,	[rax + r10*8-8]
    mov       rax,	[rax+8]
    test      rax,	rax
    jnz       L1943
    movzx     rax,	byte [r13+2]
    cmp       rax,	1
    jz        L1944
    cmp       rax,	2
    jnz       L1943
L1944:
    mov       rcx,	41
    mov       rdx,	rbx
    mov       r8,	rbx
    call      mc_libmcl.genmc
    jmp       L1942
L1943:
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rsi,	rax
    movzx     rax,	byte [mc_decls.pmode]
    lea       r10,	[pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L1946
    movzx     rax,	byte [r13+2]
    lea       r10,	[mc_genmcl.scondcodes]
    movzx     r10,	byte [r10 + rax-1]
    mov       rdi,	r10
L1946:
    mov       rcx,	42
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mc_libmcl.genmc
L1942:
    jmp       L1940
L1941:
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rsi,	rax
    movzx     rax,	byte [mc_decls.pmode]
    dec       rax
    mov       r10,	73
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mc_libmcl.genmc
L1940:
    mov       rcx,	26
    mov       rdx,	rdi
    mov       r8,	r12
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    call      mc_stackmcl.poppcl
    mov       eax,	[r13+16]
    test      eax,	eax
    jnz       L1948
    call      mc_stackmcl.poppcl
L1948:
L1938:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_jumpt
mc_genmcl.px_jumpt:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    mov       rdx,	5
    call      mc_auxmcl.do_jumptruefalse
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_jumpf
mc_genmcl.px_jumpf:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    mov       rdx,	4
    call      mc_auxmcl.do_jumptruefalse
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_bitand
mc_genmcl.px_bitand:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    mov       rdx,	38
    call      mc_auxmcl.do_bitwise
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_bitor
mc_genmcl.px_bitor:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    mov       rdx,	39
    call      mc_auxmcl.do_bitwise
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_bitxor
mc_genmcl.px_bitxor:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    mov       rdx,	40
    call      mc_auxmcl.do_bitwise
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_shl
mc_genmcl.px_shl:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    mov       rdx,	43
    call      mc_auxmcl.do_shift
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_shr
mc_genmcl.px_shr:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    lea       r10,	[pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L1957
    mov       rax,	44
    jmp       L1956
L1957:
    mov       rax,	45
L1956:
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mc_auxmcl.do_shift
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_retproc
mc_genmcl.px_retproc:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rax,	[mc_decls.mclprocentry]
    cmp       rax,	[mc_decls.mccodex]
    jnz       L1960
    lea       rcx,	[L12334]
    call      mc_libmcl.mgencomment
L1960:
    mov       rcx,	rdi
    call      mc_auxmcl.do_procentry
    call      mc_auxmcl.do_procexit
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_retfn
mc_genmcl.px_retfn:
;?>>
   %define R.p rsi
   %define R.ax rdi
   %define R.bx rbx
    %define mc_genmcl.px_retfn.$T1 -8
    push      rdi
    push      rbx
    push      rsi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       rsi,	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	11
    jnz       L1963
    mov       rcx,	1
    mov       rdx,	10
    xor       r8d,	r8d
    call      mc_libmcl.mgenireg
    mov       rbx,	rax
    mov       al,	1
    lea       r10,	[mc_decls.regset]
    mov       [r10],	al
    mov       rcx,	6
    call      mc_stackmcl.getworkregm
    mov       rdi,	rax
    mov       rcx,	[pc_decls.blockretname]
    mov       rdx,	6
    call      mc_libmcl.mgenmem
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    movzx     rax,	byte [rdi+10]
    mov       rcx,	rax
    mov       rdx,	10
    xor       r8d,	r8d
    call      mc_libmcl.mgenireg
    mov       rdi,	rax
    mov       eax,	[rsi+4]
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	rax
    mov       r9,	1
    call      mc_auxmcl.copyblock
    mov       rcx,	[pc_decls.blockretname]
    mov       rdx,	6
    call      mc_libmcl.mgenmem
    mov       [rbp + mc_genmcl.px_retfn.$T1],	rax
    mov       rcx,	1
    mov       rdx,	6
    call      mc_libmcl.mgenreg
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	[rbp + mc_genmcl.px_retfn.$T1]
    call      mc_libmcl.genmc
L1963:
    mov       rcx,	rsi
    call      mc_genmcl.px_retproc
;---------------
    add       rsp,	40
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_setcall
mc_genmcl.px_setcall:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    xor       ecx,	ecx
    call      mc_stackmcl.saveopnds
    mov       rax,	[mc_decls.ncalldepth]
    cmp       rax,	16
    jl        L1966
    lea       rcx,	[L12335]
    lea       rdx,	[L12336]
    call      pc_api.merror
L1966:
    inc       qword [mc_decls.ncalldepth]
    movsxd    rax,	dword [rdi+16]
    cmp       rax,	4
    jg        L1968
    mov       eax,	[mc_decls.mstackdepth]
    and       eax,	1
    lea       r10,	[mc_decls.callalign]
    mov       r11,	[mc_decls.ncalldepth]
    mov       [r10 + r11-1],	al
    jmp       L1967
L1968:
    movsxd    rax,	dword [rdi+16]
    and       eax,	1
    mov       r10d,	[mc_decls.mstackdepth]
    and       r10d,	1
    xor       rax,	r10
    lea       r10,	[mc_decls.callalign]
    mov       r11,	[mc_decls.ncalldepth]
    mov       [r10 + r11-1],	al
L1967:
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	11
    setz      al
    movzx     eax,	al
    lea       r10,	[mc_decls.callblockret]
    mov       r11,	[mc_decls.ncalldepth]
    mov       [r10 + r11-1],	al
    mov       eax,	[rdi+4]
    lea       r10,	[mc_decls.callblocksize]
    mov       r11,	[mc_decls.ncalldepth]
    mov       [r10 + r11*4-4],	eax
    lea       rax,	[mc_decls.callalign]
    mov       r10,	[mc_decls.ncalldepth]
    mov       al,	[rax + r10-1]
    test      al,	al
    jz        L1970
    mov       rcx,	1
    call      mc_libmcl.pushslots
L1970:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_setarg
mc_genmcl.px_setarg:
;?>>
   %define R.p rbx
   %define R.n rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    movsxd    rax,	dword [rbx+16]
    lea       r10,	[mc_decls.callblockret]
    mov       r11,	[mc_decls.ncalldepth]
    movzx     r10,	byte [r10 + r11-1]
    add       rax,	r10
    mov       rdi,	rax
    cmp       rdi,	4
    jle       L1973
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	11
    jnz       L1975
    mov       eax,	[rbx+4]
    xor       ecx,	ecx
    mov       rdx,	rax
    mov       r8,	rdi
    call      mc_auxmcl.copyblockarg
L1975:
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.pushopnd
    jmp       L1972
L1973:
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	11
    jnz       L1976
    mov       eax,	[rbx+4]
    lea       r10,	[mc_decls.callargsize]
    mov       r11,	[mc_decls.ncalldepth]
    shl       r11,	4
    lea       r10,	[r10 + r11-16]
    mov       r11,	rdi
    mov       [r10 + r11*4-4],	eax
L1976:
L1972:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_callp
mc_genmcl.px_callp:
;?>>
    %define mc_genmcl.px_callp.p 72
   %define R.nargs rdi
   %define R.nregargs rbx
   %define R.slots rsi
   %define R.isptr r12
   %define R.shadow r13
   %define R.blockret r14
   %define R.av_1 r15
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       [rbp+72],	rcx
;---------------
    xor       r12,	r12
    xor       eax,	eax
    mov       r13,	rax
    lea       rax,	[mc_decls.callblockret]
    mov       r10,	[mc_decls.ncalldepth]
    movzx     rax,	byte [rax + r10-1]
    mov       r14,	rax
    mov       rax,	[rbp + mc_genmcl.px_callp.p]
    movsxd    rax,	dword [rax+16]
    add       rax,	r14
    mov       rdi,	rax
    mov       rax,	rdi
    mov       r10,	4
    cmp       rax,	r10
    cmovg     rax,	r10
    mov       rbx,	rax
    mov       rax,	[rbp + mc_genmcl.px_callp.p]
    movzx     rax,	byte [rax]
    cmp       rax,	19
    jz        L1980
    cmp       rax,	22
    jnz       L1979
L1980:
    mov       r12,	1
L1979:
    mov       rax,	[rbp + mc_genmcl.px_callp.p]
    movsxd    rax,	dword [rax+20]
    mov       rcx,	rbx
    mov       rdx,	rax
    mov       r8,	r12
    call      mc_auxmcl.do_pushlowargs
    xor       rsi,	rsi
    mov       rax,	rdi
    cmp       rax,	4
    jg        L1982
    mov       rax,	[mc_decls.mstackdepth]
    test      rax,	rax
    jz        L1984
    mov       rax,	4
    add       rsi,	rax
    mov       rcx,	4
    call      mc_libmcl.pushslots
    lea       rax,	[mc_decls.callalign]
    mov       r10,	[mc_decls.ncalldepth]
    movzx     rax,	byte [rax + r10-1]
    add       rsi,	rax
    jmp       L1983
L1984:
    mov       al,	1
    mov       [pc_decls.localshadow],	al
L1983:
    jmp       L1981
L1982:
    lea       rax,	[mc_decls.callalign]
    mov       r10,	[mc_decls.ncalldepth]
    movzx     rax,	byte [rax + r10-1]
    mov       r10,	rdi
    add       r10,	rax
    mov       rsi,	r10
    mov       rcx,	4
    call      mc_libmcl.pushslots
L1981:
    test      r12,	r12
    jz        L1986
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rcx,	21
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    jmp       L1985
L1986:
    mov       rax,	[rbp + mc_genmcl.px_callp.p]
    mov       rax,	[rax+8]
    mov       rcx,	rax
    call      mc_libmcl.mgenmemaddr
    mov       rcx,	21
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L1985:
    mov       rax,	rbx
    sub       rax,	r14
    mov       r15,	rax
    cmp       r15,	0
    jle       L1989
L1987:
    call      mc_stackmcl.poppcl
    dec       r15
    jnz       L1987
L1989:
    test      rsi,	rsi
    jz        L1991
    mov       rcx,	rsi
    call      mc_libmcl.popslots
L1991:
    mov       al,	[mc_decls.pmode]
    test      al,	al
    jz        L1993
    mov       rcx,	[rbp + mc_genmcl.px_callp.p]
    call      mc_auxmcl.do_getretvalue
L1993:
    dec       qword [mc_decls.ncalldepth]
;---------------
    add       rsp,	40
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_jumpret
mc_genmcl.px_jumpret:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       al,	[mc_decls.pmode]
    test      al,	al
    jz        L1996
    mov       rax,	[mc_decls.noperands]
    test      rax,	rax
    jz        L1998
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    mov       r8,	1
    call      mc_stackmcl.loadparam
    call      mc_stackmcl.poppcl
L1998:
L1996:
    mov       rcx,	rdi
    call      mc_genmcl.px_jump
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_jumpretm
mc_genmcl.px_jumpretm:
;?>>
   %define R.p r13
   %define R.n rdi
   %define R.reg rbx
   %define R.av_1 rsi
   %define R.av_2 r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r13,	rcx
;---------------
    movsxd    rax,	dword [r13+16]
    mov       r10,	[mc_decls.noperands]
    sub       r10,	rax
    inc       r10
    mov       rdi,	r10
    movsxd    rax,	dword [r13+16]
    mov       rsi,	rax
    cmp       rsi,	0
    jle       L2002
L2000:
    lea       rax,	[mc_decls.pclmode]
    mov       r10,	rdi
    movzx     rax,	byte [rax + r10-1]
    mov       rcx,	rdi
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    inc       rdi
    dec       rsi
    jnz       L2000
L2002:
    mov       rbx,	1
    movsxd    rax,	dword [r13+16]
    mov       r12,	rax
    cmp       r12,	0
    jle       L2005
L2003:
    cmp       rbx,	4
    jnz       L2007
    lea       rax,	[mc_decls.pclmode]
    mov       r10,	[mc_decls.noperands]
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	2
    jle       L2007
    mov       rbx,	11
L2007:
    mov       rcx,	rbx
    call      mc_stackmcl.movetoreg
    call      mc_stackmcl.poppcl
    inc       rbx
    dec       r12
    jnz       L2003
L2005:
    mov       rcx,	r13
    call      mc_genmcl.px_jump
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_startmx
mc_genmcl.px_startmx:
;?>>
    %define mc_genmcl.px_startmx.p 16
;?]]
    sub       rsp,	40
;---------------
    xor       ecx,	ecx
    call      mc_stackmcl.saveopnds
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mc_genmcl.px_resetmx
mc_genmcl.px_resetmx:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	1
    call      mc_stackmcl.movetoreg
    movzx     rax,	byte [rdi]
    cmp       rax,	118
    jnz       L2011
    call      mc_stackmcl.poppcl
L2011:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_stop
mc_genmcl.px_stop:
;?>>
    %define mc_genmcl.px_stop.p 16
;?]]
    sub       rsp,	40
;---------------
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	6
    mov       r8,	11
    call      mc_stackmcl.loadparam
    lea       rcx,	[L12337]
    call      mc_libmcl.mgenextname
    mov       rcx,	21
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       al,	1
    mov       [pc_decls.localshadow],	al
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mc_genmcl.px_incrto
mc_genmcl.px_incrto:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    mov       rdx,	52
    mov       r8,	28
    call      mc_auxmcl.do_incr
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_decrto
mc_genmcl.px_decrto:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    mov       rdx,	53
    mov       r8,	29
    call      mc_auxmcl.do_incr
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_incrload
mc_genmcl.px_incrload:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    mov       rdx,	52
    mov       r8,	28
    call      mc_auxmcl.do_incrload
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_decrload
mc_genmcl.px_decrload:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    mov       rdx,	53
    mov       r8,	29
    call      mc_auxmcl.do_incrload
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_loadincr
mc_genmcl.px_loadincr:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    mov       rdx,	52
    mov       r8,	28
    call      mc_auxmcl.do_loadincr
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_loaddecr
mc_genmcl.px_loaddecr:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    mov       rdx,	53
    mov       r8,	29
    call      mc_auxmcl.do_loadincr
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_forup
mc_genmcl.px_forup:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    mov       rdx,	52
    mov       r8,	28
    mov       r9,	14
    call      mc_auxmcl.do_for
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_fordown
mc_genmcl.px_fordown:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    mov       rdx,	53
    mov       r8,	29
    mov       r9,	13
    call      mc_auxmcl.do_for
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_iload
mc_genmcl.px_iload:
;?>>
    %define mc_genmcl.px_iload.p 40
   %define R.ax rdi
   %define R.px rbx
   %define R.nextpcl rsi
    %define mc_genmcl.px_iload.$T1 -8
    push      rdi
    push      rbx
    push      rsi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	11
    jz        L2023
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	[mc_decls.noperands]
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	2
    jnz       L2025
    movzx     rax,	byte [mc_decls.pmode]
    lea       r10,	[mc_decls.pclreg]
    mov       r11,	[mc_decls.noperands]
    movzx     r10,	byte [r10 + r11-1]
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.mgenireg
    mov       rbx,	rax
    jmp       L2024
L2025:
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       rbx,	rax
L2024:
    mov       rax,	[mc_decls.currpcl]
    lea       rax,	[rax+32]
    mov       rsi,	rax
    movzx     rax,	byte [rsi]
    cmp       rax,	114
    jnz       L2027
    movzx     rax,	byte [rsi+3]
    mov       [rbp + mc_genmcl.px_iload.$T1],	rax
    movzx     rax,	byte [rsi+3]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mc_genmcl.getsharereg
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_genmcl.px_iload.$T1]
    call      mc_stackmcl.getworkreg_rm
    mov       rdi,	rax
    movsxd    rax,	dword [rsi+28]
    and       rax,	255
    lea       r10,	[mc_decls.ploadop]
    movzx     r10,	byte [r10 + rax]
    mov       rcx,	r10
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    movzx     rax,	byte [rsi+3]
    movzx     r10,	byte [rdi+10]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_stackmcl.setnewzz
    mov       [mc_decls.currpcl],	rsi
    jmp       L2026
L2027:
    movzx     rax,	byte [mc_decls.pmode]
    mov       [rbp + mc_genmcl.px_iload.$T1],	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mc_genmcl.getsharereg
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_genmcl.px_iload.$T1]
    call      mc_stackmcl.getworkreg_rm
    mov       rdi,	rax
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    movzx     rax,	byte [mc_decls.pmode]
    movzx     r10,	byte [rdi+10]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_stackmcl.setnewzz
L2026:
    jmp       L2022
L2023:
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind_simp
    mov       rbx,	rax
    movzx     rax,	byte [rbx+10]
    mov       rcx,	rax
    mov       rdx,	6
    call      mc_stackmcl.getworkreg_rm
    mov       rdi,	rax
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_auxmcl.dolea
L2022:
;---------------
    add       rsp,	40
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.getsharereg
mc_genmcl.getsharereg:
;?>>
   %define R.ax rcx
   %define R.mode rdx
   %define R.reg dil
   %define R.regix bl
    push      rdi
    push      rbx
;?]]
;---------------
    mov       dil,	[rcx+10]
    mov       bl,	[rcx+11]
    cmp       rdx,	2
    jg        L2030
    xor       eax,	eax
    jmp       L2028
L2030:
    test      dil,	dil
    jz        L2032
    movzx     rax,	dil
    lea       r10,	[mc_decls.workregs]
    mov       r10b,	[r10 + rax-1]
    test      r10b,	r10b
    jnz       L2033
    movzx     rax,	dil
    cmp       rax,	11
    jl        L2032
    cmp       rax,	14
    jg        L2032
L2033:
    movzx     rax,	dil
    jmp       L2028
L2032:
    test      bl,	bl
    jz        L2034
    movzx     rax,	bl
    lea       r10,	[mc_decls.workregs]
    mov       r10b,	[r10 + rax-1]
    test      r10b,	r10b
    jnz       L2035
    movzx     rax,	dil
    cmp       rax,	11
    jl        L2034
    cmp       rax,	14
    jg        L2034
L2035:
    movzx     rax,	bl
    jmp       L2028
L2034:
L2031:
    xor       eax,	eax
L2028:
;---------------
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_iloadx
mc_genmcl.px_iloadx:
;?>>
   %define R.p r12
   %define R.nextpcl rdi
   %define R.ax rbx
   %define R.px rsi
    %define mc_genmcl.px_iloadx.$T1 -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       r12,	rcx
;---------------
    mov       rcx,	r12
    call      mc_auxmcl.do_addrmode
    mov       rsi,	rax
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	11
    jnz       L2038
    movzx     rax,	byte [rsi+10]
    mov       rcx,	rax
    mov       rdx,	6
    call      mc_stackmcl.getworkreg_rm
    mov       rbx,	rax
    mov       rcx,	rbx
    mov       rdx,	rsi
    call      mc_auxmcl.dolea
    call      mc_stackmcl.poppcl
    movzx     rax,	byte [rbx+10]
    mov       rcx,	rax
    mov       rdx,	6
    call      mc_stackmcl.setnewzz
    jmp       L2037
L2038:
    mov       rax,	[mc_decls.currpcl]
    lea       rax,	[rax+32]
    mov       rdi,	rax
    movzx     rax,	byte [rdi]
    cmp       rax,	114
    jnz       L2040
    movzx     rax,	byte [rdi+3]
    mov       [rbp + mc_genmcl.px_iloadx.$T1],	rax
    movzx     rax,	byte [rdi+3]
    mov       rcx,	rsi
    mov       rdx,	rax
    call      mc_genmcl.getsharereg
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_genmcl.px_iloadx.$T1]
    call      mc_stackmcl.getworkreg_rm
    mov       rbx,	rax
    movsxd    rax,	dword [rdi+28]
    and       rax,	255
    lea       r10,	[mc_decls.ploadop]
    movzx     r10,	byte [r10 + rax]
    mov       rcx,	r10
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    movzx     rax,	byte [rdi+3]
    movzx     r10,	byte [rbx+10]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_stackmcl.setnewzz
    mov       [mc_decls.currpcl],	rdi
    jmp       L2039
L2040:
    movzx     rax,	byte [mc_decls.pmode]
    mov       [rbp + mc_genmcl.px_iloadx.$T1],	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	rsi
    mov       rdx,	rax
    call      mc_genmcl.getsharereg
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_genmcl.px_iloadx.$T1]
    call      mc_stackmcl.getworkreg_rm
    mov       rbx,	rax
    mov       rcx,	11
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    movzx     rax,	byte [mc_decls.pmode]
    movzx     r10,	byte [rbx+10]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_stackmcl.setnewzz
L2039:
L2037:
;---------------
    add       rsp,	48
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_istore
mc_genmcl.px_istore:
;?>>
   %define R.p rsi
   %define R.bx rdi
   %define R.px rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	[mc_decls.noperands]
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	2
    jnz       L2043
    movzx     rax,	byte [mc_decls.pmode]
    lea       r10,	[mc_decls.pclreg]
    mov       r11,	[mc_decls.noperands]
    movzx     r10,	byte [r10 + r11-1]
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.mgenireg
    mov       rbx,	rax
    jmp       L2042
L2043:
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       rbx,	rax
L2042:
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	11
    jnz       L2045
    mov       rcx,	rbx
    call      mc_stackmcl.makesimpleaddr
    mov       rbx,	rax
    mov       rcx,	rdi
    mov       rdx,	6
    call      mc_stackmcl.makeopndind
    mov       rdi,	rax
    mov       eax,	[rsi+4]
    mov       rcx,	rbx
    mov       rdx,	rdi
    mov       r8,	rax
    mov       r9,	1
    call      mc_auxmcl.copyblock
    jmp       L2044
L2045:
    mov       rcx,	11
    mov       rdx,	rbx
    mov       r8,	rdi
    call      mc_libmcl.genmc
L2044:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_istorex
mc_genmcl.px_istorex:
;?>>
   %define R.p rsi
   %define R.cx rdi
   %define R.px rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    sub       r10,	2
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    mov       rcx,	rsi
    call      mc_auxmcl.do_addrmode
    mov       rbx,	rax
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	11
    jnz       L2048
    mov       rcx,	rbx
    call      mc_stackmcl.makesimpleaddr
    mov       rbx,	rax
    mov       rcx,	rdi
    mov       rdx,	6
    call      mc_stackmcl.makeopndind
    mov       rdi,	rax
    mov       eax,	[rsi+4]
    mov       rcx,	rbx
    mov       rdx,	rdi
    mov       r8,	rax
    mov       r9,	1
    call      mc_auxmcl.copyblock
    jmp       L2047
L2048:
    mov       rcx,	11
    mov       rdx,	rbx
    mov       r8,	rdi
    call      mc_libmcl.genmc
L2047:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_storem
mc_genmcl.px_storem:
;?>>
   %define R.p r12
   %define R.bx rdi
   %define R.px rbx
   %define R.dblock rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       r12,	rcx
;---------------
    mov       eax,	[r12+4]
    cmp       rax,	16
    jz        L2051
    lea       rcx,	[L12338]
    lea       rdx,	[L12339]
    call      pc_api.merror
L2051:
    mov       rcx,	16
    call      mc_libmcl.newblocktemp
    mov       rsi,	rax
    mov       rcx,	rsi
    mov       rdx,	6
    call      mc_libmcl.mgenmem
    mov       rbx,	rax
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    mov       rcx,	rbx
    mov       rdx,	8
    xor       r8d,	r8d
    call      mc_libmcl.applyoffset
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	rdi
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    mov       rcx,	11
    mov       rdx,	rbx
    mov       r8,	rdi
    call      mc_libmcl.genmc
    movzx     rax,	byte [rdi+10]
    mov       rcx,	rax
    mov       rdx,	6
    call      mc_libmcl.mgenreg
    mov       rcx,	14
    mov       rdx,	rax
    mov       r8,	rbx
    call      mc_libmcl.genmc
    movzx     rax,	byte [rdi+10]
    mov       rcx,	rax
    mov       rdx,	6
    call      mc_stackmcl.setnewzz
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_addpx
mc_genmcl.px_addpx:
;?>>
   %define R.p rsi
   %define R.ax rdi
   %define R.cx rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    mov       rcx,	rsi
    call      mc_auxmcl.do_addrmode
    mov       rbx,	rax
    movzx     rax,	byte [rbx+10]
    mov       rcx,	rax
    mov       rdx,	6
    call      mc_stackmcl.getworkreg_rm
    mov       rdi,	rax
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_auxmcl.dolea
    call      mc_stackmcl.poppcl
    movzx     rax,	byte [rdi+10]
    mov       rcx,	rax
    mov       rdx,	6
    call      mc_stackmcl.setnewzz
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_subpx
mc_genmcl.px_subpx:
;?>>
   %define R.p r14
   %define R.scale rdi
   %define R.extra rbx
   %define R.ax rsi
   %define R.bx r12
   %define R.z r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       r14,	rcx
;---------------
    movsxd    rax,	dword [r14+16]
    mov       rdi,	rax
    movsxd    rax,	dword [r14+20]
    mov       rbx,	rax
    mov       rax,	[mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rsi,	rax
    mov       rcx,	[mc_decls.noperands]
    call      mc_stackmcl.isimmload
    mov       r13,	rax
    test      rax,	rax
    jz        L2055
    mov       rax,	[r13+8]
    imul      rax,	rdi
    add       rax,	rbx
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	29
    mov       rdx,	rsi
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L2054
L2055:
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       r12,	rax
    mov       rcx,	r12
    mov       rdx,	rdi
    call      mc_auxmcl.scaleindex
    mov       rdi,	rax
    cmp       rdi,	1
    jle       L2057
    mov       rcx,	r12
    mov       rdx,	rdi
    call      mc_auxmcl.mulimm
L2057:
    mov       rcx,	29
    mov       rdx,	rsi
    mov       r8,	r12
    call      mc_libmcl.genmc
    test      rbx,	rbx
    jz        L2059
    call      msys.m$print_startcon
    lea       rcx,	[L12340]
    call      msys.m$print_str_nf
    mov       rcx,	rbx
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L12341]
    lea       rdx,	[L12342]
    call      pc_api.merror
L2059:
L2054:
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_to
mc_genmcl.px_to:
;?>>
   %define R.p rsi
   %define R.q rdi
   %define R.ax rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    lea       rax,	[rsi+32]
    mov       [mc_decls.currpcl],	rax
    mov       rdi,	rax
    mov       rax,	[rdi+8]
    mov       rcx,	rax
    mov       rdx,	6
    call      mc_libmcl.mgenmem
    mov       rbx,	rax
    mov       rcx,	53
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rax,	[rsi+8]
    mov       rcx,	rax
    call      mc_libmcl.mgenlabel
    mov       rcx,	26
    mov       rdx,	5
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_iswap
mc_genmcl.px_iswap:
;?>>
    %define mc_genmcl.px_iswap.p 48
   %define R.ax rdi
   %define R.bx rbx
   %define R.px rsi
   %define R.qx r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       rsi,	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       r12,	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	rax
    call      mc_stackmcl.getworkregm
    mov       rdi,	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	rax
    call      mc_stackmcl.getworkregm
    mov       rbx,	rax
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	11
    jz        L2063
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rsi
    call      mc_libmcl.genmc
    mov       rcx,	11
    mov       rdx,	rbx
    mov       r8,	r12
    call      mc_libmcl.genmc
    mov       rcx,	11
    mov       rdx,	r12
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rcx,	11
    mov       rdx,	rsi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    jmp       L2062
L2063:
    lea       rcx,	[L12343]
    lea       rdx,	[L12344]
    call      pc_api.merror
L2062:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_swapstk
mc_genmcl.px_swapstk:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    movsxd    rax,	dword [rdi+20]
    mov       r10,	[mc_decls.noperands]
    sub       r10,	rax
    inc       r10
    movsxd    rax,	dword [rdi+16]
    mov       r11,	[mc_decls.noperands]
    sub       r11,	rax
    inc       r11
    mov       rcx,	r11
    mov       rdx,	r10
    call      mc_stackmcl.swapopnds
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_labeldef
mc_genmcl.px_labeldef:
;?>>
   %define R.p rdi
    %define mc_genmcl.px_labeldef.str -104
    push      rdi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	136
    mov       rdi,	rcx
;---------------
    mov       rax,	[rdi+8]
    mov       rax,	[rax]
    lea       rcx,	[rbp + mc_genmcl.px_labeldef.str]
    mov       rdx,	rax
    call      strcpy
    lea       rcx,	[rbp + mc_genmcl.px_labeldef.str]
    lea       rdx,	[L12345]
    call      strcat
    lea       rcx,	[rbp + mc_genmcl.px_labeldef.str]
    call      mc_libmcl.mgencomment
;---------------
    add       rsp,	136
    pop       rbp
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_addto
mc_genmcl.px_addto:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    mov       rdx,	28
    mov       r8,	65
    call      mc_auxmcl.do_binto
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_subto
mc_genmcl.px_subto:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    mov       rdx,	29
    mov       r8,	67
    call      mc_auxmcl.do_binto
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_multo
mc_genmcl.px_multo:
;?>>
   %define R.p r13
   %define R.ax rdi
   %define R.bx rbx
   %define R.cx rsi
   %define R.x r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r13,	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	2
    jg        L2070
    mov       rcx,	r13
    mov       rdx,	69
    call      mc_auxmcl.do_binto_float
    jmp       L2068
L2070:
    movzx     rax,	byte [mc_decls.pmode]
    lea       r10,	[pc_tables.psize]
    movzx     r10,	byte [r10 + rax]
    cmp       r10,	1
    jnz       L2072
    lea       rcx,	[L12346]
    lea       rdx,	[L12347]
    call      pc_api.merror
L2072:
    mov       rcx,	10
    xor       edx,	edx
    call      mc_stackmcl.pushpcl_reg
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       rdi,	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    sub       r10,	2
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rbx,	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rsi,	rax
    mov       rcx,	11
    mov       rdx,	rsi
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rax,	[mc_decls.noperands]
    sub       rax,	2
    mov       rcx,	rax
    call      mc_stackmcl.isimmload
    mov       r12,	rax
    test      rax,	rax
    jz        L2074
    mov       rax,	[r12+8]
    mov       rcx,	rsi
    mov       rdx,	rax
    call      mc_auxmcl.mulimm
    jmp       L2073
L2074:
    mov       rcx,	34
    mov       rdx,	rsi
    mov       r8,	rbx
    call      mc_libmcl.genmc
L2073:
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rsi
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
L2068:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_bitandto
mc_genmcl.px_bitandto:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    mov       rdx,	38
    xor       r8d,	r8d
    call      mc_auxmcl.do_binto
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_bitorto
mc_genmcl.px_bitorto:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    mov       rdx,	39
    xor       r8d,	r8d
    call      mc_auxmcl.do_binto
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_bitxorto
mc_genmcl.px_bitxorto:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    mov       rdx,	40
    xor       r8d,	r8d
    call      mc_auxmcl.do_binto
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_shlto
mc_genmcl.px_shlto:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    mov       rdx,	43
    call      mc_auxmcl.do_shiftnto
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_shrto
mc_genmcl.px_shrto:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    lea       r10,	[pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L2081
    mov       rax,	44
    jmp       L2080
L2081:
    mov       rax,	45
L2080:
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mc_auxmcl.do_shiftnto
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_fix
mc_genmcl.px_fix:
;?>>
   %define R.p rsi
   %define R.fx rdi
   %define R.ax rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    movsxd    rax,	dword [rsi+28]
    and       rax,	255
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	rax
    xor       edx,	edx
    call      mc_stackmcl.pushpcl_reg
    movzx     rax,	byte [mc_decls.pmode]
    lea       r10,	[pc_tables.pmin]
    movzx     r10,	byte [r10 + rax]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	r10
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rbx,	rax
    movsxd    rax,	dword [rsi+28]
    and       rax,	255
    dec       rax
    mov       r10,	84
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	rbx
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rax,	[mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	[mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    call      mc_stackmcl.poppcl
    movzx     rax,	byte [mc_decls.pmode]
    movzx     r10,	byte [rbx+10]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_stackmcl.setnewzz
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_float
mc_genmcl.px_float:
;?>>
   %define R.p r14
   %define R.ax rdi
   %define R.fx rbx
   %define R.lab rsi
   %define R.lab2 r12
   %define R.pmode2 r13b
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       r14,	rcx
;---------------
    movsxd    rax,	dword [r14+28]
    and       rax,	255
    mov       r13b,	al
    movzx     rax,	r13b
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    movzx     rax,	r13b
    lea       r10,	[pc_tables.psize]
    movzx     r10,	byte [r10 + rax]
    cmp       r10,	4
    jge       L2085
    lea       rcx,	[L12348]
    lea       rdx,	[L12349]
    call      pc_api.merror
L2085:
    movzx     rax,	r13b
    lea       r10,	[pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L2087
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	rax
    xor       edx,	edx
    call      mc_stackmcl.pushpcl_reg
    movzx     rax,	byte [r14+3]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rbx,	rax
    movzx     rax,	byte [mc_decls.pmode]
    dec       rax
    mov       r10,	86
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	rbx
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rax,	[mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	[mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    jmp       L2086
L2087:
    movzx     rax,	r13b
    cmp       rax,	6
    jnz       L2088
    mov       rcx,	2
    xor       edx,	edx
    call      mc_stackmcl.pushpcl_reg
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	2
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rbx,	rax
    call      mc_libmcl.mcreatefwdlabel
    mov       rsi,	rax
    call      mc_libmcl.mcreatefwdlabel
    mov       r12,	rax
    xor       ecx,	ecx
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	42
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	rsi
    call      mc_libmcl.mgenlabel
    mov       rcx,	26
    mov       rdx,	12
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    mov       rcx,	87
    mov       rdx,	rbx
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rcx,	r12
    call      mc_libmcl.mgenlabel
    mov       rcx,	25
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	rsi
    call      mc_libmcl.mdefinefwdlabel
    mov       rax,	[mc_decls.labmask63]
    test      rax,	rax
    jnz       L2090
    inc       qword [pc_api.mlabelno]
    mov       rax,	[pc_api.mlabelno]
    mov       [mc_decls.labmask63],	rax
    inc       qword [pc_api.mlabelno]
    mov       rax,	[pc_api.mlabelno]
    mov       [mc_decls.laboffset64],	rax
L2090:
    mov       rcx,	[mc_decls.labmask63]
    call      mc_libmcl.mgenlabelmem
    mov       rcx,	38
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	87
    mov       rdx,	rbx
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rcx,	[mc_decls.laboffset64]
    call      mc_libmcl.mgenlabelmem
    mov       rcx,	66
    mov       rdx,	rbx
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	r12
    call      mc_libmcl.mdefinefwdlabel
;mc_genmcl.px_float.reduce:
L2091:
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	1
    jnz       L2093
    mov       rcx,	rbx
    mov       rdx,	4
    call      mc_libmcl.changeopndsize
    mov       rcx,	88
    mov       rdx,	rax
    mov       r8,	rbx
    call      mc_libmcl.genmc
    mov       al,	1
    lea       r10,	[mc_decls.pclmode]
    mov       r11,	[mc_decls.noperands]
    mov       [r10 + r11-1],	al
L2093:
    mov       rax,	[mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	[mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    jmp       L2086
L2088:
    mov       rcx,	2
    xor       edx,	edx
    call      mc_stackmcl.pushpcl_reg
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	2
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rbx,	rax
    mov       rcx,	rdi
    mov       rdx,	8
    call      mc_libmcl.changeopndsize
    mov       rdi,	rax
    mov       rcx,	87
    mov       rdx,	rbx
    mov       r8,	rdi
    call      mc_libmcl.genmc
    jmp       L2091
L2086:
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_idiv
mc_genmcl.px_idiv:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    lea       r10,	[pc_tables.psigned]
    movzx     r10,	byte [r10 + rax]
    mov       rcx,	rdi
    mov       rdx,	r10
    mov       r8,	1
    call      mc_auxmcl.do_divrem
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_irem
mc_genmcl.px_irem:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    lea       r10,	[pc_tables.psigned]
    movzx     r10,	byte [r10 + rax]
    mov       rcx,	rdi
    mov       rdx,	r10
    xor       r8d,	r8d
    call      mc_auxmcl.do_divrem
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_idivrem
mc_genmcl.px_idivrem:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    lea       r10,	[pc_tables.psigned]
    movzx     r10,	byte [r10 + rax]
    mov       rcx,	rdi
    mov       rdx,	r10
    mov       r8,	2
    call      mc_auxmcl.do_divrem
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_clear
mc_genmcl.px_clear:
;?>>
   %define R.p rbx
   %define R.ax rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	6
    call      mc_stackmcl.getopnd_ind_simp
    mov       rdi,	rax
    mov       eax,	[rbx+4]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mc_auxmcl.clearblock
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_subp
mc_genmcl.px_subp:
;?>>
   %define R.p r12
   %define R.ax rdi
   %define R.bx rbx
   %define R.n rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       r12,	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rbx,	rax
    mov       rcx,	29
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    movsxd    rax,	dword [r12+16]
    cmp       rax,	1
    jle       L2100
    movsxd    rax,	dword [r12+16]
    mov       rcx,	rax
    call      mc_libmcl.ispoweroftwo
    mov       rsi,	rax
    test      rsi,	rsi
    jz        L2102
    mov       rcx,	rsi
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	45
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L2101
L2102:
    call      msys.m$print_startcon
    movsxd    rax,	dword [r12+16]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L12350]
    lea       rdx,	[L12351]
    call      pc_api.merror
L2101:
L2100:
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_switch
mc_genmcl.px_switch:
;?>>
    %define mc_genmcl.px_switch.p 64
   %define R.minlab rdi
   %define R.maxlab rbx
   %define R.jumplab rsi
   %define R.elselab r12
   %define R.reg r13
   %define R.ax r14
    %define mc_genmcl.px_switch.bx -8
    %define mc_genmcl.px_switch.ax2 -16
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+64],	rcx
;---------------
    mov       rax,	[rbp + mc_genmcl.px_switch.p]
    movsxd    rax,	dword [rax+16]
    mov       rdi,	rax
    mov       rax,	[rbp + mc_genmcl.px_switch.p]
    movsxd    rax,	dword [rax+20]
    mov       rbx,	rax
    mov       rax,	[rbp + mc_genmcl.px_switch.p]
    mov       rsi,	[rax+8]
    mov       rax,	[rbp + mc_genmcl.px_switch.p]
    lea       rax,	[rax+32]
    mov       [mc_decls.currpcl],	rax
    mov       rax,	[mc_decls.currpcl]
    mov       r12,	[rax+8]
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       r14,	rax
    mov       rax,	[rbp + mc_genmcl.px_switch.p]
    mov       eax,	[rax+4]
    cmp       rax,	8
    jge       L2105
    mov       rcx,	r14
    mov       rdx,	8
    call      mc_libmcl.changeopndsize
    mov       r10,	rax
    mov       [rbp + mc_genmcl.px_switch.ax2],	r10
    mov       rcx,	18
    mov       rdx,	rax
    mov       r8,	r14
    call      mc_libmcl.genmc
    mov       r14,	[rbp + mc_genmcl.px_switch.ax2]
L2105:
    test      rdi,	rdi
    jz        L2107
    mov       rcx,	rdi
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	29
    mov       rdx,	r14
    mov       r8,	rax
    call      mc_libmcl.genmc
L2107:
    mov       rax,	rbx
    sub       rax,	rdi
    inc       rax
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	42
    mov       rdx,	r14
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	r12
    call      mc_libmcl.mgenlabel
    mov       rcx,	26
    mov       rdx,	3
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    movzx     rax,	byte [pc_api.phighmem]
    cmp       rax,	2
    jnz       L2109
    call      mc_stackmcl.getworkireg
    mov       r13,	rax
    mov       rcx,	r13
    mov       rdx,	6
    call      mc_libmcl.mgenreg
    mov       [rbp + mc_genmcl.px_switch.bx],	rax
    mov       rcx,	rsi
    call      mc_libmcl.mgenlabelmem
    mov       rcx,	14
    mov       rdx,	[rbp + mc_genmcl.px_switch.bx]
    mov       r8,	rax
    call      mc_libmcl.genmc
    sub       rsp,	8
    push      0
    push      0
    push      0
    movzx     rax,	byte [r14+10]
    mov       rcx,	r13
    mov       rdx,	rax
    mov       r8,	8
    xor       r9d,	r9d
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       rcx,	25
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L2108
L2109:
    sub       rsp,	8
    push      0
    mov       rax,	rsi
    push      rax
    push      0
    movzx     rax,	byte [r14+10]
    xor       ecx,	ecx
    mov       rdx,	rax
    mov       r8,	8
    xor       r9d,	r9d
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       rcx,	25
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2108:
    call      mc_stackmcl.poppcl
    mov       rcx,	73
    mov       rdx,	1
    call      mc_libmcl.setsegment
;---------------
    add       rsp,	48
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_switchu
mc_genmcl.px_switchu:
;?>>
    %define mc_genmcl.px_switchu.p 64
   %define R.minlab rdi
   %define R.maxlab rbx
   %define R.jumplab rsi
   %define R.reg r12
   %define R.ax r13
   %define R.bx r14
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+64],	rcx
;---------------
    mov       rax,	[rbp + mc_genmcl.px_switchu.p]
    movsxd    rax,	dword [rax+16]
    mov       rdi,	rax
    mov       rax,	[rbp + mc_genmcl.px_switchu.p]
    movsxd    rax,	dword [rax+20]
    mov       rbx,	rax
    mov       rax,	[rbp + mc_genmcl.px_switchu.p]
    mov       rsi,	[rax+8]
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       r13,	rax
    movzx     rax,	byte [pc_api.phighmem]
    cmp       rax,	2
    jnz       L2112
    call      mc_stackmcl.getworkireg
    mov       r12,	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	r12
    mov       rdx,	rax
    call      mc_libmcl.mgenreg
    mov       r14,	rax
    mov       rcx,	rsi
    call      mc_libmcl.mgenlabelmem
    mov       rcx,	14
    mov       rdx,	r14
    mov       r8,	rax
    call      mc_libmcl.genmc
    sub       rsp,	8
    push      0
    push      0
    push      0
    mov       rax,	rdi
    neg       rax
    shl       rax,	3
    movzx     r10,	byte [r13+10]
    mov       rcx,	r12
    mov       rdx,	r10
    mov       r8,	8
    mov       r9,	rax
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       rcx,	25
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L2111
L2112:
    sub       rsp,	8
    push      0
    mov       rax,	rsi
    push      rax
    push      0
    mov       rax,	rdi
    neg       rax
    shl       rax,	3
    movzx     r10,	byte [r13+10]
    xor       ecx,	ecx
    mov       rdx,	r10
    mov       r8,	8
    mov       r9,	rax
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       rcx,	25
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2111:
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	32
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_swlabel
mc_genmcl.px_swlabel:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rax,	[rdi+8]
    mov       rcx,	rax
    call      mc_libmcl.mgenlabel
    mov       rcx,	119
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_endsw
mc_genmcl.px_endsw:
;?>>
    %define mc_genmcl.px_endsw.p 16
;?]]
    sub       rsp,	40
;---------------
    mov       rcx,	67
    mov       rdx,	1
    call      mc_libmcl.setsegment
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mc_genmcl.px_fwiden
mc_genmcl.px_fwiden:
;?>>
   %define R.p rbx
   %define R.fx rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    movsxd    rax,	dword [rbx+28]
    and       rax,	255
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    mov       rcx,	rdi
    mov       rdx,	8
    call      mc_libmcl.changeopndsize
    mov       rcx,	89
    mov       rdx,	rax
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       al,	2
    lea       r10,	[mc_decls.pclmode]
    mov       r11,	[mc_decls.noperands]
    mov       [r10 + r11-1],	al
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_fnarrow
mc_genmcl.px_fnarrow:
;?>>
   %define R.p rbx
   %define R.fx rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    movsxd    rax,	dword [rbx+28]
    and       rax,	255
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    mov       rcx,	rdi
    mov       rdx,	4
    call      mc_libmcl.changeopndsize
    mov       rcx,	88
    mov       rdx,	rax
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       al,	1
    lea       r10,	[mc_decls.pclmode]
    mov       r11,	[mc_decls.noperands]
    mov       [r10 + r11-1],	al
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_truncate
mc_genmcl.px_truncate:
;?>>
   %define R.p rsi
   %define R.ax rdi
   %define R.pmode2 bl
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    movsxd    rax,	dword [rsi+28]
    and       rax,	255
    mov       bl,	al
    movzx     rax,	bl
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    mov       eax,	[rsi+4]
    movzx     r10,	bl
    lea       r11,	[pc_tables.psize]
    movzx     r11,	byte [r11 + r10]
    cmp       rax,	r11
    jz        L2119
    movzx     rax,	byte [mc_decls.pmode]
    lea       r10,	[pc_tables.psize]
    movzx     r10,	byte [r10 + rax]
    mov       rcx,	rdi
    mov       rdx,	r10
    call      mc_libmcl.changeopndsize
    movzx     r10,	bl
    lea       r11,	[mc_decls.ploadop]
    movzx     r11,	byte [r11 + r10]
    mov       rcx,	r11
    mov       rdx,	rax
    mov       r8,	rdi
    call      mc_libmcl.genmc
L2119:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_typepun
mc_genmcl.px_typepun:
;?>>
   %define R.p rsi
   %define R.ax rdi
   %define R.bx rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    movsxd    rax,	dword [rsi+28]
    and       rax,	255
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rbx,	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	rax
    call      mc_stackmcl.getworkregm
    mov       rdi,	rax
    movzx     rax,	word [rdi+8]
    and       rax,	31
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mc_libmcl.changeopndsize
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    movzx     rax,	byte [mc_decls.pmode]
    movzx     r10,	byte [rdi+10]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_stackmcl.setnewzz
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_unload
mc_genmcl.px_unload:
;?>>
    %define mc_genmcl.px_unload.p 16
;?]]
    sub       rsp,	40
;---------------
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mc_genmcl.px_loadbit
mc_genmcl.px_loadbit:
;?>>
    %define mc_genmcl.px_loadbit.p 48
   %define R.ax rdi
   %define R.z rbx
   %define R.i rsi
   %define R.m r12
    %define mc_genmcl.px_loadbit.$T1 -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    mov       rcx,	[mc_decls.noperands]
    call      mc_stackmcl.isimmload
    mov       rbx,	rax
    test      rax,	rax
    jz        L2124
    mov       rsi,	[rbx+8]
    mov       rax,	rsi
    cmp       rax,	0
    jl        L2126
    cmp       rax,	31
    jg        L2126
    mov       rax,	5
    jmp       L2125
L2126:
    mov       rax,	6
L2125:
    mov       r12,	rax
    mov       rax,	[mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	r12
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    test      rsi,	rsi
    jz        L2128
    mov       rcx,	rsi
    mov       rdx,	r12
    call      mc_libmcl.mgenint
    mov       rcx,	45
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    cmp       rsi,	63
    jz        L2131
L2130:
L2128:
    jmp       L2123
L2124:
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    mov       al,	[pc_decls.r10used]
    test      al,	al
    jz        L2133
    mov       rcx,	11
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	12
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2133:
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	3
    mov       r8,	11
    call      mc_stackmcl.loadparam
    mov       rcx,	45
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       al,	[pc_decls.r10used]
    test      al,	al
    jz        L2135
    mov       rcx,	11
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	13
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2135:
L2123:
    mov       rcx,	1
    mov       rdx,	5
    call      mc_libmcl.mgenint
    mov       [rbp + mc_genmcl.px_loadbit.$T1],	rax
    mov       rcx,	rdi
    mov       rdx,	4
    call      mc_libmcl.changeopndsize
    mov       rcx,	38
    mov       rdx,	rax
    mov       r8,	[rbp + mc_genmcl.px_loadbit.$T1]
    call      mc_libmcl.genmc
;mc_genmcl.px_loadbit.skip:
L2131:
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	48
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_assem
mc_genmcl.px_assem:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rax,	[pc_api.idomcl_assem]
    test      rax,	rax
    jz        L2138
    mov       rax,	[rdi+8]
    mov       rcx,	rax
    mov       r10,	[pc_api.idomcl_assem]
    call      r10
    jmp       L2137
L2138:
    lea       rcx,	[L12352]
    lea       rdx,	[L12353]
    call      pc_api.merror
L2137:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_sin
mc_genmcl.px_sin:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    lea       rdx,	[L12354]
    mov       r8,	1
    call      mc_auxmcl.do_maths
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_cos
mc_genmcl.px_cos:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    lea       rdx,	[L12355]
    mov       r8,	1
    call      mc_auxmcl.do_maths
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_tan
mc_genmcl.px_tan:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    lea       rdx,	[L12356]
    mov       r8,	1
    call      mc_auxmcl.do_maths
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_asin
mc_genmcl.px_asin:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    lea       rdx,	[L12357]
    mov       r8,	1
    call      mc_auxmcl.do_maths
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_acos
mc_genmcl.px_acos:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    lea       rdx,	[L12358]
    mov       r8,	1
    call      mc_auxmcl.do_maths
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_atan
mc_genmcl.px_atan:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    lea       rdx,	[L12359]
    mov       r8,	1
    call      mc_auxmcl.do_maths
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_log
mc_genmcl.px_log:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    lea       rdx,	[L12360]
    mov       r8,	1
    call      mc_auxmcl.do_maths
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_log10
mc_genmcl.px_log10:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    lea       rdx,	[L12361]
    mov       r8,	1
    call      mc_auxmcl.do_maths
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_exp
mc_genmcl.px_exp:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    lea       rdx,	[L12362]
    mov       r8,	1
    call      mc_auxmcl.do_maths
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_round
mc_genmcl.px_round:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    lea       rdx,	[L12363]
    mov       r8,	1
    call      mc_auxmcl.do_maths
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_floor
mc_genmcl.px_floor:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    lea       rdx,	[L12364]
    mov       r8,	1
    call      mc_auxmcl.do_maths
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_ceil
mc_genmcl.px_ceil:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    lea       rdx,	[L12365]
    mov       r8,	1
    call      mc_auxmcl.do_maths
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_atan2
mc_genmcl.px_atan2:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rax,	[mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	[mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    mov       rcx,	rdi
    lea       rdx,	[L12366]
    mov       r8,	2
    call      mc_auxmcl.do_maths
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_fmod
mc_genmcl.px_fmod:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rax,	[mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	[mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    mov       rcx,	rdi
    lea       rdx,	[L12367]
    mov       r8,	2
    call      mc_auxmcl.do_maths
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_setcc
mc_genmcl.px_setcc:
;?>>
   %define R.p r13
   %define R.cond rdi
   %define R.ax rbx
   %define R.bx rsi
   %define R.cx r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r13,	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rbx,	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rsi,	rax
    movzx     rax,	byte [r13+2]
    lea       r10,	[mc_genmcl.ucondcodes]
    movzx     r10,	byte [r10 + rax-1]
    mov       rdi,	r10
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	11
    jnz       L2155
    lea       rcx,	[L12368]
    lea       rdx,	[L12369]
    call      pc_api.merror
    jmp       L2154
L2155:
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	2
    jle       L2156
    movzx     rax,	byte [mc_decls.pmode]
    lea       r10,	[pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L2158
    movzx     rax,	byte [r13+2]
    lea       r10,	[mc_genmcl.scondcodes]
    movzx     r10,	byte [r10 + rax-1]
    mov       rdi,	r10
L2158:
    mov       rcx,	42
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mc_libmcl.genmc
    mov       rcx,	rbx
    mov       rdx,	1
    call      mc_libmcl.changeopndsize
    mov       r12,	rax
    jmp       L2154
L2156:
    movzx     rax,	byte [mc_decls.pmode]
    dec       rax
    mov       r10,	73
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mc_libmcl.genmc
    mov       rcx,	3
    call      mc_stackmcl.getworkregm
    mov       r12,	rax
    movzx     rax,	byte [r12+10]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_stackmcl.setnewzz
    mov       rax,	[mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	[mc_decls.noperands]
    call      mc_stackmcl.swapopnds
L2154:
    mov       rcx,	58
    mov       rdx,	rdi
    mov       r8,	r12
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    mov       rcx,	r12
    mov       rdx,	4
    call      mc_libmcl.changeopndsize
    mov       rcx,	19
    mov       rdx,	rax
    mov       r8,	r12
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_min
mc_genmcl.px_min:
;?>>
    %define mc_genmcl.px_min.p 16
;?]]
    sub       rsp,	40
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	2
    jle       L2161
    movzx     rax,	byte [mc_decls.pmode]
    lea       r10,	[pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L2163
    mov       rax,	15
    jmp       L2162
L2163:
    mov       rax,	7
L2162:
    mov       rcx,	rax
    call      mc_auxmcl.do_max_int
    jmp       L2160
L2161:
    movzx     rax,	byte [mc_decls.pmode]
    dec       rax
    mov       r10,	112
    add       r10,	rax
    mov       rcx,	r10
    call      mc_auxmcl.do_max_float
L2160:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mc_genmcl.px_max
mc_genmcl.px_max:
;?>>
    %define mc_genmcl.px_max.p 16
;?]]
    sub       rsp,	40
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	2
    jle       L2166
    movzx     rax,	byte [mc_decls.pmode]
    lea       r10,	[pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L2168
    mov       rax,	12
    jmp       L2167
L2168:
    mov       rax,	2
L2167:
    mov       rcx,	rax
    call      mc_auxmcl.do_max_int
    jmp       L2165
L2166:
    movzx     rax,	byte [mc_decls.pmode]
    dec       rax
    mov       r10,	113
    add       r10,	rax
    mov       rcx,	r10
    call      mc_auxmcl.do_max_float
L2165:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mc_genmcl.px_power
mc_genmcl.px_power:
;?>>
   %define R.p rbx
   %define R.d rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	2
    jle       L2171
    mov       rcx,	82
    call      mc_auxmcl.gethostfn
    mov       rdi,	rax
    mov       rax,	[mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	[mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    mov       rcx,	rbx
    mov       rdx,	rdi
    mov       r8,	2
    call      mc_auxmcl.do_host
    jmp       L2170
L2171:
    mov       rax,	[mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	[mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    mov       rcx,	rbx
    lea       rdx,	[L12370]
    mov       r8,	2
    call      mc_auxmcl.do_maths
L2170:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_minto
mc_genmcl.px_minto:
;?>>
    %define mc_genmcl.px_minto.p 16
    %define mc_genmcl.px_minto.$T1 -8
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	2
    jle       L2174
    movzx     rax,	byte [mc_decls.pmode]
    mov       [rbp + mc_genmcl.px_minto.$T1],	rax
    movzx     rax,	byte [mc_decls.pmode]
    lea       r10,	[pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L2176
    mov       rax,	14
    jmp       L2175
L2176:
    mov       rax,	6
L2175:
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_genmcl.px_minto.$T1]
    call      mc_auxmcl.do_maxto_int
    jmp       L2173
L2174:
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	6
    mov       rdx,	rax
    call      mc_auxmcl.do_maxto_real
L2173:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc mc_genmcl.px_maxto
mc_genmcl.px_maxto:
;?>>
    %define mc_genmcl.px_maxto.p 16
    %define mc_genmcl.px_maxto.$T1 -8
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	2
    jle       L2179
    movzx     rax,	byte [mc_decls.pmode]
    mov       [rbp + mc_genmcl.px_maxto.$T1],	rax
    movzx     rax,	byte [mc_decls.pmode]
    lea       r10,	[pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L2181
    mov       rax,	13
    jmp       L2180
L2181:
    mov       rax,	3
L2180:
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_genmcl.px_maxto.$T1]
    call      mc_auxmcl.do_maxto_int
    jmp       L2178
L2179:
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	3
    mov       rdx,	rax
    call      mc_auxmcl.do_maxto_real
L2178:
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc mc_genmcl.px_negto
mc_genmcl.px_negto:
;?>>
    %define mc_genmcl.px_negto.p 32
   %define R.px rdi
   %define R.fx rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       rdi,	rax
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	2
    jle       L2184
    mov       rcx,	50
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L2183
L2184:
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	rax
    call      mc_stackmcl.getworkregm
    mov       rbx,	rax
    mov       rcx,	11
    mov       rdx,	rbx
    mov       r8,	rdi
    call      mc_libmcl.genmc
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mc_auxmcl.do_negreal
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
L2183:
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_absto
mc_genmcl.px_absto:
;?>>
    %define mc_genmcl.px_absto.p 40
   %define R.px rdi
   %define R.ax rbx
   %define R.lx rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       rdi,	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	rax
    call      mc_stackmcl.getworkregm
    mov       rbx,	rax
    mov       rcx,	11
    mov       rdx,	rbx
    mov       r8,	rdi
    call      mc_libmcl.genmc
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	2
    jle       L2187
    xor       ecx,	ecx
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	42
    mov       rdx,	rbx
    mov       r8,	rax
    call      mc_libmcl.genmc
    inc       qword [pc_api.mlabelno]
    mov       rax,	[pc_api.mlabelno]
    mov       rcx,	rax
    call      mc_libmcl.mgenlabel
    mov       r10,	rax
    mov       rsi,	r10
    mov       rcx,	26
    mov       rdx,	13
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    mov       rcx,	50
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	9
    mov       rdx,	rsi
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L2186
L2187:
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mc_auxmcl.do_absreal
L2186:
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_addpxto
mc_genmcl.px_addpxto:
;?>>
   %define R.p r12
   %define R.ax rdi
   %define R.bx rbx
   %define R.z rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       r12,	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       rdi,	rax
    mov       rax,	[mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    call      mc_stackmcl.isimmload
    mov       rsi,	rax
    test      rax,	rax
    jz        L2190
    mov       rax,	[rsi+8]
    movsxd    r10,	dword [r12+16]
    imul      rax,	r10
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	28
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L2189
L2190:
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rbx,	rax
    movsxd    rax,	dword [r12+16]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mc_auxmcl.mulimm
    mov       rcx,	28
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
L2189:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_subpxto
mc_genmcl.px_subpxto:
;?>>
   %define R.p r12
   %define R.ax rdi
   %define R.bx rbx
   %define R.z rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       r12,	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       rdi,	rax
    mov       rax,	[mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    call      mc_stackmcl.isimmload
    mov       rsi,	rax
    test      rax,	rax
    jz        L2193
    mov       rax,	[rsi+8]
    movsxd    r10,	dword [r12+16]
    imul      rax,	r10
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	29
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L2192
L2193:
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rbx,	rax
    movsxd    rax,	dword [r12+16]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mc_auxmcl.mulimm
    mov       rcx,	29
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    mov       eax,	[r12+20]
    test      eax,	eax
    jz        L2195
    lea       rcx,	[L12371]
    lea       rdx,	[L12372]
    call      pc_api.merror
L2195:
L2192:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_divto
mc_genmcl.px_divto:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    mov       rdx,	71
    call      mc_auxmcl.do_binto_float
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_bitnotto
mc_genmcl.px_bitnotto:
;?>>
    %define mc_genmcl.px_bitnotto.p 24
   %define R.px rdi
    push      rdi
;?]]
    sub       rsp,	48
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       rdi,	rax
    mov       rcx,	51
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_notto
mc_genmcl.px_notto:
;?>>
    %define mc_genmcl.px_notto.p 24
   %define R.px rdi
    %define mc_genmcl.px_notto.$T1 -8
    push      rdi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
;---------------
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	3
    call      mc_stackmcl.getopnd_ind
    mov       rdi,	rax
    mov       rcx,	1
    mov       rdx,	3
    call      mc_libmcl.mgenint
    mov       [rbp + mc_genmcl.px_notto.$T1],	rax
    mov       rcx,	rdi
    mov       rdx,	1
    call      mc_libmcl.changeopndsize
    mov       rcx,	40
    mov       rdx,	rax
    mov       r8,	[rbp + mc_genmcl.px_notto.$T1]
    call      mc_libmcl.genmc
;---------------
    add       rsp,	40
    pop       rbp
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_toboolto
mc_genmcl.px_toboolto:
;?>>
    %define mc_genmcl.px_toboolto.p 40
   %define R.ax rdi
   %define R.bx rbx
   %define R.px rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
;---------------
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	3
    call      mc_stackmcl.getopnd_ind
    mov       rsi,	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	rax
    call      mc_stackmcl.getworkregm
    mov       rdi,	rax
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rsi
    call      mc_libmcl.genmc
    mov       rcx,	41
    mov       rdx,	rdi
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rcx,	rdi
    mov       rdx,	1
    call      mc_libmcl.changeopndsize
    mov       r10,	rax
    mov       rbx,	r10
    mov       rcx,	58
    mov       rdx,	5
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    mov       rcx,	rdi
    mov       rdx,	4
    call      mc_libmcl.changeopndsize
    mov       rcx,	19
    mov       rdx,	rax
    mov       r8,	rbx
    call      mc_libmcl.genmc
    mov       rcx,	11
    mov       rdx,	rsi
    mov       r8,	rdi
    call      mc_libmcl.genmc
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_sign
mc_genmcl.px_sign:
;?>>
    %define mc_genmcl.px_sign.p 64
   %define R.ax rdi
   %define R.bx rbx
   %define R.lx1 rsi
   %define R.lx2 r12
   %define R.lx3 r13
   %define R.gtop r14b
    %define mc_genmcl.px_sign.ltop -8
    %define mc_genmcl.px_sign.$T1 -16
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    mov       rcx,	10
    call      mc_stackmcl.getworkregm
    mov       rbx,	rax
    mov       rcx,	rbx
    call      mc_libmcl.clearreg
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	2
    jg        L2202
    mov       r14b,	7
    mov       al,	2
    mov       [rbp + mc_genmcl.px_sign.ltop],	al
    movzx     rax,	byte [mc_decls.pmode]
    movq      XMM0,	[L12373]
    mov       rdx,	rax
    call      mc_libmcl.mgenrealmem
    movzx     r10,	byte [mc_decls.pmode]
    dec       r10
    mov       r11,	73
    add       r11,	r10
    mov       rcx,	r11
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L2201
L2202:
    mov       r14b,	15
    mov       al,	12
    mov       [rbp + mc_genmcl.px_sign.ltop],	al
    movzx     rax,	byte [mc_decls.pmode]
    xor       ecx,	ecx
    mov       rdx,	rax
    call      mc_libmcl.mgenint
    mov       rcx,	42
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
L2201:
    inc       qword [pc_api.mlabelno]
    mov       rax,	[pc_api.mlabelno]
    mov       rcx,	rax
    call      mc_libmcl.mgenlabel
    mov       r10,	rax
    mov       rsi,	r10
    movzx     r10,	r14b
    mov       rcx,	26
    mov       rdx,	r10
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    inc       qword [pc_api.mlabelno]
    mov       rax,	[pc_api.mlabelno]
    mov       rcx,	rax
    call      mc_libmcl.mgenlabel
    mov       r10,	rax
    mov       r12,	r10
    movzx     r10,	byte [rbp + mc_genmcl.px_sign.ltop]
    mov       rcx,	26
    mov       rdx,	r10
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    inc       qword [pc_api.mlabelno]
    mov       rax,	[pc_api.mlabelno]
    mov       rcx,	rax
    call      mc_libmcl.mgenlabel
    mov       r10,	rax
    mov       r13,	r10
    mov       rcx,	25
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	9
    mov       rdx,	rsi
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	1
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       [rbp + mc_genmcl.px_sign.$T1],	rax
    mov       rcx,	rbx
    mov       rdx,	1
    call      mc_libmcl.changeopndsize
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	[rbp + mc_genmcl.px_sign.$T1]
    call      mc_libmcl.genmc
    mov       rcx,	25
    mov       rdx,	r13
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	9
    mov       rdx,	r12
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	53
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	9
    mov       rdx,	r13
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    movzx     rax,	byte [rbx+10]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_stackmcl.setnewzz
;---------------
    add       rsp,	48
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_loadbf
mc_genmcl.px_loadbf:
;?>>
   %define R.p rsi
   %define R.y rdi
   %define R.z rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    mov       rax,	[mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    call      mc_stackmcl.isimmload
    mov       rdi,	rax
    mov       rcx,	[mc_decls.noperands]
    call      mc_stackmcl.isimmload
    mov       rbx,	rax
    test      rdi,	rdi
    jz        L2205
    test      rbx,	rbx
    jz        L2205
    mov       rax,	[rbx+8]
    mov       r10,	[rdi+8]
    mov       rcx,	rsi
    mov       rdx,	r10
    mov       r8,	rax
    call      mc_auxmcl.do_loadbf_const
    jmp       L2204
L2205:
    mov       rcx,	rsi
    call      mc_auxmcl.do_loadbf_var
L2204:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_storebit
mc_genmcl.px_storebit:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      mc_auxmcl.do_storebit
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_storebf
mc_genmcl.px_storebf:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      mc_auxmcl.do_storebf
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_loadall
mc_genmcl.px_loadall:
;?>>
    %define mc_genmcl.px_loadall.p 16
;?]]
    sub       rsp,	40
;---------------
    call      mc_stackmcl.checkallloaded
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mc_genmcl.px_setjmp
mc_genmcl.px_setjmp:
;?>>
   %define R.p r12
   %define R.ax rdi
   %define R.bx rbx
   %define R.lab rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       r12,	rcx
;---------------
    call      mc_libmcl.mcreatefwdlabel
    mov       rsi,	rax
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	6
    call      mc_stackmcl.getopnd_ind
    mov       rbx,	rax
    mov       rcx,	6
    xor       edx,	edx
    call      mc_stackmcl.pushpcl_reg
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rdi,	rax
    mov       rcx,	rsi
    call      mc_libmcl.mgenlabel
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	11
    mov       rdx,	rbx
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rcx,	rbx
    mov       rdx,	8
    xor       r8d,	r8d
    call      mc_libmcl.applyoffset
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	[mc_decls.dstackopnd]
    call      mc_libmcl.genmc
    mov       rcx,	rbx
    mov       rdx,	16
    xor       r8d,	r8d
    call      mc_libmcl.applyoffset
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	[mc_decls.dframeopnd]
    call      mc_libmcl.genmc
    mov       rax,	[mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	[mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    call      mc_stackmcl.poppcl
    mov       rcx,	rdi
    call      mc_libmcl.clearreg
    mov       rcx,	r12
    call      mc_stackmcl.freeworkregs
    mov       rcx,	1
    call      mc_stackmcl.movetoreg
    mov       rcx,	rsi
    call      mc_libmcl.mdefinefwdlabel
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_longjmp
mc_genmcl.px_longjmp:
;?>>
    %define mc_genmcl.px_longjmp.p 40
   %define R.ax rdi
   %define R.bx rbx
   %define R.cx rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
;---------------
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rbx,	rax
    mov       rax,	[mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	6
    call      mc_stackmcl.getopnd_ind
    mov       rdi,	rax
    mov       rcx,	rdi
    mov       rdx,	8
    xor       r8d,	r8d
    call      mc_libmcl.applyoffset
    mov       rcx,	11
    mov       rdx,	[mc_decls.dstackopnd]
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	rdi
    mov       rdx,	16
    xor       r8d,	r8d
    call      mc_libmcl.applyoffset
    mov       rcx,	11
    mov       rdx,	[mc_decls.dframeopnd]
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	6
    xor       edx,	edx
    call      mc_stackmcl.pushpcl_reg
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rsi,	rax
    mov       rcx,	11
    mov       rdx,	rsi
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rax,	[mc_decls.noperands]
    sub       rax,	2
    mov       rcx,	rax
    mov       rdx,	[mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    call      mc_stackmcl.poppcl
    mov       rcx,	1
    call      mc_stackmcl.swapopndregs
    mov       rcx,	25
    mov       rdx,	rsi
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rax,	[mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	[mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genmcl.px_initdswx
mc_genmcl.px_initdswx:
;?>>
    %define mc_genmcl.px_initdswx.p 16
;?]]
;---------------
;---
;---------------
    ret       
;End 
;Proc mc_auxmcl.allocregvars
mc_auxmcl.allocregvars:
;?>>
   %define R.skipparams rcx
   %define R.isleaf rdx
    %define mc_auxmcl.allocregvars.params -32
    %define mc_auxmcl.allocregvars.xparams -64
    %define mc_auxmcl.allocregvars.leafparams -96
    %define mc_auxmcl.allocregvars.xleafparams -128
    %define mc_auxmcl.allocregvars.leafparamno -136
    %define mc_auxmcl.allocregvars.xleafparamno -144
    %define mc_auxmcl.allocregvars.locals -400
    %define mc_auxmcl.allocregvars.xlocals -656
   %define R.nparams rdi
   %define R.nxparams rbx
   %define R.nleafparams rsi
   %define R.nxleafparams r12
   %define R.nlocals r13
   %define R.nxlocals r14
   %define R.n r15
    %define mc_auxmcl.allocregvars.reg -664
    %define mc_auxmcl.allocregvars.nl -672
    %define mc_auxmcl.allocregvars.np -680
    %define mc_auxmcl.allocregvars.nlx -688
    %define mc_auxmcl.allocregvars.npx -696
    %define mc_auxmcl.allocregvars.d -704
    %define mc_auxmcl.allocregvars.i -712
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	712
;---------------
    xor       rdi,	rdi
    xor       eax,	eax
    mov       rbx,	rax
    xor       rsi,	rsi
    xor       eax,	eax
    mov       r12,	rax
    xor       r13,	r13
    xor       eax,	eax
    mov       r14,	rax
    mov       rax,	[mc_decls.maxregvars]
    add       rax,	[mc_decls.maxxregvars]
    test      rax,	rax
    jz        L2212
L2214:
    test      rcx,	rcx
    jnz       L2216
    mov       rax,	[pc_decls.currfunc]
    mov       rax,	[rax+16]
    mov       [rbp + mc_auxmcl.allocregvars.d],	rax
    xor       r15,	r15
    jmp       L2220
L2217:
    inc       r15
    mov       rax,	[rbp + mc_auxmcl.allocregvars.d]
    mov       al,	[rax+92]
    test      al,	al
    jz        L2222
    mov       rax,	[rbp + mc_auxmcl.allocregvars.d]
    mov       al,	[rax+91]
    test      al,	al
    jnz       L2222
    mov       rax,	[rbp + mc_auxmcl.allocregvars.d]
    mov       al,	[rax+88]
    test      al,	al
    jnz       L2222
    cmp       r15,	4
    jg        L2222
    test      rdx,	rdx
    jnz       L2224
    mov       rax,	[rbp + mc_auxmcl.allocregvars.d]
    movzx     rax,	byte [rax+82]
    lea       r10,	[pc_tables.pint]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L2226
    cmp       rdi,	4
    jge       L2228
    inc       rdi
    mov       rax,	rdi
    mov       r10,	[rbp + mc_auxmcl.allocregvars.d]
    mov       [rbp + rax*8 + mc_auxmcl.allocregvars.params-8],	r10
L2228:
    jmp       L2225
L2226:
    mov       rax,	[rbp + mc_auxmcl.allocregvars.d]
    movzx     rax,	byte [rax+82]
    lea       r10,	[pc_tables.pfloat]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L2229
    cmp       rbx,	4
    jge       L2231
    inc       rbx
    mov       rax,	rbx
    mov       r10,	[rbp + mc_auxmcl.allocregvars.d]
    mov       [rbp + rax*8 + mc_auxmcl.allocregvars.xparams-8],	r10
L2231:
L2229:
L2225:
    jmp       L2223
L2224:
    mov       rax,	[rbp + mc_auxmcl.allocregvars.d]
    movzx     rax,	byte [rax+82]
    lea       r10,	[pc_tables.pint]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L2233
    cmp       rsi,	4
    jge       L2235
    inc       rsi
    mov       rax,	rsi
    mov       r10,	[rbp + mc_auxmcl.allocregvars.d]
    mov       [rbp + rax*8 + mc_auxmcl.allocregvars.leafparams-8],	r10
    mov       [rbp + rsi + mc_auxmcl.allocregvars.leafparamno-1],	r15b
L2235:
    jmp       L2232
L2233:
    mov       rax,	[rbp + mc_auxmcl.allocregvars.d]
    movzx     rax,	byte [rax+82]
    lea       r10,	[pc_tables.pfloat]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L2236
    cmp       r12,	4
    jge       L2238
    inc       r12
    mov       rax,	r12
    mov       r10,	[rbp + mc_auxmcl.allocregvars.d]
    mov       [rbp + rax*8 + mc_auxmcl.allocregvars.xleafparams-8],	r10
    mov       [rbp + r12 + mc_auxmcl.allocregvars.xleafparamno-1],	r15b
L2238:
L2236:
L2232:
L2223:
L2222:
    mov       rax,	[rbp + mc_auxmcl.allocregvars.d]
    mov       rax,	[rax+16]
    mov       [rbp + mc_auxmcl.allocregvars.d],	rax
L2220:
    mov       rax,	[rbp + mc_auxmcl.allocregvars.d]
    test      rax,	rax
    jnz       L2217
L2216:
    mov       rax,	[pc_decls.currfunc]
    mov       rax,	[rax+24]
    mov       [rbp + mc_auxmcl.allocregvars.d],	rax
    jmp       L2242
L2239:
    mov       rax,	[rbp + mc_auxmcl.allocregvars.d]
    mov       al,	[rax+92]
    test      al,	al
    jz        L2244
    mov       rax,	[rbp + mc_auxmcl.allocregvars.d]
    mov       al,	[rax+91]
    test      al,	al
    jnz       L2244
    mov       rax,	[rbp + mc_auxmcl.allocregvars.d]
    mov       al,	[rax+88]
    test      al,	al
    jnz       L2244
    mov       rax,	[rbp + mc_auxmcl.allocregvars.d]
    movzx     rax,	byte [rax+82]
    lea       r10,	[pc_tables.pint]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L2246
    cmp       r13,	32
    jge       L2248
    inc       r13
    mov       rax,	r13
    mov       r10,	[rbp + mc_auxmcl.allocregvars.d]
    mov       [rbp + rax*8 + mc_auxmcl.allocregvars.locals-8],	r10
L2248:
    jmp       L2245
L2246:
    mov       rax,	[rbp + mc_auxmcl.allocregvars.d]
    movzx     rax,	byte [rax+82]
    lea       r10,	[pc_tables.pfloat]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L2249
    cmp       r14,	32
    jge       L2249
    inc       r14
    mov       rax,	r14
    mov       r10,	[rbp + mc_auxmcl.allocregvars.d]
    mov       [rbp + rax*8 + mc_auxmcl.allocregvars.xlocals-8],	r10
L2249:
L2245:
L2244:
    mov       rax,	[rbp + mc_auxmcl.allocregvars.d]
    mov       rax,	[rax+24]
    mov       [rbp + mc_auxmcl.allocregvars.d],	rax
L2242:
    mov       rax,	[rbp + mc_auxmcl.allocregvars.d]
    test      rax,	rax
    jnz       L2239
    test      r13,	r13
    jnz       L2251
    mov       rax,	[mc_decls.maxregvars]
    mov       r10,	rdi
    cmp       rax,	r10
    cmovg     rax,	r10
    mov       [rbp + mc_auxmcl.allocregvars.np],	rax
    xor       eax,	eax
    mov       [rbp + mc_auxmcl.allocregvars.nl],	rax
    jmp       L2250
L2251:
    test      rdi,	rdi
    jnz       L2252
    mov       rax,	[mc_decls.maxregvars]
    mov       r10,	r13
    cmp       rax,	r10
    cmovg     rax,	r10
    mov       [rbp + mc_auxmcl.allocregvars.nl],	rax
    xor       eax,	eax
    mov       [rbp + mc_auxmcl.allocregvars.np],	rax
    jmp       L2250
L2252:
    mov       [rbp + mc_auxmcl.allocregvars.nl],	r13
    mov       [rbp + mc_auxmcl.allocregvars.np],	rdi
    mov       rax,	[rbp + mc_auxmcl.allocregvars.np]
    add       rax,	[rbp + mc_auxmcl.allocregvars.nl]
    sub       rax,	[mc_decls.maxregvars]
    mov       r15,	rax
    cmp       r15,	0
    jle       L2254
    dec       qword [rbp + mc_auxmcl.allocregvars.np]
    dec       r15
    cmp       r15,	0
    jle       L2256
    mov       rax,	[rbp + mc_auxmcl.allocregvars.np]
    cmp       rax,	0
    jle       L2256
    dec       qword [rbp + mc_auxmcl.allocregvars.np]
    dec       r15
L2256:
    cmp       r15,	0
    jle       L2258
    mov       rax,	r15
    sub       [rbp + mc_auxmcl.allocregvars.nl],	rax
L2258:
L2254:
L2250:
    mov       rax,	4
    mov       [rbp + mc_auxmcl.allocregvars.reg],	rax
    mov       rax,	1
    mov       [rbp + mc_auxmcl.allocregvars.i],	rax
    mov       rax,	[rbp + mc_auxmcl.allocregvars.nl]
    cmp       rax,	1
    jl        L2261
L2259:
    mov       rax,	[rbp + mc_auxmcl.allocregvars.i]
    mov       rax,	[rbp + rax*8 + mc_auxmcl.allocregvars.locals-8]
    mov       [rbp + mc_auxmcl.allocregvars.d],	rax
    mov       al,	[rbp + mc_auxmcl.allocregvars.reg]
    mov       r10,	[rbp + mc_auxmcl.allocregvars.d]
    mov       [r10+90],	al
    mov       al,	1
    lea       r10,	[mc_decls.isregvar]
    mov       r11,	[rbp + mc_auxmcl.allocregvars.reg]
    mov       [r10 + r11-1],	al
    inc       qword [rbp + mc_auxmcl.allocregvars.reg]
    mov       rax,	[rbp + mc_auxmcl.allocregvars.i]
    inc       rax
    mov       [rbp + mc_auxmcl.allocregvars.i],	rax
    cmp       rax,	[rbp + mc_auxmcl.allocregvars.nl]
    jle       L2259
L2261:
    mov       rax,	1
    mov       [rbp + mc_auxmcl.allocregvars.i],	rax
    mov       rax,	[rbp + mc_auxmcl.allocregvars.np]
    cmp       rax,	1
    jl        L2264
L2262:
    mov       rax,	[rbp + mc_auxmcl.allocregvars.i]
    mov       rax,	[rbp + rax*8 + mc_auxmcl.allocregvars.params-8]
    mov       [rbp + mc_auxmcl.allocregvars.d],	rax
    mov       al,	[rbp + mc_auxmcl.allocregvars.reg]
    mov       r10,	[rbp + mc_auxmcl.allocregvars.d]
    mov       [r10+90],	al
    mov       al,	1
    lea       r10,	[mc_decls.isregvar]
    mov       r11,	[rbp + mc_auxmcl.allocregvars.reg]
    mov       [r10 + r11-1],	al
    inc       qword [rbp + mc_auxmcl.allocregvars.reg]
    mov       rax,	[rbp + mc_auxmcl.allocregvars.i]
    inc       rax
    mov       [rbp + mc_auxmcl.allocregvars.i],	rax
    cmp       rax,	[rbp + mc_auxmcl.allocregvars.np]
    jle       L2262
L2264:
    mov       rax,	1
    mov       [rbp + mc_auxmcl.allocregvars.i],	rax
    cmp       rsi,	1
    jl        L2267
L2265:
    mov       rax,	[rbp + mc_auxmcl.allocregvars.i]
    mov       rax,	[rbp + rax*8 + mc_auxmcl.allocregvars.leafparams-8]
    mov       [rbp + mc_auxmcl.allocregvars.d],	rax
    mov       rax,	[rbp + mc_auxmcl.allocregvars.i]
    movzx     rax,	byte [rbp + rax + mc_auxmcl.allocregvars.leafparamno-1]
    add       rax,	11
    dec       rax
    mov       [rbp + mc_auxmcl.allocregvars.reg],	rax
    mov       rax,	[rbp + mc_auxmcl.allocregvars.reg]
    cmp       rax,	11
    jnz       L2269
    mov       al,	1
    mov       [pc_decls.r10used],	al
L2269:
    mov       rax,	[rbp + mc_auxmcl.allocregvars.reg]
    cmp       rax,	12
    jnz       L2271
    mov       al,	1
    mov       [pc_decls.r11used],	al
L2271:
    mov       al,	[rbp + mc_auxmcl.allocregvars.reg]
    mov       r10,	[rbp + mc_auxmcl.allocregvars.d]
    mov       [r10+90],	al
    mov       al,	1
    lea       r10,	[mc_decls.isregvar]
    mov       r11,	[rbp + mc_auxmcl.allocregvars.reg]
    mov       [r10 + r11-1],	al
    mov       rax,	[rbp + mc_auxmcl.allocregvars.i]
    inc       rax
    mov       [rbp + mc_auxmcl.allocregvars.i],	rax
    cmp       rax,	rsi
    jle       L2265
L2267:
    test      r14,	r14
    jnz       L2273
    mov       rax,	[mc_decls.maxxregvars]
    mov       r10,	rbx
    cmp       rax,	r10
    cmovg     rax,	r10
    mov       [rbp + mc_auxmcl.allocregvars.npx],	rax
    xor       eax,	eax
    mov       [rbp + mc_auxmcl.allocregvars.nlx],	rax
    jmp       L2272
L2273:
    test      rbx,	rbx
    jnz       L2274
    mov       rax,	[mc_decls.maxxregvars]
    mov       r10,	r14
    cmp       rax,	r10
    cmovg     rax,	r10
    mov       [rbp + mc_auxmcl.allocregvars.nlx],	rax
    xor       eax,	eax
    mov       [rbp + mc_auxmcl.allocregvars.npx],	rax
    jmp       L2272
L2274:
    mov       [rbp + mc_auxmcl.allocregvars.nlx],	r14
    mov       [rbp + mc_auxmcl.allocregvars.npx],	rbx
    mov       rax,	[rbp + mc_auxmcl.allocregvars.npx]
    add       rax,	[rbp + mc_auxmcl.allocregvars.nlx]
    sub       rax,	[mc_decls.maxregvars]
    mov       r15,	rax
    cmp       r15,	0
    jle       L2276
    dec       qword [rbp + mc_auxmcl.allocregvars.npx]
    dec       r15
    cmp       r15,	0
    jle       L2278
    mov       rax,	[rbp + mc_auxmcl.allocregvars.npx]
    cmp       rax,	0
    jle       L2278
    dec       qword [rbp + mc_auxmcl.allocregvars.npx]
    dec       r15
L2278:
    cmp       r15,	0
    jle       L2280
    mov       rax,	r15
    sub       [rbp + mc_auxmcl.allocregvars.nlx],	rax
L2280:
L2276:
L2272:
    mov       rax,	16
    mov       [rbp + mc_auxmcl.allocregvars.reg],	rax
    mov       rax,	1
    mov       [rbp + mc_auxmcl.allocregvars.i],	rax
    mov       rax,	[rbp + mc_auxmcl.allocregvars.nlx]
    cmp       rax,	1
    jl        L2283
L2281:
    mov       rax,	[rbp + mc_auxmcl.allocregvars.i]
    mov       rax,	[rbp + rax*8 + mc_auxmcl.allocregvars.xlocals-8]
    mov       [rbp + mc_auxmcl.allocregvars.d],	rax
    mov       al,	[rbp + mc_auxmcl.allocregvars.reg]
    mov       r10,	[rbp + mc_auxmcl.allocregvars.d]
    mov       [r10+90],	al
    mov       al,	1
    lea       r10,	[mc_decls.isxregvar]
    mov       r11,	[rbp + mc_auxmcl.allocregvars.reg]
    mov       [r10 + r11-1],	al
    dec       qword [rbp + mc_auxmcl.allocregvars.reg]
    mov       rax,	[rbp + mc_auxmcl.allocregvars.i]
    inc       rax
    mov       [rbp + mc_auxmcl.allocregvars.i],	rax
    cmp       rax,	[rbp + mc_auxmcl.allocregvars.nlx]
    jle       L2281
L2283:
    mov       rax,	1
    mov       [rbp + mc_auxmcl.allocregvars.i],	rax
    mov       rax,	[rbp + mc_auxmcl.allocregvars.npx]
    cmp       rax,	1
    jl        L2286
L2284:
    mov       rax,	[rbp + mc_auxmcl.allocregvars.i]
    mov       rax,	[rbp + rax*8 + mc_auxmcl.allocregvars.xparams-8]
    mov       [rbp + mc_auxmcl.allocregvars.d],	rax
    mov       al,	[rbp + mc_auxmcl.allocregvars.reg]
    mov       r10,	[rbp + mc_auxmcl.allocregvars.d]
    mov       [r10+90],	al
    mov       al,	1
    lea       r10,	[mc_decls.isxregvar]
    mov       r11,	[rbp + mc_auxmcl.allocregvars.reg]
    mov       [r10 + r11-1],	al
    dec       qword [rbp + mc_auxmcl.allocregvars.reg]
    mov       rax,	[rbp + mc_auxmcl.allocregvars.i]
    inc       rax
    mov       [rbp + mc_auxmcl.allocregvars.i],	rax
    cmp       rax,	[rbp + mc_auxmcl.allocregvars.npx]
    jle       L2284
L2286:
    mov       rax,	1
    mov       [rbp + mc_auxmcl.allocregvars.i],	rax
    cmp       r12,	1
    jl        L2289
L2287:
    mov       rax,	[rbp + mc_auxmcl.allocregvars.i]
    mov       rax,	[rbp + rax*8 + mc_auxmcl.allocregvars.xleafparams-8]
    mov       [rbp + mc_auxmcl.allocregvars.d],	rax
    mov       rax,	[rbp + mc_auxmcl.allocregvars.i]
    movzx     rax,	byte [rbp + rax + mc_auxmcl.allocregvars.xleafparamno-1]
    inc       rax
    dec       rax
    mov       [rbp + mc_auxmcl.allocregvars.reg],	rax
    mov       al,	[rbp + mc_auxmcl.allocregvars.reg]
    mov       r10,	[rbp + mc_auxmcl.allocregvars.d]
    mov       [r10+90],	al
    mov       al,	1
    lea       r10,	[mc_decls.isxregvar]
    mov       r11,	[rbp + mc_auxmcl.allocregvars.reg]
    mov       [r10 + r11-1],	al
    mov       rax,	[rbp + mc_auxmcl.allocregvars.i]
    inc       rax
    mov       [rbp + mc_auxmcl.allocregvars.i],	rax
    cmp       rax,	r12
    jle       L2287
L2289:
L2212:
;---------------
    add       rsp,	712
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.initproc
mc_auxmcl.initproc:
;?>>
   %define R.d r15
   %define R.e rdi
   %define R.n rbx
   %define R.r rsi
   %define R.npregs r12
   %define R.av_1 r13
   %define R.av_2 r14
    %define mc_auxmcl.initproc.$T1 -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       r15,	rcx
;---------------
    lea       rax,	[mc_decls.regset]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    lea       rax,	[mc_decls.xregset]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    lea       rax,	[mc_decls.workregs]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    lea       rax,	[mc_decls.workxregs]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    lea       rax,	[mc_decls.isregvar]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    lea       rax,	[mc_decls.isxregvar]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    mov       rax,	3
    mov       [mc_decls.nworkregs],	rax
    mov       al,	1
    lea       r10,	[mc_decls.workregs]
    mov       [r10],	al
    mov       al,	1
    lea       r10,	[mc_decls.workregs]
    mov       [r10+1],	al
    mov       al,	1
    lea       r10,	[mc_decls.workregs]
    mov       [r10+2],	al
    mov       rax,	2
    mov       [mc_decls.nworkxregs],	rax
    mov       al,	1
    lea       r10,	[mc_decls.workxregs]
    mov       [r10+4],	al
    mov       al,	1
    lea       r10,	[mc_decls.workxregs]
    mov       [r10+5],	al
    xor       eax,	eax
    mov       [mc_decls.maxxregvars],	rax
    mov       [mc_decls.maxregvars],	rax
    xor       r12,	r12
    mov       rax,	[pc_decls.currfunc]
    mov       rax,	[rax+48]
    mov       [pc_decls.pinfo],	rax
    mov       rax,	[pc_decls.pinfo]
    test      rax,	rax
    jnz       L2292
    mov       rax,	10
    mov       [mc_decls.nworkregs],	rax
    mov       rax,	12
    mov       [mc_decls.nworkxregs],	rax
    mov       rsi,	4
L2293:
    mov       al,	1
    lea       r10,	[mc_decls.workregs]
    mov       r11,	rsi
    mov       [r10 + r11-1],	al
    inc       rsi
    cmp       rsi,	10
    jle       L2293
    mov       rsi,	7
L2296:
    mov       al,	1
    lea       r10,	[mc_decls.workxregs]
    mov       r11,	rsi
    mov       [r10 + r11-1],	al
    inc       rsi
    cmp       rsi,	16
    jle       L2296
    jmp       L2291
L2292:
    mov       rax,	[pc_decls.currfunc]
    movzx     rax,	byte [rax+112]
    mov       r10,	[pc_decls.pinfo]
    movzx     r10,	byte [r10+4]
    cmp       rax,	r10
    cmovl     rax,	r10
    mov       r10,	4
    cmp       r10,	rax
    cmovg     r10,	rax
    mov       r12,	r10
    mov       rax,	4
    mov       [mc_decls.nworkregs],	rax
    mov       rax,	[pc_decls.pinfo]
    mov       al,	[rax+7]
    test      al,	al
    jz        L2300
    inc       qword [mc_decls.nworkregs]
L2300:
    mov       rax,	5
    mov       [mc_decls.nworkxregs],	rax
    mov       rax,	[mc_decls.nworkregs]
    sub       rax,	3
    mov       rbx,	rax
    cmp       r12,	3
    jg        L2302
    test      rbx,	rbx
    jz        L2302
    mov       al,	1
    lea       r10,	[mc_decls.workregs]
    mov       [r10+13],	al
    dec       rbx
    cmp       r12,	2
    jg        L2304
    test      rbx,	rbx
    jz        L2304
    mov       al,	1
    lea       r10,	[mc_decls.workregs]
    mov       [r10+12],	al
    dec       rbx
L2304:
L2302:
    mov       rsi,	10
    mov       r13,	rbx
    cmp       r13,	0
    jle       L2307
L2305:
    mov       rax,	rsi
    dec       rsi
    mov       r10b,	1
    lea       r11,	[mc_decls.workregs]
    mov       [r11 + rax-1],	r10b
    dec       r13
    jnz       L2305
L2307:
    mov       rsi,	7
    mov       rax,	[mc_decls.nworkxregs]
    sub       rax,	2
    mov       r14,	rax
    cmp       r14,	0
    jle       L2310
L2308:
    mov       rax,	rsi
    inc       rsi
    mov       r10b,	1
    lea       r11,	[mc_decls.workxregs]
    mov       [r11 + rax-1],	r10b
    dec       r14
    jnz       L2308
L2310:
L2291:
    mov       rsi,	4
L2311:
    lea       rax,	[mc_decls.workregs]
    mov       r10,	rsi
    mov       al,	[rax + r10-1]
    test      al,	al
    jnz       L2315
    inc       qword [mc_decls.maxregvars]
L2315:
    inc       rsi
    cmp       rsi,	10
    jle       L2311
    mov       rsi,	7
L2316:
    lea       rax,	[mc_decls.workxregs]
    mov       r10,	rsi
    mov       al,	[rax + r10-1]
    test      al,	al
    jnz       L2320
    inc       qword [mc_decls.maxxregvars]
L2320:
    inc       rsi
    cmp       rsi,	16
    jle       L2316
    lea       rax,	[mc_decls.usedregs]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    lea       rax,	[mc_decls.usedxregs]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    lea       rax,	[mc_decls.pcltempflags]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    mov       [rax+16],	r10d
    xor       eax,	eax
    mov       [pc_decls.r11used],	al
    mov       [pc_decls.r10used],	al
    xor       eax,	eax
    mov       [mc_decls.mstackdepth],	rax
    xor       eax,	eax
    mov       [mc_decls.noperands],	rax
    xor       eax,	eax
    mov       [mc_genmcl.framebytes],	rax
    mov       [mc_genmcl.paramoffset],	rax
    mov       [mc_genmcl.frameoffset],	rax
    xor       eax,	eax
    mov       [pc_decls.localshadow],	al
    xor       eax,	eax
    mov       [mc_decls.nblocktemps],	rax
    movzx     rax,	byte [r15+82]
    cmp       rax,	11
    jnz       L2322
    lea       rcx,	[L12374]
    mov       rdx,	8
    call      pc_api.pc_makesymbol
    mov       rdi,	rax
    mov       al,	[r15+82]
    mov       [rdi+82],	al
    mov       al,	1
    mov       [rdi+92],	al
    mov       al,	5
    mov       [rdi+72],	al
    mov       rax,	[pc_decls.currfunc]
    mov       rax,	[rax+16]
    mov       [rdi+16],	rax
    mov       rax,	[pc_decls.currfunc]
    mov       [rdi+32],	rax
    mov       rax,	rdi
    mov       r10,	[pc_decls.currfunc]
    mov       [r10+16],	rax
    mov       [pc_decls.blockretname],	rdi
L2322:
    mov       al,	[pc_decls.fregoptim]
    test      al,	al
    jz        L2325
    mov       rax,	[pc_decls.currfunc]
    mov       rax,	[rax+48]
    test      rax,	rax
    jnz       L2324
L2325:
    jmp       L2290
L2324:
    mov       rax,	[pc_decls.currfunc]
    mov       rax,	[rax+48]
    mov       al,	[rax+5]
    test      al,	al
    jnz       L2290
L2327:
    mov       rax,	[pc_decls.currfunc]
    mov       rax,	[rax+48]
    movzx     rax,	byte [rax+3]
    mov       [rbp + mc_auxmcl.initproc.$T1],	rax
    mov       rax,	[pc_decls.currfunc]
    mov       al,	[rax+110]
    test      al,	al
    jnz       L2328
    mov       rax,	[pc_decls.currfunc]
    mov       al,	[rax+113]
    test      al,	al
    jz        L2329
L2328:
    mov       rax,	1
    jmp       L2330
L2329:
    xor       eax,	eax
L2330:
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_auxmcl.initproc.$T1]
    call      mc_auxmcl.allocregvars
L2290:
;---------------
    add       rsp,	40
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.do_procentry
mc_auxmcl.do_procentry:
;?>>
    %define mc_auxmcl.do_procentry.p 72
   %define R.retmode rdi
   %define R.ntemps rbx
   %define R.hasequiv rsi
   %define R.size r12
   %define R.ax r13
   %define R.d r14
   %define R.rr r15
    %define mc_auxmcl.do_procentry.ff -8
    %define mc_auxmcl.do_procentry.r -16
    %define mc_auxmcl.do_procentry.i -24
    %define mc_auxmcl.do_procentry.$T1 -32
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	72
;---------------
    mov       rcx,	[mc_decls.mclprocentry]
    call      mc_auxmcl.setmclentry
    xor       eax,	eax
    mov       [pc_decls.bxspill],	rax
    mov       [pc_decls.bspill],	rax
    mov       rax,	[pc_decls.currfunc]
    mov       rax,	[rax+48]
    test      rax,	rax
    jz        L2334
    mov       rax,	[pc_decls.currfunc]
    mov       rax,	[rax+48]
    mov       al,	[rax+5]
    test      al,	al
    jnz       L2333
L2334:
    mov       rax,	4
    mov       [rbp + mc_auxmcl.do_procentry.r],	rax
L2335:
    lea       rax,	[mc_decls.usedregs]
    mov       r10,	[rbp + mc_auxmcl.do_procentry.r]
    mov       al,	[rax + r10-1]
    test      al,	al
    jnz       L2340
    lea       rax,	[mc_decls.isregvar]
    mov       r10,	[rbp + mc_auxmcl.do_procentry.r]
    mov       al,	[rax + r10-1]
    test      al,	al
    jz        L2339
L2340:
    inc       qword [pc_decls.bspill]
L2339:
    mov       rax,	[rbp + mc_auxmcl.do_procentry.r]
    inc       rax
    mov       [rbp + mc_auxmcl.do_procentry.r],	rax
    cmp       rax,	10
    jle       L2335
    mov       rax,	7
    mov       [rbp + mc_auxmcl.do_procentry.r],	rax
L2341:
    lea       rax,	[mc_decls.usedxregs]
    mov       r10,	[rbp + mc_auxmcl.do_procentry.r]
    mov       al,	[rax + r10-1]
    test      al,	al
    jnz       L2346
    lea       rax,	[mc_decls.isxregvar]
    mov       r10,	[rbp + mc_auxmcl.do_procentry.r]
    mov       al,	[rax + r10-1]
    test      al,	al
    jz        L2345
L2346:
    inc       qword [pc_decls.bxspill]
L2345:
    mov       rax,	[rbp + mc_auxmcl.do_procentry.r]
    inc       rax
    mov       [rbp + mc_auxmcl.do_procentry.r],	rax
    cmp       rax,	16
    jle       L2341
L2333:
    mov       rax,	[pc_decls.currfunc]
    mov       r14,	[rax+16]
    jmp       L2350
L2347:
    mov       al,	[r14+91]
    test      al,	al
    jz        L2352
    lea       rcx,	[L12375]
    lea       rdx,	[L12376]
    call      pc_api.merror
L2352:
    mov       al,	[r14+90]
    test      al,	al
    jnz       L2354
    mov       rax,	[mc_genmcl.paramoffset]
    add       rax,	16
    mov       r10,	[pc_decls.bspill]
    add       r10,	[pc_decls.bxspill]
    shl       r10,	3
    add       rax,	r10
    mov       [r14+76],	eax
    movsxd    rax,	dword [r14+76]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       [rbp + mc_auxmcl.do_procentry.$T1],	rax
    mov       rcx,	r14
    call      mc_writenasm.getdispname
    mov       rcx,	rax
    call      mc_libmcl.mgenname
    mov       rcx,	5
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.do_procentry.$T1]
    call      mc_libmcl.genmc
    jmp       L2353
L2354:
    movzx     rax,	byte [r14+90]
    mov       r15,	rax
    lea       rax,	[mc_decls.usedregs]
    movzx     rax,	byte [rax+14]
    mov       [rbp + mc_auxmcl.do_procentry.ff],	rax
    xor       eax,	eax
    mov       [r14+90],	al
    movzx     rax,	byte [r14+82]
    mov       rcx,	r15
    mov       rdx,	rax
    call      mc_libmcl.mgenreg
    mov       [rbp + mc_auxmcl.do_procentry.$T1],	rax
    mov       rcx,	r14
    mov       rdx,	6
    call      mc_libmcl.mgenmem
    mov       rcx,	6
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.do_procentry.$T1]
    call      mc_libmcl.genmc
    mov       [r14+90],	r15b
    mov       al,	[rbp + mc_auxmcl.do_procentry.ff]
    lea       r10,	[mc_decls.usedregs]
    mov       [r10+14],	al
L2353:
    mov       rax,	8
    add       [mc_genmcl.paramoffset],	rax
    mov       r14,	[r14+16]
L2350:
    test      r14,	r14
    jnz       L2347
    mov       rax,	[pc_decls.currfunc]
    movzx     rax,	byte [rax+82]
    mov       rdi,	rax
    mov       rax,	[pc_decls.currfunc]
    mov       r14,	[rax+24]
    jmp       L2358
L2355:
    movzx     rax,	byte [r14+82]
    lea       r10,	[pc_tables.psize]
    movzx     r10,	byte [r10 + rax]
    mov       r12,	r10
    movzx     rax,	byte [r14+82]
    cmp       rax,	11
    jnz       L2360
    mov       eax,	[r14+84]
    mov       r12,	rax
L2360:
    mov       al,	[r14+92]
    test      al,	al
    jz        L2356
L2362:
    mov       al,	[r14+91]
    test      al,	al
    jz        L2364
    mov       rsi,	1
    jmp       L2363
L2364:
    mov       al,	[r14+90]
    test      al,	al
    jz        L2365
    movzx     rax,	byte [r14+90]
    mov       r15,	rax
    lea       rax,	[mc_decls.usedregs]
    movzx     rax,	byte [rax+14]
    mov       [rbp + mc_auxmcl.do_procentry.ff],	rax
    xor       eax,	eax
    mov       [r14+90],	al
    movzx     rax,	byte [r14+82]
    mov       rcx,	r15
    mov       rdx,	rax
    call      mc_libmcl.mgenreg
    mov       [rbp + mc_auxmcl.do_procentry.$T1],	rax
    mov       rcx,	r14
    mov       rdx,	6
    call      mc_libmcl.mgenmem
    mov       rcx,	6
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.do_procentry.$T1]
    call      mc_libmcl.genmc
    mov       [r14+90],	r15b
    mov       al,	[rbp + mc_auxmcl.do_procentry.ff]
    lea       r10,	[mc_decls.usedregs]
    mov       [r10+14],	al
    jmp       L2363
L2365:
    mov       rcx,	r12
    call      mc_libmcl.roundsizetg
    sub       [mc_genmcl.frameoffset],	rax
    mov       eax,	[mc_genmcl.frameoffset]
    mov       [r14+76],	eax
    movsxd    rax,	dword [r14+76]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       [rbp + mc_auxmcl.do_procentry.$T1],	rax
    mov       rcx,	r14
    call      mc_writenasm.getdispname
    mov       rcx,	rax
    call      mc_libmcl.mgenname
    mov       rcx,	5
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.do_procentry.$T1]
    call      mc_libmcl.genmc
L2363:
L2356:
    mov       r14,	[r14+24]
L2358:
    test      r14,	r14
    jnz       L2355
    xor       rbx,	rbx
    mov       rax,	1
    mov       [rbp + mc_auxmcl.do_procentry.i],	rax
L2366:
    lea       rax,	[mc_decls.pcltempflags]
    mov       r10,	[rbp + mc_auxmcl.do_procentry.i]
    mov       al,	[rax + r10-1]
    test      al,	al
    jz        L2370
    inc       rbx
    mov       rax,	8
    sub       [mc_genmcl.frameoffset],	rax
    lea       rax,	[mc_decls.pcltempopnds]
    mov       r10,	[rbp + mc_auxmcl.do_procentry.i]
    mov       r13,	[rax + r10*8-8]
    mov       eax,	[mc_genmcl.frameoffset]
    mov       [r13+12],	eax
    movsxd    rax,	dword [r13+12]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       [rbp + mc_auxmcl.do_procentry.$T1],	rax
    mov       rcx,	[pc_decls.currfunc]
    mov       rdx,	[rbp + mc_auxmcl.do_procentry.i]
    call      mc_writenasm.gettempname
    mov       rcx,	rax
    call      mc_libmcl.mgenname
    mov       rcx,	5
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.do_procentry.$T1]
    call      mc_libmcl.genmc
L2370:
    mov       rax,	[rbp + mc_auxmcl.do_procentry.i]
    inc       rax
    mov       [rbp + mc_auxmcl.do_procentry.i],	rax
    cmp       rax,	20
    jle       L2366
    mov       rax,	[pc_decls.currfunc]
    mov       al,	[rax+108]
    test      al,	al
    jz        L2372
    mov       rax,	[pc_decls.currfunc]
    mov       ax,	[rax+114]
    test      ax,	ax
    jnz       L2375
    mov       rax,	[pc_decls.currfunc]
    mov       al,	[rax+112]
    test      al,	al
    jz        L2374
L2375:
    lea       rcx,	[L12377]
    lea       rdx,	[L12378]
    call      pc_api.merror
L2374:
    test      rbx,	rbx
    jz        L2377
    lea       rcx,	[L12379]
    lea       rdx,	[L12380]
    call      pc_api.merror
L2377:
    call      mc_auxmcl.resetmclentry
    jmp       L2331
L2372:
    mov       rax,	[mc_genmcl.frameoffset]
    neg       rax
    mov       [mc_genmcl.framebytes],	rax
    mov       rax,	[pc_decls.bspill]
    add       rax,	[pc_decls.bxspill]
    and       eax,	1
    test      rax,	rax
    jz        L2379
    mov       rax,	[mc_genmcl.framebytes]
    and       rax,	8
    jnz       L2381
    mov       rax,	8
    add       [mc_genmcl.framebytes],	rax
L2381:
    jmp       L2378
L2379:
    mov       rax,	[mc_genmcl.framebytes]
    and       rax,	8
    jz        L2383
    mov       rax,	8
    add       [mc_genmcl.framebytes],	rax
L2383:
L2378:
    mov       al,	[pc_decls.localshadow]
    test      al,	al
    jz        L2385
    mov       rax,	32
    add       [mc_genmcl.framebytes],	rax
L2385:
    mov       rax,	[pc_decls.bspill]
    test      rax,	rax
    jz        L2387
    mov       rax,	4
    mov       [rbp + mc_auxmcl.do_procentry.r],	rax
L2388:
    lea       rax,	[mc_decls.usedregs]
    mov       r10,	[rbp + mc_auxmcl.do_procentry.r]
    mov       al,	[rax + r10-1]
    test      al,	al
    jnz       L2393
    lea       rax,	[mc_decls.isregvar]
    mov       r10,	[rbp + mc_auxmcl.do_procentry.r]
    mov       al,	[rax + r10-1]
    test      al,	al
    jz        L2392
L2393:
    mov       rcx,	[rbp + mc_auxmcl.do_procentry.r]
    mov       rdx,	6
    call      mc_libmcl.mgenreg
    mov       rcx,	12
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2392:
    mov       rax,	[rbp + mc_auxmcl.do_procentry.r]
    inc       rax
    mov       [rbp + mc_auxmcl.do_procentry.r],	rax
    cmp       rax,	10
    jle       L2388
L2387:
    mov       rax,	[pc_decls.bxspill]
    test      rax,	rax
    jz        L2395
    mov       rcx,	1
    mov       rdx,	6
    call      mc_libmcl.mgenreg
    mov       r13,	rax
    mov       rax,	7
    mov       [rbp + mc_auxmcl.do_procentry.r],	rax
L2396:
    lea       rax,	[mc_decls.usedxregs]
    mov       r10,	[rbp + mc_auxmcl.do_procentry.r]
    mov       al,	[rax + r10-1]
    test      al,	al
    jnz       L2401
    lea       rax,	[mc_decls.isxregvar]
    mov       r10,	[rbp + mc_auxmcl.do_procentry.r]
    mov       al,	[rax + r10-1]
    test      al,	al
    jz        L2400
L2401:
    mov       rcx,	[rbp + mc_auxmcl.do_procentry.r]
    mov       rdx,	8
    call      mc_libmcl.mgenxreg
    mov       rcx,	17
    mov       rdx,	r13
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	12
    mov       rdx,	r13
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2400:
    mov       rax,	[rbp + mc_auxmcl.do_procentry.r]
    inc       rax
    mov       [rbp + mc_auxmcl.do_procentry.r],	rax
    cmp       rax,	16
    jle       L2396
L2395:
    lea       rcx,	[L12381]
    call      mc_libmcl.mgencomment
    mov       rax,	[mc_decls.mccodex]
    mov       [mc_auxmcl.mclframesetup],	rax
    call      mc_auxmcl.spillparams
    lea       rcx,	[L12382]
    call      mc_libmcl.mgencomment
    call      mc_auxmcl.resetmclentry
L2331:
;---------------
    add       rsp,	72
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.do_procexit
mc_auxmcl.do_procexit:
;?>>
   %define R.ax rdi
   %define R.r rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
;---------------
    lea       rcx,	[L12382]
    call      mc_libmcl.mgencomment
    mov       rax,	[pc_decls.currfunc]
    mov       al,	[rax+108]
    test      al,	al
    jz        L2404
    mov       rcx,	22
    xor       edx,	edx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L2402
L2404:
    mov       rcx,	[mc_auxmcl.mclframesetup]
    call      mc_auxmcl.setmclentryf
    mov       rax,	[mc_genmcl.framebytes]
    test      rax,	rax
    jnz       L2407
    mov       rax,	[pc_decls.currfunc]
    mov       al,	[rax+112]
    test      al,	al
    jz        L2406
L2407:
    lea       rax,	[mc_decls.usedregs]
    mov       al,	[rax+14]
    test      al,	al
    jz        L2409
    mov       rcx,	12
    mov       rdx,	[mc_decls.dframeopnd]
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	11
    mov       rdx,	[mc_decls.dframeopnd]
    mov       r8,	[mc_decls.dstackopnd]
    call      mc_libmcl.genmc
    mov       rcx,	[mc_genmcl.framebytes]
    call      mc_libmcl.pushstack
    jmp       L2408
L2409:
    mov       rax,	[mc_genmcl.framebytes]
    test      rax,	rax
    jz        L2411
    mov       rax,	[mc_genmcl.framebytes]
    add       rax,	8
    mov       rcx,	rax
    call      mc_libmcl.pushstack
L2411:
L2408:
L2406:
    call      mc_auxmcl.resetmclentryf
    mov       rax,	[mc_genmcl.framebytes]
    test      rax,	rax
    jnz       L2414
    mov       rax,	[pc_decls.currfunc]
    mov       al,	[rax+112]
    test      al,	al
    jz        L2413
L2414:
    lea       rax,	[mc_decls.usedregs]
    mov       al,	[rax+14]
    test      al,	al
    jz        L2416
    mov       rcx,	[mc_genmcl.framebytes]
    call      mc_libmcl.popstack
    mov       rcx,	13
    mov       rdx,	[mc_decls.dframeopnd]
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L2415
L2416:
    mov       rax,	[mc_genmcl.framebytes]
    test      rax,	rax
    jz        L2418
    mov       rax,	[mc_genmcl.framebytes]
    add       rax,	8
    mov       rcx,	rax
    call      mc_libmcl.popstack
L2418:
L2415:
L2413:
    mov       rax,	[pc_decls.bxspill]
    test      rax,	rax
    jz        L2420
    mov       rcx,	11
    mov       rdx,	6
    call      mc_libmcl.mgenreg
    mov       rdi,	rax
    mov       rbx,	16
L2421:
    lea       rax,	[mc_decls.usedxregs]
    mov       r10,	rbx
    mov       al,	[rax + r10-1]
    test      al,	al
    jz        L2425
    mov       rcx,	13
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	rbx
    mov       rdx,	8
    call      mc_libmcl.mgenxreg
    mov       rcx,	17
    mov       rdx,	rax
    mov       r8,	rdi
    call      mc_libmcl.genmc
L2425:
    dec       rbx
    cmp       rbx,	7
    jge       L2421
L2420:
    mov       rax,	[pc_decls.bspill]
    test      rax,	rax
    jz        L2427
    mov       rbx,	10
L2428:
    lea       rax,	[mc_decls.usedregs]
    mov       r10,	rbx
    mov       al,	[rax + r10-1]
    test      al,	al
    jz        L2432
    mov       rcx,	rbx
    mov       rdx,	6
    call      mc_libmcl.mgenreg
    mov       rcx,	13
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2432:
    dec       rbx
    cmp       rbx,	4
    jge       L2428
L2427:
    mov       rcx,	22
    xor       edx,	edx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2402:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.spillparams
mc_auxmcl.spillparams:
;?>>
   %define R.d rdi
   %define R.ax rbx
   %define R.offset rsi
   %define R.regoffset r12
   %define R.firstoffset r13
   %define R.i r14
    %define mc_auxmcl.spillparams.$T1 -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    mov       rsi,	16
    xor       r12,	r12
    xor       eax,	eax
    mov       r12,	rax
    mov       rax,	[pc_decls.currfunc]
    mov       rdi,	[rax+16]
    mov       rax,	[pc_decls.currfunc]
    mov       al,	[rax+113]
    test      al,	al
    jz        L2435
    movsxd    rax,	dword [rdi+76]
    mov       r13,	rax
    mov       rax,	[pc_decls.currfunc]
    movzx     rax,	byte [rax+112]
    mov       r14,	rax
    cmp       r14,	3
    jg        L2438
L2436:
    sub       rsp,	8
    push      0
    push      0
    push      8
    mov       rax,	r14
    shl       rax,	3
    add       rax,	r13
    mov       rcx,	15
    xor       edx,	edx
    mov       r8,	1
    mov       r9,	rax
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       rbx,	rax
    lea       rax,	[r14+11]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	11
    mov       rdx,	rbx
    mov       r8,	rax
    call      mc_libmcl.genmc
    inc       r14
    cmp       r14,	3
    jle       L2436
L2438:
L2435:
    jmp       L2442
L2439:
    cmp       r12,	3
    jg        L2441
L2444:
    mov       al,	[rdi+92]
    test      al,	al
    jz        L2446
    mov       al,	[rdi+90]
    test      al,	al
    jnz       L2448
    sub       rsp,	8
    push      0
    push      0
    push      8
    movsxd    rax,	dword [rdi+76]
    mov       rcx,	15
    xor       edx,	edx
    mov       r8,	1
    mov       r9,	rax
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       rbx,	rax
    movzx     rax,	byte [rdi+82]
    cmp       rax,	2
    jz        L2450
    cmp       rax,	1
    jz        L2451
    jmp       L2452
L2450:
    lea       rax,	[r12+1]
    mov       rcx,	rax
    mov       rdx,	8
    call      mc_libmcl.mgenxreg
    mov       rcx,	17
    mov       rdx,	rbx
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L2449
L2451:
    lea       rax,	[r12+1]
    mov       rcx,	rax
    mov       rdx,	8
    call      mc_libmcl.mgenxreg
    mov       [rbp + mc_auxmcl.spillparams.$T1],	rax
    mov       rcx,	rbx
    mov       rdx,	4
    call      mc_libmcl.changeopndsize
    mov       rcx,	16
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.spillparams.$T1]
    call      mc_libmcl.genmc
    jmp       L2449
L2452:
    lea       rax,	[r12+11]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	11
    mov       rdx,	rbx
    mov       r8,	rax
    call      mc_libmcl.genmc
L2449:
    jmp       L2447
L2448:
    mov       al,	[rdi+90]
    test      al,	al
    jz        L2453
    movzx     rax,	byte [rdi+82]
    cmp       rax,	2
    jg        L2455
    movzx     rax,	byte [rdi+90]
    cmp       rax,	5
    jl        L2457
    movzx     rax,	byte [rdi+82]
    lea       r10,	[r12+1]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_libmcl.mgenxreg
    mov       [rbp + mc_auxmcl.spillparams.$T1],	rax
    movzx     rax,	byte [rdi+90]
    mov       rcx,	rax
    mov       rdx,	8
    call      mc_libmcl.mgenxreg
    mov       rcx,	17
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.spillparams.$T1]
    call      mc_libmcl.genmc
L2457:
    jmp       L2454
L2455:
    movzx     rax,	byte [rdi+90]
    cmp       rax,	10
    jg        L2458
    movzx     rax,	byte [rdi+82]
    lea       r10,	[r12+11]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_libmcl.mgenreg
    mov       [rbp + mc_auxmcl.spillparams.$T1],	rax
    movzx     rax,	byte [rdi+82]
    movzx     r10,	byte [rdi+90]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_libmcl.mgenreg
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.spillparams.$T1]
    call      mc_libmcl.genmc
L2458:
L2454:
L2453:
L2447:
L2446:
    mov       rax,	8
    add       rsi,	rax
    inc       r12
    mov       rdi,	[rdi+16]
L2442:
    test      rdi,	rdi
    jnz       L2439
L2441:
;---------------
    add       rsp,	48
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.do_jumptruefalse
mc_auxmcl.do_jumptruefalse:
;?>>
   %define R.p rsi
   %define R.cond r12
   %define R.ax rdi
   %define R.bx rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	2
    jle       L2461
    mov       rcx,	41
    mov       rdx,	rdi
    mov       r8,	rdi
    call      mc_libmcl.genmc
    jmp       L2460
L2461:
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	rax
    call      mc_stackmcl.getworkregm
    mov       rbx,	rax
    movzx     rax,	byte [mc_decls.pmode]
    dec       rax
    mov       r10,	76
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	rbx
    mov       r8,	rbx
    call      mc_libmcl.genmc
    movzx     rax,	byte [mc_decls.pmode]
    dec       rax
    mov       r10,	73
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
L2460:
    mov       rax,	[rsi+8]
    mov       rcx,	rax
    call      mc_libmcl.mgenlabel
    mov       rcx,	26
    mov       rdx,	r12
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.do_bitwise
mc_auxmcl.do_bitwise:
;?>>
    %define mc_auxmcl.do_bitwise.p 40
   %define R.opc rsi
   %define R.ax rdi
   %define R.bx rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rdx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rbx,	rax
    mov       rcx,	rsi
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.do_shift
mc_auxmcl.do_shift:
;?>>
    %define mc_auxmcl.do_shift.p 48
   %define R.opc r12
   %define R.ax rdi
   %define R.cx rbx
   %define R.y rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       r12,	rdx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    lea       rax,	[mc_decls.pclopnd]
    mov       r10,	[mc_decls.noperands]
    mov       rsi,	[rax + r10*8-8]
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	[mc_decls.noperands]
    movzx     rax,	byte [rax + r10-1]
    test      rax,	rax
    jnz       L2465
    movzx     rax,	byte [rsi+1]
    cmp       rax,	4
    jnz       L2465
    mov       rax,	[rsi+8]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L2464
L2465:
    mov       al,	[pc_decls.r10used]
    test      al,	al
    jz        L2467
    mov       rcx,	11
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	12
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2467:
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	3
    mov       r8,	11
    call      mc_stackmcl.loadparam
    mov       rbx,	rax
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    mov       al,	[pc_decls.r10used]
    test      al,	al
    jz        L2469
    mov       rcx,	11
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	13
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2469:
L2464:
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.setmclentry
mc_auxmcl.setmclentry:
;?>>
   %define R.p rcx
;?]]
;---------------
    mov       rax,	[mc_decls.mccodex]
    mov       [mc_decls.mce_oldmccodex],	rax
    mov       [mc_decls.mccodex],	rcx
    mov       rax,	[rcx]
    mov       [mc_decls.mce_lastmcl],	rax
    mov       rax,	[rcx+8]
    mov       [mc_decls.mce_nextmcl],	rax
;---------------
    ret       
;End 
;Proc mc_auxmcl.resetmclentry
mc_auxmcl.resetmclentry:
;?>>
   %define R.pnew rdi
    push      rdi
;?]]
    sub       rsp,	16
;---------------
    mov       rax,	[mc_decls.mce_lastmcl]
    mov       r10,	[mc_decls.mccodex]
    mov       [r10],	rax
    mov       rax,	[mc_decls.mce_nextmcl]
    mov       r10,	[mc_decls.mccodex]
    mov       [r10+8],	rax
    mov       rdi,	[mc_decls.mccodex]
    mov       rax,	[mc_decls.mce_oldmccodex]
    mov       [mc_decls.mccodex],	rax
    mov       rax,	rdi
L2471:
;---------------
    add       rsp,	16
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.setmclentryf
mc_auxmcl.setmclentryf:
;?>>
   %define R.p rcx
;?]]
;---------------
    mov       rax,	[mc_decls.mccodex]
    mov       [mc_decls.mcf_oldmccodex],	rax
    mov       [mc_decls.mccodex],	rcx
    mov       rax,	[rcx]
    mov       [mc_decls.mcf_lastmcl],	rax
    mov       rax,	[rcx+8]
    mov       [mc_decls.mcf_nextmcl],	rax
;---------------
    ret       
;End 
;Proc mc_auxmcl.resetmclentryf
mc_auxmcl.resetmclentryf:
;?>>
   %define R.pnew rdi
    push      rdi
;?]]
    sub       rsp,	16
;---------------
    mov       rax,	[mc_decls.mcf_lastmcl]
    mov       r10,	[mc_decls.mccodex]
    mov       [r10],	rax
    mov       rax,	[mc_decls.mcf_nextmcl]
    mov       r10,	[mc_decls.mccodex]
    mov       [r10+8],	rax
    mov       rdi,	[mc_decls.mccodex]
    mov       rax,	[mc_decls.mcf_oldmccodex]
    mov       [mc_decls.mccodex],	rax
    mov       rax,	rdi
L2473:
;---------------
    add       rsp,	16
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.do_pushlowargs
mc_auxmcl.do_pushlowargs:
;?>>
   %define R.nargs r15
    %define mc_auxmcl.do_pushlowargs.nvariadics 80
    %define mc_auxmcl.do_pushlowargs.isptr 88
   %define R.ax rdi
   %define R.j rbx
   %define R.k rsi
   %define R.nextireg r12
   %define R.nextxreg r13
   %define R.mode r14
    %define mc_auxmcl.do_pushlowargs.imode -8
    %define mc_auxmcl.do_pushlowargs.blockret -16
    %define mc_auxmcl.do_pushlowargs.dblock -24
    %define mc_auxmcl.do_pushlowargs.av_1 -32
    %define mc_auxmcl.do_pushlowargs.i -40
    %define mc_auxmcl.do_pushlowargs.$T1 -48
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	88
    mov       r15,	rcx
    mov       [rbp+80],	rdx
    mov       [rbp+88],	r8
;---------------
    test      r15,	r15
    jnz       L2476
    jmp       L2474
L2476:
    lea       rax,	[mc_decls.callblockret]
    mov       r10,	[mc_decls.ncalldepth]
    movzx     rax,	byte [rax + r10-1]
    mov       [rbp + mc_auxmcl.do_pushlowargs.blockret],	rax
    mov       r12,	11
    mov       r13,	1
    xor       rsi,	rsi
    mov       rax,	[mc_decls.noperands]
    mov       [rbp + mc_auxmcl.do_pushlowargs.i],	rax
    mov       rax,	[mc_decls.noperands]
    sub       rax,	r15
    inc       rax
    mov       [rbp + mc_auxmcl.do_pushlowargs.av_1],	rax
    mov       rax,	[rbp + mc_auxmcl.do_pushlowargs.i]
    cmp       rax,	[rbp + mc_auxmcl.do_pushlowargs.av_1]
    jl        L2479
L2477:
    inc       rsi
    cmp       rsi,	1
    jnz       L2481
    mov       rax,	[rbp + mc_auxmcl.do_pushlowargs.blockret]
    test      rax,	rax
    jz        L2481
    lea       rax,	[mc_decls.callblocksize]
    mov       r10,	[mc_decls.ncalldepth]
    mov       eax,	[rax + r10*4-4]
    mov       rcx,	rax
    call      mc_libmcl.newblocktemp
    mov       [rbp + mc_auxmcl.do_pushlowargs.dblock],	rax
    mov       al,	1
    mov       r10,	[rbp + mc_auxmcl.do_pushlowargs.dblock]
    mov       [r10+92],	al
    mov       rcx,	[rbp + mc_auxmcl.do_pushlowargs.dblock]
    mov       rdx,	6
    call      mc_libmcl.mgenmem
    mov       [rbp + mc_auxmcl.do_pushlowargs.$T1],	rax
    mov       rcx,	11
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	14
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.do_pushlowargs.$T1]
    call      mc_libmcl.genmc
    jmp       L2480
L2481:
    mov       rax,	[rbp + mc_auxmcl.do_pushlowargs.i]
    sub       rax,	[rbp + mc_auxmcl.do_pushlowargs.isptr]
    add       rax,	[rbp + mc_auxmcl.do_pushlowargs.blockret]
    mov       rbx,	rax
    lea       rax,	[mc_decls.pclmode]
    mov       r10,	rbx
    movzx     rax,	byte [rax + r10-1]
    mov       r14,	rax
    mov       rax,	r14
    cmp       rax,	11
    jz        L2483
    cmp       rax,	2
    jz        L2484
    cmp       rax,	1
    jz        L2484
    jmp       L2485
L2483:
    mov       rcx,	rbx
    mov       rdx,	r14
    mov       r8,	r12
    call      mc_stackmcl.loadparam
    mov       rdi,	rax
    lea       rax,	[mc_decls.callargsize]
    mov       r10,	[mc_decls.ncalldepth]
    shl       r10,	4
    lea       rax,	[rax + r10-16]
    mov       r10,	rsi
    mov       eax,	[rax + r10*4-4]
    mov       rcx,	rdi
    mov       rdx,	rax
    mov       r8,	rsi
    call      mc_auxmcl.copyblockarg
    jmp       L2482
L2484:
    mov       rcx,	rbx
    mov       rdx,	r14
    mov       r8,	r13
    call      mc_stackmcl.loadparam
    mov       rax,	[rbp + mc_auxmcl.do_pushlowargs.nvariadics]
    test      rax,	rax
    jz        L2487
    cmp       rsi,	[rbp + mc_auxmcl.do_pushlowargs.nvariadics]
    jl        L2487
    cmp       r14,	1
    jnz       L2489
    mov       rax,	5
    jmp       L2488
L2489:
    mov       rax,	6
L2488:
    mov       [rbp + mc_auxmcl.do_pushlowargs.imode],	rax
    mov       rcx,	r13
    mov       rdx,	r14
    call      mc_libmcl.mgenreg
    mov       [rbp + mc_auxmcl.do_pushlowargs.$T1],	rax
    mov       rcx,	r12
    mov       rdx,	[rbp + mc_auxmcl.do_pushlowargs.imode]
    call      mc_libmcl.mgenreg
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.do_pushlowargs.$T1]
    call      mc_libmcl.genmc
L2487:
    jmp       L2482
L2485:
;mc_auxmcl.do_pushlowargs.doint:
    mov       rcx,	rbx
    mov       rdx,	r14
    mov       r8,	r12
    call      mc_stackmcl.loadparam
L2482:
L2480:
    inc       r12
    inc       r13
    mov       rax,	[rbp + mc_auxmcl.do_pushlowargs.i]
    dec       rax
    mov       [rbp + mc_auxmcl.do_pushlowargs.i],	rax
    cmp       rax,	[rbp + mc_auxmcl.do_pushlowargs.av_1]
    jge       L2477
L2479:
L2474:
;---------------
    add       rsp,	88
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.do_getretvalue
mc_auxmcl.do_getretvalue:
;?>>
   %define R.p r12
   %define R.i rdi
   %define R.n rbx
   %define R.m rsi
    %define mc_auxmcl.do_getretvalue.modes -80
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	112
    mov       r12,	rcx
;---------------
    lea       rax,	[r12+32]
    movzx     rax,	byte [rax]
    cmp       rax,	13
    jnz       L2493
    xor       rbx,	rbx
    jmp       L2495
L2494:
    movzx     rax,	byte [r12+3]
    inc       rbx
    mov       r10,	rbx
    mov       [rbp + r10*8 + mc_auxmcl.do_getretvalue.modes-8],	rax
L2495:
    add       r12,	32
    mov       rax,	r12
    movzx     rax,	byte [rax]
    cmp       rax,	13
    jz        L2494
    lea       rax,	[r12-32]
    mov       [mc_decls.currpcl],	rax
    mov       rdi,	rbx
    cmp       rdi,	1
    jl        L2499
L2497:
    mov       rsi,	[rbp + rdi*8 + mc_auxmcl.do_getretvalue.modes-8]
    cmp       rsi,	2
    jg        L2501
    lea       rax,	[mc_decls.multxregs]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    jmp       L2500
L2501:
    lea       rax,	[mc_decls.multregs]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
L2500:
    mov       rcx,	rsi
    mov       rdx,	rax
    call      mc_stackmcl.pushpcl_reg
    dec       rdi
    cmp       rdi,	1
    jge       L2497
L2499:
    jmp       L2492
L2493:
    movzx     rax,	byte [r12+3]
    mov       rcx,	rax
    mov       rdx,	1
    call      mc_stackmcl.pushpcl_reg
L2492:
;---------------
    add       rsp,	112
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.ismemaddr
mc_auxmcl.ismemaddr:
;?>>
   %define R.n rcx
;?]]
;---------------
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	rcx
    movzx     rax,	byte [rax + r10-1]
    test      rax,	rax
    jnz       L2504
    lea       rax,	[mc_decls.pclopnd]
    mov       r10,	rcx
    mov       rax,	[rax + r10*8-8]
    movzx     rax,	byte [rax+1]
    cmp       rax,	2
    jnz       L2504
    mov       rax,	1
    jmp       L2502
L2504:
    xor       eax,	eax
L2502:
;---------------
    ret       
;End 
;Proc mc_auxmcl.do_incr
mc_auxmcl.do_incr:
;?>>
   %define R.p rbx
   %define R.incrop rsi
   %define R.addop r12
   %define R.mx rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
;---------------
    movzx     rax,	byte [rbx+3]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       rdi,	rax
    movsxd    rax,	dword [rbx+16]
    cmp       rax,	1
    jnz       L2507
    mov       rcx,	rsi
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L2506
L2507:
    movsxd    rax,	dword [rbx+16]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
L2506:
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.do_incrload
mc_auxmcl.do_incrload:
;?>>
   %define R.p rsi
   %define R.incrop r12
   %define R.addop r13
   %define R.ax rdi
   %define R.mx rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       rbx,	rax
    movzx     rax,	byte [mc_decls.pmode]
    lea       r10,	[mc_decls.pclreg]
    mov       r11,	[mc_decls.noperands]
    movzx     r10,	byte [r10 + r11-1]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_stackmcl.getworkreg_rm
    mov       rdi,	rax
    movsxd    rax,	dword [rsi+16]
    cmp       rax,	1
    jnz       L2510
    mov       rcx,	r12
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L2509
L2510:
    movsxd    rax,	dword [rsi+16]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	r13
    mov       rdx,	rbx
    mov       r8,	rax
    call      mc_libmcl.genmc
L2509:
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    mov       al,	1
    lea       r10,	[mc_decls.pclloc]
    mov       r11,	[mc_decls.noperands]
    mov       [r10 + r11-1],	al
    xor       eax,	eax
    lea       r10,	[mc_decls.pclopnd]
    mov       r11,	[mc_decls.noperands]
    mov       [r10 + r11*8-8],	rax
    mov       al,	[rdi+10]
    lea       r10,	[mc_decls.pclreg]
    mov       r11,	[mc_decls.noperands]
    mov       [r10 + r11-1],	al
    mov       al,	[mc_decls.pmode]
    lea       r10,	[mc_decls.pclmode]
    mov       r11,	[mc_decls.noperands]
    mov       [r10 + r11-1],	al
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.do_loadincr
mc_auxmcl.do_loadincr:
;?>>
   %define R.p rsi
   %define R.incrop r12
   %define R.addop r13
   %define R.ax rdi
   %define R.mx rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       rbx,	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	rax
    xor       edx,	edx
    call      mc_stackmcl.pushpcl_reg
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rdi,	rax
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    movsxd    rax,	dword [rsi+16]
    cmp       rax,	1
    jnz       L2513
    mov       rcx,	r12
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L2512
L2513:
    movsxd    rax,	dword [rsi+16]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	r13
    mov       rdx,	rbx
    mov       r8,	rax
    call      mc_libmcl.genmc
L2512:
    mov       rax,	[mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	[mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.do_for
mc_auxmcl.do_for:
;?>>
   %define R.p r13
   %define R.incop r14
    %define mc_auxmcl.do_for.addop 80
    %define mc_auxmcl.do_for.cond 88
   %define R.q rdi
   %define R.r rbx
   %define R.ax rsi
   %define R.bx r12
    %define mc_auxmcl.do_for.mx -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       r13,	rcx
    mov       r14,	rdx
    mov       [rbp+80],	r8
    mov       [rbp+88],	r9
;---------------
    lea       rax,	[r13+32]
    mov       rdi,	rax
    lea       rax,	[rdi+32]
    mov       [mc_decls.currpcl],	rax
    mov       rbx,	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[rdi+8]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_libmcl.mgenmem
    mov       [rbp + mc_auxmcl.do_for.mx],	rax
    mov       rax,	[rdi+8]
    mov       al,	[rax+90]
    test      al,	al
    jz        L2516
    movsxd    rax,	dword [r13+16]
    cmp       rax,	1
    jnz       L2518
    mov       rcx,	r14
    mov       rdx,	[rbp + mc_auxmcl.do_for.mx]
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L2517
L2518:
    movsxd    rax,	dword [r13+16]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	[rbp + mc_auxmcl.do_for.addop]
    mov       rdx,	[rbp + mc_auxmcl.do_for.mx]
    mov       r8,	rax
    call      mc_libmcl.genmc
L2517:
    mov       rsi,	[rbp + mc_auxmcl.do_for.mx]
    jmp       L2515
L2516:
    call      mc_stackmcl.getworkireg
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rsi,	rax
    mov       rcx,	11
    mov       rdx,	rsi
    mov       r8,	[rbp + mc_auxmcl.do_for.mx]
    call      mc_libmcl.genmc
    movsxd    rax,	dword [r13+16]
    cmp       rax,	1
    jnz       L2520
    mov       rcx,	r14
    mov       rdx,	rsi
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L2519
L2520:
    movsxd    rax,	dword [r13+16]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	[rbp + mc_auxmcl.do_for.addop]
    mov       rdx,	rsi
    mov       r8,	rax
    call      mc_libmcl.genmc
L2519:
    mov       rcx,	11
    mov       rdx,	[rbp + mc_auxmcl.do_for.mx]
    mov       r8,	rsi
    call      mc_libmcl.genmc
L2515:
    movzx     rax,	byte [rbx+1]
    cmp       rax,	4
    jnz       L2522
    mov       rax,	[rbx+8]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       r12,	rax
    jmp       L2521
L2522:
    mov       rax,	[rbx+8]
    mov       rcx,	rax
    mov       rdx,	6
    call      mc_libmcl.mgenmem
    mov       r12,	rax
L2521:
    mov       rcx,	42
    mov       rdx,	rsi
    mov       r8,	r12
    call      mc_libmcl.genmc
    mov       rax,	[r13+8]
    mov       rcx,	rax
    call      mc_libmcl.mgenlabel
    mov       rcx,	26
    mov       rdx,	[rbp + mc_auxmcl.do_for.cond]
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
;---------------
    add       rsp,	48
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.scaleindex
mc_auxmcl.scaleindex:
;?>>
   %define R.ax rdi
   %define R.scale rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rax,	rbx
    cmp       rax,	1
    jz        L2526
    cmp       rax,	2
    jz        L2526
    cmp       rax,	4
    jz        L2526
    cmp       rax,	8
    jnz       L2525
L2526:
    mov       rax,	rbx
    jmp       L2523
L2525:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_auxmcl.mulimm
    mov       rax,	1
L2523:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.mulimm
mc_auxmcl.mulimm:
;?>>
   %define R.ax rsi
   %define R.n r12
   %define R.shifts rdi
   %define R.m rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    mov       rax,	r12
    test      rax,	rax
    jz        L2529
    cmp       rax,	1
    jz        L2530
    cmp       rax,	-1
    jz        L2531
    jmp       L2532
L2529:
    mov       rcx,	rsi
    call      mc_libmcl.clearreg
    jmp       L2527
L2530:
    jmp       L2527
L2531:
    mov       rcx,	50
    mov       rdx,	rsi
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L2527
L2532:
L2528:
    xor       rdi,	rdi
    mov       rax,	r12
    mov       rbx,	rax
    jmp       L2534
L2533:
    sar       rbx,	1
    inc       rdi
L2534:
    mov       eax,	ebx
    and       eax,	1
    test      rax,	rax
    jz        L2533
    test      rdi,	rdi
    jz        L2537
    mov       rcx,	rdi
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	43
    mov       rdx,	rsi
    mov       r8,	rax
    call      mc_libmcl.genmc
L2537:
    mov       rax,	rbx
    cmp       rax,	1
    jz        L2539
    cmp       rax,	3
    jz        L2540
    cmp       rax,	5
    jz        L2540
    cmp       rax,	9
    jz        L2540
    jmp       L2541
L2539:
    jmp       L2527
L2540:
    sub       rsp,	8
    push      0
    push      0
    push      0
    lea       rax,	[rbx-1]
    movzx     r10,	byte [rsi+10]
    movzx     r11,	byte [rsi+10]
    mov       rcx,	r11
    mov       rdx,	r10
    mov       r8,	rax
    xor       r9d,	r9d
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       rcx,	14
    mov       rdx,	rsi
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L2538
L2541:
    test      rdi,	rdi
    jz        L2543
    mov       al,	34
    mov       r10,	[mc_decls.mccodex]
    mov       [r10+33],	al
    mov       rcx,	r12
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       r10,	[mc_decls.mccodex]
    mov       [r10+24],	rax
    jmp       L2542
L2543:
    mov       rcx,	r12
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	34
    mov       rdx,	rsi
    mov       r8,	rax
    call      mc_libmcl.genmc
L2542:
L2538:
L2527:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.do_addrmode
mc_auxmcl.do_addrmode:
;?>>
    %define mc_auxmcl.do_addrmode.p 72
   %define R.px rdi
   %define R.ax rbx
   %define R.bx rsi
    %define mc_auxmcl.do_addrmode.scale -8
   %define R.extra r12
   %define R.offset r13
   %define R.reg r14
    %define mc_auxmcl.do_addrmode.regix -16
    %define mc_auxmcl.do_addrmode.d -24
    %define mc_auxmcl.do_addrmode.q -32
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	72
    mov       [rbp+72],	rcx
;---------------
    mov       rax,	[rbp + mc_auxmcl.do_addrmode.p]
    movsxd    rax,	dword [rax+16]
    mov       [rbp + mc_auxmcl.do_addrmode.scale],	rax
    mov       rax,	[rbp + mc_auxmcl.do_addrmode.p]
    movsxd    rax,	dword [rax+20]
    mov       r12,	rax
    mov       rcx,	[mc_decls.noperands]
    call      mc_stackmcl.isimmload
    mov       [rbp + mc_auxmcl.do_addrmode.q],	rax
    mov       rax,	[rbp + mc_auxmcl.do_addrmode.q]
    test      rax,	rax
    jz        L2546
    mov       rax,	[rbp + mc_auxmcl.do_addrmode.q]
    mov       rax,	[rax+8]
    imul      rax,	[rbp + mc_auxmcl.do_addrmode.scale]
    add       rax,	r12
    mov       r13,	rax
L2546:
    xor       rdi,	rdi
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	[mc_decls.noperands]
    movzx     rax,	byte [rax + r10-2]
    cmp       rax,	2
    jnz       L2548
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	[mc_decls.noperands]
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	2
    jnz       L2550
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	[mc_decls.noperands]
    movzx     rax,	byte [rax + r10-1]
    mov       r14,	rax
    mov       rcx,	r14
    lea       rdx,	[rbp + mc_auxmcl.do_addrmode.scale]
    mov       r8,	[mc_decls.noperands]
    call      mc_auxmcl.scaleregvar
    mov       [rbp + mc_auxmcl.do_addrmode.regix],	rax
    sub       rsp,	8
    push      0
    push      0
    push      0
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	[mc_decls.noperands]
    movzx     rax,	byte [rax + r10-2]
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_auxmcl.do_addrmode.regix]
    mov       r8,	[rbp + mc_auxmcl.do_addrmode.scale]
    mov       r9,	r12
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       rdi,	rax
    jmp       L2549
L2550:
    mov       rax,	[rbp + mc_auxmcl.do_addrmode.q]
    test      rax,	rax
    jz        L2551
    sub       rsp,	8
    push      0
    push      0
    push      0
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	[mc_decls.noperands]
    movzx     rax,	byte [rax + r10-2]
    mov       rcx,	rax
    xor       edx,	edx
    mov       r8,	1
    mov       r9,	r13
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       rdi,	rax
    jmp       L2549
L2551:
    lea       rax,	[mc_decls.pclmode]
    mov       r10,	[mc_decls.noperands]
    movzx     rax,	byte [rax + r10-1]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       r10,	rax
    mov       rsi,	r10
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_auxmcl.do_addrmode.scale]
    call      mc_auxmcl.scaleindex
    mov       [rbp + mc_auxmcl.do_addrmode.scale],	rax
    sub       rsp,	8
    push      0
    push      0
    push      0
    movzx     rax,	byte [rsi+10]
    lea       r10,	[mc_decls.pclreg]
    mov       r11,	[mc_decls.noperands]
    movzx     r10,	byte [r10 + r11-2]
    mov       rcx,	r10
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.do_addrmode.scale]
    mov       r9,	r12
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       rdi,	rax
L2549:
    jmp       L2547
L2548:
    mov       rax,	[mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    call      mc_auxmcl.ismemaddr
    test      rax,	rax
    jz        L2552
    lea       rax,	[mc_decls.pclopnd]
    mov       r10,	[mc_decls.noperands]
    mov       rax,	[rax + r10*8-16]
    mov       rax,	[rax+8]
    mov       [rbp + mc_auxmcl.do_addrmode.d],	rax
    mov       rax,	[rbp + mc_auxmcl.do_addrmode.d]
    movzx     rax,	byte [rax+72]
    cmp       rax,	3
    jnz       L2556
    movzx     rax,	byte [pc_api.phighmem]
    cmp       rax,	2
    jz        L2555
L2556:
    mov       rax,	[rbp + mc_auxmcl.do_addrmode.d]
    movzx     rax,	byte [rax+72]
    cmp       rax,	5
    jnz       L2554
    mov       rax,	[rbp + mc_auxmcl.do_addrmode.d]
    movzx     rax,	byte [rax+82]
    cmp       rax,	11
    jnz       L2554
L2555:
    jmp       L2557
L2554:
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	[mc_decls.noperands]
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	2
    jnz       L2559
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	[mc_decls.noperands]
    movzx     rax,	byte [rax + r10-1]
    mov       r14,	rax
    mov       rcx,	r14
    lea       rdx,	[rbp + mc_auxmcl.do_addrmode.scale]
    mov       r8,	[mc_decls.noperands]
    call      mc_auxmcl.scaleregvar
    mov       [rbp + mc_auxmcl.do_addrmode.regix],	rax
    sub       rsp,	8
    push      qword [rbp + mc_auxmcl.do_addrmode.d]
    push      0
    push      0
    xor       ecx,	ecx
    mov       rdx,	[rbp + mc_auxmcl.do_addrmode.regix]
    mov       r8,	[rbp + mc_auxmcl.do_addrmode.scale]
    mov       r9,	r12
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       rdi,	rax
    jmp       L2558
L2559:
    mov       rax,	[rbp + mc_auxmcl.do_addrmode.q]
    test      rax,	rax
    jz        L2560
    sub       rsp,	8
    push      qword [rbp + mc_auxmcl.do_addrmode.d]
    push      0
    push      0
    xor       ecx,	ecx
    xor       edx,	edx
    mov       r8,	1
    mov       r9,	r13
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       rdi,	rax
    jmp       L2558
L2560:
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	10
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       r10,	rax
    mov       rsi,	r10
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_auxmcl.do_addrmode.scale]
    call      mc_auxmcl.scaleindex
    mov       [rbp + mc_auxmcl.do_addrmode.scale],	rax
    sub       rsp,	8
    push      qword [rbp + mc_auxmcl.do_addrmode.d]
    push      0
    push      0
    movzx     rax,	byte [rsi+10]
    xor       ecx,	ecx
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.do_addrmode.scale]
    mov       r9,	r12
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       rdi,	rax
L2558:
    jmp       L2547
L2552:
;mc_auxmcl.do_addrmode.skip:
L2557:
    mov       rax,	[mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rbx,	rax
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	[mc_decls.noperands]
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	1
    jnz       L2562
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	[mc_decls.noperands]
    movzx     rax,	byte [rax + r10-1]
    mov       r14,	rax
    mov       rcx,	r14
    lea       rdx,	[rbp + mc_auxmcl.do_addrmode.scale]
    mov       r8,	[mc_decls.noperands]
    call      mc_auxmcl.scaleregvar
    mov       [rbp + mc_auxmcl.do_addrmode.regix],	rax
    sub       rsp,	8
    push      0
    push      0
    push      0
    movzx     rax,	byte [rbx+10]
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_auxmcl.do_addrmode.regix]
    mov       r8,	[rbp + mc_auxmcl.do_addrmode.scale]
    mov       r9,	r12
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       rdi,	rax
    jmp       L2561
L2562:
    mov       rax,	[rbp + mc_auxmcl.do_addrmode.q]
    test      rax,	rax
    jz        L2563
    sub       rsp,	8
    push      0
    push      0
    push      0
    movzx     rax,	byte [rbx+10]
    mov       rcx,	rax
    xor       edx,	edx
    mov       r8,	1
    mov       r9,	r13
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       rdi,	rax
    jmp       L2561
L2563:
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       r10,	rax
    mov       rsi,	r10
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_auxmcl.do_addrmode.scale]
    call      mc_auxmcl.scaleindex
    mov       [rbp + mc_auxmcl.do_addrmode.scale],	rax
    sub       rsp,	8
    push      0
    push      0
    push      0
    movzx     rax,	byte [rsi+10]
    movzx     r10,	byte [rbx+10]
    mov       rcx,	r10
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.do_addrmode.scale]
    mov       r9,	r12
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       rdi,	rax
L2561:
L2547:
    mov       rax,	[rbp + mc_auxmcl.do_addrmode.p]
    movzx     rax,	byte [rax+3]
    lea       r10,	[pc_tables.psize]
    movzx     r10,	byte [r10 + rax]
    lea       rax,	[rdi+8]
    mov       r15w,	[rax]
    mov       r11,	-32
    and       r15w,	r11w
    or        r15w,	r10w
    mov       [rax],	r15w
    mov       rax,	rdi
L2544:
;---------------
    add       rsp,	72
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.scaleregvar
mc_auxmcl.scaleregvar:
;?>>
   %define R.reg rsi
   %define R.scale r12
   %define R.n r13
   %define R.regix rdi
   %define R.ax rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
;---------------
    mov       rax,	[r12]
    cmp       rax,	1
    jz        L2567
    cmp       rax,	2
    jz        L2567
    cmp       rax,	4
    jz        L2567
    cmp       rax,	8
    jnz       L2566
L2567:
    mov       rax,	rsi
    jmp       L2564
L2566:
    call      mc_stackmcl.getworkireg
    mov       rdi,	rax
    mov       rcx,	rdi
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rbx,	rax
    mov       rax,	[r12]
    cmp       rax,	16
    jnz       L2569
    sub       rsp,	8
    push      0
    push      0
    push      0
    mov       rcx,	rsi
    mov       rdx,	rsi
    mov       r8,	1
    xor       r9d,	r9d
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       rcx,	14
    mov       rdx,	rbx
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rax,	8
    mov       [r12],	rax
    jmp       L2568
L2569:
    mov       rcx,	rsi
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	11
    mov       rdx,	rbx
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rax,	[r12]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mc_auxmcl.mulimm
    mov       rax,	1
    mov       [r12],	rax
L2568:
    mov       al,	1
    lea       r10,	[mc_decls.pclloc]
    mov       r11,	r13
    mov       [r10 + r11-1],	al
    mov       al,	dil
    lea       r10,	[mc_decls.pclreg]
    mov       r11,	r13
    mov       [r10 + r11-1],	al
    mov       al,	10
    lea       r10,	[mc_decls.pclmode]
    mov       r11,	r13
    mov       [r10 + r11-1],	al
    xor       eax,	eax
    lea       r10,	[mc_decls.pclopnd]
    mov       r11,	r13
    mov       [r10 + r11*8-8],	rax
    mov       rax,	rdi
L2564:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.dolea
mc_auxmcl.dolea:
;?>>
   %define R.ax rdi
   %define R.px rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    movzx     rax,	byte [rbx+11]
    movzx     r10,	word [rbx+8]
    shr       r10,	12
    and       r10,	15
    cmp       r10,	rax
    jnz       L2574
    movsxd    rax,	dword [rbx+12]
    cmp       rax,	r10
    jnz       L2574
    test      rax,	rax
    jnz       L2574
    mov       rax,	1
    jmp       L2575
L2574:
    xor       eax,	eax
L2575:
    test      rax,	rax
    setnz     al
    movzx     eax,	al
    test      ax,	ax
    jz        L2573
    movzx     rax,	byte [rbx+10]
    movzx     r10,	byte [rdi+10]
    cmp       rax,	r10
    jz        L2572
L2573:
    mov       rcx,	14
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
L2572:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.do_binto
mc_auxmcl.do_binto:
;?>>
   %define R.p rsi
   %define R.opc r12
   %define R.fopc r13
   %define R.ax rdi
   %define R.bx rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    cmp       rax,	2
    jg        L2578
    mov       rcx,	rsi
    mov       rdx,	r13
    call      mc_auxmcl.do_binto_float
    jmp       L2576
L2578:
    movzx     rax,	byte [rsi+3]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       rdi,	rax
    movzx     rax,	byte [rsi+3]
    mov       r10,	[mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rbx,	rax
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
L2576:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.do_binto_float
mc_auxmcl.do_binto_float:
;?>>
    %define mc_auxmcl.do_binto_float.p 48
   %define R.opc r12
   %define R.px rdi
   %define R.bx rbx
   %define R.cx rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       r12,	rdx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	rax
    xor       edx,	edx
    call      mc_stackmcl.pushpcl_reg
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       rdi,	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    sub       r10,	2
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rbx,	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rsi,	rax
    mov       rcx,	11
    mov       rdx,	rsi
    mov       r8,	rdi
    call      mc_libmcl.genmc
    movzx     rax,	byte [mc_decls.pmode]
    dec       rax
    mov       r10,	r12
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	rsi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rsi
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.do_shiftnto
mc_auxmcl.do_shiftnto:
;?>>
    %define mc_auxmcl.do_shiftnto.p 40
   %define R.opc rsi
   %define R.px rdi
   %define R.cx rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rdx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       rdi,	rax
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	[mc_decls.noperands]
    movzx     rax,	byte [rax + r10-2]
    test      rax,	rax
    jnz       L2582
    lea       rax,	[mc_decls.pclopnd]
    mov       r10,	[mc_decls.noperands]
    mov       rax,	[rax + r10*8-16]
    movzx     rax,	byte [rax+1]
    cmp       rax,	4
    jnz       L2582
    lea       rax,	[mc_decls.pclopnd]
    mov       r10,	[mc_decls.noperands]
    mov       rax,	[rax + r10*8-16]
    mov       rax,	[rax+8]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	rsi
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L2581
L2582:
    mov       al,	[pc_decls.r10used]
    test      al,	al
    jz        L2584
    mov       rcx,	11
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	12
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2584:
    mov       rax,	[mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	3
    mov       r8,	11
    call      mc_stackmcl.loadparam
    mov       rbx,	rax
    mov       rcx,	rsi
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    mov       al,	[pc_decls.r10used]
    test      al,	al
    jz        L2586
    mov       rcx,	11
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	13
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2586:
L2581:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.do_divrem
mc_auxmcl.do_divrem:
;?>>
   %define R.p r15
    %define mc_auxmcl.do_divrem.issigned 80
    %define mc_auxmcl.do_divrem.isdiv 88
   %define R.ax rdi
   %define R.bx rbx
   %define R.px rsi
   %define R.q r12
   %define R.opc r13
   %define R.n r14
    %define mc_auxmcl.do_divrem.shifts -8
    %define mc_auxmcl.do_divrem.fdivto -16
    %define mc_auxmcl.do_divrem.locyy -24
    %define mc_auxmcl.do_divrem.loczz -32
    %define mc_auxmcl.do_divrem.$T1 -40
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	72
    mov       r15,	rcx
    mov       [rbp+80],	rdx
    mov       [rbp+88],	r8
;---------------
    xor       eax,	eax
    mov       [rbp + mc_auxmcl.do_divrem.fdivto],	al
    mov       rax,	[mc_decls.noperands]
    dec       rax
    mov       [rbp + mc_auxmcl.do_divrem.locyy],	rax
    mov       rax,	[mc_decls.noperands]
    mov       [rbp + mc_auxmcl.do_divrem.loczz],	rax
    movzx     rax,	byte [r15]
    cmp       rax,	94
    jz        L2590
    cmp       rax,	95
    jnz       L2589
L2590:
    mov       rax,	[rbp + mc_auxmcl.do_divrem.locyy]
    mov       r10,	[rbp + mc_auxmcl.do_divrem.loczz]
    mov       [rbp + mc_auxmcl.do_divrem.loczz],	rax
    mov       [rbp + mc_auxmcl.do_divrem.locyy],	r10
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[rbp + mc_auxmcl.do_divrem.locyy]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    mov       al,	1
    mov       [rbp + mc_auxmcl.do_divrem.fdivto],	al
    mov       rcx,	rdi
    mov       rdx,	8
    call      mc_libmcl.changeopndsize
    mov       rcx,	12
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mc_stackmcl.makeopndind
    mov       rsi,	rax
    movzx     rax,	byte [mc_decls.pmode]
    movzx     r10,	byte [rdi+10]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_libmcl.mgenreg
    mov       rdi,	rax
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rsi
    call      mc_libmcl.genmc
    jmp       L2588
L2589:
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[rbp + mc_auxmcl.do_divrem.locyy]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
L2588:
    mov       rcx,	[rbp + mc_auxmcl.do_divrem.loczz]
    call      mc_stackmcl.isimmload
    mov       r12,	rax
    test      r12,	r12
    jz        L2592
    mov       rax,	[rbp + mc_auxmcl.do_divrem.isdiv]
    cmp       rax,	1
    jnz       L2592
    mov       r14,	[r12+8]
    mov       rax,	r14
    test      rax,	rax
    jz        L2594
    cmp       rax,	1
    jz        L2595
    jmp       L2596
L2594:
    lea       rcx,	[L12383]
    lea       rdx,	[L12384]
    call      pc_api.merror
    jmp       L2593
L2595:
    call      mc_stackmcl.poppcl
    jmp       L2587
L2596:
    mov       rcx,	r14
    call      mc_libmcl.ispoweroftwo
    mov       [rbp + mc_auxmcl.do_divrem.shifts],	rax
    mov       rax,	[rbp + mc_auxmcl.do_divrem.shifts]
    test      rax,	rax
    jz        L2598
    mov       al,	[rbp + mc_auxmcl.do_divrem.fdivto]
    test      al,	al
    jnz       L2598
    mov       rcx,	[rbp + mc_auxmcl.do_divrem.shifts]
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       [rbp + mc_auxmcl.do_divrem.$T1],	rax
    mov       rax,	[rbp + mc_auxmcl.do_divrem.issigned]
    test      rax,	rax
    jz        L2600
    mov       rax,	44
    jmp       L2599
L2600:
    mov       rax,	45
L2599:
    mov       rcx,	rax
    mov       rdx,	rdi
    mov       r8,	[rbp + mc_auxmcl.do_divrem.$T1]
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    jmp       L2587
L2598:
L2593:
L2592:
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[rbp + mc_auxmcl.do_divrem.loczz]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rbx,	rax
    call      mc_auxmcl.saverdx
    mov       rcx,	[rbp + mc_auxmcl.do_divrem.locyy]
    mov       rdx,	[rbp + mc_auxmcl.do_divrem.loczz]
    call      mc_auxmcl.fixdivopnds
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[rbp + mc_auxmcl.do_divrem.loczz]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rbx,	rax
    mov       rax,	[rbp + mc_auxmcl.do_divrem.issigned]
    test      rax,	rax
    jz        L2602
    movzx     rax,	byte [mc_decls.pmode]
    lea       r10,	[pc_tables.psize]
    movzx     r10,	byte [r10 + rax]
    cmp       r10,	8
    jz        L2604
    cmp       r10,	4
    jz        L2605
    cmp       r10,	2
    jz        L2606
    jmp       L2607
L2604:
    mov       rax,	57
    jmp       L2603
L2605:
    mov       rax,	56
    jmp       L2603
L2606:
    mov       rax,	55
    jmp       L2603
L2607:
    lea       rcx,	[L12385]
    lea       rdx,	[L12386]
    call      pc_api.merror
    xor       eax,	eax
L2603:
    mov       r13,	rax
    mov       rcx,	r13
    xor       edx,	edx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       r13,	36
    jmp       L2601
L2602:
    mov       rcx,	12
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	rax
    call      mc_libmcl.clearreg
    mov       r13,	37
L2601:
    mov       rcx,	r13
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rax,	[rbp + mc_auxmcl.do_divrem.isdiv]
    test      rax,	rax
    jz        L2609
    cmp       rax,	2
    jz        L2610
    jmp       L2611
L2609:
    mov       rcx,	12
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       [rbp + mc_auxmcl.do_divrem.$T1],	rax
    mov       rcx,	1
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	27
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.do_divrem.$T1]
    call      mc_libmcl.genmc
    jmp       L2608
L2610:
    mov       rcx,	12
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	27
    mov       rdx,	rbx
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	2
    call      mc_stackmcl.swapopndregs
    mov       rcx,	[rbp + mc_auxmcl.do_divrem.locyy]
    mov       rdx,	[rbp + mc_auxmcl.do_divrem.loczz]
    call      mc_stackmcl.swapopnds
L2611:
L2608:
    call      mc_auxmcl.restorerdx
    mov       al,	[rbp + mc_auxmcl.do_divrem.fdivto]
    test      al,	al
    jz        L2613
    mov       rcx,	6
    call      mc_stackmcl.getworkregm
    mov       rbx,	rax
    mov       rcx,	13
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[rbp + mc_auxmcl.do_divrem.locyy]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       [rbp + mc_auxmcl.do_divrem.$T1],	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mc_stackmcl.makeopndind
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.do_divrem.$T1]
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
L2613:
    mov       rax,	[rbp + mc_auxmcl.do_divrem.isdiv]
    cmp       rax,	2
    jz        L2615
    call      mc_stackmcl.poppcl
L2615:
L2587:
;---------------
    add       rsp,	72
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.fixdivopnds
mc_auxmcl.fixdivopnds:
;?>>
   %define R.locyy r14
   %define R.loczz r15
   %define R.regx rdi
   %define R.regy rbx
   %define R.zop rsi
   %define R.bx r12
   %define R.ax r13
    %define mc_auxmcl.fixdivopnds.$T1 -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       r14,	rcx
    mov       r15,	rdx
;---------------
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	r14
    movzx     rax,	byte [rax + r10-1]
    mov       rdi,	rax
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	r15
    movzx     rax,	byte [rax + r10-1]
    mov       rbx,	rax
    cmp       rdi,	1
    jz        L2616
L2618:
    mov       rcx,	r14
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       r12,	rax
    mov       rcx,	r15
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       r13,	rax
    cmp       rbx,	1
    jnz       L2620
    mov       rcx,	27
    mov       rdx,	r12
    mov       r8,	r13
    call      mc_libmcl.genmc
    mov       rcx,	r14
    mov       rdx,	r15
    call      mc_stackmcl.swapopnds
    jmp       L2616
L2620:
    lea       rax,	[mc_decls.regset]
    movzx     rax,	byte [rax]
    test      rax,	rax
    jnz       L2622
    mov       rcx,	1
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	27
    mov       rdx,	rax
    mov       r8,	r12
    call      mc_libmcl.genmc
    xor       eax,	eax
    lea       r10,	[mc_decls.regset]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
    mov       al,	1
    lea       r10,	[mc_decls.pclreg]
    mov       r11,	r14
    mov       [r10 + r11-1],	al
    mov       al,	1
    lea       r10,	[mc_decls.regset]
    mov       [r10],	al
    jmp       L2616
L2622:
    mov       rsi,	[mc_decls.noperands]
    cmp       rsi,	1
    jl        L2626
L2623:
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	1
    jnz       L2628
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	1
    jz        L2625
L2628:
    dec       rsi
    cmp       rsi,	1
    jge       L2623
L2626:
    jmp       L2616
L2625:
    mov       rcx,	r14
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       [rbp + mc_auxmcl.fixdivopnds.$T1],	rax
    mov       rcx,	1
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	27
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.fixdivopnds.$T1]
    call      mc_libmcl.genmc
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	r14
    lea       rax,	[rax + r10-1]
    lea       r10,	[mc_decls.pclreg]
    mov       r11,	rsi
    lea       r10,	[r10 + r11-1]
    mov       r11b,	[rax]
    mov       r9b,	[r10]
    mov       [r10],	r11b
    mov       [rax],	r9b
L2616:
;---------------
    add       rsp,	40
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.saverdx
mc_auxmcl.saverdx:
;?>>
;?]]
    sub       rsp,	40
;---------------
    mov       al,	[pc_decls.r11used]
    test      al,	al
    jz        L2631
    mov       rcx,	12
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	12
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2631:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mc_auxmcl.restorerdx
mc_auxmcl.restorerdx:
;?>>
;?]]
    sub       rsp,	40
;---------------
    mov       al,	[pc_decls.r11used]
    test      al,	al
    jz        L2634
    mov       rcx,	12
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	13
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2634:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mc_auxmcl.clearblock
mc_auxmcl.clearblock:
;?>>
    %define mc_auxmcl.clearblock.ax 64
    %define mc_auxmcl.clearblock.n 72
   %define R.rx rdi
   %define R.rcount rbx
   %define R.nwords rsi
   %define R.lab r12
   %define R.oddbytes r13
   %define R.offset r14
    %define mc_auxmcl.clearblock.countreg -8
    %define mc_auxmcl.clearblock.av_1 -16
    %define mc_auxmcl.clearblock.i -24
    %define mc_auxmcl.clearblock.$T1 -32
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+64],	rcx
    mov       [rbp+72],	rdx
;---------------
    mov       rax,	[rbp + mc_auxmcl.clearblock.n]
    mov       r10,	8
    cqo       
    idiv      r10
    xchg      rax,	rdx
    mov       r13,	rax
    mov       rax,	r13
    sub       [rbp + mc_auxmcl.clearblock.n],	rax
    mov       rax,	[rbp + mc_auxmcl.clearblock.n]
    sar       rax,	3
    mov       rsi,	rax
    mov       rcx,	6
    call      mc_stackmcl.getworkregm
    mov       rdi,	rax
    mov       rcx,	rdi
    call      mc_libmcl.clearreg
    xor       r14,	r14
    mov       rax,	rsi
    cmp       rax,	1
    jl        L2637
    cmp       rax,	8
    jg        L2637
    mov       rcx,	[rbp + mc_auxmcl.clearblock.ax]
    mov       rdx,	8
    call      mc_libmcl.changeopndsize
    mov       [rbp + mc_auxmcl.clearblock.ax],	rax
    mov       [rbp + mc_auxmcl.clearblock.av_1],	rsi
    mov       rax,	[rbp + mc_auxmcl.clearblock.av_1]
    cmp       rax,	0
    jle       L2640
L2638:
    mov       rcx,	[rbp + mc_auxmcl.clearblock.ax]
    mov       rdx,	r14
    xor       r8d,	r8d
    call      mc_libmcl.applyoffset
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rax,	8
    add       r14,	rax
    dec       qword [rbp + mc_auxmcl.clearblock.av_1]
    jnz       L2638
L2640:
    jmp       L2636
L2637:
    test      rsi,	rsi
    jz        L2641
    mov       rax,	rsi
    and       rax,	3
    jz        L2643
    call      mc_stackmcl.getworkireg
    mov       r10,	rax
    mov       [rbp + mc_auxmcl.clearblock.countreg],	r10
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rbx,	rax
    inc       qword [pc_api.mlabelno]
    mov       r12,	[pc_api.mlabelno]
    mov       rcx,	[rbp + mc_auxmcl.clearblock.ax]
    call      mc_stackmcl.makesimpleaddr
    mov       [rbp + mc_auxmcl.clearblock.ax],	rax
    mov       rcx,	rsi
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	11
    mov       rdx,	rbx
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	r12
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	11
    mov       rdx,	[rbp + mc_auxmcl.clearblock.ax]
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rcx,	8
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       [rbp + mc_auxmcl.clearblock.$T1],	rax
    mov       rax,	[rbp + mc_auxmcl.clearblock.ax]
    movzx     rax,	byte [rax+10]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	28
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.clearblock.$T1]
    call      mc_libmcl.genmc
    mov       rcx,	53
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	r12
    call      mc_libmcl.mgenlabel
    mov       rcx,	26
    mov       rdx,	5
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    xor       r14,	r14
    jmp       L2642
L2643:
    call      mc_stackmcl.getworkireg
    mov       r10,	rax
    mov       [rbp + mc_auxmcl.clearblock.countreg],	r10
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rbx,	rax
    inc       qword [pc_api.mlabelno]
    mov       r12,	[pc_api.mlabelno]
    mov       rcx,	[rbp + mc_auxmcl.clearblock.ax]
    call      mc_stackmcl.makesimpleaddr
    mov       [rbp + mc_auxmcl.clearblock.ax],	rax
    mov       rax,	rsi
    sar       rax,	2
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	11
    mov       rdx,	rbx
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	r12
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rax,	1
    mov       [rbp + mc_auxmcl.clearblock.i],	rax
L2644:
    mov       rcx,	[rbp + mc_auxmcl.clearblock.ax]
    mov       rdx,	r14
    xor       r8d,	r8d
    call      mc_libmcl.applyoffset
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rax,	8
    add       r14,	rax
    mov       rax,	[rbp + mc_auxmcl.clearblock.i]
    inc       rax
    mov       [rbp + mc_auxmcl.clearblock.i],	rax
    cmp       rax,	4
    jle       L2644
    mov       rcx,	32
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       [rbp + mc_auxmcl.clearblock.$T1],	rax
    mov       rax,	[rbp + mc_auxmcl.clearblock.ax]
    movzx     rax,	byte [rax+10]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	28
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.clearblock.$T1]
    call      mc_libmcl.genmc
    mov       rcx,	53
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	r12
    call      mc_libmcl.mgenlabel
    mov       rcx,	26
    mov       rdx,	5
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    xor       r14,	r14
L2642:
L2641:
L2636:
    test      r13,	r13
    jz        L2648
    mov       [rbp + mc_auxmcl.clearblock.n],	r13
    mov       rax,	[rbp + mc_auxmcl.clearblock.n]
    cmp       rax,	4
    jl        L2650
    mov       rcx,	rdi
    mov       rdx,	4
    call      mc_libmcl.changeopndsize
    mov       rdi,	rax
    mov       rcx,	[rbp + mc_auxmcl.clearblock.ax]
    mov       rdx,	r14
    mov       r8,	4
    call      mc_libmcl.applyoffset
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rax,	4
    sub       [rbp + mc_auxmcl.clearblock.n],	rax
    mov       rax,	4
    add       r14,	rax
L2650:
    mov       rax,	[rbp + mc_auxmcl.clearblock.n]
    cmp       rax,	2
    jl        L2652
    mov       rcx,	rdi
    mov       rdx,	2
    call      mc_libmcl.changeopndsize
    mov       rdi,	rax
    mov       rcx,	[rbp + mc_auxmcl.clearblock.ax]
    mov       rdx,	r14
    mov       r8,	2
    call      mc_libmcl.applyoffset
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rax,	2
    sub       [rbp + mc_auxmcl.clearblock.n],	rax
    mov       rax,	2
    add       r14,	rax
L2652:
    mov       rax,	[rbp + mc_auxmcl.clearblock.n]
    cmp       rax,	1
    jnz       L2654
    mov       rcx,	rdi
    mov       rdx,	1
    call      mc_libmcl.changeopndsize
    mov       rdi,	rax
    mov       rcx,	[rbp + mc_auxmcl.clearblock.ax]
    mov       rdx,	r14
    mov       r8,	1
    call      mc_libmcl.applyoffset
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	rdi
    call      mc_libmcl.genmc
L2654:
L2648:
;---------------
    add       rsp,	64
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.do_blockdata
mc_auxmcl.do_blockdata:
;?>>
   %define R.p r14
   %define R.d rdi
   %define R.n rbx
   %define R.nwords rsi
   %define R.r r12
   %define R.av_1 r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       r14,	rcx
;---------------
    mov       eax,	[r14+4]
    mov       rbx,	rax
    test      rbx,	rbx
    jnz       L2657
    jmp       L2655
L2657:
    mov       rax,	rbx
    sar       rax,	3
    mov       rsi,	rax
    mov       rdi,	[r14+8]
    mov       r13,	rsi
    cmp       r13,	0
    jle       L2660
L2658:
    mov       rax,	rdi
    add       rdi,	8
    mov       rax,	[rax]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	119
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    dec       r13
    jnz       L2658
L2660:
    mov       rax,	rsi
    shl       rax,	3
    mov       r10,	rbx
    sub       r10,	rax
    mov       r12,	r10
    test      r12,	r12
    jz        L2662
    mov       rcx,	rdi
    mov       rdx,	r12
    mov       r8,	66
    call      mc_auxmcl.genstring_db
L2662:
    lea       rcx,	[L12387]
    call      mc_libmcl.mgencomment
L2655:
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.copyblock
mc_auxmcl.copyblock:
;?>>
   %define R.ax r13
   %define R.bx r14
    %define mc_auxmcl.copyblock.n 88
    %define mc_auxmcl.copyblock.savedest 96
   %define R.rx rdi
   %define R.rcount rbx
   %define R.nwords rsi
   %define R.lab r12
    %define mc_auxmcl.copyblock.oddbytes -8
    %define mc_auxmcl.copyblock.offset -16
    %define mc_auxmcl.copyblock.axreg -24
    %define mc_auxmcl.copyblock.saved -32
    %define mc_auxmcl.copyblock.av_1 -40
    %define mc_auxmcl.copyblock.$T1 -48
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	88
    mov       r13,	rcx
    mov       r14,	rdx
    mov       [rbp+88],	r8
    mov       [rbp+96],	r9
;---------------
    xor       eax,	eax
    mov       [rbp + mc_auxmcl.copyblock.saved],	al
    mov       rax,	[rbp + mc_auxmcl.copyblock.n]
    cmp       rax,	16
    jnz       L2665
    mov       rcx,	2
    call      mc_stackmcl.getworkregm
    mov       rdi,	rax
    mov       rcx,	91
    mov       rdx,	rdi
    mov       r8,	r14
    call      mc_libmcl.genmc
    mov       rcx,	91
    mov       rdx,	r13
    mov       r8,	rdi
    call      mc_libmcl.genmc
    jmp       L2663
L2665:
    mov       rax,	[rbp + mc_auxmcl.copyblock.n]
    mov       r10,	8
    cqo       
    idiv      r10
    xchg      rax,	rdx
    mov       [rbp + mc_auxmcl.copyblock.oddbytes],	rax
    mov       rax,	[rbp + mc_auxmcl.copyblock.oddbytes]
    sub       [rbp + mc_auxmcl.copyblock.n],	rax
    mov       rax,	[rbp + mc_auxmcl.copyblock.n]
    sar       rax,	3
    mov       rsi,	rax
    mov       rcx,	6
    call      mc_stackmcl.getworkregm
    mov       rdi,	rax
    xor       eax,	eax
    mov       [rbp + mc_auxmcl.copyblock.offset],	rax
    mov       rax,	rsi
    cmp       rax,	1
    jl        L2667
    cmp       rax,	4
    jg        L2667
    mov       rcx,	r13
    mov       rdx,	8
    call      mc_libmcl.changeopndsize
    mov       r13,	rax
    mov       rcx,	r14
    mov       rdx,	8
    call      mc_libmcl.changeopndsize
    mov       r14,	rax
    mov       [rbp + mc_auxmcl.copyblock.av_1],	rsi
    mov       rax,	[rbp + mc_auxmcl.copyblock.av_1]
    cmp       rax,	0
    jle       L2670
L2668:
    mov       rcx,	r14
    mov       rdx,	[rbp + mc_auxmcl.copyblock.offset]
    xor       r8d,	r8d
    call      mc_libmcl.applyoffset
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	r13
    mov       rdx,	[rbp + mc_auxmcl.copyblock.offset]
    xor       r8d,	r8d
    call      mc_libmcl.applyoffset
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rax,	8
    add       [rbp + mc_auxmcl.copyblock.offset],	rax
    dec       qword [rbp + mc_auxmcl.copyblock.av_1]
    jnz       L2668
L2670:
    jmp       L2666
L2667:
    test      rsi,	rsi
    jz        L2671
    mov       rcx,	6
    call      mc_stackmcl.getworkregm
    mov       rbx,	rax
    inc       qword [pc_api.mlabelno]
    mov       r12,	[pc_api.mlabelno]
    mov       rax,	[rbp + mc_auxmcl.copyblock.savedest]
    test      rax,	rax
    jz        L2673
    movzx     rax,	byte [r13+10]
    mov       [rbp + mc_auxmcl.copyblock.axreg],	rax
    mov       rcx,	[rbp + mc_auxmcl.copyblock.axreg]
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	12
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       al,	1
    mov       [rbp + mc_auxmcl.copyblock.saved],	al
L2673:
    mov       rcx,	r13
    call      mc_stackmcl.makesimpleaddr
    mov       r13,	rax
    mov       rcx,	r14
    call      mc_stackmcl.makesimpleaddr
    mov       r14,	rax
    lea       rax,	[r13+8]
    mov       r10w,	8
    mov       r15w,	[rax]
    mov       r11,	-32
    and       r15w,	r11w
    or        r15w,	r10w
    mov       [rax],	r15w
    mov       rcx,	rsi
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	11
    mov       rdx,	rbx
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	r12
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	r14
    call      mc_libmcl.genmc
    mov       rcx,	11
    mov       rdx,	r13
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rcx,	8
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       [rbp + mc_auxmcl.copyblock.$T1],	rax
    movzx     rax,	byte [r13+10]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	28
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.copyblock.$T1]
    call      mc_libmcl.genmc
    mov       rcx,	8
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       [rbp + mc_auxmcl.copyblock.$T1],	rax
    movzx     rax,	byte [r14+10]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	28
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.copyblock.$T1]
    call      mc_libmcl.genmc
    mov       rcx,	53
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	r12
    call      mc_libmcl.mgenlabel
    mov       rcx,	26
    mov       rdx,	5
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    xor       eax,	eax
    mov       [rbp + mc_auxmcl.copyblock.offset],	rax
L2671:
L2666:
    mov       rax,	[rbp + mc_auxmcl.copyblock.oddbytes]
    test      rax,	rax
    jz        L2675
    mov       rax,	[rbp + mc_auxmcl.copyblock.oddbytes]
    mov       [rbp + mc_auxmcl.copyblock.n],	rax
    mov       rax,	[rbp + mc_auxmcl.copyblock.n]
    cmp       rax,	4
    jl        L2677
    mov       rcx,	rdi
    mov       rdx,	4
    call      mc_libmcl.changeopndsize
    mov       rdi,	rax
    mov       rcx,	r14
    mov       rdx,	[rbp + mc_auxmcl.copyblock.offset]
    mov       r8,	4
    call      mc_libmcl.applyoffset
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	r13
    mov       rdx,	[rbp + mc_auxmcl.copyblock.offset]
    mov       r8,	4
    call      mc_libmcl.applyoffset
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rax,	4
    sub       [rbp + mc_auxmcl.copyblock.n],	rax
    mov       rax,	4
    add       [rbp + mc_auxmcl.copyblock.offset],	rax
L2677:
    mov       rax,	[rbp + mc_auxmcl.copyblock.n]
    cmp       rax,	2
    jl        L2679
    mov       rcx,	rdi
    mov       rdx,	2
    call      mc_libmcl.changeopndsize
    mov       rdi,	rax
    mov       rcx,	r14
    mov       rdx,	[rbp + mc_auxmcl.copyblock.offset]
    mov       r8,	2
    call      mc_libmcl.applyoffset
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	r13
    mov       rdx,	[rbp + mc_auxmcl.copyblock.offset]
    mov       r8,	2
    call      mc_libmcl.applyoffset
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rax,	2
    sub       [rbp + mc_auxmcl.copyblock.n],	rax
    mov       rax,	2
    add       [rbp + mc_auxmcl.copyblock.offset],	rax
L2679:
    mov       rax,	[rbp + mc_auxmcl.copyblock.n]
    cmp       rax,	1
    jnz       L2681
    mov       rcx,	rdi
    mov       rdx,	1
    call      mc_libmcl.changeopndsize
    mov       rdi,	rax
    mov       rcx,	r14
    mov       rdx,	[rbp + mc_auxmcl.copyblock.offset]
    mov       r8,	1
    call      mc_libmcl.applyoffset
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	r13
    mov       rdx,	[rbp + mc_auxmcl.copyblock.offset]
    mov       r8,	1
    call      mc_libmcl.applyoffset
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	rdi
    call      mc_libmcl.genmc
L2681:
L2675:
    mov       al,	[rbp + mc_auxmcl.copyblock.saved]
    test      al,	al
    jz        L2683
    mov       rcx,	[rbp + mc_auxmcl.copyblock.axreg]
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	13
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2683:
L2663:
;---------------
    add       rsp,	88
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.genstringtable
mc_auxmcl.genstringtable:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
;---------------
    mov       rax,	[mc_decls.cstringlist]
    test      rax,	rax
    jz        L2684
L2686:
    lea       rcx,	[L12388]
    call      mc_libmcl.mgencomment
    mov       rcx,	73
    mov       rdx,	8
    call      mc_libmcl.setsegment
    mov       rax,	[mc_decls.kk0used]
    test      rax,	rax
    jz        L2688
    mov       rcx,	[mc_decls.kk0used]
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    xor       ecx,	ecx
    call      mc_auxmcl.gendb
L2688:
    mov       rdi,	[mc_decls.cstringlist]
    jmp       L2692
L2689:
    mov       rax,	[rdi+16]
    mov       rcx,	rax
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rax,	[rdi]
    mov       rcx,	rax
    mov       rdx,	-1
    xor       r8d,	r8d
    call      mc_auxmcl.genstring_db
    mov       rdi,	[rdi+8]
L2692:
    test      rdi,	rdi
    jnz       L2689
L2684:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.genstring_db
mc_auxmcl.genstring_db:
;?>>
   %define R.s r13
   %define R.length r14
   %define R.strtype r15
   %define R.c rdi
   %define R.seqlen rbx
   %define R.seq rsi
   %define R.av_1 r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    sub       rsp,	48
    mov       r13,	rcx
    mov       r14,	rdx
    mov       r15,	r8
;---------------
    cmp       r14,	-1
    jnz       L2695
    mov       rcx,	r13
    call      strlen
    mov       r14,	rax
L2695:
    test      r14,	r14
    jnz       L2697
    xor       ecx,	ecx
    call      mc_auxmcl.gendb
    jmp       L2693
L2697:
    xor       rbx,	rbx
    mov       rax,	r14
    mov       r12,	rax
    cmp       r12,	0
    jle       L2700
L2698:
    mov       rax,	r13
    inc       r13
    movzx     rax,	byte [rax]
    mov       rdi,	rax
    cmp       rdi,	32
    jl        L2703
    cmp       rdi,	127
    jge       L2703
    mov       rax,	rdi
    cmp       rax,	34
    jz        L2704
    cmp       rax,	92
    jnz       L2702
L2704:
L2703:
    test      rbx,	rbx
    jz        L2706
    mov       rcx,	rsi
    mov       rdx,	rbx
    call      mc_auxmcl.gendbstring
    xor       rbx,	rbx
L2706:
    mov       rcx,	rdi
    call      mc_auxmcl.gendb
    jmp       L2701
L2702:
    test      rbx,	rbx
    jnz       L2708
    mov       rbx,	1
    lea       rax,	[r13-1]
    mov       rsi,	rax
    jmp       L2707
L2708:
    inc       rbx
L2707:
L2701:
    dec       r12
    jnz       L2698
L2700:
    test      rbx,	rbx
    jz        L2710
    mov       rcx,	rsi
    mov       rdx,	rbx
    call      mc_auxmcl.gendbstring
L2710:
    test      r15,	r15
    jnz       L2712
    xor       ecx,	ecx
    call      mc_auxmcl.gendb
L2712:
L2693:
;---------------
    add       rsp,	48
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.gendb
mc_auxmcl.gendb:
;?>>
   %define R.a rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	116
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.gendbstring
mc_auxmcl.gendbstring:
;?>>
   %define R.s rdi
   %define R.length rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_libmcl.mgenstring
    mov       rcx,	116
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.gendq
mc_auxmcl.gendq:
;?>>
   %define R.a rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	119
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.genrealtable
mc_auxmcl.genrealtable:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
;---------------
    mov       rax,	[mc_decls.creallist]
    test      rax,	rax
    jnz       L2718
    mov       rax,	[mc_decls.cr32list]
    test      rax,	rax
    jz        L2716
L2718:
    lea       rcx,	[L12389]
    call      mc_libmcl.mgencomment
    mov       rcx,	73
    mov       rdx,	8
    call      mc_libmcl.setsegment
    mov       rdi,	[mc_decls.creallist]
    jmp       L2722
L2719:
    mov       rax,	[rdi+16]
    mov       rcx,	rax
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    movq      XMM4,	[rdi]
    comisd    XMM4,	[L12390]
    jnz       L2724
    movq      XMM4,	[rdi]
    movq      rax,	XMM4
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	119
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L2723
L2724:
    movq      XMM4,	[rdi]
    movq      XMM0,	XMM4
    mov       rdx,	2
    call      mc_libmcl.mgenrealimm
    mov       rcx,	119
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2723:
    mov       rdi,	[rdi+8]
L2722:
    test      rdi,	rdi
    jnz       L2719
    lea       rcx,	[L12391]
    call      mc_libmcl.mgencomment
    mov       rdi,	[mc_decls.cr32list]
    jmp       L2728
L2725:
    mov       rax,	[rdi+16]
    mov       rcx,	rax
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    movq      XMM4,	[rdi]
    comisd    XMM4,	[L12392]
    jnz       L2730
    movq      XMM4,	[rdi]
    cvtsd2ss  XMM4,	XMM4
    movq      rax,	XMM4
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	118
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L2729
L2730:
    movq      XMM4,	[rdi]
    movq      XMM0,	XMM4
    mov       rdx,	1
    call      mc_libmcl.mgenrealimm
    mov       rcx,	118
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2729:
    mov       rdi,	[rdi+8]
L2728:
    test      rdi,	rdi
    jnz       L2725
L2716:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.genabsneg
mc_auxmcl.genabsneg:
;?>>
;?]]
    sub       rsp,	40
;---------------
    mov       rax,	[mc_decls.lababs32]
    add       rax,	[mc_decls.lababs64]
    add       rax,	[mc_decls.labneg32]
    add       rax,	[mc_decls.labneg64]
    test      rax,	rax
    jz        L2733
    mov       rcx,	73
    mov       rdx,	16
    call      mc_libmcl.setsegment
L2733:
    mov       rax,	[mc_decls.lababs32]
    test      rax,	rax
    jz        L2735
    lea       rcx,	[L12393]
    call      mc_libmcl.mgencomment
    mov       rcx,	[mc_decls.lababs32]
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	9223372034707292159
    call      mc_auxmcl.gendq
    mov       rcx,	9223372034707292159
    call      mc_auxmcl.gendq
L2735:
    mov       rax,	[mc_decls.lababs64]
    test      rax,	rax
    jz        L2737
    lea       rcx,	[L12394]
    call      mc_libmcl.mgencomment
    mov       rcx,	[mc_decls.lababs64]
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	9223372036854775807
    call      mc_auxmcl.gendq
    mov       rcx,	9223372036854775807
    call      mc_auxmcl.gendq
L2737:
    mov       rax,	[mc_decls.labneg32]
    test      rax,	rax
    jz        L2739
    lea       rcx,	[L12395]
    call      mc_libmcl.mgencomment
    mov       rcx,	[mc_decls.labneg32]
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	-9223372034707292160
    call      mc_auxmcl.gendq
    mov       rcx,	-9223372034707292160
    call      mc_auxmcl.gendq
L2739:
    mov       rax,	[mc_decls.labneg64]
    test      rax,	rax
    jz        L2741
    lea       rcx,	[L12396]
    call      mc_libmcl.mgencomment
    mov       rcx,	[mc_decls.labneg64]
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	-9223372036854775808
    call      mc_auxmcl.gendq
    mov       rcx,	-9223372036854775808
    call      mc_auxmcl.gendq
L2741:
    mov       rax,	[mc_decls.labzero]
    test      rax,	rax
    jz        L2743
    lea       rcx,	[L12397]
    call      mc_libmcl.mgencomment
    mov       rcx,	[mc_decls.labzero]
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    xor       ecx,	ecx
    call      mc_auxmcl.gendq
L2743:
    mov       rax,	[mc_decls.labmask63]
    test      rax,	rax
    jz        L2745
    lea       rcx,	[L12398]
    call      mc_libmcl.mgencomment
    mov       rcx,	[mc_decls.labmask63]
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	9223372036854775807
    call      mc_auxmcl.gendq
    mov       rcx,	[mc_decls.laboffset64]
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	4890909195324358656
    call      mc_auxmcl.gendq
L2745:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mc_auxmcl.do_maths
mc_auxmcl.do_maths:
;?>>
   %define R.p rdi
   %define R.opname rbx
   %define R.nargs rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    mov       rcx,	rdi
    mov       rdx,	rbx
    xor       r8d,	r8d
    mov       r9,	rsi
    call      mc_auxmcl.do_callrts
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.do_host
mc_auxmcl.do_host:
;?>>
   %define R.p rdi
   %define R.d rbx
   %define R.nargs rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    mov       rcx,	rdi
    xor       edx,	edx
    mov       r8,	rbx
    mov       r9,	rsi
    call      mc_auxmcl.do_callrts
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.do_callrts
mc_auxmcl.do_callrts:
;?>>
   %define R.p rsi
   %define R.opname r12
   %define R.d r13
   %define R.nargs r14
   %define R.slots rdi
   %define R.av_1 rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
    mov       r14,	r9
;---------------
    mov       rcx,	r14
    call      mc_stackmcl.saveopnds
    xor       rdi,	rdi
    mov       eax,	[mc_decls.mstackdepth]
    and       eax,	1
    test      rax,	rax
    jz        L2750
    mov       rcx,	1
    call      mc_libmcl.pushslots
    mov       rdi,	1
L2750:
    mov       rcx,	r14
    xor       edx,	edx
    xor       r8d,	r8d
    call      mc_auxmcl.do_pushlowargs
    mov       rax,	[mc_decls.mstackdepth]
    test      rax,	rax
    jz        L2752
    mov       rax,	4
    add       rdi,	rax
    mov       rcx,	4
    call      mc_libmcl.pushslots
    jmp       L2751
L2752:
    mov       al,	1
    mov       [pc_decls.localshadow],	al
L2751:
    test      r12,	r12
    jz        L2754
    mov       rcx,	r12
    call      mc_libmcl.mgenextname
    mov       rcx,	21
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L2753
L2754:
    mov       rcx,	r13
    call      mc_libmcl.mgenmemaddr
    mov       rcx,	21
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2753:
    mov       rbx,	r14
    cmp       rbx,	0
    jle       L2757
L2755:
    call      mc_stackmcl.poppcl
    dec       rbx
    jnz       L2755
L2757:
    test      rdi,	rdi
    jz        L2759
    mov       rcx,	rdi
    call      mc_libmcl.popslots
L2759:
    mov       rcx,	rsi
    call      mc_auxmcl.do_getretvalue
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.do_max_int
mc_auxmcl.do_max_int:
;?>>
   %define R.cond rsi
   %define R.ax rdi
   %define R.bx rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rbx,	rax
    mov       rcx,	42
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    mov       rcx,	15
    mov       rdx,	rsi
    mov       r8,	rdi
    mov       r9,	rbx
    call      mc_libmcl.genmc_cond
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.do_max_float
mc_auxmcl.do_max_float:
;?>>
   %define R.opc rsi
   %define R.ax rdi
   %define R.bx rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rbx,	rax
    mov       rcx,	rsi
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.do_maxto_int
mc_auxmcl.do_maxto_int:
;?>>
   %define R.cond r13
    %define mc_auxmcl.do_maxto_int.mode 64
   %define R.ax rdi
   %define R.bx rbx
   %define R.lx rsi
   %define R.lab r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r13,	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       rdi,	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rbx,	rax
    mov       rcx,	42
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    inc       qword [pc_api.mlabelno]
    mov       r12,	[pc_api.mlabelno]
    mov       rcx,	r12
    call      mc_libmcl.mgenlabel
    mov       r10,	rax
    mov       rsi,	r10
    mov       rcx,	26
    mov       rdx,	r13
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    mov       rcx,	9
    mov       rdx,	rsi
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.do_maxto_real
mc_auxmcl.do_maxto_real:
;?>>
   %define R.cond r14
    %define mc_auxmcl.do_maxto_real.mode 72
   %define R.px rdi
   %define R.ax rbx
   %define R.bx rsi
   %define R.lx r12
   %define R.lab r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       r14,	rcx
    mov       [rbp+72],	rdx
;---------------
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	[rbp + mc_auxmcl.do_maxto_real.mode]
    call      mc_stackmcl.getopnd_ind
    mov       rdi,	rax
    mov       rax,	[mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_auxmcl.do_maxto_real.mode]
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rsi,	rax
    mov       rcx,	[rbp + mc_auxmcl.do_maxto_real.mode]
    xor       edx,	edx
    call      mc_stackmcl.pushpcl_reg
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rbx,	rax
    mov       rcx,	11
    mov       rdx,	rbx
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rax,	[rbp + mc_auxmcl.do_maxto_real.mode]
    dec       rax
    mov       r10,	73
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mc_libmcl.genmc
    inc       qword [pc_api.mlabelno]
    mov       r13,	[pc_api.mlabelno]
    mov       rcx,	r13
    call      mc_libmcl.mgenlabel
    mov       r10,	rax
    mov       r12,	r10
    mov       rcx,	26
    mov       rdx,	r14
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rsi
    call      mc_libmcl.genmc
    mov       rcx,	9
    mov       rdx,	r12
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	32
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.do_negreal
mc_auxmcl.do_negreal:
;?>>
   %define R.ax rdi
    %define mc_auxmcl.do_negreal.mode 32
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    dec       rax
    test      rax,	rax
    jz        L2766
    mov       rax,	[mc_decls.labneg64]
    test      rax,	rax
    jnz       L2768
    call      mc_libmcl.mcreatefwdlabel
    mov       [mc_decls.labneg64],	rax
L2768:
    mov       rcx,	[mc_decls.labneg64]
    call      mc_libmcl.mgenlabelmem
    mov       rcx,	77
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L2765
L2766:
    mov       rax,	[mc_decls.labneg32]
    test      rax,	rax
    jnz       L2770
    call      mc_libmcl.mcreatefwdlabel
    mov       [mc_decls.labneg32],	rax
L2770:
    mov       rcx,	[mc_decls.labneg32]
    call      mc_libmcl.mgenlabelmem
    mov       rcx,	76
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
L2765:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.do_absreal
mc_auxmcl.do_absreal:
;?>>
   %define R.ax rdi
    %define mc_auxmcl.do_absreal.mode 32
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    dec       rax
    test      rax,	rax
    jz        L2773
    mov       rax,	[mc_decls.lababs64]
    test      rax,	rax
    jnz       L2775
    call      mc_libmcl.mcreatefwdlabel
    mov       [mc_decls.lababs64],	rax
L2775:
    mov       rcx,	[mc_decls.lababs64]
    call      mc_libmcl.mgenlabelmem
    mov       rcx,	79
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L2772
L2773:
    mov       rax,	[mc_decls.lababs32]
    test      rax,	rax
    jnz       L2777
    call      mc_libmcl.mcreatefwdlabel
    mov       [mc_decls.lababs32],	rax
L2777:
    mov       rcx,	[mc_decls.lababs32]
    call      mc_libmcl.mgenlabelmem
    mov       rcx,	78
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
L2772:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.do_loadbf_const
mc_auxmcl.do_loadbf_const:
;?>>
    %define mc_auxmcl.do_loadbf_const.p 56
   %define R.i r12
   %define R.j r13
   %define R.ax rdi
   %define R.mx rbx
   %define R.mask rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r12,	rdx
    mov       r13,	r8
;---------------
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    sub       r10,	2
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    cmp       r13,	63
    jnz       L2780
    mov       rcx,	r12
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	44
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L2779
L2780:
    test      r12,	r12
    jz        L2782
    mov       rcx,	r12
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	45
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
L2782:
    mov       rax,	r13
    sub       rax,	r12
    inc       rax
    mov       r10,	-1
    mov       cl,	al
    shl       r10,	cl
    not       r10
    mov       rsi,	r10
    cmp       rsi,	2147483647
    ja        L2784
    mov       rcx,	rsi
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	38
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L2783
L2784:
    mov       rax,	[mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rbx,	rax
    mov       rcx,	rsi
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	11
    mov       rdx,	rbx
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	38
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
L2783:
L2779:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.do_loadbf_var
mc_auxmcl.do_loadbf_var:
;?>>
    %define mc_auxmcl.do_loadbf_var.p 16
;?]]
    sub       rsp,	40
;---------------
    lea       rcx,	[L12399]
    lea       rdx,	[L12400]
    call      pc_api.merror
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mc_auxmcl.do_storebit
mc_auxmcl.do_storebit:
;?>>
    %define mc_auxmcl.do_storebit.p 72
   %define R.px rdi
   %define R.ax rbx
   %define R.cx rsi
   %define R.ix r12
   %define R.q r13
   %define R.r r14
   %define R.i r15
    %define mc_auxmcl.do_storebit.offset -8
    %define mc_auxmcl.do_storebit.mask1s -16
    %define mc_auxmcl.do_storebit.mask0s -24
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
;---------------
    mov       rcx,	[mc_decls.noperands]
    call      mc_stackmcl.isimmload
    mov       r13,	rax
    mov       rax,	[mc_decls.noperands]
    sub       rax,	2
    mov       rcx,	rax
    call      mc_stackmcl.isimmload
    mov       r14,	rax
    test      r13,	r13
    jz        L2788
    mov       rax,	[mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	3
    call      mc_stackmcl.getopnd_ind
    mov       rdi,	rax
    mov       r15,	[r13+8]
    mov       rax,	r15
    sar       rax,	3
    mov       [rbp + mc_auxmcl.do_storebit.offset],	rax
    mov       rax,	7
    and       r15,	rax
    mov       rcx,	rdi
    mov       rdx,	[rbp + mc_auxmcl.do_storebit.offset]
    xor       r8d,	r8d
    call      mc_libmcl.applyoffset
    mov       rdi,	rax
    mov       rax,	1
    mov       cl,	r15b
    shl       rax,	cl
    mov       [rbp + mc_auxmcl.do_storebit.mask0s],	al
    mov       rax,	1
    mov       cl,	r15b
    shl       rax,	cl
    not       rax
    mov       [rbp + mc_auxmcl.do_storebit.mask1s],	al
    test      r14,	r14
    jz        L2790
    mov       rax,	[r14+8]
    test      rax,	rax
    jnz       L2792
    movzx     rax,	byte [mc_decls.pmode]
    movzx     r10,	byte [rbp + mc_auxmcl.do_storebit.mask1s]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_libmcl.mgenint
    mov       rcx,	38
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L2791
L2792:
    movzx     rax,	byte [mc_decls.pmode]
    movzx     r10,	byte [rbp + mc_auxmcl.do_storebit.mask0s]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_libmcl.mgenint
    mov       rcx,	39
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
L2791:
    jmp       L2789
L2790:
    mov       rax,	[mc_decls.noperands]
    sub       rax,	2
    mov       rcx,	rax
    mov       rdx,	3
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rbx,	rax
    movzx     rax,	byte [mc_decls.pmode]
    movzx     r10,	byte [rbp + mc_auxmcl.do_storebit.mask1s]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_libmcl.mgenint
    mov       rcx,	38
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    test      r15,	r15
    jz        L2794
    mov       rcx,	r15
    mov       rdx,	3
    call      mc_libmcl.mgenint
    mov       rcx,	43
    mov       rdx,	rbx
    mov       r8,	rax
    call      mc_libmcl.genmc
L2794:
    mov       rcx,	39
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
L2789:
    jmp       L2787
L2788:
    test      r14,	r14
    jz        L2795
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       rdi,	rax
    test      r13,	r13
    jnz       L2797
    mov       rcx,	6
    call      mc_stackmcl.getworkregm
    mov       rbx,	rax
    mov       rcx,	1
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	11
    mov       rdx,	rbx
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	11
    mov       rdx,	6
    call      mc_libmcl.mgenreg
    mov       rsi,	rax
    mov       al,	[pc_decls.r10used]
    test      al,	al
    jz        L2799
    mov       rcx,	12
    mov       rdx,	rsi
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2799:
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	10
    mov       r8,	11
    call      mc_stackmcl.loadparam
    mov       r12,	rax
    mov       rcx,	rsi
    mov       rdx,	1
    call      mc_libmcl.changeopndsize
    mov       rcx,	43
    mov       rdx,	rbx
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       al,	[pc_decls.r10used]
    test      al,	al
    jz        L2801
    mov       rcx,	13
    mov       rdx,	rsi
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2801:
    mov       rax,	[r14+8]
    test      rax,	rax
    jnz       L2803
    mov       rcx,	51
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	38
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    jmp       L2802
L2803:
    mov       rcx,	39
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
L2802:
    jmp       L2796
L2797:
    lea       rcx,	[L12401]
    lea       rdx,	[L12402]
    call      pc_api.merror
L2796:
    jmp       L2787
L2795:
    lea       rcx,	[L12403]
    lea       rdx,	[L12404]
    call      pc_api.merror
L2787:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	56
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.do_storebf
mc_auxmcl.do_storebf:
;?>>
    %define mc_auxmcl.do_storebf.p 72
   %define R.ax rdi
   %define R.rx rbx
   %define R.mx rsi
   %define R.dx r12
   %define R.i r13
   %define R.j r14
   %define R.q r15
    %define mc_auxmcl.do_storebf.r -8
    %define mc_auxmcl.do_storebf.mask -16
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
    mov       [rbp+72],	rcx
;---------------
    mov       rax,	[mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    call      mc_stackmcl.isimmload
    mov       r15,	rax
    mov       rcx,	[mc_decls.noperands]
    call      mc_stackmcl.isimmload
    mov       [rbp + mc_auxmcl.do_storebf.r],	rax
    mov       rax,	[rbp + mc_auxmcl.do_storebf.r]
    cmp       rax,	r15
    jnz       L2806
    test      rax,	rax
    jnz       L2806
    lea       rcx,	[L12405]
    lea       rdx,	[L12406]
    call      pc_api.merror
L2806:
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    sub       r10,	3
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       r12,	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[mc_decls.noperands]
    sub       r10,	2
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       rdi,	rax
    mov       r13,	[r15+8]
    mov       rax,	[rbp + mc_auxmcl.do_storebf.r]
    mov       r14,	[rax+8]
    mov       rcx,	6
    call      mc_stackmcl.getworkregm
    mov       rsi,	rax
    movzx     rax,	byte [mc_decls.pmode]
    mov       rcx,	rax
    call      mc_stackmcl.getworkregm
    mov       rbx,	rax
    mov       rcx,	11
    mov       rdx,	rbx
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rax,	r14
    sub       rax,	r13
    inc       rax
    mov       r10,	-1
    mov       cl,	al
    shl       r10,	cl
    not       r10
    mov       cl,	r13b
    shl       r10,	cl
    not       r10
    mov       [rbp + mc_auxmcl.do_storebf.mask],	r10
    mov       rcx,	[rbp + mc_auxmcl.do_storebf.mask]
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	11
    mov       rdx,	rsi
    mov       r8,	rax
    call      mc_libmcl.genmc
    test      r13,	r13
    jz        L2808
    mov       rcx,	r13
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	43
    mov       rdx,	r12
    mov       r8,	rax
    call      mc_libmcl.genmc
L2808:
    mov       rax,	[rbp + mc_auxmcl.do_storebf.p]
    mov       eax,	[rax+4]
    mov       rcx,	rsi
    mov       rdx,	rax
    call      mc_libmcl.changeopndsize
    mov       rcx,	38
    mov       rdx,	rbx
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	39
    mov       rdx,	rbx
    mov       r8,	r12
    call      mc_libmcl.genmc
    mov       rax,	[rbp + mc_auxmcl.do_storebf.p]
    mov       eax,	[rax+4]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mc_libmcl.changeopndsize
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
;---------------
    add       rsp,	56
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.gethostfn
mc_auxmcl.gethostfn:
;?>>
   %define R.opc r13
   %define R.d rdi
   %define R.name rbx
   %define R.namec rsi
   %define R.ps r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r13,	rcx
;---------------
    mov       rax,	[pc_api.igethostfn]
    test      rax,	rax
    jnz       L2811
    cmp       r13,	82
    jnz       L2814
L2813:
    lea       rax,	[L12407]
    mov       rbx,	rax
    lea       rax,	[L12408]
    mov       rsi,	rax
    jmp       L2812
L2814:
    xor       rbx,	rbx
L2812:
    test      rbx,	rbx
    jz        L2816
    mov       r12,	[pc_decls.psymboltable]
    jmp       L2820
L2817:
    mov       rax,	[r12]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mlib.eqstring
    test      rax,	rax
    jnz       L2823
    mov       rax,	[r12]
    mov       rcx,	rsi
    mov       rdx,	rax
    call      mlib.eqstring
    test      rax,	rax
    jz        L2822
L2823:
    mov       rax,	r12
    jmp       L2809
L2822:
    mov       r12,	[r12+8]
L2820:
    test      r12,	r12
    jnz       L2817
L2816:
    lea       rax,	[pc_tables.pclnames]
    mov       r10,	r13
    mov       rax,	[rax + r10*8]
    lea       rcx,	[L12409]
    mov       rdx,	rax
    call      pc_api.merror
L2811:
    mov       rcx,	r13
    mov       rax,	[pc_api.igethostfn]
    call      rax
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L2825
    lea       rax,	[pc_tables.pclnames]
    mov       r10,	r13
    mov       rax,	[rax + r10*8]
    lea       rcx,	[L12410]
    mov       rdx,	rax
    call      pc_api.merror
L2825:
    mov       rax,	rdi
L2809:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.copyblockarg
mc_auxmcl.copyblockarg:
;?>>
   %define R.px r12
   %define R.size r13
    %define mc_auxmcl.copyblockarg.argno 72
   %define R.dblock rdi
   %define R.ax rbx
   %define R.bx rsi
    %define mc_auxmcl.copyblockarg.$T3 -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       r12,	rcx
    mov       r13,	rdx
;---------------
    test      r12,	r12
    jnz       L2828
    call      msys.m$print_startcon
    lea       rcx,	[L12411]
    call      msys.m$print_str_nf
    mov       rax,	[pc_decls.currfunc]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rcx,	[L12412]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L2826
L2828:
    mov       rcx,	r13
    call      mc_libmcl.newblocktemp
    mov       rdi,	rax
    mov       al,	1
    mov       [rdi+92],	al
    test      r12,	r12
    jz        L2830
    mov       rcx,	6
    call      mc_stackmcl.getworkregm
    mov       rsi,	rax
    mov       rcx,	11
    mov       rdx,	rsi
    mov       r8,	r12
    call      mc_libmcl.genmc
    jmp       L2829
L2830:
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	11
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rsi,	rax
L2829:
    mov       rcx,	6
    call      mc_stackmcl.getworkregm
    mov       rbx,	rax
    mov       rcx,	rdi
    mov       rdx,	6
    call      mc_libmcl.mgenmem
    mov       rcx,	14
    mov       rdx,	rbx
    mov       r8,	rax
    call      mc_libmcl.genmc
    movzx     rax,	byte [rsi+10]
    mov       rcx,	rax
    mov       rdx,	10
    xor       r8d,	r8d
    call      mc_libmcl.mgenireg
    mov       [rbp + mc_auxmcl.copyblockarg.$T3],	rax
    movzx     rax,	byte [rbx+10]
    mov       rcx,	rax
    mov       rdx,	10
    xor       r8d,	r8d
    call      mc_libmcl.mgenireg
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_auxmcl.copyblockarg.$T3]
    mov       r8,	r13
    mov       r9,	1
    call      mc_auxmcl.copyblock
    test      r12,	r12
    jz        L2832
    mov       rcx,	rdi
    mov       rdx,	6
    call      mc_libmcl.mgenmem
    mov       rcx,	14
    mov       rdx,	r12
    mov       r8,	rax
    call      mc_libmcl.genmc
L2832:
    xor       ecx,	ecx
    call      mc_stackmcl.freeworkregs
L2826:
;---------------
    add       rsp,	40
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_auxmcl.fixmain
mc_auxmcl.fixmain:
;?>>
   %define R.d rdi
   %define R.dn rbx
   %define R.dargs rsi
   %define R.denv r12
   %define R.dinfo r13
   %define R.ax r14
    %define mc_auxmcl.fixmain.$T1 -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    mov       rdi,	[pc_decls.currfunc]
    mov       rbx,	[rdi+16]
    mov       rsi,	[rbx+16]
    lea       rcx,	[L12413]
    mov       rdx,	3
    call      pc_api.pc_makesymbol
    mov       r12,	rax
    mov       al,	6
    mov       [r12+82],	al
    mov       eax,	8
    mov       [r12+84],	eax
    lea       rcx,	[L12414]
    mov       rdx,	3
    call      pc_api.pc_makesymbol
    mov       r13,	rax
    mov       al,	11
    mov       [r13+82],	al
    mov       eax,	128
    mov       [r13+84],	eax
    mov       rcx,	90
    mov       rdx,	8
    call      mc_libmcl.setsegment
    mov       rcx,	r13
    call      mc_libmcl.mgenmemaddr
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	128
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	124
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	r12
    call      mc_libmcl.mgenmemaddr
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	8
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	124
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	67
    mov       rdx,	1
    call      mc_libmcl.setsegment
    mov       rcx,	r12
    call      pc_api.pc_addlocal
    mov       rcx,	r13
    call      pc_api.pc_addlocal
    xor       eax,	eax
    mov       [rdi+16],	rax
    mov       [rsi+16],	rax
    mov       [rbx+16],	rax
    xor       eax,	eax
    mov       [rdi+112],	al
    mov       al,	4
    mov       [rbx+72],	al
    mov       al,	1
    mov       [rbx+92],	al
    mov       al,	4
    mov       [rsi+72],	al
    mov       al,	4
    mov       [rsi+92],	al
    mov       rcx,	rsi
    call      pc_api.pc_addlocal
    mov       rcx,	rbx
    call      pc_api.pc_addlocal
    mov       rcx,	1
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       r10,	rax
    mov       r14,	r10
    mov       rcx,	12
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	r13
    mov       rdx,	6
    call      mc_libmcl.mgenmem
    mov       rcx,	14
    mov       rdx,	r14
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       al,	1
    mov       [r13+88],	al
    mov       rcx,	12
    mov       rdx,	r14
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	32
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	29
    mov       rdx,	[mc_decls.dstackopnd]
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	rbx
    mov       rdx,	6
    call      mc_libmcl.mgenmem
    mov       [rbp + mc_auxmcl.fixmain.$T1],	rax
    mov       rcx,	11
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	14
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.fixmain.$T1]
    call      mc_libmcl.genmc
    mov       al,	1
    mov       [rbx+88],	al
    mov       rcx,	rsi
    mov       rdx,	6
    call      mc_libmcl.mgenmem
    mov       [rbp + mc_auxmcl.fixmain.$T1],	rax
    mov       rcx,	12
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	14
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.fixmain.$T1]
    call      mc_libmcl.genmc
    mov       al,	1
    mov       [rsi+88],	al
    mov       rcx,	r12
    mov       rdx,	6
    call      mc_libmcl.mgenmem
    mov       [rbp + mc_auxmcl.fixmain.$T1],	rax
    mov       rcx,	13
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	14
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.fixmain.$T1]
    call      mc_libmcl.genmc
    mov       al,	1
    mov       [r12+88],	al
    mov       rcx,	14
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	rax
    call      mc_libmcl.clearreg
    lea       rcx,	[L12415]
    call      mc_libmcl.mgenextname
    mov       rcx,	21
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	48
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	29
    mov       rdx,	[mc_decls.dstackopnd]
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rax,	[pc_decls.pcmdskip]
    test      rax,	rax
    jz        L2835
    mov       rcx,	[pc_decls.pcmdskip]
    mov       rdx,	9
    call      mc_libmcl.mgenint
    mov       [rbp + mc_auxmcl.fixmain.$T1],	rax
    mov       rcx,	rbx
    mov       rdx,	6
    call      mc_libmcl.mgenmem
    mov       rcx,	29
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.fixmain.$T1]
    call      mc_libmcl.genmc
    mov       rax,	[pc_decls.pcmdskip]
    shl       rax,	3
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       [rbp + mc_auxmcl.fixmain.$T1],	rax
    mov       rcx,	rsi
    mov       rdx,	6
    call      mc_libmcl.mgenmem
    mov       rcx,	28
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.fixmain.$T1]
    call      mc_libmcl.genmc
L2835:
;---------------
    add       rsp,	48
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.mclinit
mc_libmcl.mclinit:
;?>>
   %define R.bypass r14
   %define R.a rdi
   %define R.r rbx
   %define R.av_1 rsi
   %define R.av_2 r12
   %define R.i r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       r14,	rcx
;---------------
    mov       rax,	64
    cmp       rax,	64
    jle       L2838
    lea       rcx,	[L12416]
    call      mlib.abortprogram
L2838:
    mov       rbx,	1
L2839:
    mov       rcx,	rbx
    mov       rdx,	1
    call      mc_libmcl.mgenreg0
    lea       r10,	[mc_decls.regtable]
    mov       r11,	rbx
    shl       r11,	6
    lea       r10,	[r10 + r11-64]
    mov       [r10],	rax
    mov       rcx,	rbx
    mov       rdx,	2
    call      mc_libmcl.mgenreg0
    lea       r10,	[mc_decls.regtable]
    mov       r11,	rbx
    shl       r11,	6
    lea       r10,	[r10 + r11-64]
    mov       [r10+8],	rax
    mov       rcx,	rbx
    mov       rdx,	4
    call      mc_libmcl.mgenreg0
    lea       r10,	[mc_decls.regtable]
    mov       r11,	rbx
    shl       r11,	6
    lea       r10,	[r10 + r11-64]
    mov       [r10+24],	rax
    mov       rcx,	rbx
    mov       rdx,	8
    call      mc_libmcl.mgenreg0
    lea       r10,	[mc_decls.regtable]
    mov       r11,	rbx
    shl       r11,	6
    lea       r10,	[r10 + r11-64]
    mov       [r10+56],	rax
    inc       rbx
    cmp       rbx,	16
    jle       L2839
    mov       r13,	-128
    mov       rsi,	64
    cmp       rsi,	-128
    jl        L2844
L2842:
    call      mc_libmcl.newmclopnd
    mov       rdi,	rax
    lea       rax,	[rdi+8]
    mov       r10w,	3
    mov       r8w,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       r8w,	r11w
    or        r8w,	r10w
    mov       [rax],	r8w
    mov       al,	15
    mov       [rdi+10],	al
    lea       rax,	[rdi+8]
    mov       r10w,	8
    mov       r8w,	[rax]
    mov       r11,	-32
    and       r8w,	r11w
    or        r8w,	r10w
    mov       [rax],	r8w
    mov       [rdi+12],	r13d
    mov       rax,	rdi
    lea       r10,	[mc_decls.frameregtable]
    mov       r11,	r13
    mov       [r10 + r11*8+1024],	rax
    inc       r13
    cmp       r13,	rsi
    jle       L2842
L2844:
    mov       rcx,	15
    mov       rdx,	6
    call      mc_libmcl.mgenreg
    mov       [mc_decls.dframeopnd],	rax
    mov       rcx,	16
    mov       rdx,	6
    call      mc_libmcl.mgenreg
    mov       [mc_decls.dstackopnd],	rax
    call      mc_libmcl.initmcdest
    mov       rcx,	67
    mov       rdx,	1
    call      mc_libmcl.setsegment
    xor       eax,	eax
    mov       [mc_decls.lab_funcnametable],	rax
    xor       eax,	eax
    mov       [mc_decls.lab_funcaddrtable],	rax
    mov       r13,	-1
    mov       r12,	10
    cmp       r12,	-1
    jl        L2847
L2845:
    mov       rcx,	r13
    mov       rdx,	8
    call      mc_libmcl.mgenint0
    lea       r10,	[mc_libmcl.smallinttable]
    mov       r11,	r13
    mov       [r10 + r11*8+8],	rax
    inc       r13
    cmp       r13,	r12
    jle       L2845
L2847:
    test      r14,	r14
    jz        L2849
    mov       al,	1
    mov       [pc_decls.mcldone],	al
L2849:
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.initmcdest
mc_libmcl.initmcdest:
;?>>
;?]]
;---------------
    xor       eax,	eax
    mov       [mc_decls.mccodex],	rax
    mov       [mc_decls.mccode],	rax
;---------------
    ret       
;End 
;Proc mc_libmcl.genmc
mc_libmcl.genmc:
;?>>
   %define R.opcode rsi
   %define R.a r12
   %define R.b r13
   %define R.m rdi
   %define R.labno rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
;---------------
    mov       rcx,	64
    call      mlib.pcm_allocnfz
    mov       rdi,	rax
    mov       [rdi+33],	sil
    inc       qword [mc_libmcl.mclseqno]
    mov       rax,	[mc_libmcl.mclseqno]
    mov       [rdi+36],	eax
    mov       eax,	[pc_decls.mmpos]
    mov       [rdi+40],	eax
    mov       [rdi+16],	r12
    mov       [rdi+24],	r13
    mov       rax,	rsi
    cmp       rax,	14
    jz        L2853
    cmp       rax,	9
    jz        L2854
    cmp       rax,	11
    jz        L2855
    jmp       L2856
L2853:
    test      r13,	r13
    jz        L2858
    movzx     rax,	word [r13+8]
    shr       rax,	12
    and       rax,	15
    cmp       rax,	5
    jnz       L2858
    mov       rax,	[r13]
    mov       r10b,	1
    mov       [rax+88],	r10b
L2858:
    jmp       L2852
L2854:
    mov       rbx,	[r12]
    jmp       L2852
L2855:
    movzx     rax,	word [r12+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	5
    jz        L2861
    test      r13,	r13
    jz        L2860
    movzx     rax,	word [r13+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	5
    jnz       L2860
L2861:
    movzx     rax,	word [r12+8]
    and       rax,	31
    cmp       rax,	8
    jnz       L2863
    mov       rax,	17
    jmp       L2862
L2863:
    mov       rax,	16
L2862:
    mov       [rdi+33],	al
L2860:
L2856:
L2852:
    mov       rax,	[mc_decls.mccode]
    test      rax,	rax
    jz        L2865
    mov       rax,	[mc_decls.mccodex]
    mov       [rdi],	rax
    mov       rax,	rdi
    mov       r10,	[mc_decls.mccodex]
    mov       [r10+8],	rax
    mov       [mc_decls.mccodex],	rdi
    jmp       L2864
L2865:
    mov       rax,	rdi
    mov       [mc_decls.mccodex],	rax
    mov       [mc_decls.mccode],	rax
L2864:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.genmc_cond
mc_libmcl.genmc_cond:
;?>>
   %define R.opcode rdi
   %define R.cond rbx
   %define R.a rsi
   %define R.b r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
    mov       r12,	r9
;---------------
    mov       rcx,	rdi
    mov       rdx,	rsi
    mov       r8,	r12
    call      mc_libmcl.genmc
    mov       al,	bl
    mov       r10,	[mc_decls.mccodex]
    mov       [r10+34],	al
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.genmc_str
mc_libmcl.genmc_str:
;?>>
   %define R.opcode rdi
   %define R.s rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rbx
    mov       rdx,	-1
    call      mc_libmcl.mgenstring
    mov       rcx,	rdi
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.newmclopnd
mc_libmcl.newmclopnd:
;?>>
   %define R.a rdi
    push      rdi
;?]]
    sub       rsp,	48
;---------------
    mov       rcx,	16
    call      mlib.pcm_allocnfz
    mov       rdi,	rax
    inc       qword [mc_libmcl.nmclopnd]
    mov       rax,	rdi
L2868:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.duplopnd
mc_libmcl.duplopnd:
;?>>
   %define R.a rbx
   %define R.b rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rcx,	16
    call      mlib.pcm_allocnfz
    mov       rdi,	rax
    mov       rax,	rbx
    movdqu    XMM4,	[rax]
    movdqu    [rdi],	XMM4
    mov       rax,	rdi
L2869:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.mgenindex
mc_libmcl.mgenindex:
;?>>
   %define R.areg rbx
   %define R.ireg rsi
   %define R.scale r12
   %define R.offset r13
    %define mc_libmcl.mgenindex.size 96
    %define mc_libmcl.mgenindex.labno 104
    %define mc_libmcl.mgenindex.def 112
   %define R.a rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
    mov       r13,	r9
;---------------
    call      mc_libmcl.newmclopnd
    mov       rdi,	rax
    lea       rax,	[rdi+8]
    mov       r10w,	3
    mov       r15w,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       r15w,	r11w
    or        r15w,	r10w
    mov       [rax],	r15w
    mov       [rdi+10],	bl
    cmp       rbx,	15
    jz        L2873
    cmp       rsi,	15
    jnz       L2872
L2873:
    mov       al,	1
    lea       r10,	[mc_decls.usedregs]
    mov       [r10+14],	al
L2872:
    mov       [rdi+11],	sil
    lea       rax,	[rdi+8]
    mov       r10w,	r12w
    mov       r15w,	[rax]
    mov       r11,	-481
    shl       r10w,	5
    and       r15w,	r11w
    or        r15w,	r10w
    mov       [rax],	r15w
    lea       rax,	[rdi+8]
    mov       r10w,	[rbp + mc_libmcl.mgenindex.size]
    mov       r15w,	[rax]
    mov       r11,	-32
    and       r15w,	r11w
    or        r15w,	r10w
    mov       [rax],	r15w
    mov       [rdi+12],	r13d
    mov       rax,	[rbp + mc_libmcl.mgenindex.labno]
    test      rax,	rax
    jz        L2875
    mov       rax,	[rbp + mc_libmcl.mgenindex.labno]
    mov       [rdi],	rax
    lea       rax,	[rdi+8]
    mov       r10w,	6
    mov       r15w,	[rax]
    mov       r11,	-61441
    shl       r10w,	12
    and       r15w,	r11w
    or        r15w,	r10w
    mov       [rax],	r15w
    jmp       L2874
L2875:
    mov       rax,	[rbp + mc_libmcl.mgenindex.def]
    test      rax,	rax
    jz        L2876
    mov       rax,	[rbp + mc_libmcl.mgenindex.def]
    mov       [rdi],	rax
    mov       rax,	[rbp + mc_libmcl.mgenindex.def]
    lea       rax,	[rax+89]
    inc       byte [rax]
    lea       rax,	[rdi+8]
    mov       r10w,	5
    mov       r15w,	[rax]
    mov       r11,	-61441
    shl       r10w,	12
    and       r15w,	r11w
    or        r15w,	r10w
    mov       [rax],	r15w
    mov       rax,	[rbp + mc_libmcl.mgenindex.def]
    movzx     rax,	byte [rax+72]
    cmp       rax,	4
    jz        L2879
    cmp       rax,	5
    jnz       L2878
L2879:
    mov       al,	15
    mov       [rdi+10],	al
    mov       al,	1
    lea       r10,	[mc_decls.usedregs]
    mov       [r10+14],	al
L2878:
L2876:
L2874:
    mov       rax,	rdi
L2870:
;---------------
    add       rsp,	32
    pop       rbp
    pop       r15
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.mgencomment
mc_libmcl.mgencomment:
;?>>
   %define R.s rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	3
    mov       rdx,	rdi
    call      mc_libmcl.genmc_str
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.mgenstring
mc_libmcl.mgenstring:
;?>>
   %define R.s rbx
   %define R.length rsi
   %define R.a rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    call      mc_libmcl.newmclopnd
    mov       rdi,	rax
    lea       rax,	[rdi+8]
    mov       r10w,	2
    mov       r9w,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    cmp       rsi,	0
    jge       L2883
    mov       rcx,	rbx
    call      strlen
    mov       rsi,	rax
L2883:
    lea       rax,	[rsi+1]
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [rdi],	rax
    mov       rax,	[rdi]
    mov       rcx,	rax
    mov       rdx,	rbx
    mov       r8,	rsi
    call      memcpy
    mov       rax,	[rdi]
    xor       r10d,	r10d
    mov       r11,	rsi
    mov       [rax + r11],	r10b
    lea       rax,	[rdi+8]
    mov       r10w,	4
    mov       r9w,	[rax]
    mov       r11,	-61441
    shl       r10w,	12
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    lea       rax,	[rdi+8]
    mov       r10w,	8
    mov       r9w,	[rax]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    mov       rax,	rdi
L2881:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.mgenname
mc_libmcl.mgenname:
;?>>
   %define R.s rbx
   %define R.a rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    call      mc_libmcl.newmclopnd
    mov       rdi,	rax
    lea       rax,	[rdi+8]
    mov       r10w,	2
    mov       r9w,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    mov       rcx,	rbx
    call      mlib.pcm_copyheapstring
    mov       [rdi],	rax
    lea       rax,	[rdi+8]
    mov       r10w,	7
    mov       r9w,	[rax]
    mov       r11,	-61441
    shl       r10w,	12
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    lea       rax,	[rdi+8]
    mov       r10w,	8
    mov       r9w,	[rax]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    mov       rax,	rdi
L2884:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.setsegment
mc_libmcl.setsegment:
;?>>
   %define R.seg rsi
   %define R.align r12
   %define R.opc rdi
   %define R.oldalign rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    cmp       rsi,	[mc_decls.currsegment]
    jz        L2887
    mov       rax,	rsi
    cmp       rax,	73
    jz        L2889
    cmp       rax,	90
    jz        L2890
    cmp       rax,	67
    jz        L2891
    cmp       rax,	82
    jz        L2892
    jmp       L2893
L2889:
    mov       rdi,	120
    jmp       L2888
L2890:
    mov       rdi,	121
    jmp       L2888
L2891:
    mov       rdi,	122
    jmp       L2888
L2892:
    lea       rcx,	[L12417]
    lea       rdx,	[L12418]
    call      pc_api.merror
    jmp       L2888
L2893:
    lea       rcx,	[L12419]
    lea       rdx,	[L12420]
    call      pc_api.merror
L2888:
    mov       rax,	[mc_decls.mccodex]
    test      rax,	rax
    jz        L2895
    mov       rax,	[mc_decls.mccodex]
    movzx     rax,	byte [rax+33]
    cmp       rax,	120
    jz        L2896
    cmp       rax,	121
    jz        L2896
    cmp       rax,	122
    jnz       L2895
L2896:
    mov       al,	dil
    mov       r10,	[mc_decls.mccodex]
    mov       [r10+33],	al
    jmp       L2894
L2895:
    mov       rcx,	rdi
    xor       edx,	edx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2894:
    mov       [mc_decls.currsegment],	rsi
L2887:
    cmp       r12,	1
    jle       L2898
    mov       rax,	[mc_decls.mccodex]
    movzx     rax,	byte [rax+33]
    cmp       rax,	123
    jnz       L2900
    mov       rax,	[mc_decls.mccodex]
    mov       rax,	[rax+16]
    mov       rbx,	[rax]
    cmp       rbx,	r12
    jge       L2885
L2902:
L2900:
    mov       rcx,	r12
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	123
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2898:
L2885:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.changeopndsize
mc_libmcl.changeopndsize:
;?>>
   %define R.a rbx
   %define R.size rsi
   %define R.b rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    movzx     rax,	word [rbx+8]
    and       rax,	31
    cmp       rax,	rsi
    jz        L2905
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jnz       L2907
    movzx     rax,	byte [rbx+10]
    lea       r10,	[mc_decls.regtable]
    mov       r11,	rax
    shl       r11,	6
    lea       r10,	[r10 + r11-64]
    mov       rax,	rsi
    mov       r10,	[r10 + rax*8-8]
    mov       rdi,	r10
    jmp       L2906
L2907:
    mov       rcx,	rbx
    call      mc_libmcl.duplopnd
    mov       rdi,	rax
    lea       rax,	[rdi+8]
    mov       r10w,	si
    mov       r8w,	[rax]
    mov       r11,	-32
    and       r8w,	r11w
    or        r8w,	r10w
    mov       [rax],	r8w
L2906:
    mov       rax,	rdi
    jmp       L2903
L2905:
    mov       rax,	rbx
L2903:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.applyoffset
mc_libmcl.applyoffset:
;?>>
   %define R.a rbx
   %define R.offset rsi
   %define R.size r12
   %define R.b rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
;---------------
    test      rsi,	rsi
    jnz       L2910
    test      r12,	r12
    jnz       L2910
    mov       rax,	rbx
    jmp       L2908
L2910:
    mov       rcx,	rbx
    call      mc_libmcl.duplopnd
    mov       rdi,	rax
    lea       rax,	[rdi+12]
    mov       r10d,	esi
    add       [rax],	r10d
    test      r12,	r12
    jz        L2912
    lea       rax,	[rdi+8]
    mov       r10w,	r12w
    mov       r9w,	[rax]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
L2912:
    mov       rax,	rdi
L2908:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.mgenint
mc_libmcl.mgenint:
;?>>
   %define R.x rsi
   %define R.mode r12
   %define R.a rdi
   %define R.size rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    lea       rax,	[pc_tables.psize]
    mov       r10,	r12
    movzx     rax,	byte [rax + r10]
    mov       rbx,	rax
    mov       rax,	rsi
    cmp       rax,	-1
    jl        L2915
    cmp       rax,	10
    jg        L2915
    cmp       rbx,	8
    jnz       L2915
    lea       rax,	[mc_libmcl.smallinttable]
    mov       r10,	rsi
    mov       rax,	[rax + r10*8+8]
    jmp       L2913
L2915:
    call      mc_libmcl.newmclopnd
    mov       rdi,	rax
    lea       rax,	[rdi+8]
    mov       r10w,	2
    mov       r9w,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    mov       [rdi],	rsi
    lea       rax,	[rdi+8]
    mov       r10w,	1
    mov       r9w,	[rax]
    mov       r11,	-61441
    shl       r10w,	12
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    lea       rax,	[rdi+8]
    mov       r10w,	bx
    mov       r9w,	[rax]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    mov       rax,	rdi
L2913:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.mgenint0
mc_libmcl.mgenint0:
;?>>
   %define R.x rbx
   %define R.size rsi
   %define R.a rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    call      mc_libmcl.newmclopnd
    mov       rdi,	rax
    lea       rax,	[rdi+8]
    mov       r10w,	2
    mov       r9w,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    mov       [rdi],	rbx
    lea       rax,	[rdi+8]
    mov       r10w,	1
    mov       r9w,	[rax]
    mov       r11,	-61441
    shl       r10w,	12
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    lea       rax,	[rdi+8]
    mov       r10w,	si
    mov       r9w,	[rax]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    mov       rax,	rdi
L2916:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.mgenrealmem
mc_libmcl.mgenrealmem:
;?>>
   %define R.x XMM15
   %define R.mode rbx
   %define R.a rdi
    push      rdi
    push      rbx
    movq      rax,	XMM15
    push      rax
;?]]
    sub       rsp,	48
    movq      XMM15,	XMM0
    mov       rbx,	rdx
;---------------
    call      mc_libmcl.newmclopnd
    mov       rdi,	rax
    lea       rax,	[rdi+8]
    mov       r10w,	3
    mov       r9w,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    lea       rax,	[rbx-1]
    test      rax,	rax
    jz        L2919
    movq      XMM0,	XMM15
    call      mc_libmcl.getrealindex
    mov       [rdi],	rax
    jmp       L2918
L2919:
    movq      XMM0,	XMM15
    call      mc_libmcl.getr32index
    mov       [rdi],	rax
L2918:
    lea       rax,	[rdi+8]
    mov       r10w,	6
    mov       r9w,	[rax]
    mov       r11,	-61441
    shl       r10w,	12
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    lea       rax,	[pc_tables.psize]
    mov       r10,	rbx
    movzx     rax,	byte [rax + r10]
    lea       r10,	[rdi+8]
    mov       r9w,	[r10]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	ax
    mov       [r10],	r9w
    mov       rax,	rdi
L2917:
;---------------
    add       rsp,	48
    pop       rcx
    movq      XMM15,	rcx
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.mgenrealimm
mc_libmcl.mgenrealimm:
;?>>
   %define R.x XMM15
   %define R.mode rbx
   %define R.a rdi
    push      rdi
    push      rbx
    movq      rax,	XMM15
    push      rax
;?]]
    sub       rsp,	48
    movq      XMM15,	XMM0
    mov       rbx,	rdx
;---------------
    call      mc_libmcl.newmclopnd
    mov       rdi,	rax
    lea       rax,	[rdi+8]
    mov       r10w,	2
    mov       r9w,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    movq      XMM4,	XMM15
    movq      [rdi],	XMM4
    lea       rax,	[rdi+8]
    mov       r10w,	2
    mov       r9w,	[rax]
    mov       r11,	-61441
    shl       r10w,	12
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    lea       rax,	[pc_tables.psize]
    mov       r10,	rbx
    movzx     rax,	byte [rax + r10]
    lea       r10,	[rdi+8]
    mov       r9w,	[r10]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	ax
    mov       [r10],	r9w
    mov       rax,	rdi
L2920:
;---------------
    add       rsp,	48
    pop       rcx
    movq      XMM15,	rcx
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.mgenlabel
mc_libmcl.mgenlabel:
;?>>
   %define R.x rbx
   %define R.a rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    call      mc_libmcl.newmclopnd
    mov       rdi,	rax
    lea       rax,	[rdi+8]
    mov       r10w,	2
    mov       r9w,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    test      rbx,	rbx
    jnz       L2923
    inc       qword [pc_api.mlabelno]
    mov       rbx,	[pc_api.mlabelno]
L2923:
    mov       [rdi],	rbx
    lea       rax,	[rdi+8]
    mov       r10w,	6
    mov       r9w,	[rax]
    mov       r11,	-61441
    shl       r10w,	12
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    mov       rax,	rdi
L2921:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.mgenlabelmem
mc_libmcl.mgenlabelmem:
;?>>
   %define R.x rbx
   %define R.a rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rcx,	rbx
    call      mc_libmcl.mgenlabel
    mov       rdi,	rax
    lea       rax,	[rdi+8]
    mov       r10w,	3
    mov       r9w,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    mov       rax,	rdi
L2924:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.mgenmem
mc_libmcl.mgenmem:
;?>>
   %define R.d rsi
   %define R.mode r12
   %define R.a rdi
   %define R.reg rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    mov       al,	[rsi+90]
    test      al,	al
    jz        L2927
    movzx     rax,	byte [rsi+82]
    lea       r10,	[pc_tables.pfloat]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L2929
    mov       rcx,	rsi
    call      mc_libmcl.mgenxregvar
    jmp       L2925
L2929:
    mov       rcx,	rsi
    mov       rdx,	r12
    call      mc_libmcl.mgenregvar
    jmp       L2925
L2928:
L2927:
    xor       rbx,	rbx
    movzx     rax,	byte [rsi+72]
    cmp       rax,	4
    jz        L2932
    cmp       rax,	5
    jnz       L2931
L2932:
    mov       rbx,	15
    mov       al,	1
    lea       r10,	[mc_decls.usedregs]
    mov       [r10+14],	al
L2931:
    call      mc_libmcl.newmclopnd
    mov       rdi,	rax
    lea       rax,	[rdi+8]
    mov       r10w,	3
    mov       r9w,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    mov       [rdi+10],	bl
    mov       [rdi],	rsi
    lea       rax,	[rsi+89]
    inc       byte [rax]
    lea       rax,	[rdi+8]
    mov       r10w,	5
    mov       r9w,	[rax]
    mov       r11,	-61441
    shl       r10w,	12
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    test      r12,	r12
    jz        L2934
    lea       rax,	[pc_tables.psize]
    mov       r10,	r12
    movzx     rax,	byte [rax + r10]
    lea       r10,	[rdi+8]
    mov       r9w,	[r10]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	ax
    mov       [r10],	r9w
    jmp       L2933
L2934:
    mov       eax,	[rsi+84]
    mov       r10,	8
    cmp       rax,	r10
    cmova     rax,	r10
    lea       r10,	[rdi+8]
    mov       r9w,	[r10]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	ax
    mov       [r10],	r9w
L2933:
    mov       rax,	rdi
L2925:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.mgenmemaddr
mc_libmcl.mgenmemaddr:
;?>>
   %define R.d rbx
   %define R.a rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       al,	1
    mov       [rbx+88],	al
    lea       rax,	[rbx+89]
    inc       byte [rax]
    call      mc_libmcl.newmclopnd
    mov       rdi,	rax
    lea       rax,	[rdi+8]
    mov       r10w,	2
    mov       r9w,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    mov       [rdi],	rbx
    lea       rax,	[rbx+89]
    inc       byte [rax]
    lea       rax,	[rdi+8]
    mov       r10w,	5
    mov       r9w,	[rax]
    mov       r11,	-61441
    shl       r10w,	12
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    lea       rax,	[rdi+8]
    mov       r10w,	8
    mov       r9w,	[rax]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    mov       rax,	rdi
L2935:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.mgenreg0
mc_libmcl.mgenreg0:
;?>>
   %define R.reg rbx
   %define R.size rsi
   %define R.a rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    call      mc_libmcl.newmclopnd
    mov       rdi,	rax
    lea       rax,	[rdi+8]
    mov       r10w,	1
    mov       r9w,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    mov       [rdi+10],	bl
    lea       rax,	[rdi+8]
    mov       r10w,	si
    mov       r9w,	[rax]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    test      rsi,	rsi
    jnz       L2938
    lea       rcx,	[L12421]
    lea       rdx,	[L12422]
    call      pc_api.merror
L2938:
    mov       rax,	rdi
L2936:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.mgenxreg
mc_libmcl.mgenxreg:
;?>>
   %define R.xreg rbx
   %define R.size rsi
   %define R.a rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    call      mc_libmcl.newmclopnd
    mov       rdi,	rax
    lea       rax,	[rdi+8]
    mov       r10w,	5
    mov       r9w,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    mov       [rdi+10],	bl
    lea       rax,	[rdi+8]
    mov       r10w,	si
    mov       r9w,	[rax]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    test      rsi,	rsi
    jnz       L2941
    lea       rcx,	[L12423]
    lea       rdx,	[L12424]
    call      pc_api.merror
L2941:
    mov       rax,	rdi
L2939:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.mgenreg
mc_libmcl.mgenreg:
;?>>
   %define R.reg rsi
   %define R.mode r12
   %define R.a rdi
   %define R.size rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    lea       rax,	[pc_tables.psize]
    mov       r10,	r12
    movzx     rax,	byte [rax + r10]
    mov       rbx,	rax
    cmp       r12,	2
    jg        L2944
    call      mc_libmcl.newmclopnd
    mov       rdi,	rax
    lea       rax,	[rdi+8]
    mov       r10w,	5
    mov       r8w,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       r8w,	r11w
    or        r8w,	r10w
    mov       [rax],	r8w
    mov       [rdi+10],	sil
    mov       al,	1
    lea       r10,	[mc_decls.usedxregs]
    mov       r11,	rsi
    mov       [r10 + r11-1],	al
    lea       rax,	[pc_tables.psize]
    mov       r10,	r12
    movzx     rax,	byte [rax + r10]
    lea       r10,	[rdi+8]
    mov       r8w,	[r10]
    mov       r11,	-32
    and       r8w,	r11w
    or        r8w,	ax
    mov       [r10],	r8w
    mov       rax,	rdi
    jmp       L2943
L2944:
    test      rbx,	rbx
    jnz       L2946
    mov       rbx,	8
L2946:
    mov       al,	1
    lea       r10,	[mc_decls.usedregs]
    mov       r11,	rsi
    mov       [r10 + r11-1],	al
    mov       rax,	rsi
    cmp       rax,	11
    jl        L2948
    cmp       rax,	14
    jg        L2948
    mov       al,	1
    lea       r10,	[mc_decls.regset]
    mov       r11,	rsi
    mov       [r10 + r11-1],	al
L2948:
    lea       rax,	[mc_decls.regtable]
    mov       r10,	rsi
    shl       r10,	6
    lea       rax,	[rax + r10-64]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8-8]
    jmp       L2942
    mov       rcx,	rsi
    mov       rdx,	rbx
    call      mc_libmcl.mgenreg0
L2943:
L2942:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.mgenregi
mc_libmcl.mgenregi:
;?>>
   %define R.reg rdi
   %define R.mode rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    lea       rax,	[mc_decls.regtable]
    mov       r10,	rdi
    shl       r10,	6
    lea       rax,	[rax + r10-64]
    lea       r10,	[pc_tables.psize]
    mov       r11,	rbx
    movzx     r10,	byte [r10 + r11]
    mov       rax,	[rax + r10*8-8]
    jmp       L2949
    lea       rax,	[pc_tables.psize]
    mov       r10,	rbx
    movzx     rax,	byte [rax + r10]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mc_libmcl.mgenreg0
L2949:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.mgenireg
mc_libmcl.mgenireg:
;?>>
   %define R.reg rbx
   %define R.mode rsi
   %define R.offset r12
   %define R.a rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
;---------------
    call      mc_libmcl.newmclopnd
    mov       rdi,	rax
    lea       rax,	[rdi+8]
    mov       r10w,	3
    mov       r9w,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    mov       [rdi+10],	bl
    lea       rax,	[pc_tables.psize]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10]
    lea       r10,	[rdi+8]
    mov       r9w,	[r10]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	ax
    mov       [r10],	r9w
    mov       [rdi+12],	r12d
    mov       rax,	rdi
L2950:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.mgentemp
mc_libmcl.mgentemp:
;?>>
   %define R.n rbx
   %define R.mode rsi
   %define R.a rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    lea       rax,	[mc_decls.pcltempflags]
    mov       r10,	rbx
    mov       al,	[rax + r10-1]
    test      al,	al
    jz        L2953
    lea       rax,	[pc_tables.psize]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10]
    lea       r10,	[mc_decls.pcltempopnds]
    mov       r11,	rbx
    mov       r10,	[r10 + r11*8-8]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_libmcl.changeopndsize
    jmp       L2951
L2953:
    call      mc_libmcl.newmclopnd
    mov       rdi,	rax
    lea       rax,	[rdi+8]
    mov       r10w,	3
    mov       r9w,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    mov       al,	15
    mov       [rdi+10],	al
    mov       al,	1
    lea       r10,	[mc_decls.usedregs]
    mov       [r10+14],	al
    lea       rax,	[rdi+8]
    mov       r10w,	8
    mov       r9w,	[rax]
    mov       r11,	-61441
    shl       r10w,	12
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    lea       rax,	[pc_tables.psize]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10]
    lea       r10,	[rdi+8]
    mov       r9w,	[r10]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	ax
    mov       [r10],	r9w
    mov       [rdi],	rbx
    mov       rax,	rdi
    lea       r10,	[mc_decls.pcltempopnds]
    mov       r11,	rbx
    mov       [r10 + r11*8-8],	rax
    mov       al,	1
    lea       r10,	[mc_decls.pcltempflags]
    mov       r11,	rbx
    mov       [r10 + r11-1],	al
    mov       rax,	rdi
L2951:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.roundsizetg
mc_libmcl.roundsizetg:
;?>>
   %define R.size rcx
;?]]
;---------------
    mov       rax,	rcx
    and       rax,	7
    jnz       L2956
    mov       rax,	rcx
    jmp       L2954
L2956:
    mov       rax,	rcx
    and       rax,	7
    mov       r10,	8
    sub       r10,	rax
    mov       rax,	rcx
    add       rax,	r10
L2954:
;---------------
    ret       
;End 
;Proc mc_libmcl.merroropnd
mc_libmcl.merroropnd:
;?>>
   %define R.mess rdi
   %define R.opndtype rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    call      msys.m$print_startcon
    lea       rcx,	[L12425]
    call      msys.m$print_setfmt
    mov       rcx,	rdi
    call      msys.m$print_str_nf
    lea       rax,	[pc_tables.opndnames]
    mov       r10,	rbx
    mov       rcx,	[rax + r10*8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	1
    call      exit
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.mcreatefwdlabel
mc_libmcl.mcreatefwdlabel:
;?>>
;?]]
;---------------
    inc       qword [pc_api.mlabelno]
    mov       rax,	[pc_api.mlabelno]
L2958:
;---------------
    ret       
;End 
;Proc mc_libmcl.mdefinefwdlabel
mc_libmcl.mdefinefwdlabel:
;?>>
   %define R.lab rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.mgenextname
mc_libmcl.mgenextname:
;?>>
   %define R.s rbx
    %define mc_libmcl.mgenextname.str -64
   %define R.d rdi
    push      rdi
    push      rbx
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	96
    mov       rbx,	rcx
;---------------
    lea       rcx,	[rbp + mc_libmcl.mgenextname.str]
    mov       rdx,	rbx
    call      strcpy
    mov       rcx,	rbx
    call      strlen
    xor       r10d,	r10d
    mov       [rbp + rax + mc_libmcl.mgenextname.str-1],	r10b
    lea       rcx,	[rbp + mc_libmcl.mgenextname.str]
    call      mc_libmcl.findnamesym
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L2962
    mov       rcx,	128
    call      mlib.pcm_allocnfz
    mov       rdi,	rax
    lea       rcx,	[rbp + mc_libmcl.mgenextname.str]
    call      mlib.pcm_copyheapstring
    mov       [rdi],	rax
    mov       al,	1
    mov       [rdi+72],	al
    mov       al,	1
    mov       [rdi+80],	al
    mov       rcx,	rdi
    call      mc_libmcl.addnamesym
L2962:
    mov       rcx,	rdi
    call      mc_libmcl.mgenmemaddr
L2960:
;---------------
    add       rsp,	96
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.mgenregvar
mc_libmcl.mgenregvar:
;?>>
   %define R.d rbx
   %define R.mode rsi
   %define R.a rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    movzx     rax,	byte [rbx+90]
    mov       rcx,	rax
    mov       rdx,	rsi
    call      mc_libmcl.mgenreg
    mov       rdi,	rax
    mov       rax,	rdi
L2963:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.mgenxregvar
mc_libmcl.mgenxregvar:
;?>>
   %define R.d rbx
   %define R.a rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    movzx     rax,	byte [rbx+90]
    mov       rcx,	rax
    mov       rdx,	8
    call      mc_libmcl.mgenxreg
    mov       rdi,	rax
    movzx     rax,	byte [rbx+90]
    mov       r10b,	1
    lea       r11,	[mc_decls.isxregvar]
    mov       [r11 + rax-1],	r10b
    mov       rax,	rdi
L2964:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.getprimreg
mc_libmcl.getprimreg:
;?>>
   %define R.ax rcx
;?]]
;---------------
    mov       al,	[rcx+10]
    test      al,	al
    jz        L2967
    movzx     rax,	byte [rcx+10]
    jmp       L2966
L2967:
    movzx     rax,	byte [rcx+11]
L2966:
L2965:
;---------------
    ret       
;End 
;Proc mc_libmcl.pushslots
mc_libmcl.pushslots:
;?>>
   %define R.nslots rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rax,	rdi
    shl       rax,	3
    mov       rcx,	rax
    call      mc_libmcl.pushstack
    mov       rax,	rdi
    add       [mc_decls.mstackdepth],	rax
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.popslots
mc_libmcl.popslots:
;?>>
   %define R.nslots rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rax,	rdi
    shl       rax,	3
    mov       rcx,	rax
    call      mc_libmcl.popstack
    mov       rax,	rdi
    sub       [mc_decls.mstackdepth],	rax
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.pushstack
mc_libmcl.pushstack:
;?>>
   %define R.n rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    test      rdi,	rdi
    jz        L2972
    mov       rcx,	rdi
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	29
    mov       rdx,	[mc_decls.dstackopnd]
    mov       r8,	rax
    call      mc_libmcl.genmc
L2972:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.popstack
mc_libmcl.popstack:
;?>>
   %define R.n rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    test      rdi,	rdi
    jz        L2975
    mov       rcx,	rdi
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	28
    mov       rdx,	[mc_decls.dstackopnd]
    mov       r8,	rax
    call      mc_libmcl.genmc
L2975:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.getstringindex
mc_libmcl.getstringindex:
;?>>
   %define R.s rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    test      rdi,	rdi
    jnz       L2978
    inc       qword [pc_api.mlabelno]
    mov       rax,	[pc_api.mlabelno]
    mov       [mc_decls.kk0used],	rax
    mov       rax,	[mc_decls.kk0used]
    jmp       L2976
L2978:
    mov       rax,	[mc_decls.cstringlist]
    test      rax,	rax
    jz        L2980
    mov       rax,	[mc_decls.cstringlist]
    mov       rax,	[rax]
    mov       rcx,	rax
    mov       rdx,	rdi
    call      mlib.eqstring
    test      rax,	rax
    jz        L2980
    mov       rax,	[mc_decls.cstringlist]
    mov       rax,	[rax+16]
    jmp       L2976
L2980:
    lea       rcx,	[mc_decls.cstringlist]
    mov       rdx,	rdi
    call      mc_libmcl.addconst
L2976:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.addconst
mc_libmcl.addconst:
;?>>
   %define R.clist rbx
   %define R.value rsi
   %define R.p rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    mov       rcx,	24
    call      mlib.pcm_allocnfz
    mov       rdi,	rax
    mov       [rdi],	rsi
    inc       qword [pc_api.mlabelno]
    mov       rax,	[pc_api.mlabelno]
    mov       [rdi+16],	rax
    mov       rax,	[rbx]
    mov       [rdi+8],	rax
    mov       [rbx],	rdi
    mov       rax,	[pc_api.mlabelno]
L2981:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.getrealindex
mc_libmcl.getrealindex:
;?>>
   %define R.x XMM15
    movq      rax,	XMM15
    push      rax
;?]]
    sub       rsp,	48
    movq      XMM15,	XMM0
;---------------
    movq      XMM4,	XMM15
    movq      rax,	XMM4
    lea       rcx,	[mc_decls.creallist]
    mov       rdx,	rax
    call      mc_libmcl.addconst
L2982:
;---------------
    add       rsp,	48
    pop       rcx
    movq      XMM15,	rcx
    ret       
;End 
;Proc mc_libmcl.getr32index
mc_libmcl.getr32index:
;?>>
   %define R.x XMM15
    movq      rax,	XMM15
    push      rax
;?]]
    sub       rsp,	48
    movq      XMM15,	XMM0
;---------------
    movq      XMM4,	XMM15
    movq      rax,	XMM4
    lea       rcx,	[mc_decls.cr32list]
    mov       rdx,	rax
    call      mc_libmcl.addconst
L2983:
;---------------
    add       rsp,	48
    pop       rcx
    movq      XMM15,	rcx
    ret       
;End 
;Proc mc_libmcl.ispoweroftwo
mc_libmcl.ispoweroftwo:
;?>>
   %define R.x rcx
   %define R.a rdi
   %define R.n rbx
   %define R.av_1 rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	16
;---------------
    mov       rdi,	1
    xor       rbx,	rbx
    mov       rax,	60
    mov       rsi,	rax
L2985:
    inc       rbx
    mov       rax,	rdi
    shl       rax,	1
    mov       rdi,	rax
    cmp       rdi,	rcx
    jnz       L2989
    mov       rax,	rbx
    jmp       L2984
L2989:
    dec       rsi
    jnz       L2985
    xor       eax,	eax
L2984:
;---------------
    add       rsp,	16
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.axerror
mc_libmcl.axerror:
;?>>
   %define R.mess rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    call      msys.m$print_startcon
    lea       rcx,	[L12426]
    call      msys.m$print_str_nf
    mov       rcx,	rdi
    call      msys.m$print_str_nf
    lea       rcx,	[L12427]
    call      msys.m$print_str_nf
    mov       rcx,	[mc_decls.aaseqno]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	1
    call      exit
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.newblocktemp
mc_libmcl.newblocktemp:
;?>>
   %define R.size rbx
    %define mc_libmcl.newblocktemp.str -16
   %define R.d rdi
    push      rdi
    push      rbx
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       rbx,	rcx
;---------------
    mov       rax,	[mc_decls.nblocktemps]
    cmp       rax,	50
    jle       L2993
    lea       rcx,	[L12428]
    lea       rdx,	[L12429]
    call      pc_api.merror
L2993:
    inc       qword [mc_decls.nblocktemps]
    lea       rcx,	[rbp + mc_libmcl.newblocktemp.str]
    call      msys.m$print_startstr
    lea       rcx,	[L12430]
    call      msys.m$print_setfmt
    mov       rcx,	[mc_decls.nblocktemps]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       rcx,	[rbp + mc_libmcl.newblocktemp.str]
    mov       rdx,	8
    call      pc_api.pc_makesymbol
    mov       rdi,	rax
    mov       al,	11
    mov       [rdi+82],	al
    mov       [rdi+84],	ebx
    mov       al,	1
    mov       [rdi+92],	al
    mov       al,	4
    mov       [rdi+72],	al
    mov       rax,	[pc_decls.currfunc]
    mov       rax,	[rax+24]
    mov       [rdi+24],	rax
    mov       rax,	[pc_decls.currfunc]
    mov       [rdi+32],	rax
    mov       rax,	rdi
    mov       r10,	[pc_decls.currfunc]
    mov       [r10+24],	rax
    mov       rax,	rdi
    lea       r10,	[mc_decls.blockdefs]
    mov       r11,	[mc_decls.nblocktemps]
    mov       [r10 + r11*8-8],	rax
    mov       rax,	rdi
L2991:
;---------------
    add       rsp,	48
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.findnamesym
mc_libmcl.findnamesym:
;?>>
   %define R.s rbx
   %define R.i rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rdi,	1
    mov       rax,	[mc_libmcl.nnametable]
    cmp       rax,	1
    jl        L2997
L2995:
    lea       rax,	[mc_libmcl.nametable]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    mov       rax,	[rax]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mlib.eqstring
    test      rax,	rax
    jz        L2999
    lea       rax,	[mc_libmcl.nametable]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    jmp       L2994
L2999:
    inc       rdi
    cmp       rdi,	[mc_libmcl.nnametable]
    jle       L2995
L2997:
    xor       eax,	eax
L2994:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.addnamesym
mc_libmcl.addnamesym:
;?>>
   %define R.d rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rax,	[mc_libmcl.nnametable]
    cmp       rax,	20
    jge       L3002
    inc       qword [mc_libmcl.nnametable]
    mov       rax,	[mc_libmcl.nnametable]
    mov       r10,	rdi
    lea       r11,	[mc_libmcl.nametable]
    mov       [r11 + rax*8-8],	r10
    jmp       L3001
L3002:
    lea       rcx,	[L12431]
    lea       rdx,	[L12432]
    call      pc_api.merror
L3001:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.callproc
mc_libmcl.callproc:
;?>>
    %define mc_libmcl.callproc.cpname 16
    %define mc_libmcl.callproc.name 24
    %define mc_libmcl.callproc.lineno 32
;?]]
;---------------
L3003:
;---------------
    ret       
;End 
;Proc mc_libmcl.mgenstringx
mc_libmcl.mgenstringx:
;?>>
   %define R.s rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      mc_libmcl.getstringindex
    mov       rcx,	rax
    call      mc_libmcl.mgenlabelmem
L3004:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_libmcl.clearreg
mc_libmcl.clearreg:
;?>>
   %define R.ax rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    movzx     rax,	word [rdi+8]
    and       rax,	31
    cmp       rax,	8
    jnz       L3007
    mov       rcx,	rdi
    mov       rdx,	4
    call      mc_libmcl.changeopndsize
    mov       rdi,	rax
L3007:
    mov       rcx,	40
    mov       rdx,	rdi
    mov       r8,	rdi
    call      mc_libmcl.genmc
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.getopnd
mc_stackmcl.getopnd:
;?>>
   %define R.n r13
   %define R.mode r14
   %define R.reg r15
   %define R.ax rdi
   %define R.bx rbx
   %define R.a rsi
   %define R.d r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    sub       rsp,	48
    mov       r13,	rcx
    mov       r14,	rdx
    mov       r15,	r8
;---------------
    lea       rax,	[mc_decls.pclopnd]
    mov       r10,	r13
    mov       rsi,	[rax + r10*8-8]
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	r13
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	1
    jz        L3010
    cmp       rax,	2
    jz        L3010
    cmp       rax,	3
    jz        L3011
    jmp       L3012
L3010:
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	r13
    movzx     rax,	byte [rax + r10-1]
    mov       rcx,	rax
    mov       rdx,	r14
    call      mc_libmcl.mgenreg
    jmp       L3008
L3011:
    mov       rcx,	r13
    mov       rdx,	r14
    call      mc_libmcl.mgentemp
    mov       rbx,	rax
    mov       rax,	rbx
    jmp       L3008
L3012:
L3009:
    movzx     rax,	byte [rsi+1]
    cmp       rax,	1
    jz        L3014
    cmp       rax,	2
    jz        L3015
    cmp       rax,	4
    jz        L3016
    cmp       rax,	5
    jz        L3017
    cmp       rax,	6
    jz        L3017
    cmp       rax,	7
    jz        L3018
    cmp       rax,	3
    jz        L3019
    jmp       L3020
L3014:
    mov       r12,	[rsi+8]
    cmp       r14,	11
    jnz       L3022
    movzx     rax,	byte [r12+72]
    cmp       rax,	5
    jz        L3022
    mov       r14,	6
    jmp       L3015
L3022:
    mov       rax,	[rsi+8]
    mov       rcx,	rax
    mov       rdx,	r14
    call      mc_libmcl.mgenmem
    mov       rdi,	rax
L3021:
    jmp       L3013
L3015:
    mov       r12,	[rsi+8]
    movzx     rax,	byte [r12+72]
    cmp       rax,	5
    jnz       L3024
    movzx     rax,	byte [r12+82]
    cmp       rax,	11
    jnz       L3024
    mov       rax,	[rsi+8]
    mov       rcx,	rax
    mov       rdx,	r14
    call      mc_libmcl.mgenmem
    mov       rdi,	rax
    jmp       L3023
L3024:
    mov       rcx,	r15
    mov       rdx,	r14
    call      mc_stackmcl.getworkreg_rm
    mov       rdi,	rax
    mov       rax,	[rsi+8]
    mov       rcx,	rax
    mov       rdx,	r14
    call      mc_libmcl.mgenmem
    mov       rcx,	14
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
L3023:
    jmp       L3013
L3016:
    lea       rax,	[pc_tables.psize]
    mov       r10,	r14
    movzx     rax,	byte [rax + r10]
    cmp       rax,	2
    jz        L3026
    cmp       rax,	4
    jz        L3027
    jmp       L3028
L3026:
    lea       rax,	[rsi+8]
    mov       r10,	65535
    and       [rax],	r10
    jmp       L3025
L3027:
    lea       rax,	[rsi+8]
    mov       r10,	4294967295
    and       [rax],	r10
L3028:
L3025:
    mov       rax,	[rsi+8]
    mov       rcx,	rax
    mov       rdx,	r14
    call      mc_libmcl.mgenint
    mov       rbx,	rax
    mov       rax,	[rsi+8]
    cmp       rax,	-2147483648
    jl        L3030
    cmp       rax,	2147483647
    jg        L3030
    mov       rdi,	rbx
    jmp       L3029
L3030:
    mov       rcx,	r15
    mov       rdx,	r14
    call      mc_stackmcl.getworkreg_rm
    mov       rdi,	rax
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
L3029:
    jmp       L3013
L3017:
    movq      XMM4,	[rsi+8]
    movq      XMM0,	XMM4
    mov       rdx,	r14
    call      mc_libmcl.mgenrealmem
    mov       rdi,	rax
    jmp       L3013
L3018:
    mov       rcx,	r15
    mov       rdx,	r14
    call      mc_stackmcl.getworkreg_rm
    mov       rdi,	rax
    mov       rax,	[rsi+8]
    mov       rcx,	rax
    call      mc_libmcl.getstringindex
    mov       rcx,	rax
    call      mc_libmcl.mgenlabelmem
    mov       rcx,	14
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L3013
L3019:
    mov       rcx,	r15
    mov       rdx,	r14
    call      mc_stackmcl.getworkreg_rm
    mov       rdi,	rax
    mov       rax,	[rsi+8]
    mov       rcx,	rax
    call      mc_libmcl.mgenlabelmem
    mov       rcx,	14
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L3013
L3020:
;mc_stackmcl.getopnd.error:
    movzx     rax,	byte [rsi+1]
    lea       r10,	[pc_tables.opndnames]
    mov       r10,	[r10 + rax*8]
    lea       rcx,	[L12433]
    mov       rdx,	r10
    call      pc_api.merror
L3013:
    mov       rax,	rdi
L3008:
;---------------
    add       rsp,	48
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.loadopnd
mc_stackmcl.loadopnd:
;?>>
   %define R.n rbx
   %define R.mode rsi
   %define R.reg r12
   %define R.ax rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
;---------------
    mov       rcx,	rbx
    mov       rdx,	rsi
    mov       r8,	r12
    call      mc_stackmcl.getopnd
    mov       rdi,	rax
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	rbx
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	2
    jnz       L3034
    test      r12,	r12
    jnz       L3036
    mov       rcx,	rsi
    call      mc_stackmcl.getworkreg
    mov       r12,	rax
L3036:
L3034:
    mov       rcx,	rdi
    mov       rdx,	rsi
    mov       r8,	r12
    call      mc_stackmcl.loadtoreg
    mov       rdi,	rax
    xor       eax,	eax
    lea       r10,	[mc_decls.pclopnd]
    mov       r11,	rbx
    mov       [r10 + r11*8-8],	rax
    mov       al,	1
    lea       r10,	[mc_decls.pclloc]
    mov       r11,	rbx
    mov       [r10 + r11-1],	al
    mov       al,	[rdi+10]
    lea       r10,	[mc_decls.pclreg]
    mov       r11,	rbx
    mov       [r10 + r11-1],	al
    mov       rax,	rdi
L3032:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.loadparam
mc_stackmcl.loadparam:
;?>>
   %define R.n rbx
   %define R.mode rsi
   %define R.reg r12
   %define R.ax rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
;---------------
    mov       rcx,	rbx
    mov       rdx,	rsi
    mov       r8,	r12
    call      mc_stackmcl.getopnd
    mov       rdi,	rax
    mov       rcx,	rdi
    mov       rdx,	rsi
    mov       r8,	r12
    call      mc_stackmcl.loadtoreg_m
    mov       rdi,	rax
    mov       rax,	rdi
L3037:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.pushopnd
mc_stackmcl.pushopnd:
;?>>
   %define R.n r12
   %define R.mode r13
   %define R.ax rdi
   %define R.bx rbx
   %define R.p rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r12,	rcx
    mov       r13,	rdx
;---------------
    lea       rax,	[mc_decls.pclopnd]
    mov       r10,	r12
    mov       rsi,	[rax + r10*8-8]
    test      r13,	r13
    jnz       L3040
    lea       rax,	[mc_decls.pclmode]
    mov       r10,	r12
    movzx     rax,	byte [rax + r10-1]
    mov       r13,	rax
L3040:
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	r12
    movzx     rax,	byte [rax + r10-1]
    test      rax,	rax
    jnz       L3042
    movzx     rax,	byte [rsi+1]
    cmp       rax,	1
    jz        L3044
    cmp       rax,	4
    jz        L3045
    cmp       rax,	5
    jz        L3046
    jmp       L3047
L3044:
    lea       rax,	[pc_tables.psize]
    mov       r10,	r13
    movzx     rax,	byte [rax + r10]
    cmp       rax,	8
    jnz       L3049
    movzx     rax,	byte [mc_decls.pmode]
    mov       r10,	[rsi+8]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_libmcl.mgenmem
    mov       rdi,	rax
    jmp       L3050
L3049:
    jmp       L3043
L3045:
    mov       rax,	[rsi+8]
    cmp       rax,	-2147483648
    jl        L3052
    cmp       rax,	2147483647
    jg        L3052
    mov       rax,	[rsi+8]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rdi,	rax
    jmp       L3050
L3052:
    jmp       L3043
L3046:
    movq      XMM4,	[rsi+8]
    movq      XMM0,	XMM4
    mov       rdx,	2
    call      mc_libmcl.mgenrealmem
    mov       rdi,	rax
    jmp       L3050
L3047:
L3043:
L3042:
    mov       rcx,	r12
    mov       rdx,	r13
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    movzx     rax,	word [rdi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	5
    jnz       L3054
    mov       rbx,	rdi
    cmp       r13,	4
    jnz       L3056
    mov       rax,	5
    jmp       L3055
L3056:
    mov       rax,	6
L3055:
    mov       rcx,	rax
    call      mc_stackmcl.getworkregm
    mov       rdi,	rax
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
L3054:
;mc_stackmcl.pushopnd.pushit:
L3050:
    mov       rcx,	rdi
    mov       rdx,	8
    call      mc_libmcl.changeopndsize
    mov       rcx,	12
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    inc       qword [mc_decls.mstackdepth]
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.loadtoreg
mc_stackmcl.loadtoreg:
;?>>
   %define R.ax rbx
   %define R.mode rsi
   %define R.reg r12
   %define R.bx rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
;---------------
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L3060
    cmp       rax,	5
    jnz       L3059
L3060:
    test      r12,	r12
    jz        L3063
    movzx     rax,	byte [rbx+10]
    cmp       rax,	r12
    jnz       L3062
L3063:
    mov       rax,	rbx
    jmp       L3057
L3062:
L3059:
    mov       rcx,	r12
    mov       rdx,	rsi
    call      mc_stackmcl.getworkreg_rm
    mov       rdi,	rax
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_stackmcl.loadtoreg_common
    mov       rax,	rdi
L3057:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.loadtoreg_m
mc_stackmcl.loadtoreg_m:
;?>>
   %define R.ax rbx
   %define R.mode rsi
   %define R.reg r12
   %define R.bx rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
;---------------
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L3067
    cmp       rax,	5
    jnz       L3066
L3067:
    movzx     rax,	byte [rbx+10]
    cmp       rax,	r12
    jnz       L3069
    mov       rax,	rbx
    jmp       L3064
L3069:
L3066:
    mov       rcx,	r12
    mov       rdx,	rsi
    call      mc_libmcl.mgenreg
    mov       rdi,	rax
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_stackmcl.loadtoreg_common
    mov       rax,	rdi
L3064:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.loadtoreg_common
mc_stackmcl.loadtoreg_common:
;?>>
   %define R.bx rdi
   %define R.ax rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	2
    jnz       L3072
    movzx     rax,	word [rbx+8]
    shr       rax,	12
    and       rax,	15
    cmp       rax,	1
    jnz       L3072
    mov       rax,	[rbx]
    test      rax,	rax
    jnz       L3072
    mov       rcx,	rdi
    mov       rdx,	4
    call      mc_libmcl.changeopndsize
    mov       rdi,	rax
    mov       rcx,	rdi
    call      mc_libmcl.clearreg
    jmp       L3071
L3072:
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
L3071:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.pushpcl
mc_stackmcl.pushpcl:
;?>>
   %define R.p rbx
   %define R.n rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rax,	[mc_decls.noperands]
    cmp       rax,	20
    jl        L3075
    lea       rcx,	[L12434]
    lea       rdx,	[L12435]
    call      pc_api.merror
L3075:
    inc       qword [mc_decls.noperands]
    mov       rdi,	[mc_decls.noperands]
    xor       eax,	eax
    lea       r10,	[mc_decls.pclloc]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
    mov       rax,	rbx
    lea       r10,	[mc_decls.pclopnd]
    mov       r11,	rdi
    mov       [r10 + r11*8-8],	rax
    xor       eax,	eax
    lea       r10,	[mc_decls.pclreg]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
    mov       al,	1
    lea       r10,	[mc_decls.pclcount]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
    mov       al,	[rbx+3]
    lea       r10,	[mc_decls.pclmode]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
    movzx     rax,	byte [rbx+1]
    cmp       rax,	1
    jnz       L3077
    mov       rax,	[rbx+8]
    mov       al,	[rax+90]
    test      al,	al
    jz        L3077
    mov       rax,	[rbx+8]
    mov       al,	[rax+90]
    lea       r10,	[mc_decls.pclreg]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
    mov       al,	2
    lea       r10,	[mc_decls.pclloc]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
L3077:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.pushpcl_reg
mc_stackmcl.pushpcl_reg:
;?>>
   %define R.mode rbx
   %define R.reg rsi
   %define R.n rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    mov       rax,	[mc_decls.noperands]
    cmp       rax,	20
    jl        L3080
    lea       rcx,	[L12436]
    lea       rdx,	[L12437]
    call      pc_api.merror
L3080:
    test      rsi,	rsi
    jnz       L3082
    mov       rcx,	rbx
    call      mc_stackmcl.getworkreg
    mov       rsi,	rax
L3082:
    inc       qword [mc_decls.noperands]
    mov       rdi,	[mc_decls.noperands]
    mov       al,	1
    lea       r10,	[mc_decls.pclloc]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
    xor       eax,	eax
    lea       r10,	[mc_decls.pclopnd]
    mov       r11,	rdi
    mov       [r10 + r11*8-8],	rax
    mov       al,	sil
    lea       r10,	[mc_decls.pclreg]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
    mov       al,	1
    lea       r10,	[mc_decls.pclcount]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
    mov       al,	bl
    lea       r10,	[mc_decls.pclmode]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
    cmp       rbx,	2
    jg        L3084
    mov       al,	1
    lea       r10,	[mc_decls.xregset]
    mov       r11,	rsi
    mov       [r10 + r11-1],	al
    jmp       L3083
L3084:
    mov       al,	1
    lea       r10,	[mc_decls.regset]
    mov       r11,	rsi
    mov       [r10 + r11-1],	al
L3083:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.poppcl
mc_stackmcl.poppcl:
;?>>
   %define R.n rdi
    push      rdi
;?]]
    sub       rsp,	48
;---------------
    mov       rdi,	[mc_decls.noperands]
    cmp       rdi,	0
    jg        L3087
    lea       rcx,	[L12438]
    lea       rdx,	[L12439]
    call      pc_api.merror
L3087:
    lea       rax,	[mc_decls.pclcount]
    mov       r10,	rdi
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	1
    jle       L3089
    lea       rax,	[mc_decls.pclcount]
    mov       r10,	rdi
    lea       rax,	[rax + r10-1]
    dec       byte [rax]
    jmp       L3085
L3089:
    dec       qword [mc_decls.noperands]
L3085:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.duplpcl
mc_stackmcl.duplpcl:
;?>>
   %define R.mode rdi
    %define mc_stackmcl.duplpcl.$T1 -8
    push      rdi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
;---------------
    lea       rax,	[mc_decls.pclmode]
    mov       r10,	[mc_decls.noperands]
    movzx     rax,	byte [rax + r10-1]
    mov       rdi,	rax
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rcx,	rdi
    xor       edx,	edx
    call      mc_stackmcl.pushpcl_reg
    mov       rax,	[mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       [rbp + mc_stackmcl.duplpcl.$T1],	rax
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	[rbp + mc_stackmcl.duplpcl.$T1]
    call      mc_libmcl.genmc
;---------------
    add       rsp,	40
    pop       rbp
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.getworkireg
mc_stackmcl.getworkireg:
;?>>
   %define R.r rdi
   %define R.av_1 rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
;---------------
    mov       rbx,	10
L3092:
    mov       rdi,	1
L3095:
    lea       rax,	[mc_decls.workregs]
    mov       r10,	rdi
    mov       al,	[rax + r10-1]
    test      al,	al
    jz        L3099
    lea       rax,	[mc_decls.regset]
    mov       r10,	rdi
    movzx     rax,	byte [rax + r10-1]
    test      rax,	rax
    jnz       L3099
    mov       al,	1
    lea       r10,	[mc_decls.regset]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
    mov       rax,	rdi
    jmp       L3091
L3099:
    inc       rdi
    cmp       rdi,	14
    jle       L3095
    call      mc_stackmcl.savenextopnd
    dec       rbx
    jnz       L3092
    lea       rcx,	[L12440]
    lea       rdx,	[L12441]
    call      pc_api.merror
    xor       eax,	eax
L3091:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.getworkxreg
mc_stackmcl.getworkxreg:
;?>>
   %define R.r rdi
    push      rdi
;?]]
    sub       rsp,	48
;---------------
    mov       rdi,	5
L3101:
    lea       rax,	[mc_decls.workxregs]
    mov       r10,	rdi
    mov       al,	[rax + r10-1]
    test      al,	al
    jz        L3105
    lea       rax,	[mc_decls.xregset]
    mov       r10,	rdi
    movzx     rax,	byte [rax + r10-1]
    test      rax,	rax
    jnz       L3105
    mov       al,	1
    lea       r10,	[mc_decls.xregset]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
    mov       rax,	rdi
    jmp       L3100
L3105:
    inc       rdi
    cmp       rdi,	16
    jle       L3101
    lea       rcx,	[L12442]
    lea       rdx,	[L12443]
    call      pc_api.merror
    xor       eax,	eax
L3100:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.getworkregm
mc_stackmcl.getworkregm:
;?>>
   %define R.mode rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      mc_stackmcl.getworkreg
    mov       rcx,	rax
    mov       rdx,	rdi
    call      mc_libmcl.mgenreg
L3106:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.getworkreg
mc_stackmcl.getworkreg:
;?>>
   %define R.mode rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    cmp       rdi,	2
    jg        L3109
    call      mc_stackmcl.getworkxreg
    jmp       L3108
L3109:
    call      mc_stackmcl.getworkireg
L3108:
L3107:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.getworkreg_rm
mc_stackmcl.getworkreg_rm:
;?>>
   %define R.reg rdi
   %define R.mode rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rax,	rdi
    test      rax,	rax
    jz        L3113
    cmp       rax,	15
    jnz       L3112
L3113:
    mov       rcx,	rbx
    call      mc_stackmcl.getworkregm
    jmp       L3110
L3112:
    cmp       rbx,	2
    jle       L3117
    lea       rax,	[mc_decls.isregvar]
    mov       r10,	rdi
    mov       al,	[rax + r10-1]
    test      al,	al
    jnz       L3116
L3117:
    lea       rax,	[mc_decls.isxregvar]
    mov       r10,	rdi
    mov       al,	[rax + r10-1]
    test      al,	al
    jz        L3115
L3116:
    mov       rcx,	rbx
    call      mc_stackmcl.getworkregm
    jmp       L3110
L3115:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_libmcl.mgenreg
L3110:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.saveopnd
mc_stackmcl.saveopnd:
;?>>
   %define R.n rsi
   %define R.allregs r12
   %define R.reg rdi
   %define R.mode rbx
    %define mc_stackmcl.saveopnd.$T1 -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	1
    jnz       L3118
L3120:
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10-1]
    mov       rdi,	rax
    lea       rax,	[mc_decls.pclmode]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10-1]
    mov       rbx,	rax
    cmp       rbx,	2
    jle       L3122
    test      r12,	r12
    jnz       L3125
    mov       rax,	rdi
    cmp       rax,	4
    jl        L3126
    cmp       rax,	10
    jle       L3124
L3126:
L3125:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_libmcl.mgenreg
    mov       [rbp + mc_stackmcl.saveopnd.$T1],	rax
    mov       rcx,	rsi
    mov       rdx,	rbx
    call      mc_libmcl.mgentemp
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	[rbp + mc_stackmcl.saveopnd.$T1]
    call      mc_libmcl.genmc
L3124:
    xor       eax,	eax
    lea       r10,	[mc_decls.regset]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
    jmp       L3121
L3122:
    test      r12,	r12
    jnz       L3129
    mov       rax,	rdi
    cmp       rax,	1
    jl        L3128
    cmp       rax,	6
    jg        L3128
L3129:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_libmcl.mgenxreg
    mov       [rbp + mc_stackmcl.saveopnd.$T1],	rax
    mov       rcx,	rsi
    mov       rdx,	rbx
    call      mc_libmcl.mgentemp
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	[rbp + mc_stackmcl.saveopnd.$T1]
    call      mc_libmcl.genmc
L3128:
    xor       eax,	eax
    lea       r10,	[mc_decls.xregset]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
L3121:
    mov       al,	3
    lea       r10,	[mc_decls.pclloc]
    mov       r11,	rsi
    mov       [r10 + r11-1],	al
    xor       eax,	eax
    lea       r10,	[mc_decls.pclreg]
    mov       r11,	rsi
    mov       [r10 + r11-1],	al
L3118:
;---------------
    add       rsp,	48
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.saveopnds
mc_stackmcl.saveopnds:
;?>>
   %define R.n rsi
   %define R.av_1 rdi
   %define R.i rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    mov       rbx,	1
    mov       rax,	[mc_decls.noperands]
    sub       rax,	rsi
    mov       rdi,	rax
    cmp       rdi,	1
    jl        L3133
L3131:
    mov       rcx,	rbx
    xor       edx,	edx
    call      mc_stackmcl.saveopnd
    inc       rbx
    cmp       rbx,	rdi
    jle       L3131
L3133:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.savenextopnd
mc_stackmcl.savenextopnd:
;?>>
   %define R.i rdi
    push      rdi
;?]]
    sub       rsp,	48
;---------------
    mov       rdi,	1
    mov       rax,	[mc_decls.noperands]
    cmp       rax,	1
    jl        L3137
L3135:
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	rdi
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	1
    jnz       L3139
    lea       rax,	[mc_decls.pclmode]
    mov       r10,	rdi
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	2
    jle       L3139
    mov       rcx,	rdi
    mov       rdx,	1
    call      mc_stackmcl.saveopnd
    jmp       L3134
L3139:
    inc       rdi
    cmp       rdi,	[mc_decls.noperands]
    jle       L3135
L3137:
L3134:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.savenextxopnd
mc_stackmcl.savenextxopnd:
;?>>
   %define R.i rdi
    push      rdi
;?]]
    sub       rsp,	48
;---------------
    mov       rdi,	1
    mov       rax,	[mc_decls.noperands]
    cmp       rax,	1
    jl        L3143
L3141:
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	rdi
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	1
    jnz       L3145
    lea       rax,	[mc_decls.pclmode]
    mov       r10,	rdi
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	2
    jg        L3145
    mov       rcx,	rdi
    mov       rdx,	1
    call      mc_stackmcl.saveopnd
    jmp       L3140
L3145:
    inc       rdi
    cmp       rdi,	[mc_decls.noperands]
    jle       L3141
L3143:
L3140:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.movetoreg
mc_stackmcl.movetoreg:
;?>>
   %define R.newreg r12
   %define R.oldreg rdi
   %define R.mode rbx
   %define R.i rsi
    %define mc_stackmcl.movetoreg.$T1 -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       r12,	rcx
;---------------
    lea       rax,	[mc_decls.pclmode]
    mov       r10,	[mc_decls.noperands]
    movzx     rax,	byte [rax + r10-1]
    mov       rbx,	rax
    mov       rcx,	[mc_decls.noperands]
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
;mc_stackmcl.movetoreg.retry:
L3147:
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	[mc_decls.noperands]
    movzx     rax,	byte [rax + r10-1]
    mov       rdi,	rax
    cmp       rdi,	r12
    jz        L3146
L3149:
    cmp       rbx,	2
    jg        L3151
    lea       rax,	[mc_decls.xregset]
    mov       r10,	r12
    mov       al,	[rax + r10-1]
    test      al,	al
    jz        L3153
    lea       rcx,	[L12444]
    lea       rdx,	[L12445]
    call      pc_api.merror
L3153:
    jmp       L3150
L3151:
    lea       rax,	[mc_decls.regset]
    mov       r10,	r12
    mov       al,	[rax + r10-1]
    test      al,	al
    jz        L3155
    mov       rsi,	1
    mov       rax,	[mc_decls.noperands]
    cmp       rax,	1
    jl        L3158
L3156:
    cmp       rbx,	2
    jle       L3160
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	r12
    jnz       L3160
    mov       rcx,	rsi
    mov       rdx,	[mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    mov       rcx,	r12
    mov       rdx,	6
    call      mc_libmcl.mgenreg
    mov       [rbp + mc_stackmcl.movetoreg.$T1],	rax
    mov       rcx,	rdi
    mov       rdx,	6
    call      mc_libmcl.mgenreg
    mov       rcx,	27
    mov       rdx,	rax
    mov       r8,	[rbp + mc_stackmcl.movetoreg.$T1]
    call      mc_libmcl.genmc
    jmp       L3147
L3160:
    inc       rsi
    cmp       rsi,	[mc_decls.noperands]
    jle       L3156
L3158:
L3155:
L3150:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_libmcl.mgenreg
    mov       [rbp + mc_stackmcl.movetoreg.$T1],	rax
    mov       rcx,	r12
    mov       rdx,	rbx
    call      mc_libmcl.mgenreg
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	[rbp + mc_stackmcl.movetoreg.$T1]
    call      mc_libmcl.genmc
    mov       al,	r12b
    lea       r10,	[mc_decls.pclreg]
    mov       r11,	[mc_decls.noperands]
    mov       [r10 + r11-1],	al
    cmp       rbx,	2
    jg        L3162
    mov       al,	1
    lea       r10,	[mc_decls.xregset]
    mov       r11,	r12
    mov       [r10 + r11-1],	al
    jmp       L3161
L3162:
    mov       al,	1
    lea       r10,	[mc_decls.regset]
    mov       r11,	r12
    mov       [r10 + r11-1],	al
L3161:
L3146:
;---------------
    add       rsp,	48
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.getopnd_ind
mc_stackmcl.getopnd_ind:
;?>>
   %define R.n rsi
   %define R.mode r12
   %define R.a rdi
   %define R.d rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10-1]
    test      rax,	rax
    jnz       L3165
    lea       rax,	[mc_decls.pclopnd]
    mov       r10,	rsi
    mov       rdi,	[rax + r10*8-8]
    movzx     rax,	byte [rdi+1]
    cmp       rax,	2
    jnz       L3167
    mov       rbx,	[rdi+8]
    movzx     rax,	byte [rbx+72]
    cmp       rax,	5
    jnz       L3170
    movzx     rax,	byte [rbx+82]
    cmp       rax,	11
    jz        L3169
L3170:
    mov       rax,	[rdi+8]
    mov       rcx,	rax
    mov       rdx,	r12
    call      mc_libmcl.mgenmem
    jmp       L3163
L3169:
L3167:
L3165:
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	1
    jz        L3172
    mov       rcx,	rsi
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
L3172:
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10-1]
    mov       rcx,	rax
    mov       rdx,	r12
    xor       r8d,	r8d
    call      mc_libmcl.mgenireg
L3163:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.getopnd_ind_simp
mc_stackmcl.getopnd_ind_simp:
;?>>
   %define R.n rdi
   %define R.mode rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	rdi
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	1
    jz        L3175
    mov       rcx,	rdi
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
L3175:
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	rdi
    movzx     rax,	byte [rax + r10-1]
    mov       rcx,	rax
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      mc_libmcl.mgenireg
L3173:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.swapopnds
mc_stackmcl.swapopnds:
;?>>
   %define R.m rcx
   %define R.n rdx
;?]]
;---------------
    lea       rax,	[mc_decls.pclopnd]
    mov       r10,	rcx
    lea       rax,	[rax + r10*8-8]
    lea       r10,	[mc_decls.pclopnd]
    mov       r11,	rdx
    lea       r10,	[r10 + r11*8-8]
    mov       r11,	[rax]
    mov       r9,	[r10]
    mov       [r10],	r11
    mov       [rax],	r9
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	rcx
    lea       rax,	[rax + r10-1]
    lea       r10,	[mc_decls.pclloc]
    mov       r11,	rdx
    lea       r10,	[r10 + r11-1]
    mov       r11b,	[rax]
    mov       r9b,	[r10]
    mov       [r10],	r11b
    mov       [rax],	r9b
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	rcx
    lea       rax,	[rax + r10-1]
    lea       r10,	[mc_decls.pclreg]
    mov       r11,	rdx
    lea       r10,	[r10 + r11-1]
    mov       r11b,	[rax]
    mov       r9b,	[r10]
    mov       [r10],	r11b
    mov       [rax],	r9b
    lea       rax,	[mc_decls.pclmode]
    mov       r10,	rcx
    lea       rax,	[rax + r10-1]
    lea       r10,	[mc_decls.pclmode]
    mov       r11,	rdx
    lea       r10,	[r10 + r11-1]
    mov       r11b,	[rax]
    mov       r9b,	[r10]
    mov       [r10],	r11b
    mov       [rax],	r9b
    lea       rax,	[mc_decls.pclcount]
    mov       r10,	rcx
    lea       rax,	[rax + r10-1]
    lea       r10,	[mc_decls.pclcount]
    mov       r11,	rdx
    lea       r10,	[r10 + r11-1]
    mov       r11b,	[rax]
    mov       r9b,	[r10]
    mov       [r10],	r11b
    mov       [rax],	r9b
;---------------
    ret       
;End 
;Proc mc_stackmcl.isimmload
mc_stackmcl.isimmload:
;?>>
   %define R.n rcx
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	16
;---------------
    lea       rax,	[mc_decls.pclopnd]
    mov       r10,	rcx
    mov       rdi,	[rax + r10*8-8]
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	rcx
    movzx     rax,	byte [rax + r10-1]
    test      rax,	rax
    jnz       L3179
    movzx     rax,	byte [rdi]
    cmp       rax,	1
    jnz       L3179
    movzx     rax,	byte [rdi+1]
    cmp       rax,	4
    jnz       L3179
    mov       rax,	rdi
    jmp       L3178
L3179:
    xor       eax,	eax
L3178:
L3177:
;---------------
    add       rsp,	16
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.setnewzz
mc_stackmcl.setnewzz:
;?>>
   %define R.reg rcx
   %define R.mode rdx
;?]]
;---------------
    mov       al,	1
    lea       r10,	[mc_decls.pclloc]
    mov       r11,	[mc_decls.noperands]
    mov       [r10 + r11-1],	al
    xor       eax,	eax
    lea       r10,	[mc_decls.pclopnd]
    mov       r11,	[mc_decls.noperands]
    mov       [r10 + r11*8-8],	rax
    mov       al,	cl
    lea       r10,	[mc_decls.pclreg]
    mov       r11,	[mc_decls.noperands]
    mov       [r10 + r11-1],	al
    mov       al,	dl
    lea       r10,	[mc_decls.pclmode]
    mov       r11,	[mc_decls.noperands]
    mov       [r10 + r11-1],	al
;---------------
    ret       
;End 
;Proc mc_stackmcl.freeworkregs
mc_stackmcl.freeworkregs:
;?>>
    %define mc_stackmcl.freeworkregs.p 32
   %define R.reg rdi
   %define R.i rbx
    push      rdi
    push      rbx
;?]]
;---------------
    lea       rax,	[mc_decls.regset]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    lea       rax,	[mc_decls.xregset]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    mov       rbx,	1
    mov       rax,	[mc_decls.noperands]
    cmp       rax,	1
    jl        L3184
L3182:
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	rbx
    movzx     rax,	byte [rax + r10-1]
    mov       rdi,	rax
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	rbx
    mov       al,	[rax + r10-1]
    test      al,	al
    jz        L3186
    lea       rax,	[mc_decls.pclmode]
    mov       r10,	rbx
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	2
    jg        L3188
    mov       al,	1
    lea       r10,	[mc_decls.xregset]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
    jmp       L3187
L3188:
    mov       al,	1
    lea       r10,	[mc_decls.regset]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
L3187:
L3186:
    inc       rbx
    cmp       rbx,	[mc_decls.noperands]
    jle       L3182
L3184:
;---------------
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.swapopndregs
mc_stackmcl.swapopndregs:
;?>>
   %define R.reg2 rsi
   %define R.reg1 rdi
   %define R.i rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    lea       rax,	[mc_decls.pclmode]
    mov       r10,	[mc_decls.noperands]
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	2
    jg        L3191
    lea       rcx,	[L12446]
    lea       rdx,	[L12447]
    call      pc_api.merror
L3191:
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	[mc_decls.noperands]
    movzx     rax,	byte [rax + r10-1]
    mov       rdi,	rax
    cmp       rdi,	rsi
    jz        L3189
L3193:
    mov       rax,	[mc_decls.noperands]
    dec       rax
    mov       rbx,	rax
    cmp       rbx,	1
    jl        L3197
L3194:
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	rbx
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	1
    jnz       L3199
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	rbx
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	rsi
    jnz       L3199
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	[mc_decls.noperands]
    lea       rax,	[rax + r10-1]
    lea       r10,	[mc_decls.pclreg]
    mov       r11,	rbx
    lea       r10,	[r10 + r11-1]
    mov       r11b,	[rax]
    mov       r9b,	[r10]
    mov       [r10],	r11b
    mov       [rax],	r9b
    jmp       L3189
L3199:
    dec       rbx
    cmp       rbx,	1
    jge       L3194
L3197:
    xor       eax,	eax
    lea       r10,	[mc_decls.regset]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
    mov       al,	sil
    lea       r10,	[mc_decls.pclreg]
    mov       r11,	[mc_decls.noperands]
    mov       [r10 + r11-1],	al
L3189:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.makeopndind
mc_stackmcl.makeopndind:
;?>>
   %define R.a rdi
   %define R.mode rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    movzx     rax,	word [rdi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L3202
    lea       rcx,	[L12448]
    lea       rdx,	[L12449]
    call      pc_api.merror
L3202:
    movzx     rax,	byte [rdi+10]
    mov       rcx,	rax
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      mc_libmcl.mgenireg
L3200:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.makesimpleaddr
mc_stackmcl.makesimpleaddr:
;?>>
   %define R.ax r13
   %define R.bx rdi
   %define R.newreg rbx
   %define R.reg rsi
   %define R.regix r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r13,	rcx
;---------------
    movzx     rax,	byte [r13+10]
    mov       rsi,	rax
    movzx     rax,	byte [r13+11]
    mov       r12,	rax
    cmp       rsi,	15
    jnz       L3205
    xor       rsi,	rsi
L3205:
    movzx     rax,	word [r13+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jz        L3207
    lea       rcx,	[L12450]
    lea       rdx,	[L12451]
    call      pc_api.merror
L3207:
    test      rsi,	rsi
    jnz       L3209
    test      r12,	r12
    jnz       L3209
    call      mc_stackmcl.getworkireg
    mov       rbx,	rax
    jmp       L3208
L3209:
    test      rsi,	rsi
    jz        L3210
    mov       rax,	r13
    jmp       L3203
L3210:
    test      r12,	r12
    jz        L3211
    mov       rbx,	r12
    jmp       L3208
L3211:
    mov       rbx,	r12
L3208:
    mov       rcx,	rbx
    mov       rdx,	10
    xor       r8d,	r8d
    call      mc_libmcl.mgenireg
    mov       rdi,	rax
    mov       rcx,	rbx
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	14
    mov       rdx,	rax
    mov       r8,	r13
    call      mc_libmcl.genmc
    mov       rax,	rdi
L3203:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.checkallloaded
mc_stackmcl.checkallloaded:
;?>>
   %define R.i rdi
    push      rdi
;?]]
    sub       rsp,	48
;---------------
    mov       rdi,	1
    mov       rax,	[mc_decls.noperands]
    cmp       rax,	1
    jl        L3215
L3213:
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	rdi
    movzx     rax,	byte [rax + r10-1]
    test      rax,	rax
    jnz       L3217
    lea       rax,	[mc_decls.pclopnd]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    movzx     rax,	byte [rax+1]
    cmp       rax,	1
    jnz       L3217
    lea       rax,	[mc_decls.pclopnd]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    movzx     rax,	byte [rax+3]
    mov       rcx,	rdi
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
L3217:
    inc       rdi
    cmp       rdi,	[mc_decls.noperands]
    jle       L3213
L3215:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.stropndstack
mc_stackmcl.stropndstack:
;?>>
   %define R.indent r13
   %define R.s rdi
   %define R.fs rbx
   %define R.i rsi
   %define R.r r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r13,	rcx
;---------------
    lea       rax,	[mc_stackmcl.stropndstack.str]
    mov       rdi,	rax
    test      r13,	r13
    jz        L3220
    mov       rcx,	rdi
    call      msys.m$print_startstr
    lea       rcx,	[L12452]
    call      msys.m$print_setfmt
    mov       rcx,	[mc_decls.noperands]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L3219
L3220:
    mov       rcx,	rdi
    call      msys.m$print_startstr
    lea       rcx,	[L12453]
    call      msys.m$print_setfmt
    mov       rcx,	[mc_decls.noperands]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
L3219:
    mov       rsi,	1
    mov       rax,	[mc_decls.noperands]
    cmp       rax,	1
    jl        L3223
L3221:
    mov       rax,	[mc_decls.noperands]
    sub       rax,	rsi
    inc       rax
    sub       rax,	1
    cmp       rax,	4
    jae       L3226
    lea       r10,	[L3225]
    jmp       [r10 + rax*8]
    segment .data
L3225:
    dq  L3227
    dq  L3228
    dq  L3229
    dq  L3230
    segment .text
L3227:
    lea       rax,	[L12454]
    jmp       L3224
L3228:
    lea       rax,	[L12455]
    jmp       L3224
L3229:
    lea       rax,	[L12456]
    jmp       L3224
L3230:
    lea       rax,	[L12457]
    jmp       L3224
L3226:
    lea       rax,	[L12458]
L3224:
    mov       rcx,	rdi
    mov       rdx,	rax
    call      strcat
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	1
    jz        L3232
    cmp       rax,	2
    jz        L3232
    cmp       rax,	3
    jz        L3233
    jmp       L3234
L3232:
    lea       rax,	[mc_decls.pclmode]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	2
    jg        L3236
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10-1]
    lea       r10,	[mc_decls.xregnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	rdi
    mov       rdx,	r10
    call      strcat
    jmp       L3235
L3236:
    lea       rax,	[mc_decls.pclreg]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10-1]
    lea       r10,	[mc_decls.regnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	rdi
    mov       rdx,	r10
    call      strcat
L3235:
    lea       rax,	[mc_decls.pclloc]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	2
    jnz       L3238
    mov       rcx,	rdi
    lea       rdx,	[L12459]
    call      strcat
L3238:
    jmp       L3231
L3233:
    mov       rcx,	rdi
    lea       rdx,	[L12460]
    call      strcat
    mov       rcx,	rsi
    xor       edx,	edx
    call      msys.strint
    mov       rcx,	rdi
    mov       rdx,	rax
    call      strcat
    jmp       L3231
L3234:
    mov       rcx,	rdi
    lea       rdx,	[L12461]
    call      strcat
    movzx     rax,	byte [pc_api.fpshortnames]
    mov       rbx,	rax
    mov       al,	1
    mov       [pc_api.fpshortnames],	al
    lea       rax,	[mc_decls.pclopnd]
    mov       r10,	rsi
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rax
    call      pc_diags.stropnd
    mov       rcx,	rdi
    mov       rdx,	rax
    call      strcat
    mov       [pc_api.fpshortnames],	bl
    mov       rcx,	rdi
    lea       rdx,	[L12462]
    call      strcat
L3231:
    lea       rax,	[mc_decls.pclcount]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	1
    jle       L3240
    mov       rcx,	rdi
    lea       rdx,	[L12463]
    call      strcat
L3240:
    mov       rcx,	rdi
    lea       rdx,	[L12464]
    call      strcat
    lea       rax,	[mc_decls.pclmode]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10-1]
    lea       r10,	[pc_tables.pstdnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	rdi
    mov       rdx,	r10
    call      strcat
    mov       rcx,	rdi
    lea       rdx,	[L12465]
    call      strcat
    cmp       rsi,	[mc_decls.noperands]
    jge       L3242
    mov       rcx,	rdi
    lea       rdx,	[L12466]
    call      strcat
L3242:
    inc       rsi
    cmp       rsi,	[mc_decls.noperands]
    jle       L3221
L3223:
    mov       rcx,	rdi
    lea       rdx,	[L12467]
    call      strcat
    lea       rcx,	[mc_stackmcl.stropndstack.str]
    mov       rdx,	50
    lea       r8,	[L12468]
    call      mlib.ipadstr
    mov       rcx,	rdi
    lea       rdx,	[L12469]
    call      strcat
    mov       r12,	1
L3243:
    lea       rax,	[mc_decls.regset]
    mov       r10,	r12
    mov       al,	[rax + r10-1]
    test      al,	al
    jz        L3247
    lea       rax,	[L12470]
    jmp       L3246
L3247:
    lea       rax,	[L12471]
L3246:
    mov       rcx,	rdi
    mov       rdx,	rax
    call      strcat
    inc       r12
    cmp       r12,	10
    jle       L3243
    mov       rcx,	rdi
    lea       rdx,	[L12472]
    call      strcat
    mov       rcx,	rdi
    lea       rdx,	[L12473]
    call      strcat
    mov       r12,	1
    mov       rax,	[mc_decls.xregmax]
    cmp       rax,	1
    jl        L3250
L3248:
    lea       rax,	[mc_decls.xregset]
    mov       r10,	r12
    mov       al,	[rax + r10-1]
    test      al,	al
    jz        L3252
    lea       rax,	[L12474]
    jmp       L3251
L3252:
    lea       rax,	[L12475]
L3251:
    mov       rcx,	rdi
    mov       rdx,	rax
    call      strcat
    inc       r12
    cmp       r12,	[mc_decls.xregmax]
    jle       L3248
L3250:
    mov       rcx,	rdi
    lea       rdx,	[L12476]
    call      strcat
    mov       rcx,	[mc_decls.mstackdepth]
    xor       edx,	edx
    call      msys.strint
    mov       rcx,	rdi
    mov       rdx,	rax
    call      strcat
    mov       rcx,	rdi
    lea       rdx,	[L12477]
    call      strcat
    mov       rcx,	[mc_decls.noperands]
    xor       edx,	edx
    call      msys.strint
    mov       rcx,	rdi
    mov       rdx,	rax
    call      strcat
    mov       rcx,	rdi
    lea       rdx,	[L12478]
    call      strcat
    mov       rcx,	[mc_decls.ncalldepth]
    xor       edx,	edx
    call      msys.strint
    mov       rcx,	rdi
    mov       rdx,	rax
    call      strcat
    mov       rax,	rdi
L3218:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_stackmcl.showopndstack
mc_stackmcl.showopndstack:
;?>>
;?]]
    sub       rsp,	40
;---------------
    mov       rcx,	1
    call      mc_stackmcl.stropndstack
    mov       rcx,	rax
    call      mc_libmcl.mgencomment
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mc_optim.peephole
mc_optim.peephole:
;?>>
   %define R.m rdi
   %define R.m2 rbx
   %define R.m3 rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
;---------------
    mov       al,	[pc_decls.fpeephole]
    test      al,	al
    jz        L3254
L3256:
    mov       rax,	[mc_decls.mccode]
    mov       rdi,	[rax+8]
    jmp       L3260
L3257:
    mov       rbx,	[rdi+8]
    mov       rsi,	[rbx+8]
    movzx     rax,	byte [rdi+33]
    cmp       rax,	8
    jz        L3262
    cmp       rax,	11
    jz        L3263
    cmp       rax,	38
    jz        L3264
    cmp       rax,	40
    jz        L3265
    cmp       rax,	26
    jz        L3266
    jmp       L3267
L3262:
    jmp       L3259
L3263:
    movzx     rax,	byte [rbx+33]
    cmp       rax,	11
    jz        L3269
    cmp       rax,	41
    jz        L3270
    cmp       rax,	42
    jz        L3271
    cmp       rax,	28
    jz        L3272
    cmp       rax,	29
    jz        L3272
    cmp       rax,	52
    jz        L3273
    cmp       rax,	53
    jz        L3273
    cmp       rax,	25
    jz        L3274
    jmp       L3275
L3269:
    mov       rax,	[rdi+16]
    mov       rcx,	rax
    call      mc_optim.isreg0
    test      rax,	rax
    jz        L3277
    mov       rax,	[rdi+16]
    mov       r10,	[rbx+24]
    cmp       rax,	r10
    jnz       L3277
    mov       rcx,	rbx
    call      mc_optim.endr0
    test      rax,	rax
    jz        L3277
    mov       rax,	[rbx+16]
    mov       rcx,	rax
    call      mc_optim.isreg10
    test      rax,	rax
    jnz       L3278
L3279:
    mov       rax,	[rbx+16]
    mov       rcx,	rax
    call      mc_optim.isreg
    test      rax,	rax
    jnz       L3281
    mov       rax,	[rdi+24]
    mov       rcx,	rax
    call      mc_optim.isreg
    test      rax,	rax
    jz        L3280
L3281:
    mov       rax,	[rbx+16]
    mov       [rdi+16],	rax
    mov       rcx,	rbx
    call      mc_optim.deletemcl
L3280:
L3278:
    jmp       L3276
L3277:
    mov       rax,	[rdi+16]
    mov       rcx,	rax
    call      mc_optim.isreg0
    test      rax,	rax
    jz        L3282
    mov       rax,	[rdi+16]
    mov       r10,	[rbx+24]
    cmp       rax,	r10
    jnz       L3282
    mov       rax,	[rbx+16]
    mov       rcx,	rax
    call      mc_optim.isreg10
    test      rax,	rax
    jz        L3282
    movzx     rax,	byte [rsi+33]
    cmp       rax,	21
    jnz       L3282
    mov       rcx,	rsi
    call      mc_optim.endr0
    test      rax,	rax
    jz        L3282
    mov       rax,	[rbx+16]
    mov       [rdi+16],	rax
    mov       rcx,	rbx
    call      mc_optim.deletemcl
L3282:
L3276:
    jmp       L3268
L3270:
    mov       rax,	[rdi+16]
    mov       rcx,	rax
    call      mc_optim.isreg0
    test      rax,	rax
    jz        L3284
    mov       rax,	[rdi+16]
    mov       r10,	[rbx+16]
    cmp       r10,	rax
    jnz       L3285
    mov       rax,	[rbx+24]
    cmp       r10,	rax
    jnz       L3285
    mov       rax,	1
    jmp       L3286
L3285:
    xor       eax,	eax
L3286:
    test      rax,	rax
    setnz     al
    movzx     eax,	al
    test      ax,	ax
    jz        L3284
    mov       rax,	[rdi+24]
    mov       rcx,	rax
    call      mc_optim.isreg
    test      rax,	rax
    jz        L3284
    mov       rcx,	rsi
    call      mc_optim.endr0
    test      rax,	rax
    jz        L3284
    mov       al,	41
    mov       [rdi+33],	al
    mov       rax,	[rdi+24]
    mov       [rdi+16],	rax
    mov       rcx,	rbx
    call      mc_optim.deletemcl
    mov       rdi,	rax
L3284:
    jmp       L3268
L3271:
    mov       rax,	[rdi+16]
    mov       rcx,	rax
    call      mc_optim.isreg0
    test      rax,	rax
    jz        L3288
    mov       rax,	[rdi+16]
    mov       r10,	[rbx+16]
    cmp       rax,	r10
    jnz       L3288
    mov       rax,	[rdi+24]
    mov       rcx,	rax
    call      mc_optim.isreg
    test      rax,	rax
    jz        L3288
    mov       rcx,	rsi
    call      mc_optim.endr0
    test      rax,	rax
    jz        L3288
    mov       al,	42
    mov       [rdi+33],	al
    mov       rax,	[rdi+24]
    mov       [rdi+16],	rax
    mov       rax,	[rbx+24]
    mov       [rdi+24],	rax
    mov       rcx,	rbx
    call      mc_optim.deletemcl
L3288:
    jmp       L3268
L3272:
    mov       rax,	[rdi+16]
    mov       rcx,	rax
    call      mc_optim.isreg
    test      rax,	rax
    jz        L3290
    mov       rax,	[rdi+16]
    mov       r10,	[rbx+16]
    cmp       rax,	r10
    jnz       L3290
    mov       rax,	[rdi+24]
    mov       rcx,	rax
    call      mc_optim.isreg
    test      rax,	rax
    jz        L3290
    mov       rax,	[rbx+24]
    mov       rcx,	rax
    call      mc_optim.isconst
    test      rax,	rax
    jz        L3290
    mov       al,	14
    mov       [rdi+33],	al
    sub       rsp,	8
    push      0
    push      0
    push      0
    movzx     rax,	byte [rbx+33]
    cmp       rax,	28
    jnz       L3292
    mov       rax,	[rbx+24]
    mov       rax,	[rax]
    jmp       L3291
L3292:
    mov       rax,	[rbx+24]
    mov       rax,	[rax]
    neg       rax
L3291:
    mov       r10,	[rdi+24]
    movzx     r10,	byte [r10+10]
    mov       rcx,	r10
    xor       edx,	edx
    mov       r8,	1
    mov       r9,	rax
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       [rdi+24],	rax
    mov       rcx,	rbx
    call      mc_optim.deletemcl
L3290:
    jmp       L3268
L3273:
    mov       rax,	[rdi+16]
    mov       rcx,	rax
    call      mc_optim.isreg
    test      rax,	rax
    jz        L3294
    mov       rax,	[rdi+16]
    mov       r10,	[rbx+16]
    cmp       rax,	r10
    jnz       L3294
    mov       rax,	[rdi+24]
    mov       rcx,	rax
    call      mc_optim.isreg
    test      rax,	rax
    jz        L3294
    mov       al,	14
    mov       [rdi+33],	al
    sub       rsp,	8
    push      0
    push      0
    push      0
    movzx     rax,	byte [rbx+33]
    cmp       rax,	52
    jnz       L3296
    mov       rax,	1
    jmp       L3295
L3296:
    mov       rax,	-1
L3295:
    mov       r10,	[rdi+24]
    movzx     r10,	byte [r10+10]
    mov       rcx,	r10
    xor       edx,	edx
    mov       r8,	1
    mov       r9,	rax
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       [rdi+24],	rax
    mov       rcx,	rbx
    call      mc_optim.deletemcl
L3294:
    jmp       L3268
L3274:
    mov       rax,	[rdi+16]
    mov       rcx,	rax
    call      mc_optim.isreg0
    test      rax,	rax
    jz        L3298
    mov       rax,	[rbx+16]
    mov       rcx,	rax
    call      mc_optim.isreg0
    test      rax,	rax
    jz        L3298
    mov       al,	25
    mov       [rdi+33],	al
    mov       rax,	[rdi+24]
    mov       [rdi+16],	rax
    xor       eax,	eax
    mov       [rdi+24],	rax
    mov       rcx,	rbx
    call      mc_optim.deletemcl
L3298:
L3275:
L3268:
    jmp       L3261
L3264:
    movzx     rax,	byte [rbx+33]
    cmp       rax,	41
    jnz       L3300
    mov       rax,	[rdi+16]
    mov       rcx,	rax
    call      mc_optim.isreg0
    test      rax,	rax
    jz        L3302
    mov       rax,	[rdi+16]
    mov       r10,	[rbx+16]
    cmp       r10,	rax
    jnz       L3303
    mov       rax,	[rbx+24]
    cmp       r10,	rax
    jnz       L3303
    mov       rax,	1
    jmp       L3304
L3303:
    xor       eax,	eax
L3304:
    test      rax,	rax
    setnz     al
    movzx     eax,	al
    test      ax,	ax
    jz        L3302
    mov       rcx,	rsi
    call      mc_optim.endr0
    test      rax,	rax
    jz        L3302
    mov       rcx,	rbx
    call      mc_optim.deletemcl
    mov       rdi,	rax
L3302:
L3300:
    jmp       L3261
L3265:
    movzx     rax,	byte [rbx+33]
    cmp       rax,	11
    jnz       L3306
    mov       rax,	[rdi+16]
    mov       rcx,	rax
    call      mc_optim.isreg0
    test      rax,	rax
    jz        L3308
    mov       rax,	[rdi+16]
    mov       r10,	[rdi+24]
    cmp       rax,	r10
    jnz       L3308
    mov       rax,	[rbx+16]
    mov       rcx,	rax
    call      mc_optim.isreg
    test      rax,	rax
    jz        L3308
    mov       rax,	[rbx+24]
    mov       rcx,	rax
    call      mc_optim.isreg0
    test      rax,	rax
    jz        L3308
    mov       rcx,	rbx
    call      mc_optim.endr0
    test      rax,	rax
    jz        L3308
    mov       rax,	[rbx+16]
    mov       [rdi+24],	rax
    mov       [rdi+16],	rax
    mov       rcx,	rbx
    call      mc_optim.deletemcl
    mov       rdi,	rax
L3308:
L3306:
    jmp       L3261
L3266:
    movzx     rax,	byte [rbx+33]
    cmp       rax,	25
    jnz       L3310
    movzx     rax,	byte [rsi+33]
    cmp       rax,	9
    jnz       L3310
    mov       rax,	[rdi+16]
    mov       rax,	[rax]
    mov       r10,	[rsi+16]
    mov       r10,	[r10]
    cmp       rax,	r10
    jnz       L3310
    mov       rcx,	rdi
    call      mc_optim.endr0
    test      rax,	rax
    jz        L3310
    movzx     rax,	byte [rdi+34]
    lea       r10,	[mc_decls.asmrevcond]
    mov       r10,	[r10 + rax*8]
    mov       [rdi+34],	r10b
    mov       rax,	[rbx+16]
    mov       [rdi+16],	rax
    mov       rcx,	rbx
    call      mc_optim.deletemcl
    mov       rdi,	rax
L3310:
L3267:
L3261:
    mov       rdi,	[rdi+8]
L3260:
    test      rdi,	rdi
    jnz       L3257
L3259:
L3254:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_optim.isreg
mc_optim.isreg:
;?>>
   %define R.a rcx
;?]]
;---------------
    movzx     rax,	word [rcx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    setz      al
    movzx     eax,	al
L3311:
;---------------
    ret       
;End 
;Proc mc_optim.isreg0
mc_optim.isreg0:
;?>>
   %define R.a rcx
;?]]
;---------------
    test      rcx,	rcx
    jnz       L3314
    xor       eax,	eax
    jmp       L3312
L3314:
    movzx     rax,	word [rcx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jnz       L3316
    movzx     rax,	byte [rcx+10]
    cmp       rax,	1
    jnz       L3316
    mov       rax,	1
    jmp       L3312
L3316:
    xor       eax,	eax
L3312:
;---------------
    ret       
;End 
;Proc mc_optim.isreg10
mc_optim.isreg10:
;?>>
   %define R.a rcx
;?]]
;---------------
    test      rcx,	rcx
    jnz       L3319
    xor       eax,	eax
    jmp       L3317
L3319:
    movzx     rax,	word [rcx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jnz       L3321
    movzx     rax,	byte [rcx+10]
    cmp       rax,	11
    jnz       L3321
    mov       rax,	1
    jmp       L3317
L3321:
    xor       eax,	eax
L3317:
;---------------
    ret       
;End 
;Proc mc_optim.isreg00
mc_optim.isreg00:
;?>>
   %define R.m rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rax,	[rdi+16]
    mov       rcx,	rax
    call      mc_optim.isreg
    test      rax,	rax
    jz        L3324
    mov       rax,	[rdi+16]
    mov       r10,	[rdi+24]
    cmp       rax,	r10
    jnz       L3324
    mov       rax,	1
    jmp       L3322
L3324:
    xor       eax,	eax
L3322:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_optim.isconst
mc_optim.isconst:
;?>>
   %define R.a rcx
;?]]
;---------------
    test      rcx,	rcx
    jnz       L3327
    xor       eax,	eax
    jmp       L3325
L3327:
    movzx     rax,	word [rcx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	2
    jnz       L3329
    movzx     rax,	word [rcx+8]
    shr       rax,	12
    and       rax,	15
    cmp       rax,	1
    jnz       L3329
    mov       rax,	1
    jmp       L3325
L3329:
    xor       eax,	eax
L3325:
;---------------
    ret       
;End 
;Proc mc_optim.sameoperand
mc_optim.sameoperand:
;?>>
   %define R.a rdi
   %define R.b rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	16
    call      memcmp
    movsxd    r10,	eax
    cmp       r10,	0
    setz      r10b
    movzx     r10d,	r10b
    mov       rax,	r10
L3330:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_optim.sameregopnd
mc_optim.sameregopnd:
;?>>
   %define R.a rcx
   %define R.b rdx
;?]]
;---------------
    movzx     rax,	word [rcx+8]
    shr       rax,	9
    and       rax,	7
    movzx     r10,	word [rdx+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	rax
    jnz       L3334
    cmp       r10,	1
    jz        L3333
L3334:
    xor       eax,	eax
    jmp       L3331
L3333:
    movzx     rax,	byte [rcx+10]
    movzx     r10,	byte [rdx+10]
    cmp       rax,	r10
    setz      al
    movzx     eax,	al
L3331:
;---------------
    ret       
;End 
;Proc mc_optim.deletemcl
mc_optim.deletemcl:
;?>>
   %define R.p rsi
   %define R.a rdi
   %define R.b rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    mov       rdi,	[rsi]
    mov       rbx,	[rsi+8]
    test      rdi,	rdi
    jz        L3338
    test      rbx,	rbx
    jnz       L3337
L3338:
    lea       rcx,	[L12479]
    lea       rdx,	[L12480]
    call      pc_api.merror
L3337:
    mov       [rdi+8],	rbx
    mov       [rbx],	rdi
    mov       rax,	rbx
L3335:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_optim.endr0
mc_optim.endr0:
;?>>
   %define R.m rcx
;?]]
;---------------
    lea       rax,	[rcx+48]
    movzx     rax,	byte [rax]
L3339:
;---------------
    ret       
;End 
;Proc mc_genss.genss
mc_genss.genss:
;?>>
   %define R.obj r14
   %define R.index rdi
   %define R.m rbx
   %define R.pr rsi
   %define R.codeaddr r12
   %define R.offsetptr r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       r14,	rcx
;---------------
    mov       al,	[pc_decls.ssdone]
    test      al,	al
    jnz       L3340
L3342:
    call      mwindows.os_clock
    mov       [pc_decls.sstime],	rax
    mov       rcx,	[pc_api.mlabelno]
    call      mc_genss.initlib
    xor       eax,	eax
    mov       [mc_decls.ss_zdatalen],	rax
    mov       rcx,	1024
    call      mc_genss.buffercreate
    mov       [mc_decls.ss_zdata],	rax
    mov       rcx,	1024
    call      mc_genss.buffercreate
    mov       [mc_decls.ss_idata],	rax
    mov       rcx,	1024
    call      mc_genss.buffercreate
    mov       [mc_decls.ss_code],	rax
    xor       eax,	eax
    mov       [mc_decls.ss_idatarelocs],	rax
    xor       eax,	eax
    mov       [mc_decls.ss_coderelocs],	rax
    xor       eax,	eax
    mov       [mc_decls.ss_nsymbols],	rax
    mov       rcx,	1
    call      mc_genss.switchseg
    mov       rax,	9999
    mov       [mc_decls.aaseqno],	rax
    xor       eax,	eax
    mov       [mc_genss.extraparam],	rax
    mov       rbx,	[mc_decls.mccode]
    xor       rdi,	rdi
    jmp       L3344
L3343:
    inc       rdi
    mov       rax,	rdi
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mc_genss.doinstr
    mov       rbx,	[rbx+8]
L3344:
    test      rbx,	rbx
    jnz       L3343
    xor       ecx,	ecx
    call      mc_genss.switchseg
    mov       rcx,	[mc_decls.ss_zdata]
    call      mc_genss.bufferlength
    test      rax,	rax
    jz        L3347
    lea       rcx,	[L12481]
    call      mc_libmcl.axerror
L3347:
    test      r14,	r14
    jz        L3349
    mov       rcx,	[mc_decls.ss_code]
    xor       edx,	edx
    call      mc_genss.bufferelemptr
    mov       r12,	rax
    mov       rsi,	[mc_decls.riplist]
    jmp       L3353
L3350:
    mov       eax,	[rsi+8]
    lea       r10,	[r12 + rax]
    mov       r13,	r10
    movsxd    rax,	dword [rsi+12]
    mov       r10,	r13
    sub       [r10],	eax
    mov       rsi,	[rsi]
L3353:
    test      rsi,	rsi
    jnz       L3350
L3349:
    mov       al,	1
    mov       [pc_decls.ssdone],	al
    call      mwindows.os_clock
    sub       rax,	[pc_decls.sstime]
    mov       [pc_decls.sstime],	rax
L3340:
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.doinstr
mc_genss.doinstr:
;?>>
    %define mc_genss.doinstr.m 64
    %define mc_genss.doinstr.index 72
   %define R.a rdi
   %define R.b rbx
   %define R.d rsi
   %define R.x r12
   %define R.offset r13
   %define R.shortjmp r14
    %define mc_genss.doinstr.n -8
    %define mc_genss.doinstr.av_1 -16
    %define mc_genss.doinstr.av_2 -24
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+64],	rcx
;---------------
    mov       rax,	[mc_genss.currdata]
    mov       rax,	[rax+16]
    mov       r10,	[mc_genss.currdata]
    mov       r10,	[r10+8]
    sub       rax,	r10
    cmp       rax,	1024
    jge       L3356
    mov       rcx,	[mc_genss.currdata]
    call      mc_genss.bufferexpand
L3356:
    xor       eax,	eax
    mov       [mc_genss.usesizeb],	al
    mov       [mc_genss.nowmask],	al
    mov       [mc_genss.f3override],	al
    mov       [mc_genss.f2override],	al
    mov       [mc_genss.addroverride],	al
    mov       [mc_genss.sizeoverride],	al
    mov       [mc_genss.rex],	al
    mov       rax,	[rbp + mc_genss.doinstr.m]
    mov       rdi,	[rax+16]
    mov       rax,	[rbp + mc_genss.doinstr.m]
    mov       rbx,	[rax+24]
    mov       rax,	[rbp + mc_genss.doinstr.m]
    mov       eax,	[rax+36]
    mov       [mc_decls.aaseqno],	rax
    xor       eax,	eax
    mov       [mc_genss.ripentry],	rax
    mov       rax,	[rbp + mc_genss.doinstr.m]
    mov       [mc_genss.currmcl],	rax
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+33]
    sub       rax,	1
    cmp       rax,	151
    jae       L3359
    lea       r10,	[L3358]
    jmp       [r10 + rax*8]
    segment .data
L3358:
    dq  L3360
    dq  L3361
    dq  L3483
    dq  L3364
    dq  L3362
    dq  L3363
    dq  L3359
    dq  L3483
    dq  L3371
    dq  L3392
    dq  L3406
    dq  L3401
    dq  L3402
    dq  L3407
    dq  L3465
    dq  L3449
    dq  L3450
    dq  L3408
    dq  L3409
    dq  L3410
    dq  L3376
    dq  L3397
    dq  L3359
    dq  L3398
    dq  L3377
    dq  L3378
    dq  L3411
    dq  L3405
    dq  L3405
    dq  L3405
    dq  L3405
    dq  L3404
    dq  L3404
    dq  L3412
    dq  L3359
    dq  L3404
    dq  L3404
    dq  L3405
    dq  L3405
    dq  L3405
    dq  L3443
    dq  L3405
    dq  L3442
    dq  L3442
    dq  L3442
    dq  L3442
    dq  L3442
    dq  L3442
    dq  L3442
    dq  L3404
    dq  L3404
    dq  L3403
    dq  L3403
    dq  L3393
    dq  L3394
    dq  L3395
    dq  L3396
    dq  L3448
    dq  L3479
    dq  L3479
    dq  L3482
    dq  L3482
    dq  L3451
    dq  L3452
    dq  L3451
    dq  L3452
    dq  L3451
    dq  L3452
    dq  L3451
    dq  L3452
    dq  L3451
    dq  L3452
    dq  L3455
    dq  L3456
    dq  L3456
    dq  L3453
    dq  L3454
    dq  L3453
    dq  L3454
    dq  L3454
    dq  L3454
    dq  L3459
    dq  L3460
    dq  L3461
    dq  L3462
    dq  L3463
    dq  L3464
    dq  L3458
    dq  L3457
    dq  L3475
    dq  L3475
    dq  L3359
    dq  L3359
    dq  L3467
    dq  L3467
    dq  L3467
    dq  L3468
    dq  L3468
    dq  L3468
    dq  L3469
    dq  L3469
    dq  L3469
    dq  L3469
    dq  L3466
    dq  L3466
    dq  L3466
    dq  L3466
    dq  L3466
    dq  L3466
    dq  L3466
    dq  L3466
    dq  L3451
    dq  L3451
    dq  L3452
    dq  L3452
    dq  L3385
    dq  L3386
    dq  L3387
    dq  L3388
    dq  L3390
    dq  L3391
    dq  L3389
    dq  L3426
    dq  L3413
    dq  L3413
    dq  L3413
    dq  L3413
    dq  L3447
    dq  L3444
    dq  L3444
    dq  L3444
    dq  L3445
    dq  L3446
    dq  L3470
    dq  L3471
    dq  L3472
    dq  L3473
    dq  L3474
    dq  L3478
    dq  L3481
    dq  L3476
    dq  L3477
    dq  L3477
    dq  L3477
    dq  L3477
    dq  L3477
    dq  L3477
    dq  L3477
    dq  L3480
    dq  L3359
    dq  L3392
    segment .text
L3360:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    mov       rax,	[rax+16]
    mov       rax,	[rax]
    mov       [mc_decls.currasmproc],	rax
    jmp       L3357
L3361:
    jmp       L3357
L3362:
    jmp       L3357
L3363:
    jmp       L3357
L3364:
    movzx     rax,	word [rdi+8]
    shr       rax,	12
    and       rax,	15
    cmp       rax,	4
    jz        L3366
    cmp       rax,	5
    jz        L3367
    jmp       L3368
L3366:
    jmp       L3365
L3367:
    mov       rsi,	[rdi]
    mov       al,	2
    mov       [rsi+93],	al
    mov       al,	[mc_genss.currseg]
    mov       [rsi+94],	al
    mov       rcx,	6
    call      mc_genss.getcurrdatalen
    mov       [rsi+76],	eax
    mov       al,	[rsi+81]
    test      al,	al
    jz        L3370
    mov       rcx,	rsi
    call      mc_genss.getstindex
L3370:
    mov       rcx,	rsi
    call      mc_genss.dofwdrefs
L3368:
L3365:
    jmp       L3357
L3371:
    movzx     rax,	word [rdi+8]
    shr       rax,	12
    and       rax,	15
    cmp       rax,	5
    jnz       L3373
    mov       rsi,	[rdi]
    jmp       L3372
L3373:
    mov       rax,	[rdi]
    mov       r10,	[mc_decls.labeldeftable]
    mov       r10,	[r10 + rax*8-8]
    mov       rsi,	r10
L3372:
    mov       al,	2
    mov       [rsi+93],	al
    mov       al,	[mc_genss.currseg]
    mov       [rsi+94],	al
    mov       rcx,	6
    call      mc_genss.getcurrdatalen
    mov       [rsi+76],	eax
    mov       al,	[rsi+81]
    test      al,	al
    jz        L3375
    mov       rcx,	rsi
    call      mc_genss.getstindex
L3375:
    mov       rcx,	rsi
    call      mc_genss.dofwdrefs
    jmp       L3357
L3376:
    mov       rcx,	rdi
    call      mc_genss.do_call
    jmp       L3357
L3377:
    mov       rcx,	rdi
    mov       rdx,	[rbp + mc_genss.doinstr.m]
    call      mc_genss.do_jmp
    jmp       L3357
L3378:
    mov       rcx,	rdi
    mov       rdx,	1
    call      mc_genss.getdef
    mov       rsi,	rax
    mov       rcx,	7
    call      mc_genss.getcurrdatalen
    inc       rax
    mov       rcx,	rsi
    mov       rdx,	rax
    call      mc_genss.getrel32
    mov       r13,	rax
    cmp       r13,	0
    jge       L3380
    cmp       r13,	-126
    jge       L3382
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	15
    mov       [r10],	al
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+34]
    mov       r10,	128
    add       r10,	rax
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r11,	[rax]
    inc       qword [rax]
    mov       [r11],	r10b
    lea       rax,	[r13-4]
    mov       rcx,	rax
    call      mc_genss.gendword
    jmp       L3381
L3382:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+34]
    mov       r10,	112
    add       r10,	rax
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r11,	[rax]
    inc       qword [rax]
    mov       [r11],	r10b
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       [r10],	r13b
L3381:
    jmp       L3379
L3380:
    mov       rcx,	[rbp + mc_genss.doinstr.m]
    mov       rdx,	rsi
    call      mc_genss.checkshortjump
    mov       r14,	rax
    test      r14,	r14
    jnz       L3384
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	15
    mov       [r10],	al
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+34]
    mov       r10,	128
    add       r10,	rax
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r11,	[rax]
    inc       qword [rax]
    mov       [r11],	r10b
    mov       rcx,	rdi
    call      mc_genss.genrel32
    jmp       L3383
L3384:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+34]
    mov       r10,	112
    add       r10,	rax
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r11,	[rax]
    inc       qword [rax]
    mov       [r11],	r10b
    mov       rcx,	rdi
    call      mc_genss.genrel8
L3383:
L3379:
    jmp       L3357
L3385:
    mov       rcx,	rdi
    mov       rdx,	1
    call      mc_genss.genopnd
    jmp       L3357
L3386:
    mov       rcx,	rdi
    mov       rdx,	2
    call      mc_genss.genopnd
    jmp       L3357
L3387:
    mov       rcx,	rdi
    mov       rdx,	4
    call      mc_genss.genopnd
    jmp       L3357
L3388:
    mov       rcx,	rdi
    mov       rdx,	8
    call      mc_genss.genopnd
    jmp       L3357
L3389:
    mov       rcx,	1
    call      mc_genss.switchseg
    jmp       L3357
L3390:
    mov       rcx,	2
    call      mc_genss.switchseg
    jmp       L3357
L3391:
    mov       rcx,	3
    call      mc_genss.switchseg
    jmp       L3357
L3392:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+33]
    lea       r10,	[mc_decls.mclcodes]
    mov       r10b,	[r10 + rax-1]
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r11,	[rax]
    inc       qword [rax]
    mov       [r11],	r10b
    jmp       L3357
L3393:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	102
    mov       [r10],	al
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	152
    mov       [r10],	al
    jmp       L3357
L3394:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	102
    mov       [r10],	al
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	153
    mov       [r10],	al
    jmp       L3357
L3395:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	153
    mov       [r10],	al
    jmp       L3357
L3396:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	72
    mov       [r10],	al
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	153
    mov       [r10],	al
    jmp       L3357
L3397:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	195
    mov       [r10],	al
    jmp       L3357
L3398:
    movzx     rax,	word [rdi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	2
    jz        L3400
    lea       rcx,	[L12482]
    call      mc_libmcl.axerror
L3400:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	194
    mov       [r10],	al
    mov       rcx,	[rdi]
    call      mc_genss.genword
    jmp       L3357
L3401:
    mov       rcx,	rdi
    call      mc_genss.do_push
    jmp       L3357
L3402:
    mov       rcx,	rdi
    call      mc_genss.do_pop
    jmp       L3357
L3403:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+33]
    lea       r10,	[mc_decls.mclcodes]
    movzx     r10,	byte [r10 + rax-1]
    mov       rcx,	rdi
    mov       rdx,	r10
    call      mc_genss.do_inc
    jmp       L3357
L3404:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+33]
    lea       r10,	[mc_decls.mclcodes]
    movzx     r10,	byte [r10 + rax-1]
    mov       rcx,	rdi
    mov       rdx,	r10
    call      mc_genss.do_neg
    jmp       L3357
L3405:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+33]
    lea       r10,	[mc_decls.mclcodes]
    movzx     r10,	byte [r10 + rax-1]
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	r10
    call      mc_genss.do_arith
    jmp       L3357
L3406:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_genss.do_mov
    jmp       L3357
L3407:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_genss.do_lea
    jmp       L3357
L3408:
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	190
    call      mc_genss.do_movsx
    jmp       L3357
L3409:
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	182
    call      mc_genss.do_movsx
    jmp       L3357
L3410:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_genss.do_movsxd
    jmp       L3357
L3411:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_genss.do_exch
    jmp       L3357
L3412:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_genss.do_imul2
    jmp       L3357
L3413:
    movzx     rax,	word [rdi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	2
    jnz       L3415
    mov       rax,	[rdi]
    mov       r10,	[rbp + mc_genss.doinstr.m]
    movzx     r10,	byte [r10+33]
    lea       r11,	[mc_decls.mclcodes]
    movzx     r11,	byte [r11 + r10-1]
    imul      rax,	r11
    mov       [rbp + mc_genss.doinstr.n],	rax
    mov       rax,	[mc_genss.currseg]
    cmp       rax,	1
    jz        L3417
    cmp       rax,	2
    jz        L3418
    jmp       L3419
L3417:
    mov       rax,	[rbp + mc_genss.doinstr.n]
    mov       [rbp + mc_genss.doinstr.av_1],	rax
    mov       rax,	[rbp + mc_genss.doinstr.av_1]
    cmp       rax,	0
    jle       L3422
L3420:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	144
    mov       [r10],	al
    dec       qword [rbp + mc_genss.doinstr.av_1]
    jnz       L3420
L3422:
    jmp       L3416
L3418:
    mov       rax,	[rbp + mc_genss.doinstr.n]
    mov       [rbp + mc_genss.doinstr.av_2],	rax
    mov       rax,	[rbp + mc_genss.doinstr.av_2]
    cmp       rax,	0
    jle       L3425
L3423:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    xor       eax,	eax
    mov       [r10],	al
    dec       qword [rbp + mc_genss.doinstr.av_2]
    jnz       L3423
L3425:
    jmp       L3416
L3419:
    mov       rax,	[rbp + mc_genss.doinstr.n]
    add       [mc_decls.ss_zdatalen],	rax
L3416:
    jmp       L3414
L3415:
    lea       rcx,	[L12483]
    call      mc_libmcl.axerror
L3414:
    jmp       L3357
L3426:
    movzx     rax,	word [rdi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	2
    jnz       L3428
    mov       r12,	[rdi]
    cmp       r12,	1
    jl        L3431
    cmp       r12,	16384
    jle       L3430
L3431:
    lea       rcx,	[L12484]
    call      mc_libmcl.axerror
L3430:
    mov       rax,	[mc_genss.currseg]
    cmp       rax,	3
    jz        L3433
    jmp       L3435
L3434:
    mov       rax,	[mc_genss.currseg]
    cmp       rax,	1
    jnz       L3438
    mov       rax,	144
    jmp       L3437
L3438:
    xor       eax,	eax
L3437:
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
L3435:
    mov       rcx,	[mc_genss.currdata]
    call      mc_genss.bufferlength
    mov       r10,	r12
    cqo       
    idiv      r10
    xchg      rax,	rdx
    test      rax,	rax
    jnz       L3434
    jmp       L3432
L3433:
    jmp       L3440
L3439:
    inc       qword [mc_decls.ss_zdatalen]
L3440:
    mov       rax,	[mc_decls.ss_zdatalen]
    mov       r10,	r12
    cqo       
    idiv      r10
    xchg      rax,	rdx
    test      rax,	rax
    jnz       L3439
L3432:
    jmp       L3427
L3428:
    lea       rcx,	[L12485]
    call      mc_libmcl.axerror
L3427:
    jmp       L3357
L3442:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+33]
    lea       r10,	[mc_decls.mclcodes]
    movzx     r10,	byte [r10 + rax-1]
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	r10
    call      mc_genss.do_shift
    jmp       L3357
L3443:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_genss.do_test
    jmp       L3357
L3444:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+33]
    lea       r10,	[mc_decls.mclcodes]
    movzx     r10,	byte [r10 + rax-1]
    mov       rcx,	rdi
    mov       rdx,	r10
    call      mc_genss.do_loop
    jmp       L3357
L3445:
    mov       rcx,	rdi
    mov       rdx,	4
    call      mc_genss.do_jcxz
    jmp       L3357
L3446:
    mov       rcx,	rdi
    mov       rdx,	8
    call      mc_genss.do_jcxz
    jmp       L3357
L3447:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	215
    mov       [r10],	al
    jmp       L3357
L3448:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+34]
    mov       rcx,	rax
    mov       rdx,	rdi
    call      mc_genss.do_setcc
    jmp       L3357
L3449:
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	4
    call      mc_genss.do_movxmm
    jmp       L3357
L3450:
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	8
    call      mc_genss.do_movxmm
    jmp       L3357
L3451:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+33]
    lea       r10,	[mc_decls.mclcodes]
    movzx     r10,	byte [r10 + rax-1]
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	243
    mov       r9,	r10
    call      mc_genss.do_arithxmm
    jmp       L3357
L3452:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+33]
    lea       r10,	[mc_decls.mclcodes]
    movzx     r10,	byte [r10 + rax-1]
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	242
    mov       r9,	r10
    call      mc_genss.do_arithxmm
    jmp       L3357
L3453:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+33]
    lea       r10,	[mc_decls.mclcodes]
    movzx     r10,	byte [r10 + rax-1]
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	r10
    mov       r9,	4
    call      mc_genss.do_logicxmm
    jmp       L3357
L3454:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+33]
    lea       r10,	[mc_decls.mclcodes]
    movzx     r10,	byte [r10 + rax-1]
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	r10
    mov       r9,	8
    call      mc_genss.do_logicxmm
    jmp       L3357
L3455:
    mov       rcx,	rdi
    mov       rdx,	rbx
    xor       r8d,	r8d
    mov       r9,	47
    call      mc_genss.do_arithxmm
    jmp       L3357
L3456:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+33]
    lea       r10,	[mc_decls.mclcodes]
    movzx     r10,	byte [r10 + rax-1]
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	102
    mov       r9,	r10
    call      mc_genss.do_arithxmm
    jmp       L3357
L3457:
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	243
    call      mc_genss.do_convertfloat
    jmp       L3357
L3458:
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	242
    call      mc_genss.do_convertfloat
    jmp       L3357
L3459:
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	243
    mov       r9,	45
    call      mc_genss.do_fix
    jmp       L3357
L3460:
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	242
    mov       r9,	45
    call      mc_genss.do_fix
    jmp       L3357
L3461:
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	243
    mov       r9,	44
    call      mc_genss.do_fix
    jmp       L3357
L3462:
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	242
    mov       r9,	44
    call      mc_genss.do_fix
    jmp       L3357
L3463:
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	243
    call      mc_genss.do_float
    jmp       L3357
L3464:
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	242
    call      mc_genss.do_float
    jmp       L3357
L3465:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+34]
    mov       rcx,	rax
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_genss.do_cmovcc
    jmp       L3357
L3466:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	217
    mov       [r10],	al
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+33]
    lea       r10,	[mc_decls.mclcodes]
    mov       r10b,	[r10 + rax-1]
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r11,	[rax]
    inc       qword [rax]
    mov       [r11],	r10b
    jmp       L3357
L3467:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+33]
    lea       r10,	[mc_decls.mclcodes]
    movzx     r10,	byte [r10 + rax-1]
    mov       rcx,	rdi
    mov       rdx,	1
    mov       r8,	r10
    call      mc_genss.do_fmem
    jmp       L3357
L3468:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+33]
    lea       r10,	[mc_decls.mclcodes]
    movzx     r10,	byte [r10 + rax-1]
    mov       rcx,	rdi
    xor       edx,	edx
    mov       r8,	r10
    call      mc_genss.do_fmem
    jmp       L3357
L3469:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	222
    mov       [r10],	al
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+33]
    lea       r10,	[mc_decls.mclcodes]
    mov       r10b,	[r10 + rax-1]
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r11,	[rax]
    inc       qword [rax]
    mov       [r11],	r10b
    jmp       L3357
L3470:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	166
    mov       [r10],	al
    jmp       L3357
L3471:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	102
    mov       [r10],	al
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	167
    mov       [r10],	al
    jmp       L3357
L3472:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	167
    mov       [r10],	al
    jmp       L3357
L3473:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	72
    mov       [r10],	al
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	167
    mov       [r10],	al
    jmp       L3357
L3474:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	15
    mov       [r10],	al
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+33]
    lea       r10,	[mc_decls.mclcodes]
    mov       r10b,	[r10 + rax-1]
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r11,	[rax]
    inc       qword [rax]
    mov       [r11],	r10b
    jmp       L3357
L3475:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+33]
    lea       r10,	[mc_decls.mclcodes]
    movzx     r10,	byte [r10 + rax-1]
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	r10
    call      mc_genss.do_movdqx
    jmp       L3357
L3476:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	219
    mov       [r10],	al
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	227
    mov       [r10],	al
    jmp       L3357
L3477:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	217
    mov       [r10],	al
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+33]
    lea       r10,	[mc_decls.mclcodes]
    mov       r10b,	[r10 + rax-1]
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r11,	[rax]
    inc       qword [rax]
    mov       [r11],	r10b
    jmp       L3357
L3478:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_genss.do_popcnt
    jmp       L3357
L3479:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+33]
    lea       r10,	[mc_decls.mclcodes]
    movzx     r10,	byte [r10 + rax-1]
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	r10
    call      mc_genss.do_bsf
    jmp       L3357
L3480:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	15
    mov       [r10],	al
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	162
    mov       [r10],	al
    jmp       L3357
L3481:
    mov       rcx,	rdi
    call      mc_genss.do_bswap
    jmp       L3357
L3482:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+33]
    lea       r10,	[mc_decls.mclcodes]
    movzx     r10,	byte [r10 + rax-1]
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+32]
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	rax
    mov       r9,	r10
    call      mc_genss.do_dshift
    jmp       L3357
L3483:
    jmp       L3357
L3359:
    call      msys.m$print_startcon
    lea       rcx,	[L12486]
    call      msys.m$print_str_nf
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+33]
    lea       r10,	[mc_decls.mclnames]
    mov       r10,	[r10 + rax*8-8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    lea       rcx,	[L12487]
    call      msys.m$print_str_nf
    mov       rcx,	[mc_decls.aaseqno]
    call      msys.m$print_i64_nf
    lea       rcx,	[L12488]
    call      msys.m$print_str_nf
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte [rax+33]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    lea       rcx,	[L12489]
    call      msys.m$print_str_nf
    mov       rcx,	151
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L12490]
    call      mc_libmcl.axerror
L3357:
;---------------
    add       rsp,	64
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.start
mc_genss.start:
;?>>
;?]]
;---------------
    mov       al,	64
    lea       r10,	[mc_genss.ishighreg]
    mov       [r10+3],	al
    mov       al,	64
    lea       r10,	[mc_genss.ishighreg]
    mov       [r10+5],	al
    mov       al,	64
    lea       r10,	[mc_genss.ishighreg]
    mov       [r10+14],	al
    mov       al,	64
    lea       r10,	[mc_genss.ishighreg]
    mov       [r10+15],	al
;---------------
    ret       
;End 
;Proc mc_genss.genword
mc_genss.genword:
;?>>
   %define R.x rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	[mc_genss.currdata]
    mov       rdx,	rdi
    call      mc_genss.addword
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genss.gendword
mc_genss.gendword:
;?>>
   %define R.x rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	[mc_genss.currdata]
    mov       rdx,	rdi
    call      mc_genss.adddword
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genss.genqword
mc_genss.genqword:
;?>>
   %define R.x rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	[mc_genss.currdata]
    mov       rdx,	rdi
    call      mc_genss.addqword
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genss.genopnd
mc_genss.genopnd:
;?>>
   %define R.a rsi
   %define R.size r12
   %define R.s rdi
   %define R.length rbx
   %define R.x32 XMM15
    push      rdi
    push      rbx
    push      rsi
    push      r12
    movq      rax,	XMM15
    push      rax
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    test      r12,	r12
    jnz       L3490
    movzx     rax,	word [rsi+8]
    and       rax,	31
    mov       r12,	rax
L3490:
    movzx     rax,	word [rsi+8]
    shr       rax,	12
    and       rax,	15
    cmp       rax,	4
    jz        L3492
    cmp       rax,	7
    jz        L3493
    jmp       L3494
L3492:
    mov       rdi,	[rsi]
    mov       rcx,	rdi
    call      strlen
    mov       rbx,	rax
    cmp       rbx,	100
    jle       L3496
    lea       rax,	[rbx+1]
    mov       r10,	1024
    cmp       r10,	rax
    cmovl     r10,	rax
    mov       rcx,	[mc_genss.currdata]
    mov       rdx,	r10
    call      mc_genss.buffercheck
L3496:
    jmp       L3498
L3497:
    mov       rax,	rdi
    inc       rdi
    mov       al,	[rax]
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
L3498:
    mov       al,	[rdi]
    test      al,	al
    jnz       L3497
    jmp       L3488
L3493:
    call      msys.m$print_startcon
    lea       rcx,	[L12491]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L3494:
L3491:
    mov       rcx,	rsi
    xor       edx,	edx
    call      mc_genss.getdef
    test      rax,	rax
    jz        L3501
    cmp       r12,	2
    jg        L3501
    lea       rcx,	[L12492]
    call      mc_libmcl.axerror
L3501:
    mov       rax,	r12
    cmp       rax,	1
    jz        L3503
    cmp       rax,	2
    jz        L3504
    cmp       rax,	4
    jz        L3505
    cmp       rax,	8
    jz        L3506
    jmp       L3507
L3503:
    mov       rax,	[rsi]
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
    jmp       L3502
L3504:
    mov       rcx,	[rsi]
    call      mc_genss.genword
    jmp       L3502
L3505:
    movzx     rax,	word [rsi+8]
    shr       rax,	12
    and       rax,	15
    cmp       rax,	1
    jz        L3509
    cmp       rax,	2
    jz        L3510
    cmp       rax,	5
    jz        L3511
    cmp       rax,	6
    jz        L3511
    jmp       L3512
L3509:
    mov       rcx,	[rsi]
    call      mc_genss.gendword
    jmp       L3508
L3510:
    movq      XMM4,	[rsi]
    cvtsd2ss  XMM4,	XMM4
    movq      XMM15,	XMM4
    movq      XMM4,	XMM15
    movq      rax,	XMM4
    mov       rcx,	rax
    call      mc_genss.gendword
    jmp       L3508
L3511:
    mov       rcx,	rsi
    call      mc_genss.genabs32
    jmp       L3508
L3512:
    call      msys.m$print_startcon
    movzx     rax,	word [rsi+8]
    shr       rax,	12
    and       rax,	15
    lea       r10,	[mc_decls.valtypenames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L12493]
    call      mc_libmcl.axerror
L3508:
    jmp       L3502
L3506:
    movzx     rax,	word [rsi+8]
    shr       rax,	12
    and       rax,	15
    cmp       rax,	1
    jz        L3514
    cmp       rax,	2
    jz        L3515
    cmp       rax,	5
    jz        L3516
    cmp       rax,	6
    jz        L3516
    jmp       L3517
L3514:
    mov       rcx,	[rsi]
    call      mc_genss.genqword
    jmp       L3513
L3515:
    movq      XMM4,	[rsi]
    movq      rax,	XMM4
    mov       rcx,	rax
    call      mc_genss.genqword
    jmp       L3513
L3516:
    mov       rcx,	rsi
    call      mc_genss.genabs64
    jmp       L3513
L3517:
    call      msys.m$print_startcon
    movzx     rax,	word [rsi+8]
    shr       rax,	12
    and       rax,	15
    lea       r10,	[mc_decls.valtypenames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L12494]
    call      mc_libmcl.axerror
L3513:
L3507:
L3502:
L3488:
;---------------
    add       rsp,	48
    pop       rcx
    movq      XMM15,	rcx
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.addrelocitem
mc_genss.addrelocitem:
;?>>
   %define R.reloctype r12
   %define R.d r13
   %define R.r rdi
   %define R.stindex rbx
   %define R.adjust rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r12,	rcx
    mov       r13,	rdx
;---------------
    mov       rcx,	r13
    call      mc_genss.getstindex
    mov       rbx,	rax
    mov       rsi,	4
    cmp       r12,	1
    jnz       L3520
    mov       rsi,	8
L3520:
    mov       rcx,	32
    call      mlib.pcm_allocnfz
    mov       rdi,	rax
    mov       rax,	[mc_genss.currrelocs]
    mov       [rdi],	rax
    mov       [rdi+8],	r12
    mov       rcx,	1
    call      mc_genss.getcurrdatalen
    sub       rax,	rsi
    mov       [rdi+16],	rax
    mov       [rdi+24],	rbx
    inc       qword [mc_genss.nrelocs]
    mov       [mc_genss.currrelocs],	rdi
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.getstindex
mc_genss.getstindex:
;?>>
   %define R.d rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    movsx     rax,	word [rdi+96]
    test      rax,	rax
    jnz       L3523
    mov       rax,	[mc_decls.ss_nsymbols]
    cmp       rax,	[mc_decls.ss_symboltablesize]
    jl        L3525
    call      mc_genss.extendsymboltable
L3525:
    inc       qword [mc_decls.ss_nsymbols]
    mov       rax,	[mc_decls.ss_nsymbols]
    mov       [rdi+96],	ax
    movsx     rax,	word [rdi+96]
    mov       r10,	rdi
    mov       r11,	[mc_decls.ss_symboltable]
    mov       [r11 + rax*8-8],	r10
    movzx     rax,	byte [rdi+94]
    test      rax,	rax
    jnz       L3527
    mov       al,	[rdi+80]
    test      al,	al
    jz        L3529
    mov       al,	1
    mov       [rdi+94],	al
L3529:
L3527:
L3523:
    movsx     rax,	word [rdi+96]
L3521:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genss.genrel32
mc_genss.genrel32:
;?>>
   %define R.a rbx
   %define R.d rdi
    %define mc_genss.genrel32.$T1 -8
    push      rdi
    push      rbx
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       rbx,	rcx
;---------------
    mov       rcx,	rbx
    xor       edx,	edx
    call      mc_genss.getdef
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L3532
    mov       rcx,	[rbx]
    call      mc_genss.gendword
    jmp       L3530
L3532:
    movzx     rax,	byte [rdi+93]
    cmp       rax,	2
    jz        L3534
    cmp       rax,	1
    jz        L3535
    jmp       L3536
L3534:
    movzx     rax,	byte [rdi+94]
    cmp       rax,	[mc_genss.currseg]
    jz        L3538
    lea       rcx,	[L12495]
    call      mc_libmcl.axerror
L3538:
    movsxd    rax,	dword [rdi+76]
    mov       [rbp + mc_genss.genrel32.$T1],	rax
    mov       rcx,	2
    call      mc_genss.getcurrdatalen
    add       rax,	4
    mov       r10,	[rbp + mc_genss.genrel32.$T1]
    sub       r10,	rax
    movsxd    rax,	dword [rbx+12]
    add       r10,	rax
    mov       rcx,	r10
    call      mc_genss.gendword
    jmp       L3533
L3535:
    mov       rcx,	3
    call      mc_genss.getcurrdatalen
    mov       r10,	[rdi+64]
    mov       rcx,	r10
    mov       rdx,	rax
    mov       r8,	4
    xor       r9d,	r9d
    call      mc_genss.addfwdref
    mov       [rdi+64],	rax
    movsxd    rax,	dword [rbx+12]
    mov       rcx,	rax
    call      mc_genss.gendword
    jmp       L3533
L3536:
    movsxd    rax,	dword [rbx+12]
    mov       rcx,	rax
    call      mc_genss.gendword
    mov       rcx,	4
    mov       rdx,	rdi
    call      mc_genss.addrelocitem
L3533:
L3530:
;---------------
    add       rsp,	48
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.getdef
mc_genss.getdef:
;?>>
   %define R.a rbx
   %define R.dneeded rsi
   %define R.d rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jz        L3542
    cmp       rax,	2
    jnz       L3541
L3542:
    movzx     rax,	word [rbx+8]
    shr       rax,	12
    and       rax,	15
    cmp       rax,	6
    jz        L3544
    cmp       rax,	5
    jz        L3545
    jmp       L3546
L3544:
    mov       rax,	[rbx]
    mov       r10,	[mc_decls.labeldeftable]
    mov       r10,	[r10 + rax*8-8]
    mov       rax,	r10
    jmp       L3539
L3545:
    mov       rdi,	[rbx]
    movzx     rax,	byte [rdi+93]
    test      rax,	rax
    jnz       L3548
    mov       al,	[rdi+80]
    test      al,	al
    jnz       L3550
    mov       al,	1
    mov       [rdi+93],	al
L3550:
L3548:
    mov       rax,	rdi
    jmp       L3539
L3546:
L3543:
L3541:
    test      rsi,	rsi
    jz        L3552
    call      msys.m$print_startcon
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    lea       r10,	[mc_decls.opndnames_ma]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    movzx     rax,	word [rbx+8]
    shr       rax,	12
    and       rax,	15
    lea       r10,	[mc_decls.valtypenames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L12496]
    call      mc_libmcl.axerror
L3552:
    xor       eax,	eax
L3539:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.genabs32
mc_genss.genabs32:
;?>>
   %define R.a rbx
   %define R.d rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rcx,	rbx
    mov       rdx,	1
    call      mc_genss.getdef
    mov       rdi,	rax
    movzx     rax,	byte [rdi+93]
    cmp       rax,	2
    jz        L3555
    cmp       rax,	1
    jz        L3556
    jmp       L3557
L3555:
    movsxd    rax,	dword [rdi+76]
    movsxd    r10,	dword [rbx+12]
    add       rax,	r10
    mov       rcx,	rax
    call      mc_genss.gendword
    mov       rcx,	2
    mov       rdx,	rdi
    call      mc_genss.addrelocitem
    jmp       L3554
L3556:
    mov       rcx,	4
    call      mc_genss.getcurrdatalen
    mov       r10,	[rdi+64]
    mov       rcx,	r10
    mov       rdx,	rax
    mov       r8,	2
    mov       r9,	[mc_genss.currseg]
    call      mc_genss.addfwdref
    mov       [rdi+64],	rax
    movzx     rax,	byte [rdi+72]
    cmp       rax,	4
    jz        L3560
    cmp       rax,	5
    jnz       L3559
L3560:
    movsxd    rax,	dword [rdi+76]
    movsxd    r10,	dword [rbx+12]
    add       rax,	r10
    mov       rcx,	rax
    call      mc_genss.gendword
    jmp       L3558
L3559:
    movsxd    rax,	dword [rbx+12]
    mov       rcx,	rax
    call      mc_genss.gendword
    mov       rcx,	2
    mov       rdx,	rdi
    call      mc_genss.addrelocitem
L3558:
    jmp       L3554
L3557:
    movsxd    rax,	dword [rbx+12]
    mov       rcx,	rax
    call      mc_genss.gendword
    mov       rcx,	2
    mov       rdx,	rdi
    call      mc_genss.addrelocitem
L3554:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.genabs64
mc_genss.genabs64:
;?>>
   %define R.a rbx
   %define R.d rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rcx,	rbx
    mov       rdx,	1
    call      mc_genss.getdef
    mov       rdi,	rax
    movzx     rax,	byte [rdi+93]
    cmp       rax,	2
    jz        L3563
    cmp       rax,	1
    jz        L3564
    jmp       L3565
L3563:
    movsxd    rax,	dword [rdi+76]
    movsxd    r10,	dword [rbx+12]
    add       rax,	r10
    mov       rcx,	rax
    call      mc_genss.genqword
    mov       rcx,	1
    mov       rdx,	rdi
    call      mc_genss.addrelocitem
    jmp       L3562
L3564:
    mov       rcx,	5
    call      mc_genss.getcurrdatalen
    mov       r10,	[rdi+64]
    mov       rcx,	r10
    mov       rdx,	rax
    mov       r8,	1
    mov       r9,	[mc_genss.currseg]
    call      mc_genss.addfwdref
    mov       [rdi+64],	rax
    movzx     rax,	byte [rdi+72]
    cmp       rax,	4
    jz        L3568
    cmp       rax,	5
    jnz       L3567
L3568:
    movsxd    rax,	dword [rdi+76]
    movsxd    r10,	dword [rbx+12]
    add       rax,	r10
    mov       rcx,	rax
    call      mc_genss.genqword
    jmp       L3566
L3567:
    movsxd    rax,	dword [rbx+12]
    mov       rcx,	rax
    call      mc_genss.genqword
    mov       rcx,	1
    mov       rdx,	rdi
    call      mc_genss.addrelocitem
L3566:
    jmp       L3562
L3565:
    movsxd    rax,	dword [rbx+12]
    mov       rcx,	rax
    call      mc_genss.genqword
    mov       rcx,	1
    mov       rdx,	rdi
    call      mc_genss.addrelocitem
L3562:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.getrel32
mc_genss.getrel32:
;?>>
   %define R.d rdi
   %define R.offset rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    movzx     rax,	byte [rdi+93]
    cmp       rax,	2
    jnz       L3571
    movzx     rax,	byte [rdi+94]
    cmp       rax,	[mc_genss.currseg]
    jz        L3573
    lea       rcx,	[L12497]
    call      mc_libmcl.axerror
L3573:
    movsxd    rax,	dword [rdi+76]
    lea       r10,	[rbx+1]
    sub       rax,	r10
    jmp       L3570
L3571:
    mov       rax,	2147483647
L3570:
L3569:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.dofwdrefs
mc_genss.dofwdrefs:
;?>>
   %define R.d r15
   %define R.f rdi
   %define R.offset rbx
   %define R.p8 rsi
   %define R.p32 r12
   %define R.p64 r13
   %define R.data r14
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    sub       rsp,	48
    mov       r15,	rcx
;---------------
    mov       rax,	[r15+64]
    test      rax,	rax
    jz        L3574
L3576:
    mov       rdi,	[r15+64]
    jmp       L3578
L3577:
    movsxd    rax,	dword [rdi+8]
    mov       rbx,	rax
    movsx     rax,	word [rdi+12]
    cmp       rax,	4
    jz        L3581
    cmp       rax,	2
    jz        L3582
    cmp       rax,	1
    jz        L3582
    cmp       rax,	6
    jz        L3583
    jmp       L3584
L3581:
    mov       rcx,	[mc_genss.currdata]
    mov       rdx,	rbx
    call      mc_genss.bufferelemptr
    mov       r12,	rax
    movsxd    rax,	dword [r15+76]
    sub       rax,	rbx
    sub       rax,	4
    mov       [r12],	eax
    jmp       L3580
L3582:
    movsx     rax,	word [rdi+14]
    cmp       rax,	1
    jz        L3586
    cmp       rax,	3
    jz        L3587
    cmp       rax,	2
    jz        L3588
    jmp       L3589
L3586:
    mov       r14,	[mc_decls.ss_code]
    jmp       L3585
L3587:
    lea       rcx,	[L12498]
    call      mc_libmcl.axerror
    jmp       L3585
L3588:
    mov       r14,	[mc_decls.ss_idata]
L3589:
L3585:
    mov       rcx,	r14
    mov       rdx,	rbx
    call      mc_genss.bufferelemptr
    mov       r12,	rax
    movsx     rax,	word [rdi+12]
    cmp       rax,	2
    jnz       L3591
    movsxd    rax,	dword [r12]
    movsxd    r10,	dword [r15+76]
    add       rax,	r10
    mov       [r12],	eax
    jmp       L3590
L3591:
    mov       r13,	r12
    mov       rax,	[r13]
    movsxd    r10,	dword [r15+76]
    add       rax,	r10
    mov       [r13],	rax
L3590:
    jmp       L3580
L3583:
    mov       rcx,	[mc_genss.currdata]
    mov       rdx,	rbx
    call      mc_genss.bufferelemptr
    mov       rsi,	rax
    movsxd    rax,	dword [r15+76]
    sub       rax,	rbx
    dec       rax
    mov       [rsi],	al
    jmp       L3580
L3584:
    call      msys.m$print_startcon
    movsx     rax,	word [rdi+12]
    lea       r10,	[mc_objdecls.relocnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    mov       rcx,	[r15]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L12499]
    call      mc_libmcl.axerror
L3580:
    mov       rdi,	[rdi]
L3578:
    test      rdi,	rdi
    jnz       L3577
L3574:
;---------------
    add       rsp,	48
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.genrex
mc_genss.genrex:
;?>>
;?]]
;---------------
    mov       al,	[mc_genss.f2override]
    test      al,	al
    jz        L3594
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	242
    mov       [r10],	al
L3594:
    mov       al,	[mc_genss.f3override]
    test      al,	al
    jz        L3596
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	243
    mov       [r10],	al
L3596:
    mov       al,	[mc_genss.sizeoverride]
    test      al,	al
    jz        L3598
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	102
    mov       [r10],	al
L3598:
    mov       al,	[mc_genss.addroverride]
    test      al,	al
    jz        L3600
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	103
    mov       [r10],	al
L3600:
    mov       al,	[mc_genss.nowmask]
    test      al,	al
    jz        L3602
    and       byte [mc_genss.rex],	247
L3602:
    mov       al,	[mc_genss.rex]
    test      al,	al
    jz        L3604
    movzx     rax,	byte [mc_genss.rex]
    and       rax,	15
    add       rax,	64
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
L3604:
;---------------
    ret       
;End 
;Proc mc_genss.isbytesized
mc_genss.isbytesized:
;?>>
   %define R.x rcx
;?]]
;---------------
    mov       rax,	rcx
    cmp       rax,	-128
    jl        L3606
    cmp       rax,	127
    jg        L3606
    mov       rax,	1
    jmp       L3607
L3606:
    xor       eax,	eax
L3607:
L3605:
;---------------
    ret       
;End 
;Proc mc_genss.isdwordsized
mc_genss.isdwordsized:
;?>>
   %define R.x rcx
;?]]
;---------------
    mov       rax,	rcx
    cmp       rax,	-2147483648
    jl        L3609
    cmp       rax,	2147483647
    jg        L3609
    mov       rax,	1
    jmp       L3610
L3609:
    xor       eax,	eax
L3610:
L3608:
;---------------
    ret       
;End 
;Proc mc_genss.genamode
mc_genss.genamode:
;?>>
   %define R.a rbx
    %define mc_genss.genamode.am 40
   %define R.pr rdi
    push      rdi
    push      rbx
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       rbx,	rcx
    mov       [rbp+40],	rdx
;---------------
    mov       al,	[rbp + mc_genss.genamode.am]
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
    movsx     rax,	byte [rbp + mc_genss.genamode.am+2]
    cmp       rax,	1
    jnz       L3613
    mov       al,	[rbp + mc_genss.genamode.am+1]
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
L3613:
    movzx     rax,	byte [rbp + mc_genss.genamode.am+3]
    test      rax,	rax
    jz        L3615
    cmp       rax,	1
    jz        L3616
    cmp       rax,	4
    jz        L3617
    jmp       L3618
L3615:
    jmp       L3614
L3616:
    mov       eax,	[rbp + mc_genss.genamode.am+4]
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
    jmp       L3614
L3617:
    movsx     rax,	byte [rbp + mc_genss.genamode.am+2]
    cmp       rax,	-1
    jnz       L3620
    mov       rcx,	16
    call      mlib.pcm_alloc
    mov       rdi,	rax
    mov       rax,	[mc_decls.riplist]
    mov       [rdi],	rax
    mov       rax,	[mc_genss.currdata]
    mov       rax,	[rax+8]
    mov       r10,	[mc_genss.currdata]
    mov       r10,	[r10]
    sub       rax,	r10
    mov       [rdi+8],	eax
    mov       rax,	rdi
    mov       [mc_decls.riplist],	rax
    mov       [mc_genss.ripentry],	rax
L3620:
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jnz       L3623
L3622:
    movzx     rax,	word [rbx+8]
    shr       rax,	12
    and       rax,	15
    cmp       rax,	5
    jz        L3625
    cmp       rax,	6
    jz        L3625
    test      rax,	rax
    jz        L3626
    cmp       rax,	8
    jz        L3626
    jmp       L3627
L3625:
    mov       rcx,	rbx
    call      mc_genss.genabs32
    jmp       L3624
L3626:
    movsxd    rax,	dword [rbp + mc_genss.genamode.am+4]
    mov       rcx,	rax
    call      mc_genss.gendword
    jmp       L3624
L3627:
    lea       rcx,	[L12500]
    call      mc_libmcl.axerror
L3624:
    jmp       L3621
L3623:
    call      msys.m$print_startcon
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    lea       r10,	[mc_decls.opndnames_ma]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L12501]
    call      mc_libmcl.axerror
L3621:
    jmp       L3614
L3618:
    lea       rcx,	[L12502]
    call      mc_libmcl.axerror
L3614:
;---------------
    add       rsp,	32
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.setopsize
mc_genss.setopsize:
;?>>
   %define R.a rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    movzx     rax,	word [rdi+8]
    and       rax,	31
    cmp       rax,	8
    jz        L3630
    cmp       rax,	4
    jz        L3631
    cmp       rax,	1
    jz        L3632
    cmp       rax,	2
    jz        L3633
    jmp       L3634
L3630:
    mov       al,	8
    or        [mc_genss.rex],	al
    jmp       L3629
L3631:
    jmp       L3629
L3632:
    jmp       L3629
L3633:
    mov       al,	1
    mov       [mc_genss.sizeoverride],	al
    jmp       L3629
L3634:
    lea       rcx,	[L12503]
    call      mc_libmcl.axerror
L3629:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genss.getdispsize
mc_genss.getdispsize:
;?>>
   %define R.a rbx
   %define R.offset rsi
   %define R.d rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    mov       rcx,	rbx
    xor       edx,	edx
    call      mc_genss.getdef
    mov       rdi,	rax
    mov       eax,	[rbx+12]
    mov       [rsi],	eax
    test      rdi,	rdi
    jz        L3637
    movzx     rax,	byte [rdi+72]
    cmp       rax,	4
    jz        L3640
    cmp       rax,	5
    jnz       L3639
L3640:
    movsxd    rax,	dword [rdi+76]
    mov       r10,	rsi
    add       [r10],	eax
    jmp       L3638
L3639:
    mov       rax,	4
    jmp       L3635
L3638:
L3637:
    mov       eax,	[rsi]
    test      eax,	eax
    jz        L3642
    movsxd    rax,	dword [rsi]
    mov       rcx,	rax
    call      mc_genss.isbytesized
    test      rax,	rax
    jz        L3644
    mov       rax,	1
    jmp       L3643
L3644:
    mov       rax,	4
L3643:
    jmp       L3641
L3642:
    xor       eax,	eax
L3641:
L3635:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.checkhighreg
mc_genss.checkhighreg:
;?>>
   %define R.a rcx
;?]]
;---------------
    movzx     rax,	word [rcx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jnz       L3647
    movzx     rax,	byte [rcx+10]
    lea       r10,	[mc_genss.ishighreg]
    movzx     r10,	byte [r10 + rax-1]
    or        [mc_genss.rex],	r10b
L3647:
;---------------
    ret       
;End 
;Proc mc_genss.do_loop
mc_genss.do_loop:
;?>>
   %define R.a rbx
   %define R.opc rsi
   %define R.offset rdi
    %define mc_genss.do_loop.$T1 -8
    push      rdi
    push      rbx
    push      rsi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    mov       rcx,	9
    call      mc_genss.getcurrdatalen
    inc       rax
    mov       [rbp + mc_genss.do_loop.$T1],	rax
    mov       rcx,	rbx
    mov       rdx,	1
    call      mc_genss.getdef
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_genss.do_loop.$T1]
    call      mc_genss.getrel32
    mov       rdi,	rax
    cmp       rdi,	0
    jge       L3650
    cmp       rdi,	-126
    jge       L3652
    lea       rcx,	[L12504]
    call      mc_libmcl.axerror
L3652:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       [r10],	sil
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       [r10],	dil
    jmp       L3649
L3650:
    lea       rcx,	[L12505]
    call      mc_libmcl.axerror
L3649:
;---------------
    add       rsp,	40
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.do_jcxz
mc_genss.do_jcxz:
;?>>
   %define R.a rbx
   %define R.opsize rsi
   %define R.offset rdi
    %define mc_genss.do_jcxz.$T1 -8
    push      rdi
    push      rbx
    push      rsi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    mov       rcx,	10
    call      mc_genss.getcurrdatalen
    inc       rax
    mov       [rbp + mc_genss.do_jcxz.$T1],	rax
    mov       rcx,	rbx
    mov       rdx,	1
    call      mc_genss.getdef
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_genss.do_jcxz.$T1]
    call      mc_genss.getrel32
    mov       rdi,	rax
    cmp       rdi,	0
    jge       L3655
    cmp       rdi,	-126
    jge       L3657
    lea       rcx,	[L12506]
    call      mc_libmcl.axerror
L3657:
    cmp       rsi,	4
    jnz       L3659
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	103
    mov       [r10],	al
L3659:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	227
    mov       [r10],	al
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       [r10],	dil
    jmp       L3654
L3655:
    lea       rcx,	[L12507]
    call      mc_libmcl.axerror
L3654:
;---------------
    add       rsp,	40
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.do_call
mc_genss.do_call:
;?>>
   %define R.a rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    movzx     rax,	word [rdi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	2
    jnz       L3663
L3662:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	232
    mov       [r10],	al
    mov       rcx,	rdi
    call      mc_genss.genrel32
    jmp       L3661
L3663:
    movzx     rax,	word [rdi+8]
    and       rax,	31
    test      rax,	rax
    jz        L3665
    cmp       rax,	1
    jz        L3666
    cmp       rax,	2
    jz        L3666
    cmp       rax,	4
    jz        L3666
    jmp       L3667
L3665:
    lea       rax,	[rdi+8]
    mov       r10w,	8
    mov       r9w,	[rax]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    jmp       L3664
L3666:
    lea       rcx,	[L12508]
    call      mc_libmcl.axerror
L3667:
L3664:
    mov       rcx,	255
    mov       rdx,	2
    mov       r8,	rdi
    call      mc_genss.genxrm
L3661:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genss.do_jmp
mc_genss.do_jmp:
;?>>
   %define R.a r12
   %define R.m r13
   %define R.offset rdi
   %define R.shortjmp rbx
   %define R.d rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r12,	rcx
    mov       r13,	rdx
;---------------
    mov       rcx,	r12
    xor       edx,	edx
    call      mc_genss.getdef
    mov       rsi,	rax
    movzx     rax,	word [r12+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	2
    jnz       L3671
L3670:
    mov       rcx,	11
    call      mc_genss.getcurrdatalen
    inc       rax
    mov       rcx,	rsi
    mov       rdx,	rax
    call      mc_genss.getrel32
    mov       rdi,	rax
    cmp       rdi,	0
    jge       L3673
    cmp       rdi,	-126
    jle       L3673
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	235
    mov       [r10],	al
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       [r10],	dil
    jmp       L3672
L3673:
    xor       rbx,	rbx
    mov       rax,	rdi
    cmp       rax,	0
    jle       L3675
    mov       rcx,	r13
    mov       rdx,	rsi
    call      mc_genss.checkshortjump
    mov       rbx,	rax
L3675:
    test      rbx,	rbx
    jnz       L3677
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	233
    mov       [r10],	al
    mov       rcx,	r12
    call      mc_genss.genrel32
    jmp       L3676
L3677:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	235
    mov       [r10],	al
    mov       rcx,	r12
    call      mc_genss.genrel8
L3676:
L3672:
    jmp       L3669
L3671:
    movzx     rax,	word [r12+8]
    and       rax,	31
    test      rax,	rax
    jz        L3679
    cmp       rax,	1
    jz        L3680
    cmp       rax,	2
    jz        L3680
    cmp       rax,	4
    jz        L3680
    jmp       L3681
L3679:
    lea       rax,	[r12+8]
    mov       r10w,	8
    mov       r9w,	[rax]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    jmp       L3678
L3680:
    lea       rcx,	[L12509]
    call      mc_libmcl.axerror
L3681:
L3678:
    mov       rcx,	255
    mov       rdx,	4
    mov       r8,	r12
    call      mc_genss.genxrm
L3669:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.getcurrdatalen
mc_genss.getcurrdatalen:
;?>>
    %define mc_genss.getcurrdatalen.id 16
;?]]
    sub       rsp,	40
;---------------
    mov       rax,	[mc_genss.currseg]
    cmp       rax,	3
    jnz       L3684
    mov       rax,	[mc_decls.ss_zdatalen]
    jmp       L3682
L3684:
    mov       rcx,	[mc_genss.currdata]
    call      mc_genss.bufferlength
L3682:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mc_genss.do_cmovcc
mc_genss.do_cmovcc:
;?>>
   %define R.cond rdi
   %define R.a rbx
   %define R.b rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    movzx     rax,	word [rbx+8]
    and       rax,	31
    movzx     r10,	word [rsi+8]
    and       r10,	31
    cmp       rax,	r10
    jz        L3687
    movzx     rax,	word [rsi+8]
    and       rax,	31
    jz        L3687
    lea       rcx,	[L12510]
    call      mc_libmcl.axerror
L3687:
    movzx     rax,	word [rbx+8]
    and       rax,	31
    cmp       rax,	1
    jnz       L3689
    lea       rcx,	[L12511]
    call      mc_libmcl.axerror
L3689:
    mov       rax,	3904
    add       rax,	rdi
    mov       rcx,	rax
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mc_genss.genrrm
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.do_fmem
mc_genss.do_fmem:
;?>>
   %define R.a rbx
   %define R.freal rsi
   %define R.code r12
   %define R.mf rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
;---------------
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jz        L3692
    lea       rcx,	[L12512]
    call      mc_libmcl.axerror
L3692:
    test      rsi,	rsi
    jz        L3694
    movzx     rax,	word [rbx+8]
    and       rax,	31
    cmp       rax,	4
    jz        L3696
    cmp       rax,	8
    jz        L3697
    cmp       rax,	10
    jz        L3698
    cmp       rax,	16
    jz        L3698
    jmp       L3699
L3696:
    xor       rdi,	rdi
    jmp       L3695
L3697:
    mov       rdi,	2
    jmp       L3695
L3698:
    mov       rdi,	1
    mov       rax,	r12
    test      rax,	rax
    jz        L3701
    cmp       rax,	3
    jz        L3702
    jmp       L3703
L3701:
    mov       r12,	5
    jmp       L3700
L3702:
    mov       r12,	7
    jmp       L3700
L3703:
    lea       rcx,	[L12513]
    call      mc_libmcl.axerror
L3700:
    jmp       L3695
L3699:
    call      msys.m$print_startcon
    lea       rcx,	[L12514]
    call      msys.m$print_str_nf
    movzx     rax,	word [rbx+8]
    and       rax,	31
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.m$print_u64
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L12515]
    call      mc_libmcl.axerror
L3695:
    jmp       L3693
L3694:
    movzx     rax,	word [rbx+8]
    and       rax,	31
    cmp       rax,	2
    jz        L3705
    cmp       rax,	4
    jz        L3706
    cmp       rax,	8
    jz        L3707
    jmp       L3708
L3705:
    mov       rdi,	3
    jmp       L3704
L3706:
    mov       rdi,	1
    jmp       L3704
L3707:
    mov       rdi,	3
    mov       rax,	r12
    test      rax,	rax
    jz        L3710
    cmp       rax,	3
    jz        L3711
    jmp       L3712
L3710:
    mov       r12,	5
    jmp       L3709
L3711:
    mov       r12,	7
    jmp       L3709
L3712:
    lea       rcx,	[L12516]
    call      mc_libmcl.axerror
L3709:
    jmp       L3704
L3708:
    lea       rcx,	[L12517]
    call      mc_libmcl.axerror
L3704:
L3693:
    mov       rax,	rdi
    shl       rax,	1
    mov       r10,	217
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	r12
    mov       r8,	rbx
    call      mc_genss.genxrm
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.genrel8
mc_genss.genrel8:
;?>>
   %define R.a rbx
   %define R.d rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rcx,	rbx
    mov       rdx,	1
    call      mc_genss.getdef
    mov       rdi,	rax
    movzx     rax,	byte [rdi+93]
    cmp       rax,	1
    jnz       L3715
    mov       rcx,	3
    call      mc_genss.getcurrdatalen
    mov       r10,	[rdi+64]
    mov       rcx,	r10
    mov       rdx,	rax
    mov       r8,	6
    xor       r9d,	r9d
    call      mc_genss.addfwdref
    mov       [rdi+64],	rax
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    xor       eax,	eax
    mov       [r10],	al
    jmp       L3714
L3715:
    lea       rcx,	[L12518]
    call      mc_libmcl.axerror
L3714:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.checkshortjump
mc_genss.checkshortjump:
;?>>
   %define R.m rcx
   %define R.d rdx
   %define R.n rdi
   %define R.a rbx
    push      rdi
    push      rbx
;?]]
;---------------
    xor       rdi,	rdi
    mov       rax,	[rcx+8]
    mov       rcx,	rax
    jmp       L3718
L3717:
    movzx     rax,	byte [rcx+33]
    cmp       rax,	9
    jz        L3721
    cmp       rax,	3
    jz        L3722
    cmp       rax,	8
    jz        L3722
    cmp       rax,	124
    jz        L3723
    jmp       L3724
L3721:
    mov       rbx,	[rcx+16]
    movzx     rax,	word [rbx+8]
    shr       rax,	12
    and       rax,	15
    cmp       rax,	6
    jz        L3726
    cmp       rax,	5
    jz        L3727
    jmp       L3728
L3726:
    mov       rax,	[rbx]
    movsxd    r10,	dword [rdx+100]
    cmp       rax,	r10
    jnz       L3730
    mov       rax,	1
    jmp       L3716
L3730:
    jmp       L3725
L3727:
    mov       rax,	[rbx]
    cmp       rax,	rdx
    jnz       L3732
    mov       rax,	1
    jmp       L3716
L3732:
L3728:
L3725:
    jmp       L3720
L3722:
    jmp       L3720
L3723:
    xor       eax,	eax
    jmp       L3716
L3724:
    inc       rdi
L3720:
    mov       rax,	[rcx+8]
    mov       rcx,	rax
L3718:
    test      rcx,	rcx
    jz        L3733
    cmp       rdi,	8
    jle       L3717
L3733:
    xor       eax,	eax
L3716:
;---------------
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.addfwdref
mc_genss.addfwdref:
;?>>
   %define R.p rbx
   %define R.offset rsi
   %define R.reltype r12
   %define R.seg r13
   %define R.q rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
    mov       r13,	r9
;---------------
    mov       rcx,	16
    call      mlib.pcm_allocnfz
    mov       rdi,	rax
    mov       [rdi],	rbx
    mov       [rdi+8],	esi
    mov       [rdi+12],	r12w
    mov       [rdi+14],	r13w
    mov       rax,	rdi
L3734:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.switchseg
mc_genss.switchseg:
;?>>
   %define R.newseg rcx
;?]]
;---------------
    cmp       rcx,	[mc_genss.currseg]
    jz        L3735
L3737:
    mov       rax,	[mc_genss.currseg]
    cmp       rax,	1
    jz        L3739
    cmp       rax,	2
    jz        L3740
    jmp       L3741
L3739:
    mov       rax,	[mc_genss.currrelocs]
    mov       [mc_decls.ss_coderelocs],	rax
    mov       rax,	[mc_genss.nrelocs]
    mov       [mc_decls.ss_ncoderelocs],	rax
    jmp       L3738
L3740:
    mov       rax,	[mc_genss.currrelocs]
    mov       [mc_decls.ss_idatarelocs],	rax
    mov       rax,	[mc_genss.nrelocs]
    mov       [mc_decls.ss_nidatarelocs],	rax
L3741:
L3738:
    mov       [mc_genss.currseg],	rcx
    mov       rax,	[mc_genss.currseg]
    cmp       rax,	1
    jz        L3743
    cmp       rax,	2
    jz        L3744
    cmp       rax,	3
    jz        L3745
    jmp       L3746
L3743:
    mov       rax,	[mc_decls.ss_code]
    mov       [mc_genss.currdata],	rax
    mov       rax,	[mc_decls.ss_coderelocs]
    mov       [mc_genss.currrelocs],	rax
    mov       rax,	[mc_decls.ss_ncoderelocs]
    mov       [mc_genss.nrelocs],	rax
    jmp       L3742
L3744:
    mov       rax,	[mc_decls.ss_idata]
    mov       [mc_genss.currdata],	rax
    mov       rax,	[mc_decls.ss_idatarelocs]
    mov       [mc_genss.currrelocs],	rax
    mov       rax,	[mc_decls.ss_nidatarelocs]
    mov       [mc_genss.nrelocs],	rax
    jmp       L3742
L3745:
    mov       rax,	[mc_decls.ss_zdata]
    mov       [mc_genss.currdata],	rax
L3746:
L3742:
L3735:
;---------------
    ret       
;End 
;Proc mc_genss.do_popcnt
mc_genss.do_popcnt:
;?>>
   %define R.a rdi
   %define R.b rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jnz       L3749
    movzx     rax,	word [rbx+8]
    and       rax,	31
    jnz       L3751
    lea       rax,	[rbx+8]
    mov       r10w,	8
    mov       r9w,	[rax]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
L3751:
L3749:
    mov       al,	1
    mov       [mc_genss.f3override],	al
    mov       rcx,	4024
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_genss.genrrm
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.do_bsf
mc_genss.do_bsf:
;?>>
   %define R.a rdi
   %define R.b rbx
   %define R.opc rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jnz       L3754
    movzx     rax,	word [rbx+8]
    and       rax,	31
    jnz       L3756
    lea       rax,	[rbx+8]
    mov       r10w,	8
    mov       r9w,	[rax]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
L3756:
L3754:
    movzx     rax,	word [rdi+8]
    and       rax,	31
    movzx     r10,	word [rbx+8]
    and       r10,	31
    cmp       rax,	r10
    jz        L3758
    lea       rcx,	[L12519]
    call      mc_libmcl.axerror
L3758:
    mov       rax,	3840
    add       rax,	rsi
    mov       rcx,	rax
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_genss.genrrm
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.extendsymboltable
mc_genss.extendsymboltable:
;?>>
   %define R.oldsymboltable rdi
   %define R.oldsymboltablesize rbx
   %define R.i rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
;---------------
    mov       rbx,	[mc_decls.ss_symboltablesize]
    mov       rdi,	[mc_decls.ss_symboltable]
    mov       rax,	[mc_decls.ss_symboltablesize]
    shl       rax,	1
    mov       [mc_decls.ss_symboltablesize],	rax
    mov       rax,	8
    imul      rax,	[mc_decls.ss_symboltablesize]
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [mc_decls.ss_symboltable],	rax
    mov       rsi,	1
    mov       rax,	[mc_decls.ss_nsymbols]
    cmp       rax,	1
    jl        L3762
L3760:
    mov       rax,	[rdi + rsi*8-8]
    mov       r10,	[mc_decls.ss_symboltable]
    mov       r11,	rsi
    mov       [r10 + r11*8-8],	rax
    inc       rsi
    cmp       rsi,	[mc_decls.ss_nsymbols]
    jle       L3760
L3762:
    mov       rax,	8
    imul      rax,	rbx
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.pcm_free
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.initlib
mc_genss.initlib:
;?>>
   %define R.nlabels rsi
    %define mc_genss.initlib.str -256
   %define R.d rdi
   %define R.i rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	296
    mov       rsi,	rcx
;---------------
    mov       rcx,	262144
    call      mlib.pcm_alloc
    mov       [mc_decls.ss_symboltable],	rax
    mov       rax,	32768
    mov       [mc_decls.ss_symboltablesize],	rax
    xor       eax,	eax
    mov       [mc_decls.ss_nsymbols],	rax
    mov       rax,	rsi
    shl       rax,	3
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [mc_decls.labeldeftable],	rax
    mov       rbx,	1
    cmp       rsi,	1
    jl        L3766
L3764:
    mov       rcx,	128
    call      mlib.pcm_allocnfz
    mov       r10,	[mc_decls.labeldeftable]
    mov       r11,	rbx
    mov       [r10 + r11*8-8],	rax
    mov       rdi,	rax
    mov       [rdi+100],	ebx
    lea       rcx,	[rbp + mc_genss.initlib.str]
    call      msys.m$print_startstr
    lea       rcx,	[L12520]
    call      msys.m$print_setfmt
    mov       rcx,	rbx
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       rcx,	[rbp + mc_genss.initlib.str]
    call      mlib.pcm_copyheapstring
    mov       [rdi],	rax
    mov       al,	1
    mov       [rdi+93],	al
    inc       rbx
    cmp       rbx,	rsi
    jle       L3764
L3766:
;---------------
    add       rsp,	296
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.buffercreate
mc_genss.buffercreate:
;?>>
   %define R.size rbx
   %define R.a rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rcx,	32
    call      mlib.pcm_alloc
    mov       rdi,	rax
    mov       [rdi+24],	rbx
    mov       rax,	[rdi+24]
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [rdi+8],	rax
    mov       [rdi],	rax
    mov       rax,	[rdi]
    mov       r10,	[rdi+24]
    lea       rax,	[rax + r10]
    mov       [rdi+16],	rax
    mov       rax,	rdi
L3767:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.bufferexpand
mc_genss.bufferexpand:
;?>>
   %define R.a r12
   %define R.newalloc rdi
   %define R.usedbytes rbx
   %define R.p rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       r12,	rcx
;---------------
    mov       rax,	[r12+24]
    shl       rax,	1
    mov       rdi,	rax
    mov       rax,	[r12+8]
    mov       r10,	[r12]
    sub       rax,	r10
    mov       rbx,	rax
    mov       rax,	[r12+24]
    mov       r10,	rbx
    cmp       r10,	rax
    jle       L3770
    call      msys.m$print_startcon
    lea       rcx,	[L12521]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    xor       ecx,	ecx
    call      exit
L3770:
    mov       rcx,	rdi
    call      mlib.pcm_alloc
    mov       rsi,	rax
    mov       rax,	[r12]
    mov       rcx,	rsi
    mov       rdx,	rax
    mov       r8,	rbx
    call      memcpy
    mov       [r12],	rsi
    lea       rax,	[rsi + rbx]
    mov       [r12+8],	rax
    mov       [r12+24],	rdi
    lea       rax,	[rsi + rdi]
    mov       [r12+16],	rax
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.buffercheck
mc_genss.buffercheck:
;?>>
   %define R.a rdi
   %define R.n rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    jmp       L3773
L3772:
    mov       rcx,	rdi
    call      mc_genss.bufferexpand
L3773:
    mov       rax,	[rdi+16]
    mov       r10,	[rdi+8]
    sub       rax,	r10
    cmp       rax,	rbx
    jl        L3772
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.bufferlength
mc_genss.bufferlength:
;?>>
   %define R.a rcx
;?]]
;---------------
    mov       rax,	[rcx+8]
    mov       r10,	[rcx]
    sub       rax,	r10
L3775:
;---------------
    ret       
;End 
;Proc mc_genss.bufferelemptr
mc_genss.bufferelemptr:
;?>>
   %define R.a rcx
   %define R.offset rdx
;?]]
;---------------
    mov       rax,	[rcx]
    mov       r10,	rdx
    lea       rax,	[rax + r10]
L3776:
;---------------
    ret       
;End 
;Proc mc_genss.addword
mc_genss.addword:
;?>>
   %define R.a rcx
   %define R.x rdx
;?]]
;---------------
    mov       rax,	[rcx+8]
    mov       r10w,	dx
    mov       [rax],	r10w
    lea       rax,	[rcx+8]
    add       qword [rax],	2
;---------------
    ret       
;End 
;Proc mc_genss.adddword
mc_genss.adddword:
;?>>
   %define R.a rcx
   %define R.x rdx
;?]]
;---------------
    mov       rax,	[rcx+8]
    mov       r10d,	edx
    mov       [rax],	r10d
    lea       rax,	[rcx+8]
    add       qword [rax],	4
;---------------
    ret       
;End 
;Proc mc_genss.addqword
mc_genss.addqword:
;?>>
   %define R.a rcx
   %define R.x rdx
;?]]
;---------------
    mov       rax,	[rcx+8]
    mov       r10,	rdx
    mov       [rax],	r10
    lea       rax,	[rcx+8]
    add       qword [rax],	8
;---------------
    ret       
;End 
;Proc mc_genss.genxrm
mc_genss.genxrm:
;?>>
   %define R.opcode rbx
   %define R.code rsi
   %define R.b r12
   %define R.am rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
;---------------
    mov       rcx,	r12
    call      mc_genss.setopsize
    xor       ecx,	ecx
    mov       rdx,	rsi
    mov       r8,	r12
    xor       r9d,	r9d
    call      mc_genss.genrm
    mov       rdi,	rax
    mov       rax,	[mc_genss.currmcl]
    movzx     rax,	byte [rax+33]
    cmp       rax,	12
    jz        L3782
    cmp       rax,	13
    jnz       L3783
L3782:
    and       byte [mc_genss.rex],	247
L3783:
L3781:
    mov       rax,	rbx
    shr       rax,	16
    and       rax,	255
    jz        L3785
    mov       rax,	rbx
    shr       rax,	16
    and       rax,	511
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
L3785:
    call      mc_genss.genrex
    mov       rax,	rbx
    shr       rax,	8
    and       rax,	255
    jz        L3787
    mov       rax,	rbx
    shr       rax,	8
    and       rax,	255
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
L3787:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       [r10],	bl
    mov       rcx,	r12
    mov       rdx,	rdi
    call      mc_genss.genamode
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.genrrm
mc_genss.genrrm:
;?>>
   %define R.opcode rbx
   %define R.a rsi
   %define R.b r12
   %define R.am rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
;---------------
    movzx     rax,	word [rsi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jnz       L3790
    movzx     rax,	byte [rsi+10]
    lea       r10,	[mc_genss.ishighreg]
    movzx     r10,	byte [r10 + rax-1]
    or        [mc_genss.rex],	r10b
L3790:
    mov       rcx,	rsi
    call      mc_genss.setopsize
    mov       al,	[mc_genss.usesizeb]
    test      al,	al
    jz        L3792
    and       byte [mc_genss.rex],	247
    movzx     rax,	word [r12+8]
    and       rax,	31
    cmp       rax,	8
    jnz       L3794
    mov       al,	8
    or        [mc_genss.rex],	al
L3794:
L3792:
    movzx     rax,	word [rsi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	5
    setz      al
    movzx     eax,	al
    movzx     r10,	byte [rsi+10]
    mov       rcx,	r10
    xor       edx,	edx
    mov       r8,	r12
    mov       r9,	rax
    call      mc_genss.genrm
    mov       rdi,	rax
    mov       rax,	rbx
    shr       rax,	16
    and       rax,	255
    jz        L3796
    mov       rax,	rbx
    shr       rax,	16
    and       rax,	511
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
L3796:
    call      mc_genss.genrex
    mov       rax,	rbx
    shr       rax,	8
    and       rax,	255
    jz        L3798
    mov       rax,	rbx
    shr       rax,	8
    and       rax,	255
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
L3798:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       [r10],	bl
    mov       rcx,	r12
    mov       rdx,	rdi
    call      mc_genss.genamode
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.getregcode
mc_genss.getregcode:
;?>>
   %define R.reg rcx
   %define R.mask rdx
   %define R.isxreg r8
   %define R.regcode rdi
    push      rdi
;?]]
    sub       rsp,	16
;---------------
    test      r8,	r8
    jnz       L3801
    lea       rax,	[mc_decls.regcodes]
    mov       r10,	rcx
    movzx     rax,	byte [rax + r10]
    mov       rdi,	rax
    jmp       L3800
L3801:
    lea       rax,	[rcx-1]
    mov       rdi,	rax
L3800:
    cmp       rdi,	8
    jl        L3803
    mov       rax,	8
    sub       rdi,	rax
    mov       al,	dl
    or        [mc_genss.rex],	al
L3803:
    mov       rax,	rdi
L3799:
;---------------
    add       rsp,	16
    pop       rdi
    ret       
;End 
;Proc mc_genss.checkimmrange
mc_genss.checkimmrange:
;?>>
   %define R.value rdi
   %define R.size rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rax,	rbx
    cmp       rax,	1
    jz        L3806
    cmp       rax,	2
    jz        L3807
    jmp       L3808
L3806:
    mov       rax,	rdi
    cmp       rax,	-128
    jl        L3811
    cmp       rax,	255
    jle       L3810
L3811:
    lea       rcx,	[L12522]
    call      mc_libmcl.axerror
L3810:
    jmp       L3805
L3807:
    mov       rax,	rdi
    cmp       rax,	-32768
    jl        L3814
    cmp       rax,	65535
    jle       L3813
L3814:
    lea       rcx,	[L12523]
    call      mc_libmcl.axerror
L3813:
    jmp       L3805
L3808:
    mov       rax,	rdi
    cmp       rax,	-2147483648
    jl        L3817
    mov       r10,	4294967295
    cmp       rax,	r10
    jle       L3816
L3817:
    lea       rcx,	[L12524]
    call      mc_libmcl.axerror
L3816:
L3805:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.genrm
mc_genss.genrm:
;?>>
   %define R.reg r13
   %define R.opc r14
    %define mc_genss.genrm.b 80
    %define mc_genss.genrm.isxreg 88
   %define R.mode rdi
   %define R.rm rbx
   %define R.scale rsi
   %define R.index r12
    %define mc_genss.genrm.base -8
    %define mc_genss.genrm.regix -16
    %define mc_genss.genrm.ismem -24
    %define mc_genss.genrm.am -32
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       r13,	rcx
    mov       r14,	rdx
    mov       [rbp+80],	r8
    mov       [rbp+88],	r9
;---------------
    lea       rax,	[rbp + mc_genss.genrm.am]
    xor       r10d,	r10d
    mov       [rax],	r10
    test      r13,	r13
    jz        L3820
    mov       rcx,	r13
    mov       rdx,	4
    mov       r8,	[rbp + mc_genss.genrm.isxreg]
    call      mc_genss.getregcode
    mov       r14,	rax
L3820:
    mov       rax,	[rbp + mc_genss.genrm.b]
    movzx     rax,	word [rax+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L3822
    cmp       rax,	5
    jz        L3822
    cmp       rax,	3
    jz        L3823
    jmp       L3824
L3822:
    mov       rax,	[rbp + mc_genss.genrm.b]
    movzx     rax,	word [rax+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	5
    setz      al
    movzx     eax,	al
    mov       r10,	[rbp + mc_genss.genrm.b]
    movzx     r10,	byte [r10+10]
    mov       rcx,	r10
    mov       rdx,	1
    mov       r8,	rax
    call      mc_genss.getregcode
    mov       rbx,	rax
    mov       rax,	[rbp + mc_genss.genrm.b]
    movzx     rax,	byte [rax+10]
    lea       r10,	[mc_genss.ishighreg]
    movzx     r10,	byte [r10 + rax-1]
    or        [mc_genss.rex],	r10b
    mov       rax,	r14
    shl       rax,	3
    mov       r10,	192
    add       r10,	rax
    add       r10,	rbx
    mov       [rbp + mc_genss.genrm.am],	r10b
    mov       rax,	[rbp + mc_genss.genrm.am]
    jmp       L3818
L3823:
    mov       rax,	1
    mov       [rbp + mc_genss.genrm.ismem],	rax
    mov       rax,	[rbp + mc_genss.genrm.b]
    movzx     rax,	word [rax+8]
    shr       rax,	12
    and       rax,	15
    cmp       rax,	5
    jz        L3826
    cmp       rax,	3
    jz        L3827
    cmp       rax,	6
    jz        L3828
    jmp       L3829
L3826:
    mov       rax,	[rbp + mc_genss.genrm.b]
    mov       rax,	[rax]
    movzx     rax,	byte [rax+72]
    cmp       rax,	3
    jnz       L3831
    mov       rax,	2
    mov       [rbp + mc_genss.genrm.ismem],	rax
L3831:
    jmp       L3825
L3827:
    mov       rax,	2
    mov       [rbp + mc_genss.genrm.ismem],	rax
    jmp       L3825
L3828:
    mov       rax,	2
    mov       [rbp + mc_genss.genrm.ismem],	rax
L3829:
L3825:
    jmp       L3821
L3824:
    lea       rcx,	[L12525]
    call      mc_libmcl.axerror
L3821:
    xor       eax,	eax
    mov       rbx,	rax
    mov       rdi,	rax
    xor       rsi,	rsi
    mov       rax,	[rbp + mc_genss.genrm.b]
    movzx     rax,	byte [rax+10]
    mov       r13,	rax
    mov       rax,	[rbp + mc_genss.genrm.b]
    movzx     rax,	byte [rax+11]
    mov       [rbp + mc_genss.genrm.regix],	rax
    mov       rax,	[rbp + mc_genss.genrm.regix]
    cmp       rax,	r13
    jnz       L3833
    test      rax,	rax
    jnz       L3833
    xor       rdi,	rdi
    mov       rax,	4
    mov       rbx,	rax
    mov       rsi,	1
    mov       r12,	4
    mov       rax,	5
    mov       [rbp + mc_genss.genrm.base],	rax
    mov       al,	4
    mov       [rbp + mc_genss.genrm.am+3],	al
    jmp       L3832
L3833:
    mov       rax,	[rbp + mc_genss.genrm.b]
    movzx     rax,	word [rax+8]
    shr       rax,	5
    and       rax,	15
    cmp       rax,	1
    jg        L3834
    mov       rax,	[rbp + mc_genss.genrm.regix]
    test      rax,	rax
    jnz       L3834
;mc_genss.genrm.simple:
L3835:
    lea       rax,	[rbp + mc_genss.genrm.am+4]
    mov       rcx,	[rbp + mc_genss.genrm.b]
    mov       rdx,	rax
    call      mc_genss.getdispsize
    mov       [rbp + mc_genss.genrm.am+3],	al
    mov       al,	[rbp + mc_genss.genrm.am+3]
    test      al,	al
    jz        L3837
    movzx     rax,	byte [rbp + mc_genss.genrm.am+3]
    cmp       rax,	1
    jnz       L3839
    mov       rax,	1
    jmp       L3838
L3839:
    mov       rax,	2
L3838:
    mov       rdi,	rax
L3837:
    mov       rcx,	r13
    mov       rdx,	1
    xor       r8d,	r8d
    call      mc_genss.getregcode
    mov       [rbp + mc_genss.genrm.base],	rax
    mov       rbx,	rax
    cmp       rbx,	4
    jz        L3841
    cmp       rbx,	5
    jnz       L3843
    movzx     rax,	byte [rbp + mc_genss.genrm.am+3]
    test      rax,	rax
    jnz       L3843
    mov       rdi,	1
    mov       al,	1
    mov       [rbp + mc_genss.genrm.am+3],	al
L3843:
    xor       r12,	r12
    jmp       L3840
L3841:
    mov       r12,	4
    mov       rsi,	1
L3840:
    jmp       L3832
L3834:
    mov       rax,	[rbp + mc_genss.genrm.regix]
    test      rax,	rax
    jz        L3844
    test      r13,	r13
    jnz       L3844
    mov       rax,	[rbp + mc_genss.genrm.b]
    movzx     rax,	word [rax+8]
    shr       rax,	5
    and       rax,	15
    cmp       rax,	1
    jg        L3846
    mov       rax,	r13
    mov       r10,	[rbp + mc_genss.genrm.regix]
    mov       [rbp + mc_genss.genrm.regix],	rax
    mov       r13,	r10
    jmp       L3835
L3846:
    mov       al,	4
    mov       [rbp + mc_genss.genrm.am+3],	al
    xor       rdi,	rdi
    mov       rax,	4
    mov       rbx,	rax
    mov       rax,	[rbp + mc_genss.genrm.b]
    movzx     rax,	word [rax+8]
    shr       rax,	5
    and       rax,	15
    jz        L3848
    mov       rax,	[rbp + mc_genss.genrm.b]
    movzx     rax,	word [rax+8]
    shr       rax,	5
    and       rax,	15
    jmp       L3847
L3848:
    mov       rax,	1
L3847:
    mov       rsi,	rax
    mov       rax,	5
    mov       [rbp + mc_genss.genrm.base],	rax
    mov       rcx,	[rbp + mc_genss.genrm.regix]
    mov       rdx,	2
    xor       r8d,	r8d
    call      mc_genss.getregcode
    mov       r12,	rax
    mov       rax,	[rbp + mc_genss.genrm.regix]
    cmp       rax,	16
    jnz       L3850
    lea       rcx,	[L12526]
    call      mc_libmcl.axerror
L3850:
    jmp       L3832
L3844:
    lea       rax,	[rbp + mc_genss.genrm.am+4]
    mov       rcx,	[rbp + mc_genss.genrm.b]
    mov       rdx,	rax
    call      mc_genss.getdispsize
    mov       [rbp + mc_genss.genrm.am+3],	al
    mov       al,	[rbp + mc_genss.genrm.am+3]
    test      al,	al
    jz        L3852
    movzx     rax,	byte [rbp + mc_genss.genrm.am+3]
    cmp       rax,	1
    jnz       L3854
    mov       rax,	1
    jmp       L3853
L3854:
    mov       rax,	2
L3853:
    mov       rdi,	rax
L3852:
    mov       rbx,	4
    mov       rax,	[rbp + mc_genss.genrm.b]
    movzx     rax,	word [rax+8]
    shr       rax,	5
    and       rax,	15
    jz        L3856
    mov       rax,	[rbp + mc_genss.genrm.b]
    movzx     rax,	word [rax+8]
    shr       rax,	5
    and       rax,	15
    jmp       L3855
L3856:
    mov       rax,	1
L3855:
    mov       rsi,	rax
    test      r13,	r13
    jnz       L3858
    mov       rax,	5
    mov       [rbp + mc_genss.genrm.base],	rax
    jmp       L3857
L3858:
    mov       rax,	r13
    cmp       rax,	15
    jz        L3861
    cmp       rax,	8
    jnz       L3860
L3861:
    movzx     rax,	byte [rbp + mc_genss.genrm.am+3]
    test      rax,	rax
    jnz       L3860
    mov       rdi,	1
    mov       al,	1
    mov       [rbp + mc_genss.genrm.am+3],	al
L3860:
    mov       rcx,	r13
    mov       rdx,	1
    xor       r8d,	r8d
    call      mc_genss.getregcode
    mov       [rbp + mc_genss.genrm.base],	rax
L3857:
    mov       rax,	[rbp + mc_genss.genrm.regix]
    test      rax,	rax
    jnz       L3863
    mov       r12,	4
    jmp       L3862
L3863:
    mov       rcx,	[rbp + mc_genss.genrm.regix]
    mov       rdx,	2
    xor       r8d,	r8d
    call      mc_genss.getregcode
    mov       r12,	rax
    test      r13,	r13
    jnz       L3865
    mov       al,	4
    mov       [rbp + mc_genss.genrm.am+3],	al
L3865:
    mov       rax,	[rbp + mc_genss.genrm.regix]
    cmp       rax,	16
    jnz       L3867
    cmp       rsi,	1
    jle       L3867
    lea       rcx,	[L12527]
    call      mc_libmcl.axerror
L3867:
L3862:
L3832:
    test      rsi,	rsi
    jz        L3869
    lea       rax,	[mc_genss.genrm.scaletable]
    mov       r10,	rsi
    mov       rax,	[rax + r10*8-8]
    shl       rax,	6
    mov       r10,	r12
    shl       r10,	3
    add       rax,	r10
    add       rax,	[rbp + mc_genss.genrm.base]
    mov       [rbp + mc_genss.genrm.am+1],	al
    mov       al,	1
    mov       [rbp + mc_genss.genrm.am+2],	al
L3869:
    movzx     rax,	byte [rbp + mc_genss.genrm.am+3]
    cmp       rax,	4
    jnz       L3871
    mov       rax,	[rbp + mc_genss.genrm.ismem]
    test      rax,	rax
    jz        L3871
    test      r13,	r13
    jnz       L3874
    mov       rax,	[rbp + mc_genss.genrm.regix]
    test      rax,	rax
    jz        L3873
L3874:
    movzx     rax,	byte [pc_api.phighmem]
    cmp       rax,	2
    jnz       L3876
    mov       rax,	[rbp + mc_genss.genrm.ismem]
    cmp       rax,	2
    jnz       L3876
    call      msys.m$print_startcon
    lea       rcx,	[L12528]
    call      msys.m$print_str_nf
    mov       rcx,	[mc_decls.aaseqno]
    call      msys.m$print_i64_nf
    mov       rcx,	[mc_genss.currmcl]
    call      mc_writenasm.strmclstr
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L3876:
    jmp       L3872
L3873:
    mov       al,	[pc_api.phighmem]
    test      al,	al
    jz        L3877
    mov       al,	-1
    mov       [rbp + mc_genss.genrm.am+2],	al
    xor       rdi,	rdi
    mov       rax,	5
    mov       rbx,	rax
L3877:
L3872:
L3871:
    mov       rax,	rdi
    shl       rax,	6
    mov       r10,	r14
    shl       r10,	3
    add       rax,	r10
    add       rax,	rbx
    mov       [rbp + mc_genss.genrm.am],	al
    mov       rax,	[rbp + mc_genss.genrm.am]
L3818:
;---------------
    add       rsp,	64
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.do_arith
mc_genss.do_arith:
;?>>
   %define R.a r13
   %define R.b r14
   %define R.code r15
   %define R.d rdi
   %define R.opc rbx
   %define R.dispsize rsi
   %define R.x r12
    %define mc_genss.do_arith.$T1 -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       r13,	rcx
    mov       r14,	rdx
    mov       r15,	r8
;---------------
    movzx     rax,	word [r13+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L3880
    cmp       rax,	3
    jz        L3881
    jmp       L3882
L3880:
    movzx     rax,	word [r14+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L3884
    cmp       rax,	3
    jz        L3884
    cmp       rax,	2
    jz        L3885
    jmp       L3886
L3884:
    mov       rax,	r15
    shl       rax,	3
    mov       [rbp + mc_genss.do_arith.$T1],	rax
    movzx     rax,	word [r13+8]
    and       rax,	31
    cmp       rax,	1
    jnz       L3888
    mov       rax,	2
    jmp       L3887
L3888:
    mov       rax,	3
L3887:
    mov       r10,	[rbp + mc_genss.do_arith.$T1]
    or        r10,	rax
    mov       rbx,	r10
    mov       rcx,	rbx
    mov       rdx,	r13
    mov       r8,	r14
    call      mc_genss.genrrm
    jmp       L3883
L3885:
;mc_genss.do_arith.doregimm:
L3889:
    mov       rcx,	r14
    xor       edx,	edx
    call      mc_genss.getdef
    mov       rdi,	rax
    test      rdi,	rdi
    jz        L3891
    movzx     rax,	word [r13+8]
    and       rax,	31
    cmp       rax,	4
    jge       L3893
    lea       rcx,	[L12529]
    call      mc_libmcl.axerror
L3893:
    mov       rcx,	129
    mov       rdx,	r15
    mov       r8,	r13
    call      mc_genss.genxrm
    mov       rcx,	r14
    mov       rdx,	4
    call      mc_genss.genopnd
    jmp       L3878
L3891:
    mov       r12,	[r14]
    mov       rsi,	1
    movzx     rax,	word [r13+8]
    and       rax,	31
    cmp       rax,	1
    jnz       L3895
    mov       rbx,	128
    mov       rcx,	r12
    mov       rdx,	1
    call      mc_genss.checkimmrange
    mov       rax,	r12
    cmp       rax,	-128
    jl        L3898
    cmp       rax,	255
    jle       L3897
L3898:
    lea       rcx,	[L12530]
    call      mc_libmcl.axerror
L3897:
    jmp       L3894
L3895:
    mov       rax,	r12
    cmp       rax,	-128
    jl        L3899
    cmp       rax,	127
    jg        L3899
    mov       rbx,	131
    jmp       L3894
L3899:
    mov       rcx,	r12
    mov       rdx,	4
    call      mc_genss.checkimmrange
    mov       rbx,	129
    movzx     rax,	word [r13+8]
    and       rax,	31
    cmp       rax,	2
    jnz       L3901
    mov       rax,	2
    jmp       L3900
L3901:
    mov       rax,	4
L3900:
    mov       rsi,	rax
L3894:
    mov       rcx,	rbx
    mov       rdx,	r15
    mov       r8,	r13
    call      mc_genss.genxrm
    mov       rax,	rsi
    cmp       rax,	1
    jz        L3903
    cmp       rax,	2
    jz        L3904
    cmp       rax,	4
    jz        L3905
    jmp       L3906
L3903:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       [r10],	r12b
    jmp       L3902
L3904:
    mov       rcx,	r12
    call      mc_genss.genword
    jmp       L3902
L3905:
    mov       rcx,	r12
    call      mc_genss.gendword
L3906:
L3902:
    mov       rcx,	rsi
    call      mc_genss.fixrip
    jmp       L3883
L3886:
    lea       rcx,	[L12531]
    call      mc_libmcl.axerror
L3883:
    jmp       L3879
L3881:
    movzx     rax,	word [r14+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L3908
    cmp       rax,	2
    jz        L3909
    jmp       L3910
L3908:
    mov       rax,	r15
    shl       rax,	3
    mov       [rbp + mc_genss.do_arith.$T1],	rax
    movzx     rax,	word [r14+8]
    and       rax,	31
    cmp       rax,	1
    jnz       L3912
    xor       eax,	eax
    jmp       L3911
L3912:
    mov       rax,	1
L3911:
    mov       r10,	[rbp + mc_genss.do_arith.$T1]
    or        r10,	rax
    mov       rbx,	r10
    mov       rcx,	rbx
    mov       rdx,	r14
    mov       r8,	r13
    call      mc_genss.genrrm
    jmp       L3907
L3909:
    jmp       L3889
L3910:
    lea       rcx,	[L12532]
    call      mc_libmcl.axerror
L3907:
    jmp       L3879
L3882:
    call      msys.m$print_startcon
    lea       rax,	[mc_decls.opndnames_ma]
    mov       r10,	r15
    mov       rcx,	[rax + r10*8]
    call      msys.m$print_str_nf
    lea       rcx,	[L12533]
    call      msys.m$print_str_nf
    mov       rcx,	r15
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L12534]
    call      mc_libmcl.axerror
L3879:
L3878:
;---------------
    add       rsp,	40
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.do_mov
mc_genss.do_mov:
;?>>
   %define R.a r14
   %define R.b r15
   %define R.regcode rdi
   %define R.opc rbx
   %define R.dispsize rsi
   %define R.value r12
   %define R.d r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    sub       rsp,	48
    mov       r14,	rcx
    mov       r15,	rdx
;---------------
    mov       rcx,	r15
    xor       edx,	edx
    call      mc_genss.getdef
    mov       r13,	rax
    movzx     rax,	word [r14+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L3915
    cmp       rax,	3
    jz        L3916
    jmp       L3917
L3915:
    movzx     rax,	word [r15+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L3919
    cmp       rax,	3
    jz        L3919
    cmp       rax,	2
    jz        L3920
    jmp       L3921
L3919:
    movzx     rax,	word [r14+8]
    and       rax,	31
    movzx     r10,	word [r15+8]
    and       r10,	31
    cmp       rax,	r10
    jz        L3923
    movzx     rax,	word [r15+8]
    and       rax,	31
    jz        L3923
    lea       rcx,	[L12535]
    call      mc_libmcl.axerror
L3923:
    movzx     rax,	word [r14+8]
    and       rax,	31
    cmp       rax,	1
    jnz       L3925
    mov       rax,	138
    jmp       L3924
L3925:
    mov       rax,	139
L3924:
    mov       rcx,	rax
    mov       rdx,	r14
    mov       r8,	r15
    call      mc_genss.genrrm
    jmp       L3918
L3920:
    mov       r12,	[r15]
    movzx     rax,	byte [r14+10]
    mov       rcx,	rax
    mov       rdx,	1
    xor       r8d,	r8d
    call      mc_genss.getregcode
    mov       rdi,	rax
    mov       rcx,	r14
    call      mc_genss.setopsize
    test      r13,	r13
    jz        L3927
    movzx     rax,	word [r14+8]
    and       rax,	31
    cmp       rax,	2
    jg        L3927
    lea       rcx,	[L12536]
    call      mc_libmcl.axerror
L3927:
    mov       rcx,	r14
    call      mc_genss.checkhighreg
    movzx     rax,	word [r14+8]
    and       rax,	31
    cmp       rax,	1
    jz        L3929
    cmp       rax,	2
    jz        L3930
    cmp       rax,	4
    jz        L3931
    jmp       L3932
L3929:
    mov       rax,	r12
    cmp       rax,	-128
    jl        L3935
    cmp       rax,	255
    jle       L3934
L3935:
    lea       rcx,	[L12537]
    call      mc_libmcl.axerror
L3934:
    call      mc_genss.genrex
    mov       rax,	176
    add       rax,	rdi
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       [r10],	r12b
    jmp       L3928
L3930:
    mov       rax,	r12
    cmp       rax,	-32768
    jl        L3938
    cmp       rax,	65535
    jle       L3937
L3938:
    lea       rcx,	[L12538]
    call      mc_libmcl.axerror
L3937:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	102
    mov       [r10],	al
    call      mc_genss.genrex
    mov       rax,	184
    add       rax,	rdi
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
    mov       rcx,	r12
    call      mc_genss.genword
    jmp       L3928
L3931:
    test      r13,	r13
    jz        L3940
    call      mc_genss.genrex
    mov       rax,	184
    add       rax,	rdi
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
    mov       rcx,	r15
    mov       rdx,	4
    call      mc_genss.genopnd
    jmp       L3939
L3940:
    mov       rax,	r12
    cmp       rax,	-2147483648
    jl        L3943
    mov       r10d,	4294967295
    mov       r10d,	r10d
    cmp       rax,	r10
    jle       L3942
L3943:
    call      msys.m$print_startcon
    mov       rcx,	r12
    call      msys.m$print_i64_nf
    mov       rcx,	r12
    call      msys.m$print_ptr_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L12539]
    call      mc_libmcl.axerror
L3942:
;mc_genss.do_mov.doreg32:
L3944:
    call      mc_genss.genrex
    mov       rax,	184
    add       rax,	rdi
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
    mov       rcx,	r12
    call      mc_genss.gendword
L3939:
    jmp       L3928
L3932:
    test      r13,	r13
    jz        L3946
    mov       al,	8
    or        [mc_genss.rex],	al
    call      mc_genss.genrex
    mov       rax,	184
    add       rax,	rdi
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
    mov       rcx,	r15
    mov       rdx,	8
    call      mc_genss.genopnd
    jmp       L3945
L3946:
    cmp       r12,	0
    jl        L3948
    mov       rax,	r12
    mov       r10,	4294967295
    cmp       rax,	r10
    jg        L3948
    and       byte [mc_genss.rex],	247
    jmp       L3944
L3948:
    mov       al,	8
    or        [mc_genss.rex],	al
    call      mc_genss.genrex
    mov       rax,	184
    add       rax,	rdi
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
    mov       rcx,	r12
    call      mc_genss.genqword
L3945:
L3928:
    jmp       L3918
L3921:
    lea       rcx,	[L12540]
    call      mc_libmcl.axerror
L3918:
    jmp       L3914
L3916:
    movzx     rax,	word [r15+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L3950
    cmp       rax,	2
    jz        L3951
    jmp       L3952
L3950:
    movzx     rax,	word [r14+8]
    and       rax,	31
    jnz       L3954
    movzx     rax,	word [r15+8]
    and       rax,	31
    lea       r10,	[r14+8]
    mov       r9w,	[r10]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	ax
    mov       [r10],	r9w
L3954:
    movzx     rax,	word [r14+8]
    and       rax,	31
    movzx     r10,	word [r15+8]
    and       r10,	31
    cmp       rax,	r10
    jz        L3956
    movzx     rax,	word [r14+8]
    and       rax,	31
    jz        L3956
    lea       rcx,	[L12541]
    call      mc_libmcl.axerror
L3956:
    movzx     rax,	word [r15+8]
    and       rax,	31
    cmp       rax,	1
    jnz       L3958
    mov       rax,	136
    jmp       L3957
L3958:
    mov       rax,	137
L3957:
    mov       rcx,	rax
    mov       rdx,	r15
    mov       r8,	r14
    call      mc_genss.genrrm
    jmp       L3949
L3951:
    mov       r12,	[r15]
    movzx     rax,	word [r14+8]
    and       rax,	31
    jnz       L3960
    lea       rax,	[r14+8]
    mov       r10w,	1
    mov       r9w,	[rax]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
L3960:
    test      r13,	r13
    jz        L3962
    movzx     rax,	word [r14+8]
    and       rax,	31
    cmp       rax,	2
    jg        L3962
    lea       rcx,	[L12542]
    call      mc_libmcl.axerror
L3962:
    mov       rcx,	r14
    call      mc_genss.setopsize
    movzx     rax,	word [r14+8]
    and       rax,	31
    cmp       rax,	1
    jnz       L3964
    mov       rax,	198
    jmp       L3963
L3964:
    mov       rax,	199
L3963:
    mov       rbx,	rax
    test      r13,	r13
    jnz       L3966
    movzx     rax,	word [r14+8]
    and       rax,	31
    mov       rcx,	r12
    mov       rdx,	rax
    call      mc_genss.checkimmrange
L3966:
    mov       rcx,	rbx
    xor       edx,	edx
    mov       r8,	r14
    call      mc_genss.genxrm
    mov       r12,	[r15]
    movzx     rax,	word [r14+8]
    and       rax,	31
    mov       rsi,	rax
    movzx     rax,	word [r14+8]
    and       rax,	31
    cmp       rax,	1
    jz        L3968
    cmp       rax,	2
    jz        L3969
    cmp       rax,	4
    jz        L3970
    cmp       rax,	8
    jz        L3970
    jmp       L3971
L3968:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       [r10],	r12b
    jmp       L3967
L3969:
    mov       rcx,	r12
    call      mc_genss.genword
    jmp       L3967
L3970:
    mov       rcx,	r15
    mov       rdx,	4
    call      mc_genss.genopnd
    mov       rsi,	4
L3971:
L3967:
    mov       rcx,	rsi
    call      mc_genss.fixrip
    jmp       L3949
L3952:
    lea       rcx,	[L12543]
    call      mc_libmcl.axerror
L3949:
    jmp       L3914
L3917:
    lea       rcx,	[L12544]
    call      mc_libmcl.axerror
L3914:
;---------------
    add       rsp,	48
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.do_push
mc_genss.do_push:
;?>>
   %define R.a rbx
   %define R.code rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    movzx     rax,	word [rbx+8]
    and       rax,	31
    jnz       L3974
    lea       rax,	[rbx+8]
    mov       r10w,	8
    mov       r9w,	[rax]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
L3974:
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L3976
    cmp       rax,	2
    jz        L3977
    cmp       rax,	3
    jz        L3978
    jmp       L3979
L3976:
    movzx     rax,	word [rbx+8]
    and       rax,	31
    cmp       rax,	8
    jz        L3981
    lea       rcx,	[L12545]
    call      mc_libmcl.axerror
L3981:
    movzx     rax,	byte [rbx+10]
    mov       rcx,	rax
    mov       rdx,	1
    xor       r8d,	r8d
    call      mc_genss.getregcode
    mov       rdi,	rax
    and       byte [mc_genss.rex],	247
    call      mc_genss.genrex
    mov       rax,	80
    add       rax,	rdi
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
    jmp       L3975
L3977:
    mov       rcx,	rbx
    xor       edx,	edx
    call      mc_genss.getdef
    test      rax,	rax
    jz        L3983
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	104
    mov       [r10],	al
    mov       rcx,	rbx
    mov       rdx,	4
    call      mc_genss.genopnd
    jmp       L3982
L3983:
    mov       rax,	[rbx]
    mov       rcx,	rax
    call      mc_genss.isbytesized
    test      rax,	rax
    jz        L3984
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	106
    mov       [r10],	al
    mov       rax,	[rbx]
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
    jmp       L3982
L3984:
    mov       rax,	[rbx]
    mov       rcx,	rax
    call      mc_genss.isdwordsized
    test      rax,	rax
    jz        L3985
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	104
    mov       [r10],	al
    mov       rcx,	[rbx]
    call      mc_genss.gendword
    jmp       L3982
L3985:
    lea       rcx,	[L12546]
    call      mc_libmcl.axerror
L3982:
    jmp       L3975
L3978:
    movzx     rax,	word [rbx+8]
    and       rax,	31
    cmp       rax,	8
    jz        L3987
    lea       rcx,	[L12547]
    call      mc_libmcl.axerror
L3987:
    mov       rcx,	255
    mov       rdx,	6
    mov       r8,	rbx
    call      mc_genss.genxrm
    jmp       L3975
L3979:
    lea       rcx,	[L12548]
    call      mc_libmcl.axerror
L3975:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.do_pop
mc_genss.do_pop:
;?>>
   %define R.a rbx
   %define R.code rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    movzx     rax,	word [rbx+8]
    and       rax,	31
    jnz       L3990
    lea       rax,	[rbx+8]
    mov       r10w,	8
    mov       r9w,	[rax]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
L3990:
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L3992
    cmp       rax,	3
    jz        L3993
    jmp       L3994
L3992:
    movzx     rax,	word [rbx+8]
    and       rax,	31
    cmp       rax,	8
    jz        L3996
    lea       rcx,	[L12549]
    call      mc_libmcl.axerror
L3996:
    movzx     rax,	byte [rbx+10]
    mov       rcx,	rax
    mov       rdx,	1
    xor       r8d,	r8d
    call      mc_genss.getregcode
    mov       rdi,	rax
    call      mc_genss.genrex
    mov       rax,	88
    add       rax,	rdi
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
    jmp       L3991
L3993:
    movzx     rax,	word [rbx+8]
    and       rax,	31
    cmp       rax,	8
    jz        L3998
    lea       rcx,	[L12550]
    call      mc_libmcl.axerror
L3998:
    mov       rcx,	143
    xor       edx,	edx
    mov       r8,	rbx
    call      mc_genss.genxrm
    jmp       L3991
L3994:
    lea       rcx,	[L12551]
    call      mc_libmcl.axerror
L3991:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.do_inc
mc_genss.do_inc:
;?>>
   %define R.a rdi
   %define R.code rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    movzx     rax,	word [rdi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L4001
    cmp       rax,	3
    jnz       L4002
L4001:
    movzx     rax,	word [rdi+8]
    and       rax,	31
    cmp       rax,	1
    jnz       L4004
    mov       rax,	254
    jmp       L4003
L4004:
    mov       rax,	255
L4003:
    mov       rcx,	rax
    mov       rdx,	rbx
    mov       r8,	rdi
    call      mc_genss.genxrm
    jmp       L4000
L4002:
    lea       rcx,	[L12552]
    call      mc_libmcl.axerror
L4000:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.do_neg
mc_genss.do_neg:
;?>>
   %define R.a rdi
   %define R.code rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    movzx     rax,	word [rdi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L4007
    cmp       rax,	3
    jnz       L4008
L4007:
    movzx     rax,	word [rdi+8]
    and       rax,	31
    cmp       rax,	1
    jnz       L4010
    mov       rax,	246
    jmp       L4009
L4010:
    mov       rax,	247
L4009:
    mov       rcx,	rax
    mov       rdx,	rbx
    mov       r8,	rdi
    call      mc_genss.genxrm
    jmp       L4006
L4008:
    lea       rcx,	[L12553]
    call      mc_libmcl.axerror
L4006:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.do_lea
mc_genss.do_lea:
;?>>
   %define R.a rdi
   %define R.b rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    movzx     rax,	word [rdi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jnz       L4014
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jz        L4013
L4014:
    lea       rcx,	[L12554]
    call      mc_libmcl.axerror
L4013:
    movzx     rax,	word [rdi+8]
    and       rax,	31
    cmp       rax,	4
    jge       L4016
    lea       rcx,	[L12555]
    call      mc_libmcl.axerror
L4016:
    mov       rcx,	141
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_genss.genrrm
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.do_movsx
mc_genss.do_movsx:
;?>>
   %define R.a rdi
   %define R.b rbx
   %define R.opc rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    movzx     rax,	word [rdi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L4019
    lea       rcx,	[L12556]
    call      mc_libmcl.axerror
L4019:
    movzx     rax,	word [rdi+8]
    and       rax,	31
    cmp       rax,	8
    jnz       L4021
    movzx     rax,	word [rbx+8]
    and       rax,	31
    cmp       rax,	4
    jnz       L4021
    cmp       rsi,	190
    jnz       L4023
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_genss.do_movsxd
    jmp       L4022
L4023:
    movzx     rax,	byte [rdi+10]
    lea       r10,	[mc_decls.regtable]
    mov       r11,	rax
    shl       r11,	6
    lea       r10,	[r10 + r11-64]
    mov       r10,	[r10+24]
    mov       rdi,	r10
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_genss.do_mov
L4022:
    jmp       L4017
L4021:
    movzx     rax,	word [rdi+8]
    and       rax,	31
    cmp       rax,	1
    jz        L4026
    movzx     rax,	word [rdi+8]
    and       rax,	31
    movzx     r10,	word [rbx+8]
    and       r10,	31
    cmp       rax,	r10
    ja        L4025
L4026:
    lea       rcx,	[L12557]
    call      mc_libmcl.axerror
L4025:
    cmp       rsi,	182
    jnz       L4028
    movzx     rax,	word [rbx+8]
    and       rax,	31
    cmp       rax,	4
    jnz       L4028
    lea       rcx,	[L12558]
    call      mc_libmcl.axerror
L4028:
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L4030
    cmp       rax,	3
    jz        L4031
    jmp       L4032
L4030:
    jmp       L4029
L4031:
    movzx     rax,	word [rbx+8]
    and       rax,	31
    jnz       L4034
    lea       rcx,	[L12559]
    call      mc_libmcl.axerror
L4034:
    movzx     rax,	word [rbx+8]
    and       rax,	31
    cmp       rax,	8
    jnz       L4036
    lea       rcx,	[L12560]
    call      mc_libmcl.axerror
L4036:
    jmp       L4029
L4032:
    lea       rcx,	[L12561]
    call      mc_libmcl.axerror
L4029:
    movzx     rax,	word [rbx+8]
    and       rax,	31
    cmp       rax,	1
    jnz       L4038
    mov       rax,	rsi
    jmp       L4037
L4038:
    lea       rax,	[rsi+1]
L4037:
    mov       r10,	3840
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_genss.genrrm
L4017:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.do_exch
mc_genss.do_exch:
;?>>
   %define R.a rbx
   %define R.b rsi
   %define R.regcode rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jnz       L4041
    movzx     rax,	word [rsi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jnz       L4041
    movzx     rax,	byte [rbx+10]
    cmp       rax,	1
    jz        L4042
    movzx     rax,	byte [rsi+10]
    cmp       rax,	1
    jnz       L4041
L4042:
    movzx     rax,	word [rbx+8]
    and       rax,	31
    cmp       rax,	1
    jz        L4041
    movzx     rax,	byte [rbx+10]
    cmp       rax,	1
    jz        L4044
    mov       rax,	rbx
    mov       r10,	rsi
    mov       rsi,	rax
    mov       rbx,	r10
L4044:
    movzx     rax,	word [rbx+8]
    and       rax,	31
    movzx     r10,	word [rsi+8]
    and       r10,	31
    cmp       rax,	r10
    jz        L4046
    lea       rcx,	[L12562]
    call      mc_libmcl.axerror
L4046:
    mov       rcx,	rbx
    call      mc_genss.setopsize
    movzx     rax,	byte [rsi+10]
    mov       rcx,	rax
    mov       rdx,	1
    xor       r8d,	r8d
    call      mc_genss.getregcode
    mov       rdi,	rax
    call      mc_genss.genrex
    mov       rax,	144
    add       rax,	rdi
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
    jmp       L4039
L4041:
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jnz       L4048
    mov       rax,	rbx
    mov       r10,	rsi
    mov       rsi,	rax
    mov       rbx,	r10
L4048:
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jnz       L4051
    movzx     rax,	word [rsi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L4050
    movzx     rax,	word [rsi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jz        L4050
L4051:
    lea       rcx,	[L12563]
    call      mc_libmcl.axerror
L4050:
    movzx     rax,	word [rsi+8]
    and       rax,	31
    jnz       L4053
    movzx     rax,	word [rsi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jnz       L4053
    movzx     rax,	word [rbx+8]
    and       rax,	31
    lea       r10,	[rsi+8]
    mov       r9w,	[r10]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	ax
    mov       [r10],	r9w
L4053:
    movzx     rax,	word [rbx+8]
    and       rax,	31
    movzx     r10,	word [rsi+8]
    and       r10,	31
    cmp       rax,	r10
    jz        L4055
    lea       rcx,	[L12564]
    call      mc_libmcl.axerror
L4055:
    movzx     rax,	word [rbx+8]
    and       rax,	31
    cmp       rax,	1
    jnz       L4057
    mov       rax,	134
    jmp       L4056
L4057:
    mov       rax,	135
L4056:
    mov       rcx,	rax
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mc_genss.genrrm
L4039:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.do_movsxd
mc_genss.do_movsxd:
;?>>
   %define R.a rdi
   %define R.b rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jnz       L4060
    movzx     rax,	word [rbx+8]
    and       rax,	31
    jnz       L4060
    lea       rax,	[rbx+8]
    mov       r10w,	4
    mov       r9w,	[rax]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
L4060:
    movzx     rax,	word [rdi+8]
    and       rax,	31
    cmp       rax,	8
    jnz       L4063
    movzx     rax,	word [rbx+8]
    and       rax,	31
    cmp       rax,	4
    jle       L4062
L4063:
    lea       rcx,	[L12565]
    call      mc_libmcl.axerror
L4062:
    movzx     rax,	word [rdi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jnz       L4066
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L4065
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jz        L4065
L4066:
    lea       rcx,	[L12566]
    call      mc_libmcl.axerror
L4065:
    mov       rcx,	99
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_genss.genrrm
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.do_imul2
mc_genss.do_imul2:
;?>>
   %define R.a r12
   %define R.b r13
   %define R.opc rdi
   %define R.dispsize rbx
   %define R.value rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r12,	rcx
    mov       r13,	rdx
;---------------
    movzx     rax,	word [r12+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L4069
    lea       rcx,	[L12567]
    call      mc_libmcl.axerror
L4069:
    movzx     rax,	word [r13+8]
    and       rax,	31
    jnz       L4071
    movzx     rax,	word [r12+8]
    and       rax,	31
    lea       r10,	[r13+8]
    mov       r9w,	[r10]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	ax
    mov       [r10],	r9w
L4071:
    movzx     rax,	word [r12+8]
    and       rax,	31
    cmp       rax,	1
    jnz       L4073
    lea       rcx,	[L12568]
    call      mc_libmcl.axerror
L4073:
    movzx     rax,	word [r13+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L4075
    cmp       rax,	3
    jz        L4075
    cmp       rax,	2
    jz        L4076
    jmp       L4077
L4075:
    movzx     rax,	word [r12+8]
    and       rax,	31
    movzx     r10,	word [r13+8]
    and       r10,	31
    cmp       rax,	r10
    jz        L4079
    lea       rcx,	[L12569]
    call      mc_libmcl.axerror
L4079:
    mov       rcx,	4015
    mov       rdx,	r12
    mov       r8,	r13
    call      mc_genss.genrrm
    jmp       L4074
L4076:
    mov       rcx,	r13
    xor       edx,	edx
    call      mc_genss.getdef
    test      rax,	rax
    jz        L4081
    lea       rcx,	[L12570]
    call      mc_libmcl.axerror
L4081:
    mov       rsi,	[r13]
    mov       rax,	rsi
    cmp       rax,	-128
    jl        L4083
    cmp       rax,	127
    jg        L4083
    mov       rdi,	107
    jmp       L4082
L4083:
    mov       rdi,	105
L4082:
    mov       rcx,	rdi
    mov       rdx,	r12
    mov       r8,	r12
    call      mc_genss.genrrm
    mov       rax,	rsi
    cmp       rax,	-128
    jl        L4085
    cmp       rax,	127
    jg        L4085
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       [r10],	sil
    mov       rbx,	1
    jmp       L4084
L4085:
    movzx     rax,	word [r12+8]
    and       rax,	31
    cmp       rax,	2
    jnz       L4086
    mov       rcx,	rsi
    call      mc_genss.genword
    mov       rbx,	2
    jmp       L4084
L4086:
    mov       rcx,	rsi
    call      mc_genss.gendword
    mov       rbx,	4
L4084:
    mov       rcx,	rbx
    call      mc_genss.fixrip
    jmp       L4074
L4077:
    lea       rcx,	[L12571]
    call      mc_libmcl.axerror
L4074:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.do_shift
mc_genss.do_shift:
;?>>
   %define R.a r12
   %define R.b r13
   %define R.code r14
   %define R.w rdi
   %define R.opc rbx
   %define R.needdisp rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       r12,	rcx
    mov       r13,	rdx
    mov       r14,	r8
;---------------
    movzx     rax,	word [r12+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L4089
    movzx     rax,	word [r12+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jz        L4089
    lea       rcx,	[L12572]
    call      mc_libmcl.axerror
L4089:
    mov       rcx,	r13
    xor       edx,	edx
    call      mc_genss.getdef
    test      rax,	rax
    jz        L4091
    lea       rcx,	[L12573]
    call      mc_libmcl.axerror
L4091:
    movzx     rax,	word [r12+8]
    and       rax,	31
    cmp       rax,	1
    jnz       L4093
    xor       eax,	eax
    jmp       L4092
L4093:
    mov       rax,	1
L4092:
    mov       rdi,	rax
    xor       rsi,	rsi
    movzx     rax,	word [r13+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	2
    jz        L4095
    cmp       rax,	1
    jz        L4096
    jmp       L4097
L4095:
    mov       rax,	[r13]
    cmp       rax,	1
    jnz       L4099
    mov       rax,	208
    add       rax,	rdi
    mov       rbx,	rax
    jmp       L4098
L4099:
    mov       rax,	192
    add       rax,	rdi
    mov       rbx,	rax
    mov       rsi,	1
L4098:
    jmp       L4094
L4096:
    movzx     rax,	byte [r13+10]
    cmp       rax,	11
    jnz       L4102
    movzx     rax,	word [r13+8]
    and       rax,	31
    cmp       rax,	1
    jz        L4101
L4102:
    lea       rcx,	[L12574]
    call      mc_libmcl.axerror
L4101:
    mov       rax,	210
    add       rax,	rdi
    mov       rbx,	rax
    jmp       L4094
L4097:
    lea       rcx,	[L12575]
    call      mc_libmcl.axerror
L4094:
    mov       rcx,	rbx
    mov       rdx,	r14
    mov       r8,	r12
    call      mc_genss.genxrm
    test      rsi,	rsi
    jz        L4104
    mov       rax,	[r13]
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
    mov       rcx,	1
    call      mc_genss.fixrip
L4104:
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.do_test
mc_genss.do_test:
;?>>
   %define R.a rbx
   %define R.b rsi
   %define R.value rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jnz       L4107
    movzx     rax,	byte [rbx+10]
    cmp       rax,	1
    jnz       L4107
    movzx     rax,	word [rsi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	2
    jnz       L4107
    mov       rdi,	[rsi]
    movzx     rax,	word [rbx+8]
    and       rax,	31
    cmp       rax,	1
    jz        L4109
    cmp       rax,	2
    jz        L4110
    cmp       rax,	4
    jz        L4111
    jmp       L4112
L4109:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	168
    mov       [r10],	al
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       [r10],	dil
    jmp       L4108
L4110:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	102
    mov       [r10],	al
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	169
    mov       [r10],	al
    mov       rcx,	rdi
    call      mc_genss.genword
    jmp       L4108
L4111:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	169
    mov       [r10],	al
    mov       rcx,	rdi
    call      mc_genss.gendword
    jmp       L4108
L4112:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	72
    mov       [r10],	al
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	169
    mov       [r10],	al
    mov       rcx,	rdi
    call      mc_genss.gendword
L4108:
    jmp       L4106
L4107:
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L4114
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jnz       L4113
L4114:
    movzx     rax,	word [rsi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	2
    jnz       L4113
    movzx     rax,	word [rbx+8]
    and       rax,	31
    cmp       rax,	1
    jnz       L4116
    mov       rax,	246
    jmp       L4115
L4116:
    mov       rax,	247
L4115:
    mov       rcx,	rax
    xor       edx,	edx
    mov       r8,	rbx
    call      mc_genss.genxrm
    movzx     rax,	word [rbx+8]
    and       rax,	31
    cmp       rax,	1
    jz        L4118
    cmp       rax,	2
    jz        L4119
    jmp       L4120
L4118:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       [r10],	dil
    jmp       L4117
L4119:
    mov       rcx,	rdi
    call      mc_genss.genword
    jmp       L4117
L4120:
    mov       rcx,	rdi
    call      mc_genss.gendword
L4117:
    movzx     rax,	word [rbx+8]
    and       rax,	31
    mov       rcx,	rax
    call      mc_genss.fixrip
    jmp       L4106
L4113:
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L4122
    cmp       rax,	3
    jnz       L4121
L4122:
    movzx     rax,	word [rsi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jnz       L4121
;mc_genss.do_test.domemreg:
L4123:
    movzx     rax,	word [rbx+8]
    and       rax,	31
    cmp       rax,	1
    jnz       L4125
    mov       rax,	132
    jmp       L4124
L4125:
    mov       rax,	133
L4124:
    mov       rcx,	rax
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mc_genss.genrrm
    jmp       L4106
L4121:
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jnz       L4126
    movzx     rax,	word [rsi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jnz       L4126
    mov       rax,	rbx
    mov       r10,	rsi
    mov       rsi,	rax
    mov       rbx,	r10
    jmp       L4123
L4126:
    lea       rcx,	[L12576]
    call      mc_libmcl.axerror
L4106:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.do_setcc
mc_genss.do_setcc:
;?>>
   %define R.cond rdi
   %define R.b rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L4131
    cmp       rax,	3
    jnz       L4130
L4131:
    movzx     rax,	word [rbx+8]
    and       rax,	31
    cmp       rax,	1
    jle       L4129
L4130:
    lea       rcx,	[L12577]
    call      mc_libmcl.axerror
L4129:
    mov       rax,	3984
    add       rax,	rdi
    mov       rcx,	rax
    xor       edx,	edx
    mov       r8,	rbx
    call      mc_genss.genxrm
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.checksize
mc_genss.checksize:
;?>>
   %define R.a rdi
   %define R.size1 rbx
   %define R.size2 rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    movzx     rax,	word [rdi+8]
    and       rax,	31
    jnz       L4134
    lea       rcx,	[L12578]
    call      mc_libmcl.axerror
L4134:
    test      rbx,	rbx
    jz        L4136
    movzx     rax,	word [rdi+8]
    and       rax,	31
    cmp       rax,	rbx
    jz        L4136
    cmp       rax,	rsi
    jz        L4136
    call      msys.m$print_startcon
    lea       rcx,	[L12579]
    call      msys.m$print_str_nf
    movzx     rax,	word [rdi+8]
    and       rax,	31
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.m$print_u64
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L12580]
    call      mc_libmcl.axerror
L4136:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.do_arithxmm
mc_genss.do_arithxmm:
;?>>
   %define R.a rdi
   %define R.b rbx
   %define R.prefix rsi
   %define R.opc r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
    mov       r12,	r9
;---------------
    movzx     rax,	word [rdi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	5
    jnz       L4140
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	5
    jz        L4139
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jz        L4139
L4140:
    lea       rcx,	[L12581]
    call      mc_libmcl.axerror
L4139:
    test      rsi,	rsi
    jz        L4142
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       [r10],	sil
L4142:
    mov       rax,	3840
    add       rax,	r12
    mov       rcx,	rax
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_genss.genrrm
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.do_logicxmm
mc_genss.do_logicxmm:
;?>>
   %define R.a rdi
   %define R.b rbx
   %define R.opc rsi
   %define R.size r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
    mov       r12,	r9
;---------------
    movzx     rax,	word [rdi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	5
    jnz       L4146
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	5
    jz        L4145
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jz        L4145
L4146:
    lea       rcx,	[L12582]
    call      mc_libmcl.axerror
L4145:
    cmp       r12,	8
    jnz       L4148
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	102
    mov       [r10],	al
L4148:
    mov       rax,	3840
    add       rax,	rsi
    mov       rcx,	rax
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_genss.genrrm
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.do_convertfloat
mc_genss.do_convertfloat:
;?>>
   %define R.a rdi
   %define R.b rbx
   %define R.prefix rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    movzx     rax,	word [rdi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	5
    jnz       L4152
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	5
    jz        L4151
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jz        L4151
L4152:
    lea       rcx,	[L12583]
    call      mc_libmcl.axerror
L4151:
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       [r10],	sil
    mov       al,	1
    mov       [mc_genss.nowmask],	al
    mov       rcx,	3930
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_genss.genrrm
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.do_fix
mc_genss.do_fix:
;?>>
   %define R.a rdi
   %define R.b rbx
   %define R.prefix rsi
   %define R.opc r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r15
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
    mov       r12,	r9
;---------------
    movzx     rax,	word [rdi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jnz       L4156
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	5
    jz        L4155
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jz        L4155
L4156:
    lea       rcx,	[L12584]
    call      mc_libmcl.axerror
L4155:
    mov       rcx,	rdi
    mov       rdx,	4
    mov       r8,	8
    call      mc_genss.checksize
    cmp       rsi,	243
    jnz       L4158
    mov       rax,	4
    jmp       L4157
L4158:
    mov       rax,	8
L4157:
    lea       r10,	[rbx+8]
    mov       r15w,	[r10]
    mov       r11,	-32
    and       r15w,	r11w
    or        r15w,	ax
    mov       [r10],	r15w
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       [r10],	sil
    mov       rax,	3840
    add       rax,	r12
    mov       rcx,	rax
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_genss.genrrm
;---------------
    add       rsp,	48
    pop       r15
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.do_float
mc_genss.do_float:
;?>>
   %define R.a rdi
   %define R.b rbx
   %define R.prefix rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    movzx     rax,	word [rdi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	5
    jnz       L4162
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L4161
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jz        L4161
L4162:
    lea       rcx,	[L12585]
    call      mc_libmcl.axerror
L4161:
    mov       rcx,	rbx
    mov       rdx,	4
    mov       r8,	8
    call      mc_genss.checksize
    cmp       rsi,	243
    jnz       L4164
    mov       rax,	4
    jmp       L4163
L4164:
    mov       rax,	8
L4163:
    lea       r10,	[rdi+8]
    mov       r9w,	[r10]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	ax
    mov       [r10],	r9w
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       [r10],	sil
    mov       al,	1
    mov       [mc_genss.usesizeb],	al
    mov       rcx,	3882
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_genss.genrrm
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.do_movxmm
mc_genss.do_movxmm:
;?>>
   %define R.a rdi
   %define R.b rbx
   %define R.size rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    movzx     rax,	word [rdi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L4167
    cmp       rax,	5
    jz        L4168
    cmp       rax,	3
    jz        L4169
    jmp       L4170
L4167:
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	5
    jnz       L4173
L4172:
    movzx     rax,	word [rdi+8]
    and       rax,	31
    cmp       rax,	rsi
    jz        L4175
    lea       rcx,	[L12586]
    call      mc_libmcl.axerror
L4175:
    movzx     rax,	word [rdi+8]
    and       rax,	31
    lea       r10,	[rbx+8]
    mov       r9w,	[r10]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	ax
    mov       [r10],	r9w
    mov       al,	1
    mov       [mc_genss.sizeoverride],	al
    mov       rcx,	3966
    mov       rdx,	rbx
    mov       r8,	rdi
    call      mc_genss.genrrm
    jmp       L4171
L4173:
    lea       rcx,	[L12587]
    call      mc_libmcl.axerror
L4171:
    jmp       L4166
L4168:
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L4177
    cmp       rax,	5
    jz        L4178
    cmp       rax,	3
    jz        L4179
    jmp       L4180
L4177:
    movzx     rax,	word [rbx+8]
    and       rax,	31
    lea       r10,	[rdi+8]
    mov       r9w,	[r10]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	ax
    mov       [r10],	r9w
    movzx     rax,	word [rbx+8]
    and       rax,	31
    cmp       rax,	rsi
    jz        L4182
    lea       rcx,	[L12588]
    call      mc_libmcl.axerror
L4182:
    mov       al,	1
    mov       [mc_genss.sizeoverride],	al
    mov       rcx,	3950
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_genss.genrrm
    jmp       L4176
L4178:
    movzx     rax,	word [rbx+8]
    and       rax,	31
    lea       r10,	[rdi+8]
    mov       r9w,	[r10]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	ax
    mov       [r10],	r9w
    mov       al,	1
    mov       [mc_genss.f3override],	al
    mov       rcx,	3966
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_genss.genrrm
    jmp       L4176
L4179:
    movzx     rax,	word [rbx+8]
    and       rax,	31
    jnz       L4184
    movzx     rax,	word [rdi+8]
    and       rax,	31
    lea       r10,	[rbx+8]
    mov       r9w,	[r10]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	ax
    mov       [r10],	r9w
L4184:
    movzx     rax,	word [rbx+8]
    and       rax,	31
    cmp       rax,	rsi
    jz        L4186
    lea       rcx,	[L12589]
    call      mc_libmcl.axerror
L4186:
    cmp       rsi,	4
    jnz       L4188
    mov       al,	1
    mov       [mc_genss.sizeoverride],	al
    mov       al,	1
    mov       [mc_genss.nowmask],	al
    mov       rcx,	3950
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_genss.genrrm
    jmp       L4187
L4188:
    mov       al,	1
    mov       [mc_genss.f3override],	al
    mov       al,	1
    mov       [mc_genss.nowmask],	al
    mov       rcx,	3966
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_genss.genrrm
L4187:
    jmp       L4176
L4180:
    lea       rcx,	[L12590]
    call      mc_libmcl.axerror
L4176:
    jmp       L4166
L4169:
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	5
    jnz       L4191
L4190:
    movzx     rax,	word [rdi+8]
    and       rax,	31
    jz        L4193
    movzx     rax,	word [rdi+8]
    and       rax,	31
    cmp       rax,	rsi
    jz        L4193
    lea       rcx,	[L12591]
    call      mc_libmcl.axerror
L4193:
    mov       al,	1
    mov       [mc_genss.sizeoverride],	al
    cmp       rsi,	4
    jnz       L4195
    mov       rax,	3966
    jmp       L4194
L4195:
    mov       rax,	4054
L4194:
    mov       rcx,	rax
    mov       rdx,	rbx
    mov       r8,	rdi
    call      mc_genss.genrrm
    jmp       L4189
L4191:
    lea       rcx,	[L12592]
    call      mc_libmcl.axerror
L4189:
    jmp       L4166
L4170:
    lea       rcx,	[L12593]
    call      mc_libmcl.axerror
L4166:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.fixrip
mc_genss.fixrip:
;?>>
   %define R.dispsize rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rax,	[mc_genss.ripentry]
    test      rax,	rax
    jz        L4196
L4198:
    mov       rax,	rdi
    test      rax,	rax
    jz        L4200
    cmp       rax,	1
    jz        L4201
    cmp       rax,	2
    jz        L4201
    cmp       rax,	4
    jz        L4201
    jmp       L4202
L4200:
    jmp       L4196
L4201:
    jmp       L4199
L4202:
    call      msys.m$print_startcon
    lea       rcx,	[L12594]
    call      msys.m$print_str_nf
    mov       rcx,	rdi
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L12595]
    call      mc_libmcl.axerror
L4199:
    mov       eax,	edi
    mov       r10,	[mc_genss.ripentry]
    mov       [r10+12],	eax
L4196:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_genss.do_bswap
mc_genss.do_bswap:
;?>>
   %define R.a rbx
   %define R.code rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jnz       L4206
    movzx     rax,	word [rbx+8]
    and       rax,	31
    cmp       rax,	4
    jge       L4205
L4206:
    lea       rcx,	[L12596]
    call      mc_libmcl.axerror
L4205:
    mov       rcx,	rbx
    call      mc_genss.setopsize
    movzx     rax,	byte [rbx+10]
    mov       rcx,	rax
    mov       rdx,	1
    xor       r8d,	r8d
    call      mc_genss.getregcode
    mov       rdi,	rax
    call      mc_genss.genrex
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       al,	15
    mov       [r10],	al
    mov       rax,	200
    add       rax,	rdi
    mov       r10,	[mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword [r10]
    mov       [r11],	al
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.do_movdqx
mc_genss.do_movdqx:
;?>>
   %define R.a rdi
   %define R.b rbx
   %define R.prefix rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    mov       rax,	rsi
    shl       rax,	16
    add       rax,	3840
    mov       rsi,	rax
    movzx     rax,	word [rdi+8]
    and       rax,	31
    jnz       L4209
    lea       rax,	[rdi+8]
    mov       r10w,	16
    mov       r9w,	[rax]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
L4209:
    movzx     rax,	word [rbx+8]
    and       rax,	31
    jnz       L4211
    lea       rax,	[rbx+8]
    mov       r10w,	16
    mov       r9w,	[rax]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
L4211:
    movzx     rax,	word [rdi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jnz       L4213
    lea       rax,	[rsi+127]
    mov       rcx,	rax
    mov       rdx,	rbx
    mov       r8,	rdi
    call      mc_genss.genrrm
    jmp       L4212
L4213:
    lea       rax,	[rsi+111]
    mov       rcx,	rax
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_genss.genrrm
L4212:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_genss.do_dshift
mc_genss.do_dshift:
;?>>
   %define R.a rdi
   %define R.b rbx
   %define R.c rsi
   %define R.opc r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r15
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
    mov       r12,	r9
;---------------
    movzx     rax,	word [rdi+8]
    and       rax,	31
    jnz       L4216
    movzx     rax,	word [rbx+8]
    and       rax,	31
    lea       r10,	[rdi+8]
    mov       r15w,	[r10]
    mov       r11,	-32
    and       r15w,	r11w
    or        r15w,	ax
    mov       [r10],	r15w
L4216:
    movzx     rax,	word [rdi+8]
    and       rax,	31
    movzx     r10,	word [rbx+8]
    and       r10,	31
    cmp       rax,	r10
    jnz       L4219
    movzx     rax,	word [rdi+8]
    and       rax,	31
    cmp       rax,	1
    jg        L4218
L4219:
    lea       rcx,	[L12597]
    call      mc_libmcl.axerror
L4218:
    xor       eax,	eax
    mov       [mc_genss.sizeoverride],	al
    mov       rax,	3840
    add       rax,	r12
    mov       rcx,	rax
    mov       rdx,	rbx
    mov       r8,	rdi
    call      mc_genss.genrrm
    mov       rax,	[mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       [r10],	sil
;---------------
    add       rsp,	48
    pop       r15
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_decls.start
mc_decls.start:
;?>>
   %define R.av_1 rdi
   %define R.i rbx
    push      rdi
    push      rbx
;?]]
;---------------
    xor       rbx,	rbx
    mov       rax,	13
    mov       rdi,	rax
    cmp       rdi,	0
    jl        L4223
L4221:
    mov       al,	10
    lea       r10,	[mc_decls.ploadop]
    mov       r11,	rbx
    mov       [r10 + r11],	al
    inc       rbx
    cmp       rbx,	rdi
    jle       L4221
L4223:
    mov       al,	19
    lea       r10,	[mc_decls.ploadop]
    mov       [r10+5],	al
    lea       r10,	[mc_decls.ploadop]
    mov       [r10+4],	al
    lea       r10,	[mc_decls.ploadop]
    mov       [r10+3],	al
    mov       al,	18
    lea       r10,	[mc_decls.ploadop]
    mov       [r10+9],	al
    lea       r10,	[mc_decls.ploadop]
    mov       [r10+8],	al
    lea       r10,	[mc_decls.ploadop]
    mov       [r10+7],	al
    mov       al,	16
    lea       r10,	[mc_decls.ploadop]
    mov       [r10+1],	al
    mov       al,	17
    lea       r10,	[mc_decls.ploadop]
    mov       [r10+2],	al
    mov       al,	11
    lea       r10,	[mc_decls.ploadop]
    mov       [r10+10],	al
    lea       r10,	[mc_decls.ploadop]
    mov       [r10+6],	al
;---------------
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writenasm.getassemstr
mc_writenasm.getassemstr:
;?>>
   %define R.d rdi
   %define R.m rbx
   %define R.i rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
;---------------
    mov       rcx,	[pc_decls.pdest]
    call      mlib.gs_init
    lea       rcx,	[L12598]
    call      mc_writenasm.asmstr
    lea       rcx,	[L12599]
    call      mc_writenasm.asmstr
    lea       rcx,	[L12600]
    call      mc_writenasm.asmstr
    lea       rcx,	[L12601]
    call      mc_writenasm.asmstr
    lea       rcx,	[L12602]
    call      mc_writenasm.asmstr
    lea       rcx,	[L12603]
    call      mc_writenasm.asmstr
    lea       rcx,	[L12604]
    call      mc_writenasm.asmstr
    lea       rcx,	[L12605]
    call      mc_writenasm.asmstr
    lea       rcx,	[L12606]
    call      mc_writenasm.asmstr
    lea       rcx,	[L12607]
    call      mc_writenasm.asmstr
    lea       rcx,	[L12608]
    call      mc_writenasm.asmstr
    lea       rcx,	[L12609]
    call      mc_writenasm.asmstr
    lea       rcx,	[L12610]
    call      mc_writenasm.asmstr
    lea       rcx,	[L12611]
    call      mc_writenasm.asmstr
    lea       rcx,	[L12612]
    call      mc_writenasm.asmstr
    lea       rcx,	[L12613]
    call      mc_writenasm.asmstr
    lea       rcx,	[L12614]
    call      mc_writenasm.asmstr
    lea       rcx,	[L12615]
    call      mc_writenasm.asmstr
    lea       rcx,	[L12616]
    call      mc_writenasm.asmstr
    mov       rdi,	[pc_decls.psymboltable]
    jmp       L4228
L4225:
    mov       al,	[rdi+80]
    test      al,	al
    jz        L4230
    lea       rcx,	[L12617]
    call      mc_writenasm.asmstr
    mov       rcx,	[rdi]
    call      mc_writenasm.asmstr
    lea       rcx,	[L12618]
    call      mc_writenasm.asmstr
L4230:
    mov       al,	[rdi+81]
    test      al,	al
    jz        L4232
    lea       rcx,	[L12619]
    call      mc_writenasm.asmstr
    mov       rcx,	[rdi]
    call      mc_writenasm.asmstr
    lea       rcx,	[L12620]
    call      mc_writenasm.asmstr
L4232:
    mov       rdi,	[rdi+8]
L4228:
    test      rdi,	rdi
    jnz       L4225
    lea       rcx,	[L12620]
    call      mc_writenasm.asmstr
    mov       rbx,	[mc_decls.mccode]
    mov       rsi,	1
    jmp       L4234
L4233:
    mov       rcx,	rsi
    mov       rdx,	rbx
    call      mc_writenasm.writemcl
    inc       rsi
    mov       rbx,	[rbx+8]
L4234:
    test      rbx,	rbx
    jnz       L4233
    mov       rax,	[pc_decls.pdest]
L4224:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writenasm.writemcl
mc_writenasm.writemcl:
;?>>
    %define mc_writenasm.writemcl.index 24
   %define R.mcl rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rdx
;---------------
    mov       rcx,	rdi
    call      mc_writenasm.strmcl
    mov       rcx,	[pc_decls.pdest]
    call      mlib.gs_line
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_writenasm.start
mc_writenasm.start:
;?>>
   %define R.flag dil
   %define R.av_1 rbx
   %define R.i rsi
   %define R.r r12
   %define R.k r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	16
;---------------
    mov       rax,	1297301838
    mov       [pc_decls.assemtype],	rax
    mov       rsi,	1
L4238:
    mov       rax,	rsi
    cmp       rax,	1
    jz        L4243
    cmp       rax,	2
    jz        L4243
    cmp       rax,	4
    jz        L4243
    cmp       rax,	8
    jnz       L4242
L4243:
    mov       r12,	1
L4244:
    xor       dil,	dil
    mov       rax,	1
    mov       r13,	rax
    mov       rbx,	137
    cmp       rbx,	1
    jl        L4249
L4247:
    test      dil,	dil
    jz        L4251
    lea       rax,	[mc_decls.regsizes]
    mov       r10,	r13
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	rsi
    jnz       L4253
    lea       rax,	[mc_decls.regindices]
    mov       r10,	r13
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	r12
    jnz       L4253
    lea       rax,	[mc_decls.dregnames]
    mov       r10,	r13
    mov       rax,	[rax + r10*8-8]
    lea       r10,	[mc_writenasm.nregnames]
    mov       r11,	rsi
    shl       r11,	7
    lea       r10,	[r10 + r11-128]
    mov       r11,	r12
    mov       [r10 + r11*8-8],	rax
L4253:
    jmp       L4250
L4251:
    lea       rax,	[mc_decls.regsizes]
    mov       r10,	r13
    movzx     rax,	byte [rax + r10-1]
    test      rax,	rax
    jnz       L4254
    mov       dil,	1
L4254:
L4250:
    inc       r13
    cmp       r13,	rbx
    jle       L4247
L4249:
    inc       r12
    cmp       r12,	16
    jle       L4244
L4242:
    inc       rsi
    cmp       rsi,	8
    jle       L4238
;---------------
    add       rsp,	16
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writenasm.strmcl
mc_writenasm.strmcl:
;?>>
    %define mc_writenasm.strmcl.mcl 72
    %define mc_writenasm.strmcl.opcname -128
   %define R.a rdi
   %define R.b rbx
   %define R.opcode rsi
   %define R.cond r12
   %define R.sizepref r13
   %define R.comment r14
   %define R.d r15
    %define mc_writenasm.strmcl.$T1 -136
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	168
    mov       [rbp+72],	rcx
;---------------
    mov       rax,	[rbp + mc_writenasm.strmcl.mcl]
    movzx     rax,	byte [rax+33]
    mov       rsi,	rax
    mov       rax,	[rbp + mc_writenasm.strmcl.mcl]
    movzx     rax,	byte [rax+34]
    mov       r12,	rax
    mov       rax,	[rbp + mc_writenasm.strmcl.mcl]
    mov       rdi,	[rax+16]
    mov       rax,	[rbp + mc_writenasm.strmcl.mcl]
    mov       rbx,	[rax+24]
    xor       r14,	r14
    mov       rax,	rsi
    cmp       rax,	1
    jz        L4257
    cmp       rax,	2
    jz        L4258
    cmp       rax,	3
    jz        L4259
    cmp       rax,	4
    jz        L4260
    cmp       rax,	9
    jz        L4261
    cmp       rax,	5
    jz        L4262
    cmp       rax,	6
    jz        L4263
    cmp       rax,	122
    jz        L4264
    cmp       rax,	120
    jz        L4265
    cmp       rax,	121
    jz        L4266
    jmp       L4267
L4257:
    lea       rcx,	[L12621]
    call      mc_writenasm.asmstr
    mov       rax,	[rdi]
    mov       rcx,	[rax]
    call      mc_writenasm.asmstr
    mov       rax,	[rdi]
    mov       [mc_decls.currasmproc],	rax
    jmp       L4255
L4258:
    lea       rcx,	[L12622]
    call      mc_writenasm.asmstr
    xor       eax,	eax
    mov       [mc_decls.currasmproc],	rax
    jmp       L4255
L4259:
    mov       rcx,	59
    call      mc_writenasm.asmchar
    mov       rcx,	[rdi]
    call      mc_writenasm.asmstr
    jmp       L4255
L4260:
    mov       r15,	[rdi]
    movzx     rax,	word [rdi+8]
    shr       rax,	12
    and       rax,	15
    cmp       rax,	5
    jz        L4269
    cmp       rax,	4
    jz        L4270
    jmp       L4271
L4269:
    mov       rcx,	r15
    call      mc_writenasm.getdispname
    mov       rcx,	rax
    call      mc_writenasm.asmstr
    jmp       L4268
L4270:
    mov       rcx,	[rdi]
    call      mc_writenasm.asmstr
    jmp       L4255
L4271:
    lea       rcx,	[L12623]
    lea       rdx,	[L12624]
    call      pc_api.merror
L4268:
    lea       rcx,	[L12625]
    call      mc_writenasm.asmstr
    mov       al,	[r15+81]
    test      al,	al
    jz        L4273
    mov       rax,	[r15]
    mov       [rbp + mc_writenasm.strmcl.$T1],	rax
    mov       rax,	[r15]
    mov       rcx,	rax
    call      pc_api.getbasename
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_writenasm.strmcl.$T1]
    call      mlib.eqstring
    test      rax,	rax
    jnz       L4274
L4275:
    lea       rcx,	[L12626]
    call      mc_writenasm.asmstr
    mov       rax,	[r15]
    mov       rcx,	rax
    call      pc_api.getbasename
    mov       rcx,	rax
    call      mc_writenasm.asmstr
    lea       rcx,	[L12627]
    call      mc_writenasm.asmstr
L4274:
L4273:
    jmp       L4255
L4261:
    lea       rcx,	[mc_writenasm.strmcl.str]
    call      msys.m$print_startstr
    lea       rcx,	[L12628]
    call      msys.m$print_setfmt
    mov       rcx,	[rdi]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       rcx,	[mc_writenasm.strmcl.str]
    call      mc_writenasm.asmstr
    jmp       L4255
L4262:
    lea       rcx,	[L12629]
    call      mc_writenasm.asmstr
    mov       rcx,	[rdi]
    call      mc_writenasm.asmstr
    lea       rcx,	[L12630]
    call      mc_writenasm.asmstr
    mov       rcx,	rbx
    xor       edx,	edx
    xor       r8d,	r8d
    call      mc_writenasm.asmopnd
    jmp       L4255
L4263:
    mov       r15,	[rdi]
    lea       rcx,	[L12631]
    call      mc_writenasm.asmstr
    mov       rcx,	r15
    call      mc_writenasm.getdispname
    mov       rcx,	rax
    call      mc_writenasm.asmstr
    lea       rcx,	[L12632]
    call      mc_writenasm.asmstr
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jnz       L4278
L4277:
    movzx     rax,	word [rbx+8]
    and       rax,	31
    movzx     r10,	byte [rbx+10]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_writenasm.strreg
    mov       rcx,	rax
    call      mc_writenasm.asmstr
    jmp       L4276
L4278:
    movzx     rax,	word [rbx+8]
    and       rax,	31
    movzx     r10,	byte [rbx+10]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_writenasm.strxreg
    mov       rcx,	rax
    call      mc_writenasm.asmstr
L4276:
    jmp       L4255
    jmp       L4256
L4264:
    lea       rcx,	[L12633]
    call      mc_writenasm.asmstr
    mov       al,	1
    mov       [mc_writenasm.currseg],	al
    jmp       L4255
L4265:
    lea       rcx,	[L12634]
    call      mc_writenasm.asmstr
    mov       al,	2
    mov       [mc_writenasm.currseg],	al
    jmp       L4255
L4266:
    lea       rcx,	[L12635]
    call      mc_writenasm.asmstr
    mov       al,	3
    mov       [mc_writenasm.currseg],	al
    jmp       L4255
L4267:
L4256:
    mov       rax,	rsi
    cmp       rax,	26
    jz        L4280
    cmp       rax,	58
    jz        L4281
    cmp       rax,	15
    jz        L4282
    cmp       rax,	38
    jz        L4283
    cmp       rax,	39
    jz        L4284
    cmp       rax,	40
    jz        L4285
    cmp       rax,	51
    jz        L4286
    cmp       rax,	34
    jz        L4287
    cmp       rax,	19
    jz        L4288
    cmp       rax,	18
    jz        L4289
    cmp       rax,	16
    jz        L4290
    cmp       rax,	123
    jz        L4291
    cmp       rax,	8
    jz        L4292
    jmp       L4293
L4280:
    lea       rcx,	[rbp + mc_writenasm.strmcl.opcname]
    call      msys.m$print_startstr
    lea       rcx,	[L12636]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rax,	[mc_decls.asmcondnames]
    mov       r10,	r12
    mov       rcx,	[rax + r10*8]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L4279
L4281:
    lea       rcx,	[rbp + mc_writenasm.strmcl.opcname]
    call      msys.m$print_startstr
    lea       rcx,	[L12637]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rax,	[mc_decls.asmcondnames]
    mov       r10,	r12
    mov       rcx,	[rax + r10*8]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L4279
L4282:
    lea       rcx,	[rbp + mc_writenasm.strmcl.opcname]
    call      msys.m$print_startstr
    lea       rcx,	[L12638]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rax,	[mc_decls.asmcondnames]
    mov       r10,	r12
    mov       rcx,	[rax + r10*8]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L4279
L4283:
    lea       rcx,	[rbp + mc_writenasm.strmcl.opcname]
    lea       rdx,	[L12639]
    call      strcpy
    jmp       L4279
L4284:
    lea       rcx,	[rbp + mc_writenasm.strmcl.opcname]
    lea       rdx,	[L12640]
    call      strcpy
    jmp       L4279
L4285:
    lea       rcx,	[rbp + mc_writenasm.strmcl.opcname]
    lea       rdx,	[L12641]
    call      strcpy
    jmp       L4279
L4286:
    lea       rcx,	[rbp + mc_writenasm.strmcl.opcname]
    lea       rdx,	[L12642]
    call      strcpy
    jmp       L4279
L4287:
    lea       rcx,	[rbp + mc_writenasm.strmcl.opcname]
    lea       rdx,	[L12643]
    call      strcpy
    jmp       L4279
L4288:
    movzx     rax,	word [rdi+8]
    and       rax,	31
    cmp       rax,	8
    jnz       L4295
    movzx     rax,	word [rbx+8]
    and       rax,	31
    cmp       rax,	4
    jnz       L4295
    mov       rcx,	rdi
    mov       rdx,	4
    call      mc_libmcl.changeopndsize
    mov       rdi,	rax
    mov       r10,	[rbp + mc_writenasm.strmcl.mcl]
    mov       [r10+16],	rax
    mov       rsi,	11
L4295:
    jmp       L4293
    jmp       L4279
L4289:
    movzx     rax,	word [rdi+8]
    and       rax,	31
    cmp       rax,	8
    jnz       L4297
    movzx     rax,	word [rbx+8]
    and       rax,	31
    cmp       rax,	4
    jnz       L4297
    lea       rcx,	[rbp + mc_writenasm.strmcl.opcname]
    lea       rdx,	[L12644]
    call      strcpy
    jmp       L4296
L4297:
    jmp       L4293
L4296:
    jmp       L4279
L4290:
    movzx     rax,	word [rdi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	5
    jnz       L4299
    movzx     rax,	word [rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	5
    jnz       L4299
    mov       rsi,	17
L4299:
    jmp       L4293
    jmp       L4279
L4291:
    movzx     rax,	byte [mc_writenasm.currseg]
    cmp       rax,	3
    jnz       L4301
    lea       rcx,	[rbp + mc_writenasm.strmcl.opcname]
    lea       rdx,	[L12645]
    call      strcpy
    jmp       L4300
L4301:
    jmp       L4293
L4300:
    jmp       L4279
L4292:
    jmp       L4255
L4293:
    cmp       rsi,	151
    jle       L4303
    mov       rcx,	rsi
    xor       edx,	edx
    call      msys.strint
    lea       rcx,	[rbp + mc_writenasm.strmcl.opcname]
    mov       rdx,	rax
    call      strcpy
    jmp       L4302
L4303:
    lea       rax,	[mc_decls.mclnames]
    mov       r10,	rsi
    mov       rax,	[rax + r10*8-8]
    lea       rax,	[rax+2]
    lea       rcx,	[rbp + mc_writenasm.strmcl.opcname]
    mov       rdx,	rax
    call      strcpy
L4302:
L4279:
    cmp       rsi,	119
    jnz       L4305
    mov       rax,	4
    jmp       L4304
L4305:
    mov       rax,	10
L4304:
    lea       rcx,	[rbp + mc_writenasm.strmcl.opcname]
    mov       rdx,	rax
    lea       r8,	[L12646]
    call      mlib.ipadstr
    lea       rcx,	[mc_writenasm.strmcl.str]
    lea       rdx,	[L12647]
    call      strcpy
    lea       rcx,	[mc_writenasm.strmcl.str]
    mov       rdx,	4
    lea       r8,	[L12648]
    call      mlib.ipadstr
    lea       rcx,	[mc_writenasm.strmcl.str]
    lea       rdx,	[rbp + mc_writenasm.strmcl.opcname]
    call      strcat
    lea       rcx,	[mc_writenasm.strmcl.str]
    call      mc_writenasm.asmstr
    test      rdi,	rdi
    jz        L4307
    test      rbx,	rbx
    jz        L4307
    mov       rcx,	rsi
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_writenasm.needsizeprefix
    mov       r13,	rax
    mov       rcx,	rdi
    mov       rdx,	r13
    xor       r8d,	r8d
    call      mc_writenasm.asmopnd
    lea       rcx,	[L12649]
    call      mc_writenasm.asmstr
    mov       rcx,	rbx
    mov       rdx,	r13
    xor       r8d,	r8d
    call      mc_writenasm.asmopnd
    mov       rax,	[rbp + mc_writenasm.strmcl.mcl]
    mov       al,	[rax+32]
    test      al,	al
    jz        L4309
    lea       rcx,	[L12650]
    call      mc_writenasm.asmstr
    mov       rax,	[rbp + mc_writenasm.strmcl.mcl]
    movzx     rax,	byte [rax+32]
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.strint
    mov       rcx,	rax
    call      mc_writenasm.asmstr
L4309:
    jmp       L4306
L4307:
    test      rdi,	rdi
    jz        L4310
    movzx     rax,	word [rdi+8]
    shr       rax,	9
    and       rax,	7
    jz        L4310
    cmp       rsi,	21
    jnz       L4312
    mov       rcx,	rdi
    xor       edx,	edx
    mov       r8,	rsi
    call      mc_writenasm.asmopnd
    jmp       L4311
L4312:
    mov       rcx,	rdi
    mov       rdx,	1
    mov       r8,	rsi
    call      mc_writenasm.asmopnd
L4311:
L4310:
L4306:
L4255:
;---------------
    add       rsp,	168
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writenasm.strmclstr
mc_writenasm.strmclstr:
;?>>
   %define R.m rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	[pc_decls.pdest]
    call      mlib.gs_init
    mov       rcx,	rdi
    call      mc_writenasm.strmcl
    mov       rax,	[pc_decls.pdest]
    mov       rax,	[rax]
L4313:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_writenasm.mstropnd
mc_writenasm.mstropnd:
;?>>
   %define R.a rsi
   %define R.sizeprefix r12
   %define R.opcode r13
    %define mc_writenasm.mstropnd.str2 -128
   %define R.plus rdi
   %define R.offset rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	168
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
;---------------
    xor       eax,	eax
    lea       r10,	[mc_writenasm.mstropnd.str]
    mov       [r10],	al
    movzx     rax,	word [rsi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L4316
    cmp       rax,	2
    jz        L4317
    cmp       rax,	3
    jz        L4318
    cmp       rax,	5
    jz        L4319
    jmp       L4320
L4316:
    movzx     rax,	word [rsi+8]
    and       rax,	31
    movzx     r10,	byte [rsi+10]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_writenasm.strreg
    jmp       L4314
L4317:
    cmp       r13,	119
    jnz       L4322
    movzx     rax,	word [rsi+8]
    shr       rax,	12
    and       rax,	15
    cmp       rax,	1
    jnz       L4322
    mov       rax,	[rsi]
    cmp       rax,	0
    jl        L4324
    cmp       rax,	9
    jg        L4324
    mov       rax,	[rsi]
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.strint
    lea       rcx,	[mc_writenasm.mstropnd.str]
    mov       rdx,	rax
    call      strcat
    jmp       L4323
L4324:
    lea       rcx,	[mc_writenasm.mstropnd.str]
    lea       rdx,	[L12651]
    call      strcat
    mov       rax,	[rsi]
    mov       rcx,	rax
    lea       rdx,	[L12652]
    call      msys.strword
    lea       rcx,	[mc_writenasm.mstropnd.str]
    mov       rdx,	rax
    call      strcat
L4323:
    jmp       L4321
L4322:
    mov       rcx,	rsi
    call      mc_writenasm.strvalue
    lea       rcx,	[mc_writenasm.mstropnd.str]
    mov       rdx,	rax
    call      strcpy
L4321:
    jmp       L4315
L4318:
    movzx     rax,	word [rsi+8]
    shr       rax,	12
    and       rax,	15
    cmp       rax,	1
    jz        L4326
    cmp       rax,	2
    jz        L4327
    cmp       rax,	3
    jz        L4328
    jmp       L4329
L4326:
    mov       rax,	[rsi]
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.strint
    lea       rcx,	[mc_writenasm.mstropnd.str]
    mov       rdx,	rax
    call      strcpy
    jmp       L4325
L4327:
    movq      XMM4,	[rsi]
    movq      XMM0,	XMM4
    xor       edx,	edx
    call      msys.strreal
    lea       rcx,	[mc_writenasm.mstropnd.str]
    mov       rdx,	rax
    call      strcpy
    jmp       L4325
L4328:
    lea       rcx,	[mc_writenasm.mstropnd.str]
    call      msys.m$print_startstr
    lea       rcx,	[L12653]
    call      msys.m$print_setfmt
    movq      XMM4,	[rsi]
    movq      XMM0,	XMM4
    xor       edx,	edx
    call      msys.m$print_r64
    call      msys.m$print_end
L4329:
L4325:
    movzx     rax,	word [rsi+8]
    and       rax,	31
    mov       rcx,	rax
    mov       rdx,	r12
    call      mc_writenasm.getsizeprefix
    lea       rcx,	[mc_writenasm.mstropnd.str]
    mov       rdx,	rax
    call      strcat
    lea       rcx,	[mc_writenasm.mstropnd.str]
    lea       rdx,	[L12654]
    call      strcat
    lea       rax,	[L12655]
    mov       rdi,	rax
    mov       al,	[rsi+10]
    test      al,	al
    jz        L4331
    movzx     rax,	byte [rsi+10]
    mov       rcx,	rax
    mov       rdx,	8
    call      mc_writenasm.strreg
    lea       rcx,	[mc_writenasm.mstropnd.str]
    mov       rdx,	rax
    call      strcat
    lea       rax,	[L12656]
    mov       rdi,	rax
L4331:
    mov       al,	[rsi+11]
    test      al,	al
    jz        L4333
    lea       rcx,	[mc_writenasm.mstropnd.str]
    mov       rdx,	rdi
    call      strcat
    movzx     rax,	byte [rsi+11]
    mov       rcx,	rax
    mov       rdx,	8
    call      mc_writenasm.strreg
    lea       rcx,	[mc_writenasm.mstropnd.str]
    mov       rdx,	rax
    call      strcat
    lea       rax,	[L12656]
    mov       rdi,	rax
    movzx     rax,	word [rsi+8]
    shr       rax,	5
    and       rax,	15
    cmp       rax,	1
    jle       L4335
    lea       rcx,	[mc_writenasm.mstropnd.str]
    lea       rdx,	[L12657]
    call      strcat
    movzx     rax,	word [rsi+8]
    shr       rax,	5
    and       rax,	15
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.strint
    lea       rcx,	[mc_writenasm.mstropnd.str]
    mov       rdx,	rax
    call      strcat
L4335:
L4333:
    movzx     rax,	word [rsi+8]
    shr       rax,	12
    and       rax,	15
    cmp       rax,	5
    jz        L4338
    cmp       rax,	6
    jz        L4338
    cmp       rax,	8
    jnz       L4337
L4338:
    mov       al,	[rdi]
    test      al,	al
    jz        L4340
    lea       rcx,	[mc_writenasm.mstropnd.str]
    mov       rdx,	rdi
    call      strcat
L4340:
    mov       rcx,	rsi
    call      mc_writenasm.strvalue
    lea       rcx,	[mc_writenasm.mstropnd.str]
    mov       rdx,	rax
    call      strcat
    jmp       L4336
L4337:
    movsxd    rax,	dword [rsi+12]
    mov       rbx,	rax
    test      rax,	rax
    jz        L4341
    lea       rcx,	[rbp + mc_writenasm.mstropnd.str2]
    call      msys.m$print_startstr
    mov       rcx,	rbx
    lea       rdx,	[L12658]
    call      msys.m$print_i64
    call      msys.m$print_end
    lea       rcx,	[mc_writenasm.mstropnd.str]
    lea       rdx,	[rbp + mc_writenasm.mstropnd.str2]
    call      strcat
L4341:
L4336:
    lea       rcx,	[mc_writenasm.mstropnd.str]
    lea       rdx,	[L12659]
    call      strcat
    jmp       L4315
L4319:
    movzx     rax,	word [rsi+8]
    and       rax,	31
    movzx     r10,	byte [rsi+10]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_writenasm.strxreg
    jmp       L4314
L4320:
    call      msys.m$print_startcon
    lea       rcx,	[L12660]
    call      msys.m$print_str_nf
    movzx     rax,	word [rsi+8]
    shr       rax,	9
    and       rax,	7
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.m$print_u64
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rax,	[L12661]
    jmp       L4314
L4315:
    lea       rax,	[mc_writenasm.mstropnd.str]
L4314:
;---------------
    add       rsp,	168
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writenasm.strvalue
mc_writenasm.strvalue:
;?>>
   %define R.a r12
    %define mc_writenasm.strvalue.str2 -128
   %define R.def rdi
   %define R.value rbx
   %define R.offset rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	160
    mov       r12,	rcx
;---------------
    mov       rdi,	[r12]
    mov       rbx,	[r12]
    lea       rcx,	[mc_writenasm.strvalue.str]
    lea       rdx,	[L12662]
    call      strcpy
    movzx     rax,	word [r12+8]
    shr       rax,	12
    and       rax,	15
    cmp       rax,	5
    jz        L4344
    cmp       rax,	1
    jz        L4345
    cmp       rax,	2
    jz        L4346
    cmp       rax,	3
    jz        L4347
    cmp       rax,	4
    jz        L4348
    cmp       rax,	7
    jz        L4349
    cmp       rax,	6
    jz        L4350
    cmp       rax,	8
    jz        L4351
    jmp       L4352
L4344:
    mov       rcx,	rdi
    call      mc_writenasm.getdispname
    lea       rcx,	[mc_writenasm.strvalue.str]
    mov       rdx,	rax
    call      strcat
;mc_writenasm.strvalue.addoffset:
L4353:
    movsxd    rax,	dword [r12+12]
    mov       rsi,	rax
    test      rax,	rax
    jz        L4355
    lea       rcx,	[rbp + mc_writenasm.strvalue.str2]
    call      msys.m$print_startstr
    cmp       rsi,	0
    jle       L4357
    lea       rax,	[L12663]
    jmp       L4356
L4357:
    lea       rax,	[L12664]
L4356:
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       rcx,	rsi
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       rcx,	[mc_writenasm.strvalue.str]
    lea       rdx,	[rbp + mc_writenasm.strvalue.str2]
    call      strcat
L4355:
    jmp       L4343
L4345:
    mov       rcx,	rbx
    xor       edx,	edx
    call      msys.strint
    lea       rcx,	[mc_writenasm.strvalue.str]
    mov       rdx,	rax
    call      strcat
    jmp       L4343
L4346:
    lea       rcx,	[mc_writenasm.strvalue.str]
    call      msys.m$print_startstr
    movq      XMM4,	[r12]
    movq      XMM0,	XMM4
    lea       rdx,	[L12665]
    call      msys.m$print_r64
    call      msys.m$print_end
    jmp       L4343
L4347:
    lea       rcx,	[mc_writenasm.strvalue.str]
    lea       rdx,	[L12666]
    call      strcat
    movq      XMM4,	[r12]
    movq      XMM0,	XMM4
    xor       edx,	edx
    call      msys.strreal
    lea       rcx,	[mc_writenasm.strvalue.str]
    mov       rdx,	rax
    call      strcat
    jmp       L4343
L4348:
    lea       rcx,	[mc_writenasm.strvalue.str]
    lea       rdx,	[L12667]
    call      strcat
    mov       rax,	[r12]
    lea       rcx,	[mc_writenasm.strvalue.str]
    mov       rdx,	rax
    call      strcat
    lea       rcx,	[mc_writenasm.strvalue.str]
    lea       rdx,	[L12667]
    call      strcat
    jmp       L4343
L4349:
    mov       rax,	[r12]
    lea       rcx,	[mc_writenasm.strvalue.str]
    mov       rdx,	rax
    call      strcat
    jmp       L4343
L4350:
    lea       rcx,	[mc_writenasm.strvalue.str]
    lea       rdx,	[L12668]
    call      strcat
    mov       rax,	[r12]
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.strint
    lea       rcx,	[mc_writenasm.strvalue.str]
    mov       rdx,	rax
    call      strcat
    jmp       L4353
L4351:
    mov       rax,	[r12]
    mov       rcx,	[mc_decls.currasmproc]
    mov       rdx,	rax
    call      mc_writenasm.gettempname
    jmp       L4342
L4352:
    lea       rcx,	[L12669]
    lea       rdx,	[L12670]
    call      pc_api.merror
L4343:
    lea       rax,	[mc_writenasm.strvalue.str]
L4342:
;---------------
    add       rsp,	160
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writenasm.asmopnd
mc_writenasm.asmopnd:
;?>>
   %define R.a rdi
   %define R.sizeprefix rbx
   %define R.opcode rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mc_writenasm.mstropnd
    mov       rcx,	rax
    call      mc_writenasm.asmstr
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writenasm.getxregname
mc_writenasm.getxregname:
;?>>
   %define R.reg rdi
    %define mc_writenasm.getxregname.size 32
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    test      rdi,	rdi
    jnz       L4361
    lea       rax,	[L12671]
    jmp       L4359
L4361:
    lea       rcx,	[mc_writenasm.getxregname.str]
    call      msys.m$print_startstr
    lea       rcx,	[L12672]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rax,	[rdi-1]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       rax,	[mc_writenasm.getxregname.str]
L4359:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_writenasm.asmstr
mc_writenasm.asmstr:
;?>>
   %define R.s rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	[pc_decls.pdest]
    mov       rdx,	rdi
    call      mlib.gs_str
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_writenasm.asmchar
mc_writenasm.asmchar:
;?>>
   %define R.c rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	[pc_decls.pdest]
    mov       rdx,	rdi
    call      mlib.gs_char
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_writenasm.getdispname
mc_writenasm.getdispname:
;?>>
   %define R.d rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       al,	[rdi+90]
    test      al,	al
    jz        L4366
    lea       rcx,	[mc_writenasm.getdispname.str]
    call      msys.m$print_startstr
    lea       rcx,	[L12673]
    call      msys.m$print_setfmt
    lea       rcx,	[L12674]
    call      msys.m$print_str_nf
    mov       rcx,	[rdi]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       rax,	[mc_writenasm.getdispname.str]
    jmp       L4364
L4366:
    mov       al,	[pc_api.fpshortnames]
    test      al,	al
    jz        L4368
    mov       rax,	[rdi]
    jmp       L4364
L4368:
    mov       rcx,	rdi
    xor       edx,	edx
    call      pc_api.getfullname
L4364:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_writenasm.gettempname
mc_writenasm.gettempname:
;?>>
   %define R.d rdi
   %define R.n rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       al,	[pc_api.fpshortnames]
    test      al,	al
    jz        L4371
    lea       rcx,	[mc_writenasm.gettempname.str]
    call      msys.m$print_startstr
    lea       rcx,	[L12675]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       rcx,	rbx
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L4370
L4371:
    lea       rcx,	[mc_writenasm.gettempname.str]
    call      msys.m$print_startstr
    lea       rcx,	[L12676]
    call      msys.m$print_setfmt
    mov       rcx,	rdi
    call      mc_writenasm.getdispname
    mov       rcx,	rax
    call      msys.m$print_str_nf
    mov       rcx,	rbx
    call      msys.m$print_i64_nf
    call      msys.m$print_end
L4370:
    lea       rax,	[mc_writenasm.gettempname.str]
L4369:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writenasm.strreg
mc_writenasm.strreg:
;?>>
   %define R.reg rcx
   %define R.size rdx
;?]]
;---------------
    lea       rax,	[mc_writenasm.nregnames]
    mov       r10,	rdx
    shl       r10,	7
    lea       rax,	[rax + r10-128]
    mov       r10,	rcx
    mov       rax,	[rax + r10*8-8]
L4372:
;---------------
    ret       
;End 
;Proc mc_writenasm.strxreg
mc_writenasm.strxreg:
;?>>
   %define R.reg rbx
   %define R.size rsi
   %define R.d rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    mov       rcx,	rbx
    mov       rdx,	1
    call      mc_writenasm.checkregvar
    mov       rdi,	rax
    cmp       rsi,	8
    jnz       L4375
    test      rdi,	rdi
    jz        L4375
    mov       rcx,	rdi
    call      mc_writenasm.getdispname
    jmp       L4374
L4375:
    mov       rcx,	rbx
    mov       rdx,	rsi
    call      mc_writenasm.getxregname
L4374:
L4373:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writenasm.needsizeprefix
mc_writenasm.needsizeprefix:
;?>>
   %define R.opcode rcx
   %define R.a rdx
   %define R.b r8
;?]]
;---------------
    mov       rax,	rcx
    cmp       rax,	18
    jz        L4378
    cmp       rax,	19
    jz        L4378
    cmp       rax,	86
    jz        L4378
    cmp       rax,	87
    jz        L4378
    cmp       rax,	82
    jz        L4379
    cmp       rax,	83
    jz        L4379
    cmp       rax,	84
    jz        L4379
    cmp       rax,	85
    jz        L4379
    cmp       rax,	43
    jz        L4380
    cmp       rax,	45
    jz        L4380
    cmp       rax,	44
    jz        L4380
    jmp       L4381
L4378:
    mov       rax,	1
    jmp       L4376
L4379:
    mov       rax,	1
    jmp       L4376
L4380:
    movzx     rax,	word [rdx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jnz       L4383
    mov       rax,	1
    jmp       L4376
L4383:
    xor       eax,	eax
    jmp       L4376
L4381:
L4377:
    movzx     rax,	word [rdx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L4386
    movzx     rax,	word [rdx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	5
    jz        L4386
    movzx     rax,	word [r8+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L4386
    movzx     rax,	word [r8+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	5
    jnz       L4385
L4386:
    xor       eax,	eax
    jmp       L4376
L4385:
    mov       rax,	1
L4376:
;---------------
    ret       
;End 
;Proc mc_writenasm.getsizeprefix
mc_writenasm.getsizeprefix:
;?>>
   %define R.size rcx
   %define R.enable rdx
;?]]
;---------------
    test      rdx,	rdx
    jnz       L4389
    lea       rax,	[L12677]
    jmp       L4387
L4389:
    mov       rax,	rcx
    cmp       rax,	1
    jz        L4391
    cmp       rax,	2
    jz        L4392
    cmp       rax,	4
    jz        L4393
    cmp       rax,	8
    jz        L4394
    jmp       L4395
L4391:
    lea       rax,	[L12678]
    jmp       L4387
L4392:
    lea       rax,	[L12679]
    jmp       L4387
L4393:
    lea       rax,	[L12680]
    jmp       L4387
L4394:
    lea       rax,	[L12681]
    jmp       L4387
L4395:
L4390:
    lea       rax,	[L12682]
L4387:
;---------------
    ret       
;End 
;Proc mc_writenasm.checkregvar
mc_writenasm.checkregvar:
;?>>
    %define mc_writenasm.checkregvar.reg 16
    %define mc_writenasm.checkregvar.ispfloat 24
;?]]
;---------------
    xor       eax,	eax
L4396:
;---------------
    ret       
;End 
;Proc mc_writeexe.writeexe
mc_writeexe.writeexe:
;?>>
   %define R.outfile rdi
   %define R.dodll rbx
   %define R.entrypoint rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    mov       al,	[pc_decls.exedone]
    test      al,	al
    jnz       L4397
L4399:
    mov       rcx,	rsi
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_writeexe.genexe1
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_writeexe.genexe2
    mov       al,	1
    mov       [pc_decls.exedone],	al
L4397:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writeexe.genexe1
mc_writeexe.genexe1:
;?>>
   %define R.entrypoint r13
   %define R.outfile r14
    %define mc_writeexe.genexe1.dodll 80
   %define R.offset rdi
   %define R.codeaddr rbx
   %define R.offsetptr rsi
   %define R.pr r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       r13,	rcx
    mov       r14,	rdx
    mov       [rbp+80],	r8
;---------------
    call      mc_writeexe.initsectiontable
    mov       rcx,	r14
    call      mlib.extractfile
    mov       [mc_writeexe.dllfilename],	rax
    mov       rax,	[rbp + mc_writeexe.genexe1.dodll]
    mov       [mc_writeexe.isdll],	rax
    mov       rax,	[mc_writeexe.isdll]
    test      rax,	rax
    jz        L4402
    mov       rax,	268435456
    jmp       L4401
L4402:
    mov       rax,	4194304
L4401:
    mov       [mc_writeexe.imagebase],	rax
    mov       [mc_writeexe.userentrypoint],	r13
    call      mc_writeexe.loadlibs
    call      mc_writeexe.scanst
    call      mc_writeexe.getoffsets
    lea       rax,	[mc_writeexe.sectiontable]
    mov       rcx,	rax
    call      mc_writeexe.relocdata
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+72]
    mov       rcx,	rax
    call      mc_writeexe.relocdata
    lea       rax,	[mc_writeexe.sectiontable]
    mov       rax,	[rax]
    mov       rcx,	rax
    xor       edx,	edx
    call      mc_genss.bufferelemptr
    mov       rbx,	rax
    mov       al,	[pc_api.phighmem]
    test      al,	al
    jz        L4404
    mov       r12,	[mc_decls.riplist]
    jmp       L4408
L4405:
    mov       eax,	[r12+8]
    lea       r10,	[rbx + rax]
    mov       rsi,	r10
    movsxd    rax,	dword [r12+12]
    mov       r10d,	[rsi]
    sub       r10,	[mc_writeexe.imagebase]
    mov       r11d,	[r12+8]
    mov       rcx,	r11
    mov       rdx,	r10
    mov       r8,	rax
    call      mc_writeexe.getripoffset
    mov       rdi,	rax
    mov       [rsi],	edi
    mov       r12,	[r12]
L4408:
    test      r12,	r12
    jnz       L4405
L4404:
;---------------
    add       rsp,	32
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writeexe.genexe2
mc_writeexe.genexe2:
;?>>
   %define R.outfile rbx
   %define R.dodll rsi
   %define R.i rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    mov       rcx,	rbx
    call      mlib.extractfile
    mov       [mc_writeexe.dllfilename],	rax
    mov       [mc_writeexe.isdll],	rsi
    mov       rcx,	[mc_writeexe.filesize]
    call      mlib.pcm_allocz
    mov       [mc_writeexe.dataptr],	rax
    mov       [mc_writeexe.datastart],	rax
    call      mc_writeexe.writedosstub
    call      mc_writeexe.writepesig
    call      mc_writeexe.writefileheader
    call      mc_writeexe.writeoptheader
    mov       rdi,	1
    mov       rax,	[mc_writeexe.nsections]
    cmp       rax,	1
    jl        L4412
L4410:
    lea       rax,	[mc_writeexe.sectiontable]
    mov       r10,	rdi
    shl       r10,	3
    lea       r10,	[r10 + r10*8]
    lea       rax,	[rax + r10-72]
    mov       rcx,	rax
    call      mc_writeexe.writesectionheader
    inc       rdi
    cmp       rdi,	[mc_writeexe.nsections]
    jle       L4410
L4412:
    lea       rax,	[mc_writeexe.sectiontable]
    mov       rcx,	[rax+32]
    call      mc_writeexe.writepadding
    mov       rdi,	1
    mov       rax,	[mc_writeexe.nsections]
    cmp       rax,	1
    jl        L4415
L4413:
    lea       rax,	[mc_writeexe.sectiontable]
    mov       r10,	rdi
    shl       r10,	3
    lea       r10,	[r10 + r10*8]
    lea       rax,	[rax + r10-72]
    mov       rcx,	rax
    call      mc_writeexe.writesectiondata
    inc       rdi
    cmp       rdi,	[mc_writeexe.nsections]
    jle       L4413
L4415:
    movzx     rax,	byte [pc_decls.pverbose]
    cmp       rax,	2
    jnz       L4417
    call      msys.m$print_startcon
    lea       rcx,	[L12683]
    call      msys.m$print_str_nf
    mov       rax,	[mc_writeexe.dataptr]
    sub       rax,	[mc_writeexe.datastart]
    mov       rcx,	rax
    lea       rdx,	[L12684]
    call      msys.m$print_i64
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
L4417:
    mov       rax,	[mc_writeexe.dataptr]
    sub       rax,	[mc_writeexe.datastart]
    mov       rcx,	rbx
    mov       rdx,	[mc_writeexe.datastart]
    mov       r8,	rax
    call      mlib.writefile
    test      rax,	rax
    jnz       L4419
    call      msys.m$print_startcon
    lea       rcx,	[L12685]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	1
    call      exit
L4419:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writeexe.loadlibs
mc_writeexe.loadlibs:
;?>>
   %define R.i rdi
   %define R.hinst rbx
    %define mc_writeexe.loadlibs.filename -304
    push      rdi
    push      rbx
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	336
;---------------
    mov       rdi,	1
    mov       rax,	[pc_decls.nplibfiles]
    cmp       rax,	1
    jl        L4423
L4421:
    lea       rax,	[pc_decls.plibfiles]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    movzx     rax,	byte [rax]
    cmp       rax,	36
    jz        L4425
    lea       rax,	[pc_decls.plibfiles]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    lea       rcx,	[rbp + mc_writeexe.loadlibs.filename]
    mov       rdx,	rax
    call      strcpy
    lea       rcx,	[rbp + mc_writeexe.loadlibs.filename]
    call      mwindows.os_getdllinst
    mov       rbx,	rax
    test      rbx,	rbx
    jnz       L4427
    call      msys.m$print_startcon
    lea       rcx,	[L12686]
    call      msys.m$print_str_nf
    lea       rcx,	[rbp + mc_writeexe.loadlibs.filename]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L12687]
    call      mc_libmcl.axerror
L4427:
    mov       rax,	rbx
    lea       r10,	[mc_writeexe.libinsttable]
    mov       r11,	rdi
    mov       [r10 + r11*8-8],	rax
    lea       rcx,	[rbp + mc_writeexe.loadlibs.filename]
    call      mlib.pcm_copyheapstring
    lea       r10,	[mc_writeexe.libinstnames]
    mov       r11,	rdi
    mov       [r10 + r11*8-8],	rax
L4425:
    inc       rdi
    cmp       rdi,	[pc_decls.nplibfiles]
    jle       L4421
L4423:
;---------------
    add       rsp,	336
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writeexe.initsectiontable
mc_writeexe.initsectiontable:
;?>>
    %define mc_writeexe.initsectiontable.$T2 -8
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    lea       rax,	[mc_writeexe.sectiontable]
    lea       r10,	[L12688]
    mov       [rax+8],	r10
    lea       rax,	[mc_writeexe.sectiontable]
    mov       r10,	1
    mov       [rax+16],	r10
    lea       rax,	[mc_writeexe.sectiontable]
    mov       r10,	[mc_decls.ss_code]
    mov       [rax],	r10
    mov       rcx,	[mc_decls.ss_code]
    call      mc_genss.bufferlength
    lea       r10,	[mc_writeexe.sectiontable]
    mov       [r10+40],	rax
    mov       al,	[pc_decls.pverbose]
    test      al,	al
    jz        L4430
    call      msys.m$print_startcon
    lea       rcx,	[L12689]
    call      msys.m$print_str_nf
    mov       rcx,	[mc_decls.ss_code]
    call      mc_genss.bufferlength
    mov       rcx,	rax
    lea       rdx,	[L12690]
    call      msys.m$print_i64
    lea       rcx,	[L12691]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    movzx     rax,	byte [pc_decls.pverbose]
    cmp       rax,	2
    jnz       L4432
    call      msys.m$print_startcon
    lea       rcx,	[L12692]
    call      msys.m$print_str_nf
    mov       rcx,	[mc_decls.ss_idata]
    call      mc_genss.bufferlength
    mov       rcx,	rax
    lea       rdx,	[L12693]
    call      msys.m$print_i64
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       rcx,	[L12694]
    call      msys.m$print_str_nf
    mov       rcx,	[mc_decls.ss_code]
    call      mc_genss.bufferlength
    mov       [rbp + mc_writeexe.initsectiontable.$T2],	rax
    mov       rcx,	[mc_decls.ss_idata]
    call      mc_genss.bufferlength
    mov       r10,	[rbp + mc_writeexe.initsectiontable.$T2]
    add       r10,	rax
    mov       rcx,	r10
    lea       rdx,	[L12695]
    call      msys.m$print_i64
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       rcx,	[L12696]
    call      msys.m$print_str_nf
    mov       rcx,	[mc_decls.ss_zdatalen]
    lea       rdx,	[L12697]
    call      msys.m$print_i64
    call      msys.m$print_newline
    call      msys.m$print_end
L4432:
L4430:
    mov       rcx,	[mc_decls.ss_idata]
    call      mc_genss.bufferlength
    test      rax,	rax
    jnz       L4434
    mov       rcx,	[mc_decls.ss_idata]
    xor       edx,	edx
    call      mc_genss.addqword
L4434:
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+72]
    lea       r10,	[L12698]
    mov       [rax+8],	r10
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+72]
    mov       r10,	2
    mov       [rax+16],	r10
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+72]
    mov       r10,	[mc_decls.ss_idata]
    mov       [rax],	r10
    mov       rcx,	[mc_decls.ss_idata]
    call      mc_genss.bufferlength
    lea       r10,	[mc_writeexe.sectiontable]
    lea       r10,	[r10+72]
    mov       [r10+40],	rax
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+72]
    mov       rax,	[rax+40]
    mov       rcx,	rax
    mov       rdx,	512
    call      mlib.roundtoblock
    lea       r10,	[mc_writeexe.sectiontable]
    lea       r10,	[r10+72]
    mov       [r10+24],	rax
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+72]
    mov       r10,	[mc_decls.ss_nidatarelocs]
    mov       [rax+64],	r10
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+72]
    mov       r10,	[mc_decls.ss_idatarelocs]
    mov       [rax+56],	r10
    mov       rax,	[mc_decls.ss_zdatalen]
    test      rax,	rax
    jnz       L4436
    mov       rax,	16
    mov       [mc_decls.ss_zdatalen],	rax
L4436:
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+144]
    lea       r10,	[L12699]
    mov       [rax+8],	r10
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+144]
    mov       r10,	3
    mov       [rax+16],	r10
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+144]
    mov       r10,	[mc_decls.ss_zdatalen]
    mov       [rax+40],	r10
    lea       rax,	[mc_writeexe.sectiontable]
    mov       rax,	[rax+40]
    mov       rcx,	rax
    mov       rdx,	512
    call      mlib.roundtoblock
    lea       r10,	[mc_writeexe.sectiontable]
    mov       [r10+24],	rax
    lea       rax,	[mc_writeexe.sectiontable]
    mov       r10,	[mc_decls.ss_ncoderelocs]
    mov       [rax+64],	r10
    lea       rax,	[mc_writeexe.sectiontable]
    mov       r10,	[mc_decls.ss_coderelocs]
    mov       [rax+56],	r10
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+216]
    lea       r10,	[L12700]
    mov       [rax+8],	r10
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+216]
    mov       r10,	5
    mov       [rax+16],	r10
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+216]
    xor       r10d,	r10d
    mov       [rax+40],	r10
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+216]
    xor       r10d,	r10d
    mov       [rax+24],	r10
    mov       rax,	4
    mov       [mc_writeexe.nsections],	rax
;---------------
    add       rsp,	48
    pop       rbp
    ret       
;End 
;Proc mc_writeexe.extractlibname
mc_writeexe.extractlibname:
;?>>
   %define R.name r13
   %define R.libno r14
    %define mc_writeexe.extractlibname.moduleno 88
   %define R.s rdi
   %define R.name2 rbx
    %define mc_writeexe.extractlibname.str -256
   %define R.i rsi
   %define R.n r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	296
    mov       r13,	rcx
    mov       r14,	rdx
;---------------
    xor       rbx,	rbx
;mc_writeexe.extractlibname.reenter:
    mov       rdi,	r13
    xor       eax,	eax
    mov       [r14],	rax
    jmp       L4440
L4439:
    movzx     rax,	byte [rdi]
    cmp       rax,	46
    jnz       L4443
    mov       rax,	rdi
    sub       rax,	r13
    lea       rcx,	[rbp + mc_writeexe.extractlibname.str]
    mov       rdx,	r13
    mov       r8,	rax
    call      memcpy
    mov       rax,	rdi
    sub       rax,	r13
    xor       r10d,	r10d
    mov       [rbp + rax + mc_writeexe.extractlibname.str],	r10b
    lea       rcx,	[rbp + mc_writeexe.extractlibname.str]
    lea       rdx,	[L12701]
    call      strcat
    mov       rsi,	1
    mov       rax,	[mc_writeexe.ndlls]
    cmp       rax,	1
    jl        L4446
L4444:
    lea       rax,	[mc_writeexe.dlltable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       rax,	[rax]
    lea       rcx,	[rbp + mc_writeexe.extractlibname.str]
    mov       rdx,	rax
    call      mlib.eqstring
    test      rax,	rax
    jz        L4448
    mov       [r14],	rsi
    mov       rax,	[r14]
    lea       r10,	[mc_writeexe.dlltable]
    mov       r11,	rax
    shl       r11,	4
    lea       r11,	[r11 + r11*2]
    lea       r10,	[r10 + r11-40]
    inc       qword [r10]
    test      rbx,	rbx
    jz        L4450
    mov       rax,	rbx
    jmp       L4449
L4450:
    lea       rax,	[rdi+1]
L4449:
    jmp       L4437
L4448:
    inc       rsi
    cmp       rsi,	[mc_writeexe.ndlls]
    jle       L4444
L4446:
    mov       rax,	[mc_writeexe.ndlls]
    cmp       rax,	50
    jl        L4452
    lea       rcx,	[L12702]
    call      mc_libmcl.axerror
L4452:
    inc       qword [mc_writeexe.ndlls]
    mov       rax,	[mc_writeexe.ndlls]
    mov       [r14],	rax
    lea       rcx,	[rbp + mc_writeexe.extractlibname.str]
    call      mlib.pcm_copyheapstring
    mov       r10,	[r14]
    lea       r11,	[mc_writeexe.dlltable]
    mov       r15,	r10
    shl       r15,	4
    lea       r15,	[r15 + r15*2]
    lea       r11,	[r11 + r15-48]
    mov       [r11],	rax
    mov       rax,	[r14]
    lea       r10,	[mc_writeexe.dlltable]
    mov       r11,	rax
    shl       r11,	4
    lea       r11,	[r11 + r11*2]
    lea       r10,	[r10 + r11-48]
    mov       rax,	1
    mov       [r10+8],	rax
    test      rbx,	rbx
    jz        L4454
    mov       rax,	rbx
    jmp       L4453
L4454:
    lea       rax,	[rdi+1]
L4453:
    jmp       L4437
L4443:
    inc       rdi
L4440:
    mov       al,	[rdi]
    test      al,	al
    jnz       L4439
    mov       rsi,	1
    mov       rax,	[pc_decls.nplibfiles]
    cmp       rax,	1
    jl        L4458
L4455:
    lea       rax,	[mc_writeexe.libinsttable]
    mov       r10,	rsi
    mov       rax,	[rax + r10*8-8]
    test      rax,	rax
    jz        L4460
    lea       rax,	[mc_writeexe.libinsttable]
    mov       r10,	rsi
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rax
    mov       rdx,	r13
    call      mwindows.os_getdllprocaddr
    test      rax,	rax
    jz        L4462
    mov       r12,	rsi
    jmp       L4457
L4462:
L4460:
    inc       rsi
    cmp       rsi,	[pc_decls.nplibfiles]
    jle       L4455
L4458:
    call      msys.m$print_startcon
    mov       rcx,	r13
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L12703]
    call      mc_libmcl.axerror
L4457:
    lea       rax,	[mc_writeexe.libnotable]
    mov       r10,	r12
    mov       rax,	[rax + r10*8-8]
    mov       [r14],	rax
    test      rax,	rax
    jz        L4464
    mov       rax,	[r14]
    lea       r10,	[mc_writeexe.dlltable]
    mov       r11,	rax
    shl       r11,	4
    lea       r11,	[r11 + r11*2]
    lea       r10,	[r10 + r11-40]
    inc       qword [r10]
    mov       rax,	r13
    jmp       L4437
L4464:
    lea       rax,	[pc_decls.plibfiles]
    mov       r10,	r12
    mov       rax,	[rax + r10*8-8]
    lea       rcx,	[rbp + mc_writeexe.extractlibname.str]
    mov       rdx,	rax
    call      strcpy
    lea       rcx,	[rbp + mc_writeexe.extractlibname.str]
    lea       rdx,	[L12704]
    call      strcat
    mov       rax,	[mc_writeexe.ndlls]
    cmp       rax,	50
    jl        L4466
    lea       rcx,	[L12705]
    call      mc_libmcl.axerror
L4466:
    inc       qword [mc_writeexe.ndlls]
    mov       rax,	[mc_writeexe.ndlls]
    mov       [r14],	rax
    lea       rcx,	[rbp + mc_writeexe.extractlibname.str]
    call      mlib.pcm_copyheapstring
    mov       r10,	[r14]
    lea       r11,	[mc_writeexe.dlltable]
    mov       r15,	r10
    shl       r15,	4
    lea       r15,	[r15 + r15*2]
    lea       r11,	[r11 + r15-48]
    mov       [r11],	rax
    mov       rax,	[r14]
    lea       r10,	[mc_writeexe.dlltable]
    mov       r11,	rax
    shl       r11,	4
    lea       r11,	[r11 + r11*2]
    lea       r10,	[r10 + r11-48]
    mov       rax,	1
    mov       [r10+8],	rax
    mov       rax,	[r14]
    lea       r10,	[mc_writeexe.libnotable]
    mov       r11,	r12
    mov       [r10 + r11*8-8],	rax
    mov       rax,	r13
L4437:
;---------------
    add       rsp,	296
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writeexe.scanst
mc_writeexe.scanst:
;?>>
   %define R.i rdi
    %define mc_writeexe.scanst.libno -8
   %define R.d rbx
   %define R.name rsi
   %define R.basename r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    mov       rdi,	1
    mov       rax,	[mc_decls.ss_nsymbols]
    cmp       rax,	1
    jl        L4470
L4468:
    mov       rax,	[mc_decls.ss_symboltable]
    mov       r10,	rdi
    mov       rbx,	[rax + r10*8-8]
    mov       al,	[rbx+80]
    test      al,	al
    jz        L4472
    mov       rax,	[mc_writeexe.nimports]
    cmp       rax,	3000
    jl        L4474
    lea       rcx,	[L12706]
    call      mc_libmcl.axerror
L4474:
    inc       qword [mc_writeexe.nimports]
    mov       rax,	[rbx]
    mov       rcx,	rax
    lea       rdx,	[rbp + mc_writeexe.scanst.libno]
    mov       r8,	1
    call      mc_writeexe.extractlibname
    mov       rsi,	rax
    lea       rax,	[mc_writeexe.importtable]
    mov       r10,	[mc_writeexe.nimports]
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10]
    mov       r10,	[rbp + mc_writeexe.scanst.libno]
    mov       [rax+8],	r10
    lea       rax,	[mc_writeexe.importtable]
    mov       r10,	[mc_writeexe.nimports]
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10]
    mov       r10,	rsi
    mov       [rax+16],	r10
    lea       rax,	[mc_writeexe.importtable]
    mov       r10,	[mc_writeexe.nimports]
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10]
    mov       r10,	rbx
    mov       [rax],	r10
    mov       ax,	[mc_writeexe.nimports]
    mov       [rbx+98],	ax
    jmp       L4471
L4472:
    mov       al,	[rbx+81]
    test      al,	al
    jz        L4475
    mov       rax,	[rbx]
    mov       rcx,	rax
    call      pc_api.getbasename
    mov       r12,	rax
    mov       rax,	[mc_writeexe.userentrypoint]
    test      rax,	rax
    jz        L4477
    mov       rcx,	r12
    mov       rdx,	[mc_writeexe.userentrypoint]
    call      mlib.eqstring
    test      rax,	rax
    jz        L4479
    mov       [mc_writeexe.stentrypoint],	rbx
L4479:
    jmp       L4476
L4477:
    mov       al,	[rbx+83]
    test      al,	al
    jz        L4481
    mov       rax,	[mc_writeexe.isdll]
    test      rax,	rax
    jnz       L4481
    mov       [mc_writeexe.stentrypoint],	rbx
L4481:
L4476:
    mov       rax,	[mc_writeexe.nexports]
    cmp       rax,	1000
    jl        L4483
    lea       rcx,	[L12707]
    call      mc_libmcl.axerror
L4483:
    inc       qword [mc_writeexe.nexports]
    lea       rax,	[mc_writeexe.exporttable]
    mov       r10,	[mc_writeexe.nexports]
    shl       r10,	4
    lea       rax,	[rax + r10-16]
    mov       r10,	rbx
    mov       [rax],	r10
    mov       rax,	[rbx]
    mov       rcx,	rax
    call      pc_api.getbasename
    lea       r10,	[mc_writeexe.exporttable]
    mov       r11,	[mc_writeexe.nexports]
    shl       r11,	4
    lea       r10,	[r10 + r11-16]
    mov       [r10+8],	rax
L4475:
L4471:
    inc       rdi
    cmp       rdi,	[mc_decls.ss_nsymbols]
    jle       L4468
L4470:
;---------------
    add       rsp,	48
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writeexe.relocdata
mc_writeexe.relocdata:
;?>>
    %define mc_writeexe.relocdata.s 72
   %define R.u rdi
   %define R.r rbx
   %define R.p rsi
   %define R.p32 r12
   %define R.p64 r13
   %define R.d r14
   %define R.index r15
    %define mc_writeexe.relocdata.thunkoffset -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       [rbp+72],	rcx
;---------------
    mov       rax,	[rbp + mc_writeexe.relocdata.s]
    mov       rax,	[rax]
    mov       rcx,	rax
    xor       edx,	edx
    call      mc_genss.bufferelemptr
    mov       rsi,	rax
    mov       rax,	[rbp + mc_writeexe.relocdata.s]
    mov       rbx,	[rax+56]
    jmp       L4486
L4485:
    mov       rax,	[rbx+24]
    mov       r10,	[mc_decls.ss_symboltable]
    mov       r10,	[r10 + rax*8-8]
    mov       r14,	r10
    movsx     rax,	word [r14+98]
    mov       r15,	rax
    lea       rax,	[mc_writeexe.importtable]
    mov       r10,	r15
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10]
    mov       rax,	[rax+40]
    mov       [rbp + mc_writeexe.relocdata.thunkoffset],	rax
    mov       rax,	[rbx+8]
    cmp       rax,	4
    jz        L4489
    cmp       rax,	2
    jz        L4490
    cmp       rax,	1
    jz        L4490
    jmp       L4491
L4489:
    mov       al,	[r14+80]
    test      al,	al
    jnz       L4493
    lea       rcx,	[L12708]
    call      mc_libmcl.axerror
L4493:
    mov       rax,	[rbx+16]
    mov       r10,	[rbp + mc_writeexe.relocdata.thunkoffset]
    sub       r10,	rax
    sub       r10,	4
    mov       rax,	[rbx+16]
    mov       [rsi + rax],	r10d
    jmp       L4488
L4490:
    mov       al,	[r14+80]
    test      al,	al
    jz        L4495
    mov       rax,	[mc_writeexe.imagebase]
    add       rax,	[rbp + mc_writeexe.relocdata.thunkoffset]
    lea       r10,	[mc_writeexe.sectiontable]
    mov       r10,	[r10+48]
    add       rax,	r10
    mov       r10,	[rbx+16]
    mov       [rsi + r10],	eax
    jmp       L4494
L4495:
    xor       rdi,	rdi
    movzx     rax,	byte [r14+94]
    cmp       rax,	3
    jz        L4497
    cmp       rax,	2
    jz        L4498
    cmp       rax,	1
    jz        L4499
    jmp       L4500
L4497:
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+144]
    mov       rdi,	rax
    jmp       L4496
L4498:
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+72]
    mov       rdi,	rax
    jmp       L4496
L4499:
    lea       rax,	[mc_writeexe.sectiontable]
    mov       rdi,	rax
    jmp       L4496
L4500:
    call      msys.m$print_startcon
    mov       rcx,	[r14]
    call      msys.m$print_str_nf
    movzx     rax,	byte [r14+94]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L12709]
    call      mc_libmcl.axerror
L4496:
    mov       rax,	[rbx+16]
    lea       r10,	[rsi + rax]
    mov       r12,	r10
    mov       rax,	[rbx+8]
    cmp       rax,	2
    jnz       L4502
    mov       eax,	[r12]
    mov       r10,	[rdi+48]
    add       rax,	r10
    add       rax,	[mc_writeexe.imagebase]
    mov       [r12],	eax
    jmp       L4501
L4502:
    mov       r13,	r12
    mov       rax,	[r13]
    mov       r10,	[rdi+48]
    add       rax,	r10
    add       rax,	[mc_writeexe.imagebase]
    mov       [r13],	rax
L4501:
L4494:
    jmp       L4488
L4491:
    call      msys.m$print_startcon
    mov       rax,	[rbx+8]
    lea       r10,	[mc_objdecls.relocnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L12710]
    call      mc_libmcl.axerror
L4488:
    mov       rbx,	[rbx]
L4486:
    test      rbx,	rbx
    jnz       L4485
;---------------
    add       rsp,	40
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writeexe.getbaserelocs
mc_writeexe.getbaserelocs:
;?>>
   %define R.s r12
   %define R.r rdi
   %define R.p rbx
   %define R.d rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       r12,	rcx
;---------------
    mov       rax,	[r12]
    mov       rcx,	rax
    xor       edx,	edx
    call      mc_genss.bufferelemptr
    mov       rbx,	rax
    mov       rdi,	[r12+56]
    jmp       L4505
L4504:
    mov       rax,	[rdi+24]
    mov       r10,	[mc_decls.ss_symboltable]
    mov       r10,	[r10 + rax*8-8]
    mov       rsi,	r10
    mov       rax,	[rdi+8]
    cmp       rax,	2
    jz        L4508
    cmp       rax,	1
    jnz       L4509
L4508:
    mov       al,	[rsi+80]
    test      al,	al
    jnz       L4510
L4511:
    mov       rax,	[rdi+8]
    cmp       rax,	2
    jz        L4512
L4513:
    mov       rax,	[rdi+8]
    mov       r10,	[r12+48]
    mov       r11,	[rdi+16]
    add       r10,	r11
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_writeexe.newbasereloc
L4512:
L4510:
L4509:
L4507:
    mov       rdi,	[rdi]
L4505:
    test      rdi,	rdi
    jnz       L4504
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writeexe.writerecordx
mc_writeexe.writerecordx:
;?>>
   %define R.r rdi
   %define R.length rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	[mc_writeexe.dataptr]
    mov       rdx,	rdi
    mov       r8,	rbx
    call      memcpy
    mov       rax,	rbx
    add       [mc_writeexe.dataptr],	rax
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writeexe.writedosstub
mc_writeexe.writedosstub:
;?>>
;?]]
    sub       rsp,	40
;---------------
    lea       rcx,	[mc_writeexe.writedosstub.stubdata]
    mov       rdx,	128
    call      mc_writeexe.writerecordx
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mc_writeexe.writepesig
mc_writeexe.writepesig:
;?>>
;?]]
;---------------
    mov       rax,	[mc_writeexe.dataptr]
    inc       qword [mc_writeexe.dataptr]
    mov       r10b,	80
    mov       [rax],	r10b
    mov       rax,	[mc_writeexe.dataptr]
    inc       qword [mc_writeexe.dataptr]
    mov       r10b,	69
    mov       [rax],	r10b
    mov       rax,	[mc_writeexe.dataptr]
    inc       qword [mc_writeexe.dataptr]
    xor       r10d,	r10d
    mov       [rax],	r10b
    mov       rax,	[mc_writeexe.dataptr]
    inc       qword [mc_writeexe.dataptr]
    xor       r10d,	r10d
    mov       [rax],	r10b
;---------------
    ret       
;End 
;Proc mc_writeexe.writepadding
mc_writeexe.writepadding:
;?>>
   %define R.offset rcx
;?]]
;---------------
    mov       rax,	[mc_writeexe.datastart]
    mov       r10,	rcx
    lea       rax,	[rax + r10]
    mov       [mc_writeexe.dataptr],	rax
;---------------
    ret       
;End 
;Proc mc_writeexe.writefileheader
mc_writeexe.writefileheader:
;?>>
    %define mc_writeexe.writefileheader.header -24
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
;---------------
    lea       rax,	[rbp + mc_writeexe.writefileheader.header]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    mov       [rax+16],	r10d
    mov       ax,	34404
    mov       [rbp + mc_writeexe.writefileheader.header],	ax
    mov       ax,	[mc_writeexe.nsections]
    mov       [rbp + mc_writeexe.writefileheader.header+2],	ax
    mov       ax,	240
    mov       [rbp + mc_writeexe.writefileheader.header+16],	ax
    mov       ax,	559
    mov       [rbp + mc_writeexe.writefileheader.header+18],	ax
    mov       rax,	[mc_writeexe.isdll]
    test      rax,	rax
    jz        L4520
    mov       ax,	8750
    mov       [rbp + mc_writeexe.writefileheader.header+18],	ax
L4520:
    lea       rcx,	[rbp + mc_writeexe.writefileheader.header]
    mov       rdx,	20
    call      mc_writeexe.writerecordx
;---------------
    add       rsp,	64
    pop       rbp
    ret       
;End 
;Proc mc_writeexe.writeoptheader
mc_writeexe.writeoptheader:
;?>>
    %define mc_writeexe.writeoptheader.header -240
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	272
;---------------
    lea       rax,	[rbp + mc_writeexe.writeoptheader.header]
    xor       r10d,	r10d
    mov       r11,	30
L12711:
    mov       [rax],	r10
    add       rax,	8
    dec       r11
    jnz       L12711
    mov       ax,	523
    mov       [rbp + mc_writeexe.writeoptheader.header],	ax
    mov       al,	1
    mov       [rbp + mc_writeexe.writeoptheader.header+2],	al
    xor       eax,	eax
    mov       [rbp + mc_writeexe.writeoptheader.header+3],	al
    lea       rax,	[mc_writeexe.sectiontable]
    mov       rax,	[rax+24]
    mov       [rbp + mc_writeexe.writeoptheader.header+4],	eax
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+72]
    mov       rax,	[rax+24]
    lea       r10,	[mc_writeexe.sectiontable]
    lea       r10,	[r10+216]
    mov       r10,	[r10+24]
    add       rax,	r10
    mov       [rbp + mc_writeexe.writeoptheader.header+8],	eax
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+144]
    mov       rax,	[rax+40]
    mov       rcx,	rax
    mov       rdx,	512
    call      mlib.roundtoblock
    mov       [rbp + mc_writeexe.writeoptheader.header+12],	eax
    mov       rax,	[mc_writeexe.stentrypoint]
    test      rax,	rax
    jnz       L4523
    mov       rax,	[mc_writeexe.stentrypoint2]
    mov       [mc_writeexe.stentrypoint],	rax
L4523:
    mov       rax,	[mc_writeexe.stentrypoint]
    test      rax,	rax
    jnz       L4525
    mov       rax,	[mc_writeexe.userentrypoint]
    test      rax,	rax
    jz        L4527
    call      msys.m$print_startcon
    mov       rcx,	[mc_writeexe.userentrypoint]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L12712]
    call      mc_libmcl.axerror
    jmp       L4526
L4527:
    mov       rax,	[mc_writeexe.isdll]
    test      rax,	rax
    jnz       L4529
    lea       rcx,	[L12713]
    call      mc_libmcl.axerror
L4529:
L4526:
    jmp       L4524
L4525:
    lea       rax,	[mc_writeexe.sectiontable]
    mov       rax,	[rax+48]
    mov       r10,	[mc_writeexe.stentrypoint]
    movsxd    r10,	dword [r10+76]
    add       rax,	r10
    mov       [rbp + mc_writeexe.writeoptheader.header+16],	eax
L4524:
    mov       eax,	4096
    mov       [rbp + mc_writeexe.writeoptheader.header+20],	eax
    mov       rax,	[mc_writeexe.imagebase]
    mov       [rbp + mc_writeexe.writeoptheader.header+24],	rax
    mov       eax,	4096
    mov       [rbp + mc_writeexe.writeoptheader.header+32],	eax
    mov       eax,	512
    mov       [rbp + mc_writeexe.writeoptheader.header+36],	eax
    mov       ax,	4
    mov       [rbp + mc_writeexe.writeoptheader.header+40],	ax
    xor       eax,	eax
    mov       [rbp + mc_writeexe.writeoptheader.header+42],	ax
    mov       ax,	5
    mov       [rbp + mc_writeexe.writeoptheader.header+48],	ax
    mov       ax,	2
    mov       [rbp + mc_writeexe.writeoptheader.header+50],	ax
    mov       eax,	[mc_writeexe.imagesize]
    mov       [rbp + mc_writeexe.writeoptheader.header+56],	eax
    lea       rax,	[mc_writeexe.sectiontable]
    mov       rax,	[rax+32]
    mov       [rbp + mc_writeexe.writeoptheader.header+60],	eax
    mov       ax,	3
    mov       [rbp + mc_writeexe.writeoptheader.header+68],	ax
    mov       rax,	4194304
    mov       [rbp + mc_writeexe.writeoptheader.header+72],	rax
    mov       rax,	2097152
    mov       [rbp + mc_writeexe.writeoptheader.header+80],	rax
    mov       rax,	1048576
    mov       [rbp + mc_writeexe.writeoptheader.header+88],	rax
    mov       rax,	4096
    mov       [rbp + mc_writeexe.writeoptheader.header+96],	rax
    mov       eax,	16
    mov       [rbp + mc_writeexe.writeoptheader.header+108],	eax
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+216]
    mov       rax,	[rax+48]
    mov       [rbp + mc_writeexe.writeoptheader.header+120],	eax
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+216]
    mov       rax,	[rax+40]
    sub       rax,	[mc_writeexe.exportdirvirtsize]
    sub       rax,	[mc_writeexe.blockdirvirtsize]
    mov       [rbp + mc_writeexe.writeoptheader.header+124],	eax
    mov       rax,	[mc_writeexe.isdll]
    test      rax,	rax
    jz        L4531
    mov       ax,	64
    mov       [rbp + mc_writeexe.writeoptheader.header+70],	ax
    mov       eax,	[mc_writeexe.exportdirvirtaddr]
    mov       [rbp + mc_writeexe.writeoptheader.header+112],	eax
    mov       eax,	[mc_writeexe.exportdirvirtsize]
    mov       [rbp + mc_writeexe.writeoptheader.header+116],	eax
    mov       eax,	[mc_writeexe.blockdirvirtaddr]
    mov       [rbp + mc_writeexe.writeoptheader.header+152],	eax
    mov       eax,	[mc_writeexe.blockdirvirtsize]
    mov       [rbp + mc_writeexe.writeoptheader.header+156],	eax
L4531:
    mov       eax,	[mc_writeexe.fileiatoffset]
    mov       [rbp + mc_writeexe.writeoptheader.header+208],	eax
    mov       eax,	[mc_writeexe.fileiatsize]
    mov       [rbp + mc_writeexe.writeoptheader.header+212],	eax
    lea       rcx,	[rbp + mc_writeexe.writeoptheader.header]
    mov       rdx,	240
    call      mc_writeexe.writerecordx
;---------------
    add       rsp,	272
    pop       rbp
    ret       
;End 
;Proc mc_writeexe.writesectionheader
mc_writeexe.writesectionheader:
;?>>
   %define R.s rbx
    %define mc_writeexe.writesectionheader.sheader -40
   %define R.aa rdi
    push      rdi
    push      rbx
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	80
    mov       rbx,	rcx
;---------------
    lea       rax,	[rbp + mc_writeexe.writesectionheader.sheader]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    mov       [rax+16],	r10
    mov       [rax+24],	r10
    mov       [rax+32],	r10
    mov       rax,	[rbx+8]
    lea       r10,	[rbp + mc_writeexe.writesectionheader.sheader]
    mov       rcx,	r10
    mov       rdx,	rax
    call      strcpy
    mov       rax,	[rbx+40]
    mov       [rbp + mc_writeexe.writesectionheader.sheader+8],	eax
    mov       rax,	[rbx+48]
    mov       [rbp + mc_writeexe.writesectionheader.sheader+12],	eax
    mov       rax,	[rbx+32]
    mov       [rbp + mc_writeexe.writesectionheader.sheader+20],	eax
    mov       rax,	[rbx+24]
    mov       [rbp + mc_writeexe.writesectionheader.sheader+16],	eax
    mov       rax,	[rbx+16]
    cmp       rax,	3
    jz        L4534
    cmp       rax,	2
    jz        L4535
    cmp       rax,	1
    jz        L4536
    cmp       rax,	5
    jz        L4537
    jmp       L4538
L4534:
    mov       rdi,	3226468480
    mov       [rbp + mc_writeexe.writesectionheader.sheader+36],	edi
    jmp       L4533
L4535:
    mov       rdi,	3226468416
    mov       [rbp + mc_writeexe.writesectionheader.sheader+36],	edi
    jmp       L4533
L4536:
    mov       rdi,	1615855648
    mov       [rbp + mc_writeexe.writesectionheader.sheader+36],	edi
    jmp       L4533
L4537:
    mov       rdi,	3224371264
    mov       [rbp + mc_writeexe.writesectionheader.sheader+36],	edi
L4538:
L4533:
    lea       rcx,	[rbp + mc_writeexe.writesectionheader.sheader]
    mov       rdx,	40
    call      mc_writeexe.writerecordx
;---------------
    add       rsp,	80
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writeexe.writesectiondata
mc_writeexe.writesectiondata:
;?>>
   %define R.s rdi
    %define mc_writeexe.writesectiondata.$T1 -8
    push      rdi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       rdi,	rcx
;---------------
    mov       rax,	[rdi+16]
    cmp       rax,	5
    jz        L4541
    cmp       rax,	3
    jz        L4542
    jmp       L4543
L4541:
    mov       rax,	[rdi+40]
    mov       r10,	[rdi]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_writeexe.writerecordx
    mov       rax,	[rdi+24]
    mov       r10,	[rdi+40]
    cmp       rax,	r10
    jle       L4545
    mov       rax,	[rdi+24]
    mov       r10,	[rdi+40]
    sub       rax,	r10
    add       [mc_writeexe.dataptr],	rax
L4545:
    jmp       L4540
L4542:
    jmp       L4540
L4543:
    mov       rax,	[rdi+24]
    mov       [rbp + mc_writeexe.writesectiondata.$T1],	rax
    mov       rax,	[rdi]
    mov       rcx,	rax
    xor       edx,	edx
    call      mc_genss.bufferelemptr
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_writeexe.writesectiondata.$T1]
    call      mc_writeexe.writerecordx
L4540:
;---------------
    add       rsp,	40
    pop       rbp
    pop       rdi
    ret       
;End 
;Proc mc_writeexe.writeexporttable
mc_writeexe.writeexporttable:
;?>>
    %define mc_writeexe.writeexporttable.pstart 72
    %define mc_writeexe.writeexporttable.sortindex -16000
   %define R.phdr rdi
   %define R.paddrtable rbx
   %define R.pnametable rsi
   %define R.pordtable r12
   %define R.pdllname r13
   %define R.pnames r14
   %define R.addrtableoffset r15
    %define mc_writeexe.writeexporttable.nametableoffset -16008
    %define mc_writeexe.writeexporttable.ordtableoffset -16016
    %define mc_writeexe.writeexporttable.dllnameoffset -16024
    %define mc_writeexe.writeexporttable.namesoffset -16032
    %define mc_writeexe.writeexporttable.virtoffset -16040
    %define mc_writeexe.writeexporttable.sectionno -16048
    %define mc_writeexe.writeexporttable.d -16056
    %define mc_writeexe.writeexporttable.basename -16064
    %define mc_writeexe.writeexporttable.i -16072
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	16104
    mov       [rbp+72],	rcx
;---------------
    mov       rdi,	[rbp + mc_writeexe.writeexporttable.pstart]
    mov       eax,	1602876664
    mov       [rdi+4],	eax
    mov       eax,	1
    mov       [rdi+16],	eax
    mov       eax,	[mc_writeexe.nexports]
    mov       [rdi+20],	eax
    mov       eax,	[mc_writeexe.nexports]
    mov       [rdi+24],	eax
    mov       r15,	40
    mov       rax,	[mc_writeexe.nexports]
    shl       rax,	2
    mov       r10,	r15
    add       r10,	rax
    mov       [rbp + mc_writeexe.writeexporttable.nametableoffset],	r10
    mov       rax,	[mc_writeexe.nexports]
    shl       rax,	2
    mov       r10,	[rbp + mc_writeexe.writeexporttable.nametableoffset]
    add       r10,	rax
    mov       [rbp + mc_writeexe.writeexporttable.ordtableoffset],	r10
    mov       rax,	[mc_writeexe.nexports]
    shl       rax,	1
    mov       r10,	[rbp + mc_writeexe.writeexporttable.ordtableoffset]
    add       r10,	rax
    mov       [rbp + mc_writeexe.writeexporttable.dllnameoffset],	r10
    mov       rcx,	[mc_writeexe.dllfilename]
    call      strlen
    mov       r10,	[rbp + mc_writeexe.writeexporttable.dllnameoffset]
    add       r10,	rax
    inc       r10
    mov       [rbp + mc_writeexe.writeexporttable.namesoffset],	r10
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+216]
    mov       rax,	[rax+48]
    add       rax,	[mc_writeexe.exportdiroffset]
    mov       [rbp + mc_writeexe.writeexporttable.virtoffset],	rax
    mov       rax,	[rbp + mc_writeexe.writeexporttable.pstart]
    mov       r10,	r15
    lea       rax,	[rax + r10]
    mov       rbx,	rax
    mov       rax,	[rbp + mc_writeexe.writeexporttable.pstart]
    mov       r10,	[rbp + mc_writeexe.writeexporttable.nametableoffset]
    lea       rax,	[rax + r10]
    mov       rsi,	rax
    mov       rax,	[rbp + mc_writeexe.writeexporttable.pstart]
    mov       r10,	[rbp + mc_writeexe.writeexporttable.ordtableoffset]
    lea       rax,	[rax + r10]
    mov       r12,	rax
    mov       rax,	[rbp + mc_writeexe.writeexporttable.pstart]
    mov       r10,	[rbp + mc_writeexe.writeexporttable.dllnameoffset]
    lea       rax,	[rax + r10]
    mov       r13,	rax
    mov       rax,	[rbp + mc_writeexe.writeexporttable.pstart]
    mov       r10,	[rbp + mc_writeexe.writeexporttable.namesoffset]
    lea       rax,	[rax + r10]
    mov       r14,	rax
    mov       rax,	[rbp + mc_writeexe.writeexporttable.dllnameoffset]
    add       rax,	[rbp + mc_writeexe.writeexporttable.virtoffset]
    mov       [rdi+12],	eax
    mov       rax,	r15
    add       rax,	[rbp + mc_writeexe.writeexporttable.virtoffset]
    mov       [rdi+28],	eax
    mov       rax,	[rbp + mc_writeexe.writeexporttable.nametableoffset]
    add       rax,	[rbp + mc_writeexe.writeexporttable.virtoffset]
    mov       [rdi+32],	eax
    mov       rax,	[rbp + mc_writeexe.writeexporttable.ordtableoffset]
    add       rax,	[rbp + mc_writeexe.writeexporttable.virtoffset]
    mov       [rdi+36],	eax
    mov       rcx,	r13
    mov       rdx,	[mc_writeexe.dllfilename]
    call      strcpy
    mov       rax,	[mc_writeexe.nexports]
    cmp       rax,	2000
    jle       L4548
    lea       rcx,	[L12714]
    call      mc_libmcl.axerror
L4548:
    lea       rcx,	[rbp + mc_writeexe.writeexporttable.sortindex]
    call      mc_writeexe.sortexports
    mov       rax,	1
    mov       [rbp + mc_writeexe.writeexporttable.i],	rax
    mov       rax,	[mc_writeexe.nexports]
    cmp       rax,	1
    jl        L4551
L4549:
    mov       rax,	[rbp + mc_writeexe.writeexporttable.i]
    mov       rax,	[rbp + rax*8 + mc_writeexe.writeexporttable.sortindex-8]
    lea       r10,	[mc_writeexe.exporttable]
    lea       r11,	[rax + rax]
    lea       r10,	[r10 + r11*8-16]
    mov       r10,	[r10]
    mov       [rbp + mc_writeexe.writeexporttable.d],	r10
    mov       rax,	[rbp + mc_writeexe.writeexporttable.i]
    mov       rax,	[rbp + rax*8 + mc_writeexe.writeexporttable.sortindex-8]
    lea       r10,	[mc_writeexe.exporttable]
    lea       r11,	[rax + rax]
    lea       r10,	[r10 + r11*8-16]
    mov       r10,	[r10+8]
    mov       [rbp + mc_writeexe.writeexporttable.basename],	r10
    mov       rax,	[rbp + mc_writeexe.writeexporttable.d]
    movzx     rax,	byte [rax+94]
    mov       rcx,	rax
    call      mc_writeexe.getsectionno
    mov       [rbp + mc_writeexe.writeexporttable.sectionno],	rax
    mov       rcx,	r14
    mov       rdx,	[rbp + mc_writeexe.writeexporttable.basename]
    call      strcpy
    mov       rax,	[rbp + mc_writeexe.writeexporttable.namesoffset]
    add       rax,	[rbp + mc_writeexe.writeexporttable.virtoffset]
    mov       [rsi],	eax
    add       rsi,	4
    mov       rcx,	[rbp + mc_writeexe.writeexporttable.basename]
    call      strlen
    inc       rax
    add       [rbp + mc_writeexe.writeexporttable.namesoffset],	rax
    mov       rcx,	[rbp + mc_writeexe.writeexporttable.basename]
    call      strlen
    inc       rax
    add       r14,	rax
    mov       rax,	[rbp + mc_writeexe.writeexporttable.d]
    movsxd    rax,	dword [rax+76]
    lea       r10,	[mc_writeexe.sectiontable]
    mov       r11,	[rbp + mc_writeexe.writeexporttable.sectionno]
    shl       r11,	3
    lea       r11,	[r11 + r11*8]
    lea       r10,	[r10 + r11-72]
    mov       r10,	[r10+48]
    add       rax,	r10
    mov       [rbx],	eax
    add       rbx,	4
    mov       rax,	[rbp + mc_writeexe.writeexporttable.i]
    dec       rax
    mov       [r12],	ax
    add       r12,	2
    mov       rax,	[rbp + mc_writeexe.writeexporttable.i]
    inc       rax
    mov       [rbp + mc_writeexe.writeexporttable.i],	rax
    cmp       rax,	[mc_writeexe.nexports]
    jle       L4549
L4551:
;---------------
    add       rsp,	16104
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writeexe.getexporttablesize
mc_writeexe.getexporttablesize:
;?>>
   %define R.size rdi
   %define R.i rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
;---------------
    mov       rdi,	40
    mov       rax,	[mc_writeexe.nexports]
    shl       rax,	2
    add       rdi,	rax
    mov       rax,	[mc_writeexe.nexports]
    shl       rax,	2
    add       rdi,	rax
    mov       rax,	[mc_writeexe.nexports]
    shl       rax,	1
    add       rdi,	rax
    mov       rcx,	[mc_writeexe.dllfilename]
    call      strlen
    inc       rax
    add       rdi,	rax
    mov       rbx,	1
    mov       rax,	[mc_writeexe.nexports]
    cmp       rax,	1
    jl        L4555
L4553:
    lea       rax,	[mc_writeexe.exporttable]
    mov       r10,	rbx
    shl       r10,	4
    lea       rax,	[rax + r10-16]
    mov       rax,	[rax]
    mov       rax,	[rax]
    mov       rcx,	rax
    call      strlen
    inc       rax
    add       rdi,	rax
    inc       rbx
    cmp       rbx,	[mc_writeexe.nexports]
    jle       L4553
L4555:
    mov       rax,	rdi
L4552:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writeexe.newbasereloc
mc_writeexe.newbasereloc:
;?>>
   %define R.addr rbx
   %define R.reltype rsi
   %define R.p rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    mov       rcx,	16
    call      mlib.pcm_allocnfz
    mov       rdi,	rax
    mov       [rdi+8],	ebx
    mov       [rdi+12],	esi
    mov       rax,	[mc_writeexe.basereloclist]
    mov       [rdi],	rax
    mov       [mc_writeexe.basereloclist],	rdi
    inc       qword [mc_writeexe.nbaserelocs]
    mov       rax,	rbx
    cmp       [mc_writeexe.maxrelocaddr],	rax
    jge       L12715
    mov       [mc_writeexe.maxrelocaddr],	rax
L12715:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writeexe.scanbaserelocs
mc_writeexe.scanbaserelocs:
;?>>
   %define R.baseaddr rdi
   %define R.addr rbx
   %define R.nextblock rsi
   %define R.p r12
   %define R.i r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
;---------------
    mov       rdi,	4096
    xor       eax,	eax
    mov       [mc_writeexe.nbaseblocks],	rax
L4558:
    lea       rax,	[rdi+4096]
    mov       rsi,	rax
    mov       rax,	[mc_writeexe.nbaseblocks]
    cmp       rax,	500
    jl        L4562
    lea       rcx,	[L12716]
    call      mc_libmcl.axerror
L4562:
    inc       qword [mc_writeexe.nbaseblocks]
    mov       rax,	rdi
    lea       r10,	[mc_writeexe.blockbases]
    mov       r11,	[mc_writeexe.nbaseblocks]
    mov       [r10 + r11*8-8],	rax
    xor       eax,	eax
    lea       r10,	[mc_writeexe.blockcounts]
    mov       r11,	[mc_writeexe.nbaseblocks]
    mov       [r10 + r11*4-4],	eax
    mov       r12,	[mc_writeexe.basereloclist]
    jmp       L4564
L4563:
    mov       eax,	[r12+8]
    mov       rbx,	rax
    cmp       rbx,	rdi
    jl        L4567
    cmp       rbx,	rsi
    jge       L4567
    lea       rax,	[mc_writeexe.blockcounts]
    mov       r10,	[mc_writeexe.nbaseblocks]
    lea       rax,	[rax + r10*4-4]
    inc       dword [rax]
L4567:
    mov       r12,	[r12]
L4564:
    test      r12,	r12
    jnz       L4563
    mov       rdi,	rsi
    cmp       rdi,	[mc_writeexe.maxrelocaddr]
    jle       L4558
    mov       r13,	1
    mov       rax,	[mc_writeexe.nbaseblocks]
    cmp       rax,	1
    jl        L4570
L4568:
    lea       rax,	[mc_writeexe.blockcounts]
    mov       r10,	r13
    mov       eax,	[rax + r10*4-4]
    test      eax,	eax
    jz        L4572
    lea       rax,	[mc_writeexe.blockcounts]
    mov       r10,	r13
    movsxd    rax,	dword [rax + r10*4-4]
    and       eax,	1
    test      rax,	rax
    jz        L4574
    lea       rax,	[mc_writeexe.blockcounts]
    mov       r10,	r13
    lea       rax,	[rax + r10*4-4]
    inc       dword [rax]
    lea       rax,	[mc_writeexe.blockpadding]
    mov       r10,	r13
    lea       rax,	[rax + r10-1]
    inc       byte [rax]
L4574:
    lea       rax,	[mc_writeexe.blockcounts]
    mov       r10,	r13
    movsxd    rax,	dword [rax + r10*4-4]
    shl       rax,	1
    add       rax,	8
    lea       r10,	[mc_writeexe.blockbytes]
    mov       r11,	r13
    mov       [r10 + r11*4-4],	eax
    lea       rax,	[mc_writeexe.blockbytes]
    mov       r10,	r13
    movsxd    rax,	dword [rax + r10*4-4]
    add       [mc_writeexe.basetablesize],	rax
L4572:
    inc       r13
    cmp       r13,	[mc_writeexe.nbaseblocks]
    jle       L4568
L4570:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writeexe.writebasereloctable
mc_writeexe.writebasereloctable:
;?>>
   %define R.pstart rcx
   %define R.p32 rdi
   %define R.p16 rbx
   %define R.baseaddr rsi
   %define R.addr r12
   %define R.nextblock r13
   %define R.q r14
   %define R.i r15
    %define mc_writeexe.writebasereloctable.$T1 -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	8
;---------------
    mov       rdi,	rcx
    mov       r15,	1
    mov       rax,	[mc_writeexe.nbaseblocks]
    cmp       rax,	1
    jl        L4578
L4576:
    lea       rax,	[mc_writeexe.blockcounts]
    mov       r10,	r15
    mov       eax,	[rax + r10*4-4]
    test      eax,	eax
    jz        L4580
    lea       rax,	[mc_writeexe.blockbases]
    mov       r10,	r15
    mov       rax,	[rax + r10*8-8]
    mov       [rdi],	eax
    add       rdi,	4
    lea       rax,	[mc_writeexe.blockbytes]
    mov       r10,	r15
    mov       eax,	[rax + r10*4-4]
    mov       [rdi],	eax
    add       rdi,	4
    mov       rbx,	rdi
    mov       r14,	[mc_writeexe.basereloclist]
    lea       rax,	[mc_writeexe.blockbases]
    mov       r10,	r15
    mov       rsi,	[rax + r10*8-8]
    lea       rax,	[rsi+4096]
    mov       r13,	rax
    jmp       L4582
L4581:
    mov       eax,	[r14+8]
    mov       r12,	rax
    cmp       r12,	rsi
    jl        L4585
    cmp       r12,	r13
    jge       L4585
    mov       rax,	r12
    sub       rax,	rsi
    mov       [rbp + mc_writeexe.writebasereloctable.$T1],	rax
    movsxd    rax,	dword [r14+12]
    cmp       rax,	2
    jnz       L4587
    mov       rax,	3
    jmp       L4586
L4587:
    mov       rax,	10
L4586:
    shl       rax,	12
    mov       r10,	[rbp + mc_writeexe.writebasereloctable.$T1]
    add       r10,	rax
    mov       [rbx],	r10w
    add       rbx,	2
L4585:
    mov       r14,	[r14]
L4582:
    test      r14,	r14
    jnz       L4581
    lea       rax,	[mc_writeexe.blockpadding]
    mov       r10,	r15
    mov       al,	[rax + r10-1]
    test      al,	al
    jz        L4589
    mov       rax,	rbx
    add       rbx,	2
    xor       r10d,	r10d
    mov       [rax],	r10w
L4589:
    mov       rdi,	rbx
L4580:
    inc       r15
    cmp       r15,	[mc_writeexe.nbaseblocks]
    jle       L4576
L4578:
;---------------
    add       rsp,	8
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writeexe.sortexports
mc_writeexe.sortexports:
;?>>
   %define R.sortindex r14
   %define R.d rdi
   %define R.e rbx
   %define R.swapped rsi
   %define R.av_1 r12
   %define R.i r13
    %define mc_writeexe.sortexports.$T1 -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       r14,	rcx
;---------------
    mov       r13,	1
    mov       rax,	[mc_writeexe.nexports]
    cmp       rax,	1
    jl        L4593
L4591:
    mov       [r14 + r13*8-8],	r13
    inc       r13
    cmp       r13,	[mc_writeexe.nexports]
    jle       L4591
L4593:
L4594:
    xor       rsi,	rsi
    mov       rax,	1
    mov       r13,	rax
    mov       rax,	[mc_writeexe.nexports]
    dec       rax
    mov       r12,	rax
    cmp       r12,	1
    jl        L4599
L4597:
    mov       rax,	[r14 + r13*8-8]
    lea       r10,	[mc_writeexe.exporttable]
    lea       r11,	[rax + rax]
    lea       r10,	[r10 + r11*8-16]
    mov       r10,	[r10]
    mov       rdi,	r10
    mov       rax,	[r14 + r13*8]
    lea       r10,	[mc_writeexe.exporttable]
    lea       r11,	[rax + rax]
    lea       r10,	[r10 + r11*8-16]
    mov       r10,	[r10]
    mov       rbx,	r10
    mov       rax,	[rbx]
    mov       rcx,	rax
    call      pc_api.getbasename
    mov       [rbp + mc_writeexe.sortexports.$T1],	rax
    mov       rax,	[rdi]
    mov       rcx,	rax
    call      pc_api.getbasename
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_writeexe.sortexports.$T1]
    call      strcmp
    movsxd    r10,	eax
    cmp       r10,	0
    jle       L4601
    mov       rsi,	1
    lea       rax,	[r14 + r13*8-8]
    lea       r10,	[r14 + r13*8]
    mov       r11,	[rax]
    mov       r9,	[r10]
    mov       [r10],	r11
    mov       [rax],	r9
L4601:
    inc       r13
    cmp       r13,	r12
    jle       L4597
L4599:
    test      rsi,	rsi
    jnz       L4594
;---------------
    add       rsp,	48
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writeexe.getsectionno
mc_writeexe.getsectionno:
;?>>
   %define R.segment rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rax,	rdi
    cmp       rax,	3
    jz        L4604
    cmp       rax,	2
    jz        L4605
    cmp       rax,	1
    jz        L4606
    jmp       L4607
L4604:
    mov       rax,	3
    jmp       L4603
L4605:
    mov       rax,	2
    jmp       L4603
L4606:
    mov       rax,	1
    jmp       L4603
L4607:
    lea       rcx,	[L12717]
    call      mc_libmcl.axerror
    xor       eax,	eax
L4603:
L4602:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_writeexe.getoffsets
mc_writeexe.getoffsets:
;?>>
   %define R.fileoffset rdi
   %define R.imageoffset rbx
   %define R.i rsi
   %define R.diroffset r12
   %define R.impdirno r13
   %define R.hinttableoffset r14
    %define mc_writeexe.getoffsets.j -8
    %define mc_writeexe.getoffsets.codesize -16
    %define mc_writeexe.getoffsets.length -24
    %define mc_writeexe.getoffsets.thunkoffset -32
    %define mc_writeexe.getoffsets.offset -40
    %define mc_writeexe.getoffsets.dirstartoffset -48
    %define mc_writeexe.getoffsets.pcode -56
    %define mc_writeexe.getoffsets.pimpdir -64
    %define mc_writeexe.getoffsets.pdir -72
    %define mc_writeexe.getoffsets.paddr -80
    %define mc_writeexe.getoffsets.pname -88
    %define mc_writeexe.getoffsets.iatoffset -96
    %define mc_writeexe.getoffsets.phint -104
    %define mc_writeexe.getoffsets.pextra -112
    %define mc_writeexe.getoffsets.xxx -120
    %define mc_writeexe.getoffsets.av_1 -128
    %define mc_writeexe.getoffsets.thunkptr -136
    %define mc_writeexe.getoffsets.codebase -144
    %define mc_writeexe.getoffsets.thunkaddr -152
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	192
;---------------
    mov       rdi,	392
    mov       rax,	40
    imul      rax,	[mc_writeexe.nsections]
    add       rdi,	rax
    mov       rcx,	rdi
    mov       rdx,	512
    call      mlib.roundtoblock
    mov       rdi,	rax
    mov       rbx,	4096
    lea       rax,	[mc_writeexe.sectiontable]
    mov       rax,	[rax+40]
    mov       [rbp + mc_writeexe.getoffsets.codesize],	rax
    mov       rcx,	[mc_decls.ss_code]
    mov       rdx,	[rbp + mc_writeexe.getoffsets.codesize]
    call      mc_genss.bufferelemptr
    mov       [rbp + mc_writeexe.getoffsets.pcode],	rax
    jmp       L4610
L4609:
    mov       rax,	[rbp + mc_writeexe.getoffsets.pcode]
    inc       qword [rbp + mc_writeexe.getoffsets.pcode]
    mov       r10b,	144
    mov       [rax],	r10b
    inc       qword [rbp + mc_writeexe.getoffsets.codesize]
L4610:
    mov       rax,	[rbp + mc_writeexe.getoffsets.codesize]
    and       rax,	7
    jnz       L4609
    mov       rax,	[rbp + mc_writeexe.getoffsets.codesize]
    mov       [rbp + mc_writeexe.getoffsets.thunkoffset],	rax
    mov       rax,	[mc_writeexe.nimports]
    shl       rax,	3
    add       [rbp + mc_writeexe.getoffsets.codesize],	rax
    lea       rax,	[mc_writeexe.sectiontable]
    mov       r10,	[rbp + mc_writeexe.getoffsets.codesize]
    mov       [rax+40],	r10
    mov       rcx,	[rbp + mc_writeexe.getoffsets.codesize]
    mov       rdx,	512
    call      mlib.roundtoblock
    lea       r10,	[mc_writeexe.sectiontable]
    mov       [r10+24],	rax
    mov       rax,	[rbp + mc_writeexe.getoffsets.codesize]
    sub       rax,	[rbp + mc_writeexe.getoffsets.thunkoffset]
    add       rax,	16
    mov       rcx,	[mc_decls.ss_code]
    mov       rdx,	rax
    call      mc_genss.buffercheck
    mov       rsi,	1
    mov       rax,	[mc_writeexe.nsections]
    cmp       rax,	1
    jl        L4614
L4612:
    lea       rax,	[mc_writeexe.sectiontable]
    mov       r10,	rsi
    shl       r10,	3
    lea       r10,	[r10 + r10*8]
    lea       rax,	[rax + r10-72]
    mov       rax,	[rax+16]
    cmp       rax,	3
    jz        L4616
    lea       rax,	[mc_writeexe.sectiontable]
    mov       r10,	rsi
    shl       r10,	3
    lea       r10,	[r10 + r10*8]
    lea       rax,	[rax + r10-72]
    mov       r10,	rdi
    mov       [rax+32],	r10
L4616:
    lea       rax,	[mc_writeexe.sectiontable]
    mov       r10,	rsi
    shl       r10,	3
    lea       r10,	[r10 + r10*8]
    lea       rax,	[rax + r10-72]
    mov       rax,	[rax+16]
    cmp       rax,	3
    jz        L4618
    lea       rax,	[mc_writeexe.sectiontable]
    mov       r10,	rsi
    shl       r10,	3
    lea       r10,	[r10 + r10*8]
    lea       rax,	[rax + r10-72]
    mov       rax,	[rax+40]
    mov       r10,	rdi
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	512
    call      mlib.roundtoblock
    mov       rdi,	rax
L4618:
    lea       rax,	[mc_writeexe.sectiontable]
    mov       r10,	rsi
    shl       r10,	3
    lea       r10,	[r10 + r10*8]
    lea       rax,	[rax + r10-72]
    mov       r10,	rbx
    mov       [rax+48],	r10
    lea       rax,	[mc_writeexe.sectiontable]
    mov       r10,	rsi
    shl       r10,	3
    lea       r10,	[r10 + r10*8]
    lea       rax,	[rax + r10-72]
    mov       rax,	[rax+16]
    cmp       rax,	5
    jnz       L4620
    mov       r12,	rbx
    mov       r13,	rsi
L4620:
    lea       rax,	[mc_writeexe.sectiontable]
    mov       r10,	rsi
    shl       r10,	3
    lea       r10,	[r10 + r10*8]
    lea       rax,	[rax + r10-72]
    mov       rax,	[rax+40]
    mov       r10,	rbx
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	4096
    call      mlib.roundtoblock
    mov       rbx,	rax
    inc       rsi
    cmp       rsi,	[mc_writeexe.nsections]
    jle       L4612
L4614:
    mov       rax,	[mc_writeexe.isdll]
    test      rax,	rax
    jz        L4622
    lea       rax,	[mc_writeexe.sectiontable]
    mov       rcx,	rax
    call      mc_writeexe.getbaserelocs
    lea       rax,	[mc_writeexe.sectiontable]
    lea       rax,	[rax+72]
    mov       rcx,	rax
    call      mc_writeexe.getbaserelocs
L4622:
    mov       rax,	[mc_writeexe.ndlls]
    inc       rax
    shl       rax,	2
    lea       rax,	[rax + rax*4]
    add       r12,	rax
    mov       rsi,	1
    mov       rax,	[mc_writeexe.ndlls]
    cmp       rax,	1
    jl        L4625
L4623:
    lea       rax,	[mc_writeexe.dlltable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       r10,	r12
    mov       [rax+16],	r10
    lea       rax,	[mc_writeexe.dlltable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       rax,	[rax+8]
    inc       rax
    shl       rax,	3
    add       r12,	rax
    inc       rsi
    cmp       rsi,	[mc_writeexe.ndlls]
    jle       L4623
L4625:
    mov       [mc_writeexe.fileiatoffset],	r12
    mov       rsi,	1
    mov       rax,	[mc_writeexe.ndlls]
    cmp       rax,	1
    jl        L4628
L4626:
    lea       rax,	[mc_writeexe.dlltable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       r10,	r12
    mov       [rax+24],	r10
    lea       rax,	[mc_writeexe.dlltable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       rax,	[rax+8]
    inc       rax
    shl       rax,	3
    add       r12,	rax
    inc       rsi
    cmp       rsi,	[mc_writeexe.ndlls]
    jle       L4626
L4628:
    mov       rax,	r12
    sub       rax,	[mc_writeexe.fileiatoffset]
    mov       [mc_writeexe.fileiatsize],	rax
    mov       r14,	r12
    mov       rsi,	1
    mov       rax,	[mc_writeexe.nimports]
    cmp       rax,	1
    jl        L4631
L4629:
    lea       rax,	[mc_writeexe.importtable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10]
    mov       rax,	[rax+16]
    mov       rcx,	rax
    call      strlen
    add       rax,	3
    mov       [rbp + mc_writeexe.getoffsets.length],	rax
    mov       rax,	[rbp + mc_writeexe.getoffsets.length]
    and       rax,	1
    jz        L4633
    inc       qword [rbp + mc_writeexe.getoffsets.length]
L4633:
    lea       rax,	[mc_writeexe.importtable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10]
    mov       r10,	r12
    mov       [rax+24],	r10
    mov       rax,	[rbp + mc_writeexe.getoffsets.length]
    add       r12,	rax
    inc       rsi
    cmp       rsi,	[mc_writeexe.nimports]
    jle       L4629
L4631:
    mov       rcx,	r12
    mov       rdx,	4
    call      mlib.roundtoblock
    mov       r12,	rax
    mov       rsi,	1
    mov       rax,	[mc_writeexe.ndlls]
    cmp       rax,	1
    jl        L4636
L4634:
    lea       rax,	[mc_writeexe.dlltable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       rax,	[rax]
    mov       rcx,	rax
    call      strlen
    inc       rax
    mov       [rbp + mc_writeexe.getoffsets.length],	rax
    mov       rax,	[rbp + mc_writeexe.getoffsets.length]
    and       rax,	1
    jz        L4638
    inc       qword [rbp + mc_writeexe.getoffsets.length]
L4638:
    lea       rax,	[mc_writeexe.dlltable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       r10,	r12
    mov       [rax+40],	r10
    lea       rax,	[mc_writeexe.dlltable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       rax,	[rax+8]
    shl       rax,	2
    add       r12,	rax
    lea       rax,	[mc_writeexe.dlltable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       r10,	r12
    mov       [rax+32],	r10
    mov       rax,	[rbp + mc_writeexe.getoffsets.length]
    add       r12,	rax
    inc       rsi
    cmp       rsi,	[mc_writeexe.ndlls]
    jle       L4634
L4636:
    lea       rax,	[mc_writeexe.sectiontable]
    mov       r10,	r13
    shl       r10,	3
    lea       r10,	[r10 + r10*8]
    lea       rax,	[rax + r10-72]
    mov       rax,	[rax+48]
    mov       [rbp + mc_writeexe.getoffsets.dirstartoffset],	rax
    mov       rax,	[mc_writeexe.isdll]
    test      rax,	rax
    jz        L4640
    mov       [mc_writeexe.exportdirvirtaddr],	r12
    mov       rax,	r12
    sub       rax,	[rbp + mc_writeexe.getoffsets.dirstartoffset]
    mov       [mc_writeexe.exportdiroffset],	rax
    call      mc_writeexe.getexporttablesize
    mov       [mc_writeexe.exportdirvirtsize],	rax
    mov       rax,	[mc_writeexe.exportdirvirtsize]
    add       r12,	rax
    call      mc_writeexe.scanbaserelocs
    mov       [mc_writeexe.blockdirvirtaddr],	r12
    mov       rax,	r12
    sub       rax,	[rbp + mc_writeexe.getoffsets.dirstartoffset]
    mov       [mc_writeexe.blockdiroffset],	rax
    mov       rax,	[mc_writeexe.basetablesize]
    mov       [mc_writeexe.blockdirvirtsize],	rax
    mov       rax,	[mc_writeexe.blockdirvirtsize]
    add       r12,	rax
L4640:
    mov       rax,	r12
    sub       rax,	[rbp + mc_writeexe.getoffsets.dirstartoffset]
    mov       [rbp + mc_writeexe.getoffsets.offset],	rax
    lea       rax,	[mc_writeexe.sectiontable]
    mov       r10,	r13
    shl       r10,	3
    lea       r10,	[r10 + r10*8]
    lea       rax,	[rax + r10-72]
    mov       r10,	[rbp + mc_writeexe.getoffsets.offset]
    mov       [rax+40],	r10
    mov       rcx,	[rbp + mc_writeexe.getoffsets.offset]
    mov       rdx,	512
    call      mlib.roundtoblock
    lea       r10,	[mc_writeexe.sectiontable]
    mov       r11,	r13
    shl       r11,	3
    lea       r11,	[r11 + r11*8]
    lea       r10,	[r10 + r11-72]
    mov       [r10+24],	rax
    mov       rax,	rdi
    add       rax,	[rbp + mc_writeexe.getoffsets.offset]
    mov       rcx,	rax
    mov       rdx,	512
    call      mlib.roundtoblock
    mov       [mc_writeexe.filesize],	rax
    mov       rax,	r12
    sub       rax,	[rbp + mc_writeexe.getoffsets.dirstartoffset]
    mov       r10,	rbx
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	4096
    call      mlib.roundtoblock
    mov       [mc_writeexe.imagesize],	rax
    mov       rcx,	[rbp + mc_writeexe.getoffsets.offset]
    call      mlib.pcm_allocz
    lea       r10,	[mc_writeexe.sectiontable]
    mov       r11,	r13
    shl       r11,	3
    lea       r11,	[r11 + r11*8]
    lea       r10,	[r10 + r11-72]
    mov       [r10],	rax
    mov       [rbp + mc_writeexe.getoffsets.pimpdir],	rax
    mov       rax,	[rbp + mc_writeexe.getoffsets.pimpdir]
    mov       [rbp + mc_writeexe.getoffsets.pdir],	rax
    mov       rsi,	1
    mov       rax,	[mc_writeexe.ndlls]
    cmp       rax,	1
    jl        L4643
L4641:
    lea       rax,	[mc_writeexe.dlltable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       rax,	[rax+16]
    mov       r10,	[rbp + mc_writeexe.getoffsets.pdir]
    mov       [r10],	eax
    lea       rax,	[mc_writeexe.dlltable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       rax,	[rax+24]
    mov       r10,	[rbp + mc_writeexe.getoffsets.pdir]
    mov       [r10+16],	eax
    lea       rax,	[mc_writeexe.dlltable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       rax,	[rax+32]
    mov       r10,	[rbp + mc_writeexe.getoffsets.pdir]
    mov       [r10+12],	eax
    add       qword [rbp + mc_writeexe.getoffsets.pdir],	20
    lea       rax,	[mc_writeexe.dlltable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       rax,	[rax+24]
    mov       [rbp + mc_writeexe.getoffsets.iatoffset],	rax
    mov       rax,	[rbp + mc_writeexe.getoffsets.pimpdir]
    mov       r10,	[rbp + mc_writeexe.getoffsets.iatoffset]
    lea       rax,	[rax + r10]
    mov       r10,	[rbp + mc_writeexe.getoffsets.dirstartoffset]
    sub       rax,	r10
    mov       [rbp + mc_writeexe.getoffsets.paddr],	rax
    lea       rax,	[mc_writeexe.dlltable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       rax,	[rax+16]
    mov       r10,	[rbp + mc_writeexe.getoffsets.pimpdir]
    lea       r10,	[r10 + rax]
    mov       rax,	[rbp + mc_writeexe.getoffsets.dirstartoffset]
    sub       r10,	rax
    mov       [rbp + mc_writeexe.getoffsets.pname],	r10
    mov       rax,	1
    mov       [rbp + mc_writeexe.getoffsets.j],	rax
    mov       rax,	[mc_writeexe.nimports]
    cmp       rax,	1
    jl        L4646
L4644:
    lea       rax,	[mc_writeexe.importtable]
    mov       r10,	[rbp + mc_writeexe.getoffsets.j]
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10]
    mov       rax,	[rax+8]
    cmp       rax,	rsi
    jnz       L4648
    lea       rax,	[mc_writeexe.importtable]
    mov       r10,	[rbp + mc_writeexe.getoffsets.j]
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10]
    mov       rax,	[rax+24]
    mov       r10,	[rbp + mc_writeexe.getoffsets.paddr]
    mov       [r10],	rax
    mov       r10,	[rbp + mc_writeexe.getoffsets.pname]
    mov       [r10],	rax
    lea       rax,	[mc_writeexe.importtable]
    mov       r10,	[rbp + mc_writeexe.getoffsets.j]
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10]
    mov       r10,	[rbp + mc_writeexe.getoffsets.iatoffset]
    mov       [rax+32],	r10
    mov       rax,	8
    add       [rbp + mc_writeexe.getoffsets.iatoffset],	rax
    add       qword [rbp + mc_writeexe.getoffsets.pname],	8
    add       qword [rbp + mc_writeexe.getoffsets.paddr],	8
L4648:
    mov       rax,	[rbp + mc_writeexe.getoffsets.j]
    inc       rax
    mov       [rbp + mc_writeexe.getoffsets.j],	rax
    cmp       rax,	[mc_writeexe.nimports]
    jle       L4644
L4646:
    inc       rsi
    cmp       rsi,	[mc_writeexe.ndlls]
    jle       L4641
L4643:
    mov       rsi,	1
    mov       rax,	[mc_writeexe.nimports]
    cmp       rax,	1
    jl        L4651
L4649:
    lea       rax,	[mc_writeexe.importtable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10]
    mov       rax,	[rax+24]
    mov       r10,	[rbp + mc_writeexe.getoffsets.pimpdir]
    lea       r10,	[r10 + rax]
    mov       rax,	[rbp + mc_writeexe.getoffsets.dirstartoffset]
    sub       r10,	rax
    mov       [rbp + mc_writeexe.getoffsets.phint],	r10
    add       qword [rbp + mc_writeexe.getoffsets.phint],	2
    lea       rax,	[mc_writeexe.importtable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10]
    mov       rax,	[rax+16]
    mov       rcx,	[rbp + mc_writeexe.getoffsets.phint]
    mov       rdx,	rax
    call      strcpy
    inc       rsi
    cmp       rsi,	[mc_writeexe.nimports]
    jle       L4649
L4651:
    mov       rax,	[rbp + mc_writeexe.getoffsets.dirstartoffset]
    mov       [rbp + mc_writeexe.getoffsets.xxx],	rax
    mov       rsi,	1
    mov       rax,	[mc_writeexe.ndlls]
    cmp       rax,	1
    jl        L4654
L4652:
    lea       rax,	[mc_writeexe.dlltable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       rax,	[rax+40]
    mov       r10,	[rbp + mc_writeexe.getoffsets.pimpdir]
    lea       r10,	[r10 + rax]
    mov       rax,	[rbp + mc_writeexe.getoffsets.dirstartoffset]
    sub       r10,	rax
    mov       [rbp + mc_writeexe.getoffsets.pextra],	r10
    mov       rax,	1
    mov       [rbp + mc_writeexe.getoffsets.j],	rax
    lea       rax,	[mc_writeexe.dlltable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       rax,	[rax+8]
    mov       [rbp + mc_writeexe.getoffsets.av_1],	rax
    mov       rax,	[rbp + mc_writeexe.getoffsets.av_1]
    cmp       rax,	1
    jl        L4657
L4655:
    mov       eax,	[rbp + mc_writeexe.getoffsets.xxx]
    mov       r10,	[rbp + mc_writeexe.getoffsets.pextra]
    mov       [r10],	eax
    add       qword [rbp + mc_writeexe.getoffsets.pextra],	4
    mov       rax,	[rbp + mc_writeexe.getoffsets.j]
    inc       rax
    mov       [rbp + mc_writeexe.getoffsets.j],	rax
    cmp       rax,	[rbp + mc_writeexe.getoffsets.av_1]
    jle       L4655
L4657:
    mov       rax,	20
    add       [rbp + mc_writeexe.getoffsets.xxx],	rax
    lea       rax,	[mc_writeexe.dlltable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       rax,	[rax+32]
    mov       r10,	[rbp + mc_writeexe.getoffsets.pimpdir]
    lea       r10,	[r10 + rax]
    mov       rax,	[rbp + mc_writeexe.getoffsets.dirstartoffset]
    sub       r10,	rax
    mov       [rbp + mc_writeexe.getoffsets.phint],	r10
    lea       rax,	[mc_writeexe.dlltable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       rax,	[rax]
    mov       rcx,	[rbp + mc_writeexe.getoffsets.phint]
    mov       rdx,	rax
    call      strcpy
    inc       rsi
    cmp       rsi,	[mc_writeexe.ndlls]
    jle       L4652
L4654:
    mov       rax,	[mc_writeexe.isdll]
    test      rax,	rax
    jz        L4659
    mov       rax,	[rbp + mc_writeexe.getoffsets.pimpdir]
    mov       r10,	[mc_writeexe.exportdiroffset]
    lea       rax,	[rax + r10]
    mov       rcx,	rax
    call      mc_writeexe.writeexporttable
    mov       rax,	[rbp + mc_writeexe.getoffsets.pimpdir]
    mov       r10,	[mc_writeexe.blockdiroffset]
    lea       rax,	[rax + r10]
    mov       rcx,	rax
    call      mc_writeexe.writebasereloctable
L4659:
    mov       rcx,	[mc_decls.ss_code]
    mov       rdx,	[rbp + mc_writeexe.getoffsets.thunkoffset]
    call      mc_genss.bufferelemptr
    mov       [rbp + mc_writeexe.getoffsets.thunkptr],	rax
    mov       rcx,	[mc_decls.ss_code]
    xor       edx,	edx
    call      mc_genss.bufferelemptr
    mov       [rbp + mc_writeexe.getoffsets.codebase],	rax
    mov       rsi,	1
    mov       rax,	[mc_writeexe.nimports]
    cmp       rax,	1
    jl        L4662
L4660:
    mov       rax,	[rbp + mc_writeexe.getoffsets.thunkptr]
    sub       rax,	[rbp + mc_writeexe.getoffsets.codebase]
    lea       r10,	[mc_writeexe.importtable]
    mov       r11,	rsi
    shl       r11,	4
    lea       r11,	[r11 + r11*2]
    lea       r10,	[r10 + r11]
    mov       [r10+40],	rax
    movzx     rax,	byte [pc_api.phighmem]
    test      rax,	rax
    jnz       L4664
    mov       rax,	[rbp + mc_writeexe.getoffsets.thunkptr]
    inc       qword [rbp + mc_writeexe.getoffsets.thunkptr]
    mov       r10b,	72
    mov       [rax],	r10b
    mov       rax,	[rbp + mc_writeexe.getoffsets.thunkptr]
    inc       qword [rbp + mc_writeexe.getoffsets.thunkptr]
    mov       r10b,	255
    mov       [rax],	r10b
    mov       rax,	[rbp + mc_writeexe.getoffsets.thunkptr]
    inc       qword [rbp + mc_writeexe.getoffsets.thunkptr]
    mov       r10b,	36
    mov       [rax],	r10b
    mov       rax,	[rbp + mc_writeexe.getoffsets.thunkptr]
    inc       qword [rbp + mc_writeexe.getoffsets.thunkptr]
    mov       r10b,	37
    mov       [rax],	r10b
    lea       rax,	[mc_writeexe.importtable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10]
    mov       rax,	[rax+32]
    mov       r10,	[mc_writeexe.imagebase]
    add       r10,	rax
    mov       [rbp + mc_writeexe.getoffsets.thunkaddr],	r10
    mov       eax,	[rbp + mc_writeexe.getoffsets.thunkaddr]
    mov       r10,	[rbp + mc_writeexe.getoffsets.thunkptr]
    mov       [r10],	eax
    add       qword [rbp + mc_writeexe.getoffsets.thunkptr],	4
    jmp       L4663
L4664:
    mov       rax,	[rbp + mc_writeexe.getoffsets.thunkptr]
    inc       qword [rbp + mc_writeexe.getoffsets.thunkptr]
    mov       r10b,	72
    mov       [rax],	r10b
    mov       rax,	[rbp + mc_writeexe.getoffsets.thunkptr]
    inc       qword [rbp + mc_writeexe.getoffsets.thunkptr]
    mov       r10b,	255
    mov       [rax],	r10b
    mov       rax,	[rbp + mc_writeexe.getoffsets.thunkptr]
    inc       qword [rbp + mc_writeexe.getoffsets.thunkptr]
    mov       r10b,	37
    mov       [rax],	r10b
    lea       rax,	[mc_writeexe.importtable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10]
    mov       rax,	[rax+32]
    mov       r10,	[mc_writeexe.imagebase]
    add       r10,	rax
    mov       [rbp + mc_writeexe.getoffsets.thunkaddr],	r10
    mov       rax,	[rbp + mc_writeexe.getoffsets.thunkaddr]
    sub       rax,	[mc_writeexe.imagebase]
    mov       r10,	[rbp + mc_writeexe.getoffsets.thunkptr]
    sub       r10,	[rbp + mc_writeexe.getoffsets.codebase]
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_writeexe.getripoffset
    mov       r10,	[rbp + mc_writeexe.getoffsets.thunkptr]
    mov       [r10],	eax
    add       qword [rbp + mc_writeexe.getoffsets.thunkptr],	4
    mov       rax,	[rbp + mc_writeexe.getoffsets.thunkptr]
    inc       qword [rbp + mc_writeexe.getoffsets.thunkptr]
    mov       r10b,	144
    mov       [rax],	r10b
L4663:
    inc       rsi
    cmp       rsi,	[mc_writeexe.nimports]
    jle       L4660
L4662:
;---------------
    add       rsp,	192
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writeexe.getripoffset
mc_writeexe.getripoffset:
;?>>
   %define R.addr rcx
   %define R.dest rdx
   %define R.extra r8
;?]]
;---------------
    lea       rax,	[mc_writeexe.sectiontable]
    mov       rax,	[rax+48]
    add       rcx,	rax
    lea       rax,	[rcx+4]
    mov       r10,	rdx
    sub       r10,	rax
    sub       r10,	r8
    mov       rax,	r10
L4665:
;---------------
    ret       
;End 
;Proc mc_writeobj.writecoff
mc_writeobj.writecoff:
;?>>
   %define R.outfile rbx
    %define mc_writeobj.writecoff.header -24
    %define mc_writeobj.writecoff.zsection -64
    %define mc_writeobj.writecoff.isection -104
    %define mc_writeobj.writecoff.csection -144
   %define R.offset rdi
    push      rdi
    push      rbx
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	176
    mov       rbx,	rcx
;---------------
    mov       al,	[pc_decls.objdone]
    test      al,	al
    jnz       L4666
L4668:
    lea       rax,	[rbp + mc_writeobj.writecoff.header]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    mov       [rax+16],	r10d
    lea       rax,	[rbp + mc_writeobj.writecoff.zsection]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    mov       [rax+16],	r10
    mov       [rax+24],	r10
    mov       [rax+32],	r10
    lea       rax,	[rbp + mc_writeobj.writecoff.isection]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    mov       [rax+16],	r10
    mov       [rax+24],	r10
    mov       [rax+32],	r10
    lea       rax,	[rbp + mc_writeobj.writecoff.csection]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    mov       [rax+16],	r10
    mov       [rax+24],	r10
    mov       [rax+32],	r10
    mov       ax,	34404
    mov       [rbp + mc_writeobj.writecoff.header],	ax
    mov       ax,	3
    mov       [rbp + mc_writeobj.writecoff.header+2],	ax
    lea       rax,	[rbp + mc_writeobj.writecoff.zsection]
    mov       rcx,	rax
    lea       rdx,	[L12718]
    call      strcpy
    mov       eax,	[mc_decls.ss_zdatalen]
    mov       [rbp + mc_writeobj.writecoff.zsection+16],	eax
    mov       eax,	3225419904
    mov       [rbp + mc_writeobj.writecoff.zsection+36],	eax
    mov       rax,	[mc_decls.ss_nidatarelocs]
    cmp       rax,	65536
    jge       L4671
    mov       rax,	[mc_decls.ss_ncoderelocs]
    cmp       rax,	65536
    jl        L4670
L4671:
    lea       rcx,	[L12719]
    call      mc_libmcl.axerror
L4670:
    lea       rax,	[rbp + mc_writeobj.writecoff.isection]
    mov       rcx,	rax
    lea       rdx,	[L12720]
    call      strcpy
    mov       rcx,	[mc_decls.ss_idata]
    call      mc_genss.bufferlength
    mov       [rbp + mc_writeobj.writecoff.isection+16],	eax
    mov       ax,	[mc_decls.ss_nidatarelocs]
    mov       [rbp + mc_writeobj.writecoff.isection+32],	ax
    mov       eax,	3226468416
    mov       [rbp + mc_writeobj.writecoff.isection+36],	eax
    lea       rax,	[rbp + mc_writeobj.writecoff.csection]
    mov       rcx,	rax
    lea       rdx,	[L12721]
    call      strcpy
    mov       rcx,	[mc_decls.ss_code]
    call      mc_genss.bufferlength
    mov       [rbp + mc_writeobj.writecoff.csection+16],	eax
    mov       ax,	[mc_decls.ss_ncoderelocs]
    mov       [rbp + mc_writeobj.writecoff.csection+32],	ax
    mov       eax,	1615855648
    mov       [rbp + mc_writeobj.writecoff.csection+36],	eax
    mov       rcx,	rbx
    call      mc_writeobj.initsymboltable
    call      mc_writeobj.convertsymboltable
    mov       rdi,	20
    mov       rax,	120
    add       rdi,	rax
    mov       ax,	[rbp + mc_writeobj.writecoff.isection+32]
    test      ax,	ax
    jz        L4673
    mov       [rbp + mc_writeobj.writecoff.isection+24],	edi
    movzx     rax,	word [rbp + mc_writeobj.writecoff.isection+32]
    shl       rax,	1
    lea       rax,	[rax + rax*4]
    add       rdi,	rax
L4673:
    mov       ax,	[rbp + mc_writeobj.writecoff.csection+32]
    test      ax,	ax
    jz        L4675
    mov       [rbp + mc_writeobj.writecoff.csection+24],	edi
    movzx     rax,	word [rbp + mc_writeobj.writecoff.csection+32]
    shl       rax,	1
    lea       rax,	[rax + rax*4]
    add       rdi,	rax
L4675:
    mov       [rbp + mc_writeobj.writecoff.isection+20],	edi
    mov       eax,	[rbp + mc_writeobj.writecoff.isection+16]
    add       rdi,	rax
    mov       [rbp + mc_writeobj.writecoff.csection+20],	edi
    mov       eax,	[rbp + mc_writeobj.writecoff.csection+16]
    add       rdi,	rax
    mov       [rbp + mc_writeobj.writecoff.header+8],	edi
    mov       rax,	[mc_writeobj.nsymbols]
    shl       rax,	1
    lea       rax,	[rax + rax*8]
    add       rdi,	rax
    mov       eax,	[mc_writeobj.nsymbols]
    mov       [rbp + mc_writeobj.writecoff.header+12],	eax
    mov       rax,	[mc_writeobj.nextstringoffset]
    add       rdi,	rax
    mov       rcx,	rdi
    call      malloc
    mov       [mc_writeobj.dataptr],	rax
    mov       [mc_writeobj.datastart],	rax
    lea       rcx,	[rbp + mc_writeobj.writecoff.header]
    mov       rdx,	20
    call      mc_writeobj.writerecord
    lea       rcx,	[rbp + mc_writeobj.writecoff.zsection]
    mov       rdx,	40
    call      mc_writeobj.writerecord
    lea       rcx,	[rbp + mc_writeobj.writecoff.isection]
    mov       rdx,	40
    call      mc_writeobj.writerecord
    lea       rcx,	[rbp + mc_writeobj.writecoff.csection]
    mov       rdx,	40
    call      mc_writeobj.writerecord
    mov       rcx,	[mc_decls.ss_idatarelocs]
    mov       rdx,	[mc_decls.ss_nidatarelocs]
    call      mc_writeobj.writerelocs
    mov       rcx,	[mc_decls.ss_coderelocs]
    mov       rdx,	[mc_decls.ss_ncoderelocs]
    call      mc_writeobj.writerelocs
    mov       rcx,	[mc_decls.ss_idata]
    call      mc_writeobj.writedata
    mov       rcx,	[mc_decls.ss_code]
    call      mc_writeobj.writedata
    call      mc_writeobj.writesymboltable
    call      mc_writeobj.writestringtable
    mov       al,	[pc_decls.pverbose]
    test      al,	al
    jz        L4677
    call      msys.m$print_startcon
    lea       rcx,	[L12722]
    call      msys.m$print_str_nf
    mov       rcx,	rbx
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L4677:
    mov       rax,	[mc_writeobj.dataptr]
    sub       rax,	[mc_writeobj.datastart]
    mov       rcx,	rbx
    mov       rdx,	[mc_writeobj.datastart]
    mov       r8,	rax
    call      mlib.writefile
    mov       al,	1
    mov       [pc_decls.objdone],	al
L4666:
;---------------
    add       rsp,	176
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writeobj.writerecord
mc_writeobj.writerecord:
;?>>
   %define R.r rdi
   %define R.length rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	[mc_writeobj.dataptr]
    mov       rdx,	rdi
    mov       r8,	rbx
    call      memcpy
    mov       rax,	rbx
    add       [mc_writeobj.dataptr],	rax
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writeobj.writerelocs
mc_writeobj.writerelocs:
;?>>
   %define R.r rbx
   %define R.nrelocs rsi
   %define R.d rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    test      rsi,	rsi
    jnz       L4681
    jmp       L4679
L4681:
    jmp       L4683
L4682:
    mov       rax,	[rbx+8]
    cmp       rax,	2
    jz        L4686
    cmp       rax,	1
    jnz       L4687
L4686:
    mov       rax,	[rbx+24]
    mov       r10,	[mc_decls.ss_symboltable]
    mov       r10,	[r10 + rax*8-8]
    mov       rdi,	r10
    movzx     rax,	byte [rdi+94]
    cmp       rax,	3
    jz        L4689
    cmp       rax,	2
    jz        L4690
    cmp       rax,	1
    jz        L4691
    test      rax,	rax
    jz        L4692
    jmp       L4693
L4689:
    mov       eax,	2
    lea       r10,	[mc_writeobj.writerelocs.s]
    mov       [r10+4],	eax
    jmp       L4688
L4690:
    mov       eax,	4
    lea       r10,	[mc_writeobj.writerelocs.s]
    mov       [r10+4],	eax
    jmp       L4688
L4691:
    mov       eax,	6
    lea       r10,	[mc_writeobj.writerelocs.s]
    mov       [r10+4],	eax
    jmp       L4688
L4692:
    mov       rax,	[rbx+24]
    add       rax,	[mc_writeobj.stoffset]
    lea       r10,	[mc_writeobj.writerelocs.s]
    mov       [r10+4],	eax
    jmp       L4688
L4693:
    lea       rcx,	[L12723]
    call      mc_libmcl.axerror
L4688:
    jmp       L4685
L4687:
    mov       rax,	[rbx+24]
    add       rax,	[mc_writeobj.stoffset]
    lea       r10,	[mc_writeobj.writerelocs.s]
    mov       [r10+4],	eax
L4685:
    mov       rax,	[rbx+8]
    lea       r10,	[mc_writeobj.writerelocs.s]
    mov       [r10+8],	ax
    movzx     rax,	byte [pc_api.phighmem]
    test      rax,	rax
    jz        L4695
    cmp       rax,	2
    jz        L4696
    jmp       L4697
L4695:
    jmp       L4694
L4696:
    mov       rax,	[rbx+8]
    cmp       rax,	2
    jnz       L4699
    mov       ax,	4
    lea       r10,	[mc_writeobj.writerelocs.s]
    mov       [r10+8],	ax
    mov       rax,	4
    mov       [rbx+8],	rax
L4699:
    jmp       L4694
L4697:
    lea       rcx,	[L12724]
    call      mc_libmcl.axerror
L4694:
    mov       rax,	[rbx+16]
    lea       r10,	[mc_writeobj.writerelocs.s]
    mov       [r10],	eax
    mov       rcx,	[mc_writeobj.dataptr]
    lea       rdx,	[mc_writeobj.writerelocs.s]
    mov       r8,	10
    call      memcpy
    add       qword [mc_writeobj.dataptr],	10
    mov       rbx,	[rbx]
L4683:
    test      rbx,	rbx
    jnz       L4682
L4679:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writeobj.writedata
mc_writeobj.writedata:
;?>>
   %define R.data rdi
    %define mc_writeobj.writedata.$T1 -8
    push      rdi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      mc_genss.bufferlength
    mov       [rbp + mc_writeobj.writedata.$T1],	rax
    mov       rcx,	rdi
    xor       edx,	edx
    call      mc_genss.bufferelemptr
    mov       rcx,	[mc_writeobj.dataptr]
    mov       rdx,	rax
    mov       r8,	[rbp + mc_writeobj.writedata.$T1]
    call      memcpy
    mov       rcx,	rdi
    call      mc_genss.bufferlength
    add       [mc_writeobj.dataptr],	rax
;---------------
    add       rsp,	40
    pop       rbp
    pop       rdi
    ret       
;End 
;Proc mc_writeobj.writesymboltable
mc_writeobj.writesymboltable:
;?>>
   %define R.i rdi
    push      rdi
;?]]
    sub       rsp,	48
;---------------
    mov       rdi,	1
    mov       rax,	[mc_writeobj.nsymbols]
    cmp       rax,	1
    jl        L4704
L4702:
    lea       rax,	[mc_writeobj.symboltable]
    mov       r10,	rdi
    shl       r10,	1
    lea       r10,	[r10 + r10*8]
    lea       rax,	[rax + r10]
    mov       rcx,	rax
    mov       rdx,	18
    call      mc_writeobj.writerecord
    inc       rdi
    cmp       rdi,	[mc_writeobj.nsymbols]
    jle       L4702
L4704:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_writeobj.writestringtable
mc_writeobj.writestringtable:
;?>>
   %define R.p rdi
   %define R.i rbx
   %define R.n rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
;---------------
    mov       rdi,	[mc_writeobj.dataptr]
    mov       eax,	[mc_writeobj.nextstringoffset]
    mov       [rdi],	eax
    add       qword [mc_writeobj.dataptr],	4
    mov       rbx,	1
    mov       rax,	[mc_writeobj.nstrings]
    cmp       rax,	1
    jl        L4708
L4706:
    lea       rax,	[mc_writeobj.stringlengths]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8-8]
    inc       rax
    mov       rsi,	rax
    lea       rax,	[mc_writeobj.stringtable]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	[mc_writeobj.dataptr]
    mov       rdx,	rax
    mov       r8,	rsi
    call      memcpy
    mov       rax,	rsi
    add       [mc_writeobj.dataptr],	rax
    inc       rbx
    cmp       rbx,	[mc_writeobj.nstrings]
    jle       L4706
L4708:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writeobj.makesymbol
mc_writeobj.makesymbol:
;?>>
   %define R.name rbx
   %define R.value rsi
   %define R.sectionno r12
   %define R.symtype r13
    %define mc_writeobj.makesymbol.storage 88
    %define mc_writeobj.makesymbol.naux 96
   %define R.namelen rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
    mov       r13,	r9
;---------------
    mov       rcx,	rbx
    call      strlen
    mov       rdi,	rax
    cmp       rdi,	8
    jge       L4711
    lea       rax,	[mc_writeobj.makesymbol.r]
    mov       rcx,	rax
    mov       rdx,	rbx
    call      strcpy
    jmp       L4710
L4711:
    cmp       rdi,	8
    jnz       L4712
    lea       rax,	[mc_writeobj.makesymbol.r]
    mov       rcx,	rax
    mov       rdx,	rbx
    mov       r8,	rdi
    call      memcpy
    jmp       L4710
L4712:
    xor       eax,	eax
    lea       r10,	[mc_writeobj.makesymbol.r]
    mov       [r10],	eax
    mov       rcx,	rbx
    mov       rdx,	rdi
    call      mc_writeobj.addstringentry
    lea       r10,	[mc_writeobj.makesymbol.r]
    mov       [r10+4],	eax
L4710:
    mov       eax,	esi
    lea       r10,	[mc_writeobj.makesymbol.r]
    mov       [r10+8],	eax
    mov       ax,	r12w
    lea       r10,	[mc_writeobj.makesymbol.r]
    mov       [r10+12],	ax
    mov       ax,	r13w
    lea       r10,	[mc_writeobj.makesymbol.r]
    mov       [r10+14],	ax
    mov       al,	[rbp + mc_writeobj.makesymbol.storage]
    lea       r10,	[mc_writeobj.makesymbol.r]
    mov       [r10+16],	al
    mov       al,	[rbp + mc_writeobj.makesymbol.naux]
    lea       r10,	[mc_writeobj.makesymbol.r]
    mov       [r10+17],	al
    lea       rax,	[mc_writeobj.makesymbol.r]
L4709:
;---------------
    add       rsp,	40
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writeobj.addsymbol
mc_writeobj.addsymbol:
;?>>
   %define R.r rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rax,	[mc_writeobj.nsymbols]
    cmp       rax,	13000
    jl        L4715
    lea       rcx,	[L12725]
    call      mc_libmcl.axerror
L4715:
    inc       qword [mc_writeobj.nsymbols]
    mov       rax,	[mc_writeobj.nsymbols]
    lea       r10,	[mc_writeobj.symboltable]
    mov       r11,	rax
    shl       r11,	1
    lea       r11,	[r11 + r11*8]
    lea       r10,	[r10 + r11]
    mov       rcx,	r10
    mov       rdx,	rdi
    mov       r8,	18
    call      memcpy
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_writeobj.initsymboltable
mc_writeobj.initsymboltable:
;?>>
   %define R.filename rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    xor       eax,	eax
    mov       [mc_writeobj.nsymbols],	rax
    push      1
    push      103
    lea       rcx,	[L12726]
    xor       edx,	edx
    mov       r8,	-2
    xor       r9d,	r9d
    sub       rsp,	32
    call      mc_writeobj.makesymbol
    add       rsp,	48
    mov       rcx,	rax
    call      mc_writeobj.addsymbol
    mov       rcx,	rdi
    call      mc_writeobj.strtoaux
    mov       rcx,	rax
    call      mc_writeobj.addsymbol
    push      1
    push      3
    lea       rcx,	[L12727]
    xor       edx,	edx
    mov       r8,	1
    xor       r9d,	r9d
    sub       rsp,	32
    call      mc_writeobj.makesymbol
    add       rsp,	48
    mov       rcx,	rax
    call      mc_writeobj.addsymbol
    xor       ecx,	ecx
    xor       edx,	edx
    call      mc_writeobj.sectiontoaux
    mov       rcx,	rax
    call      mc_writeobj.addsymbol
    push      1
    push      3
    lea       rcx,	[L12728]
    xor       edx,	edx
    mov       r8,	2
    xor       r9d,	r9d
    sub       rsp,	32
    call      mc_writeobj.makesymbol
    add       rsp,	48
    mov       rcx,	rax
    call      mc_writeobj.addsymbol
    mov       rcx,	[mc_decls.ss_idata]
    mov       rdx,	[mc_decls.ss_nidatarelocs]
    call      mc_writeobj.sectiontoaux
    mov       rcx,	rax
    call      mc_writeobj.addsymbol
    push      1
    push      3
    lea       rcx,	[L12729]
    xor       edx,	edx
    mov       r8,	3
    xor       r9d,	r9d
    sub       rsp,	32
    call      mc_writeobj.makesymbol
    add       rsp,	48
    mov       rcx,	rax
    call      mc_writeobj.addsymbol
    mov       rcx,	[mc_decls.ss_code]
    mov       rdx,	[mc_decls.ss_ncoderelocs]
    call      mc_writeobj.sectiontoaux
    mov       rcx,	rax
    call      mc_writeobj.addsymbol
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mc_writeobj.strtoaux
mc_writeobj.strtoaux:
;?>>
   %define R.s rsi
   %define R.p rdi
   %define R.n rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    lea       rax,	[mc_writeobj.strtoaux.r]
    mov       rdi,	rax
    mov       rcx,	rdi
    xor       edx,	edx
    mov       r8,	18
    call      memset
    xor       rbx,	rbx
    jmp       L4719
L4718:
    mov       rax,	rsi
    inc       rsi
    mov       al,	[rax]
    mov       r10,	rdi
    inc       rdi
    mov       [r10],	al
    inc       rbx
L4719:
    movzx     rax,	byte [rsi]
    test      rax,	rax
    jz        L4721
    cmp       rbx,	18
    jl        L4718
L4721:
    lea       rax,	[mc_writeobj.strtoaux.r]
L4717:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writeobj.sectiontoaux
mc_writeobj.sectiontoaux:
;?>>
   %define R.data rdi
   %define R.nrelocs rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    lea       rax,	[mc_writeobj.sectiontoaux.r]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    mov       [rax+16],	r10w
    test      rdi,	rdi
    jnz       L4724
    mov       eax,	[mc_decls.ss_zdatalen]
    lea       r10,	[mc_writeobj.sectiontoaux.r]
    mov       [r10],	eax
    jmp       L4723
L4724:
    mov       rcx,	rdi
    call      mc_genss.bufferlength
    lea       r10,	[mc_writeobj.sectiontoaux.r]
    mov       [r10],	eax
L4723:
    mov       ax,	bx
    lea       r10,	[mc_writeobj.sectiontoaux.r]
    mov       [r10+4],	ax
    lea       rax,	[mc_writeobj.sectiontoaux.r]
L4722:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writeobj.addstringentry
mc_writeobj.addstringentry:
;?>>
   %define R.s rbx
   %define R.length rsi
   %define R.offset rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    mov       rdi,	[mc_writeobj.nextstringoffset]
    mov       rax,	[mc_writeobj.nstrings]
    cmp       rax,	5000
    jle       L4727
    lea       rcx,	[L12730]
    call      mc_libmcl.axerror
L4727:
    mov       rcx,	rbx
    call      mlib.pcm_copyheapstring
    inc       qword [mc_writeobj.nstrings]
    mov       r10,	[mc_writeobj.nstrings]
    lea       r11,	[mc_writeobj.stringtable]
    mov       [r11 + r10*8-8],	rax
    mov       rax,	rsi
    lea       r10,	[mc_writeobj.stringlengths]
    mov       r11,	[mc_writeobj.nstrings]
    mov       [r10 + r11*8-8],	rax
    lea       rax,	[rsi+1]
    add       [mc_writeobj.nextstringoffset],	rax
    mov       rax,	rdi
L4725:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writeobj.convertsymboltable
mc_writeobj.convertsymboltable:
;?>>
   %define R.s rdi
   %define R.name rbx
   %define R.i rsi
   %define R.sect r12
   %define R.scope r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
;---------------
    mov       rax,	[mc_writeobj.nsymbols]
    dec       rax
    mov       [mc_writeobj.stoffset],	rax
    xor       eax,	eax
    mov       [mc_writeobj.nstrings],	rax
    mov       rax,	4
    mov       [mc_writeobj.nextstringoffset],	rax
    mov       rsi,	1
    mov       rax,	[mc_decls.ss_nsymbols]
    cmp       rax,	1
    jl        L4731
L4729:
    mov       rax,	[mc_decls.ss_symboltable]
    mov       r10,	rsi
    mov       rdi,	[rax + r10*8-8]
    mov       rbx,	[rdi]
    movzx     rax,	byte [rdi+94]
    cmp       rax,	3
    jz        L4733
    cmp       rax,	2
    jz        L4734
    cmp       rax,	1
    jz        L4735
    jmp       L4736
L4733:
    mov       r12,	1
    jmp       L4732
L4734:
    mov       r12,	2
    jmp       L4732
L4735:
    mov       r12,	3
    jmp       L4732
L4736:
    xor       r12,	r12
L4732:
    mov       al,	[rdi+80]
    test      al,	al
    jz        L4738
    xor       r12,	r12
L4738:
    xor       r13,	r13
    mov       al,	[rdi+80]
    test      al,	al
    jnz       L4741
    mov       al,	[rdi+81]
    test      al,	al
    jz        L4740
L4741:
    mov       r13,	2
    jmp       L4739
L4740:
    mov       r13,	3
L4739:
    mov       al,	[rdi+81]
    test      al,	al
    jz        L4743
    mov       rcx,	rbx
    call      pc_api.getbasename
    mov       rbx,	rax
L4743:
    push      0
    mov       rax,	r13
    push      rax
    movsxd    rax,	dword [rdi+76]
    mov       rcx,	rbx
    mov       rdx,	rax
    mov       r8,	r12
    xor       r9d,	r9d
    sub       rsp,	32
    call      mc_writeobj.makesymbol
    add       rsp,	48
    mov       rcx,	rax
    call      mc_writeobj.addsymbol
    inc       rsi
    cmp       rsi,	[mc_decls.ss_nsymbols]
    jle       L4729
L4731:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mc_writess_dummy.writessdata
mc_writess_dummy.writessdata:
;?>>
    %define mc_writess_dummy.writessdata.fexe 16
;?]]
;---------------
    xor       eax,	eax
L4744:
;---------------
    ret       
;End 
;Proc mx_run.writememlib
mx_run.writememlib:
;?>>
   %define R.filename r14
   %define R.plib rdi
   %define R.k rbx
    %define mx_run.writememlib.lib -216
   %define R.ndlls rsi
   %define R.nlibs r12
   %define R.i r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	256
    mov       r14,	rcx
;---------------
    lea       rax,	[rbp + mx_run.writememlib.lib]
    xor       r10d,	r10d
    mov       r11,	27
L12731:
    mov       [rax],	r10
    add       rax,	8
    dec       r11
    jnz       L12731
    mov       rcx,	[mc_decls.ss_zdatalen]
    mov       rdx,	8
    call      mlib.roundtoblock
    mov       [mc_decls.ss_zdatalen],	rax
    mov       rcx,	[mc_decls.ss_code]
    mov       rdx,	8
    mov       r8,	144
    call      mx_run.roundsegment
    mov       rcx,	[mc_decls.ss_idata]
    mov       rdx,	8
    xor       r8d,	r8d
    call      mx_run.roundsegment
    lea       rax,	[L12732]
    mov       [rbp + mx_run.writememlib.lib],	rax
    mov       [rbp + mx_run.writememlib.lib+184],	r14
    mov       rcx,	r14
    call      mlib.extractbasefile
    mov       rcx,	rax
    call      mlib.pcm_copyheapstring
    mov       [rbp + mx_run.writememlib.lib+192],	rax
    mov       rax,	1
    mov       [rbp + mx_run.writememlib.lib+208],	rax
    call      mx_run.countsymbols
    lea       rcx,	[rbp + mx_run.writememlib.lib]
    call      mx_run.writerelocs
    mov       rax,	[mc_decls.ss_zdatalen]
    mov       [rbp + mx_run.writememlib.lib+24],	rax
    mov       rcx,	[mc_decls.ss_code]
    call      mc_genss.bufferlength
    mov       [rbp + mx_run.writememlib.lib+8],	rax
    mov       rcx,	[mc_decls.ss_idata]
    call      mc_genss.bufferlength
    mov       [rbp + mx_run.writememlib.lib+16],	rax
    mov       rcx,	[mc_decls.ss_code]
    xor       edx,	edx
    call      mc_genss.bufferelemptr
    mov       [rbp + mx_run.writememlib.lib+72],	rax
    mov       rcx,	[mc_decls.ss_idata]
    xor       edx,	edx
    call      mc_genss.bufferelemptr
    mov       [rbp + mx_run.writememlib.lib+80],	rax
    xor       rsi,	rsi
    xor       eax,	eax
    mov       r12,	rax
    mov       r13,	1
    mov       rax,	[pc_decls.nplibfiles]
    cmp       rax,	1
    jl        L4748
L4746:
    lea       rax,	[pc_decls.plibfiles]
    mov       r10,	r13
    mov       rax,	[rax + r10*8-8]
    movzx     rax,	byte [rax]
    cmp       rax,	36
    jz        L4750
    inc       rsi
L4750:
    inc       r13
    cmp       r13,	[pc_decls.nplibfiles]
    jle       L4746
L4748:
    mov       [rbp + mx_run.writememlib.lib+40],	rsi
    mov       [rbp + mx_run.writememlib.lib+48],	r12
    mov       rax,	8
    imul      rax,	rsi
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [rbp + mx_run.writememlib.lib+96],	rax
    mov       rax,	8
    imul      rax,	r12
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [rbp + mx_run.writememlib.lib+104],	rax
    xor       rbx,	rbx
    mov       rax,	1
    mov       r13,	rax
    mov       rax,	[pc_decls.nplibfiles]
    cmp       rax,	1
    jl        L4753
L4751:
    lea       rax,	[pc_decls.plibfiles]
    mov       r10,	r13
    mov       rax,	[rax + r10*8-8]
    movzx     rax,	byte [rax]
    cmp       rax,	36
    jz        L4755
    lea       rax,	[pc_decls.plibfiles]
    mov       r10,	r13
    mov       rax,	[rax + r10*8-8]
    mov       r10,	[rbp + mx_run.writememlib.lib+96]
    inc       rbx
    mov       r11,	rbx
    mov       [r10 + r11*8-8],	rax
L4755:
    inc       r13
    cmp       r13,	[pc_decls.nplibfiles]
    jle       L4751
L4753:
    lea       rcx,	[rbp + mx_run.writememlib.lib]
    call      mx_run.addsymbols
    mov       rcx,	216
    call      mlib.pcm_allocnfz
    mov       rdi,	rax
    mov       rcx,	rdi
    lea       rdx,	[rbp + mx_run.writememlib.lib]
    mov       r8,	216
    call      memcpy
    mov       rax,	rdi
L4745:
;---------------
    add       rsp,	256
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_run.roundsegment
mx_run.roundsegment:
;?>>
   %define R.p r12
   %define R.align r13
   %define R.value r14
   %define R.length rdi
   %define R.newlength rbx
   %define R.av_1 rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       r12,	rcx
    mov       r13,	rdx
    mov       r14,	r8
;---------------
    mov       rcx,	r12
    call      mc_genss.bufferlength
    mov       rdi,	rax
    mov       rcx,	rdi
    mov       rdx,	r13
    call      mlib.roundtoblock
    mov       rbx,	rax
    mov       rcx,	r12
    mov       rdx,	r13
    call      mc_genss.buffercheck
    mov       rax,	rbx
    sub       rax,	rdi
    mov       rsi,	rax
    cmp       rsi,	0
    jle       L4759
L4757:
    lea       rax,	[r12+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       [r10],	r14b
    dec       rsi
    jnz       L4757
L4759:
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_run.writerelocs
mx_run.writerelocs:
;?>>
   %define R.lib r14
   %define R.oldr rdi
    %define mx_run.writerelocs.newr -8
   %define R.k rbx
   %define R.d rsi
   %define R.baseptr64 r12
   %define R.i r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       r14,	rcx
;---------------
    mov       rax,	[mc_decls.ss_nidatarelocs]
    add       rax,	[mc_decls.ss_ncoderelocs]
    mov       [r14+32],	rax
    mov       rax,	[r14+32]
    shl       rax,	3
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [r14+88],	rax
    xor       rbx,	rbx
    mov       rax,	1
    mov       r13,	rax
L4761:
    cmp       r13,	1
    jnz       L4765
    mov       rax,	[mc_decls.ss_idatarelocs]
    jmp       L4764
L4765:
    mov       rax,	[mc_decls.ss_coderelocs]
L4764:
    mov       rdi,	rax
    jmp       L4769
L4766:
    lea       rax,	[rbp + mx_run.writerelocs.newr]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       rax,	[rdi+16]
    mov       [rbp + mx_run.writerelocs.newr],	eax
    cmp       r13,	1
    jnz       L4771
    mov       rax,	2
    jmp       L4770
L4771:
    mov       rax,	1
L4770:
    mov       [rbp + mx_run.writerelocs.newr+6],	al
    mov       rax,	[rdi+24]
    mov       r10,	[mc_decls.ss_symboltable]
    mov       r10,	[r10 + rax*8-8]
    mov       rsi,	r10
    mov       rax,	[rdi+8]
    cmp       rax,	4
    jz        L4773
    cmp       rax,	2
    jz        L4774
    cmp       rax,	1
    jz        L4774
    jmp       L4775
L4773:
    mov       al,	[rsi+80]
    test      al,	al
    jz        L4777
    mov       ax,	[rsi+116]
    mov       [rbp + mx_run.writerelocs.newr+4],	ax
    mov       al,	5
    mov       [rbp + mx_run.writerelocs.newr+7],	al
    jmp       L4776
L4777:
    lea       rcx,	[L12733]
    call      mc_libmcl.axerror
L4776:
    jmp       L4772
L4774:
    mov       al,	[rsi+80]
    test      al,	al
    jz        L4779
    mov       rax,	[rdi+8]
    cmp       rax,	2
    jnz       L4781
    mov       rax,	3
    jmp       L4780
L4781:
    mov       rax,	4
L4780:
    mov       [rbp + mx_run.writerelocs.newr+7],	al
    mov       ax,	[rsi+116]
    mov       [rbp + mx_run.writerelocs.newr+4],	ax
    jmp       L4778
L4779:
    mov       rax,	[rdi+8]
    cmp       rax,	2
    jnz       L4783
    mov       al,	1
    mov       [rbp + mx_run.writerelocs.newr+7],	al
    jmp       L4782
L4783:
    mov       al,	2
    mov       [rbp + mx_run.writerelocs.newr+7],	al
L4782:
    mov       al,	[rsi+94]
    mov       [rbp + mx_run.writerelocs.newr+4],	al
L4778:
    jmp       L4772
L4775:
    lea       rcx,	[L12734]
    call      mc_libmcl.axerror
L4772:
    mov       rax,	[r14+88]
    inc       rbx
    mov       r10,	rbx
    mov       r11,	[rbp + mx_run.writerelocs.newr]
    mov       [rax + r10*8-8],	r11
    mov       rdi,	[rdi]
L4769:
    test      rdi,	rdi
    jnz       L4766
    inc       r13
    cmp       r13,	2
    jle       L4761
;---------------
    add       rsp,	48
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_run.addsymbols
mx_run.addsymbols:
;?>>
   %define R.lib r14
   %define R.d rdi
   %define R.stentry rbx
   %define R.epoffset rsi
   %define R.k r12
   %define R.i r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       r14,	rcx
;---------------
    xor       rbx,	rbx
    mov       rax,	-1
    mov       rsi,	rax
    mov       rax,	[mx_decls.nsymimports]
    mov       [r14+56],	rax
    mov       rax,	[mx_decls.nsymexports]
    mov       [r14+64],	rax
    mov       rax,	[mx_decls.nsymimports]
    shl       rax,	3
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [r14+112],	rax
    mov       rax,	[mx_decls.nsymexports]
    shl       rax,	3
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [r14+120],	rax
    mov       rcx,	[mx_decls.nsymexports]
    call      mlib.pcm_alloc
    mov       [r14+128],	rax
    mov       rax,	[mx_decls.nsymexports]
    shl       rax,	3
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [r14+136],	rax
    xor       r12,	r12
    mov       rax,	1
    mov       r13,	rax
    mov       rax,	[mc_decls.ss_nsymbols]
    cmp       rax,	1
    jl        L4787
L4785:
    mov       rax,	[mc_decls.ss_symboltable]
    mov       r10,	r13
    mov       rax,	[rax + r10*8-8]
    mov       ax,	[rax+116]
    test      ax,	ax
    jz        L4789
    mov       rax,	[mc_decls.ss_symboltable]
    mov       r10,	r13
    mov       rdi,	[rax + r10*8-8]
    mov       rax,	[rdi]
    mov       r10,	[r14+112]
    inc       r12
    mov       r11,	r12
    mov       [r10 + r11*8-8],	rax
L4789:
    inc       r13
    cmp       r13,	[mc_decls.ss_nsymbols]
    jle       L4785
L4787:
    xor       r12,	r12
    mov       rax,	1
    mov       r13,	rax
    mov       rax,	[mc_decls.ss_nsymbols]
    cmp       rax,	1
    jl        L4792
L4790:
    mov       rax,	[mc_decls.ss_symboltable]
    mov       r10,	r13
    mov       rdi,	[rax + r10*8-8]
    mov       ax,	[rdi+118]
    test      ax,	ax
    jz        L4794
    mov       al,	[rdi+83]
    test      al,	al
    jz        L4796
    mov       rbx,	rdi
L4796:
    mov       rax,	[rdi]
    mov       r10,	[r14+120]
    inc       r12
    mov       r11,	r12
    mov       [r10 + r11*8-8],	rax
    mov       al,	[rdi+94]
    mov       r10,	[r14+128]
    mov       r11,	r12
    mov       [r10 + r11-1],	al
    movsxd    rax,	dword [rdi+76]
    mov       r10,	[r14+136]
    mov       r11,	r12
    mov       [r10 + r11*8-8],	rax
L4794:
    inc       r13
    cmp       r13,	[mc_decls.ss_nsymbols]
    jle       L4790
L4792:
    test      rbx,	rbx
    jz        L4798
    movsxd    rax,	dword [rbx+76]
    mov       [r14+144],	rax
    jmp       L4797
L4798:
    call      msys.m$print_startcon
    lea       rcx,	[L12735]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rax,	-1
    mov       [r14+144],	rax
L4797:
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_run.countsymbols
mx_run.countsymbols:
;?>>
   %define R.d rdi
   %define R.i rbx
    push      rdi
    push      rbx
;?]]
;---------------
    mov       rbx,	1
    mov       rax,	[mc_decls.ss_nsymbols]
    cmp       rax,	1
    jl        L4802
L4800:
    mov       rax,	[mc_decls.ss_symboltable]
    mov       r10,	rbx
    mov       rdi,	[rax + r10*8-8]
    mov       al,	[rdi+81]
    test      al,	al
    jz        L4804
    inc       qword [mx_decls.nsymexports]
    mov       rax,	[mx_decls.nsymexports]
    mov       [rdi+118],	ax
L4804:
    mov       al,	[rdi+80]
    test      al,	al
    jz        L4806
    inc       qword [mx_decls.nsymimports]
    mov       rax,	[mx_decls.nsymimports]
    mov       [rdi+116],	ax
L4806:
    inc       rbx
    cmp       rbx,	[mc_decls.ss_nsymbols]
    jle       L4800
L4802:
;---------------
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_run.runlibfile
mx_run.runlibfile:
;?>>
   %define R.filename rbx
   %define R.cmdskip rsi
   %define R.plib rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    mov       rcx,	rbx
    call      mx_run.writememlib
    mov       rdi,	rax
    mov       rcx,	rdi
    call      mx_lib.loadmemmcu
    mov       rcx,	rdi
    call      mx_lib.fixuplib
    mov       rcx,	rdi
    mov       rdx,	rsi
    call      mx_lib.runprogram
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_lib.readlibfile
mx_lib.readlibfile:
;?>>
   %define R.filespec r14
    %define mx_lib.readlibfile.p 72
   %define R.plib rdi
    %define mx_lib.readlibfile.lib -216
   %define R.sig rbx
   %define R.dir rsi
   %define R.n r12
   %define R.i r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	256
    mov       r14,	rcx
    mov       [rbp+72],	rdx
;---------------
    lea       rax,	[rbp + mx_lib.readlibfile.lib]
    xor       r10d,	r10d
    mov       r11,	27
L12736:
    mov       [rax],	r10
    add       rax,	8
    dec       r11
    jnz       L12736
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       rbx,	rax
    cmp       rbx,	441992013
    jz        L4810
    call      msys.m$print_startcon
    lea       rcx,	[L12737]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	1
    call      exit
L4810:
    mov       rcx,	r14
    call      mlib.pcm_copyheapstring
    mov       [rbp + mx_lib.readlibfile.lib+184],	rax
    mov       rcx,	r14
    call      mlib.extractbasefile
    mov       rcx,	rax
    call      mlib.pcm_copyheapstring
    mov       [rbp + mx_lib.readlibfile.lib+192],	rax
L4811:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readbyte
    mov       rsi,	rax
    cmp       rax,	14
    jae       L4814
    lea       r10,	[L4813]
    jmp       [r10 + rax*8]
    segment .data
L4813:
    dq  L4846
    dq  L4815
    dq  L4818
    dq  L4817
    dq  L4816
    dq  L4843
    dq  L4819
    dq  L4823
    dq  L4827
    dq  L4831
    dq  L4835
    dq  L4839
    dq  L4844
    dq  L4845
    segment .text
L4815:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readstring
    mov       [rbp + mx_lib.readlibfile.lib],	rax
    jmp       L4811
L4816:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       [rbp + mx_lib.readlibfile.lib+24],	rax
    jmp       L4811
L4817:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       r12,	rax
    mov       [rbp + mx_lib.readlibfile.lib+16],	rax
    mov       rcx,	r12
    call      mlib.pcm_alloc
    mov       [rbp + mx_lib.readlibfile.lib+80],	rax
    mov       rax,	[rbp + mx_lib.readlibfile.lib+80]
    mov       rcx,	rax
    mov       rdx,	[rbp + mx_lib.readlibfile.p]
    mov       r8,	r12
    call      memcpy
    mov       rax,	r12
    add       [rbp + mx_lib.readlibfile.p],	rax
    jmp       L4811
L4818:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       r12,	rax
    mov       [rbp + mx_lib.readlibfile.lib+8],	rax
    mov       rax,	[rbp + mx_lib.readlibfile.p]
    mov       [rbp + mx_lib.readlibfile.lib+72],	rax
    mov       rax,	r12
    add       [rbp + mx_lib.readlibfile.p],	rax
    jmp       L4811
L4819:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       r12,	rax
    mov       [rbp + mx_lib.readlibfile.lib+40],	rax
    mov       rax,	8
    imul      rax,	r12
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [rbp + mx_lib.readlibfile.lib+96],	rax
    mov       r13,	1
    cmp       r12,	1
    jl        L4822
L4820:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readstring
    mov       r10,	[rbp + mx_lib.readlibfile.lib+96]
    mov       r11,	r13
    mov       [r10 + r11*8-8],	rax
    inc       r13
    cmp       r13,	r12
    jle       L4820
L4822:
    jmp       L4811
L4823:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       r12,	rax
    mov       [rbp + mx_lib.readlibfile.lib+48],	rax
    mov       rax,	8
    imul      rax,	r12
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [rbp + mx_lib.readlibfile.lib+104],	rax
    mov       r13,	1
    cmp       r12,	1
    jl        L4826
L4824:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readstring
    mov       r10,	[rbp + mx_lib.readlibfile.lib+104]
    mov       r11,	r13
    mov       [r10 + r11*8-8],	rax
    inc       r13
    cmp       r13,	r12
    jle       L4824
L4826:
    jmp       L4811
L4827:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       r12,	rax
    mov       [rbp + mx_lib.readlibfile.lib+56],	rax
    mov       rax,	8
    imul      rax,	r12
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [rbp + mx_lib.readlibfile.lib+112],	rax
    mov       r13,	1
    cmp       r12,	1
    jl        L4830
L4828:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readstring
    mov       r10,	[rbp + mx_lib.readlibfile.lib+112]
    mov       r11,	r13
    mov       [r10 + r11*8-8],	rax
    inc       r13
    cmp       r13,	r12
    jle       L4828
L4830:
    jmp       L4811
L4831:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       r12,	rax
    mov       [rbp + mx_lib.readlibfile.lib+64],	rax
    mov       rax,	8
    imul      rax,	r12
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [rbp + mx_lib.readlibfile.lib+120],	rax
    mov       r13,	1
    cmp       r12,	1
    jl        L4834
L4832:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readstring
    mov       r10,	[rbp + mx_lib.readlibfile.lib+120]
    mov       r11,	r13
    mov       [r10 + r11*8-8],	rax
    inc       r13
    cmp       r13,	r12
    jle       L4832
L4834:
    jmp       L4811
L4835:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       r12,	rax
    mov       rcx,	r12
    call      mlib.pcm_alloc
    mov       [rbp + mx_lib.readlibfile.lib+128],	rax
    mov       r13,	1
    cmp       r12,	1
    jl        L4838
L4836:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readbyte
    mov       r10,	[rbp + mx_lib.readlibfile.lib+128]
    mov       r11,	r13
    mov       [r10 + r11-1],	al
    inc       r13
    cmp       r13,	r12
    jle       L4836
L4838:
    jmp       L4811
L4839:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       r12,	rax
    mov       rax,	8
    imul      rax,	r12
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [rbp + mx_lib.readlibfile.lib+136],	rax
    mov       r13,	1
    cmp       r12,	1
    jl        L4842
L4840:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       r10,	[rbp + mx_lib.readlibfile.lib+136]
    mov       r11,	r13
    mov       [r10 + r11*8-8],	rax
    inc       r13
    cmp       r13,	r12
    jle       L4840
L4842:
    jmp       L4811
L4843:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       r12,	rax
    mov       [rbp + mx_lib.readlibfile.lib+32],	rax
    mov       rax,	[rbp + mx_lib.readlibfile.lib+32]
    shl       rax,	3
    mov       r12,	rax
    mov       rcx,	r12
    call      mlib.pcm_alloc
    mov       [rbp + mx_lib.readlibfile.lib+88],	rax
    mov       rax,	[rbp + mx_lib.readlibfile.lib+88]
    mov       rcx,	rax
    mov       rdx,	[rbp + mx_lib.readlibfile.p]
    mov       r8,	r12
    call      memcpy
    mov       rax,	r12
    add       [rbp + mx_lib.readlibfile.p],	rax
    jmp       L4811
L4844:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       [rbp + mx_lib.readlibfile.lib+144],	rax
    jmp       L4811
L4845:
    jmp       L4812
L4846:
    jmp       L4811
L4814:
    call      msys.m$print_startcon
    lea       rcx,	[L12738]
    call      msys.m$print_str_nf
    lea       rax,	[mx_decls.mcxdirnames]
    mov       r10,	rsi
    mov       rcx,	[rax + r10*8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    xor       ecx,	ecx
    call      exit
    jmp       L4811
L4812:
    mov       rcx,	216
    call      mlib.pcm_allocnfz
    mov       rdi,	rax
    mov       rcx,	rdi
    lea       rdx,	[rbp + mx_lib.readlibfile.lib]
    mov       r8,	216
    call      memcpy
    mov       rax,	rdi
L4808:
;---------------
    add       rsp,	256
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_lib.readbyte
mx_lib.readbyte:
;?>>
   %define R.p rcx
;?]]
;---------------
    mov       rax,	rcx
    mov       r10,	[rax]
    inc       qword [rax]
    movzx     r10,	byte [r10]
    mov       rax,	r10
L4847:
;---------------
    ret       
;End 
;Proc mx_lib.readu32
mx_lib.readu32:
;?>>
   %define R.p rcx
   %define R.x rdi
    push      rdi
;?]]
    sub       rsp,	16
;---------------
    mov       rax,	[rcx]
    mov       eax,	[rax]
    mov       rdi,	rax
    mov       rax,	rcx
    add       qword [rax],	4
    mov       rax,	rdi
L4848:
;---------------
    add       rsp,	16
    pop       rdi
    ret       
;End 
;Proc mx_lib.readstring
mx_lib.readstring:
;?>>
   %define R.p rbx
   %define R.s rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rax,	[rbx]
    mov       rcx,	rax
    call      mlib.pcm_copyheapstring
    mov       rdi,	rax
L4850:
L4851:
    mov       rax,	rbx
    inc       qword [rax]
    mov       rax,	[rax]
    mov       al,	[rax]
    test      al,	al
    jnz       L4850
    mov       rax,	rbx
    inc       qword [rax]
    mov       rax,	rdi
L4849:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_lib.alloclibdata
mx_lib.alloclibdata:
;?>>
   %define R.lib r12
   %define R.tablesize rdi
   %define R.n rbx
   %define R.p rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       r12,	rcx
;---------------
    mov       rax,	[r12+24]
    mov       rcx,	rax
    call      mlib.pcm_allocz
    mov       [r12+152],	rax
    mov       rax,	[r12+56]
    shl       rax,	4
    mov       rdi,	rax
    mov       rbx,	[r12+8]
    mov       rax,	rbx
    add       rax,	rdi
    mov       rcx,	rax
    call      mwindows.os_allocexecmem
    mov       rsi,	rax
    test      rsi,	rsi
    jnz       L4855
    lea       rcx,	[L12739]
    lea       rdx,	[L12740]
    call      mx_lib.error
L4855:
    mov       rax,	[r12+72]
    mov       rcx,	rsi
    mov       rdx,	rax
    mov       r8,	rbx
    call      memcpy
    lea       rax,	[rsi + rbx]
    mov       rcx,	rax
    xor       edx,	edx
    mov       r8,	rdi
    call      memset
    mov       [r12+72],	rsi
    mov       [r12+160],	rdi
    mov       rax,	[r12+64]
    mov       r10,	8
    imul      r10,	rax
    mov       rcx,	r10
    call      mlib.pcm_alloc
    mov       [r12+168],	rax
    mov       rax,	[r12+56]
    mov       r10,	2
    imul      r10,	rax
    mov       rcx,	r10
    call      mlib.pcm_alloc
    mov       [r12+176],	rax
    mov       rax,	[r12+144]
    mov       r10,	4294967295
    cmp       rax,	r10
    jz        L4857
    mov       rax,	[r12+72]
    mov       r10,	[r12+144]
    lea       rax,	[rax + r10]
    mov       [r12+200],	rax
L4857:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_lib.error
mx_lib.error:
;?>>
   %define R.mess rdi
   %define R.param rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       al,	[rbx]
    test      al,	al
    jz        L4860
    call      msys.m$print_startcon
    mov       rcx,	rdi
    call      msys.m$print_setfmt
    mov       rcx,	rbx
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L4859
L4860:
    call      msys.m$print_startcon
    mov       rcx,	rdi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L4859:
    call      msys.m$print_startcon
    lea       rcx,	[L12741]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	1
    call      exit
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_lib.loadmemmcu
mx_lib.loadmemmcu:
;?>>
   %define R.lib rsi
   %define R.newlib rdi
   %define R.name rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    mov       rbx,	[rsi+192]
    mov       rax,	[rsi+184]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mx_lib.checknew
    mov       rcx,	rbx
    call      mx_lib.mxaddlib
    mov       rdi,	rax
    mov       rax,	rsi
    lea       r10,	[mx_decls.libtable]
    mov       r11,	rdi
    mov       [r10 + r11*8-8],	rax
    mov       rcx,	rsi
    call      mx_lib.loadimports
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_lib.checknew
mx_lib.checknew:
;?>>
   %define R.name rdi
   %define R.filename rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rdi
    call      mx_lib.findlib
    test      rax,	rax
    jz        L4864
    lea       rcx,	[L12742]
    mov       rdx,	rbx
    call      mx_lib.error
L4864:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_lib.findlib
mx_lib.findlib:
;?>>
   %define R.name rbx
   %define R.i rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rdi,	1
    mov       rax,	[mx_decls.nlibs]
    cmp       rax,	1
    jl        L4868
L4866:
    lea       rax,	[mx_decls.libnametable]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mlib.eqstring
    test      rax,	rax
    jz        L4870
    mov       rax,	rdi
    jmp       L4865
L4870:
    inc       rdi
    cmp       rdi,	[mx_decls.nlibs]
    jle       L4866
L4868:
    xor       eax,	eax
L4865:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_lib.mxaddlib
mx_lib.mxaddlib:
;?>>
   %define R.name rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rax,	[mx_decls.nlibs]
    cmp       rax,	20
    jl        L4873
    lea       rcx,	[L12743]
    lea       rdx,	[L12744]
    call      mx_lib.error
L4873:
    inc       qword [mx_decls.nlibs]
    mov       rax,	[mx_decls.nlibs]
    mov       r10,	rdi
    lea       r11,	[mx_decls.libnametable]
    mov       [r11 + rax*8-8],	r10
    mov       rax,	[mx_decls.nlibs]
L4871:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mx_lib.fixuplib
mx_lib.fixuplib:
;?>>
    %define mx_lib.fixuplib.lib 16
;?]]
    sub       rsp,	40
;---------------
    call      mx_lib.loaddlls
    call      mx_lib.checksymbols
    call      mx_lib.dorelocations
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mx_lib.loaddlls
mx_lib.loaddlls:
;?>>
   %define R.inst rdi
   %define R.i rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
;---------------
    mov       rbx,	1
    mov       rax,	[mx_decls.ndlllibs]
    cmp       rax,	1
    jl        L4878
L4876:
    lea       rax,	[mx_decls.dllinsttable]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8-8]
    test      rax,	rax
    jnz       L4880
    lea       rax,	[mx_decls.dllnametable]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rax
    call      mwindows.os_getdllinst
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L4882
    lea       rax,	[mx_decls.dllnametable]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8-8]
    lea       rcx,	[L12745]
    mov       rdx,	rax
    call      mx_lib.error
L4882:
    mov       rax,	rdi
    lea       r10,	[mx_decls.dllinsttable]
    mov       r11,	rbx
    mov       [r10 + r11*8-8],	rax
L4880:
    inc       rbx
    cmp       rbx,	[mx_decls.ndlllibs]
    jle       L4876
L4878:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_lib.finddllsymbol
mx_lib.finddllsymbol:
;?>>
   %define R.name rsi
   %define R.dllindex r12
   %define R.p rdi
   %define R.i rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    xor       eax,	eax
    mov       [r12],	rax
    mov       rbx,	1
    mov       rax,	[mx_decls.ndlllibs]
    cmp       rax,	1
    jl        L4886
L4884:
    lea       rax,	[mx_decls.dllinsttable]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rax
    mov       rdx,	rsi
    call      mwindows.os_getdllprocaddr
    mov       rdi,	rax
    test      rdi,	rdi
    jz        L4888
    mov       [r12],	rbx
    mov       rax,	rdi
    jmp       L4883
L4888:
    inc       rbx
    cmp       rbx,	[mx_decls.ndlllibs]
    jle       L4884
L4886:
    xor       eax,	eax
L4883:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_lib.checksymbols
mx_lib.checksymbols:
;?>>
    %define mx_lib.checksymbols.dllindex -8
   %define R.undef rdi
   %define R.p rbx
   %define R.i rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
;---------------
    xor       rdi,	rdi
    mov       rax,	1
    mov       rsi,	rax
    mov       rax,	[mx_decls.nsymbols]
    cmp       rax,	1
    jl        L4892
L4890:
    lea       rax,	[mx_decls.symboldefined]
    mov       r10,	rsi
    mov       al,	[rax + r10-1]
    test      al,	al
    jnz       L4894
    lea       rax,	[mx_decls.symbolnametable]
    mov       r10,	rsi
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rax
    lea       rdx,	[rbp + mx_lib.checksymbols.dllindex]
    call      mx_lib.finddllsymbol
    mov       rbx,	rax
    test      rbx,	rbx
    jz        L4896
    mov       rax,	rbx
    lea       r10,	[mx_decls.symboladdress]
    mov       r11,	rsi
    mov       [r10 + r11*8-8],	rax
    mov       al,	[rbp + mx_lib.checksymbols.dllindex]
    lea       r10,	[mx_decls.symboldllindex]
    mov       r11,	rsi
    mov       [r10 + r11-1],	al
    mov       al,	1
    lea       r10,	[mx_decls.symboldefined]
    mov       r11,	rsi
    mov       [r10 + r11-1],	al
    jmp       L4895
L4896:
    call      msys.m$print_startcon
    lea       rcx,	[L12746]
    call      msys.m$print_str_nf
    lea       rax,	[mx_decls.symbolnametable]
    mov       r10,	rsi
    mov       rcx,	[rax + r10*8-8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    inc       rdi
L4895:
L4894:
    inc       rsi
    cmp       rsi,	[mx_decls.nsymbols]
    jle       L4890
L4892:
    test      rdi,	rdi
    jz        L4898
L4898:
;---------------
    add       rsp,	40
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_lib.dorelocations
mx_lib.dorelocations:
;?>>
   %define R.i rdi
    push      rdi
;?]]
    sub       rsp,	48
;---------------
    mov       rdi,	1
    mov       rax,	[mx_decls.nlibs]
    cmp       rax,	1
    jl        L4902
L4900:
    lea       rax,	[mx_decls.librelocated]
    mov       r10,	rdi
    mov       al,	[rax + r10-1]
    test      al,	al
    jnz       L4904
    lea       rax,	[mx_decls.libtable]
    mov       r10,	rdi
    mov       rcx,	[rax + r10*8-8]
    call      mx_lib.reloclib
L4904:
    inc       rdi
    cmp       rdi,	[mx_decls.nlibs]
    jle       L4900
L4902:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mx_lib.reloclib
mx_lib.reloclib:
;?>>
    %define mx_lib.reloclib.lib 72
   %define R.index rdi
   %define R.targetoffset rbx
   %define R.name rsi
   %define R.p r12
   %define R.q r13
   %define R.qaddr r14
    %define mx_lib.reloclib.r -8
   %define R.av_1 r15
    %define mx_lib.reloclib.av_2 -16
    %define mx_lib.reloclib.i -24
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
    mov       [rbp+72],	rcx
;---------------
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       rax,	[rax+72]
    mov       r10,	[rbp + mx_lib.reloclib.lib]
    mov       r10,	[r10+8]
    lea       rax,	[rax + r10]
    mov       r12,	rax
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       rax,	[rax+56]
    shl       rax,	3
    lea       r10,	[r12 + rax]
    mov       r14,	r10
    mov       rax,	1
    mov       [rbp + mx_lib.reloclib.i],	rax
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       r15,	[rax+56]
    cmp       r15,	1
    jl        L4908
L4906:
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       rax,	[rax+112]
    mov       r10,	[rbp + mx_lib.reloclib.i]
    mov       rsi,	[rax + r10*8-8]
    mov       rax,	r12
    inc       r12
    mov       r10b,	72
    mov       [rax],	r10b
    mov       rax,	r12
    inc       r12
    mov       r10b,	255
    mov       [rax],	r10b
    mov       rax,	r12
    inc       r12
    mov       r10b,	36
    mov       [rax],	r10b
    mov       rax,	r12
    inc       r12
    mov       r10b,	37
    mov       [rax],	r10b
    mov       [r12],	r14d
    add       r12,	4
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       rax,	[rax+176]
    mov       r10,	[rbp + mx_lib.reloclib.i]
    movsx     rax,	word [rax + r10*2-2]
    mov       rdi,	rax
    lea       rax,	[mx_decls.symboladdress]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    mov       r10,	r14
    add       r14,	8
    mov       [r10],	rax
    mov       rax,	[rbp + mx_lib.reloclib.i]
    inc       rax
    mov       [rbp + mx_lib.reloclib.i],	rax
    cmp       rax,	r15
    jle       L4906
L4908:
    mov       rax,	1
    mov       [rbp + mx_lib.reloclib.i],	rax
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       rax,	[rax+32]
    mov       [rbp + mx_lib.reloclib.av_2],	rax
    mov       rax,	[rbp + mx_lib.reloclib.av_2]
    cmp       rax,	1
    jl        L4911
L4909:
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       rax,	[rax+88]
    mov       r10,	[rbp + mx_lib.reloclib.i]
    mov       rax,	[rax + r10*8-8]
    mov       [rbp + mx_lib.reloclib.r],	rax
    movzx     rax,	byte [rbp + mx_lib.reloclib.r+6]
    cmp       rax,	1
    jz        L4913
    cmp       rax,	2
    jz        L4914
    cmp       rax,	3
    jz        L4915
    jmp       L4916
L4913:
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       rax,	[rax+72]
    mov       r10d,	[rbp + mx_lib.reloclib.r]
    lea       rax,	[rax + r10]
    mov       r12,	rax
    jmp       L4912
L4914:
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       rax,	[rax+80]
    mov       r10d,	[rbp + mx_lib.reloclib.r]
    lea       rax,	[rax + r10]
    mov       r12,	rax
    jmp       L4912
L4915:
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       rax,	[rax+152]
    mov       r10d,	[rbp + mx_lib.reloclib.r]
    lea       rax,	[rax + r10]
    mov       r12,	rax
L4916:
L4912:
    movzx     rax,	byte [rbp + mx_lib.reloclib.r+7]
    cmp       rax,	1
    jz        L4918
    cmp       rax,	2
    jz        L4919
    cmp       rax,	4
    jz        L4920
    cmp       rax,	3
    jz        L4921
    cmp       rax,	5
    jz        L4922
    jmp       L4923
L4918:
    mov       eax,	[r12]
    mov       rbx,	rax
    movzx     rax,	byte [rbp + mx_lib.reloclib.r+4]
    cmp       rax,	1
    jz        L4925
    cmp       rax,	2
    jz        L4926
    cmp       rax,	3
    jz        L4927
    jmp       L4928
L4925:
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       rax,	[rax+72]
    mov       r10,	rbx
    lea       rax,	[rax + r10]
    mov       [r12],	eax
    jmp       L4924
L4926:
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       rax,	[rax+80]
    mov       r10,	rbx
    lea       rax,	[rax + r10]
    mov       [r12],	eax
    jmp       L4924
L4927:
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       rax,	[rax+152]
    mov       r10,	rbx
    lea       rax,	[rax + r10]
    mov       [r12],	eax
L4928:
L4924:
    jmp       L4917
L4919:
    mov       eax,	[r12]
    mov       rbx,	rax
    movzx     rax,	byte [rbp + mx_lib.reloclib.r+4]
    cmp       rax,	1
    jz        L4930
    cmp       rax,	2
    jz        L4931
    cmp       rax,	3
    jz        L4932
    jmp       L4933
L4930:
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       rax,	[rax+72]
    mov       r10,	rbx
    lea       rax,	[rax + r10]
    mov       [r12],	rax
    jmp       L4929
L4931:
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       rax,	[rax+80]
    mov       r10,	rbx
    lea       rax,	[rax + r10]
    mov       [r12],	rax
    jmp       L4929
L4932:
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       rax,	[rax+152]
    mov       r10,	rbx
    lea       rax,	[rax + r10]
    mov       [r12],	rax
L4933:
L4929:
    jmp       L4917
L4920:
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       rax,	[rax+176]
    movzx     r10,	word [rbp + mx_lib.reloclib.r+4]
    movsx     rax,	word [rax + r10*2-2]
    mov       rdi,	rax
    lea       rax,	[mx_decls.symboladdress]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    mov       r10,	r12
    add       [r10],	rax
    jmp       L4917
L4921:
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       rax,	[rax+176]
    movzx     r10,	word [rbp + mx_lib.reloclib.r+4]
    movsx     rax,	word [rax + r10*2-2]
    mov       rdi,	rax
    lea       rax,	[mx_decls.symboladdress]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    mov       r10,	r12
    add       [r10],	eax
    jmp       L4917
L4922:
    movzx     rax,	byte [rbp + mx_lib.reloclib.r+6]
    cmp       rax,	1
    jz        L4935
    lea       rcx,	[L12747]
    lea       rdx,	[L12748]
    call      mx_lib.error
L4935:
    movzx     rax,	word [rbp + mx_lib.reloclib.r+4]
    mov       rdi,	rax
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       rax,	[rax+72]
    mov       r10,	[rbp + mx_lib.reloclib.lib]
    mov       r10,	[r10+8]
    lea       rax,	[rax + r10]
    lea       r10,	[rdi-1]
    shl       r10,	3
    lea       rax,	[rax + r10]
    mov       r13,	rax
    lea       rax,	[r12+4]
    mov       r10,	r13
    sub       r10,	rax
    mov       [r12],	r10d
L4923:
L4917:
    mov       rax,	[rbp + mx_lib.reloclib.i]
    inc       rax
    mov       [rbp + mx_lib.reloclib.i],	rax
    cmp       rax,	[rbp + mx_lib.reloclib.av_2]
    jle       L4909
L4911:
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       rax,	[rax+208]
    mov       r10b,	1
    lea       r11,	[mx_decls.librelocated]
    mov       [r11 + rax-1],	r10b
;---------------
    add       rsp,	56
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_lib.loadimports
mx_lib.loadimports:
;?>>
   %define R.plib rsi
   %define R.av_1 rdi
   %define R.i rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    mov       rbx,	1
    mov       rdi,	[rsi+48]
    cmp       rdi,	1
    jl        L4939
L4937:
    mov       rax,	[rsi+104]
    mov       r10,	rbx
    mov       rcx,	[rax + r10*8-8]
    call      mx_lib.dosublib
    inc       rbx
    cmp       rbx,	rdi
    jle       L4937
L4939:
    mov       rcx,	rsi
    call      mx_lib.alloclibdata
    mov       rcx,	rsi
    call      mx_lib.dosymbols
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_lib.dosublib
mx_lib.dosublib:
;?>>
   %define R.name rsi
   %define R.qlib rdi
   %define R.n rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    mov       rcx,	rsi
    call      mx_lib.findlib
    mov       rbx,	rax
    test      rbx,	rbx
    jnz       L4942
    mov       rcx,	rsi
    call      mx_lib.mxaddlib
    mov       rbx,	rax
    call      msys.m$print_startcon
    lea       rcx,	[L12749]
    call      msys.m$print_str_nf
    mov       rcx,	rsi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	rsi
    lea       rdx,	[L12750]
    call      mlib.addext
    mov       rcx,	rax
    mov       rdx,	rbx
    call      mx_lib.loadlibfile
    mov       rdi,	rax
    mov       rcx,	rdi
    call      mx_lib.loadimports
L4942:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_lib.loadlibfile
mx_lib.loadlibfile:
;?>>
   %define R.filename rsi
   %define R.libno r12
   %define R.plib rdi
   %define R.p rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    mov       rcx,	rsi
    call      mx_lib.readmxfile
    mov       rbx,	rax
    test      rbx,	rbx
    jnz       L4945
    lea       rcx,	[L12751]
    mov       rdx,	rsi
    call      mx_lib.error
L4945:
    mov       rcx,	rsi
    mov       rdx,	rbx
    call      mx_lib.readlibfile
    mov       rdi,	rax
    mov       [rdi+208],	r12
    mov       rax,	rdi
    lea       r10,	[mx_decls.libtable]
    mov       r11,	r12
    mov       [r10 + r11*8-8],	rax
L4943:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_lib.dosymbols
mx_lib.dosymbols:
;?>>
   %define R.lib r15
   %define R.ix rdi
   %define R.baseaddr rbx
   %define R.av_1 rsi
   %define R.av_2 r12
   %define R.av_3 r13
   %define R.i r14
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    sub       rsp,	48
    mov       r15,	rcx
;---------------
    mov       r14,	1
    mov       rsi,	[r15+40]
    cmp       rsi,	1
    jl        L4949
L4947:
    mov       rax,	[r15+96]
    mov       r10,	r14
    mov       rcx,	[rax + r10*8-8]
    call      mx_lib.adddll
    inc       r14
    cmp       r14,	rsi
    jle       L4947
L4949:
    mov       r14,	1
    mov       r12,	[r15+56]
    cmp       r12,	1
    jl        L4952
L4950:
    mov       rax,	[r15+112]
    mov       r10,	r14
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rax
    call      mx_lib.addsymbol
    mov       rdi,	rax
    mov       rax,	[r15+176]
    mov       r10w,	di
    mov       r11,	r14
    mov       [rax + r11*2-2],	r10w
    inc       r14
    cmp       r14,	r12
    jle       L4950
L4952:
    mov       r14,	1
    mov       r13,	[r15+64]
    cmp       r13,	1
    jl        L4955
L4953:
    mov       rax,	[r15+120]
    mov       r10,	r14
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rax
    call      mx_lib.addsymbol
    mov       rdi,	rax
    lea       rax,	[mx_decls.symboldefined]
    mov       r10,	rdi
    mov       al,	[rax + r10-1]
    test      al,	al
    jz        L4957
    call      msys.m$print_startcon
    lea       rcx,	[L12752]
    call      msys.m$print_str_nf
    mov       rax,	[r15+120]
    mov       r10,	r14
    mov       rcx,	[rax + r10*8-8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L4954
L4957:
    mov       al,	1
    lea       r10,	[mx_decls.symboldefined]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
    mov       rax,	[r15+128]
    mov       r10,	r14
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	1
    jz        L4959
    cmp       rax,	2
    jz        L4960
    cmp       rax,	3
    jz        L4961
    jmp       L4962
L4959:
    mov       rbx,	[r15+72]
    jmp       L4958
L4960:
    mov       rbx,	[r15+80]
    jmp       L4958
L4961:
    mov       rbx,	[r15+152]
    jmp       L4958
L4962:
    xor       rbx,	rbx
L4958:
    mov       rax,	[r15+136]
    mov       r10,	r14
    mov       rax,	[rax + r10*8-8]
    lea       r10,	[rbx + rax]
    lea       rax,	[mx_decls.symboladdress]
    mov       r11,	rdi
    mov       [rax + r11*8-8],	r10
    mov       rax,	[r15+208]
    lea       r10,	[mx_decls.symbollibindex]
    mov       r11,	rdi
    mov       [r10 + r11*2-2],	ax
L4954:
    inc       r14
    cmp       r14,	r13
    jle       L4953
L4955:
;---------------
    add       rsp,	48
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_lib.readmxfile
mx_lib.readmxfile:
;?>>
   %define R.filename rbx
   %define R.p rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rcx,	rbx
    call      mlib.readfile
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L4965
    xor       eax,	eax
    jmp       L4963
L4965:
    mov       al,	13
    mov       r10,	[mlib.rfsize]
    mov       [rdi + r10],	al
    mov       rax,	rdi
L4963:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_lib.adddll
mx_lib.adddll:
;?>>
   %define R.name rbx
   %define R.i rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rdi,	1
    mov       rax,	[mx_decls.ndlllibs]
    cmp       rax,	1
    jl        L4969
L4967:
    lea       rax,	[mx_decls.dllnametable]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mlib.eqstring
    test      rax,	rax
    jnz       L4966
L4971:
    inc       rdi
    cmp       rdi,	[mx_decls.ndlllibs]
    jle       L4967
L4969:
    mov       rax,	[mx_decls.ndlllibs]
    cmp       rax,	20
    jl        L4973
    lea       rcx,	[L12753]
    lea       rdx,	[L12754]
    call      mx_lib.error
L4973:
    inc       qword [mx_decls.ndlllibs]
    mov       rax,	[mx_decls.ndlllibs]
    mov       r10,	rbx
    lea       r11,	[mx_decls.dllnametable]
    mov       [r11 + rax*8-8],	r10
L4966:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_lib.addsymbol
mx_lib.addsymbol:
;?>>
   %define R.name rbx
   %define R.i rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rdi,	1
    mov       rax,	[mx_decls.nsymbols]
    cmp       rax,	1
    jl        L4977
L4975:
    lea       rax,	[mx_decls.symbolnametable]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mlib.eqstring
    test      rax,	rax
    jz        L4979
    mov       rax,	rdi
    jmp       L4974
L4979:
    inc       rdi
    cmp       rdi,	[mx_decls.nsymbols]
    jle       L4975
L4977:
    mov       rax,	[mx_decls.nsymbols]
    cmp       rax,	3000
    jl        L4981
    lea       rcx,	[L12755]
    lea       rdx,	[L12756]
    call      mx_lib.error
L4981:
    inc       qword [mx_decls.nsymbols]
    mov       rax,	[mx_decls.nsymbols]
    mov       r10,	rbx
    lea       r11,	[mx_decls.symbolnametable]
    mov       [r11 + rax*8-8],	r10
    mov       rax,	[mx_decls.nsymbols]
L4974:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_lib.setspecialglobals
mx_lib.setspecialglobals:
;?>>
   %define R.cmdskip rbx
   %define R.i rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rdi,	1
    mov       rax,	[mx_decls.nsymbols]
    cmp       rax,	1
    jl        L4985
L4983:
    lea       rax,	[mx_decls.symbolnametable]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rax
    lea       rdx,	[L12757]
    call      mlib.eqstring
    test      rax,	rax
    jnz       L4988
    lea       rax,	[mx_decls.symbolnametable]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rax
    lea       rdx,	[L12758]
    call      mlib.eqstring
    test      rax,	rax
    jz        L4987
L4988:
    lea       rax,	[mx_decls.symboladdress]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    mov       r10b,	bl
    mov       [rax],	r10b
L4987:
    inc       rdi
    cmp       rdi,	[mx_decls.nsymbols]
    jle       L4983
L4985:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_lib.runprogram
mx_lib.runprogram:
;?>>
   %define R.lib r12
   %define R.cmdskip r13
   %define R.fnptr rdi
   %define R.libno rbx
   %define R.i rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r12,	rcx
    mov       r13,	rdx
;---------------
    mov       rbx,	[r12+208]
    mov       rsi,	1
    mov       rax,	[mx_decls.nlibs]
    cmp       rax,	1
    jl        L4992
L4990:
    cmp       rsi,	rbx
    jz        L4994
    lea       rax,	[mx_decls.libinitdone]
    mov       r10,	rsi
    mov       al,	[rax + r10-1]
    test      al,	al
    jnz       L4994
    lea       rax,	[mx_decls.libtable]
    mov       r10,	rsi
    mov       rcx,	[rax + r10*8-8]
    call      mx_lib.calllibinit
L4994:
    inc       rsi
    cmp       rsi,	[mx_decls.nlibs]
    jle       L4990
L4992:
    mov       rax,	[r12+200]
    test      rax,	rax
    jnz       L4996
    lea       rcx,	[L12759]
    lea       rdx,	[L12760]
    call      mx_lib.error
L4996:
    mov       rcx,	r13
    call      mx_lib.setspecialglobals
    mov       rdi,	[r12+200]
    mov       rax,	rdi
    call      rax
    mov       al,	1
    lea       r10,	[mx_decls.libinitdone]
    mov       r11,	rbx
    mov       [r10 + r11-1],	al
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_lib.calllibinit
mx_lib.calllibinit:
;?>>
   %define R.lib rsi
   %define R.fnptr rdi
   %define R.libno rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    mov       rbx,	[rsi+208]
    mov       rax,	[rsi+200]
    test      rax,	rax
    jz        L4999
    mov       rdi,	[rsi+200]
    mov       rax,	rdi
    call      rax
L4999:
    mov       rax,	[rsi+208]
    mov       r10b,	1
    lea       r11,	[mx_decls.libinitdone]
    mov       [r11 + rax-1],	r10b
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_lib.findsymbol
mx_lib.findsymbol:
;?>>
   %define R.name rbx
   %define R.i rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rdi,	1
    mov       rax,	[mx_decls.nsymbols]
    cmp       rax,	1
    jl        L5003
L5001:
    lea       rax,	[mx_decls.symbolnametable]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rax
    mov       rdx,	rbx
    call      mlib.eqstring
    test      rax,	rax
    jz        L5005
    lea       rax,	[mx_decls.symboladdress]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    jmp       L5000
L5005:
    inc       rdi
    cmp       rdi,	[mx_decls.nsymbols]
    jle       L5001
L5003:
    xor       eax,	eax
L5000:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_lib.loadmx
mx_lib.loadmx:
;?>>
   %define R.filename r12
   %define R.plib rdi
   %define R.newlib rbx
   %define R.name rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       r12,	rcx
;---------------
    mov       rcx,	r12
    call      mlib.extractbasefile
    mov       rcx,	rax
    call      mlib.convlcstring
    mov       rcx,	rax
    call      mlib.pcm_copyheapstring
    mov       rsi,	rax
    mov       rcx,	rsi
    mov       rdx,	r12
    call      mx_lib.checknew
    mov       rcx,	rsi
    call      mx_lib.mxaddlib
    mov       rbx,	rax
    mov       rcx,	r12
    mov       rdx,	rbx
    call      mx_lib.loadlibfile
    mov       rdi,	rax
    mov       rcx,	rdi
    call      mx_lib.loadimports
    mov       rax,	rdi
L5006:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_lib.loadmemmcb
mx_lib.loadmemmcb:
;?>>
   %define R.filename r12
   %define R.p r13
   %define R.plib rdi
   %define R.newlib rbx
   %define R.name rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r12,	rcx
    mov       r13,	rdx
;---------------
    mov       rcx,	r12
    call      mlib.extractbasefile
    mov       rcx,	rax
    call      mlib.convlcstring
    mov       rcx,	rax
    call      mlib.pcm_copyheapstring
    mov       rsi,	rax
    mov       rcx,	rsi
    mov       rdx,	r12
    call      mx_lib.checknew
    mov       rcx,	rsi
    call      mx_lib.mxaddlib
    mov       rbx,	rax
    mov       rcx,	r12
    mov       rdx,	r13
    call      mx_lib.readlibfile
    mov       rdi,	rax
    mov       [rdi+208],	rbx
    mov       rax,	rdi
    lea       r10,	[mx_decls.libtable]
    mov       r11,	rbx
    mov       [r10 + r11*8-8],	rax
    mov       rcx,	rdi
    call      mx_lib.loadimports
    mov       rax,	rdi
L5007:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_write.writemcx
mx_write.writemcx:
;?>>
   %define R.filename r13
   %define R.n rdi
   %define R.ndlls rbx
   %define R.nlibs rsi
   %define R.i r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r13,	rcx
;---------------
    mov       rcx,	[mc_decls.ss_zdatalen]
    mov       rdx,	8
    call      mlib.roundtoblock
    mov       [mc_decls.ss_zdatalen],	rax
    mov       rcx,	[mc_decls.ss_code]
    mov       rdx,	8
    mov       r8,	144
    call      mx_write.roundsegment
    mov       rcx,	[mc_decls.ss_idata]
    mov       rdx,	8
    xor       r8d,	r8d
    call      mx_write.roundsegment
    mov       rcx,	1024
    call      mc_genss.buffercreate
    mov       [mx_write.dest],	rax
    mov       rcx,	441992013
    call      mx_write.genu32
    mov       rcx,	1
    call      mx_write.genbyte
    lea       rcx,	[L12761]
    call      mx_write.genstring
    call      mx_run.countsymbols
    call      mx_write.writerelocs
    mov       rcx,	4
    call      mx_write.genbyte
    mov       rcx,	[mc_decls.ss_zdatalen]
    call      mx_write.genu32
    mov       rcx,	2
    call      mx_write.genbyte
    mov       rcx,	[mc_decls.ss_code]
    call      mc_genss.bufferlength
    mov       r10,	rax
    mov       rdi,	r10
    mov       rcx,	rax
    call      mx_write.genu32
    mov       rcx,	[mc_decls.ss_code]
    xor       edx,	edx
    call      mc_genss.bufferelemptr
    mov       rcx,	rax
    mov       rdx,	rdi
    call      mx_write.genblock
    mov       rcx,	3
    call      mx_write.genbyte
    mov       rcx,	[mc_decls.ss_idata]
    call      mc_genss.bufferlength
    mov       r10,	rax
    mov       rdi,	r10
    mov       rcx,	rax
    call      mx_write.genu32
    mov       rcx,	[mc_decls.ss_idata]
    xor       edx,	edx
    call      mc_genss.bufferelemptr
    mov       rcx,	rax
    mov       rdx,	rdi
    call      mx_write.genblock
    xor       rbx,	rbx
    xor       eax,	eax
    mov       rsi,	rax
    mov       r12,	1
    mov       rax,	[pc_decls.nplibfiles]
    cmp       rax,	1
    jl        L5011
L5009:
    lea       rax,	[pc_decls.plibfiles]
    mov       r10,	r12
    mov       rax,	[rax + r10*8-8]
    movzx     rax,	byte [rax]
    cmp       rax,	36
    jz        L5013
    inc       rbx
L5013:
    inc       r12
    cmp       r12,	[pc_decls.nplibfiles]
    jle       L5009
L5011:
    mov       rcx,	6
    call      mx_write.genbyte
    mov       rcx,	rbx
    call      mx_write.genu32
    mov       r12,	1
    mov       rax,	[pc_decls.nplibfiles]
    cmp       rax,	1
    jl        L5016
L5014:
    lea       rax,	[pc_decls.plibfiles]
    mov       r10,	r12
    mov       rax,	[rax + r10*8-8]
    movzx     rax,	byte [rax]
    cmp       rax,	36
    jz        L5018
    lea       rax,	[pc_decls.plibfiles]
    mov       r10,	r12
    mov       rcx,	[rax + r10*8-8]
    call      mx_write.genstring
L5018:
    inc       r12
    cmp       r12,	[pc_decls.nplibfiles]
    jle       L5014
L5016:
    call      mx_write.writesymbols
    mov       rcx,	13
    call      mx_write.genbyte
    mov       rax,	[mx_write.dest]
    mov       rax,	[rax+8]
    mov       r10,	[mx_write.dest]
    mov       r10,	[r10]
    sub       rax,	r10
    mov       r10,	[mx_write.dest]
    mov       r10,	[r10]
    mov       rcx,	r13
    mov       rdx,	r10
    mov       r8,	rax
    call      mlib.writefile
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_write.writerelocs
mx_write.writerelocs:
;?>>
   %define R.oldr rdi
    %define mx_write.writerelocs.newr -8
   %define R.n rbx
   %define R.count rsi
   %define R.d r12
   %define R.baseptr64 r13
   %define R.i r14
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    mov       rcx,	5
    call      mx_write.genbyte
    mov       rax,	[mc_decls.ss_nidatarelocs]
    add       rax,	[mc_decls.ss_ncoderelocs]
    mov       r10,	rax
    mov       rbx,	r10
    mov       rcx,	rax
    call      mx_write.genu32
    xor       rsi,	rsi
    mov       rax,	1
    mov       r14,	rax
L5020:
    cmp       r14,	1
    jnz       L5024
    mov       rax,	[mc_decls.ss_idatarelocs]
    jmp       L5023
L5024:
    mov       rax,	[mc_decls.ss_coderelocs]
L5023:
    mov       rdi,	rax
    jmp       L5028
L5025:
    inc       rsi
    lea       rax,	[rbp + mx_write.writerelocs.newr]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       rax,	[rdi+16]
    mov       [rbp + mx_write.writerelocs.newr],	eax
    cmp       r14,	1
    jnz       L5030
    mov       rax,	2
    jmp       L5029
L5030:
    mov       rax,	1
L5029:
    mov       [rbp + mx_write.writerelocs.newr+6],	al
    mov       rax,	[rdi+24]
    mov       r10,	[mc_decls.ss_symboltable]
    mov       r10,	[r10 + rax*8-8]
    mov       r12,	r10
    mov       rax,	[rdi+8]
    cmp       rax,	4
    jz        L5032
    cmp       rax,	2
    jz        L5033
    cmp       rax,	1
    jz        L5033
    jmp       L5034
L5032:
    mov       al,	[r12+80]
    test      al,	al
    jz        L5036
    mov       ax,	[r12+116]
    mov       [rbp + mx_write.writerelocs.newr+4],	ax
    mov       al,	5
    mov       [rbp + mx_write.writerelocs.newr+7],	al
    jmp       L5035
L5036:
    lea       rcx,	[L12762]
    call      mc_libmcl.axerror
L5035:
    jmp       L5031
L5033:
    mov       al,	[r12+80]
    test      al,	al
    jz        L5038
    mov       rax,	[rdi+8]
    cmp       rax,	2
    jnz       L5040
    mov       rax,	3
    jmp       L5039
L5040:
    mov       rax,	4
L5039:
    mov       [rbp + mx_write.writerelocs.newr+7],	al
    mov       ax,	[r12+116]
    mov       [rbp + mx_write.writerelocs.newr+4],	ax
    jmp       L5037
L5038:
    mov       rax,	[rdi+8]
    cmp       rax,	2
    jnz       L5042
    mov       al,	1
    mov       [rbp + mx_write.writerelocs.newr+7],	al
    jmp       L5041
L5042:
    mov       al,	2
    mov       [rbp + mx_write.writerelocs.newr+7],	al
L5041:
    mov       al,	[r12+94]
    mov       [rbp + mx_write.writerelocs.newr+4],	al
L5037:
    jmp       L5031
L5034:
    lea       rcx,	[L12763]
    call      mc_libmcl.axerror
L5031:
    lea       rcx,	[rbp + mx_write.writerelocs.newr]
    mov       rdx,	8
    call      mx_write.genblock
    mov       rdi,	[rdi]
L5028:
    test      rdi,	rdi
    jnz       L5025
    inc       r14
    cmp       r14,	2
    jle       L5020
;---------------
    add       rsp,	48
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_write.writesymbols
mx_write.writesymbols:
;?>>
   %define R.d rdi
   %define R.i rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
;---------------
    mov       rcx,	8
    call      mx_write.genbyte
    mov       rcx,	[mx_decls.nsymimports]
    call      mx_write.genu32
    mov       rbx,	1
    mov       rax,	[mc_decls.ss_nsymbols]
    cmp       rax,	1
    jl        L5046
L5044:
    mov       rax,	[mc_decls.ss_symboltable]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8-8]
    mov       ax,	[rax+116]
    test      ax,	ax
    jz        L5048
    mov       rax,	[mc_decls.ss_symboltable]
    mov       r10,	rbx
    mov       rdi,	[rax + r10*8-8]
    mov       rcx,	[rdi]
    call      mx_write.genstring
L5048:
    inc       rbx
    cmp       rbx,	[mc_decls.ss_nsymbols]
    jle       L5044
L5046:
    mov       rcx,	9
    call      mx_write.genbyte
    mov       rcx,	[mx_decls.nsymexports]
    call      mx_write.genu32
    mov       rbx,	1
    mov       rax,	[mc_decls.ss_nsymbols]
    cmp       rax,	1
    jl        L5051
L5049:
    mov       rax,	[mc_decls.ss_symboltable]
    mov       r10,	rbx
    mov       rdi,	[rax + r10*8-8]
    mov       ax,	[rdi+118]
    test      ax,	ax
    jz        L5053
    mov       al,	[rdi+83]
    test      al,	al
    jz        L5055
    mov       [mx_write.entrypoint],	rdi
L5055:
    mov       rcx,	[rdi]
    call      mx_write.genstring
L5053:
    inc       rbx
    cmp       rbx,	[mc_decls.ss_nsymbols]
    jle       L5049
L5051:
    mov       rcx,	10
    call      mx_write.genbyte
    mov       rcx,	[mx_decls.nsymexports]
    call      mx_write.genu32
    mov       rbx,	1
    mov       rax,	[mc_decls.ss_nsymbols]
    cmp       rax,	1
    jl        L5058
L5056:
    mov       rax,	[mc_decls.ss_symboltable]
    mov       r10,	rbx
    mov       rdi,	[rax + r10*8-8]
    mov       ax,	[rdi+118]
    test      ax,	ax
    jz        L5060
    movzx     rax,	byte [rdi+94]
    mov       rcx,	rax
    call      mx_write.genbyte
L5060:
    inc       rbx
    cmp       rbx,	[mc_decls.ss_nsymbols]
    jle       L5056
L5058:
    mov       rcx,	11
    call      mx_write.genbyte
    mov       rcx,	[mx_decls.nsymexports]
    call      mx_write.genu32
    mov       rbx,	1
    mov       rax,	[mc_decls.ss_nsymbols]
    cmp       rax,	1
    jl        L5063
L5061:
    mov       rax,	[mc_decls.ss_symboltable]
    mov       r10,	rbx
    mov       rdi,	[rax + r10*8-8]
    mov       ax,	[rdi+118]
    test      ax,	ax
    jz        L5065
    movsxd    rax,	dword [rdi+76]
    mov       rcx,	rax
    call      mx_write.genu32
L5065:
    inc       rbx
    cmp       rbx,	[mc_decls.ss_nsymbols]
    jle       L5061
L5063:
    mov       rcx,	12
    call      mx_write.genbyte
    mov       rax,	[mx_write.entrypoint]
    test      rax,	rax
    jz        L5067
    mov       rax,	[mx_write.entrypoint]
    movsxd    rax,	dword [rax+76]
    mov       rcx,	rax
    call      mx_write.genu32
    jmp       L5066
L5067:
    mov       rcx,	4294967295
    call      mx_write.genu32
L5066:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_write.roundsegment
mx_write.roundsegment:
;?>>
   %define R.p r12
   %define R.align r13
   %define R.value r14
   %define R.length rdi
   %define R.newlength rbx
   %define R.av_1 rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       r12,	rcx
    mov       r13,	rdx
    mov       r14,	r8
;---------------
    mov       rcx,	r12
    call      mc_genss.bufferlength
    mov       rdi,	rax
    mov       rcx,	rdi
    mov       rdx,	r13
    call      mlib.roundtoblock
    mov       rbx,	rax
    mov       rcx,	r12
    mov       rdx,	r13
    call      mc_genss.buffercheck
    mov       rax,	rbx
    sub       rax,	rdi
    mov       rsi,	rax
    cmp       rsi,	0
    jle       L5071
L5069:
    lea       rax,	[r12+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       [r10],	r14b
    dec       rsi
    jnz       L5069
L5071:
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mx_write.genbyte
mx_write.genbyte:
;?>>
   %define R.x rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	[mx_write.dest]
    mov       rdx,	1
    call      mc_genss.buffercheck
    mov       rax,	[mx_write.dest]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       [r10],	dil
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mx_write.genu32
mx_write.genu32:
;?>>
   %define R.x rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	[mx_write.dest]
    mov       rdx,	4
    call      mc_genss.buffercheck
    mov       rax,	[mx_write.dest]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    add       qword [rax],	4
    mov       [r10],	edi
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mx_write.genstring
mx_write.genstring:
;?>>
   %define R.s rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      strlen
    inc       rax
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mx_write.genblock
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mx_write.genblock
mx_write.genblock:
;?>>
   %define R.p rdi
   %define R.length rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	[mx_write.dest]
    mov       rdx,	rbx
    call      mc_genss.buffercheck
    mov       rax,	[mx_write.dest]
    mov       rax,	[rax+8]
    mov       rcx,	rax
    mov       rdx,	rdi
    mov       r8,	rbx
    call      memcpy
    mov       rax,	[mx_write.dest]
    lea       rax,	[rax+8]
    mov       r10,	rbx
    add       [rax],	r10
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm.main
mm.main:
main:
;?>>
;?]]
    sub       rsp,	40
;---------------
    call      msyswin.start
    call      pcl.start
    call      mm.start
    call      mm_cli.main2
    xor       ecx,	ecx
    call      exit
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mm_cli.main2
mm_cli.main2:
;?>>
;?]]
    sub       rsp,	40
;---------------
    call      mwindows.os_clock
    mov       [mm_cli.startclock],	rax
    mov       rax,	[mm_cli.startclock]
    mov       [pc_decls.pstartclock],	rax
    call      mm_cli.initdata
    call      mm_cli.getinputoptions
    mov       rax,	[mm_decls.prodmode]
    test      rax,	rax
    jz        L5079
    call      mm_cli.production_compiler
    jmp       L5078
L5079:
    call      mm_cli.debug_compiler
L5078:
    mov       rax,	[mm_decls.fverbose]
    cmp       rax,	3
    jnz       L5081
    call      msys.m$print_startcon
    lea       rcx,	[L12764]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L5081:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mm_cli.debug_compiler
mm_cli.debug_compiler:
;?>>
;?]]
    sub       rsp,	40
;---------------
    mov       rcx,	[mm_cli.inputfile]
    call      mm_modules.loadproject
    mov       rax,	[mm_decls.dpasslevel]
    cmp       rax,	6
    jnz       L5084
    mov       rax,	4
    mov       [mm_decls.passlevel],	rax
    jmp       L5083
L5084:
    mov       rax,	[mm_decls.dpasslevel]
    cmp       rax,	7
    jnz       L5085
    mov       rax,	6
    mov       [mm_decls.passlevel],	rax
L5085:
L5083:
    mov       rax,	[mm_decls.dpasslevel]
    cmp       rax,	2
    jl        L5087
    movzx     rax,	byte [mm_decls.fshowast1]
    mov       rcx,	rax
    call      mm_cli.do_parse
L5087:
    mov       rax,	[mm_decls.dpasslevel]
    cmp       rax,	4
    jl        L5089
    movzx     rax,	byte [mm_decls.fshowast2]
    mov       rcx,	rax
    call      mm_cli.do_name
L5089:
    mov       rax,	[mm_decls.dpasslevel]
    cmp       rax,	5
    jl        L5091
    movzx     rax,	byte [mm_decls.fshowast3]
    mov       rcx,	rax
    call      mm_cli.do_type
L5091:
    mov       rax,	[mm_decls.dpasslevel]
    cmp       rax,	6
    jl        L5093
    mov       al,	[mm_decls.fshowpcl]
    test      al,	al
    jnz       L5094
    mov       al,	[mm_decls.fshowpst]
    test      al,	al
    jz        L5095
L5094:
    mov       rax,	1
    jmp       L5096
L5095:
    xor       eax,	eax
L5096:
    mov       rcx,	rax
    call      mm_cli.do_genpcl
L5093:
    mov       rax,	[mm_decls.dpasslevel]
    cmp       rax,	7
    jl        L5098
    mov       al,	[mm_decls.fshowasm]
    test      al,	al
    jnz       L5099
    xor       eax,	eax
    test      ax,	ax
    jz        L5100
L5099:
    mov       rax,	1
    jmp       L5101
L5100:
    xor       eax,	eax
L5101:
    mov       rcx,	rax
    call      mm_cli.do_genmcl
L5098:
    mov       rax,	[mm_decls.dpasslevel]
    cmp       rax,	8
    jl        L5103
    xor       ecx,	ecx
    call      pc_api.pcl_genss
L5103:
    mov       al,	[mm_decls.fshowtiming]
    test      al,	al
    jz        L5105
    call      mm_diags.showtimings
L5105:
    call      mm_diags.showlogfile
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mm_cli.production_compiler
mm_cli.production_compiler:
;?>>
;?]]
    sub       rsp,	40
;---------------
    call      mm_cli.showcompilemess
    mov       rcx,	[mm_cli.inputfile]
    call      mm_modules.loadproject
    xor       ecx,	ecx
    call      mm_cli.do_parse
    xor       ecx,	ecx
    call      mm_cli.do_name
    xor       ecx,	ecx
    call      mm_cli.do_type
    mov       rax,	[mm_decls.passlevel]
    cmp       rax,	1
    jnz       L5108
    mov       rcx,	[mm_cli.inputfile]
    call      mm_support.do_writema
L5108:
    mov       rax,	[mm_decls.passlevel]
    cmp       rax,	2
    jz        L5111
    cmp       rax,	3
    jnz       L5110
L5111:
    mov       rcx,	[mm_cli.inputfile]
    call      mm_support.do_getinfo
L5110:
    mov       rax,	[mm_decls.passlevel]
    cmp       rax,	8
    jnz       L5113
    call      mm_cli.do_writeexports
L5113:
    mov       rax,	[mm_decls.passlevel]
    cmp       rax,	4
    setz      al
    movzx     eax,	al
    mov       rcx,	rax
    call      mm_cli.do_genpcl
    mov       rax,	[mm_decls.passlevel]
    cmp       rax,	5
    jnz       L5115
    call      pc_run.pcl_runpcl
L5115:
    mov       rax,	[mm_decls.passlevel]
    cmp       rax,	6
    jl        L5117
    mov       rax,	[mm_decls.passlevel]
    cmp       rax,	6
    jz        L5118
    xor       eax,	eax
    test      ax,	ax
    jz        L5119
L5118:
    mov       rax,	1
    jmp       L5120
L5119:
    xor       eax,	eax
L5120:
    mov       rcx,	rax
    call      mm_cli.do_genmcl
    mov       rax,	[mm_decls.passlevel]
    cmp       rax,	7
    jz        L5122
    cmp       rax,	9
    jz        L5123
    cmp       rax,	8
    jz        L5124
    cmp       rax,	10
    jz        L5125
    cmp       rax,	11
    jz        L5126
    jmp       L5127
L5122:
    mov       rcx,	[mm_decls.outfile]
    lea       rdx,	[L12765]
    call      mlib.changeext
    mov       rcx,	rax
    call      pc_api.pcl_writeobj
    jmp       L5121
L5123:
    mov       rcx,	[mm_decls.outfile]
    lea       rdx,	[L12766]
    call      mlib.changeext
    mov       rcx,	rax
    call      pc_api.pcl_writeexe
    jmp       L5121
L5124:
    mov       rcx,	[mm_decls.outfile]
    lea       rdx,	[L12767]
    call      mlib.changeext
    mov       rcx,	rax
    call      pc_api.pcl_writedll
    jmp       L5121
L5125:
    mov       rcx,	[mm_decls.outfile]
    lea       rdx,	[L12768]
    call      mlib.changeext
    mov       rcx,	rax
    call      pc_api.pcl_writemx
    jmp       L5121
L5126:
    call      pc_api.pcl_exec
L5127:
L5121:
L5117:
    mov       al,	[mm_decls.fshowtiming]
    test      al,	al
    jz        L5129
    call      mm_diags.showtimings
L5129:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mm_cli.showcompilemess
mm_cli.showcompilemess:
;?>>
;?]]
    sub       rsp,	40
;---------------
    mov       rax,	[mm_decls.fverbose]
    cmp       rax,	1
    jl        L5132
    mov       al,	[mm_cli.msfile]
    test      al,	al
    jnz       L5132
    call      msys.m$print_startcon
    lea       rcx,	[L12769]
    call      msys.m$print_setfmt
    mov       rcx,	[mm_cli.inputfile]
    call      msys.m$print_str_nf
    lea       rax,	[mm_cli.passnames]
    mov       r10,	[mm_decls.passlevel]
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	[mm_decls.outfile]
    mov       rdx,	rax
    call      mlib.changeext
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L5132:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mm_cli.do_parse
mm_cli.do_parse:
;?>>
   %define R.flog rsi
   %define R.tt rdi
   %define R.i rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    call      clock
    movsxd    r10,	eax
    mov       rdi,	r10
    mov       rbx,	1
    mov       rax,	[mm_decls.nmodules]
    cmp       rax,	1
    jl        L5136
L5134:
    lea       rax,	[mm_decls.modules]
    mov       r10,	rbx
    mov       rcx,	[rax + r10*8]
    call      mm_parse.parsemodule
    inc       rbx
    cmp       rbx,	[mm_decls.nmodules]
    jle       L5134
L5136:
    call      clock
    movsxd    r10,	eax
    sub       r10,	rdi
    mov       [mm_cli.parsetime],	r10
    mov       rax,	[mm_decls.prodmode]
    test      rax,	rax
    jnz       L5139
    mov       rax,	[mm_decls.dpasslevel]
    cmp       rax,	3
    jl        L5138
L5139:
    call      mm_name.fixusertypes
L5138:
    call      mm_cli.fixstartprocs
    test      rsi,	rsi
    jz        L5141
    lea       rcx,	[L12770]
    call      mm_diags.showast
L5141:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_cli.do_name
mm_cli.do_name:
;?>>
   %define R.flog rsi
   %define R.tt rdi
   %define R.i rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    call      clock
    movsxd    r10,	eax
    mov       rdi,	r10
    call      mm_name.rx_typetable
    mov       rbx,	2
    mov       rax,	[mm_decls.nmodules]
    cmp       rax,	2
    jl        L5145
L5143:
    mov       rcx,	rbx
    call      mm_name.rx_module
    inc       rbx
    cmp       rbx,	[mm_decls.nmodules]
    jle       L5143
L5145:
    mov       rcx,	1
    call      mm_name.rx_module
    call      clock
    movsxd    r10,	eax
    sub       r10,	rdi
    mov       [mm_cli.resolvetime],	r10
    test      rsi,	rsi
    jz        L5147
    lea       rcx,	[L12771]
    call      mm_diags.showast
L5147:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_cli.do_type
mm_cli.do_type:
;?>>
   %define R.flog rsi
   %define R.tt rdi
   %define R.i rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    call      clock
    movsxd    r10,	eax
    mov       rdi,	r10
    call      mm_type.tx_typetable
    mov       rbx,	1
    mov       rax,	[mm_decls.nmodules]
    cmp       rax,	1
    jl        L5151
L5149:
    mov       rcx,	rbx
    call      mm_type.tx_module
    inc       rbx
    cmp       rbx,	[mm_decls.nmodules]
    jle       L5149
L5151:
    call      mm_type.tx_allprocs
    call      clock
    movsxd    r10,	eax
    sub       r10,	rdi
    mov       [mm_cli.typetime],	r10
    test      rsi,	rsi
    jz        L5153
    lea       rcx,	[L12772]
    call      mm_diags.showast
L5153:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_cli.do_genc
mm_cli.do_genc:
;?>>
   %define R.tt rdi
   %define R.file rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
;---------------
    call      clock
    movsxd    r10,	eax
    mov       rdi,	r10
    mov       rcx,	[mm_decls.outfile]
    lea       rdx,	[L12773]
    call      mlib.changeext
    mov       rcx,	rax
    call      mlib.pcm_copyheapstring
    mov       rbx,	rax
    mov       rcx,	rbx
    call      mm_genpcl.codegen_il
    call      clock
    movsxd    r10,	eax
    sub       r10,	rdi
    mov       [mm_cli.ctime],	r10
    call      msys.m$print_startcon
    lea       rcx,	[L12774]
    call      msys.m$print_str_nf
    mov       rcx,	rbx
    call      msys.m$print_str_nf
    mov       rax,	[mm_lib.dest]
    movsxd    rax,	dword [rax+8]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	rbx
    mov       rdx,	[mm_lib.dest]
    call      mm_lib.writegsfile
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_cli.do_genpcl
mm_cli.do_genpcl:
;?>>
   %define R.flog rbx
   %define R.tt rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    call      clock
    movsxd    r10,	eax
    mov       rdi,	r10
    xor       ecx,	ecx
    call      mm_genpcl.codegen_il
    call      clock
    movsxd    r10,	eax
    sub       r10,	rdi
    mov       [mm_cli.pcltime],	r10
    mov       al,	[pc_decls.fregoptim]
    test      al,	al
    jnz       L5158
    mov       al,	[pc_decls.fpeephole]
    test      al,	al
    jz        L5157
L5158:
    call      pc_reduce.pcl_reducetest
L5157:
    test      rbx,	rbx
    jz        L5160
    mov       al,	[mm_decls.fshowpcl]
    test      al,	al
    jnz       L5163
    mov       rax,	[mm_decls.passlevel]
    cmp       rax,	4
    jnz       L5162
L5163:
    mov       rcx,	[mm_decls.outfile]
    lea       rdx,	[L12775]
    call      mlib.changeext
    mov       rcx,	rax
    call      pc_api.pcl_writepcl
L5162:
    mov       al,	[mm_decls.fshowpst]
    test      al,	al
    jz        L5165
    mov       rax,	[mm_decls.passlevel]
    cmp       rax,	4
    jnz       L5165
    lea       rcx,	[L12776]
    call      pc_api.pcl_writepst
L5165:
L5160:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_cli.do_genmcl
mm_cli.do_genmcl:
;?>>
   %define R.flog rbx
   %define R.tt rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    call      clock
    movsxd    r10,	eax
    mov       rdi,	r10
    call      pc_api.pcl_genmcl
    call      clock
    movsxd    r10,	eax
    sub       r10,	rdi
    mov       [pc_decls.mcltime],	r10
    test      rbx,	rbx
    jz        L5168
    mov       rcx,	[mm_decls.outfile]
    lea       rdx,	[L12777]
    call      mlib.changeext
    mov       rcx,	rax
    mov       rdx,	16705
    call      pc_api.pcl_writeasm
L5168:
    mov       al,	[mm_decls.fshowpst]
    test      al,	al
    jz        L5170
    mov       rax,	[mm_decls.passlevel]
    cmp       rax,	4
    jle       L5170
    lea       rcx,	[L12778]
    call      pc_api.pcl_writepst
L5170:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_cli.initdata
mm_cli.initdata:
;?>>
   %define R.pm rdi
    push      rdi
;?]]
    sub       rsp,	48
;---------------
    call      mlib.pcm_init
    call      mm_lex.lexsetup
    call      mm_assem.initassemsymbols
    call      mm_support.init_tt_tables
    call      mm_support.initbblib
    mov       rcx,	64
    call      mlib.pcm_allocz
    mov       rdi,	rax
    lea       rax,	[L12779]
    mov       [rdi],	rax
    lea       rcx,	[L12780]
    call      mm_lex.addnamestr
    xor       ecx,	ecx
    mov       rdx,	rax
    mov       r8,	1
    call      mm_lib.createdupldef
    mov       [mm_decls.stprogram],	rax
    mov       rax,	[mm_decls.stprogram]
    mov       [rdi+24],	rax
    mov       rax,	rdi
    lea       r10,	[mm_decls.modules]
    mov       [r10],	rax
    lea       rax,	[mm_support.mgetsourceinfo]
    mov       [pc_decls.igetmsourceinfo],	rax
    lea       rax,	[mm_assemaux.domcl_assem]
    mov       [pc_api.idomcl_assem],	rax
    lea       rax,	[mm_genpcl.findhostfn]
    mov       [pc_api.igethostfn],	rax
    lea       rax,	[mm_assemaux.checkasmlabel]
    mov       [pc_api.icheckasmlabel],	rax
    lea       rcx,	[L12781]
    call      remove
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_cli.getinputoptions
mm_cli.getinputoptions:
;?>>
    %define mm_cli.getinputoptions.paramno -8
   %define R.pmtype rdi
   %define R.sw rbx
   %define R.extlen rsi
    %define mm_cli.getinputoptions.name -16
    %define mm_cli.getinputoptions.value -24
   %define R.ext r12
    %define mm_cli.getinputoptions.filespec -328
   %define R.av_1 r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	360
;---------------
    mov       al,	[pcl.pc_userunpcl]
    test      al,	al
    jz        L5174
    mov       rax,	5
    mov       [mm_decls.passlevel],	rax
    mov       rax,	1
    mov       [mm_decls.prodmode],	rax
    xor       eax,	eax
    mov       [mm_decls.fverbose],	rax
L5174:
    mov       rax,	1
    mov       [rbp + mm_cli.getinputoptions.paramno],	rax
    call      mwindows.os_gethostname
    mov       rcx,	rax
    call      mlib.extractfile
    mov       rcx,	rax
    lea       rdx,	[L12782]
    call      mlib.eqstring
    test      rax,	rax
    jz        L5176
    mov       al,	1
    mov       [mm_cli.msfile],	al
    xor       eax,	eax
    mov       [mm_decls.fverbose],	rax
    mov       rcx,	13
    lea       rdx,	[L12783]
    xor       r8d,	r8d
    call      mm_cli.do_option
L5176:
    jmp       L5178
L5177:
    mov       rax,	rdi
    cmp       rax,	1
    jz        L5181
    cmp       rax,	2
    jz        L5182
    cmp       rax,	3
    jz        L5183
    jmp       L5184
L5181:
    mov       rcx,	[rbp + mm_cli.getinputoptions.name]
    call      mlib.convlcstring
    mov       rbx,	1
    mov       r13,	55
    cmp       r13,	1
    jl        L5188
L5185:
    lea       rax,	[mm_cli.optionnames]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	[rbp + mm_cli.getinputoptions.name]
    mov       rdx,	rax
    call      mlib.eqstring
    test      rax,	rax
    jz        L5190
    mov       rcx,	rbx
    mov       rdx,	[rbp + mm_cli.getinputoptions.value]
    mov       r8,	[rbp + mm_cli.getinputoptions.paramno]
    call      mm_cli.do_option
    jmp       L5187
L5190:
    inc       rbx
    cmp       rbx,	r13
    jle       L5185
L5188:
    call      msys.m$print_startcon
    lea       rcx,	[L12784]
    call      msys.m$print_str_nf
    mov       rcx,	[rbp + mm_cli.getinputoptions.name]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	99
    call      exit
L5187:
    jmp       L5180
L5182:
    mov       rax,	[mm_cli.inputfile]
    test      rax,	rax
    jz        L5192
    lea       rcx,	[L12785]
    lea       rdx,	[L12786]
    lea       r8,	[L12786]
    call      mm_support.loaderror
L5192:
    mov       rcx,	[rbp + mm_cli.getinputoptions.name]
    call      mlib.convlcstring
    mov       rcx,	[rbp + mm_cli.getinputoptions.name]
    call      mlib.pcm_copyheapstring
    mov       [mm_cli.inputfile],	rax
    mov       rax,	[mm_decls.passlevel]
    cmp       rax,	11
    jz        L5195
    cmp       rax,	5
    jnz       L5194
L5195:
    mov       rax,	[rbp + mm_cli.getinputoptions.paramno]
    dec       rax
    add       rax,	[msys.$cmdskip]
    mov       [mm_cli.cmdskip],	rax
    jmp       L5179
L5194:
    jmp       L5180
L5183:
    lea       rcx,	[L12787]
    lea       rdx,	[L12788]
    lea       r8,	[L12788]
    call      mm_support.loaderror
    jmp       L5180
L5184:
    lea       rcx,	[L12789]
    lea       rdx,	[L12790]
    lea       r8,	[L12790]
    call      mm_support.loaderror
L5180:
L5178:
    lea       rcx,	[rbp + mm_cli.getinputoptions.paramno]
    lea       rdx,	[rbp + mm_cli.getinputoptions.name]
    lea       r8,	[rbp + mm_cli.getinputoptions.value]
    lea       r9,	[L12791]
    call      mlib.nextcmdparamnew
    mov       rdi,	rax
    test      rax,	rax
    jnz       L5177
L5179:
    mov       rax,	[mm_decls.debugmode]
    cmp       rax,	[mm_decls.prodmode]
    jnz       L5197
    test      rax,	rax
    jnz       L5197
    mov       rax,	9
    mov       [mm_decls.passlevel],	rax
    lea       rax,	[L12792]
    mov       [mm_cli.outext],	rax
    mov       rax,	1
    mov       [mm_decls.prodmode],	rax
L5197:
    mov       rax,	[mm_decls.passlevel]
    cmp       rax,	7
    jz        L5199
    cmp       rax,	8
    jz        L5199
    cmp       rax,	6
    jz        L5200
    cmp       rax,	10
    jz        L5201
    cmp       rax,	11
    jz        L5201
    jmp       L5202
L5199:
    mov       al,	2
    mov       [mm_decls.highmem],	al
    jmp       L5198
L5200:
    mov       rax,	[pc_decls.assemtype]
    cmp       rax,	1297301838
    jnz       L5204
    mov       al,	2
    mov       [mm_decls.highmem],	al
L5204:
    jmp       L5198
L5201:
    xor       eax,	eax
    mov       [mm_decls.highmem],	al
L5202:
L5198:
    mov       rax,	[mm_cli.inputfile]
    test      rax,	rax
    jnz       L5206
    call      mm_cli.showcaption
    call      msys.m$print_startcon
    lea       rcx,	[L12793]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       rcx,	[L12794]
    call      msys.m$print_str_nf
    mov       rax,	[msys.cmdparams]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    lea       rcx,	[L12795]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       rcx,	[L12796]
    call      msys.m$print_str_nf
    mov       rax,	[msys.cmdparams]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    lea       rcx,	[L12797]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    xor       ecx,	ecx
    call      exit
    jmp       L5205
L5206:
    mov       rcx,	[mm_cli.inputfile]
    call      mlib.pcm_copyheapstring
    mov       [mm_decls.outfile],	rax
    mov       rax,	[mm_decls.destfilename]
    test      rax,	rax
    jz        L5208
    mov       rax,	[mm_decls.destfilename]
    mov       [mm_decls.outfile],	rax
L5208:
    mov       rax,	[mm_decls.destfilepath]
    test      rax,	rax
    jz        L5210
    lea       rcx,	[rbp + mm_cli.getinputoptions.filespec]
    mov       rdx,	[mm_decls.destfilepath]
    call      strcpy
    lea       rcx,	[rbp + mm_cli.getinputoptions.filespec]
    call      mlib.extractfile
    mov       rcx,	rax
    mov       rdx,	[mm_decls.outfile]
    call      strcat
    lea       rcx,	[rbp + mm_cli.getinputoptions.filespec]
    call      mlib.pcm_copyheapstring
    mov       [mm_decls.outfile],	rax
L5210:
L5205:
    mov       rcx,	[mm_cli.inputfile]
    xor       edx,	edx
    call      mlib.extractext
    mov       r12,	rax
    mov       rcx,	r12
    call      strlen
    mov       rsi,	rax
    mov       rax,	[msys.cmdparams]
    mov       rax,	[rax]
    mov       rcx,	rax
    mov       rdx,	r12
    call      mlib.changeext
    lea       rcx,	[rbp + mm_cli.getinputoptions.filespec]
    mov       rdx,	rax
    call      strcpy
    lea       rcx,	[rbp + mm_cli.getinputoptions.filespec]
    call      mlib.convlcstring
    lea       rcx,	[rbp + mm_cli.getinputoptions.filespec]
    mov       rdx,	[mm_cli.inputfile]
    call      mlib.eqstring
    test      rax,	rax
    jz        L5212
    mov       rax,	[mm_decls.passlevel]
    cmp       rax,	9
    jnz       L5212
    lea       rcx,	[rbp + mm_cli.getinputoptions.filespec]
    call      strlen
    lea       r10,	[rbp + rax + mm_cli.getinputoptions.filespec]
    mov       rax,	rsi
    sub       r10,	rax
    sub       r10,	1
    mov       rcx,	r10
    lea       rdx,	[L12798]
    call      strcpy
    lea       rcx,	[rbp + mm_cli.getinputoptions.filespec]
    call      mlib.pcm_copyheapstring
    mov       [mm_decls.outfile],	rax
    call      msys.m$print_startcon
    lea       rcx,	[L12799]
    call      msys.m$print_str_nf
    mov       rcx,	[mm_decls.outfile]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L5212:
    movzx     rax,	byte [mm_decls.highmem]
    mov       rcx,	rax
    mov       rdx,	-1
    mov       r8,	[mm_decls.fshortnames]
    call      pc_api.pcl_setflags
    mov       rcx,	[mm_cli.cmdskip]
    xor       edx,	edx
    call      pc_api.pcl_cmdskip
    movzx     rax,	byte [mm_decls.msyslevel]
    cmp       rax,	2
    jnz       L5214
    mov       al,	1
    mov       [pc_api.pfullsys],	al
L5214:
;---------------
    add       rsp,	360
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_cli.do_option
mm_cli.do_option:
;?>>
   %define R.sw rdi
   %define R.value rbx
   %define R.paramno rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    mov       rax,	rdi
    cmp       rax,	1
    jl        L5217
    cmp       rax,	13
    jg        L5217
    mov       rax,	[mm_decls.prodmode]
    test      rax,	rax
    jz        L5219
    lea       rax,	[mm_cli.optionnames]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    lea       rcx,	[L12800]
    mov       rdx,	rax
    lea       r8,	[L12801]
    call      mm_support.loaderror
L5219:
    lea       rax,	[mm_cli.optionvalues]
    mov       r10,	rdi
    movzx     rax,	byte [rax + r10-1]
    mov       [mm_decls.passlevel],	rax
    mov       rax,	1
    mov       [mm_decls.prodmode],	rax
    lea       rax,	[mm_cli.passnames]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    mov       [mm_cli.outext],	rax
    mov       rax,	rdi
    cmp       rax,	6
    jz        L5221
    cmp       rax,	5
    jz        L5222
    jmp       L5223
L5221:
    mov       rax,	[pc_decls.assemtype]
    cmp       rax,	16705
    jnz       L5226
    cmp       rdi,	7
    jnz       L5225
    mov       rax,	[pc_decls.assemtype]
    cmp       rax,	1297301838
    jz        L5225
L5226:
    lea       rcx,	[L12802]
    lea       rdx,	[L12803]
    lea       r8,	[L12803]
    call      mm_support.loaderror
L5225:
    jmp       L5220
L5222:
    lea       rax,	[rsi-1]
    add       rax,	[msys.$cmdskip]
    mov       [mm_cli.cmdskip],	rax
L5223:
L5220:
    jmp       L5215
L5217:
    mov       rax,	rdi
    cmp       rax,	14
    jl        L5227
    cmp       rax,	21
    jg        L5227
    mov       rax,	[mm_decls.debugmode]
    test      rax,	rax
    jz        L5229
    lea       rcx,	[L12804]
    lea       rdx,	[L12805]
    lea       r8,	[L12805]
    call      mm_support.loaderror
L5229:
    lea       rax,	[rdi-14]
    inc       rax
    mov       [mm_decls.dpasslevel],	rax
    mov       rax,	1
    mov       [mm_decls.debugmode],	rax
    jmp       L5215
L5227:
L5216:
    mov       rax,	rdi
    cmp       rax,	29
    jz        L5231
    cmp       rax,	30
    jz        L5232
    cmp       rax,	31
    jz        L5233
    cmp       rax,	33
    jz        L5234
    cmp       rax,	32
    jz        L5235
    cmp       rax,	34
    jz        L5236
    cmp       rax,	35
    jz        L5237
    cmp       rax,	36
    jz        L5238
    cmp       rax,	41
    jz        L5239
    cmp       rax,	37
    jz        L5240
    cmp       rax,	38
    jz        L5241
    cmp       rax,	39
    jz        L5242
    cmp       rax,	25
    jz        L5243
    cmp       rax,	22
    jz        L5244
    cmp       rax,	23
    jz        L5244
    cmp       rax,	24
    jz        L5244
    cmp       rax,	26
    jz        L5245
    cmp       rax,	27
    jz        L5246
    cmp       rax,	28
    jz        L5247
    cmp       rax,	42
    jz        L5248
    cmp       rax,	43
    jz        L5249
    cmp       rax,	44
    jz        L5249
    cmp       rax,	45
    jz        L5249
    cmp       rax,	46
    jz        L5250
    cmp       rax,	47
    jz        L5250
    cmp       rax,	48
    jz        L5251
    cmp       rax,	49
    jz        L5251
    cmp       rax,	50
    jz        L5252
    cmp       rax,	51
    jz        L5253
    cmp       rax,	52
    jz        L5254
    cmp       rax,	53
    jz        L5255
    cmp       rax,	40
    jz        L5256
    cmp       rax,	54
    jz        L5257
    cmp       rax,	55
    jz        L5257
    jmp       L5258
L5231:
    mov       al,	1
    mov       [mm_decls.fshowast1],	al
    jmp       L5230
L5232:
    mov       al,	1
    mov       [mm_decls.fshowast2],	al
    jmp       L5230
L5233:
    mov       al,	1
    mov       [mm_decls.fshowast3],	al
    jmp       L5230
L5234:
    mov       al,	1
    mov       [mm_decls.fshowpcl],	al
    jmp       L5230
L5235:
    mov       al,	1
    mov       [mm_decls.fshowc],	al
    jmp       L5230
L5236:
    mov       al,	1
    mov       [mm_decls.fshowasm],	al
    jmp       L5230
L5237:
    mov       al,	1
    mov       [mm_decls.fshowst],	al
    jmp       L5230
L5238:
    mov       al,	1
    mov       [mm_decls.fshowstflat],	al
    jmp       L5230
L5239:
    mov       al,	1
    mov       [mm_decls.fshowpst],	al
    jmp       L5230
L5240:
    mov       al,	1
    mov       [mm_decls.fshowtypes],	al
    jmp       L5230
L5241:
    mov       al,	1
    mov       [mm_decls.fshowss],	al
    jmp       L5230
L5242:
    mov       al,	1
    mov       [mm_decls.fshowmodules],	al
    jmp       L5230
L5243:
    mov       al,	1
    mov       [mm_decls.clinux],	al
    jmp       L5230
L5244:
    lea       rax,	[mm_cli.optionvalues]
    mov       r10,	rdi
    mov       al,	[rax + r10-1]
    mov       [mm_decls.msyslevel],	al
    jmp       L5230
L5245:
    xor       eax,	eax
    mov       [pc_decls.fregoptim],	al
    mov       [pc_decls.fpeephole],	al
    jmp       L5230
L5246:
    xor       eax,	eax
    mov       [pc_decls.fpeephole],	al
    jmp       L5230
L5247:
    xor       eax,	eax
    mov       [pc_decls.fregoptim],	al
    jmp       L5230
L5248:
    mov       al,	1
    mov       [mm_decls.fshowtiming],	al
    jmp       L5230
L5249:
    lea       rax,	[mm_cli.optionvalues]
    mov       r10,	rdi
    movzx     rax,	byte [rax + r10-1]
    mov       [mm_decls.fverbose],	rax
    jmp       L5230
L5250:
    lea       rax,	[mm_cli.optionvalues]
    mov       r10,	rdi
    mov       al,	[rax + r10-1]
    mov       [pc_decls.pverbose],	al
    jmp       L5230
L5251:
    call      mm_cli.showhelp
    xor       ecx,	ecx
    call      exit
    jmp       L5230
L5252:
    xor       eax,	eax
    mov       [mm_decls.dointlibs],	al
    jmp       L5230
L5253:
    mov       al,	[mm_cli.do_option.outpathused]
    test      al,	al
    jz        L5260
    lea       rcx,	[L12806]
    lea       rdx,	[L12807]
    lea       r8,	[L12807]
    call      mm_support.loaderror
L5260:
    mov       rcx,	rbx
    call      mlib.pcm_copyheapstring
    mov       [mm_decls.destfilename],	rax
    mov       al,	1
    mov       [mm_cli.do_option.outused],	al
    jmp       L5230
L5254:
    mov       al,	[mm_cli.do_option.outused]
    test      al,	al
    jz        L5262
    lea       rcx,	[L12808]
    lea       rdx,	[L12809]
    lea       r8,	[L12809]
    call      mm_support.loaderror
L5262:
    mov       rcx,	rbx
    call      strlen
    lea       r10,	[rbx + rax]
    sub       r10,	1
    movzx     r10,	byte [r10]
    cmp       r10,	92
    jz        L5264
    cmp       r10,	47
    jz        L5264
    lea       rcx,	[L12810]
    lea       rdx,	[L12811]
    lea       r8,	[L12811]
    call      mm_support.loaderror
L5264:
    mov       rcx,	rbx
    call      mlib.pcm_copyheapstring
    mov       [mm_decls.destfilepath],	rax
    mov       al,	1
    mov       [mm_cli.do_option.outpathused],	al
    jmp       L5230
L5255:
    mov       al,	1
    mov       [mm_decls.fcheckunusedlocals],	al
    jmp       L5230
L5256:
    mov       rax,	1
    mov       [mm_decls.fshortnames],	rax
    jmp       L5230
L5257:
    lea       rax,	[mm_cli.optionvalues]
    mov       r10,	rdi
    mov       al,	[rax + r10-1]
    mov       [mm_decls.highmem],	al
L5258:
L5230:
L5215:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_cli.showcaption
mm_cli.showcaption:
;?>>
;?]]
    sub       rsp,	40
;---------------
    call      msys.m$print_startcon
    lea       rcx,	[L12812]
    call      msys.m$print_str_nf
    lea       rcx,	[L12813]
    call      msys.m$print_str_nf
    lea       rcx,	[L12814]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mm_cli.showhelp
mm_cli.showhelp:
;?>>
;?]]
    sub       rsp,	40
;---------------
    call      msys.m$print_startcon
    lea       rcx,	[L12815]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mm_cli.do_writeexports
mm_cli.do_writeexports:
;?>>
    %define mm_cli.do_writeexports.str -304
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	336
;---------------
    mov       rcx,	[mm_decls.outfile]
    call      mlib.extractbasefile
    lea       rcx,	[rbp + mm_cli.do_writeexports.str]
    mov       rdx,	rax
    call      strcpy
    lea       rcx,	[rbp + mm_cli.do_writeexports.str]
    lea       rdx,	[L12816]
    call      mlib.changeext
    mov       rcx,	[mm_decls.outfile]
    mov       rdx,	rax
    call      mm_export_dummy.writeexports
;---------------
    add       rsp,	336
    pop       rbp
    ret       
;End 
;Proc mm_cli.getoutfilename
mm_cli.getoutfilename:
;?>>
   %define R.file rdi
   %define R.ext rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mlib.changeext
    mov       rcx,	rax
    call      mlib.pcm_copyheapstring
L5268:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_cli.fixstartprocs
mm_cli.fixstartprocs:
;?>>
   %define R.ms rdi
   %define R.ps rbx
   %define R.s rsi
   %define R.i r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
;---------------
    mov       r12,	1
    mov       rax,	[mm_decls.nsubprogs]
    cmp       rax,	1
    jl        L5272
L5270:
    lea       rax,	[mm_decls.subprogs]
    mov       r10,	r12
    mov       rbx,	[rax + r10*8]
    movsx     rax,	word [rbx+10]
    test      rax,	rax
    jnz       L5274
    mov       ax,	[rbx+8]
    mov       [rbx+10],	ax
L5274:
    inc       r12
    cmp       r12,	[mm_decls.nsubprogs]
    jle       L5270
L5272:
    mov       r12,	1
    mov       rax,	[mm_decls.nmodules]
    cmp       rax,	1
    jl        L5277
L5275:
    lea       rax,	[mm_decls.modules]
    mov       r10,	r12
    mov       rdi,	[rax + r10*8]
    mov       rax,	[rdi+48]
    test      rax,	rax
    jz        L5279
    movsx     rax,	word [rdi+18]
    mov       r10b,	1
    lea       r11,	[mm_decls.subproghasstart]
    mov       [r11 + rax],	r10b
L5279:
    inc       r12
    cmp       r12,	[mm_decls.nmodules]
    jle       L5275
L5277:
    mov       r12,	1
    mov       rax,	[mm_decls.nmodules]
    cmp       rax,	1
    jl        L5282
L5280:
    lea       rax,	[mm_decls.modules]
    mov       r10,	r12
    mov       rdi,	[rax + r10*8]
    mov       rax,	[rdi+48]
    test      rax,	rax
    jnz       L5284
    movsx     rax,	word [rdi+18]
    mov       rsi,	rax
    lea       rax,	[mm_decls.subproghasstart]
    mov       r10,	rsi
    mov       al,	[rax + r10]
    test      al,	al
    jz        L5286
    lea       rax,	[mm_decls.subprogs]
    mov       r10,	rsi
    mov       rax,	[rax + r10*8]
    movsx     rax,	word [rax+10]
    cmp       rax,	r12
    jnz       L5286
    mov       rax,	[rdi+24]
    mov       rcx,	rax
    lea       rdx,	[L12817]
    mov       r8,	2
    mov       r9,	r12
    call      mm_cli.addstartproc
    mov       [rdi+48],	rax
L5286:
L5284:
    inc       r12
    cmp       r12,	[mm_decls.nmodules]
    jle       L5280
L5282:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_cli.addstartproc
mm_cli.addstartproc:
;?>>
   %define R.owner rbx
   %define R.name rsi
   %define R.scope r12
   %define R.moduleno r13
   %define R.stproc rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
    mov       r13,	r9
;---------------
    mov       rcx,	rsi
    call      mm_lex.addnamestr
    mov       rcx,	rbx
    mov       rdx,	rax
    mov       r8,	6
    call      mm_lib.getduplnameptr
    mov       rdi,	rax
    mov       [rdi+170],	r12b
    mov       [rdi+94],	r13b
    lea       rax,	[mm_decls.moduletosub]
    mov       r10,	r13
    mov       al,	[rax + r10]
    mov       [rdi+95],	al
    xor       ecx,	ecx
    call      mm_parse.makeblock
    mov       [rdi+64],	rax
    mov       rcx,	rbx
    mov       rdx,	rdi
    call      mm_lib.adddef
    mov       rcx,	rdi
    call      mm_lib.addtoproclist
    mov       rax,	rdi
L5287:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_genpcl.codegen_il
mm_genpcl.codegen_il:
;?>>
    %define mm_genpcl.codegen_il.dummy 40
   %define R.d rdi
   %define R.pp rbx
   %define R.i rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
;---------------
    xor       ecx,	ecx
    mov       rdx,	[mm_decls.nunits]
    call      pc_api.pcl_start
    call      mm_genpcl.dolibs
    mov       rbx,	[mm_decls.staticlist]
    jmp       L5290
L5289:
    mov       rdi,	[rbx]
    mov       rcx,	rdi
    call      mm_genpcl.dostaticvar
    mov       rbx,	[rbx+8]
L5290:
    test      rbx,	rbx
    jnz       L5289
    lea       rcx,	[L12818]
    call      pc_api.gencomment
    mov       rsi,	1
    mov       rax,	[mm_decls.ndllproctable]
    cmp       rax,	1
    jl        L5294
L5292:
    lea       rax,	[mm_decls.dllproctable]
    mov       r10,	rsi
    mov       rcx,	[rax + r10*8-8]
    call      mm_genpcl.gendllproc
    inc       rsi
    cmp       rsi,	[mm_decls.ndllproctable]
    jle       L5292
L5294:
    mov       rbx,	[mm_decls.proclist]
    jmp       L5296
L5295:
    mov       rdi,	[rbx]
    mov       rax,	rdi
    mov       r10,	rax
    mov       [mm_decls.currproc],	r10
    mov       rcx,	rax
    call      mm_genpcl.genprocdef
    mov       rbx,	[rbx+8]
L5296:
    test      rbx,	rbx
    jnz       L5295
    call      mm_genpcl.scanprocs
    call      pc_api.pcl_end
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_genpcl.genprocdef
mm_genpcl.genprocdef:
;?>>
   %define R.p rbx
   %define R.ms rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    movzx     rax,	byte [rbx+94]
    lea       r10,	[mm_decls.modules]
    mov       r10,	[r10 + rax*8]
    mov       rdi,	r10
    xor       eax,	eax
    mov       [mm_genpcl.pcldoswx],	rax
    mov       rax,	[rdi+56]
    mov       r10,	rbx
    cmp       r10,	rax
    jnz       L5300
    movzx     rax,	byte [rbx+94]
    lea       r10,	[mm_decls.moduletosub]
    movzx     r10,	byte [r10 + rax]
    cmp       r10,	[mm_decls.mainsubprogno]
    jnz       L5300
    mov       rcx,	rbx
    call      mm_genpcl.genmaindef
    jmp       L5298
L5300:
    mov       rax,	[rdi+48]
    mov       r10,	rbx
    cmp       r10,	rax
    jnz       L5301
    mov       rcx,	rbx
    call      mm_genpcl.genstartdef
    jmp       L5298
L5301:
L5299:
    mov       eax,	[rbx+88]
    mov       [pc_decls.mmpos],	rax
    mov       rcx,	rbx
    xor       edx,	edx
    call      mm_genpcl.doprocdef
    call      mm_genpcl.createfwdlabel
    mov       [mm_genpcl.retindex],	rax
    lea       rcx,	[L12819]
    call      pc_api.gencomment
    movzx     rax,	word [rbx+92]
    shr       eax,	1
    and       eax,	1
    test      rax,	rax
    jz        L5303
    mov       rcx,	126
    xor       edx,	edx
    call      pc_api.pc_gen
    xor       ecx,	ecx
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rax,	[pc_api.pccurr]
    mov       [mm_genpcl.pcldoswx],	rax
    xor       ecx,	ecx
    xor       edx,	edx
    call      pc_api.pc_gen
L5303:
    mov       rcx,	[rbx+64]
    call      mm_blockpcl.evalunit
    lea       rcx,	[L12819]
    call      pc_api.gencomment
    mov       rcx,	[mm_genpcl.retindex]
    call      mm_genpcl.definefwdlabel
    call      mm_genpcl.genreturn
    call      pc_api.pc_endproc
L5298:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_genpcl.gendllproc
mm_genpcl.gendllproc:
;?>>
   %define R.p rbx
   %define R.e rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rcx,	rbx
    call      mm_libpcl.getpsymbol
    mov       rcx,	rax
    call      pc_api.pc_setimport
    mov       rdi,	[rbx+16]
    jmp       L5308
L5305:
    mov       rcx,	rdi
    call      mm_libpcl.getpsymbol
    mov       rcx,	rax
    call      pc_api.pc_addparam
    mov       rdi,	[rdi+32]
L5308:
    test      rdi,	rdi
    jnz       L5305
    xor       ecx,	ecx
    call      pc_api.pc_setimport
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_genpcl.dolibs
mm_genpcl.dolibs:
;?>>
   %define R.i rdi
    push      rdi
;?]]
    sub       rsp,	48
;---------------
    mov       rdi,	1
    mov       rax,	[mm_decls.nlibfiles]
    cmp       rax,	1
    jl        L5312
L5310:
    lea       rax,	[mm_decls.libfiles]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8]
    movzx     rax,	byte [rax]
    cmp       rax,	36
    jz        L5314
    lea       rax,	[mm_decls.libfiles]
    mov       r10,	rdi
    mov       rcx,	[rax + r10*8]
    call      pc_api.pc_addplib
L5314:
    inc       rdi
    cmp       rdi,	[mm_decls.nlibfiles]
    jle       L5310
L5312:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_genpcl.dostaticvar
mm_genpcl.dostaticvar:
;?>>
   %define R.d rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    movzx     rax,	word [rdi+92]
    shr       eax,	11
    and       eax,	1
    test      rax,	rax
    jnz       L5315
L5317:
    movzx     rax,	byte [rdi+170]
    cmp       rax,	2
    jnz       L5319
    mov       rax,	[rdi]
    movzx     rax,	byte [rax]
    cmp       rax,	36
    jnz       L5319
    mov       rax,	[rdi]
    mov       rcx,	rax
    lea       rdx,	[L12820]
    call      mlib.eqstring
    test      rax,	rax
    jz        L5321
    mov       al,	3
    mov       [rdi+170],	al
L5321:
L5319:
    movzx     rax,	word [rdi+92]
    shr       eax,	8
    and       eax,	1
    cmp       rax,	1
    jz        L5315
L5323:
    mov       rax,	[rdi+64]
    test      rax,	rax
    jz        L5324
    mov       rcx,	rdi
    call      mm_genpcl.genmem_d
    mov       rcx,	123
    mov       rdx,	rax
    call      pc_api.pc_gen
    movsxd    rax,	dword [rdi+72]
    mov       rcx,	rax
    call      mm_libpcl.setmode
    movsxd    rax,	dword [rdi+72]
    mov       rcx,	rax
    call      mm_lib.getalignment
    mov       rcx,	rax
    call      pc_api.pc_setalign
    mov       rax,	[rdi+64]
    mov       rcx,	rax
    mov       rdx,	1
    mov       r8,	65
    xor       r9d,	r9d
    call      mm_genpcl.genidata
    jmp       L5322
L5324:
;mm_genpcl.dostaticvar.dozstatic:
    mov       rcx,	rdi
    call      mm_genpcl.genmem_d
    mov       rcx,	124
    mov       rdx,	rax
    call      pc_api.pc_gen
    movsxd    rax,	dword [rdi+72]
    mov       rcx,	rax
    call      mm_libpcl.setmode
    movsxd    rax,	dword [rdi+72]
    mov       rcx,	rax
    call      mm_lib.getalignment
    mov       rcx,	rax
    call      pc_api.pc_setalign
L5322:
L5315:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_genpcl.genidata
mm_genpcl.genidata:
;?>>
   %define R.p r14
    %define mm_genpcl.genidata.doterm 72
    %define mm_genpcl.genidata.am 80
    %define mm_genpcl.genidata.offset 88
    %define mm_genpcl.genidata.data -2000
   %define R.t rdi
   %define R.tbase rbx
   %define R.allbytes sil
   %define R.nbytes r12b
   %define R.q r13
    %define mm_genpcl.genidata.d -2008
    %define mm_genpcl.genidata.$T1 -2016
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	2048
    mov       r14,	rcx
    mov       [rbp+80],	r8
    mov       [rbp+88],	r9
;---------------
    movsxd    rax,	dword [r14+49]
    mov       rdi,	rax
    mov       eax,	[r14+4]
    mov       [pc_decls.mmpos],	rax
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rdi
    movsxd    rax,	dword [rax + r10*4]
    mov       rbx,	rax
    movzx     rax,	byte [r14]
    cmp       rax,	1
    jz        L5328
    cmp       rax,	20
    jz        L5329
    cmp       rax,	4
    jz        L5330
    cmp       rax,	58
    jz        L5331
    cmp       rax,	59
    jz        L5332
    cmp       rax,	55
    jz        L5333
    cmp       rax,	56
    jz        L5333
    jmp       L5334
L5328:
    lea       rax,	[mm_decls.ttisref]
    mov       r10,	rdi
    mov       al,	[rax + r10]
    test      al,	al
    jz        L5336
    cmp       rdi,	20
    jnz       L5338
    mov       rax,	[r14+16]
    test      rax,	rax
    jz        L5340
    movzx     rax,	byte [r14+45]
    cmp       rax,	66
    jnz       L5342
    lea       rcx,	[L12821]
    xor       edx,	edx
    call      mm_support.gerror
L5342:
    mov       rax,	[r14+16]
    mov       rcx,	rax
    call      pc_api.genstring
    mov       rcx,	125
    mov       rdx,	rax
    call      pc_api.pc_gen
    jmp       L5339
L5340:
    xor       ecx,	ecx
    call      pc_api.genint
    mov       rcx,	125
    mov       rdx,	rax
    call      pc_api.pc_gen
L5339:
    jmp       L5337
L5338:
    mov       rax,	[r14+16]
    mov       rcx,	rax
    call      pc_api.genint
    mov       rcx,	125
    mov       rdx,	rax
    call      pc_api.pc_gen
L5337:
    mov       rcx,	3
    call      mm_libpcl.setmode
    jmp       L5335
L5336:
    lea       rax,	[mm_decls.ttisreal]
    mov       r10,	rdi
    mov       al,	[rax + r10]
    test      al,	al
    jz        L5343
    mov       rcx,	rdi
    call      mm_lib.getpclmode
    movq      XMM4,	[r14+16]
    movq      XMM0,	XMM4
    mov       rdx,	rax
    call      pc_api.genrealimm
    mov       rcx,	125
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	rdi
    call      mm_libpcl.setmode
    jmp       L5335
L5343:
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rdi
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	10
    jnz       L5344
    movzx     rax,	byte [r14+45]
    test      rax,	rax
    jnz       L5346
    lea       rcx,	[L12822]
    xor       edx,	edx
    call      mm_support.gerror
L5346:
    mov       eax,	[r14+40]
    mov       r10,	[r14+16]
    mov       rcx,	r10
    mov       rdx,	rax
    call      pc_api.gendata
    mov       rcx,	125
    mov       rdx,	rax
    call      pc_api.pc_gen
    jmp       L5335
L5344:
    mov       rax,	[r14+16]
    mov       rcx,	rax
    call      pc_api.genint
    mov       rcx,	125
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	r14
    call      mm_libpcl.setmode_u
L5335:
    jmp       L5327
L5329:
    mov       r13,	[r14+16]
    mov       sil,	1
    xor       r12b,	r12b
    jmp       L5350
L5347:
    movzx     rax,	byte [r13]
    cmp       rax,	1
    jnz       L5352
    movsxd    rax,	dword [r13+49]
    cmp       rax,	17
    jnz       L5352
    movzx     rax,	r12b
    cmp       rax,	2000
    jge       L5352
    mov       rax,	[r13+16]
    inc       r12b
    mov       r10b,	r12b
    movzx     r11,	r10b
    mov       [rbp + r11 + mm_genpcl.genidata.data-1],	al
    jmp       L5351
L5352:
    xor       sil,	sil
    jmp       L5349
L5351:
    mov       r13,	[r13+8]
L5350:
    test      r13,	r13
    jnz       L5347
L5349:
    test      sil,	sil
    jz        L5354
    test      r12b,	r12b
    jz        L5354
    movzx     rax,	r12b
    mov       [rbp + mm_genpcl.genidata.$T1],	rax
    movzx     rax,	r12b
    lea       rcx,	[rbp + mm_genpcl.genidata.data]
    mov       rdx,	rax
    call      mlib.pcm_copyheapstringn
    mov       rcx,	rax
    mov       rdx,	[rbp + mm_genpcl.genidata.$T1]
    call      pc_api.gendata
    mov       rcx,	125
    mov       rdx,	rax
    call      pc_api.pc_gen
    jmp       L5353
L5354:
    mov       r13,	[r14+16]
    jmp       L5358
L5355:
    mov       rcx,	r13
    mov       rdx,	1
    mov       r8,	65
    xor       r9d,	r9d
    call      mm_genpcl.genidata
    mov       r13,	[r13+8]
L5358:
    test      r13,	r13
    jnz       L5355
L5353:
    jmp       L5327
L5330:
    mov       rax,	[r14+16]
    mov       [rbp + mm_genpcl.genidata.d],	rax
    mov       rax,	[rbp + mm_genpcl.genidata.d]
    movzx     rax,	byte [rax+78]
    cmp       rax,	10
    jz        L5360
    cmp       rax,	6
    jz        L5360
    cmp       rax,	7
    jz        L5360
    cmp       rax,	14
    jz        L5361
    jmp       L5362
L5360:
    mov       rcx,	[rbp + mm_genpcl.genidata.d]
    call      mm_genpcl.genmemaddr_d
    mov       rcx,	125
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rax,	[rbp + mm_genpcl.genidata.offset]
    test      rax,	rax
    jz        L5364
    mov       rcx,	1
    mov       rdx,	[rbp + mm_genpcl.genidata.offset]
    call      pc_api.pc_setscaleoff
L5364:
    mov       rax,	[rbp + mm_genpcl.genidata.am]
    cmp       rax,	80
    jnz       L5366
    mov       rcx,	4
    call      mm_libpcl.setmode
    jmp       L5365
L5366:
    mov       rcx,	rdi
    call      mm_libpcl.setmode
L5365:
    jmp       L5359
L5361:
    mov       rax,	[rbp + mm_genpcl.genidata.d]
    movsxd    rax,	dword [rax+80]
    test      rax,	rax
    jnz       L5368
    inc       qword [pc_api.mlabelno]
    mov       rax,	[pc_api.mlabelno]
    mov       r10,	[rbp + mm_genpcl.genidata.d]
    mov       [r10+80],	eax
L5368:
    mov       rax,	[rbp + mm_genpcl.genidata.d]
    movsxd    rax,	dword [rax+80]
    mov       rcx,	rax
    call      pc_api.genlabel
    mov       rcx,	125
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	3
    call      mm_libpcl.setmode
    jmp       L5359
L5362:
    lea       rcx,	[L12823]
    xor       edx,	edx
    call      mm_support.gerror
L5359:
    jmp       L5326
L5331:
    mov       rax,	[r14+16]
    mov       rcx,	rax
    mov       rdx,	1
    mov       r8,	65
    xor       r9d,	r9d
    call      mm_genpcl.genidata
    jmp       L5327
L5332:
    mov       rax,	[r14+16]
    mov       rax,	[rax+16]
    mov       rcx,	rax
    call      pc_api.genint
    mov       rcx,	125
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	rdi
    call      mm_libpcl.setmode
    jmp       L5327
L5333:
    mov       rax,	[r14+24]
    test      rax,	rax
    jz        L5370
    mov       rax,	[r14+24]
    mov       rax,	[rax+16]
    jmp       L5369
L5370:
    xor       eax,	eax
L5369:
    mov       r10,	[r14+16]
    mov       rcx,	r10
    mov       rdx,	1
    mov       r8,	80
    mov       r9,	rax
    call      mm_genpcl.genidata
    jmp       L5327
L5334:
    movzx     rax,	byte [r14]
    lea       r10,	[mm_tables.jtagnames]
    mov       r10,	[r10 + rax*8]
    lea       rcx,	[L12824]
    mov       rdx,	r10
    mov       r8,	r14
    call      mm_support.gerror_s
L5327:
L5326:
;---------------
    add       rsp,	2048
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_genpcl.genmem_u
mm_genpcl.genmem_u:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rax,	[rdi+16]
    mov       rcx,	rax
    call      mm_libpcl.getpsymbol
    mov       rcx,	rax
    call      pc_api.genmem
L5371:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_genpcl.genmem_d
mm_genpcl.genmem_d:
;?>>
   %define R.d rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      mm_libpcl.getpsymbol
    mov       rcx,	rax
    call      pc_api.genmem
L5372:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_genpcl.genpushmem_d
mm_genpcl.genpushmem_d:
;?>>
   %define R.d rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      mm_libpcl.getpsymbol
    mov       rcx,	rax
    call      pc_api.genmem
    mov       rcx,	1
    mov       rdx,	rax
    call      pc_api.pc_gen
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_genpcl.genmemaddr_d
mm_genpcl.genmemaddr_d:
;?>>
   %define R.d rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      mm_libpcl.getpsymbol
    mov       rcx,	rax
    call      pc_api.genmemaddr
L5374:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_genpcl.genpushmemaddr_d
mm_genpcl.genpushmemaddr_d:
;?>>
   %define R.d rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      mm_libpcl.getpsymbol
    mov       rcx,	rax
    call      pc_api.genmemaddr
    mov       rcx,	1
    mov       rdx,	rax
    call      pc_api.pc_gen
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_genpcl.definelabel
mm_genpcl.definelabel:
;?>>
;?]]
    sub       rsp,	40
;---------------
    inc       qword [pc_api.mlabelno]
    mov       rax,	[pc_api.mlabelno]
    mov       rcx,	rax
    call      pc_api.genlabel
    mov       rcx,	127
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rax,	[pc_api.mlabelno]
L5376:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mm_genpcl.createfwdlabel
mm_genpcl.createfwdlabel:
;?>>
;?]]
;---------------
    inc       qword [pc_api.mlabelno]
    mov       rax,	[pc_api.mlabelno]
L5377:
;---------------
    ret       
;End 
;Proc mm_genpcl.definefwdlabel
mm_genpcl.definefwdlabel:
;?>>
   %define R.lab rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      pc_api.genlabel
    mov       rcx,	127
    mov       rdx,	rax
    call      pc_api.pc_gen
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_genpcl.genreturn
mm_genpcl.genreturn:
;?>>
;?]]
    sub       rsp,	40
;---------------
    mov       rax,	[mm_decls.currproc]
    movzx     rax,	byte [rax+122]
    test      rax,	rax
    jz        L5381
    cmp       rax,	1
    jz        L5382
    jmp       L5383
L5381:
    mov       rcx,	20
    xor       edx,	edx
    call      pc_api.pc_gen
    jmp       L5380
L5382:
    mov       rcx,	23
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rax,	[mm_decls.currproc]
    movsxd    rax,	dword [rax+72]
    mov       rcx,	rax
    call      mm_libpcl.setmode
    jmp       L5380
L5383:
    mov       rax,	[mm_decls.currproc]
    movzx     rax,	byte [rax+122]
    mov       rcx,	23
    mov       rdx,	rax
    xor       r8d,	r8d
    call      pc_api.pc_genx
L5380:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mm_genpcl.reversecond
mm_genpcl.reversecond:
;?>>
   %define R.cc rcx
;?]]
;---------------
    mov       rax,	rcx
    cmp       rax,	1
    jz        L5386
    cmp       rax,	2
    jz        L5387
    cmp       rax,	3
    jz        L5388
    cmp       rax,	4
    jz        L5389
    cmp       rax,	5
    jz        L5390
    cmp       rax,	6
    jz        L5391
    jmp       L5392
L5386:
    mov       rax,	2
    mov       rcx,	rax
    jmp       L5385
L5387:
    mov       rax,	1
    mov       rcx,	rax
    jmp       L5385
L5388:
    mov       rax,	5
    mov       rcx,	rax
    jmp       L5385
L5389:
    mov       rax,	6
    mov       rcx,	rax
    jmp       L5385
L5390:
    mov       rax,	3
    mov       rcx,	rax
    jmp       L5385
L5391:
    mov       rax,	4
    mov       rcx,	rax
L5392:
L5385:
    mov       rax,	rcx
L5384:
;---------------
    ret       
;End 
;Proc mm_genpcl.reversecond_order
mm_genpcl.reversecond_order:
;?>>
   %define R.cc rcx
;?]]
;---------------
    mov       rax,	rcx
    cmp       rax,	1
    jz        L5395
    cmp       rax,	2
    jz        L5396
    cmp       rax,	3
    jz        L5397
    cmp       rax,	4
    jz        L5398
    cmp       rax,	5
    jz        L5399
    cmp       rax,	6
    jz        L5400
    jmp       L5401
L5395:
    mov       rax,	1
    mov       rcx,	rax
    jmp       L5394
L5396:
    mov       rax,	2
    mov       rcx,	rax
    jmp       L5394
L5397:
    mov       rax,	6
    mov       rcx,	rax
    jmp       L5394
L5398:
    mov       rax,	5
    mov       rcx,	rax
    jmp       L5394
L5399:
    mov       rax,	4
    mov       rcx,	rax
    jmp       L5394
L5400:
    mov       rax,	3
    mov       rcx,	rax
L5401:
L5394:
    mov       rax,	rcx
L5393:
;---------------
    ret       
;End 
;Proc mm_genpcl.stacklooplabels
mm_genpcl.stacklooplabels:
;?>>
   %define R.a rdi
   %define R.b rbx
   %define R.c rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    inc       qword [mm_genpcl.loopindex]
    mov       rax,	[mm_genpcl.loopindex]
    cmp       rax,	50
    jle       L5404
    lea       rcx,	[L12825]
    xor       edx,	edx
    call      mm_support.gerror
L5404:
    lea       rax,	[mm_genpcl.loopstack]
    mov       r10,	[mm_genpcl.loopindex]
    shl       r10,	5
    lea       rax,	[rax + r10-32]
    mov       r10,	rdi
    mov       [rax],	r10
    lea       rax,	[mm_genpcl.loopstack]
    mov       r10,	[mm_genpcl.loopindex]
    shl       r10,	5
    lea       rax,	[rax + r10-32]
    mov       r10,	rbx
    mov       [rax+8],	r10
    lea       rax,	[mm_genpcl.loopstack]
    mov       r10,	[mm_genpcl.loopindex]
    shl       r10,	5
    lea       rax,	[rax + r10-32]
    mov       r10,	rsi
    mov       [rax+16],	r10
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_genpcl.findlooplabel
mm_genpcl.findlooplabel:
;?>>
   %define R.k rbx
   %define R.n rsi
   %define R.i rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    lea       rax,	[rsi-1]
    mov       r10,	[mm_genpcl.loopindex]
    sub       r10,	rax
    mov       rdi,	r10
    cmp       rdi,	1
    jl        L5408
    cmp       rdi,	[mm_genpcl.loopindex]
    jle       L5407
L5408:
    lea       rcx,	[L12826]
    xor       edx,	edx
    call      mm_support.gerror
L5407:
    lea       rax,	[mm_genpcl.loopstack]
    mov       r10,	rdi
    shl       r10,	5
    lea       rax,	[rax + r10-32]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8-8]
L5405:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_genpcl.genpc_sysfn
mm_genpcl.genpc_sysfn:
;?>>
   %define R.fnindex rdi
   %define R.a rbx
   %define R.b rsi
   %define R.c r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
    mov       r12,	r9
;---------------
    sub       rsp,	8
    push      1
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	rsi
    mov       r9,	r12
    sub       rsp,	32
    call      mm_genpcl.genpc_sysproc
    add       rsp,	48
;---------------
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_genpcl.genpc_sysproc
mm_genpcl.genpc_sysproc:
;?>>
   %define R.fnindex r12
   %define R.a r13
   %define R.b r14
    %define mm_genpcl.genpc_sysproc.c 88
    %define mm_genpcl.genpc_sysproc.asfunc 96
    %define mm_genpcl.genpc_sysproc.nargs -8
   %define R.opc rdi
   %define R.d rbx
   %define R.p rsi
    %define mm_genpcl.genpc_sysproc.$T1 -16
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       r12,	rcx
    mov       r13,	rdx
    mov       r14,	r8
    mov       [rbp+88],	r9
;---------------
    xor       eax,	eax
    mov       [rbp + mm_genpcl.genpc_sysproc.nargs],	rax
    xor       rdi,	rdi
    mov       rcx,	131
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rsi,	[pc_api.pccurr]
    mov       rcx,	[rbp + mm_genpcl.genpc_sysproc.c]
    mov       rdx,	3
    lea       r8,	[rbp + mm_genpcl.genpc_sysproc.nargs]
    call      mm_genpcl.pushsysarg
    mov       rcx,	r14
    mov       rdx,	2
    lea       r8,	[rbp + mm_genpcl.genpc_sysproc.nargs]
    call      mm_genpcl.pushsysarg
    mov       rcx,	r13
    mov       rdx,	1
    lea       r8,	[rbp + mm_genpcl.genpc_sysproc.nargs]
    call      mm_genpcl.pushsysarg
    mov       eax,	[rbp + mm_genpcl.genpc_sysproc.nargs]
    mov       [rsi+16],	eax
    mov       rcx,	r12
    call      mm_genpcl.getsysfnhandler
    mov       rbx,	rax
    test      rbx,	rbx
    jz        L5412
    mov       rcx,	rbx
    call      mm_libpcl.getpsymbol
    mov       rcx,	rax
    call      pc_api.genmemaddr
    mov       [rbp + mm_genpcl.genpc_sysproc.$T1],	rax
    mov       rax,	[rbp + mm_genpcl.genpc_sysproc.asfunc]
    test      rax,	rax
    jz        L5414
    mov       rax,	21
    jmp       L5413
L5414:
    mov       rax,	18
L5413:
    mov       rcx,	rax
    mov       rdx,	[rbp + mm_genpcl.genpc_sysproc.$T1]
    call      pc_api.pc_gen
    mov       rcx,	[rbp + mm_genpcl.genpc_sysproc.nargs]
    call      pc_api.pc_setnargs
    jmp       L5411
L5412:
    lea       rax,	[mm_tables.sysfnnames]
    mov       r10,	r12
    mov       rax,	[rax + r10*8-8]
    lea       rax,	[rax+3]
    mov       rcx,	rax
    call      pc_api.gennameaddr
    mov       [rbp + mm_genpcl.genpc_sysproc.$T1],	rax
    mov       rax,	[rbp + mm_genpcl.genpc_sysproc.asfunc]
    test      rax,	rax
    jz        L5416
    mov       rax,	21
    jmp       L5415
L5416:
    mov       rax,	18
L5415:
    mov       rcx,	rax
    mov       rdx,	[rbp + mm_genpcl.genpc_sysproc.$T1]
    call      pc_api.pc_gen
L5411:
    mov       eax,	[rbp + mm_genpcl.genpc_sysproc.nargs]
    mov       r10,	[pc_api.pccurr]
    mov       [r10+16],	eax
;---------------
    add       rsp,	48
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_genpcl.pushsysarg
mm_genpcl.pushsysarg:
;?>>
   %define R.p rdi
   %define R.n rbx
   %define R.nargs rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    test      rdi,	rdi
    jz        L5419
    mov       rcx,	rdi
    call      mm_blockpcl.evalunit
    mov       rcx,	132
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	rdi
    call      mm_libpcl.setmode_u
    mov       eax,	ebx
    mov       r10,	[pc_api.pccurr]
    mov       [r10+16],	eax
    mov       eax,	ebx
    mov       r10,	[pc_api.pccurr]
    mov       [r10+20],	eax
    mov       rax,	rsi
    inc       qword [rax]
L5419:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_genpcl.start
mm_genpcl.start:
;?>>
;?]]
;---------------
    mov       al,	1
    lea       r10,	[mm_genpcl.zero_unit]
    mov       [r10],	al
    mov       eax,	3
    lea       r10,	[mm_genpcl.zero_unit]
    mov       [r10+49],	eax
    xor       eax,	eax
    lea       r10,	[mm_genpcl.zero_unit]
    mov       [r10+16],	rax
    mov       al,	1
    lea       r10,	[mm_genpcl.zero_unit]
    mov       [r10+61],	al
;---------------
    ret       
;End 
;Proc mm_genpcl.getsysfnhandler
mm_genpcl.getsysfnhandler:
;?>>
   %define R.fn r12
   %define R.p rdi
    %define mm_genpcl.getsysfnhandler.str -304
   %define R.report rbx
   %define R.pp rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	336
    mov       r12,	rcx
;---------------
    lea       rax,	[mm_tables.sysfnhandlers]
    mov       r10,	r12
    mov       rax,	[rax + r10*8-8]
    test      rax,	rax
    jz        L5423
    lea       rax,	[mm_tables.sysfnhandlers]
    mov       r10,	r12
    mov       rax,	[rax + r10*8-8]
    jmp       L5421
L5423:
    lea       rcx,	[rbp + mm_genpcl.getsysfnhandler.str]
    lea       rdx,	[L12827]
    call      strcpy
    lea       rax,	[mm_tables.sysfnnames]
    mov       r10,	r12
    mov       rax,	[rax + r10*8-8]
    lea       rax,	[rax+3]
    lea       rcx,	[rbp + mm_genpcl.getsysfnhandler.str]
    mov       rdx,	rax
    call      strcat
    mov       rsi,	[mm_decls.proclist]
    jmp       L5427
L5424:
    mov       rax,	[rsi]
    mov       rax,	[rax]
    mov       rcx,	rax
    lea       rdx,	[rbp + mm_genpcl.getsysfnhandler.str]
    call      mlib.eqstring
    test      rax,	rax
    jz        L5429
    mov       rax,	[rsi]
    lea       r10,	[mm_tables.sysfnhandlers]
    mov       r11,	r12
    mov       [r10 + r11*8-8],	rax
    mov       rax,	[rsi]
    jmp       L5421
L5429:
    mov       rsi,	[rsi+8]
L5427:
    test      rsi,	rsi
    jnz       L5424
    mov       rbx,	1
    xor       rbx,	rbx
    mov       rax,	rbx
    test      rax,	rax
    jz        L5431
    call      msys.m$print_startcon
    lea       rcx,	[L12828]
    call      msys.m$print_str_nf
    lea       rcx,	[rbp + mm_genpcl.getsysfnhandler.str]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L5431:
    cmp       r12,	33
    jz        L5433
    mov       rcx,	33
    call      mm_genpcl.getsysfnhandler
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L5435
    test      rbx,	rbx
    jz        L5435
    lea       rcx,	[L12829]
    xor       edx,	edx
    call      mm_support.gerror
L5435:
    mov       rax,	rdi
    jmp       L5421
L5433:
    xor       eax,	eax
L5421:
;---------------
    add       rsp,	336
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_genpcl.findhostfn
mm_genpcl.findhostfn:
;?>>
   %define R.opc rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    cmp       rdi,	82
    jnz       L5439
L5438:
    mov       rcx,	32
    call      mm_genpcl.getsysfnhandler
    mov       rcx,	rax
    call      mm_libpcl.getpsymbol
    jmp       L5437
L5439:
    xor       eax,	eax
L5437:
L5436:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_genpcl.genpushint
mm_genpcl.genpushint:
;?>>
   %define R.a rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      pc_api.genint
    mov       rcx,	1
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	3
    call      mm_libpcl.setmode
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_genpcl.genpushreal
mm_genpcl.genpushreal:
;?>>
   %define R.x XMM15
   %define R.mode rdi
    push      rdi
    movq      rax,	XMM15
    push      rax
;?]]
    sub       rsp,	40
    movq      XMM15,	XMM0
    mov       rdi,	rdx
;---------------
    mov       rcx,	rdi
    call      mm_lib.getpclmode
    movq      XMM0,	XMM15
    mov       rdx,	rax
    call      pc_api.genreal
    mov       rcx,	1
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	rdi
    call      mm_libpcl.setmode
;---------------
    add       rsp,	40
    pop       rcx
    movq      XMM15,	rcx
    pop       rdi
    ret       
;End 
;Proc mm_genpcl.genpushstring
mm_genpcl.genpushstring:
;?>>
   %define R.s rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      pc_api.genstring
    mov       rcx,	1
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	4
    call      mm_libpcl.setmode
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_genpcl.genmaindef
mm_genpcl.genmaindef:
;?>>
   %define R.p rsi
   %define R.d rdi
   %define R.i rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    mov       eax,	[rsi+88]
    mov       [pc_decls.mmpos],	rax
    mov       rcx,	rsi
    mov       rdx,	1
    call      mm_genpcl.doprocdef
    call      mm_genpcl.createfwdlabel
    mov       [mm_genpcl.retindex],	rax
    mov       rbx,	1
    mov       rax,	[mm_decls.nsubprogs]
    cmp       rax,	1
    jl        L5446
L5444:
    cmp       rbx,	[mm_decls.mainsubprogno]
    jz        L5448
    lea       rax,	[mm_decls.subprogs]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8]
    movsx     rax,	word [rax+10]
    lea       r10,	[mm_decls.modules]
    mov       r10,	[r10 + rax*8]
    mov       r10,	[r10+48]
    mov       rdi,	r10
    mov       rcx,	rdi
    call      mm_genpcl.docallproc
L5448:
    inc       rbx
    cmp       rbx,	[mm_decls.nsubprogs]
    jle       L5444
L5446:
    lea       rax,	[mm_decls.subprogs]
    mov       r10,	[mm_decls.mainsubprogno]
    mov       rax,	[rax + r10*8]
    movsx     rax,	word [rax+10]
    lea       r10,	[mm_decls.modules]
    mov       r10,	[r10 + rax*8]
    mov       r10,	[r10+48]
    mov       rdi,	r10
    mov       rcx,	rdi
    call      mm_genpcl.docallproc
    lea       rcx,	[L12830]
    call      pc_api.gencomment
    mov       rcx,	[rsi+64]
    call      mm_blockpcl.evalunit
    lea       rcx,	[L12830]
    call      pc_api.gencomment
    mov       rcx,	[mm_genpcl.retindex]
    call      mm_genpcl.definefwdlabel
    xor       ecx,	ecx
    call      pc_api.genint
    mov       rcx,	1
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	3
    call      mm_libpcl.setmode
    mov       rcx,	32
    xor       edx,	edx
    call      pc_api.pc_gen
    call      mm_genpcl.genreturn
    call      pc_api.pc_endproc
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_genpcl.genstartdef
mm_genpcl.genstartdef:
;?>>
   %define R.p r14
   %define R.d rdi
   %define R.lead rbx
   %define R.m rsi
   %define R.s r12
   %define R.i r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       r14,	rcx
;---------------
    xor       rbx,	rbx
    movzx     rax,	byte [r14+94]
    mov       rsi,	rax
    movzx     rax,	byte [r14+95]
    mov       r12,	rax
    cmp       r12,	[mm_decls.mainsubprogno]
    jnz       L5451
    movzx     rax,	byte [r14+94]
    lea       r10,	[mm_decls.subprogs]
    mov       r11,	r12
    mov       r10,	[r10 + r11*8]
    movsx     r10,	word [r10+10]
    cmp       rax,	r10
    jnz       L5451
    mov       rbx,	1
    jmp       L5450
L5451:
    movzx     rax,	byte [r14+94]
    lea       r10,	[mm_decls.subprogs]
    mov       r11,	r12
    mov       r10,	[r10 + r11*8]
    movsx     r10,	word [r10+8]
    cmp       rax,	r10
    jnz       L5452
    mov       rbx,	2
L5452:
L5450:
    mov       eax,	[r14+88]
    mov       [pc_decls.mmpos],	rax
    mov       rcx,	r14
    xor       edx,	edx
    call      mm_genpcl.doprocdef
    call      mm_genpcl.createfwdlabel
    mov       [mm_genpcl.retindex],	rax
    test      rbx,	rbx
    jz        L5454
    mov       r13,	1
    mov       rax,	[mm_decls.nmodules]
    cmp       rax,	1
    jl        L5457
L5455:
    lea       rax,	[mm_decls.moduletosub]
    mov       r10,	r13
    movzx     rax,	byte [rax + r10]
    cmp       rax,	r12
    jnz       L5459
    cmp       r13,	rsi
    jz        L5459
    lea       rax,	[mm_decls.modules]
    mov       r10,	r13
    mov       rax,	[rax + r10*8]
    mov       rdi,	[rax+48]
    mov       rcx,	rdi
    call      mm_genpcl.docallproc
L5459:
    inc       r13
    cmp       r13,	[mm_decls.nmodules]
    jle       L5455
L5457:
L5454:
    lea       rcx,	[L12830]
    call      pc_api.gencomment
    mov       rcx,	[r14+64]
    call      mm_blockpcl.evalunit
    lea       rcx,	[L12830]
    call      pc_api.gencomment
    mov       rcx,	[mm_genpcl.retindex]
    call      mm_genpcl.definefwdlabel
    call      mm_genpcl.genreturn
    call      pc_api.pc_endproc
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_genpcl.initstaticvar
mm_genpcl.initstaticvar:
;?>>
   %define R.d rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rax,	[rdi+64]
    test      rax,	rax
    jz        L5462
    mov       rcx,	[rdi+64]
    call      mm_blockpcl.evalunit
L5462:
    mov       rcx,	rdi
    call      mm_genpcl.genmem_d
    mov       rcx,	4
    mov       rdx,	rax
    call      pc_api.pc_gen
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_genpcl.docallproc
mm_genpcl.docallproc:
;?>>
   %define R.d rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    test      rdi,	rdi
    jnz       L5465
    jmp       L5463
L5465:
    mov       rcx,	131
    xor       edx,	edx
    call      pc_api.pc_gen
    xor       ecx,	ecx
    call      pc_api.pc_setnargs
    mov       rcx,	rdi
    call      mm_genpcl.genmemaddr_d
    mov       rcx,	18
    mov       rdx,	rax
    call      pc_api.pc_gen
L5463:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_genpcl.doprocdef
mm_genpcl.doprocdef:
;?>>
   %define R.d rsi
   %define R.ismain r12
   %define R.p rdi
   %define R.e rbx
    %define mm_genpcl.doprocdef.$T1 -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    movzx     rax,	byte [rsi+124]
    mov       [rbp + mm_genpcl.doprocdef.$T1],	rax
    mov       rcx,	rsi
    call      mm_libpcl.getpsymbol
    mov       r10,	rax
    mov       rdi,	r10
    mov       rcx,	rax
    xor       edx,	edx
    mov       r8,	r12
    mov       r9,	[rbp + mm_genpcl.doprocdef.$T1]
    call      pc_api.pc_defproc
    mov       rbx,	[rsi+16]
    jmp       L5470
L5467:
    movzx     rax,	byte [rbx+78]
    cmp       rax,	12
    jz        L5472
    cmp       rax,	11
    jz        L5473
    jmp       L5474
L5472:
    mov       rcx,	rbx
    call      mm_libpcl.getpsymbol
    mov       rcx,	rax
    call      pc_api.pc_addparam
    jmp       L5471
L5473:
    movzx     rax,	word [rbx+92]
    shr       eax,	8
    and       eax,	1
    test      rax,	rax
    jz        L5477
    mov       rax,	[rbx+96]
    test      rax,	rax
    jnz       L5476
L5477:
    mov       rcx,	rbx
    call      mm_libpcl.getpsymbol
    mov       rcx,	rax
    call      pc_api.pc_addlocal
L5476:
L5474:
L5471:
    mov       rbx,	[rbx+32]
L5470:
    test      rbx,	rbx
    jnz       L5467
;---------------
    add       rsp,	48
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_genpcl.scanprocs
mm_genpcl.scanprocs:
;?>>
    %define mm_genpcl.scanprocs.proctable -8000
   %define R.currpcl rdi
   %define R.nprocs rbx
   %define R.i rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	8040
;---------------
    xor       rbx,	rbx
    mov       rax,	[pc_api.pcstart]
    mov       rdi,	rax
L5479:
    movzx     rax,	byte [rdi]
    cmp       rax,	120
    jz        L5484
    cmp       rax,	121
    jnz       L5483
L5484:
    mov       rax,	[rdi+8]
    mov       al,	[rax+109]
    test      al,	al
    jz        L5483
    cmp       rbx,	1000
    jl        L5486
    lea       rcx,	[L12831]
    xor       edx,	edx
    call      mm_support.gerror
L5486:
    mov       rax,	[rdi+8]
    inc       rbx
    mov       r10,	rbx
    mov       [rbp + r10*8 + mm_genpcl.scanprocs.proctable-8],	rax
L5483:
    add       rdi,	32
    cmp       rdi,	[pc_api.pccurr]
    jbe       L5479
    test      rbx,	rbx
    jnz       L5488
    mov       rax,	[mm_blockpcl.pnprocs]
    test      rax,	rax
    jnz       L5488
    lea       rcx,	[L12832]
    mov       rdx,	3
    call      pc_api.pc_makesymbol
    mov       [mm_blockpcl.pnprocs],	rax
    mov       al,	10
    mov       r10,	[mm_blockpcl.pnprocs]
    mov       [r10+82],	al
    jmp       L5489
L5488:
    call      mm_genpcl.setfunctab
    mov       rcx,	[mm_blockpcl.pprocaddr]
    call      pc_api.genmem
    mov       rcx,	123
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       al,	11
    mov       r10,	[pc_api.pccurr]
    mov       [r10+3],	al
    mov       rax,	rbx
    shl       rax,	3
    mov       r10,	[pc_api.pccurr]
    mov       [r10+4],	eax
    mov       al,	11
    mov       r10,	[mm_blockpcl.pprocaddr]
    mov       [r10+82],	al
    mov       rax,	[pc_api.pccurr]
    mov       eax,	[rax+4]
    mov       r10,	[mm_blockpcl.pprocaddr]
    mov       [r10+84],	eax
    mov       rsi,	1
    cmp       rbx,	1
    jl        L5492
L5490:
    mov       rax,	[rbp + rsi*8 + mm_genpcl.scanprocs.proctable-8]
    mov       rcx,	rax
    call      pc_api.genmemaddr
    mov       rcx,	125
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	4
    call      mm_libpcl.setmode
    inc       rsi
    cmp       rsi,	rbx
    jle       L5490
L5492:
    mov       rcx,	[mm_blockpcl.pprocname]
    call      pc_api.genmem
    mov       rcx,	123
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       al,	11
    mov       r10,	[pc_api.pccurr]
    mov       [r10+3],	al
    mov       rax,	rbx
    shl       rax,	3
    mov       r10,	[pc_api.pccurr]
    mov       [r10+4],	eax
    mov       al,	11
    mov       r10,	[mm_blockpcl.pprocname]
    mov       [r10+82],	al
    mov       rax,	[pc_api.pccurr]
    mov       eax,	[rax+4]
    mov       r10,	[mm_blockpcl.pprocname]
    mov       [r10+84],	eax
    mov       rsi,	1
    cmp       rbx,	1
    jl        L5495
L5493:
    mov       rax,	[rbp + rsi*8 + mm_genpcl.scanprocs.proctable-8]
    mov       rax,	[rax]
    mov       rcx,	rax
    call      pc_api.getbasename
    mov       rcx,	rax
    call      pc_api.genstring
    mov       rcx,	125
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	4
    call      mm_libpcl.setmode
    inc       rsi
    cmp       rsi,	rbx
    jle       L5493
L5495:
;mm_genpcl.scanprocs.finish:
L5489:
    mov       rcx,	[mm_blockpcl.pnprocs]
    call      pc_api.genmem
    mov       rcx,	123
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	3
    call      mm_libpcl.setmode
    mov       rcx,	rbx
    call      pc_api.genint
    mov       rcx,	125
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	3
    call      mm_libpcl.setmode
;---------------
    add       rsp,	8040
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_genpcl.setfunctab
mm_genpcl.setfunctab:
;?>>
;?]]
    sub       rsp,	40
;---------------
    mov       rax,	[mm_blockpcl.pnprocs]
    test      rax,	rax
    jnz       L5498
    lea       rcx,	[L12832]
    mov       rdx,	3
    call      pc_api.pc_makesymbol
    mov       [mm_blockpcl.pnprocs],	rax
    mov       al,	10
    mov       r10,	[mm_blockpcl.pnprocs]
    mov       [r10+82],	al
    lea       rcx,	[L12833]
    mov       rdx,	3
    call      pc_api.pc_makesymbol
    mov       [mm_blockpcl.pprocname],	rax
    lea       rcx,	[L12834]
    mov       rdx,	3
    call      pc_api.pc_makesymbol
    mov       [mm_blockpcl.pprocaddr],	rax
L5498:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mm_libpcl.getpsymbol
mm_libpcl.getpsymbol:
;?>>
   %define R.d r13
   %define R.p rdi
   %define R.e rbx
    %define mm_libpcl.getpsymbol.str -256
    %define mm_libpcl.getpsymbol.chain -384
   %define R.n rsi
   %define R.i r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	424
    mov       r13,	rcx
;---------------
    test      r13,	r13
    jnz       L5501
    xor       eax,	eax
    jmp       L5499
L5501:
    mov       rax,	[r13+56]
    test      rax,	rax
    jz        L5503
    mov       rax,	[r13+56]
    jmp       L5499
L5503:
    movzx     rax,	word [r13+92]
    shr       eax,	8
    and       eax,	1
    test      rax,	rax
    jz        L5505
    mov       rax,	[r13+96]
    test      rax,	rax
    jz        L5505
    mov       rcx,	r13
    call      mm_libpcl.getequivdef
    mov       r10,	rax
    mov       rbx,	r10
    mov       rcx,	rax
    call      mm_libpcl.getpsymbol
    mov       rax,	[rbx+56]
    mov       [r13+56],	rax
    mov       rax,	[rbx+56]
    jmp       L5499
L5505:
    movzx     rax,	byte [r13+78]
    cmp       rax,	11
    jz        L5508
    cmp       rax,	12
    jz        L5508
    movzx     rax,	word [r13+92]
    shr       eax,	11
    and       eax,	1
    test      rax,	rax
    jz        L5507
L5508:
    mov       rax,	[r13+104]
    test      rax,	rax
    jz        L5510
    mov       rax,	[r13+104]
    jmp       L5509
L5510:
    mov       rax,	[r13]
L5509:
    lea       rcx,	[rbp + mm_libpcl.getpsymbol.str]
    mov       rdx,	rax
    call      strcpy
    jmp       L5506
L5507:
    mov       rbx,	r13
    xor       rsi,	rsi
L5511:
    inc       rsi
    mov       rax,	rsi
    mov       r10,	rbx
    mov       [rbp + rax*8 + mm_libpcl.getpsymbol.chain-8],	r10
    mov       rbx,	[rbx+8]
    test      rbx,	rbx
    jz        L5514
    movzx     rax,	byte [rbx+78]
    cmp       rax,	1
    jnz       L5511
L5514:
    mov       rax,	[rbp + rsi*8 + mm_libpcl.getpsymbol.chain-8]
    mov       rax,	[rax]
    lea       rcx,	[rbp + mm_libpcl.getpsymbol.str]
    mov       rdx,	rax
    call      strcpy
    lea       rax,	[rsi-1]
    mov       r12,	rax
    cmp       r12,	1
    jl        L5517
L5515:
    lea       rcx,	[rbp + mm_libpcl.getpsymbol.str]
    lea       rdx,	[L12835]
    call      strcat
    mov       rax,	[rbp + r12*8 + mm_libpcl.getpsymbol.chain-8]
    mov       rax,	[rax+104]
    test      rax,	rax
    jz        L5519
    mov       rax,	[rbp + r12*8 + mm_libpcl.getpsymbol.chain-8]
    mov       rax,	[rax+104]
    lea       rcx,	[rbp + mm_libpcl.getpsymbol.str]
    mov       rdx,	rax
    call      strcat
    jmp       L5518
L5519:
    mov       rax,	[rbp + r12*8 + mm_libpcl.getpsymbol.chain-8]
    mov       rax,	[rax]
    lea       rcx,	[rbp + mm_libpcl.getpsymbol.str]
    mov       rdx,	rax
    call      strcat
L5518:
    dec       r12
    cmp       r12,	1
    jge       L5515
L5517:
L5506:
    movzx     rax,	byte [r13+78]
    lea       r10,	[mm_tables.name2pid]
    movzx     r10,	byte [r10 + rax]
    lea       rcx,	[rbp + mm_libpcl.getpsymbol.str]
    mov       rdx,	r10
    call      pc_api.pc_makesymbol
    mov       rdi,	rax
    mov       [r13+56],	rax
    movsxd    rax,	dword [r13+72]
    mov       rcx,	rax
    call      mm_lib.getpclmode
    mov       [rdi+82],	al
    movsxd    rax,	dword [r13+72]
    lea       r10,	[mm_decls.ttsize]
    mov       r10d,	[r10 + rax*4]
    mov       [rdi+84],	r10d
    mov       rax,	[r13+8]
    test      rax,	rax
    jz        L5521
    mov       rax,	[r13+8]
    mov       rax,	[rax+8]
    test      rax,	rax
    jz        L5521
    mov       rax,	[r13+8]
    mov       rcx,	rax
    call      mm_libpcl.getpsymbol
    mov       [rdi+32],	rax
L5521:
    movzx     rax,	byte [r13+170]
    cmp       rax,	3
    jnz       L5523
    mov       al,	1
    mov       [rdi+81],	al
L5523:
    movzx     rax,	byte [r13+78]
    cmp       rax,	7
    jz        L5526
    cmp       rax,	8
    jnz       L5525
L5526:
    mov       al,	1
    mov       [rdi+80],	al
L5525:
    mov       ax,	[r13+168]
    mov       [rdi+92],	al
    mov       eax,	[r13+80]
    mov       [rdi+100],	eax
    movzx     rax,	word [r13+92]
    shr       eax,	6
    and       eax,	1
    mov       [rdi+109],	al
    mov       al,	[r13+124]
    mov       [rdi+108],	al
    mov       al,	[r13+123]
    mov       [rdi+107],	al
    mov       rbx,	[r13+8]
    xor       eax,	eax
    test      ax,	ax
    jz        L5528
    movzx     rax,	byte [r13+78]
    cmp       rax,	10
    jnz       L5528
    test      rbx,	rbx
    jz        L5528
    movzx     rax,	byte [rbx+78]
    cmp       rax,	6
    jnz       L5528
    mov       rax,	[r13+64]
    test      rax,	rax
    jz        L5528
    mov       rax,	[rbx+56]
    mov       [rdi+56],	rax
    mov       rax,	[rbx+56]
    lea       rax,	[rax+104]
    or        byte [rax],	2
L5528:
    mov       rax,	rdi
L5499:
;---------------
    add       rsp,	424
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_libpcl.setmode
mm_libpcl.setmode:
;?>>
   %define R.mode rdi
    %define mm_libpcl.setmode.$T1 -8
    push      rdi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       rdi,	rcx
;---------------
    lea       rax,	[mm_decls.ttsize]
    mov       r10,	rdi
    mov       eax,	[rax + r10*4]
    mov       [rbp + mm_libpcl.setmode.$T1],	rax
    mov       rcx,	rdi
    call      mm_lib.getpclmode
    mov       rcx,	rax
    mov       rdx,	[rbp + mm_libpcl.setmode.$T1]
    call      pc_api.pc_setmode
;---------------
    add       rsp,	40
    pop       rbp
    pop       rdi
    ret       
;End 
;Proc mm_libpcl.setmode2
mm_libpcl.setmode2:
;?>>
   %define R.mode rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      mm_lib.getpclmode
    mov       rcx,	rax
    call      pc_api.pc_setmode2
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_libpcl.setmode_u
mm_libpcl.setmode_u:
;?>>
   %define R.p rbx
   %define R.mode rdi
    %define mm_libpcl.setmode_u.$T1 -8
    push      rdi
    push      rbx
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       rbx,	rcx
;---------------
    movsxd    rax,	dword [rbx+49]
    mov       rdi,	rax
    lea       rax,	[mm_decls.ttsize]
    mov       r10,	rdi
    mov       eax,	[rax + r10*4]
    mov       [rbp + mm_libpcl.setmode_u.$T1],	rax
    mov       rcx,	rdi
    call      mm_lib.getpclmode
    mov       rcx,	rax
    mov       rdx,	[rbp + mm_libpcl.setmode_u.$T1]
    call      pc_api.pc_setmode
;---------------
    add       rsp,	48
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_libpcl.getequivdef
mm_libpcl.getequivdef:
;?>>
   %define R.d rbx
   %define R.p rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rdi,	[rbx+96]
    movzx     rax,	byte [rdi]
    cmp       rax,	4
    jz        L5534
    cmp       rax,	58
    jz        L5535
    jmp       L5536
L5534:
    mov       rax,	[rdi+16]
    jmp       L5533
L5535:
    mov       rax,	[rdi+16]
    mov       rax,	[rax+16]
    jmp       L5533
L5536:
    lea       rcx,	[L12836]
    xor       edx,	edx
    call      mm_support.gerror
    xor       eax,	eax
L5533:
L5532:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.evalunit
mm_blockpcl.evalunit:
;?>>
   %define R.p r12
   %define R.a rdi
   %define R.b rbx
   %define R.c rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       r12,	rcx
;---------------
    test      r12,	r12
    jnz       L5539
    jmp       L5537
L5539:
    mov       eax,	[r12+4]
    mov       [pc_decls.mmpos],	rax
    mov       rdi,	[r12+16]
    mov       rbx,	[r12+24]
    mov       rsi,	[r12+32]
    movzx     rax,	byte [r12]
    sub       rax,	1
    cmp       rax,	122
    jae       L5542
    lea       r10,	[L5541]
    jmp       [r10 + rax*8]
    segment .data
L5541:
    dq  L5543
    dq  L5544
    dq  L5542
    dq  L5545
    dq  L5542
    dq  L5546
    dq  L5542
    dq  L5607
    dq  L5542
    dq  L5542
    dq  L5542
    dq  L5542
    dq  L5542
    dq  L5609
    dq  L5580
    dq  L5581
    dq  L5597
    dq  L5598
    dq  L5599
    dq  L5542
    dq  L5542
    dq  L5542
    dq  L5542
    dq  L5542
    dq  L5549
    dq  L5542
    dq  L5542
    dq  L5550
    dq  L5552
    dq  L5551
    dq  L5553
    dq  L5547
    dq  L5582
    dq  L5583
    dq  L5584
    dq  L5596
    dq  L5542
    dq  L5604
    dq  L5605
    dq  L5600
    dq  L5542
    dq  L5542
    dq  L5542
    dq  L5542
    dq  L5542
    dq  L5585
    dq  L5542
    dq  L5610
    dq  L5588
    dq  L5542
    dq  L5586
    dq  L5587
    dq  L5589
    dq  L5542
    dq  L5590
    dq  L5591
    dq  L5542
    dq  L5592
    dq  L5594
    dq  L5542
    dq  L5593
    dq  L5595
    dq  L5542
    dq  L5542
    dq  L5542
    dq  L5542
    dq  L5542
    dq  L5542
    dq  L5542
    dq  L5542
    dq  L5542
    dq  L5542
    dq  L5542
    dq  L5542
    dq  L5542
    dq  L5542
    dq  L5542
    dq  L5542
    dq  L5542
    dq  L5542
    dq  L5542
    dq  L5542
    dq  L5542
    dq  L5542
    dq  L5542
    dq  L5542
    dq  L5542
    dq  L5542
    dq  L5548
    dq  L5606
    dq  L5554
    dq  L5555
    dq  L5556
    dq  L5557
    dq  L5558
    dq  L5559
    dq  L5560
    dq  L5561
    dq  L5562
    dq  L5563
    dq  L5564
    dq  L5565
    dq  L5566
    dq  L5567
    dq  L5568
    dq  L5569
    dq  L5570
    dq  L5570
    dq  L5570
    dq  L5570
    dq  L5572
    dq  L5573
    dq  L5571
    dq  L5574
    dq  L5574
    dq  L5575
    dq  L5575
    dq  L5576
    dq  L5577
    dq  L5578
    dq  L5579
    dq  L5608
    segment .text
L5543:
    mov       rcx,	r12
    call      mm_blockpcl.do_const
    jmp       L5540
L5544:
    jmp       L5540
L5545:
    mov       rcx,	r12
    call      mm_blockpcl.do_name
    jmp       L5540
L5546:
    mov       rcx,	r12
    call      mm_blockpcl.do_block
    jmp       L5540
L5547:
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_blockpcl.do_callproc
    jmp       L5540
L5548:
    mov       rcx,	r12
    mov       rdx,	rdi
    call      mm_blockpcl.do_return
    jmp       L5540
L5549:
    mov       rcx,	r12
    mov       rdx,	rdi
    call      mm_blockpcl.do_returnmult
    jmp       L5540
L5550:
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_blockpcl.do_assign
    jmp       L5540
L5551:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mm_blockpcl.do_assignms
    jmp       L5540
L5552:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mm_blockpcl.do_assignmm
    jmp       L5540
L5553:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mm_blockpcl.do_assignmdrem
    jmp       L5540
L5554:
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_blockpcl.do_to
    jmp       L5540
L5555:
    sub       rsp,	8
    push      0
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    mov       r9,	rsi
    sub       rsp,	32
    call      mm_blockpcl.do_if
    add       rsp,	48
    jmp       L5540
L5556:
    sub       rsp,	8
    push      0
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    mov       r9,	rsi
    sub       rsp,	32
    call      mm_blockpcl.do_for
    add       rsp,	48
    jmp       L5540
L5557:
    sub       rsp,	8
    push      1
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    mov       r9,	rsi
    sub       rsp,	32
    call      mm_blockpcl.do_for
    add       rsp,	48
    jmp       L5540
L5558:
    sub       rsp,	8
    push      0
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    mov       r9,	rsi
    sub       rsp,	32
    call      mm_blockpcl.do_forall
    add       rsp,	48
    jmp       L5540
L5559:
    sub       rsp,	8
    push      1
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    mov       r9,	rsi
    sub       rsp,	32
    call      mm_blockpcl.do_forall
    add       rsp,	48
    jmp       L5540
L5560:
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    mov       r9,	rsi
    call      mm_blockpcl.do_while
    jmp       L5540
L5561:
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_blockpcl.do_repeat
    jmp       L5540
L5562:
    mov       rcx,	rdi
    call      mm_blockpcl.do_goto
    jmp       L5540
L5563:
    mov       rcx,	r12
    call      mm_blockpcl.do_labeldef
    jmp       L5540
L5564:
    mov       rcx,	r12
    mov       rdx,	1
    call      mm_blockpcl.do_exit
    jmp       L5540
L5565:
    mov       rcx,	r12
    mov       rdx,	2
    call      mm_blockpcl.do_exit
    jmp       L5540
L5566:
    mov       rcx,	r12
    mov       rdx,	3
    call      mm_blockpcl.do_exit
    jmp       L5540
L5567:
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_blockpcl.do_do
    jmp       L5540
L5568:
    push      0
    push      0
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    mov       r9,	rsi
    sub       rsp,	32
    call      mm_blockpcl.do_case
    add       rsp,	48
    jmp       L5540
L5569:
    push      0
    push      1
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    mov       r9,	rsi
    sub       rsp,	32
    call      mm_blockpcl.do_case
    add       rsp,	48
    jmp       L5540
L5570:
    sub       rsp,	8
    push      0
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    mov       r9,	rsi
    sub       rsp,	32
    call      mm_blockpcl.do_switch
    add       rsp,	48
    jmp       L5540
L5571:
    mov       rcx,	r12
    mov       rdx,	rdi
    call      mm_blockpcl.do_recase
    jmp       L5540
L5572:
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_blockpcl.do_swap
    jmp       L5540
L5573:
    sub       rsp,	8
    push      0
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    mov       r9,	rsi
    sub       rsp,	32
    call      mm_blockpcl.do_select
    add       rsp,	48
    jmp       L5540
L5574:
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_blockpcl.do_print
    jmp       L5540
L5575:
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_blockpcl.do_print
    jmp       L5540
L5576:
    mov       rcx,	r12
    mov       rdx,	rdi
    call      mm_blockpcl.do_read
    jmp       L5540
L5577:
    mov       rcx,	rdi
    call      mm_blockpcl.do_readln
    jmp       L5540
L5578:
    mov       rcx,	r12
    mov       rdx,	rdi
    call      mm_blockpcl.do_stop
    jmp       L5540
L5579:
    mov       rcx,	rdi
    call      mm_blockpcl.evalunit
    mov       rcx,	134
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	rdi
    call      mm_libpcl.setmode_u
    jmp       L5540
L5580:
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_blockpcl.do_andl
    jmp       L5540
L5581:
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_blockpcl.do_orl
    jmp       L5540
L5582:
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_blockpcl.do_setcc
    jmp       L5540
L5583:
    mov       rcx,	r12
    mov       rdx,	rdi
    call      mm_blockpcl.do_setccchain
    jmp       L5540
L5584:
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_blockpcl.do_bin
    jmp       L5540
L5585:
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_blockpcl.do_index
    jmp       L5540
L5586:
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_blockpcl.do_dotindex
    jmp       L5540
L5587:
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_blockpcl.do_dotslice
    jmp       L5540
L5588:
    mov       rcx,	r12
    call      mm_blockpcl.do_dot
    jmp       L5540
L5589:
    mov       rcx,	r12
    mov       rdx,	rdi
    call      mm_blockpcl.do_ptr
    jmp       L5540
L5590:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mm_blockpcl.evalref
    jmp       L5540
L5591:
    mov       rcx,	rdi
    xor       edx,	edx
    call      mm_blockpcl.evalref
    jmp       L5540
L5592:
    mov       rcx,	r12
    mov       rdx,	rdi
    call      mm_blockpcl.do_convert
    jmp       L5540
L5593:
    mov       rcx,	r12
    mov       rdx,	rdi
    call      mm_blockpcl.do_typepun
    jmp       L5540
L5594:
    mov       rcx,	r12
    mov       rdx,	rdi
    call      mm_blockpcl.do_shorten
    jmp       L5540
L5595:
    mov       rcx,	r12
    call      mm_blockpcl.do_typeconst
    jmp       L5540
L5596:
    mov       rcx,	r12
    mov       rdx,	rdi
    call      mm_blockpcl.do_unary
    jmp       L5540
L5597:
    mov       rcx,	r12
    mov       rdx,	rdi
    call      mm_blockpcl.do_notl
    jmp       L5540
L5598:
    mov       rcx,	r12
    mov       rdx,	rdi
    call      mm_blockpcl.do_istruel
    jmp       L5540
L5599:
    mov       rcx,	r12
    mov       rdx,	rdi
    call      mm_blockpcl.do_isfalsel
    jmp       L5540
L5600:
    movzx     rax,	byte [r12+62]
    cmp       rax,	84
    jz        L5603
    cmp       rax,	85
    jnz       L5602
L5603:
    mov       rcx,	r12
    mov       rdx,	rdi
    call      mm_blockpcl.do_incr
    jmp       L5601
L5602:
    mov       rcx,	r12
    mov       rdx,	rdi
    call      mm_blockpcl.do_incrload
L5601:
    jmp       L5540
L5604:
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_blockpcl.do_binto
    jmp       L5540
L5605:
    mov       rcx,	r12
    mov       rdx,	rdi
    call      mm_blockpcl.do_unaryto
    jmp       L5540
L5606:
    mov       rcx,	r12
    mov       rdx,	rdi
    call      mm_blockpcl.do_syscall
    jmp       L5540
L5607:
    mov       rcx,	r12
    call      pc_api.genassem
    mov       rcx,	42
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	r12
    call      mm_libpcl.setmode_u
    jmp       L5540
L5608:
    mov       rcx,	r12
    mov       rdx,	rdi
    call      mm_blockpcl.do_empty
    jmp       L5540
L5609:
    lea       rcx,	[L12837]
    call      pc_api.gencomment
    mov       rax,	[r12+16]
    mov       rcx,	[rax+16]
    call      pc_api.gencomment
    jmp       L5540
L5610:
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_blockpcl.do_slice
    jmp       L5540
L5542:
    movzx     rax,	byte [r12]
    lea       r10,	[mm_tables.jtagnames]
    mov       r10,	[r10 + rax*8]
    lea       rcx,	[L12838]
    mov       rdx,	r10
    xor       r8d,	r8d
    call      mm_support.gerror_s
    jmp       L5537
L5540:
    movsxd    rax,	dword [r12+49]
    test      rax,	rax
    jz        L5612
    mov       al,	[r12+61]
    test      al,	al
    jnz       L5612
    movzx     rax,	byte [r12]
    cmp       rax,	28
    jz        L5614
    cmp       rax,	32
    jz        L5614
    cmp       rax,	90
    jnz       L5615
L5614:
    jmp       L5613
L5615:
    movzx     rax,	byte [r12]
    lea       r10,	[mm_tables.jsolo]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jnz       L5617
    mov       rcx,	r12
    xor       edx,	edx
    lea       r8,	[L12839]
    xor       r9d,	r9d
    call      mm_diags.printunit
    movzx     rax,	byte [r12]
    lea       r10,	[mm_tables.jtagnames]
    mov       r10,	[r10 + rax*8]
    lea       rcx,	[L12840]
    mov       rdx,	r10
    call      pc_api.addstr
    mov       rcx,	rax
    xor       edx,	edx
    call      mm_support.gerror
L5617:
    mov       rcx,	11
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	r12
    call      mm_libpcl.setmode_u
L5613:
L5612:
L5537:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.evalref
mm_blockpcl.evalref:
;?>>
   %define R.p r12
   %define R.q r13
   %define R.a rdi
   %define R.b rbx
   %define R.c rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r12,	rcx
    mov       r13,	rdx
;---------------
    mov       rdi,	[r12+16]
    mov       rbx,	[r12+24]
    mov       rsi,	[r12+32]
    mov       eax,	[r12+4]
    mov       [pc_decls.mmpos],	rax
    movzx     rax,	byte [r12]
    cmp       rax,	4
    jz        L5620
    cmp       rax,	46
    jz        L5621
    cmp       rax,	49
    jz        L5622
    cmp       rax,	53
    jz        L5623
    jmp       L5624
L5620:
    mov       rcx,	[r12+16]
    call      mm_genpcl.genpushmemaddr_d
    mov       rcx,	4
    call      mm_libpcl.setmode
    test      r13,	r13
    jz        L5626
    mov       rcx,	[r13+16]
    call      mm_genpcl.genpushint
    mov       rcx,	57
    mov       rdx,	1
    xor       r8d,	r8d
    call      pc_api.pc_genix
    mov       rcx,	17
    call      mm_libpcl.setmode
L5626:
    jmp       L5619
L5621:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mm_blockpcl.do_indexref
    jmp       L5619
L5622:
    mov       rcx,	r12
    call      mm_blockpcl.do_dotref
    jmp       L5619
L5623:
    mov       rcx,	[r12+16]
    call      mm_blockpcl.evalunit
    jmp       L5619
L5624:
    movzx     rax,	byte [r12]
    cmp       rax,	92
    jnz       L5629
L5628:
    sub       rsp,	8
    push      1
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    mov       r9,	rsi
    sub       rsp,	32
    call      mm_blockpcl.do_if
    add       rsp,	48
    jmp       L5627
L5629:
    mov       rcx,	r12
    xor       edx,	edx
    lea       r8,	[L12841]
    xor       r9d,	r9d
    call      mm_diags.printunit
    lea       rcx,	[L12842]
    xor       edx,	edx
    call      mm_support.gerror
L5627:
L5619:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.evalarray
mm_blockpcl.evalarray:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    movsxd    rax,	dword [rdi+49]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    cmp       r10,	11
    jz        L5632
    jmp       L5633
L5632:
    mov       rcx,	rdi
    xor       edx,	edx
    call      mm_blockpcl.evalref
    mov       rcx,	2
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	4
    call      mm_libpcl.setmode
    jmp       L5631
L5633:
    movsxd    rax,	dword [rdi+49]
    cmp       rax,	20
    jnz       L5635
    mov       rcx,	rdi
    call      mm_blockpcl.evalunit
    jmp       L5634
L5635:
    mov       rcx,	rdi
    xor       edx,	edx
    call      mm_blockpcl.evalref
L5634:
L5631:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_block
mm_blockpcl.do_block:
;?>>
   %define R.p rbx
   %define R.a rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rdi,	[rbx+16]
    jmp       L5638
L5637:
    mov       rcx,	rdi
    call      mm_blockpcl.evalunit
    mov       rdi,	[rdi+8]
L5638:
    test      rdi,	rdi
    jnz       L5637
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.genjumpcond
mm_blockpcl.genjumpcond:
;?>>
   %define R.opc r14
    %define mm_blockpcl.genjumpcond.p 72
    %define mm_blockpcl.genjumpcond.lab 80
   %define R.q rdi
   %define R.r rbx
   %define R.s rsi
   %define R.lab2 r12
   %define R.i r13
    %define mm_blockpcl.genjumpcond.$T1 -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       r14,	rcx
    mov       [rbp+72],	rdx
    mov       [rbp+80],	r8
;---------------
    mov       rax,	[rbp + mm_blockpcl.genjumpcond.p]
    mov       rdi,	[rax+16]
    mov       rax,	[rbp + mm_blockpcl.genjumpcond.p]
    mov       rbx,	[rax+24]
    mov       rax,	[rbp + mm_blockpcl.genjumpcond.p]
    movzx     rax,	byte [rax]
    cmp       rax,	15
    jz        L5642
    cmp       rax,	16
    jz        L5643
    cmp       rax,	17
    jz        L5644
    cmp       rax,	19
    jz        L5644
    cmp       rax,	18
    jz        L5645
    cmp       rax,	6
    jz        L5646
    cmp       rax,	33
    jz        L5647
    cmp       rax,	43
    jz        L5648
    cmp       rax,	44
    jz        L5649
    cmp       rax,	34
    jz        L5650
    jmp       L5651
L5642:
    mov       rax,	r14
    cmp       rax,	28
    jz        L5653
    cmp       rax,	27
    jz        L5654
    jmp       L5655
L5653:
    mov       rcx,	28
    mov       rdx,	rdi
    mov       r8,	[rbp + mm_blockpcl.genjumpcond.lab]
    call      mm_blockpcl.genjumpcond
    mov       rcx,	28
    mov       rdx,	rbx
    mov       r8,	[rbp + mm_blockpcl.genjumpcond.lab]
    call      mm_blockpcl.genjumpcond
    jmp       L5652
L5654:
    call      mm_genpcl.createfwdlabel
    mov       r12,	rax
    mov       rcx,	28
    mov       rdx,	rdi
    mov       r8,	r12
    call      mm_blockpcl.genjumpcond
    mov       rcx,	27
    mov       rdx,	rbx
    mov       r8,	[rbp + mm_blockpcl.genjumpcond.lab]
    call      mm_blockpcl.genjumpcond
    mov       rcx,	r12
    call      mm_genpcl.definefwdlabel
L5655:
L5652:
    jmp       L5641
L5643:
    mov       rax,	r14
    cmp       rax,	28
    jz        L5657
    cmp       rax,	27
    jz        L5658
    jmp       L5659
L5657:
    call      mm_genpcl.createfwdlabel
    mov       r12,	rax
    mov       rcx,	27
    mov       rdx,	rdi
    mov       r8,	r12
    call      mm_blockpcl.genjumpcond
    mov       rcx,	28
    mov       rdx,	rbx
    mov       r8,	[rbp + mm_blockpcl.genjumpcond.lab]
    call      mm_blockpcl.genjumpcond
    mov       rcx,	r12
    call      mm_genpcl.definefwdlabel
    jmp       L5656
L5658:
    mov       rcx,	27
    mov       rdx,	rdi
    mov       r8,	[rbp + mm_blockpcl.genjumpcond.lab]
    call      mm_blockpcl.genjumpcond
    mov       rcx,	27
    mov       rdx,	rbx
    mov       r8,	[rbp + mm_blockpcl.genjumpcond.lab]
    call      mm_blockpcl.genjumpcond
L5659:
L5656:
    jmp       L5641
L5644:
    mov       rax,	r14
    cmp       rax,	28
    jz        L5661
    cmp       rax,	27
    jz        L5662
    jmp       L5663
L5661:
    mov       rcx,	27
    mov       rdx,	rdi
    mov       r8,	[rbp + mm_blockpcl.genjumpcond.lab]
    call      mm_blockpcl.genjumpcond
    jmp       L5660
L5662:
    mov       rcx,	28
    mov       rdx,	rdi
    mov       r8,	[rbp + mm_blockpcl.genjumpcond.lab]
    call      mm_blockpcl.genjumpcond
L5663:
L5660:
    jmp       L5641
L5645:
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	[rbp + mm_blockpcl.genjumpcond.lab]
    call      mm_blockpcl.genjumpcond
    jmp       L5641
L5646:
    jmp       L5665
L5664:
    mov       rcx,	rdi
    call      mm_blockpcl.evalunit
    mov       rdi,	[rdi+8]
L5665:
    test      rdi,	rdi
    jz        L5667
    mov       rax,	[rdi+8]
    test      rax,	rax
    jnz       L5664
L5667:
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	[rbp + mm_blockpcl.genjumpcond.lab]
    call      mm_blockpcl.genjumpcond
    jmp       L5641
L5647:
    sub       rsp,	8
    push      qword [rbp + mm_blockpcl.genjumpcond.lab]
    mov       rax,	[rbp + mm_blockpcl.genjumpcond.p]
    movzx     rax,	byte [rax+64]
    mov       rcx,	r14
    mov       rdx,	rax
    mov       r8,	rdi
    mov       r9,	rbx
    sub       rsp,	32
    call      mm_blockpcl.gcomparejump
    add       rsp,	48
    jmp       L5641
L5648:
    mov       rcx,	rdi
    call      mm_blockpcl.evalunit
    cmp       r14,	27
    jnz       L5669
    call      mm_genpcl.createfwdlabel
    mov       r12,	rax
    mov       rcx,	[rbx+16]
    call      mm_blockpcl.evalunit
    mov       rcx,	r12
    call      pc_api.genlabel
    mov       rcx,	26
    mov       rdx,	3
    mov       r8,	rax
    call      pc_api.pc_gencond
    mov       rcx,	rdi
    call      mm_libpcl.setmode_u
    mov       eax,	1
    mov       r10,	[pc_api.pccurr]
    mov       [r10+16],	eax
    mov       rcx,	[rbx+24]
    call      mm_blockpcl.evalunit
    mov       rcx,	[rbp + mm_blockpcl.genjumpcond.lab]
    call      pc_api.genlabel
    mov       rcx,	26
    mov       rdx,	4
    mov       r8,	rax
    call      pc_api.pc_gencond
    mov       rcx,	rdi
    call      mm_libpcl.setmode_u
    mov       rcx,	r12
    call      mm_genpcl.definefwdlabel
    jmp       L5668
L5669:
    mov       rcx,	[rbx+16]
    call      mm_blockpcl.evalunit
    mov       rcx,	[rbp + mm_blockpcl.genjumpcond.lab]
    call      pc_api.genlabel
    mov       rcx,	26
    mov       rdx,	3
    mov       r8,	rax
    call      pc_api.pc_gencond
    mov       rcx,	rdi
    call      mm_libpcl.setmode_u
    mov       eax,	1
    mov       r10,	[pc_api.pccurr]
    mov       [r10+16],	eax
    mov       rcx,	[rbx+24]
    call      mm_blockpcl.evalunit
    mov       rcx,	[rbp + mm_blockpcl.genjumpcond.lab]
    call      pc_api.genlabel
    mov       rcx,	26
    mov       rdx,	6
    mov       r8,	rax
    call      pc_api.pc_gencond
    mov       rcx,	rdi
    call      mm_libpcl.setmode_u
L5668:
    jmp       L5641
L5649:
    mov       rsi,	[rbx+16]
    test      rsi,	rsi
    jnz       L5671
    lea       rcx,	[L12843]
    xor       edx,	edx
    call      mm_support.gerror
L5671:
    cmp       r14,	28
    jnz       L5673
    call      mm_genpcl.createfwdlabel
    mov       r12,	rax
    mov       rcx,	rdi
    call      mm_blockpcl.evalunit
    jmp       L5675
L5674:
    mov       rcx,	rsi
    call      mm_blockpcl.evalunit
    mov       rsi,	[rsi+8]
    test      rsi,	rsi
    jz        L5678
    mov       rcx,	r12
    call      pc_api.genlabel
    mov       rcx,	26
    mov       rdx,	1
    mov       r8,	rax
    call      pc_api.pc_gencond
    mov       eax,	1
    mov       r10,	[pc_api.pccurr]
    mov       [r10+16],	eax
    jmp       L5677
L5678:
    mov       rcx,	[rbp + mm_blockpcl.genjumpcond.lab]
    call      pc_api.genlabel
    mov       rcx,	26
    mov       rdx,	2
    mov       r8,	rax
    call      pc_api.pc_gencond
L5677:
    mov       rcx,	rdi
    call      mm_libpcl.setmode_u
L5675:
    test      rsi,	rsi
    jnz       L5674
    mov       rcx,	r12
    call      mm_genpcl.definefwdlabel
    jmp       L5672
L5673:
    mov       rcx,	rdi
    call      mm_blockpcl.evalunit
    jmp       L5682
L5679:
    mov       rcx,	rsi
    call      mm_blockpcl.evalunit
    mov       rcx,	[rbp + mm_blockpcl.genjumpcond.lab]
    call      pc_api.genlabel
    mov       rcx,	26
    mov       rdx,	1
    mov       r8,	rax
    call      pc_api.pc_gencond
    mov       rcx,	rdi
    call      mm_libpcl.setmode_u
    mov       rax,	[rsi+8]
    test      rax,	rax
    jz        L5684
    mov       eax,	1
    mov       r10,	[pc_api.pccurr]
    mov       [r10+16],	eax
L5684:
    mov       rsi,	[rsi+8]
L5682:
    test      rsi,	rsi
    jnz       L5679
L5672:
    jmp       L5641
L5650:
    mov       rbx,	[rdi+8]
    mov       r13,	1
    mov       rcx,	rdi
    call      mm_blockpcl.evalunit
    cmp       r14,	28
    jnz       L5686
    jmp       L5688
L5687:
    mov       rcx,	rbx
    call      mm_blockpcl.evalunit
    mov       rax,	[rbx+8]
    test      rax,	rax
    jz        L5691
    mov       rcx,	10
    mov       rdx,	1
    mov       r8,	2
    xor       r9d,	r9d
    call      pc_api.pc_genxy
    mov       rcx,	[rbp + mm_blockpcl.genjumpcond.lab]
    call      pc_api.genlabel
    mov       [rbp + mm_blockpcl.genjumpcond.$T1],	rax
    mov       rax,	[rbp + mm_blockpcl.genjumpcond.p]
    lea       rax,	[rax+40]
    mov       r10,	r13
    movzx     rax,	byte [rax + r10-1]
    mov       rcx,	rax
    call      mm_genpcl.reversecond
    mov       rcx,	rax
    call      mm_genpcl.reversecond_order
    mov       rcx,	26
    mov       rdx,	rax
    mov       r8,	[rbp + mm_blockpcl.genjumpcond.$T1]
    call      pc_api.pc_gencond
    mov       eax,	1
    mov       r10,	[pc_api.pccurr]
    mov       [r10+16],	eax
    jmp       L5690
L5691:
    mov       rcx,	[rbp + mm_blockpcl.genjumpcond.lab]
    call      pc_api.genlabel
    mov       [rbp + mm_blockpcl.genjumpcond.$T1],	rax
    mov       rax,	[rbp + mm_blockpcl.genjumpcond.p]
    lea       rax,	[rax+40]
    mov       r10,	r13
    movzx     rax,	byte [rax + r10-1]
    mov       rcx,	rax
    call      mm_genpcl.reversecond
    mov       rcx,	26
    mov       rdx,	rax
    mov       r8,	[rbp + mm_blockpcl.genjumpcond.$T1]
    call      pc_api.pc_gencond
L5690:
    mov       rcx,	rdi
    call      mm_libpcl.setmode_u
    inc       r13
    mov       rdi,	rbx
    mov       rbx,	[rbx+8]
L5688:
    test      rbx,	rbx
    jnz       L5687
    jmp       L5685
L5686:
    call      mm_genpcl.createfwdlabel
    mov       r12,	rax
    jmp       L5693
L5692:
    mov       rcx,	rbx
    call      mm_blockpcl.evalunit
    mov       rax,	[rbx+8]
    test      rax,	rax
    jz        L5696
    mov       rcx,	10
    mov       rdx,	1
    mov       r8,	2
    xor       r9d,	r9d
    call      pc_api.pc_genxy
    mov       rcx,	r12
    call      pc_api.genlabel
    mov       [rbp + mm_blockpcl.genjumpcond.$T1],	rax
    mov       rax,	[rbp + mm_blockpcl.genjumpcond.p]
    lea       rax,	[rax+40]
    mov       r10,	r13
    movzx     rax,	byte [rax + r10-1]
    mov       rcx,	rax
    call      mm_genpcl.reversecond
    mov       rcx,	rax
    call      mm_genpcl.reversecond_order
    mov       rcx,	26
    mov       rdx,	rax
    mov       r8,	[rbp + mm_blockpcl.genjumpcond.$T1]
    call      pc_api.pc_gencond
    mov       eax,	1
    mov       r10,	[pc_api.pccurr]
    mov       [r10+16],	eax
    jmp       L5695
L5696:
    mov       rcx,	[rbp + mm_blockpcl.genjumpcond.lab]
    call      pc_api.genlabel
    mov       r10,	[rbp + mm_blockpcl.genjumpcond.p]
    lea       r10,	[r10+40]
    mov       r11,	r13
    movzx     r10,	byte [r10 + r11-1]
    mov       rcx,	26
    mov       rdx,	r10
    mov       r8,	rax
    call      pc_api.pc_gencond
L5695:
    mov       rcx,	rdi
    call      mm_libpcl.setmode_u
    inc       r13
    mov       rdi,	rbx
    mov       rbx,	[rbx+8]
L5693:
    test      rbx,	rbx
    jnz       L5692
    mov       rcx,	r12
    call      mm_genpcl.definefwdlabel
L5685:
    jmp       L5641
L5651:
    mov       rcx,	[rbp + mm_blockpcl.genjumpcond.p]
    call      mm_blockpcl.evalunit
    mov       rcx,	[rbp + mm_blockpcl.genjumpcond.lab]
    call      pc_api.genlabel
    mov       rcx,	r14
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rax,	[rbp + mm_blockpcl.genjumpcond.p]
    movsxd    rax,	dword [rax+49]
    lea       r10,	[mm_decls.ttisblock]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L5698
    lea       rcx,	[L12844]
    xor       edx,	edx
    call      mm_support.gerror
L5698:
    mov       rax,	[rbp + mm_blockpcl.genjumpcond.p]
    movsxd    rax,	dword [rax+49]
    mov       rcx,	rax
    call      mm_libpcl.setmode
L5641:
;---------------
    add       rsp,	48
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.gcomparejump
mm_blockpcl.gcomparejump:
;?>>
   %define R.jumpopc rdi
   %define R.cond rbx
   %define R.lhs rsi
   %define R.rhs r12
    %define mm_blockpcl.gcomparejump.lab 80
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
    mov       r12,	r9
;---------------
    cmp       rdi,	28
    jnz       L5701
    mov       rcx,	rbx
    call      mm_genpcl.reversecond
    mov       rbx,	rax
L5701:
    mov       rcx,	rsi
    call      mm_blockpcl.evalunit
    mov       rcx,	r12
    call      mm_blockpcl.evalunit
    mov       rcx,	[rbp + mm_blockpcl.gcomparejump.lab]
    call      pc_api.genlabel
    mov       rcx,	26
    mov       rdx,	rbx
    mov       r8,	rax
    call      pc_api.pc_gencond
    mov       rcx,	rsi
    call      mm_libpcl.setmode_u
;---------------
    add       rsp,	32
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.genjumpl
mm_blockpcl.genjumpl:
;?>>
   %define R.lab rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      pc_api.genlabel
    mov       rcx,	24
    mov       rdx,	rax
    call      pc_api.pc_gen
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.unimpl
mm_blockpcl.unimpl:
;?>>
   %define R.mess rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    lea       rcx,	[L12845]
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mm_support.gerror_s
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_const
mm_blockpcl.do_const:
;?>>
   %define R.p rbx
   %define R.mode rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    movsxd    rax,	dword [rbx+49]
    mov       rdi,	rax
    lea       rax,	[mm_decls.ttisinteger]
    mov       r10,	rdi
    mov       al,	[rax + r10]
    test      al,	al
    jnz       L5707
    cmp       rdi,	6
    jnz       L5706
L5707:
    mov       rcx,	[rbx+16]
    call      mm_genpcl.genpushint
    jmp       L5705
L5706:
    lea       rax,	[mm_decls.ttisreal]
    mov       r10,	rdi
    mov       al,	[rax + r10]
    test      al,	al
    jz        L5708
    mov       rcx,	rdi
    call      mm_lib.getpclmode
    movq      XMM4,	[rbx+16]
    movq      XMM0,	XMM4
    mov       rdx,	rax
    call      mm_genpcl.genpushreal
    jmp       L5705
L5708:
    lea       rax,	[mm_decls.ttisref]
    mov       r10,	rdi
    mov       al,	[rax + r10]
    test      al,	al
    jz        L5709
    mov       al,	[rbx+44]
    test      al,	al
    jz        L5711
    movzx     rax,	byte [rbx+45]
    cmp       rax,	66
    jnz       L5713
    lea       rcx,	[L12846]
    xor       edx,	edx
    call      mm_support.gerror
L5713:
    mov       rcx,	[rbx+16]
    call      mm_genpcl.genpushstring
    jmp       L5710
L5711:
    mov       rcx,	[rbx+16]
    call      mm_genpcl.genpushint
L5710:
    jmp       L5705
L5709:
    lea       rcx,	[L12847]
    xor       edx,	edx
    call      mm_support.gerror
L5705:
    mov       rcx,	rdi
    call      mm_libpcl.setmode
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_name
mm_blockpcl.do_name:
;?>>
   %define R.p rbx
   %define R.d rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rdi,	[rbx+16]
    movzx     rax,	byte [rdi+78]
    cmp       rax,	6
    jz        L5716
    cmp       rax,	7
    jz        L5716
    cmp       rax,	14
    jz        L5717
    cmp       rax,	13
    jz        L5718
    jmp       L5719
L5716:
    mov       rcx,	rdi
    call      mm_genpcl.genpushmemaddr_d
    mov       rcx,	4
    call      mm_libpcl.setmode
    jmp       L5715
L5717:
    movsxd    rax,	dword [rdi+80]
    test      rax,	rax
    jnz       L5721
    inc       qword [pc_api.mlabelno]
    mov       rax,	[pc_api.mlabelno]
    mov       [rdi+80],	eax
L5721:
    mov       al,	[rbx+61]
    test      al,	al
    jz        L5723
    movsxd    rax,	dword [rdi+80]
    mov       rcx,	rax
    call      pc_api.genlabel
    mov       rcx,	1
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	4
    call      mm_libpcl.setmode
    jmp       L5722
L5723:
    movsxd    rax,	dword [rdi+80]
    mov       rcx,	rax
    call      pc_api.genlabel
    mov       rcx,	24
    mov       rdx,	rax
    call      pc_api.pc_gen
    xor       eax,	eax
    mov       [rbx+49],	eax
    xor       eax,	eax
    mov       [rbx+61],	al
L5722:
    jmp       L5715
L5718:
    movsxd    rax,	dword [rdi+84]
    mov       rcx,	rax
    call      mm_genpcl.genpushint
    mov       rcx,	3
    call      mm_libpcl.setmode
    jmp       L5715
L5719:
    mov       rcx,	rdi
    call      mm_genpcl.genpushmem_d
    movsxd    rax,	dword [rdi+72]
    mov       rcx,	rax
    call      mm_libpcl.setmode
L5715:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_stop
mm_blockpcl.do_stop:
;?>>
    %define mm_blockpcl.do_stop.p 24
   %define R.a rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rdx
;---------------
    test      rdi,	rdi
    jz        L5726
    mov       rcx,	rdi
    call      mm_blockpcl.evalunit
    jmp       L5725
L5726:
    xor       ecx,	ecx
    call      pc_api.genint
    mov       rcx,	1
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	3
    call      mm_libpcl.setmode
L5725:
    mov       rcx,	32
    xor       edx,	edx
    call      pc_api.pc_gen
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_andl
mm_blockpcl.do_andl:
;?>>
    %define mm_blockpcl.do_andl.p 48
   %define R.a rsi
   %define R.b r12
   %define R.labfalse rdi
   %define R.labend rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rsi,	rdx
    mov       r12,	r8
;---------------
    mov       rcx,	117
    xor       edx,	edx
    call      pc_api.pc_gen
    call      mm_genpcl.createfwdlabel
    mov       rdi,	rax
    call      mm_genpcl.createfwdlabel
    mov       rbx,	rax
    mov       rcx,	28
    mov       rdx,	rsi
    mov       r8,	rdi
    call      mm_blockpcl.genjumpcond
    mov       rcx,	28
    mov       rdx,	r12
    mov       r8,	rdi
    call      mm_blockpcl.genjumpcond
    mov       rcx,	1
    call      mm_genpcl.genpushint
    mov       rcx,	118
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	3
    call      mm_libpcl.setmode
    mov       rcx,	rbx
    call      mm_blockpcl.genjumpl
    mov       rcx,	rdi
    call      mm_genpcl.definefwdlabel
    xor       ecx,	ecx
    call      mm_genpcl.genpushint
    mov       rcx,	119
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	3
    call      mm_libpcl.setmode
    mov       rcx,	rbx
    call      mm_genpcl.definefwdlabel
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_orl
mm_blockpcl.do_orl:
;?>>
    %define mm_blockpcl.do_orl.p 56
   %define R.a r12
   %define R.b r13
   %define R.labtrue rdi
   %define R.labfalse rbx
   %define R.labend rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r12,	rdx
    mov       r13,	r8
;---------------
    mov       rcx,	117
    xor       edx,	edx
    call      pc_api.pc_gen
    call      mm_genpcl.createfwdlabel
    mov       rdi,	rax
    call      mm_genpcl.createfwdlabel
    mov       rbx,	rax
    call      mm_genpcl.createfwdlabel
    mov       rsi,	rax
    mov       rcx,	27
    mov       rdx,	r12
    mov       r8,	rdi
    call      mm_blockpcl.genjumpcond
    mov       rcx,	28
    mov       rdx,	r13
    mov       r8,	rbx
    call      mm_blockpcl.genjumpcond
    mov       rcx,	rdi
    call      mm_genpcl.definefwdlabel
    mov       rcx,	1
    call      mm_genpcl.genpushint
    mov       rcx,	118
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	3
    call      mm_libpcl.setmode
    mov       rcx,	rsi
    call      mm_blockpcl.genjumpl
    mov       rcx,	rbx
    call      mm_genpcl.definefwdlabel
    xor       ecx,	ecx
    call      mm_genpcl.genpushint
    mov       rcx,	119
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	3
    call      mm_libpcl.setmode
    mov       rcx,	rsi
    call      mm_genpcl.definefwdlabel
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_notl
mm_blockpcl.do_notl:
;?>>
   %define R.p rdi
   %define R.a rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rbx
    call      mm_blockpcl.evalunit
    movzx     rax,	byte [rdi+62]
    mov       rcx,	rax
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	3
    call      mm_libpcl.setmode
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_istruel
mm_blockpcl.do_istruel:
;?>>
   %define R.p rdi
   %define R.a rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rbx
    call      mm_blockpcl.evalunit
    mov       rcx,	64
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	rdi
    call      mm_libpcl.setmode_u
    movsxd    rax,	dword [rbx+49]
    mov       rcx,	rax
    call      mm_libpcl.setmode2
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_isfalsel
mm_blockpcl.do_isfalsel:
;?>>
   %define R.p rdi
   %define R.a rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rbx
    call      mm_blockpcl.evalunit
    mov       rcx,	65
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	rdi
    call      mm_libpcl.setmode_u
    movsxd    rax,	dword [rbx+49]
    mov       rcx,	rax
    call      mm_libpcl.setmode2
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_typepun
mm_blockpcl.do_typepun:
;?>>
   %define R.p rdi
   %define R.a rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rbx
    call      mm_blockpcl.evalunit
    movzx     rax,	byte [rbx]
    cmp       rax,	4
    jnz       L5734
    mov       rax,	[rbx+16]
    lea       rax,	[rax+92]
    or        byte [rax],	32
L5734:
    movsxd    rax,	dword [rbx+49]
    movsxd    r10,	dword [rdi+49]
    cmp       rax,	r10
    jz        L5732
L5736:
    mov       rcx,	110
    xor       edx,	edx
    call      pc_api.pc_gen
    movsxd    rax,	dword [rdi+53]
    mov       rcx,	rax
    call      mm_libpcl.setmode
    movsxd    rax,	dword [rbx+49]
    mov       rcx,	rax
    call      mm_libpcl.setmode2
L5732:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_shorten
mm_blockpcl.do_shorten:
;?>>
    %define mm_blockpcl.do_shorten.p 24
   %define R.a rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rdx
;---------------
    mov       rcx,	rdi
    call      mm_blockpcl.evalunit
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_assign
mm_blockpcl.do_assign:
;?>>
   %define R.p rdi
   %define R.a rbx
   %define R.b rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    movzx     rax,	byte [rbx]
    cmp       rax,	4
    jnz       L5740
    mov       rax,	[rbx+16]
    mov       ax,	[rax+168]
    test      ax,	ax
    jz        L5738
L5740:
    movzx     rax,	byte [rsi]
    cmp       rax,	20
    jnz       L5743
L5742:
    mov       al,	[rdi+61]
    test      al,	al
    jnz       L5745
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mm_blockpcl.do_assignblock
    jmp       L5738
L5745:
L5743:
L5741:
    movzx     rax,	byte [rbx]
    cmp       rax,	46
    jz        L5747
    cmp       rax,	48
    jz        L5748
    cmp       rax,	49
    jz        L5749
    jmp       L5750
L5747:
    mov       rax,	[rbx+24]
    mov       r10,	[rbx+16]
    mov       rcx,	rdi
    mov       rdx,	r10
    mov       r8,	rax
    mov       r9,	rsi
    call      mm_blockpcl.do_storeindex
    jmp       L5738
L5748:
    lea       rcx,	[L12848]
    xor       edx,	edx
    call      mm_support.gerror
    jmp       L5746
L5749:
    mov       rax,	[rbx+24]
    mov       rcx,	rbx
    mov       rdx,	rax
    mov       r8,	rsi
    call      mm_blockpcl.do_storedot
    jmp       L5738
L5750:
L5746:
    mov       rcx,	rsi
    call      mm_blockpcl.evalunit
    mov       al,	[rdi+61]
    test      al,	al
    jz        L5752
    mov       rcx,	9
    xor       edx,	edx
    call      pc_api.pc_gen
L5752:
    movzx     rax,	byte [rbx]
    cmp       rax,	4
    jz        L5754
    cmp       rax,	53
    jz        L5755
    cmp       rax,	51
    jz        L5756
    cmp       rax,	52
    jz        L5757
    cmp       rax,	92
    jz        L5758
    jmp       L5759
L5754:
    mov       rax,	[rbx+16]
    movzx     rax,	byte [rax+78]
    cmp       rax,	6
    jz        L5762
    cmp       rax,	7
    jz        L5762
    cmp       rax,	14
    jnz       L5761
L5762:
    lea       rcx,	[L12849]
    xor       edx,	edx
    call      mm_support.gerror
L5761:
    mov       rcx,	rbx
    call      mm_genpcl.genmem_u
    mov       rcx,	4
    mov       rdx,	rax
    call      pc_api.pc_gen
    jmp       L5753
L5755:
    mov       rcx,	rbx
    xor       edx,	edx
    call      mm_blockpcl.evalref
    mov       rcx,	5
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	rbx
    call      mm_libpcl.setmode_u
    jmp       L5753
L5756:
    mov       rax,	[rbx+16]
    mov       rcx,	rax
    xor       edx,	edx
    call      mm_blockpcl.evalref
    mov       rcx,	[rbx+24]
    call      mm_blockpcl.evalunit
    mov       rcx,	16
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	[rbx+16]
    call      mm_libpcl.setmode_u
    jmp       L5738
L5757:
    mov       rax,	[rbx+16]
    mov       rcx,	rax
    xor       edx,	edx
    call      mm_blockpcl.evalref
    mov       rax,	[rbx+24]
    mov       rcx,	[rax+16]
    call      mm_blockpcl.evalunit
    mov       rax,	[rbx+24]
    mov       rcx,	[rax+24]
    call      mm_blockpcl.evalunit
    mov       rcx,	17
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	[rbx+16]
    call      mm_libpcl.setmode_u
    jmp       L5738
L5758:
    sub       rsp,	8
    push      1
    mov       rax,	[rbx+32]
    mov       r10,	[rbx+24]
    mov       r11,	[rbx+16]
    mov       rcx,	rbx
    mov       rdx,	r11
    mov       r8,	r10
    mov       r9,	rax
    sub       rsp,	32
    call      mm_blockpcl.do_if
    add       rsp,	48
    mov       rcx,	5
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	rbx
    call      mm_libpcl.setmode_u
    jmp       L5753
L5759:
    call      msys.m$print_startcon
    movzx     rax,	byte [rbx]
    lea       r10,	[mm_tables.jtagnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L12850]
    xor       edx,	edx
    call      mm_support.gerror
L5753:
    mov       rcx,	rbx
    call      mm_libpcl.setmode_u
L5738:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_bin
mm_blockpcl.do_bin:
;?>>
   %define R.p rdi
   %define R.a rbx
   %define R.b rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    mov       rcx,	rbx
    call      mm_blockpcl.evalunit
    mov       rcx,	rsi
    call      mm_blockpcl.evalunit
    movzx     rax,	byte [rdi+62]
    cmp       rax,	57
    jz        L5766
    cmp       rax,	58
    jnz       L5765
L5766:
    movsxd    rax,	dword [rbx+49]
    lea       r10,	[mm_decls.tttarget]
    movsxd    r10,	dword [r10 + rax*4]
    lea       rax,	[mm_decls.ttsize]
    mov       eax,	[rax + r10*4]
    movzx     r10,	byte [rdi+62]
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      pc_api.pc_genix
    jmp       L5764
L5765:
    movzx     rax,	byte [rdi+62]
    mov       rcx,	rax
    xor       edx,	edx
    call      pc_api.pc_gen
    movzx     rax,	byte [rdi+62]
    cmp       rax,	59
    jnz       L5768
    movsxd    rax,	dword [rbx+49]
    lea       r10,	[mm_decls.tttarget]
    movsxd    r10,	dword [r10 + rax*4]
    lea       rax,	[mm_decls.ttsize]
    mov       eax,	[rax + r10*4]
    mov       rcx,	rax
    xor       edx,	edx
    call      pc_api.pc_setscaleoff
L5768:
L5764:
    mov       rcx,	rdi
    call      mm_libpcl.setmode_u
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_setcc
mm_blockpcl.do_setcc:
;?>>
   %define R.p rdi
   %define R.a rbx
   %define R.b rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    mov       rcx,	rbx
    call      mm_blockpcl.evalunit
    mov       rcx,	rsi
    call      mm_blockpcl.evalunit
    movzx     rax,	byte [rdi+64]
    mov       rcx,	31
    mov       rdx,	rax
    xor       r8d,	r8d
    call      pc_api.pc_gencond
    mov       rcx,	rbx
    call      mm_libpcl.setmode_u
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_setccchain
mm_blockpcl.do_setccchain:
;?>>
   %define R.p r14
    %define mm_blockpcl.do_setccchain.q 72
   %define R.lab1 rdi
   %define R.lab2 rbx
   %define R.i rsi
   %define R.cond r12
   %define R.r r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       r14,	rcx
    mov       [rbp+72],	rdx
;---------------
    call      mm_genpcl.createfwdlabel
    mov       rdi,	rax
    call      mm_genpcl.createfwdlabel
    mov       rbx,	rax
    mov       rax,	[rbp + mm_blockpcl.do_setccchain.q]
    mov       r13,	[rax+8]
    mov       rsi,	1
    mov       rcx,	117
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	[rbp + mm_blockpcl.do_setccchain.q]
    call      mm_blockpcl.evalunit
    jmp       L5772
L5771:
    mov       rcx,	r13
    call      mm_blockpcl.evalunit
    lea       rax,	[r14+40]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10-1]
    mov       rcx,	rax
    call      mm_genpcl.reversecond
    mov       r12,	rax
    mov       rax,	[r13+8]
    test      rax,	rax
    jz        L5775
    mov       rcx,	10
    mov       rdx,	1
    mov       r8,	2
    xor       r9d,	r9d
    call      pc_api.pc_genxy
    mov       rcx,	r12
    call      mm_genpcl.reversecond_order
    mov       r12,	rax
L5775:
    mov       rcx,	rdi
    call      pc_api.genlabel
    mov       rcx,	26
    mov       rdx,	r12
    mov       r8,	rax
    call      pc_api.pc_gencond
    mov       rax,	[r13+8]
    test      rax,	rax
    jz        L5777
    mov       eax,	1
    mov       r10,	[pc_api.pccurr]
    mov       [r10+16],	eax
L5777:
    mov       rcx,	[rbp + mm_blockpcl.do_setccchain.q]
    call      mm_libpcl.setmode_u
    inc       rsi
    mov       [rbp + mm_blockpcl.do_setccchain.q],	r13
    mov       r13,	[r13+8]
L5772:
    test      r13,	r13
    jnz       L5771
    mov       rcx,	1
    call      mm_genpcl.genpushint
    mov       rcx,	118
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	3
    call      mm_libpcl.setmode
    mov       rcx,	rbx
    call      pc_api.genlabel
    mov       rcx,	24
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	rdi
    call      mm_genpcl.definefwdlabel
    xor       ecx,	ecx
    call      mm_genpcl.genpushint
    mov       rcx,	119
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	3
    call      mm_libpcl.setmode
    mov       rcx,	rbx
    call      mm_genpcl.definefwdlabel
;---------------
    add       rsp,	32
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_binto
mm_blockpcl.do_binto:
;?>>
   %define R.p rdi
   %define R.a rbx
   %define R.b rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    mov       rcx,	rsi
    call      mm_blockpcl.evalunit
    mov       rcx,	rbx
    xor       edx,	edx
    call      mm_blockpcl.evalref
    call      mm_blockpcl.do_setinplace
    movzx     rax,	byte [rdi+62]
    mov       rcx,	rax
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	rbx
    call      mm_libpcl.setmode_u
    movsxd    rax,	dword [rbx+49]
    lea       r10,	[mm_decls.ttisref]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L5780
    movsxd    rax,	dword [rsi+49]
    lea       r10,	[mm_decls.ttisinteger]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L5780
    movsxd    rax,	dword [rbx+49]
    lea       r10,	[mm_decls.tttarget]
    movsxd    r10,	dword [r10 + rax*4]
    lea       rax,	[mm_decls.ttsize]
    mov       eax,	[rax + r10*4]
    mov       rcx,	rax
    xor       edx,	edx
    call      pc_api.pc_setscaleoff
L5780:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_unary
mm_blockpcl.do_unary:
;?>>
   %define R.p rbx
   %define R.a rsi
   %define R.adj rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    movsxd    rax,	dword [rsi+49]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    cmp       r10,	11
    jnz       L5783
    mov       rcx,	rsi
    xor       edx,	edx
    call      mm_blockpcl.evalref
    movzx     rax,	byte [rbx+62]
    cmp       rax,	2
    jz        L5785
    cmp       rax,	4
    jz        L5785
    cmp       rax,	1
    jz        L5786
    jmp       L5787
L5785:
    mov       rcx,	8
    call      mm_genpcl.genpushint
    mov       rcx,	3
    mov       rdx,	1
    xor       r8d,	r8d
    call      pc_api.pc_genix
    mov       rcx,	3
    call      mm_libpcl.setmode
    movzx     rax,	byte [rbx+62]
    cmp       rax,	4
    jnz       L5789
    movsxd    rax,	dword [rsi+49]
    lea       r10,	[mm_decls.ttlower]
    movsxd    r10,	dword [r10 + rax*4]
    dec       r10
    mov       rdi,	r10
    test      rdi,	rdi
    jz        L5791
    mov       rcx,	rdi
    call      mm_genpcl.genpushint
    mov       rcx,	43
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	3
    call      mm_libpcl.setmode
L5791:
L5789:
    jmp       L5784
L5786:
    mov       rcx,	2
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	4
    call      mm_libpcl.setmode
L5787:
L5784:
    jmp       L5781
L5783:
    mov       rcx,	rsi
    call      mm_blockpcl.evalunit
    movzx     rax,	byte [rbx+62]
    mov       rcx,	rax
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	rsi
    call      mm_libpcl.setmode_u
L5781:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_unaryto
mm_blockpcl.do_unaryto:
;?>>
   %define R.p rdi
   %define R.a rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rbx
    xor       edx,	edx
    call      mm_blockpcl.evalref
    call      mm_blockpcl.do_setinplace
    movzx     rax,	byte [rdi+62]
    mov       rcx,	rax
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	rbx
    call      mm_libpcl.setmode_u
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_ptr
mm_blockpcl.do_ptr:
;?>>
   %define R.p rdi
   %define R.a rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rbx
    call      mm_blockpcl.evalunit
    mov       rcx,	2
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	rdi
    call      mm_libpcl.setmode_u
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_labeldef
mm_blockpcl.do_labeldef:
;?>>
   %define R.p rbx
   %define R.d rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rdi,	[rbx+16]
    movsxd    rax,	dword [rdi+80]
    test      rax,	rax
    jnz       L5796
    inc       qword [pc_api.mlabelno]
    mov       rax,	[pc_api.mlabelno]
    mov       [rdi+80],	eax
L5796:
    mov       rcx,	rdi
    call      mm_genpcl.genmemaddr_d
    mov       rcx,	128
    mov       rdx,	rax
    call      pc_api.pc_gen
    movsxd    rax,	dword [rdi+80]
    mov       rcx,	rax
    call      pc_api.genlabel
    mov       rcx,	127
    mov       rdx,	rax
    call      pc_api.pc_gen
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_goto
mm_blockpcl.do_goto:
;?>>
   %define R.a rbx
   %define R.d rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    movzx     rax,	byte [rbx]
    cmp       rax,	4
    jnz       L5799
    mov       rax,	[rbx+16]
    movzx     rax,	byte [rax+78]
    cmp       rax,	14
    jnz       L5799
    mov       rdi,	[rbx+16]
    movsxd    rax,	dword [rdi+80]
    test      rax,	rax
    jnz       L5801
    inc       qword [pc_api.mlabelno]
    mov       rax,	[pc_api.mlabelno]
    mov       [rdi+80],	eax
L5801:
    movsxd    rax,	dword [rdi+80]
    mov       rcx,	rax
    call      pc_api.genlabel
    mov       rcx,	24
    mov       rdx,	rax
    call      pc_api.pc_gen
    jmp       L5798
L5799:
    mov       rcx,	rbx
    call      mm_blockpcl.evalunit
    mov       rcx,	25
    xor       edx,	edx
    call      pc_api.pc_gen
L5798:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_do
mm_blockpcl.do_do:
;?>>
    %define mm_blockpcl.do_do.p 40
   %define R.a rsi
    %define mm_blockpcl.do_do.b 56
   %define R.lab_abc rdi
   %define R.lab_d rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rdx
;---------------
    call      mm_genpcl.definelabel
    mov       rdi,	rax
    call      mm_genpcl.createfwdlabel
    mov       rbx,	rax
    mov       rcx,	rdi
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_genpcl.stacklooplabels
    mov       rcx,	rsi
    call      mm_blockpcl.evalunit
    mov       rcx,	rdi
    call      mm_blockpcl.genjumpl
    mov       rcx,	rbx
    call      mm_genpcl.definefwdlabel
    dec       qword [mm_genpcl.loopindex]
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_to
mm_blockpcl.do_to:
;?>>
   %define R.p r14
   %define R.a r15
    %define mm_blockpcl.do_to.b 88
   %define R.cvar rdi
   %define R.lab_b rbx
   %define R.lab_c rsi
   %define R.lab_d r12
   %define R.count r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       r14,	rcx
    mov       r15,	rdx
    mov       [rbp+88],	r8
;---------------
    mov       rdi,	[r14+32]
    mov       eax,	3
    mov       [r15+49],	eax
    mov       rcx,	r15
    call      mm_blockpcl.evalunit
    mov       rcx,	rdi
    call      mm_genpcl.genmem_u
    mov       rcx,	4
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	3
    call      mm_libpcl.setmode
    call      mm_genpcl.createfwdlabel
    mov       rbx,	rax
    call      mm_genpcl.createfwdlabel
    mov       rsi,	rax
    call      mm_genpcl.createfwdlabel
    mov       r12,	rax
    mov       rcx,	rbx
    mov       rdx,	rsi
    mov       r8,	r12
    call      mm_genpcl.stacklooplabels
    movzx     rax,	byte [r15]
    cmp       rax,	1
    jz        L5805
    mov       rcx,	rdi
    call      mm_blockpcl.evalunit
    mov       rcx,	[mm_genpcl.pzero]
    call      mm_blockpcl.evalunit
    mov       rcx,	r12
    call      pc_api.genlabel
    mov       rcx,	26
    mov       rdx,	4
    mov       r8,	rax
    call      pc_api.pc_gencond
    mov       rcx,	3
    call      mm_libpcl.setmode
    jmp       L5804
L5805:
    mov       r13,	[r15+16]
    cmp       r13,	0
    jg        L5807
    mov       rcx,	r12
    call      mm_blockpcl.genjumpl
L5807:
L5804:
    mov       rcx,	rbx
    call      mm_genpcl.definefwdlabel
    mov       rcx,	[rbp + mm_blockpcl.do_to.b]
    call      mm_blockpcl.evalunit
    mov       rcx,	rsi
    call      mm_genpcl.definefwdlabel
    mov       rcx,	rbx
    call      pc_api.genlabel
    mov       rcx,	33
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	3
    call      mm_libpcl.setmode
    mov       rcx,	rdi
    call      mm_genpcl.genmem_u
    mov       rcx,	12
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	3
    call      mm_libpcl.setmode
    mov       rcx,	r12
    call      mm_genpcl.definefwdlabel
    dec       qword [mm_genpcl.loopindex]
;---------------
    add       rsp,	40
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_while
mm_blockpcl.do_while:
;?>>
    %define mm_blockpcl.do_while.p 64
   %define R.pcond r13
   %define R.pbody r14
    %define mm_blockpcl.do_while.pincr 88
   %define R.lab_b rdi
   %define R.lab_c rbx
   %define R.lab_d rsi
   %define R.lab_incr r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       r13,	rdx
    mov       r14,	r8
    mov       [rbp+88],	r9
;---------------
    call      mm_genpcl.createfwdlabel
    mov       rdi,	rax
    call      mm_genpcl.createfwdlabel
    mov       rbx,	rax
    call      mm_genpcl.createfwdlabel
    mov       rsi,	rax
    mov       rax,	[rbp + mm_blockpcl.do_while.pincr]
    test      rax,	rax
    jz        L5810
    call      mm_genpcl.createfwdlabel
    mov       r12,	rax
    jmp       L5809
L5810:
    mov       r12,	rbx
L5809:
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mm_genpcl.stacklooplabels
    mov       rcx,	r12
    call      mm_blockpcl.genjumpl
    mov       rcx,	rdi
    call      mm_genpcl.definefwdlabel
    mov       rcx,	r14
    call      mm_blockpcl.evalunit
    mov       rcx,	rbx
    call      mm_genpcl.definefwdlabel
    mov       rax,	[rbp + mm_blockpcl.do_while.pincr]
    test      rax,	rax
    jz        L5812
    mov       rcx,	[rbp + mm_blockpcl.do_while.pincr]
    call      mm_blockpcl.evalunit
    mov       rcx,	r12
    call      mm_genpcl.definefwdlabel
L5812:
    mov       rcx,	27
    mov       rdx,	r13
    mov       r8,	rdi
    call      mm_blockpcl.docond
    mov       rcx,	rsi
    call      mm_genpcl.definefwdlabel
    dec       qword [mm_genpcl.loopindex]
;---------------
    add       rsp,	32
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_repeat
mm_blockpcl.do_repeat:
;?>>
    %define mm_blockpcl.do_repeat.p 56
   %define R.a r12
   %define R.b r13
   %define R.lab_ab rdi
   %define R.lab_c rbx
   %define R.lab_d rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r12,	rdx
    mov       r13,	r8
;---------------
    call      mm_genpcl.definelabel
    mov       rdi,	rax
    call      mm_genpcl.createfwdlabel
    mov       rbx,	rax
    call      mm_genpcl.createfwdlabel
    mov       rsi,	rax
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mm_genpcl.stacklooplabels
    mov       rcx,	r12
    call      mm_blockpcl.evalunit
    mov       rcx,	rbx
    call      mm_genpcl.definefwdlabel
    movzx     rax,	byte [r13]
    cmp       rax,	1
    jnz       L5816
    mov       rax,	[r13+16]
    test      rax,	rax
    jz        L5815
L5816:
    mov       rcx,	28
    mov       rdx,	r13
    mov       r8,	rdi
    call      mm_blockpcl.docond
L5815:
    mov       rcx,	rsi
    call      mm_genpcl.definefwdlabel
    dec       qword [mm_genpcl.loopindex]
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_exit
mm_blockpcl.do_exit:
;?>>
   %define R.p rsi
   %define R.k r12
   %define R.n rdi
   %define R.index rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    movsxd    rax,	dword [rsi+40]
    mov       rbx,	rax
    test      rbx,	rbx
    jnz       L5819
    mov       rbx,	[mm_genpcl.loopindex]
L5819:
    mov       rcx,	r12
    mov       rdx,	rbx
    call      mm_genpcl.findlooplabel
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L5821
    lea       rcx,	[L12851]
    mov       rdx,	rsi
    call      mm_support.gerror
    jmp       L5820
L5821:
    mov       rcx,	rdi
    call      mm_blockpcl.genjumpl
L5820:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_if
mm_blockpcl.do_if:
;?>>
   %define R.p r13
   %define R.pcond r14
    %define mm_blockpcl.do_if.plist 80
    %define mm_blockpcl.do_if.pelse 88
    %define mm_blockpcl.do_if.isref 96
   %define R.labend rdi
   %define R.i rbx
   %define R.lab2 rsi
   %define R.ismult r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       r13,	rcx
    mov       r14,	rdx
    mov       [rbp+80],	r8
    mov       [rbp+88],	r9
;---------------
    call      mm_genpcl.createfwdlabel
    mov       rdi,	rax
    movsxd    rax,	dword [r13+49]
    cmp       rax,	0
    setnz     al
    movzx     eax,	al
    mov       r12,	rax
    xor       rbx,	rbx
    mov       rax,	r12
    test      rax,	rax
    jz        L5824
    mov       rcx,	117
    xor       edx,	edx
    call      pc_api.pc_gen
L5824:
    jmp       L5828
L5825:
    inc       rbx
    call      mm_genpcl.createfwdlabel
    mov       rsi,	rax
    mov       rcx,	28
    mov       rdx,	r14
    mov       r8,	rsi
    call      mm_blockpcl.docond
    mov       rax,	[rbp + mm_blockpcl.do_if.isref]
    test      rax,	rax
    jz        L5830
    mov       rcx,	[rbp + mm_blockpcl.do_if.plist]
    xor       edx,	edx
    call      mm_blockpcl.evalref
    jmp       L5829
L5830:
    mov       rcx,	[rbp + mm_blockpcl.do_if.plist]
    call      mm_blockpcl.evalunit
L5829:
    test      r12,	r12
    jz        L5832
    mov       rcx,	118
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	r13
    call      mm_libpcl.setmode_u
L5832:
    mov       rax,	[r14+8]
    test      rax,	rax
    jnz       L5835
    mov       rax,	[rbp + mm_blockpcl.do_if.pelse]
    test      rax,	rax
    jz        L5834
L5835:
    mov       rcx,	rdi
    call      mm_blockpcl.genjumpl
L5834:
    mov       rcx,	rsi
    call      mm_genpcl.definefwdlabel
    mov       r14,	[r14+8]
    mov       rax,	[rbp + mm_blockpcl.do_if.plist]
    mov       rax,	[rax+8]
    mov       [rbp + mm_blockpcl.do_if.plist],	rax
L5828:
    test      r14,	r14
    jnz       L5825
    mov       rax,	[rbp + mm_blockpcl.do_if.pelse]
    test      rax,	rax
    jz        L5837
    mov       rax,	[rbp + mm_blockpcl.do_if.isref]
    test      rax,	rax
    jz        L5839
    mov       rcx,	[rbp + mm_blockpcl.do_if.pelse]
    xor       edx,	edx
    call      mm_blockpcl.evalref
    jmp       L5838
L5839:
    mov       rcx,	[rbp + mm_blockpcl.do_if.pelse]
    call      mm_blockpcl.evalunit
L5838:
    test      r12,	r12
    jz        L5841
    mov       rcx,	119
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	r13
    call      mm_libpcl.setmode_u
L5841:
L5837:
    mov       rcx,	rdi
    call      mm_genpcl.definefwdlabel
;---------------
    add       rsp,	32
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_return
mm_blockpcl.do_return:
;?>>
    %define mm_blockpcl.do_return.p 24
   %define R.a rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rdx
;---------------
    test      rdi,	rdi
    jz        L5844
    mov       rcx,	rdi
    call      mm_blockpcl.evalunit
    mov       rcx,	[mm_genpcl.retindex]
    call      pc_api.genlabel
    mov       rcx,	29
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	rdi
    call      mm_libpcl.setmode_u
    jmp       L5843
L5844:
    mov       rcx,	[mm_genpcl.retindex]
    call      mm_blockpcl.genjumpl
L5843:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_returnmult
mm_blockpcl.do_returnmult:
;?>>
   %define R.p r12
   %define R.a r13
    %define mm_blockpcl.do_returnmult.params -800
   %define R.q rdi
   %define R.nparams rbx
   %define R.i rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	840
    mov       r12,	rcx
    mov       r13,	rdx
;---------------
    mov       rdi,	r13
    xor       rbx,	rbx
    jmp       L5847
L5846:
    cmp       rbx,	100
    jl        L5850
    lea       rcx,	[L12852]
    xor       edx,	edx
    call      mm_support.gerror
L5850:
    inc       rbx
    mov       rax,	rbx
    mov       r10,	rdi
    mov       [rbp + rax*8 + mm_blockpcl.do_returnmult.params-8],	r10
    mov       rdi,	[rdi+8]
L5847:
    test      rdi,	rdi
    jnz       L5846
    mov       rsi,	rbx
    cmp       rsi,	1
    jl        L5853
L5851:
    mov       rcx,	[rbp + rsi*8 + mm_blockpcl.do_returnmult.params-8]
    call      mm_blockpcl.evalunit
    dec       rsi
    cmp       rsi,	1
    jge       L5851
L5853:
    mov       rcx,	[mm_genpcl.retindex]
    call      pc_api.genlabel
    mov       rcx,	30
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	rbx
    call      pc_api.pc_setnargs
    mov       al,	1
    mov       [r12+61],	al
;---------------
    add       rsp,	840
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_callproc
mm_blockpcl.do_callproc:
;?>>
   %define R.p r15
    %define mm_blockpcl.do_callproc.a 80
    %define mm_blockpcl.do_callproc.b 88
    %define mm_blockpcl.do_callproc.paramlist -800
    %define mm_blockpcl.do_callproc.argattr -904
   %define R.nparams rdi
   %define R.isptr rbx
   %define R.nvariadics rsi
   %define R.nret r12
   %define R.isfn r13
   %define R.iparams r14
    %define mm_blockpcl.do_callproc.fparams -912
    %define mm_blockpcl.do_callproc.nfixedparams -920
    %define mm_blockpcl.do_callproc.d -928
    %define mm_blockpcl.do_callproc.e -936
    %define mm_blockpcl.do_callproc.pmult -944
    %define mm_blockpcl.do_callproc.q -952
    %define mm_blockpcl.do_callproc.i -960
    %define mm_blockpcl.do_callproc.$T1 -968
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	1000
    mov       r15,	rcx
    mov       [rbp+80],	rdx
    mov       [rbp+88],	r8
;---------------
    xor       rbx,	rbx
    mov       rax,	[rbp + mm_blockpcl.do_callproc.a]
    movzx     rax,	byte [rax]
    cmp       rax,	4
    jz        L5856
    cmp       rax,	53
    jz        L5857
    jmp       L5858
L5856:
    mov       rax,	[rbp + mm_blockpcl.do_callproc.a]
    mov       rax,	[rax+16]
    mov       [rbp + mm_blockpcl.do_callproc.d],	rax
    jmp       L5855
L5857:
    mov       rax,	[rbp + mm_blockpcl.do_callproc.a]
    movsxd    rax,	dword [rax+49]
    lea       r10,	[mm_decls.ttnamedef]
    mov       r10,	[r10 + rax*8]
    mov       [rbp + mm_blockpcl.do_callproc.d],	r10
    mov       rbx,	1
    jmp       L5855
L5858:
    lea       rcx,	[L12853]
    xor       edx,	edx
    call      mm_support.gerror
L5855:
    mov       rax,	[rbp + mm_blockpcl.do_callproc.d]
    movsxd    rax,	dword [rax+72]
    cmp       rax,	0
    setnz     al
    movzx     eax,	al
    mov       r13,	rax
    xor       rdi,	rdi
    xor       eax,	eax
    mov       rsi,	rax
    mov       rax,	[rbp + mm_blockpcl.do_callproc.b]
    mov       [rbp + mm_blockpcl.do_callproc.q],	rax
    xor       eax,	eax
    mov       [rbp + mm_blockpcl.do_callproc.nfixedparams],	rax
    mov       rax,	[rbp + mm_blockpcl.do_callproc.d]
    mov       rax,	[rax+16]
    mov       [rbp + mm_blockpcl.do_callproc.e],	rax
    jmp       L5862
L5859:
    mov       rax,	[rbp + mm_blockpcl.do_callproc.e]
    movzx     rax,	byte [rax+78]
    cmp       rax,	12
    jnz       L5864
    inc       qword [rbp + mm_blockpcl.do_callproc.nfixedparams]
L5864:
    mov       rax,	[rbp + mm_blockpcl.do_callproc.e]
    mov       rax,	[rax+32]
    mov       [rbp + mm_blockpcl.do_callproc.e],	rax
L5862:
    mov       rax,	[rbp + mm_blockpcl.do_callproc.e]
    test      rax,	rax
    jnz       L5859
    mov       rax,	[rbp + mm_blockpcl.do_callproc.b]
    mov       [rbp + mm_blockpcl.do_callproc.q],	rax
    jmp       L5868
L5865:
    cmp       rdi,	100
    jl        L5870
    lea       rcx,	[L12854]
    xor       edx,	edx
    call      mm_support.gerror
L5870:
    inc       rdi
    mov       rax,	rdi
    mov       r10,	[rbp + mm_blockpcl.do_callproc.q]
    mov       [rbp + rax*8 + mm_blockpcl.do_callproc.paramlist-8],	r10
    mov       rax,	[rbp + mm_blockpcl.do_callproc.d]
    mov       al,	[rax+123]
    test      al,	al
    jz        L5872
    cmp       rdi,	[rbp + mm_blockpcl.do_callproc.nfixedparams]
    jl        L5872
    cmp       rdi,	4
    jg        L5872
    test      rsi,	rsi
    jnz       L5872
    mov       rsi,	rdi
L5872:
    mov       rax,	[rbp + mm_blockpcl.do_callproc.q]
    mov       rax,	[rax+8]
    mov       [rbp + mm_blockpcl.do_callproc.q],	rax
L5868:
    mov       rax,	[rbp + mm_blockpcl.do_callproc.q]
    test      rax,	rax
    jnz       L5865
    mov       rcx,	131
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	r15
    call      mm_libpcl.setmode_u
    mov       eax,	edi
    mov       r10,	[pc_api.pccurr]
    mov       [r10+16],	eax
    xor       eax,	eax
    mov       [rbp + mm_blockpcl.do_callproc.fparams],	rax
    mov       r14,	rax
    mov       rax,	1
    mov       [rbp + mm_blockpcl.do_callproc.i],	rax
    cmp       rdi,	1
    jl        L5875
L5873:
    mov       rax,	[rbp + mm_blockpcl.do_callproc.i]
    mov       rax,	[rbp + rax*8 + mm_blockpcl.do_callproc.paramlist-8]
    mov       [rbp + mm_blockpcl.do_callproc.q],	rax
    xor       eax,	eax
    mov       r10,	[rbp + mm_blockpcl.do_callproc.i]
    mov       [rbp + r10 + mm_blockpcl.do_callproc.argattr-1],	al
    mov       rax,	[rbp + mm_blockpcl.do_callproc.q]
    movsxd    rax,	dword [rax+49]
    cmp       rax,	2
    jz        L5878
    cmp       rax,	1
    jnz       L5877
L5878:
    inc       qword [rbp + mm_blockpcl.do_callproc.fparams]
    mov       rax,	[rbp + mm_blockpcl.do_callproc.fparams]
    cmp       rax,	8
    jle       L5880
    mov       al,	2
    mov       r10,	[rbp + mm_blockpcl.do_callproc.i]
    mov       [rbp + r10 + mm_blockpcl.do_callproc.argattr-1],	al
L5880:
    jmp       L5876
L5877:
    inc       r14
    cmp       r14,	8
    jle       L5882
    mov       al,	2
    mov       r10,	[rbp + mm_blockpcl.do_callproc.i]
    mov       [rbp + r10 + mm_blockpcl.do_callproc.argattr-1],	al
L5882:
L5876:
    mov       rax,	[rbp + mm_blockpcl.do_callproc.i]
    inc       rax
    mov       [rbp + mm_blockpcl.do_callproc.i],	rax
    cmp       rax,	rdi
    jle       L5873
L5875:
    mov       rax,	[rbp + mm_blockpcl.do_callproc.fparams]
    cmp       rax,	8
    jle       L5884
    cmp       r14,	8
    jle       L5884
    lea       rcx,	[L12855]
    xor       edx,	edx
    call      mm_support.gerror
L5884:
    mov       rax,	[rbp + mm_blockpcl.do_callproc.fparams]
    mov       r10,	r14
    cmp       rax,	r10
    cmovl     rax,	r10
    sub       rax,	8
    mov       r14,	rax
    mov       [rbp + mm_blockpcl.do_callproc.i],	rdi
    mov       rax,	[rbp + mm_blockpcl.do_callproc.i]
    cmp       rax,	1
    jl        L5887
L5885:
    mov       eax,	r14d
    and       eax,	1
    test      rax,	rax
    jz        L5889
    mov       rax,	[rbp + mm_blockpcl.do_callproc.i]
    mov       al,	[rbp + rax + mm_blockpcl.do_callproc.argattr-1]
    test      al,	al
    jz        L5889
    mov       al,	1
    mov       r10,	[rbp + mm_blockpcl.do_callproc.i]
    mov       [rbp + r10 + mm_blockpcl.do_callproc.argattr-1],	al
    xor       r14,	r14
L5889:
    mov       rax,	[rbp + mm_blockpcl.do_callproc.i]
    mov       rax,	[rbp + rax*8 + mm_blockpcl.do_callproc.paramlist-8]
    mov       [rbp + mm_blockpcl.do_callproc.q],	rax
    mov       rcx,	[rbp + mm_blockpcl.do_callproc.q]
    call      mm_blockpcl.evalunit
    test      rsi,	rsi
    jz        L5891
    mov       rax,	[rbp + mm_blockpcl.do_callproc.i]
    cmp       rax,	rsi
    jl        L5891
    mov       rax,	[pc_api.pccurr]
    movzx     rax,	byte [rax+3]
    cmp       rax,	1
    jnz       L5891
    mov       rcx,	115
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       eax,	8
    mov       r10,	[pc_api.pccurr]
    mov       [r10+4],	eax
    mov       al,	2
    mov       r10,	[pc_api.pccurr]
    mov       [r10+3],	al
    mov       rax,	[pc_api.pccurr]
    lea       rax,	[rax+28]
    mov       r10d,	1
    mov       r9d,	[rax]
    mov       r11,	-256
    and       r9d,	r11d
    or        r9d,	r10d
    mov       [rax],	r9d
    mov       rcx,	132
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	1
    call      mm_libpcl.setmode
    jmp       L5890
L5891:
    mov       rcx,	132
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	[rbp + mm_blockpcl.do_callproc.q]
    call      mm_libpcl.setmode_u
L5890:
    mov       eax,	[rbp + mm_blockpcl.do_callproc.i]
    mov       r10,	[pc_api.pccurr]
    mov       [r10+16],	eax
    mov       rax,	[rbp + mm_blockpcl.do_callproc.i]
    movsx     rax,	byte [rbp + rax + mm_blockpcl.do_callproc.argattr-1]
    mov       r10,	[pc_api.pccurr]
    mov       [r10+20],	eax
    mov       rax,	[rbp + mm_blockpcl.do_callproc.i]
    dec       rax
    mov       [rbp + mm_blockpcl.do_callproc.i],	rax
    cmp       rax,	1
    jge       L5885
L5887:
    test      rbx,	rbx
    jnz       L5893
    mov       rcx,	[rbp + mm_blockpcl.do_callproc.d]
    call      mm_genpcl.genmemaddr_d
    mov       [rbp + mm_blockpcl.do_callproc.$T1],	rax
    test      r13,	r13
    jz        L5895
    mov       rax,	21
    jmp       L5894
L5895:
    mov       rax,	18
L5894:
    mov       rcx,	rax
    mov       rdx,	[rbp + mm_blockpcl.do_callproc.$T1]
    call      pc_api.pc_gen
    jmp       L5892
L5893:
    mov       rax,	[rbp + mm_blockpcl.do_callproc.a]
    mov       rcx,	[rax+16]
    call      mm_blockpcl.evalunit
    test      r13,	r13
    jz        L5897
    mov       rax,	22
    jmp       L5896
L5897:
    mov       rax,	19
L5896:
    mov       rcx,	rax
    xor       edx,	edx
    call      pc_api.pc_gen
L5892:
    mov       eax,	edi
    mov       r10,	[pc_api.pccurr]
    mov       [r10+16],	eax
    mov       eax,	esi
    mov       r10,	[pc_api.pccurr]
    mov       [r10+20],	eax
    test      r13,	r13
    jz        L5899
    mov       rcx,	r15
    call      mm_libpcl.setmode_u
L5899:
    mov       rax,	[rbp + mm_blockpcl.do_callproc.d]
    movzx     rax,	byte [rax+122]
    cmp       rax,	1
    jle       L5901
    test      r13,	r13
    jz        L5901
    mov       rax,	[rbp + mm_blockpcl.do_callproc.d]
    movzx     rax,	byte [rax+122]
    mov       r12,	rax
    mov       rax,	[rbp + mm_blockpcl.do_callproc.d]
    movsxd    rax,	dword [rax+72]
    lea       r10,	[mm_decls.ttmult]
    mov       r10,	[r10 + rax*8]
    mov       [rbp + mm_blockpcl.do_callproc.pmult],	r10
    mov       rax,	1
    mov       [rbp + mm_blockpcl.do_callproc.i],	rax
    cmp       r12,	1
    jl        L5904
L5902:
    mov       rcx,	13
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rax,	[rbp + mm_blockpcl.do_callproc.pmult]
    mov       r10,	[rbp + mm_blockpcl.do_callproc.i]
    movsxd    rax,	dword [rax + r10*4-4]
    mov       rcx,	rax
    call      mm_libpcl.setmode
    mov       rax,	[rbp + mm_blockpcl.do_callproc.i]
    inc       rax
    mov       [rbp + mm_blockpcl.do_callproc.i],	rax
    cmp       rax,	r12
    jle       L5902
L5904:
L5901:
    test      r13,	r13
    jz        L5906
    mov       al,	[r15+61]
    test      al,	al
    jnz       L5906
    mov       rcx,	11
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	r15
    call      mm_libpcl.setmode_u
L5906:
;---------------
    add       rsp,	1000
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_print
mm_blockpcl.do_print:
;?>>
   %define R.p r14
    %define mm_blockpcl.do_print.a 72
    %define mm_blockpcl.do_print.b 80
   %define R.q rdi
   %define R.r rbx
   %define R.fmt rsi
   %define R.m r12
   %define R.fn r13
    %define mm_blockpcl.do_print.needprintend -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       r14,	rcx
    mov       [rbp+72],	rdx
    mov       [rbp+80],	r8
;---------------
    mov       rax,	[rbp + mm_blockpcl.do_print.a]
    test      rax,	rax
    jz        L5909
    mov       rax,	1
    mov       [rbp + mm_blockpcl.do_print.needprintend],	rax
    mov       rax,	[rbp + mm_blockpcl.do_print.a]
    movsxd    rax,	dword [rax+49]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    cmp       r10,	7
    jz        L5911
    lea       rcx,	[L12856]
    xor       edx,	edx
    call      mm_support.gerror
L5911:
    mov       rax,	[rbp + mm_blockpcl.do_print.a]
    movsxd    rax,	dword [rax+49]
    lea       r10,	[mm_decls.tttarget]
    movsxd    r10,	dword [r10 + rax*4]
    lea       rax,	[mm_decls.ttbasetype]
    movsxd    rax,	dword [rax + r10*4]
    test      rax,	rax
    jz        L5913
    cmp       rax,	12
    jz        L5914
    cmp       rax,	7
    jz        L5915
    jmp       L5916
L5913:
    sub       rsp,	8
    push      0
    mov       rcx,	2
    mov       rdx,	[rbp + mm_blockpcl.do_print.a]
    xor       r8d,	r8d
    xor       r9d,	r9d
    sub       rsp,	32
    call      mm_genpcl.genpc_sysproc
    add       rsp,	48
    jmp       L5912
L5914:
    sub       rsp,	8
    push      0
    mov       rcx,	3
    mov       rdx,	[rbp + mm_blockpcl.do_print.a]
    xor       r8d,	r8d
    xor       r9d,	r9d
    sub       rsp,	32
    call      mm_genpcl.genpc_sysproc
    add       rsp,	48
    jmp       L5912
L5915:
    sub       rsp,	8
    push      0
    mov       rcx,	4
    mov       rdx,	[rbp + mm_blockpcl.do_print.a]
    xor       r8d,	r8d
    xor       r9d,	r9d
    sub       rsp,	32
    call      mm_genpcl.genpc_sysproc
    add       rsp,	48
    jmp       L5912
L5916:
    lea       rcx,	[L12857]
    xor       edx,	edx
    call      mm_support.gerror
L5912:
    jmp       L5908
L5909:
    mov       rax,	1
    mov       [rbp + mm_blockpcl.do_print.needprintend],	rax
    sub       rsp,	8
    push      0
    mov       rcx,	5
    xor       edx,	edx
    xor       r8d,	r8d
    xor       r9d,	r9d
    sub       rsp,	32
    call      mm_genpcl.genpc_sysproc
    add       rsp,	48
L5908:
    mov       rdi,	[rbp + mm_blockpcl.do_print.b]
    movzx     rax,	byte [r14]
    cmp       rax,	116
    jz        L5918
    cmp       rax,	117
    jnz       L5919
L5918:
    movsxd    rax,	dword [rdi+49]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    cmp       r10,	7
    jnz       L5922
    movsxd    rax,	dword [rdi+49]
    lea       r10,	[mm_decls.tttarget]
    movsxd    r10,	dword [r10 + rax*4]
    lea       rax,	[mm_decls.ttbasetype]
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	12
    jz        L5921
L5922:
    lea       rcx,	[L12858]
    xor       edx,	edx
    call      mm_support.gerror
L5921:
    sub       rsp,	8
    push      0
    mov       rcx,	6
    mov       rdx,	rdi
    xor       r8d,	r8d
    xor       r9d,	r9d
    sub       rsp,	32
    call      mm_genpcl.genpc_sysproc
    add       rsp,	48
    mov       rdi,	[r14+32]
L5919:
L5917:
    jmp       L5924
L5923:
    movzx     rax,	byte [rdi]
    cmp       rax,	86
    jz        L5927
    cmp       rax,	87
    jz        L5928
    cmp       rax,	88
    jz        L5929
    jmp       L5930
L5927:
    mov       rsi,	[rdi+24]
    mov       rbx,	[rdi+16]
    movsxd    rax,	dword [rbx+49]
    mov       r12,	rax
    jmp       L5926
L5928:
    sub       rsp,	8
    push      0
    mov       rcx,	7
    xor       edx,	edx
    xor       r8d,	r8d
    xor       r9d,	r9d
    sub       rsp,	32
    call      mm_genpcl.genpc_sysproc
    add       rsp,	48
    mov       rdi,	[rdi+8]
    jmp       L5924
L5929:
    sub       rsp,	8
    push      0
    mov       rcx,	8
    xor       edx,	edx
    xor       r8d,	r8d
    xor       r9d,	r9d
    sub       rsp,	32
    call      mm_genpcl.genpc_sysproc
    add       rsp,	48
    mov       rdi,	[rdi+8]
    jmp       L5924
L5930:
    xor       rsi,	rsi
    mov       rax,	rdi
    mov       rbx,	rax
    movsxd    rax,	dword [rdi+49]
    mov       r12,	rax
L5926:
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	r12
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	3
    jz        L5932
    cmp       rax,	4
    jz        L5933
    cmp       rax,	2
    jz        L5934
    cmp       rax,	1
    jz        L5935
    cmp       rax,	7
    jz        L5936
    cmp       rax,	6
    jz        L5937
    cmp       rax,	10
    jz        L5938
    cmp       rax,	8
    jz        L5939
    cmp       rax,	11
    jz        L5940
    cmp       rax,	5
    jz        L5941
    jmp       L5942
L5932:
    mov       r13,	9
    test      rsi,	rsi
    jnz       L5944
    mov       r13,	10
L5944:
    jmp       L5931
L5933:
    mov       r13,	11
    jmp       L5931
L5934:
    mov       r13,	13
    jmp       L5931
L5935:
    mov       r13,	12
    jmp       L5931
L5936:
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	r12
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	12
    jz        L5947
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	r12
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	10
    jnz       L5946
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	r12
    movsxd    rax,	dword [rax + r10*4]
    lea       r10,	[mm_decls.tttarget]
    movsxd    r10,	dword [r10 + rax*4]
    cmp       r10,	12
    jnz       L5946
L5947:
    mov       r13,	14
    test      rsi,	rsi
    jnz       L5949
    mov       r13,	15
L5949:
    jmp       L5945
L5946:
    mov       r13,	17
    test      rsi,	rsi
    jnz       L5951
    mov       r13,	18
L5951:
L5945:
    jmp       L5931
L5937:
    mov       r13,	20
    jmp       L5931
L5938:
    lea       rcx,	[L12859]
    xor       edx,	edx
    call      mm_support.gerror
    mov       rdi,	[rdi+8]
    jmp       L5931
L5939:
    lea       rcx,	[L12860]
    xor       edx,	edx
    call      mm_support.gerror
    jmp       L5931
L5940:
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	r12
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	12
    jnz       L5953
    mov       r13,	16
    jmp       L5952
L5953:
    lea       rcx,	[L12861]
    xor       edx,	edx
    call      mm_support.gerror
L5952:
    jmp       L5931
L5941:
    mov       r13,	19
    jmp       L5931
L5942:
    call      msys.m$print_startcon
    mov       rcx,	r12
    mov       rdx,	1
    call      mm_lib.strmode
    mov       rcx,	rax
    call      msys.m$print_str_nf
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	r12
    movsxd    rax,	dword [rax + r10*4]
    mov       rcx,	rax
    mov       rdx,	1
    call      mm_lib.strmode
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	r12
    mov       rdx,	1
    call      mm_lib.strmode
    lea       rcx,	[L12862]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_support.gerror_s
L5931:
    mov       rax,	r13
    cmp       rax,	10
    jz        L5955
    cmp       rax,	15
    jz        L5955
    cmp       rax,	18
    jnz       L5956
L5955:
    sub       rsp,	8
    push      0
    mov       rcx,	r13
    mov       rdx,	rbx
    xor       r8d,	r8d
    xor       r9d,	r9d
    sub       rsp,	32
    call      mm_genpcl.genpc_sysproc
    add       rsp,	48
    jmp       L5954
L5956:
    sub       rsp,	8
    push      0
    test      rsi,	rsi
    jz        L5958
    mov       rax,	rsi
    jmp       L5957
L5958:
    mov       rax,	[mm_genpcl.pzero]
L5957:
    mov       rcx,	r13
    mov       rdx,	rbx
    mov       r8,	rax
    xor       r9d,	r9d
    sub       rsp,	32
    call      mm_genpcl.genpc_sysproc
    add       rsp,	48
L5954:
    mov       rdi,	[rdi+8]
L5924:
    test      rdi,	rdi
    jnz       L5923
    movzx     rax,	byte [r14]
    cmp       rax,	115
    jz        L5960
    cmp       rax,	117
    jnz       L5961
L5960:
    sub       rsp,	8
    push      0
    mov       rcx,	21
    xor       edx,	edx
    xor       r8d,	r8d
    xor       r9d,	r9d
    sub       rsp,	32
    call      mm_genpcl.genpc_sysproc
    add       rsp,	48
L5961:
L5959:
    mov       rax,	[rbp + mm_blockpcl.do_print.needprintend]
    test      rax,	rax
    jz        L5963
    sub       rsp,	8
    push      0
    mov       rcx,	22
    xor       edx,	edx
    xor       r8d,	r8d
    xor       r9d,	r9d
    sub       rsp,	32
    call      mm_genpcl.genpc_sysproc
    add       rsp,	48
L5963:
;---------------
    add       rsp,	48
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_incr
mm_blockpcl.do_incr:
;?>>
   %define R.p rdi
   %define R.a rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rbx
    xor       edx,	edx
    call      mm_blockpcl.evalref
    call      mm_blockpcl.do_setinplace
    movzx     rax,	byte [rdi+62]
    mov       rcx,	rax
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	rbx
    call      mm_libpcl.setmode_u
    movsxd    rax,	dword [rbx+49]
    mov       rcx,	rax
    call      mm_blockpcl.setincrstep
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.setincrstep
mm_blockpcl.setincrstep:
;?>>
   %define R.m rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	1
    call      pc_api.pc_setincr
    lea       rax,	[mm_decls.ttisref]
    mov       r10,	rdi
    mov       al,	[rax + r10]
    test      al,	al
    jz        L5967
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	rdi
    movsxd    rax,	dword [rax + r10*4]
    lea       r10,	[mm_decls.ttsize]
    mov       r10d,	[r10 + rax*4]
    mov       rcx,	r10
    call      pc_api.pc_setincr
L5967:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_incrload
mm_blockpcl.do_incrload:
;?>>
   %define R.p rdi
   %define R.a rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rbx
    xor       edx,	edx
    call      mm_blockpcl.evalref
    call      mm_blockpcl.do_setinplace
    movzx     rax,	byte [rdi+62]
    mov       rcx,	rax
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	rbx
    call      mm_libpcl.setmode_u
    movsxd    rax,	dword [rbx+49]
    mov       rcx,	rax
    call      mm_blockpcl.setincrstep
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_for
mm_blockpcl.do_for:
;?>>
    %define mm_blockpcl.do_for.p 64
   %define R.pindex r14
    %define mm_blockpcl.do_for.pfrom 80
    %define mm_blockpcl.do_for.pbody 88
    %define mm_blockpcl.do_for.down 96
   %define R.pto rdi
   %define R.pstep rbx
   %define R.pelse rsi
   %define R.px r12
   %define R.ptoinit r13
    %define mm_blockpcl.do_for.lab_b -8
    %define mm_blockpcl.do_for.lab_c -16
    %define mm_blockpcl.do_for.lab_d -24
    %define mm_blockpcl.do_for.lab_e -32
    %define mm_blockpcl.do_for.a -40
    %define mm_blockpcl.do_for.b -48
    %define mm_blockpcl.do_for.stepx -56
    %define mm_blockpcl.do_for.d -64
    %define mm_blockpcl.do_for.$T1 -72
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	112
    mov       r14,	rdx
    mov       [rbp+80],	r8
    mov       [rbp+88],	r9
;---------------
    mov       rax,	[rbp + mm_blockpcl.do_for.pfrom]
    mov       rdi,	[rax+8]
    mov       rbx,	[rdi+8]
    mov       rax,	[rbp + mm_blockpcl.do_for.pbody]
    mov       rsi,	[rax+8]
    mov       r13,	[r14+8]
    movzx     rax,	byte [rdi]
    cmp       rax,	53
    jnz       L5971
    mov       r12,	[rdi+16]
    movzx     rax,	byte [r12]
    cmp       rax,	4
    jnz       L5973
    mov       rax,	[r12+16]
    mov       [rbp + mm_blockpcl.do_for.d],	rax
    movzx     rax,	byte [rax+78]
    cmp       rax,	12
    jnz       L5973
    mov       rax,	[rbp + mm_blockpcl.do_for.d]
    movzx     rax,	byte [rax+160]
    cmp       rax,	1
    jnz       L5973
    lea       rcx,	[L12863]
    xor       edx,	edx
    call      mm_support.gerror
L5973:
L5971:
    call      mm_genpcl.createfwdlabel
    mov       [rbp + mm_blockpcl.do_for.lab_b],	rax
    call      mm_genpcl.createfwdlabel
    mov       [rbp + mm_blockpcl.do_for.lab_c],	rax
    call      mm_genpcl.createfwdlabel
    mov       [rbp + mm_blockpcl.do_for.lab_d],	rax
    test      rsi,	rsi
    jz        L5975
    call      mm_genpcl.createfwdlabel
    mov       [rbp + mm_blockpcl.do_for.lab_e],	rax
    jmp       L5974
L5975:
    mov       rax,	[rbp + mm_blockpcl.do_for.lab_d]
    mov       [rbp + mm_blockpcl.do_for.lab_e],	rax
L5974:
    mov       rcx,	[rbp + mm_blockpcl.do_for.lab_b]
    mov       rdx,	[rbp + mm_blockpcl.do_for.lab_c]
    mov       r8,	[rbp + mm_blockpcl.do_for.lab_d]
    call      mm_genpcl.stacklooplabels
    mov       rcx,	[rbp + mm_blockpcl.do_for.pfrom]
    call      mm_blockpcl.evalunit
    mov       rcx,	r14
    call      mm_genpcl.genmem_u
    mov       rcx,	4
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	r14
    call      mm_libpcl.setmode_u
    test      r13,	r13
    jz        L5977
    xor       eax,	eax
    mov       [r13+61],	al
    mov       rcx,	r13
    call      mm_blockpcl.evalunit
L5977:
    mov       rax,	[rbp + mm_blockpcl.do_for.pfrom]
    movzx     rax,	byte [rax]
    cmp       rax,	1
    jnz       L5979
    movzx     rax,	byte [rdi]
    cmp       rax,	1
    jnz       L5979
    mov       rax,	[rbp + mm_blockpcl.do_for.pfrom]
    mov       rax,	[rax+16]
    mov       [rbp + mm_blockpcl.do_for.a],	rax
    mov       rax,	[rdi+16]
    mov       [rbp + mm_blockpcl.do_for.b],	rax
    mov       rax,	[rbp + mm_blockpcl.do_for.down]
    test      rax,	rax
    jz        L5983
    mov       rax,	[rbp + mm_blockpcl.do_for.a]
    cmp       rax,	[rbp + mm_blockpcl.do_for.b]
    jge       L5982
L5983:
    mov       rax,	[rbp + mm_blockpcl.do_for.down]
    test      rax,	rax
    jnz       L5981
    mov       rax,	[rbp + mm_blockpcl.do_for.a]
    cmp       rax,	[rbp + mm_blockpcl.do_for.b]
    jg        L5981
L5982:
    jmp       L5980
L5981:
    mov       rcx,	[rbp + mm_blockpcl.do_for.lab_e]
    call      pc_api.genlabel
    mov       rcx,	24
    mov       rdx,	rax
    call      pc_api.pc_gen
L5980:
    jmp       L5978
L5979:
    mov       rax,	[rbp + mm_blockpcl.do_for.pfrom]
    movzx     rax,	byte [rax]
    cmp       rax,	1
    jnz       L5985
    mov       rcx,	rdi
    call      mm_blockpcl.evalunit
    mov       rcx,	[rbp + mm_blockpcl.do_for.pfrom]
    call      mm_blockpcl.evalunit
    mov       rcx,	[rbp + mm_blockpcl.do_for.lab_e]
    call      pc_api.genlabel
    mov       [rbp + mm_blockpcl.do_for.$T1],	rax
    mov       rax,	[rbp + mm_blockpcl.do_for.down]
    test      rax,	rax
    jz        L5987
    mov       rax,	6
    jmp       L5986
L5987:
    mov       rax,	3
L5986:
    mov       rcx,	26
    mov       rdx,	rax
    mov       r8,	[rbp + mm_blockpcl.do_for.$T1]
    call      pc_api.pc_gencond
    jmp       L5984
L5985:
    mov       rcx,	r14
    call      mm_blockpcl.evalunit
    mov       rcx,	rdi
    call      mm_blockpcl.evalunit
    mov       rcx,	[rbp + mm_blockpcl.do_for.lab_e]
    call      pc_api.genlabel
    mov       [rbp + mm_blockpcl.do_for.$T1],	rax
    mov       rax,	[rbp + mm_blockpcl.do_for.down]
    test      rax,	rax
    jz        L5989
    mov       rax,	3
    jmp       L5988
L5989:
    mov       rax,	6
L5988:
    mov       rcx,	26
    mov       rdx,	rax
    mov       r8,	[rbp + mm_blockpcl.do_for.$T1]
    call      pc_api.pc_gencond
L5984:
    mov       rcx,	r14
    call      mm_libpcl.setmode_u
L5978:
    mov       rcx,	[rbp + mm_blockpcl.do_for.lab_b]
    call      mm_genpcl.definefwdlabel
    mov       rcx,	[rbp + mm_blockpcl.do_for.pbody]
    call      mm_blockpcl.evalunit
    mov       rcx,	[rbp + mm_blockpcl.do_for.lab_c]
    call      mm_genpcl.definefwdlabel
    test      rbx,	rbx
    jz        L5991
    movzx     rax,	byte [rbx]
    cmp       rax,	1
    jz        L5993
    lea       rcx,	[L12864]
    xor       edx,	edx
    call      mm_support.gerror
L5993:
    mov       rax,	[rbx+16]
    mov       [rbp + mm_blockpcl.do_for.stepx],	rax
    mov       rax,	[rbp + mm_blockpcl.do_for.stepx]
    cmp       rax,	0
    jg        L5995
    lea       rcx,	[L12865]
    xor       edx,	edx
    call      mm_support.gerror
L5995:
    mov       rcx,	[rbp + mm_blockpcl.do_for.lab_b]
    call      pc_api.genlabel
    mov       [rbp + mm_blockpcl.do_for.$T1],	rax
    mov       rax,	[rbp + mm_blockpcl.do_for.down]
    test      rax,	rax
    jz        L5997
    mov       rax,	35
    jmp       L5996
L5997:
    mov       rax,	34
L5996:
    mov       rcx,	rax
    mov       rdx,	[rbp + mm_blockpcl.do_for.stepx]
    mov       r8,	[rbp + mm_blockpcl.do_for.$T1]
    call      pc_api.pc_genx
    mov       rcx,	r14
    call      mm_libpcl.setmode_u
    jmp       L5990
L5991:
    mov       rcx,	[rbp + mm_blockpcl.do_for.lab_b]
    call      pc_api.genlabel
    mov       [rbp + mm_blockpcl.do_for.$T1],	rax
    mov       rax,	[rbp + mm_blockpcl.do_for.down]
    test      rax,	rax
    jz        L5999
    mov       rax,	35
    jmp       L5998
L5999:
    mov       rax,	34
L5998:
    mov       rcx,	rax
    mov       rdx,	1
    mov       r8,	[rbp + mm_blockpcl.do_for.$T1]
    call      pc_api.pc_genx
    mov       rcx,	r14
    call      mm_libpcl.setmode_u
L5990:
    mov       rcx,	r14
    call      mm_genpcl.genmem_u
    mov       rcx,	12
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	3
    call      mm_libpcl.setmode
    movzx     rax,	byte [rdi]
    cmp       rax,	1
    jz        L6001
    cmp       rax,	4
    jz        L6002
    jmp       L6003
L6001:
    mov       rax,	[rdi+16]
    mov       rcx,	rax
    call      pc_api.genint
    mov       rcx,	12
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	3
    call      mm_libpcl.setmode
    jmp       L6000
L6002:
    mov       rcx,	rdi
    call      mm_genpcl.genmem_u
    mov       rcx,	12
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	3
    call      mm_libpcl.setmode
L6003:
L6000:
    test      rsi,	rsi
    jz        L6005
    mov       rcx,	[rbp + mm_blockpcl.do_for.lab_e]
    call      mm_genpcl.definefwdlabel
    mov       rcx,	rsi
    call      mm_blockpcl.evalunit
L6005:
    mov       rcx,	[rbp + mm_blockpcl.do_for.lab_d]
    call      mm_genpcl.definefwdlabel
    dec       qword [mm_genpcl.loopindex]
;---------------
    add       rsp,	112
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_forall
mm_blockpcl.do_forall:
;?>>
    %define mm_blockpcl.do_forall.p 64
   %define R.pindex r14
    %define mm_blockpcl.do_forall.plist 80
    %define mm_blockpcl.do_forall.pbody 88
    %define mm_blockpcl.do_forall.down 96
   %define R.plocal rdi
   %define R.pfrom rbx
   %define R.pto rsi
   %define R.pelse r12
   %define R.passign r13
    %define mm_blockpcl.do_forall.lab_b -8
    %define mm_blockpcl.do_forall.lab_c -16
    %define mm_blockpcl.do_forall.lab_d -24
    %define mm_blockpcl.do_forall.lab_e -32
    %define mm_blockpcl.do_forall.a -40
    %define mm_blockpcl.do_forall.b -48
    %define mm_blockpcl.do_forall.dto -56
    %define mm_blockpcl.do_forall.$T1 -64
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	96
    mov       r14,	rdx
    mov       [rbp+80],	r8
    mov       [rbp+88],	r9
;---------------
    mov       rdi,	[r14+8]
    mov       rbx,	[rdi+8]
    mov       rsi,	[rbx+8]
    mov       rax,	[rbp + mm_blockpcl.do_forall.plist]
    mov       r13,	[rax+8]
    mov       rax,	[rbp + mm_blockpcl.do_forall.pbody]
    mov       r12,	[rax+8]
    call      mm_genpcl.createfwdlabel
    mov       [rbp + mm_blockpcl.do_forall.lab_b],	rax
    call      mm_genpcl.createfwdlabel
    mov       [rbp + mm_blockpcl.do_forall.lab_c],	rax
    call      mm_genpcl.createfwdlabel
    mov       [rbp + mm_blockpcl.do_forall.lab_d],	rax
    test      r12,	r12
    jz        L6008
    call      mm_genpcl.createfwdlabel
    mov       [rbp + mm_blockpcl.do_forall.lab_e],	rax
    jmp       L6007
L6008:
    mov       rax,	[rbp + mm_blockpcl.do_forall.lab_d]
    mov       [rbp + mm_blockpcl.do_forall.lab_e],	rax
L6007:
    mov       rcx,	[rbp + mm_blockpcl.do_forall.lab_b]
    mov       rdx,	[rbp + mm_blockpcl.do_forall.lab_c]
    mov       r8,	[rbp + mm_blockpcl.do_forall.lab_d]
    call      mm_genpcl.stacklooplabels
    mov       rcx,	rbx
    call      mm_blockpcl.evalunit
    mov       rcx,	r14
    call      mm_genpcl.genmem_u
    mov       rcx,	4
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	r14
    call      mm_libpcl.setmode_u
    movzx     rax,	byte [rsi]
    cmp       rax,	1
    jz        L6010
    cmp       rax,	4
    jz        L6010
    mov       rcx,	rsi
    call      mm_blockpcl.evalunit
    mov       rcx,	[mm_decls.currproc]
    mov       rdx,	11
    call      mm_lib.getavname
    mov       [rbp + mm_blockpcl.do_forall.dto],	rax
    mov       rcx,	[rbp + mm_blockpcl.do_forall.dto]
    call      mm_genpcl.genmem_d
    mov       rcx,	4
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	3
    call      mm_libpcl.setmode
    mov       rcx,	[rbp + mm_blockpcl.do_forall.dto]
    call      mm_lib.createname
    mov       rsi,	rax
    mov       rax,	[rbp + mm_blockpcl.do_forall.dto]
    mov       eax,	[rax+72]
    mov       [rsi+49],	eax
    mov       al,	1
    mov       [rsi+61],	al
L6010:
    movzx     rax,	byte [rbx]
    cmp       rax,	1
    jnz       L6012
    movzx     rax,	byte [rsi]
    cmp       rax,	1
    jnz       L6012
    mov       rax,	[rbx+16]
    mov       [rbp + mm_blockpcl.do_forall.a],	rax
    mov       rax,	[rsi+16]
    mov       [rbp + mm_blockpcl.do_forall.b],	rax
    mov       rax,	[rbp + mm_blockpcl.do_forall.down]
    test      rax,	rax
    jz        L6016
    mov       rax,	[rbp + mm_blockpcl.do_forall.a]
    cmp       rax,	[rbp + mm_blockpcl.do_forall.b]
    jge       L6015
L6016:
    mov       rax,	[rbp + mm_blockpcl.do_forall.down]
    test      rax,	rax
    jnz       L6014
    mov       rax,	[rbp + mm_blockpcl.do_forall.a]
    cmp       rax,	[rbp + mm_blockpcl.do_forall.b]
    jg        L6014
L6015:
    jmp       L6013
L6014:
    mov       rcx,	[rbp + mm_blockpcl.do_forall.lab_e]
    call      pc_api.genlabel
    mov       rcx,	24
    mov       rdx,	rax
    call      pc_api.pc_gen
L6013:
    jmp       L6011
L6012:
    movzx     rax,	byte [rbx]
    cmp       rax,	1
    jnz       L6018
    mov       rcx,	rsi
    call      mm_blockpcl.evalunit
    mov       rcx,	rbx
    call      mm_blockpcl.evalunit
    mov       rcx,	[rbp + mm_blockpcl.do_forall.lab_e]
    call      pc_api.genlabel
    mov       [rbp + mm_blockpcl.do_forall.$T1],	rax
    mov       rax,	[rbp + mm_blockpcl.do_forall.down]
    test      rax,	rax
    jz        L6020
    mov       rax,	6
    jmp       L6019
L6020:
    mov       rax,	3
L6019:
    mov       rcx,	26
    mov       rdx,	rax
    mov       r8,	[rbp + mm_blockpcl.do_forall.$T1]
    call      pc_api.pc_gencond
    jmp       L6017
L6018:
    mov       rcx,	rbx
    call      mm_blockpcl.evalunit
    mov       rcx,	rsi
    call      mm_blockpcl.evalunit
    mov       rcx,	[rbp + mm_blockpcl.do_forall.lab_e]
    call      pc_api.genlabel
    mov       [rbp + mm_blockpcl.do_forall.$T1],	rax
    mov       rax,	[rbp + mm_blockpcl.do_forall.down]
    test      rax,	rax
    jz        L6022
    mov       rax,	3
    jmp       L6021
L6022:
    mov       rax,	6
L6021:
    mov       rcx,	26
    mov       rdx,	rax
    mov       r8,	[rbp + mm_blockpcl.do_forall.$T1]
    call      pc_api.pc_gencond
L6017:
    mov       rcx,	r14
    call      mm_libpcl.setmode_u
L6011:
    mov       rcx,	[rbp + mm_blockpcl.do_forall.lab_b]
    call      mm_genpcl.definefwdlabel
    xor       eax,	eax
    mov       [r13+61],	al
    mov       rcx,	r13
    call      mm_blockpcl.evalunit
    mov       rcx,	[rbp + mm_blockpcl.do_forall.pbody]
    call      mm_blockpcl.evalunit
    mov       rcx,	[rbp + mm_blockpcl.do_forall.lab_c]
    call      mm_genpcl.definefwdlabel
    mov       rcx,	[rbp + mm_blockpcl.do_forall.lab_b]
    call      pc_api.genlabel
    mov       [rbp + mm_blockpcl.do_forall.$T1],	rax
    mov       rax,	[rbp + mm_blockpcl.do_forall.down]
    test      rax,	rax
    jz        L6024
    mov       rax,	35
    jmp       L6023
L6024:
    mov       rax,	34
L6023:
    mov       rcx,	rax
    mov       rdx,	1
    mov       r8,	[rbp + mm_blockpcl.do_forall.$T1]
    call      pc_api.pc_genx
    mov       rcx,	r14
    call      mm_libpcl.setmode_u
    mov       rcx,	r14
    call      mm_genpcl.genmem_u
    mov       rcx,	12
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	3
    call      mm_libpcl.setmode
    movzx     rax,	byte [rsi]
    cmp       rax,	1
    jz        L6026
    cmp       rax,	4
    jz        L6027
    jmp       L6028
L6026:
    mov       rax,	[rsi+16]
    mov       rcx,	rax
    call      pc_api.genint
    mov       rcx,	12
    mov       rdx,	rax
    call      pc_api.pc_gen
    jmp       L6025
L6027:
    mov       rcx,	rsi
    call      mm_genpcl.genmem_u
    mov       rcx,	12
    mov       rdx,	rax
    call      pc_api.pc_gen
    jmp       L6025
L6028:
    mov       rcx,	[rbp + mm_blockpcl.do_forall.dto]
    call      mm_genpcl.genmem_d
    mov       rcx,	12
    mov       rdx,	rax
    call      pc_api.pc_gen
L6025:
    mov       rcx,	3
    call      mm_libpcl.setmode
    test      r12,	r12
    jz        L6030
    mov       rcx,	[rbp + mm_blockpcl.do_forall.lab_e]
    call      mm_genpcl.definefwdlabel
    mov       rcx,	r12
    call      mm_blockpcl.evalunit
L6030:
    mov       rcx,	[rbp + mm_blockpcl.do_forall.lab_d]
    call      mm_genpcl.definefwdlabel
    dec       qword [mm_genpcl.loopindex]
;---------------
    add       rsp,	96
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_swap
mm_blockpcl.do_swap:
;?>>
    %define mm_blockpcl.do_swap.p 32
   %define R.a rdi
   %define R.b rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rdx
    mov       rbx,	r8
;---------------
    mov       rcx,	rdi
    xor       edx,	edx
    call      mm_blockpcl.evalref
    call      mm_blockpcl.do_setinplace
    mov       rcx,	rbx
    xor       edx,	edx
    call      mm_blockpcl.evalref
    call      mm_blockpcl.do_setinplace
    mov       rcx,	36
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	rdi
    call      mm_libpcl.setmode_u
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_convert
mm_blockpcl.do_convert:
;?>>
   %define R.p rdi
   %define R.a rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    movzx     rax,	byte [rdi+62]
    cmp       rax,	7
    jz        L6034
    test      rax,	rax
    jz        L6035
    jmp       L6036
L6034:
    mov       rcx,	rbx
    call      mm_blockpcl.evalunit
    jmp       L6032
L6035:
    lea       rcx,	[L12866]
    xor       edx,	edx
    call      mm_support.gerror
    jmp       L6033
L6036:
    mov       rcx,	rbx
    call      mm_blockpcl.evalunit
    movzx     rax,	byte [rdi+62]
    lea       r10,	[mm_tables.convtopcl]
    movzx     r10,	byte [r10 + rax]
    mov       rcx,	r10
    xor       edx,	edx
    call      pc_api.pc_gen
L6033:
    mov       rcx,	rdi
    call      mm_libpcl.setmode_u
    movsxd    rax,	dword [rdi+53]
    mov       rcx,	rax
    call      mm_libpcl.setmode2
L6032:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.checkdotchain
mm_blockpcl.checkdotchain:
;?>>
   %define R.p rbx
   %define R.pname rsi
   %define R.offset rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    movzx     rax,	byte [rbx]
    cmp       rax,	49
    jnz       L6040
L6039:
    mov       rax,	[rbx+16]
    mov       rcx,	rax
    mov       rdx,	rsi
    call      mm_blockpcl.checkdotchain
    mov       rdi,	rax
    mov       eax,	[rbx+40]
    add       rax,	rdi
    jmp       L6037
L6040:
    mov       [rsi],	rbx
    xor       eax,	eax
    jmp       L6037
L6038:
    xor       eax,	eax
L6037:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_dotref
mm_blockpcl.do_dotref:
;?>>
   %define R.pdot r12
   %define R.imode rdi
   %define R.offset rbx
   %define R.a rsi
    %define mm_blockpcl.do_dotref.pname -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       r12,	rcx
;---------------
    movsxd    rax,	dword [r12+49]
    xor       ecx,	ecx
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_lib.createrefmode
    mov       rdi,	rax
    mov       rsi,	[r12+16]
    xor       eax,	eax
    mov       [rbp + mm_blockpcl.do_dotref.pname],	rax
    mov       rcx,	rsi
    lea       rdx,	[rbp + mm_blockpcl.do_dotref.pname]
    call      mm_blockpcl.checkdotchain
    mov       rbx,	rax
    mov       eax,	[r12+40]
    add       rbx,	rax
    mov       rsi,	[rbp + mm_blockpcl.do_dotref.pname]
    mov       rcx,	rsi
    xor       edx,	edx
    call      mm_blockpcl.evalref
    test      rbx,	rbx
    jz        L6043
    mov       rcx,	rbx
    call      mm_genpcl.genpushint
    mov       rcx,	57
    mov       rdx,	1
    xor       r8d,	r8d
    call      pc_api.pc_genix
L6043:
    mov       rcx,	rdi
    call      mm_libpcl.setmode
;---------------
    add       rsp,	48
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_dot
mm_blockpcl.do_dot:
;?>>
   %define R.pdot rsi
   %define R.offset rdi
   %define R.a rbx
    %define mm_blockpcl.do_dot.pname -8
    push      rdi
    push      rbx
    push      rsi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       rsi,	rcx
;---------------
    mov       rbx,	[rsi+16]
    xor       eax,	eax
    mov       [rbp + mm_blockpcl.do_dot.pname],	rax
    mov       rcx,	rbx
    lea       rdx,	[rbp + mm_blockpcl.do_dot.pname]
    call      mm_blockpcl.checkdotchain
    mov       rdi,	rax
    mov       eax,	[rsi+40]
    add       rdi,	rax
    mov       rbx,	[rbp + mm_blockpcl.do_dot.pname]
    mov       rcx,	rbx
    xor       edx,	edx
    call      mm_blockpcl.evalref
    mov       rcx,	rdi
    call      pc_api.genint
    mov       rcx,	1
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	3
    call      mm_libpcl.setmode
    mov       rcx,	3
    mov       rdx,	1
    xor       r8d,	r8d
    call      pc_api.pc_genix
    mov       rcx,	rsi
    call      mm_libpcl.setmode_u
;---------------
    add       rsp,	40
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_storedot
mm_blockpcl.do_storedot:
;?>>
   %define R.pdot rsi
    %define mm_blockpcl.do_storedot.pfield 56
   %define R.rhs r12
   %define R.offset rdi
   %define R.a rbx
    %define mm_blockpcl.do_storedot.pname -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       rsi,	rcx
    mov       r12,	r8
;---------------
    mov       rcx,	r12
    call      mm_blockpcl.evalunit
    mov       al,	[rsi+61]
    test      al,	al
    jz        L6047
    mov       rcx,	9
    xor       edx,	edx
    call      pc_api.pc_gen
L6047:
    mov       rbx,	[rsi+16]
    xor       eax,	eax
    mov       [rbp + mm_blockpcl.do_storedot.pname],	rax
    mov       rcx,	rbx
    lea       rdx,	[rbp + mm_blockpcl.do_storedot.pname]
    call      mm_blockpcl.checkdotchain
    mov       rdi,	rax
    mov       eax,	[rsi+40]
    add       rdi,	rax
    mov       rbx,	[rbp + mm_blockpcl.do_storedot.pname]
    mov       rcx,	rbx
    xor       edx,	edx
    call      mm_blockpcl.evalref
    mov       rcx,	rdi
    call      pc_api.genint
    mov       rcx,	1
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	3
    call      mm_libpcl.setmode
    mov       rcx,	6
    mov       rdx,	1
    xor       r8d,	r8d
    call      pc_api.pc_genix
    mov       rcx,	rsi
    call      mm_libpcl.setmode_u
;---------------
    add       rsp,	48
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_index
mm_blockpcl.do_index:
;?>>
   %define R.p r12
   %define R.parray r13
    %define mm_blockpcl.do_index.pindex 72
   %define R.addoffset rdi
   %define R.scale rbx
   %define R.offset rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       r12,	rcx
    mov       r13,	rdx
    mov       [rbp+72],	r8
;---------------
    mov       rcx,	r13
    lea       rdx,	[rbp + mm_blockpcl.do_index.pindex]
    call      mm_blockpcl.getindexoffset
    mov       rdi,	rax
    mov       rcx,	r13
    call      mm_blockpcl.evalarray
    movsxd    rax,	dword [r13+49]
    lea       r10,	[mm_decls.tttarget]
    movsxd    r10,	dword [r10 + rax*4]
    lea       rax,	[mm_decls.ttsize]
    mov       eax,	[rax + r10*4]
    mov       rbx,	rax
    movsxd    rax,	dword [r13+49]
    lea       r10,	[mm_decls.ttlower]
    movsxd    r10,	dword [r10 + rax*4]
    neg       r10
    imul      r10,	rbx
    mov       rax,	rdi
    imul      rax,	rbx
    add       r10,	rax
    mov       rsi,	r10
    mov       rcx,	[rbp + mm_blockpcl.do_index.pindex]
    call      mm_blockpcl.evalunit
    mov       rcx,	3
    mov       rdx,	rbx
    mov       r8,	rsi
    call      pc_api.pc_genix
    mov       rcx,	r12
    call      mm_libpcl.setmode_u
;---------------
    add       rsp,	40
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_storeindex
mm_blockpcl.do_storeindex:
;?>>
   %define R.p rsi
   %define R.parray r12
    %define mm_blockpcl.do_storeindex.pindex 72
   %define R.rhs r13
   %define R.addoffset rdi
   %define R.scale rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       [rbp+72],	r8
    mov       r13,	r9
;---------------
    mov       rcx,	r12
    lea       rdx,	[rbp + mm_blockpcl.do_storeindex.pindex]
    call      mm_blockpcl.getindexoffset
    mov       rdi,	rax
    mov       rcx,	r13
    call      mm_blockpcl.evalunit
    mov       al,	[rsi+61]
    test      al,	al
    jz        L6051
    mov       rcx,	9
    xor       edx,	edx
    call      pc_api.pc_gen
L6051:
    mov       rcx,	r12
    call      mm_blockpcl.evalarray
    mov       rcx,	[rbp + mm_blockpcl.do_storeindex.pindex]
    call      mm_blockpcl.evalunit
    movsxd    rax,	dword [r12+49]
    lea       r10,	[mm_decls.tttarget]
    movsxd    r10,	dword [r10 + rax*4]
    lea       rax,	[mm_decls.ttsize]
    mov       eax,	[rax + r10*4]
    mov       rbx,	rax
    movsxd    rax,	dword [r12+49]
    lea       r10,	[mm_decls.ttlower]
    movsxd    r10,	dword [r10 + rax*4]
    neg       r10
    imul      r10,	rbx
    mov       rax,	rdi
    imul      rax,	rbx
    add       r10,	rax
    mov       rcx,	6
    mov       rdx,	rbx
    mov       r8,	r10
    call      pc_api.pc_genix
    mov       rcx,	[rsi+16]
    call      mm_libpcl.setmode_u
;---------------
    add       rsp,	40
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_indexref
mm_blockpcl.do_indexref:
;?>>
   %define R.parray rsi
    %define mm_blockpcl.do_indexref.pindex 48
   %define R.addoffset rdi
   %define R.scale rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       rsi,	rcx
    mov       [rbp+48],	rdx
;---------------
    mov       rcx,	rsi
    lea       rdx,	[rbp + mm_blockpcl.do_indexref.pindex]
    call      mm_blockpcl.getindexoffset
    mov       rdi,	rax
    mov       rcx,	rsi
    call      mm_blockpcl.evalarray
    mov       rcx,	[rbp + mm_blockpcl.do_indexref.pindex]
    call      mm_blockpcl.evalunit
    movsxd    rax,	dword [rsi+49]
    lea       r10,	[mm_decls.tttarget]
    movsxd    r10,	dword [r10 + rax*4]
    lea       rax,	[mm_decls.ttsize]
    mov       eax,	[rax + r10*4]
    mov       rbx,	rax
    movsxd    rax,	dword [rsi+49]
    lea       r10,	[mm_decls.ttlower]
    movsxd    r10,	dword [r10 + rax*4]
    neg       r10
    imul      r10,	rbx
    mov       rax,	rdi
    imul      rax,	rbx
    add       r10,	rax
    mov       rcx,	57
    mov       rdx,	rbx
    mov       r8,	r10
    call      pc_api.pc_genix
    movsxd    rax,	dword [rsi+49]
    lea       r10,	[mm_decls.tttarget]
    movsxd    r10,	dword [r10 + rax*4]
    mov       rcx,	r10
    call      mm_libpcl.setmode
;---------------
    add       rsp,	40
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.getindexoffset
mm_blockpcl.getindexoffset:
;?>>
    %define mm_blockpcl.getindexoffset.parray 24
   %define R.pindex rdx
   %define R.addoffset rdi
    push      rdi
;?]]
    sub       rsp,	16
;---------------
    xor       rdi,	rdi
    mov       rax,	[rdx]
    movzx     rax,	byte [rax]
    cmp       rax,	35
    jnz       L6055
    mov       rax,	[rdx]
    movzx     rax,	byte [rax+62]
    cmp       rax,	43
    jz        L6056
    cmp       rax,	44
    jnz       L6055
L6056:
    mov       rax,	[rdx]
    mov       rax,	[rax+24]
    movzx     rax,	byte [rax]
    cmp       rax,	1
    jnz       L6058
    mov       rax,	[rdx]
    movzx     rax,	byte [rax+62]
    cmp       rax,	43
    jnz       L6060
    mov       rax,	[rdx]
    mov       rax,	[rax+24]
    mov       rax,	[rax+16]
    jmp       L6059
L6060:
    mov       rax,	[rdx]
    mov       rax,	[rax+24]
    mov       rax,	[rax+16]
    neg       rax
L6059:
    mov       rdi,	rax
    mov       rax,	[rdx]
    mov       rax,	[rax+16]
    mov       [rdx],	rax
L6058:
L6055:
    mov       rax,	rdi
L6053:
;---------------
    add       rsp,	16
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_switch
mm_blockpcl.do_switch:
;?>>
   %define R.p r12
   %define R.pindex r13
    %define mm_blockpcl.do_switch.pwhenthen 72
    %define mm_blockpcl.do_switch.pelse 80
    %define mm_blockpcl.do_switch.isref 88
   %define R.minlab rdi
   %define R.maxlab rbx
   %define R.n rsi
    %define mm_blockpcl.do_switch.iscomplex -8
    %define mm_blockpcl.do_switch.i -16
    %define mm_blockpcl.do_switch.lab_a -24
    %define mm_blockpcl.do_switch.lab_d -32
    %define mm_blockpcl.do_switch.labjump -40
    %define mm_blockpcl.do_switch.elselab -48
    %define mm_blockpcl.do_switch.labstmt -56
    %define mm_blockpcl.do_switch.ax -64
    %define mm_blockpcl.do_switch.bx -72
    %define mm_blockpcl.do_switch.ismult -80
    %define mm_blockpcl.do_switch.looptype -88
    %define mm_blockpcl.do_switch.opc -96
    %define mm_blockpcl.do_switch.labels -8104
    %define mm_blockpcl.do_switch.w -8112
    %define mm_blockpcl.do_switch.wt -8120
    %define mm_blockpcl.do_switch.pjump -8128
    %define mm_blockpcl.do_switch.psetup -8136
    %define mm_blockpcl.do_switch.djump -8144
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	8184
    mov       r12,	rcx
    mov       r13,	rdx
    mov       [rbp+72],	r8
    mov       [rbp+80],	r9
;---------------
    movzx     rax,	byte [r12]
    cmp       rax,	107
    jz        L6063
    cmp       rax,	108
    jz        L6064
    cmp       rax,	109
    jz        L6065
    jmp       L6066
L6063:
    xor       eax,	eax
    mov       [rbp + mm_blockpcl.do_switch.looptype],	al
    mov       al,	37
    mov       [rbp + mm_blockpcl.do_switch.opc],	al
    jmp       L6062
L6064:
;mm_blockpcl.do_switch.dodosw:
    mov       al,	1
    mov       [rbp + mm_blockpcl.do_switch.looptype],	al
    mov       al,	37
    mov       [rbp + mm_blockpcl.do_switch.opc],	al
    jmp       L6062
L6065:
    mov       al,	2
    mov       [rbp + mm_blockpcl.do_switch.looptype],	al
    mov       al,	38
    mov       [rbp + mm_blockpcl.do_switch.opc],	al
    jmp       L6062
L6066:
    mov       al,	3
    mov       [rbp + mm_blockpcl.do_switch.looptype],	al
L6062:
    movsxd    rax,	dword [r12+49]
    test      rax,	rax
    jz        L6068
    movzx     rax,	byte [rbp + mm_blockpcl.do_switch.looptype]
    test      rax,	rax
    jnz       L6068
    mov       rax,	1
    jmp       L6069
L6068:
    xor       eax,	eax
L6069:
    mov       [rbp + mm_blockpcl.do_switch.ismult],	rax
    mov       rdi,	1000000
    mov       rbx,	-1000000
    xor       rsi,	rsi
    xor       eax,	eax
    mov       [rbp + mm_blockpcl.do_switch.iscomplex],	rax
    mov       rax,	[rbp + mm_blockpcl.do_switch.pwhenthen]
    mov       [rbp + mm_blockpcl.do_switch.wt],	rax
    jmp       L6071
L6070:
    mov       rax,	[rbp + mm_blockpcl.do_switch.wt]
    mov       rax,	[rax+16]
    mov       [rbp + mm_blockpcl.do_switch.w],	rax
    jmp       L6074
L6073:
    mov       rax,	[rbp + mm_blockpcl.do_switch.w]
    movzx     rax,	byte [rax]
    cmp       rax,	21
    jz        L6077
    cmp       rax,	1
    jz        L6078
    jmp       L6079
L6077:
    mov       rax,	[rbp + mm_blockpcl.do_switch.w]
    mov       rax,	[rax+16]
    mov       rax,	[rax+16]
    mov       [rbp + mm_blockpcl.do_switch.ax],	rax
    mov       rax,	[rbp + mm_blockpcl.do_switch.w]
    mov       rax,	[rax+24]
    mov       rax,	[rax+16]
    mov       [rbp + mm_blockpcl.do_switch.bx],	rax
;mm_blockpcl.do_switch.dorange:
L6080:
    mov       rax,	[rbp + mm_blockpcl.do_switch.ax]
    mov       [rbp + mm_blockpcl.do_switch.i],	rax
    mov       rax,	[rbp + mm_blockpcl.do_switch.i]
    cmp       rax,	[rbp + mm_blockpcl.do_switch.bx]
    jg        L6083
L6081:
    mov       rax,	[rbp + mm_blockpcl.do_switch.i]
    mov       r10,	rdi
    cmp       rax,	r10
    cmovg     rax,	r10
    mov       rdi,	rax
    mov       rax,	[rbp + mm_blockpcl.do_switch.i]
    mov       r10,	rbx
    cmp       rax,	r10
    cmovl     rax,	r10
    mov       rbx,	rax
    mov       rax,	[rbp + mm_blockpcl.do_switch.i]
    inc       rax
    mov       [rbp + mm_blockpcl.do_switch.i],	rax
    cmp       rax,	[rbp + mm_blockpcl.do_switch.bx]
    jle       L6081
L6083:
    jmp       L6076
L6078:
    mov       rax,	[rbp + mm_blockpcl.do_switch.w]
    mov       rax,	[rax+16]
    mov       [rbp + mm_blockpcl.do_switch.bx],	rax
    mov       [rbp + mm_blockpcl.do_switch.ax],	rax
    jmp       L6080
L6079:
    mov       rcx,	[rbp + mm_blockpcl.do_switch.w]
    call      mm_lib.strexpr
    mov       rax,	[rax]
    lea       rcx,	[L12867]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_support.gerror_s
L6076:
    mov       rax,	[rbp + mm_blockpcl.do_switch.w]
    mov       rax,	[rax+8]
    mov       [rbp + mm_blockpcl.do_switch.w],	rax
L6074:
    mov       rax,	[rbp + mm_blockpcl.do_switch.w]
    test      rax,	rax
    jnz       L6073
    mov       rax,	[rbp + mm_blockpcl.do_switch.wt]
    mov       rax,	[rax+8]
    mov       [rbp + mm_blockpcl.do_switch.wt],	rax
L6071:
    mov       rax,	[rbp + mm_blockpcl.do_switch.wt]
    test      rax,	rax
    jnz       L6070
    mov       rax,	rbx
    sub       rax,	rdi
    inc       rax
    mov       rsi,	rax
    cmp       rsi,	1000
    jle       L6085
    lea       rcx,	[L12868]
    xor       edx,	edx
    call      mm_support.gerror
L6085:
    mov       al,	[rbp + mm_blockpcl.do_switch.looptype]
    test      al,	al
    jz        L6087
    call      mm_genpcl.definelabel
    mov       [rbp + mm_blockpcl.do_switch.lab_a],	rax
    call      mm_genpcl.createfwdlabel
    mov       [rbp + mm_blockpcl.do_switch.lab_d],	rax
    mov       rcx,	[rbp + mm_blockpcl.do_switch.lab_a]
    mov       rdx,	[rbp + mm_blockpcl.do_switch.lab_a]
    mov       r8,	[rbp + mm_blockpcl.do_switch.lab_d]
    call      mm_genpcl.stacklooplabels
    jmp       L6086
L6087:
    call      mm_genpcl.createfwdlabel
    mov       [rbp + mm_blockpcl.do_switch.lab_d],	rax
L6086:
    call      mm_genpcl.createfwdlabel
    mov       [rbp + mm_blockpcl.do_switch.labjump],	rax
    call      mm_genpcl.createfwdlabel
    mov       [rbp + mm_blockpcl.do_switch.elselab],	rax
    mov       rax,	[rbp + mm_blockpcl.do_switch.ismult]
    test      rax,	rax
    jz        L6089
    mov       rcx,	117
    xor       edx,	edx
    call      pc_api.pc_gen
L6089:
    movzx     rax,	byte [rbp + mm_blockpcl.do_switch.looptype]
    cmp       rax,	3
    jnz       L6091
    mov       rax,	[r13+8]
    mov       [rbp + mm_blockpcl.do_switch.pjump],	rax
    mov       rax,	[rbp + mm_blockpcl.do_switch.pjump]
    movzx     rax,	byte [rax]
    cmp       rax,	4
    jz        L6093
    lea       rcx,	[L12869]
    xor       edx,	edx
    call      mm_support.gerror
L6093:
    mov       rax,	[rbp + mm_blockpcl.do_switch.pjump]
    mov       rax,	[rax+16]
    mov       [rbp + mm_blockpcl.do_switch.djump],	rax
    mov       rax,	[rbp + mm_blockpcl.do_switch.djump]
    movsxd    rax,	dword [rax+72]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    cmp       r10,	7
    jz        L6095
    lea       rcx,	[L12870]
    xor       edx,	edx
    call      mm_support.gerror
L6095:
    mov       rcx,	[rbp + mm_blockpcl.do_switch.labjump]
    call      pc_api.genlabel
    mov       rcx,	1
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	4
    call      mm_libpcl.setmode
    mov       rax,	[pc_api.pccurr]
    mov       [rbp + mm_blockpcl.do_switch.psetup],	rax
    mov       rcx,	[rbp + mm_blockpcl.do_switch.pjump]
    call      mm_genpcl.genmem_u
    mov       rcx,	4
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	4
    call      mm_libpcl.setmode
    mov       rax,	[mm_genpcl.pcldoswx]
    test      rax,	rax
    jnz       L6097
    lea       rcx,	[L12871]
    xor       edx,	edx
    call      mm_support.gerror
L6097:
    mov       rax,	[rbp + mm_blockpcl.do_switch.psetup]
    mov       r10,	[mm_genpcl.pcldoswx]
    mov       r11,	[rax]
    mov       [r10],	r11
    mov       r11,	[rax+8]
    mov       [r10+8],	r11
    mov       r11,	[rax+16]
    mov       [r10+16],	r11
    mov       r11,	[rax+24]
    mov       [r10+24],	r11
    mov       rax,	[rbp + mm_blockpcl.do_switch.psetup]
    lea       rax,	[rax+32]
    mov       r10,	[mm_genpcl.pcldoswx]
    lea       r10,	[r10+32]
    mov       r11,	[rax]
    mov       [r10],	r11
    mov       r11,	[rax+8]
    mov       [r10+8],	r11
    mov       r11,	[rax+16]
    mov       [r10+16],	r11
    mov       r11,	[rax+24]
    mov       [r10+24],	r11
    sub       qword [pc_api.pccurr],	64
L6091:
    mov       rcx,	r13
    call      mm_blockpcl.evalunit
    movzx     rax,	byte [rbp + mm_blockpcl.do_switch.looptype]
    cmp       rax,	3
    jz        L6099
    mov       rcx,	[rbp + mm_blockpcl.do_switch.labjump]
    call      pc_api.genlabel
    movzx     r10,	byte [rbp + mm_blockpcl.do_switch.opc]
    mov       rcx,	r10
    mov       rdx,	rdi
    mov       r8,	rbx
    mov       r9,	rax
    call      pc_api.pc_genxy
    mov       rcx,	3
    call      mm_libpcl.setmode
    movzx     rax,	byte [rbp + mm_blockpcl.do_switch.looptype]
    cmp       rax,	2
    jge       L6101
    mov       rcx,	[rbp + mm_blockpcl.do_switch.elselab]
    call      pc_api.genlabel
    mov       rcx,	12
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	3
    call      mm_libpcl.setmode
L6101:
    jmp       L6098
L6099:
    lea       rcx,	[L12872]
    call      pc_api.gencomment
    mov       rcx,	25
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	4
    call      mm_libpcl.setmode
L6098:
    mov       rcx,	[rbp + mm_blockpcl.do_switch.labjump]
    call      mm_genpcl.definefwdlabel
    mov       [rbp + mm_blockpcl.do_switch.i],	rdi
    mov       rax,	[rbp + mm_blockpcl.do_switch.i]
    cmp       rax,	rbx
    jg        L6104
L6102:
    mov       rcx,	[rbp + mm_blockpcl.do_switch.elselab]
    call      pc_api.genlabel
    mov       rcx,	39
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rax,	[pc_api.pccurr]
    mov       r10,	[rbp + mm_blockpcl.do_switch.i]
    mov       [rbp + r10*8 + mm_blockpcl.do_switch.labels],	rax
    mov       rax,	[rbp + mm_blockpcl.do_switch.i]
    inc       rax
    mov       [rbp + mm_blockpcl.do_switch.i],	rax
    cmp       rax,	rbx
    jle       L6102
L6104:
    mov       rcx,	40
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rax,	[rbp + mm_blockpcl.do_switch.pwhenthen]
    mov       [rbp + mm_blockpcl.do_switch.wt],	rax
    jmp       L6106
L6105:
    call      mm_genpcl.definelabel
    mov       [rbp + mm_blockpcl.do_switch.labstmt],	rax
    mov       rax,	[rbp + mm_blockpcl.do_switch.wt]
    mov       rax,	[rax+16]
    mov       [rbp + mm_blockpcl.do_switch.w],	rax
    jmp       L6109
L6108:
    mov       rax,	[rbp + mm_blockpcl.do_switch.w]
    movzx     rax,	byte [rax]
    cmp       rax,	21
    jz        L6112
    cmp       rax,	1
    jz        L6113
    jmp       L6114
L6112:
    mov       rax,	[rbp + mm_blockpcl.do_switch.w]
    mov       rax,	[rax+16]
    mov       rax,	[rax+16]
    mov       [rbp + mm_blockpcl.do_switch.ax],	rax
    mov       rax,	[rbp + mm_blockpcl.do_switch.w]
    mov       rax,	[rax+24]
    mov       rax,	[rax+16]
    mov       [rbp + mm_blockpcl.do_switch.bx],	rax
    jmp       L6111
L6113:
    mov       rax,	[rbp + mm_blockpcl.do_switch.w]
    mov       rax,	[rax+16]
    mov       [rbp + mm_blockpcl.do_switch.bx],	rax
    mov       [rbp + mm_blockpcl.do_switch.ax],	rax
L6114:
L6111:
    mov       rax,	[rbp + mm_blockpcl.do_switch.ax]
    mov       [rbp + mm_blockpcl.do_switch.i],	rax
    mov       rax,	[rbp + mm_blockpcl.do_switch.i]
    cmp       rax,	[rbp + mm_blockpcl.do_switch.bx]
    jg        L6117
L6115:
    mov       rax,	[rbp + mm_blockpcl.do_switch.i]
    mov       rax,	[rbp + rax*8 + mm_blockpcl.do_switch.labels]
    mov       r10,	[rbp + mm_blockpcl.do_switch.labstmt]
    mov       [rax+8],	r10
    mov       rax,	[rbp + mm_blockpcl.do_switch.i]
    inc       rax
    mov       [rbp + mm_blockpcl.do_switch.i],	rax
    cmp       rax,	[rbp + mm_blockpcl.do_switch.bx]
    jle       L6115
L6117:
    mov       rax,	[rbp + mm_blockpcl.do_switch.w]
    mov       rax,	[rax+8]
    mov       [rbp + mm_blockpcl.do_switch.w],	rax
L6109:
    mov       rax,	[rbp + mm_blockpcl.do_switch.w]
    test      rax,	rax
    jnz       L6108
    mov       rax,	[rbp + mm_blockpcl.do_switch.isref]
    test      rax,	rax
    jz        L6119
    mov       rax,	[rbp + mm_blockpcl.do_switch.wt]
    mov       rax,	[rax+24]
    mov       rcx,	rax
    xor       edx,	edx
    call      mm_blockpcl.evalref
    jmp       L6118
L6119:
    mov       rax,	[rbp + mm_blockpcl.do_switch.wt]
    mov       rcx,	[rax+24]
    call      mm_blockpcl.evalunit
L6118:
    mov       rax,	[rbp + mm_blockpcl.do_switch.ismult]
    test      rax,	rax
    jz        L6121
    mov       rcx,	118
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	r12
    call      mm_libpcl.setmode_u
L6121:
    movzx     rax,	byte [rbp + mm_blockpcl.do_switch.looptype]
    test      rax,	rax
    jz        L6123
    cmp       rax,	1
    jz        L6124
    cmp       rax,	2
    jz        L6125
    jmp       L6126
L6123:
    mov       rcx,	[rbp + mm_blockpcl.do_switch.lab_d]
    call      mm_blockpcl.genjumpl
    jmp       L6122
L6124:
    mov       rcx,	[rbp + mm_blockpcl.do_switch.lab_a]
    call      mm_blockpcl.genjumpl
    jmp       L6122
L6125:
    mov       rcx,	r13
    call      mm_blockpcl.evalunit
    mov       rcx,	[rbp + mm_blockpcl.do_switch.labjump]
    call      pc_api.genlabel
    movzx     r10,	byte [rbp + mm_blockpcl.do_switch.opc]
    mov       rcx,	r10
    mov       rdx,	rdi
    mov       r8,	rbx
    mov       r9,	rax
    call      pc_api.pc_genxy
    mov       rcx,	3
    call      mm_libpcl.setmode
    jmp       L6122
L6126:
    mov       rcx,	r13
    call      mm_blockpcl.evalunit
    lea       rcx,	[L12873]
    call      pc_api.gencomment
    mov       rcx,	25
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	4
    call      mm_libpcl.setmode
L6122:
    mov       rax,	[rbp + mm_blockpcl.do_switch.wt]
    mov       rax,	[rax+8]
    mov       [rbp + mm_blockpcl.do_switch.wt],	rax
L6106:
    mov       rax,	[rbp + mm_blockpcl.do_switch.wt]
    test      rax,	rax
    jnz       L6105
    mov       rcx,	[rbp + mm_blockpcl.do_switch.elselab]
    call      mm_genpcl.definefwdlabel
    mov       rax,	[rbp + mm_blockpcl.do_switch.pelse]
    test      rax,	rax
    jz        L6128
    mov       rax,	[rbp + mm_blockpcl.do_switch.isref]
    test      rax,	rax
    jz        L6130
    mov       rcx,	[rbp + mm_blockpcl.do_switch.pelse]
    xor       edx,	edx
    call      mm_blockpcl.evalref
    jmp       L6129
L6130:
    mov       rcx,	[rbp + mm_blockpcl.do_switch.pelse]
    call      mm_blockpcl.evalunit
L6129:
    mov       rax,	[rbp + mm_blockpcl.do_switch.ismult]
    test      rax,	rax
    jz        L6132
    mov       rcx,	119
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	r12
    call      mm_libpcl.setmode_u
L6132:
L6128:
    mov       al,	[rbp + mm_blockpcl.do_switch.looptype]
    test      al,	al
    jz        L6134
    movzx     rax,	byte [rbp + mm_blockpcl.do_switch.looptype]
    cmp       rax,	1
    jz        L6136
    cmp       rax,	2
    jz        L6137
    jmp       L6138
L6136:
    mov       rcx,	[rbp + mm_blockpcl.do_switch.lab_a]
    call      mm_blockpcl.genjumpl
    jmp       L6135
L6137:
    mov       rcx,	r13
    call      mm_blockpcl.evalunit
    mov       rcx,	[rbp + mm_blockpcl.do_switch.labjump]
    call      pc_api.genlabel
    movzx     r10,	byte [rbp + mm_blockpcl.do_switch.opc]
    mov       rcx,	r10
    mov       rdx,	rdi
    mov       r8,	rbx
    mov       r9,	rax
    call      pc_api.pc_genxy
    mov       rcx,	3
    call      mm_libpcl.setmode
    jmp       L6135
L6138:
    mov       rcx,	r13
    call      mm_blockpcl.evalunit
    lea       rcx,	[L12874]
    call      pc_api.gencomment
    mov       rcx,	25
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	4
    call      mm_libpcl.setmode
L6135:
    dec       qword [mm_genpcl.loopindex]
L6134:
    mov       rcx,	[rbp + mm_blockpcl.do_switch.lab_d]
    call      mm_genpcl.definefwdlabel
;---------------
    add       rsp,	8184
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_select
mm_blockpcl.do_select:
;?>>
   %define R.p r13
   %define R.a r14
    %define mm_blockpcl.do_select.b 80
    %define mm_blockpcl.do_select.c 88
    %define mm_blockpcl.do_select.isref 96
    %define mm_blockpcl.do_select.labels -2048
   %define R.labend rdi
   %define R.labjump rbx
   %define R.n rsi
   %define R.i r12
    %define mm_blockpcl.do_select.elselab -2056
    %define mm_blockpcl.do_select.labstmt -2064
    %define mm_blockpcl.do_select.ismult -2072
    %define mm_blockpcl.do_select.q -2080
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	2112
    mov       r13,	rcx
    mov       r14,	rdx
    mov       [rbp+80],	r8
    mov       [rbp+88],	r9
;---------------
    movsxd    rax,	dword [r13+49]
    test      rax,	rax
    jz        L6140
    mov       al,	[r13+61]
    test      al,	al
    jz        L6140
    mov       rax,	1
    jmp       L6141
L6140:
    xor       eax,	eax
L6141:
    mov       [rbp + mm_blockpcl.do_select.ismult],	rax
    mov       rax,	[rbp + mm_blockpcl.do_select.b]
    mov       [rbp + mm_blockpcl.do_select.q],	rax
    xor       rsi,	rsi
    jmp       L6143
L6142:
    cmp       rsi,	256
    jl        L6146
    lea       rcx,	[L12875]
    xor       edx,	edx
    call      mm_support.gerror
L6146:
    inc       rsi
    mov       rax,	[rbp + mm_blockpcl.do_select.q]
    mov       rax,	[rax+8]
    mov       [rbp + mm_blockpcl.do_select.q],	rax
L6143:
    mov       rax,	[rbp + mm_blockpcl.do_select.q]
    test      rax,	rax
    jnz       L6142
    call      mm_genpcl.createfwdlabel
    mov       rdi,	rax
    call      mm_genpcl.createfwdlabel
    mov       rbx,	rax
    call      mm_genpcl.createfwdlabel
    mov       [rbp + mm_blockpcl.do_select.elselab],	rax
    mov       rax,	[rbp + mm_blockpcl.do_select.ismult]
    test      rax,	rax
    jz        L6148
    mov       rcx,	117
    xor       edx,	edx
    call      pc_api.pc_gen
L6148:
    mov       rcx,	r14
    call      mm_blockpcl.evalunit
    mov       rcx,	rbx
    call      pc_api.genlabel
    mov       rcx,	37
    mov       rdx,	1
    mov       r8,	rsi
    mov       r9,	rax
    call      pc_api.pc_genxy
    mov       rcx,	3
    call      mm_libpcl.setmode
    mov       rcx,	[rbp + mm_blockpcl.do_select.elselab]
    call      pc_api.genlabel
    mov       rcx,	12
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	3
    call      mm_libpcl.setmode
    mov       rcx,	rbx
    call      mm_genpcl.definefwdlabel
    mov       rax,	[rbp + mm_blockpcl.do_select.b]
    mov       [rbp + mm_blockpcl.do_select.q],	rax
    xor       r12,	r12
    mov       rax,	1
    mov       r12,	rax
    cmp       rsi,	1
    jl        L6151
L6149:
    mov       rcx,	[rbp + mm_blockpcl.do_select.elselab]
    call      pc_api.genlabel
    mov       rcx,	39
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rax,	[pc_api.pccurr]
    mov       [rbp + r12*8 + mm_blockpcl.do_select.labels-8],	rax
    inc       r12
    cmp       r12,	rsi
    jle       L6149
L6151:
    mov       rcx,	40
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rax,	[rbp + mm_blockpcl.do_select.b]
    mov       [rbp + mm_blockpcl.do_select.q],	rax
    xor       r12,	r12
    jmp       L6153
L6152:
    call      mm_genpcl.definelabel
    mov       [rbp + mm_blockpcl.do_select.labstmt],	rax
    inc       r12
    mov       rax,	[rbp + r12*8 + mm_blockpcl.do_select.labels-8]
    mov       r10,	[rbp + mm_blockpcl.do_select.labstmt]
    mov       [rax+8],	r10
    mov       rax,	[rbp + mm_blockpcl.do_select.isref]
    test      rax,	rax
    jz        L6156
    mov       rcx,	[rbp + mm_blockpcl.do_select.q]
    xor       edx,	edx
    call      mm_blockpcl.evalref
    jmp       L6155
L6156:
    mov       rcx,	[rbp + mm_blockpcl.do_select.q]
    call      mm_blockpcl.evalunit
L6155:
    mov       rax,	[rbp + mm_blockpcl.do_select.ismult]
    test      rax,	rax
    jz        L6158
    mov       rcx,	118
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	r13
    call      mm_libpcl.setmode_u
L6158:
    mov       rcx,	rdi
    call      mm_blockpcl.genjumpl
    mov       rax,	[rbp + mm_blockpcl.do_select.q]
    mov       rax,	[rax+8]
    mov       [rbp + mm_blockpcl.do_select.q],	rax
L6153:
    mov       rax,	[rbp + mm_blockpcl.do_select.q]
    test      rax,	rax
    jnz       L6152
    mov       rcx,	[rbp + mm_blockpcl.do_select.elselab]
    call      mm_genpcl.definefwdlabel
    mov       rax,	[rbp + mm_blockpcl.do_select.isref]
    test      rax,	rax
    jz        L6160
    mov       rcx,	[rbp + mm_blockpcl.do_select.c]
    xor       edx,	edx
    call      mm_blockpcl.evalref
    jmp       L6159
L6160:
    mov       rcx,	[rbp + mm_blockpcl.do_select.c]
    call      mm_blockpcl.evalunit
L6159:
    mov       rax,	[rbp + mm_blockpcl.do_select.ismult]
    test      rax,	rax
    jz        L6162
    mov       rcx,	119
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	r13
    call      mm_libpcl.setmode_u
L6162:
    mov       rcx,	rdi
    call      mm_genpcl.definefwdlabel
;---------------
    add       rsp,	2112
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_case
mm_blockpcl.do_case:
;?>>
   %define R.p r13
   %define R.pindex r14
    %define mm_blockpcl.do_case.pwhenthen 80
    %define mm_blockpcl.do_case.pelse 88
    %define mm_blockpcl.do_case.loopsw 96
    %define mm_blockpcl.do_case.isref 104
    %define mm_blockpcl.do_case.labtable -4000
    %define mm_blockpcl.do_case.unittable -8000
   %define R.ncases rdi
   %define R.ismult rbx
   %define R.lab_abc rsi
   %define R.lab_d r12
    %define mm_blockpcl.do_case.labelse -8008
    %define mm_blockpcl.do_case.w -8016
    %define mm_blockpcl.do_case.wt -8024
    %define mm_blockpcl.do_case.i -8032
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	8064
    mov       r13,	rcx
    mov       r14,	rdx
    mov       [rbp+80],	r8
    mov       [rbp+88],	r9
;---------------
    movzx     rax,	byte [r13]
    cmp       rax,	106
    setz      al
    movzx     eax,	al
    mov       [rbp + mm_blockpcl.do_case.loopsw],	rax
    test      r14,	r14
    jnz       L6165
    lea       rcx,	[L12876]
    xor       edx,	edx
    call      mm_support.gerror
L6165:
    movsxd    rax,	dword [r13+49]
    test      rax,	rax
    jz        L6166
    mov       rax,	[rbp + mm_blockpcl.do_case.loopsw]
    test      rax,	rax
    jnz       L6166
    mov       rax,	1
    jmp       L6167
L6166:
    xor       eax,	eax
L6167:
    mov       rbx,	rax
    mov       rax,	[rbp + mm_blockpcl.do_case.loopsw]
    test      rax,	rax
    jz        L6169
    call      mm_genpcl.definelabel
    mov       rsi,	rax
    call      mm_genpcl.createfwdlabel
    mov       r12,	rax
    mov       rcx,	rsi
    mov       rdx,	rsi
    mov       r8,	r12
    call      mm_genpcl.stacklooplabels
    jmp       L6168
L6169:
    call      mm_genpcl.createfwdlabel
    mov       r12,	rax
L6168:
    test      rbx,	rbx
    jz        L6171
    mov       rcx,	117
    xor       edx,	edx
    call      pc_api.pc_gen
L6171:
    xor       rdi,	rdi
    mov       rax,	[mm_blockpcl.casedepth]
    cmp       rax,	20
    jl        L6173
    lea       rcx,	[L12877]
    xor       edx,	edx
    call      mm_support.gerror
L6173:
    inc       qword [mm_blockpcl.casedepth]
    mov       rax,	[mm_blockpcl.casedepth]
    mov       r10,	r13
    lea       r11,	[mm_blockpcl.casestmt]
    mov       [r11 + rax*8-8],	r10
    mov       rax,	[rbp + mm_blockpcl.do_case.pwhenthen]
    test      rax,	rax
    jnz       L6175
    test      rbx,	rbx
    jz        L6177
    lea       rcx,	[L12878]
    xor       edx,	edx
    call      mm_support.gerror
L6177:
    jmp       L6178
L6175:
    mov       rcx,	r14
    call      mm_blockpcl.evalunit
    mov       rax,	[rbp + mm_blockpcl.do_case.pwhenthen]
    mov       [rbp + mm_blockpcl.do_case.wt],	rax
    jmp       L6180
L6179:
    mov       rax,	[rbp + mm_blockpcl.do_case.wt]
    mov       rax,	[rax+16]
    mov       [rbp + mm_blockpcl.do_case.w],	rax
    cmp       rdi,	500
    jl        L6183
    lea       rcx,	[L12879]
    xor       edx,	edx
    call      mm_support.gerror
L6183:
    call      mm_genpcl.createfwdlabel
    inc       rdi
    mov       r10,	rdi
    mov       [rbp + r10*8 + mm_blockpcl.do_case.labtable-8],	rax
    mov       rax,	[rbp + mm_blockpcl.do_case.wt]
    mov       rax,	[rax+24]
    mov       [rbp + rdi*8 + mm_blockpcl.do_case.unittable-8],	rax
    jmp       L6185
L6184:
    mov       rcx,	[rbp + mm_blockpcl.do_case.w]
    call      mm_blockpcl.evalunit
    mov       rax,	[rbp + rdi*8 + mm_blockpcl.do_case.labtable-8]
    mov       r10,	rax
    mov       r11,	[rbp + mm_blockpcl.do_case.w]
    mov       [r11+40],	r10d
    mov       rcx,	rax
    call      pc_api.genlabel
    mov       rcx,	26
    mov       rdx,	1
    mov       r8,	rax
    call      pc_api.pc_gencond
    mov       rax,	[rbp + mm_blockpcl.do_case.w]
    mov       rax,	[rax+8]
    test      rax,	rax
    jnz       L6189
    mov       rax,	[rbp + mm_blockpcl.do_case.wt]
    mov       rax,	[rax+8]
    test      rax,	rax
    jz        L6188
L6189:
    mov       eax,	1
    mov       r10,	[pc_api.pccurr]
    mov       [r10+16],	eax
L6188:
    mov       rcx,	[rbp + mm_blockpcl.do_case.w]
    call      mm_libpcl.setmode_u
    mov       rax,	[rbp + mm_blockpcl.do_case.w]
    mov       rax,	[rax+8]
    mov       [rbp + mm_blockpcl.do_case.w],	rax
L6185:
    mov       rax,	[rbp + mm_blockpcl.do_case.w]
    test      rax,	rax
    jnz       L6184
    mov       rax,	[rbp + mm_blockpcl.do_case.wt]
    mov       rax,	[rax+8]
    mov       [rbp + mm_blockpcl.do_case.wt],	rax
L6180:
    mov       rax,	[rbp + mm_blockpcl.do_case.wt]
    test      rax,	rax
    jnz       L6179
;mm_blockpcl.do_case.skip:
L6178:
    call      mm_genpcl.createfwdlabel
    mov       [rbp + mm_blockpcl.do_case.labelse],	rax
    mov       rax,	[rbp + mm_blockpcl.do_case.labelse]
    lea       r10,	[mm_blockpcl.caseelse]
    mov       r11,	[mm_blockpcl.casedepth]
    mov       [r10 + r11*8-8],	rax
    mov       rcx,	[rbp + mm_blockpcl.do_case.labelse]
    call      mm_blockpcl.genjumpl
    mov       rax,	1
    mov       [rbp + mm_blockpcl.do_case.i],	rax
    cmp       rdi,	1
    jl        L6192
L6190:
    mov       rax,	[rbp + mm_blockpcl.do_case.i]
    mov       rcx,	[rbp + rax*8 + mm_blockpcl.do_case.labtable-8]
    call      mm_genpcl.definefwdlabel
    mov       rax,	[rbp + mm_blockpcl.do_case.isref]
    test      rax,	rax
    jz        L6194
    mov       rax,	[rbp + mm_blockpcl.do_case.i]
    mov       rax,	[rbp + rax*8 + mm_blockpcl.do_case.unittable-8]
    mov       rcx,	rax
    xor       edx,	edx
    call      mm_blockpcl.evalref
    jmp       L6193
L6194:
    mov       rax,	[rbp + mm_blockpcl.do_case.i]
    mov       rcx,	[rbp + rax*8 + mm_blockpcl.do_case.unittable-8]
    call      mm_blockpcl.evalunit
L6193:
    test      rbx,	rbx
    jz        L6196
    mov       rcx,	118
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	r13
    call      mm_libpcl.setmode_u
L6196:
    mov       rax,	[rbp + mm_blockpcl.do_case.loopsw]
    test      rax,	rax
    jz        L6198
    mov       rcx,	rsi
    call      mm_blockpcl.genjumpl
    jmp       L6197
L6198:
    mov       rcx,	r12
    call      mm_blockpcl.genjumpl
L6197:
    mov       rax,	[rbp + mm_blockpcl.do_case.i]
    inc       rax
    mov       [rbp + mm_blockpcl.do_case.i],	rax
    cmp       rax,	rdi
    jle       L6190
L6192:
    mov       rcx,	[rbp + mm_blockpcl.do_case.labelse]
    call      mm_genpcl.definefwdlabel
    mov       rax,	[rbp + mm_blockpcl.do_case.pelse]
    test      rax,	rax
    jz        L6200
    mov       rax,	[rbp + mm_blockpcl.do_case.isref]
    test      rax,	rax
    jz        L6202
    mov       rcx,	[rbp + mm_blockpcl.do_case.pelse]
    xor       edx,	edx
    call      mm_blockpcl.evalref
    jmp       L6201
L6202:
    mov       rcx,	[rbp + mm_blockpcl.do_case.pelse]
    call      mm_blockpcl.evalunit
L6201:
    test      rbx,	rbx
    jz        L6204
    mov       rcx,	119
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	r13
    call      mm_libpcl.setmode_u
L6204:
L6200:
    mov       rax,	[rbp + mm_blockpcl.do_case.loopsw]
    test      rax,	rax
    jz        L6206
    mov       rcx,	rsi
    call      mm_blockpcl.genjumpl
    mov       rcx,	r12
    call      mm_genpcl.definefwdlabel
    dec       qword [mm_genpcl.loopindex]
    jmp       L6205
L6206:
    mov       rcx,	r12
    call      mm_genpcl.definefwdlabel
L6205:
    dec       qword [mm_blockpcl.casedepth]
;---------------
    add       rsp,	8064
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_dotindex
mm_blockpcl.do_dotindex:
;?>>
    %define mm_blockpcl.do_dotindex.p 32
   %define R.a rdi
   %define R.b rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rdx
    mov       rbx,	r8
;---------------
    mov       rcx,	rdi
    call      mm_blockpcl.evalunit
    mov       rcx,	rbx
    call      mm_blockpcl.evalunit
    mov       rcx,	14
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	3
    call      mm_libpcl.setmode
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_dotslice
mm_blockpcl.do_dotslice:
;?>>
    %define mm_blockpcl.do_dotslice.p 32
   %define R.a rdi
   %define R.b rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rdx
    mov       rbx,	r8
;---------------
    mov       rcx,	rdi
    call      mm_blockpcl.evalunit
    mov       rcx,	[rbx+16]
    call      mm_blockpcl.evalunit
    mov       rcx,	[rbx+24]
    call      mm_blockpcl.evalunit
    mov       rcx,	15
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	3
    call      mm_libpcl.setmode
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_read
mm_blockpcl.do_read:
;?>>
   %define R.p rbx
   %define R.a rsi
   %define R.m rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    movsxd    rax,	dword [rbx+49]
    mov       rdi,	rax
    test      rsi,	rsi
    jnz       L6211
    mov       rsi,	[mm_genpcl.pzero]
L6211:
    lea       rax,	[mm_decls.ttisinteger]
    mov       r10,	rdi
    mov       al,	[rax + r10]
    test      al,	al
    jz        L6213
    mov       rcx,	23
    mov       rdx,	rsi
    xor       r8d,	r8d
    xor       r9d,	r9d
    call      mm_genpcl.genpc_sysfn
    jmp       L6212
L6213:
    lea       rax,	[mm_decls.ttisreal]
    mov       r10,	rdi
    mov       al,	[rax + r10]
    test      al,	al
    jz        L6214
    lea       rax,	[mm_decls.ttsize]
    mov       r10,	rdi
    mov       eax,	[rax + r10*4]
    cmp       rax,	8
    jnz       L6214
    mov       rcx,	24
    mov       rdx,	rsi
    xor       r8d,	r8d
    xor       r9d,	r9d
    call      mm_genpcl.genpc_sysfn
    jmp       L6212
L6214:
    cmp       rdi,	20
    jnz       L6215
    mov       rcx,	25
    mov       rdx,	rsi
    xor       r8d,	r8d
    xor       r9d,	r9d
    call      mm_genpcl.genpc_sysfn
    jmp       L6212
L6215:
    call      msys.m$print_startcon
    lea       rcx,	[L12880]
    call      msys.m$print_str_nf
    mov       rcx,	rdi
    mov       rdx,	1
    call      mm_lib.strmode
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L12881]
    xor       edx,	edx
    call      mm_support.gerror
L6212:
    mov       rcx,	rbx
    call      mm_libpcl.setmode_u
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_readln
mm_blockpcl.do_readln:
;?>>
   %define R.a rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    test      rdi,	rdi
    jz        L6218
    movsxd    rax,	dword [rdi+49]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    cmp       r10,	7
    jz        L6220
    lea       rcx,	[L12882]
    xor       edx,	edx
    call      mm_support.gerror
L6220:
    movsxd    rax,	dword [rdi+49]
    lea       r10,	[mm_decls.tttarget]
    movsxd    r10,	dword [r10 + rax*4]
    lea       rax,	[mm_decls.ttbasetype]
    movsxd    rax,	dword [rax + r10*4]
    test      rax,	rax
    jz        L6222
    cmp       rax,	17
    jz        L6223
    cmp       rax,	12
    jz        L6223
    jmp       L6224
L6222:
    sub       rsp,	8
    push      0
    mov       rcx,	26
    mov       rdx,	rdi
    xor       r8d,	r8d
    xor       r9d,	r9d
    sub       rsp,	32
    call      mm_genpcl.genpc_sysproc
    add       rsp,	48
    jmp       L6221
L6223:
    sub       rsp,	8
    push      0
    mov       rcx,	27
    mov       rdx,	rdi
    xor       r8d,	r8d
    xor       r9d,	r9d
    sub       rsp,	32
    call      mm_genpcl.genpc_sysproc
    add       rsp,	48
    jmp       L6221
L6224:
    lea       rcx,	[L12883]
    xor       edx,	edx
    call      mm_support.gerror
L6221:
    jmp       L6217
L6218:
    sub       rsp,	8
    push      0
    mov       rcx,	28
    xor       edx,	edx
    xor       r8d,	r8d
    xor       r9d,	r9d
    sub       rsp,	32
    call      mm_genpcl.genpc_sysproc
    add       rsp,	48
L6217:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.docond
mm_blockpcl.docond:
;?>>
   %define R.opc rdi
   %define R.p rbx
   %define R.lab rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mm_blockpcl.genjumpcond
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_syscall
mm_blockpcl.do_syscall:
;?>>
   %define R.p rdi
   %define R.a rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    call      mm_genpcl.setfunctab
    movsx     rax,	word [rdi+40]
    cmp       rax,	29
    jz        L6228
    cmp       rax,	30
    jz        L6229
    cmp       rax,	31
    jz        L6230
    jmp       L6231
L6228:
    mov       rcx,	[mm_blockpcl.pnprocs]
    call      pc_api.genmem
    mov       rcx,	1
    mov       rdx,	rax
    call      pc_api.pc_gen
    jmp       L6227
L6229:
    mov       rcx,	[mm_blockpcl.pprocname]
    call      pc_api.genmemaddr
    mov       rcx,	1
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	4
    call      mm_libpcl.setmode
    mov       rcx,	rbx
    call      mm_blockpcl.evalunit
    mov       rcx,	3
    mov       rdx,	8
    mov       r8,	-8
    call      pc_api.pc_genix
    jmp       L6227
L6230:
    mov       rcx,	[mm_blockpcl.pprocaddr]
    call      pc_api.genmemaddr
    mov       rcx,	1
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	4
    call      mm_libpcl.setmode
    mov       rcx,	rbx
    call      mm_blockpcl.evalunit
    mov       rcx,	3
    mov       rdx,	8
    mov       r8,	-8
    call      pc_api.pc_genix
    jmp       L6227
L6231:
    lea       rcx,	[L12884]
    call      pc_api.gencomment
L6227:
    mov       rcx,	3
    call      mm_libpcl.setmode
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_slice
mm_blockpcl.do_slice:
;?>>
    %define mm_blockpcl.do_slice.p 32
   %define R.a rdi
   %define R.b rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rdx
    mov       rbx,	r8
;---------------
    test      rbx,	rbx
    jnz       L6234
    mov       rcx,	rdi
    call      mm_blockpcl.evalarray
    movzx     rax,	byte [rdi]
    cmp       rax,	1
    jnz       L6236
    mov       rax,	[rdi+16]
    mov       rcx,	rax
    call      strlen
    mov       rcx,	rax
    call      mm_genpcl.genpushint
    jmp       L6235
L6236:
    movsxd    rax,	dword [rdi+49]
    lea       r10,	[mm_decls.ttlength]
    movsxd    r10,	dword [r10 + rax*4]
    mov       rcx,	r10
    call      mm_genpcl.genpushint
L6235:
    jmp       L6233
L6234:
    mov       rax,	[rbx+16]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mm_blockpcl.do_indexref
    mov       rax,	[rbx+16]
    movzx     rax,	byte [rax]
    mov       r10,	[rbx+24]
    movzx     r10,	byte [r10]
    cmp       r10,	rax
    jnz       L6238
    cmp       r10,	1
    jnz       L6238
    mov       rax,	[rbx+24]
    mov       rax,	[rax+16]
    mov       r10,	[rbx+16]
    mov       r10,	[r10+16]
    sub       rax,	r10
    inc       rax
    mov       rcx,	rax
    call      mm_genpcl.genpushint
    jmp       L6237
L6238:
    mov       rcx,	[rbx+24]
    call      mm_blockpcl.evalunit
    mov       rcx,	[rbx+16]
    call      mm_blockpcl.evalunit
    mov       rcx,	44
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	3
    call      mm_libpcl.setmode
    mov       rcx,	1
    call      mm_genpcl.genpushint
    mov       rcx,	43
    xor       edx,	edx
    call      pc_api.pc_gen
L6237:
    mov       rcx,	3
    call      mm_libpcl.setmode
L6233:
    mov       rcx,	7
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	11
    call      mm_libpcl.setmode
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_assignblock
mm_blockpcl.do_assignblock:
;?>>
    %define mm_blockpcl.do_assignblock.p 32
   %define R.a rdi
   %define R.b rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rdx
    mov       rbx,	r8
;---------------
    movzx     rax,	byte [rbx]
    cmp       rax,	20
    jnz       L6241
    movsxd    rax,	dword [rdi+49]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    cmp       r10,	10
    jnz       L6243
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mm_blockpcl.do_assignarray
    jmp       L6242
L6243:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mm_blockpcl.do_assignrecord
L6242:
    jmp       L6240
L6241:
    lea       rcx,	[L12885]
    xor       edx,	edx
    call      mm_support.gerror
L6240:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_assignarray
mm_blockpcl.do_assignarray:
;?>>
   %define R.a r14
   %define R.b r15
   %define R.passign rdi
   %define R.pindex rbx
   %define R.pconst rsi
   %define R.q r12
   %define R.index r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    sub       rsp,	48
    mov       r14,	rcx
    mov       r15,	rdx
;---------------
    movsxd    rax,	dword [r14+49]
    lea       r10,	[mm_decls.tttarget]
    movsxd    r10,	dword [r10 + rax*4]
    lea       rax,	[mm_decls.ttbasetype]
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	12
    jnz       L6246
    lea       rcx,	[L12886]
    xor       edx,	edx
    call      mm_support.gerror
L6246:
    mov       rcx,	1
    mov       rdx,	3
    call      mm_lib.createconstunit
    mov       rsi,	rax
    mov       rcx,	46
    mov       rdx,	r14
    mov       r8,	rsi
    call      mm_lib.createunit2
    mov       rbx,	rax
    mov       rax,	[r15+16]
    mov       rcx,	28
    mov       rdx,	rbx
    mov       r8,	rax
    call      mm_lib.createunit2
    mov       rdi,	rax
    movsxd    rax,	dword [r14+49]
    lea       r10,	[mm_decls.tttarget]
    movsxd    r10,	dword [r10 + rax*4]
    mov       [rbx+49],	r10d
    mov       [rdi+49],	r10d
    movsxd    rax,	dword [r14+49]
    lea       r10,	[mm_decls.ttlower]
    movsxd    r10,	dword [r10 + rax*4]
    mov       r13,	r10
    mov       r12,	[r15+16]
    jmp       L6248
L6247:
    mov       [rsi+16],	r13
    mov       al,	1
    mov       [rsi+61],	al
    mov       [rdi+24],	r12
    mov       rcx,	rdi
    call      mm_blockpcl.evalunit
    inc       r13
    mov       r12,	[r12+8]
L6248:
    test      r12,	r12
    jnz       L6247
;---------------
    add       rsp,	48
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_assignrecord
mm_blockpcl.do_assignrecord:
;?>>
    %define mm_blockpcl.do_assignrecord.a 72
    %define mm_blockpcl.do_assignrecord.b 80
   %define R.passign rdi
   %define R.pdot rbx
   %define R.pfield rsi
   %define R.q r12
   %define R.m r13
   %define R.fieldtype r14
   %define R.d r15
    %define mm_blockpcl.do_assignrecord.e -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       [rbp+72],	rcx
    mov       [rbp+80],	rdx
;---------------
    mov       rcx,	4
    call      mm_lib.createunit0
    mov       rsi,	rax
    mov       rcx,	49
    mov       rdx,	[rbp + mm_blockpcl.do_assignrecord.a]
    mov       r8,	rsi
    call      mm_lib.createunit2
    mov       rbx,	rax
    mov       rax,	[rbp + mm_blockpcl.do_assignrecord.b]
    mov       rax,	[rax+16]
    mov       rcx,	28
    mov       rdx,	rbx
    mov       r8,	rax
    call      mm_lib.createunit2
    mov       rdi,	rax
    mov       rax,	[rbp + mm_blockpcl.do_assignrecord.a]
    movsxd    rax,	dword [rax+49]
    lea       r10,	[mm_decls.tttarget]
    movsxd    r10,	dword [r10 + rax*4]
    mov       [rbx+49],	r10d
    mov       [rdi+49],	r10d
    mov       rax,	[rbp + mm_blockpcl.do_assignrecord.a]
    movsxd    rax,	dword [rax+49]
    mov       r13,	rax
    lea       rax,	[mm_decls.ttnamedef]
    mov       r10,	r13
    mov       r15,	[rax + r10*8]
    mov       rax,	[r15+16]
    mov       [rbp + mm_blockpcl.do_assignrecord.e],	rax
    mov       rax,	[rbp + mm_blockpcl.do_assignrecord.b]
    mov       r12,	[rax+16]
    jmp       L6252
L6251:
    mov       rax,	[rbp + mm_blockpcl.do_assignrecord.e]
    movzx     rax,	byte [rax+78]
    cmp       rax,	13
    jnz       L6255
    mov       rax,	[rbp + mm_blockpcl.do_assignrecord.e]
    movsxd    rax,	dword [rax+72]
    cmp       rax,	27
    jz        L6255
    mov       rax,	[rbp + mm_blockpcl.do_assignrecord.e]
    movsxd    rax,	dword [rax+72]
    mov       r14,	rax
    mov       rax,	[rbp + mm_blockpcl.do_assignrecord.e]
    mov       [rsi+16],	rax
    mov       eax,	r14d
    mov       [rbx+49],	eax
    mov       [rsi+49],	eax
    mov       [rdi+49],	eax
    mov       [rdi+24],	r12
    mov       rax,	[rbp + mm_blockpcl.do_assignrecord.e]
    mov       eax,	[rax+84]
    mov       [rbx+40],	eax
    mov       rcx,	rdi
    call      mm_blockpcl.evalunit
    mov       r12,	[r12+8]
L6255:
    mov       rax,	[rbp + mm_blockpcl.do_assignrecord.e]
    mov       rax,	[rax+32]
    mov       [rbp + mm_blockpcl.do_assignrecord.e],	rax
L6252:
    mov       rax,	[rbp + mm_blockpcl.do_assignrecord.e]
    test      rax,	rax
    jnz       L6251
;---------------
    add       rsp,	40
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.pushrhs
mm_blockpcl.pushrhs:
;?>>
   %define R.a rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    test      rdi,	rdi
    jnz       L6258
    jmp       L6256
L6258:
    mov       rcx,	[rdi+8]
    call      mm_blockpcl.pushrhs
    mov       rcx,	rdi
    call      mm_blockpcl.evalunit
L6256:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_assignms
mm_blockpcl.do_assignms:
;?>>
   %define R.a r13
   %define R.b r14
   %define R.nlhs rdi
   %define R.nrhs rbx
   %define R.d rsi
   %define R.i r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       r13,	rcx
    mov       r14,	rdx
;---------------
    mov       eax,	[r13+40]
    mov       rdi,	rax
    movzx     rax,	byte [r14]
    cmp       rax,	32
    jnz       L6262
L6261:
    mov       rcx,	r14
    call      mm_blockpcl.evalunit
    mov       rax,	[r14+16]
    movzx     rax,	byte [rax]
    cmp       rax,	4
    jz        L6264
    lea       rcx,	[L12887]
    xor       edx,	edx
    call      mm_support.gerror
L6264:
    mov       rax,	[r14+16]
    mov       rsi,	[rax+16]
    movzx     rax,	byte [rsi+122]
    mov       rbx,	rax
    mov       r13,	[r13+16]
    jmp       L6260
L6262:
    movsxd    rax,	dword [r14+49]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    cmp       r10,	11
    jnz       L6266
    lea       rcx,	[L12888]
    xor       edx,	edx
    call      mm_support.gerror
    jmp       L6265
L6266:
    lea       rcx,	[L12889]
    xor       edx,	edx
    call      mm_support.gerror
L6265:
L6260:
    mov       rcx,	r13
    call      mm_blockpcl.poptomult
    cmp       rbx,	rdi
    jle       L6268
    mov       rcx,	r14
    call      mm_lib.getprocretmodes
    mov       rsi,	rax
    lea       rax,	[rdi+1]
    mov       r12,	rax
    cmp       r12,	rbx
    jg        L6271
L6269:
    mov       rcx,	11
    xor       edx,	edx
    call      pc_api.pc_gen
    movsxd    rax,	dword [rsi+72]
    lea       r10,	[mm_decls.ttmult]
    mov       r10,	[r10 + rax*8]
    mov       rax,	r12
    movsxd    r10,	dword [r10 + rax*4-4]
    mov       rcx,	r10
    call      mm_libpcl.setmode
    inc       r12
    cmp       r12,	rbx
    jle       L6269
L6271:
L6268:
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_assignmm
mm_blockpcl.do_assignmm:
;?>>
   %define R.a rdi
   %define R.b rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	[rbx+16]
    call      mm_blockpcl.pushrhs
    mov       rcx,	133
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	[rdi+16]
    call      mm_blockpcl.poptomult
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_assignmdrem
mm_blockpcl.do_assignmdrem:
;?>>
   %define R.a rdi
   %define R.b rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rbx
    call      mm_blockpcl.evalunit
    mov       rcx,	[rdi+16]
    call      mm_blockpcl.poptomult
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.poptomult
mm_blockpcl.poptomult:
;?>>
   %define R.a rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
L6275:
    movzx     rax,	byte [rdi]
    cmp       rax,	4
    jz        L6279
    cmp       rax,	46
    jz        L6280
    cmp       rax,	48
    jz        L6280
    cmp       rax,	49
    jz        L6280
    cmp       rax,	53
    jz        L6281
    cmp       rax,	92
    jz        L6282
    cmp       rax,	105
    jz        L6282
    cmp       rax,	107
    jz        L6282
    cmp       rax,	112
    jz        L6282
    cmp       rax,	51
    jz        L6283
    jmp       L6284
L6279:
    mov       rcx,	rdi
    call      mm_genpcl.genmem_u
    mov       rcx,	4
    mov       rdx,	rax
    call      pc_api.pc_gen
    jmp       L6278
L6280:
    mov       rcx,	rdi
    xor       edx,	edx
    call      mm_blockpcl.evalref
    mov       rcx,	5
    xor       edx,	edx
    call      pc_api.pc_gen
    jmp       L6278
L6281:
    mov       rcx,	[rdi+16]
    call      mm_blockpcl.evalunit
    mov       rcx,	5
    xor       edx,	edx
    call      pc_api.pc_gen
    jmp       L6278
L6282:
    mov       rcx,	rdi
    xor       edx,	edx
    call      mm_blockpcl.evalref
    mov       rcx,	5
    xor       edx,	edx
    call      pc_api.pc_gen
    jmp       L6278
L6283:
    mov       rax,	[rdi+16]
    mov       rcx,	rax
    xor       edx,	edx
    call      mm_blockpcl.evalref
    mov       rcx,	[rdi+24]
    call      mm_blockpcl.evalunit
    mov       rcx,	16
    xor       edx,	edx
    call      pc_api.pc_gen
    jmp       L6278
L6284:
    call      msys.m$print_startcon
    movzx     rax,	byte [rdi]
    lea       r10,	[mm_tables.jtagnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L12890]
    xor       edx,	edx
    call      mm_support.gerror
L6278:
    mov       rcx,	rdi
    call      mm_libpcl.setmode_u
    mov       rdi,	[rdi+8]
    test      rdi,	rdi
    jnz       L6275
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_recase
mm_blockpcl.do_recase:
;?>>
    %define mm_blockpcl.do_recase.p 64
   %define R.a r14
   %define R.q rdi
   %define R.wt rbx
   %define R.w rsi
   %define R.destlab r12
   %define R.casevalue r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       r14,	rdx
;---------------
    mov       rax,	[mm_blockpcl.casedepth]
    test      rax,	rax
    jnz       L6287
    lea       rcx,	[L12891]
    xor       edx,	edx
    call      mm_support.gerror
L6287:
    test      r14,	r14
    jz        L6289
    mov       r13,	[r14+16]
    jmp       L6288
L6289:
    lea       rax,	[mm_blockpcl.caseelse]
    mov       r10,	[mm_blockpcl.casedepth]
    mov       rcx,	[rax + r10*8-8]
    call      mm_blockpcl.genjumpl
L6288:
    lea       rax,	[mm_blockpcl.casestmt]
    mov       r10,	[mm_blockpcl.casedepth]
    mov       rdi,	[rax + r10*8-8]
    xor       r12,	r12
    mov       rax,	[rdi+24]
    mov       rbx,	rax
    jmp       L6291
L6290:
    mov       rsi,	[rbx+16]
    jmp       L6294
L6293:
    movzx     rax,	byte [rsi]
    cmp       rax,	1
    jnz       L6297
    movsxd    rax,	dword [rsi+49]
    lea       r10,	[mm_decls.ttisinteger]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L6297
    mov       rax,	[rsi+16]
    cmp       rax,	r13
    jnz       L6297
    movsxd    rax,	dword [rsi+40]
    mov       r12,	rax
    jmp       L6292
L6297:
    mov       rsi,	[rsi+8]
L6294:
    test      rsi,	rsi
    jnz       L6293
    mov       rbx,	[rbx+8]
L6291:
    test      rbx,	rbx
    jnz       L6290
L6292:
    test      r12,	r12
    jnz       L6299
    lea       rax,	[mm_blockpcl.caseelse]
    mov       r10,	[mm_blockpcl.casedepth]
    mov       rcx,	[rax + r10*8-8]
    call      mm_blockpcl.genjumpl
    jmp       L6298
L6299:
    mov       rcx,	r12
    call      mm_blockpcl.genjumpl
L6298:
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_empty
mm_blockpcl.do_empty:
;?>>
    %define mm_blockpcl.do_empty.p 24
   %define R.a rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rdx
;---------------
    mov       rcx,	rdi
    xor       edx,	edx
    call      mm_blockpcl.evalref
    mov       rcx,	41
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	rdi
    call      mm_libpcl.setmode_u
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_typeconst
mm_blockpcl.do_typeconst:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	[rdi+16]
    call      mm_genpcl.genpushint
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_blockpcl.do_setinplace
mm_blockpcl.do_setinplace:
;?>>
;?]]
;---------------
    mov       rax,	[pc_api.pccurr]
    movzx     rax,	byte [rax]
    cmp       rax,	1
    jnz       L6304
    mov       rax,	[pc_api.pccurr]
    movzx     rax,	byte [rax+1]
    cmp       rax,	2
    jnz       L6304
    mov       eax,	1
    mov       r10,	[pc_api.pccurr]
    mov       [r10+16],	eax
L6304:
;---------------
    ret       
;End 
;Proc mm_assem.readassemline
mm_assem.readassemline:
;?>>
;?]]
    sub       rsp,	40
;---------------
    call      mm_lex.lex
    mov       rcx,	1
    call      mm_assem.assembleline
L6305:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mm_assem.readassemblock
mm_assem.readassemblock:
;?>>
    %define mm_assem.readassemblock.ulist -8
    %define mm_assem.readassemblock.ulistx -16
   %define R.u rdi
    push      rdi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
;---------------
    xor       eax,	eax
    mov       [rbp + mm_assem.readassemblock.ulistx],	rax
    mov       [rbp + mm_assem.readassemblock.ulist],	rax
L6307:
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	59
    jz        L6310
    cmp       rax,	87
    jz        L6311
    cmp       rax,	4
    jz        L6312
    jmp       L6313
L6310:
    lea       rcx,	[L12892]
    call      mm_support.serror
    jmp       L6309
L6311:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    mov       rcx,	rax
    mov       rdx,	135
    xor       r8d,	r8d
    xor       r9d,	r9d
    call      mm_parse.checkend
    jmp       L6308
L6312:
    jmp       L6309
L6313:
    xor       ecx,	ecx
    call      mm_assem.assembleline
    mov       rdi,	rax
    lea       rcx,	[rbp + mm_assem.readassemblock.ulist]
    lea       rdx,	[rbp + mm_assem.readassemblock.ulistx]
    mov       r8,	rdi
    call      mm_lib.addlistunit
L6309:
    jmp       L6307
L6308:
    mov       rcx,	[rbp + mm_assem.readassemblock.ulist]
    call      mm_parse.makeblock
L6306:
;---------------
    add       rsp,	56
    pop       rbp
    pop       rdi
    ret       
;End 
;Proc mm_assem.assembleline
mm_assem.assembleline:
;?>>
   %define R.oneline r15
    %define mm_assem.assembleline.dlist -8
    %define mm_assem.assembleline.dlistx -16
   %define R.p rdi
   %define R.pname rbx
   %define R.q rsi
   %define R.opc r12
   %define R.noperands r13
   %define R.stname r14
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
    mov       r15,	rcx
;---------------
    xor       eax,	eax
    mov       [rbp + mm_assem.assembleline.dlistx],	rax
    mov       [rbp + mm_assem.assembleline.dlist],	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	67
    jnz       L6316
    lea       rax,	[mm_decls.nextlx]
    movzx     rax,	byte [rax]
    cmp       rax,	5
    jnz       L6316
    mov       rcx,	100
    call      mm_lib.createunit0
    mov       rdi,	rax
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       rcx,	[mm_decls.currproc]
    mov       rdx,	rax
    mov       r8,	14
    call      mm_lib.getduplnameptr
    mov       r14,	rax
    mov       [rdi+16],	r14
    mov       rcx,	[mm_decls.currproc]
    mov       rdx,	r14
    call      mm_lib.adddef
    call      mm_lex.lex
    test      r15,	r15
    jz        L6318
    call      mm_lex.lex
L6318:
    mov       rax,	rdi
    jmp       L6314
L6316:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	26
    jnz       L6319
    mov       rcx,	67
    call      mm_parse.lexchecksymbol
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       rcx,	rax
    call      mm_lib.createname
    mov       rbx,	rax
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       [rbx+4],	eax
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	4
    jz        L6321
L6322:
    call      mm_parse.readunit
    lea       rcx,	[rbp + mm_assem.assembleline.dlist]
    lea       rdx,	[rbp + mm_assem.assembleline.dlistx]
    mov       r8,	rax
    call      mm_lib.addlistunit
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jnz       L6326
    call      mm_lex.lex
L6326:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	4
    jz        L6327
    cmp       rax,	59
    jnz       L6322
L6327:
L6321:
    mov       rcx,	9
    mov       rdx,	rbx
    mov       r8,	[rbp + mm_assem.assembleline.dlist]
    call      mm_lib.createunit2
    jmp       L6314
L6319:
L6315:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	38
    jz        L6329
    cmp       rax,	39
    jz        L6330
    cmp       rax,	40
    jz        L6331
    cmp       rax,	47
    jz        L6332
    cmp       rax,	108
    jz        L6333
    jmp       L6334
L6329:
    mov       r12,	38
;mm_assem.assembleline.doop:
L6335:
    mov       rcx,	8
    call      mm_lib.createunit0
    mov       rdi,	rax
    mov       [rdi+40],	r12w
    call      mm_lex.lex
    jmp       L6328
L6330:
    mov       r12,	39
    jmp       L6335
L6331:
    mov       r12,	40
    jmp       L6335
L6332:
    mov       r12,	51
    jmp       L6335
L6333:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    cmp       rax,	1
    jnz       L6337
    mov       r12,	29
    jmp       L6335
L6337:
    jmp       L6338
L6334:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	67
    jnz       L6340
    mov       rcx,	8
    call      mm_lib.createunit0
    mov       rdi,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    cmp       rax,	78
    jz        L6342
    cmp       rax,	74
    jz        L6343
    cmp       rax,	75
    jz        L6344
    cmp       rax,	76
    jz        L6345
    jmp       L6346
L6342:
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       eax,	[rax+80]
    mov       [rdi+40],	ax
    jmp       L6341
L6343:
    mov       ax,	26
    mov       [rdi+40],	ax
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       eax,	[rax+80]
    mov       [rdi+45],	al
    jmp       L6341
L6344:
    mov       ax,	58
    mov       [rdi+40],	ax
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       eax,	[rax+80]
    mov       [rdi+45],	al
    jmp       L6341
L6345:
    mov       ax,	15
    mov       [rdi+40],	ax
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       eax,	[rax+80]
    mov       [rdi+45],	al
    jmp       L6341
L6346:
    lea       rcx,	[L12893]
    call      mm_lex.ps
    lea       rcx,	[L12894]
    call      mm_support.serror
L6341:
    call      mm_lex.lex
    jmp       L6339
L6340:
;mm_assem.assembleline.$else:
L6338:
    lea       rcx,	[L12895]
    call      mm_lex.ps
    lea       rcx,	[L12896]
    call      mm_support.serror
L6339:
L6328:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	4
    jz        L6348
    cmp       rax,	59
    jz        L6348
    xor       r13,	r13
L6349:
    call      mm_assem.readassemopnd
    mov       rsi,	rax
    inc       r13
    cmp       r13,	3
    jg        L6352
    lea       rax,	[rdi+16]
    mov       r10,	rsi
    mov       r11,	r13
    mov       [rax + r11*8-8],	r10
    jmp       L6351
L6352:
    lea       rcx,	[L12897]
    call      mm_support.serror
L6351:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jnz       L6350
L6354:
    call      mm_lex.lex
L6353:
    jmp       L6349
L6350:
L6348:
    mov       rcx,	4
    call      mm_parse.checksymbol
    mov       rax,	rdi
L6314:
;---------------
    add       rsp,	56
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_assem.readassemopnd
mm_assem.readassemopnd:
;?>>
   %define R.p rdi
   %define R.reg rbx
   %define R.regix rsi
   %define R.scale r12
   %define R.prefixmode r13
   %define R.pcode r14
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
;---------------
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	62
    jz        L6357
    cmp       rax,	63
    jz        L6357
    cmp       rax,	67
    jz        L6358
    cmp       rax,	24
    jz        L6359
    cmp       rax,	25
    jz        L6359
    cmp       rax,	79
    jz        L6360
    cmp       rax,	11
    jz        L6361
    jmp       L6362
L6357:
    call      mm_parse.readunit
    jmp       L6355
L6358:
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    movzx     rax,	byte [rax+79]
    cmp       rax,	70
    jz        L6364
    cmp       rax,	71
    jz        L6365
    jmp       L6366
L6364:
    mov       rcx,	10
    call      mm_lib.createunit0
    mov       rdi,	rax
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       eax,	[rax+80]
    mov       [rdi+40],	eax
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       ax,	[rax+164]
    mov       [rdi+44],	al
    call      mm_lex.lex
    mov       rax,	rdi
    jmp       L6355
L6365:
    mov       rcx,	11
    call      mm_lib.createunit0
    mov       rdi,	rax
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       eax,	[rax+80]
    mov       [rdi+40],	eax
    call      mm_lex.lex
    mov       rax,	rdi
    jmp       L6355
L6366:
L6363:
    call      mm_parse.readunit
    jmp       L6355
L6359:
    call      mm_parse.readunit
    jmp       L6355
L6360:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    cmp       rax,	17
    jz        L6368
    cmp       rax,	18
    jz        L6368
    cmp       rax,	19
    jz        L6368
    cmp       rax,	4
    jnz       L6369
L6368:
    jmp       L6367
L6369:
    lea       rcx,	[L12898]
    call      mm_support.serror
L6367:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    mov       r13,	rax
    mov       rcx,	11
    call      mm_parse.lexchecksymbol
    jmp       L6370
L6361:
    xor       r13,	r13
;mm_assem.readassemopnd.gotprefix:
L6370:
    xor       eax,	eax
    mov       rsi,	rax
    mov       rbx,	rax
    xor       r14,	r14
    mov       rax,	1
    mov       r12,	rax
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	67
    jnz       L6372
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    movzx     rax,	byte [rax+79]
    cmp       rax,	70
    jnz       L6372
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    movsxd    rax,	dword [rax+80]
    mov       rbx,	rax
    call      mm_lex.lex
L6372:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	24
    jnz       L6374
    lea       rax,	[mm_decls.nextlx]
    movzx     rax,	byte [rax]
    cmp       rax,	67
    jnz       L6374
    lea       rax,	[mm_decls.nextlx]
    mov       rax,	[rax+8]
    movzx     rax,	byte [rax+79]
    cmp       rax,	70
    jnz       L6374
    call      mm_lex.lex
L6374:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	67
    jnz       L6376
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    movzx     rax,	byte [rax+79]
    cmp       rax,	70
    jnz       L6376
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    movsxd    rax,	dword [rax+80]
    mov       rsi,	rax
    call      mm_lex.lex
L6376:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	26
    jnz       L6378
    mov       rcx,	62
    call      mm_parse.lexchecksymbol
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       r12,	rax
    cmp       rax,	1
    jz        L6380
    cmp       rax,	2
    jz        L6380
    cmp       rax,	4
    jz        L6380
    cmp       rax,	8
    jnz       L6381
L6380:
    jmp       L6379
L6381:
    lea       rcx,	[L12899]
    call      mm_support.serror
L6379:
    call      mm_lex.lex
L6378:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	24
    jz        L6383
    cmp       rax,	25
    jz        L6383
    cmp       rax,	62
    jz        L6383
    cmp       rax,	67
    jz        L6383
    cmp       rax,	9
    jz        L6383
    cmp       rax,	136
    jnz       L6384
L6383:
    call      mm_parse.readunit
    mov       r14,	rax
L6384:
L6382:
    mov       rcx,	12
    call      mm_parse.checksymbol
    call      mm_lex.lex
    mov       rcx,	12
    mov       rdx,	r14
    call      mm_lib.createunit1
    mov       rdi,	rax
    test      rsi,	rsi
    jnz       L6386
    cmp       r12,	1
    jle       L6386
    mov       rsi,	rbx
    xor       rbx,	rbx
L6386:
    test      r14,	r14
    jnz       L6388
    mov       rax,	rbx
    add       rax,	rsi
    test      rax,	rax
    jnz       L6388
    lea       rcx,	[L12900]
    call      mm_support.serror
L6388:
    mov       [rdi+40],	bl
    mov       [rdi+41],	sil
    mov       [rdi+42],	r12b
    mov       [rdi+43],	r13b
    mov       rax,	rdi
    jmp       L6355
L6362:
    lea       rcx,	[L12901]
    call      mm_lex.ps
    lea       rcx,	[L12902]
    call      mm_support.serror
L6356:
    xor       eax,	eax
L6355:
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_assem.initassemsymbols
mm_assem.initassemsymbols:
;?>>
    %define mm_assem.initassemsymbols.str -32
   %define R.i rdi
   %define R.av_1 rbx
   %define R.av_2 rsi
   %define R.av_3 r12
   %define R.av_4 r13
   %define R.av_5 r14
    %define mm_assem.initassemsymbols.av_6 -40
    %define mm_assem.initassemsymbols.av_7 -48
    %define mm_assem.initassemsymbols.av_8 -56
    %define mm_assem.initassemsymbols.av_9 -64
    %define mm_assem.initassemsymbols.av_10 -72
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	104
;---------------
    mov       rdi,	1
    mov       rbx,	151
    cmp       rbx,	1
    jl        L6392
L6390:
    lea       rax,	[mc_decls.mclnames]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    lea       rax,	[rax+2]
    mov       rcx,	rax
    mov       rdx,	78
    mov       r8,	rdi
    xor       r9d,	r9d
    call      mm_lex.addreservedword
    inc       rdi
    cmp       rdi,	rbx
    jle       L6390
L6392:
    mov       rdi,	1
    mov       rsi,	137
    cmp       rsi,	1
    jl        L6395
L6393:
    lea       rax,	[mc_decls.regsizes]
    mov       r10,	rdi
    movzx     rax,	byte [rax + r10-1]
    lea       r10,	[mc_decls.regindices]
    mov       r11,	rdi
    movzx     r10,	byte [r10 + r11-1]
    lea       r11,	[mc_decls.dregnames]
    mov       r15,	rdi
    mov       r11,	[r11 + r15*8-8]
    mov       rcx,	r11
    mov       rdx,	70
    mov       r8,	r10
    mov       r9,	rax
    call      mm_lex.addreservedword
    inc       rdi
    cmp       rdi,	rsi
    jle       L6393
L6395:
    mov       rdi,	1
    mov       r12,	16
    cmp       r12,	1
    jl        L6398
L6396:
    lea       rax,	[mc_decls.xmmregnames]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rax
    mov       rdx,	71
    mov       r8,	rdi
    xor       r9d,	r9d
    call      mm_lex.addreservedword
    inc       rdi
    cmp       rdi,	r12
    jle       L6396
L6398:
    mov       rdi,	1
    mov       r13,	8
    cmp       r13,	1
    jl        L6401
L6399:
    lea       rax,	[mc_decls.fregnames]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rax
    mov       rdx,	72
    mov       r8,	rdi
    xor       r9d,	r9d
    call      mm_lex.addreservedword
    inc       rdi
    cmp       rdi,	r13
    jle       L6399
L6401:
    mov       rdi,	1
    mov       r14,	8
    cmp       r14,	1
    jl        L6404
L6402:
    lea       rax,	[mc_decls.mregnames]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rax
    mov       rdx,	73
    mov       r8,	rdi
    xor       r9d,	r9d
    call      mm_lex.addreservedword
    inc       rdi
    cmp       rdi,	r14
    jle       L6402
L6404:
    mov       rdi,	1
    mov       rax,	18
    mov       [rbp + mm_assem.initassemsymbols.av_6],	rax
    mov       rax,	[rbp + mm_assem.initassemsymbols.av_6]
    cmp       rax,	1
    jl        L6407
L6405:
    lea       rax,	[mc_decls.jmpcccodes]
    mov       r10,	rdi
    movzx     rax,	byte [rax + r10-1]
    lea       r10,	[mc_decls.jmpccnames]
    mov       r11,	rdi
    mov       r10,	[r10 + r11*8-8]
    mov       rcx,	r10
    mov       rdx,	74
    mov       r8,	rax
    xor       r9d,	r9d
    call      mm_lex.addreservedword
    inc       rdi
    cmp       rdi,	[rbp + mm_assem.initassemsymbols.av_6]
    jle       L6405
L6407:
    mov       rdi,	1
    mov       rax,	16
    mov       [rbp + mm_assem.initassemsymbols.av_7],	rax
    mov       rax,	[rbp + mm_assem.initassemsymbols.av_7]
    cmp       rax,	1
    jl        L6410
L6408:
    lea       rax,	[mc_decls.setcccodes]
    mov       r10,	rdi
    movzx     rax,	byte [rax + r10-1]
    lea       r10,	[mc_decls.setccnames]
    mov       r11,	rdi
    mov       r10,	[r10 + r11*8-8]
    mov       rcx,	r10
    mov       rdx,	75
    mov       r8,	rax
    xor       r9d,	r9d
    call      mm_lex.addreservedword
    inc       rdi
    cmp       rdi,	[rbp + mm_assem.initassemsymbols.av_7]
    jle       L6408
L6410:
    mov       rdi,	1
    mov       rax,	16
    mov       [rbp + mm_assem.initassemsymbols.av_8],	rax
    mov       rax,	[rbp + mm_assem.initassemsymbols.av_8]
    cmp       rax,	1
    jl        L6413
L6411:
    lea       rax,	[mc_decls.cmovcccodes]
    mov       r10,	rdi
    movzx     rax,	byte [rax + r10-1]
    lea       r10,	[mc_decls.cmovccnames]
    mov       r11,	rdi
    mov       r10,	[r10 + r11*8-8]
    mov       rcx,	r10
    mov       rdx,	76
    mov       r8,	rax
    xor       r9d,	r9d
    call      mm_lex.addreservedword
    inc       rdi
    cmp       rdi,	[rbp + mm_assem.initassemsymbols.av_8]
    jle       L6411
L6413:
    mov       rdi,	1
    mov       rax,	5
    mov       [rbp + mm_assem.initassemsymbols.av_9],	rax
    mov       rax,	[rbp + mm_assem.initassemsymbols.av_9]
    cmp       rax,	1
    jl        L6416
L6414:
    lea       rax,	[mc_decls.segmentnames]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8]
    lea       rcx,	[rbp + mm_assem.initassemsymbols.str]
    mov       rdx,	rax
    call      strcpy
    lea       rcx,	[rbp + mm_assem.initassemsymbols.str]
    call      strlen
    xor       r10d,	r10d
    mov       [rbp + rax + mm_assem.initassemsymbols.str-4],	r10b
    lea       rcx,	[rbp + mm_assem.initassemsymbols.str]
    call      mlib.pcm_copyheapstring
    mov       rcx,	rax
    mov       rdx,	77
    mov       r8,	rdi
    xor       r9d,	r9d
    call      mm_lex.addreservedword
    inc       rdi
    cmp       rdi,	[rbp + mm_assem.initassemsymbols.av_9]
    jle       L6414
L6416:
    mov       rdi,	1
    mov       rax,	6
    mov       [rbp + mm_assem.initassemsymbols.av_10],	rax
    mov       rax,	[rbp + mm_assem.initassemsymbols.av_10]
    cmp       rax,	1
    jl        L6419
L6417:
    lea       rax,	[mm_assem.initassemsymbols.sizes]
    mov       r10,	rdi
    movzx     rax,	byte [rax + r10-1]
    lea       r10,	[mm_assem.initassemsymbols.regnos]
    mov       r11,	rdi
    movzx     r10,	byte [r10 + r11-1]
    lea       r11,	[mm_assem.initassemsymbols.regnames]
    mov       r15,	rdi
    mov       r11,	[r11 + r15*8-8]
    mov       rcx,	r11
    mov       rdx,	70
    mov       r8,	r10
    mov       r9,	rax
    call      mm_lex.addreservedword
    inc       rdi
    cmp       rdi,	[rbp + mm_assem.initassemsymbols.av_10]
    jle       L6417
L6419:
;---------------
    add       rsp,	104
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_assemaux.domcl_assem
mm_assemaux.domcl_assem:
;?>>
   %define R.pcode rdi
    %define mm_assemaux.domcl_assem.$T1 -8
    push      rdi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       rdi,	rcx
;---------------
    test      rdi,	rdi
    jz        L6423
    movzx     rax,	byte [rdi]
    cmp       rax,	8
    jz        L6422
L6423:
    jmp       L6420
L6422:
    mov       rax,	[rdi+24]
    mov       rcx,	rax
    call      mm_assemaux.genasmopnd
    mov       [rbp + mm_assemaux.domcl_assem.$T1],	rax
    mov       rax,	[rdi+16]
    mov       rcx,	rax
    call      mm_assemaux.genasmopnd
    movsx     r10,	word [rdi+40]
    mov       rcx,	r10
    mov       rdx,	rax
    mov       r8,	[rbp + mm_assemaux.domcl_assem.$T1]
    call      mc_libmcl.genmc
    mov       al,	[rdi+45]
    mov       r10,	[mc_decls.mccodex]
    mov       [r10+34],	al
    movsx     rax,	word [rdi+40]
    cmp       rax,	92
    jz        L6425
    cmp       rax,	93
    jz        L6425
    cmp       rax,	61
    jz        L6425
    cmp       rax,	62
    jnz       L6426
L6425:
    mov       rax,	[rdi+32]
    test      rax,	rax
    jz        L6429
    mov       rax,	[rdi+32]
    movzx     rax,	byte [rax]
    cmp       rax,	1
    jz        L6428
L6429:
    lea       rcx,	[L12903]
    xor       edx,	edx
    call      mm_support.gerror
L6428:
    mov       rax,	[rdi+32]
    mov       rax,	[rax+16]
    mov       r10,	[mc_decls.mccodex]
    mov       [r10+32],	al
L6426:
L6424:
L6420:
;---------------
    add       rsp,	40
    pop       rbp
    pop       rdi
    ret       
;End 
;Proc mm_assemaux.genasmopnd
mm_assemaux.genasmopnd:
;?>>
    %define mm_assemaux.genasmopnd.p 64
   %define R.ax rdi
   %define R.d rbx
   %define R.offset rsi
   %define R.labno r12
   %define R.a r13
   %define R.x r14
    %define mm_assemaux.genasmopnd.y -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+64],	rcx
;---------------
    mov       rax,	[rbp + mm_assemaux.genasmopnd.p]
    test      rax,	rax
    jnz       L6432
    xor       eax,	eax
    jmp       L6430
L6432:
    mov       rax,	[rbp + mm_assemaux.genasmopnd.p]
    movzx     rax,	byte [rax]
    cmp       rax,	10
    jz        L6434
    cmp       rax,	1
    jz        L6435
    cmp       rax,	12
    jz        L6436
    cmp       rax,	4
    jz        L6437
    cmp       rax,	11
    jz        L6438
    cmp       rax,	35
    jz        L6439
    jmp       L6440
L6434:
    mov       rax,	[rbp + mm_assemaux.genasmopnd.p]
    movzx     rax,	byte [rax+44]
    lea       r10,	[mc_decls.regmodes]
    movzx     r10,	byte [r10 + rax-1]
    mov       rax,	[rbp + mm_assemaux.genasmopnd.p]
    movzx     rax,	byte [rax+40]
    mov       rcx,	rax
    mov       rdx,	r10
    call      mc_libmcl.mgenreg
    mov       rdi,	rax
    jmp       L6433
L6435:
    mov       rax,	[rbp + mm_assemaux.genasmopnd.p]
    mov       rax,	[rax+16]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rdi,	rax
    jmp       L6433
L6436:
    mov       rax,	[rbp + mm_assemaux.genasmopnd.p]
    mov       r13,	[rax+16]
    xor       rbx,	rbx
    xor       eax,	eax
    mov       r12,	rax
    mov       rsi,	rax
    test      r13,	r13
    jz        L6442
    movzx     rax,	byte [r13]
    cmp       rax,	1
    jz        L6444
    cmp       rax,	4
    jz        L6445
    cmp       rax,	35
    jz        L6446
    cmp       rax,	36
    jz        L6447
    cmp       rax,	90
    jz        L6448
    jmp       L6449
L6444:
    mov       rsi,	[r13+16]
    jmp       L6443
L6445:
    mov       rax,	[r13+16]
    mov       rcx,	rax
    call      mm_libpcl.getpsymbol
    mov       rbx,	rax
    movzx     rax,	byte [rbx+72]
    cmp       rax,	6
    jnz       L6451
    mov       rcx,	rbx
    call      mm_assemaux.fixasmlabel
    mov       r12,	rax
    xor       rbx,	rbx
L6451:
    jmp       L6443
L6446:
    mov       r14,	[r13+16]
    mov       rax,	[r13+24]
    mov       [rbp + mm_assemaux.genasmopnd.y],	rax
    movzx     rax,	byte [r14]
    cmp       rax,	4
    jnz       L6453
    mov       rax,	[rbp + mm_assemaux.genasmopnd.y]
    movzx     rax,	byte [rax]
    cmp       rax,	1
    jnz       L6453
    mov       rax,	[r14+16]
    mov       rcx,	rax
    call      mm_libpcl.getpsymbol
    mov       rbx,	rax
    movzx     rax,	byte [rbx+72]
    cmp       rax,	6
    jnz       L6455
    mov       rcx,	rbx
    call      mm_assemaux.fixasmlabel
    mov       r12,	rax
    xor       rbx,	rbx
L6455:
    jmp       L6452
L6453:
    jmp       L6456
L6452:
    movzx     rax,	byte [r13+62]
    cmp       rax,	43
    jz        L6459
    cmp       rax,	57
    jnz       L6458
L6459:
    mov       rax,	[rbp + mm_assemaux.genasmopnd.y]
    mov       rax,	[rax+16]
    jmp       L6457
L6458:
    mov       rax,	[rbp + mm_assemaux.genasmopnd.y]
    mov       rax,	[rax+16]
    neg       rax
L6457:
    mov       rsi,	rax
    jmp       L6443
L6447:
    movzx     rax,	byte [r13+62]
    cmp       rax,	60
    jz        L6461
    lea       rcx,	[L12904]
    lea       rdx,	[L12905]
    call      pc_api.merror
L6461:
    mov       rax,	[r13+16]
    movzx     rax,	byte [rax]
    cmp       rax,	1
    jz        L6463
    lea       rcx,	[L12906]
    xor       edx,	edx
    call      mm_support.gerror
L6463:
    mov       rax,	[r13+16]
    mov       rax,	[rax+16]
    neg       rax
    mov       rsi,	rax
    jmp       L6443
L6448:
    lea       rcx,	[L12907]
    lea       rdx,	[L12908]
    call      pc_api.merror
    jmp       L6443
L6449:
;mm_assemaux.genasmopnd.error:
L6456:
    call      msys.m$print_startcon
    movzx     rax,	byte [r13]
    lea       r10,	[mm_tables.jtagnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L12909]
    xor       edx,	edx
    call      mm_support.gerror
L6443:
L6442:
    sub       rsp,	8
    mov       rax,	rbx
    push      rax
    mov       rax,	r12
    push      rax
    mov       rax,	[rbp + mm_assemaux.genasmopnd.p]
    movzx     rax,	byte [rax+43]
    lea       r10,	[mm_decls.ttsize]
    mov       r10d,	[r10 + rax*4]
    push      r10
    mov       rax,	[rbp + mm_assemaux.genasmopnd.p]
    movzx     rax,	byte [rax+42]
    mov       r10,	[rbp + mm_assemaux.genasmopnd.p]
    movzx     r10,	byte [r10+41]
    mov       r11,	[rbp + mm_assemaux.genasmopnd.p]
    movzx     r11,	byte [r11+40]
    mov       rcx,	r11
    mov       rdx,	r10
    mov       r8,	rax
    mov       r9,	rsi
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       rdi,	rax
    jmp       L6433
L6437:
    mov       rax,	[rbp + mm_assemaux.genasmopnd.p]
    mov       rax,	[rax+16]
    mov       rcx,	rax
    call      mm_libpcl.getpsymbol
    mov       rbx,	rax
    movzx     rax,	byte [rbx+72]
    cmp       rax,	6
    jnz       L6465
    mov       rcx,	rbx
    call      mm_assemaux.fixasmlabel
    mov       r12,	rax
    mov       rcx,	r12
    call      mc_libmcl.mgenlabel
    mov       rdi,	rax
    jmp       L6464
L6465:
    mov       rcx,	rbx
    call      mc_libmcl.mgenmemaddr
    mov       rdi,	rax
L6464:
    jmp       L6433
L6438:
    mov       rax,	[rbp + mm_assemaux.genasmopnd.p]
    movzx     rax,	byte [rax+40]
    mov       rcx,	rax
    mov       rdx,	8
    call      mc_libmcl.mgenxreg
    mov       rdi,	rax
    jmp       L6433
L6439:
    mov       rax,	[rbp + mm_assemaux.genasmopnd.p]
    mov       r14,	[rax+16]
    mov       rax,	[rbp + mm_assemaux.genasmopnd.p]
    mov       rax,	[rax+24]
    mov       [rbp + mm_assemaux.genasmopnd.y],	rax
    movzx     rax,	byte [r14]
    cmp       rax,	4
    jnz       L6467
    mov       rax,	[rbp + mm_assemaux.genasmopnd.y]
    movzx     rax,	byte [rax]
    cmp       rax,	1
    jnz       L6467
    mov       rax,	[r14+16]
    mov       rcx,	rax
    call      mm_libpcl.getpsymbol
    mov       rbx,	rax
    mov       rax,	[rbp + mm_assemaux.genasmopnd.p]
    movzx     rax,	byte [rax+62]
    cmp       rax,	43
    jz        L6470
    cmp       rax,	57
    jnz       L6469
L6470:
    mov       rax,	[rbp + mm_assemaux.genasmopnd.y]
    mov       rax,	[rax+16]
    jmp       L6468
L6469:
    mov       rax,	[rbp + mm_assemaux.genasmopnd.y]
    mov       rax,	[rax+16]
    neg       rax
L6468:
    mov       rsi,	rax
    movzx     rax,	byte [rbx+72]
    cmp       rax,	6
    jnz       L6472
    mov       rcx,	rbx
    call      mm_assemaux.fixasmlabel
    mov       r12,	rax
    mov       rcx,	r12
    call      mc_libmcl.mgenlabel
    mov       rdi,	rax
    jmp       L6471
L6472:
    mov       rcx,	rbx
    call      mc_libmcl.mgenmemaddr
    mov       rdi,	rax
L6471:
    mov       [rdi+12],	esi
    jmp       L6466
L6467:
    lea       rcx,	[L12910]
    xor       edx,	edx
    call      mm_support.gerror
L6466:
    jmp       L6433
L6440:
    call      msys.m$print_startcon
    mov       rax,	[rbp + mm_assemaux.genasmopnd.p]
    movzx     rax,	byte [rax]
    lea       r10,	[mm_tables.jtagnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L12911]
    xor       edx,	edx
    call      mm_support.gerror
L6433:
    mov       rax,	rdi
L6430:
;---------------
    add       rsp,	48
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_assemaux.fixasmlabel
mm_assemaux.fixasmlabel:
;?>>
   %define R.d rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    movsxd    rax,	dword [rdi+100]
    test      rax,	rax
    jnz       L6475
    lea       rcx,	[L12912]
    xor       edx,	edx
    call      mm_support.gerror
L6475:
    movsxd    rax,	dword [rdi+100]
L6473:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_assemaux.checkasmlabel
mm_assemaux.checkasmlabel:
;?>>
   %define R.p rcx
   %define R.q rdi
   %define R.d rbx
    push      rdi
    push      rbx
;?]]
;---------------
    mov       rdi,	[rcx+16]
    test      rdi,	rdi
    jz        L6478
    movzx     rax,	byte [rdi]
    cmp       rax,	4
    jnz       L6478
    mov       rbx,	[rdi+16]
    movzx     rax,	byte [rbx+78]
    cmp       rax,	14
    jnz       L6480
    movsxd    rax,	dword [rbx+80]
    jmp       L6476
L6480:
L6478:
    xor       eax,	eax
L6476:
;---------------
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_diags.printst
mm_diags.printst:
;?>>
   %define R.f rbx
   %define R.p rsi
   %define R.level r12
   %define R.q rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
;---------------
    mov       rcx,	rbx
    mov       rdx,	rsi
    mov       r8,	r12
    call      mm_diags.printstrec
    mov       rdi,	[rsi+16]
    jmp       L6483
L6482:
    lea       rax,	[r12+1]
    mov       rcx,	rbx
    mov       rdx,	rdi
    mov       r8,	rax
    call      mm_diags.printst
    mov       rdi,	[rdi+32]
L6483:
    test      rdi,	rdi
    jnz       L6482
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_diags.printstrec
mm_diags.printstrec:
;?>>
   %define R.f r13
    %define mm_diags.printstrec.p 72
    %define mm_diags.printstrec.level 80
    %define mm_diags.printstrec.dd -176
    %define mm_diags.printstrec.v -192
   %define R.d rdi
   %define R.col rbx
   %define R.offset rsi
    %define mm_diags.printstrec.str -448
   %define R.av_1 r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	480
    mov       r13,	rcx
    mov       [rbp+72],	rdx
    mov       [rbp+80],	r8
;---------------
    lea       rax,	[rbp + mm_diags.printstrec.v]
    mov       rdi,	rax
    mov       rcx,	rdi
    call      mlib.gs_init
    lea       rcx,	[rbp + mm_diags.printstrec.str]
    call      msys.m$print_startstr
    mov       rcx,	[rbp + mm_diags.printstrec.p]
    call      msys.m$print_ptr_nf
    call      msys.m$print_end
    mov       rcx,	rdi
    lea       rdx,	[rbp + mm_diags.printstrec.str]
    call      mlib.gs_str
    mov       rcx,	rdi
    lea       rdx,	[L12913]
    call      mlib.gs_str
    xor       rsi,	rsi
    mov       rax,	[rbp + mm_diags.printstrec.level]
    mov       r12,	rax
    cmp       r12,	0
    jle       L6488
L6486:
    mov       rcx,	rdi
    lea       rdx,	[L12914]
    call      mlib.gs_str
    mov       rax,	4
    add       rsi,	rax
    dec       r12
    jnz       L6486
L6488:
    mov       rcx,	rdi
    lea       rdx,	[L12915]
    call      mlib.gs_str
    mov       rax,	28
    sub       rax,	rsi
    mov       r10,	[rbp + mm_diags.printstrec.p]
    mov       r10,	[r10]
    mov       rcx,	rdi
    mov       rdx,	r10
    mov       r8,	rax
    mov       r9,	45
    call      mlib.gs_leftstr
    mov       rax,	[rbp + mm_diags.printstrec.p]
    movzx     rax,	byte [rax+78]
    lea       r10,	[mm_tables.namenames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	rdi
    mov       rdx,	r10
    mov       r8,	12
    mov       r9,	46
    call      mlib.gs_leftstr
    mov       rcx,	rdi
    call      mlib.gs_getcol
    mov       rbx,	rax
    mov       rax,	[rbp + mm_diags.printstrec.p]
    lea       r10,	[rbp + mm_diags.printstrec.dd]
    push      r10
    mov       r14,	22
L12916:
    mov       r11,	[rax]
    mov       [r10],	r11
    add       r10,	8
    add       rax,	8
    dec       r14
    jnz       L12916
    pop       r10
    mov       rcx,	rdi
    lea       rdx,	[L12917]
    call      mlib.gs_str
    mov       rax,	[rbp + mm_diags.printstrec.p]
    movzx     rax,	word [rax+92]
    shr       eax,	11
    and       eax,	1
    test      rax,	rax
    jz        L6490
    mov       rcx,	rdi
    lea       rdx,	[L12918]
    call      mlib.gs_str
    jmp       L6489
L6490:
    mov       rax,	[rbp + mm_diags.printstrec.p]
    movzx     rax,	byte [rax+170]
    lea       r10,	[mm_tables.scopenames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	rdi
    mov       rdx,	r10
    call      mlib.gs_str
    mov       rcx,	rdi
    lea       rdx,	[L12919]
    call      mlib.gs_str
L6489:
    movzx     rax,	word [rbp + mm_diags.printstrec.dd+92]
    and       eax,	1
    test      rax,	rax
    jz        L6492
    mov       rcx,	rdi
    lea       rdx,	[L12920]
    call      mlib.gs_str
L6492:
    movzx     rax,	byte [rbp + mm_diags.printstrec.dd+78]
    cmp       rax,	12
    jnz       L6494
    mov       al,	[rbp + mm_diags.printstrec.dd+160]
    test      al,	al
    jz        L6494
    movzx     rax,	byte [rbp + mm_diags.printstrec.dd+160]
    lea       r10,	[mm_tables.parammodenames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	rdi
    mov       rdx,	r10
    call      mlib.gs_str
L6494:
    mov       al,	[rbp + mm_diags.printstrec.dd+149]
    test      al,	al
    jz        L6496
    mov       rcx,	rdi
    lea       rdx,	[L12921]
    call      mlib.gs_str
    movzx     rax,	byte [rbp + mm_diags.printstrec.dd+149]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.gs_strint
    mov       rcx,	rdi
    lea       rdx,	[L12922]
    call      mlib.gs_str
    movsx     rax,	word [rbp + mm_diags.printstrec.dd+166]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.gs_strint
    mov       rcx,	rdi
    lea       rdx,	[L12923]
    call      mlib.gs_str
L6496:
    mov       al,	[rbp + mm_diags.printstrec.dd+161]
    test      al,	al
    jz        L6498
    mov       rcx,	rdi
    lea       rdx,	[L12924]
    call      mlib.gs_str
L6498:
    mov       al,	[rbp + mm_diags.printstrec.dd+123]
    test      al,	al
    jz        L6500
    mov       rcx,	rdi
    lea       rdx,	[L12925]
    call      mlib.gs_str
    movzx     rax,	byte [rbp + mm_diags.printstrec.dd+123]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.gs_strint
    mov       rcx,	rdi
    lea       rdx,	[L12926]
    call      mlib.gs_str
L6500:
    mov       al,	[rbp + mm_diags.printstrec.dd+94]
    test      al,	al
    jz        L6502
    movzx     rax,	byte [rbp + mm_diags.printstrec.dd+78]
    cmp       rax,	2
    jz        L6504
    lea       rcx,	[rbp + mm_diags.printstrec.str]
    call      msys.m$print_startstr
    lea       rcx,	[L12927]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    movzx     rax,	byte [rbp + mm_diags.printstrec.dd+94]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L6503
L6504:
    lea       rcx,	[rbp + mm_diags.printstrec.str]
    call      msys.m$print_startstr
    lea       rcx,	[L12928]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    movzx     rax,	byte [rbp + mm_diags.printstrec.dd+95]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
L6503:
    mov       rcx,	rdi
    lea       rdx,	[rbp + mm_diags.printstrec.str]
    call      mlib.gs_str
L6502:
    mov       ax,	[rbp + mm_diags.printstrec.dd+168]
    test      ax,	ax
    jz        L6506
    mov       rcx,	rdi
    lea       rdx,	[L12929]
    call      mlib.gs_str
L6506:
    mov       al,	[rbp + mm_diags.printstrec.dd+124]
    test      al,	al
    jz        L6508
    mov       rcx,	rdi
    lea       rdx,	[L12930]
    call      mlib.gs_str
L6508:
    mov       rcx,	rdi
    lea       rdx,	[L12931]
    call      mlib.gs_str
    lea       rax,	[rbx+10]
    mov       rcx,	rdi
    mov       rdx,	rax
    mov       r8,	61
    call      mlib.gs_padto
    mov       rax,	[rbp + mm_diags.printstrec.p]
    mov       rax,	[rax+8]
    test      rax,	rax
    jz        L6510
    lea       rcx,	[rbp + mm_diags.printstrec.str]
    call      msys.m$print_startstr
    lea       rcx,	[L12932]
    call      msys.m$print_setfmt
    mov       rax,	[rbp + mm_diags.printstrec.p]
    mov       rax,	[rax+8]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       rcx,	rdi
    lea       rdx,	[rbp + mm_diags.printstrec.str]
    mov       r8,	18
    mov       r9,	45
    call      mlib.gs_leftstr
    jmp       L6509
L6510:
    mov       rcx,	rdi
    lea       rdx,	[L12933]
    mov       r8,	18
    mov       r9,	45
    call      mlib.gs_leftstr
L6509:
    mov       rax,	[rbp + mm_diags.printstrec.p]
    movsxd    rax,	dword [rax+72]
    test      rax,	rax
    jnz       L6513
L6512:
    mov       rcx,	rdi
    lea       rdx,	[L12934]
    call      mlib.gs_str
    jmp       L6511
L6513:
    mov       rax,	[rbp + mm_diags.printstrec.p]
    movsxd    rax,	dword [rax+72]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.gs_strint
    mov       rcx,	rdi
    lea       rdx,	[L12935]
    call      mlib.gs_str
    mov       rax,	[rbp + mm_diags.printstrec.p]
    movsxd    rax,	dword [rax+72]
    mov       rcx,	rax
    mov       rdx,	1
    call      mm_lib.strmode
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.gs_str
    mov       rcx,	rdi
    lea       rdx,	[L12936]
    call      mlib.gs_str
L6511:
    mov       rax,	[rbp + mm_diags.printstrec.p]
    movzx     rax,	byte [rax+78]
    cmp       rax,	13
    jz        L6515
    cmp       rax,	12
    jz        L6515
    cmp       rax,	6
    jz        L6516
    cmp       rax,	7
    jz        L6517
    cmp       rax,	10
    jz        L6518
    cmp       rax,	11
    jz        L6519
    cmp       rax,	9
    jz        L6520
    cmp       rax,	5
    jz        L6521
    jmp       L6522
L6515:
    mov       rcx,	rdi
    lea       rdx,	[L12937]
    call      mlib.gs_str
    mov       rax,	[rbp + mm_diags.printstrec.p]
    movsxd    rax,	dword [rax+84]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.gs_strint
    mov       rax,	[rbp + mm_diags.printstrec.p]
    movsxd    rax,	dword [rax+72]
    cmp       rax,	27
    jnz       L6524
    mov       rcx,	rdi
    lea       rdx,	[L12938]
    call      mlib.gs_str
    mov       rax,	[rbp + mm_diags.printstrec.p]
    movzx     rax,	byte [rax+150]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.gs_strint
    mov       rcx,	rdi
    lea       rdx,	[L12939]
    call      mlib.gs_str
    mov       rax,	[rbp + mm_diags.printstrec.p]
    movzx     rax,	byte [rax+148]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.gs_strint
L6524:
    mov       rax,	[rbp + mm_diags.printstrec.p]
    lea       rax,	[rax+136]
    mov       r10,	[rbp + mm_diags.printstrec.p]
    movzx     r10,	byte [r10+143]
    lea       rcx,	[rbp + mm_diags.printstrec.str]
    lea       rdx,	[L12940]
    mov       r8,	r10
    mov       r9,	rax
    call      sprintf
    lea       rcx,	[rbp + mm_diags.printstrec.str]
    call      msys.m$print_startstr
    mov       rax,	[rbp + mm_diags.printstrec.p]
    movzx     rax,	byte [rax+143]
    mov       rcx,	rax
    lea       rdx,	[L12941]
    call      msys.m$print_i64
    mov       rax,	[rbp + mm_diags.printstrec.p]
    lea       rax,	[rax+136]
    mov       rcx,	rax
    lea       rdx,	[L12942]
    call      msys.m$print_str
    call      msys.m$print_end
    mov       rcx,	rdi
    lea       rdx,	[L12943]
    call      mlib.gs_str
    mov       rcx,	rdi
    lea       rdx,	[rbp + mm_diags.printstrec.str]
    call      mlib.gs_str
    mov       rcx,	rdi
    lea       rdx,	[L12944]
    call      mlib.gs_str
    mov       rax,	[rbp + mm_diags.printstrec.p]
    movzx     rax,	byte [rax+143]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.gs_strint
    mov       rax,	[rbp + mm_diags.printstrec.p]
    mov       rax,	[rax+64]
    test      rax,	rax
    jz        L6526
    mov       rcx,	rdi
    lea       rdx,	[L12945]
    call      mlib.gs_str
    mov       rax,	[rbp + mm_diags.printstrec.p]
    mov       rax,	[rax+64]
    mov       rcx,	rax
    call      mm_lib.strexpr
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.gs_strvar
L6526:
    mov       rax,	[rbp + mm_diags.printstrec.p]
    movzx     rax,	byte [rax+78]
    cmp       rax,	12
    jnz       L6528
    mov       rax,	[rbp + mm_diags.printstrec.p]
    mov       al,	[rax+162]
    test      al,	al
    jz        L6528
    mov       rcx,	rdi
    lea       rdx,	[L12946]
    call      mlib.gs_str
L6528:
    jmp       L6514
L6516:
    mov       rcx,	rdi
    lea       rdx,	[L12947]
    call      mlib.gs_str
    mov       rax,	[rbp + mm_diags.printstrec.p]
    movsxd    rax,	dword [rax+80]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.gs_strint
    mov       rcx,	rdi
    lea       rdx,	[L12948]
    call      mlib.gs_str
    mov       rax,	[rbp + mm_diags.printstrec.p]
    movzx     rax,	byte [rax+122]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.gs_strint
    jmp       L6514
L6517:
    mov       rcx,	rdi
    lea       rdx,	[L12949]
    call      mlib.gs_str
    mov       rax,	[rbp + mm_diags.printstrec.p]
    movsxd    rax,	dword [rax+80]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.gs_strint
    mov       rax,	[rbp + mm_diags.printstrec.p]
    mov       rax,	[rax+104]
    test      rax,	rax
    jz        L6530
    mov       rcx,	rdi
    lea       rdx,	[L12950]
    call      mlib.gs_str
    mov       rax,	[rbp + mm_diags.printstrec.p]
    mov       rax,	[rax+104]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.gs_str
L6530:
    jmp       L6514
L6518:
    mov       rax,	[rbp + mm_diags.printstrec.p]
    mov       rax,	[rax+64]
    test      rax,	rax
    jz        L6532
    mov       rcx,	rdi
    lea       rdx,	[L12951]
    call      mlib.gs_str
    mov       rax,	[rbp + mm_diags.printstrec.p]
    mov       rax,	[rax+64]
    mov       rcx,	rax
    call      mm_lib.strexpr
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.gs_strvar
L6532:
    jmp       L6514
L6519:
    mov       rax,	[rbp + mm_diags.printstrec.p]
    mov       rax,	[rax+64]
    test      rax,	rax
    jz        L6534
    mov       rcx,	rdi
    lea       rdx,	[L12952]
    call      mlib.gs_str
    mov       rax,	[rbp + mm_diags.printstrec.p]
    mov       rax,	[rax+64]
    mov       rcx,	rax
    call      mm_lib.strexpr
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.gs_strvar
L6534:
    jmp       L6514
L6520:
    mov       rcx,	rdi
    lea       rdx,	[L12953]
    call      mlib.gs_str
    mov       rax,	[rbp + mm_diags.printstrec.p]
    mov       rax,	[rax+64]
    mov       rcx,	rax
    call      mm_lib.strexpr
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.gs_strvar
    jmp       L6514
L6521:
    mov       rax,	[rbp + mm_diags.printstrec.p]
    mov       eax,	[rax+144]
    test      eax,	eax
    jz        L6536
    mov       rcx,	rdi
    lea       rdx,	[L12954]
    call      mlib.gs_str
    mov       rcx,	rdi
    lea       rdx,	[L12955]
    call      mlib.gs_str
L6536:
L6522:
L6514:
    mov       rax,	[rbp + mm_diags.printstrec.p]
    movzx     rax,	word [rax+92]
    shr       eax,	7
    and       eax,	1
    test      rax,	rax
    jz        L6538
    mov       rcx,	rdi
    lea       rdx,	[L12956]
    call      mlib.gs_str
    mov       rax,	[rbp + mm_diags.printstrec.p]
    mov       rax,	[rax+128]
    mov       rax,	[rax]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.gs_str
    mov       rcx,	rdi
    lea       rdx,	[L12957]
    call      mlib.gs_str
    mov       rax,	[rbp + mm_diags.printstrec.p]
    movzx     rax,	byte [rax+151]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.gs_strint
L6538:
    mov       rax,	[rbp + mm_diags.printstrec.p]
    movzx     rax,	word [rax+92]
    shr       eax,	8
    and       eax,	1
    test      rax,	rax
    jz        L6540
    mov       rax,	[rbp + mm_diags.printstrec.p]
    mov       rax,	[rax+96]
    mov       rcx,	rax
    call      mm_lib.strexpr
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.gs_strvar
L6540:
    mov       rcx,	rdi
    lea       rdx,	[L12958]
    call      mlib.gs_str
    mov       rcx,	rdi
    mov       rdx,	r13
    call      mlib.gs_println
    mov       rax,	[rbp + mm_diags.printstrec.p]
    movzx     rax,	byte [rax+78]
    cmp       rax,	9
    jz        L6542
    cmp       rax,	11
    jz        L6542
    cmp       rax,	10
    jz        L6542
    cmp       rax,	15
    jnz       L6543
L6542:
    mov       rax,	[rbp + mm_diags.printstrec.p]
    mov       rax,	[rax+64]
    test      rax,	rax
    jz        L6545
    mov       rax,	[rbp + mm_diags.printstrec.p]
    mov       rax,	[rax+64]
    mov       rcx,	rax
    xor       edx,	edx
    lea       r8,	[L12959]
    mov       r9,	r13
    call      mm_diags.printunit
L6545:
L6543:
L6541:
;---------------
    add       rsp,	480
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_diags.printstflat
mm_diags.printstflat:
;?>>
   %define R.f r12
   %define R.p rdi
   %define R.av_1 rbx
   %define R.i rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       r12,	rcx
;---------------
    mov       rcx,	r12
    call      msys.m$print_startfile
    lea       rcx,	[L12960]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    xor       rsi,	rsi
    mov       rax,	65534
    mov       rbx,	rax
    cmp       rbx,	0
    jl        L6549
L6547:
    lea       rax,	[mm_lex.hashtable]
    mov       r10,	rsi
    mov       rdi,	[rax + r10*8]
    test      rdi,	rdi
    jnz       L6551
    jmp       L6548
L6551:
    movzx     rax,	byte [rdi+77]
    cmp       rax,	67
    jnz       L6554
L6553:
    mov       rcx,	r12
    call      msys.m$print_startfile
    mov       rcx,	rsi
    lea       rdx,	[L12961]
    call      msys.m$print_i64
    mov       rcx,	rdi
    call      msys.m$print_ptr_nf
    mov       rcx,	[rdi]
    call      msys.m$print_str_nf
    movzx     rax,	byte [rdi+77]
    lea       r10,	[mm_tables.symbolnames]
    mov       r10,	[r10 + rax*8-8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rcx,	[L12962]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    movzx     rax,	byte [rdi+78]
    lea       r10,	[mm_tables.namenames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rdi,	[rdi+40]
    jmp       L6556
L6555:
    mov       rcx,	r12
    call      msys.m$print_startfile
    lea       rcx,	[L12963]
    call      msys.m$print_str_nf
    mov       rcx,	rdi
    call      msys.m$print_ptr_nf
    mov       rcx,	[rdi]
    call      msys.m$print_str_nf
    movzx     rax,	byte [rdi+77]
    lea       r10,	[mm_tables.symbolnames]
    mov       r10,	[r10 + rax*8-8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rcx,	[L12964]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    movzx     rax,	byte [rdi+78]
    lea       r10,	[mm_tables.namenames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       rax,	[rdi+8]
    test      rax,	rax
    jz        L6559
    mov       rcx,	r12
    call      msys.m$print_startfile
    lea       rcx,	[L12965]
    call      msys.m$print_setfmt
    mov       rax,	[rdi+8]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    mov       rax,	[rdi+8]
    movzx     rax,	byte [rax+78]
    lea       r10,	[mm_tables.namenames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_end
L6559:
    mov       rcx,	r12
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rdi,	[rdi+40]
L6556:
    test      rdi,	rdi
    jnz       L6555
L6554:
L6552:
L6548:
    inc       rsi
    cmp       rsi,	rbx
    jle       L6547
L6549:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_diags.printcode
mm_diags.printcode:
;?>>
   %define R.f rsi
    %define mm_diags.printcode.caption 48
   %define R.p rdi
   %define R.pp rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    mov       rbx,	[mm_decls.proclist]
    jmp       L6562
L6561:
    mov       rdi,	[rbx]
    mov       rcx,	rsi
    call      msys.m$print_startfile
    mov       rcx,	[rdi]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rcx,	[L12966]
    call      msys.m$print_str_nf
    movzx     rax,	byte [rdi+170]
    sub       rax,	1
    cmp       rax,	3
    jae       L6566
    lea       r10,	[L6565]
    jmp       [r10 + rax*8]
    segment .data
L6565:
    dq  L6567
    dq  L6568
    dq  L6569
    segment .text
L6567:
    lea       rax,	[L12967]
    jmp       L6564
L6568:
    lea       rax,	[L12968]
    jmp       L6564
L6569:
    lea       rax,	[L12969]
    jmp       L6564
L6566:
    lea       rax,	[L12970]
L6564:
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       rax,	[rdi+8]
    movzx     rax,	byte [rax+78]
    cmp       rax,	5
    jnz       L6571
    mov       rcx,	rsi
    call      msys.m$print_startfile
    lea       rcx,	[L12971]
    call      msys.m$print_str_nf
    mov       rax,	[rdi+8]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    call      msys.m$print_end
L6571:
    mov       rcx,	rsi
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rax,	[rdi+64]
    mov       rcx,	rax
    xor       edx,	edx
    lea       r8,	[L12972]
    mov       r9,	rsi
    call      mm_diags.printunit
    mov       rcx,	rsi
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rbx,	[rbx+8]
L6562:
    test      rbx,	rbx
    jnz       L6561
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_diags.printunit
mm_diags.printunit:
;?>>
   %define R.p r13
   %define R.level r14
    %define mm_diags.printunit.prefix 88
    %define mm_diags.printunit.dev 96
   %define R.d rdi
   %define R.t rbx
   %define R.idname rsi
   %define R.a r12
    %define mm_diags.printunit.av_1 -8
    %define mm_diags.printunit.av_2 -16
    %define mm_diags.printunit.i -24
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
    mov       r13,	rcx
    mov       r14,	rdx
    mov       [rbp+88],	r8
    mov       [rbp+96],	r9
;---------------
    test      r13,	r13
    jnz       L6574
    jmp       L6572
L6574:
    mov       eax,	[r13+4]
    test      eax,	eax
    jz        L6576
    mov       eax,	[r13+4]
    mov       rcx,	rax
    call      mm_support.getlineno
    mov       [mm_diags.currlineno],	rax
    mov       eax,	[r13+4]
    shr       rax,	24
    and       rax,	255
    mov       [mm_diags.currfileno],	rax
L6576:
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    mov       rcx,	r13
    call      msys.m$print_ptr_nf
    lea       rcx,	[L12973]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    mov       rcx,	r14
    mov       rdx,	[rbp + mm_diags.printunit.prefix]
    mov       r8,	r13
    call      mm_diags.getprefix
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
    movzx     rax,	byte [r13]
    lea       r10,	[mm_tables.jtagnames]
    mov       r10,	[r10 + rax*8]
    mov       rsi,	r10
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    mov       rcx,	rsi
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rcx,	[L12974]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    movzx     rax,	byte [r13]
    cmp       rax,	4
    jz        L6578
    cmp       rax,	100
    jz        L6579
    cmp       rax,	1
    jz        L6580
    cmp       rax,	7
    jz        L6581
    cmp       rax,	62
    jz        L6582
    cmp       rax,	68
    jz        L6583
    cmp       rax,	58
    jz        L6584
    cmp       rax,	61
    jz        L6584
    cmp       rax,	20
    jz        L6585
    cmp       rax,	49
    jz        L6586
    cmp       rax,	46
    jz        L6587
    cmp       rax,	53
    jz        L6587
    cmp       rax,	103
    jz        L6588
    cmp       rax,	101
    jz        L6588
    cmp       rax,	102
    jz        L6588
    cmp       rax,	90
    jz        L6589
    cmp       rax,	8
    jz        L6590
    cmp       rax,	10
    jz        L6591
    cmp       rax,	11
    jz        L6592
    cmp       rax,	12
    jz        L6593
    cmp       rax,	22
    jz        L6594
    cmp       rax,	34
    jz        L6595
    jmp       L6596
L6578:
    mov       rdi,	[r13+16]
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    mov       rcx,	[rdi]
    call      msys.m$print_str_nf
    movzx     rax,	byte [rdi+78]
    lea       r10,	[mm_tables.namenames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       rax,	[rdi+64]
    test      rax,	rax
    jz        L6598
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L12975]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       rax,	[rdi+64]
    movzx     rax,	byte [rax]
    lea       r10,	[mm_tables.jtagnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rcx,	[L12976]
    call      msys.m$print_str_nf
    call      msys.m$print_end
L6598:
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L12977]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       rcx,	rdi
    call      mm_lib.getdottedname
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    mov       al,	[r13+40]
    test      al,	al
    jz        L6600
    lea       rax,	[L12978]
    jmp       L6599
L6600:
    lea       rax,	[L12979]
L6599:
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       rax,	[r13+32]
    test      rax,	rax
    jz        L6602
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L12980]
    call      msys.m$print_str_nf
    mov       rcx,	[r13+32]
    call      msys.m$print_ptr_nf
    call      msys.m$print_end
L6602:
    mov       al,	[r13+40]
    test      al,	al
    jz        L6604
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L12981]
    call      msys.m$print_str_nf
    call      msys.m$print_end
L6604:
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L12982]
    call      msys.m$print_str_nf
    movzx     rax,	byte [r13+57]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    mov       al,	[r13+41]
    test      al,	al
    jz        L6606
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L12983]
    call      msys.m$print_str_nf
    mov       al,	[r13+41]
    mov       cl,	al
    xor       edx,	edx
    call      msys.m$print_c8
    call      msys.m$print_end
L6606:
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L12984]
    call      msys.m$print_str_nf
    movsxd    rax,	dword [r13+40]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L6577
L6579:
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    mov       rax,	[r13+16]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L6577
L6580:
    movsxd    rax,	dword [r13+49]
    mov       rbx,	rax
    mov       r12,	[r13+16]
    cmp       rbx,	20
    jnz       L6608
    mov       eax,	[r13+40]
    cmp       rax,	256
    jle       L6610
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L12985]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rcx,	[L12986]
    call      msys.m$print_str_nf
    lea       rcx,	[L12987]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       eax,	[r13+40]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L6609
L6610:
    mov       eax,	[r13+40]
    test      eax,	eax
    jz        L6611
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L12988]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       rcx,	[r13+16]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rcx,	[L12989]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       eax,	[r13+40]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L6609
L6611:
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L12990]
    call      msys.m$print_str_nf
    call      msys.m$print_end
L6609:
    jmp       L6607
L6608:
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rbx
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	3
    jz        L6613
    cmp       rax,	16
    jz        L6613
    cmp       rax,	15
    jz        L6613
    cmp       rax,	14
    jz        L6613
    cmp       rax,	4
    jz        L6614
    cmp       rax,	19
    jz        L6614
    cmp       rax,	18
    jz        L6614
    cmp       rax,	17
    jz        L6614
    cmp       rax,	5
    jz        L6615
    cmp       rax,	12
    jz        L6615
    cmp       rax,	2
    jz        L6616
    cmp       rax,	1
    jz        L6616
    cmp       rax,	7
    jz        L6617
    cmp       rax,	6
    jz        L6618
    cmp       rax,	10
    jz        L6619
    jmp       L6620
L6613:
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    mov       rcx,	r12
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L6612
L6614:
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    mov       rcx,	r12
    xor       edx,	edx
    call      msys.m$print_u64
    call      msys.m$print_end
    jmp       L6612
L6615:
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    mov       rcx,	r12
    call      mlib.chr
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L6612
L6616:
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    movq      XMM4,	[r13+16]
    movq      XMM0,	XMM4
    xor       edx,	edx
    call      msys.m$print_r64
    call      msys.m$print_end
    jmp       L6612
L6617:
    mov       rax,	[r13+16]
    test      rax,	rax
    jz        L6622
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L12991]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       rcx,	[r13+16]
    call      msys.m$print_i64_nf
    mov       eax,	[r13+40]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L6621
L6622:
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L12992]
    call      msys.m$print_str_nf
    call      msys.m$print_end
L6621:
    jmp       L6612
L6618:
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    mov       rax,	[r13+16]
    test      rax,	rax
    jz        L6624
    lea       rax,	[L12993]
    jmp       L6623
L6624:
    lea       rax,	[L12994]
L6623:
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L6612
L6619:
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L12995]
    call      msys.m$print_str_nf
    lea       rcx,	[L12996]
    call      msys.m$print_str_nf
    movzx     rax,	byte [r13+45]
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.m$print_c8
    lea       rcx,	[L12997]
    call      msys.m$print_str_nf
    mov       eax,	[r13+40]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L6612
L6620:
    call      msys.m$print_startcon
    lea       rcx,	[L12998]
    call      msys.m$print_str_nf
    mov       rcx,	rbx
    call      mm_lib.typename
    mov       rcx,	rax
    call      msys.m$print_str_nf
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rbx
    movsxd    rax,	dword [rax + r10*4]
    mov       rcx,	rax
    call      mm_lib.typename
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L12999]
    call      msys.m$print_str_nf
    call      msys.m$print_end
L6612:
L6607:
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L13000]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       rcx,	rbx
    call      mm_lib.typename
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       al,	[r13+44]
    test      al,	al
    jz        L6626
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L13001]
    call      msys.m$print_setfmt
    movzx     rax,	byte [r13+45]
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.m$print_c8
    call      msys.m$print_end
L6626:
    mov       eax,	[r13+40]
    test      eax,	eax
    jz        L6628
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L13002]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    movsxd    rax,	dword [r13+40]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
L6628:
    jmp       L6577
L6581:
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    mov       rcx,	[r13+16]
    call      msys.m$print_str_nf
    lea       rcx,	[L13003]
    call      msys.m$print_str_nf
    mov       eax,	[r13+40]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L6577
L6582:
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    movsxd    rax,	dword [r13+49]
    mov       rcx,	rax
    call      mm_lib.typename
    mov       rcx,	rax
    call      msys.m$print_str_nf
    mov       rax,	[r13+16]
    mov       rcx,	rax
    call      mm_lib.typename
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L6577
L6583:
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    movsx     rax,	word [r13+40]
    lea       r10,	[mm_tables.bitfieldnames]
    mov       r10,	[r10 + rax*8-8]
    lea       r10,	[r10+3]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L6577
L6584:
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L13004]
    call      msys.m$print_str_nf
    movsxd    rax,	dword [r13+53]
    mov       rcx,	rax
    mov       rdx,	1
    call      mm_lib.strmode
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L6577
L6585:
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L13005]
    call      msys.m$print_str_nf
    mov       eax,	[r13+40]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    lea       rcx,	[L13006]
    call      msys.m$print_str_nf
    movzx     rax,	byte [r13+40]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L6577
L6586:
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L13007]
    call      msys.m$print_str_nf
    mov       eax,	[r13+40]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L6577
L6587:
    jmp       L6577
L6588:
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L13008]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    movsxd    rax,	dword [r13+40]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L6577
L6589:
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    movsx     rax,	word [r13+40]
    lea       r10,	[mm_tables.sysfnnames]
    mov       r10,	[r10 + rax*8-8]
    lea       r10,	[r10+3]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L6577
L6590:
    jmp       L6577
L6591:
    jmp       L6577
L6592:
    jmp       L6577
L6593:
    jmp       L6577
L6594:
    jmp       L6577
L6595:
    mov       rax,	1
    mov       [rbp + mm_diags.printunit.i],	rax
    mov       rax,	4
    mov       [rbp + mm_diags.printunit.av_1],	rax
    mov       rax,	[rbp + mm_diags.printunit.av_1]
    cmp       rax,	1
    jl        L6631
L6629:
    lea       rax,	[r13+40]
    mov       r10,	[rbp + mm_diags.printunit.i]
    movzx     rax,	byte [rax + r10-1]
    test      rax,	rax
    jz        L6631
L6633:
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    lea       rax,	[r13+40]
    mov       r10,	[rbp + mm_diags.printunit.i]
    movzx     rax,	byte [rax + r10-1]
    lea       r10,	[pc_tables.ccnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rcx,	[L13009]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       rax,	[rbp + mm_diags.printunit.i]
    inc       rax
    mov       [rbp + mm_diags.printunit.i],	rax
    cmp       rax,	[rbp + mm_diags.printunit.av_1]
    jle       L6629
L6631:
L6596:
L6577:
    mov       al,	[r13+60]
    test      al,	al
    jz        L6635
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L13010]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L6634
L6635:
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L13011]
    call      msys.m$print_str_nf
    call      msys.m$print_end
L6634:
    movzx     rax,	byte [r13]
    cmp       rax,	35
    jz        L6637
    cmp       rax,	38
    jz        L6637
    cmp       rax,	36
    jz        L6637
    cmp       rax,	39
    jz        L6637
    cmp       rax,	40
    jz        L6637
    cmp       rax,	15
    jz        L6637
    cmp       rax,	16
    jz        L6637
    cmp       rax,	17
    jz        L6637
    cmp       rax,	18
    jz        L6637
    cmp       rax,	37
    jz        L6638
    cmp       rax,	58
    jz        L6639
    cmp       rax,	33
    jz        L6640
    jmp       L6641
L6637:
    mov       al,	[r13+62]
    test      al,	al
    jz        L6643
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L13012]
    call      msys.m$print_setfmt
    movzx     rax,	byte [r13+62]
    lea       r10,	[pc_tables.pclnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L6642
L6643:
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L13013]
    call      msys.m$print_setfmt
    call      msys.m$print_end
L6642:
    jmp       L6636
L6638:
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L13014]
    call      msys.m$print_setfmt
    movzx     rax,	byte [r13+62]
    lea       r10,	[mm_tables.propnames]
    mov       r10,	[r10 + rax*8-8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L6636
L6639:
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L13015]
    call      msys.m$print_setfmt
    movzx     rax,	byte [r13+62]
    lea       r10,	[mm_tables.convnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L6636
L6640:
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L13016]
    call      msys.m$print_setfmt
    movzx     rax,	byte [r13+64]
    lea       r10,	[pc_tables.ccnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_end
L6641:
L6636:
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rax,	1
    mov       [rbp + mm_diags.printunit.i],	rax
    movzx     rax,	byte [r13]
    lea       r10,	[mm_tables.jsubs]
    movzx     r10,	byte [r10 + rax]
    mov       [rbp + mm_diags.printunit.av_2],	r10
    mov       rax,	[rbp + mm_diags.printunit.av_2]
    cmp       rax,	1
    jl        L6646
L6644:
    mov       rcx,	[rbp + mm_diags.printunit.i]
    xor       edx,	edx
    call      msys.strint
    lea       r10,	[r14+1]
    lea       r11,	[r13+16]
    mov       r15,	[rbp + mm_diags.printunit.i]
    mov       r11,	[r11 + r15*8-8]
    mov       rcx,	[rbp + mm_diags.printunit.dev]
    mov       rdx,	r11
    mov       r8,	r10
    mov       r9,	rax
    call      mm_diags.printunitlist
    mov       rax,	[rbp + mm_diags.printunit.i]
    inc       rax
    mov       [rbp + mm_diags.printunit.i],	rax
    cmp       rax,	[rbp + mm_diags.printunit.av_2]
    jle       L6644
L6646:
L6572:
;---------------
    add       rsp,	56
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_diags.printunitlist
mm_diags.printunitlist:
;?>>
   %define R.dev rdi
   %define R.p rbx
   %define R.level rsi
   %define R.prefix r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
    mov       r12,	r9
;---------------
    test      rbx,	rbx
    jnz       L6649
    jmp       L6647
L6649:
    jmp       L6651
L6650:
    mov       rcx,	rbx
    mov       rdx,	rsi
    mov       r8,	r12
    mov       r9,	rdi
    call      mm_diags.printunit
    mov       rbx,	[rbx+8]
L6651:
    test      rbx,	rbx
    jnz       L6650
L6647:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_diags.getprefix
mm_diags.getprefix:
;?>>
   %define R.level rsi
   %define R.prefix r12
   %define R.p r13
    %define mm_diags.getprefix.indentstr -1024
    %define mm_diags.getprefix.modestr -17408
   %define R.isexpr rdi
   %define R.av_1 rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	17448
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
;---------------
    xor       eax,	eax
    mov       [rbp + mm_diags.getprefix.indentstr],	al
    cmp       rsi,	10
    jle       L6655
    mov       rsi,	10
L6655:
    mov       rbx,	rsi
    cmp       rbx,	0
    jle       L6658
L6656:
    lea       rcx,	[rbp + mm_diags.getprefix.indentstr]
    lea       rdx,	[L13017]
    call      strcat
    dec       rbx
    jnz       L6656
L6658:
    lea       rax,	[L13018]
    mov       rdi,	rax
    movzx     rax,	byte [r13]
    lea       r10,	[mm_tables.jisexpr]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L6660
    lea       rax,	[L13019]
    mov       rdi,	rax
L6660:
    movzx     rax,	byte [r13]
    cmp       rax,	92
    jz        L6662
    cmp       rax,	107
    jz        L6662
    cmp       rax,	105
    jz        L6662
    cmp       rax,	112
    jnz       L6663
L6662:
    movsxd    rax,	dword [r13+49]
    test      rax,	rax
    jnz       L6665
    lea       rax,	[L13020]
    mov       rdi,	rax
L6665:
L6663:
L6661:
    lea       rcx,	[rbp + mm_diags.getprefix.modestr]
    call      msys.m$print_startstr
    lea       rcx,	[L13021]
    call      msys.m$print_setfmt
    mov       rcx,	rdi
    call      msys.m$print_str_nf
    mov       al,	[r13+61]
    test      al,	al
    jz        L6667
    lea       rax,	[L13022]
    jmp       L6666
L6667:
    lea       rax,	[L13023]
L6666:
    mov       rcx,	rax
    call      msys.m$print_str_nf
    movsxd    rax,	dword [r13+49]
    mov       rcx,	rax
    mov       rdx,	1
    call      mm_lib.strmode
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
    xor       eax,	eax
    mov       [rbp + mm_diags.getprefix.modestr+255],	al
    lea       rcx,	[rbp + mm_diags.getprefix.modestr]
    lea       rdx,	[L13024]
    call      strcat
    mov       al,	32
    mov       [rbp + mm_diags.getprefix.modestr+16],	al
    xor       eax,	eax
    mov       [rbp + mm_diags.getprefix.modestr+17],	al
    call      mm_diags.getlineinfok
    lea       rcx,	[mm_diags.getprefix.str]
    mov       rdx,	rax
    call      strcpy
    lea       rcx,	[mm_diags.getprefix.str]
    lea       rdx,	[rbp + mm_diags.getprefix.modestr]
    call      strcat
    lea       rcx,	[mm_diags.getprefix.str]
    lea       rdx,	[rbp + mm_diags.getprefix.indentstr]
    call      strcat
    lea       rcx,	[mm_diags.getprefix.str]
    mov       rdx,	r12
    call      strcat
    mov       al,	[r12]
    test      al,	al
    jz        L6669
    lea       rcx,	[mm_diags.getprefix.str]
    lea       rdx,	[L13025]
    call      strcat
L6669:
    lea       rax,	[mm_diags.getprefix.str]
L6653:
;---------------
    add       rsp,	17448
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_diags.getlineinfok
mm_diags.getlineinfok:
;?>>
;?]]
    sub       rsp,	40
;---------------
    lea       rcx,	[mm_diags.getlineinfok.str]
    call      msys.m$print_startstr
    lea       rcx,	[L13026]
    call      msys.m$print_setfmt
    mov       rcx,	[mm_diags.currfileno]
    lea       rdx,	[L13027]
    call      msys.m$print_i64
    mov       rcx,	[mm_diags.currlineno]
    lea       rdx,	[L13028]
    call      msys.m$print_i64
    call      msys.m$print_end
    lea       rax,	[mm_diags.getlineinfok.str]
L6670:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mm_diags.printmodelist
mm_diags.printmodelist:
;?>>
   %define R.f r13
   %define R.mbase rdi
   %define R.av_1 rbx
   %define R.m rsi
   %define R.i r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r13,	rcx
;---------------
    mov       rcx,	r13
    call      msys.m$print_startfile
    lea       rcx,	[L13029]
    call      msys.m$print_str_nf
    mov       rcx,	[mm_decls.ntypes]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    xor       rsi,	rsi
    mov       rax,	[mm_decls.ntypes]
    cmp       rax,	0
    jl        L6674
L6672:
    mov       rcx,	r13
    call      msys.m$print_startfile
    mov       rcx,	rsi
    lea       rdx,	[L13030]
    call      msys.m$print_i64
    mov       rcx,	rsi
    mov       rdx,	1
    call      mm_lib.strmode
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rsi
    movsxd    rax,	dword [rax + r10*4]
    mov       rdi,	rax
    mov       rcx,	r13
    call      msys.m$print_startfile
    mov       rcx,	[mm_diags.printmodelist.tab]
    call      msys.m$print_str_nf
    lea       rcx,	[L13031]
    call      msys.m$print_str_nf
    mov       rcx,	rdi
    call      msys.m$print_i64_nf
    mov       rcx,	rdi
    mov       rdx,	1
    call      mm_lib.strmode
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	r13
    call      msys.m$print_startfile
    mov       rcx,	[mm_diags.printmodelist.tab]
    call      msys.m$print_str_nf
    lea       rcx,	[L13032]
    call      msys.m$print_str_nf
    lea       rax,	[mm_decls.ttname]
    mov       r10,	rsi
    mov       rcx,	[rax + r10*8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	r13
    call      msys.m$print_startfile
    mov       rcx,	[mm_diags.printmodelist.tab]
    call      msys.m$print_str_nf
    lea       rcx,	[L13033]
    call      msys.m$print_str_nf
    lea       rax,	[mm_decls.ttnamedef]
    mov       r10,	rsi
    mov       rcx,	[rax + r10*8]
    call      msys.m$print_ptr_nf
    lea       rax,	[mm_decls.ttnamedef]
    mov       r10,	rsi
    mov       rax,	[rax + r10*8]
    test      rax,	rax
    jz        L6676
    lea       rax,	[mm_decls.ttnamedef]
    mov       r10,	rsi
    mov       rax,	[rax + r10*8]
    mov       rax,	[rax]
    jmp       L6675
L6676:
    lea       rax,	[L13034]
L6675:
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	r13
    call      msys.m$print_startfile
    mov       rcx,	[mm_diags.printmodelist.tab]
    call      msys.m$print_str_nf
    lea       rcx,	[L13035]
    call      msys.m$print_str_nf
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	rsi
    movsxd    rax,	dword [rax + r10*4]
    mov       rcx,	rax
    mov       rdx,	1
    call      mm_lib.strmode
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	r13
    call      msys.m$print_startfile
    mov       rcx,	[mm_diags.printmodelist.tab]
    call      msys.m$print_str_nf
    lea       rcx,	[L13036]
    call      msys.m$print_str_nf
    lea       rax,	[mm_decls.ttsize]
    mov       r10,	rsi
    mov       eax,	[rax + r10*4]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    lea       rcx,	[L13037]
    call      msys.m$print_str_nf
    lea       rax,	[mm_decls.ttsizeset]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	r13
    call      msys.m$print_startfile
    lea       rcx,	[L13038]
    call      msys.m$print_setfmt
    mov       rcx,	[mm_diags.printmodelist.tab]
    call      msys.m$print_str_nf
    lea       rax,	[mm_decls.ttlower]
    mov       r10,	rsi
    movsxd    rax,	dword [rax + r10*4]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    lea       rax,	[mm_decls.ttlower]
    mov       r10,	rsi
    movsxd    rax,	dword [rax + r10*4]
    lea       r10,	[mm_decls.ttlength]
    mov       r11,	rsi
    movsxd    r10,	dword [r10 + r11*4]
    add       rax,	r10
    dec       rax
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    lea       rax,	[mm_decls.ttlength]
    mov       r10,	rsi
    movsxd    rax,	dword [rax + r10*4]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    cmp       rdi,	28
    jnz       L6678
    mov       rcx,	r13
    call      msys.m$print_startfile
    mov       rcx,	[mm_diags.printmodelist.tab]
    call      msys.m$print_str_nf
    lea       rcx,	[L13039]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       r12,	1
    lea       rax,	[mm_decls.ttlength]
    mov       r10,	rsi
    movsxd    rax,	dword [rax + r10*4]
    mov       rbx,	rax
    cmp       rbx,	1
    jl        L6681
L6679:
    mov       rcx,	r13
    call      msys.m$print_startfile
    lea       rax,	[mm_decls.ttmult]
    mov       r10,	rsi
    mov       rax,	[rax + r10*8]
    mov       r10,	r12
    movsxd    rax,	dword [rax + r10*4-4]
    mov       rcx,	rax
    mov       rdx,	1
    call      mm_lib.strmode
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rcx,	[L13040]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    inc       r12
    cmp       r12,	rbx
    jle       L6679
L6681:
    mov       rcx,	r13
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
L6678:
    mov       rcx,	r13
    call      msys.m$print_startfile
    mov       rcx,	[mm_diags.printmodelist.tab]
    call      msys.m$print_str_nf
    lea       rcx,	[L13041]
    call      msys.m$print_str_nf
    lea       rax,	[mm_decls.ttsigned]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	r13
    call      msys.m$print_startfile
    mov       rcx,	[mm_diags.printmodelist.tab]
    call      msys.m$print_str_nf
    lea       rcx,	[L13042]
    call      msys.m$print_str_nf
    lea       rax,	[mm_decls.ttisreal]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	r13
    call      msys.m$print_startfile
    mov       rcx,	[mm_diags.printmodelist.tab]
    call      msys.m$print_str_nf
    lea       rcx,	[L13043]
    call      msys.m$print_str_nf
    lea       rax,	[mm_decls.ttisinteger]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	r13
    call      msys.m$print_startfile
    mov       rcx,	[mm_diags.printmodelist.tab]
    call      msys.m$print_str_nf
    lea       rcx,	[L13044]
    call      msys.m$print_str_nf
    lea       rax,	[mm_decls.ttisshort]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	r13
    call      msys.m$print_startfile
    mov       rcx,	[mm_diags.printmodelist.tab]
    call      msys.m$print_str_nf
    lea       rcx,	[L13045]
    call      msys.m$print_str_nf
    lea       rax,	[mm_decls.ttisref]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	r13
    call      msys.m$print_startfile
    mov       rcx,	[mm_diags.printmodelist.tab]
    call      msys.m$print_str_nf
    lea       rcx,	[L13046]
    call      msys.m$print_str_nf
    lea       rax,	[mm_decls.ttisblock]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	r13
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
    inc       rsi
    cmp       rsi,	[mm_decls.ntypes]
    jle       L6672
L6674:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_diags.showprojectinfo
mm_diags.showprojectinfo:
;?>>
    %define mm_diags.showprojectinfo.dev 72
   %define R.pm rdi
   %define R.ps rbx
   %define R.s rsi
   %define R.isfirst r12b
   %define R.ismain r13b
   %define R.av_1 r14
   %define R.pf r15
    %define mm_diags.showprojectinfo.i -8
    %define mm_diags.showprojectinfo.j -16
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
    mov       [rbp+72],	rcx
;---------------
    mov       rcx,	[rbp + mm_diags.showprojectinfo.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L13047]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	[rbp + mm_diags.showprojectinfo.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L13048]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	[rbp + mm_diags.showprojectinfo.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L13049]
    call      msys.m$print_str_nf
    mov       rcx,	[mm_decls.nmodules]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rax,	1
    mov       [rbp + mm_diags.showprojectinfo.i],	rax
    mov       rax,	[mm_decls.nmodules]
    cmp       rax,	1
    jl        L6685
L6683:
    lea       rax,	[mm_decls.modules]
    mov       r10,	[rbp + mm_diags.showprojectinfo.i]
    mov       rdi,	[rax + r10*8]
    mov       rax,	[rbp + mm_diags.showprojectinfo.i]
    cmp       rax,	1
    jle       L6687
    movsx     rax,	word [rdi+18]
    lea       r10,	[mm_decls.modules]
    mov       r11,	[rbp + mm_diags.showprojectinfo.i]
    mov       r10,	[r10 + r11*8-8]
    movsx     r10,	word [r10+18]
    cmp       rax,	r10
    jz        L6687
    mov       rcx,	[rbp + mm_diags.showprojectinfo.dev]
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
L6687:
    lea       rax,	[mm_decls.moduletosub]
    mov       r10,	[rbp + mm_diags.showprojectinfo.i]
    movzx     rax,	byte [rax + r10]
    lea       r10,	[mm_decls.subprogs]
    mov       r10,	[r10 + rax*8]
    mov       rbx,	r10
    movsx     rax,	word [rbx+8]
    cmp       rax,	[rbp + mm_diags.showprojectinfo.i]
    setz      al
    movzx     eax,	al
    mov       r12b,	al
    movsx     rax,	word [rbx+10]
    cmp       rax,	[rbp + mm_diags.showprojectinfo.i]
    setz      al
    movzx     eax,	al
    mov       r13b,	al
    test      r12b,	r12b
    jz        L6689
    test      r13b,	r13b
    jz        L6689
    lea       rax,	[L13050]
    mov       rsi,	rax
    jmp       L6688
L6689:
    test      r12b,	r12b
    jz        L6690
    lea       rax,	[L13051]
    mov       rsi,	rax
    jmp       L6688
L6690:
    test      r13b,	r13b
    jz        L6691
    lea       rax,	[L13052]
    mov       rsi,	rax
    jmp       L6688
L6691:
    lea       rax,	[L13053]
    mov       rsi,	rax
L6688:
    mov       rcx,	[rbp + mm_diags.showprojectinfo.dev]
    call      msys.m$print_startfile
    mov       rcx,	[mm_diags.showprojectinfo.tab]
    call      msys.m$print_str_nf
    mov       rcx,	[rbp + mm_diags.showprojectinfo.i]
    lea       rdx,	[L13054]
    call      msys.m$print_i64
    mov       rcx,	rsi
    call      msys.m$print_str_nf
    mov       rax,	[rdi]
    mov       rcx,	rax
    lea       rdx,	[L13055]
    call      msys.m$print_str
    lea       rcx,	[L13056]
    call      msys.m$print_str_nf
    movzx     rax,	byte [rdi+22]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    lea       rcx,	[L13057]
    call      msys.m$print_str_nf
    movsx     rax,	word [rdi+18]
    lea       r10,	[mm_decls.subprogs]
    mov       r10,	[r10 + rax*8]
    mov       r10,	[r10]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    lea       rcx,	[L13058]
    call      msys.m$print_str_nf
    movsx     rax,	word [rdi+20]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    mov       rax,	[rdi+40]
    test      rax,	rax
    jz        L6693
    mov       rcx,	[rbp + mm_diags.showprojectinfo.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L13059]
    call      msys.m$print_str_nf
    mov       rax,	[rdi+40]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    call      msys.m$print_end
L6693:
    mov       rax,	[rdi+56]
    test      rax,	rax
    jz        L6695
    mov       rcx,	[rbp + mm_diags.showprojectinfo.dev]
    call      msys.m$print_startfile
    call      msys.m$print_space
    mov       rax,	[rdi+56]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    lea       rcx,	[L13060]
    call      msys.m$print_str_nf
    mov       rax,	[rdi+56]
    movzx     rax,	byte [rax+170]
    lea       r10,	[mm_tables.scopenames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    mov       rcx,	[rdi+56]
    call      msys.m$print_ptr_nf
    call      msys.m$print_end
L6695:
    mov       rax,	[rdi+48]
    test      rax,	rax
    jz        L6697
    mov       rcx,	[rbp + mm_diags.showprojectinfo.dev]
    call      msys.m$print_startfile
    call      msys.m$print_space
    mov       rax,	[rdi+48]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    lea       rcx,	[L13060]
    call      msys.m$print_str_nf
    mov       rax,	[rdi+48]
    movzx     rax,	byte [rax+170]
    lea       r10,	[mm_tables.scopenames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    mov       rcx,	[rdi+48]
    call      msys.m$print_ptr_nf
    call      msys.m$print_end
L6697:
    mov       rcx,	[rbp + mm_diags.showprojectinfo.dev]
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rax,	[rbp + mm_diags.showprojectinfo.i]
    inc       rax
    mov       [rbp + mm_diags.showprojectinfo.i],	rax
    cmp       rax,	[mm_decls.nmodules]
    jle       L6683
L6685:
    mov       rcx,	[rbp + mm_diags.showprojectinfo.dev]
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	[rbp + mm_diags.showprojectinfo.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L13061]
    call      msys.m$print_str_nf
    mov       rcx,	[mm_decls.nsubprogs]
    call      msys.m$print_i64_nf
    lea       rcx,	[L13062]
    call      msys.m$print_str_nf
    mov       rcx,	[mm_decls.mainsubprogno]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rax,	1
    mov       [rbp + mm_diags.showprojectinfo.i],	rax
    mov       rax,	[mm_decls.nsubprogs]
    cmp       rax,	1
    jl        L6700
L6698:
    lea       rax,	[mm_decls.subprogs]
    mov       r10,	[rbp + mm_diags.showprojectinfo.i]
    mov       rbx,	[rax + r10*8]
    mov       rcx,	[rbp + mm_diags.showprojectinfo.dev]
    call      msys.m$print_startfile
    mov       rcx,	[mm_diags.showprojectinfo.tab]
    call      msys.m$print_str_nf
    mov       rcx,	[rbp + mm_diags.showprojectinfo.i]
    call      msys.m$print_i64_nf
    mov       rcx,	[rbx]
    call      msys.m$print_str_nf
    lea       rcx,	[L13063]
    call      msys.m$print_str_nf
    movzx     rax,	byte [rbx+14]
    shr       eax,	1
    and       eax,	1
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.m$print_u64
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       ax,	[rbx+8]
    test      ax,	ax
    jz        L6702
    mov       rcx,	[rbp + mm_diags.showprojectinfo.dev]
    call      msys.m$print_startfile
    mov       rcx,	[mm_diags.showprojectinfo.tab]
    call      msys.m$print_str_nf
    mov       rcx,	[mm_diags.showprojectinfo.tab]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    movsx     rax,	word [rbx+8]
    mov       [rbp + mm_diags.showprojectinfo.j],	rax
    movsx     rax,	word [rbx+12]
    mov       r14,	rax
    mov       rax,	[rbp + mm_diags.showprojectinfo.j]
    cmp       rax,	r14
    jg        L6705
L6703:
    mov       rcx,	[rbp + mm_diags.showprojectinfo.dev]
    call      msys.m$print_startfile
    call      msys.m$print_space
    lea       rax,	[mm_decls.modules]
    mov       r10,	[rbp + mm_diags.showprojectinfo.j]
    mov       rax,	[rax + r10*8]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    lea       rcx,	[L13064]
    call      msys.m$print_str_nf
    lea       rax,	[mm_decls.modules]
    mov       r10,	[rbp + mm_diags.showprojectinfo.j]
    mov       rax,	[rax + r10*8]
    mov       rcx,	[rax+32]
    call      msys.m$print_ptr_nf
    lea       rcx,	[L13065]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       rax,	[rbp + mm_diags.showprojectinfo.j]
    inc       rax
    mov       [rbp + mm_diags.showprojectinfo.j],	rax
    cmp       rax,	r14
    jle       L6703
L6705:
    mov       rcx,	[rbp + mm_diags.showprojectinfo.dev]
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
L6702:
    mov       rax,	[rbp + mm_diags.showprojectinfo.i]
    inc       rax
    mov       [rbp + mm_diags.showprojectinfo.i],	rax
    cmp       rax,	[mm_decls.nsubprogs]
    jle       L6698
L6700:
    mov       rcx,	[rbp + mm_diags.showprojectinfo.dev]
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	[rbp + mm_diags.showprojectinfo.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L13066]
    call      msys.m$print_str_nf
    mov       rcx,	[mm_decls.nsourcefiles]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rax,	1
    mov       [rbp + mm_diags.showprojectinfo.i],	rax
    mov       rax,	[mm_decls.nsourcefiles]
    cmp       rax,	1
    jl        L6708
L6706:
    lea       rax,	[mm_decls.sources]
    mov       r10,	[rbp + mm_diags.showprojectinfo.i]
    mov       r15,	[rax + r10*8]
    mov       rcx,	[rbp + mm_diags.showprojectinfo.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L13067]
    call      msys.m$print_setfmt
    mov       rcx,	[rbp + mm_diags.showprojectinfo.i]
    lea       rdx,	[L13068]
    call      msys.m$print_i64
    mov       rax,	[r15]
    mov       rcx,	rax
    lea       rdx,	[L13069]
    call      msys.m$print_str
    mov       rax,	[r15+8]
    mov       rcx,	rax
    lea       rdx,	[L13070]
    call      msys.m$print_str
    mov       rax,	[r15+16]
    mov       rcx,	rax
    lea       rdx,	[L13071]
    call      msys.m$print_str
    mov       rax,	[r15+24]
    mov       rcx,	rax
    lea       rdx,	[L13072]
    call      msys.m$print_str
    mov       rax,	[r15+48]
    mov       rcx,	rax
    lea       rdx,	[L13073]
    call      msys.m$print_i64
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rax,	[rbp + mm_diags.showprojectinfo.i]
    inc       rax
    mov       [rbp + mm_diags.showprojectinfo.i],	rax
    cmp       rax,	[mm_decls.nsourcefiles]
    jle       L6706
L6708:
    mov       rcx,	[rbp + mm_diags.showprojectinfo.dev]
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	[rbp + mm_diags.showprojectinfo.dev]
    call      msys.m$print_startfile
    lea       rcx,	[L13074]
    call      msys.m$print_str_nf
    mov       rcx,	[mm_decls.nlibfiles]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rax,	1
    mov       [rbp + mm_diags.showprojectinfo.i],	rax
    mov       rax,	[mm_decls.nlibfiles]
    cmp       rax,	1
    jl        L6711
L6709:
    mov       rcx,	[rbp + mm_diags.showprojectinfo.dev]
    call      msys.m$print_startfile
    mov       rcx,	[mm_diags.showprojectinfo.tab]
    call      msys.m$print_str_nf
    lea       rax,	[mm_decls.libfiles]
    mov       r10,	[rbp + mm_diags.showprojectinfo.i]
    mov       rax,	[rax + r10*8]
    mov       rcx,	rax
    lea       rdx,	[L13075]
    call      msys.m$print_str
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rax,	[rbp + mm_diags.showprojectinfo.i]
    inc       rax
    mov       [rbp + mm_diags.showprojectinfo.i],	rax
    cmp       rax,	[mm_decls.nlibfiles]
    jle       L6709
L6711:
    mov       rcx,	[rbp + mm_diags.showprojectinfo.dev]
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
;---------------
    add       rsp,	56
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_diags.showlogfile
mm_diags.showlogfile:
;?>>
    %define mm_diags.showlogfile.str -256
   %define R.logdev rdi
   %define R.size rbx
    push      rdi
    push      rbx
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	288
;---------------
    mov       rax,	[mm_decls.debugmode]
    test      rax,	rax
    jz        L6712
L6714:
    lea       rcx,	[L13076]
    lea       rdx,	[L13077]
    call      fopen
    mov       rdi,	rax
    mov       al,	[mm_decls.fshowmodules]
    test      al,	al
    jz        L6716
    mov       rcx,	rdi
    call      mm_diags.showprojectinfo
L6716:
    mov       al,	[mm_decls.fshowasm]
    test      al,	al
    jz        L6718
    mov       rax,	[mm_decls.dpasslevel]
    cmp       rax,	7
    jl        L6718
    mov       rcx,	rdi
    call      msys.m$print_startfile
    lea       rcx,	[L13078]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	[mm_decls.outfile]
    lea       rdx,	[L13079]
    call      mlib.changeext
    mov       rcx,	rax
    mov       rdx,	rdi
    call      mm_lib.addtolog
L6718:
    mov       al,	[mm_decls.fshowpcl]
    test      al,	al
    jz        L6720
    mov       rax,	[mm_decls.dpasslevel]
    cmp       rax,	6
    jl        L6720
    mov       rcx,	[mm_decls.outfile]
    lea       rdx,	[L13080]
    call      mlib.changeext
    mov       rcx,	rax
    mov       rdx,	rdi
    call      mm_lib.addtolog
L6720:
    mov       al,	[mm_decls.fshowpst]
    test      al,	al
    jz        L6722
    mov       rax,	[mm_decls.dpasslevel]
    cmp       rax,	6
    jl        L6722
    lea       rcx,	[L13081]
    mov       rdx,	rdi
    call      mm_lib.addtolog
L6722:
    mov       al,	[mm_decls.fshowast3]
    test      al,	al
    jz        L6724
    mov       rax,	[mm_decls.dpasslevel]
    cmp       rax,	5
    jl        L6724
    lea       rcx,	[L13082]
    mov       rdx,	rdi
    call      mm_lib.addtolog
L6724:
    mov       al,	[mm_decls.fshowast2]
    test      al,	al
    jz        L6726
    mov       rax,	[mm_decls.dpasslevel]
    cmp       rax,	4
    jl        L6726
    lea       rcx,	[L13083]
    mov       rdx,	rdi
    call      mm_lib.addtolog
L6726:
    mov       al,	[mm_decls.fshowast1]
    test      al,	al
    jz        L6728
    mov       rax,	[mm_decls.dpasslevel]
    cmp       rax,	2
    jl        L6728
    lea       rcx,	[L13084]
    mov       rdx,	rdi
    call      mm_lib.addtolog
L6728:
    mov       al,	[mm_decls.fshowst]
    test      al,	al
    jz        L6730
    lea       rcx,	[L13085]
    mov       rdx,	rdi
    call      mm_diags.showsttree
L6730:
    mov       al,	[mm_decls.fshowstflat]
    test      al,	al
    jz        L6732
    lea       rcx,	[L13086]
    mov       rdx,	rdi
    call      mm_diags.showstflat
L6732:
    mov       al,	[mm_decls.fshowtypes]
    test      al,	al
    jz        L6734
    mov       rcx,	rdi
    call      mm_diags.printmodelist
L6734:
    mov       rcx,	rdi
    call      mlib.getfilesize
    mov       rbx,	rax
    mov       rcx,	rdi
    call      fclose
    test      rbx,	rbx
    jz        L6736
    call      msys.m$print_startcon
    lea       rcx,	[L13087]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      mwindows.os_getch
    cmp       rax,	27
    jnz       L6738
    xor       ecx,	ecx
    call      exit
L6738:
    lea       rcx,	[rbp + mm_diags.showlogfile.str]
    call      msys.m$print_startstr
    lea       rcx,	[L13088]
    call      msys.m$print_str_nf
    lea       rcx,	[L13089]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       rcx,	[L13090]
    call      mlib.checkfile
    test      rax,	rax
    jz        L6740
    lea       rcx,	[rbp + mm_diags.showlogfile.str]
    xor       edx,	edx
    xor       r8d,	r8d
    call      mwindows.os_execwait
    jmp       L6739
L6740:
    call      msys.m$print_startcon
    lea       rcx,	[L13091]
    call      msys.m$print_str_nf
    lea       rcx,	[L13092]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L6739:
L6736:
L6712:
;---------------
    add       rsp,	288
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_diags.showstflat
mm_diags.showstflat:
;?>>
   %define R.caption rdi
   %define R.f rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rbx
    call      msys.m$print_startfile
    lea       rcx,	[L13093]
    call      msys.m$print_str_nf
    mov       rcx,	rdi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	rbx
    call      mm_diags.printstflat
    mov       rcx,	rbx
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_diags.showsttree
mm_diags.showsttree:
;?>>
   %define R.caption r12
   %define R.f r13
   %define R.pp rdi
   %define R.d rbx
   %define R.i rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r12,	rcx
    mov       r13,	rdx
;---------------
    mov       rcx,	r13
    call      msys.m$print_startfile
    lea       rcx,	[L13093]
    call      msys.m$print_str_nf
    mov       rcx,	r12
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	r13
    mov       rdx,	[mm_decls.stprogram]
    xor       r8d,	r8d
    call      mm_diags.printst
    mov       rcx,	r13
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	r13
    call      msys.m$print_startfile
    lea       rcx,	[L13094]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rdi,	[mm_decls.proclist]
    jmp       L6744
L6743:
    mov       rbx,	[rdi]
    mov       rcx,	r13
    call      msys.m$print_startfile
    lea       rcx,	[L13095]
    call      msys.m$print_setfmt
    mov       rcx,	rbx
    call      msys.m$print_ptr_nf
    mov       rax,	[rbx+8]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    mov       rax,	[rbx]
    mov       rcx,	rax
    lea       rdx,	[L13096]
    call      msys.m$print_str
    movzx     rax,	byte [rbx+78]
    lea       r10,	[mm_tables.namenames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    movzx     rax,	byte [rbx+94]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rdi,	[rdi+8]
L6744:
    test      rdi,	rdi
    jnz       L6743
    mov       rcx,	r13
    call      msys.m$print_startfile
    lea       rcx,	[L13097]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	r13
    call      msys.m$print_startfile
    lea       rcx,	[L13098]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rsi,	1
    mov       rax,	[mm_decls.ndllproctable]
    cmp       rax,	1
    jl        L6748
L6746:
    lea       rax,	[mm_decls.dllproctable]
    mov       r10,	rsi
    mov       rbx,	[rax + r10*8-8]
    mov       rcx,	r13
    call      msys.m$print_startfile
    lea       rcx,	[L13099]
    call      msys.m$print_setfmt
    mov       rcx,	rbx
    call      msys.m$print_ptr_nf
    mov       rax,	[rbx+8]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    mov       rax,	[rbx]
    mov       rcx,	rax
    lea       rdx,	[L13100]
    call      msys.m$print_str
    movzx     rax,	byte [rbx+78]
    lea       r10,	[mm_tables.namenames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    movzx     rax,	byte [rbx+94]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    inc       rsi
    cmp       rsi,	[mm_decls.ndllproctable]
    jle       L6746
L6748:
    mov       rcx,	r13
    call      msys.m$print_startfile
    lea       rcx,	[L13101]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_diags.showast
mm_diags.showast:
;?>>
   %define R.filename rbx
   %define R.f rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rcx,	rbx
    lea       rdx,	[L13102]
    call      fopen
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L6751
    jmp       L6749
L6751:
    mov       rcx,	rdi
    call      msys.m$print_startfile
    lea       rcx,	[L13103]
    call      msys.m$print_str_nf
    mov       rcx,	rbx
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	rdi
    lea       rdx,	[L13104]
    call      mm_diags.printcode
    mov       rcx,	rdi
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	rdi
    call      fclose
L6749:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_diags.printsymbol
mm_diags.printsymbol:
;?>>
   %define R.lp rdi
    %define mm_diags.printsymbol.l -16
    push      rdi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
    mov       rdi,	rcx
;---------------
    mov       rax,	rdi
    lea       r10,	[rbp + mm_diags.printsymbol.l]
    movdqu    XMM4,	[rax]
    movdqu    [r10],	XMM4
    movzx     rax,	byte [rbp + mm_diags.printsymbol.l]
    lea       r10,	[mm_tables.symbolnames]
    mov       r10,	[r10 + rax*8-8]
    lea       rcx,	[L13105]
    mov       rdx,	r10
    call      printf
    movzx     rax,	byte [rbp + mm_diags.printsymbol.l]
    sub       rax,	6
    cmp       rax,	62
    jae       L6755
    lea       r10,	[L6754]
    jmp       [r10 + rax*8]
    segment .data
L6754:
    dq  L6767
    dq  L6755
    dq  L6755
    dq  L6755
    dq  L6755
    dq  L6755
    dq  L6755
    dq  L6755
    dq  L6755
    dq  L6767
    dq  L6755
    dq  L6755
    dq  L6755
    dq  L6767
    dq  L6755
    dq  L6767
    dq  L6755
    dq  L6755
    dq  L6767
    dq  L6767
    dq  L6767
    dq  L6767
    dq  L6767
    dq  L6767
    dq  L6755
    dq  L6767
    dq  L6767
    dq  L6767
    dq  L6767
    dq  L6767
    dq  L6767
    dq  L6767
    dq  L6767
    dq  L6767
    dq  L6755
    dq  L6767
    dq  L6767
    dq  L6767
    dq  L6755
    dq  L6755
    dq  L6755
    dq  L6755
    dq  L6755
    dq  L6755
    dq  L6755
    dq  L6755
    dq  L6755
    dq  L6755
    dq  L6755
    dq  L6755
    dq  L6755
    dq  L6755
    dq  L6755
    dq  L6755
    dq  L6755
    dq  L6755
    dq  L6759
    dq  L6764
    dq  L6766
    dq  L6765
    dq  L6755
    dq  L6756
    segment .text
L6756:
    mov       rax,	[rbp + mm_diags.printsymbol.l+8]
    movzx     rax,	byte [rax+76]
    mov       r10,	[rbp + mm_diags.printsymbol.l+8]
    mov       r10,	[r10]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mm_lex.printstrn
    mov       al,	[rbp + mm_diags.printsymbol.l+1]
    test      al,	al
    jz        L6758
    call      msys.m$print_startcon
    lea       rcx,	[L13106]
    call      msys.m$print_setfmt
    movzx     rax,	byte [rbp + mm_diags.printsymbol.l+1]
    lea       r10,	[mm_tables.symbolnames]
    mov       r10,	[r10 + rax*8-8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_end
L6758:
    jmp       L6753
L6759:
    movzx     rax,	byte [rbp + mm_diags.printsymbol.l+1]
    cmp       rax,	3
    jz        L6761
    cmp       rax,	4
    jz        L6762
    jmp       L6763
L6761:
    call      msys.m$print_startcon
    mov       rcx,	[rbp + mm_diags.printsymbol.l+8]
    call      msys.m$print_i64_nf
    lea       rcx,	[L13107]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L6760
L6762:
    call      msys.m$print_startcon
    mov       rax,	[rbp + mm_diags.printsymbol.l+8]
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.m$print_u64
    lea       rcx,	[L13108]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L6760
L6763:
    call      msys.m$print_startcon
    mov       rcx,	[rbp + mm_diags.printsymbol.l+8]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
L6760:
    jmp       L6753
L6764:
    call      msys.m$print_startcon
    movq      XMM4,	[rbp + mm_diags.printsymbol.l+8]
    movq      XMM0,	XMM4
    xor       edx,	edx
    call      msys.m$print_r64
    call      msys.m$print_end
    jmp       L6753
L6765:
    call      msys.m$print_startcon
    lea       rcx,	[L13109]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       rcx,	[rbp + mm_diags.printsymbol.l+8]
    call      msys.printstr
    call      msys.m$print_startcon
    lea       rcx,	[L13109]
    call      msys.m$print_str_nf
    mov       rax,	[rbp + mm_diags.printsymbol.l+8]
    mov       rcx,	rax
    call      strlen
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L6753
L6766:
    call      msys.m$print_startcon
    lea       rcx,	[L13110]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       rcx,	[rbp + mm_diags.printsymbol.l+8]
    call      msys.printstr
    call      msys.m$print_startcon
    lea       rcx,	[L13110]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L6753
L6767:
    call      msys.m$print_startcon
    movzx     rax,	byte [rbp + mm_diags.printsymbol.l]
    lea       r10,	[mm_tables.symbolnames]
    mov       r10,	[r10 + rax*8-8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L6753
L6755:
    mov       al,	[rbp + mm_diags.printsymbol.l+1]
    test      al,	al
    jz        L6769
    call      msys.m$print_startcon
    lea       rcx,	[L13111]
    call      msys.m$print_setfmt
    movzx     rax,	byte [rbp + mm_diags.printsymbol.l+1]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
L6769:
L6753:
    call      msys.m$print_startcon
    call      msys.m$print_space
    lea       rcx,	[L13112]
    call      msys.m$print_str_nf
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    shr       rax,	24
    and       rax,	255
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.m$print_u64
    call      msys.m$print_newline
    call      msys.m$print_end
;---------------
    add       rsp,	56
    pop       rbp
    pop       rdi
    ret       
;End 
;Proc mm_diags.showtime
mm_diags.showtime:
;?>>
   %define R.caption rdi
   %define R.t rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    call      msys.m$print_startcon
    lea       rcx,	[L13113]
    call      msys.m$print_setfmt
    mov       rcx,	rdi
    lea       rdx,	[L13114]
    call      msys.m$print_str
    mov       rcx,	rbx
    lea       rdx,	[L13115]
    call      msys.m$print_i64
    mov       rax,	rbx
    cvtsi2sd  XMM4,	rax
    mulsd     XMM4,	[L13116]
    mov       rax,	[mm_cli.compiletime]
    cvtsi2sd  XMM5,	rax
    divsd     XMM4,	XMM5
    movq      XMM0,	XMM4
    lea       rdx,	[L13117]
    call      msys.m$print_r64
    call      msys.m$print_newline
    call      msys.m$print_end
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_diags.showtimings
mm_diags.showtimings:
;?>>
;?]]
    sub       rsp,	40
;---------------
    call      mwindows.os_clock
    mov       [mm_cli.endclock],	rax
    mov       rax,	[mm_cli.endclock]
    sub       rax,	[mm_cli.startclock]
    mov       [mm_cli.compiletime],	rax
    lea       rcx,	[L13118]
    mov       rdx,	[mm_cli.loadtime]
    call      mm_diags.showtime
    lea       rcx,	[L13119]
    mov       rdx,	[mm_cli.parsetime]
    call      mm_diags.showtime
    lea       rcx,	[L13120]
    mov       rdx,	[mm_cli.resolvetime]
    call      mm_diags.showtime
    lea       rcx,	[L13121]
    mov       rdx,	[mm_cli.typetime]
    call      mm_diags.showtime
    lea       rcx,	[L13122]
    mov       rdx,	[mm_cli.pcltime]
    call      mm_diags.showtime
    lea       rcx,	[L13123]
    mov       rdx,	[pc_decls.mcltime]
    call      mm_diags.showtime
    lea       rcx,	[L13124]
    mov       rdx,	[pc_decls.sstime]
    call      mm_diags.showtime
    lea       rcx,	[L13125]
    mov       rdx,	[pc_decls.exetime]
    call      mm_diags.showtime
    call      msys.m$print_startcon
    lea       rcx,	[L13126]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L13127]
    mov       rdx,	[mm_cli.compiletime]
    call      mm_diags.showtime
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mm_export_dummy.writeexports
mm_export_dummy.writeexports:
;?>>
    %define mm_export_dummy.writeexports.basefile 16
    %define mm_export_dummy.writeexports.modulename 24
;?]]
;---------------
;---
;---------------
    ret       
;End 
;Proc mm_lex.lex
mm_lex.lex:
;?>>
;?]]
    sub       rsp,	40
;---------------
    lea       rax,	[mm_decls.nextlx]
    lea       r10,	[mm_decls.lx]
    movdqu    XMM4,	[rax]
    movdqu    [r10],	XMM4
    mov       rax,	[mm_lex.lxstart]
    sub       rax,	[mm_lex.lxsource]
    lea       r10,	[mm_decls.lx]
    lea       r10,	[r10+4]
    mov       r9d,	[r10]
    mov       r11,	-16777216
    and       r9d,	r11d
    or        r9d,	eax
    mov       [r10],	r9d
L6774:
    call      mm_lex.lexreadtoken
    lea       rax,	[mm_decls.nextlx]
    movzx     rax,	byte [rax]
    cmp       rax,	58
    jz        L6776
    cmp       rax,	68
    jz        L6777
    cmp       rax,	67
    jz        L6778
    cmp       rax,	60
    jz        L6779
    cmp       rax,	44
    jz        L6780
    jmp       L6781
L6776:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jz        L6784
    cmp       rax,	11
    jz        L6784
    cmp       rax,	9
    jz        L6784
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    lea       r10,	[mm_tables.symboloptypes]
    movzx     r10,	byte [r10 + rax-1]
    cmp       r10,	1
    jnz       L6783
    mov       rax,	[mm_decls.assemmode]
    test      rax,	rax
    jnz       L6783
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	37
    jz        L6783
    cmp       rax,	36
    jz        L6783
L6784:
    jmp       L6782
L6783:
    mov       al,	4
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    mov       al,	1
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+1],	al
    jmp       L6775
L6782:
    jmp       L6774
L6777:
    call      mm_lex.doinclude
    jmp       L6774
L6778:
    lea       rax,	[mm_decls.nextlx]
    movzx     rax,	byte [rax+1]
    cmp       rax,	66
    jnz       L6787
L6786:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	62
    jz        L6789
    cmp       rax,	63
    jz        L6790
    jmp       L6791
L6789:
    lea       rax,	[mm_decls.nextlx]
    mov       rax,	[rax+8]
    movsxd    rax,	dword [rax+80]
    cmp       rax,	1
    jz        L6793
    cmp       rax,	2
    jz        L6794
    jmp       L6795
L6793:
    lea       rax,	[mm_decls.lx]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    imul      r10,	1000000
    mov       [rax],	r10
    jmp       L6792
L6794:
    lea       rax,	[mm_decls.lx]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    imul      r10,	1000000000
    mov       [rax],	r10
    jmp       L6792
L6795:
    lea       rcx,	[L13128]
    call      mm_support.lxerror
L6792:
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       rcx,	rax
    call      mm_lex.setinttype
    lea       r10,	[mm_decls.lx]
    mov       [r10+1],	al
    jmp       L6788
L6790:
    lea       rcx,	[L13129]
    call      mm_support.lxerror
    jmp       L6788
L6791:
    mov       al,	67
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    jmp       L6775
L6788:
    jmp       L6785
L6787:
    mov       al,	67
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    jmp       L6775
L6785:
    jmp       L6774
L6779:
    mov       al,	67
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    jmp       L6775
L6780:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	47
    jnz       L6797
    mov       al,	45
    lea       r10,	[mm_decls.lx]
    mov       [r10],	al
    mov       al,	1
    lea       r10,	[mm_decls.lx]
    mov       [r10+1],	al
    jmp       L6796
L6797:
    jmp       L6775
L6796:
    jmp       L6774
L6781:
    jmp       L6775
L6775:
    lea       rax,	[mm_decls.nextlx]
    lea       rax,	[rax+4]
    mov       r10d,	[mm_lex.lxfileno]
    mov       r9d,	[rax]
    mov       r11,	-4278190081
    shl       r10d,	24
    and       r9d,	r11d
    or        r9d,	r10d
    mov       [rax],	r9d
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mm_lex.lexreadtoken
mm_lex.lexreadtoken:
;?>>
   %define R.c rdi
   %define R.hsum rbx
   %define R.sptr rsi
   %define R.lxsvalue r12
   %define R.commentseen r13
   %define R.p r14
   %define R.q r15
    %define mm_lex.lexreadtoken.str -256
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	296
;---------------
    xor       eax,	eax
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+1],	al
L6799:
    mov       rax,	[mm_lex.lxsptr]
    mov       [mm_lex.lxstart],	rax
    mov       rax,	[mm_lex.lxsptr]
    inc       qword [mm_lex.lxsptr]
    movzx     rax,	byte [rax]
    cmp       rax,	127
    jae       L6802
    lea       r10,	[L6801]
    jmp       [r10 + rax*8]
    segment .data
L6801:
    dq  L6922
    dq  L6802
    dq  L6802
    dq  L6802
    dq  L6802
    dq  L6802
    dq  L6802
    dq  L6802
    dq  L6802
    dq  L6919
    dq  L6921
    dq  L6802
    dq  L6802
    dq  L6920
    dq  L6802
    dq  L6802
    dq  L6802
    dq  L6802
    dq  L6802
    dq  L6802
    dq  L6802
    dq  L6802
    dq  L6802
    dq  L6802
    dq  L6802
    dq  L6802
    dq  L6802
    dq  L6802
    dq  L6802
    dq  L6802
    dq  L6802
    dq  L6802
    dq  L6919
    dq  L6828
    dq  L6917
    dq  L6836
    dq  L6803
    dq  L6895
    dq  L6911
    dq  L6916
    dq  L6870
    dq  L6871
    dq  L6891
    dq  L6883
    dq  L6864
    dq  L6886
    dq  L6856
    dq  L6894
    dq  L6819
    dq  L6819
    dq  L6819
    dq  L6819
    dq  L6819
    dq  L6819
    dq  L6819
    dq  L6819
    dq  L6819
    dq  L6819
    dq  L6866
    dq  L6865
    dq  L6900
    dq  L6896
    dq  L6906
    dq  L6877
    dq  L6876
    dq  L6818
    dq  L6818
    dq  L6818
    dq  L6818
    dq  L6818
    dq  L6818
    dq  L6818
    dq  L6818
    dq  L6818
    dq  L6818
    dq  L6818
    dq  L6818
    dq  L6818
    dq  L6818
    dq  L6818
    dq  L6818
    dq  L6818
    dq  L6818
    dq  L6818
    dq  L6818
    dq  L6818
    dq  L6818
    dq  L6818
    dq  L6818
    dq  L6818
    dq  L6818
    dq  L6872
    dq  L6837
    dq  L6873
    dq  L6875
    dq  L6803
    dq  L6918
    dq  L6803
    dq  L6803
    dq  L6803
    dq  L6803
    dq  L6803
    dq  L6803
    dq  L6803
    dq  L6803
    dq  L6803
    dq  L6803
    dq  L6803
    dq  L6803
    dq  L6803
    dq  L6803
    dq  L6803
    dq  L6803
    dq  L6803
    dq  L6803
    dq  L6803
    dq  L6803
    dq  L6803
    dq  L6803
    dq  L6803
    dq  L6803
    dq  L6803
    dq  L6803
    dq  L6854
    dq  L6874
    dq  L6855
    dq  L6882
    segment .text
L6803:
    mov       rax,	[mm_lex.lxsptr]
    sub       rax,	1
    mov       r12,	rax
;mm_lex.lexreadtoken.doname:
L6804:
    movzx     rax,	byte [r12]
    mov       rbx,	rax
    mov       rsi,	[mm_lex.lxsptr]
L6805:
    mov       rax,	rsi
    inc       rsi
    movzx     rax,	byte [rax]
    mov       rdi,	rax
    lea       r10,	[mm_lex.namemap]
    movzx     r10,	byte [r10 + rax]
    cmp       r10,	1
    jz        L6807
    cmp       r10,	2
    jz        L6808
    jmp       L6809
L6807:
    mov       rax,	rbx
    shl       rax,	4
    sub       rax,	rbx
    add       rax,	rdi
    mov       rbx,	rax
    jmp       L6805
L6808:
    lea       rax,	[rdi+32]
    lea       r10,	[rsi-1]
    mov       [r10],	al
    mov       rax,	rbx
    shl       rax,	4
    sub       rax,	rbx
    add       rax,	rdi
    add       rax,	32
    mov       rbx,	rax
    jmp       L6805
L6809:
    lea       rax,	[rsi-1]
    mov       [mm_lex.lxsptr],	rax
    jmp       L6806
L6806:
    cmp       rdi,	34
    jnz       L6811
    lea       rax,	[r12+1]
    cmp       rax,	[mm_lex.lxsptr]
    jnz       L6813
    movzx     rax,	byte [r12]
    mov       rcx,	rax
    call      toupper
    movsxd    r10,	eax
    mov       rdi,	r10
    cmp       r10,	70
    jz        L6815
    cmp       r10,	82
    jz        L6815
    cmp       r10,	83
    jz        L6816
    cmp       r10,	66
    jz        L6816
    cmp       r10,	65
    jz        L6816
    jmp       L6817
L6815:
    call      mm_lex.readrawstring
    jmp       L6798
L6816:
    mov       rcx,	rdi
    call      mm_lex.readarraystring
    jmp       L6798
L6817:
L6814:
L6813:
L6811:
    mov       rax,	[mm_lex.lxsptr]
    sub       rax,	r12
    mov       rcx,	r12
    mov       rdx,	rax
    mov       r8,	rbx
    call      mm_lex.lookup
    jmp       L6798
L6818:
    mov       rax,	[mm_lex.lxsptr]
    sub       rax,	1
    mov       r12,	rax
    mov       rax,	r12
    mov       r10b,	32
    add       [rax],	r10b
    jmp       L6804
L6819:
    mov       rax,	[mm_lex.lxsptr]
    sub       rax,	1
    mov       [mm_lex.lxstart],	rax
    mov       rax,	[mm_lex.lxsptr]
    movzx     rax,	byte [rax]
    cmp       rax,	41
    jz        L6821
    cmp       rax,	13
    jz        L6821
    cmp       rax,	44
    jz        L6821
    cmp       rax,	32
    jz        L6821
    cmp       rax,	120
    jz        L6822
    cmp       rax,	88
    jz        L6822
    jmp       L6823
L6821:
    mov       al,	62
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    mov       al,	3
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+1],	al
    mov       rax,	[mm_lex.lxstart]
    movzx     rax,	byte [rax]
    sub       rax,	48
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+8],	rax
    jmp       L6820
L6822:
    mov       rax,	[mm_lex.lxstart]
    movzx     rax,	byte [rax]
    cmp       rax,	48
    jz        L6825
    cmp       rax,	50
    jz        L6826
    jmp       L6827
L6825:
    inc       qword [mm_lex.lxsptr]
    call      mm_lex.readhex
    jmp       L6824
L6826:
    inc       qword [mm_lex.lxsptr]
    call      mm_lex.readbin
    jmp       L6824
L6827:
    lea       rcx,	[L13130]
    call      mm_support.lxerror
L6824:
    jmp       L6820
L6823:
    dec       qword [mm_lex.lxsptr]
    call      mm_lex.readdec
L6820:
    jmp       L6798
L6828:
;mm_lex.lexreadtoken.docomment:
L6830:
    mov       rax,	[mm_lex.lxsptr]
    inc       qword [mm_lex.lxsptr]
    movzx     rax,	byte [rax]
    mov       rdi,	rax
    cmp       rax,	13
    jz        L6832
    cmp       rax,	10
    jz        L6833
    test      rax,	rax
    jz        L6834
    jmp       L6835
L6832:
    inc       qword [mm_lex.lxsptr]
    jmp       L6831
L6833:
    jmp       L6831
L6834:
    dec       qword [mm_lex.lxsptr]
    jmp       L6831
L6835:
    jmp       L6830
L6831:
    mov       al,	58
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    jmp       L6798
L6836:
    mov       al,	23
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    jmp       L6798
L6837:
    xor       r13,	r13
L6838:
    mov       rax,	[mm_lex.lxsptr]
    inc       qword [mm_lex.lxsptr]
    movzx     rax,	byte [rax]
    cmp       rax,	13
    jz        L6840
    cmp       rax,	10
    jz        L6841
    test      rax,	rax
    jz        L6842
    cmp       rax,	32
    jz        L6843
    cmp       rax,	9
    jz        L6843
    cmp       rax,	33
    jz        L6844
    jmp       L6845
L6840:
    inc       qword [mm_lex.lxsptr]
    jmp       L6839
L6841:
    jmp       L6839
L6842:
    mov       al,	59
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    dec       qword [mm_lex.lxsptr]
    jmp       L6798
L6843:
    jmp       L6838
L6844:
    mov       r13,	1
    jmp       L6838
L6845:
    test      r13,	r13
    jnz       L6847
    lea       rcx,	[L13131]
    call      mm_support.lxerror
L6847:
    jmp       L6838
L6839:
L6848:
    mov       rax,	[mm_lex.lxsptr]
    inc       qword [mm_lex.lxsptr]
    movzx     rax,	byte [rax]
    cmp       rax,	13
    jz        L6850
    cmp       rax,	10
    jz        L6851
    cmp       rax,	32
    jz        L6852
    cmp       rax,	9
    jz        L6852
    jmp       L6853
L6850:
    inc       qword [mm_lex.lxsptr]
    jmp       L6848
L6851:
    jmp       L6848
L6852:
    jmp       L6848
L6853:
    dec       qword [mm_lex.lxsptr]
    jmp       L6849
L6849:
    jmp       L6799
L6854:
    mov       al,	13
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    jmp       L6798
L6855:
    mov       al,	14
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    jmp       L6798
L6856:
    mov       rax,	[mm_lex.lxsptr]
    movzx     rax,	byte [rax]
    cmp       rax,	46
    jnz       L6859
L6858:
    inc       qword [mm_lex.lxsptr]
    mov       rax,	[mm_lex.lxsptr]
    movzx     rax,	byte [rax]
    cmp       rax,	46
    jnz       L6861
    inc       qword [mm_lex.lxsptr]
    mov       al,	22
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    jmp       L6860
L6861:
    mov       al,	21
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    mov       al,	21
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+1],	al
L6860:
    jmp       L6798
L6859:
    mov       rax,	[mm_lex.lxsptr]
    movzx     rax,	byte [rax]
    cmp       rax,	48
    jl        L6863
    cmp       rax,	57
    jg        L6863
    dec       qword [mm_lex.lxsptr]
    lea       rcx,	[L13132]
    call      mm_support.lxerror
    jmp       L6798
L6863:
    mov       al,	1
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    jmp       L6798
L6862:
L6857:
    jmp       L6799
L6864:
    mov       al,	3
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    jmp       L6798
L6865:
    mov       al,	4
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    jmp       L6798
L6866:
    mov       rax,	[mm_lex.lxsptr]
    movzx     rax,	byte [rax]
    cmp       rax,	61
    jnz       L6869
L6868:
    inc       qword [mm_lex.lxsptr]
    mov       al,	6
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    mov       al,	28
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+1],	al
    jmp       L6867
L6869:
    mov       al,	5
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
L6867:
    jmp       L6798
L6870:
    mov       al,	9
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    jmp       L6798
L6871:
    mov       al,	10
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    jmp       L6798
L6872:
    mov       al,	11
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    jmp       L6798
L6873:
    mov       al,	12
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    jmp       L6798
L6874:
    mov       al,	16
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    jmp       L6798
L6875:
    mov       al,	15
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    jmp       L6798
L6876:
    mov       al,	17
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    jmp       L6798
L6877:
    lea       rax,	[rbp + mm_lex.lexreadtoken.str]
    mov       r14,	rax
    mov       rax,	[mm_lex.lxsptr]
    lea       rax,	[rax+1]
    mov       r15,	rax
    jmp       L6879
L6878:
    mov       rax,	r15
    inc       r15
    mov       al,	[rax]
    mov       r10,	r14
    inc       r14
    mov       [r10],	al
L6879:
    movzx     rax,	byte [r15]
    cmp       rax,	13
    jz        L6881
    cmp       rax,	10
    jz        L6881
    test      rax,	rax
    jnz       L6878
L6881:
    xor       eax,	eax
    mov       [r14],	al
    lea       rcx,	[rbp + mm_lex.lexreadtoken.str]
    call      mlib.pcm_copyheapstring
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+8],	rax
    mov       al,	18
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    jmp       L6798
L6882:
    jmp       L6799
L6883:
    mov       al,	24
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    mov       rax,	[mm_lex.lxsptr]
    movzx     rax,	byte [rax]
    cmp       rax,	43
    jnz       L6885
    inc       qword [mm_lex.lxsptr]
    mov       al,	61
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    mov       al,	84
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+1],	al
    jmp       L6798
L6885:
    jmp       L6798
L6886:
    mov       al,	25
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    mov       rax,	[mm_lex.lxsptr]
    movzx     rax,	byte [rax]
    cmp       rax,	45
    jz        L6888
    cmp       rax,	62
    jz        L6889
    jmp       L6890
L6888:
    inc       qword [mm_lex.lxsptr]
    mov       al,	61
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    mov       al,	85
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+1],	al
    jmp       L6798
L6889:
    inc       qword [mm_lex.lxsptr]
    mov       al,	8
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    jmp       L6798
L6890:
L6887:
    jmp       L6798
L6891:
    mov       rax,	[mm_lex.lxsptr]
    movzx     rax,	byte [rax]
    cmp       rax,	42
    jnz       L6893
    inc       qword [mm_lex.lxsptr]
    mov       al,	43
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    jmp       L6892
L6893:
    mov       al,	26
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
L6892:
    jmp       L6798
L6894:
    mov       al,	27
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    jmp       L6798
L6895:
    mov       al,	28
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    jmp       L6798
L6896:
    mov       rax,	[mm_lex.lxsptr]
    movzx     rax,	byte [rax]
    cmp       rax,	62
    jnz       L6899
L6898:
    mov       al,	7
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    inc       qword [mm_lex.lxsptr]
    jmp       L6897
L6899:
    mov       al,	41
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    mov       al,	1
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+1],	al
L6897:
    jmp       L6798
L6900:
    mov       al,	42
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    mov       rax,	[mm_lex.lxsptr]
    movzx     rax,	byte [rax]
    cmp       rax,	61
    jz        L6902
    cmp       rax,	62
    jz        L6903
    cmp       rax,	60
    jz        L6904
    jmp       L6905
L6902:
    inc       qword [mm_lex.lxsptr]
    mov       al,	4
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+1],	al
    jmp       L6901
L6903:
    inc       qword [mm_lex.lxsptr]
    mov       al,	2
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+1],	al
    jmp       L6901
L6904:
    inc       qword [mm_lex.lxsptr]
    mov       al,	34
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    jmp       L6901
L6905:
    mov       al,	3
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+1],	al
L6901:
    jmp       L6798
L6906:
    mov       al,	42
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    mov       rax,	[mm_lex.lxsptr]
    movzx     rax,	byte [rax]
    cmp       rax,	61
    jz        L6908
    cmp       rax,	62
    jz        L6909
    jmp       L6910
L6908:
    inc       qword [mm_lex.lxsptr]
    mov       al,	42
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    mov       al,	5
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+1],	al
    jmp       L6907
L6909:
    inc       qword [mm_lex.lxsptr]
    mov       al,	35
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    jmp       L6907
L6910:
    mov       al,	42
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    mov       al,	6
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+1],	al
L6907:
    jmp       L6798
L6911:
    mov       rax,	[mm_lex.lxsptr]
    movzx     rax,	byte [rax]
    cmp       rax,	38
    jz        L6913
    cmp       rax,	46
    jz        L6914
    jmp       L6915
L6913:
    inc       qword [mm_lex.lxsptr]
    mov       al,	20
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    mov       al,	57
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+1],	al
    jmp       L6912
L6914:
    inc       qword [mm_lex.lxsptr]
    mov       al,	2
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    xor       eax,	eax
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+1],	al
    jmp       L6912
L6915:
    mov       al,	19
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    mov       al,	55
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+1],	al
L6912:
    jmp       L6798
L6916:
    mov       rcx,	39
    call      mm_lex.lxreadstring
    jmp       L6798
L6917:
    mov       rcx,	34
    call      mm_lex.lxreadstring
    jmp       L6798
L6918:
    call      mm_lex.readrawxname
    jmp       L6798
L6919:
    jmp       L6799
L6920:
    inc       qword [mm_lex.lxsptr]
    mov       al,	58
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    jmp       L6798
L6921:
    mov       al,	58
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    jmp       L6798
L6922:
    mov       rax,	[mm_lex.sourcelevel]
    test      rax,	rax
    jz        L6924
    call      mm_lex.unstacksource
    jmp       L6798
L6924:
    mov       al,	59
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    dec       qword [mm_lex.lxsptr]
    jmp       L6798
L6923:
    jmp       L6799
L6802:
    lea       rcx,	[L13133]
    call      mm_support.lxerror
    jmp       L6798
L6798:
;---------------
    add       rsp,	296
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lex.lexsetup
mm_lex.lexsetup:
;?>>
;?]]
    sub       rsp,	40
;---------------
    call      mm_lex.inithashtable
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mm_lex.printstrn
mm_lex.printstrn:
;?>>
   %define R.s rdi
   %define R.length rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    test      rbx,	rbx
    jz        L6928
    call      msys.m$print_startcon
    mov       rcx,	rbx
    lea       rdx,	[L13134]
    call      msys.m$print_i64
    mov       rcx,	rdi
    lea       rdx,	[L13135]
    call      msys.m$print_str
    call      msys.m$print_end
L6928:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lex.readrawstring
mm_lex.readrawstring:
;?>>
   %define R.dest rdi
   %define R.c rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
;---------------
    mov       al,	65
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    inc       qword [mm_lex.lxsptr]
    mov       rax,	[mm_lex.lxsptr]
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+8],	rax
    mov       rdi,	[mm_lex.lxsptr]
L6930:
    mov       rax,	[mm_lex.lxsptr]
    inc       qword [mm_lex.lxsptr]
    movzx     rax,	byte [rax]
    mov       rbx,	rax
    cmp       rax,	34
    jz        L6932
    cmp       rax,	13
    jz        L6933
    cmp       rax,	10
    jz        L6933
    test      rax,	rax
    jz        L6933
    jmp       L6934
L6932:
    mov       rax,	[mm_lex.lxsptr]
    movzx     rax,	byte [rax]
    cmp       rax,	34
    jnz       L6936
    mov       rax,	rdi
    inc       rdi
    mov       r10b,	34
    mov       [rax],	r10b
    inc       qword [mm_lex.lxsptr]
    jmp       L6935
L6936:
    jmp       L6931
L6935:
    jmp       L6930
L6933:
    lea       rcx,	[L13136]
    call      mm_support.lxerror
    dec       qword [mm_lex.lxsptr]
    jmp       L6931
L6934:
    mov       rax,	rdi
    inc       rdi
    mov       r10b,	bl
    mov       [rax],	r10b
    jmp       L6930
L6931:
    lea       rax,	[mm_decls.nextlx]
    mov       rax,	[rax+8]
    mov       r10,	[mm_lex.lxsptr]
    sub       r10,	rax
    lea       rax,	[mm_decls.nextlx]
    mov       [rax+2],	r10w
    lea       rax,	[mm_decls.nextlx]
    movzx     rax,	word [rax+2]
    lea       r10,	[mm_decls.nextlx]
    mov       r10,	[r10+8]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mlib.pcm_copyheapstringn
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+8],	rax
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lex.lookup
mm_lex.lookup:
;?>>
   %define R.name r12
   %define R.length r13
   %define R.hashindex r14
   %define R.wrapped rdi
   %define R.j rbx
   %define R.d rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       r12,	rcx
    mov       r13,	rdx
    mov       r14,	r8
;---------------
    mov       rax,	r14
    and       rax,	65535
    mov       rbx,	rax
    lea       rax,	[mm_lex.hashtable]
    mov       r10,	rbx
    mov       rsi,	[rax + r10*8]
    xor       rdi,	rdi
L6938:
    test      rsi,	rsi
    jnz       L6941
    jmp       L6939
L6941:
    movzx     rax,	byte [rsi+76]
    cmp       rax,	r13
    jnz       L6943
    mov       rax,	[rsi]
    mov       rcx,	rax
    mov       rdx,	r12
    mov       r8,	r13
    call      memcmp
    movsxd    r10,	eax
    test      r10,	r10
    jnz       L6943
    mov       rax,	rsi
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+8],	rax
    mov       al,	[rsi+77]
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    mov       al,	[rsi+79]
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+1],	al
    jmp       L6937
L6943:
    inc       rbx
    cmp       rbx,	65536
    jl        L6945
    test      rdi,	rdi
    jz        L6947
    lea       rcx,	[L13137]
    call      mlib.abortprogram
L6947:
    mov       rdi,	1
    xor       rbx,	rbx
L6945:
    lea       rax,	[mm_lex.hashtable]
    mov       r10,	rbx
    mov       rsi,	[rax + r10*8]
    jmp       L6938
L6939:
    mov       rcx,	176
    call      mlib.pcm_allocnfz
    mov       rsi,	rax
    mov       rax,	rsi
    lea       r10,	[mm_lex.hashtable]
    mov       r11,	rbx
    mov       [r10 + r11*8],	rax
    mov       rcx,	r12
    mov       rdx,	r13
    call      mlib.pcm_copyheapstringn
    mov       [rsi],	rax
    mov       [rsi+76],	r13b
    mov       al,	67
    mov       [rsi+77],	al
    mov       rax,	rsi
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+8],	rax
    mov       al,	[rsi+77]
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
L6937:
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lex.lookupsys
mm_lex.lookupsys:
;?>>
   %define R.name rsi
   %define R.j rdi
   %define R.wrapped rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    mov       rcx,	rsi
    call      mm_lex.gethashvaluez
    and       rax,	65535
    mov       rdi,	rax
    lea       rax,	[mm_lex.hashtable]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8]
    lea       r10,	[mm_decls.lx]
    mov       [r10+8],	rax
    xor       rbx,	rbx
L6949:
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    test      rax,	rax
    jz        L6950
L6952:
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       rax,	[rax]
    mov       rcx,	rax
    mov       rdx,	rsi
    call      mlib.eqstring
    test      rax,	rax
    jz        L6953
    call      msys.m$print_startcon
    lea       rcx,	[L13138]
    call      msys.m$print_str_nf
    mov       rcx,	rsi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	1
    call      exit
L6953:
L6951:
    inc       rdi
    cmp       rdi,	65536
    jl        L6955
    test      rbx,	rbx
    jz        L6957
    lea       rcx,	[L13139]
    call      mlib.abortprogram
L6957:
    mov       rbx,	1
    xor       rdi,	rdi
L6955:
    lea       rax,	[mm_lex.hashtable]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8]
    lea       r10,	[mm_decls.lx]
    mov       [r10+8],	rax
    jmp       L6949
L6950:
    mov       rcx,	176
    call      mlib.pcm_allocnfz
    lea       r10,	[mm_decls.lx]
    mov       [r10+8],	rax
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    lea       r10,	[mm_lex.hashtable]
    mov       r11,	rdi
    mov       [r10 + r11*8],	rax
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       r10,	rsi
    mov       [rax],	r10
    mov       rcx,	rsi
    call      strlen
    lea       r10,	[mm_decls.lx]
    mov       r10,	[r10+8]
    mov       [r10+76],	al
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       r10b,	67
    mov       [rax+77],	r10b
    xor       eax,	eax
L6948:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lex.gethashvaluez
mm_lex.gethashvaluez:
;?>>
   %define R.s rcx
   %define R.c rdi
   %define R.hsum rbx
    push      rdi
    push      rbx
;?]]
;---------------
    movzx     rax,	byte [rcx]
    test      rax,	rax
    jnz       L6960
    xor       eax,	eax
    jmp       L6958
L6960:
    mov       rax,	rcx
    inc       rcx
    movzx     rax,	byte [rax]
    mov       rbx,	rax
L6961:
    mov       rax,	rcx
    inc       rcx
    movzx     rax,	byte [rax]
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L6964
    jmp       L6962
L6964:
    mov       rax,	rbx
    shl       rax,	4
    sub       rax,	rbx
    add       rax,	rdi
    mov       rbx,	rax
    jmp       L6961
L6962:
    mov       rax,	rbx
L6958:
;---------------
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lex.inithashtable
mm_lex.inithashtable:
;?>>
   %define R.i rdi
   %define R.av_1 rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
;---------------
    lea       rcx,	[mm_lex.hashtable]
    xor       edx,	edx
    mov       r8,	524288
    call      memset
    mov       rdi,	1
    mov       rbx,	174
    cmp       rbx,	1
    jl        L6968
L6966:
    lea       rax,	[mm_tables.stnames]
    mov       r10,	rdi
    mov       rcx,	[rax + r10*8-8]
    call      mm_lex.lookupsys
    lea       rax,	[mm_tables.stsymbols]
    mov       r10,	rdi
    mov       al,	[rax + r10-1]
    lea       r10,	[mm_decls.lx]
    mov       r10,	[r10+8]
    mov       [r10+77],	al
    lea       rax,	[mm_tables.stsymbols]
    mov       r10,	rdi
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	66
    jnz       L6971
L6970:
    lea       rax,	[mm_tables.stsubcodes]
    mov       r10,	rdi
    movsx     rax,	word [rax + r10*2-2]
    lea       r10,	[mm_decls.lx]
    mov       r10,	[r10+8]
    mov       [r10+80],	eax
    lea       rax,	[mm_tables.stsymbols]
    mov       r10,	rdi
    mov       al,	[rax + r10-1]
    lea       r10,	[mm_decls.lx]
    mov       r10,	[r10+8]
    mov       [r10+79],	al
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       r10b,	67
    mov       [rax+77],	r10b
    jmp       L6969
L6971:
    lea       rax,	[mm_tables.stsubcodes]
    mov       r10,	rdi
    mov       ax,	[rax + r10*2-2]
    lea       r10,	[mm_decls.lx]
    mov       r10,	[r10+8]
    mov       [r10+79],	al
L6969:
    inc       rdi
    cmp       rdi,	rbx
    jle       L6966
L6968:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lex.printhashtable
mm_lex.printhashtable:
;?>>
;?]]
    sub       rsp,	40
;---------------
    call      msys.m$print_startcon
    lea       rcx,	[L13140]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mm_lex.addreservedword
mm_lex.addreservedword:
;?>>
   %define R.name rdi
   %define R.symbol rbx
   %define R.subcode rsi
   %define R.regsize r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
    mov       r12,	r9
;---------------
    mov       rcx,	rdi
    call      mm_lex.lookupsys
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       r10b,	67
    mov       [rax+77],	r10b
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       r10b,	bl
    mov       [rax+79],	r10b
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       r10d,	esi
    mov       [rax+80],	r10d
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       r10w,	r12w
    mov       [rax+164],	r10w
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lex.doinclude
mm_lex.doinclude:
;?>>
   %define R.file rdi
   %define R.pf rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
;---------------
    call      mm_lex.lexreadtoken
    lea       rax,	[mm_decls.nextlx]
    movzx     rax,	byte [rax]
    cmp       rax,	65
    jz        L6976
    lea       rcx,	[L13141]
    call      mm_support.lxerror
L6976:
    lea       rax,	[mm_decls.nextlx]
    mov       rdi,	[rax+8]
    mov       rcx,	rdi
    call      mlib.convlcstring
    mov       rcx,	rdi
    lea       rdx,	[L13142]
    call      mlib.addext
    mov       rdi,	rax
    lea       rax,	[mm_decls.sources]
    mov       r10,	[mm_lex.lxfileno]
    mov       rax,	[rax + r10*8]
    mov       rax,	[rax+16]
    mov       rcx,	rdi
    lea       rdx,	[L13143]
    mov       r8,	rax
    call      mm_support.getsupportfile
    mov       rbx,	rax
    call      mm_lex.lexreadtoken
    movsx     rax,	word [rbx+64]
    mov       rcx,	rax
    xor       edx,	edx
    call      mm_lex.stacksource
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lex.startlex
mm_lex.startlex:
;?>>
   %define R.file rcx
;?]]
;---------------
    mov       rax,	[rcx+32]
    mov       [mm_lex.lxsptr],	rax
    mov       [mm_lex.lxsource],	rax
    xor       eax,	eax
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+4],	eax
    movsx     rax,	word [rcx+64]
    mov       [mm_lex.lxfileno],	rax
    mov       al,	4
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    xor       eax,	eax
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+1],	al
;---------------
    ret       
;End 
;Proc mm_lex.addnamestr
mm_lex.addnamestr:
;?>>
   %define R.name rbx
    %define mm_lex.addnamestr.oldlx -16
   %define R.symptr rdi
    %define mm_lex.addnamestr.$T1 -24
    push      rdi
    push      rbx
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       rbx,	rcx
;---------------
    lea       rax,	[mm_decls.nextlx]
    lea       r10,	[rbp + mm_lex.addnamestr.oldlx]
    movdqu    XMM4,	[rax]
    movdqu    [r10],	XMM4
    mov       rcx,	rbx
    call      mm_lex.gethashvaluez
    mov       [rbp + mm_lex.addnamestr.$T1],	rax
    mov       rcx,	rbx
    call      strlen
    mov       rcx,	rbx
    mov       rdx,	rax
    mov       r8,	[rbp + mm_lex.addnamestr.$T1]
    call      mm_lex.lookup
    lea       rax,	[mm_decls.nextlx]
    mov       rdi,	[rax+8]
    lea       rax,	[rbp + mm_lex.addnamestr.oldlx]
    lea       r10,	[mm_decls.nextlx]
    movdqu    XMM4,	[rax]
    movdqu    [r10],	XMM4
    mov       rax,	rdi
L6978:
;---------------
    add       rsp,	64
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lex.ps
mm_lex.ps:
;?>>
   %define R.caption rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    call      msys.m$print_startcon
    lea       rcx,	[L13144]
    call      msys.m$print_str_nf
    mov       rcx,	rdi
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rcx,	[L13145]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       rcx,	[mm_decls.lx]
    call      mm_diags.printsymbol
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_lex.psnext
mm_lex.psnext:
;?>>
   %define R.caption rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    call      msys.m$print_startcon
    mov       rcx,	rdi
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rcx,	[L13145]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       rcx,	[mm_decls.nextlx]
    call      mm_diags.printsymbol
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_lex.psx
mm_lex.psx:
;?>>
   %define R.caption rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    call      msys.m$print_startcon
    mov       rcx,	rdi
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rcx,	[L13145]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       rcx,	[mm_decls.lx]
    call      mm_diags.printsymbol
    call      msys.m$print_startcon
    lea       rcx,	[L13146]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       rcx,	[mm_decls.nextlx]
    call      mm_diags.printsymbol
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_lex.stacksource
mm_lex.stacksource:
;?>>
   %define R.fileno rdi
   %define R.isimport rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rax,	[mm_lex.sourcelevel]
    cmp       rax,	20
    jl        L6984
    lea       rcx,	[L13147]
    call      mm_support.lxerror
L6984:
    inc       qword [mm_lex.sourcelevel]
    mov       rax,	[mm_lex.lxstart]
    lea       r10,	[mm_lex.lxstart_stack]
    mov       r11,	[mm_lex.sourcelevel]
    mov       [r10 + r11*8-8],	rax
    mov       rax,	[mm_lex.lxsource]
    lea       r10,	[mm_lex.lxsource_stack]
    mov       r11,	[mm_lex.sourcelevel]
    mov       [r10 + r11*8-8],	rax
    mov       rax,	[mm_lex.lxsptr]
    lea       r10,	[mm_lex.lxsptr_stack]
    mov       r11,	[mm_lex.sourcelevel]
    mov       [r10 + r11*8-8],	rax
    mov       rax,	[mm_lex.lxfileno]
    lea       r10,	[mm_lex.lxfileno_stack]
    mov       r11,	[mm_lex.sourcelevel]
    mov       [r10 + r11*8-8],	rax
    lea       rax,	[mm_decls.nextlx]
    lea       r10,	[mm_lex.lxnextlx_stack]
    mov       r11,	[mm_lex.sourcelevel]
    shl       r11,	4
    movdqu    XMM4,	[rax]
    movdqu    [r10 + r11-16],	XMM4
    mov       al,	[mm_lex.lximport]
    lea       r10,	[mm_lex.lximport_stack]
    mov       r11,	[mm_lex.sourcelevel]
    mov       [r10 + r11-1],	al
    mov       [mm_lex.lximport],	rbx
    lea       rax,	[mm_decls.sources]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8]
    mov       rax,	[rax+32]
    mov       [mm_lex.lxsptr],	rax
    mov       [mm_lex.lxsource],	rax
    xor       eax,	eax
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+4],	eax
    mov       [mm_lex.lxfileno],	rdi
    mov       al,	4
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    xor       eax,	eax
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+1],	al
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lex.unstacksource
mm_lex.unstacksource:
;?>>
;?]]
;---------------
    mov       rax,	[mm_lex.sourcelevel]
    cmp       rax,	0
    jle       L6987
    lea       rax,	[mm_lex.lxstart_stack]
    mov       r10,	[mm_lex.sourcelevel]
    mov       rax,	[rax + r10*8-8]
    mov       [mm_lex.lxstart],	rax
    lea       rax,	[mm_lex.lxsource_stack]
    mov       r10,	[mm_lex.sourcelevel]
    mov       rax,	[rax + r10*8-8]
    mov       [mm_lex.lxsource],	rax
    lea       rax,	[mm_lex.lxsptr_stack]
    mov       r10,	[mm_lex.sourcelevel]
    mov       rax,	[rax + r10*8-8]
    mov       [mm_lex.lxsptr],	rax
    lea       rax,	[mm_lex.lxnextlx_stack]
    mov       r10,	[mm_lex.sourcelevel]
    shl       r10,	4
    lea       rax,	[rax + r10-16]
    lea       r10,	[mm_decls.nextlx]
    movdqu    XMM4,	[rax]
    movdqu    [r10],	XMM4
    lea       rax,	[mm_lex.lxfileno_stack]
    mov       r10,	[mm_lex.sourcelevel]
    mov       rax,	[rax + r10*8-8]
    mov       [mm_lex.lxfileno],	rax
    lea       rax,	[mm_lex.lximport_stack]
    mov       r10,	[mm_lex.sourcelevel]
    movzx     rax,	byte [rax + r10-1]
    mov       [mm_lex.lximport],	rax
    dec       qword [mm_lex.sourcelevel]
L6987:
;---------------
    ret       
;End 
;Proc mm_lex.readarraystring
mm_lex.readarraystring:
;?>>
   %define R.prefix rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    inc       qword [mm_lex.lxsptr]
    mov       rcx,	34
    call      mm_lex.lxreadstring
    cmp       rdi,	83
    jnz       L6990
    mov       al,	83
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+1],	al
    jmp       L6989
L6990:
    lea       rax,	[mm_decls.nextlx]
    lea       rax,	[rax+2]
    dec       word [rax]
    mov       al,	66
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+1],	al
L6989:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_lex.setinttype
mm_lex.setinttype:
;?>>
   %define R.a rcx
;?]]
;---------------
    mov       rax,	rcx
    mov       r10,	9223372036854775807
    cmp       rax,	r10
    ja        L6993
    mov       rax,	3
    jmp       L6992
L6993:
    mov       rax,	4
L6992:
L6991:
;---------------
    ret       
;End 
;Proc mm_lex.readrawxname
mm_lex.readrawxname:
;?>>
   %define R.c rdi
   %define R.hsum rbx
   %define R.length rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
;---------------
    mov       rax,	[mm_lex.lxsptr]
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+8],	rax
    xor       rbx,	rbx
    jmp       L6996
L6995:
    mov       rax,	rbx
    shl       rax,	4
    sub       rax,	rbx
    add       rax,	rdi
    mov       rbx,	rax
L6996:
    mov       rax,	[mm_lex.lxsptr]
    inc       qword [mm_lex.lxsptr]
    movzx     rax,	byte [rax]
    mov       rdi,	rax
    lea       r10,	[mm_lex.namemap]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jnz       L6995
    dec       qword [mm_lex.lxsptr]
    lea       rax,	[mm_decls.nextlx]
    mov       rax,	[rax+8]
    mov       r10,	[mm_lex.lxsptr]
    sub       r10,	rax
    mov       rsi,	r10
    test      rsi,	rsi
    jnz       L6999
    lea       rcx,	[L13148]
    call      mm_support.lxerror
L6999:
    lea       rax,	[mm_decls.nextlx]
    mov       rax,	[rax+8]
    mov       rcx,	rax
    mov       rdx,	rsi
    mov       r8,	rbx
    call      mm_lex.lookup
    mov       al,	60
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
L6994:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lex.lxerror_s
mm_lex.lxerror_s:
;?>>
   %define R.mess rdi
    %define mm_lex.lxerror_s.s 32
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      mm_support.lxerror
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_lex.lxreadstring
mm_lex.lxreadstring:
;?>>
   %define R.termchar r14
    %define mm_lex.lxreadstring.s -8
   %define R.t rdi
   %define R.c rbx
   %define R.length rsi
   %define R.hasescape r12
    %define mm_lex.lxreadstring.str -16
   %define R.pass r13
    %define mm_lex.lxreadstring.$T1 -24
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       r14,	rcx
;---------------
    cmp       r14,	34
    jnz       L7003
    mov       al,	65
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    jmp       L7002
L7003:
    mov       al,	64
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    mov       al,	3
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+1],	al
L7002:
    xor       rsi,	rsi
    xor       eax,	eax
    mov       r12,	rax
    xor       rdi,	rdi
    mov       rax,	1
    mov       r13,	rax
L7004:
    mov       rax,	[mm_lex.lxsptr]
    mov       [rbp + mm_lex.lxreadstring.s],	rax
L7007:
    mov       rax,	[rbp + mm_lex.lxreadstring.s]
    inc       qword [rbp + mm_lex.lxreadstring.s]
    movzx     rax,	byte [rax]
    mov       rbx,	rax
    cmp       rax,	92
    jz        L7010
    cmp       rax,	34
    jz        L7011
    cmp       rax,	39
    jz        L7011
    cmp       rax,	13
    jz        L7012
    cmp       rax,	10
    jz        L7012
    test      rax,	rax
    jz        L7012
    jmp       L7013
L7010:
    mov       r12,	1
    mov       rax,	[rbp + mm_lex.lxreadstring.s]
    movzx     rax,	byte [rax]
    mov       rbx,	rax
    cmp       rbx,	65
    jl        L7015
    cmp       rbx,	90
    jg        L7015
    mov       rax,	32
    add       rbx,	rax
L7015:
    inc       qword [rbp + mm_lex.lxreadstring.s]
    mov       rax,	rbx
    cmp       rax,	97
    jz        L7017
    cmp       rax,	98
    jz        L7018
    cmp       rax,	99
    jz        L7019
    cmp       rax,	114
    jz        L7019
    cmp       rax,	101
    jz        L7020
    cmp       rax,	102
    jz        L7021
    cmp       rax,	104
    jz        L7022
    cmp       rax,	108
    jz        L7023
    cmp       rax,	110
    jz        L7023
    cmp       rax,	116
    jz        L7024
    cmp       rax,	117
    jz        L7025
    cmp       rax,	118
    jz        L7025
    cmp       rax,	119
    jz        L7026
    cmp       rax,	120
    jz        L7027
    cmp       rax,	121
    jz        L7028
    cmp       rax,	122
    jz        L7029
    jmp       L7030
L7017:
    mov       rbx,	7
    jmp       L7016
L7018:
    mov       rbx,	8
    jmp       L7016
L7019:
    mov       rbx,	13
    jmp       L7016
L7020:
    mov       rbx,	27
    jmp       L7016
L7021:
    mov       rbx,	12
    jmp       L7016
L7022:
    jmp       L7032
L7031:
    lea       rcx,	[rbp + mm_lex.lxreadstring.s]
    mov       rdx,	2
    mov       r8,	1
    call      mm_lex.readhexcode
    mov       rbx,	rax
    cmp       r13,	2
    jnz       L7035
    mov       [rdi],	bl
L7035:
    inc       rdi
L7032:
    mov       rax,	[rbp + mm_lex.lxreadstring.s]
    movzx     rax,	byte [rax]
    cmp       rax,	92
    jnz       L7031
    inc       qword [rbp + mm_lex.lxreadstring.s]
    dec       rdi
    jmp       L7016
L7023:
    mov       rbx,	10
    jmp       L7016
L7024:
    mov       rbx,	9
    jmp       L7016
L7025:
    cmp       r13,	2
    jnz       L7037
    mov       rax,	rdi
    jmp       L7036
L7037:
    xor       eax,	eax
L7036:
    mov       [rbp + mm_lex.lxreadstring.$T1],	rax
    cmp       rbx,	117
    jnz       L7039
    mov       rax,	4
    jmp       L7038
L7039:
    mov       rax,	6
L7038:
    lea       rcx,	[rbp + mm_lex.lxreadstring.s]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_lex.readhexcode
    mov       rcx,	rax
    mov       rdx,	[rbp + mm_lex.lxreadstring.$T1]
    call      mm_lex.getutf8
    add       rdi,	rax
    jmp       L7007
L7026:
    cmp       r13,	2
    jnz       L7041
    mov       al,	13
    mov       [rdi],	al
L7041:
    inc       rdi
    mov       rbx,	10
    jmp       L7016
L7027:
    lea       rcx,	[rbp + mm_lex.lxreadstring.s]
    mov       rdx,	2
    xor       r8d,	r8d
    call      mm_lex.readhexcode
    mov       rbx,	rax
    jmp       L7016
L7028:
    mov       rbx,	16
    jmp       L7016
L7029:
    xor       rbx,	rbx
    jmp       L7016
L7030:
    mov       rax,	rbx
    cmp       rax,	34
    jz        L7043
    cmp       rax,	92
    jz        L7044
    cmp       rax,	39
    jz        L7045
    cmp       rax,	48
    jz        L7046
    jmp       L7047
L7043:
    mov       rbx,	34
    jmp       L7042
L7044:
    mov       rbx,	92
    jmp       L7042
L7045:
    mov       rbx,	39
    jmp       L7042
L7046:
    xor       rbx,	rbx
    jmp       L7042
L7047:
    mov       [rbp + mm_lex.lxreadstring.str],	bl
    xor       eax,	eax
    mov       [rbp + mm_lex.lxreadstring.str+1],	al
    lea       rcx,	[L13149]
    lea       rdx,	[rbp + mm_lex.lxreadstring.str]
    call      mm_lex.lxerror_s
L7042:
L7016:
    jmp       L7009
L7011:
    cmp       rbx,	r14
    jnz       L7049
    mov       rax,	[rbp + mm_lex.lxreadstring.s]
    movzx     rax,	byte [rax]
    cmp       rax,	rbx
    jnz       L7051
    inc       qword [rbp + mm_lex.lxreadstring.s]
    jmp       L7050
L7051:
    jmp       L7008
L7050:
L7049:
    mov       r12,	1
    jmp       L7009
L7012:
    lea       rcx,	[L13150]
    call      mm_support.lxerror
L7013:
L7009:
    cmp       r13,	2
    jnz       L7053
    mov       [rdi],	bl
L7053:
    inc       rdi
    jmp       L7007
L7008:
    cmp       r13,	1
    jnz       L7055
    mov       rsi,	rdi
    lea       rax,	[rsi+1]
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+2],	ax
    test      r12,	r12
    jz        L7057
    lea       rax,	[rsi+1]
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       rdi,	rax
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+8],	rax
    jmp       L7056
L7057:
    test      rsi,	rsi
    jnz       L7058
    lea       rax,	[L13151]
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+8],	rax
    mov       rax,	[rbp + mm_lex.lxreadstring.s]
    mov       [mm_lex.lxsptr],	rax
    jmp       L7001
L7058:
    mov       rcx,	[mm_lex.lxsptr]
    mov       rdx,	rsi
    call      mlib.pcm_copyheapstringn
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+8],	rax
    mov       rax,	[rbp + mm_lex.lxreadstring.s]
    mov       [mm_lex.lxsptr],	rax
    jmp       L7001
L7056:
    jmp       L7054
L7055:
    xor       eax,	eax
    mov       [rdi],	al
    mov       rax,	[rbp + mm_lex.lxreadstring.s]
    mov       [mm_lex.lxsptr],	rax
L7054:
    inc       r13
    cmp       r13,	2
    jle       L7004
L7001:
;---------------
    add       rsp,	64
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lex.readhexcode
mm_lex.readhexcode:
;?>>
   %define R.s r12
   %define R.n r13
   %define R.sp r14
   %define R.a rdi
   %define R.c rbx
   %define R.i rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       r12,	rcx
    mov       r13,	rdx
    mov       r14,	r8
;---------------
    xor       rdi,	rdi
    mov       rax,	1
    mov       rsi,	rax
    cmp       r13,	1
    jl        L7062
L7060:
    test      r14,	r14
    jz        L7064
    mov       eax,	esi
    and       eax,	1
    test      rax,	rax
    jz        L7064
L7065:
    mov       rax,	r12
    mov       r10,	[rax]
    inc       qword [rax]
    movzx     r10,	byte [r10]
    mov       rbx,	r10
    cmp       rbx,	32
    jz        L7065
    jmp       L7063
L7064:
    mov       rax,	r12
    mov       r10,	[rax]
    inc       qword [rax]
    movzx     r10,	byte [r10]
    mov       rbx,	r10
L7063:
    mov       rax,	rbx
    cmp       rax,	65
    jl        L7069
    cmp       rax,	70
    jg        L7069
    mov       rax,	rdi
    shl       rax,	4
    add       rax,	rbx
    sub       rax,	65
    add       rax,	10
    mov       rdi,	rax
    jmp       L7068
L7069:
    mov       rax,	rbx
    cmp       rax,	97
    jl        L7070
    cmp       rax,	102
    jg        L7070
    mov       rax,	rdi
    shl       rax,	4
    add       rax,	rbx
    sub       rax,	97
    add       rax,	10
    mov       rdi,	rax
    jmp       L7068
L7070:
    mov       rax,	rbx
    cmp       rax,	48
    jl        L7071
    cmp       rax,	57
    jg        L7071
    mov       rax,	rdi
    shl       rax,	4
    add       rax,	rbx
    sub       rax,	48
    mov       rdi,	rax
    jmp       L7068
L7071:
    lea       rcx,	[L13152]
    call      mm_support.lxerror
L7068:
    inc       rsi
    cmp       rsi,	r13
    jle       L7060
L7062:
    mov       rax,	rdi
L7059:
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lex.getutf8
mm_lex.getutf8:
;?>>
   %define R.c rcx
   %define R.s rdx
   %define R.n rdi
    %define mm_lex.getutf8.str -16
    push      rdi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	24
;---------------
    test      rdx,	rdx
    jnz       L7074
    lea       rax,	[rbp + mm_lex.getutf8.str]
    mov       rdx,	rax
L7074:
    cmp       rcx,	127
    jg        L7076
    mov       rdi,	1
    mov       rax,	rdx
    inc       rdx
    mov       r10b,	cl
    mov       [rax],	r10b
    jmp       L7075
L7076:
    cmp       rcx,	2047
    jg        L7077
    mov       rdi,	2
    mov       rax,	rcx
    shr       rax,	6
    and       rax,	31
    mov       r10,	192
    add       r10,	rax
    mov       rax,	rdx
    inc       rdx
    mov       [rax],	r10b
    mov       rax,	rcx
    and       rax,	63
    mov       r10,	128
    add       r10,	rax
    mov       rax,	rdx
    inc       rdx
    mov       [rax],	r10b
    jmp       L7075
L7077:
    cmp       rcx,	65535
    jg        L7078
    mov       rdi,	3
    mov       rax,	rcx
    shr       rax,	12
    and       rax,	15
    mov       r10,	224
    add       r10,	rax
    mov       rax,	rdx
    inc       rdx
    mov       [rax],	r10b
    mov       rax,	rcx
    shr       rax,	6
    and       rax,	63
    mov       r10,	128
    add       r10,	rax
    mov       rax,	rdx
    inc       rdx
    mov       [rax],	r10b
    mov       rax,	rcx
    and       rax,	63
    mov       r10,	128
    add       r10,	rax
    mov       rax,	rdx
    inc       rdx
    mov       [rax],	r10b
    jmp       L7075
L7078:
    cmp       rcx,	1114111
    jg        L7079
    mov       rdi,	4
    mov       rax,	rcx
    shr       rax,	18
    and       rax,	7
    mov       r10,	240
    add       r10,	rax
    mov       rax,	rdx
    inc       rdx
    mov       [rax],	r10b
    mov       rax,	rcx
    shr       rax,	12
    and       rax,	63
    mov       r10,	128
    add       r10,	rax
    mov       rax,	rdx
    inc       rdx
    mov       [rax],	r10b
    mov       rax,	rcx
    shr       rax,	6
    and       rax,	63
    mov       r10,	128
    add       r10,	rax
    mov       rax,	rdx
    inc       rdx
    mov       [rax],	r10b
    mov       rax,	rcx
    and       rax,	63
    mov       r10,	128
    add       r10,	rax
    mov       rax,	rdx
    inc       rdx
    mov       [rax],	r10b
    jmp       L7075
L7079:
    xor       rdi,	rdi
L7075:
    xor       eax,	eax
    mov       [rdx],	al
    mov       rax,	rdi
L7072:
;---------------
    add       rsp,	24
    pop       rbp
    pop       rdi
    ret       
;End 
;Proc mm_lex.readdec
mm_lex.readdec:
;?>>
   %define R.c rdi
   %define R.dest rbx
   %define R.destend rsi
   %define R.pstart r12
   %define R.islong r13
   %define R.length r14
    %define mm_lex.readdec.str -1024
   %define R.a r15
    %define mm_lex.readdec.av_1 -1032
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	1064
;---------------
    xor       r13,	r13
    mov       rax,	[mm_lex.lxsptr]
    mov       r12,	rax
    lea       rax,	[rbp + mm_lex.readdec.str]
    mov       rbx,	rax
    lea       rax,	[rbx+1024]
    sub       rax,	10
    mov       rsi,	rax
    xor       r15,	r15
L7081:
    mov       rax,	[mm_lex.lxsptr]
    inc       qword [mm_lex.lxsptr]
    movzx     rax,	byte [rax]
    mov       rdi,	rax
    cmp       rax,	48
    jl        L7084
    cmp       rax,	57
    jg        L7084
    mov       rax,	r15
    shl       rax,	1
    lea       rax,	[rax + rax*4]
    add       rax,	rdi
    sub       rax,	48
    mov       r15,	rax
    mov       rax,	rbx
    inc       rbx
    mov       r10b,	dil
    mov       [rax],	r10b
    jmp       L7083
L7084:
    mov       rax,	rdi
    cmp       rax,	101
    jz        L7086
    cmp       rax,	69
    jz        L7086
    cmp       rax,	46
    jz        L7087
    cmp       rax,	95
    jz        L7088
    cmp       rax,	39
    jz        L7088
    cmp       rax,	108
    jz        L7089
    cmp       rax,	76
    jz        L7089
    cmp       rax,	98
    jz        L7090
    cmp       rax,	66
    jz        L7090
    jmp       L7091
L7086:
    mov       [mm_lex.lxsptr],	r12
    call      mm_lex.readreal
    jmp       L7080
L7087:
    mov       rax,	[mm_lex.lxsptr]
    movzx     rax,	byte [rax]
    cmp       rax,	46
    jz        L7093
    mov       [mm_lex.lxsptr],	r12
    call      mm_lex.readreal
    jmp       L7080
L7093:
    dec       qword [mm_lex.lxsptr]
    jmp       L7082
L7088:
    jmp       L7085
L7089:
    call      mm_lex.nodecimal
    jmp       L7085
L7090:
    mov       rax,	rbx
    lea       r10,	[rbp + mm_lex.readdec.str]
    sub       rax,	r10
    mov       r14,	rax
    cmp       r14,	64
    jle       L7095
    lea       rcx,	[L13153]
    call      mm_support.lxerror
L7095:
    lea       rax,	[rbp + mm_lex.readdec.str]
    mov       rbx,	rax
    xor       r15,	r15
    mov       rax,	r14
    mov       [rbp + mm_lex.readdec.av_1],	rax
    mov       rax,	[rbp + mm_lex.readdec.av_1]
    cmp       rax,	0
    jle       L7098
L7096:
    movzx     rax,	byte [rbx]
    cmp       rax,	50
    jb        L7100
    lea       rcx,	[L13154]
    call      mm_support.lxerror
L7100:
    mov       rax,	r15
    shl       rax,	1
    mov       r10,	rbx
    inc       rbx
    movzx     r10,	byte [r10]
    add       rax,	r10
    sub       rax,	48
    mov       r15,	rax
    dec       qword [rbp + mm_lex.readdec.av_1]
    jnz       L7096
L7098:
    jmp       L7101
L7091:
    dec       qword [mm_lex.lxsptr]
    jmp       L7082
L7085:
L7083:
    cmp       rbx,	rsi
    jb        L7103
    lea       rcx,	[L13155]
    call      mm_support.lxerror
L7103:
    jmp       L7081
L7082:
    mov       rax,	rbx
    lea       r10,	[rbp + mm_lex.readdec.str]
    sub       rax,	r10
    mov       r14,	rax
    cmp       r14,	20
    jg        L7106
    cmp       r14,	20
    jnz       L7105
    lea       rcx,	[rbp + mm_lex.readdec.str]
    mov       rdx,	[mm_lex.u64maxstr]
    mov       r8,	20
    call      strncmp
    movsxd    r10,	eax
    cmp       r10,	0
    jle       L7105
L7106:
    call      mm_lex.nodecimal
L7105:
;mm_lex.readdec.finish:
L7101:
    mov       al,	62
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    mov       rcx,	r15
    call      mm_lex.setinttype
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+1],	al
    mov       rax,	r15
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+8],	rax
L7080:
;---------------
    add       rsp,	1064
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lex.readhex
mm_lex.readhex:
;?>>
   %define R.c rdi
   %define R.dest rbx
   %define R.destend rsi
   %define R.pstart r12
   %define R.length r13
    %define mm_lex.readhex.str -1024
   %define R.a r14
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	1056
;---------------
    mov       r12,	[mm_lex.lxsptr]
    lea       rax,	[rbp + mm_lex.readhex.str]
    mov       rbx,	rax
    lea       rax,	[rbx+1024]
    sub       rax,	10
    mov       rsi,	rax
    xor       r14,	r14
L7108:
    mov       rax,	[mm_lex.lxsptr]
    inc       qword [mm_lex.lxsptr]
    movzx     rax,	byte [rax]
    mov       rdi,	rax
    cmp       rax,	48
    jl        L7111
    cmp       rax,	57
    jg        L7111
    mov       rax,	r14
    shl       rax,	4
    add       rax,	rdi
    sub       rax,	48
    mov       r14,	rax
    mov       rax,	rbx
    inc       rbx
    mov       r10b,	dil
    mov       [rax],	r10b
    jmp       L7110
L7111:
    mov       rax,	rdi
    cmp       rax,	65
    jl        L7112
    cmp       rax,	70
    jg        L7112
    mov       rax,	rbx
    inc       rbx
    mov       r10b,	dil
    mov       [rax],	r10b
    mov       rax,	r14
    shl       rax,	4
    add       rax,	rdi
    sub       rax,	65
    add       rax,	10
    mov       r14,	rax
    jmp       L7110
L7112:
    mov       rax,	rdi
    cmp       rax,	97
    jl        L7113
    cmp       rax,	102
    jg        L7113
    lea       rax,	[rdi-32]
    mov       r10,	rbx
    inc       rbx
    mov       [r10],	al
    mov       rax,	r14
    shl       rax,	4
    add       rax,	rdi
    sub       rax,	97
    add       rax,	10
    mov       r14,	rax
    jmp       L7110
L7113:
    mov       rax,	rdi
    cmp       rax,	95
    jz        L7115
    cmp       rax,	39
    jz        L7115
    cmp       rax,	108
    jz        L7116
    cmp       rax,	76
    jz        L7116
    cmp       rax,	46
    jz        L7117
    jmp       L7118
L7115:
    jmp       L7114
L7116:
    call      mm_lex.nodecimal
    jmp       L7114
L7117:
    dec       qword [mm_lex.lxsptr]
    jmp       L7109
L7118:
    dec       qword [mm_lex.lxsptr]
    jmp       L7109
L7114:
L7110:
    cmp       rbx,	rsi
    jb        L7120
    lea       rcx,	[L13155]
    call      mm_support.lxerror
L7120:
    jmp       L7108
L7109:
    mov       rax,	rbx
    lea       r10,	[rbp + mm_lex.readhex.str]
    sub       rax,	r10
    mov       r13,	rax
    cmp       r13,	16
    jle       L7122
    lea       rcx,	[L13156]
    call      mm_support.lxerror
    jmp       L7107
L7122:
    mov       al,	62
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    mov       rcx,	r14
    call      mm_lex.setinttype
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+1],	al
    mov       rax,	r14
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+8],	rax
L7107:
;---------------
    add       rsp,	1056
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lex.readbin
mm_lex.readbin:
;?>>
   %define R.c rdi
   %define R.dest rbx
   %define R.destend rsi
   %define R.pstart r12
   %define R.length r13
    %define mm_lex.readbin.str -1024
   %define R.a r14
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	1056
;---------------
    mov       r12,	[mm_lex.lxsptr]
    lea       rax,	[rbp + mm_lex.readbin.str]
    mov       rbx,	rax
    lea       rax,	[rbx+1024]
    sub       rax,	10
    mov       rsi,	rax
    xor       r14,	r14
L7124:
    mov       rax,	[mm_lex.lxsptr]
    inc       qword [mm_lex.lxsptr]
    movzx     rax,	byte [rax]
    mov       rdi,	rax
    cmp       rax,	48
    jz        L7127
    cmp       rax,	49
    jz        L7127
    cmp       rax,	95
    jz        L7128
    cmp       rax,	39
    jz        L7128
    cmp       rax,	108
    jz        L7129
    cmp       rax,	76
    jz        L7129
    cmp       rax,	46
    jz        L7130
    jmp       L7131
L7127:
    mov       rax,	r14
    shl       rax,	1
    add       rax,	rdi
    sub       rax,	48
    mov       r14,	rax
    mov       rax,	rbx
    inc       rbx
    mov       r10b,	dil
    mov       [rax],	r10b
    jmp       L7126
L7128:
    jmp       L7126
L7129:
    call      mm_lex.nodecimal
    jmp       L7126
L7130:
    dec       qword [mm_lex.lxsptr]
    jmp       L7125
L7131:
    mov       rax,	rdi
    cmp       rax,	50
    jl        L7133
    cmp       rax,	57
    jg        L7133
    lea       rcx,	[L13157]
    call      mm_support.lxerror
    jmp       L7132
L7133:
    dec       qword [mm_lex.lxsptr]
    jmp       L7125
L7132:
L7126:
    cmp       rbx,	rsi
    jb        L7135
    lea       rcx,	[L13158]
    call      mm_support.lxerror
L7135:
    jmp       L7124
L7125:
    mov       rax,	rbx
    lea       r10,	[rbp + mm_lex.readbin.str]
    sub       rax,	r10
    mov       r13,	rax
    cmp       r13,	64
    jle       L7137
    call      mm_lex.nodecimal
L7137:
    mov       al,	62
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    mov       rcx,	r14
    call      mm_lex.setinttype
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+1],	al
    mov       rax,	r14
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+8],	rax
;---------------
    add       rsp,	1056
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lex.readreal
mm_lex.readreal:
;?>>
   %define R.c rdi
   %define R.negexpon rbx
   %define R.dotseen rsi
   %define R.length r12
   %define R.fractlen r13
   %define R.expon r14
   %define R.expseen r15
   %define R.x XMM15
    %define mm_lex.readreal.str -1024
    %define mm_lex.readreal.dest -1032
    %define mm_lex.readreal.destend -1040
    %define mm_lex.readreal.a -1048
    %define mm_lex.readreal.av_1 -1056
    %define mm_lex.readreal.av_2 -1064
    %define mm_lex.readreal.av_3 -1072
    %define mm_lex.readreal.av_4 -1080
    %define mm_lex.readreal.i -1088
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
    movq      rax,	XMM15
    push      rax
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	1120
;---------------
    lea       rax,	[rbp + mm_lex.readreal.str]
    mov       [rbp + mm_lex.readreal.dest],	rax
    mov       rax,	[rbp + mm_lex.readreal.dest]
    lea       rax,	[rax+1024]
    sub       rax,	100
    mov       [rbp + mm_lex.readreal.destend],	rax
    xor       eax,	eax
    mov       r13,	rax
    mov       r14,	rax
    mov       r15,	rax
    mov       rsi,	rax
    mov       rbx,	rax
    mov       r12,	rax
L7139:
    mov       rax,	[mm_lex.lxsptr]
    inc       qword [mm_lex.lxsptr]
    movzx     rax,	byte [rax]
    mov       rdi,	rax
    cmp       rax,	48
    jl        L7142
    cmp       rax,	57
    jg        L7142
    mov       rax,	[rbp + mm_lex.readreal.dest]
    inc       qword [rbp + mm_lex.readreal.dest]
    mov       r10b,	dil
    mov       [rax],	r10b
    inc       r12
    test      rsi,	rsi
    jz        L7144
    inc       r13
L7144:
    jmp       L7141
L7142:
    mov       rax,	rdi
    cmp       rax,	46
    jz        L7146
    cmp       rax,	101
    jz        L7147
    cmp       rax,	69
    jz        L7147
    cmp       rax,	95
    jz        L7148
    cmp       rax,	39
    jz        L7148
    cmp       rax,	108
    jz        L7149
    cmp       rax,	76
    jz        L7149
    jmp       L7150
L7146:
    test      rsi,	rsi
    jz        L7152
    dec       qword [mm_lex.lxsptr]
    jmp       L7140
L7152:
    mov       rsi,	1
    mov       rax,	[rbp + mm_lex.readreal.dest]
    inc       qword [rbp + mm_lex.readreal.dest]
    mov       r10b,	dil
    mov       [rax],	r10b
    jmp       L7145
L7147:
    test      r15,	r15
    jz        L7154
    lea       rcx,	[L13159]
    call      mm_support.lxerror
L7154:
    mov       r15,	1
    mov       rax,	[rbp + mm_lex.readreal.dest]
    inc       qword [rbp + mm_lex.readreal.dest]
    mov       r10b,	dil
    mov       [rax],	r10b
    jmp       L7156
L7155:
    inc       qword [mm_lex.lxsptr]
L7156:
    mov       rax,	[mm_lex.lxsptr]
    movzx     rax,	byte [rax]
    cmp       rax,	32
    jz        L7155
    mov       rax,	[mm_lex.lxsptr]
    movzx     rax,	byte [rax]
    cmp       rax,	43
    jz        L7160
    cmp       rax,	45
    jnz       L7159
L7160:
    mov       rax,	[mm_lex.lxsptr]
    movzx     rax,	byte [rax]
    cmp       rax,	45
    jnz       L7162
    mov       rbx,	1
L7162:
    mov       rax,	[mm_lex.lxsptr]
    inc       qword [mm_lex.lxsptr]
    mov       al,	[rax]
    mov       r10,	[rbp + mm_lex.readreal.dest]
    inc       qword [rbp + mm_lex.readreal.dest]
    mov       [r10],	al
L7159:
    xor       r14,	r14
L7163:
    mov       rax,	[mm_lex.lxsptr]
    inc       qword [mm_lex.lxsptr]
    movzx     rax,	byte [rax]
    mov       rdi,	rax
    cmp       rax,	48
    jl        L7166
    cmp       rax,	57
    jg        L7166
    mov       rax,	r14
    shl       rax,	1
    lea       rax,	[rax + rax*4]
    add       rax,	rdi
    sub       rax,	48
    mov       r14,	rax
    mov       rax,	[rbp + mm_lex.readreal.dest]
    inc       qword [rbp + mm_lex.readreal.dest]
    mov       r10b,	dil
    mov       [rax],	r10b
    mov       rax,	[rbp + mm_lex.readreal.dest]
    cmp       rax,	[rbp + mm_lex.readreal.destend]
    jb        L7168
    lea       rcx,	[L13160]
    call      mm_support.lxerror
L7168:
    jmp       L7165
L7166:
    mov       rax,	rdi
    cmp       rax,	95
    jz        L7170
    cmp       rax,	39
    jz        L7170
    cmp       rax,	108
    jz        L7171
    cmp       rax,	76
    jz        L7171
    jmp       L7172
L7170:
    jmp       L7169
L7171:
    xor       eax,	eax
    mov       r10,	[rbp + mm_lex.readreal.dest]
    mov       [r10],	al
    call      mm_lex.nodecimal
    jmp       L7138
L7172:
    dec       qword [mm_lex.lxsptr]
    jmp       L7140
L7169:
L7165:
    jmp       L7163
L7148:
    jmp       L7145
L7149:
    call      mm_lex.nodecimal
    jmp       L7138
L7150:
    dec       qword [mm_lex.lxsptr]
    jmp       L7140
L7145:
L7141:
    mov       rax,	[rbp + mm_lex.readreal.dest]
    cmp       rax,	[rbp + mm_lex.readreal.destend]
    jb        L7174
    lea       rcx,	[L13161]
    call      mm_support.lxerror
L7174:
    jmp       L7139
L7140:
    xor       eax,	eax
    mov       r10,	[rbp + mm_lex.readreal.dest]
    mov       [r10],	al
    test      r15,	r15
    jz        L7176
    cmp       r14,	0
    jl        L7176
    test      rsi,	rsi
    jnz       L7176
    xor       eax,	eax
    mov       [rbp + mm_lex.readreal.a],	rax
    mov       rax,	1
    mov       [rbp + mm_lex.readreal.i],	rax
    cmp       r12,	1
    jl        L7179
L7177:
    mov       rax,	[rbp + mm_lex.readreal.a]
    shl       rax,	1
    lea       rax,	[rax + rax*4]
    mov       r10,	[rbp + mm_lex.readreal.i]
    movzx     r10,	byte [rbp + r10 + mm_lex.readreal.str-1]
    add       rax,	r10
    sub       rax,	48
    mov       [rbp + mm_lex.readreal.a],	rax
    mov       rax,	[rbp + mm_lex.readreal.i]
    inc       rax
    mov       [rbp + mm_lex.readreal.i],	rax
    cmp       rax,	r12
    jle       L7177
L7179:
    mov       [rbp + mm_lex.readreal.av_1],	r14
    mov       rax,	[rbp + mm_lex.readreal.av_1]
    cmp       rax,	0
    jle       L7182
L7180:
    mov       rax,	[rbp + mm_lex.readreal.a]
    shl       rax,	1
    lea       rax,	[rax + rax*4]
    mov       [rbp + mm_lex.readreal.a],	rax
    dec       qword [rbp + mm_lex.readreal.av_1]
    jnz       L7180
L7182:
    mov       al,	62
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    mov       rcx,	[rbp + mm_lex.readreal.a]
    call      mm_lex.setinttype
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+1],	al
    mov       rax,	[rbp + mm_lex.readreal.a]
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+8],	rax
    jmp       L7138
L7176:
    test      rbx,	rbx
    jz        L7184
    mov       rax,	r14
    neg       rax
    mov       r14,	rax
L7184:
    mov       rax,	r13
    sub       r14,	rax
    movq      XMM4,	[L13162]
    movq      XMM15,	XMM4
    mov       rax,	1
    mov       [rbp + mm_lex.readreal.i],	rax
    mov       rax,	r12
    add       rax,	rsi
    mov       [rbp + mm_lex.readreal.av_2],	rax
    mov       rax,	[rbp + mm_lex.readreal.av_2]
    cmp       rax,	1
    jl        L7187
L7185:
    mov       rax,	[rbp + mm_lex.readreal.i]
    movzx     rax,	byte [rbp + rax + mm_lex.readreal.str-1]
    mov       rdi,	rax
    cmp       rdi,	46
    jz        L7189
    movq      XMM4,	XMM15
    mulsd     XMM4,	[L13163]
    mov       rax,	rdi
    cvtsi2sd  XMM5,	rax
    addsd     XMM4,	XMM5
    mov       rax,	48
    cmp       rax,	0
    jl        L13164
    cvtsi2sd  XMM5,	rax
    jmp       L13165
L13164:
    and       rax,	[L12294]
    cvtsi2sd  XMM5,	rax
    addsd     XMM5,	[L12295]
L13165:
    subsd     XMM4,	XMM5
    movq      XMM15,	XMM4
L7189:
    mov       rax,	[rbp + mm_lex.readreal.i]
    inc       rax
    mov       [rbp + mm_lex.readreal.i],	rax
    cmp       rax,	[rbp + mm_lex.readreal.av_2]
    jle       L7185
L7187:
    cmp       r14,	0
    jl        L7191
    mov       [rbp + mm_lex.readreal.av_3],	r14
    mov       rax,	[rbp + mm_lex.readreal.av_3]
    cmp       rax,	0
    jle       L7194
L7192:
    movq      XMM4,	XMM15
    mulsd     XMM4,	[L13166]
    movq      XMM15,	XMM4
    dec       qword [rbp + mm_lex.readreal.av_3]
    jnz       L7192
L7194:
    jmp       L7190
L7191:
    mov       rax,	r14
    neg       rax
    mov       [rbp + mm_lex.readreal.av_4],	rax
    mov       rax,	[rbp + mm_lex.readreal.av_4]
    cmp       rax,	0
    jle       L7197
L7195:
    movq      XMM4,	XMM15
    divsd     XMM4,	[L13167]
    movq      XMM15,	XMM4
    dec       qword [rbp + mm_lex.readreal.av_4]
    jnz       L7195
L7197:
L7190:
    movq      XMM4,	XMM15
    lea       rax,	[mm_decls.nextlx]
    movq      [rax+8],	XMM4
    mov       al,	63
    lea       r10,	[mm_decls.nextlx]
    mov       [r10],	al
    mov       al,	1
    lea       r10,	[mm_decls.nextlx]
    mov       [r10+1],	al
L7138:
;---------------
    add       rsp,	1120
    pop       rbp
    pop       rcx
    movq      XMM15,	rcx
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lex.nodecimal
mm_lex.nodecimal:
;?>>
;?]]
    sub       rsp,	40
;---------------
    lea       rcx,	[L13168]
    call      mm_support.lxerror
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mm_lex.start
mm_lex.start:
;?>>
   %define R.av_1 rdi
   %define R.c rbx
    push      rdi
    push      rbx
;?]]
;---------------
    xor       rbx,	rbx
    mov       rax,	255
    mov       rdi,	rax
    cmp       rdi,	0
    jl        L7202
L7200:
    mov       rax,	rbx
    cmp       rax,	97
    jl        L7206
    cmp       rax,	122
    jle       L7205
L7206:
    mov       rax,	rbx
    cmp       rax,	48
    jl        L7207
    cmp       rax,	57
    jle       L7205
L7207:
    mov       rax,	rbx
    cmp       rax,	95
    jz        L7208
    cmp       rax,	36
    jnz       L7204
L7208:
L7205:
    mov       al,	1
    lea       r10,	[mm_lex.namemap]
    mov       r11,	rbx
    mov       [r10 + r11],	al
    jmp       L7203
L7204:
    mov       rax,	rbx
    cmp       rax,	65
    jl        L7209
    cmp       rax,	90
    jg        L7209
    mov       al,	2
    lea       r10,	[mm_lex.namemap]
    mov       r11,	rbx
    mov       [r10 + r11],	al
L7209:
L7203:
    inc       rbx
    cmp       rbx,	rdi
    jle       L7200
L7202:
;---------------
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.newstrec
mm_lib.newstrec:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
;---------------
    mov       rcx,	176
    call      mlib.pcm_allocnfz
    mov       rdi,	rax
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       [rdi+88],	eax
    mov       al,	[mm_decls.currmoduleno]
    mov       [rdi+94],	al
    lea       rax,	[mm_decls.moduletosub]
    mov       r10,	[mm_decls.currmoduleno]
    mov       al,	[rax + r10]
    mov       [rdi+95],	al
    mov       rax,	rdi
L7210:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_lib.getduplnameptr
mm_lib.getduplnameptr:
;?>>
   %define R.owner rbx
   %define R.symptr rsi
   %define R.id r12
   %define R.p rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
;---------------
    call      mm_lib.newstrec
    mov       rdi,	rax
    mov       rax,	[rsi]
    mov       [rdi],	rax
    mov       al,	[rsi+76]
    mov       [rdi+76],	al
    mov       al,	67
    mov       [rdi+77],	al
    mov       [rdi+8],	rbx
    mov       [rdi+78],	r12b
    mov       rax,	[rsi+40]
    mov       [rdi+40],	rax
    mov       [rsi+40],	rdi
    mov       [rdi+48],	rsi
    mov       rax,	rdi
L7211:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.adddef
mm_lib.adddef:
;?>>
   %define R.owner rbx
   %define R.p rsi
   %define R.q rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    mov       rax,	[rsi+40]
    mov       rdi,	rax
    test      rax,	rax
    jz        L7214
    mov       rax,	[rdi+8]
    cmp       rax,	rbx
    jnz       L7216
    call      msys.m$print_startcon
    mov       rcx,	[rdi]
    call      msys.m$print_str_nf
    lea       rcx,	[L13169]
    call      msys.m$print_str_nf
    mov       rcx,	[rbx]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L13170]
    call      mm_support.serror
L7216:
L7214:
    mov       rax,	[rbx+16]
    test      rax,	rax
    jnz       L7218
    mov       [rbx+16],	rsi
    jmp       L7217
L7218:
    mov       rax,	[rbx+24]
    mov       r10,	rsi
    mov       [rax+32],	r10
L7217:
    mov       [rbx+24],	rsi
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.createname
mm_lib.createname:
;?>>
   %define R.p rbx
   %define R.u rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    call      mm_lib.allocunitrec
    mov       rdi,	rax
    mov       al,	4
    mov       [rdi],	al
    mov       [rdi+16],	rbx
    mov       rax,	rdi
L7219:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.createunit0
mm_lib.createunit0:
;?>>
   %define R.tag rbx
   %define R.u rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    call      mm_lib.allocunitrec
    mov       rdi,	rax
    mov       [rdi],	bl
    mov       rax,	rdi
L7220:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.createunit1
mm_lib.createunit1:
;?>>
   %define R.tag rbx
   %define R.p rsi
   %define R.u rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    call      mm_lib.allocunitrec
    mov       rdi,	rax
    mov       [rdi],	bl
    mov       [rdi+16],	rsi
    mov       rax,	rdi
L7221:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.createunit2
mm_lib.createunit2:
;?>>
   %define R.tag rbx
   %define R.p rsi
   %define R.q r12
   %define R.u rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
;---------------
    call      mm_lib.allocunitrec
    mov       rdi,	rax
    mov       [rdi],	bl
    mov       [rdi+16],	rsi
    mov       [rdi+24],	r12
    mov       rax,	rdi
L7222:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.createunit3
mm_lib.createunit3:
;?>>
   %define R.tag rbx
   %define R.p rsi
   %define R.q r12
   %define R.r r13
   %define R.u rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
    mov       r13,	r9
;---------------
    call      mm_lib.allocunitrec
    mov       rdi,	rax
    mov       [rdi],	bl
    mov       [rdi+16],	rsi
    mov       [rdi+24],	r12
    mov       [rdi+32],	r13
    mov       rax,	rdi
L7223:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.insertunit
mm_lib.insertunit:
;?>>
   %define R.p r12
   %define R.tag r13
   %define R.q rdi
   %define R.nextunit rbx
   %define R.mode rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r12,	rcx
    mov       r13,	rdx
;---------------
    call      mm_lib.allocunitrec
    mov       rdi,	rax
    mov       rax,	r12
    push      rdi
    mov       r11,	8
L13171:
    mov       r10,	[rax]
    mov       [rdi],	r10
    add       rdi,	8
    add       rax,	8
    dec       r11
    jnz       L13171
    mov       r10b,	[rax]
    mov       [rdi],	r10b
    pop       rdi
    movsxd    rax,	dword [rdi+49]
    mov       rsi,	rax
    mov       rbx,	[rdi+8]
    xor       eax,	eax
    mov       [rdi+8],	rax
    mov       rax,	r12
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    mov       [rax+16],	r10
    mov       [rax+24],	r10
    mov       [rax+32],	r10
    mov       [rax+40],	r10
    mov       [rax+48],	r10
    mov       [rax+56],	r10
    mov       [rax+64],	r10b
    mov       [r12],	r13b
    mov       eax,	[rdi+4]
    mov       [r12+4],	eax
    mov       [r12+16],	rdi
    mov       [r12+49],	esi
    mov       [r12+8],	rbx
    mov       al,	[rdi+61]
    mov       [r12+61],	al
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.deleteunit
mm_lib.deleteunit:
;?>>
   %define R.p rcx
   %define R.q rdx
   %define R.r rdi
    push      rdi
;?]]
    sub       rsp,	16
;---------------
    mov       rdi,	[rcx+8]
    mov       rax,	rdx
    push      rcx
    mov       r11,	8
L13172:
    mov       r10,	[rax]
    mov       [rcx],	r10
    add       rcx,	8
    add       rax,	8
    dec       r11
    jnz       L13172
    mov       r10b,	[rax]
    mov       [rcx],	r10b
    pop       rcx
    mov       [rcx+8],	rdi
;---------------
    add       rsp,	16
    pop       rdi
    ret       
;End 
;Proc mm_lib.createconstunit
mm_lib.createconstunit:
;?>>
   %define R.a rbx
   %define R.t rsi
   %define R.u rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    call      mm_lib.allocunitrec
    mov       rdi,	rax
    mov       al,	1
    mov       [rdi],	al
    mov       [rdi+16],	rbx
    mov       [rdi+49],	esi
    mov       al,	1
    mov       [rdi+60],	al
    mov       rax,	rdi
L7226:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.createstringconstunit
mm_lib.createstringconstunit:
;?>>
   %define R.s rbx
   %define R.length rsi
   %define R.u rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    call      mm_lib.allocunitrec
    mov       rdi,	rax
    mov       al,	1
    mov       [rdi],	al
    mov       [rdi+16],	rbx
    mov       eax,	20
    mov       [rdi+49],	eax
    mov       al,	1
    mov       [rdi+44],	al
    cmp       rsi,	-1
    jnz       L7229
    mov       rcx,	rbx
    call      strlen
    inc       rax
    mov       [rdi+40],	eax
    jmp       L7228
L7229:
    mov       [rdi+40],	esi
L7228:
    mov       rax,	rdi
L7227:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.newtypename
mm_lib.newtypename:
;?>>
   %define R.a rdi
   %define R.b rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rax,	[mm_decls.ntypenames]
    cmp       rax,	38000
    jl        L7232
    lea       rcx,	[L13173]
    call      mm_support.serror
L7232:
    inc       qword [mm_decls.ntypenames]
    lea       rax,	[mm_decls.typenames]
    mov       r10,	[mm_decls.ntypenames]
    shl       r10,	5
    lea       rax,	[rax + r10]
    mov       r10,	rdi
    mov       [rax+8],	r10
    lea       rax,	[mm_decls.typenames]
    mov       r10,	[mm_decls.ntypenames]
    shl       r10,	5
    lea       rax,	[rax + r10]
    mov       r10,	rbx
    mov       [rax+16],	r10
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    lea       r10,	[mm_decls.typenamepos]
    mov       r11,	[mm_decls.ntypenames]
    lea       r10,	[r10 + r11*4]
    mov       [r10],	eax
    mov       rax,	[mm_decls.ntypenames]
    neg       rax
L7230:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.createusertype
mm_lib.createusertype:
;?>>
   %define R.stname rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rax,	[mm_decls.ntypes]
    cmp       rax,	16000
    jl        L7235
    call      msys.m$print_startcon
    mov       rcx,	[mm_decls.ntypes]
    call      msys.m$print_i64_nf
    mov       rcx,	[rdi]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L13174]
    call      mm_support.serror
L7235:
    inc       qword [mm_decls.ntypes]
    mov       rax,	[rdi]
    lea       r10,	[mm_decls.ttname]
    mov       r11,	[mm_decls.ntypes]
    mov       [r10 + r11*8],	rax
    mov       rax,	rdi
    lea       r10,	[mm_decls.ttnamedef]
    mov       r11,	[mm_decls.ntypes]
    mov       [r10 + r11*8],	rax
    xor       eax,	eax
    lea       r10,	[mm_decls.ttbasetype]
    mov       r11,	[mm_decls.ntypes]
    mov       [r10 + r11*4],	eax
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    lea       r10,	[mm_decls.ttlineno]
    mov       r11,	[mm_decls.ntypes]
    mov       [r10 + r11*4],	eax
    mov       eax,	[mm_decls.ntypes]
    mov       [rdi+72],	eax
    mov       rax,	[mm_decls.ntypes]
L7233:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_lib.createusertypefromstr
mm_lib.createusertypefromstr:
;?>>
   %define R.name rbx
   %define R.stname rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rcx,	rbx
    call      mm_lex.addnamestr
    mov       rcx,	[mm_decls.stmodule]
    mov       rdx,	rax
    mov       r8,	5
    call      mm_lib.getduplnameptr
    mov       rdi,	rax
    mov       rcx,	rdi
    call      mm_lib.createusertype
L7236:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.getrangelwbunit
mm_lib.getrangelwbunit:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    movzx     rax,	byte [rdi]
    cmp       rax,	21
    jnz       L7239
    mov       rax,	[rdi+16]
    jmp       L7238
L7239:
    mov       rcx,	37
    mov       rdx,	rdi
    call      mm_lib.createunit1
    mov       rdi,	rax
    mov       al,	3
    mov       [rdi+62],	al
    mov       rax,	rdi
L7238:
L7237:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_lib.getrangeupbunit
mm_lib.getrangeupbunit:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    movzx     rax,	byte [rdi]
    cmp       rax,	21
    jnz       L7242
    mov       rax,	[rdi+24]
    jmp       L7241
L7242:
    mov       rcx,	37
    mov       rdx,	rdi
    call      mm_lib.createunit1
    mov       rdi,	rax
    mov       al,	4
    mov       [rdi+62],	al
    mov       rax,	rdi
L7241:
L7240:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_lib.createarraymode
mm_lib.createarraymode:
;?>>
   %define R.owner rbx
   %define R.target rsi
   %define R.dimexpr r12
   %define R.typedefx r13
   %define R.m rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
    mov       r13,	r9
;---------------
    test      r13,	r13
    jnz       L7245
    call      mm_lib.nextautotype
    mov       rcx,	rax
    call      mm_lib.createusertypefromstr
    mov       rdi,	rax
    jmp       L7244
L7245:
    mov       rdi,	r13
L7244:
    mov       eax,	10
    lea       r10,	[mm_decls.ttbasetype]
    mov       r11,	rdi
    mov       [r10 + r11*4],	eax
    mov       eax,	1
    lea       r10,	[mm_decls.ttlower]
    mov       r11,	rdi
    mov       [r10 + r11*4],	eax
    mov       rax,	r12
    lea       r10,	[mm_decls.ttdimexpr]
    mov       r11,	rdi
    mov       [r10 + r11*8],	rax
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	rdi
    lea       rax,	[rax + r10*4]
    mov       rcx,	rbx
    mov       rdx,	rsi
    mov       r8,	rax
    call      mm_lib.storemode
    mov       rax,	rbx
    lea       r10,	[mm_decls.ttowner]
    mov       r11,	rdi
    mov       [r10 + r11*8],	rax
    mov       al,	1
    lea       r10,	[mm_decls.ttisblock]
    mov       r11,	rdi
    mov       [r10 + r11],	al
    mov       rax,	rdi
L7243:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.sameunit
mm_lib.sameunit:
;?>>
   %define R.p rdi
   %define R.q rbx
   %define R.powner rsi
   %define R.qowner r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
    mov       r12,	r9
;---------------
    cmp       rdi,	rbx
    jnz       L7248
    mov       rax,	1
    jmp       L7246
L7248:
    test      rdi,	rdi
    jz        L7251
    test      rbx,	rbx
    jnz       L7250
L7251:
    xor       eax,	eax
    jmp       L7246
L7250:
    movzx     rax,	byte [rdi]
    movzx     r10,	byte [rbx]
    cmp       rax,	r10
    jz        L7253
    xor       eax,	eax
    jmp       L7246
L7253:
    movzx     rax,	byte [rdi]
    cmp       rax,	1
    jz        L7255
    cmp       rax,	21
    jz        L7256
    cmp       rax,	27
    jz        L7256
    cmp       rax,	4
    jz        L7257
    jmp       L7258
L7255:
    mov       rax,	[rdi+16]
    mov       r10,	[rbx+16]
    cmp       rax,	r10
    setz      al
    movzx     eax,	al
    jmp       L7246
L7256:
    mov       rax,	[rbx+16]
    mov       r10,	[rdi+16]
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    xor       r9d,	r9d
    call      mm_lib.sameunit
    test      rax,	rax
    jz        L7259
    mov       rax,	[rbx+24]
    mov       r10,	[rdi+24]
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    xor       r9d,	r9d
    call      mm_lib.sameunit
    test      rax,	rax
    jz        L7259
    mov       rax,	1
    jmp       L7260
L7259:
    xor       eax,	eax
L7260:
    jmp       L7246
L7257:
    mov       rax,	[rdi+16]
    mov       r10,	[rbx+16]
    cmp       rax,	r10
    jnz       L7262
    cmp       rsi,	r12
    jnz       L7262
    mov       rax,	1
    jmp       L7246
L7262:
L7258:
L7254:
    xor       eax,	eax
L7246:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.createarraymodek
mm_lib.createarraymodek:
;?>>
   %define R.owner rsi
   %define R.target r12
   %define R.lower r13
   %define R.length r14
    %define mm_lib.createarraymodek.typedefx 96
   %define R.atype rdi
   %define R.m rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
    mov       r14,	r9
;---------------
    mov       rdi,	10
    mov       rax,	[rbp + mm_lib.createarraymodek.typedefx]
    test      rax,	rax
    jnz       L7265
    call      mm_lib.nextautotype
    mov       rcx,	rax
    call      mm_lib.createusertypefromstr
    mov       rbx,	rax
    jmp       L7264
L7265:
    mov       rbx,	[rbp + mm_lib.createarraymodek.typedefx]
L7264:
    mov       eax,	edi
    lea       r10,	[mm_decls.ttbasetype]
    mov       r11,	rbx
    mov       [r10 + r11*4],	eax
    mov       eax,	r13d
    lea       r10,	[mm_decls.ttlower]
    mov       r11,	rbx
    mov       [r10 + r11*4],	eax
    mov       eax,	r14d
    lea       r10,	[mm_decls.ttlength]
    mov       r11,	rbx
    mov       [r10 + r11*4],	eax
    cmp       r12,	0
    jge       L7267
    lea       rcx,	[L13175]
    call      mm_support.serror
L7267:
    lea       rax,	[mm_decls.ttsize]
    mov       r10,	r12
    mov       eax,	[rax + r10*4]
    mov       r10,	r14
    imul      r10,	rax
    lea       rax,	[mm_decls.ttsize]
    mov       r11,	rbx
    mov       [rax + r11*4],	r10d
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	rbx
    lea       rax,	[rax + r10*4]
    mov       rcx,	rsi
    mov       rdx,	r12
    mov       r8,	rax
    call      mm_lib.storemode
    mov       rax,	rsi
    lea       r10,	[mm_decls.ttowner]
    mov       r11,	rbx
    mov       [r10 + r11*8],	rax
    mov       al,	1
    lea       r10,	[mm_decls.ttisblock]
    mov       r11,	rbx
    mov       [r10 + r11],	al
    mov       rax,	rbx
L7263:
;---------------
    add       rsp,	32
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.nextautotype
mm_lib.nextautotype:
;?>>
;?]]
    sub       rsp,	40
;---------------
    lea       rcx,	[mm_lib.nextautotype.str]
    call      msys.m$print_startstr
    lea       rcx,	[L13176]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    inc       qword [mm_lib.autotypeno]
    mov       rcx,	[mm_lib.autotypeno]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       rax,	[mm_lib.nextautotype.str]
L7268:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mm_lib.createslicemode
mm_lib.createslicemode:
;?>>
   %define R.owner rbx
   %define R.slicetype rsi
   %define R.target r12
   %define R.dimexpr r13
    %define mm_lib.createslicemode.typedefx 88
   %define R.m rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
    mov       r13,	r9
;---------------
    mov       rax,	[rbp + mm_lib.createslicemode.typedefx]
    test      rax,	rax
    jnz       L7271
    call      mm_lib.nextautotype
    mov       rcx,	rax
    call      mm_lib.createusertypefromstr
    mov       rdi,	rax
    jmp       L7270
L7271:
    mov       rdi,	[rbp + mm_lib.createslicemode.typedefx]
L7270:
    mov       eax,	esi
    lea       r10,	[mm_decls.ttbasetype]
    mov       r11,	rdi
    mov       [r10 + r11*4],	eax
    test      r13,	r13
    jz        L7273
    mov       rax,	r13
    lea       r10,	[mm_decls.ttdimexpr]
    mov       r11,	rdi
    mov       [r10 + r11*8],	rax
    jmp       L7272
L7273:
    mov       eax,	1
    lea       r10,	[mm_decls.ttlower]
    mov       r11,	rdi
    mov       [r10 + r11*4],	eax
L7272:
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	rdi
    lea       rax,	[rax + r10*4]
    mov       rcx,	rbx
    mov       rdx,	r12
    mov       r8,	rax
    call      mm_lib.storemode
    mov       rax,	rbx
    lea       r10,	[mm_decls.ttowner]
    mov       r11,	rdi
    mov       [r10 + r11*8],	rax
    mov       al,	1
    lea       r10,	[mm_decls.ttisblock]
    mov       r11,	rdi
    mov       [r10 + r11],	al
    mov       rax,	rdi
L7269:
;---------------
    add       rsp,	40
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.createslicemodek
mm_lib.createslicemodek:
;?>>
   %define R.owner rbx
   %define R.target rsi
   %define R.lower r12
   %define R.typedefx r13
   %define R.m rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
    mov       r13,	r9
;---------------
    test      r13,	r13
    jnz       L7276
    call      mm_lib.nextautotype
    mov       rcx,	rax
    call      mm_lib.createusertypefromstr
    mov       rdi,	rax
    jmp       L7275
L7276:
    mov       rdi,	r13
L7275:
    mov       eax,	11
    lea       r10,	[mm_decls.ttbasetype]
    mov       r11,	rdi
    mov       [r10 + r11*4],	eax
    mov       eax,	r12d
    lea       r10,	[mm_decls.ttlower]
    mov       r11,	rdi
    mov       [r10 + r11*4],	eax
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	rdi
    lea       rax,	[rax + r10*4]
    mov       rcx,	rbx
    mov       rdx,	rsi
    mov       r8,	rax
    call      mm_lib.storemode
    mov       rax,	rbx
    lea       r10,	[mm_decls.ttowner]
    mov       r11,	rdi
    mov       [r10 + r11*8],	rax
    mov       al,	1
    lea       r10,	[mm_decls.ttisblock]
    mov       r11,	rdi
    mov       [r10 + r11],	al
    mov       rax,	rdi
L7274:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.createrefmode
mm_lib.createrefmode:
;?>>
   %define R.owner rsi
   %define R.target r12
   %define R.typedefx r13
   %define R.k rdi
   %define R.m rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
;---------------
    test      r13,	r13
    jnz       L7279
    mov       rdi,	31
    mov       rax,	[mm_decls.ntypes]
    cmp       rax,	31
    jl        L7282
L7280:
    lea       rax,	[mm_decls.ttisref]
    mov       r10,	rdi
    mov       al,	[rax + r10]
    test      al,	al
    jz        L7284
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	rdi
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	r12
    jnz       L7286
    mov       rax,	rdi
    jmp       L7277
L7286:
L7284:
    inc       rdi
    cmp       rdi,	[mm_decls.ntypes]
    jle       L7280
L7282:
    call      mm_lib.nextautotype
    mov       rcx,	rax
    call      mm_lib.createusertypefromstr
    mov       rbx,	rax
    jmp       L7278
L7279:
    mov       rbx,	r13
L7278:
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	rbx
    lea       rax,	[rax + r10*4]
    mov       rcx,	rsi
    mov       rdx,	r12
    mov       r8,	rax
    call      mm_lib.storemode
    mov       eax,	7
    lea       r10,	[mm_decls.ttbasetype]
    mov       r11,	rbx
    mov       [r10 + r11*4],	eax
    lea       rax,	[mm_decls.ttsize]
    mov       eax,	[rax+28]
    lea       r10,	[mm_decls.ttsize]
    mov       r11,	rbx
    mov       [r10 + r11*4],	eax
    mov       al,	1
    lea       r10,	[mm_decls.ttisref]
    mov       r11,	rbx
    mov       [r10 + r11],	al
    mov       rax,	rbx
L7277:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.createrefprocmode
mm_lib.createrefprocmode:
;?>>
    %define mm_lib.createrefprocmode.owner 48
   %define R.stproc rsi
   %define R.paramlist r12
    %define mm_lib.createrefprocmode.kwd 72
    %define mm_lib.createrefprocmode.prettype 80
    %define mm_lib.createrefprocmode.typedefx 88
   %define R.m rdi
   %define R.mproc rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       rsi,	rdx
    mov       r12,	r8
;---------------
    mov       rcx,	rsi
    call      mm_lib.createusertype
    mov       rbx,	rax
    mov       [rsi+112],	r12
    mov       eax,	[rbp + mm_lib.createrefprocmode.prettype]
    mov       [rsi+72],	eax
    mov       eax,	24
    lea       r10,	[mm_decls.ttbasetype]
    mov       r11,	rbx
    mov       [r10 + r11*4],	eax
    mov       rax,	[rbp + mm_lib.createrefprocmode.typedefx]
    test      rax,	rax
    jnz       L7289
    call      mm_lib.nextautotype
    mov       rcx,	rax
    call      mm_lib.createusertypefromstr
    mov       rdi,	rax
    jmp       L7288
L7289:
    mov       rdi,	[rbp + mm_lib.createrefprocmode.typedefx]
L7288:
    mov       eax,	ebx
    lea       r10,	[mm_decls.tttarget]
    mov       r11,	rdi
    mov       [r10 + r11*4],	eax
    mov       eax,	7
    lea       r10,	[mm_decls.ttbasetype]
    mov       r11,	rdi
    mov       [r10 + r11*4],	eax
    lea       rax,	[mm_decls.ttsize]
    mov       eax,	[rax+28]
    lea       r10,	[mm_decls.ttsize]
    mov       r11,	rdi
    mov       [r10 + r11*4],	eax
    mov       al,	1
    lea       r10,	[mm_decls.ttisref]
    mov       r11,	rdi
    mov       [r10 + r11],	al
    mov       rax,	rdi
L7287:
;---------------
    add       rsp,	32
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.copyttvalues
mm_lib.copyttvalues:
;?>>
   %define R.dest rcx
   %define R.source rdx
;?]]
;---------------
    lea       rax,	[mm_decls.ttsigned]
    mov       r10,	rdx
    mov       al,	[rax + r10]
    lea       r10,	[mm_decls.ttsigned]
    mov       r11,	rcx
    mov       [r10 + r11],	al
    lea       rax,	[mm_decls.ttisreal]
    mov       r10,	rdx
    mov       al,	[rax + r10]
    lea       r10,	[mm_decls.ttisreal]
    mov       r11,	rcx
    mov       [r10 + r11],	al
    lea       rax,	[mm_decls.ttisinteger]
    mov       r10,	rdx
    mov       al,	[rax + r10]
    lea       r10,	[mm_decls.ttisinteger]
    mov       r11,	rcx
    mov       [r10 + r11],	al
    lea       rax,	[mm_decls.ttisshort]
    mov       r10,	rdx
    mov       al,	[rax + r10]
    lea       r10,	[mm_decls.ttisshort]
    mov       r11,	rcx
    mov       [r10 + r11],	al
    lea       rax,	[mm_decls.ttisref]
    mov       r10,	rdx
    mov       al,	[rax + r10]
    lea       r10,	[mm_decls.ttisref]
    mov       r11,	rcx
    mov       [r10 + r11],	al
    lea       rax,	[mm_decls.ttisblock]
    mov       r10,	rdx
    mov       al,	[rax + r10]
    lea       r10,	[mm_decls.ttisblock]
    mov       r11,	rcx
    mov       [r10 + r11],	al
;---------------
    ret       
;End 
;Proc mm_lib.getdottedname
mm_lib.getdottedname:
;?>>
   %define R.p rbx
    %define mm_lib.getdottedname.str2 -256
   %define R.owner rdi
    push      rdi
    push      rbx
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	288
    mov       rbx,	rcx
;---------------
    mov       rax,	[rbx]
    lea       rcx,	[mm_lib.getdottedname.str]
    mov       rdx,	rax
    call      strcpy
    mov       rdi,	[rbx+8]
    jmp       L7293
L7292:
    lea       rcx,	[rbp + mm_lib.getdottedname.str2]
    lea       rdx,	[mm_lib.getdottedname.str]
    call      strcpy
    mov       rax,	[rdi]
    lea       rcx,	[mm_lib.getdottedname.str]
    mov       rdx,	rax
    call      strcpy
    lea       rcx,	[mm_lib.getdottedname.str]
    lea       rdx,	[L13177]
    call      strcat
    lea       rcx,	[mm_lib.getdottedname.str]
    lea       rdx,	[rbp + mm_lib.getdottedname.str2]
    call      strcat
    mov       rdi,	[rdi+8]
L7293:
    test      rdi,	rdi
    jz        L7295
    movzx     rax,	byte [rdi+78]
    cmp       rax,	1
    jnz       L7292
L7295:
    lea       rax,	[mm_lib.getdottedname.str]
L7291:
;---------------
    add       rsp,	288
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.getavname
mm_lib.getavname:
;?>>
   %define R.owner rsi
   %define R.id r12
   %define R.p rdi
    %define mm_lib.getavname.str -32
   %define R.name rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    cmp       r12,	11
    jnz       L7298
    movzx     rax,	byte [rsi+78]
    cmp       rax,	6
    jz        L7298
    lea       rcx,	[L13178]
    call      mm_support.serror
L7298:
    cmp       r12,	11
    jnz       L7300
    lea       rcx,	[rbp + mm_lib.getavname.str]
    call      msys.m$print_startstr
    lea       rcx,	[L13179]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    inc       qword [mm_lib.nextavindex]
    mov       rcx,	[mm_lib.nextavindex]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L7299
L7300:
    lea       rcx,	[rbp + mm_lib.getavname.str]
    call      msys.m$print_startstr
    lea       rcx,	[L13180]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    inc       qword [mm_lib.nextsvindex]
    mov       rcx,	[mm_lib.nextsvindex]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
L7299:
    lea       rcx,	[rbp + mm_lib.getavname.str]
    call      mlib.pcm_copyheapstring
    mov       rbx,	rax
    mov       rcx,	rbx
    call      mm_lex.addnamestr
    mov       rcx,	rbx
    call      mm_lex.addnamestr
    mov       rcx,	rsi
    mov       rdx,	rax
    mov       r8,	r12
    call      mm_lib.getduplnameptr
    mov       rdi,	rax
    mov       ax,	1
    mov       [rdi+168],	ax
    mov       eax,	3
    mov       [rdi+72],	eax
    mov       rcx,	rsi
    mov       rdx,	rdi
    call      mm_lib.adddef
    mov       rax,	rdi
L7296:
;---------------
    add       rsp,	64
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.unionstr_clear
mm_lib.unionstr_clear:
;?>>
   %define R.u rcx
;?]]
;---------------
    xor       eax,	eax
    mov       [rcx],	rax
;---------------
    ret       
;End 
;Proc mm_lib.unionstr_append
mm_lib.unionstr_append:
;?>>
   %define R.u rdi
   %define R.c rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    movzx     rax,	byte [rdi+7]
    cmp       rax,	6
    jnz       L7304
    lea       rcx,	[L13181]
    call      mm_support.serror
L7304:
    lea       rax,	[rdi+7]
    inc       byte [rax]
    movzx     rax,	byte [rdi+7]
    mov       r10b,	bl
    mov       [rdi + rax-1],	r10b
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.unionstr_concat
mm_lib.unionstr_concat:
;?>>
   %define R.u r12
   %define R.v r13
   %define R.ulen rdi
   %define R.vlen rbx
   %define R.i rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r12,	rcx
    mov       r13,	rdx
;---------------
    movzx     rax,	byte [r12+7]
    mov       rdi,	rax
    movzx     rax,	byte [r13+7]
    mov       rbx,	rax
    mov       rax,	rdi
    add       rax,	rbx
    cmp       rax,	7
    jle       L7307
    lea       rcx,	[L13182]
    call      mm_support.serror
L7307:
    mov       rsi,	1
    cmp       rbx,	1
    jl        L7310
L7308:
    mov       al,	[r13 + rsi-1]
    mov       r10,	rsi
    add       r10,	rdi
    mov       [r12 + r10-1],	al
    inc       rsi
    cmp       rsi,	rbx
    jle       L7308
L7310:
    mov       rax,	rdi
    add       rax,	rbx
    mov       [r12+7],	al
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.unionstr_last
mm_lib.unionstr_last:
;?>>
   %define R.u rcx
;?]]
;---------------
    mov       al,	[rcx+7]
    test      al,	al
    jz        L7313
    movzx     rax,	byte [rcx+7]
    movzx     r10,	byte [rcx + rax-1]
    mov       rax,	r10
    jmp       L7311
L7313:
    xor       eax,	eax
L7311:
;---------------
    ret       
;End 
;Proc mm_lib.unionstr_copy
mm_lib.unionstr_copy:
;?>>
   %define R.u rdi
   %define R.v rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	8
    call      memcpy
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.createrecordmode
mm_lib.createrecordmode:
;?>>
   %define R.owner rbx
   %define R.typedefx rsi
   %define R.m rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    test      rsi,	rsi
    jnz       L7317
    mov       rcx,	rbx
    call      mm_lib.createusertype
    mov       rdi,	rax
    jmp       L7316
L7317:
    mov       rdi,	rsi
L7316:
    mov       eax,	8
    lea       r10,	[mm_decls.ttbasetype]
    mov       r11,	rdi
    mov       [r10 + r11*4],	eax
    mov       al,	1
    lea       r10,	[mm_decls.ttusercat]
    mov       r11,	rdi
    mov       [r10 + r11],	al
    mov       al,	1
    lea       r10,	[mm_decls.ttisblock]
    mov       r11,	rdi
    mov       [r10 + r11],	al
    mov       rax,	rdi
L7315:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.createtuplemode
mm_lib.createtuplemode:
;?>>
   %define R.owner rsi
   %define R.elements r12
   %define R.elementslen r13
   %define R.typedefx r14
   %define R.m rdi
   %define R.i rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
    mov       r14,	r9
;---------------
    test      r14,	r14
    jnz       L7320
    mov       rcx,	rsi
    call      mm_lib.createusertype
    mov       rdi,	rax
    jmp       L7319
L7320:
    mov       rdi,	r14
L7319:
    mov       eax,	28
    lea       r10,	[mm_decls.ttbasetype]
    mov       r11,	rdi
    mov       [r10 + r11*4],	eax
    mov       al,	1
    lea       r10,	[mm_decls.ttusercat]
    mov       r11,	rdi
    mov       [r10 + r11],	al
    mov       eax,	r13d
    lea       r10,	[mm_decls.ttlength]
    mov       r11,	rdi
    mov       [r10 + r11*4],	eax
    mov       rax,	r13
    shl       rax,	2
    mov       rcx,	rax
    call      mlib.pcm_alloc
    lea       r10,	[mm_decls.ttmult]
    mov       r11,	rdi
    mov       [r10 + r11*8],	rax
    mov       rbx,	1
    cmp       r13,	1
    jl        L7323
L7321:
    lea       rax,	[mm_decls.ttmult]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8]
    mov       r10,	rbx
    lea       rax,	[rax + r10*4-4]
    mov       r10,	[r12 + rbx*8-8]
    mov       rcx,	rsi
    mov       rdx,	r10
    mov       r8,	rax
    call      mm_lib.storemode
    inc       rbx
    cmp       rbx,	r13
    jle       L7321
L7323:
    mov       rax,	rdi
L7318:
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.strexpr
mm_lib.strexpr:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	[mm_lib.exprstr]
    call      mlib.gs_init
    mov       rcx,	[mm_lib.exprstr]
    mov       rdx,	rdi
    call      mm_lib.jevalx2
    mov       rax,	[mm_lib.exprstr]
L7324:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_lib.jevalx2
mm_lib.jevalx2:
;?>>
   %define R.dest rdi
   %define R.p rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       [mm_lib.jdest],	rdi
    mov       rcx,	rbx
    call      mm_lib.jevalx
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.jevalx
mm_lib.jevalx:
;?>>
   %define R.p r12
   %define R.q rdi
   %define R.a rbx
   %define R.b rsi
    %define mm_lib.jevalx.str -504
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	544
    mov       r12,	rcx
;---------------
    test      r12,	r12
    jnz       L7328
    jmp       L7326
L7328:
    mov       rbx,	[r12+16]
    mov       rsi,	[r12+24]
    movzx     rax,	byte [r12]
    cmp       rax,	1
    jz        L7330
    cmp       rax,	4
    jz        L7331
    cmp       rax,	35
    jz        L7332
    cmp       rax,	33
    jz        L7332
    cmp       rax,	36
    jz        L7333
    cmp       rax,	18
    jz        L7333
    cmp       rax,	17
    jz        L7333
    cmp       rax,	37
    jz        L7334
    cmp       rax,	32
    jz        L7335
    cmp       rax,	46
    jz        L7336
    cmp       rax,	51
    jz        L7336
    cmp       rax,	48
    jz        L7336
    cmp       rax,	52
    jz        L7336
    cmp       rax,	49
    jz        L7337
    cmp       rax,	20
    jz        L7338
    cmp       rax,	21
    jz        L7339
    cmp       rax,	28
    jz        L7340
    cmp       rax,	92
    jz        L7341
    cmp       rax,	62
    jz        L7342
    cmp       rax,	58
    jz        L7343
    cmp       rax,	61
    jz        L7343
    cmp       rax,	59
    jz        L7344
    cmp       rax,	60
    jz        L7345
    cmp       rax,	27
    jz        L7346
    cmp       rax,	53
    jz        L7347
    cmp       rax,	6
    jz        L7348
    cmp       rax,	2
    jz        L7349
    cmp       rax,	55
    jz        L7350
    cmp       rax,	56
    jz        L7351
    cmp       rax,	67
    jz        L7352
    cmp       rax,	74
    jz        L7353
    cmp       rax,	73
    jz        L7353
    cmp       rax,	68
    jz        L7354
    cmp       rax,	86
    jz        L7355
    cmp       rax,	90
    jz        L7356
    cmp       rax,	40
    jz        L7357
    cmp       rax,	13
    jz        L7358
    jmp       L7359
L7330:
    movsxd    rax,	dword [r12+49]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    cmp       r10,	16
    jz        L7361
    cmp       r10,	3
    jz        L7361
    cmp       r10,	14
    jz        L7361
    cmp       r10,	15
    jz        L7361
    cmp       r10,	19
    jz        L7362
    cmp       r10,	4
    jz        L7362
    cmp       r10,	17
    jz        L7362
    cmp       r10,	18
    jz        L7362
    cmp       r10,	12
    jz        L7363
    cmp       r10,	5
    jz        L7363
    cmp       r10,	1
    jz        L7364
    cmp       r10,	2
    jz        L7364
    cmp       r10,	7
    jz        L7365
    jmp       L7366
L7361:
    mov       rax,	[r12+16]
    mov       rcx,	rax
    lea       rdx,	[rbp + mm_lib.jevalx.str]
    call      msys.getstrint
    jmp       L7360
L7362:
    mov       rax,	[r12+16]
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.strword
    lea       rcx,	[rbp + mm_lib.jevalx.str]
    mov       rdx,	rax
    call      strcpy
    jmp       L7360
L7363:
    mov       rax,	[r12+16]
    mov       [rbp + mm_lib.jevalx.str],	al
    xor       eax,	eax
    mov       [rbp + mm_lib.jevalx.str-1],	al
    jmp       L7360
L7364:
    lea       rcx,	[rbp + mm_lib.jevalx.str]
    call      msys.m$print_startstr
    movq      XMM4,	[r12+16]
    movq      XMM0,	XMM4
    xor       edx,	edx
    call      msys.m$print_r64
    call      msys.m$print_end
    jmp       L7360
L7365:
    movsxd    rax,	dword [r12+49]
    cmp       rax,	20
    jnz       L7368
    mov       al,	[r12+44]
    test      al,	al
    jz        L7368
    mov       eax,	[r12+40]
    cmp       rax,	250
    jle       L7370
    lea       rcx,	[rbp + mm_lib.jevalx.str]
    lea       rdx,	[L13183]
    call      strcpy
    jmp       L7369
L7370:
    mov       rax,	[r12+16]
    mov       rcx,	rax
    lea       rdx,	[rbp + mm_lib.jevalx.str]
    call      pc_api.convertstring
L7369:
    lea       rcx,	[L13184]
    call      mm_lib.jadditem
    lea       rcx,	[rbp + mm_lib.jevalx.str]
    call      mm_lib.jadditem
    lea       rcx,	[L13184]
    call      mm_lib.jadditem
    jmp       L7326
L7368:
    lea       rcx,	[rbp + mm_lib.jevalx.str]
    call      msys.m$print_startstr
    mov       rcx,	[r12+16]
    call      msys.m$print_ptr_nf
    call      msys.m$print_end
L7367:
    jmp       L7360
L7366:
    lea       rcx,	[rbp + mm_lib.jevalx.str]
    lea       rdx,	[L13185]
    call      strcpy
L7360:
    lea       rcx,	[rbp + mm_lib.jevalx.str]
    call      mm_lib.jadditem
    jmp       L7329
L7331:
    mov       rax,	[r12+16]
    mov       rcx,	[rax]
    call      mm_lib.jadditem
    jmp       L7329
L7332:
    movzx     rax,	byte [r12+62]
    lea       r10,	[pc_tables.pclnames]
    mov       r10,	[r10 + rax*8]
    lea       rcx,	[rbp + mm_lib.jevalx.str]
    mov       rdx,	r10
    call      strcpy
    lea       rcx,	[L13186]
    call      mm_lib.jadditem
    mov       rcx,	rbx
    call      mm_lib.jevalx
    lea       rcx,	[rbp + mm_lib.jevalx.str]
    call      mm_lib.jadditem
    mov       rcx,	rsi
    call      mm_lib.jevalx
    lea       rcx,	[L13187]
    call      mm_lib.jadditem
    jmp       L7329
L7333:
    movzx     rax,	byte [r12+62]
    lea       r10,	[pc_tables.pclnames]
    mov       r10,	[r10 + rax*8]
    lea       rcx,	[rbp + mm_lib.jevalx.str]
    mov       rdx,	r10
    call      strcpy
    lea       rcx,	[rbp + mm_lib.jevalx.str]
    call      mm_lib.jadditem
    lea       rcx,	[L13188]
    call      mm_lib.jadditem
    movzx     rax,	byte [rbx]
    cmp       rax,	62
    jnz       L7372
    mov       rax,	[rbx+16]
    mov       rcx,	rax
    mov       rdx,	1
    call      mm_lib.strmode
    mov       rcx,	rax
    call      mm_lib.jadditem
    jmp       L7371
L7372:
    mov       rcx,	rbx
    call      mm_lib.jevalx
L7371:
    lea       rcx,	[L13189]
    call      mm_lib.jadditem
    jmp       L7329
L7334:
    movzx     rax,	byte [r12+62]
    lea       r10,	[mm_tables.propnames]
    mov       r10,	[r10 + rax*8-8]
    lea       rcx,	[rbp + mm_lib.jevalx.str]
    mov       rdx,	r10
    call      strcpy
    lea       rcx,	[rbp + mm_lib.jevalx.str]
    call      mm_lib.jadditem
    lea       rcx,	[L13190]
    call      mm_lib.jadditem
    mov       rcx,	rbx
    call      mm_lib.jevalx
    lea       rcx,	[L13191]
    call      mm_lib.jadditem
    jmp       L7329
L7335:
    mov       rcx,	rbx
    call      mm_lib.jevalx
    lea       rcx,	[L13192]
    call      mm_lib.jadditem
    mov       rdi,	rsi
    jmp       L7374
L7373:
    mov       rcx,	rdi
    call      mm_lib.jevalx
    mov       rdi,	[rdi+8]
    test      rdi,	rdi
    jz        L7377
    lea       rcx,	[L13193]
    call      mm_lib.jadditem
L7377:
L7374:
    test      rdi,	rdi
    jnz       L7373
    lea       rcx,	[L13194]
    call      mm_lib.jadditem
    jmp       L7329
L7336:
    mov       rcx,	rbx
    call      mm_lib.jevalx
    movzx     rax,	byte [r12]
    cmp       rax,	51
    jz        L7380
    movzx     rax,	byte [r12]
    cmp       rax,	52
    jnz       L7379
L7380:
    lea       rcx,	[L13195]
    call      mm_lib.jadditem
L7379:
    lea       rcx,	[L13196]
    call      mm_lib.jadditem
    mov       rcx,	rsi
    call      mm_lib.jevalx
    lea       rcx,	[L13197]
    call      mm_lib.jadditem
    jmp       L7329
L7337:
    mov       rcx,	rbx
    call      mm_lib.jevalx
    lea       rcx,	[L13198]
    call      mm_lib.jadditem
    mov       rcx,	rsi
    call      mm_lib.jevalx
    jmp       L7329
L7338:
    lea       rcx,	[L13199]
    call      mm_lib.jadditem
    mov       rdi,	rbx
    jmp       L7382
L7381:
    mov       rcx,	rdi
    call      mm_lib.jevalx
    mov       rdi,	[rdi+8]
    test      rdi,	rdi
    jz        L7385
    lea       rcx,	[L13200]
    call      mm_lib.jadditem
L7385:
L7382:
    test      rdi,	rdi
    jnz       L7381
    lea       rcx,	[L13201]
    call      mm_lib.jadditem
    jmp       L7329
L7339:
    lea       rcx,	[L13202]
    call      mm_lib.jadditem
    mov       rcx,	rbx
    call      mm_lib.jevalx
    lea       rcx,	[L13203]
    call      mm_lib.jadditem
    mov       rcx,	rsi
    call      mm_lib.jevalx
    lea       rcx,	[L13204]
    call      mm_lib.jadditem
    jmp       L7329
L7340:
    mov       rcx,	rbx
    call      mm_lib.jevalx
    lea       rcx,	[L13205]
    call      mm_lib.jadditem
    mov       rcx,	rsi
    call      mm_lib.jevalx
    jmp       L7329
L7341:
    lea       rcx,	[L13206]
    call      mm_lib.jadditem
    mov       rcx,	rbx
    call      mm_lib.jevalx
    lea       rcx,	[L13207]
    call      mm_lib.jadditem
    mov       rcx,	rsi
    call      mm_lib.jevalx
    lea       rcx,	[L13207]
    call      mm_lib.jadditem
    mov       rcx,	[r12+32]
    call      mm_lib.jevalx
    lea       rcx,	[L13208]
    call      mm_lib.jadditem
    jmp       L7329
L7342:
    movsxd    rax,	dword [r12+49]
    mov       rcx,	rax
    mov       rdx,	1
    call      mm_lib.strmode
    mov       rcx,	rax
    call      mm_lib.jadditem
    jmp       L7329
L7343:
    movsxd    rax,	dword [r12+53]
    mov       rcx,	rax
    mov       rdx,	1
    call      mm_lib.strmode
    mov       rcx,	rax
    call      mm_lib.jadditem
    movzx     rax,	byte [r12]
    cmp       rax,	61
    jnz       L7387
    lea       rcx,	[L13209]
    call      mm_lib.jadditem
L7387:
    lea       rcx,	[L13210]
    call      mm_lib.jadditem
    mov       rcx,	rbx
    call      mm_lib.jevalx
    lea       rcx,	[L13211]
    call      mm_lib.jadditem
    jmp       L7329
L7344:
    lea       rcx,	[L13212]
    call      mm_lib.jadditem
    mov       rcx,	rbx
    call      mm_lib.jevalx
    lea       rcx,	[L13213]
    call      mm_lib.jadditem
    jmp       L7329
L7345:
    lea       rcx,	[L13214]
    call      mm_lib.jadditem
    mov       rcx,	rbx
    call      mm_lib.jevalx
    lea       rcx,	[L13215]
    call      mm_lib.jadditem
    jmp       L7329
L7346:
    mov       rcx,	rbx
    call      mm_lib.jevalx
    lea       rcx,	[L13216]
    call      mm_lib.jadditem
    test      rsi,	rsi
    jz        L7389
    mov       rcx,	[r12+24]
    call      mm_lib.jevalx
    jmp       L7388
L7389:
    lea       rcx,	[L13217]
    call      mm_lib.jaddstr
L7388:
    jmp       L7329
L7347:
    mov       rcx,	rbx
    call      mm_lib.jevalx
    lea       rcx,	[L13218]
    call      mm_lib.jadditem
    jmp       L7329
L7348:
    lea       rcx,	[L13219]
    call      mm_lib.jadditem
    jmp       L7329
L7349:
    lea       rcx,	[L13220]
    call      mm_lib.jaddstr
    jmp       L7329
L7350:
    lea       rcx,	[L13221]
    call      mm_lib.jadditem
    mov       rcx,	rbx
    call      mm_lib.jevalx
    test      rsi,	rsi
    jz        L7391
    lea       rcx,	[L13222]
    call      mm_lib.jaddstr
    mov       rax,	[rsi+16]
    mov       rcx,	[mm_lib.jdest]
    mov       rdx,	rax
    call      mlib.gs_strint
L7391:
    jmp       L7329
L7351:
    lea       rcx,	[L13223]
    call      mm_lib.jadditem
    mov       rcx,	rbx
    call      mm_lib.jevalx
    jmp       L7329
L7352:
    lea       rcx,	[L13224]
    call      mm_lib.jadditem
    mov       rcx,	rbx
    call      mm_lib.jevalx
    lea       rcx,	[L13225]
    call      mm_lib.jadditem
    jmp       L7329
L7353:
    lea       rcx,	[L13226]
    call      mm_lib.jaddstr
    movzx     rax,	byte [r12]
    lea       r10,	[mm_tables.jtagnames]
    mov       r10,	[r10 + rax*8]
    lea       r10,	[r10+1]
    mov       rcx,	r10
    call      mm_lib.jaddstr
    jmp       L7329
L7354:
    mov       rcx,	rbx
    call      mm_lib.jevalx
    lea       rcx,	[L13227]
    call      mm_lib.jaddstr
    movsx     rax,	word [r12+40]
    lea       r10,	[mm_tables.bitfieldnames]
    mov       r10,	[r10 + rax*8-8]
    mov       rcx,	r10
    call      mm_lib.jaddstr
    jmp       L7329
L7355:
    mov       rcx,	rbx
    call      mm_lib.jevalx
    lea       rcx,	[L13228]
    call      mm_lib.jaddstr
    mov       rcx,	rsi
    call      mm_lib.jevalx
    jmp       L7329
L7356:
    movsx     rax,	word [r12+40]
    lea       r10,	[mm_tables.sysfnnames]
    mov       r10,	[r10 + rax*8-8]
    lea       r10,	[r10+3]
    mov       rcx,	r10
    call      mm_lib.jaddstr
    lea       rcx,	[L13229]
    call      mm_lib.jaddstr
    test      rbx,	rbx
    jz        L7393
    mov       rcx,	rbx
    call      mm_lib.jevalx
L7393:
    lea       rcx,	[L13230]
    call      mm_lib.jaddstr
    jmp       L7329
L7357:
    lea       rcx,	[L13231]
    call      mm_lib.jaddstr
    mov       rcx,	rbx
    call      mm_lib.jevalx
    jmp       L7329
L7358:
    lea       rcx,	[L13232]
    call      mm_lib.jaddstr
    mov       rcx,	rbx
    call      mm_lib.jevalx
    jmp       L7329
L7359:
    call      msys.m$print_startcon
    movzx     rax,	byte [r12]
    lea       r10,	[mm_tables.jtagnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L13233]
    mov       rdx,	r12
    call      mm_support.gerror
L7329:
L7326:
;---------------
    add       rsp,	544
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.jadditem
mm_lib.jadditem:
;?>>
   %define R.s rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	[mm_lib.jdest]
    mov       rdx,	rdi
    call      mm_support.gs_additem
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_lib.jaddstr
mm_lib.jaddstr:
;?>>
   %define R.s rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	[mm_lib.jdest]
    mov       rdx,	rdi
    call      mlib.gs_str
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_lib.strmode
mm_lib.strmode:
;?>>
   %define R.m rdi
   %define R.expand rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rdi
    mov       rdx,	rbx
    lea       r8,	[mm_lib.strmode.str]
    call      mm_lib.istrmode
    lea       rax,	[mm_lib.strmode.str]
L7396:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.strmode2
mm_lib.strmode2:
;?>>
   %define R.m rdi
   %define R.expand rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rdi
    mov       rdx,	rbx
    lea       r8,	[mm_lib.strmode2.str]
    call      mm_lib.istrmode
    lea       rax,	[mm_lib.strmode2.str]
L7397:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.istrmode
mm_lib.istrmode:
;?>>
   %define R.m r14
    %define mm_lib.istrmode.expand 72
    %define mm_lib.istrmode.dest 80
   %define R.d rdi
   %define R.q rbx
   %define R.needcomma rsi
   %define R.i r12
   %define R.target r13
    %define mm_lib.istrmode.mbase -8
    %define mm_lib.istrmode.n -16
    %define mm_lib.istrmode.sxx -32
    %define mm_lib.istrmode.xx -40
    %define mm_lib.istrmode.strdim -144
    %define mm_lib.istrmode.prefix -152
    %define mm_lib.istrmode.tn -184
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	224
    mov       r14,	rcx
    mov       [rbp+72],	rdx
    mov       [rbp+80],	r8
;---------------
    lea       rax,	[rbp + mm_lib.istrmode.sxx]
    mov       [rbp + mm_lib.istrmode.xx],	rax
    cmp       r14,	0
    jge       L7400
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    lea       rdx,	[L13234]
    call      strcpy
    mov       rax,	r14
    neg       rax
    lea       r10,	[mm_decls.typenames]
    mov       r11,	rax
    shl       r11,	5
    lea       r10,	[r10 + r11]
    lea       rax,	[rbp + mm_lib.istrmode.tn]
    mov       r11,	[r10]
    mov       [rax],	r11
    mov       r11,	[r10+8]
    mov       [rax+8],	r11
    mov       r11,	[r10+16]
    mov       [rax+16],	r11
    mov       r11,	[r10+24]
    mov       [rax+24],	r11
    mov       rax,	[rbp + mm_lib.istrmode.tn+8]
    test      rax,	rax
    jz        L7402
    mov       rax,	[rbp + mm_lib.istrmode.tn+8]
    mov       rax,	[rax]
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    mov       rdx,	rax
    call      strcat
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    lea       rdx,	[L13235]
    call      strcat
L7402:
    mov       rax,	[rbp + mm_lib.istrmode.tn+16]
    mov       rax,	[rax]
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    mov       rdx,	rax
    call      strcat
    jmp       L7398
L7400:
    cmp       r14,	31
    jge       L7404
    cmp       r14,	7
    jz        L7404
    mov       rcx,	r14
    call      mm_lib.typename
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    mov       rdx,	rax
    call      strcpy
    jmp       L7398
L7404:
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	r14
    movsxd    rax,	dword [rax + r10*4]
    mov       [rbp + mm_lib.istrmode.mbase],	rax
    cmp       rax,	7
    jz        L7406
    cmp       rax,	10
    jz        L7407
    cmp       rax,	11
    jz        L7408
    cmp       rax,	8
    jz        L7409
    test      rax,	rax
    jz        L7410
    cmp       rax,	31
    jz        L7411
    cmp       rax,	24
    jz        L7412
    cmp       rax,	28
    jz        L7413
    cmp       rax,	27
    jz        L7414
    jmp       L7415
L7406:
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    lea       rdx,	[L13236]
    call      strcpy
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	r14
    movsxd    rax,	dword [rax + r10*4]
    mov       r13,	rax
    cmp       r13,	0
    jl        L7417
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	r13
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	8
    jnz       L7417
    mov       rcx,	r13
    call      mm_lib.typename
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    mov       rdx,	rax
    call      strcat
    jmp       L7416
L7417:
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    call      strlen
    mov       r10,	[rbp + mm_lib.istrmode.dest]
    lea       r10,	[r10 + rax]
    lea       rax,	[mm_decls.tttarget]
    mov       r11,	r14
    movsxd    rax,	dword [rax + r11*4]
    mov       rcx,	rax
    xor       edx,	edx
    mov       r8,	r10
    call      mm_lib.istrmode
L7416:
    jmp       L7405
L7407:
    lea       rax,	[mm_decls.ttdimexpr]
    mov       r10,	r14
    mov       rax,	[rax + r10*8]
    test      rax,	rax
    jz        L7419
    lea       rax,	[mm_decls.ttdimexpr]
    mov       r10,	r14
    mov       rax,	[rax + r10*8]
    mov       rcx,	rax
    call      mm_lib.strexpr
    mov       rcx,	rax
    lea       rdx,	[rbp + mm_lib.istrmode.strdim]
    call      mm_support.gs_copytostr
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    call      msys.m$print_startstr
    lea       rcx,	[L13237]
    call      msys.m$print_setfmt
    lea       rcx,	[rbp + mm_lib.istrmode.strdim]
    call      msys.m$print_str_nf
    mov       rcx,	r14
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L7418
L7419:
    lea       rax,	[mm_decls.ttlength]
    mov       r10,	r14
    mov       eax,	[rax + r10*4]
    test      eax,	eax
    jz        L7421
    lea       rax,	[mm_decls.ttlower]
    mov       r10,	r14
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	1
    jnz       L7423
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    call      msys.m$print_startstr
    lea       rcx,	[L13238]
    call      msys.m$print_setfmt
    lea       rax,	[mm_decls.ttlength]
    mov       r10,	r14
    movsxd    rax,	dword [rax + r10*4]
    lea       r10,	[mm_decls.ttlower]
    mov       r11,	r14
    movsxd    r10,	dword [r10 + r11*4]
    add       rax,	r10
    dec       rax
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L7422
L7423:
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    call      msys.m$print_startstr
    lea       rcx,	[L13239]
    call      msys.m$print_setfmt
    lea       rax,	[mm_decls.ttlower]
    mov       r10,	r14
    movsxd    rax,	dword [rax + r10*4]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    lea       rax,	[mm_decls.ttlength]
    mov       r10,	r14
    movsxd    rax,	dword [rax + r10*4]
    lea       r10,	[mm_decls.ttlower]
    mov       r11,	r14
    movsxd    r10,	dword [r10 + r11*4]
    add       rax,	r10
    dec       rax
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
L7422:
    jmp       L7420
L7421:
    lea       rax,	[mm_decls.ttlower]
    mov       r10,	r14
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	1
    jnz       L7425
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    call      msys.m$print_startstr
    lea       rcx,	[L13240]
    call      msys.m$print_setfmt
    call      msys.m$print_end
    jmp       L7424
L7425:
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    call      msys.m$print_startstr
    lea       rcx,	[L13241]
    call      msys.m$print_setfmt
    lea       rax,	[mm_decls.ttlower]
    mov       r10,	r14
    movsxd    rax,	dword [rax + r10*4]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
L7424:
L7420:
L7418:
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    call      strlen
    mov       r10,	[rbp + mm_lib.istrmode.dest]
    lea       r10,	[r10 + rax]
    lea       rax,	[mm_decls.tttarget]
    mov       r11,	r14
    movsxd    rax,	dword [rax + r11*4]
    mov       rcx,	rax
    xor       edx,	edx
    mov       r8,	r10
    call      mm_lib.istrmode
    jmp       L7405
L7408:
    lea       rax,	[mm_tables.stdnames]
    mov       r10,	[rbp + mm_lib.istrmode.mbase]
    mov       rax,	[rax + r10*8]
    mov       [rbp + mm_lib.istrmode.prefix],	rax
    lea       rax,	[mm_decls.ttdimexpr]
    mov       r10,	r14
    mov       rax,	[rax + r10*8]
    test      rax,	rax
    jz        L7427
    lea       rax,	[mm_decls.ttdimexpr]
    mov       r10,	r14
    mov       rax,	[rax + r10*8]
    mov       rcx,	rax
    call      mm_lib.strexpr
    mov       rcx,	rax
    lea       rdx,	[rbp + mm_lib.istrmode.strdim]
    call      mm_support.gs_copytostr
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    call      msys.m$print_startstr
    lea       rcx,	[L13242]
    call      msys.m$print_setfmt
    mov       rcx,	[rbp + mm_lib.istrmode.prefix]
    call      msys.m$print_str_nf
    lea       rcx,	[rbp + mm_lib.istrmode.strdim]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L7426
L7427:
    lea       rax,	[mm_decls.ttlower]
    mov       r10,	r14
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	1
    jnz       L7429
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    mov       rdx,	[rbp + mm_lib.istrmode.prefix]
    call      strcpy
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    lea       rdx,	[L13243]
    call      strcat
    jmp       L7428
L7429:
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    call      msys.m$print_startstr
    lea       rcx,	[L13244]
    call      msys.m$print_setfmt
    mov       rcx,	[rbp + mm_lib.istrmode.prefix]
    call      msys.m$print_str_nf
    lea       rax,	[mm_decls.ttlower]
    mov       r10,	r14
    movsxd    rax,	dword [rax + r10*4]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
L7428:
L7426:
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    call      strlen
    mov       r10,	[rbp + mm_lib.istrmode.dest]
    lea       r10,	[r10 + rax]
    lea       rax,	[mm_decls.tttarget]
    mov       r11,	r14
    movsxd    rax,	dword [rax + r11*4]
    mov       rcx,	rax
    xor       edx,	edx
    mov       r8,	r10
    call      mm_lib.istrmode
    jmp       L7405
L7409:
    mov       rax,	[rbp + mm_lib.istrmode.expand]
    test      rax,	rax
    jnz       L7431
    mov       rcx,	r14
    call      mm_lib.typename
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    mov       rdx,	rax
    call      strcpy
    jmp       L7398
L7431:
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    lea       rdx,	[L13245]
    call      strcpy
    mov       rax,	[rbp + mm_lib.istrmode.expand]
    cmp       rax,	2
    jz        L7433
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	r14
    movsxd    rax,	dword [rax + r10*4]
    mov       rcx,	rax
    call      mm_lib.typename
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    mov       rdx,	rax
    call      strcat
L7433:
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    lea       rdx,	[L13246]
    call      strcat
    lea       rax,	[mm_decls.ttnamedef]
    mov       r10,	r14
    mov       rdi,	[rax + r10*8]
    xor       rsi,	rsi
    mov       rax,	[rdi+16]
    mov       rbx,	rax
    jmp       L7437
L7434:
    test      rsi,	rsi
    jz        L7439
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    lea       rdx,	[L13247]
    call      strcat
L7439:
    mov       rsi,	1
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    call      strlen
    mov       r10,	[rbp + mm_lib.istrmode.dest]
    lea       r10,	[r10 + rax]
    movsxd    rax,	dword [rbx+72]
    mov       rcx,	rax
    xor       edx,	edx
    mov       r8,	r10
    call      mm_lib.istrmode
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    lea       rdx,	[L13248]
    call      strcat
    mov       rax,	[rbx]
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    mov       rdx,	rax
    call      strcat
    mov       rbx,	[rbx+32]
L7437:
    test      rbx,	rbx
    jnz       L7434
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    lea       rdx,	[L13249]
    call      strcat
    jmp       L7405
L7410:
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    lea       rdx,	[L13250]
    call      strcpy
    jmp       L7405
L7411:
    mov       rcx,	r14
    call      mm_lib.typename
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    mov       rdx,	rax
    call      strcpy
    jmp       L7405
L7412:
    lea       rax,	[mm_decls.ttnamedef]
    mov       r10,	r14
    mov       rdi,	[rax + r10*8]
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    lea       rdx,	[L13251]
    call      strcpy
    mov       rbx,	[rdi+112]
    xor       rsi,	rsi
    jmp       L7441
L7440:
    test      rsi,	rsi
    jz        L7444
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    lea       rdx,	[L13252]
    call      strcat
L7444:
    mov       rsi,	1
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    call      strlen
    mov       r10,	[rbp + mm_lib.istrmode.dest]
    lea       r10,	[r10 + rax]
    movsxd    rax,	dword [rbx+72]
    mov       rcx,	rax
    xor       edx,	edx
    mov       r8,	r10
    call      mm_lib.istrmode
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    lea       rdx,	[L13253]
    call      strcat
    mov       rax,	[rbx]
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    mov       rdx,	rax
    call      strcat
    mov       rbx,	[rbx+32]
L7441:
    test      rbx,	rbx
    jnz       L7440
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    lea       rdx,	[L13254]
    call      strcat
    movsxd    rax,	dword [rdi+72]
    test      rax,	rax
    jz        L7446
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    call      strlen
    mov       r10,	[rbp + mm_lib.istrmode.dest]
    lea       r10,	[r10 + rax]
    movsxd    rax,	dword [rdi+72]
    mov       rcx,	rax
    xor       edx,	edx
    mov       r8,	r10
    call      mm_lib.istrmode
L7446:
    jmp       L7405
L7413:
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    lea       rdx,	[L13255]
    call      strcpy
    lea       rax,	[mm_decls.ttlength]
    mov       r10,	r14
    movsxd    rax,	dword [rax + r10*4]
    mov       [rbp + mm_lib.istrmode.n],	rax
    mov       r12,	1
    mov       rax,	[rbp + mm_lib.istrmode.n]
    cmp       rax,	1
    jl        L7449
L7447:
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    call      strlen
    mov       r10,	[rbp + mm_lib.istrmode.dest]
    lea       r10,	[r10 + rax]
    lea       rax,	[mm_decls.ttmult]
    mov       r11,	r14
    mov       rax,	[rax + r11*8]
    mov       r11,	r12
    movsxd    rax,	dword [rax + r11*4-4]
    mov       rcx,	rax
    xor       edx,	edx
    mov       r8,	r10
    call      mm_lib.istrmode
    cmp       r12,	[rbp + mm_lib.istrmode.n]
    jge       L7451
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    lea       rdx,	[L13256]
    call      strcat
L7451:
    inc       r12
    cmp       r12,	[rbp + mm_lib.istrmode.n]
    jle       L7447
L7449:
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    lea       rdx,	[L13257]
    call      strcat
    jmp       L7405
L7414:
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    lea       rdx,	[L13258]
    call      strcpy
    jmp       L7405
L7415:
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	r14
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	31
    jge       L7453
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    lea       rdx,	[L13259]
    call      strcpy
    mov       rcx,	[rbp + mm_lib.istrmode.dest]
    call      strlen
    mov       r10,	[rbp + mm_lib.istrmode.dest]
    lea       r10,	[r10 + rax]
    lea       rax,	[mm_decls.tttarget]
    mov       r11,	r14
    movsxd    rax,	dword [rax + r11*4]
    mov       rcx,	rax
    xor       edx,	edx
    mov       r8,	r10
    call      mm_lib.istrmode
    jmp       L7452
L7453:
    call      msys.m$print_startcon
    mov       rcx,	r14
    call      mm_lib.typename
    mov       rcx,	rax
    call      msys.m$print_str_nf
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	r14
    movsxd    rax,	dword [rax + r10*4]
    mov       rcx,	rax
    mov       rdx,	1
    call      mm_lib.strmode
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L13260]
    call      mm_support.mcerror
L7452:
L7405:
L7398:
;---------------
    add       rsp,	224
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.addtoproclist
mm_lib.addtoproclist:
;?>>
   %define R.d rbx
   %define R.pp rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rcx,	16
    call      mlib.pcm_allocnfz
    mov       rdi,	rax
    mov       rax,	[mm_decls.proclist]
    test      rax,	rax
    jnz       L7456
    mov       rax,	rdi
    mov       [mm_decls.proclistx],	rax
    mov       [mm_decls.proclist],	rax
    jmp       L7455
L7456:
    mov       rax,	rdi
    mov       r10,	[mm_decls.proclistx]
    mov       [r10+8],	rax
    mov       [mm_decls.proclistx],	rdi
L7455:
    mov       [rdi],	rbx
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.addstatic
mm_lib.addstatic:
;?>>
   %define R.d rbx
   %define R.pp rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rcx,	16
    call      mlib.pcm_allocnfz
    mov       rdi,	rax
    mov       rax,	[mm_decls.staticlist]
    test      rax,	rax
    jnz       L7459
    mov       rax,	rdi
    mov       [mm_decls.staticlistx],	rax
    mov       [mm_decls.staticlist],	rax
    jmp       L7458
L7459:
    mov       rax,	rdi
    mov       r10,	[mm_decls.staticlistx]
    mov       [r10+8],	rax
    mov       [mm_decls.staticlistx],	rdi
L7458:
    mov       [rdi],	rbx
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.addexpconst
mm_lib.addexpconst:
;?>>
   %define R.d rbx
   %define R.pp rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rcx,	16
    call      mlib.pcm_allocnfz
    mov       rdi,	rax
    mov       rax,	[mm_decls.constlist]
    test      rax,	rax
    jnz       L7462
    mov       rax,	rdi
    mov       [mm_decls.constlistx],	rax
    mov       [mm_decls.constlist],	rax
    jmp       L7461
L7462:
    mov       rax,	rdi
    mov       r10,	[mm_decls.constlistx]
    mov       [r10+8],	rax
    mov       [mm_decls.constlistx],	rdi
L7461:
    mov       [rdi],	rbx
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.typename
mm_lib.typename:
;?>>
   %define R.m rcx
;?]]
;---------------
    cmp       rcx,	0
    jl        L7465
    lea       rax,	[mm_decls.ttname]
    mov       r10,	rcx
    mov       rax,	[rax + r10*8]
    jmp       L7463
L7465:
    mov       rax,	rcx
    neg       rax
    lea       r10,	[mm_decls.typenames]
    mov       r11,	rax
    shl       r11,	5
    lea       r10,	[r10 + r11]
    mov       r10,	[r10+16]
    mov       r10,	[r10]
    mov       rax,	r10
L7463:
;---------------
    ret       
;End 
;Proc mm_lib.allocunitrec
mm_lib.allocunitrec:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
;---------------
    inc       qword [mm_decls.nunits]
    mov       rax,	65
    add       [mm_decls.nunitsmem],	rax
    mov       rax,	[mm_lib.remainingunits]
    dec       qword [mm_lib.remainingunits]
    test      rax,	rax
    jz        L7468
    mov       rdi,	[mm_lib.unitheapptr]
    add       qword [mm_lib.unitheapptr],	65
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       [rdi+4],	eax
    mov       al,	[mm_decls.currmoduleno]
    mov       [rdi+57],	al
    lea       rax,	[mm_decls.moduletosub]
    mov       r10,	[mm_decls.currmoduleno]
    mov       al,	[rax + r10]
    mov       [rdi+58],	al
    mov       rax,	rdi
    jmp       L7466
L7468:
    mov       rcx,	2129920
    call      mlib.pcm_alloc
    mov       [mm_lib.unitheapptr],	rax
    mov       rdi,	rax
    mov       rcx,	rdi
    xor       edx,	edx
    mov       r8,	2129920
    call      memset
    mov       rax,	32767
    mov       [mm_lib.remainingunits],	rax
    add       qword [mm_lib.unitheapptr],	65
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       [rdi+4],	eax
    mov       al,	[mm_decls.currmoduleno]
    mov       [rdi+57],	al
    lea       rax,	[mm_decls.moduletosub]
    mov       r10,	[mm_decls.currmoduleno]
    mov       al,	[rax + r10]
    mov       [rdi+58],	al
    mov       rax,	rdi
L7466:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_lib.createdupldef
mm_lib.createdupldef:
;?>>
   %define R.owner rbx
   %define R.symptr rsi
   %define R.id r12
   %define R.p rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
;---------------
    call      mm_lib.newstrec
    mov       rdi,	rax
    mov       rax,	[rsi]
    mov       [rdi],	rax
    mov       al,	[rsi+76]
    mov       [rdi+76],	al
    mov       al,	67
    mov       [rdi+77],	al
    mov       [rdi+8],	rbx
    mov       [rdi+78],	r12b
    mov       rax,	[rsi+40]
    mov       [rdi+40],	rax
    mov       [rsi+40],	rdi
    test      rbx,	rbx
    jz        L7471
    mov       rax,	[rbx+16]
    test      rax,	rax
    jnz       L7473
    mov       rax,	rdi
    mov       [rbx+24],	rax
    mov       [rbx+16],	rax
    jmp       L7472
L7473:
    mov       rax,	[rbx+24]
    mov       r10,	rdi
    mov       [rax+32],	r10
    mov       [rbx+24],	rdi
L7472:
L7471:
    mov       rax,	rdi
L7469:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.createnewmoduledef
mm_lib.createnewmoduledef:
;?>>
   %define R.owner rdi
   %define R.symptr rbx
   %define R.id rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mm_lib.createdupldef
L7474:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.duplunit
mm_lib.duplunit:
;?>>
   %define R.p r12
    %define mm_lib.duplunit.lineno 56
   %define R.q rdi
   %define R.av_1 rbx
   %define R.i rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       r12,	rcx
;---------------
    test      r12,	r12
    jnz       L7477
    xor       eax,	eax
    jmp       L7475
L7477:
    movzx     rax,	byte [r12]
    mov       rcx,	rax
    call      mm_lib.createunit0
    mov       rdi,	rax
    mov       rax,	r12
    push      rdi
    mov       r11,	8
L13261:
    mov       r10,	[rax]
    mov       [rdi],	r10
    add       rdi,	8
    add       rax,	8
    dec       r11
    jnz       L13261
    mov       r10b,	[rax]
    mov       [rdi],	r10b
    pop       rdi
    xor       eax,	eax
    mov       [rdi+8],	rax
    mov       rsi,	1
    movzx     rax,	byte [rdi]
    lea       r10,	[mm_tables.jsubs]
    movzx     r10,	byte [r10 + rax]
    mov       rbx,	r10
    cmp       rbx,	1
    jl        L7480
L7478:
    lea       rax,	[rdi+16]
    mov       r10,	rsi
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rax
    xor       edx,	edx
    call      mm_lib.duplunit
    lea       r10,	[rdi+16]
    mov       r11,	rsi
    mov       [r10 + r11*8-8],	rax
    inc       rsi
    cmp       rsi,	rbx
    jle       L7478
L7480:
    mov       rax,	rdi
L7475:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.isconstunit
mm_lib.isconstunit:
;?>>
   %define R.a rcx
;?]]
;---------------
    movzx     rax,	byte [rcx+60]
L7481:
;---------------
    ret       
;End 
;Proc mm_lib.getownername
mm_lib.getownername:
;?>>
   %define R.d rbx
   %define R.dest rsi
   %define R.owner rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    mov       rdi,	[rbx+8]
    test      rdi,	rdi
    jz        L7485
    movzx     rax,	byte [rdi+78]
    cmp       rax,	1
    jnz       L7484
L7485:
    jmp       L7482
L7484:
    mov       rcx,	rdi
    mov       rdx,	rsi
    call      mm_lib.getownername
    mov       rax,	[rdi]
    mov       rcx,	rsi
    mov       rdx,	rax
    call      strcat
    mov       rcx,	rsi
    lea       rdx,	[L13262]
    call      strcat
L7482:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.getalignment
mm_lib.getalignment:
;?>>
   %define R.m rbx
   %define R.a rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rbx
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	10
    jz        L7488
    cmp       rax,	8
    jz        L7489
    jmp       L7490
L7488:
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	rbx
    movsxd    rax,	dword [rax + r10*4]
    mov       rcx,	rax
    call      mm_lib.getalignment
    jmp       L7486
L7489:
    lea       rax,	[mm_decls.ttnamedef]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8]
    movsx     rax,	word [rax+166]
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L7492
    call      msys.m$print_startcon
    lea       rcx,	[L13263]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rdi,	8
L7492:
    mov       rax,	rdi
    jmp       L7486
L7490:
    lea       rax,	[mm_decls.ttisblock]
    mov       r10,	rbx
    mov       al,	[rax + r10]
    test      al,	al
    jz        L7494
    mov       rax,	8
    jmp       L7486
L7494:
L7487:
    lea       rax,	[mm_decls.ttsize]
    mov       r10,	rbx
    mov       eax,	[rax + r10*4]
    mov       rdi,	rax
    mov       rax,	rdi
    cmp       rax,	1
    jz        L7496
    cmp       rax,	2
    jz        L7496
    cmp       rax,	4
    jz        L7496
    cmp       rax,	8
    jz        L7496
    test      rax,	rax
    jz        L7497
    jmp       L7498
L7496:
    mov       rax,	rdi
    jmp       L7486
L7497:
    mov       rax,	8
    jmp       L7486
L7498:
L7495:
    call      msys.m$print_startcon
    mov       rcx,	rbx
    mov       rdx,	1
    call      mm_lib.strmode
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L13264]
    xor       edx,	edx
    call      mm_support.gerror
    xor       eax,	eax
L7486:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.addlistunit
mm_lib.addlistunit:
;?>>
   %define R.ulist rcx
   %define R.ulistx rdx
   %define R.p r8
;?]]
;---------------
    mov       rax,	[rcx]
    test      rax,	rax
    jnz       L7501
    mov       rax,	r8
    mov       [rdx],	rax
    mov       [rcx],	rax
    jmp       L7500
L7501:
    mov       rax,	[rdx]
    mov       r10,	r8
    mov       [rax+8],	r10
L7500:
    mov       [rdx],	r8
;---------------
    ret       
;End 
;Proc mm_lib.storemode
mm_lib.storemode:
;?>>
   %define R.owner rbx
   %define R.m rsi
   %define R.pmode r12
   %define R.r rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
;---------------
    cmp       rsi,	0
    jl        L7504
    mov       [r12],	esi
    mov       rax,	rsi
    jmp       L7502
L7504:
    mov       rax,	rsi
    neg       rax
    lea       r10,	[mm_decls.typenames]
    mov       r11,	rax
    shl       r11,	5
    lea       r10,	[r10 + r11]
    mov       rdi,	r10
    mov       rax,	[rdi+24]
    test      rax,	rax
    jnz       L7506
    mov       [rdi],	rbx
    mov       [r12],	esi
    mov       [rdi+24],	r12
    mov       rax,	[rdi+24]
    test      rax,	rax
    jnz       L7508
    lea       rcx,	[L13265]
    call      mm_support.serror
L7508:
    mov       rax,	rsi
    jmp       L7502
L7506:
    mov       rax,	[rdi+16]
    mov       r10,	[rdi+8]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mm_lib.newtypename
    mov       rsi,	rax
    mov       rax,	rsi
    neg       rax
    lea       r10,	[mm_decls.typenames]
    mov       r11,	rax
    shl       r11,	5
    lea       r10,	[r10 + r11]
    mov       rdi,	r10
    mov       [rdi],	rbx
    mov       [r12],	esi
    mov       [rdi+24],	r12
    mov       rax,	rsi
L7502:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.gettypebase
mm_lib.gettypebase:
;?>>
   %define R.m rcx
;?]]
;---------------
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rcx
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	14
    jz        L7511
    cmp       rax,	15
    jz        L7511
    cmp       rax,	16
    jz        L7511
    cmp       rax,	17
    jz        L7512
    cmp       rax,	18
    jz        L7512
    cmp       rax,	19
    jz        L7512
    cmp       rax,	2
    jz        L7513
    cmp       rax,	12
    jz        L7514
    jmp       L7515
L7511:
    mov       rax,	3
    jmp       L7510
L7512:
    mov       rax,	3
    jmp       L7510
L7513:
    mov       rax,	1
    jmp       L7510
L7514:
    mov       rax,	5
    jmp       L7510
L7515:
    mov       rax,	rcx
L7510:
L7509:
;---------------
    ret       
;End 
;Proc mm_lib.writegsfile
mm_lib.writegsfile:
;?>>
   %define R.filename rbx
   %define R.d rsi
   %define R.f rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    mov       rcx,	rbx
    lea       rdx,	[L13266]
    call      fopen
    mov       rdi,	rax
    mov       rcx,	rsi
    mov       rdx,	rdi
    call      mlib.gs_println
    mov       rcx,	rdi
    call      fclose
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.addtolog
mm_lib.addtolog:
;?>>
   %define R.filename rsi
   %define R.logdest r12
   %define R.f rdi
   %define R.c rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    mov       rcx,	rsi
    lea       rdx,	[L13267]
    call      fopen
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L7519
    call      msys.m$print_startcon
    lea       rcx,	[L13268]
    call      msys.m$print_str_nf
    mov       rcx,	rsi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L7517
L7519:
L7520:
    mov       rcx,	rdi
    call      fgetc
    movsxd    r10,	eax
    mov       rbx,	r10
    cmp       rbx,	-1
    jz        L7521
L7523:
    mov       rcx,	rbx
    mov       rdx,	r12
    call      fputc
    jmp       L7520
L7521:
    mov       rcx,	rdi
    call      fclose
L7517:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.getprocretmodes
mm_lib.getprocretmodes:
;?>>
   %define R.p rbx
   %define R.a rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    movzx     rax,	byte [rbx]
    cmp       rax,	32
    jz        L7526
    lea       rcx,	[L13269]
    xor       edx,	edx
    call      mm_support.txerror
L7526:
    mov       rdi,	[rbx+16]
    movzx     rax,	byte [rdi]
    cmp       rax,	4
    jnz       L7529
L7528:
    mov       rax,	[rdi+16]
    jmp       L7527
L7529:
    movsxd    rax,	dword [rdi+49]
    lea       r10,	[mm_decls.tttarget]
    movsxd    r10,	dword [r10 + rax*4]
    lea       rax,	[mm_decls.ttnamedef]
    mov       rax,	[rax + r10*8]
L7527:
L7524:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_lib.getpclmode
mm_lib.getpclmode:
;?>>
   %define R.t rcx
   %define R.u rdi
    push      rdi
;?]]
    sub       rsp,	16
;---------------
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rcx
    movsxd    rax,	dword [rax + r10*4]
    lea       r10,	[mm_tables.stdpcl]
    movzx     r10,	byte [r10 + rax]
    mov       rdi,	r10
    cmp       rdi,	11
    jnz       L7532
    lea       rax,	[mm_decls.ttsize]
    mov       r10,	rcx
    mov       eax,	[rax + r10*4]
    cmp       rax,	8
    jz        L7534
    cmp       rax,	4
    jz        L7535
    cmp       rax,	2
    jz        L7536
    cmp       rax,	1
    jz        L7537
    jmp       L7538
L7534:
    mov       rdi,	6
    jmp       L7533
L7535:
    mov       rdi,	5
    jmp       L7533
L7536:
    mov       rdi,	4
    jmp       L7533
L7537:
    mov       rdi,	3
L7538:
L7533:
L7532:
    mov       rax,	rdi
L7530:
;---------------
    add       rsp,	16
    pop       rdi
    ret       
;End 
;Proc mm_libsources.loadbuiltins
mm_libsources.loadbuiltins:
;?>>
   %define R.pf rdi
   %define R.filename rbx
   %define R.av_1 rsi
   %define R.i r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
;---------------
    mov       r12,	1
    mov       rsi,	13
    cmp       rsi,	1
    jl        L7542
L7540:
    lea       rax,	[mm_libsources.syslibnames]
    mov       r10,	r12
    mov       rbx,	[rax + r10*8-8]
    call      mm_support.newsourcefile
    mov       rdi,	rax
    mov       rcx,	rbx
    call      mlib.extractbasefile
    mov       rcx,	rax
    call      mlib.pcm_copyheapstring
    lea       r10,	[mm_decls.sources]
    mov       r11,	[mm_decls.nsourcefiles]
    mov       r10,	[r10 + r11*8]
    mov       [r10],	rax
    lea       rax,	[mm_decls.sources]
    mov       r10,	[mm_decls.nsourcefiles]
    mov       rax,	[rax + r10*8]
    mov       r10,	rbx
    mov       [rax+8],	r10
    lea       rax,	[mm_libsources.syslibtext]
    mov       r10,	r12
    mov       rax,	[rax + r10*8-8]
    lea       r10,	[mm_decls.sources]
    mov       r11,	[mm_decls.nsourcefiles]
    mov       r10,	[r10 + r11*8]
    mov       [r10+32],	rax
    lea       rax,	[mm_libsources.syslibtext]
    mov       r10,	r12
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rax
    call      mlib.pcm_copyheapstring
    lea       r10,	[mm_decls.sources]
    mov       r11,	[mm_decls.nsourcefiles]
    mov       r10,	[r10 + r11*8]
    mov       [r10+32],	rax
    lea       rax,	[mm_libsources.syslibtext]
    mov       r10,	r12
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rax
    call      strlen
    lea       r10,	[mm_decls.sources]
    mov       r11,	[mm_decls.nsourcefiles]
    mov       r10,	[r10 + r11*8]
    mov       [r10+48],	rax
    lea       rax,	[mm_decls.sources]
    mov       r10,	[mm_decls.nsourcefiles]
    mov       rax,	[rax + r10*8]
    lea       r10,	[L13270]
    mov       [rax+16],	r10
    lea       rax,	[mm_decls.sources]
    mov       r10,	[mm_decls.nsourcefiles]
    mov       rax,	[rax + r10*8]
    mov       r10,	rbx
    mov       [rax+24],	r10
    lea       rax,	[mm_decls.sources]
    mov       r10,	[mm_decls.nsourcefiles]
    mov       rax,	[rax + r10*8]
    mov       r10b,	1
    mov       [rax+56],	r10b
    lea       rax,	[mm_decls.sources]
    mov       r10,	[mm_decls.nsourcefiles]
    mov       rax,	[rax + r10*8]
    xor       r10d,	r10d
    mov       [rax+57],	r10b
    inc       r12
    cmp       r12,	rsi
    jle       L7540
L7542:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_modules.loadsp
mm_modules.loadsp:
;?>>
    %define mm_modules.loadsp.filename 64
    %define mm_modules.loadsp.mainsub 72
   %define R.sp rdi
    %define mm_modules.loadsp.modnames -2000
    %define mm_modules.loadsp.aliases -4000
    %define mm_modules.loadsp.paths -6000
    %define mm_modules.loadsp.subnames -8000
    %define mm_modules.loadsp.subpaths -10000
   %define R.nmods rbx
   %define R.nsubs rsi
   %define R.hdrcode r12
   %define R.firstmod r13
   %define R.lastmod r14
    %define mm_modules.loadsp.issyslib -10008
    %define mm_modules.loadsp.pm -10016
    %define mm_modules.loadsp.d -10024
    %define mm_modules.loadsp.stalias -10032
    %define mm_modules.loadsp.path -10040
    %define mm_modules.loadsp.name -10048
    %define mm_modules.loadsp.ext -10056
    %define mm_modules.loadsp.proj -10064
    %define mm_modules.loadsp.sepheader -10072
    %define mm_modules.loadsp.i -10080
    %define mm_modules.loadsp.j -10088
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	10128
    mov       [rbp+64],	rcx
    mov       [rbp+72],	rdx
;---------------
    xor       rbx,	rbx
    xor       eax,	eax
    mov       rsi,	rax
    xor       eax,	eax
    mov       [rbp + mm_modules.loadsp.issyslib],	rax
    xor       eax,	eax
    mov       [rbp + mm_modules.loadsp.proj],	al
    xor       eax,	eax
    mov       [rbp + mm_modules.loadsp.sepheader],	al
    mov       rcx,	[rbp + mm_modules.loadsp.filename]
    call      mlib.extractbasefile
    mov       rcx,	rax
    mov       rdx,	[mm_cli.syslibname]
    call      mlib.eqstring
    test      rax,	rax
    jz        L7545
    mov       rax,	1
    mov       [rbp + mm_modules.loadsp.issyslib],	rax
L7545:
    mov       rcx,	[rbp + mm_modules.loadsp.filename]
    xor       edx,	edx
    call      mlib.extractext
    mov       [rbp + mm_modules.loadsp.ext],	rax
    mov       rcx,	[rbp + mm_modules.loadsp.ext]
    lea       rdx,	[L13271]
    call      mlib.eqstring
    test      rax,	rax
    jnz       L7547
    mov       rcx,	[rbp + mm_modules.loadsp.ext]
    call      mlib.pcm_copyheapstring
    mov       [mm_modules.fileext],	rax
L7547:
    mov       rcx,	[rbp + mm_modules.loadsp.filename]
    mov       rdx,	[rbp + mm_modules.loadsp.issyslib]
    call      mm_modules.loadmodule
    mov       [rbp + mm_modules.loadsp.pm],	rax
    mov       rax,	[rbp + mm_modules.loadsp.pm]
    test      rax,	rax
    jnz       L7549
    lea       rcx,	[L13272]
    mov       rdx,	[rbp + mm_modules.loadsp.filename]
    lea       r8,	[L13273]
    call      mm_support.loaderror
L7549:
    mov       rax,	[rbp + mm_modules.loadsp.pm]
    mov       rax,	[rax+8]
    mov       rax,	[rax+16]
    mov       [rbp + mm_modules.loadsp.path],	rax
    mov       rax,	1
    mov       [rbp + mm_modules.loadsp.i],	rax
    mov       rax,	[mm_decls.nsubprogs]
    cmp       rax,	1
    jl        L7552
L7550:
    lea       rax,	[mm_decls.subprogs]
    mov       r10,	[rbp + mm_modules.loadsp.i]
    mov       rax,	[rax + r10*8]
    mov       rax,	[rax]
    mov       r10,	[rbp + mm_modules.loadsp.pm]
    mov       r10,	[r10]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mlib.eqstring
    test      rax,	rax
    jz        L7554
    mov       rax,	[rdi]
    lea       rcx,	[L13274]
    mov       rdx,	rax
    lea       r8,	[L13275]
    call      mm_support.loaderror
L7554:
    mov       rax,	[rbp + mm_modules.loadsp.i]
    inc       rax
    mov       [rbp + mm_modules.loadsp.i],	rax
    cmp       rax,	[mm_decls.nsubprogs]
    jle       L7550
L7552:
    mov       rax,	[rbp + mm_modules.loadsp.pm]
    mov       rcx,	[rax+8]
    call      mm_lex.startlex
    call      mm_lex.lex
    call      mm_parse.skipsemi
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	115
    jnz       L7556
    mov       al,	1
    mov       [rbp + mm_modules.loadsp.proj],	al
    mov       rcx,	41
    call      mm_parse.lexchecksymbol
    call      mm_lex.lex
L7556:
L7557:
    call      mm_parse.skipsemi
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	125
    jz        L7560
    cmp       rax,	4
    jz        L7561
    jmp       L7562
L7560:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    mov       r12,	rax
    call      mm_lex.lex
    mov       rax,	r12
    cmp       rax,	1
    jz        L7564
    cmp       rax,	2
    jz        L7565
    cmp       rax,	4
    jz        L7566
    cmp       rax,	3
    jz        L7567
    jmp       L7568
L7564:
    mov       rcx,	67
    call      mm_parse.checksymbol
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       rax,	[rax]
    mov       [rbp + mm_modules.loadsp.name],	rax
    mov       rax,	[rbp + mm_modules.loadsp.pm]
    mov       rax,	[rax]
    mov       rcx,	[rbp + mm_modules.loadsp.name]
    mov       rdx,	rax
    call      mlib.eqstring
    test      rax,	rax
    jnz       L7570
    cmp       rbx,	250
    jl        L7572
    lea       rcx,	[L13276]
    lea       rdx,	[L13277]
    lea       r8,	[L13277]
    call      mm_support.loaderror
L7572:
    inc       rbx
    mov       rax,	rbx
    mov       r10,	[rbp + mm_modules.loadsp.name]
    mov       [rbp + rax*8 + mm_modules.loadsp.modnames-8],	r10
    mov       rax,	[rbp + mm_modules.loadsp.path]
    mov       [rbp + rbx*8 + mm_modules.loadsp.paths-8],	rax
    xor       eax,	eax
    mov       [rbp + rbx*8 + mm_modules.loadsp.aliases-8],	rax
L7570:
    lea       rax,	[mm_decls.nextlx]
    movzx     rax,	byte [rax]
    cmp       rax,	67
    jnz       L7574
    lea       rax,	[mm_decls.nextlx]
    mov       rax,	[rax+8]
    mov       rax,	[rax]
    mov       rcx,	rax
    lea       rdx,	[L13278]
    call      mlib.eqstring
    test      rax,	rax
    jz        L7574
    call      mm_lex.lex
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	67
    jnz       L7576
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       [rbp + mm_modules.loadsp.stalias],	rax
    call      mm_lex.lex
    jmp       L7575
L7576:
    mov       rcx,	65
    call      mm_parse.checksymbol
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       rcx,	rax
    call      mm_lex.addnamestr
    mov       [rbp + mm_modules.loadsp.stalias],	rax
L7575:
    mov       rax,	[rbp + mm_modules.loadsp.stalias]
    mov       [rbp + rbx*8 + mm_modules.loadsp.aliases-8],	rax
L7574:
    jmp       L7563
L7565:
    mov       rcx,	67
    call      mm_parse.checksymbol
    cmp       rsi,	250
    jl        L7578
    lea       rcx,	[L13279]
    lea       rdx,	[L13280]
    lea       r8,	[L13280]
    call      mm_support.loaderror
L7578:
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       rax,	[rax]
    inc       rsi
    mov       r10,	rsi
    mov       [rbp + r10*8 + mm_modules.loadsp.subnames-8],	rax
    mov       rax,	[rbp + mm_modules.loadsp.path]
    mov       [rbp + rsi*8 + mm_modules.loadsp.subpaths-8],	rax
    jmp       L7563
L7566:
    mov       rcx,	67
    call      mm_parse.checksymbol
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       rcx,	[rax]
    call      mm_modules.addlib
    jmp       L7563
L7567:
    mov       rcx,	65
    call      mm_parse.checksymbol
    mov       al,	[mm_decls.loadedfromma]
    test      al,	al
    jnz       L7580
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       rcx,	rax
    call      mlib.pcm_copyheapstring
    mov       [rbp + mm_modules.loadsp.path],	rax
L7580:
    jmp       L7563
L7568:
    lea       rcx,	[L13281]
    lea       rdx,	[L13282]
    lea       r8,	[L13282]
    call      mm_support.loaderror
L7563:
    call      mm_lex.lex
    jmp       L7559
L7561:
    jmp       L7559
L7562:
    jmp       L7558
L7559:
    jmp       L7557
L7558:
    mov       al,	[rbp + mm_modules.loadsp.proj]
    test      al,	al
    jz        L7582
    mov       rcx,	87
    mov       rdx,	115
    xor       r8d,	r8d
    xor       r9d,	r9d
    call      mm_parse.checkend
L7582:
    call      mm_parse.skipsemi
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	59
    jnz       L7584
    mov       al,	1
    mov       [rbp + mm_modules.loadsp.sepheader],	al
L7584:
    mov       rax,	1
    mov       [rbp + mm_modules.loadsp.i],	rax
    cmp       rsi,	1
    jl        L7587
L7585:
    mov       rax,	[rbp + mm_modules.loadsp.pm]
    mov       rax,	[rax]
    mov       r10,	[rbp + mm_modules.loadsp.i]
    mov       r10,	[rbp + r10*8 + mm_modules.loadsp.subnames-8]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mlib.eqstring
    test      rax,	rax
    jz        L7589
    lea       rcx,	[L13283]
    lea       rdx,	[L13284]
    lea       r8,	[L13284]
    call      mm_support.loaderror
L7589:
    mov       rax,	[rbp + mm_modules.loadsp.i]
    mov       rax,	[rbp + rax*8 + mm_modules.loadsp.subnames-8]
    mov       r10,	[rbp + mm_modules.loadsp.i]
    mov       r10,	[rbp + r10*8 + mm_modules.loadsp.subpaths-8]
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_modules.getmodulefilename
    mov       rcx,	rax
    xor       edx,	edx
    call      mm_modules.loadsp
    mov       rax,	[rbp + mm_modules.loadsp.i]
    inc       rax
    mov       [rbp + mm_modules.loadsp.i],	rax
    cmp       rax,	rsi
    jle       L7585
L7587:
    mov       rax,	[mm_decls.nsubprogs]
    cmp       rax,	30
    jl        L7591
    lea       rcx,	[L13285]
    lea       rdx,	[L13286]
    lea       r8,	[L13286]
    call      mm_support.loaderror
L7591:
    mov       rcx,	16
    call      mlib.pcm_allocz
    mov       rdi,	rax
    inc       qword [mm_decls.nsubprogs]
    mov       rax,	[mm_decls.nsubprogs]
    mov       r10,	rdi
    lea       r11,	[mm_decls.subprogs]
    mov       [r11 + rax*8],	r10
    mov       al,	[mm_decls.nsubprogs]
    mov       [rdi+15],	al
    mov       rax,	[rbp + mm_modules.loadsp.mainsub]
    test      rax,	rax
    jz        L7593
    mov       rax,	[mm_decls.nsubprogs]
    mov       [mm_decls.mainsubprogno],	rax
L7593:
    mov       rax,	[mm_decls.nmodules]
    inc       rax
    mov       r13,	rax
    mov       rax,	r13
    add       rax,	rbx
    mov       r14,	rax
    cmp       r14,	300
    jle       L7595
    lea       rcx,	[L13287]
    lea       rdx,	[L13288]
    lea       r8,	[L13288]
    call      mm_support.loaderror
L7595:
    mov       [mm_decls.nmodules],	r14
    mov       ax,	[mm_decls.nsubprogs]
    mov       r10,	[rbp + mm_modules.loadsp.pm]
    mov       [r10+18],	ax
    mov       al,	1
    mov       r10,	[rbp + mm_modules.loadsp.pm]
    mov       [r10+23],	al
    mov       ax,	r13w
    mov       r10,	[rbp + mm_modules.loadsp.pm]
    mov       [r10+16],	ax
    mov       rax,	[rbp + mm_modules.loadsp.pm]
    mov       rax,	[rax]
    mov       rcx,	rax
    call      mm_lex.addnamestr
    mov       rcx,	[mm_decls.stprogram]
    mov       rdx,	rax
    mov       r8,	3
    call      mm_lib.createdupldef
    mov       [rbp + mm_modules.loadsp.d],	rax
    mov       r10,	[rbp + mm_modules.loadsp.pm]
    mov       [r10+24],	rax
    mov       al,	r13b
    mov       r10,	[rbp + mm_modules.loadsp.d]
    mov       [r10+94],	al
    mov       al,	[mm_decls.nsubprogs]
    mov       r10,	[rbp + mm_modules.loadsp.d]
    mov       [r10+95],	al
    mov       al,	[mm_decls.nsubprogs]
    lea       r10,	[mm_decls.moduletosub]
    mov       r11,	r13
    mov       [r10 + r11],	al
    mov       rax,	[rbp + mm_modules.loadsp.pm]
    mov       rax,	[rax]
    mov       [rdi],	rax
    mov       [rdi+8],	r13w
    xor       eax,	eax
    mov       [rdi+10],	ax
    mov       [rdi+12],	r14w
    lea       rax,	[rdi+14]
    mov       r10b,	[rbp + mm_modules.loadsp.issyslib]
    and       byte [rax],	253
    shl       r10b,	1
    or        [rax],	r10b
    mov       rax,	[rbp + mm_modules.loadsp.pm]
    lea       r10,	[mm_decls.modules]
    mov       r11,	r13
    mov       [r10 + r11*8],	rax
    mov       rax,	1
    mov       [rbp + mm_modules.loadsp.i],	rax
    cmp       rbx,	1
    jl        L7598
L7596:
    mov       rax,	[rbp + mm_modules.loadsp.i]
    mov       rax,	[rbp + rax*8 + mm_modules.loadsp.modnames-8]
    mov       r10,	[rbp + mm_modules.loadsp.i]
    mov       r10,	[rbp + r10*8 + mm_modules.loadsp.paths-8]
    mov       rcx,	r10
    mov       rdx,	rax
    mov       r8,	[rbp + mm_modules.loadsp.issyslib]
    call      mm_modules.getmodulefilename
    mov       rcx,	rax
    mov       rdx,	[rbp + mm_modules.loadsp.issyslib]
    call      mm_modules.loadmodule
    mov       [rbp + mm_modules.loadsp.pm],	rax
    mov       rax,	[rbp + mm_modules.loadsp.i]
    mov       rax,	[rbp + rax*8 + mm_modules.loadsp.aliases-8]
    mov       [rbp + mm_modules.loadsp.stalias],	rax
    mov       rax,	[rbp + mm_modules.loadsp.pm]
    test      rax,	rax
    jnz       L7600
    mov       rax,	[rbp + mm_modules.loadsp.i]
    mov       rax,	[rbp + rax*8 + mm_modules.loadsp.modnames-8]
    lea       rcx,	[L13289]
    mov       rdx,	rax
    lea       r8,	[L13290]
    call      mm_support.loaderror
L7600:
    mov       rax,	r13
    add       rax,	[rbp + mm_modules.loadsp.i]
    mov       r10,	[rbp + mm_modules.loadsp.pm]
    lea       r11,	[mm_decls.modules]
    mov       [r11 + rax*8],	r10
    mov       rax,	[rbp + mm_modules.loadsp.pm]
    mov       rax,	[rax]
    mov       rcx,	rax
    call      mm_lex.addnamestr
    mov       rcx,	[mm_decls.stprogram]
    mov       rdx,	rax
    mov       r8,	3
    call      mm_lib.createdupldef
    mov       [rbp + mm_modules.loadsp.d],	rax
    mov       r10,	[rbp + mm_modules.loadsp.pm]
    mov       [r10+24],	rax
    mov       ax,	[mm_decls.nsubprogs]
    mov       r10,	[rbp + mm_modules.loadsp.pm]
    mov       [r10+18],	ax
    mov       rax,	[rbp + mm_modules.loadsp.stalias]
    test      rax,	rax
    jz        L7602
    mov       rcx,	[mm_decls.stprogram]
    mov       rdx,	[rbp + mm_modules.loadsp.stalias]
    mov       r8,	15
    call      mm_lib.getduplnameptr
    mov       r10,	[rbp + mm_modules.loadsp.pm]
    mov       [r10+40],	rax
    mov       rax,	[rbp + mm_modules.loadsp.pm]
    mov       rax,	[rax+40]
    mov       rcx,	[mm_decls.stprogram]
    mov       rdx,	rax
    call      mm_lib.adddef
    mov       rax,	[rbp + mm_modules.loadsp.pm]
    mov       rax,	[rax+40]
    xor       r10d,	r10d
    mov       [rax+112],	r10
    mov       rcx,	[rbp + mm_modules.loadsp.d]
    call      mm_lib.createname
    mov       r10,	[rbp + mm_modules.loadsp.pm]
    mov       r10,	[r10+40]
    mov       [r10+64],	rax
L7602:
    mov       rax,	r13
    add       rax,	[rbp + mm_modules.loadsp.i]
    mov       r10,	[rbp + mm_modules.loadsp.pm]
    mov       [r10+16],	ax
    mov       r10,	[rbp + mm_modules.loadsp.d]
    mov       [r10+94],	al
    mov       al,	[mm_decls.nsubprogs]
    mov       r10,	[rbp + mm_modules.loadsp.d]
    mov       [r10+95],	al
    mov       rax,	[rbp + mm_modules.loadsp.d]
    movzx     rax,	byte [rax+94]
    mov       r10b,	[mm_decls.nsubprogs]
    lea       r11,	[mm_decls.moduletosub]
    mov       [r11 + rax],	r10b
    mov       rax,	1
    mov       [rbp + mm_modules.loadsp.j],	rax
    mov       rax,	[mm_decls.nmodules]
    cmp       rax,	1
    jl        L7605
L7603:
    mov       rax,	[rbp + mm_modules.loadsp.pm]
    mov       rax,	[rax]
    lea       r10,	[mm_decls.modules]
    mov       r11,	[rbp + mm_modules.loadsp.i]
    mov       r10,	[r10 + r11*8]
    mov       r10,	[r10]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mlib.eqstring
    test      rax,	rax
    jz        L7607
    mov       rax,	[rbp + mm_modules.loadsp.pm]
    mov       rax,	[rax]
    lea       rcx,	[L13291]
    mov       rdx,	rax
    call      mm_support.serror_s
L7607:
    mov       rax,	[rbp + mm_modules.loadsp.j]
    inc       rax
    mov       [rbp + mm_modules.loadsp.j],	rax
    cmp       rax,	[mm_decls.nmodules]
    jle       L7603
L7605:
    mov       rax,	[rbp + mm_modules.loadsp.i]
    inc       rax
    mov       [rbp + mm_modules.loadsp.i],	rax
    cmp       rax,	rbx
    jle       L7596
L7598:
    mov       rax,	rdi
L7543:
;---------------
    add       rsp,	10128
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_modules.loadmodule
mm_modules.loadmodule:
;?>>
   %define R.filespec rsi
   %define R.issyslib r12
   %define R.pm rdi
   %define R.pf rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    mov       rcx,	rsi
    mov       rdx,	r12
    call      mm_modules.loadsourcefile
    mov       rbx,	rax
    test      rbx,	rbx
    jnz       L7610
    xor       eax,	eax
    jmp       L7608
L7610:
    mov       rcx,	64
    call      mlib.pcm_allocz
    mov       rdi,	rax
    mov       rax,	[rbx]
    mov       [rdi],	rax
    mov       [rdi+8],	rbx
    mov       ax,	[rbx+64]
    mov       [rdi+20],	ax
    mov       [rdi+22],	r12b
    mov       rax,	rdi
L7608:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_modules.loadsourcefile
mm_modules.loadsourcefile:
;?>>
   %define R.filespec r13
   %define R.issyslib r14
   %define R.pf rdi
   %define R.s rbx
   %define R.filename rsi
   %define R.i r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       r13,	rcx
    mov       r14,	rdx
;---------------
    mov       rcx,	r13
    call      mlib.extractfile
    mov       rsi,	rax
    mov       r12,	1
    mov       rax,	[mm_decls.nsourcefiles]
    cmp       rax,	1
    jl        L7614
L7612:
    lea       rax,	[mm_decls.sources]
    mov       r10,	r12
    mov       rax,	[rax + r10*8]
    mov       rax,	[rax+8]
    mov       rcx,	rsi
    mov       rdx,	rax
    call      mlib.eqstring
    test      rax,	rax
    jz        L7616
    lea       rax,	[mm_decls.sources]
    mov       r10,	r12
    mov       rax,	[rax + r10*8]
    movzx     rax,	byte [rax+56]
    cmp       rax,	r14
    jnz       L7616
    lea       rax,	[mm_decls.sources]
    mov       r10,	r12
    mov       rax,	[rax + r10*8]
    jmp       L7611
L7616:
    inc       r12
    cmp       r12,	[mm_decls.nsourcefiles]
    jle       L7612
L7614:
    call      mm_support.newsourcefile
    mov       rdi,	rax
    mov       rcx,	r13
    call      mlib.pcm_copyheapstring
    mov       [rdi+24],	rax
    mov       rcx,	r13
    call      mlib.extractpath
    mov       rcx,	rax
    call      mlib.pcm_copyheapstring
    mov       [rdi+16],	rax
    mov       rcx,	r13
    call      mlib.extractbasefile
    mov       rcx,	rax
    call      mlib.pcm_copyheapstring
    mov       [rdi],	rax
    mov       rcx,	rsi
    call      mlib.pcm_copyheapstring
    mov       [rdi+8],	rax
    mov       [rdi+56],	r14b
    mov       ax,	[mm_decls.nsourcefiles]
    mov       [rdi+64],	ax
    mov       rcx,	r13
    call      mlib.readfile
    mov       rbx,	rax
    test      rbx,	rbx
    jnz       L7618
    xor       eax,	eax
    jmp       L7611
L7618:
    mov       [rdi+32],	rbx
    mov       rax,	[mlib.rfsize]
    mov       [rdi+48],	rax
    mov       rax,	[mm_decls.passlevel]
    cmp       rax,	1
    jnz       L7620
    mov       rcx,	rbx
    call      mlib.pcm_copyheapstring
    mov       [rdi+40],	rax
L7620:
    xor       eax,	eax
    mov       r10,	[mlib.rfsize]
    mov       [rbx + r10],	al
    mov       rax,	rdi
L7611:
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_modules.getmodulefilename
mm_modules.getmodulefilename:
;?>>
   %define R.path rdi
   %define R.name rbx
   %define R.issyslib rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    lea       rcx,	[mm_modules.getmodulefilename.str]
    mov       rdx,	rdi
    call      strcpy
    lea       rcx,	[mm_modules.getmodulefilename.str]
    mov       rdx,	rbx
    call      strcat
    lea       rcx,	[mm_modules.getmodulefilename.str]
    lea       rdx,	[L13292]
    call      strcat
    test      rsi,	rsi
    jz        L7623
    lea       rax,	[L13293]
    jmp       L7622
L7623:
    mov       rax,	[mm_modules.fileext]
L7622:
    lea       rcx,	[mm_modules.getmodulefilename.str]
    mov       rdx,	rax
    call      strcat
    lea       rax,	[mm_modules.getmodulefilename.str]
L7621:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_modules.addlib
mm_modules.addlib:
;?>>
   %define R.libname rbx
   %define R.i rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rdi,	1
    mov       rax,	[mm_decls.nlibfiles]
    cmp       rax,	1
    jl        L7627
L7625:
    lea       rax,	[mm_decls.libfiles]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8]
    mov       rcx,	rax
    mov       rdx,	rbx
    call      mlib.eqstring
    test      rax,	rax
    jnz       L7624
L7629:
    inc       rdi
    cmp       rdi,	[mm_decls.nlibfiles]
    jle       L7625
L7627:
    mov       rax,	[mm_decls.nlibfiles]
    cmp       rax,	50
    jl        L7631
    lea       rcx,	[L13294]
    lea       rdx,	[L13295]
    lea       r8,	[L13295]
    call      mm_support.loaderror
L7631:
    inc       qword [mm_decls.nlibfiles]
    mov       rax,	[mm_decls.nlibfiles]
    mov       r10,	rbx
    lea       r11,	[mm_decls.libfiles]
    mov       [r11 + rax*8],	r10
L7624:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_modules.loadsyslib
mm_modules.loadsyslib:
;?>>
    %define mm_modules.loadsyslib.str -304
   %define R.name rdi
   %define R.frunpcl bl
   %define R.fgenpcl sil
    push      rdi
    push      rbx
    push      rsi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	344
;---------------
    mov       rax,	[mm_decls.passlevel]
    cmp       rax,	5
    setz      al
    movzx     eax,	al
    mov       bl,	al
    mov       rax,	[mm_decls.passlevel]
    cmp       rax,	4
    setz      al
    movzx     eax,	al
    mov       sil,	al
    mov       al,	[mm_decls.dointlibs]
    test      al,	al
    jz        L7634
    xor       eax,	eax
    mov       [rbp + mm_modules.loadsyslib.str],	al
    jmp       L7633
L7634:
    lea       rcx,	[rbp + mm_modules.loadsyslib.str]
    lea       rdx,	[L13296]
    call      strcpy
L7633:
    movzx     rax,	byte [mm_decls.msyslevel]
    test      rax,	rax
    jz        L7636
    cmp       rax,	1
    jz        L7637
    jmp       L7638
L7636:
    jmp       L7632
L7637:
    xor       eax,	eax
    test      ax,	ax
    jnz       L7641
    call      mwindows.os_iswindows
    test      rax,	rax
    jnz       L7640
L7641:
    lea       rax,	[L13297]
    jmp       L7639
L7640:
    lea       rax,	[L13298]
L7639:
    mov       rdi,	rax
    jmp       L7635
L7638:
    call      mwindows.os_iswindows
    test      rax,	rax
    jz        L7643
    mov       al,	[mm_decls.clinux]
    test      al,	al
    jnz       L7643
    xor       eax,	eax
    test      ax,	ax
    jz        L7645
    lea       rax,	[L13299]
    mov       rdi,	rax
    jmp       L7644
L7645:
    test      bl,	bl
    jnz       L7647
    test      sil,	sil
    jz        L7646
L7647:
    lea       rax,	[L13300]
    mov       rdi,	rax
    jmp       L7644
L7646:
    lea       rax,	[L13301]
    mov       rdi,	rax
L7644:
    jmp       L7642
L7643:
    lea       rax,	[L13302]
    mov       rdi,	rax
L7642:
L7635:
    lea       rcx,	[rbp + mm_modules.loadsyslib.str]
    mov       rdx,	rdi
    call      strcat
    lea       rcx,	[rbp + mm_modules.loadsyslib.str]
    call      mlib.pcm_copyheapstring
    mov       [mm_cli.syslibname],	rax
    mov       rax,	[mm_decls.fverbose]
    cmp       rax,	2
    jl        L7649
    call      msys.m$print_startcon
    lea       rcx,	[L13303]
    call      msys.m$print_str_nf
    mov       rcx,	[mm_cli.syslibname]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L7649:
    lea       rcx,	[rbp + mm_modules.loadsyslib.str]
    lea       rdx,	[L13304]
    call      strcat
    lea       rcx,	[rbp + mm_modules.loadsyslib.str]
    xor       edx,	edx
    call      mm_modules.loadsp
L7632:
;---------------
    add       rsp,	344
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_modules.loadproject
mm_modules.loadproject:
;?>>
   %define R.file rsi
    %define mm_modules.loadproject.str -304
   %define R.file2 rdi
   %define R.tt rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	344
    mov       rsi,	rcx
;---------------
    call      clock
    movsxd    r10,	eax
    mov       rbx,	r10
    mov       al,	[mm_decls.dointlibs]
    test      al,	al
    jz        L7652
    call      mm_libsources.loadbuiltins
L7652:
    call      mm_modules.loadsyslib
    mov       rcx,	rsi
    call      mlib.checkfile
    test      rax,	rax
    jnz       L7654
    mov       rcx,	rsi
    lea       rdx,	[L13305]
    call      mlib.changeext
    mov       rcx,	rax
    call      mlib.pcm_copyheapstring
    mov       rdi,	rax
    mov       rcx,	rdi
    call      mlib.checkfile
    test      rax,	rax
    jz        L7656
    mov       rsi,	rdi
L7656:
L7654:
    mov       rcx,	rsi
    xor       edx,	edx
    call      mlib.extractext
    mov       rcx,	rax
    lea       rdx,	[L13305]
    call      mlib.eqstring
    test      rax,	rax
    jz        L7658
    call      msys.m$print_startcon
    lea       rcx,	[L13306]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	rsi
    xor       edx,	edx
    call      mm_modules.loadmafile
    mov       al,	1
    mov       [mm_decls.loadedfromma],	al
    mov       rcx,	rsi
    lea       rdx,	[L13307]
    call      mlib.changeext
    lea       rcx,	[rbp + mm_modules.loadproject.str]
    mov       rdx,	rax
    call      strcpy
    lea       rax,	[rbp + mm_modules.loadproject.str]
    mov       rsi,	rax
L7658:
    mov       rcx,	rsi
    mov       rdx,	1
    call      mm_modules.loadsp
    lea       rcx,	[L13308]
    call      mm_modules.addlib
    call      mwindows.os_iswindows
    test      rax,	rax
    jz        L7660
    lea       rcx,	[L13309]
    call      mm_modules.addlib
    lea       rcx,	[L13310]
    call      mm_modules.addlib
    lea       rcx,	[L13311]
    call      mm_modules.addlib
L7660:
    call      clock
    movsxd    r10,	eax
    sub       r10,	rbx
    mov       [mm_cli.loadtime],	r10
;---------------
    add       rsp,	344
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_modules.readfileline
mm_modules.readfileline:
;?>>
   %define R.s r12
    %define mm_modules.readfileline.str -2048
   %define R.t rdi
   %define R.n rbx
   %define R.c rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	2080
    mov       r12,	rcx
;---------------
    lea       rax,	[rbp + mm_modules.readfileline.str]
    mov       rdi,	rax
    xor       rbx,	rbx
L7662:
    mov       rax,	r12
    inc       r12
    movzx     rax,	byte [rax]
    mov       rsi,	rax
    test      rax,	rax
    jz        L7664
    cmp       rax,	10
    jz        L7665
    jmp       L7666
L7664:
    dec       r12
    jmp       L7663
L7665:
    jmp       L7663
L7666:
    cmp       rbx,	2048
    jge       L7668
    mov       rax,	rdi
    inc       rdi
    mov       r10b,	sil
    mov       [rax],	r10b
L7668:
    jmp       L7662
L7663:
    xor       eax,	eax
    mov       [rdi],	al
    lea       rcx,	[rbp + mm_modules.readfileline.str]
    call      msys.m$read_strline
    mov       rax,	r12
L7661:
;---------------
    add       rsp,	2080
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_modules.findnextlineheader
mm_modules.findnextlineheader:
;?>>
   %define R.s rcx
   %define R.c rdi
    push      rdi
;?]]
    sub       rsp,	16
;---------------
L7670:
    mov       rax,	rcx
    inc       rcx
    movzx     rax,	byte [rax]
    mov       rdi,	rax
    test      rax,	rax
    jz        L7672
    cmp       rax,	10
    jz        L7673
    jmp       L7674
L7672:
    xor       eax,	eax
    jmp       L7669
L7673:
    movzx     rax,	byte [rcx]
    cmp       rax,	61
    jnz       L7676
    movzx     rax,	byte [rcx+1]
    cmp       rax,	61
    jnz       L7676
    movzx     rax,	byte [rcx+2]
    cmp       rax,	61
    jnz       L7676
    lea       rax,	[rcx+3]
    jmp       L7669
L7676:
    jmp       L7670
L7674:
    jmp       L7670
    xor       eax,	eax
L7669:
;---------------
    add       rsp,	16
    pop       rdi
    ret       
;End 
;Proc mm_modules.loadmafile
mm_modules.loadmafile:
;?>>
   %define R.filespec r15
    %define mm_modules.loadmafile.builtinstr 80
   %define R.s rdi
   %define R.t rbx
    %define mm_modules.loadmafile.name -104
   %define R.sys rsi
   %define R.support r12
   %define R.pf r13
   %define R.i r14
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	136
    mov       r15,	rcx
    mov       [rbp+80],	rdx
;---------------
    test      r15,	r15
    jz        L7679
    mov       rcx,	r15
    call      mlib.readfile
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L7681
    lea       rcx,	[L13312]
    mov       rdx,	r15
    lea       r8,	[L13313]
    call      mm_support.loaderror
L7681:
    jmp       L7678
L7679:
    mov       rdi,	[rbp + mm_modules.loadmafile.builtinstr]
L7678:
    lea       rax,	[rdi+3]
    mov       rcx,	rax
    call      mm_modules.readfileline
    mov       rdi,	rax
    lea       rcx,	[rbp + mm_modules.loadmafile.name]
    mov       rdx,	110
    xor       r8d,	r8d
    call      msys.readstr
    lea       rcx,	[rbp + mm_modules.loadmafile.name]
    lea       rdx,	[L13314]
    call      mlib.eqstring
    test      rax,	rax
    jnz       L7683
    lea       rcx,	[L13315]
    lea       rdx,	[L13316]
    lea       r8,	[L13316]
    call      mm_support.loaderror
L7683:
    dec       rdi
    mov       rcx,	rdi
    call      mm_modules.findnextlineheader
    mov       rdi,	rax
L7684:
    test      rdi,	rdi
    jnz       L7687
    lea       rcx,	[L13317]
    lea       rdx,	[L13318]
    lea       r8,	[L13318]
    call      mm_support.loaderror
    jmp       L7685
L7687:
    mov       rcx,	rdi
    call      mm_modules.readfileline
    mov       rdi,	rax
    lea       rcx,	[rbp + mm_modules.loadmafile.name]
    mov       rdx,	110
    xor       r8d,	r8d
    call      msys.readstr
    xor       ecx,	ecx
    call      msys.m$read_i64
    mov       rsi,	rax
    xor       ecx,	ecx
    call      msys.m$read_i64
    mov       r12,	rax
    lea       rcx,	[rbp + mm_modules.loadmafile.name]
    lea       rdx,	[L13319]
    call      mlib.eqstring
    test      rax,	rax
    jnz       L7685
L7689:
    mov       rax,	[mm_decls.nsourcefiles]
    cmp       rax,	300
    jl        L7691
    lea       rcx,	[L13320]
    lea       rdx,	[L13321]
    lea       r8,	[L13321]
    call      mm_support.loaderror
L7691:
    mov       rcx,	rdi
    call      mm_modules.findnextlineheader
    mov       rbx,	rax
    test      rbx,	rbx
    jnz       L7693
    lea       rcx,	[L13322]
    lea       rdx,	[L13323]
    lea       r8,	[L13323]
    call      mm_support.loaderror
L7693:
    call      mm_support.newsourcefile
    mov       r13,	rax
    lea       rcx,	[rbp + mm_modules.loadmafile.name]
    call      mlib.pcm_copyheapstring
    mov       [r13+24],	rax
    mov       [r13+8],	rax
    lea       rcx,	[rbp + mm_modules.loadmafile.name]
    call      mlib.extractbasefile
    mov       rcx,	rax
    call      mlib.pcm_copyheapstring
    mov       [r13],	rax
    mov       rax,	rbx
    sub       rax,	rdi
    sub       rax,	3
    mov       [r13+48],	rax
    mov       [r13+32],	rdi
    lea       rax,	[L13323]
    mov       [r13+24],	rax
    mov       [r13+16],	rax
    mov       [r13+56],	sil
    mov       [r13+57],	r12b
    mov       rdi,	rbx
    jmp       L7684
L7685:
    mov       r14,	1
    mov       rax,	[mm_decls.nsourcefiles]
    cmp       rax,	1
    jl        L7696
L7694:
    lea       rax,	[mm_decls.sources]
    mov       r10,	r14
    mov       r13,	[rax + r10*8]
    mov       rax,	[r13+32]
    mov       r10,	[r13+48]
    xor       r11d,	r11d
    mov       [rax + r10],	r11b
    inc       r14
    cmp       r14,	[mm_decls.nsourcefiles]
    jle       L7694
L7696:
;---------------
    add       rsp,	136
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_name.rx_typetable
mm_name.rx_typetable:
;?>>
   %define R.d rdi
   %define R.i rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
;---------------
    mov       rbx,	31
    mov       rax,	[mm_decls.ntypes]
    cmp       rax,	31
    jl        L7700
L7698:
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rbx
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	8
    jnz       L7702
    lea       rax,	[mm_decls.ttnamedef]
    mov       r10,	rbx
    mov       rdi,	[rax + r10*8]
    mov       eax,	[rdi+144]
    test      eax,	eax
    jz        L7704
    mov       rcx,	rdi
    call      mm_name.do_baseclass
L7704:
L7702:
    inc       rbx
    cmp       rbx,	[mm_decls.ntypes]
    jle       L7698
L7700:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_name.rx_unit
mm_name.rx_unit:
;?>>
    %define mm_name.rx_unit.owner 72
    %define mm_name.rx_unit.p 80
   %define R.d rdi
   %define R.a rbx
   %define R.b rsi
   %define R.n r12
   %define R.oldnoexpand r13
   %define R.oldnoassem r14
   %define R.oldtag r15
    %define mm_name.rx_unit.useparams -8
    %define mm_name.rx_unit.av_1 -16
    %define mm_name.rx_unit.i -24
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
    mov       [rbp+72],	rcx
    mov       [rbp+80],	rdx
;---------------
    mov       rax,	[rbp + mm_name.rx_unit.p]
    mov       rbx,	[rax+16]
    mov       rax,	[rbp + mm_name.rx_unit.p]
    mov       rsi,	[rax+24]
    mov       rax,	[rbp + mm_name.rx_unit.p]
    mov       eax,	[rax+4]
    mov       [pc_decls.mmpos],	rax
    mov       rax,	[rbp + mm_name.rx_unit.p]
    movzx     rax,	byte [rax]
    sub       rax,	4
    cmp       rax,	46
    jae       L7708
    lea       r10,	[L7707]
    jmp       [r10 + rax*8]
    segment .data
L7707:
    dq  L7709
    dq  L7708
    dq  L7708
    dq  L7708
    dq  L7708
    dq  L7749
    dq  L7708
    dq  L7708
    dq  L7708
    dq  L7708
    dq  L7708
    dq  L7732
    dq  L7732
    dq  L7741
    dq  L7737
    dq  L7708
    dq  L7708
    dq  L7708
    dq  L7708
    dq  L7708
    dq  L7708
    dq  L7708
    dq  L7712
    dq  L7708
    dq  L7708
    dq  L7708
    dq  L7708
    dq  L7708
    dq  L7714
    dq  L7708
    dq  L7708
    dq  L7708
    dq  L7708
    dq  L7708
    dq  L7708
    dq  L7708
    dq  L7708
    dq  L7708
    dq  L7708
    dq  L7708
    dq  L7708
    dq  L7708
    dq  L7708
    dq  L7708
    dq  L7708
    dq  L7713
    segment .text
L7709:
    mov       rcx,	[rbp + mm_name.rx_unit.owner]
    mov       rdx,	[rbp + mm_name.rx_unit.p]
    call      mm_name.resolvename
    mov       rax,	[rbp + mm_name.rx_unit.p]
    movzx     rax,	byte [rax]
    cmp       rax,	4
    jnz       L7711
    mov       rax,	[rbp + mm_name.rx_unit.p]
    mov       rax,	[rax+16]
    movzx     rax,	byte [rax+78]
    cmp       rax,	15
    jnz       L7711
    mov       rax,	[mm_name.noexpand]
    test      rax,	rax
    jnz       L7711
    inc       qword [mm_name.macrolevels]
    mov       rcx,	[rbp + mm_name.rx_unit.p]
    mov       rdx,	[rbp + mm_name.rx_unit.p]
    xor       r8d,	r8d
    call      mm_name.expandmacro
    mov       rcx,	[rbp + mm_name.rx_unit.owner]
    mov       rdx,	[rbp + mm_name.rx_unit.p]
    call      mm_name.rx_unit
    dec       qword [mm_name.macrolevels]
L7711:
    jmp       L7706
L7712:
    mov       rcx,	[rbp + mm_name.rx_unit.owner]
    mov       rdx,	rsi
    call      mm_name.rx_unit
    jmp       L7706
L7713:
    mov       rcx,	[rbp + mm_name.rx_unit.owner]
    mov       rdx,	[rbp + mm_name.rx_unit.p]
    call      mm_name.resolvedot
    jmp       L7706
L7714:
    mov       rax,	[rbp + mm_name.rx_unit.p]
    movzx     rax,	byte [rax]
    mov       r15,	rax
    movzx     rax,	byte [rbx]
    cmp       rax,	4
    jnz       L7716
    mov       r13,	[mm_name.noexpand]
    mov       rax,	1
    mov       [mm_name.noexpand],	rax
    mov       rcx,	[rbp + mm_name.rx_unit.owner]
    mov       rdx,	rbx
    call      mm_name.rx_unit
    mov       [mm_name.noexpand],	r13
    jmp       L7715
L7716:
    mov       rcx,	[rbp + mm_name.rx_unit.owner]
    mov       rdx,	rbx
    call      mm_name.rx_unit
L7715:
    mov       rcx,	[rbp + mm_name.rx_unit.owner]
    mov       rdx,	rsi
    call      mm_name.rx_unitlist
    movzx     rax,	byte [rbx]
    cmp       rax,	4
    jnz       L7718
    mov       rdi,	[rbx+16]
    movzx     rax,	byte [rdi+78]
    cmp       rax,	5
    jz        L7720
    cmp       rax,	15
    jz        L7721
    jmp       L7722
L7720:
    mov       al,	58
    mov       r10,	[rbp + mm_name.rx_unit.p]
    mov       [r10],	al
    mov       rax,	[rbp + mm_name.rx_unit.p]
    lea       rax,	[rax+53]
    movsxd    r10,	dword [rdi+72]
    mov       rcx,	[rbp + mm_name.rx_unit.owner]
    mov       rdx,	r10
    mov       r8,	rax
    call      mm_lib.storemode
    mov       rax,	rsi
    mov       r10,	[rbp + mm_name.rx_unit.p]
    mov       [r10+16],	rax
    mov       rax,	[rsi+8]
    test      rax,	rax
    jz        L7724
    mov       rcx,	20
    mov       rdx,	rsi
    call      mm_lib.createunit1
    mov       r10,	[rbp + mm_name.rx_unit.p]
    mov       [r10+16],	rax
    xor       r12,	r12
    jmp       L7726
L7725:
    inc       r12
    mov       rsi,	[rsi+8]
L7726:
    test      rsi,	rsi
    jnz       L7725
    mov       rax,	[rbp + mm_name.rx_unit.p]
    mov       rax,	[rax+16]
    mov       r10d,	r12d
    mov       [rax+40],	r10d
L7724:
    jmp       L7719
L7721:
    inc       qword [mm_name.macrolevels]
    mov       rax,	[rdi+16]
    test      rax,	rax
    jz        L7729
    mov       rcx,	[rbp + mm_name.rx_unit.p]
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mm_name.expandmacro
    xor       rsi,	rsi
    xor       eax,	eax
    mov       [rbp + mm_name.rx_unit.useparams],	rax
    jmp       L7728
L7729:
    mov       rcx,	[rbp + mm_name.rx_unit.p]
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      mm_name.expandmacro
    mov       rax,	1
    mov       [rbp + mm_name.rx_unit.useparams],	rax
L7728:
    mov       rcx,	[rbp + mm_name.rx_unit.owner]
    mov       rdx,	[rbp + mm_name.rx_unit.p]
    call      mm_name.rx_unit
    dec       qword [mm_name.macrolevels]
    mov       rax,	[rbp + mm_name.rx_unit.useparams]
    test      rax,	rax
    jz        L7731
    mov       rax,	[rbp + mm_name.rx_unit.p]
    movzx     rax,	byte [rax]
    cmp       rax,	32
    jz        L7731
    mov       rcx,	[rbp + mm_name.rx_unit.p]
    mov       rdx,	r15
    call      mm_lib.insertunit
    mov       rax,	rsi
    mov       r10,	[rbp + mm_name.rx_unit.p]
    mov       [r10+24],	rax
L7731:
L7722:
L7719:
L7718:
    jmp       L7706
L7732:
    mov       rcx,	[rbp + mm_name.rx_unit.owner]
    mov       rdx,	rbx
    call      mm_name.rx_unit
    mov       rcx,	[rbp + mm_name.rx_unit.owner]
    mov       rdx,	rsi
    call      mm_name.rx_unit
    movzx     rax,	byte [rbx]
    lea       r10,	[mm_tables.isbooltag]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jnz       L7734
    mov       rcx,	rbx
    mov       rdx,	18
    call      mm_lib.insertunit
L7734:
    movzx     rax,	byte [rsi]
    lea       r10,	[mm_tables.isbooltag]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jnz       L7736
    mov       rcx,	rsi
    mov       rdx,	18
    call      mm_lib.insertunit
L7736:
    jmp       L7706
L7737:
;mm_name.rx_unit.doistruel:
L7738:
    mov       rcx,	[rbp + mm_name.rx_unit.owner]
    mov       rdx,	rbx
    call      mm_name.rx_unit
    movzx     rax,	byte [rbx]
    lea       r10,	[mm_tables.isbooltag]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L7740
    mov       rcx,	[rbp + mm_name.rx_unit.p]
    mov       rdx,	rbx
    call      mm_lib.deleteunit
L7740:
    jmp       L7706
L7741:
    mov       rcx,	[rbp + mm_name.rx_unit.owner]
    mov       rdx,	rbx
    call      mm_name.rx_unit
    movzx     rax,	byte [rbx]
    cmp       rax,	17
    jz        L7743
    cmp       rax,	18
    jz        L7744
    cmp       rax,	19
    jz        L7745
    jmp       L7746
L7743:
    mov       rcx,	[rbp + mm_name.rx_unit.p]
    mov       rdx,	rbx
    call      mm_lib.deleteunit
    mov       al,	18
    mov       r10,	[rbp + mm_name.rx_unit.p]
    mov       [r10],	al
    mov       rax,	[rbp + mm_name.rx_unit.p]
    mov       rbx,	[rax+16]
    jmp       L7738
L7744:
    mov       al,	19
    mov       [rbx],	al
    mov       rcx,	[rbp + mm_name.rx_unit.p]
    mov       rdx,	rbx
    call      mm_lib.deleteunit
    mov       rax,	[rbp + mm_name.rx_unit.p]
    mov       rbx,	[rax+16]
    jmp       L7742
L7745:
    mov       al,	18
    mov       [rbx],	al
    mov       rcx,	[rbp + mm_name.rx_unit.p]
    mov       rdx,	rbx
    call      mm_lib.deleteunit
    mov       rax,	[rbp + mm_name.rx_unit.p]
    mov       rbx,	[rax+16]
    jmp       L7742
L7746:
    movzx     rax,	byte [rbx]
    lea       r10,	[mm_tables.isbooltag]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jnz       L7748
    mov       al,	19
    mov       r10,	[rbp + mm_name.rx_unit.p]
    mov       [r10],	al
    mov       rax,	[rbp + mm_name.rx_unit.p]
    mov       rbx,	[rax+16]
L7748:
L7742:
    jmp       L7706
L7749:
    mov       rcx,	[rbp + mm_name.rx_unit.owner]
    mov       rdx,	rbx
    call      mm_name.resolvename
    mov       rax,	[mm_name.noexpand]
    test      rax,	rax
    jnz       L7751
    inc       qword [mm_name.macrolevels]
    mov       r14,	[mm_name.noassem]
    mov       rax,	1
    mov       [mm_name.noassem],	rax
    mov       rcx,	[rbp + mm_name.rx_unit.p]
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mm_name.expandmacro
    mov       [mm_name.noassem],	r14
    mov       rcx,	[rbp + mm_name.rx_unit.owner]
    mov       rdx,	[rbp + mm_name.rx_unit.p]
    call      mm_name.rx_unit
    dec       qword [mm_name.macrolevels]
L7751:
    jmp       L7706
L7708:
;mm_name.rx_unit.doabc:
    mov       rax,	1
    mov       [rbp + mm_name.rx_unit.i],	rax
    mov       rax,	[rbp + mm_name.rx_unit.p]
    movzx     rax,	byte [rax]
    lea       r10,	[mm_tables.jsubs]
    movzx     r10,	byte [r10 + rax]
    mov       [rbp + mm_name.rx_unit.av_1],	r10
    mov       rax,	[rbp + mm_name.rx_unit.av_1]
    cmp       rax,	1
    jl        L7755
L7753:
    mov       rax,	[rbp + mm_name.rx_unit.p]
    lea       rax,	[rax+16]
    mov       r10,	[rbp + mm_name.rx_unit.i]
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	[rbp + mm_name.rx_unit.owner]
    mov       rdx,	rax
    call      mm_name.rx_unitlist
    mov       rax,	[rbp + mm_name.rx_unit.i]
    inc       rax
    mov       [rbp + mm_name.rx_unit.i],	rax
    cmp       rax,	[rbp + mm_name.rx_unit.av_1]
    jle       L7753
L7755:
L7706:
;---------------
    add       rsp,	56
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_name.rx_module
mm_name.rx_module:
;?>>
   %define R.n rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       [mm_decls.currmoduleno],	rdi
    lea       rax,	[mm_decls.modules]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8]
    mov       rax,	[rax+24]
    mov       rcx,	[mm_decls.stprogram]
    mov       rdx,	rax
    call      mm_name.rx_passdef
    mov       rax,	1
L7756:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_name.rx_deflist
mm_name.rx_deflist:
;?>>
   %define R.owner rbx
   %define R.p rsi
   %define R.pstart rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    mov       rdi,	rsi
    jmp       L7759
L7758:
    mov       rcx,	rbx
    mov       rdx,	rsi
    call      mm_name.rx_passdef
    mov       rsi,	[rsi+32]
L7759:
    test      rsi,	rsi
    jnz       L7758
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_name.rx_passdef
mm_name.rx_passdef:
;?>>
   %define R.owner rdi
   %define R.p rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    movzx     rax,	byte [rbx+78]
    cmp       rax,	3
    jz        L7763
    cmp       rax,	4
    jz        L7763
    cmp       rax,	6
    jz        L7764
    cmp       rax,	7
    jz        L7765
    cmp       rax,	9
    jz        L7766
    cmp       rax,	10
    jz        L7766
    cmp       rax,	11
    jz        L7766
    cmp       rax,	12
    jz        L7766
    cmp       rax,	5
    jz        L7767
    jmp       L7768
L7763:
    mov       rax,	[rbx+16]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mm_name.rx_deflist
    jmp       L7762
L7764:
    mov       rax,	[rbx+16]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mm_name.rx_deflist
    mov       [mm_name.currstproc],	rbx
    mov       rax,	[rbx+64]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mm_name.rx_unit
    xor       eax,	eax
    mov       [mm_name.currstproc],	rax
    jmp       L7762
L7765:
    mov       rax,	[rbx+16]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mm_name.rx_deflist
    jmp       L7762
L7766:
    movzx     rax,	word [rbx+92]
    shr       eax,	8
    and       eax,	1
    test      rax,	rax
    jz        L7770
    mov       rax,	[rbx+96]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mm_name.rx_unit
L7770:
    mov       rax,	[rbx+64]
    test      rax,	rax
    jz        L7772
    mov       rax,	[rbx+64]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mm_name.rx_unit
L7772:
    jmp       L7762
L7767:
    mov       rax,	[rbx+16]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mm_name.rx_deflist
L7768:
L7762:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_name.rx_unitlist
mm_name.rx_unitlist:
;?>>
   %define R.owner rdi
   %define R.p rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    jmp       L7775
L7774:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mm_name.rx_unit
    mov       rbx,	[rbx+8]
L7775:
    test      rbx,	rbx
    jnz       L7774
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_name.resolvetopname
mm_name.resolvetopname:
;?>>
   %define R.owner r13
   %define R.stnewname r14
    %define mm_name.resolvetopname.moduleno 80
    %define mm_name.resolvetopname.allowmod 88
   %define R.extcount rdi
   %define R.subprogno rbx
   %define R.p rsi
   %define R.q r12
    %define mm_name.resolvetopname.powner -8
    %define mm_name.resolvetopname.extdef -16
    %define mm_name.resolvetopname.moddef -24
    %define mm_name.resolvetopname.ambiglist -104
    %define mm_name.resolvetopname.i -112
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	144
    mov       r13,	rcx
    mov       r14,	rdx
    mov       [rbp+80],	r8
    mov       [rbp+88],	r9
;---------------
    movzx     rax,	byte [r13+78]
    cmp       rax,	6
    jnz       L7779
    mov       r12,	[r13+16]
    jmp       L7783
L7780:
    mov       rax,	[r12+48]
    cmp       rax,	r14
    jnz       L7785
    mov       rax,	r12
    jmp       L7777
L7785:
    mov       r12,	[r12+32]
L7783:
    test      r12,	r12
    jnz       L7780
L7779:
    mov       rsi,	[r14+40]
    lea       rax,	[mm_decls.moduletosub]
    mov       r10,	[rbp + mm_name.resolvetopname.moduleno]
    movzx     rax,	byte [rax + r10]
    mov       rbx,	rax
    xor       rdi,	rdi
    xor       eax,	eax
    mov       [rbp + mm_name.resolvetopname.moddef],	rax
    mov       [rbp + mm_name.resolvetopname.extdef],	rax
    jmp       L7789
L7786:
    mov       rax,	[rsi+8]
    mov       [rbp + mm_name.resolvetopname.powner],	rax
    mov       rax,	[rbp + mm_name.resolvetopname.powner]
    movzx     rax,	byte [rax+78]
    cmp       rax,	3
    jz        L7791
    cmp       rax,	5
    jz        L7792
    cmp       rax,	1
    jz        L7793
    jmp       L7794
L7791:
    mov       rax,	[rbp + mm_name.resolvetopname.powner]
    movzx     rax,	byte [rax+94]
    cmp       rax,	[rbp + mm_name.resolvetopname.moduleno]
    jnz       L7796
    mov       rax,	rsi
    jmp       L7777
L7796:
    mov       al,	[rsi+170]
    test      al,	al
    jz        L7797
    mov       rax,	[rbp + mm_name.resolvetopname.powner]
    movzx     rax,	byte [rax+95]
    cmp       rax,	rbx
    jz        L7800
    movzx     rax,	byte [rsi+170]
    cmp       rax,	2
    jz        L7800
    movzx     rax,	word [rsi+92]
    shr       eax,	11
    and       eax,	1
    test      rax,	rax
    jz        L7799
L7800:
    inc       rdi
    mov       [rbp + mm_name.resolvetopname.extdef],	rsi
    cmp       rdi,	10
    jge       L7802
    mov       rax,	[rbp + mm_name.resolvetopname.extdef]
    mov       [rbp + rdi*8 + mm_name.resolvetopname.ambiglist-8],	rax
L7802:
L7799:
L7797:
L7795:
    jmp       L7790
L7792:
    mov       rax,	[rbp + mm_name.resolvetopname.powner]
    cmp       rax,	r13
    jz        L7805
    mov       rax,	[r13+8]
    mov       r10,	[rbp + mm_name.resolvetopname.powner]
    cmp       r10,	rax
    jnz       L7804
L7805:
    mov       rax,	rsi
    jmp       L7777
L7804:
    jmp       L7790
L7793:
    movzx     rax,	byte [rsi+78]
    cmp       rax,	3
    jz        L7807
    cmp       rax,	2
    jz        L7807
    cmp       rax,	15
    jz        L7808
    jmp       L7809
L7807:
    movzx     rax,	byte [rsi+94]
    lea       r10,	[mm_decls.moduletosub]
    movzx     r10,	byte [r10 + rax]
    cmp       rbx,	r10
    jnz       L7811
    mov       [rbp + mm_name.resolvetopname.moddef],	rsi
    jmp       L7810
L7811:
    mov       rax,	1
    mov       [rbp + mm_name.resolvetopname.i],	rax
    mov       rax,	[mm_decls.nsubprogs]
    cmp       rax,	1
    jl        L7814
L7812:
    lea       rax,	[mm_decls.subprogs]
    mov       r10,	[rbp + mm_name.resolvetopname.i]
    mov       rax,	[rax + r10*8]
    mov       rax,	[rax]
    mov       r10,	[rsi]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mlib.eqstring
    test      rax,	rax
    jz        L7816
    lea       rax,	[rsi+92]
    or        byte [rax+1],	4
    mov       [rbp + mm_name.resolvetopname.moddef],	rsi
    jmp       L7814
L7816:
    mov       rax,	[rbp + mm_name.resolvetopname.i]
    inc       rax
    mov       [rbp + mm_name.resolvetopname.i],	rax
    cmp       rax,	[mm_decls.nsubprogs]
    jle       L7812
L7814:
L7810:
    jmp       L7806
L7808:
    mov       rax,	rsi
    jmp       L7777
L7809:
L7806:
L7794:
L7790:
    mov       rsi,	[rsi+40]
L7789:
    test      rsi,	rsi
    jnz       L7786
    mov       rax,	[rbp + mm_name.resolvetopname.allowmod]
    test      rax,	rax
    jz        L7818
    mov       rax,	[rbp + mm_name.resolvetopname.moddef]
    test      rax,	rax
    jz        L7818
    mov       rax,	[rbp + mm_name.resolvetopname.moddef]
    jmp       L7777
L7818:
    mov       rax,	[rbp + mm_name.resolvetopname.extdef]
    test      rax,	rax
    jz        L7820
    cmp       rdi,	1
    jle       L7822
    mov       rax,	[rbp + mm_name.resolvetopname.extdef]
    mov       rax,	[rax+8]
    mov       rax,	[rax]
    mov       rcx,	rax
    lea       rdx,	[L13324]
    call      mlib.eqstring
    test      rax,	rax
    jnz       L7824
    mov       rax,	1
    mov       [rbp + mm_name.resolvetopname.i],	rax
    cmp       rdi,	1
    jl        L7827
L7825:
    mov       rax,	[rbp + mm_name.resolvetopname.i]
    mov       rax,	[rbp + rax*8 + mm_name.resolvetopname.ambiglist-8]
    mov       [rbp + mm_name.resolvetopname.extdef],	rax
    call      msys.m$print_startcon
    mov       rcx,	[rbp + mm_name.resolvetopname.i]
    call      msys.m$print_i64_nf
    mov       rax,	[rbp + mm_name.resolvetopname.extdef]
    mov       rax,	[rax+8]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    mov       rax,	[rbp + mm_name.resolvetopname.extdef]
    mov       rax,	[rax+8]
    movzx     rax,	byte [rax+78]
    lea       r10,	[mm_tables.namenames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rax,	[rbp + mm_name.resolvetopname.i]
    inc       rax
    mov       [rbp + mm_name.resolvetopname.i],	rax
    cmp       rax,	rdi
    jle       L7825
L7827:
    mov       rax,	[rbp + mm_name.resolvetopname.extdef]
    mov       rax,	[rax+8]
    mov       rax,	[rax]
    mov       rcx,	rax
    lea       rdx,	[L13324]
    call      mlib.eqstring
    test      rax,	rax
    jnz       L7829
    mov       rax,	[rbp + mm_name.resolvetopname.extdef]
    mov       rax,	[rax]
    lea       rcx,	[L13325]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_support.rxerror_s
L7829:
L7824:
L7822:
    mov       rax,	[rbp + mm_name.resolvetopname.extdef]
    jmp       L7777
L7820:
    xor       eax,	eax
L7777:
;---------------
    add       rsp,	144
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_name.resolvename
mm_name.resolvename:
;?>>
   %define R.owner r14
    %define mm_name.resolvename.p 72
   %define R.d rdi
   %define R.e rbx
   %define R.moduleno rsi
   %define R.mode r12
   %define R.islet r13
    %define mm_name.resolvename.str -304
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	336
    mov       r14,	rcx
    mov       [rbp+72],	rdx
;---------------
    mov       rax,	[rbp + mm_name.resolvename.p]
    mov       rdi,	[rax+16]
    mov       rax,	[rbp + mm_name.resolvename.p]
    movzx     rax,	byte [rax+57]
    mov       rsi,	rax
    movzx     rax,	byte [rdi+78]
    test      rax,	rax
    jnz       L7830
L7832:
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	rsi
    mov       r9,	[mm_name.allowmodname]
    call      mm_name.resolvetopname
    mov       rbx,	rax
    test      rbx,	rbx
    jnz       L7834
    xor       r13,	r13
    xor       eax,	eax
    mov       r12,	rax
    mov       rax,	[rbp + mm_name.resolvename.p]
    movzx     rax,	byte [rax+41]
    cmp       rax,	73
    jz        L7836
    cmp       rax,	84
    jz        L7836
    cmp       rax,	83
    jz        L7836
    cmp       rax,	76
    jz        L7837
    cmp       rax,	65
    jz        L7837
    jmp       L7838
L7836:
    mov       r12,	3
    mov       r13,	1
    jmp       L7835
L7837:
    mov       r12,	23
L7838:
L7835:
    test      r12,	r12
    jnz       L7840
    mov       rax,	[rdi]
    lea       rcx,	[rbp + mm_name.resolvename.str]
    mov       rdx,	rax
    call      strcpy
    lea       rcx,	[rbp + mm_name.resolvename.str]
    call      mlib.convucstring
    lea       rcx,	[L13326]
    lea       rdx,	[rbp + mm_name.resolvename.str]
    mov       r8,	[rbp + mm_name.resolvename.p]
    call      mm_support.rxerror_s
    jmp       L7839
L7840:
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	rsi
    mov       r9,	r12
    call      mm_name.addframevar
    mov       rbx,	rax
    mov       rax,	[rbp + mm_name.resolvename.p]
    mov       eax,	[rax+4]
    mov       [rbx+88],	eax
    lea       rax,	[rbx+92]
    mov       r10b,	r13b
    and       byte [rax],	239
    shl       r10b,	4
    or        [rax],	r10b
L7839:
L7834:
    movzx     rax,	word [rbx+168]
    cmp       rax,	255
    jge       L7842
    lea       rax,	[rbx+168]
    inc       word [rax]
L7842:
    mov       rax,	rbx
    mov       r10,	[rbp + mm_name.resolvename.p]
    mov       [r10+16],	rax
L7830:
;---------------
    add       rsp,	336
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_name.finddupl
mm_name.finddupl:
;?>>
   %define R.d rcx
   %define R.pdupl rdx
;?]]
;---------------
    movzx     rax,	byte [rdx+78]
    test      rax,	rax
    jz        L7845
    mov       rax,	rdx
    jmp       L7843
L7845:
    mov       rdx,	[rdx+40]
    jmp       L7847
L7846:
    mov       rax,	[rdx+8]
    cmp       rax,	rcx
    jnz       L7850
    mov       rax,	rdx
    jmp       L7843
L7850:
    mov       rdx,	[rdx+40]
L7847:
    test      rdx,	rdx
    jnz       L7846
    xor       eax,	eax
L7843:
;---------------
    ret       
;End 
;Proc mm_name.finddupl_sub
mm_name.finddupl_sub:
;?>>
   %define R.d rcx
   %define R.pdupl rdx
   %define R.subprogno rdi
    push      rdi
;?]]
    sub       rsp,	16
;---------------
    movzx     rax,	byte [rdx+78]
    test      rax,	rax
    jz        L7853
    mov       rax,	rdx
    jmp       L7851
L7853:
    mov       rdx,	[rdx+40]
    movzx     rax,	byte [rcx+95]
    mov       rdi,	rax
    jmp       L7855
L7854:
    mov       rax,	[rdx+8]
    movzx     rax,	byte [rax+95]
    cmp       rax,	rdi
    jnz       L7858
    mov       rax,	rdx
    jmp       L7851
L7858:
    mov       rdx,	[rdx+40]
L7855:
    test      rdx,	rdx
    jnz       L7854
    xor       eax,	eax
L7851:
;---------------
    add       rsp,	16
    pop       rdi
    ret       
;End 
;Proc mm_name.resolvedot
mm_name.resolvedot:
;?>>
    %define mm_name.resolvedot.owner 72
    %define mm_name.resolvedot.p 80
   %define R.lhs rdi
   %define R.rhs rbx
   %define R.d rsi
   %define R.e r12
   %define R.t r13
   %define R.m r14
   %define R.moduleno r15
    %define mm_name.resolvedot.subprogno -8
    %define mm_name.resolvedot.oldallowmod -16
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
    mov       [rbp+72],	rcx
    mov       [rbp+80],	rdx
;---------------
    mov       rax,	[rbp + mm_name.resolvedot.p]
    movzx     rax,	byte [rax+57]
    mov       r15,	rax
    mov       rax,	[rbp + mm_name.resolvedot.p]
    movzx     rax,	byte [rax+58]
    mov       [rbp + mm_name.resolvedot.subprogno],	rax
    mov       rax,	[rbp + mm_name.resolvedot.p]
    mov       rdi,	[rax+16]
    mov       rax,	[rbp + mm_name.resolvedot.p]
    mov       rbx,	[rax+24]
    mov       r12,	[rbx+16]
    mov       rax,	[mm_name.allowmodname]
    mov       [rbp + mm_name.resolvedot.oldallowmod],	rax
    movzx     rax,	byte [rdi]
    cmp       rax,	4
    setz      al
    movzx     eax,	al
    mov       [mm_name.allowmodname],	rax
    mov       rcx,	[rbp + mm_name.resolvedot.owner]
    mov       rdx,	rdi
    call      mm_name.rx_unit
    mov       rax,	[rbp + mm_name.resolvedot.oldallowmod]
    mov       [mm_name.allowmodname],	rax
    mov       rsi,	[rdi+16]
    movzx     rax,	byte [rdi]
    cmp       rax,	4
    jnz       L7862
L7861:
    movzx     rax,	byte [rsi+78]
    cmp       rax,	3
    jz        L7864
    cmp       rax,	5
    jz        L7864
    cmp       rax,	6
    jz        L7864
    cmp       rax,	5
    jz        L7864
    cmp       rax,	11
    jz        L7865
    cmp       rax,	10
    jz        L7865
    cmp       rax,	12
    jz        L7865
    cmp       rax,	2
    jz        L7866
    jmp       L7867
L7864:
    movzx     rax,	byte [rsi+78]
    cmp       rax,	3
    jnz       L7869
    movzx     rax,	byte [rsi+95]
    cmp       rax,	[rbp + mm_name.resolvedot.subprogno]
    jnz       L7870
L7869:
    mov       rcx,	rsi
    mov       rdx,	r12
    call      mm_name.finddupl
    mov       r12,	rax
    test      r12,	r12
    jz        L7872
    movzx     rax,	byte [rsi+78]
    cmp       rax,	3
    jnz       L7874
    movzx     rax,	byte [r12+95]
    cmp       rax,	[rbp + mm_name.resolvedot.subprogno]
    jz        L7876
    movzx     rax,	byte [r12+170]
    cmp       rax,	2
    jge       L7878
    movzx     rax,	word [r12+92]
    shr       eax,	11
    and       eax,	1
    test      rax,	rax
    jnz       L7878
    mov       rax,	[r12]
    lea       rcx,	[L13327]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_support.rxerror_s
L7878:
    jmp       L7875
L7876:
    movzx     rax,	byte [r12+94]
    cmp       rax,	r15
    jz        L7879
    mov       al,	[r12+170]
    test      al,	al
    jnz       L7881
    mov       rax,	[r12]
    lea       rcx,	[L13328]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_support.rxerror_s
L7881:
L7879:
L7875:
L7874:
;mm_name.resolvedot.domodule:
L7882:
    mov       al,	4
    mov       r10,	[rbp + mm_name.resolvedot.p]
    mov       [r10],	al
    xor       eax,	eax
    mov       r10,	[rbp + mm_name.resolvedot.p]
    mov       [r10+24],	rax
    mov       r10,	[rbp + mm_name.resolvedot.p]
    mov       [r10+16],	rax
    mov       rax,	r12
    mov       r10,	[rbp + mm_name.resolvedot.p]
    mov       [r10+16],	rax
    movzx     rax,	byte [r12+78]
    cmp       rax,	9
    jnz       L7885
L7884:
L7885:
L7883:
    jmp       L7871
L7872:
    mov       rax,	[rbp + mm_name.resolvedot.p]
    mov       rax,	[rax+24]
    mov       rax,	[rax+16]
    mov       rax,	[rax]
    lea       rcx,	[L13329]
    mov       rdx,	rax
    mov       r8,	[rbp + mm_name.resolvedot.p]
    call      mm_support.rxerror_s
L7871:
    jmp       L7863
L7865:
    movsxd    rax,	dword [rsi+72]
    mov       r14,	rax
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	r14
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	8
    jz        L7887
    cmp       rax,	7
    jz        L7888
    jmp       L7889
L7887:
    jmp       L7886
L7888:
L7890:
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	r14
    movsxd    rax,	dword [rax + r10*4]
    mov       r14,	rax
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	r14
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	8
    jz        L7893
    cmp       rax,	7
    jz        L7894
    jmp       L7895
L7893:
    jmp       L7891
L7894:
    jmp       L7892
L7895:
    lea       rcx,	[L13330]
    xor       edx,	edx
    call      mm_support.rxerror
L7892:
    jmp       L7890
L7891:
    jmp       L7886
L7889:
    lea       rcx,	[L13331]
    xor       edx,	edx
    call      mm_support.rxerror
L7886:
    lea       rax,	[mm_decls.ttnamedef]
    mov       r10,	r14
    mov       r13,	[rax + r10*8]
    mov       rcx,	r13
    mov       rdx,	r12
    call      mm_name.finddupl
    mov       r12,	rax
    test      r12,	r12
    jz        L7897
    mov       rax,	[rbp + mm_name.resolvedot.p]
    mov       rax,	[rax+24]
    mov       r10,	r12
    mov       [rax+16],	r10
    jmp       L7896
L7897:
    mov       rax,	[rbx+16]
    mov       rax,	[rax]
    lea       rcx,	[L13332]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_support.rxerror_s
L7896:
    jmp       L7863
L7866:
;mm_name.resolvedot.dosubprogid:
L7870:
    mov       rcx,	rsi
    mov       rdx,	r12
    call      mm_name.finddupl_sub
    mov       r12,	rax
    test      r12,	r12
    jz        L7899
    movzx     rax,	byte [r12+95]
    cmp       rax,	[rbp + mm_name.resolvedot.subprogno]
    jz        L7901
    movzx     rax,	byte [r12+170]
    cmp       rax,	2
    jge       L7903
    movzx     rax,	word [r12+92]
    shr       eax,	11
    and       eax,	1
    test      rax,	rax
    jnz       L7903
    mov       rax,	[r12]
    lea       rcx,	[L13333]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_support.rxerror_s
L7903:
L7901:
    jmp       L7882
L7899:
    mov       rax,	[rbp + mm_name.resolvedot.p]
    mov       rax,	[rax+24]
    mov       rax,	[rax+16]
    mov       rax,	[rax]
    lea       rcx,	[L13334]
    mov       rdx,	rax
    mov       r8,	[rbp + mm_name.resolvedot.p]
    call      mm_support.rxerror_s
L7898:
L7867:
L7863:
    jmp       L7860
L7862:
    mov       rax,	[r12+40]
    test      rax,	rax
    jnz       L7905
    mov       rax,	[r12]
    lea       rcx,	[L13335]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_support.rxerror_s
L7905:
L7860:
;---------------
    add       rsp,	56
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_name.fixmode
mm_name.fixmode:
;?>>
    %define mm_name.fixmode.p 64
   %define R.pmode rdi
   %define R.a rbx
   %define R.d rsi
   %define R.e r12
   %define R.owner r13
   %define R.m r14
    %define mm_name.fixmode.moduleno -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+64],	rcx
;---------------
    mov       rax,	[rbp + mm_name.fixmode.p]
    mov       rdi,	[rax+24]
    movsxd    rax,	dword [rdi]
    neg       rax
    mov       r14,	rax
    mov       rax,	[rbp + mm_name.fixmode.p]
    mov       rax,	[rax]
    mov       r13,	rax
    mov       rsi,	rax
    jmp       L7908
L7907:
    mov       rsi,	[rsi+8]
L7908:
    movzx     rax,	byte [rsi+78]
    cmp       rax,	3
    jnz       L7907
    movzx     rax,	byte [rsi+94]
    mov       [rbp + mm_name.fixmode.moduleno],	rax
    mov       rax,	[rbp + mm_name.fixmode.p]
    mov       rbx,	[rax+8]
    mov       rax,	[rbp + mm_name.fixmode.p]
    mov       rsi,	[rax+16]
    test      rbx,	rbx
    jnz       L7911
    test      rsi,	rsi
    jz        L7911
    mov       rcx,	r13
    mov       rdx,	rsi
    mov       r8,	[rbp + mm_name.fixmode.moduleno]
    xor       r9d,	r9d
    call      mm_name.resolvetopname
    mov       r12,	rax
L7911:
    test      r12,	r12
    jz        L7913
    movzx     rax,	byte [r12+78]
    cmp       rax,	5
    jnz       L7913
    mov       eax,	[r12+72]
    mov       [rdi],	eax
    jmp       L7912
L7913:
    mov       rax,	[rsi]
    lea       rcx,	[L13336]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_support.rxerror_s
L7912:
;---------------
    add       rsp,	48
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_name.fixusertypes
mm_name.fixusertypes:
;?>>
   %define R.p rdi
   %define R.npasses rbx
   %define R.notresolved rsi
   %define R.d r12
   %define R.i r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
;---------------
    xor       rbx,	rbx
L7915:
    inc       rbx
    xor       rsi,	rsi
    mov       rax,	1
    mov       r13,	rax
    mov       rax,	[mm_decls.ntypenames]
    cmp       rax,	1
    jl        L7920
L7918:
    lea       rax,	[mm_decls.typenames]
    mov       r10,	r13
    shl       r10,	5
    lea       rax,	[rax + r10]
    mov       rdi,	rax
    mov       rax,	[rdi+24]
    movsxd    rax,	dword [rax]
    cmp       rax,	0
    jge       L7922
    lea       rax,	[mm_decls.typenamepos]
    mov       r10,	r13
    lea       rax,	[rax + r10*4]
    mov       eax,	[rax]
    mov       [pc_decls.mmpos],	rax
    mov       rcx,	rdi
    call      mm_name.fixmode
    mov       rax,	[rdi+24]
    movsxd    rax,	dword [rax]
    cmp       rax,	0
    jge       L7924
    inc       rsi
L7924:
L7922:
    inc       r13
    cmp       r13,	[mm_decls.ntypenames]
    jle       L7918
L7920:
    cmp       rbx,	5
    jle       L7926
    call      msys.m$print_startcon
    lea       rcx,	[L13337]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       r13,	1
    mov       rax,	[mm_decls.ntypenames]
    cmp       rax,	1
    jl        L7929
L7927:
    lea       rax,	[mm_decls.typenames]
    mov       r10,	r13
    shl       r10,	5
    lea       rax,	[rax + r10]
    mov       rdi,	rax
    mov       rax,	[rdi+24]
    movsxd    rax,	dword [rax]
    cmp       rax,	0
    jge       L7931
    mov       r12,	[rdi+16]
    test      r12,	r12
    jnz       L7933
    mov       r12,	[rdi+8]
L7933:
    call      msys.m$print_startcon
    lea       rcx,	[L13338]
    call      msys.m$print_str_nf
    mov       rcx,	[r12]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L7931:
    inc       r13
    cmp       r13,	[mm_decls.ntypenames]
    jle       L7927
L7929:
    lea       rcx,	[L13339]
    xor       edx,	edx
    call      mm_support.rxerror
L7926:
    test      rsi,	rsi
    jnz       L7915
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_name.addframevar
mm_name.addframevar:
;?>>
   %define R.owner rbx
   %define R.d rsi
    %define mm_name.addframevar.moduleno 64
   %define R.mode r12
   %define R.e rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r9
;---------------
    mov       rcx,	rbx
    mov       rdx,	rsi
    mov       r8,	11
    call      mm_lib.getduplnameptr
    mov       rdi,	rax
    lea       rax,	[rdi+72]
    mov       rcx,	rbx
    mov       rdx,	r12
    mov       r8,	rax
    call      mm_lib.storemode
    mov       rcx,	rbx
    mov       rdx,	rdi
    call      mm_lib.adddef
    mov       rax,	rdi
L7934:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_name.copylistunit
mm_name.copylistunit:
;?>>
   %define R.p rbx
   %define R.q rdi
    %define mm_name.copylistunit.plist -8
    %define mm_name.copylistunit.plistx -16
    push      rdi
    push      rbx
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       rbx,	rcx
;---------------
    xor       eax,	eax
    mov       [rbp + mm_name.copylistunit.plistx],	rax
    mov       [rbp + mm_name.copylistunit.plist],	rax
    jmp       L7937
L7936:
    mov       rcx,	rbx
    call      mm_name.copyunit
    mov       rdi,	rax
    lea       rcx,	[rbp + mm_name.copylistunit.plist]
    lea       rdx,	[rbp + mm_name.copylistunit.plistx]
    mov       r8,	rdi
    call      mm_lib.addlistunit
    mov       rbx,	[rbx+8]
L7937:
    test      rbx,	rbx
    jnz       L7936
    mov       rax,	[rbp + mm_name.copylistunit.plist]
L7935:
;---------------
    add       rsp,	48
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_name.copyunit
mm_name.copyunit:
;?>>
   %define R.p r13
   %define R.q rdi
   %define R.d rbx
   %define R.av_1 rsi
   %define R.i r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r13,	rcx
;---------------
    test      r13,	r13
    jnz       L7941
    xor       eax,	eax
    jmp       L7939
L7941:
    movzx     rax,	byte [r13]
    cmp       rax,	4
    jnz       L7943
    mov       rbx,	[r13+16]
    mov       r12,	1
    mov       rax,	[mm_name.nmacroparams]
    cmp       rax,	1
    jl        L7946
L7944:
    lea       rax,	[mm_name.macroparamsgen]
    mov       r10,	r12
    mov       rax,	[rax + r10*8-8]
    cmp       rax,	rbx
    jnz       L7948
    lea       rax,	[mm_name.macroargs]
    mov       r10,	r12
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rax
    call      mm_name.copyunit
    jmp       L7939
L7948:
    inc       r12
    cmp       r12,	[mm_name.nmacroparams]
    jle       L7944
L7946:
L7943:
    movzx     rax,	byte [r13]
    mov       rcx,	rax
    call      mm_lib.createunit0
    mov       rdi,	rax
    mov       rax,	r13
    push      rdi
    mov       r11,	8
L13340:
    mov       r10,	[rax]
    mov       [rdi],	r10
    add       rdi,	8
    add       rax,	8
    dec       r11
    jnz       L13340
    mov       r10b,	[rax]
    mov       [rdi],	r10b
    pop       rdi
    xor       eax,	eax
    mov       [rdi+8],	rax
    mov       r12,	1
    movzx     rax,	byte [rdi]
    lea       r10,	[mm_tables.jsubs]
    movzx     r10,	byte [r10 + rax]
    mov       rsi,	r10
    cmp       rsi,	1
    jl        L7951
L7949:
    lea       rax,	[rdi+16]
    mov       r10,	r12
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rax
    call      mm_name.copylistunit
    lea       r10,	[rdi+16]
    mov       r11,	r12
    mov       [r10 + r11*8-8],	rax
    inc       r12
    cmp       r12,	rsi
    jle       L7949
L7951:
    mov       rax,	rdi
L7939:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_name.replaceunit
mm_name.replaceunit:
;?>>
   %define R.p rcx
   %define R.q rdx
   %define R.pnext rdi
    push      rdi
;?]]
    sub       rsp,	16
;---------------
    mov       rdi,	[rcx+8]
    mov       rax,	rdx
    push      rcx
    mov       r11,	8
L13341:
    mov       r10,	[rax]
    mov       [rcx],	r10
    add       rcx,	8
    add       rax,	8
    dec       r11
    jnz       L13341
    mov       r10b,	[rax]
    mov       [rcx],	r10b
    pop       rcx
    mov       [rcx+8],	rdi
;---------------
    add       rsp,	16
    pop       rdi
    ret       
;End 
;Proc mm_name.expandmacro
mm_name.expandmacro:
;?>>
   %define R.p r13
   %define R.a r14
   %define R.b r15
   %define R.d rdi
   %define R.pm rbx
   %define R.pnew rsi
   %define R.ignoreargs r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    sub       rsp,	48
    mov       r13,	rcx
    mov       r14,	rdx
    mov       r15,	r8
;---------------
    mov       rax,	[mm_name.macrolevels]
    cmp       rax,	10
    jle       L7955
    lea       rcx,	[L13342]
    xor       edx,	edx
    call      mm_support.rxerror
L7955:
    mov       rdi,	[r14+16]
    mov       rbx,	[rdi+112]
    xor       eax,	eax
    mov       [mm_name.nmacroparams],	rax
    jmp       L7957
L7956:
    mov       rax,	[mm_name.nmacroparams]
    cmp       rax,	50
    jl        L7960
    lea       rcx,	[L13343]
    xor       edx,	edx
    call      mm_support.rxerror
L7960:
    inc       qword [mm_name.nmacroparams]
    mov       rax,	[mm_name.nmacroparams]
    mov       r10,	rbx
    lea       r11,	[mm_name.macroparams]
    mov       [r11 + rax*8-8],	r10
    mov       rax,	[rbx+48]
    lea       r10,	[mm_name.macroparamsgen]
    mov       r11,	[mm_name.nmacroparams]
    mov       [r10 + r11*8-8],	rax
    mov       rbx,	[rbx+152]
L7957:
    test      rbx,	rbx
    jnz       L7956
    xor       eax,	eax
    mov       [mm_name.nmacroargs],	rax
    jmp       L7962
L7961:
    mov       rax,	[mm_name.nmacroargs]
    cmp       rax,	50
    jl        L7965
    lea       rcx,	[L13344]
    xor       edx,	edx
    call      mm_support.rxerror
L7965:
    inc       qword [mm_name.nmacroargs]
    mov       rax,	[mm_name.nmacroargs]
    mov       r10,	r15
    lea       r11,	[mm_name.macroargs]
    mov       [r11 + rax*8-8],	r10
    mov       r15,	[r15+8]
L7962:
    test      r15,	r15
    jnz       L7961
    mov       rax,	[mm_name.nmacroargs]
    cmp       rax,	[mm_name.nmacroparams]
    jge       L7967
    call      msys.m$print_startcon
    lea       rcx,	[L13345]
    call      msys.m$print_str_nf
    mov       rcx,	[mm_name.nmacroargs]
    call      msys.m$print_i64_nf
    mov       rcx,	[mm_name.nmacroparams]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L13346]
    xor       edx,	edx
    call      mm_support.rxerror
L7967:
    xor       r12,	r12
    mov       rax,	[mm_name.nmacroargs]
    cmp       rax,	0
    jle       L7969
    mov       rax,	[mm_name.nmacroparams]
    test      rax,	rax
    jnz       L7969
    mov       r12,	1
    xor       eax,	eax
    mov       [mm_name.nmacroparams],	rax
    mov       [mm_name.nmacroargs],	rax
    jmp       L7968
L7969:
    mov       rax,	[mm_name.nmacroargs]
    cmp       rax,	[mm_name.nmacroparams]
    jle       L7970
    lea       rcx,	[L13347]
    xor       edx,	edx
    call      mm_support.rxerror
L7970:
L7968:
    mov       rax,	[rdi+64]
    mov       rcx,	rax
    call      mm_name.copyunit
    mov       rsi,	rax
    test      r12,	r12
    jnz       L7972
    mov       rcx,	r13
    mov       rdx,	rsi
    call      mm_name.replaceunit
    jmp       L7971
L7972:
    mov       [r13+16],	rsi
L7971:
;---------------
    add       rsp,	48
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_name.duplfield
mm_name.duplfield:
;?>>
   %define R.owner rdi
   %define R.p rbx
   %define R.q rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    mov       rax,	[rbx+64]
    test      rax,	rax
    jz        L7975
    lea       rcx,	[L13348]
    call      mm_support.serror
L7975:
    movzx     rax,	word [rbx+92]
    shr       eax,	7
    and       eax,	1
    lea       r10,	[rsi+92]
    and       byte [r10],	127
    shl       al,	7
    or        [r10],	al
    mov       ax,	[rbx+92]
    mov       [rsi+92],	ax
    mov       rax,	[rbx+136]
    mov       [rsi+136],	rax
    lea       rax,	[rsi+72]
    movsxd    r10,	dword [rbx+72]
    mov       rcx,	rdi
    mov       rdx,	r10
    mov       r8,	rax
    call      mm_lib.storemode
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_name.do_baseclass
mm_name.do_baseclass:
;?>>
   %define R.p r14
   %define R.d rdi
   %define R.e rbx
   %define R.newd rsi
   %define R.dbase r12
   %define R.normalexit r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       r14,	rcx
;---------------
    movsxd    rax,	dword [r14+144]
    lea       r10,	[mm_decls.ttnamedef]
    mov       r10,	[r10 + rax*8]
    mov       r12,	r10
    mov       rdi,	[r12+16]
    jmp       L7978
L7977:
    mov       rbx,	[r14+16]
    mov       r13,	1
    jmp       L7981
L7980:
    mov       rax,	[rbx]
    mov       r10,	[rdi]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mlib.eqstring
    test      rax,	rax
    jz        L7984
    xor       r13,	r13
    jmp       L7982
L7984:
    mov       rbx,	[rbx+32]
L7981:
    test      rbx,	rbx
    jnz       L7980
L7982:
    test      r13,	r13
    jz        L7986
    movzx     rax,	byte [rdi+78]
    cmp       rax,	6
    jz        L7988
    cmp       rax,	17
    jnz       L7989
L7988:
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	17
    call      mm_lib.getduplnameptr
    mov       rsi,	rax
    mov       [rsi+128],	rdi
    jmp       L7987
L7989:
    movzx     rax,	byte [rdi+78]
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	rax
    call      mm_lib.getduplnameptr
    mov       rsi,	rax
    mov       rax,	[r14+8]
    mov       rcx,	rax
    mov       rdx,	rdi
    mov       r8,	rsi
    call      mm_name.duplfield
L7987:
    mov       rcx,	r14
    mov       rdx,	rsi
    call      mm_lib.adddef
L7986:
    mov       rdi,	[rdi+32]
L7978:
    test      rdi,	rdi
    jnz       L7977
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.parsemodule
mm_parse.parsemodule:
;?>>
   %define R.pm rbx
   %define R.owner rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    call      mm_parse.initparser
    movsx     rax,	word [rbx+16]
    mov       [mm_decls.currmoduleno],	rax
    mov       rax,	[rbx+24]
    mov       [mm_decls.stmodule],	rax
    mov       rax,	[mm_decls.stmodule]
    mov       [mm_decls.currproc],	rax
    mov       rcx,	[rbx+8]
    call      mm_lex.startlex
    mov       rdi,	[mm_decls.stmodule]
    call      mm_lex.lex
    mov       rcx,	rdi
    call      mm_parse.readmoduledefs
    mov       rax,	1
L7990:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readmoduledefs
mm_parse.readmoduledefs:
;?>>
   %define R.owner rbx
   %define R.globalflag rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    xor       rdi,	rdi
L7992:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    sub       rax,	1
    cmp       rax,	132
    jae       L7996
    lea       r10,	[L7995]
    jmp       [r10 + rax*8]
    segment .data
L7995:
    dq  L8023
    dq  L7996
    dq  L7996
    dq  L8011
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L8003
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L8012
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L8024
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L8003
    dq  L8003
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L8002
    dq  L8002
    dq  L7996
    dq  L8009
    dq  L7996
    dq  L7996
    dq  L8006
    dq  L8014
    dq  L8007
    dq  L8003
    dq  L7996
    dq  L7996
    dq  L8005
    dq  L8003
    dq  L8013
    dq  L8008
    dq  L7996
    dq  L8019
    dq  L7997
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L7996
    dq  L8010
    segment .text
L7997:
    test      rdi,	rdi
    jz        L7999
    lea       rcx,	[L13349]
    call      mm_support.serror
L7999:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    mov       rdi,	rax
    cmp       rdi,	3
    jnz       L8001
    mov       rax,	[mm_decls.stmodule]
    movzx     rax,	byte [rax+95]
    cmp       rax,	[mm_decls.nsubprogs]
    jz        L8001
    mov       rdi,	2
L8001:
    call      mm_lex.lex
    jmp       L7994
L8002:
    mov       rcx,	rbx
    mov       rdx,	rdi
    call      mm_parse.readprocdef
    xor       rdi,	rdi
    jmp       L7994
L8003:
;mm_parse.readmoduledefs.dovar:
L8004:
    sub       rsp,	8
    push      0
    mov       rcx,	rbx
    mov       rdx,	rdi
    xor       r8d,	r8d
    mov       r9,	10
    sub       rsp,	32
    call      mm_parse.readvardef
    add       rsp,	48
    xor       rdi,	rdi
    jmp       L7994
L8005:
    call      mm_lex.lex
    sub       rsp,	8
    push      120
    mov       rcx,	rbx
    mov       rdx,	rdi
    xor       r8d,	r8d
    mov       r9,	10
    sub       rsp,	32
    call      mm_parse.readvardef
    add       rsp,	48
    xor       rdi,	rdi
    jmp       L7994
L8006:
    mov       rcx,	rbx
    call      mm_parse.readimportmodule
    jmp       L7994
L8007:
    mov       rcx,	rbx
    mov       rdx,	rdi
    call      mm_parse.readtypedef
    xor       rdi,	rdi
    jmp       L7994
L8008:
    mov       rcx,	rbx
    mov       rdx,	rdi
    call      mm_parse.readconstdef
    xor       rdi,	rdi
    jmp       L7994
L8009:
    mov       rcx,	rbx
    mov       rdx,	rdi
    call      mm_parse.readclassdef
    xor       rdi,	rdi
    jmp       L7994
L8010:
    mov       rcx,	rbx
    mov       rdx,	rdi
    call      mm_parse.readtabledef
    xor       rdi,	rdi
    jmp       L7994
L8011:
    call      mm_lex.lex
    jmp       L7994
L8012:
    jmp       L7993
L8013:
    mov       rcx,	rbx
    mov       rdx,	rdi
    call      mm_parse.readmacrodef
    xor       rdi,	rdi
    jmp       L7994
L8014:
L8015:
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	87
    jz        L8018
    cmp       rax,	59
    jnz       L8015
L8018:
    mov       rcx,	87
    mov       rdx,	115
    xor       r8d,	r8d
    xor       r9d,	r9d
    call      mm_parse.checkend
    jmp       L7994
L8019:
L8020:
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	4
    jnz       L8020
    jmp       L7994
L8023:
    lea       rcx,	[L13350]
    call      mm_support.serror
    jmp       L7994
L8024:
    call      mm_parse.istypestarter
    test      rax,	rax
    jnz       L8004
L8026:
    jmp       L8027
L7996:
;mm_parse.readmoduledefs.doexec:
L8027:
    lea       rcx,	[L13351]
    call      mm_support.serror
L7994:
    jmp       L7992
L7993:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.initparser
mm_parse.initparser:
;?>>
   %define R.tabledataname rdi
    push      rdi
;?]]
    sub       rsp,	48
;---------------
    mov       rax,	[mm_decls.nullunit]
    test      rax,	rax
    jnz       L8030
    mov       rcx,	2
    call      mm_lib.createunit0
    mov       [mm_decls.nullunit],	rax
L8030:
    xor       eax,	eax
    mov       [mm_decls.currproc],	rax
    xor       eax,	eax
    mov       [mm_parse.varattribs],	rax
    xor       eax,	eax
    mov       [mm_parse.intabledata],	rax
    xor       eax,	eax
    mov       [mm_parse.inreadprint],	rax
    xor       eax,	eax
    mov       [mm_parse.inparamlist],	rax
    xor       eax,	eax
    mov       [mm_parse.inrecordbody],	rax
    xor       eax,	eax
    mov       [mm_parse.inimportmodule],	rax
    lea       rax,	[L13352]
    mov       rdi,	rax
    xor       eax,	eax
    mov       [mm_parse.labelseen],	rax
    xor       eax,	eax
    mov       [mm_parse.ndollar],	rax
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_parse.skipsemi
mm_parse.skipsemi:
;?>>
;?]]
    sub       rsp,	40
;---------------
    jmp       L8033
L8032:
    call      mm_lex.lex
L8033:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	4
    jz        L8032
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mm_parse.makeblock
mm_parse.makeblock:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    test      rdi,	rdi
    jz        L8037
    movzx     rax,	byte [rdi]
    cmp       rax,	6
    jnz       L8037
    mov       rax,	rdi
    jmp       L8035
L8037:
    mov       rcx,	6
    mov       rdx,	rdi
    call      mm_lib.createunit1
L8035:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_parse.checkequals
mm_parse.checkequals:
;?>>
;?]]
    sub       rsp,	40
;---------------
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	41
    jz        L8040
    lea       rcx,	[L13353]
    call      mm_support.serror
L8040:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mm_parse.getcurrline
mm_parse.getcurrline:
;?>>
;?]]
;---------------
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
L8041:
;---------------
    ret       
;End 
;Proc mm_parse.checkbegin
mm_parse.checkbegin:
;?>>
   %define R.fbrack rbx
   %define R.closesym rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    call      mm_parse.skipsemi
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	9
    jnz       L8044
    test      rbx,	rbx
    jz        L8044
    mov       rdi,	10
    call      mm_lex.lex
    jmp       L8043
L8044:
    mov       rdi,	87
L8043:
    mov       rax,	rdi
L8042:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.checkbeginend
mm_parse.checkbeginend:
;?>>
   %define R.closesym rdi
   %define R.kwd rbx
   %define R.startline rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    call      mm_parse.skipsemi
    cmp       rdi,	10
    jnz       L8047
    mov       rcx,	rdi
    call      mm_parse.checksymbollex
    jmp       L8046
L8047:
    mov       rcx,	rdi
    mov       rdx,	rbx
    xor       r8d,	r8d
    mov       r9,	rsi
    call      mm_parse.checkend
L8046:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.checkend
mm_parse.checkend:
;?>>
   %define R.endsym rdi
   %define R.endkwd1 rbx
   %define R.endkwd2 rsi
   %define R.startline r12
    %define mm_parse.checkend.str -104
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	144
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
    mov       r12,	r9
;---------------
    call      mm_parse.skipsemi
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	rdi
    jnz       L8050
    cmp       rax,	10
    jz        L8048
L8050:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	87
    jz        L8052
    lea       rcx,	[L13354]
    call      mm_support.serror
L8052:
    lea       rax,	[mm_decls.lx]
    mov       al,	[rax+1]
    test      al,	al
    jz        L8054
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    cmp       rax,	rbx
    jz        L8057
    cmp       rax,	rsi
    jnz       L8056
L8057:
    call      mm_lex.lex
    jmp       L8048
L8056:
;mm_parse.checkend.error:
    lea       rcx,	[rbp + mm_parse.checkend.str]
    lea       rdx,	[L13355]
    call      strcpy
    test      r12,	r12
    jz        L8060
    lea       rcx,	[rbp + mm_parse.checkend.str]
    call      strlen
    lea       r10,	[rbp + rax + mm_parse.checkend.str]
    mov       rcx,	r10
    call      msys.m$print_startstr
    lea       rcx,	[L13356]
    call      msys.m$print_setfmt
    mov       rcx,	r12
    call      msys.m$print_i64_nf
    call      msys.m$print_end
L8060:
    lea       rcx,	[rbp + mm_parse.checkend.str]
    call      mm_support.serror
L8055:
L8054:
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	rbx
    jz        L8063
    cmp       rax,	rsi
    jnz       L8062
L8063:
    call      mm_lex.lex
L8062:
L8048:
;---------------
    add       rsp,	144
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readvardef
mm_parse.readvardef:
;?>>
   %define R.owner r13
   %define R.scope r14
    %define mm_parse.readvardef.isstatic 80
    %define mm_parse.readvardef.varid 88
    %define mm_parse.readvardef.k 96
    %define mm_parse.readvardef.ulist -8
    %define mm_parse.readvardef.ulistx -16
   %define R.p rdi
   %define R.nvars rbx
   %define R.m rsi
   %define R.initcode r12
    %define mm_parse.readvardef.stname -24
    %define mm_parse.readvardef.$T1 -32
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       r13,	rcx
    mov       r14,	rdx
    mov       [rbp+80],	r8
    mov       [rbp+88],	r9
;---------------
    xor       eax,	eax
    mov       [rbp + mm_parse.readvardef.ulistx],	rax
    mov       [rbp + mm_parse.readvardef.ulist],	rax
    call      mm_parse.istypestarter
    test      rax,	rax
    jz        L8066
    mov       rcx,	r13
    xor       edx,	edx
    call      mm_parse.readtypespec
    mov       rsi,	rax
    jmp       L8065
L8066:
    lea       rcx,	[L13357]
    call      mm_support.serror
L8065:
    xor       rbx,	rbx
    jmp       L8068
L8067:
    inc       rbx
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       rcx,	r13
    mov       rdx,	rax
    mov       r8,	[rbp + mm_parse.readvardef.varid]
    call      mm_lib.getduplnameptr
    mov       [rbp + mm_parse.readvardef.stname],	rax
    mov       al,	r14b
    mov       r10,	[rbp + mm_parse.readvardef.stname]
    mov       [r10+170],	al
    mov       rax,	[rbp + mm_parse.readvardef.stname]
    lea       rax,	[rax+92]
    mov       r10b,	[rbp + mm_parse.readvardef.isstatic]
    and       byte [rax],	254
    or        [rax],	r10b
    mov       rax,	[rbp + mm_parse.readvardef.k]
    cmp       rax,	120
    setz      al
    movzx     eax,	al
    mov       r10,	[rbp + mm_parse.readvardef.stname]
    lea       r10,	[r10+92]
    and       byte [r10],	239
    shl       al,	4
    or        [r10],	al
    mov       rax,	[rbp + mm_parse.readvardef.varid]
    cmp       rax,	8
    jnz       L8071
    mov       rax,	[rbp + mm_parse.readvardef.stname]
    lea       rax,	[rax+92]
    or        byte [rax+1],	8
L8071:
    mov       rcx,	r13
    mov       rdx,	[rbp + mm_parse.readvardef.stname]
    call      mm_lib.adddef
    mov       rax,	[rbp + mm_parse.readvardef.varid]
    cmp       rax,	10
    jnz       L8073
    mov       rcx,	[rbp + mm_parse.readvardef.stname]
    call      mm_lib.addstatic
L8073:
    call      mm_lex.lex
    mov       rax,	[rbp + mm_parse.readvardef.stname]
    lea       rax,	[rax+72]
    mov       rcx,	r13
    mov       rdx,	rsi
    mov       r8,	rax
    call      mm_lib.storemode
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	6
    jz        L8076
    cmp       rax,	41
    jnz       L8075
L8076:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	41
    jz        L8078
    cmp       rax,	6
    jz        L8079
    jmp       L8080
L8078:
    mov       r12,	1
    jmp       L8077
L8079:
    mov       r12,	2
    jmp       L8077
L8080:
    mov       r12,	3
L8077:
    mov       ax,	1
    mov       r10,	[rbp + mm_parse.readvardef.stname]
    mov       [r10+168],	ax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	41
    jz        L8082
    mov       rax,	[rbp + mm_parse.readvardef.varid]
    cmp       rax,	10
    jnz       L8084
    lea       rcx,	[L13358]
    call      mm_support.serror
    movzx     rax,	byte [r13+78]
    cmp       rax,	6
    jnz       L8086
    lea       rcx,	[L13359]
    call      mm_support.serror
L8086:
L8084:
    jmp       L8081
L8082:
    mov       rax,	[rbp + mm_parse.readvardef.varid]
    cmp       rax,	11
    jnz       L8088
    lea       rcx,	[L13360]
    call      mm_support.serror
    mov       rcx,	[rbp + mm_parse.readvardef.stname]
    call      mm_lib.addstatic
L8088:
L8081:
    call      mm_lex.lex
    call      mm_parse.readunit
    mov       r10,	[rbp + mm_parse.readvardef.stname]
    mov       [r10+64],	rax
    mov       al,	r12b
    mov       r10,	[rbp + mm_parse.readvardef.stname]
    mov       [r10+171],	al
    mov       rax,	[rbp + mm_parse.readvardef.varid]
    cmp       rax,	11
    jnz       L8090
    mov       rax,	[rbp + mm_parse.readvardef.stname]
    mov       rax,	[rax+64]
    mov       [rbp + mm_parse.readvardef.$T1],	rax
    mov       rcx,	[rbp + mm_parse.readvardef.stname]
    call      mm_lib.createname
    mov       rcx,	28
    mov       rdx,	rax
    mov       r8,	[rbp + mm_parse.readvardef.$T1]
    call      mm_lib.createunit2
    mov       rdi,	rax
    mov       al,	1
    mov       [rdi+59],	al
    lea       rcx,	[rbp + mm_parse.readvardef.ulist]
    lea       rdx,	[rbp + mm_parse.readvardef.ulistx]
    mov       r8,	rdi
    call      mm_lib.addlistunit
L8090:
    jmp       L8074
L8075:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	17
    jnz       L8091
    mov       rax,	[rbp + mm_parse.readvardef.k]
    cmp       rax,	120
    jnz       L8093
    lea       rcx,	[L13361]
    call      mm_support.serror
L8093:
    call      mm_lex.lex
    mov       rax,	[rbp + mm_parse.readvardef.stname]
    lea       rax,	[rax+92]
    or        byte [rax+1],	1
    call      mm_parse.readunit
    mov       r10,	[rbp + mm_parse.readvardef.stname]
    mov       [r10+96],	rax
    jmp       L8074
L8091:
    mov       rax,	[rbp + mm_parse.readvardef.k]
    cmp       rax,	120
    jnz       L8094
    lea       rcx,	[L13362]
    call      mm_support.serror
L8094:
L8074:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jnz       L8069
L8096:
    call      mm_lex.lex
L8068:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	67
    jz        L8067
L8069:
    test      rbx,	rbx
    jnz       L8098
    lea       rcx,	[L13363]
    call      mm_support.serror
L8098:
    mov       rax,	[rbp + mm_parse.readvardef.ulist]
L8064:
;---------------
    add       rsp,	64
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readconstdef
mm_parse.readconstdef:
;?>>
   %define R.owner r13
   %define R.scope r14
   %define R.nconsts rdi
   %define R.deft rbx
   %define R.m rsi
   %define R.stname r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       r13,	rcx
    mov       r14,	rdx
;---------------
    call      mm_lex.lex
    xor       rdi,	rdi
    call      mm_parse.istypestarter
    test      rax,	rax
    jz        L8101
    mov       rcx,	r13
    xor       edx,	edx
    call      mm_parse.readtypespec
    mov       rbx,	rax
    jmp       L8100
L8101:
    mov       rbx,	22
L8100:
    jmp       L8103
L8102:
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       rcx,	r13
    mov       rdx,	rax
    mov       r8,	9
    call      mm_lib.getduplnameptr
    mov       r12,	rax
    call      mm_lex.lex
    call      mm_parse.checkequals
    call      mm_lex.lex
    mov       rcx,	1
    call      mm_parse.readconstexpr
    mov       [r12+64],	rax
    mov       rsi,	rbx
    lea       rax,	[r12+72]
    mov       rcx,	r13
    mov       rdx,	rsi
    mov       r8,	rax
    call      mm_lib.storemode
    inc       rdi
    mov       [r12+170],	r14b
    mov       rcx,	r13
    mov       rdx,	r12
    call      mm_lib.adddef
    cmp       r14,	3
    jnz       L8106
    mov       rax,	[r12]
    movzx     rax,	byte [rax]
    cmp       rax,	36
    jz        L8106
    mov       rcx,	r12
    call      mm_lib.addexpconst
L8106:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jnz       L8104
L8108:
    call      mm_lex.lex
L8103:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	67
    jz        L8102
L8104:
    test      rdi,	rdi
    jnz       L8110
    lea       rcx,	[L13364]
    call      mm_support.serror
L8110:
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readlbrack
mm_parse.readlbrack:
;?>>
    %define mm_parse.readlbrack.ulist -8
    %define mm_parse.readlbrack.ulistx -16
   %define R.p rdi
   %define R.q rbx
   %define R.r rsi
   %define R.plower r12
   %define R.oldirp r13
   %define R.length r14
    %define mm_parse.readlbrack.usecomma -24
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
;---------------
    call      mm_lex.lex
    xor       eax,	eax
    mov       [rbp + mm_parse.readlbrack.ulistx],	rax
    mov       [rbp + mm_parse.readlbrack.ulist],	rax
    xor       r12,	r12
    xor       eax,	eax
    mov       r14,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	17
    jnz       L8113
    call      mm_lex.lex
    mov       r13,	[mm_parse.inreadprint]
    mov       rax,	1
    mov       [mm_parse.inreadprint],	rax
    call      mm_parse.readunit
    mov       r12,	rax
    mov       [mm_parse.inreadprint],	r13
    mov       rcx,	5
    call      mm_parse.checksymbollex
    jmp       L8112
L8113:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	62
    jnz       L8114
    lea       rax,	[mm_decls.nextlx]
    movzx     rax,	byte [rax]
    cmp       rax,	5
    jnz       L8114
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    lea       r10,	[mm_decls.lx]
    mov       r10,	[r10+8]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mm_lib.createconstunit
    mov       r12,	rax
    call      mm_lex.lex
    call      mm_lex.lex
    jmp       L8112
L8114:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    lea       r10,	[mm_tables.symboloptypes]
    movzx     r10,	byte [r10 + rax-1]
    cmp       r10,	1
    jnz       L8115
    lea       rax,	[mm_decls.nextlx]
    movzx     rax,	byte [rax]
    cmp       rax,	10
    jnz       L8115
    mov       rcx,	63
    call      mm_lib.createunit0
    mov       rdi,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    mov       [rdi+40],	ax
    call      mm_lex.lex
    call      mm_lex.lex
    mov       rax,	rdi
    jmp       L8111
L8115:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    lea       r10,	[mm_tables.symboloptypes]
    movzx     r10,	byte [r10 + rax-1]
    cmp       r10,	1
    jnz       L8116
    lea       rax,	[mm_decls.nextlx]
    movzx     rax,	byte [rax]
    cmp       rax,	6
    jnz       L8116
    mov       rcx,	63
    call      mm_lib.createunit0
    mov       rdi,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    lea       r10,	[mm_tables.symbolgentoops]
    mov       r10b,	[r10 + rax-1]
    mov       [rdi+62],	r10b
    call      mm_lex.lex
    mov       rcx,	10
    call      mm_parse.lexchecksymbol
    call      mm_lex.lex
    mov       rax,	rdi
    jmp       L8111
L8116:
L8112:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	10
    jnz       L8119
L8118:
    call      mm_lex.lex
    mov       rcx,	20
    call      mm_lib.createunit0
    mov       rdi,	rax
    mov       [rdi+24],	r12
    xor       eax,	eax
    mov       [rdi+40],	eax
    mov       rax,	rdi
    jmp       L8111
L8119:
    call      mm_parse.readunit
    mov       rdi,	rax
L8117:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	10
    jz        L8121
    cmp       rax,	3
    jz        L8122
    cmp       rax,	16
    jz        L8123
    cmp       rax,	4
    jz        L8124
    jmp       L8125
L8121:
    call      mm_lex.lex
    mov       rax,	rdi
    jmp       L8111
L8122:
    mov       rax,	1
    mov       [rbp + mm_parse.readlbrack.usecomma],	rax
    lea       rax,	[mm_decls.nextlx]
    movzx     rax,	byte [rax]
    cmp       rax,	10
    jnz       L8127
    call      mm_lex.lex
    call      mm_lex.lex
    mov       rcx,	20
    mov       rdx,	rdi
    call      mm_lib.createunit1
    mov       rdi,	rax
    mov       eax,	1
    mov       [rdi+40],	eax
    mov       [rdi+24],	r12
    mov       rax,	rdi
    jmp       L8111
L8127:
;mm_parse.readlbrack.docomma:
L8128:
    mov       r14,	1
    mov       rax,	rdi
    mov       [rbp + mm_parse.readlbrack.ulistx],	rax
    mov       [rbp + mm_parse.readlbrack.ulist],	rax
    mov       rax,	[rbp + mm_parse.readlbrack.usecomma]
    test      rax,	rax
    jz        L8130
L8131:
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	10
    jz        L8133
L8135:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jnz       L8137
    lea       rcx,	[L13365]
    call      mm_support.serror
L8137:
    call      mm_parse.readunit
    lea       rcx,	[rbp + mm_parse.readlbrack.ulist]
    lea       rdx,	[rbp + mm_parse.readlbrack.ulistx]
    mov       r8,	rax
    call      mm_lib.addlistunit
    inc       r14
    call      mm_parse.skipsemi
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jz        L8131
L8133:
    jmp       L8129
L8130:
L8138:
    call      mm_parse.skipsemi
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	10
    jz        L8140
L8142:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jnz       L8144
    lea       rcx,	[L13365]
    call      mm_support.serror
L8144:
    call      mm_parse.readunit
    lea       rcx,	[rbp + mm_parse.readlbrack.ulist]
    lea       rdx,	[rbp + mm_parse.readlbrack.ulistx]
    mov       r8,	rax
    call      mm_lib.addlistunit
    inc       r14
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	4
    jz        L8138
L8140:
L8129:
    mov       rcx,	10
    call      mm_parse.checksymbollex
    mov       rcx,	20
    mov       rdx,	[rbp + mm_parse.readlbrack.ulist]
    call      mm_lib.createunit1
    mov       rdi,	rax
    mov       [rdi+40],	r14d
    mov       [rdi+24],	r12
    mov       rax,	rdi
    jmp       L8111
L8123:
    call      mm_lex.lex
    call      mm_parse.readunit
    mov       rbx,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	16
    jz        L8146
    cmp       rax,	10
    jz        L8147
    jmp       L8148
L8146:
    call      mm_lex.lex
    xor       ecx,	ecx
    call      mm_parse.readsunit
    mov       rsi,	rax
    mov       rcx,	10
    call      mm_parse.checksymbollex
    mov       rcx,	rdi
    call      mm_parse.fixcond
    mov       rcx,	92
    mov       rdx,	rax
    mov       r8,	rbx
    mov       r9,	rsi
    call      mm_lib.createunit3
    mov       rdi,	rax
    mov       al,	1
    mov       [rdi+48],	al
    mov       rax,	rdi
    jmp       L8111
L8147:
    call      mm_lex.lex
    mov       rcx,	rdi
    call      mm_parse.fixcond
    mov       rcx,	92
    mov       rdx,	rax
    mov       r8,	rbx
    xor       r9d,	r9d
    call      mm_lib.createunit3
    mov       rdi,	rax
    mov       al,	1
    mov       [rdi+48],	al
    mov       rax,	rdi
    jmp       L8111
L8148:
L8145:
    lea       rcx,	[rbp + mm_parse.readlbrack.ulist]
    lea       rdx,	[rbp + mm_parse.readlbrack.ulistx]
    mov       r8,	rbx
    call      mm_lib.addlistunit
    mov       rcx,	3
    call      mm_parse.checksymbol
    lea       rax,	[mm_decls.nextlx]
    movzx     rax,	byte [rax]
    cmp       rax,	16
    jz        L8150
L8151:
    call      mm_lex.lex
    call      mm_parse.readunit
    lea       rcx,	[rbp + mm_parse.readlbrack.ulist]
    lea       rdx,	[rbp + mm_parse.readlbrack.ulistx]
    mov       r8,	rax
    call      mm_lib.addlistunit
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jz        L8151
    mov       rcx,	16
    call      mm_parse.checksymbol
    jmp       L8149
L8150:
    call      mm_lex.lex
L8149:
    call      mm_lex.lex
    call      mm_parse.readunit
    mov       rsi,	rax
    mov       rcx,	10
    call      mm_parse.checksymbollex
    mov       rcx,	112
    mov       rdx,	rdi
    mov       r8,	[rbp + mm_parse.readlbrack.ulist]
    mov       r9,	rsi
    call      mm_lib.createunit3
    jmp       L8111
L8124:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    cmp       rax,	1
    jnz       L8155
    xor       eax,	eax
    mov       [rbp + mm_parse.readlbrack.usecomma],	rax
    jmp       L8128
L8155:
    mov       rax,	rdi
    mov       [rbp + mm_parse.readlbrack.ulistx],	rax
    mov       [rbp + mm_parse.readlbrack.ulist],	rax
L8156:
    call      mm_parse.skipsemi
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	10
    jz        L8158
L8160:
    call      mm_parse.readunit
    lea       rcx,	[rbp + mm_parse.readlbrack.ulist]
    lea       rdx,	[rbp + mm_parse.readlbrack.ulistx]
    mov       r8,	rax
    call      mm_lib.addlistunit
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	4
    jz        L8156
L8158:
    mov       rcx,	10
    call      mm_parse.checksymbollex
    mov       rcx,	[rbp + mm_parse.readlbrack.ulist]
    call      mm_parse.makeblock
    jmp       L8111
L8125:
    lea       rcx,	[L13366]
    call      mm_support.serror
L8120:
    xor       eax,	eax
L8111:
;---------------
    add       rsp,	64
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.addlistparam
mm_parse.addlistparam:
;?>>
   %define R.ulist rcx
   %define R.ulistx rdx
   %define R.p r8
;?]]
;---------------
    mov       rax,	[rcx]
    test      rax,	rax
    jnz       L8163
    mov       rax,	r8
    mov       [rdx],	rax
    mov       [rcx],	rax
    jmp       L8162
L8163:
    mov       rax,	[rdx]
    mov       r10,	r8
    mov       [rax+152],	r10
L8162:
    mov       [rdx],	r8
;---------------
    ret       
;End 
;Proc mm_parse.readcast
mm_parse.readcast:
;?>>
   %define R.p rdi
   %define R.opc rbx
   %define R.t rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
;---------------
    mov       rcx,	[mm_decls.currproc]
    xor       edx,	edx
    call      mm_parse.readtypespec
    mov       rsi,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	10
    jz        L8166
    cmp       rax,	17
    jz        L8167
    cmp       rax,	1
    jz        L8168
    jmp       L8169
L8166:
    mov       rcx,	62
    call      mm_lib.createunit0
    mov       rdi,	rax
    mov       eax,	26
    mov       [rdi+49],	eax
    mov       [rdi+16],	rsi
    mov       rax,	rdi
    jmp       L8164
L8167:
    mov       rbx,	61
    call      mm_lex.lex
    jmp       L8165
L8168:
    lea       rax,	[mm_decls.nextlx]
    movzx     rax,	byte [rax]
    cmp       rax,	116
    jnz       L8171
    call      mm_lex.lex
    mov       rcx,	62
    call      mm_lib.createunit0
    mov       rdi,	rax
    mov       [rdi+16],	rsi
    mov       eax,	26
    mov       [rdi+49],	eax
    call      mm_lex.lex
    jmp       L8170
L8171:
    mov       rcx,	62
    call      mm_lib.createunit0
    mov       rdi,	rax
    mov       [rdi+16],	rsi
L8170:
    mov       rax,	rdi
    jmp       L8164
L8169:
    mov       rbx,	58
L8165:
    mov       rcx,	9
    call      mm_parse.checksymbollex
    call      mm_parse.readunit
    mov       rdi,	rax
    mov       rcx,	10
    call      mm_parse.checksymbollex
    mov       rcx,	rbx
    mov       rdx,	rdi
    call      mm_lib.createunit1
    mov       rdi,	rax
    lea       rax,	[rdi+53]
    mov       rcx,	[mm_decls.currproc]
    mov       rdx,	rsi
    mov       r8,	rax
    call      mm_lib.storemode
    mov       rax,	rdi
L8164:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readopc
mm_parse.readopc:
;?>>
   %define R.p rdi
   %define R.q rbx
   %define R.r rsi
   %define R.tag r12
   %define R.opc r13
   %define R.firstsym r14
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
;---------------
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    mov       r14,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	55
    jz        L8174
    cmp       rax,	56
    jz        L8175
    jmp       L8176
L8174:
    mov       r12,	36
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    mov       r13,	rax
    jmp       L8173
L8175:
    mov       r12,	35
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    mov       r13,	rax
    jmp       L8173
L8176:
    mov       r12,	36
    lea       rax,	[mm_tables.symbolgenops]
    mov       r10,	r14
    movzx     rax,	byte [rax + r10-1]
    mov       r13,	rax
L8173:
    call      mm_lex.lex
    mov       rax,	r14
    cmp       rax,	24
    jz        L8178
    cmp       rax,	25
    jz        L8179
    cmp       rax,	36
    jz        L8180
    cmp       rax,	37
    jz        L8180
    cmp       rax,	56
    jz        L8180
    cmp       rax,	31
    jz        L8180
    cmp       rax,	32
    jz        L8180
    cmp       rax,	33
    jz        L8180
    jmp       L8181
L8178:
    call      mm_parse.readterm2
    jmp       L8172
L8179:
    mov       r13,	60
    jmp       L8177
L8180:
    call      mm_parse.readterm2
    mov       rdi,	rax
    movzx     rax,	byte [rdi]
    cmp       rax,	20
    jnz       L8183
    mov       eax,	[rdi+40]
    cmp       rax,	2
    jz        L8185
    lea       rcx,	[L13367]
    call      mm_support.serror
L8185:
    mov       rbx,	[rdi+16]
    mov       rsi,	[rbx+8]
    xor       eax,	eax
    mov       [rbx+8],	rax
    mov       rcx,	35
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mm_lib.createunit2
    mov       rdi,	rax
    mov       [rdi+62],	r13b
    mov       rax,	rdi
    jmp       L8172
L8183:
    lea       rcx,	[L13368]
    call      mm_support.serror
    mov       rcx,	r13
    mov       rdx,	rdi
    call      mm_lib.createunit1
    jmp       L8172
L8182:
    jmp       L8177
L8181:
    lea       rax,	[mm_tables.symboloptypes]
    mov       r10,	r14
    movzx     rax,	byte [rax + r10-1]
    cmp       rax,	1
    jnz       L8187
    lea       rcx,	[L13369]
    call      mm_support.serror
L8187:
L8177:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	6
    jnz       L8189
    call      mm_lex.lex
    mov       r12,	39
    cmp       r14,	25
    jnz       L8192
L8191:
    mov       r13,	105
    jmp       L8190
L8192:
    lea       rax,	[mm_tables.symbolgentoops]
    mov       r10,	r14
    movzx     rax,	byte [rax + r10-1]
    mov       r13,	rax
    test      r13,	r13
    jnz       L8194
    lea       rcx,	[L13370]
    call      mm_support.serror
L8194:
L8190:
L8189:
    call      mm_parse.readterm2
    mov       r10,	rax
    mov       rbx,	r10
    mov       rcx,	r12
    mov       rdx,	rax
    call      mm_lib.createunit1
    mov       rdi,	rax
    mov       [rdi+62],	r13b
    movzx     rax,	byte [rbx]
    cmp       rax,	20
    jnz       L8196
    lea       rcx,	[L13371]
    call      mm_support.serror
L8196:
    mov       rax,	rdi
L8172:
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readcompilervar
mm_parse.readcompilervar:
;?>>
    %define mm_parse.readcompilervar.str -104
    %define mm_parse.readcompilervar.tm -120
   %define R.p rdi
   %define R.currmodule rbx
    push      rdi
    push      rbx
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	160
;---------------
    lea       rax,	[mm_decls.modules]
    mov       r10,	[mm_decls.currmoduleno]
    mov       rbx,	[rax + r10*8]
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    sub       rax,	71
    cmp       rax,	14
    jae       L8200
    lea       r10,	[L8199]
    jmp       [r10 + rax*8]
    segment .data
L8199:
    dq  L8204
    dq  L8205
    dq  L8206
    dq  L8207
    dq  L8208
    dq  L8209
    dq  L8210
    dq  L8211
    dq  L8200
    dq  L8201
    dq  L8202
    dq  L8203
    dq  L8212
    dq  L8212
    segment .text
L8201:
    xor       ecx,	ecx
    mov       rdx,	7
    call      mm_lib.createconstunit
    mov       rdi,	rax
    call      mm_lex.lex
    mov       rax,	rdi
    jmp       L8197
L8202:
    movq      XMM4,	[L13372]
    movq      rax,	XMM4
    mov       rcx,	rax
    mov       rdx,	1
    call      mm_lib.createconstunit
    mov       rdi,	rax
    call      mm_lex.lex
    mov       rax,	rdi
    jmp       L8197
L8203:
    movq      XMM4,	[L13373]
    movq      rax,	XMM4
    mov       rcx,	rax
    mov       rdx,	1
    call      mm_lib.createconstunit
    mov       rdi,	rax
    call      mm_lex.lex
    mov       rax,	rdi
    jmp       L8197
L8204:
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       rcx,	rax
    call      mm_support.getlineno
    mov       rcx,	rax
    mov       rdx,	3
    call      mm_lib.createconstunit
    mov       rdi,	rax
    call      mm_lex.lex
    mov       rax,	rdi
    jmp       L8197
L8205:
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       rcx,	rax
    call      mm_support.getlineno
    mov       rcx,	rax
    lea       rdx,	[rbp + mm_parse.readcompilervar.str]
    call      msys.getstrint
    jmp       L8198
L8206:
    mov       rax,	[mm_decls.stmodule]
    mov       rax,	[rax]
    lea       rcx,	[rbp + mm_parse.readcompilervar.str]
    mov       rdx,	rax
    call      strcpy
    jmp       L8198
L8207:
    movsx     rax,	word [rbx+20]
    lea       r10,	[mm_decls.sources]
    mov       r10,	[r10 + rax*8]
    mov       r10,	[r10+24]
    lea       rcx,	[rbp + mm_parse.readcompilervar.str]
    mov       rdx,	r10
    call      strcpy
    jmp       L8198
L8208:
    mov       rax,	[mm_decls.currproc]
    mov       rax,	[rax]
    lea       rcx,	[rbp + mm_parse.readcompilervar.str]
    mov       rdx,	rax
    call      strcpy
    jmp       L8198
L8209:
    lea       rcx,	[rbp + mm_parse.readcompilervar.tm]
    call      mwindows.os_getsystime
    lea       rcx,	[rbp + mm_parse.readcompilervar.str]
    call      msys.m$print_startstr
    lea       rcx,	[L13374]
    call      msys.m$print_setfmt
    movzx     rax,	word [rbp + mm_parse.readcompilervar.tm+6]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    movzx     rax,	word [rbp + mm_parse.readcompilervar.tm+2]
    lea       r10,	[mm_parse.readcompilervar.monthnames]
    mov       r10,	[r10 + rax*8-8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    movzx     rax,	word [rbp + mm_parse.readcompilervar.tm]
    mov       rcx,	rax
    lea       rdx,	[L13375]
    call      msys.m$print_i64
    call      msys.m$print_end
    jmp       L8198
L8210:
    lea       rcx,	[rbp + mm_parse.readcompilervar.tm]
    call      mwindows.os_getsystime
    lea       rcx,	[rbp + mm_parse.readcompilervar.str]
    call      msys.m$print_startstr
    lea       rcx,	[L13376]
    call      msys.m$print_setfmt
    movzx     rax,	word [rbp + mm_parse.readcompilervar.tm+8]
    mov       rcx,	rax
    lea       rdx,	[L13377]
    call      msys.m$print_i64
    movzx     rax,	word [rbp + mm_parse.readcompilervar.tm+10]
    mov       rcx,	rax
    lea       rdx,	[L13377]
    call      msys.m$print_i64
    movzx     rax,	word [rbp + mm_parse.readcompilervar.tm+12]
    mov       rcx,	rax
    lea       rdx,	[L13377]
    call      msys.m$print_i64
    call      msys.m$print_end
    jmp       L8198
L8211:
    lea       rcx,	[rbp + mm_parse.readcompilervar.str]
    lea       rdx,	[L13378]
    call      strcpy
    jmp       L8198
L8212:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    cmp       rax,	83
    setz      al
    movzx     eax,	al
    mov       rcx,	rax
    mov       rdx,	6
    call      mm_lib.createconstunit
    mov       rdi,	rax
    call      mm_lex.lex
    mov       rax,	rdi
    jmp       L8197
L8200:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    lea       r10,	[mm_tables.jtagnames]
    mov       r10,	[r10 + rax*8]
    lea       rcx,	[L13379]
    mov       rdx,	r10
    call      mm_support.serror_s
L8198:
    call      mm_lex.lex
    lea       rcx,	[rbp + mm_parse.readcompilervar.str]
    call      mlib.pcm_copyheapstring
    mov       rcx,	rax
    mov       rdx,	-1
    call      mm_lib.createstringconstunit
L8197:
;---------------
    add       rsp,	160
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readcastx
mm_parse.readcastx:
;?>>
   %define R.opc rdi
   %define R.m rbx
   %define R.p rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
;---------------
    call      mm_lex.lex
    mov       rdi,	58
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	17
    jnz       L8215
    mov       rdi,	61
    call      mm_lex.lex
L8215:
    mov       rcx,	9
    call      mm_parse.checksymbollex
    xor       rbx,	rbx
    call      mm_parse.readunit
    mov       rsi,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jz        L8217
    cmp       rdi,	61
    jnz       L8219
    lea       rcx,	[L13380]
    call      mm_support.serror
L8219:
    mov       rdi,	60
    jmp       L8216
L8217:
    call      mm_lex.lex
    mov       rcx,	[mm_decls.currproc]
    xor       edx,	edx
    call      mm_parse.readtypespec
    mov       rbx,	rax
L8216:
    mov       rcx,	10
    call      mm_parse.checksymbollex
    mov       rcx,	rdi
    mov       rdx,	rsi
    call      mm_lib.createunit1
    mov       rsi,	rax
    lea       rax,	[rsi+53]
    mov       rcx,	[mm_decls.currproc]
    mov       rdx,	rbx
    mov       r8,	rax
    call      mm_lib.storemode
    mov       rax,	rsi
L8213:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.checksymbol
mm_parse.checksymbol:
;?>>
   %define R.symbol rdi
    %define mm_parse.checksymbol.str -104
    push      rdi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	136
    mov       rdi,	rcx
;---------------
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	rdi
    jz        L8222
    lea       rcx,	[rbp + mm_parse.checksymbol.str]
    call      msys.m$print_startstr
    lea       rcx,	[L13381]
    call      msys.m$print_setfmt
    lea       rax,	[mm_tables.symbolnames]
    mov       r10,	rdi
    mov       rcx,	[rax + r10*8-8]
    call      msys.m$print_str_nf
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    lea       r10,	[mm_tables.symbolnames]
    mov       r10,	[r10 + rax*8-8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       rcx,	[rbp + mm_parse.checksymbol.str]
    call      mm_support.serror
L8222:
;---------------
    add       rsp,	136
    pop       rbp
    pop       rdi
    ret       
;End 
;Proc mm_parse.lexchecksymbol
mm_parse.lexchecksymbol:
;?>>
   %define R.symbol rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    call      mm_lex.lex
    mov       rcx,	rdi
    call      mm_parse.checksymbol
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_parse.checksymbollex
mm_parse.checksymbollex:
;?>>
   %define R.symbol rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      mm_parse.checksymbol
    call      mm_lex.lex
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_parse.readtypespec
mm_parse.readtypespec:
;?>>
    %define mm_parse.readtypespec.owner 64
    %define mm_parse.readtypespec.typedefx 72
   %define R.d rdi
   %define R.t rbx
   %define R.dim rsi
   %define R.length r12
    %define mm_parse.readtypespec.dims -240
   %define R.ndims r13
   %define R.i r14
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	272
    mov       [rbp+64],	rcx
    mov       [rbp+72],	rdx
;---------------
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	11
    jz        L8227
    cmp       rax,	79
    jz        L8228
    cmp       rax,	67
    jz        L8229
    cmp       rax,	111
    jz        L8230
    cmp       rax,	112
    jz        L8230
    cmp       rax,	113
    jz        L8231
    cmp       rax,	117
    jz        L8232
    cmp       rax,	80
    jz        L8233
    cmp       rax,	121
    jz        L8234
    jmp       L8235
L8227:
;mm_parse.readtypespec.arraybounds:
    call      mm_lex.lex
    xor       r13,	r13
    mov       rax,	1
    mov       [mm_parse.inreadprint],	rax
L8237:
    xor       r12,	r12
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	12
    jz        L8241
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jnz       L8240
L8241:
    xor       rsi,	rsi
    jmp       L8239
L8240:
    call      mm_parse.readunit
    mov       rsi,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	12
    jz        L8243
    cmp       rax,	3
    jz        L8243
    cmp       rax,	5
    jz        L8244
    jmp       L8245
L8243:
    jmp       L8242
L8244:
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jz        L8247
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	12
    jz        L8247
    call      mm_parse.readunit
    mov       r12,	rax
    mov       rcx,	27
    mov       rdx,	rsi
    mov       r8,	r12
    call      mm_lib.createunit2
    mov       rsi,	rax
    jmp       L8246
L8247:
    mov       rcx,	27
    mov       rdx,	rsi
    call      mm_lib.createunit1
    mov       rsi,	rax
L8246:
L8245:
L8242:
L8239:
    cmp       r13,	30
    jl        L8249
    lea       rcx,	[L13382]
    call      mm_support.serror
L8249:
    inc       r13
    mov       rax,	r13
    mov       r10,	rsi
    mov       [rbp + rax*8 + mm_parse.readtypespec.dims-8],	r10
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jnz       L8238
L8251:
    call      mm_lex.lex
    jmp       L8237
L8238:
    xor       eax,	eax
    mov       [mm_parse.inreadprint],	rax
    mov       rcx,	12
    call      mm_parse.checksymbollex
    mov       rcx,	[rbp + mm_parse.readtypespec.owner]
    xor       edx,	edx
    call      mm_parse.readtypespec
    mov       rbx,	rax
    mov       r14,	r13
    cmp       r14,	1
    jl        L8254
L8252:
    cmp       r14,	1
    jnz       L8256
    mov       rax,	[rbp + mm_parse.readtypespec.typedefx]
    jmp       L8255
L8256:
    xor       eax,	eax
L8255:
    mov       r10,	[rbp + r14*8 + mm_parse.readtypespec.dims-8]
    mov       rcx,	[rbp + mm_parse.readtypespec.owner]
    mov       rdx,	rbx
    mov       r8,	r10
    mov       r9,	rax
    call      mm_lib.createarraymode
    mov       rbx,	rax
    dec       r14
    cmp       r14,	1
    jge       L8252
L8254:
    mov       rax,	rbx
    jmp       L8225
L8228:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    mov       rbx,	rax
    call      mm_lex.lex
    jmp       L8226
L8229:
    lea       rax,	[mm_decls.lx]
    mov       rdi,	[rax+8]
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	1
    jnz       L8258
    mov       rcx,	67
    call      mm_parse.lexchecksymbol
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mm_lib.newtypename
    mov       rbx,	rax
    call      mm_lex.lex
    jmp       L8257
L8258:
    xor       ecx,	ecx
    mov       rdx,	rdi
    call      mm_lib.newtypename
    mov       rbx,	rax
L8257:
    jmp       L8226
L8230:
    lea       rcx,	[L13383]
    call      mm_support.serror
    jmp       L8226
L8231:
    lea       rcx,	[L13384]
    call      mm_support.serror
    jmp       L8226
L8232:
;mm_parse.readtypespec.retry:
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	94
    jnz       L8261
    call      mm_lex.lex
L8261:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	108
    jz        L8263
    cmp       rax,	109
    jz        L8263
    cmp       rax,	79
    jz        L8264
    cmp       rax,	118
    jz        L8265
    jmp       L8266
L8263:
    mov       rcx,	[rbp + mm_parse.readtypespec.owner]
    mov       rdx,	[rbp + mm_parse.readtypespec.typedefx]
    call      mm_parse.readrefproc
    mov       rbx,	rax
    jmp       L8262
L8264:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    cmp       rax,	12
    jnz       L8269
L8268:
    mov       rbx,	20
    mov       rax,	[rbp + mm_parse.readtypespec.typedefx]
    test      rax,	rax
    jz        L8271
    mov       eax,	12
    lea       r10,	[mm_decls.tttarget]
    mov       r11,	[rbp + mm_parse.readtypespec.typedefx]
    mov       [r10 + r11*4],	eax
L8271:
    jmp       L8267
L8269:
    jmp       L8272
L8267:
    call      mm_lex.lex
    jmp       L8262
L8265:
    call      mm_lex.lex
    xor       rbx,	rbx
    jmp       L8273
L8266:
;mm_parse.readtypespec.readtarget:
L8272:
    mov       rcx,	[rbp + mm_parse.readtypespec.owner]
    xor       edx,	edx
    call      mm_parse.readtypespec
    mov       rbx,	rax
;mm_parse.readtypespec.gottarget:
L8273:
    mov       rcx,	[rbp + mm_parse.readtypespec.owner]
    mov       rdx,	rbx
    mov       r8,	[rbp + mm_parse.readtypespec.typedefx]
    call      mm_lib.createrefmode
    mov       rbx,	rax
L8262:
    jmp       L8226
L8233:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    cmp       rax,	12
    jnz       L8275
    mov       rbx,	20
    jmp       L8274
L8275:
    mov       rbx,	7
L8274:
    mov       rax,	[rbp + mm_parse.readtypespec.typedefx]
    test      rax,	rax
    jz        L8277
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    lea       r10,	[mm_decls.tttarget]
    mov       r11,	[rbp + mm_parse.readtypespec.typedefx]
    mov       [r10 + r11*4],	eax
L8277:
    call      mm_lex.lex
    jmp       L8226
L8234:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    mov       rcx,	[rbp + mm_parse.readtypespec.owner]
    mov       rdx,	rax
    mov       r8,	[rbp + mm_parse.readtypespec.typedefx]
    call      mm_parse.readslicetype
    mov       rbx,	rax
    jmp       L8226
L8235:
    lea       rcx,	[L13385]
    call      mm_support.serror
L8226:
    mov       rax,	[rbp + mm_parse.readtypespec.typedefx]
    test      rax,	rax
    jz        L8279
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rbx
    mov       eax,	[rax + r10*4]
    lea       r10,	[mm_decls.ttbasetype]
    mov       r11,	[rbp + mm_parse.readtypespec.typedefx]
    mov       [r10 + r11*4],	eax
L8279:
    mov       rax,	rbx
L8225:
;---------------
    add       rsp,	272
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readslicetype
mm_parse.readslicetype:
;?>>
   %define R.owner rsi
   %define R.slicetype r12
   %define R.typedefx r13
   %define R.plower rdi
   %define R.t rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
;---------------
    mov       rcx,	11
    call      mm_parse.lexchecksymbol
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	12
    jz        L8282
    mov       rax,	1
    mov       [mm_parse.inreadprint],	rax
    call      mm_parse.readunit
    mov       rdi,	rax
    xor       eax,	eax
    mov       [mm_parse.inreadprint],	rax
    mov       rcx,	5
    call      mm_parse.checksymbol
    mov       rcx,	12
    call      mm_parse.lexchecksymbol
    jmp       L8281
L8282:
    xor       rdi,	rdi
L8281:
    call      mm_lex.lex
    mov       rcx,	rsi
    mov       rdx,	r13
    call      mm_parse.readtypespec
    mov       rbx,	rax
    sub       rsp,	8
    mov       rax,	r13
    push      rax
    mov       rcx,	rsi
    mov       rdx,	r12
    mov       r8,	rbx
    mov       r9,	rdi
    sub       rsp,	32
    call      mm_lib.createslicemode
    add       rsp,	48
L8280:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readslist
mm_parse.readslist:
;?>>
   %define R.iscall rbx
   %define R.donulls rsi
    %define mm_parse.readslist.ulist -8
    %define mm_parse.readslist.ulistx -16
   %define R.oldinparamlist rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    xor       eax,	eax
    mov       [rbp + mm_parse.readslist.ulistx],	rax
    mov       [rbp + mm_parse.readslist.ulist],	rax
    call      mm_parse.skipsemi
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	10
    jnz       L8285
    mov       rax,	[rbp + mm_parse.readslist.ulist]
    jmp       L8283
L8285:
    mov       rdi,	[mm_parse.inparamlist]
    mov       [mm_parse.inparamlist],	rbx
L8286:
    call      mm_parse.skipsemi
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jz        L8289
    cmp       rax,	10
    jz        L8290
    jmp       L8291
L8289:
    test      rsi,	rsi
    jz        L8293
    mov       rcx,	2
    call      mm_lib.createunit0
    lea       rcx,	[rbp + mm_parse.readslist.ulist]
    lea       rdx,	[rbp + mm_parse.readslist.ulistx]
    mov       r8,	rax
    call      mm_lib.addlistunit
    jmp       L8292
L8293:
    lea       rcx,	[L13386]
    call      mm_support.serror
L8292:
    call      mm_lex.lex
    jmp       L8288
L8290:
    test      rsi,	rsi
    jz        L8295
    lea       rcx,	[rbp + mm_parse.readslist.ulist]
    lea       rdx,	[rbp + mm_parse.readslist.ulistx]
    mov       r8,	[mm_decls.nullunit]
    call      mm_lib.addlistunit
L8295:
    jmp       L8287
L8291:
    call      mm_parse.readunit
    lea       rcx,	[rbp + mm_parse.readslist.ulist]
    lea       rdx,	[rbp + mm_parse.readslist.ulistx]
    mov       r8,	rax
    call      mm_lib.addlistunit
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jz        L8298
    cmp       rax,	4
    jnz       L8297
L8298:
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	10
    jz        L8287
L8300:
    jmp       L8296
L8297:
    call      mm_parse.skipsemi
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	10
    jz        L8287
L8302:
    lea       rcx,	[L13387]
    call      mm_support.serror
L8296:
L8288:
    jmp       L8286
L8287:
    mov       [mm_parse.inparamlist],	rdi
    mov       rax,	[rbp + mm_parse.readslist.ulist]
L8283:
;---------------
    add       rsp,	56
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readindex
mm_parse.readindex:
;?>>
   %define R.p r12
   %define R.dot r13
   %define R.q rdi
   %define R.plower rbx
   %define R.pupper rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r12,	rcx
    mov       r13,	rdx
;---------------
    call      mm_lex.lex
    test      r13,	r13
    jnz       L8305
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	12
    jz        L8307
    cmp       rax,	21
    jz        L8308
    cmp       rax,	5
    jz        L8308
    jmp       L8309
L8307:
;mm_parse.readindex.fullslice:
L8310:
    call      mm_lex.lex
    mov       rcx,	r12
    xor       edx,	edx
    call      mm_lib.duplunit
    mov       rcx,	36
    mov       rdx,	rax
    call      mm_lib.createunit1
    mov       rbx,	rax
    mov       al,	3
    mov       [rbx+62],	al
    mov       rcx,	r12
    xor       edx,	edx
    call      mm_lib.duplunit
    mov       rcx,	36
    mov       rdx,	rax
    call      mm_lib.createunit1
    mov       rsi,	rax
    mov       al,	4
    mov       [rsi+62],	al
    mov       rcx,	21
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mm_lib.createunit2
    mov       rcx,	48
    mov       rdx,	r12
    mov       r8,	rax
    call      mm_lib.createunit2
    mov       r12,	rax
    mov       rax,	r12
    jmp       L8303
L8308:
    mov       rcx,	12
    call      mm_parse.lexchecksymbol
    jmp       L8310
L8309:
L8306:
L8305:
L8311:
    mov       rax,	[mm_parse.ndollar]
    cmp       rax,	10
    jl        L8314
    lea       rcx,	[L13388]
    call      mm_support.serror
L8314:
    inc       qword [mm_parse.ndollar]
    mov       rax,	[mm_parse.ndollar]
    mov       r10,	r12
    lea       r11,	[mm_parse.dollarstack]
    mov       [r11 + rax*8-8],	r10
    call      mm_parse.readunit
    mov       rdi,	rax
    dec       qword [mm_parse.ndollar]
    movzx     rax,	byte [rdi]
    cmp       rax,	21
    jnz       L8316
    test      r13,	r13
    jz        L8318
    mov       rax,	52
    jmp       L8317
L8318:
    mov       rax,	48
L8317:
    mov       rcx,	rax
    mov       rdx,	r12
    mov       r8,	rdi
    call      mm_lib.createunit2
    mov       r12,	rax
    jmp       L8315
L8316:
    test      r13,	r13
    jz        L8320
    mov       rax,	51
    jmp       L8319
L8320:
    mov       rax,	46
L8319:
    mov       rcx,	rax
    mov       rdx,	r12
    mov       r8,	rdi
    call      mm_lib.createunit2
    mov       r12,	rax
L8315:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jnz       L8312
L8322:
    call      mm_lex.lex
    jmp       L8311
L8312:
    mov       rcx,	12
    call      mm_parse.checksymbollex
    mov       rax,	r12
L8303:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readdotsuffix
mm_parse.readdotsuffix:
;?>>
   %define R.p r12
   %define R.q rdi
   %define R.r rbx
   %define R.p2 rsi
    %define mm_parse.readdotsuffix.$T1 -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       r12,	rcx
;---------------
    jmp       L8325
L8324:
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	11
    jz        L8328
    cmp       rax,	67
    jz        L8329
    cmp       rax,	54
    jz        L8330
    cmp       rax,	57
    jz        L8331
    cmp       rax,	116
    jz        L8332
    cmp       rax,	37
    jz        L8333
    cmp       rax,	36
    jz        L8334
    cmp       rax,	79
    jz        L8335
    jmp       L8336
L8328:
    mov       rcx,	r12
    mov       rdx,	1
    call      mm_parse.readindex
    mov       r12,	rax
    jmp       L8327
L8329:
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       rcx,	rax
    call      mm_lib.createname
    mov       rcx,	49
    mov       rdx,	r12
    mov       r8,	rax
    call      mm_lib.createunit2
    mov       r12,	rax
    call      mm_lex.lex
    jmp       L8327
L8330:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    cmp       rax,	5
    jnz       L8338
    mov       rcx,	r12
    xor       edx,	edx
    call      mm_lib.duplunit
    mov       rcx,	37
    mov       rdx,	rax
    call      mm_lib.createunit1
    mov       rdi,	rax
    mov       rcx,	r12
    xor       edx,	edx
    call      mm_lib.duplunit
    mov       rcx,	37
    mov       rdx,	rax
    call      mm_lib.createunit1
    mov       rbx,	rax
    movzx     rax,	byte [r12]
    cmp       rax,	62
    jnz       L8340
    mov       al,	9
    mov       [rdi+62],	al
    mov       al,	10
    mov       [rbx+62],	al
    jmp       L8339
L8340:
    mov       al,	3
    mov       [rdi+62],	al
    mov       al,	4
    mov       [rbx+62],	al
L8339:
    mov       rcx,	21
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_lib.createunit2
    mov       rsi,	rax
    mov       rcx,	r12
    mov       rdx,	rsi
    call      mm_lib.deleteunit
    jmp       L8337
L8338:
;mm_parse.readdotsuffix.doprop:
L8341:
    mov       rcx,	37
    mov       rdx,	r12
    call      mm_lib.createunit1
    mov       r12,	rax
    lea       rax,	[mm_decls.lx]
    mov       al,	[rax+1]
    mov       [r12+62],	al
L8337:
    call      mm_lex.lex
    jmp       L8327
L8331:
    mov       rcx,	68
    mov       rdx,	r12
    call      mm_lib.createunit1
    mov       r12,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    mov       [r12+40],	ax
    call      mm_lex.lex
    jmp       L8327
L8332:
    movzx     rax,	byte [r12]
    cmp       rax,	62
    jnz       L8344
L8343:
    jmp       L8342
L8344:
    lea       rcx,	[L13389]
    call      mm_support.serror
L8342:
    call      mm_lex.lex
    jmp       L8327
L8333:
    mov       al,	10
    lea       r10,	[mm_decls.lx]
    mov       [r10+1],	al
    jmp       L8341
L8334:
    mov       al,	9
    lea       r10,	[mm_decls.lx]
    mov       [r10+1],	al
    jmp       L8341
L8335:
    movzx     rax,	byte [r12]
    cmp       rax,	62
    jnz       L8346
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    cmp       rax,	9
    jnz       L8346
    mov       rcx,	36
    mov       rdx,	r12
    call      mm_lib.createunit1
    mov       [rbp + mm_parse.readdotsuffix.$T1],	rax
    mov       rcx,	36
    mov       rdx,	r12
    call      mm_lib.createunit1
    mov       rcx,	21
    mov       rdx,	rax
    mov       r8,	[rbp + mm_parse.readdotsuffix.$T1]
    call      mm_lib.createunit2
    mov       rdi,	rax
    mov       rax,	[rdi+16]
    mov       r10b,	9
    mov       [rax+62],	r10b
    mov       rax,	[rdi+24]
    mov       r10b,	10
    mov       [rax+62],	r10b
    jmp       L8345
L8346:
    jmp       L8347
L8345:
    call      mm_lex.lex
    mov       r12,	rdi
    jmp       L8327
L8336:
;mm_parse.readdotsuffix.error:
L8347:
    lea       rcx,	[L13390]
    call      mm_support.serror
L8327:
L8325:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	1
    jz        L8324
    mov       rax,	r12
L8323:
;---------------
    add       rsp,	48
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readconstexpr
mm_parse.readconstexpr:
;?>>
    %define mm_parse.readconstexpr.needconst 16
;?]]
    sub       rsp,	40
;---------------
    call      mm_parse.readunit
L8348:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mm_parse.readconstint
mm_parse.readconstint:
;?>>
   %define R.x rdi
    push      rdi
;?]]
    sub       rsp,	48
;---------------
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	62
    jnz       L8351
    lea       rax,	[mm_decls.lx]
    mov       rdi,	[rax+8]
    call      mm_lex.lex
    mov       rax,	rdi
    jmp       L8349
L8351:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	25
    jnz       L8352
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	62
    jnz       L8354
    lea       rax,	[mm_decls.lx]
    mov       rdi,	[rax+8]
    call      mm_lex.lex
    mov       rax,	rdi
    neg       rax
    jmp       L8349
L8354:
L8352:
L8350:
    lea       rcx,	[L13391]
    call      mm_support.serror
    xor       eax,	eax
L8349:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_parse.readprocdef
mm_parse.readprocdef:
;?>>
   %define R.procowner r15
    %define mm_parse.readprocdef.scope 80
   %define R.kwd rdi
   %define R.startline rbx
   %define R.closesym rsi
   %define R.shortfun r12
   %define R.stproc r13
   %define R.stname r14
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       r15,	rcx
    mov       [rbp+80],	rdx
;---------------
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    mov       rdi,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    cmp       rax,	1
    setz      al
    movzx     eax,	al
    mov       r12,	rax
    xor       eax,	eax
    mov       [mm_parse.nforloops],	rax
    mov       rax,	1
    mov       [mm_decls.assemmode],	rax
    mov       rcx,	r15
    mov       rdx,	[rbp + mm_parse.readprocdef.scope]
    call      mm_parse.readprocdecl
    mov       r13,	rax
    xor       eax,	eax
    mov       [mm_decls.assemmode],	rax
    call      mm_parse.checkequals
    call      mm_lex.lex
    call      mm_parse.getcurrline
    mov       rbx,	rax
    test      r12,	r12
    jnz       L8357
    xor       ecx,	ecx
    call      mm_parse.checkbegin
    mov       rsi,	rax
L8357:
    mov       rcx,	r13
    call      mm_parse.pushproc
    xor       eax,	eax
    mov       [mm_lib.nextavindex],	rax
    mov       rax,	[mm_parse.dretvar]
    test      rax,	rax
    jz        L8359
    mov       rcx,	r13
    mov       rdx,	[mm_parse.dretvar]
    mov       r8,	11
    call      mm_lib.getduplnameptr
    mov       r14,	rax
    lea       rax,	[r14+72]
    movsxd    r10,	dword [r13+72]
    mov       rcx,	r15
    mov       rdx,	r10
    mov       r8,	rax
    call      mm_lib.storemode
    mov       rcx,	r13
    mov       rdx,	r14
    call      mm_lib.adddef
L8359:
    mov       rcx,	r13
    call      mm_lib.addtoproclist
    test      r12,	r12
    jz        L8361
    call      mm_parse.readunit
    mov       [r13+64],	rax
    mov       rcx,	4
    call      mm_parse.checksymbollex
    jmp       L8360
L8361:
    xor       ecx,	ecx
    call      mm_parse.readsunit
    mov       [r13+64],	rax
    mov       rcx,	rsi
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_parse.checkbeginend
L8360:
    mov       rax,	[r13+64]
    mov       rcx,	rax
    call      mm_parse.makeblock
    mov       [r13+64],	rax
    call      mm_parse.popproc
;---------------
    add       rsp,	40
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readprocdecl
mm_parse.readprocdecl:
;?>>
    %define mm_parse.readprocdecl.procowner 64
    %define mm_parse.readprocdecl.scope 72
   %define R.kwd rdi
    %define mm_parse.readprocdecl.varparams -8
    %define mm_parse.readprocdecl.nparams -16
   %define R.nretvalues rbx
   %define R.isthreaded rsi
    %define mm_parse.readprocdecl.retmodes -48
   %define R.ms r12
   %define R.ps r13
   %define R.metadata r14
    %define mm_parse.readprocdecl.truename -56
    %define mm_parse.readprocdecl.pequiv -64
    %define mm_parse.readprocdecl.stproc -72
    %define mm_parse.readprocdecl.owner -80
    %define mm_parse.readprocdecl.paramlist -88
    %define mm_parse.readprocdecl.nameptr -96
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	128
    mov       [rbp+64],	rcx
    mov       [rbp+72],	rdx
;---------------
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    mov       rdi,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    cmp       rax,	2
    setz      al
    movzx     eax,	al
    mov       rsi,	rax
    xor       eax,	eax
    mov       [rbp + mm_parse.readprocdecl.pequiv],	rax
    lea       rax,	[L13392]
    mov       r14,	rax
    xor       eax,	eax
    mov       [rbp + mm_parse.readprocdecl.truename],	rax
    xor       eax,	eax
    mov       [rbp + mm_parse.readprocdecl.varparams],	rax
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	65
    jnz       L8364
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       rcx,	rax
    call      mlib.pcm_copyheapstring
    mov       [rbp + mm_parse.readprocdecl.truename],	rax
    lea       rax,	[mm_decls.lx]
    mov       rcx,	[rax+8]
    call      mlib.convlcstring
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       rcx,	rax
    call      mm_lex.addnamestr
    lea       r10,	[mm_decls.lx]
    mov       [r10+8],	rax
    jmp       L8363
L8364:
    mov       rcx,	67
    call      mm_parse.checksymbol
L8363:
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       [rbp + mm_parse.readprocdecl.nameptr],	rax
    mov       rax,	[mm_parse.insidedllimport]
    test      rax,	rax
    jz        L8366
    mov       rax,	7
    jmp       L8365
L8366:
    mov       rax,	6
L8365:
    mov       rcx,	[rbp + mm_parse.readprocdecl.procowner]
    mov       rdx,	[rbp + mm_parse.readprocdecl.nameptr]
    mov       r8,	rax
    call      mm_lib.getduplnameptr
    mov       [rbp + mm_parse.readprocdecl.stproc],	rax
    mov       rax,	[mm_parse.insidedllimport]
    test      rax,	rax
    jz        L8368
    mov       rax,	1
    mov       [rbp + mm_parse.readprocdecl.scope],	rax
L8368:
    mov       al,	sil
    mov       r10,	[rbp + mm_parse.readprocdecl.stproc]
    mov       [r10+124],	al
    mov       rax,	[rbp + mm_parse.readprocdecl.truename]
    test      rax,	rax
    jz        L8370
    mov       rax,	[rbp + mm_parse.readprocdecl.truename]
    mov       r10,	[rbp + mm_parse.readprocdecl.stproc]
    mov       [r10+104],	rax
L8370:
    mov       rcx,	[rbp + mm_parse.readprocdecl.procowner]
    mov       rdx,	[rbp + mm_parse.readprocdecl.stproc]
    call      mm_lib.adddef
    mov       rax,	[rbp + mm_parse.readprocdecl.stproc]
    movzx     rax,	byte [rax+78]
    cmp       rax,	7
    jnz       L8372
    mov       rax,	[rbp + mm_parse.readprocdecl.stproc]
    lea       rax,	[rax+92]
    or        byte [rax+1],	8
L8372:
    mov       rax,	[rbp + mm_parse.readprocdecl.stproc]
    mov       [rbp + mm_parse.readprocdecl.owner],	rax
    mov       rcx,	[rbp + mm_parse.readprocdecl.stproc]
    call      mm_parse.pushproc
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	26
    jnz       L8374
    mov       rax,	[rbp + mm_parse.readprocdecl.stproc]
    lea       rax,	[rax+92]
    or        byte [rax],	64
    call      mm_lex.lex
L8374:
    xor       eax,	eax
    mov       [rbp + mm_parse.readprocdecl.paramlist],	rax
    xor       eax,	eax
    mov       [rbp + mm_parse.readprocdecl.retmodes],	rax
    xor       eax,	eax
    mov       [rbp + mm_parse.readprocdecl.nparams],	rax
    xor       rbx,	rbx
    xor       eax,	eax
    mov       rbx,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	9
    jnz       L8376
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	10
    jz        L8378
    mov       rcx,	[rbp + mm_parse.readprocdecl.procowner]
    mov       rdx,	[rbp + mm_parse.readprocdecl.stproc]
    lea       r8,	[rbp + mm_parse.readprocdecl.varparams]
    lea       r9,	[rbp + mm_parse.readprocdecl.nparams]
    call      mm_parse.readparams
    mov       [rbp + mm_parse.readprocdecl.paramlist],	rax
    mov       rcx,	10
    call      mm_parse.checksymbol
L8378:
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	5
    jz        L8381
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	7
    jnz       L8380
L8381:
    call      mm_lex.lex
    mov       rcx,	[rbp + mm_parse.readprocdecl.owner]
    lea       rdx,	[rbp + mm_parse.readprocdecl.retmodes]
    call      mm_parse.readreturntype
    mov       rbx,	rax
    jmp       L8379
L8380:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    lea       r10,	[mm_decls.typestarterset]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jnz       L8383
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	67
    jnz       L8382
L8383:
    mov       rcx,	[rbp + mm_parse.readprocdecl.owner]
    lea       rdx,	[rbp + mm_parse.readprocdecl.retmodes]
    call      mm_parse.readreturntype
    mov       rbx,	rax
L8382:
L8379:
    jmp       L8375
L8376:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	5
    jz        L8385
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	7
    jnz       L8384
L8385:
    call      mm_lex.lex
    mov       rcx,	[rbp + mm_parse.readprocdecl.owner]
    lea       rdx,	[rbp + mm_parse.readprocdecl.retmodes]
    call      mm_parse.readreturntype
    mov       rbx,	rax
L8384:
L8375:
    xor       eax,	eax
    mov       [mm_parse.dretvar],	rax
    cmp       rbx,	1
    jnz       L8387
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	67
    jnz       L8389
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       [mm_parse.dretvar],	rax
    call      mm_lex.lex
L8389:
L8387:
    test      rbx,	rbx
    jnz       L8391
    cmp       rdi,	109
    jnz       L8391
    lea       rcx,	[L13393]
    call      mm_support.serror
L8391:
    test      rbx,	rbx
    jz        L8393
    cmp       rdi,	109
    jz        L8393
    lea       rcx,	[L13394]
    call      mm_support.serror
L8393:
    mov       rax,	[rbp + mm_parse.readprocdecl.paramlist]
    mov       r10,	[rbp + mm_parse.readprocdecl.stproc]
    mov       [r10+112],	rax
    mov       al,	bl
    mov       r10,	[rbp + mm_parse.readprocdecl.stproc]
    mov       [r10+122],	al
    mov       rax,	rbx
    test      rax,	rax
    jz        L8395
    cmp       rax,	1
    jz        L8396
    jmp       L8397
L8395:
    xor       eax,	eax
    mov       r10,	[rbp + mm_parse.readprocdecl.stproc]
    mov       [r10+72],	eax
    jmp       L8394
L8396:
    mov       rax,	[rbp + mm_parse.readprocdecl.stproc]
    lea       rax,	[rax+72]
    mov       r10,	[rbp + mm_parse.readprocdecl.retmodes]
    mov       rcx,	[rbp + mm_parse.readprocdecl.procowner]
    mov       rdx,	r10
    mov       r8,	rax
    call      mm_lib.storemode
    jmp       L8394
L8397:
    mov       rcx,	[rbp + mm_parse.readprocdecl.procowner]
    lea       rdx,	[rbp + mm_parse.readprocdecl.retmodes]
    mov       r8,	rbx
    xor       r9d,	r9d
    call      mm_lib.createtuplemode
    mov       r10,	[rbp + mm_parse.readprocdecl.stproc]
    mov       [r10+72],	eax
L8394:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	17
    jnz       L8399
    lea       rcx,	[L13395]
    call      mm_support.serror
    mov       rcx,	67
    call      mm_parse.lexchecksymbol
    call      mm_lex.lex
    mov       rax,	[rbp + mm_parse.readprocdecl.stproc]
    lea       rax,	[rax+92]
    or        byte [rax+1],	1
L8399:
    xor       eax,	eax
    mov       r10,	[rbp + mm_parse.readprocdecl.stproc]
    mov       [r10+64],	rax
    mov       al,	[rbp + mm_parse.readprocdecl.scope]
    mov       r10,	[rbp + mm_parse.readprocdecl.stproc]
    mov       [r10+170],	al
    mov       al,	[rbp + mm_parse.readprocdecl.varparams]
    mov       r10,	[rbp + mm_parse.readprocdecl.stproc]
    mov       [r10+123],	al
    mov       rax,	[rbp + mm_parse.readprocdecl.procowner]
    cmp       rax,	[mm_decls.stmodule]
    jnz       L8401
    mov       rax,	[rbp + mm_parse.readprocdecl.stproc]
    movzx     rax,	byte [rax+76]
    cmp       rax,	5
    jnz       L8403
    mov       rax,	[rbp + mm_parse.readprocdecl.stproc]
    mov       rax,	[rax]
    mov       rcx,	rax
    lea       rdx,	[L13396]
    call      mlib.eqstring
    test      rax,	rax
    jz        L8403
    mov       rax,	[mm_decls.stmodule]
    movzx     rax,	byte [rax+94]
    lea       r10,	[mm_decls.modules]
    mov       r10,	[r10 + rax*8]
    mov       rax,	[rbp + mm_parse.readprocdecl.stproc]
    mov       [r10+48],	rax
    mov       al,	1
    mov       r10,	[rbp + mm_parse.readprocdecl.stproc]
    mov       [r10+170],	al
    jmp       L8404
L8403:
    mov       rax,	[rbp + mm_parse.readprocdecl.stproc]
    movzx     rax,	byte [rax+76]
    cmp       rax,	4
    jnz       L8405
    mov       rax,	[rbp + mm_parse.readprocdecl.stproc]
    mov       rax,	[rax]
    mov       rcx,	rax
    lea       rdx,	[L13397]
    call      mlib.eqstring
    test      rax,	rax
    jz        L8405
    mov       rax,	[mm_decls.stmodule]
    movzx     rax,	byte [rax+94]
    lea       r10,	[mm_decls.modules]
    mov       r10,	[r10 + rax*8]
    mov       r12,	r10
    mov       rax,	[mm_decls.stmodule]
    movzx     rax,	byte [rax+95]
    lea       r10,	[mm_decls.subprogs]
    mov       r10,	[r10 + rax*8]
    mov       r13,	r10
    mov       ax,	[r13+10]
    test      ax,	ax
    jz        L8407
    lea       rcx,	[L13398]
    call      mm_support.serror
L8407:
    mov       rax,	[mm_decls.stmodule]
    movzx     rax,	byte [rax+94]
    mov       [r13+10],	ax
    mov       rax,	[rbp + mm_parse.readprocdecl.stproc]
    mov       [r12+56],	rax
    movzx     rax,	byte [r13+15]
    cmp       rax,	[mm_decls.mainsubprogno]
    jnz       L8409
    mov       al,	3
    mov       r10,	[rbp + mm_parse.readprocdecl.stproc]
    mov       [r10+170],	al
;mm_parse.readprocdecl.dosigcheck:
L8404:
    mov       rax,	[rbp + mm_parse.readprocdecl.stproc]
    mov       rax,	[rax+112]
    test      rax,	rax
    jnz       L8412
    mov       rax,	[rbp + mm_parse.readprocdecl.stproc]
    movsxd    rax,	dword [rax+72]
    test      rax,	rax
    jz        L8411
L8412:
    lea       rcx,	[L13399]
    call      mm_support.serror
L8411:
L8409:
L8405:
L8402:
L8401:
    call      mm_parse.popproc
    mov       rax,	[rbp + mm_parse.readprocdecl.stproc]
L8362:
;---------------
    add       rsp,	128
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readparams
mm_parse.readparams:
;?>>
   %define R.procowner r13
   %define R.owner r14
    %define mm_parse.readparams.varparams 80
    %define mm_parse.readparams.nparams 88
    %define mm_parse.readparams.stlist -8
    %define mm_parse.readparams.stlistx -16
   %define R.stname rdi
   %define R.parammode rbx
   %define R.pmode rsi
   %define R.m r12
    %define mm_parse.readparams.isoptional -24
    %define mm_parse.readparams.types -32
    %define mm_parse.readparams.str -64
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	96
    mov       r13,	rcx
    mov       r14,	rdx
    mov       [rbp+80],	r8
    mov       [rbp+88],	r9
;---------------
    xor       eax,	eax
    mov       [rbp + mm_parse.readparams.stlistx],	rax
    mov       [rbp + mm_parse.readparams.stlist],	rax
    xor       rsi,	rsi
    xor       eax,	eax
    mov       r10,	[rbp + mm_parse.readparams.nparams]
    mov       [r10],	rax
    xor       rbx,	rbx
    xor       eax,	eax
    mov       [rbp + mm_parse.readparams.types],	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	67
    jnz       L8415
    lea       rax,	[mm_decls.nextlx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jz        L8416
    cmp       rax,	10
    jnz       L8415
L8416:
    mov       rax,	1
    mov       [rbp + mm_parse.readparams.types],	rax
L8415:
L8417:
    xor       rbx,	rbx
    xor       eax,	eax
    mov       [rbp + mm_parse.readparams.isoptional],	rax
    mov       rax,	[rbp + mm_parse.readparams.types]
    test      rax,	rax
    jnz       L8421
    call      mm_parse.istypestarter
    test      rax,	rax
    jz        L8420
L8421:
    mov       rcx,	r13
    xor       edx,	edx
    call      mm_parse.readtypespec
    mov       rsi,	rax
;mm_parse.readparams.gotmode:
    mov       rax,	[rbp + mm_parse.readparams.nparams]
    mov       rax,	[rax]
    test      rax,	rax
    jnz       L8424
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jz        L8425
    cmp       rax,	10
    jnz       L8424
L8425:
L8426:
    mov       rax,	[rbp + mm_parse.readparams.nparams]
    inc       qword [rax]
    mov       al,	36
    mov       [rbp + mm_parse.readparams.str],	al
    xor       eax,	eax
    mov       [rbp + mm_parse.readparams.str+1],	al
    mov       rax,	[rbp + mm_parse.readparams.nparams]
    mov       rax,	[rax]
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.strint
    lea       rcx,	[rbp + mm_parse.readparams.str]
    mov       rdx,	rax
    call      strcat
    lea       rcx,	[rbp + mm_parse.readparams.str]
    call      mm_lex.addnamestr
    mov       rcx,	r14
    mov       rdx,	rax
    mov       r8,	12
    call      mm_lib.getduplnameptr
    mov       rdi,	rax
    mov       rcx,	r14
    mov       rdx,	rdi
    call      mm_lib.adddef
    lea       rax,	[rdi+72]
    mov       rcx,	r14
    mov       rdx,	rsi
    mov       r8,	rax
    call      mm_lib.storemode
    mov       [rdi+160],	bl
    lea       rcx,	[rbp + mm_parse.readparams.stlist]
    lea       rdx,	[rbp + mm_parse.readparams.stlistx]
    mov       r8,	rdi
    call      mm_parse.addlistparam
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	10
    jnz       L8430
L8429:
    jmp       L8427
L8430:
L8428:
    mov       rcx,	3
    call      mm_parse.checksymbollex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	22
    jnz       L8432
    mov       rax,	[rbp + mm_parse.readparams.nparams]
    mov       rax,	[rax]
    mov       r10,	[rbp + mm_parse.readparams.varparams]
    mov       [r10],	rax
    call      mm_lex.lex
    jmp       L8427
L8432:
    mov       rcx,	r13
    xor       edx,	edx
    call      mm_parse.readtypespec
    mov       rsi,	rax
    jmp       L8426
L8427:
    mov       rax,	[rbp + mm_parse.readparams.stlist]
    jmp       L8413
L8424:
    jmp       L8419
L8420:
    test      rsi,	rsi
    jnz       L8433
    lea       rcx,	[L13400]
    call      mm_support.serror
L8433:
L8419:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	19
    jz        L8435
    cmp       rax,	22
    jz        L8436
    jmp       L8437
L8435:
    mov       rbx,	1
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	5
    jnz       L8439
    call      mm_lex.lex
L8439:
    jmp       L8434
L8436:
    mov       rax,	[rbp + mm_parse.readparams.nparams]
    mov       rax,	[rax]
    mov       r10,	[rbp + mm_parse.readparams.varparams]
    mov       [r10],	rax
    call      mm_lex.lex
    mov       rax,	[rbp + mm_parse.readparams.stlist]
    jmp       L8413
L8437:
L8434:
    mov       rcx,	67
    call      mm_parse.checksymbol
    mov       rax,	[rbp + mm_parse.readparams.nparams]
    inc       qword [rax]
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       rcx,	r14
    mov       rdx,	rax
    mov       r8,	12
    call      mm_lib.getduplnameptr
    mov       rdi,	rax
    mov       rcx,	r14
    mov       rdx,	rdi
    call      mm_lib.adddef
    call      mm_lex.lex
    cmp       rbx,	1
    jnz       L8441
    mov       rcx,	r13
    mov       rdx,	rsi
    xor       r8d,	r8d
    call      mm_lib.createrefmode
    mov       r12,	rax
    jmp       L8440
L8441:
    mov       r12,	rsi
L8440:
    lea       rax,	[rdi+72]
    mov       rcx,	r14
    mov       rdx,	r12
    mov       r8,	rax
    call      mm_lib.storemode
    mov       [rdi+160],	bl
    mov       al,	[rbp + mm_parse.readparams.isoptional]
    mov       [rdi+161],	al
    lea       rcx,	[rbp + mm_parse.readparams.stlist]
    lea       rdx,	[rbp + mm_parse.readparams.stlistx]
    mov       r8,	rdi
    call      mm_parse.addlistparam
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	6
    jz        L8443
    cmp       rax,	41
    jnz       L8444
L8443:
    call      mm_lex.lex
    call      mm_parse.readunit
    mov       [rdi+64],	rax
    mov       al,	1
    mov       [rdi+171],	al
    mov       al,	1
    mov       [rdi+161],	al
L8444:
L8442:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jz        L8446
    cmp       rax,	10
    jz        L8447
    jmp       L8448
L8446:
    call      mm_lex.lex
    jmp       L8445
L8447:
    jmp       L8418
L8448:
    lea       rcx,	[L13401]
    call      mm_support.serror
L8445:
    jmp       L8417
L8418:
    mov       rax,	[rbp + mm_parse.readparams.stlist]
L8413:
;---------------
    add       rsp,	96
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readcondsuffix
mm_parse.readcondsuffix:
;?>>
   %define R.p rbx
   %define R.q rdi
    %define mm_parse.readcondsuffix.$T1 -8
    push      rdi
    push      rbx
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       rbx,	rcx
;---------------
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	92
    jz        L8451
    cmp       rax,	88
    jz        L8452
    jmp       L8453
L8451:
    call      mm_lex.lex
    mov       rcx,	6
    mov       rdx,	rbx
    call      mm_lib.createunit1
    mov       [rbp + mm_parse.readcondsuffix.$T1],	rax
    call      mm_parse.readunit
    mov       rcx,	rax
    call      mm_parse.fixcond
    mov       rcx,	92
    mov       rdx,	rax
    mov       r8,	[rbp + mm_parse.readcondsuffix.$T1]
    call      mm_lib.createunit2
    jmp       L8450
L8452:
    call      mm_lex.lex
    call      mm_parse.readunit
    mov       rcx,	rax
    call      mm_parse.fixcond
    mov       rcx,	17
    mov       rdx,	rax
    call      mm_lib.createunit1
    mov       rdi,	rax
    mov       al,	63
    mov       [rdi+62],	al
    mov       rcx,	6
    mov       rdx,	rbx
    call      mm_lib.createunit1
    mov       rcx,	92
    mov       rdx,	rdi
    mov       r8,	rax
    call      mm_lib.createunit2
    jmp       L8450
L8453:
    mov       rax,	rbx
L8450:
L8449:
;---------------
    add       rsp,	48
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readif
mm_parse.readif:
;?>>
   %define R.pos1 rdi
   %define R.kwd rbx
    %define mm_parse.readif.clist -8
    %define mm_parse.readif.clistx -16
    %define mm_parse.readif.plist -24
    %define mm_parse.readif.plistx -32
   %define R.pelse rsi
   %define R.p r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
;---------------
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       rdi,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    mov       rbx,	rax
    call      mm_lex.lex
    call      mm_parse.skipsemi
    xor       eax,	eax
    mov       rsi,	rax
    mov       [rbp + mm_parse.readif.plistx],	rax
    mov       [rbp + mm_parse.readif.plist],	rax
    mov       [rbp + mm_parse.readif.clistx],	rax
    mov       [rbp + mm_parse.readif.clist],	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	83
    jnz       L8456
    call      mm_lex.lex
L8456:
    jmp       L8457
L8458:
    call      mm_lex.lex
;mm_parse.readif.nextif:
L8457:
    xor       ecx,	ecx
    call      mm_parse.readsunit
    mov       rcx,	rax
    call      mm_parse.fixcond
    lea       rcx,	[rbp + mm_parse.readif.clist]
    lea       rdx,	[rbp + mm_parse.readif.clistx]
    mov       r8,	rax
    call      mm_lib.addlistunit
    call      mm_parse.skipsemi
    mov       rcx,	82
    call      mm_parse.checksymbollex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	5
    jnz       L8462
    mov       rax,	[rbp + mm_parse.readif.clist]
    cmp       rax,	[rbp + mm_parse.readif.clistx]
    jnz       L8464
    cmp       rbx,	81
    jnz       L8464
    call      mm_lex.lex
    call      mm_parse.readunit
    mov       rcx,	92
    mov       rdx,	[rbp + mm_parse.readif.clist]
    mov       r8,	rax
    xor       r9d,	r9d
    call      mm_lib.createunit3
    mov       r12,	rax
    mov       [r12+4],	edi
    mov       rax,	r12
    jmp       L8454
L8464:
    lea       rcx,	[L13402]
    call      mm_support.serror
L8463:
L8462:
    xor       ecx,	ecx
    call      mm_parse.readsunit
    lea       rcx,	[rbp + mm_parse.readif.plist]
    lea       rdx,	[rbp + mm_parse.readif.plistx]
    mov       r8,	rax
    call      mm_lib.addlistunit
    call      mm_parse.skipsemi
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	83
    jz        L8458
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	84
    jz        L8466
    cmp       rax,	85
    jz        L8467
    cmp       rax,	86
    jz        L8467
    jmp       L8468
L8466:
    call      mm_lex.lex
    xor       ecx,	ecx
    call      mm_parse.readsunit
    mov       rsi,	rax
    mov       rcx,	87
    mov       rdx,	rbx
    xor       r8d,	r8d
    xor       r9d,	r9d
    call      mm_parse.checkend
    jmp       L8465
L8467:
    mov       al,	bl
    lea       r10,	[mm_decls.lx]
    mov       [r10],	al
    call      mm_parse.readswitchcase
    mov       rcx,	rax
    call      mm_parse.makeblock
    mov       rsi,	rax
    jmp       L8465
L8468:
    mov       rcx,	87
    mov       rdx,	rbx
    xor       r8d,	r8d
    xor       r9d,	r9d
    call      mm_parse.checkend
L8465:
    mov       rcx,	92
    mov       rdx,	[rbp + mm_parse.readif.clist]
    mov       r8,	[rbp + mm_parse.readif.plist]
    mov       r9,	rsi
    call      mm_lib.createunit3
    mov       r12,	rax
    mov       [r12+4],	edi
    mov       rax,	r12
L8454:
;---------------
    add       rsp,	64
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readgoto
mm_parse.readgoto:
;?>>
   %define R.gototag rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    call      mm_lex.lex
    call      mm_parse.readunit
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mm_lib.createunit1
    mov       rcx,	rax
    call      mm_parse.readcondsuffix
L8469:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_parse.readunless
mm_parse.readunless:
;?>>
   %define R.pos rdi
   %define R.pcond rbx
   %define R.pthen rsi
   %define R.pelse r12
   %define R.p r13
   %define R.q r14
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
;---------------
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       rdi,	rax
    call      mm_lex.lex
    xor       ecx,	ecx
    call      mm_parse.readsunit
    mov       rcx,	rax
    call      mm_parse.fixcond
    mov       rbx,	rax
    mov       rcx,	82
    call      mm_parse.checksymbollex
    xor       ecx,	ecx
    call      mm_parse.readsunit
    mov       rsi,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	84
    jnz       L8472
    call      mm_lex.lex
    xor       ecx,	ecx
    call      mm_parse.readsunit
    mov       r12,	rax
    jmp       L8471
L8472:
    xor       r12,	r12
L8471:
    mov       rcx,	87
    mov       rdx,	88
    xor       r8d,	r8d
    xor       r9d,	r9d
    call      mm_parse.checkend
    mov       rcx,	17
    mov       rdx,	rbx
    call      mm_lib.createunit1
    mov       r10,	rax
    mov       r14,	r10
    mov       rcx,	92
    mov       rdx,	rax
    mov       r8,	rsi
    mov       r9,	r12
    call      mm_lib.createunit3
    mov       r13,	rax
    mov       al,	63
    mov       [r14+62],	al
    mov       [r13+4],	edi
    mov       rax,	r13
L8470:
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readswitchcase
mm_parse.readswitchcase:
;?>>
   %define R.pos1 rdi
   %define R.kwd rbx
   %define R.opc rsi
   %define R.pos2 r12
   %define R.rangeused r13
   %define R.nwhen r14
    %define mm_parse.readswitchcase.pexpr -8
    %define mm_parse.readswitchcase.pwhenlist -16
    %define mm_parse.readswitchcase.pwhenlistx -24
    %define mm_parse.readswitchcase.pwhen -32
    %define mm_parse.readswitchcase.pwhenx -40
    %define mm_parse.readswitchcase.pelse -48
    %define mm_parse.readswitchcase.p -56
    %define mm_parse.readswitchcase.pthen -64
    %define mm_parse.readswitchcase.pwhenthen -72
    %define mm_parse.readswitchcase.pjump -80
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	112
;---------------
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       rdi,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    mov       rbx,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    mov       rsi,	rax
    xor       eax,	eax
    mov       [rbp + mm_parse.readswitchcase.pjump],	rax
    call      mm_lex.lex
    call      mm_parse.skipsemi
    cmp       rsi,	110
    jnz       L8475
    mov       rcx,	9
    call      mm_parse.checksymbollex
    call      mm_parse.readunit
    mov       [rbp + mm_parse.readswitchcase.pjump],	rax
    mov       rcx,	10
    call      mm_parse.checksymbollex
    mov       rax,	[mm_decls.currproc]
    lea       rax,	[rax+92]
    or        byte [rax],	2
L8475:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	92
    jnz       L8477
    cmp       rbx,	104
    jnz       L8479
    lea       rcx,	[L13403]
    call      mm_support.serror
L8479:
    xor       eax,	eax
    mov       [rbp + mm_parse.readswitchcase.pexpr],	rax
    jmp       L8476
L8477:
    xor       ecx,	ecx
    call      mm_parse.readsunit
    mov       [rbp + mm_parse.readswitchcase.pexpr],	rax
    mov       rax,	[rbp + mm_parse.readswitchcase.pjump]
    mov       r10,	[rbp + mm_parse.readswitchcase.pexpr]
    mov       [r10+8],	rax
L8476:
    xor       eax,	eax
    mov       [rbp + mm_parse.readswitchcase.pwhenlistx],	rax
    mov       [rbp + mm_parse.readswitchcase.pwhenlist],	rax
    xor       r13,	r13
    xor       eax,	eax
    mov       r14,	rax
    call      mm_parse.skipsemi
    jmp       L8481
L8480:
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       r12,	rax
    call      mm_lex.lex
    xor       eax,	eax
    mov       [rbp + mm_parse.readswitchcase.pwhenx],	rax
    mov       [rbp + mm_parse.readswitchcase.pwhen],	rax
L8483:
    call      mm_parse.readunit
    mov       [rbp + mm_parse.readswitchcase.p],	rax
    inc       r14
    mov       eax,	r12d
    mov       r10,	[rbp + mm_parse.readswitchcase.p]
    mov       [r10+4],	eax
    mov       rax,	[rbp + mm_parse.readswitchcase.p]
    movzx     rax,	byte [rax]
    cmp       rax,	21
    jnz       L8486
    mov       r13,	1
L8486:
    lea       rcx,	[rbp + mm_parse.readswitchcase.pwhen]
    lea       rdx,	[rbp + mm_parse.readswitchcase.pwhenx]
    mov       r8,	[rbp + mm_parse.readswitchcase.p]
    call      mm_lib.addlistunit
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jnz       L8484
L8488:
    call      mm_lex.lex
    jmp       L8483
L8484:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	7
    jz        L8490
    mov       rcx,	82
    call      mm_parse.checksymbol
L8490:
    call      mm_lex.lex
    xor       ecx,	ecx
    call      mm_parse.readsunit
    mov       [rbp + mm_parse.readswitchcase.pthen],	rax
    mov       rcx,	85
    mov       rdx,	[rbp + mm_parse.readswitchcase.pwhen]
    mov       r8,	[rbp + mm_parse.readswitchcase.pthen]
    call      mm_lib.createunit2
    mov       [rbp + mm_parse.readswitchcase.pwhenthen],	rax
    mov       eax,	r12d
    mov       r10,	[rbp + mm_parse.readswitchcase.pwhenthen]
    mov       [r10+4],	eax
    lea       rcx,	[rbp + mm_parse.readswitchcase.pwhenlist]
    lea       rdx,	[rbp + mm_parse.readswitchcase.pwhenlistx]
    mov       r8,	[rbp + mm_parse.readswitchcase.pwhenthen]
    call      mm_lib.addlistunit
L8481:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	92
    jz        L8480
    cmp       rsi,	107
    jnz       L8492
    test      r13,	r13
    jnz       L8492
    cmp       r14,	8
    jg        L8494
    mov       rsi,	105
L8494:
L8492:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	84
    jz        L8496
    cmp       rax,	83
    jz        L8497
    cmp       rax,	85
    jz        L8498
    cmp       rax,	86
    jz        L8498
    jmp       L8499
L8496:
    call      mm_lex.lex
    xor       ecx,	ecx
    call      mm_parse.readsunit
    mov       [rbp + mm_parse.readswitchcase.pelse],	rax
    mov       rcx,	87
    mov       rdx,	rbx
    xor       r8d,	r8d
    xor       r9d,	r9d
    call      mm_parse.checkend
    jmp       L8495
L8497:
    mov       al,	bl
    lea       r10,	[mm_decls.lx]
    mov       [r10],	al
    call      mm_parse.readif
    mov       rcx,	rax
    call      mm_parse.makeblock
    mov       [rbp + mm_parse.readswitchcase.pelse],	rax
    jmp       L8495
L8498:
    mov       al,	bl
    lea       r10,	[mm_decls.lx]
    mov       [r10],	al
    call      mm_parse.readswitchcase
    mov       rcx,	rax
    call      mm_parse.makeblock
    mov       [rbp + mm_parse.readswitchcase.pelse],	rax
    jmp       L8495
L8499:
    xor       eax,	eax
    mov       [rbp + mm_parse.readswitchcase.pelse],	rax
    mov       rcx,	87
    mov       rdx,	rbx
    xor       r8d,	r8d
    xor       r9d,	r9d
    call      mm_parse.checkend
L8495:
    mov       rcx,	rsi
    mov       rdx,	[rbp + mm_parse.readswitchcase.pexpr]
    mov       r8,	[rbp + mm_parse.readswitchcase.pwhenlist]
    mov       r9,	[rbp + mm_parse.readswitchcase.pelse]
    call      mm_lib.createunit3
    mov       [rbp + mm_parse.readswitchcase.p],	rax
    mov       eax,	edi
    mov       r10,	[rbp + mm_parse.readswitchcase.p]
    mov       [r10+4],	eax
    mov       rax,	[rbp + mm_parse.readswitchcase.p]
L8473:
;---------------
    add       rsp,	112
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readstop
mm_parse.readstop:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
;---------------
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    lea       r10,	[mm_tables.exprstarter]
    mov       r10b,	[r10 + rax-1]
    test      r10b,	r10b
    jz        L8502
    call      mm_parse.readunit
    mov       rcx,	120
    mov       rdx,	rax
    call      mm_lib.createunit1
    mov       rdi,	rax
    jmp       L8501
L8502:
    mov       rcx,	120
    call      mm_lib.createunit0
    mov       rdi,	rax
L8501:
    mov       rcx,	rdi
    call      mm_parse.readcondsuffix
L8500:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_parse.readreturn
mm_parse.readreturn:
;?>>
   %define R.p rdi
   %define R.q rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
;---------------
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    lea       r10,	[mm_tables.exprstarter]
    mov       r10b,	[r10 + rax-1]
    test      r10b,	r10b
    jz        L8505
    call      mm_parse.readunit
    mov       rbx,	rax
    mov       rcx,	89
    mov       rdx,	rbx
    call      mm_lib.createunit1
    mov       rdi,	rax
    mov       eax,	1
    mov       [rdi+40],	eax
    jmp       L8504
L8505:
    mov       rcx,	89
    call      mm_lib.createunit0
    mov       rdi,	rax
    xor       eax,	eax
    mov       [rdi+40],	eax
L8504:
    mov       rcx,	rdi
    call      mm_parse.readcondsuffix
L8503:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readdo
mm_parse.readdo:
;?>>
   %define R.p rdi
   %define R.pos rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
;---------------
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       rbx,	rax
    call      mm_lex.lex
    xor       ecx,	ecx
    call      mm_parse.readsunit
    mov       rdi,	rax
    mov       rcx,	87
    mov       rdx,	96
    xor       r8d,	r8d
    xor       r9d,	r9d
    call      mm_parse.checkend
    mov       rcx,	104
    mov       rdx,	rdi
    call      mm_lib.createunit1
    mov       rdi,	rax
    mov       [rdi+4],	ebx
    mov       rax,	rdi
L8506:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readto
mm_parse.readto:
;?>>
   %define R.pos rdi
   %define R.id rbx
   %define R.p rsi
   %define R.pcount r12
   %define R.pbody r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
;---------------
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       rdi,	rax
    call      mm_lex.lex
    call      mm_parse.readunit
    mov       r12,	rax
    mov       rcx,	96
    call      mm_parse.checksymbollex
    xor       ecx,	ecx
    call      mm_parse.readsunit
    mov       r13,	rax
    mov       rcx,	87
    mov       rdx,	94
    mov       r8,	96
    xor       r9d,	r9d
    call      mm_parse.checkend
    mov       rbx,	11
    mov       rax,	[mm_decls.currproc]
    movzx     rax,	byte [rax+78]
    cmp       rax,	6
    jz        L8509
    mov       rbx,	10
L8509:
    mov       rcx,	[mm_decls.currproc]
    mov       rdx,	rbx
    call      mm_lib.getavname
    mov       rcx,	rax
    call      mm_lib.createname
    mov       rcx,	91
    mov       rdx,	r12
    mov       r8,	r13
    mov       r9,	rax
    call      mm_lib.createunit3
    mov       rsi,	rax
    mov       [rsi+4],	edi
    mov       rax,	rsi
L8507:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readwhile
mm_parse.readwhile:
;?>>
   %define R.pos rdi
   %define R.pcond rbx
   %define R.pbody rsi
   %define R.pincr r12
   %define R.p r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
;---------------
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       rdi,	rax
    call      mm_lex.lex
    mov       rcx,	1
    call      mm_parse.readsunit
    mov       rcx,	rax
    call      mm_parse.fixcond
    mov       rbx,	rax
    xor       r12,	r12
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jnz       L8512
    call      mm_lex.lex
    mov       rcx,	1
    call      mm_parse.readsunit
    mov       r12,	rax
L8512:
    mov       rcx,	96
    call      mm_parse.checksymbollex
    xor       ecx,	ecx
    call      mm_parse.readsunit
    mov       rsi,	rax
    mov       rcx,	87
    mov       rdx,	97
    mov       r8,	96
    xor       r9d,	r9d
    call      mm_parse.checkend
    mov       rcx,	97
    mov       rdx,	rbx
    mov       r8,	rsi
    mov       r9,	r12
    call      mm_lib.createunit3
    mov       r13,	rax
    mov       [r13+4],	edi
    mov       rax,	r13
L8510:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readrepeat
mm_parse.readrepeat:
;?>>
   %define R.pos rdi
   %define R.pbody rbx
   %define R.pcond rsi
   %define R.p r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
;---------------
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       rdi,	rax
    call      mm_lex.lex
    xor       ecx,	ecx
    call      mm_parse.readsunit
    mov       rbx,	rax
    mov       rcx,	99
    call      mm_parse.checksymbollex
    call      mm_parse.readunit
    mov       rcx,	rax
    call      mm_parse.fixcond
    mov       rsi,	rax
    mov       rcx,	98
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mm_lib.createunit2
    mov       r12,	rax
    mov       [r12+4],	edi
    mov       rax,	r12
L8513:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readloopcontrol
mm_parse.readloopcontrol:
;?>>
   %define R.opc rdi
   %define R.p rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
;---------------
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    mov       rdi,	rax
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	67
    jnz       L8516
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       rax,	[rax]
    mov       rcx,	rax
    lea       rdx,	[L13404]
    call      mlib.eqstring
    test      rax,	rax
    jz        L8516
    call      mm_lex.lex
    xor       ecx,	ecx
    mov       rdx,	3
    call      mm_lib.createconstunit
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mm_lib.createunit1
    mov       rbx,	rax
    jmp       L8515
L8516:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    lea       r10,	[mm_tables.exprstarter]
    mov       r10b,	[r10 + rax-1]
    test      r10b,	r10b
    jz        L8517
    mov       rcx,	1
    call      mm_parse.readconstexpr
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mm_lib.createunit1
    mov       rbx,	rax
    jmp       L8515
L8517:
    mov       rcx,	1
    mov       rdx,	3
    call      mm_lib.createconstunit
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mm_lib.createunit1
    mov       rbx,	rax
L8515:
    mov       rcx,	rbx
    call      mm_parse.readcondsuffix
L8514:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readprint
mm_parse.readprint:
;?>>
   %define R.oldinreadprint rdi
   %define R.opc rbx
   %define R.isfprint rsi
   %define R.fshowname r12
   %define R.pformat r13
   %define R.pdev r14
    %define mm_parse.readprint.printlist -8
    %define mm_parse.readprint.printlistx -16
    %define mm_parse.readprint.p -24
    %define mm_parse.readprint.q -32
    %define mm_parse.readprint.expr -40
    %define mm_parse.readprint.s -48
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	80
;---------------
    mov       rdi,	[mm_parse.inreadprint]
    mov       rax,	1
    mov       [mm_parse.inreadprint],	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    mov       rbx,	rax
    mov       rax,	rbx
    cmp       rax,	116
    jz        L8520
    cmp       rax,	117
    jnz       L8521
L8520:
    mov       rsi,	1
    jmp       L8519
L8521:
    xor       rsi,	rsi
L8519:
    call      mm_lex.lex
    xor       eax,	eax
    mov       [rbp + mm_parse.readprint.printlistx],	rax
    mov       [rbp + mm_parse.readprint.printlist],	rax
    xor       eax,	eax
    mov       r14,	rax
    mov       r13,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	17
    jnz       L8523
    call      mm_lex.lex
    call      mm_parse.readunit
    mov       r14,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jnz       L8525
    call      mm_lex.lex
    jmp       L8524
L8525:
    jmp       L8526
L8524:
L8523:
    test      rsi,	rsi
    jz        L8528
    call      mm_parse.readunit
    mov       r13,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jnz       L8530
    call      mm_lex.lex
    jmp       L8529
L8530:
    jmp       L8526
L8529:
L8528:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    lea       r10,	[mm_tables.exprstarter]
    mov       r10b,	[r10 + rax-1]
    test      r10b,	r10b
    jnz       L8532
    jmp       L8526
L8532:
L8533:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jz        L8536
    cmp       rax,	130
    jz        L8537
    jmp       L8538
L8536:
    mov       rcx,	87
    call      mm_lib.createunit0
    lea       rcx,	[rbp + mm_parse.readprint.printlist]
    lea       rdx,	[rbp + mm_parse.readprint.printlistx]
    mov       r8,	rax
    call      mm_lib.addlistunit
    jmp       L8535
L8537:
    mov       rcx,	88
    call      mm_lib.createunit0
    lea       rcx,	[rbp + mm_parse.readprint.printlist]
    lea       rdx,	[rbp + mm_parse.readprint.printlistx]
    mov       r8,	rax
    call      mm_lib.addlistunit
    call      mm_lex.lex
    jmp       L8535
L8538:
    xor       r12,	r12
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	41
    jnz       L8540
    mov       r12,	1
    call      mm_lex.lex
L8540:
    call      mm_parse.readunit
    mov       [rbp + mm_parse.readprint.p],	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	5
    jnz       L8542
    call      mm_lex.lex
    call      mm_parse.readunit
    mov       rcx,	86
    mov       rdx,	[rbp + mm_parse.readprint.p]
    mov       r8,	rax
    call      mm_lib.createunit2
    mov       [rbp + mm_parse.readprint.p],	rax
L8542:
    test      r12,	r12
    jz        L8544
    mov       rcx,	[rbp + mm_parse.readprint.p]
    call      mm_lib.strexpr
    mov       [rbp + mm_parse.readprint.expr],	rax
    mov       rcx,	[rbp + mm_parse.readprint.expr]
    lea       rdx,	[L13405]
    mov       r8,	-1
    call      mlib.strbuffer_add
    mov       rax,	[rbp + mm_parse.readprint.expr]
    mov       rax,	[rax]
    mov       [rbp + mm_parse.readprint.s],	rax
    mov       rax,	[rbp + mm_parse.readprint.expr]
    movsxd    rax,	dword [rax+8]
    mov       r10,	[rbp + mm_parse.readprint.expr]
    mov       r10,	[r10]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mlib.iconvucn
    mov       rax,	[rbp + mm_parse.readprint.expr]
    movsxd    rax,	dword [rax+8]
    mov       rcx,	[rbp + mm_parse.readprint.s]
    mov       rdx,	rax
    call      mm_lib.createstringconstunit
    mov       r10,	rax
    mov       [rbp + mm_parse.readprint.q],	r10
    lea       rcx,	[rbp + mm_parse.readprint.printlist]
    lea       rdx,	[rbp + mm_parse.readprint.printlistx]
    mov       r8,	rax
    call      mm_lib.addlistunit
L8544:
    lea       rcx,	[rbp + mm_parse.readprint.printlist]
    lea       rdx,	[rbp + mm_parse.readprint.printlistx]
    mov       r8,	[rbp + mm_parse.readprint.p]
    call      mm_lib.addlistunit
L8535:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jnz       L8534
L8546:
    call      mm_lex.lex
    jmp       L8533
L8534:
;mm_parse.readprint.finish:
L8526:
    mov       [mm_parse.inreadprint],	rdi
    cmp       rbx,	114
    jnz       L8548
    mov       rax,	[rbp + mm_parse.readprint.printlist]
    test      rax,	rax
    jnz       L8548
    lea       rcx,	[L13406]
    call      mm_support.serror
L8548:
    cmp       rbx,	116
    jnz       L8550
    mov       rax,	[rbp + mm_parse.readprint.printlist]
    test      rax,	rax
    jnz       L8550
    test      r13,	r13
    jnz       L8550
    lea       rcx,	[L13406]
    call      mm_support.serror
L8550:
    test      rsi,	rsi
    jz        L8552
    test      r13,	r13
    jnz       L8554
    lea       rcx,	[L13407]
    call      mm_support.serror
L8554:
    mov       rcx,	rbx
    mov       rdx,	r14
    mov       r8,	r13
    mov       r9,	[rbp + mm_parse.readprint.printlist]
    call      mm_lib.createunit3
    jmp       L8551
L8552:
    mov       rcx,	rbx
    mov       rdx,	r14
    mov       r8,	[rbp + mm_parse.readprint.printlist]
    call      mm_lib.createunit2
L8551:
L8518:
;---------------
    add       rsp,	80
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readread
mm_parse.readread:
;?>>
   %define R.oldinreadprint rdi
   %define R.opc rbx
   %define R.pformat rsi
   %define R.pdev r12
    %define mm_parse.readread.readlist -8
    %define mm_parse.readread.readlistx -16
   %define R.p r13
   %define R.pread r14
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    mov       rdi,	[mm_parse.inreadprint]
    mov       rax,	1
    mov       [mm_parse.inreadprint],	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    mov       rbx,	rax
    call      mm_lex.lex
    xor       eax,	eax
    mov       [rbp + mm_parse.readread.readlistx],	rax
    mov       [rbp + mm_parse.readread.readlist],	rax
    xor       eax,	eax
    mov       r12,	rax
    mov       rsi,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	17
    jnz       L8557
    cmp       rbx,	118
    jnz       L8559
    lea       rcx,	[L13408]
    call      mm_support.serror
L8559:
    call      mm_lex.lex
    call      mm_parse.readunit
    mov       r12,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jnz       L8561
    call      mm_lex.lex
L8561:
L8557:
    cmp       rbx,	119
    jnz       L8563
    mov       rcx,	119
    mov       rdx,	r12
    call      mm_lib.createunit1
    lea       rcx,	[rbp + mm_parse.readread.readlist]
    lea       rdx,	[rbp + mm_parse.readread.readlistx]
    mov       r8,	rax
    call      mm_lib.addlistunit
L8563:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    lea       r10,	[mm_tables.exprstarter]
    mov       r10b,	[r10 + rax-1]
    test      r10b,	r10b
    jnz       L8565
    jmp       L8566
L8565:
L8567:
    call      mm_parse.readunit
    mov       r13,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	5
    jnz       L8570
    call      mm_lex.lex
    call      mm_parse.readunit
    mov       rsi,	rax
    jmp       L8569
L8570:
    xor       rsi,	rsi
L8569:
    mov       rcx,	118
    mov       rdx,	rsi
    call      mm_lib.createunit1
    mov       r14,	rax
    mov       rcx,	28
    mov       rdx,	r13
    mov       r8,	r14
    call      mm_lib.createunit2
    mov       r13,	rax
    lea       rcx,	[rbp + mm_parse.readread.readlist]
    lea       rdx,	[rbp + mm_parse.readread.readlistx]
    mov       r8,	r13
    call      mm_lib.addlistunit
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jnz       L8568
L8572:
    call      mm_lex.lex
    jmp       L8567
L8568:
;mm_parse.readread.finish:
L8566:
    mov       [mm_parse.inreadprint],	rdi
    cmp       rbx,	118
    jnz       L8574
    mov       rax,	[rbp + mm_parse.readread.readlist]
    test      rax,	rax
    jnz       L8574
    lea       rcx,	[L13409]
    call      mm_support.serror
L8574:
    mov       rcx,	6
    mov       rdx,	[rbp + mm_parse.readread.readlist]
    call      mm_lib.createunit1
L8555:
;---------------
    add       rsp,	48
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readfor
mm_parse.readfor:
;?>>
   %define R.pos rdi
   %define R.opc rbx
   %define R.pindex rsi
   %define R.plocal r12
   %define R.pfrom r13
   %define R.pto r14
    %define mm_parse.readfor.pstep -8
    %define mm_parse.readfor.ptoinit -16
    %define mm_parse.readfor.plist -24
    %define mm_parse.readfor.passign -32
    %define mm_parse.readfor.pcond -40
    %define mm_parse.readfor.pbody -48
    %define mm_parse.readfor.pelse -56
    %define mm_parse.readfor.p -64
    %define mm_parse.readfor.i -72
    %define mm_parse.readfor.$T1 -80
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	112
;---------------
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       rdi,	rax
    call      mm_lex.lex
    xor       r12,	r12
    xor       eax,	eax
    mov       [rbp + mm_parse.readfor.ptoinit],	rax
    call      mm_parse.readname
    mov       rsi,	rax
    mov       rax,	[mm_parse.nforloops]
    cmp       rax,	10
    jl        L8577
    lea       rcx,	[L13410]
    call      mm_support.serror
L8577:
    mov       rax,	1
    mov       [rbp + mm_parse.readfor.i],	rax
    mov       rax,	[mm_parse.nforloops]
    cmp       rax,	1
    jl        L8580
L8578:
    lea       rax,	[mm_parse.forindexvars]
    mov       r10,	[rbp + mm_parse.readfor.i]
    mov       rax,	[rax + r10*8-8]
    mov       r10,	[rsi+16]
    cmp       rax,	r10
    jnz       L8582
    lea       rcx,	[L13411]
    call      mm_support.serror
L8582:
    mov       rax,	[rbp + mm_parse.readfor.i]
    inc       rax
    mov       [rbp + mm_parse.readfor.i],	rax
    cmp       rax,	[mm_parse.nforloops]
    jle       L8578
L8580:
    mov       rax,	[rsi+16]
    inc       qword [mm_parse.nforloops]
    mov       r10,	[mm_parse.nforloops]
    lea       r11,	[mm_parse.forindexvars]
    mov       [r11 + r10*8-8],	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jnz       L8584
    call      mm_lex.lex
    call      mm_parse.readname
    mov       r12,	rax
L8584:
    mov       rbx,	93
    xor       eax,	eax
    mov       [rbp + mm_parse.readfor.pstep],	rax
    xor       eax,	eax
    mov       [rbp + mm_parse.readfor.pcond],	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	44
    jz        L8587
    cmp       rax,	46
    jnz       L8586
L8587:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	42
    jnz       L8589
    mov       rbx,	94
L8589:
    call      mm_lex.lex
    call      mm_parse.readunit
    mov       [rbp + mm_parse.readfor.plist],	rax
    mov       rax,	[rbp + mm_parse.readfor.plist]
    movzx     rax,	byte [rax]
    cmp       rax,	21
    jnz       L8591
    mov       rax,	[rbp + mm_parse.readfor.plist]
    mov       r13,	[rax+16]
    mov       rax,	[rbp + mm_parse.readfor.plist]
    mov       r14,	[rax+24]
    jmp       L8590
L8591:
    cmp       rbx,	93
    jnz       L8593
    mov       rax,	95
    jmp       L8592
L8593:
    mov       rax,	96
L8592:
    mov       rbx,	rax
    mov       rcx,	[rbp + mm_parse.readfor.plist]
    xor       edx,	edx
    call      mm_lib.duplunit
    mov       rcx,	rax
    call      mm_lib.getrangelwbunit
    mov       r13,	rax
    mov       rcx,	[rbp + mm_parse.readfor.plist]
    xor       edx,	edx
    call      mm_lib.duplunit
    mov       rcx,	rax
    call      mm_lib.getrangeupbunit
    mov       r14,	rax
L8590:
    jmp       L8585
L8586:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	6
    jnz       L8595
    call      mm_lex.lex
    call      mm_parse.readunit
    mov       r13,	rax
    jmp       L8594
L8595:
    mov       rcx,	1
    mov       rdx,	3
    call      mm_lib.createconstunit
    mov       r13,	rax
L8594:
    mov       rcx,	94
    call      mm_parse.checksymbol
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    cmp       rax,	1
    jnz       L8597
    mov       rax,	94
    jmp       L8596
L8597:
    mov       rax,	93
L8596:
    mov       rbx,	rax
    call      mm_lex.lex
    call      mm_parse.readunit
    mov       r14,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	95
    jnz       L8599
    call      mm_lex.lex
    xor       ecx,	ecx
    call      mm_parse.readconstexpr
    mov       [rbp + mm_parse.readfor.pstep],	rax
    mov       rax,	[rbp + mm_parse.readfor.pstep]
    movzx     rax,	byte [rax]
    cmp       rax,	1
    jnz       L8601
    mov       rax,	[rbp + mm_parse.readfor.pstep]
    mov       rax,	[rax+16]
    cmp       rax,	1
    jnz       L8603
    xor       eax,	eax
    mov       [rbp + mm_parse.readfor.pstep],	rax
L8603:
L8601:
L8599:
L8585:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	92
    jnz       L8605
    call      mm_lex.lex
    call      mm_parse.readunit
    mov       rcx,	rax
    call      mm_parse.fixcond
    mov       [rbp + mm_parse.readfor.pcond],	rax
L8605:
    mov       rcx,	96
    call      mm_parse.checksymbollex
    xor       ecx,	ecx
    call      mm_parse.readsunit
    mov       [rbp + mm_parse.readfor.pbody],	rax
    xor       eax,	eax
    mov       [rbp + mm_parse.readfor.pelse],	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	84
    jnz       L8607
    call      mm_lex.lex
    xor       ecx,	ecx
    call      mm_parse.readsunit
    mov       [rbp + mm_parse.readfor.pelse],	rax
L8607:
    mov       rcx,	87
    mov       rdx,	93
    mov       r8,	96
    xor       r9d,	r9d
    call      mm_parse.checkend
    mov       rax,	[rbp + mm_parse.readfor.pcond]
    test      rax,	rax
    jz        L8609
    mov       rcx,	92
    mov       rdx,	[rbp + mm_parse.readfor.pcond]
    mov       r8,	[rbp + mm_parse.readfor.pbody]
    call      mm_lib.createunit2
    mov       rcx,	rax
    call      mm_parse.makeblock
    mov       [rbp + mm_parse.readfor.pbody],	rax
L8609:
    mov       rax,	[rbp + mm_parse.readfor.pelse]
    mov       r10,	[rbp + mm_parse.readfor.pbody]
    mov       [r10+8],	rax
    mov       rax,	rbx
    cmp       rax,	93
    jz        L8611
    cmp       rax,	94
    jnz       L8612
L8611:
    test      r12,	r12
    jz        L8614
    lea       rcx,	[L13412]
    call      mm_support.serror
L8614:
    mov       al,	73
    mov       [rsi+41],	al
    movzx     rax,	byte [r14]
    cmp       rax,	1
    jz        L8616
    cmp       rax,	4
    jz        L8616
    mov       rcx,	[mm_decls.currproc]
    mov       rdx,	11
    call      mm_lib.getavname
    mov       rcx,	rax
    call      mm_lib.createname
    mov       r12,	rax
    mov       al,	73
    mov       [r12+41],	al
    mov       rcx,	28
    mov       rdx,	r12
    mov       r8,	r14
    call      mm_lib.createunit2
    mov       [rbp + mm_parse.readfor.ptoinit],	rax
    mov       rax,	[rbp + mm_parse.readfor.ptoinit]
    mov       [rsi+8],	rax
    mov       r14,	r12
L8616:
    mov       [r13+8],	r14
    mov       rax,	[rbp + mm_parse.readfor.pstep]
    mov       [r14+8],	rax
    mov       rcx,	rbx
    mov       rdx,	rsi
    mov       r8,	r13
    mov       r9,	[rbp + mm_parse.readfor.pbody]
    call      mm_lib.createunit3
    mov       [rbp + mm_parse.readfor.p],	rax
    jmp       L8610
L8612:
    test      r12,	r12
    jnz       L8618
    mov       r12,	rsi
    mov       rcx,	[mm_decls.currproc]
    mov       rdx,	11
    call      mm_lib.getavname
    mov       rcx,	rax
    call      mm_lib.createname
    mov       rsi,	rax
L8618:
    mov       al,	73
    mov       [rsi+41],	al
    mov       al,	76
    mov       [r12+41],	al
    mov       [rsi+8],	r12
    mov       [r12+8],	r13
    mov       [r13+8],	r14
    mov       rcx,	rsi
    xor       edx,	edx
    call      mm_lib.duplunit
    mov       [rbp + mm_parse.readfor.$T1],	rax
    mov       rcx,	[rbp + mm_parse.readfor.plist]
    xor       edx,	edx
    call      mm_lib.duplunit
    mov       rcx,	46
    mov       rdx,	rax
    mov       r8,	[rbp + mm_parse.readfor.$T1]
    call      mm_lib.createunit2
    mov       [rbp + mm_parse.readfor.$T1],	rax
    mov       rcx,	r12
    xor       edx,	edx
    call      mm_lib.duplunit
    mov       rcx,	28
    mov       rdx,	rax
    mov       r8,	[rbp + mm_parse.readfor.$T1]
    call      mm_lib.createunit2
    mov       [rbp + mm_parse.readfor.passign],	rax
    mov       rax,	[rbp + mm_parse.readfor.passign]
    mov       r10,	[rbp + mm_parse.readfor.plist]
    mov       [r10+8],	rax
    mov       rcx,	rbx
    mov       rdx,	rsi
    mov       r8,	[rbp + mm_parse.readfor.plist]
    mov       r9,	[rbp + mm_parse.readfor.pbody]
    call      mm_lib.createunit3
    mov       [rbp + mm_parse.readfor.p],	rax
L8610:
    mov       eax,	edi
    mov       r10,	[rbp + mm_parse.readfor.p]
    mov       [r10+4],	eax
    dec       qword [mm_parse.nforloops]
    mov       rax,	[rbp + mm_parse.readfor.p]
L8575:
;---------------
    add       rsp,	112
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readname
mm_parse.readname:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
;---------------
    call      mm_parse.readterm2
    mov       rdi,	rax
    movzx     rax,	byte [rdi]
    cmp       rax,	4
    jz        L8621
    lea       rcx,	[L13413]
    call      mm_support.serror
L8621:
    mov       rax,	rdi
L8619:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_parse.readtypedef
mm_parse.readtypedef:
;?>>
   %define R.owner r13
   %define R.scope r14
   %define R.sttype rdi
   %define R.stname rbx
   %define R.t rsi
   %define R.m r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       r13,	rcx
    mov       r14,	rdx
;---------------
    mov       rcx,	67
    call      mm_parse.lexchecksymbol
    lea       rax,	[mm_decls.lx]
    mov       rbx,	[rax+8]
    call      mm_lex.lex
    call      mm_parse.checkequals
    call      mm_lex.lex
    mov       rcx,	r13
    mov       rdx,	rbx
    mov       r8,	5
    call      mm_lib.getduplnameptr
    mov       rdi,	rax
    mov       rcx,	r13
    mov       rdx,	rdi
    call      mm_lib.adddef
    mov       rcx,	rdi
    call      mm_lib.createusertype
    mov       r12,	rax
    mov       al,	1
    lea       r10,	[mm_decls.ttusercat]
    mov       r11,	r12
    mov       [r10 + r11],	al
    mov       rcx,	rdi
    mov       rdx,	r12
    call      mm_parse.readtypespec
    mov       rsi,	rax
    mov       [rdi+170],	r14b
    lea       rax,	[rdi+72]
    mov       rcx,	r13
    mov       rdx,	rsi
    mov       r8,	rax
    call      mm_lib.storemode
    cmp       rsi,	0
    jl        L8624
    lea       rax,	[mm_decls.ttisinteger]
    mov       r10,	rsi
    movzx     rax,	byte [rax + r10]
    lea       r10,	[mm_decls.ttisreal]
    mov       r11,	rsi
    movzx     r10,	byte [r10 + r11]
    add       rax,	r10
    test      rax,	rax
    jz        L8626
    mov       eax,	esi
    lea       r10,	[mm_decls.tttarget]
    mov       r11,	r12
    mov       [r10 + r11*4],	eax
    jmp       L8625
L8626:
    lea       rax,	[mm_decls.ttisref]
    mov       r10,	rsi
    mov       al,	[rax + r10]
    test      al,	al
    jnz       L8625
L8627:
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rsi
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	10
    jz        L8629
    cmp       rax,	11
    jz        L8630
    cmp       rax,	8
    jz        L8631
    jmp       L8632
L8629:
    jmp       L8628
L8630:
    jmp       L8628
L8631:
    jmp       L8628
L8632:
    mov       eax,	esi
    lea       r10,	[mm_decls.tttarget]
    mov       r11,	r12
    mov       [r10 + r11*4],	eax
L8628:
L8625:
    jmp       L8623
L8624:
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	r12
    lea       rax,	[rax + r10*4]
    mov       rcx,	r13
    mov       rdx,	rsi
    mov       r8,	rax
    call      mm_lib.storemode
L8623:
    cmp       rsi,	0
    jl        L8634
    mov       rcx,	r12
    mov       rdx,	rsi
    call      mm_lib.copyttvalues
    jmp       L8633
L8634:
    mov       eax,	29
    lea       r10,	[mm_decls.ttbasetype]
    mov       r11,	r12
    mov       [r10 + r11*4],	eax
L8633:
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readrecordfields
mm_parse.readrecordfields:
;?>>
   %define R.owner r13
   %define R.m r14
   %define R.nvars rdi
   %define R.offset rbx
   %define R.stname rsi
   %define R.stbitfield r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       r13,	rcx
    mov       r14,	rdx
;---------------
    xor       rdi,	rdi
    jmp       L8637
L8636:
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       rcx,	r13
    mov       rdx,	rax
    mov       r8,	13
    call      mm_lib.getduplnameptr
    mov       rsi,	rax
    lea       rax,	[rsi+72]
    mov       rcx,	r13
    mov       rdx,	r14
    mov       r8,	rax
    call      mm_lib.storemode
    inc       rdi
    lea       rax,	[mm_parse.unionpend]
    mov       al,	[rax+7]
    test      al,	al
    jz        L8640
    lea       rax,	[rsi+136]
    mov       rcx,	rax
    lea       rdx,	[mm_parse.unionpend]
    call      mm_lib.unionstr_copy
    lea       rcx,	[mm_parse.unionstring]
    lea       rdx,	[mm_parse.unionpend]
    call      mm_lib.unionstr_concat
    lea       rcx,	[mm_parse.unionpend]
    call      mm_lib.unionstr_clear
    jmp       L8639
L8640:
    lea       rax,	[rsi+136]
    mov       rcx,	rax
    call      mm_lib.unionstr_clear
L8639:
    mov       [mm_parse.unionlastvar],	rsi
    mov       rcx,	r13
    mov       rdx,	rsi
    call      mm_lib.adddef
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	17
    jz        L8642
    cmp       rax,	5
    jz        L8643
    jmp       L8644
L8642:
    call      mm_lex.lex
    lea       rax,	[rsi+92]
    or        byte [rax],	128
    mov       rcx,	r13
    call      mm_parse.readequivfield
    mov       [rsi+128],	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	24
    jnz       L8646
    call      mm_lex.lex
    call      mm_parse.readconstint
    mov       rbx,	rax
    mov       rax,	rbx
    mov       r10,	9223372036854775807
    cmp       rax,	r10
    jle       L8648
    lea       rcx,	[L13414]
    call      mm_support.serror
L8648:
    mov       [rsi+151],	bl
L8646:
    jmp       L8641
L8643:
    mov       rcx,	9
    call      mm_parse.lexchecksymbol
L8649:
    mov       rcx,	67
    call      mm_parse.lexchecksymbol
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       rcx,	r13
    mov       rdx,	rax
    mov       r8,	13
    call      mm_lib.getduplnameptr
    mov       r12,	rax
    mov       eax,	27
    mov       [r12+72],	eax
    mov       rcx,	r13
    mov       rdx,	r12
    call      mm_lib.adddef
    lea       rax,	[r12+92]
    or        byte [rax],	128
    mov       [r12+128],	rsi
    mov       rcx,	5
    call      mm_parse.lexchecksymbol
    mov       rcx,	62
    call      mm_parse.lexchecksymbol
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       [r12+148],	al
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jz        L8649
    mov       rcx,	10
    call      mm_parse.checksymbollex
L8644:
L8641:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jnz       L8638
L8653:
    call      mm_lex.lex
L8637:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	67
    jz        L8636
L8638:
    test      rdi,	rdi
    jnz       L8655
    lea       rcx,	[L13415]
    call      mm_support.serror
L8655:
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readtabledef
mm_parse.readtabledef:
;?>>
    %define mm_parse.readtabledef.owner 72
    %define mm_parse.readtabledef.scope 80
   %define R.i rdi
   %define R.ncols rbx
   %define R.nrows rsi
   %define R.enums r12
   %define R.nextenumvalue r13
   %define R.firstval r14
   %define R.lastval r15
    %define mm_parse.readtabledef.startline -8
    %define mm_parse.readtabledef.closesym -16
    %define mm_parse.readtabledef.ltype -24
    %define mm_parse.readtabledef.stvar -32
    %define mm_parse.readtabledef.stenum -40
    %define mm_parse.readtabledef.stgen -48
    %define mm_parse.readtabledef.varnameptrs -208
    %define mm_parse.readtabledef.varlisttypes -368
    %define mm_parse.readtabledef.plist -528
    %define mm_parse.readtabledef.plistx -688
    %define mm_parse.readtabledef.enumvalues -4688
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	4728
    mov       [rbp+72],	rcx
    mov       [rbp+80],	rdx
;---------------
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    mov       r12,	rax
    call      mm_lex.lex
    xor       eax,	eax
    mov       [mm_parse.tabledataname],	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	9
    jnz       L8658
    test      r12,	r12
    jnz       L8660
    lea       rcx,	[L13416]
    call      mm_support.serror
L8660:
    mov       r12,	1
    call      mm_lex.lex
    mov       rcx,	10
    call      mm_parse.checksymbollex
L8658:
    mov       r13,	1
    xor       rsi,	rsi
    xor       eax,	eax
    mov       rbx,	rax
    jmp       L8662
L8661:
    mov       rcx,	[rbp + mm_parse.readtabledef.owner]
    xor       edx,	edx
    call      mm_parse.readtypespec
    mov       [rbp + mm_parse.readtabledef.ltype],	rax
    mov       rcx,	67
    call      mm_parse.checksymbol
    inc       rbx
    cmp       rbx,	20
    jle       L8665
    lea       rcx,	[L13417]
    call      mm_support.serror
L8665:
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       [rbp + rbx*8 + mm_parse.readtabledef.varnameptrs-8],	rax
    mov       rax,	[rbp + mm_parse.readtabledef.ltype]
    mov       [rbp + rbx*8 + mm_parse.readtabledef.varlisttypes-8],	rax
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jnz       L8667
    call      mm_lex.lex
    jmp       L8666
L8667:
    jmp       L8663
L8666:
L8662:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	41
    jnz       L8661
L8663:
    call      mm_lex.lex
    call      mm_parse.skipsemi
    call      mm_parse.getcurrline
    mov       [rbp + mm_parse.readtabledef.startline],	rax
    xor       ecx,	ecx
    call      mm_parse.checkbegin
    mov       [rbp + mm_parse.readtabledef.closesym],	rax
    call      mm_parse.skipsemi
    xor       eax,	eax
    mov       r15,	rax
    mov       r14,	rax
    mov       rdi,	1
    cmp       rbx,	1
    jl        L8670
L8668:
    xor       eax,	eax
    mov       [rbp + rdi*8 + mm_parse.readtabledef.plistx-8],	rax
    mov       [rbp + rdi*8 + mm_parse.readtabledef.plist-8],	rax
    inc       rdi
    cmp       rdi,	rbx
    jle       L8668
L8670:
    mov       rax,	1
    mov       [mm_parse.intabledata],	rax
L8671:
    call      mm_parse.skipsemi
    cmp       rbx,	0
    jle       L8674
    mov       rcx,	9
    call      mm_parse.checksymbollex
L8674:
    inc       rsi
    cmp       rsi,	500
    jle       L8676
    lea       rcx,	[L13418]
    call      mm_support.serror
L8676:
    test      r12,	r12
    jz        L8678
    mov       rcx,	67
    call      mm_parse.checksymbol
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       [rbp + mm_parse.readtabledef.stgen],	rax
    mov       rax,	[rbp + mm_parse.readtabledef.stgen]
    mov       rax,	[rax]
    mov       [mm_parse.tabledataname],	rax
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	41
    jnz       L8680
    cmp       rsi,	1
    jz        L8682
    lea       rcx,	[L13419]
    call      mm_support.serror
L8682:
    call      mm_lex.lex
    call      mm_parse.readconstint
    mov       r13,	rax
L8680:
    mov       [rbp + rsi*8 + mm_parse.readtabledef.enumvalues-8],	r13
    mov       rcx,	[rbp + mm_parse.readtabledef.owner]
    mov       rdx,	[rbp + mm_parse.readtabledef.stgen]
    mov       r8,	9
    call      mm_lib.getduplnameptr
    mov       [rbp + mm_parse.readtabledef.stenum],	rax
    mov       eax,	3
    mov       r10,	[rbp + mm_parse.readtabledef.stenum]
    mov       [r10+72],	eax
    mov       rcx,	r13
    mov       rdx,	3
    call      mm_lib.createconstunit
    mov       r10,	[rbp + mm_parse.readtabledef.stenum]
    mov       [r10+64],	rax
    mov       al,	[rbp + mm_parse.readtabledef.scope]
    mov       r10,	[rbp + mm_parse.readtabledef.stenum]
    mov       [r10+170],	al
    mov       rcx,	[rbp + mm_parse.readtabledef.owner]
    mov       rdx,	[rbp + mm_parse.readtabledef.stenum]
    call      mm_lib.adddef
    mov       rax,	[rbp + mm_parse.readtabledef.scope]
    cmp       rax,	3
    jnz       L8684
    mov       rcx,	[rbp + mm_parse.readtabledef.stenum]
    call      mm_lib.addexpconst
L8684:
    cmp       rsi,	1
    jnz       L8686
    mov       r14,	r13
L8686:
    mov       r15,	r13
    inc       r13
    test      rbx,	rbx
    jz        L8688
    mov       rcx,	3
    call      mm_parse.checksymbollex
L8688:
L8678:
    mov       rdi,	1
    cmp       rbx,	1
    jl        L8691
L8689:
    call      mm_parse.readunit
    lea       r10,	[rbp + rdi*8 + mm_parse.readtabledef.plistx-8]
    lea       r11,	[rbp + rdi*8 + mm_parse.readtabledef.plist-8]
    mov       rcx,	r11
    mov       rdx,	r10
    mov       r8,	rax
    call      mm_lib.addlistunit
    cmp       rdi,	rbx
    jnz       L8693
    mov       rcx,	10
    call      mm_parse.checksymbollex
    jmp       L8692
L8693:
    mov       rcx,	3
    call      mm_parse.checksymbollex
L8692:
    inc       rdi
    cmp       rdi,	rbx
    jle       L8689
L8691:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jnz       L8672
L8695:
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	[rbp + mm_parse.readtabledef.closesym]
    jz        L8672
L8697:
    jmp       L8671
L8672:
    xor       eax,	eax
    mov       [mm_parse.intabledata],	rax
    call      mm_parse.skipsemi
    mov       rcx,	[rbp + mm_parse.readtabledef.closesym]
    mov       rdx,	132
    mov       r8,	[rbp + mm_parse.readtabledef.startline]
    call      mm_parse.checkbeginend
    test      rsi,	rsi
    jnz       L8699
    lea       rcx,	[L13420]
    call      mm_support.serror
L8699:
    mov       rdi,	1
    cmp       rbx,	1
    jl        L8702
L8700:
    mov       rax,	[rbp + rdi*8 + mm_parse.readtabledef.varnameptrs-8]
    mov       rcx,	[rbp + mm_parse.readtabledef.owner]
    mov       rdx,	rax
    mov       r8,	10
    call      mm_lib.getduplnameptr
    mov       [rbp + mm_parse.readtabledef.stvar],	rax
    mov       rax,	[rbp + rdi*8 + mm_parse.readtabledef.plist-8]
    mov       rcx,	20
    mov       rdx,	rax
    call      mm_lib.createunit1
    mov       r10,	[rbp + mm_parse.readtabledef.stvar]
    mov       [r10+64],	rax
    mov       rax,	[rbp + mm_parse.readtabledef.stvar]
    mov       rax,	[rax+64]
    mov       r10d,	esi
    mov       [rax+40],	r10d
    mov       rax,	[rbp + mm_parse.readtabledef.stvar]
    lea       rax,	[rax+92]
    or        byte [rax+1],	2
    mov       rax,	[rbp + mm_parse.readtabledef.stvar]
    lea       rax,	[rax+72]
    mov       r10,	[rbp + rdi*8 + mm_parse.readtabledef.varlisttypes-8]
    mov       rcx,	[rbp + mm_parse.readtabledef.owner]
    mov       rdx,	r10
    mov       r8,	rax
    call      mm_lib.storemode
    mov       al,	[rbp + mm_parse.readtabledef.scope]
    mov       r10,	[rbp + mm_parse.readtabledef.stvar]
    mov       [r10+170],	al
    mov       rcx,	[rbp + mm_parse.readtabledef.owner]
    mov       rdx,	[rbp + mm_parse.readtabledef.stvar]
    call      mm_lib.adddef
    mov       rcx,	[rbp + mm_parse.readtabledef.stvar]
    call      mm_lib.addstatic
    inc       rdi
    cmp       rdi,	rbx
    jle       L8700
L8702:
;---------------
    add       rsp,	4728
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readclassdef
mm_parse.readclassdef:
;?>>
    %define mm_parse.readclassdef.owner 72
    %define mm_parse.readclassdef.scope 80
   %define R.kwd rdi
   %define R.baseclass rbx
   %define R.m rsi
   %define R.startline r12
   %define R.closesym r13
   %define R.mrec r14
   %define R.isrecord r15
    %define mm_parse.readclassdef.align -8
    %define mm_parse.readclassdef.nameptr -16
    %define mm_parse.readclassdef.sttype -24
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
    mov       [rbp+72],	rcx
    mov       [rbp+80],	rdx
;---------------
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    mov       rdi,	rax
    mov       rax,	rdi
    cmp       rax,	111
    setz      al
    movzx     eax,	al
    mov       r15,	rax
    mov       rcx,	67
    call      mm_parse.lexchecksymbol
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       [rbp + mm_parse.readclassdef.nameptr],	rax
    call      mm_lex.lex
    xor       rbx,	rbx
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	9
    jnz       L8705
    call      mm_lex.lex
    mov       rcx,	[rbp + mm_parse.readclassdef.owner]
    xor       edx,	edx
    call      mm_parse.readtypespec
    mov       rbx,	rax
    mov       rcx,	10
    call      mm_parse.checksymbollex
L8705:
    call      mm_parse.checkequals
    call      mm_lex.lex
    xor       eax,	eax
    mov       [rbp + mm_parse.readclassdef.align],	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	17
    jnz       L8707
    call      mm_lex.lex
    mov       rax,	1
    mov       [rbp + mm_parse.readclassdef.align],	rax
L8707:
    mov       rcx,	[rbp + mm_parse.readclassdef.owner]
    mov       rdx,	[rbp + mm_parse.readclassdef.nameptr]
    mov       r8,	5
    call      mm_lib.getduplnameptr
    mov       [rbp + mm_parse.readclassdef.sttype],	rax
    mov       rcx,	[rbp + mm_parse.readclassdef.owner]
    mov       rdx,	[rbp + mm_parse.readclassdef.sttype]
    call      mm_lib.adddef
    mov       rcx,	[rbp + mm_parse.readclassdef.sttype]
    call      mm_lib.createusertype
    mov       rsi,	rax
    mov       rcx,	[rbp + mm_parse.readclassdef.owner]
    mov       rdx,	rsi
    call      mm_lib.createrecordmode
    mov       r14,	rax
    mov       rax,	[rbp + mm_parse.readclassdef.sttype]
    lea       rax,	[rax+72]
    mov       rcx,	[rbp + mm_parse.readclassdef.owner]
    mov       rdx,	r14
    mov       r8,	rax
    call      mm_lib.storemode
    mov       rax,	[rbp + mm_parse.readclassdef.sttype]
    lea       rax,	[rax+144]
    mov       rcx,	[rbp + mm_parse.readclassdef.owner]
    mov       rdx,	rbx
    mov       r8,	rax
    call      mm_lib.storemode
    mov       al,	[rbp + mm_parse.readclassdef.align]
    mov       r10,	[rbp + mm_parse.readclassdef.sttype]
    mov       [r10+149],	al
    mov       rcx,	1
    call      mm_parse.checkbegin
    mov       r13,	rax
    call      mm_parse.getcurrline
    mov       r12,	rax
    mov       rcx,	[rbp + mm_parse.readclassdef.sttype]
    mov       rdx,	rdi
    call      mm_parse.readclassbody
    mov       rcx,	r13
    mov       rdx,	rdi
    mov       r8,	r12
    call      mm_parse.checkbeginend
    mov       al,	[rbp + mm_parse.readclassdef.scope]
    mov       r10,	[rbp + mm_parse.readclassdef.sttype]
    mov       [r10+170],	al
;---------------
    add       rsp,	56
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readclassbody
mm_parse.readclassbody:
;?>>
   %define R.owner r12
    %define mm_parse.readclassbody.classkwd 56
   %define R.kwd rdi
   %define R.t rbx
   %define R.lbcount rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       r12,	rcx
;---------------
    xor       rsi,	rsi
    lea       rcx,	[mm_parse.unionstring]
    call      mm_lib.unionstr_clear
    lea       rcx,	[mm_parse.unionpend]
    call      mm_lib.unionstr_clear
L8709:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	123
    jz        L8711
    cmp       rax,	109
    jz        L8712
    cmp       rax,	108
    jz        L8712
    cmp       rax,	111
    jz        L8713
    cmp       rax,	116
    jz        L8714
    cmp       rax,	59
    jz        L8715
    cmp       rax,	4
    jz        L8716
    cmp       rax,	132
    jz        L8717
    cmp       rax,	122
    jz        L8718
    cmp       rax,	112
    jz        L8719
    cmp       rax,	113
    jz        L8719
    cmp       rax,	87
    jz        L8720
    cmp       rax,	10
    jz        L8720
    cmp       rax,	119
    jz        L8721
    cmp       rax,	120
    jz        L8722
    jmp       L8723
L8711:
    mov       rcx,	r12
    xor       edx,	edx
    call      mm_parse.readconstdef
    jmp       L8709
L8712:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    mov       rdi,	rax
    movzx     rax,	word [r12+92]
    shr       eax,	11
    and       eax,	1
    test      rax,	rax
    jz        L8725
    mov       rcx,	r12
    xor       edx,	edx
    call      mm_parse.readprocdecl
    jmp       L8724
L8725:
    mov       rcx,	r12
    xor       edx,	edx
    call      mm_parse.readprocdef
L8724:
    jmp       L8709
L8713:
    mov       rcx,	r12
    xor       edx,	edx
    call      mm_parse.readclassdef
    jmp       L8709
L8714:
    mov       rcx,	r12
    xor       edx,	edx
    call      mm_parse.readtypedef
    jmp       L8709
L8715:
    lea       rcx,	[L13421]
    call      mm_support.serror
    jmp       L8710
L8716:
    call      mm_lex.lex
    jmp       L8709
L8717:
    mov       rcx,	r12
    xor       edx,	edx
    call      mm_parse.readtabledef
    jmp       L8709
L8718:
    mov       rcx,	r12
    xor       edx,	edx
    call      mm_parse.readmacrodef
    jmp       L8709
L8719:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	112
    jnz       L8727
    mov       rax,	83
    jmp       L8726
L8727:
    mov       rax,	85
L8726:
    lea       rcx,	[mm_parse.unionpend]
    mov       rdx,	rax
    call      mm_lib.unionstr_append
    xor       eax,	eax
    mov       [mm_parse.unionlastvar],	rax
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	9
    jnz       L8729
    inc       rsi
    call      mm_lex.lex
L8729:
    jmp       L8709
L8720:
    lea       rax,	[mm_parse.unionstring]
    mov       al,	[rax+7]
    test      al,	al
    jz        L8731
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	10
    jnz       L8733
    test      rsi,	rsi
    jz        L8733
    call      mm_lex.lex
    dec       rsi
    jmp       L8732
L8733:
    lea       rcx,	[mm_parse.unionstring]
    call      mm_lib.unionstr_last
    cmp       rax,	83
    jnz       L8735
    mov       rax,	112
    jmp       L8734
L8735:
    mov       rax,	113
L8734:
    mov       rcx,	87
    mov       rdx,	rax
    xor       r8d,	r8d
    xor       r9d,	r9d
    call      mm_parse.checkend
L8732:
    mov       rax,	[mm_parse.unionlastvar]
    test      rax,	rax
    jz        L8738
    lea       rax,	[mm_parse.unionpend]
    mov       al,	[rax+7]
    test      al,	al
    jz        L8737
L8738:
    lea       rcx,	[L13422]
    call      mm_support.serror
L8737:
    mov       rax,	[mm_parse.unionlastvar]
    lea       rax,	[rax+136]
    mov       rcx,	rax
    call      mm_lib.unionstr_last
    cmp       rax,	69
    jz        L8740
    cmp       rax,	42
    jnz       L8741
L8740:
    jmp       L8739
L8741:
    mov       rax,	[mm_parse.unionlastvar]
    lea       rax,	[rax+136]
    mov       rcx,	rax
    mov       rdx,	42
    call      mm_lib.unionstr_append
L8739:
    mov       rax,	[mm_parse.unionlastvar]
    lea       rax,	[rax+136]
    mov       rcx,	rax
    mov       rdx,	69
    call      mm_lib.unionstr_append
    lea       rax,	[mm_parse.unionstring]
    lea       rax,	[rax+7]
    dec       byte [rax]
    jmp       L8730
L8731:
    jmp       L8710
L8730:
    jmp       L8709
L8721:
    call      mm_lex.lex
    call      mm_parse.istypestarter
    test      rax,	rax
    jz        L8743
;mm_parse.readclassbody.readmut:
L8744:
    inc       qword [mm_parse.insiderecord]
    mov       rcx,	r12
    xor       edx,	edx
    call      mm_parse.readtypespec
    mov       rbx,	rax
    dec       qword [mm_parse.insiderecord]
    jmp       L8742
L8743:
    mov       rbx,	22
L8742:
    mov       rcx,	r12
    mov       rdx,	rbx
    call      mm_parse.readrecordfields
    jmp       L8709
L8722:
    lea       rcx,	[L13423]
    call      mm_support.serror
    jmp       L8709
L8723:
    call      mm_parse.istypestarter
    test      rax,	rax
    jnz       L8744
L8746:
    jmp       L8710
L8745:
    jmp       L8709
L8710:
    test      rsi,	rsi
    jz        L8748
    lea       rcx,	[L13424]
    call      mm_support.serror
L8748:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readimportmodule
mm_parse.readimportmodule:
;?>>
   %define R.owner r14
   %define R.isnew rdi
   %define R.startline rbx
   %define R.closesym rsi
   %define R.stname r12
   %define R.i r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       r14,	rcx
;---------------
    mov       rax,	[mm_parse.insidedllimport]
    test      rax,	rax
    jz        L8751
    lea       rcx,	[L13425]
    call      mm_support.serror
L8751:
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	65
    jnz       L8753
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       rcx,	rax
    call      mm_lex.addnamestr
    mov       r12,	rax
    jmp       L8752
L8753:
    mov       rcx,	67
    call      mm_parse.checksymbol
    lea       rax,	[mm_decls.lx]
    mov       r12,	[rax+8]
L8752:
    call      mm_lex.lex
    call      mm_parse.checkequals
    call      mm_lex.lex
    mov       rdi,	1
    mov       r13,	1
    mov       rax,	[mm_decls.nlibfiles]
    cmp       rax,	1
    jl        L8756
L8754:
    mov       rax,	[r12]
    lea       r10,	[mm_decls.libfiles]
    mov       r11,	r13
    mov       r10,	[r10 + r11*8]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mlib.eqstring
    test      rax,	rax
    jz        L8758
    xor       rdi,	rdi
    jmp       L8756
L8758:
    inc       r13
    cmp       r13,	[mm_decls.nlibfiles]
    jle       L8754
L8756:
    test      rdi,	rdi
    jz        L8760
    mov       rcx,	[r12]
    call      mm_modules.addlib
L8760:
    call      mm_parse.getcurrline
    mov       rbx,	rax
    xor       ecx,	ecx
    call      mm_parse.checkbegin
    mov       rsi,	rax
    mov       rax,	1
    mov       [mm_parse.insidedllimport],	rax
    mov       rcx,	r14
    call      mm_parse.readimportbody
    xor       eax,	eax
    mov       [mm_parse.insidedllimport],	rax
    mov       rcx,	rsi
    mov       rdx,	114
    mov       r8,	rbx
    call      mm_parse.checkbeginend
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readimportbody
mm_parse.readimportbody:
;?>>
   %define R.owner rsi
   %define R.pos rdi
   %define R.d rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       rdi,	rax
L8762:
    call      mm_parse.skipsemi
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	108
    jz        L8765
    cmp       rax,	109
    jz        L8765
    cmp       rax,	116
    jz        L8766
    cmp       rax,	123
    jz        L8767
    cmp       rax,	111
    jz        L8768
    cmp       rax,	119
    jz        L8769
    cmp       rax,	79
    jz        L8770
    cmp       rax,	67
    jz        L8770
    cmp       rax,	117
    jz        L8770
    cmp       rax,	80
    jz        L8770
    cmp       rax,	11
    jz        L8770
    cmp       rax,	121
    jz        L8770
    cmp       rax,	59
    jz        L8771
    cmp       rax,	87
    jz        L8772
    jmp       L8773
L8765:
;mm_parse.readimportbody.doproc:
    mov       rcx,	rsi
    xor       edx,	edx
    call      mm_parse.readprocdecl
    mov       rbx,	rax
    mov       rax,	[mm_decls.ndllproctable]
    cmp       rax,	1000
    jl        L8776
    lea       rcx,	[L13426]
    call      mm_support.serror
L8776:
    inc       qword [mm_decls.ndllproctable]
    mov       rax,	[mm_decls.ndllproctable]
    mov       r10,	rbx
    lea       r11,	[mm_decls.dllproctable]
    mov       [r11 + rax*8-8],	r10
    jmp       L8764
L8766:
    mov       rcx,	rsi
    mov       rdx,	1
    call      mm_parse.readtypedef
    jmp       L8764
L8767:
    mov       rcx,	rsi
    mov       rdx,	1
    call      mm_parse.readconstdef
    jmp       L8764
L8768:
    mov       rcx,	rsi
    mov       rdx,	1
    call      mm_parse.readclassdef
    jmp       L8764
L8769:
    call      mm_lex.lex
    sub       rsp,	8
    push      119
    mov       rcx,	rsi
    mov       rdx,	1
    xor       r8d,	r8d
    mov       r9,	8
    sub       rsp,	32
    call      mm_parse.readvardef
    add       rsp,	48
    jmp       L8764
L8770:
    sub       rsp,	8
    push      0
    mov       rcx,	rsi
    mov       rdx,	1
    xor       r8d,	r8d
    mov       r9,	8
    sub       rsp,	32
    call      mm_parse.readvardef
    add       rsp,	48
    jmp       L8764
L8771:
    jmp       L8763
L8772:
    jmp       L8763
L8773:
    lea       rcx,	[L13427]
    call      mm_lex.ps
    lea       rcx,	[L13428]
    call      mm_support.serror
L8764:
    jmp       L8762
L8763:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readequivfield
mm_parse.readequivfield:
;?>>
   %define R.owner rsi
   %define R.p rdi
   %define R.d rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    mov       rcx,	67
    call      mm_parse.checksymbol
    lea       rax,	[mm_decls.lx]
    mov       rbx,	[rax+8]
    call      mm_lex.lex
    mov       rdi,	[rsi+16]
    jmp       L8779
L8778:
    mov       rax,	[rbx]
    mov       r10,	[rdi]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mlib.eqstring
    test      rax,	rax
    jz        L8782
    mov       rax,	rdi
    jmp       L8777
L8782:
    mov       rdi,	[rdi+32]
L8779:
    test      rdi,	rdi
    jnz       L8778
    call      msys.m$print_startcon
    mov       rcx,	[rbx]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L13429]
    call      mm_support.serror
    xor       eax,	eax
L8777:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readrefproc
mm_parse.readrefproc:
;?>>
    %define mm_parse.readrefproc.owner 64
    %define mm_parse.readrefproc.typedefx 72
   %define R.kwd rdi
   %define R.prettype rbx
   %define R.m rsi
    %define mm_parse.readrefproc.varparams -8
    %define mm_parse.readrefproc.nparams -16
    %define mm_parse.readrefproc.retmodes -48
   %define R.paramlist r12
   %define R.stproc r13
   %define R.nretvalues r14
    %define mm_parse.readrefproc.name -56
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	96
    mov       [rbp+64],	rcx
    mov       [rbp+72],	rdx
;---------------
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    mov       rdi,	rax
    call      mm_lex.lex
    xor       r12,	r12
    xor       eax,	eax
    mov       rbx,	rax
    xor       r14,	r14
    xor       eax,	eax
    mov       [rbp + mm_parse.readrefproc.varparams],	rax
    call      mm_lib.nextautotype
    mov       [rbp + mm_parse.readrefproc.name],	rax
    mov       rcx,	[rbp + mm_parse.readrefproc.name]
    call      mm_lex.addnamestr
    mov       rcx,	[mm_decls.stmodule]
    mov       rdx,	rax
    mov       r8,	5
    call      mm_lib.getduplnameptr
    mov       r13,	rax
    mov       rcx,	[mm_decls.stmodule]
    mov       rdx,	r13
    call      mm_lib.adddef
    xor       eax,	eax
    mov       [rbp + mm_parse.readrefproc.retmodes],	rax
    cmp       rdi,	109
    jnz       L8785
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	9
    jnz       L8787
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	10
    jz        L8789
    mov       rcx,	[rbp + mm_parse.readrefproc.owner]
    mov       rdx,	r13
    lea       r8,	[rbp + mm_parse.readrefproc.varparams]
    lea       r9,	[rbp + mm_parse.readrefproc.nparams]
    call      mm_parse.readparams
    mov       r12,	rax
    mov       rcx,	10
    call      mm_parse.checksymbol
L8789:
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	5
    jz        L8792
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	7
    jnz       L8791
L8792:
    call      mm_lex.lex
    mov       rcx,	r13
    lea       rdx,	[rbp + mm_parse.readrefproc.retmodes]
    call      mm_parse.readreturntype
    mov       r14,	rax
    jmp       L8790
L8791:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    lea       r10,	[mm_decls.typestarterset]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jnz       L8794
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	67
    jnz       L8793
L8794:
    mov       rcx,	r13
    lea       rdx,	[rbp + mm_parse.readrefproc.retmodes]
    call      mm_parse.readreturntype
    mov       r14,	rax
L8793:
L8790:
    jmp       L8786
L8787:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	5
    jz        L8796
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	7
    jnz       L8795
L8796:
    call      mm_lex.lex
    mov       rcx,	r13
    lea       rdx,	[rbp + mm_parse.readrefproc.retmodes]
    call      mm_parse.readreturntype
    mov       r14,	rax
L8795:
L8786:
    test      r14,	r14
    jnz       L8798
    lea       rcx,	[L13430]
    call      mm_support.serror
L8798:
    test      r14,	r14
    jz        L8800
    cmp       rdi,	108
    jnz       L8800
    lea       rcx,	[L13431]
    call      mm_support.serror
L8800:
    jmp       L8784
L8785:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	9
    jnz       L8802
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	10
    jz        L8804
    mov       rcx,	[rbp + mm_parse.readrefproc.owner]
    mov       rdx,	r13
    lea       r8,	[rbp + mm_parse.readrefproc.varparams]
    lea       r9,	[rbp + mm_parse.readrefproc.nparams]
    call      mm_parse.readparams
    mov       r12,	rax
    mov       rcx,	10
    call      mm_parse.checksymbol
L8804:
    call      mm_lex.lex
L8802:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    lea       r10,	[mm_decls.typestarterset]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jnz       L8807
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	5
    jz        L8807
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	7
    jnz       L8806
L8807:
    lea       rcx,	[L13432]
    call      mm_support.serror
L8806:
L8784:
    push      qword [rbp + mm_parse.readrefproc.typedefx]
    mov       rax,	rbx
    push      rax
    mov       rcx,	[rbp + mm_parse.readrefproc.owner]
    mov       rdx,	r13
    mov       r8,	r12
    mov       r9,	rdi
    sub       rsp,	32
    call      mm_lib.createrefprocmode
    add       rsp,	48
    mov       rsi,	rax
    lea       rax,	[r13+72]
    mov       r10,	[rbp + mm_parse.readrefproc.retmodes]
    mov       rcx,	[rbp + mm_parse.readrefproc.owner]
    mov       rdx,	r10
    mov       r8,	rax
    call      mm_lib.storemode
    mov       [r13+122],	r14b
    mov       rax,	r13
    lea       r10,	[mm_decls.ttnamedef]
    mov       r11,	rsi
    mov       [r10 + r11*8],	rax
    mov       al,	[rbp + mm_parse.readrefproc.varparams]
    mov       [r13+123],	al
    mov       rax,	rsi
L8783:
;---------------
    add       rsp,	96
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.pushproc
mm_parse.pushproc:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rax,	[mm_parse.nprocstack]
    cmp       rax,	10
    jl        L8810
    lea       rcx,	[L13433]
    call      mm_support.serror
L8810:
    inc       qword [mm_parse.nprocstack]
    mov       rax,	[mm_parse.nprocstack]
    mov       r10,	[mm_decls.currproc]
    lea       r11,	[mm_parse.procstack]
    mov       [r11 + rax*8-8],	r10
    mov       [mm_decls.currproc],	rdi
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_parse.popproc
mm_parse.popproc:
;?>>
;?]]
;---------------
    mov       rax,	[mm_parse.nprocstack]
    test      rax,	rax
    jz        L8813
    mov       rax,	[mm_parse.nprocstack]
    dec       qword [mm_parse.nprocstack]
    lea       r10,	[mm_parse.procstack]
    mov       r10,	[r10 + rax*8-8]
    mov       [mm_decls.currproc],	r10
    jmp       L8812
L8813:
    mov       rax,	[mm_decls.stmodule]
    mov       [mm_decls.currproc],	rax
L8812:
;---------------
    ret       
;End 
;Proc mm_parse.readreturntype
mm_parse.readreturntype:
;?>>
   %define R.owner rbx
   %define R.retmodes rsi
   %define R.nretvalues rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    mov       rcx,	rbx
    xor       edx,	edx
    call      mm_parse.readtypespec
    mov       [rsi],	rax
    mov       rdi,	1
    jmp       L8816
L8815:
    cmp       rdi,	4
    jl        L8819
    lea       rcx,	[L13434]
    call      mm_support.serror
L8819:
    call      mm_lex.lex
    mov       rcx,	rbx
    xor       edx,	edx
    call      mm_parse.readtypespec
    inc       rdi
    mov       r10,	rdi
    mov       [rsi + r10*8-8],	rax
L8816:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jz        L8815
    mov       rax,	rdi
L8814:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readset
mm_parse.readset:
;?>>
   %define R.length rdi
   %define R.nkeyvalues rbx
   %define R.oldirp rsi
   %define R.p r12
    %define mm_parse.readset.ulist -8
    %define mm_parse.readset.ulistx -16
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
;---------------
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	12
    jnz       L8823
L8822:
    call      mm_lex.lex
    mov       rcx,	22
    xor       edx,	edx
    call      mm_lib.createunit1
    jmp       L8820
L8823:
L8821:
    xor       rdi,	rdi
    xor       eax,	eax
    mov       rbx,	rax
    xor       eax,	eax
    mov       [rbp + mm_parse.readset.ulistx],	rax
    mov       [rbp + mm_parse.readset.ulist],	rax
L8824:
    mov       rsi,	[mm_parse.inreadprint]
    xor       eax,	eax
    mov       [mm_parse.inreadprint],	rax
    call      mm_parse.readunit
    mov       r12,	rax
    mov       [mm_parse.inreadprint],	rsi
    movzx     rax,	byte [r12]
    cmp       rax,	27
    jnz       L8827
    inc       rbx
L8827:
    inc       rdi
    lea       rcx,	[rbp + mm_parse.readset.ulist]
    lea       rdx,	[rbp + mm_parse.readset.ulistx]
    mov       r8,	r12
    call      mm_lib.addlistunit
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jz        L8829
    cmp       rax,	4
    jz        L8830
    cmp       rax,	12
    jz        L8831
    jmp       L8832
L8829:
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	12
    jz        L8825
L8834:
    jmp       L8828
L8830:
    mov       rcx,	12
    call      mm_parse.lexchecksymbol
    jmp       L8825
L8831:
    jmp       L8825
L8832:
    lea       rcx,	[L13435]
    call      mm_support.serror
L8828:
    call      mm_parse.skipsemi
    jmp       L8824
L8825:
    call      mm_lex.lex
    test      rbx,	rbx
    jz        L8836
    cmp       rdi,	rbx
    jle       L8838
    lea       rcx,	[L13436]
    call      mm_support.serror
L8838:
    mov       rcx,	23
    mov       rdx,	[rbp + mm_parse.readset.ulist]
    call      mm_lib.createunit1
    mov       r12,	rax
    jmp       L8835
L8836:
    mov       rcx,	22
    mov       rdx,	[rbp + mm_parse.readset.ulist]
    call      mm_lib.createunit1
    mov       r12,	rax
L8835:
    mov       [r12+40],	edi
    mov       rax,	r12
L8820:
;---------------
    add       rsp,	48
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.istypestarter
mm_parse.istypestarter:
;?>>
;?]]
;---------------
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    lea       r10,	[mm_decls.typestarterset]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L8841
    mov       rax,	1
    jmp       L8839
L8841:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	67
    jnz       L8843
    lea       rax,	[mm_decls.nextlx]
    movzx     rax,	byte [rax]
    cmp       rax,	67
    jz        L8845
    cmp       rax,	19
    jz        L8846
    jmp       L8847
L8845:
    mov       rax,	1
    jmp       L8839
L8846:
    mov       rax,	1
    jmp       L8839
L8847:
L8844:
L8843:
    xor       eax,	eax
L8839:
;---------------
    ret       
;End 
;Proc mm_parse.readunit
mm_parse.readunit:
;?>>
   %define R.p rdi
   %define R.pt rbx
   %define R.pos rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
;---------------
    xor       rbx,	rbx
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       rsi,	rax
    call      mm_parse.readterm2
    mov       rbx,	rax
    movzx     rax,	byte [rbx]
    lea       r10,	[mm_tables.jisexpr]
    movzx     r10,	byte [r10 + rax]
    test      r10,	r10
    jnz       L8850
    mov       rax,	rbx
    jmp       L8848
L8850:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    lea       r10,	[mm_tables.endsexpr]
    mov       r10b,	[r10 + rax-1]
    test      r10b,	r10b
    jz        L8852
    mov       rax,	rbx
    jmp       L8848
L8852:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	6
    jnz       L8854
    call      mm_lex.lex
    call      mm_parse.readterm2
    mov       rdi,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    lea       r10,	[mm_tables.endsexpr]
    mov       r10b,	[r10 + rax-1]
    test      r10b,	r10b
    jz        L8856
    mov       rcx,	28
    mov       rdx,	rbx
    mov       r8,	rdi
    call      mm_lib.createunit2
    mov       rdi,	rax
    mov       [rdi+4],	esi
    mov       rax,	rdi
    jmp       L8848
L8856:
    mov       rcx,	rdi
    call      mm_parse.readassignment
    mov       rcx,	28
    mov       rdx,	rbx
    mov       r8,	rax
    call      mm_lib.createunit2
    mov       rdi,	rax
    jmp       L8853
L8854:
    mov       rcx,	rbx
    call      mm_parse.readassignment
    mov       rdi,	rax
    mov       [rdi+4],	esi
L8853:
    jmp       L8858
L8857:
    call      mm_lex.lex
    xor       ecx,	ecx
    call      mm_parse.readassignment
    mov       rcx,	32
    mov       rdx,	rax
    mov       r8,	rdi
    call      mm_lib.createunit2
    mov       rdi,	rax
L8858:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	8
    jz        L8857
    mov       rax,	rdi
L8848:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readassignment
mm_parse.readassignment:
;?>>
   %define R.pt r13
   %define R.p rdi
   %define R.pos rbx
   %define R.opc rsi
   %define R.q r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r13,	rcx
;---------------
    mov       rcx,	r13
    call      mm_parse.readorterms
    mov       rdi,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    mov       rsi,	rax
    cmp       rax,	6
    jnz       L8862
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       rbx,	rax
    call      mm_lex.lex
    xor       ecx,	ecx
    call      mm_parse.readassignment
    mov       r12,	rax
    mov       rcx,	28
    mov       rdx,	rdi
    mov       r8,	r12
    call      mm_lib.createunit2
    mov       rdi,	rax
    mov       [rdi+4],	ebx
L8862:
    mov       rax,	rdi
L8860:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readorterms
mm_parse.readorterms:
;?>>
   %define R.pt rsi
   %define R.p rdi
   %define R.pos rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    mov       rcx,	rsi
    call      mm_parse.readandterms
    mov       rdi,	rax
    jmp       L8865
L8864:
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       rbx,	rax
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	6
    jnz       L8868
    lea       rcx,	[L13437]
    call      mm_support.serror
L8868:
    xor       ecx,	ecx
    call      mm_parse.readandterms
    mov       rcx,	16
    mov       rdx,	rdi
    mov       r8,	rax
    call      mm_lib.createunit2
    mov       rdi,	rax
    mov       [rdi+4],	ebx
L8865:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	39
    jz        L8864
    mov       rax,	rdi
L8863:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readandterms
mm_parse.readandterms:
;?>>
   %define R.pt rsi
   %define R.p rdi
   %define R.pos rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    mov       rcx,	rsi
    call      mm_parse.readcmpterms
    mov       rdi,	rax
    jmp       L8871
L8870:
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       rbx,	rax
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	6
    jnz       L8874
    lea       rcx,	[L13438]
    call      mm_support.serror
L8874:
    xor       ecx,	ecx
    call      mm_parse.readcmpterms
    mov       rcx,	15
    mov       rdx,	rdi
    mov       r8,	rax
    call      mm_lib.createunit2
    mov       rdi,	rax
    mov       [rdi+4],	ebx
L8871:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	38
    jz        L8870
    mov       rax,	rdi
L8869:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readcmpterms
mm_parse.readcmpterms:
;?>>
   %define R.pt r13
   %define R.p rdi
   %define R.pos rbx
   %define R.n rsi
    %define mm_parse.readcmpterms.ulist -8
    %define mm_parse.readcmpterms.ulistx -16
   %define R.q r12
    %define mm_parse.readcmpterms.genops -24
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
    mov       r13,	rcx
;---------------
    mov       rcx,	r13
    call      mm_parse.readinterms
    mov       rdi,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	41
    jz        L8877
    cmp       rax,	42
    jz        L8877
    mov       rax,	rdi
    jmp       L8875
L8877:
    mov       rax,	rdi
    mov       [rbp + mm_parse.readcmpterms.ulistx],	rax
    mov       [rbp + mm_parse.readcmpterms.ulist],	rax
    mov       rcx,	34
    mov       rdx,	rdi
    call      mm_lib.createunit1
    mov       rdi,	rax
    xor       rsi,	rsi
    lea       rax,	[rbp + mm_parse.readcmpterms.genops]
    xor       r10d,	r10d
    mov       [rax],	r10d
L8878:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	41
    jz        L8880
    cmp       rax,	42
    jnz       L8881
L8880:
    inc       rsi
    cmp       rsi,	4
    jle       L8883
    lea       rcx,	[L13439]
    call      mm_support.serror
L8883:
    lea       rax,	[mm_decls.lx]
    mov       al,	[rax+1]
    mov       [rbp + rsi + mm_parse.readcmpterms.genops-1],	al
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       rbx,	rax
    call      mm_lex.lex
    xor       ecx,	ecx
    call      mm_parse.readinterms
    mov       r12,	rax
    lea       rcx,	[rbp + mm_parse.readcmpterms.ulist]
    lea       rdx,	[rbp + mm_parse.readcmpterms.ulistx]
    mov       r8,	r12
    call      mm_lib.addlistunit
    mov       [r12+4],	ebx
    jmp       L8878
L8881:
    jmp       L8879
L8879:
    cmp       rsi,	1
    jnz       L8885
    mov       al,	33
    mov       [rdi],	al
    mov       r12,	[rdi+16]
    mov       al,	[rbp + mm_parse.readcmpterms.genops]
    mov       [rdi+64],	al
    mov       rax,	[r12+8]
    mov       [rdi+24],	rax
    xor       eax,	eax
    mov       [r12+8],	rax
    jmp       L8884
L8885:
    mov       eax,	[rbp + mm_parse.readcmpterms.genops]
    mov       [rdi+40],	eax
L8884:
    mov       rax,	rdi
L8875:
;---------------
    add       rsp,	56
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readinterms
mm_parse.readinterms:
;?>>
   %define R.pt r12
   %define R.p rdi
   %define R.pos rbx
   %define R.opc rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       r12,	rcx
;---------------
    mov       rcx,	r12
    call      mm_parse.readrangeterm
    mov       rdi,	rax
L8887:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	44
    jz        L8889
    cmp       rax,	45
    jnz       L8890
L8889:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    mov       rsi,	rax
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       rbx,	rax
    call      mm_lex.lex
    xor       ecx,	ecx
    call      mm_parse.readrangeterm
    mov       rcx,	41
    mov       rdx,	rdi
    mov       r8,	rax
    call      mm_lib.createunit2
    mov       rdi,	rax
    mov       [rdi+62],	sil
    mov       [rdi+4],	ebx
    jmp       L8887
L8890:
    jmp       L8888
L8888:
    mov       rax,	rdi
L8886:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readrangeterm
mm_parse.readrangeterm:
;?>>
   %define R.pt rsi
   %define R.p rdi
   %define R.pos rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    mov       rcx,	rsi
    call      mm_parse.readaddterms
    mov       rdi,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	21
    jnz       L8893
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       rbx,	rax
    call      mm_lex.lex
    xor       ecx,	ecx
    call      mm_parse.readaddterms
    mov       rcx,	21
    mov       rdx,	rdi
    mov       r8,	rax
    call      mm_lib.createunit2
    mov       rdi,	rax
    mov       [rdi+4],	ebx
L8893:
    mov       rax,	rdi
L8891:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readaddterms
mm_parse.readaddterms:
;?>>
   %define R.pt r13
   %define R.p rdi
   %define R.pos rbx
   %define R.sym rsi
   %define R.genop r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r13,	rcx
;---------------
    mov       rcx,	r13
    call      mm_parse.readmulterms
    mov       rdi,	rax
L8895:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    mov       rsi,	rax
    cmp       rax,	24
    jz        L8897
    cmp       rax,	25
    jz        L8897
    cmp       rax,	31
    jz        L8897
    cmp       rax,	32
    jz        L8897
    cmp       rax,	33
    jz        L8897
    cmp       rax,	36
    jz        L8897
    cmp       rax,	37
    jnz       L8898
L8897:
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       rbx,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    mov       r12,	rax
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	6
    jnz       L8900
    call      mm_lex.lex
    xor       ecx,	ecx
    call      mm_parse.readassignment
    mov       rcx,	38
    mov       rdx,	rdi
    mov       r8,	rax
    call      mm_lib.createunit2
    mov       rdi,	rax
    lea       rax,	[mm_tables.symbolgentoops]
    mov       r10,	rsi
    mov       al,	[rax + r10-1]
    mov       [rdi+62],	al
    mov       [rdi+4],	ebx
    jmp       L8896
L8900:
    xor       ecx,	ecx
    call      mm_parse.readmulterms
    mov       rcx,	35
    mov       rdx,	rdi
    mov       r8,	rax
    call      mm_lib.createunit2
    mov       rdi,	rax
    lea       rax,	[mm_tables.symbolgenops]
    mov       r10,	rsi
    mov       al,	[rax + r10-1]
    mov       [rdi+62],	al
    mov       [rdi+4],	ebx
    jmp       L8895
L8898:
    jmp       L8896
L8896:
    mov       rax,	rdi
L8894:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readmulterms
mm_parse.readmulterms:
;?>>
   %define R.pt r12
   %define R.p rdi
   %define R.pos rbx
   %define R.sym rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       r12,	rcx
;---------------
    mov       rcx,	r12
    call      mm_parse.readpowerterms
    mov       rdi,	rax
L8902:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    mov       rsi,	rax
    cmp       rax,	26
    jz        L8904
    cmp       rax,	27
    jz        L8904
    cmp       rax,	28
    jz        L8904
    cmp       rax,	29
    jz        L8904
    cmp       rax,	34
    jz        L8904
    cmp       rax,	35
    jz        L8904
    cmp       rax,	30
    jnz       L8905
L8904:
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       rbx,	rax
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	6
    jnz       L8907
    call      mm_lex.lex
    xor       ecx,	ecx
    call      mm_parse.readassignment
    mov       rcx,	38
    mov       rdx,	rdi
    mov       r8,	rax
    call      mm_lib.createunit2
    mov       rdi,	rax
    lea       rax,	[mm_tables.symbolgentoops]
    mov       r10,	rsi
    mov       al,	[rax + r10-1]
    mov       [rdi+62],	al
    mov       [rdi+4],	ebx
    jmp       L8903
L8907:
    xor       ecx,	ecx
    call      mm_parse.readpowerterms
    mov       rcx,	35
    mov       rdx,	rdi
    mov       r8,	rax
    call      mm_lib.createunit2
    mov       rdi,	rax
    lea       rax,	[mm_tables.symbolgenops]
    mov       r10,	rsi
    mov       al,	[rax + r10-1]
    mov       [rdi+62],	al
    mov       [rdi+4],	ebx
    jmp       L8902
L8905:
    jmp       L8903
L8903:
    mov       rax,	rdi
L8901:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readpowerterms
mm_parse.readpowerterms:
;?>>
   %define R.p rbx
   %define R.pos rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    test      rbx,	rbx
    jnz       L8910
    call      mm_parse.readterm2
    mov       rbx,	rax
L8910:
    jmp       L8912
L8911:
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       rdi,	rax
    call      mm_lex.lex
    xor       ecx,	ecx
    call      mm_parse.readpowerterms
    mov       rcx,	35
    mov       rdx,	rbx
    mov       r8,	rax
    call      mm_lib.createunit2
    mov       rbx,	rax
    mov       al,	82
    mov       [rbx+62],	al
    mov       [rbx+4],	edi
L8912:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	43
    jz        L8911
    mov       rax,	rbx
L8908:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readterm2
mm_parse.readterm2:
;?>>
   %define R.p rdi
   %define R.q rbx
   %define R.opc rsi
   %define R.oldinrp r12
   %define R.pos r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
;---------------
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       r13,	rax
    call      mm_parse.readterm
    mov       rdi,	rax
L8915:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	9
    jz        L8917
    cmp       rax,	15
    jz        L8918
    cmp       rax,	11
    jz        L8919
    cmp       rax,	1
    jz        L8920
    cmp       rax,	5
    jz        L8921
    cmp       rax,	61
    jz        L8922
    cmp       rax,	13
    jz        L8923
    jmp       L8924
L8917:
    call      mm_lex.lex
    mov       r12,	[mm_parse.inreadprint]
    xor       eax,	eax
    mov       [mm_parse.inreadprint],	rax
    mov       rcx,	1
    mov       rdx,	1
    call      mm_parse.readslist
    mov       rbx,	rax
    mov       rcx,	10
    call      mm_parse.checksymbollex
    movzx     rax,	byte [rdi]
    cmp       rax,	90
    jnz       L8926
    mov       [rdi+16],	rbx
    jmp       L8925
L8926:
    mov       rcx,	32
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_lib.createunit2
    mov       rdi,	rax
L8925:
    mov       [mm_parse.inreadprint],	r12
    mov       rcx,	rdi
    call      mm_parse.readcondsuffix
    mov       rdi,	rax
    jmp       L8915
L8918:
    mov       rcx,	53
    mov       rdx,	rdi
    call      mm_lib.createunit1
    mov       rdi,	rax
    call      mm_lex.lex
    jmp       L8915
L8919:
    mov       rcx,	rdi
    xor       edx,	edx
    call      mm_parse.readindex
    mov       rdi,	rax
    jmp       L8915
L8920:
    mov       rcx,	rdi
    call      mm_parse.readdotsuffix
    mov       rdi,	rax
    jmp       L8915
L8921:
    mov       rax,	[mm_parse.inreadprint]
    test      rax,	rax
    jnz       L8916
L8928:
    call      mm_lex.lex
    call      mm_parse.readunit
    mov       rbx,	rax
    mov       rax,	[mm_parse.inparamlist]
    test      rax,	rax
    jz        L8930
    mov       rax,	26
    jmp       L8929
L8930:
    mov       rax,	27
L8929:
    mov       rcx,	rax
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_lib.createunit2
    mov       rdi,	rax
    jmp       L8915
L8922:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    cmp       rax,	84
    jz        L8932
    cmp       rax,	85
    jz        L8933
    jmp       L8934
L8932:
    mov       rsi,	88
    jmp       L8931
L8933:
    mov       rsi,	89
L8934:
L8931:
    call      mm_lex.lex
    mov       rcx,	40
    mov       rdx,	rdi
    call      mm_lib.createunit1
    mov       rdi,	rax
    mov       [rdi+62],	sil
    jmp       L8915
L8923:
    lea       rcx,	[L13440]
    call      mm_support.serror
    jmp       L8915
L8924:
    jmp       L8916
L8916:
    mov       [rdi+4],	r13d
    mov       rax,	rdi
L8914:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readterm
mm_parse.readterm:
;?>>
   %define R.p rdi
   %define R.q rbx
   %define R.r rsi
    %define mm_parse.readterm.a -8
   %define R.opc r12
   %define R.pos r13
   %define R.length r14
   %define R.strtype r15b
    %define mm_parse.readterm.s -16
    %define mm_parse.readterm.cstr -272
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	312
;---------------
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       r13,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    sub       rax,	2
    cmp       rax,	135
    jae       L8938
    lea       r10,	[L8937]
    jmp       [r10 + rax*8]
    segment .data
L8937:
    dq  L8965
    dq  L8938
    dq  L8938
    dq  L8938
    dq  L8938
    dq  L8938
    dq  L8938
    dq  L8949
    dq  L8938
    dq  L8958
    dq  L8938
    dq  L9003
    dq  L8938
    dq  L8938
    dq  L8938
    dq  L8938
    dq  L8938
    dq  L8960
    dq  L8960
    dq  L8938
    dq  L8938
    dq  L8938
    dq  L8951
    dq  L8951
    dq  L8938
    dq  L8938
    dq  L8938
    dq  L8938
    dq  L8938
    dq  L8951
    dq  L8951
    dq  L8951
    dq  L8938
    dq  L8938
    dq  L8951
    dq  L8951
    dq  L8938
    dq  L8938
    dq  L8938
    dq  L8938
    dq  L8938
    dq  L8938
    dq  L8938
    dq  L8938
    dq  L8938
    dq  L8952
    dq  L8955
    dq  L8951
    dq  L8951
    dq  L8951
    dq  L8951
    dq  L8951
    dq  L8938
    dq  L8951
    dq  L8951
    dq  L8938
    dq  L8938
    dq  L8938
    dq  L8938
    dq  L8959
    dq  L8942
    dq  L8942
    dq  L8944
    dq  L8943
    dq  L8938
    dq  L8939
    dq  L8938
    dq  L9001
    dq  L8938
    dq  L8938
    dq  L8938
    dq  L8938
    dq  L8938
    dq  L8938
    dq  L8938
    dq  L8938
    dq  L8938
    dq  L8950
    dq  L8950
    dq  L8981
    dq  L8938
    dq  L8938
    dq  L8938
    dq  L8938
    dq  L8938
    dq  L8938
    dq  L8982
    dq  L8983
    dq  L8983
    dq  L8984
    dq  L8938
    dq  L8985
    dq  L8986
    dq  L8938
    dq  L8987
    dq  L8988
    dq  L8989
    dq  L8938
    dq  L8991
    dq  L8992
    dq  L8990
    dq  L8980
    dq  L8983
    dq  L8983
    dq  L8993
    dq  L8994
    dq  L8938
    dq  L8938
    dq  L8938
    dq  L8938
    dq  L8938
    dq  L8938
    dq  L8938
    dq  L8938
    dq  L8938
    dq  L8950
    dq  L8938
    dq  L8938
    dq  L8938
    dq  L9004
    dq  L8938
    dq  L8938
    dq  L9002
    dq  L8938
    dq  L8938
    dq  L8938
    dq  L8976
    dq  L8966
    dq  L8967
    dq  L8996
    dq  L8938
    dq  L8977
    dq  L8995
    dq  L8997
    dq  L9000
    segment .text
L8939:
    lea       rax,	[mm_decls.nextlx]
    movzx     rax,	byte [rax]
    cmp       rax,	17
    jnz       L8941
    call      mm_parse.readcast
    mov       rdi,	rax
    jmp       L8940
L8941:
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       rcx,	rax
    call      mm_lib.createname
    mov       rdi,	rax
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       [rdi+4],	eax
    call      mm_lex.lex
L8940:
    jmp       L8936
L8942:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    lea       r10,	[mm_decls.lx]
    mov       r10,	[r10+8]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mm_lib.createconstunit
    mov       rdi,	rax
    call      mm_lex.lex
    jmp       L8936
L8943:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	word [rax+2]
    lea       r10,	[mm_decls.lx]
    mov       r10,	[r10+8]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mm_lib.createstringconstunit
    mov       rdi,	rax
    lea       rax,	[mm_decls.lx]
    mov       al,	[rax+1]
    mov       [rdi+45],	al
    call      mm_lex.lex
    jmp       L8936
L8944:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	word [rax+2]
    dec       rax
    mov       r14,	rax
    cmp       r14,	8
    jle       L8946
    lea       rcx,	[L13441]
    call      mm_support.serror
L8946:
    xor       eax,	eax
    mov       [rbp + mm_parse.readterm.a],	rax
    test      r14,	r14
    jz        L8948
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    lea       rcx,	[rbp + mm_parse.readterm.a]
    mov       rdx,	rax
    mov       r8,	r14
    call      memcpy
L8948:
    mov       rcx,	[rbp + mm_parse.readterm.a]
    mov       rdx,	5
    call      mm_lib.createconstunit
    mov       rdi,	rax
    call      mm_lex.lex
    jmp       L8936
L8949:
    call      mm_parse.readlbrack
    mov       rdi,	rax
    jmp       L8936
L8950:
    call      mm_parse.readcast
    mov       rdi,	rax
    jmp       L8936
L8951:
    call      mm_parse.readopc
    mov       rdi,	rax
    jmp       L8936
L8952:
    lea       rax,	[mm_decls.nextlx]
    movzx     rax,	byte [rax]
    cmp       rax,	6
    jnz       L8954
    call      mm_parse.readopc
    mov       rdi,	rax
    jmp       L8953
L8954:
    call      mm_lex.lex
    call      mm_parse.readterm2
    mov       rcx,	17
    mov       rdx,	rax
    call      mm_lib.createunit1
    mov       rdi,	rax
    mov       al,	63
    mov       [rdi+62],	al
L8953:
    jmp       L8936
L8955:
    lea       rax,	[mm_decls.nextlx]
    movzx     rax,	byte [rax]
    cmp       rax,	6
    jnz       L8957
    call      mm_parse.readopc
    mov       rdi,	rax
    jmp       L8956
L8957:
    call      mm_lex.lex
    call      mm_parse.readterm2
    mov       rcx,	18
    mov       rdx,	rax
    call      mm_lib.createunit1
    mov       rdi,	rax
L8956:
    jmp       L8936
L8958:
    call      mm_parse.readset
    mov       rdi,	rax
    jmp       L8936
L8959:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    mov       r12,	rax
    call      mm_lex.lex
    call      mm_parse.readterm2
    mov       rcx,	40
    mov       rdx,	rax
    call      mm_lib.createunit1
    mov       rdi,	rax
    mov       [rdi+62],	r12b
    jmp       L8936
L8960:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    mov       r12,	rax
    call      mm_lex.lex
    call      mm_parse.readterm2
    mov       rcx,	r12
    mov       rdx,	rax
    call      mm_lib.createunit1
    mov       rdi,	rax
    mov       rax,	[rdi+16]
    movzx     rax,	byte [rax]
    cmp       rax,	32
    jnz       L8962
    mov       rax,	[rdi+16]
    mov       rax,	[rax+24]
    test      rax,	rax
    jz        L8964
    lea       rcx,	[L13442]
    call      mm_support.serror
L8964:
    mov       rax,	[rdi+16]
    mov       rax,	[rax+16]
    mov       [rdi+16],	rax
L8962:
    jmp       L8936
L8965:
    call      mm_lex.lex
    call      mm_parse.readterm2
    mov       rcx,	56
    mov       rdx,	rax
    call      mm_lib.createunit1
    mov       rdi,	rax
    jmp       L8936
L8966:
    call      mm_parse.readcompilervar
    mov       rdi,	rax
    jmp       L8936
L8967:
    mov       rax,	[mm_parse.intabledata]
    test      rax,	rax
    jz        L8969
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    cmp       rax,	1
    jnz       L8971
    xor       eax,	eax
    mov       [rbp + mm_parse.readterm.cstr],	rax
    lea       rcx,	[rbp + mm_parse.readterm.cstr]
    mov       rdx,	[mm_parse.tabledataname]
    call      strcpy
    mov       rax,	[rbp + mm_parse.readterm.cstr]
    mov       rcx,	rax
    mov       rdx,	4
    call      mm_lib.createconstunit
    mov       rdi,	rax
    jmp       L8970
L8971:
    mov       rax,	[mm_parse.tabledataname]
    mov       [rbp + mm_parse.readterm.s],	rax
    lea       rax,	[mm_decls.nextlx]
    movzx     rax,	byte [rax]
    cmp       rax,	24
    jnz       L8973
    call      mm_lex.lex
    call      mm_lex.lex
    mov       rcx,	62
    call      mm_parse.checksymbol
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    add       [rbp + mm_parse.readterm.s],	rax
L8973:
    mov       rcx,	[rbp + mm_parse.readterm.s]
    mov       rdx,	-1
    call      mm_lib.createstringconstunit
    mov       rdi,	rax
L8970:
    jmp       L8968
L8969:
    mov       rax,	[mm_parse.ndollar]
    cmp       rax,	0
    jg        L8975
    lea       rcx,	[L13443]
    call      mm_support.serror
L8975:
    lea       rax,	[mm_parse.dollarstack]
    mov       r10,	[mm_parse.ndollar]
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	36
    mov       rdx,	rax
    call      mm_lib.createunit1
    mov       rdi,	rax
    mov       al,	4
    mov       [rdi+62],	al
L8968:
    call      mm_lex.lex
    jmp       L8936
L8976:
    call      mm_parse.readcastx
    mov       rdi,	rax
    jmp       L8936
L8977:
    mov       rcx,	9
    call      mm_parse.lexchecksymbol
    call      mm_lex.lex
    call      mm_parse.readunit
    mov       rdi,	rax
    mov       rcx,	3
    call      mm_parse.checksymbollex
    call      mm_parse.readunit
    mov       rbx,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	10
    jnz       L8979
    movzx     rax,	byte [rbx]
    cmp       rax,	21
    jnz       L8979
    mov       rsi,	[rbx+24]
    mov       rbx,	[rbx+16]
    jmp       L8978
L8979:
    mov       rcx,	3
    call      mm_parse.checksymbollex
    call      mm_parse.readunit
    mov       rsi,	rax
    mov       rcx,	10
    call      mm_parse.checksymbol
L8978:
    call      mm_lex.lex
    mov       rcx,	35
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_lib.createunit2
    mov       rbx,	rax
    mov       al,	56
    mov       [rbx+62],	al
    mov       rcx,	35
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mm_lib.createunit2
    mov       rdi,	rax
    mov       al,	55
    mov       [rdi+62],	al
    jmp       L8936
L8980:
    mov       rcx,	99
    call      mm_parse.readgoto
    mov       rdi,	rax
    jmp       L8936
L8981:
    call      mm_parse.readif
    mov       rdi,	rax
    jmp       L8936
L8982:
    call      mm_parse.readunless
    mov       rdi,	rax
    jmp       L8936
L8983:
    call      mm_parse.readswitchcase
    mov       rdi,	rax
    jmp       L8936
L8984:
    call      mm_parse.readrecase
    mov       rdi,	rax
    jmp       L8936
L8985:
    call      mm_parse.readfor
    mov       rdi,	rax
    jmp       L8936
L8986:
    call      mm_parse.readto
    mov       rdi,	rax
    jmp       L8936
L8987:
    call      mm_parse.readdo
    mov       rdi,	rax
    jmp       L8936
L8988:
    call      mm_parse.readwhile
    mov       rdi,	rax
    jmp       L8936
L8989:
    call      mm_parse.readrepeat
    mov       rdi,	rax
    jmp       L8936
L8990:
    call      mm_parse.readloopcontrol
    mov       rdi,	rax
    jmp       L8936
L8991:
    call      mm_parse.readreturn
    mov       rdi,	rax
    jmp       L8936
L8992:
    call      mm_parse.readstop
    mov       rdi,	rax
    jmp       L8936
L8993:
    call      mm_parse.readprint
    mov       rdi,	rax
    jmp       L8936
L8994:
    call      mm_parse.readread
    mov       rdi,	rax
    jmp       L8936
L8995:
    mov       rcx,	9
    call      mm_parse.lexchecksymbol
    call      mm_lex.lex
    call      mm_parse.readunit
    mov       rdi,	rax
    mov       rcx,	3
    call      mm_parse.checksymbollex
    call      mm_parse.readunit
    mov       rbx,	rax
    mov       rcx,	10
    call      mm_parse.checksymbollex
    mov       rcx,	111
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_lib.createunit2
    mov       rdi,	rax
    jmp       L8936
L8996:
    call      mm_lex.lex
    call      mm_parse.readunit
    mov       rcx,	121
    mov       rdx,	rax
    call      mm_lib.createunit1
    mov       rdi,	rax
    jmp       L8936
L8997:
    mov       al,	1
    mov       r10,	[mm_decls.currproc]
    mov       [r10+120],	al
    mov       rax,	1
    mov       [mm_decls.assemmode],	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    test      rax,	rax
    jnz       L8999
    call      mm_assem.readassemline
    mov       rdi,	rax
    jmp       L8998
L8999:
    call      mm_assem.readassemblock
    mov       rdi,	rax
L8998:
    xor       eax,	eax
    mov       [mm_decls.assemmode],	rax
    jmp       L8936
L9000:
    mov       rcx,	90
    call      mm_lib.createunit0
    mov       rdi,	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax+1]
    mov       [rdi+40],	ax
    call      mm_lex.lex
    jmp       L8936
L9001:
    lea       rax,	[mm_decls.lx]
    mov       r15b,	[rax+1]
    call      mm_lex.lex
    call      mm_parse.readterm2
    mov       rcx,	13
    mov       rdx,	rax
    call      mm_lib.createunit1
    mov       rdi,	rax
    mov       [rdi+45],	r15b
    jmp       L8936
L9002:
    call      mm_lex.lex
    call      mm_parse.readterm2
    mov       rcx,	122
    mov       rdx,	rax
    call      mm_lib.createunit1
    mov       rdi,	rax
    jmp       L8936
L9003:
    lea       rcx,	[L13444]
    call      mm_support.serror
    jmp       L8936
L9004:
    mov       rcx,	9
    call      mm_parse.lexchecksymbol
    call      mm_lex.lex
    call      mm_parse.readunit
    mov       rdi,	rax
    mov       rcx,	3
    call      mm_parse.checksymbollex
    call      mm_parse.readunit
    mov       rbx,	rax
    mov       rcx,	10
    call      mm_parse.checksymbollex
    mov       rcx,	24
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_lib.createunit2
    mov       rdi,	rax
    jmp       L8936
L8938:
;mm_parse.readterm.doelse:
    call      msys.m$print_startcon
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    lea       r10,	[mm_tables.symbolnames]
    mov       r10,	[r10 + rax*8-8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    lea       rcx,	[L13445]
    call      msys.m$print_str_nf
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      mm_parse.istypestarter
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L13446]
    call      mm_support.serror
L8936:
    mov       [rdi+4],	r13d
    mov       rax,	rdi
L8935:
;---------------
    add       rsp,	312
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readmacrodef
mm_parse.readmacrodef:
;?>>
   %define R.owner r12
   %define R.scope r13
   %define R.nameptr rdi
   %define R.stmacro rbx
    %define mm_parse.readmacrodef.paramlist -8
    %define mm_parse.readmacrodef.paramlistx -16
   %define R.stname rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
    mov       r12,	rcx
    mov       r13,	rdx
;---------------
    mov       rcx,	67
    call      mm_parse.lexchecksymbol
    lea       rax,	[mm_decls.lx]
    mov       rdi,	[rax+8]
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	15
    call      mm_lib.getduplnameptr
    mov       rbx,	rax
    mov       rcx,	r12
    mov       rdx,	rbx
    call      mm_lib.adddef
    mov       r12,	rbx
    call      mm_lex.lex
    xor       eax,	eax
    mov       [rbp + mm_parse.readmacrodef.paramlistx],	rax
    mov       [rbp + mm_parse.readmacrodef.paramlist],	rax
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	9
    jnz       L9008
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	10
    jz        L9010
L9011:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	67
    jnz       L9015
L9014:
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       rcx,	r12
    mov       rdx,	rax
    mov       r8,	16
    call      mm_lib.getduplnameptr
    mov       rsi,	rax
    mov       rcx,	r12
    mov       rdx,	rsi
    call      mm_lib.adddef
    lea       rcx,	[rbp + mm_parse.readmacrodef.paramlist]
    lea       rdx,	[rbp + mm_parse.readmacrodef.paramlistx]
    mov       r8,	rsi
    call      mm_parse.addlistparam
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	10
    jz        L9012
L9017:
    mov       rcx,	3
    call      mm_parse.checksymbollex
    jmp       L9013
L9015:
    lea       rcx,	[L13447]
    call      mm_support.serror
L9013:
    jmp       L9011
L9012:
L9010:
    call      mm_lex.lex
L9008:
    mov       rax,	[rbp + mm_parse.readmacrodef.paramlist]
    mov       [rbx+112],	rax
    mov       [rbx+170],	r13b
    call      mm_parse.checkequals
    call      mm_lex.lex
    call      mm_parse.readunit
    mov       [rbx+64],	rax
;---------------
    add       rsp,	56
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readrecase
mm_parse.readrecase:
;?>>
;?]]
    sub       rsp,	40
;---------------
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	84
    jnz       L9020
    call      mm_lex.lex
    mov       rcx,	113
    call      mm_lib.createunit0
    jmp       L9019
L9020:
    call      mm_parse.readunit
    mov       rcx,	113
    mov       rdx,	rax
    call      mm_lib.createunit1
L9019:
L9018:
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mm_parse.fixcond
mm_parse.fixcond:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      mm_parse.checknotempty
    movzx     rax,	byte [rdi]
    lea       r10,	[mm_tables.isbooltag]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jnz       L9023
    mov       rcx,	rdi
    mov       rdx,	18
    call      mm_lib.insertunit
L9023:
    mov       rax,	rdi
L9021:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_parse.readsunit
mm_parse.readsunit:
;?>>
    %define mm_parse.readsunit.inwhile 64
   %define R.pos rdi
   %define R.sym rbx
   %define R.opc rsi
    %define mm_parse.readsunit.ulist -8
    %define mm_parse.readsunit.ulistx -16
   %define R.p r12
   %define R.q r13
   %define R.r r14
    %define mm_parse.readsunit.stname -24
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+64],	rcx
;---------------
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       rdi,	rax
    xor       eax,	eax
    mov       [rbp + mm_parse.readsunit.ulistx],	rax
    mov       [rbp + mm_parse.readsunit.ulist],	rax
L9025:
    jmp       L9029
L9028:
    call      mm_lex.lex
L9029:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	4
    jz        L9028
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    sub       rax,	4
    cmp       rax,	129
    jae       L9033
    lea       r10,	[L9032]
    jmp       [r10 + rax*8]
    segment .data
L9032:
    dq  L9064
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9055
    dq  L9039
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9065
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9054
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9056
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9039
    dq  L9039
    dq  L9033
    dq  L9055
    dq  L9055
    dq  L9055
    dq  L9055
    dq  L9055
    dq  L9055
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9055
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9061
    dq  L9033
    dq  L9033
    dq  L9055
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9038
    dq  L9038
    dq  L9033
    dq  L9051
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9049
    dq  L9039
    dq  L9033
    dq  L9045
    dq  L9045
    dq  L9039
    dq  L9052
    dq  L9050
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9034
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9033
    dq  L9053
    segment .text
L9034:
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	120
    jz        L9037
    cmp       rax,	119
    jnz       L9036
L9037:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    mov       rsi,	rax
    call      mm_lex.lex
    jmp       L9035
L9036:
    xor       rsi,	rsi
L9035:
    sub       rsp,	8
    mov       rax,	rsi
    push      rax
    mov       rcx,	[mm_decls.currproc]
    xor       edx,	edx
    mov       r8,	1
    mov       r9,	10
    sub       rsp,	32
    call      mm_parse.readvardef
    add       rsp,	48
    jmp       L9031
L9038:
    mov       rcx,	[mm_decls.currproc]
    xor       edx,	edx
    call      mm_parse.readprocdef
    jmp       L9031
L9039:
    lea       rax,	[mm_decls.nextlx]
    movzx     rax,	byte [rax]
    cmp       rax,	9
    jz        L9042
    cmp       rax,	17
    jz        L9042
    cmp       rax,	1
    jnz       L9041
L9042:
    jmp       L9043
L9041:
    xor       rbx,	rbx
    jmp       L9044
L9040:
    jmp       L9031
L9045:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    mov       rbx,	rax
    call      mm_lex.lex
;mm_parse.readsunit.dovar:
L9044:
    sub       rsp,	8
    mov       rax,	rbx
    push      rax
    mov       rcx,	[mm_decls.currproc]
    xor       edx,	edx
    xor       r8d,	r8d
    mov       r9,	11
    sub       rsp,	32
    call      mm_parse.readvardef
    add       rsp,	48
    mov       r13,	rax
    jmp       L9047
L9046:
    mov       r14,	[r13+8]
    xor       eax,	eax
    mov       [r13+8],	rax
    lea       rcx,	[rbp + mm_parse.readsunit.ulist]
    lea       rdx,	[rbp + mm_parse.readsunit.ulistx]
    mov       r8,	r13
    call      mm_lib.addlistunit
    mov       r13,	r14
L9047:
    test      r13,	r13
    jnz       L9046
    jmp       L9031
L9049:
    mov       rcx,	[mm_decls.currproc]
    xor       edx,	edx
    call      mm_parse.readtypedef
    jmp       L9031
L9050:
    mov       rcx,	[mm_decls.currproc]
    xor       edx,	edx
    call      mm_parse.readconstdef
    jmp       L9031
L9051:
    mov       rcx,	[mm_decls.currproc]
    xor       edx,	edx
    call      mm_parse.readclassdef
    jmp       L9031
L9052:
    mov       rcx,	[mm_decls.currproc]
    xor       edx,	edx
    call      mm_parse.readmacrodef
    jmp       L9031
L9053:
    mov       rcx,	[mm_decls.currproc]
    xor       edx,	edx
    call      mm_parse.readtabledef
    jmp       L9031
L9054:
    call      msys.m$print_startcon
    mov       rax,	[mm_decls.currproc]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L13448]
    call      mm_support.serror
    jmp       L9031
L9055:
    jmp       L9027
L9056:
    lea       rax,	[mm_decls.nextlx]
    movzx     rax,	byte [rax]
    cmp       rax,	5
    jz        L9058
    cmp       rax,	67
    jz        L9059
    jmp       L9060
L9058:
    mov       rcx,	100
    call      mm_lib.createunit0
    mov       r12,	rax
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       rcx,	[mm_decls.currproc]
    mov       rdx,	rax
    mov       r8,	14
    call      mm_lib.getduplnameptr
    mov       [rbp + mm_parse.readsunit.stname],	rax
    mov       rcx,	[mm_decls.currproc]
    mov       rdx,	[rbp + mm_parse.readsunit.stname]
    call      mm_lib.adddef
    mov       rax,	[rbp + mm_parse.readsunit.stname]
    mov       [r12+16],	rax
    call      mm_lex.lex
    mov       al,	4
    lea       r10,	[mm_decls.lx]
    mov       [r10],	al
    lea       rcx,	[rbp + mm_parse.readsunit.ulist]
    lea       rdx,	[rbp + mm_parse.readsunit.ulistx]
    mov       r8,	r12
    call      mm_lib.addlistunit
    jmp       L9057
L9059:
    mov       rbx,	119
    jmp       L9044
    jmp       L9057
L9060:
    jmp       L9043
L9057:
    jmp       L9031
L9061:
    mov       rax,	[rbp + mm_parse.readsunit.inwhile]
    test      rax,	rax
    jnz       L9027
L9063:
    jmp       L9043
L9064:
    jmp       L9031
L9065:
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       rcx,	rax
    mov       rdx,	-1
    call      mm_lib.createstringconstunit
    mov       rcx,	14
    mov       rdx,	rax
    call      mm_lib.createunit1
    mov       r12,	rax
    mov       al,	4
    lea       r10,	[mm_decls.lx]
    mov       [r10],	al
    jmp       L9066
L9033:
;mm_parse.readsunit.doexec:
L9043:
    call      mm_parse.readunit
    mov       r12,	rax
;mm_parse.readsunit.doexec2:
    movzx     rax,	byte [r12]
    cmp       rax,	4
    jnz       L9069
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	67
    jnz       L9069
    lea       rcx,	[L13449]
    call      mm_support.serror
L9069:
;mm_parse.readsunit.doexec3:
L9066:
    lea       rcx,	[rbp + mm_parse.readsunit.ulist]
    lea       rdx,	[rbp + mm_parse.readsunit.ulistx]
    mov       r8,	r12
    call      mm_lib.addlistunit
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	96
    jz        L9027
L9071:
L9031:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	4
    jz        L9025
L9027:
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	10
    jz        L9073
    cmp       rax,	82
    jz        L9073
    cmp       rax,	83
    jz        L9073
    cmp       rax,	84
    jz        L9073
    cmp       rax,	99
    jz        L9073
    cmp       rax,	92
    jz        L9073
    cmp       rax,	96
    jz        L9073
    cmp       rax,	85
    jz        L9073
    cmp       rax,	86
    jz        L9073
    cmp       rax,	87
    jz        L9073
    cmp       rax,	3
    jz        L9073
    cmp       rax,	16
    jnz       L9074
L9073:
    jmp       L9072
L9074:
    lea       rcx,	[L13450]
    call      mm_support.serror
L9072:
    mov       rax,	[rbp + mm_parse.readsunit.ulist]
    test      rax,	rax
    jz        L9077
    mov       rax,	[rbp + mm_parse.readsunit.ulist]
    mov       rax,	[rax+8]
    test      rax,	rax
    jz        L9076
L9077:
    mov       rcx,	6
    mov       rdx,	[rbp + mm_parse.readsunit.ulist]
    call      mm_lib.createunit1
    jmp       L9075
L9076:
    mov       rax,	[rbp + mm_parse.readsunit.ulist]
L9075:
L9024:
;---------------
    add       rsp,	64
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.readbxdata
mm_parse.readbxdata:
;?>>
   %define R.p rdi
   %define R.curralloc rbx
   %define R.n rsi
   %define R.q r12
   %define R.r r13
   %define R.qnew r14
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
;---------------
    mov       rbx,	4
    xor       rsi,	rsi
    xor       eax,	eax
    mov       rdi,	rax
    mov       rcx,	rbx
    call      mlib.pcm_alloc
    mov       r13,	rax
    mov       r12,	rax
L9079:
    call      mm_lex.lex
    call      mm_parse.skipsemi
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	62
    jnz       L9080
L9082:
    cmp       rsi,	rbx
    jnz       L9084
    mov       rax,	rbx
    shl       rax,	1
    mov       rbx,	rax
    mov       rcx,	rbx
    call      mlib.pcm_alloc
    mov       r14,	rax
    mov       rcx,	r14
    mov       rdx,	r12
    mov       r8,	rsi
    call      memcpy
    mov       rax,	r13
    sub       rax,	r12
    lea       r10,	[r14 + rax]
    mov       r13,	r10
    mov       rcx,	r12
    mov       rdx,	rsi
    call      mlib.pcm_free
    mov       r12,	r14
L9084:
    lea       rax,	[mm_decls.lx]
    mov       rax,	[rax+8]
    mov       r10,	r13
    inc       r13
    mov       [r10],	al
    inc       rsi
    call      mm_lex.lex
    lea       rax,	[mm_decls.lx]
    movzx     rax,	byte [rax]
    cmp       rax,	3
    jnz       L9080
L9086:
    jmp       L9079
L9080:
    mov       rcx,	10
    call      mm_parse.checksymbol
    call      mm_lex.lex
    mov       rcx,	r12
    mov       rdx,	rsi
    call      mm_lib.createstringconstunit
    mov       rdi,	rax
    mov       al,	1
    mov       [rdi+45],	al
    mov       rax,	rdi
L9078:
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_parse.checknotempty
mm_parse.checknotempty:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    test      rdi,	rdi
    jz        L9090
    movzx     rax,	byte [rdi]
    cmp       rax,	6
    jnz       L9089
    mov       rax,	[rdi+16]
    test      rax,	rax
    jnz       L9089
L9090:
    lea       rcx,	[L13451]
    call      mm_support.serror
L9089:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_support.newsourcefile
mm_support.newsourcefile:
;?>>
   %define R.pf rdi
    push      rdi
;?]]
    sub       rsp,	48
;---------------
    mov       rcx,	68
    call      mlib.pcm_allocz
    mov       rdi,	rax
    mov       rax,	[mm_decls.nsourcefiles]
    cmp       rax,	300
    jl        L9093
    lea       rcx,	[L13452]
    lea       rdx,	[L13453]
    lea       r8,	[L13453]
    call      mm_support.loaderror
L9093:
    inc       qword [mm_decls.nsourcefiles]
    mov       rax,	[mm_decls.nsourcefiles]
    mov       r10,	rdi
    lea       r11,	[mm_decls.sources]
    mov       [r11 + rax*8],	r10
    mov       ax,	[mm_decls.nsourcefiles]
    mov       [rdi+64],	ax
    mov       rax,	rdi
L9091:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_support.mcerror
mm_support.mcerror:
;?>>
   %define R.mess rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    call      msys.m$print_startcon
    lea       rcx,	[L13454]
    call      msys.m$print_str_nf
    mov       rcx,	rdi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	1
    call      exit
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_support.serror_gen
mm_support.serror_gen:
;?>>
   %define R.mess rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	42
    call      mm_support.showdivider
    call      msys.m$print_startcon
    lea       rcx,	[L13455]
    call      msys.m$print_str_nf
    mov       rcx,	rdi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       rcx,	rax
    mov       rdx,	[mm_decls.currproc]
    call      mm_support.showerrorsource
    call      msys.m$print_startcon
    mov       rcx,	rdi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       rcx,	rax
    call      mm_support.getlineno
    lea       r10,	[mm_decls.lx]
    mov       r10d,	[r10+4]
    shr       r10,	24
    and       r10,	255
    lea       r11,	[mm_decls.sources]
    mov       r11,	[r11 + r10*8]
    mov       r11,	[r11+24]
    mov       rcx,	r11
    mov       rdx,	rax
    call      mm_support.stopcompiler
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_support.showdivider
mm_support.showdivider:
;?>>
   %define R.ch rbx
   %define R.av_1 rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rdi,	87
L9097:
    call      msys.m$print_startcon
    mov       rcx,	rbx
    xor       edx,	edx
    call      msys.m$print_c8
    call      msys.m$print_end
    dec       rdi
    jnz       L9097
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_support.showerrorsource
mm_support.showerrorsource:
;?>>
    %define mm_support.showerrorsource.pos 72
    %define mm_support.showerrorsource.stproc 80
   %define R.fileno rdi
   %define R.lineoffset rbx
   %define R.errorline rsi
   %define R.s r12
   %define R.av_1 r13
   %define R.av_2 r14
   %define R.av_3 r15
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       [rbp+72],	rcx
    mov       [rbp+80],	rdx
;---------------
    mov       rcx,	[rbp + mm_support.showerrorsource.pos]
    call      mm_support.getfileno
    mov       rdi,	rax
    call      msys.m$print_startcon
    lea       rcx,	[L13456]
    call      msys.m$print_setfmt
    mov       rcx,	[rbp + mm_support.showerrorsource.pos]
    call      mm_support.getlineno
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rax,	[rbp + mm_support.showerrorsource.stproc]
    test      rax,	rax
    jz        L9102
    mov       rax,	[rbp + mm_support.showerrorsource.stproc]
    movzx     rax,	byte [rax+78]
    cmp       rax,	6
    jnz       L9102
    call      msys.m$print_startcon
    lea       rcx,	[L13457]
    call      msys.m$print_setfmt
    mov       rax,	[rbp + mm_support.showerrorsource.stproc]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L9102:
    call      msys.m$print_startcon
    lea       rcx,	[L13458]
    call      msys.m$print_setfmt
    lea       rax,	[mm_decls.sources]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    lea       rax,	[mm_decls.sources]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8]
    mov       rcx,	[rax+24]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	45
    call      mm_support.showdivider
    mov       rcx,	[rbp + mm_support.showerrorsource.pos]
    call      mm_support.getsourceline
    mov       rsi,	rax
    mov       r12,	rax
    mov       rcx,	[rbp + mm_support.showerrorsource.pos]
    call      mm_support.getsourcepos
    sub       rax,	rsi
    mov       rbx,	rax
    mov       r13,	6
L9103:
    call      msys.m$print_startcon
    lea       rcx,	[L13459]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    dec       r13
    jnz       L9103
    jmp       L9107
L9106:
    call      msys.m$print_startcon
    mov       rax,	r12
    inc       r12
    movzx     rax,	byte [rax]
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.m$print_c8
    call      msys.m$print_end
L9107:
    movzx     rax,	byte [r12]
    cmp       rax,	10
    jz        L9109
    test      rax,	rax
    jnz       L9106
L9109:
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       r12,	rsi
    mov       r14,	6
L9110:
    call      msys.m$print_startcon
    lea       rcx,	[L13459]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    dec       r14
    jnz       L9110
    mov       r15,	rbx
    cmp       r15,	0
    jle       L9115
L9113:
    movzx     rax,	byte [r12]
    cmp       rax,	9
    jnz       L9117
    call      msys.m$print_startcon
    mov       rcx,	9
    xor       edx,	edx
    call      msys.m$print_c8
    call      msys.m$print_end
    jmp       L9116
L9117:
    call      msys.m$print_startcon
    mov       rcx,	32
    xor       edx,	edx
    call      msys.m$print_c8
    call      msys.m$print_end
L9116:
    inc       r12
    dec       r15
    jnz       L9113
L9115:
    call      msys.m$print_startcon
    lea       rcx,	[L13460]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	45
    call      mm_support.showdivider
;---------------
    add       rsp,	40
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_support.stopcompiler
mm_support.stopcompiler:
;?>>
   %define R.filename rbx
   %define R.lineno rsi
   %define R.f rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    lea       rcx,	[L13461]
    lea       rdx,	[L13462]
    call      fopen
    mov       rdi,	rax
    mov       rcx,	rdi
    call      msys.m$print_startfile
    mov       rcx,	rbx
    call      msys.m$print_str_nf
    mov       rcx,	rsi
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	rdi
    call      fclose
    call      msys.m$print_startcon
    lea       rcx,	[L13463]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      mwindows.os_getch
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	1
    call      exit
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_support.serror
mm_support.serror:
;?>>
   %define R.mess rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      mm_support.serror_gen
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_support.serror_s
mm_support.serror_s:
;?>>
   %define R.mess rdi
   %define R.a rbx
    %define mm_support.serror_s.str -256
    push      rdi
    push      rbx
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	288
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    lea       rcx,	[rbp + mm_support.serror_s.str]
    call      msys.m$print_startstr
    mov       rcx,	rdi
    call      msys.m$print_setfmt
    mov       rcx,	rbx
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       rcx,	[rbp + mm_support.serror_s.str]
    call      mm_support.serror_gen
;---------------
    add       rsp,	288
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_support.error_gen
mm_support.error_gen:
;?>>
   %define R.pass rbx
   %define R.mess rsi
   %define R.p r12
   %define R.pos rdi
    %define mm_support.error_gen.$T1 -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
;---------------
    test      r12,	r12
    jz        L9123
    call      msys.m$print_startcon
    lea       rcx,	[L13464]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       eax,	[r12+4]
    mov       rdi,	rax
    jmp       L9122
L9123:
    call      msys.m$print_startcon
    lea       rcx,	[L13465]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rdi,	[pc_decls.mmpos]
L9122:
    call      msys.m$print_startcon
    lea       rcx,	[L13466]
    call      msys.m$print_str_nf
    mov       rcx,	rdi
    call      mm_support.getfileno
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	42
    call      mm_support.showdivider
    mov       rax,	rbx
    cmp       rax,	78
    jz        L9125
    cmp       rax,	84
    jz        L9126
    cmp       rax,	71
    jz        L9127
    cmp       rax,	65
    jz        L9128
    jmp       L9129
L9125:
    call      msys.m$print_startcon
    lea       rcx,	[L13467]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L9124
L9126:
    call      msys.m$print_startcon
    lea       rcx,	[L13468]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L9124
L9127:
    call      msys.m$print_startcon
    lea       rcx,	[L13469]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L9124
L9128:
    call      msys.m$print_startcon
    lea       rcx,	[L13470]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L9129:
L9124:
    mov       rcx,	rdi
    mov       rdx,	[mm_decls.currproc]
    call      mm_support.showerrorsource
    call      msys.m$print_startcon
    mov       rcx,	rsi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	rdi
    call      mm_support.getlineno
    mov       [rbp + mm_support.error_gen.$T1],	rax
    mov       rcx,	rdi
    call      mm_support.getfileno
    lea       r10,	[mm_decls.sources]
    mov       r10,	[r10 + rax*8]
    mov       r10,	[r10+24]
    mov       rcx,	r10
    mov       rdx,	[rbp + mm_support.error_gen.$T1]
    call      mm_support.stopcompiler
;---------------
    add       rsp,	48
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_support.rxerror
mm_support.rxerror:
;?>>
   %define R.mess rdi
   %define R.p rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	78
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_support.error_gen
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_support.gerror
mm_support.gerror:
;?>>
   %define R.mess rdi
   %define R.p rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	71
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_support.error_gen
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_support.txerror
mm_support.txerror:
;?>>
   %define R.mess rdi
   %define R.p rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	84
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_support.error_gen
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_support.txerror_s
mm_support.txerror_s:
;?>>
   %define R.mess rdi
   %define R.a rbx
   %define R.p rsi
    %define mm_support.txerror_s.str -256
    push      rdi
    push      rbx
    push      rsi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	296
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    lea       rcx,	[rbp + mm_support.txerror_s.str]
    call      msys.m$print_startstr
    mov       rcx,	rdi
    call      msys.m$print_setfmt
    mov       rcx,	rbx
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       rcx,	84
    lea       rdx,	[rbp + mm_support.txerror_s.str]
    mov       r8,	rsi
    call      mm_support.error_gen
;---------------
    add       rsp,	296
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_support.txerror_ss
mm_support.txerror_ss:
;?>>
   %define R.mess rdi
   %define R.a rbx
   %define R.b rsi
    %define mm_support.txerror_ss.str -256
    push      rdi
    push      rbx
    push      rsi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	296
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    lea       rcx,	[rbp + mm_support.txerror_ss.str]
    call      msys.m$print_startstr
    mov       rcx,	rdi
    call      msys.m$print_setfmt
    mov       rcx,	rbx
    call      msys.m$print_str_nf
    mov       rcx,	rsi
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       rcx,	84
    lea       rdx,	[rbp + mm_support.txerror_ss.str]
    xor       r8d,	r8d
    call      mm_support.error_gen
;---------------
    add       rsp,	296
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_support.rxerror_s
mm_support.rxerror_s:
;?>>
   %define R.mess rdi
   %define R.a rbx
   %define R.p rsi
    %define mm_support.rxerror_s.str -256
    push      rdi
    push      rbx
    push      rsi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	296
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    lea       rcx,	[rbp + mm_support.rxerror_s.str]
    call      msys.m$print_startstr
    mov       rcx,	rdi
    call      msys.m$print_setfmt
    mov       rcx,	rbx
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       rcx,	78
    lea       rdx,	[rbp + mm_support.rxerror_s.str]
    mov       r8,	rsi
    call      mm_support.error_gen
;---------------
    add       rsp,	296
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_support.gerror_s
mm_support.gerror_s:
;?>>
   %define R.mess rdi
   %define R.s rbx
   %define R.p rsi
    %define mm_support.gerror_s.str -256
    push      rdi
    push      rbx
    push      rsi
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	296
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    lea       rcx,	[rbp + mm_support.gerror_s.str]
    call      msys.m$print_startstr
    mov       rcx,	rdi
    call      msys.m$print_setfmt
    mov       rcx,	rbx
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       rcx,	71
    lea       rdx,	[rbp + mm_support.gerror_s.str]
    mov       r8,	rsi
    call      mm_support.error_gen
;---------------
    add       rsp,	296
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_support.lxerror_gen
mm_support.lxerror_gen:
;?>>
   %define R.mess rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    call      msys.m$print_startcon
    lea       rcx,	[L13471]
    call      msys.m$print_str_nf
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       rcx,	rax
    call      mm_support.getlineno
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    lea       rcx,	[L13472]
    call      msys.m$print_str_nf
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    shr       rax,	24
    and       rax,	255
    lea       r10,	[mm_decls.sources]
    mov       r10,	[r10 + rax*8]
    mov       r10,	[r10+24]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       rcx,	[L13473]
    call      msys.m$print_str_nf
    mov       rcx,	rdi
    call      msys.m$print_str_nf
    lea       rcx,	[L13474]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rax,	[mm_decls.lx]
    mov       eax,	[rax+4]
    mov       rcx,	rax
    call      mm_support.getlineno
    lea       r10,	[mm_decls.lx]
    mov       r10d,	[r10+4]
    shr       r10,	24
    and       r10,	255
    lea       r11,	[mm_decls.sources]
    mov       r11,	[r11 + r10*8]
    mov       r11,	[r11+24]
    mov       rcx,	r11
    mov       rdx,	rax
    call      mm_support.stopcompiler
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_support.lxerror
mm_support.lxerror:
;?>>
   %define R.mess rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      mm_support.lxerror_gen
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_support.loaderror
mm_support.loaderror:
;?>>
   %define R.mess rdi
   %define R.mess2 rbx
   %define R.mess3 rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    call      msys.m$print_startcon
    lea       rcx,	[L13475]
    call      msys.m$print_str_nf
    mov       rcx,	rdi
    call      msys.m$print_str_nf
    mov       rcx,	rbx
    call      msys.m$print_str_nf
    mov       rcx,	rsi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       rcx,	[L13476]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	1
    call      exit
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_support.gs_additem
mm_support.gs_additem:
;?>>
   %define R.dest r12
   %define R.s r13
   %define R.d rdi
   %define R.lastchar rbx
   %define R.nextchar rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r12,	rcx
    mov       r13,	rdx
;---------------
    mov       rdi,	[r12]
    mov       eax,	[r12+8]
    test      eax,	eax
    jz        L9142
    movsxd    rax,	dword [r12+8]
    lea       r10,	[rdi + rax]
    sub       r10,	1
    movzx     r10,	byte [r10]
    mov       rbx,	r10
    movzx     rax,	byte [r13]
    mov       rsi,	rax
    mov       rcx,	rbx
    call      mm_support.isalphanum
    test      rax,	rax
    jz        L9144
    mov       rcx,	rsi
    call      mm_support.isalphanum
    test      rax,	rax
    jz        L9144
    mov       rcx,	r12
    lea       rdx,	[L13477]
    mov       r8,	-1
    call      mlib.strbuffer_add
L9144:
L9142:
    mov       rcx,	r12
    mov       rdx,	r13
    mov       r8,	-1
    call      mlib.strbuffer_add
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_support.gs_copytostr
mm_support.gs_copytostr:
;?>>
   %define R.source rdi
   %define R.s rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       eax,	[rdi+8]
    test      eax,	eax
    jz        L9147
    movsxd    rax,	dword [rdi+8]
    mov       r10,	[rdi]
    mov       rcx,	rbx
    mov       rdx,	r10
    mov       r8,	rax
    call      memcpy
    movsxd    rax,	dword [rdi+8]
    xor       r10d,	r10d
    mov       [rbx + rax],	r10b
    jmp       L9146
L9147:
    xor       eax,	eax
    mov       [rbx],	al
L9146:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_support.isalphanum
mm_support.isalphanum:
;?>>
   %define R.c rcx
;?]]
;---------------
    cmp       rcx,	65
    jl        L9152
    cmp       rcx,	90
    jle       L9151
L9152:
    cmp       rcx,	97
    jl        L9153
    cmp       rcx,	122
    jle       L9151
L9153:
    cmp       rcx,	48
    jl        L9150
    cmp       rcx,	57
    jg        L9150
L9151:
    mov       rax,	1
    jmp       L9148
L9150:
    xor       eax,	eax
L9148:
;---------------
    ret       
;End 
;Proc mm_support.init_tt_tables
mm_support.init_tt_tables:
;?>>
   %define R.i rdi
   %define R.size rbx
   %define R.bitsize rsi
   %define R.av_1 r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
;---------------
    xor       rdi,	rdi
    mov       rax,	30
    mov       r12,	rax
    cmp       r12,	0
    jl        L9157
L9155:
    lea       rax,	[mm_tables.stdnames]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8]
    lea       r10,	[mm_decls.ttname]
    mov       r11,	rdi
    mov       [r10 + r11*8],	rax
    mov       eax,	edi
    lea       r10,	[mm_decls.ttbasetype]
    mov       r11,	rdi
    mov       [r10 + r11*4],	eax
    lea       rax,	[mm_tables.stdsize]
    mov       r10,	rdi
    movzx     rax,	byte [rax + r10]
    shl       rax,	3
    mov       rsi,	rax
    mov       rax,	rsi
    test      rax,	rax
    jz        L9159
    cmp       rax,	1
    jz        L9160
    cmp       rax,	2
    jz        L9160
    cmp       rax,	4
    jz        L9160
    jmp       L9161
L9159:
    xor       rbx,	rbx
    jmp       L9158
L9160:
    mov       rbx,	1
    jmp       L9158
L9161:
    mov       rax,	rsi
    sar       rax,	3
    mov       rbx,	rax
L9158:
    mov       eax,	ebx
    lea       r10,	[mm_decls.ttsize]
    mov       r11,	rdi
    mov       [r10 + r11*4],	eax
    mov       rax,	rdi
    cmp       rax,	14
    jz        L9163
    cmp       rax,	15
    jz        L9163
    cmp       rax,	16
    jz        L9163
    cmp       rax,	3
    jz        L9163
    cmp       rax,	17
    jz        L9164
    cmp       rax,	18
    jz        L9164
    cmp       rax,	19
    jz        L9164
    cmp       rax,	4
    jz        L9164
    cmp       rax,	12
    jz        L9164
    cmp       rax,	5
    jz        L9164
    cmp       rax,	2
    jz        L9165
    cmp       rax,	1
    jz        L9165
    cmp       rax,	7
    jz        L9166
    cmp       rax,	20
    jz        L9166
    cmp       rax,	21
    jz        L9166
    jmp       L9167
L9163:
    mov       al,	1
    lea       r10,	[mm_decls.ttsigned]
    mov       r11,	rdi
    mov       [r10 + r11],	al
    mov       al,	1
    lea       r10,	[mm_decls.ttisinteger]
    mov       r11,	rdi
    mov       [r10 + r11],	al
    jmp       L9162
L9164:
    mov       al,	1
    lea       r10,	[mm_decls.ttisinteger]
    mov       r11,	rdi
    mov       [r10 + r11],	al
    jmp       L9162
L9165:
    mov       al,	1
    lea       r10,	[mm_decls.ttisreal]
    mov       r11,	rdi
    mov       [r10 + r11],	al
    jmp       L9162
L9166:
    mov       al,	1
    lea       r10,	[mm_decls.ttisref]
    mov       r11,	rdi
    mov       [r10 + r11],	al
L9167:
L9162:
    lea       rax,	[mm_decls.ttisinteger]
    mov       r10,	rdi
    mov       al,	[rax + r10]
    test      al,	al
    jz        L9169
    cmp       rbx,	8
    jge       L9169
    mov       al,	1
    lea       r10,	[mm_decls.ttisshort]
    mov       r11,	rdi
    mov       [r10 + r11],	al
L9169:
    mov       eax,	1
    lea       r10,	[mm_decls.ttlower]
    mov       r11,	rdi
    mov       [r10 + r11*4],	eax
    mov       rax,	rdi
    cmp       rax,	8
    jz        L9172
    cmp       rax,	9
    jz        L9172
    cmp       rax,	10
    jz        L9172
    cmp       rax,	11
    jnz       L9171
L9172:
    mov       al,	1
    lea       r10,	[mm_decls.ttisblock]
    mov       r11,	rdi
    mov       [r10 + r11],	al
L9171:
    inc       rdi
    cmp       rdi,	r12
    jle       L9155
L9157:
    mov       eax,	7
    lea       r10,	[mm_decls.ttbasetype]
    mov       [r10+80],	eax
    mov       eax,	12
    lea       r10,	[mm_decls.tttarget]
    mov       [r10+80],	eax
    mov       rax,	30
    mov       [mm_decls.ntypes],	rax
    xor       ecx,	ecx
    mov       rdx,	24
    xor       r8d,	r8d
    call      mm_lib.createrefmode
    mov       [mm_tables.trefproc],	rax
    xor       ecx,	ecx
    mov       rdx,	25
    xor       r8d,	r8d
    call      mm_lib.createrefmode
    mov       [mm_tables.treflabel],	rax
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_support.getsupportfile
mm_support.getsupportfile:
;?>>
   %define R.filename r13
   %define R.ext r14
   %define R.path r15
    %define mm_support.getsupportfile.filespec -304
    %define mm_support.getsupportfile.filespec2 -608
   %define R.file rdi
   %define R.fileno rbx
   %define R.pfile rsi
   %define R.i r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	648
    mov       r13,	rcx
    mov       r14,	rdx
    mov       r15,	r8
;---------------
    mov       rdi,	r13
    mov       rax,	[mm_decls.fverbose]
    cmp       rax,	3
    jnz       L9175
    call      msys.m$print_startcon
    lea       rcx,	[L13478]
    call      msys.m$print_setfmt
    mov       rcx,	r13
    call      msys.m$print_str_nf
    mov       rcx,	r14
    call      msys.m$print_str_nf
    mov       rcx,	r15
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L9175:
    mov       al,	[r14]
    test      al,	al
    jz        L9177
    mov       rcx,	r13
    mov       rdx,	r14
    call      mlib.addext
    lea       rcx,	[rbp + mm_support.getsupportfile.filespec]
    mov       rdx,	rax
    call      strcpy
    lea       rax,	[rbp + mm_support.getsupportfile.filespec]
    mov       rdi,	rax
L9177:
    mov       al,	[mm_decls.loadedfromma]
    test      al,	al
    jz        L9179
    mov       rcx,	rdi
    call      mlib.extractfile
    mov       rcx,	rax
    call      mlib.pcm_copyheapstring
    mov       rdi,	rax
L9179:
    mov       r12,	1
    mov       rax,	[mm_decls.nsourcefiles]
    cmp       rax,	1
    jl        L9182
L9180:
    lea       rax,	[mm_decls.sources]
    mov       r10,	r12
    mov       rax,	[rax + r10*8]
    mov       rax,	[rax+8]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.eqstring
    test      rax,	rax
    jz        L9184
    lea       rax,	[mm_decls.sources]
    mov       r10,	r12
    mov       rax,	[rax + r10*8]
    mov       al,	[rax+56]
    test      al,	al
    jnz       L9184
    lea       rax,	[mm_decls.sources]
    mov       r10,	r12
    mov       rax,	[rax + r10*8]
    jmp       L9173
L9184:
    inc       r12
    cmp       r12,	[mm_decls.nsourcefiles]
    jle       L9180
L9182:
    mov       rcx,	rdi
    call      mm_support.isabspath
    test      rax,	rax
    jnz       L9186
    lea       rcx,	[rbp + mm_support.getsupportfile.filespec2]
    mov       rdx,	r15
    call      strcpy
    lea       rcx,	[rbp + mm_support.getsupportfile.filespec2]
    mov       rdx,	rdi
    call      strcat
    lea       rax,	[rbp + mm_support.getsupportfile.filespec2]
    mov       rdi,	rax
L9186:
    mov       rax,	[mm_decls.fverbose]
    cmp       rax,	3
    jnz       L9188
    test      rbx,	rbx
    jz        L9188
    call      msys.m$print_startcon
    lea       rcx,	[L13479]
    call      msys.m$print_str_nf
    mov       rcx,	rdi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L9188:
    test      rdi,	rdi
    jz        L9191
    mov       rcx,	rdi
    call      mlib.checkfile
    test      rax,	rax
    jnz       L9190
L9191:
    lea       rcx,	[L13480]
    mov       rdx,	rdi
    lea       r8,	[L13481]
    call      mm_support.loaderror
L9190:
    mov       rcx,	rdi
    xor       edx,	edx
    call      mm_modules.loadsourcefile
    mov       rsi,	rax
    mov       rax,	[mm_decls.fverbose]
    cmp       rax,	3
    jnz       L9193
    test      rsi,	rsi
    jz        L9193
    call      msys.m$print_startcon
    lea       rcx,	[L13482]
    call      msys.m$print_str_nf
    mov       rcx,	rdi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L9193:
    mov       al,	1
    mov       [rsi+57],	al
    mov       rax,	rsi
L9173:
;---------------
    add       rsp,	648
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_support.isabspath
mm_support.isabspath:
;?>>
   %define R.filespec rbx
   %define R.path rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rcx,	rbx
    call      mlib.extractpath
    mov       rdi,	rax
    movzx     rax,	byte [rdi]
    cmp       rax,	92
    jz        L9197
    cmp       rax,	47
    jz        L9197
    movzx     rax,	byte [rdi]
    test      rax,	rax
    jz        L9196
    movzx     rax,	byte [rdi+1]
    cmp       rax,	58
    jnz       L9196
L9197:
    mov       rax,	1
    jmp       L9194
L9196:
    xor       eax,	eax
L9194:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_support.initbblib
mm_support.initbblib:
;?>>
   %define R.av_1 rdi
   %define R.i rbx
    push      rdi
    push      rbx
;?]]
;---------------
    mov       rbx,	1
    mov       rdi,	6
    cmp       rdi,	1
    jl        L9201
L9199:
    lea       rax,	[mm_tables.d_typestarterset]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8-8]
    mov       r10b,	1
    lea       r11,	[mm_decls.typestarterset]
    mov       [r11 + rax],	r10b
    inc       rbx
    cmp       rbx,	rdi
    jle       L9199
L9201:
;---------------
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_support.getfileno
mm_support.getfileno:
;?>>
   %define R.pos rbx
   %define R.fileno rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    mov       rax,	rbx
    shr       rax,	24
    and       rax,	255
    mov       rdi,	rax
    cmp       rdi,	1
    jl        L9205
    cmp       rdi,	[mm_decls.nsourcefiles]
    jle       L9204
L9205:
    lea       rcx,	[L13483]
    call      mlib.abortprogram
L9204:
    mov       rax,	rdi
L9202:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_support.getlineno
mm_support.getlineno:
;?>>
   %define R.pos r13
   %define R.source rdi
   %define R.sline rbx
   %define R.s rsi
   %define R.lineno r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r13,	rcx
;---------------
    mov       rcx,	r13
    call      mm_support.getsourcestart
    mov       rdi,	rax
    mov       rcx,	r13
    call      mm_support.getsourceline
    mov       rbx,	rax
    mov       rsi,	rbx
    mov       r12,	1
    jmp       L9208
L9207:
    movzx     rax,	byte [rsi]
    cmp       rax,	10
    jnz       L9211
    inc       r12
L9211:
    dec       rsi
L9208:
    cmp       rsi,	rdi
    jae       L9207
    mov       rax,	r12
L9206:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_support.getsourceline
mm_support.getsourceline:
;?>>
   %define R.pos rsi
   %define R.source rdi
   %define R.s rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    mov       rcx,	rsi
    call      mm_support.getsourcestart
    mov       rdi,	rax
    mov       rcx,	rsi
    call      mm_support.getsourcepos
    mov       rbx,	rax
    jmp       L9214
L9213:
    dec       rbx
L9214:
    cmp       rbx,	rdi
    jbe       L9216
    movzx     rax,	byte [rbx]
    cmp       rax,	10
    jnz       L9213
L9216:
    movzx     rax,	byte [rbx]
    cmp       rax,	10
    jnz       L9218
    inc       rbx
L9218:
    mov       rax,	rbx
L9212:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_support.getsourcestart
mm_support.getsourcestart:
;?>>
   %define R.pos rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      mm_support.getfileno
    lea       r10,	[mm_decls.sources]
    mov       r10,	[r10 + rax*8]
    mov       r10,	[r10+32]
    mov       rax,	r10
L9219:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_support.getsourcepos
mm_support.getsourcepos:
;?>>
   %define R.pos rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      mm_support.getfileno
    lea       r10,	[mm_decls.sources]
    mov       r10,	[r10 + rax*8]
    mov       r10,	[r10+32]
    mov       rax,	rdi
    and       rax,	16777215
    lea       r10,	[r10 + rax]
    mov       rax,	r10
L9220:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_support.mgetsourceinfo
mm_support.mgetsourceinfo:
;?>>
   %define R.pos rbx
   %define R.filename rsi
   %define R.sourceline r12
   %define R.lineno rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
;---------------
    mov       rcx,	rbx
    call      mm_support.getlineno
    mov       rdi,	rax
    mov       rcx,	rbx
    call      mm_support.getsourcestart
    mov       [r12],	rax
    mov       rcx,	rbx
    call      mm_support.getfileno
    lea       r10,	[mm_decls.sources]
    mov       r10,	[r10 + rax*8]
    mov       r10,	[r10+24]
    mov       [rsi],	r10
    mov       rax,	rdi
L9221:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_support.do_writema
mm_support.do_writema:
;?>>
   %define R.inpfile r14
    %define mm_support.do_writema.filename -304
    %define mm_support.do_writema.sflist -2704
   %define R.f rdi
   %define R.offset rbx
   %define R.nfiles rsi
   %define R.pf r12
   %define R.i r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	2736
    mov       r14,	rcx
;---------------
    mov       rax,	[mm_decls.passlevel]
    cmp       rax,	1
    jnz       L9222
L9224:
    mov       rcx,	r14
    lea       rdx,	[L13484]
    call      mlib.changeext
    lea       rcx,	[rbp + mm_support.do_writema.filename]
    mov       rdx,	rax
    call      strcpy
    xor       rsi,	rsi
    mov       rax,	1
    mov       r13,	rax
    mov       rax,	[mm_decls.nsourcefiles]
    cmp       rax,	1
    jl        L9227
L9225:
    lea       rax,	[mm_decls.sources]
    mov       r10,	r13
    mov       rax,	[rax + r10*8]
    mov       al,	[rax+56]
    test      al,	al
    jnz       L9229
    inc       rsi
    mov       rax,	rsi
    mov       r10,	r13
    mov       [rbp + rax*8 + mm_support.do_writema.sflist-8],	r10
L9229:
    inc       r13
    cmp       r13,	[mm_decls.nsourcefiles]
    jle       L9225
L9227:
    test      rsi,	rsi
    jnz       L9231
    lea       rcx,	[L13485]
    lea       rdx,	[L13486]
    lea       r8,	[L13486]
    call      mm_support.loaderror
L9231:
    lea       rcx,	[rbp + mm_support.do_writema.filename]
    lea       rdx,	[L13487]
    call      fopen
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L9233
    lea       rcx,	[L13488]
    lea       rdx,	[rbp + mm_support.do_writema.filename]
    lea       r8,	[L13489]
    call      mm_support.loaderror
L9233:
    mov       rax,	[mm_decls.fverbose]
    test      rax,	rax
    jz        L9235
    call      msys.m$print_startcon
    lea       rcx,	[L13490]
    call      msys.m$print_str_nf
    lea       rcx,	[rbp + mm_support.do_writema.filename]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L9235:
    mov       rcx,	rdi
    call      msys.m$print_startfile
    lea       rcx,	[L13491]
    call      msys.m$print_setfmt
    mov       rcx,	rsi
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       r13,	1
    cmp       rsi,	1
    jl        L9238
L9236:
    mov       rax,	[rbp + r13*8 + mm_support.do_writema.sflist-8]
    lea       r10,	[mm_decls.sources]
    mov       r10,	[r10 + rax*8]
    mov       r12,	r10
    mov       rcx,	rdi
    call      msys.m$print_startfile
    lea       rcx,	[L13492]
    call      msys.m$print_setfmt
    mov       rcx,	[r12+8]
    call      msys.m$print_str_nf
    movzx     rax,	byte [r12+56]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    movzx     rax,	byte [r12+57]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    mov       rcx,	r13
    call      msys.m$print_i64_nf
    mov       rcx,	rsi
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	rdi
    call      mlib.getfilepos
    mov       rbx,	rax
    mov       rax,	[r12+48]
    mov       r10,	[r12+40]
    mov       rcx,	rdi
    mov       rdx,	r10
    mov       r8,	rbx
    mov       r9,	rax
    call      mlib.writerandom
    inc       r13
    cmp       r13,	rsi
    jle       L9236
L9238:
    mov       rcx,	rdi
    call      msys.m$print_startfile
    lea       rcx,	[L13493]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       r13,	1
    cmp       rsi,	1
    jl        L9241
L9239:
    mov       rax,	[rbp + r13*8 + mm_support.do_writema.sflist-8]
    lea       r10,	[mm_decls.sources]
    mov       r10,	[r10 + rax*8]
    mov       r12,	r10
    mov       rcx,	rdi
    call      msys.m$print_startfile
    mov       rcx,	r13
    call      msys.m$print_i64_nf
    mov       rcx,	[r12+8]
    call      msys.m$print_str_nf
    movzx     rax,	byte [r12+56]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    movzx     rax,	byte [r12+57]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    inc       r13
    cmp       r13,	rsi
    jle       L9239
L9241:
    mov       rcx,	rdi
    call      fclose
    xor       ecx,	ecx
    call      exit
L9222:
;---------------
    add       rsp,	2736
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_support.do_getinfo
mm_support.do_getinfo:
;?>>
   %define R.filename r13
   %define R.f rdi
   %define R.fs rbx
   %define R.pm rsi
   %define R.i r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r13,	rcx
;---------------
    mov       rax,	[mm_decls.passlevel]
    cmp       rax,	2
    jnz       L9244
    mov       rcx,	r13
    lea       rdx,	[L13494]
    call      mlib.changeext
    mov       r10,	rax
    mov       rbx,	r10
    mov       rcx,	rax
    lea       rdx,	[L13495]
    call      fopen
    mov       rdi,	rax
    test      rdi,	rdi
    jz        L9246
    call      msys.m$print_startcon
    lea       rcx,	[L13496]
    call      msys.m$print_str_nf
    mov       rcx,	rbx
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	rdi
    mov       rdx,	[mm_decls.stprogram]
    call      mm_support.getst
    mov       rcx,	rdi
    call      fclose
L9246:
L9244:
    mov       rax,	[mm_decls.passlevel]
    cmp       rax,	3
    jnz       L9248
    mov       rcx,	r13
    lea       rdx,	[L13497]
    call      mlib.changeext
    mov       r10,	rax
    mov       rbx,	r10
    mov       rcx,	rax
    lea       rdx,	[L13498]
    call      fopen
    mov       rdi,	rax
    test      rdi,	rdi
    jz        L9250
    call      msys.m$print_startcon
    lea       rcx,	[L13499]
    call      msys.m$print_str_nf
    mov       rcx,	rbx
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       r12,	1
    mov       rax,	[mm_decls.nmodules]
    cmp       rax,	1
    jl        L9253
L9251:
    lea       rax,	[mm_decls.modules]
    mov       r10,	r12
    mov       rsi,	[rax + r10*8]
    mov       rcx,	rdi
    call      msys.m$print_startfile
    mov       rax,	[rsi]
    mov       rcx,	rax
    lea       rdx,	[L13500]
    call      msys.m$print_str
    movsx     rax,	word [rsi+18]
    lea       r10,	[mm_decls.subprogs]
    mov       r10,	[r10 + rax*8]
    mov       r10,	[r10]
    mov       rcx,	r10
    lea       rdx,	[L13500]
    call      msys.m$print_str
    mov       rax,	[rsi+8]
    mov       rax,	[rax+24]
    mov       rcx,	rax
    lea       rdx,	[L13501]
    call      msys.m$print_str
    movzx     rax,	byte [rsi+22]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    inc       r12
    cmp       r12,	[mm_decls.nmodules]
    jle       L9251
L9253:
    mov       rcx,	rdi
    call      fclose
L9250:
L9248:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_support.getst
mm_support.getst:
;?>>
   %define R.f rbx
   %define R.d rsi
   %define R.q rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    mov       rcx,	rbx
    mov       rdx,	rsi
    call      mm_support.getstrec
    mov       rdi,	[rsi+16]
    jmp       L9258
L9255:
    mov       rcx,	rbx
    mov       rdx,	rdi
    call      mm_support.getst
    mov       rdi,	[rdi+32]
L9258:
    test      rdi,	rdi
    jnz       L9255
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_support.getstrec
mm_support.getstrec:
;?>>
   %define R.f rbx
   %define R.d rsi
   %define R.name rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    movzx     rax,	byte [rsi+78]
    cmp       rax,	6
    jz        L9261
    cmp       rax,	7
    jz        L9261
    cmp       rax,	5
    jz        L9261
    cmp       rax,	9
    jz        L9261
    cmp       rax,	10
    jz        L9261
    cmp       rax,	15
    jz        L9261
    cmp       rax,	8
    jnz       L9262
L9261:
    jmp       L9260
L9262:
    jmp       L9259
L9260:
    mov       rax,	[rsi+8]
    test      rax,	rax
    jz        L9264
    mov       rax,	[rsi+8]
    movzx     rax,	byte [rax+78]
    cmp       rax,	3
    jnz       L9259
L9264:
    mov       rcx,	rbx
    call      msys.m$print_startfile
    movzx     rax,	byte [rsi+94]
    lea       r10,	[mm_decls.moduletosub]
    movzx     r10,	byte [r10 + rax]
    lea       rax,	[mm_decls.subprogs]
    mov       rax,	[rax + r10*8]
    mov       rax,	[rax]
    mov       rcx,	rax
    lea       rdx,	[L13502]
    call      msys.m$print_str
    call      msys.m$print_space
    call      msys.m$print_end
    mov       rcx,	rbx
    call      msys.m$print_startfile
    mov       rax,	[rsi+8]
    mov       rax,	[rax]
    mov       rcx,	rax
    lea       rdx,	[L13503]
    call      msys.m$print_str
    call      msys.m$print_space
    call      msys.m$print_end
    mov       rcx,	rbx
    call      msys.m$print_startfile
    mov       rax,	[rsi]
    mov       rcx,	rax
    lea       rdx,	[L13504]
    call      msys.m$print_str
    call      msys.m$print_space
    call      msys.m$print_end
    movzx     rax,	byte [rsi+78]
    cmp       rax,	6
    jz        L9266
    cmp       rax,	7
    jz        L9267
    jmp       L9268
L9266:
    mov       eax,	[rsi+72]
    test      eax,	eax
    jz        L9270
    lea       rax,	[L13505]
    jmp       L9269
L9270:
    lea       rax,	[L13506]
L9269:
    mov       rdi,	rax
    jmp       L9265
L9267:
    mov       eax,	[rsi+72]
    test      eax,	eax
    jz        L9272
    lea       rax,	[L13507]
    jmp       L9271
L9272:
    lea       rax,	[L13508]
L9271:
    mov       rdi,	rax
    jmp       L9265
L9268:
    movzx     rax,	byte [rsi+78]
    lea       r10,	[mm_tables.namenames]
    mov       r10,	[r10 + rax*8]
    mov       rdi,	r10
L9265:
    mov       rcx,	rbx
    call      msys.m$print_startfile
    mov       rcx,	rdi
    lea       rdx,	[L13509]
    call      msys.m$print_str
    call      msys.m$print_end
    mov       rcx,	rbx
    call      msys.m$print_startfile
    mov       eax,	[rsi+88]
    mov       rcx,	rax
    call      mm_support.getlineno
    mov       rcx,	rax
    lea       rdx,	[L13510]
    call      msys.m$print_i64
    call      msys.m$print_space
    call      msys.m$print_end
    movzx     rax,	byte [rsi+170]
    test      rax,	rax
    jz        L9274
    cmp       rax,	1
    jz        L9275
    cmp       rax,	2
    jz        L9276
    jmp       L9277
L9274:
    lea       rax,	[L13511]
    mov       rdi,	rax
    jmp       L9273
L9275:
    lea       rax,	[L13512]
    mov       rdi,	rax
    jmp       L9273
L9276:
    lea       rax,	[L13513]
    mov       rdi,	rax
    jmp       L9273
L9277:
    lea       rax,	[L13514]
    mov       rdi,	rax
L9273:
    mov       rcx,	rbx
    call      msys.m$print_startfile
    mov       rcx,	rdi
    call      msys.m$print_str_nf
    call      msys.m$print_space
    call      msys.m$print_end
    movzx     rax,	word [rsi+92]
    shr       eax,	11
    and       eax,	1
    test      rax,	rax
    jz        L9279
    mov       rcx,	rbx
    call      msys.m$print_startfile
    lea       rcx,	[L13515]
    call      msys.m$print_str_nf
    call      msys.m$print_end
L9279:
    mov       rcx,	rbx
    call      msys.m$print_startfile
    movsxd    rax,	dword [rsi+72]
    mov       rcx,	rax
    mov       rdx,	1
    call      mm_lib.strmode
    mov       rcx,	rax
    lea       rdx,	[L13516]
    call      msys.m$print_str
    call      msys.m$print_space
    call      msys.m$print_end
    mov       rcx,	rbx
    call      msys.m$print_startfile
    movzx     rax,	byte [rsi+94]
    lea       r10,	[mm_decls.modules]
    mov       r10,	[r10 + rax*8]
    movsx     r10,	word [r10+20]
    lea       rax,	[mm_decls.sources]
    mov       rax,	[rax + r10*8]
    mov       rax,	[rax+24]
    mov       rcx,	rax
    lea       rdx,	[L13517]
    call      msys.m$print_str
    call      msys.m$print_end
    mov       rcx,	rbx
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
L9259:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_tables.start
mm_tables.start:
;?>>
   %define R.av_1 rdi
   %define R.i rbx
    push      rdi
    push      rbx
;?]]
;---------------
    mov       rbx,	1
    mov       rdi,	12
    cmp       rdi,	1
    jl        L9283
L9281:
    lea       rax,	[mm_tables.exprendsymbols]
    mov       r10,	rbx
    movzx     rax,	byte [rax + r10-1]
    mov       r10b,	1
    lea       r11,	[mm_tables.endsexpr]
    mov       [r11 + rax-1],	r10b
    inc       rbx
    cmp       rbx,	rdi
    jle       L9281
L9283:
    mov       al,	1
    lea       r10,	[mm_tables.isbooltag]
    mov       [r10+33],	al
    mov       al,	1
    lea       r10,	[mm_tables.isbooltag]
    mov       [r10+34],	al
    mov       al,	1
    lea       r10,	[mm_tables.isbooltag]
    mov       [r10+15],	al
    mov       al,	1
    lea       r10,	[mm_tables.isbooltag]
    mov       [r10+16],	al
    mov       al,	1
    lea       r10,	[mm_tables.isbooltag]
    mov       [r10+17],	al
    mov       al,	1
    lea       r10,	[mm_tables.isbooltag]
    mov       [r10+18],	al
    mov       al,	1
    lea       r10,	[mm_tables.isbooltag]
    mov       [r10+19],	al
    mov       al,	1
    lea       r10,	[mm_tables.isbooltag]
    mov       [r10+43],	al
    mov       al,	1
    lea       r10,	[mm_tables.isbooltag]
    mov       [r10+44],	al
;---------------
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tpass
mm_type.tpass:
;?>>
   %define R.p r14
    %define mm_type.tpass.t 72
    %define mm_type.tpass.lv 80
   %define R.a rdi
   %define R.b rbx
   %define R.c rsi
   %define R.oldmmpos r12
   %define R.m r13
    %define mm_type.tpass.paramtype -8
    %define mm_type.tpass.restype -16
    %define mm_type.tpass.av_1 -24
    %define mm_type.tpass.i -32
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       r14,	rcx
    mov       [rbp+72],	rdx
    mov       [rbp+80],	r8
;---------------
    test      r14,	r14
    jnz       L9286
    jmp       L9284
L9286:
    mov       rax,	[mm_type.tpass.depth]
    cmp       rax,	100
    jnz       L9288
    lea       rcx,	[L13518]
    xor       edx,	edx
    call      mm_support.txerror
L9288:
    inc       qword [mm_type.tpass.depth]
    mov       r12,	[pc_decls.mmpos]
    mov       eax,	[r14+4]
    mov       [pc_decls.mmpos],	rax
    mov       rdi,	[r14+16]
    mov       rbx,	[r14+24]
    mov       rsi,	[r14+32]
    mov       rax,	[rbp + mm_type.tpass.t]
    cmp       rax,	0
    setnz     al
    movzx     eax,	al
    mov       [r14+61],	al
    movzx     rax,	byte [r14]
    sub       rax,	1
    cmp       rax,	122
    jae       L9291
    lea       r10,	[L9290]
    jmp       [r10 + rax*8]
    segment .data
L9290:
    dq  L9293
    dq  L9291
    dq  L9291
    dq  L9292
    dq  L9291
    dq  L9324
    dq  L9293
    dq  L9354
    dq  L9291
    dq  L9357
    dq  L9357
    dq  L9358
    dq  L9396
    dq  L9399
    dq  L9312
    dq  L9312
    dq  L9313
    dq  L9313
    dq  L9313
    dq  L9340
    dq  L9317
    dq  L9398
    dq  L9291
    dq  L9397
    dq  L9291
    dq  L9291
    dq  L9291
    dq  L9302
    dq  L9291
    dq  L9291
    dq  L9291
    dq  L9310
    dq  L9296
    dq  L9390
    dq  L9296
    dq  L9298
    dq  L9299
    dq  L9300
    dq  L9301
    dq  L9316
    dq  L9297
    dq  L9291
    dq  L9291
    dq  L9291
    dq  L9291
    dq  L9308
    dq  L9291
    dq  L9323
    dq  L9311
    dq  L9291
    dq  L9322
    dq  L9322
    dq  L9309
    dq  L9291
    dq  L9303
    dq  L9306
    dq  L9291
    dq  L9314
    dq  L9395
    dq  L9337
    dq  L9315
    dq  L9294
    dq  L9291
    dq  L9291
    dq  L9295
    dq  L9295
    dq  L9359
    dq  L9376
    dq  L9291
    dq  L9291
    dq  L9291
    dq  L9291
    dq  L9375
    dq  L9375
    dq  L9291
    dq  L9291
    dq  L9291
    dq  L9291
    dq  L9291
    dq  L9291
    dq  L9291
    dq  L9291
    dq  L9291
    dq  L9291
    dq  L9291
    dq  L9362
    dq  L9353
    dq  L9353
    dq  L9327
    dq  L9377
    dq  L9336
    dq  L9307
    dq  L9334
    dq  L9334
    dq  L9335
    dq  L9335
    dq  L9345
    dq  L9349
    dq  L9343
    dq  L9344
    dq  L9342
    dq  L9342
    dq  L9342
    dq  L9326
    dq  L9321
    dq  L9321
    dq  L9320
    dq  L9320
    dq  L9320
    dq  L9320
    dq  L9318
    dq  L9319
    dq  L9370
    dq  L9328
    dq  L9328
    dq  L9328
    dq  L9328
    dq  L9364
    dq  L9363
    dq  L9341
    dq  L9325
    dq  L9391
    segment .text
L9292:
    mov       rcx,	r14
    mov       rdx,	[rbp + mm_type.tpass.t]
    mov       r8,	[rbp + mm_type.tpass.lv]
    call      mm_type.tx_name
    jmp       L9289
L9293:
    jmp       L9289
L9294:
    mov       eax,	3
    mov       [r14+49],	eax
    jmp       L9289
L9295:
    mov       rcx,	rdi
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       eax,	3
    mov       [r14+49],	eax
    jmp       L9289
L9296:
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_type.tx_bin
    jmp       L9289
L9297:
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_type.tx_in
    jmp       L9289
L9298:
    mov       rcx,	r14
    mov       rdx,	rdi
    call      mm_type.tx_unary
    jmp       L9289
L9299:
    mov       rcx,	r14
    mov       rdx,	rdi
    call      mm_type.tx_prop
    jmp       L9289
L9300:
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_type.tx_binto
    jmp       L9289
L9301:
    mov       rcx,	r14
    mov       rdx,	rdi
    call      mm_type.tx_unaryto
    jmp       L9289
L9302:
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	rbx
    mov       r9,	[rbp + mm_type.tpass.t]
    call      mm_type.tx_assign
    jmp       L9289
L9303:
    movzx     rax,	byte [rdi]
    cmp       rax,	53
    jnz       L9305
    mov       rcx,	r14
    mov       rdx,	rdi
    call      mm_lib.deleteunit
    mov       rax,	[r14+16]
    mov       rcx,	r14
    mov       rdx,	rax
    call      mm_lib.deleteunit
    mov       rcx,	r14
    mov       rdx,	[rbp + mm_type.tpass.t]
    mov       r8,	[rbp + mm_type.tpass.lv]
    call      mm_type.tpass
    jmp       L9304
L9305:
    mov       rcx,	rdi
    mov       rdx,	23
    call      mm_type.tpasslv
    movsxd    rax,	dword [rdi+49]
    xor       ecx,	ecx
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_lib.createrefmode
    mov       [r14+49],	eax
L9304:
    jmp       L9289
L9306:
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	[rbp + mm_type.tpass.t]
    call      mm_type.tx_addroffirst
    jmp       L9289
L9307:
    push      qword [rbp + mm_type.tpass.lv]
    push      qword [rbp + mm_type.tpass.t]
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	rbx
    mov       r9,	rsi
    sub       rsp,	32
    call      mm_type.tx_if
    add       rsp,	48
    jmp       L9289
L9308:
    sub       rsp,	8
    push      qword [rbp + mm_type.tpass.lv]
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	rbx
    mov       r9,	[rbp + mm_type.tpass.t]
    sub       rsp,	32
    call      mm_type.tx_index
    add       rsp,	48
    jmp       L9289
L9309:
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	[rbp + mm_type.tpass.t]
    mov       r9,	[rbp + mm_type.tpass.lv]
    call      mm_type.tx_ptr
    jmp       L9289
L9310:
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	rbx
    mov       r9,	[rbp + mm_type.tpass.t]
    call      mm_type.tx_callproc
    jmp       L9289
L9311:
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	rbx
    mov       r9,	[rbp + mm_type.tpass.lv]
    call      mm_type.tx_dot
    jmp       L9289
L9312:
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_type.tx_andl
    jmp       L9289
L9313:
    mov       rcx,	r14
    mov       rdx,	rdi
    call      mm_type.tx_notl
    jmp       L9289
L9314:
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	1
    call      mm_type.tx_convert
    jmp       L9289
L9315:
    mov       rcx,	r14
    mov       rdx,	rdi
    call      mm_type.tx_typepun
    jmp       L9289
L9316:
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	[rbp + mm_type.tpass.t]
    call      mm_type.tx_incrto
    jmp       L9289
L9317:
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_type.tx_makerange
    jmp       L9289
L9318:
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_type.tx_swap
    jmp       L9289
L9319:
    push      qword [rbp + mm_type.tpass.lv]
    push      qword [rbp + mm_type.tpass.t]
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	rbx
    mov       r9,	rsi
    sub       rsp,	32
    call      mm_type.tx_select
    add       rsp,	48
    jmp       L9289
L9320:
    push      qword [rbp + mm_type.tpass.lv]
    push      qword [rbp + mm_type.tpass.t]
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	rbx
    mov       r9,	rsi
    sub       rsp,	32
    call      mm_type.tx_switch
    add       rsp,	48
    jmp       L9289
L9321:
    push      qword [rbp + mm_type.tpass.lv]
    push      qword [rbp + mm_type.tpass.t]
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	rbx
    mov       r9,	rsi
    sub       rsp,	32
    call      mm_type.tx_case
    add       rsp,	48
    jmp       L9289
L9322:
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	rbx
    mov       r9,	[rbp + mm_type.tpass.lv]
    call      mm_type.tx_dotindex
    jmp       L9289
L9323:
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mm_type.tx_slice
    jmp       L9289
L9324:
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	[rbp + mm_type.tpass.t]
    mov       r9,	[rbp + mm_type.tpass.lv]
    call      mm_type.tx_block
    jmp       L9289
L9325:
    mov       rcx,	rdi
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    jmp       L9289
L9326:
    mov       rcx,	rdi
    xor       edx,	edx
    xor       r8d,	r8d
    call      mm_type.tpass
    jmp       L9289
L9327:
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	[rbp + mm_type.tpass.t]
    call      mm_type.tx_return
    jmp       L9289
L9328:
    mov       rcx,	rdi
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tx_unitlist
    mov       rcx,	rdi
    call      mm_type.fixchararray
    jmp       L9330
L9329:
    movzx     rax,	byte [rbx]
    cmp       rax,	86
    jnz       L9333
    mov       rax,	[rbx+16]
    mov       r10,	rax
    mov       rsi,	r10
    mov       rcx,	rax
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rax,	[rbx+24]
    mov       rcx,	rax
    mov       rdx,	20
    xor       r8d,	r8d
    call      mm_type.tpass
    jmp       L9332
L9333:
    mov       rax,	rbx
    mov       r10,	rax
    mov       rsi,	r10
    mov       rcx,	rax
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
L9332:
    mov       rcx,	rsi
    call      mm_type.fixchararray
    mov       rbx,	[rbx+8]
L9330:
    test      rbx,	rbx
    jnz       L9329
    mov       rax,	[r14+32]
    mov       rcx,	rax
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tx_unitlist
    jmp       L9289
L9334:
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mm_type.tx_for
    jmp       L9289
L9335:
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mm_type.tx_forall
    jmp       L9289
L9336:
    mov       rcx,	rdi
    mov       rdx,	3
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rcx,	rbx
    xor       edx,	edx
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rcx,	rsi
    mov       rdx,	3
    xor       r8d,	r8d
    call      mm_type.tpass
    jmp       L9289
L9337:
    mov       rcx,	rdi
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rax,	[rbp + mm_type.tpass.t]
    cmp       rax,	23
    jnz       L9339
    lea       rcx,	[L13519]
    xor       edx,	edx
    call      mm_support.txerror
L9339:
    mov       rcx,	rdi
    mov       rdx,	[rbp + mm_type.tpass.t]
    mov       r8,	1
    call      mm_type.coerceunit
    mov       rcx,	r14
    mov       rdx,	rdi
    call      mm_lib.deleteunit
    jmp       L9289
L9340:
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	[rbp + mm_type.tpass.t]
    mov       r9,	[rbp + mm_type.tpass.lv]
    call      mm_type.tx_makelist
    jmp       L9289
L9341:
    mov       rcx,	rdi
    mov       rdx,	3
    xor       r8d,	r8d
    call      mm_type.tpass
    jmp       L9289
L9342:
    mov       rcx,	r14
    mov       rdx,	rdi
    call      mm_type.tx_exit
    jmp       L9289
L9343:
    mov       rcx,	r14
    mov       rdx,	rdi
    call      mm_type.tx_goto
    jmp       L9289
L9344:
    jmp       L9289
L9345:
    mov       rcx,	rdi
    mov       rdx,	6
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rcx,	rdi
    call      mm_type.iscondtrue
    test      rax,	rax
    jz        L9347
    mov       al,	104
    mov       [r14],	al
    mov       [r14+16],	rbx
    jmp       L9346
L9347:
    mov       rcx,	rdi
    call      mm_type.iscondfalse
    test      rax,	rax
    jz        L9348
    mov       al,	2
    mov       [r14],	al
L9348:
L9346:
    mov       rcx,	rbx
    xor       edx,	edx
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rcx,	rsi
    xor       edx,	edx
    xor       r8d,	r8d
    call      mm_type.tpass
    jmp       L9289
L9349:
    mov       rcx,	rdi
    xor       edx,	edx
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rcx,	rbx
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rcx,	rbx
    call      mm_type.iscondtrue
    test      rax,	rax
    jnz       L9352
    mov       rcx,	rbx
    call      mm_type.iscondfalse
    test      rax,	rax
    jz        L9351
L9352:
    lea       rcx,	[L13520]
    xor       edx,	edx
    call      mm_support.txerror
L9351:
    jmp       L9289
L9353:
    jmp       L9289
L9354:
    mov       rax,	[rbp + mm_type.tpass.t]
    test      rax,	rax
    jz        L9356
    mov       eax,	[rbp + mm_type.tpass.t]
    mov       [r14+49],	eax
L9356:
    mov       rax,	1
    mov       [mm_type.inassem],	rax
    mov       rcx,	rdi
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tx_unitlist
    mov       rcx,	rbx
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tx_unitlist
    mov       rcx,	rsi
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tx_unitlist
    xor       eax,	eax
    mov       [mm_type.inassem],	rax
    jmp       L9289
L9357:
    jmp       L9289
L9358:
    mov       rcx,	rdi
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    jmp       L9289
L9359:
    mov       rcx,	rdi
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    movzx     rax,	byte [rdi]
    cmp       rax,	62
    jnz       L9361
    mov       r13,	[rdi+16]
    jmp       L9360
L9361:
    mov       rcx,	rdi
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    movsxd    rax,	dword [rdi+49]
    mov       r13,	rax
L9360:
    mov       al,	1
    mov       [r14],	al
    mov       eax,	20
    mov       [r14+49],	eax
    xor       eax,	eax
    mov       [r14+16],	rax
    mov       rcx,	r13
    xor       edx,	edx
    call      mm_lib.strmode
    mov       rcx,	rax
    call      mlib.pcm_copyheapstring
    mov       [r14+16],	rax
    mov       rax,	[r14+16]
    mov       rcx,	rax
    call      strlen
    inc       rax
    mov       [r14+40],	eax
    mov       al,	1
    mov       [r14+44],	al
    jmp       L9289
L9362:
    mov       rcx,	rdi
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rcx,	rbx
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    jmp       L9289
L9363:
    mov       rcx,	rdi
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    jmp       L9289
L9364:
    test      rdi,	rdi
    jz        L9366
    mov       rcx,	rdi
    mov       rdx,	5
    xor       r8d,	r8d
    call      mm_type.tpass
L9366:
    lea       rax,	[mm_decls.ttisinteger]
    mov       r10,	[rbp + mm_type.tpass.t]
    mov       al,	[rax + r10]
    test      al,	al
    jnz       L9369
    lea       rax,	[mm_decls.ttisreal]
    mov       r10,	[rbp + mm_type.tpass.t]
    mov       al,	[rax + r10]
    test      al,	al
    jz        L9368
L9369:
    mov       rcx,	[rbp + mm_type.tpass.t]
    call      mm_lib.gettypebase
    mov       [rbp + mm_type.tpass.t],	rax
L9368:
    mov       eax,	[rbp + mm_type.tpass.t]
    mov       [r14+49],	eax
    jmp       L9289
L9370:
    test      rdi,	rdi
    jz        L9372
    mov       rcx,	rdi
    mov       rdx,	3
    xor       r8d,	r8d
    call      mm_type.tpass
    movzx     rax,	byte [rdi]
    cmp       rax,	1
    jz        L9374
    lea       rcx,	[L13521]
    xor       edx,	edx
    call      mm_support.txerror
L9374:
L9372:
    jmp       L9289
L9375:
    mov       eax,	20
    mov       [r14+49],	eax
    jmp       L9289
L9376:
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	[rbp + mm_type.tpass.lv]
    call      mm_type.tx_bitfield
    jmp       L9289
L9377:
    xor       eax,	eax
    mov       [rbp + mm_type.tpass.restype],	rax
    xor       eax,	eax
    mov       [rbp + mm_type.tpass.paramtype],	rax
    movsx     rax,	word [r14+40]
    cmp       rax,	29
    jz        L9379
    cmp       rax,	30
    jz        L9380
    cmp       rax,	31
    jz        L9381
    jmp       L9382
L9379:
    mov       rax,	3
    mov       [rbp + mm_type.tpass.restype],	rax
    jmp       L9378
L9380:
    mov       rax,	3
    mov       [rbp + mm_type.tpass.paramtype],	rax
    mov       rax,	20
    mov       [rbp + mm_type.tpass.restype],	rax
    jmp       L9378
L9381:
    mov       rax,	3
    mov       [rbp + mm_type.tpass.paramtype],	rax
    mov       rax,	7
    mov       [rbp + mm_type.tpass.restype],	rax
L9382:
L9378:
    mov       rax,	[rbp + mm_type.tpass.paramtype]
    test      rax,	rax
    jz        L9384
    test      rdi,	rdi
    jnz       L9386
    lea       rcx,	[L13522]
    xor       edx,	edx
    call      mm_support.txerror
L9386:
    mov       rcx,	rdi
    mov       rdx,	[rbp + mm_type.tpass.paramtype]
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rax,	[rdi+8]
    test      rax,	rax
    jz        L9388
    lea       rcx,	[L13523]
    xor       edx,	edx
    call      mm_support.txerror
L9388:
    jmp       L9383
L9384:
    test      rdi,	rdi
    jz        L9389
    lea       rcx,	[L13523]
    xor       edx,	edx
    call      mm_support.txerror
L9389:
L9383:
    mov       eax,	[rbp + mm_type.tpass.restype]
    mov       [r14+49],	eax
    jmp       L9289
L9390:
    mov       rcx,	r14
    mov       rdx,	rdi
    call      mm_type.tx_cmpchain
    jmp       L9289
L9391:
    mov       rcx,	rdi
    mov       rdx,	23
    call      mm_type.tpasslv
    movsxd    rax,	dword [rdi+49]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    cmp       r10,	8
    jz        L9393
    cmp       r10,	10
    jz        L9393
    jmp       L9394
L9393:
    jmp       L9392
L9394:
    lea       rcx,	[L13524]
    xor       edx,	edx
    call      mm_support.txerror
L9392:
    jmp       L9289
L9395:
    jmp       L9289
L9396:
    mov       rcx,	r14
    mov       rdx,	rdi
    call      mm_type.tx_strinclude
    jmp       L9289
L9397:
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	rbx
    mov       r9,	[rbp + mm_type.tpass.t]
    call      mm_type.tx_makeslice
    jmp       L9289
L9398:
    mov       rcx,	r14
    mov       rdx,	rdi
    mov       r8,	[rbp + mm_type.tpass.t]
    call      mm_type.tx_makeset
    jmp       L9289
L9399:
    jmp       L9289
L9291:
    call      msys.m$print_startcon
    lea       rcx,	[L13525]
    call      msys.m$print_str_nf
    movzx     rax,	byte [r14]
    lea       r10,	[mm_tables.jtagnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
;mm_type.tpass.doelse:
    mov       rax,	1
    mov       [rbp + mm_type.tpass.i],	rax
    movzx     rax,	byte [r14]
    lea       r10,	[mm_tables.jsubs]
    movzx     r10,	byte [r10 + rax]
    mov       [rbp + mm_type.tpass.av_1],	r10
    mov       rax,	[rbp + mm_type.tpass.av_1]
    cmp       rax,	1
    jl        L9403
L9401:
    lea       rax,	[r14+16]
    mov       r10,	[rbp + mm_type.tpass.i]
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rax
    mov       rdx,	[rbp + mm_type.tpass.t]
    xor       r8d,	r8d
    call      mm_type.tx_unitlist
    mov       rax,	[rbp + mm_type.tpass.i]
    inc       rax
    mov       [rbp + mm_type.tpass.i],	rax
    cmp       rax,	[rbp + mm_type.tpass.av_1]
    jle       L9401
L9403:
L9289:
    mov       rcx,	r14
    call      mm_type.tevaluate
    movzx     rax,	byte [r14]
    cmp       rax,	20
    jz        L9405
    cmp       rax,	89
    jnz       L9406
L9405:
    jmp       L9404
L9406:
    mov       rax,	[rbp + mm_type.tpass.t]
    cmp       rax,	23
    jz        L9408
    mov       rax,	[rbp + mm_type.tpass.t]
    test      rax,	rax
    jz        L9408
    movsxd    rax,	dword [r14+49]
    cmp       rax,	[rbp + mm_type.tpass.t]
    jz        L9408
    mov       rcx,	r14
    mov       rdx,	[rbp + mm_type.tpass.t]
    xor       r8d,	r8d
    call      mm_type.coerceunit
L9408:
L9404:
    mov       rax,	[rbp + mm_type.tpass.t]
    test      rax,	rax
    jnz       L9410
    movzx     rax,	byte [r14]
    cmp       rax,	1
    jz        L9412
    cmp       rax,	35
    jz        L9412
    cmp       rax,	36
    jz        L9412
    cmp       rax,	33
    jz        L9412
    cmp       rax,	4
    jz        L9413
    jmp       L9414
L9412:
    jmp       L9411
L9413:
    movsxd    rax,	dword [r14+49]
    lea       r10,	[mm_decls.ttisref]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L9417
    movsxd    rax,	dword [r14+49]
    lea       r10,	[mm_decls.tttarget]
    movsxd    r10,	dword [r10 + rax*4]
    cmp       r10,	25
    jz        L9416
L9417:
L9416:
L9414:
L9411:
L9410:
    mov       [pc_decls.mmpos],	r12
    dec       qword [mm_type.tpass.depth]
L9284:
;---------------
    add       rsp,	64
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_allprocs
mm_type.tx_allprocs:
;?>>
   %define R.pp rdi
   %define R.pcode rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
;---------------
    mov       rdi,	[mm_decls.proclist]
    jmp       L9420
L9419:
    mov       rax,	[rdi]
    mov       [mm_decls.currproc],	rax
    mov       rax,	[mm_decls.currproc]
    mov       rbx,	[rax+64]
    mov       rax,	[mm_decls.currproc]
    movzx     rax,	byte [rax+122]
    cmp       rax,	1
    jle       L9423
    mov       rax,	28
    jmp       L9422
L9423:
    mov       rax,	[mm_decls.currproc]
    movsxd    rax,	dword [rax+72]
L9422:
    mov       rcx,	rbx
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rax,	[mm_decls.currproc]
    movsxd    rax,	dword [rax+72]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    test      r10,	r10
    jz        L9425
    cmp       r10,	28
    jz        L9426
    jmp       L9427
L9425:
    jmp       L9424
L9426:
    jmp       L9424
L9427:
    movzx     rax,	byte [rbx]
    cmp       rax,	89
    jz        L9429
    mov       rcx,	rbx
    mov       rdx,	89
    call      mm_lib.insertunit
    mov       rax,	[mm_decls.currproc]
    mov       eax,	[rax+72]
    mov       [rbx+49],	eax
    mov       al,	1
    mov       [rbx+61],	al
L9429:
L9424:
    mov       rdi,	[rdi+8]
L9420:
    test      rdi,	rdi
    jnz       L9419
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_block
mm_type.tx_block:
;?>>
   %define R.p rdi
   %define R.a rbx
   %define R.t rsi
   %define R.lv r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
    mov       r12,	r9
;---------------
    jmp       L9432
L9431:
    mov       rcx,	rbx
    xor       edx,	edx
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rbx,	[rbx+8]
L9432:
    test      rbx,	rbx
    jz        L9434
    mov       rax,	[rbx+8]
    test      rax,	rax
    jnz       L9431
L9434:
    test      rbx,	rbx
    jz        L9436
    mov       rcx,	rbx
    mov       rdx,	rsi
    mov       r8,	r12
    call      mm_type.tpass
    test      rsi,	rsi
    jz        L9438
    movsxd    rax,	dword [rbx+49]
    jmp       L9437
L9438:
    xor       eax,	eax
L9437:
    mov       [rdi+49],	eax
L9436:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_typetable
mm_type.tx_typetable:
;?>>
   %define R.d rdi
   %define R.i rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
;---------------
    mov       rbx,	31
    mov       rax,	[mm_decls.ntypes]
    cmp       rax,	31
    jl        L9442
L9440:
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rbx
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	8
    jnz       L9444
    lea       rax,	[mm_decls.ttnamedef]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8]
    mov       r10,	rax
    mov       rdi,	r10
    mov       rcx,	rax
    call      mm_type.tx_passdef
L9444:
    mov       rcx,	rbx
    call      mm_type.setmodesize
    inc       rbx
    cmp       rbx,	[mm_decls.ntypes]
    jle       L9440
L9442:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.setmodesize
mm_type.setmodesize:
;?>>
   %define R.m rsi
   %define R.size rdi
   %define R.target rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    lea       rax,	[mm_decls.ttsize]
    mov       r10,	rsi
    mov       eax,	[rax + r10*4]
    test      eax,	eax
    jnz       L9445
L9447:
    lea       rax,	[mm_decls.ttlineno]
    mov       r10,	rsi
    movsxd    rax,	dword [rax + r10*4]
    mov       [pc_decls.mmpos],	rax
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rsi
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	10
    jz        L9449
    cmp       rax,	8
    jz        L9450
    test      rax,	rax
    jz        L9451
    cmp       rax,	24
    jz        L9451
    cmp       rax,	11
    jz        L9452
    cmp       rax,	22
    jz        L9453
    cmp       rax,	23
    jz        L9454
    cmp       rax,	29
    jz        L9455
    cmp       rax,	28
    jz        L9456
    jmp       L9457
L9449:
    mov       rcx,	rsi
    call      mm_type.setarraysize
    jmp       L9448
L9450:
    mov       rcx,	rsi
    call      mm_type.setrecordsize
    jmp       L9448
L9451:
    jmp       L9448
L9452:
    mov       rcx,	rsi
    call      mm_type.setslicesize
    jmp       L9448
L9453:
    lea       rcx,	[L13526]
    xor       edx,	edx
    call      mm_support.txerror
    jmp       L9448
L9454:
    jmp       L9448
L9455:
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	rsi
    movsxd    rax,	dword [rax + r10*4]
    mov       rbx,	rax
    mov       rcx,	rbx
    call      mm_type.setmodesize
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rbx
    mov       eax,	[rax + r10*4]
    lea       r10,	[mm_decls.ttbasetype]
    mov       r11,	rsi
    mov       [r10 + r11*4],	eax
    lea       rax,	[mm_decls.ttsize]
    mov       r10,	rbx
    mov       eax,	[rax + r10*4]
    lea       r10,	[mm_decls.ttsize]
    mov       r11,	rsi
    mov       [r10 + r11*4],	eax
    lea       rax,	[mm_decls.ttlower]
    mov       r10,	rbx
    mov       eax,	[rax + r10*4]
    lea       r10,	[mm_decls.ttlower]
    mov       r11,	rsi
    mov       [r10 + r11*4],	eax
    lea       rax,	[mm_decls.ttlength]
    mov       r10,	rbx
    mov       eax,	[rax + r10*4]
    lea       r10,	[mm_decls.ttlength]
    mov       r11,	rsi
    mov       [r10 + r11*4],	eax
    lea       rax,	[mm_decls.ttnamedef]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8]
    lea       r10,	[mm_decls.ttnamedef]
    mov       r11,	rsi
    mov       [r10 + r11*8],	rax
    jmp       L9448
L9456:
    jmp       L9448
L9457:
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rsi
    movsxd    rax,	dword [rax + r10*4]
    lea       r10,	[mm_decls.ttsize]
    mov       r10d,	[r10 + rax*4]
    mov       rdi,	r10
    test      r10,	r10
    jz        L9459
    mov       eax,	edi
    lea       r10,	[mm_decls.ttsize]
    mov       r11,	rsi
    mov       [r10 + r11*4],	eax
    jmp       L9445
L9459:
    call      msys.m$print_startcon
    lea       rcx,	[L13527]
    call      msys.m$print_str_nf
    mov       rcx,	rsi
    mov       rdx,	1
    call      mm_lib.strmode
    mov       rcx,	rax
    call      msys.m$print_str_nf
    lea       rcx,	[L13528]
    call      msys.m$print_str_nf
    mov       rcx,	rsi
    call      msys.m$print_i64_nf
    lea       rcx,	[L13529]
    call      msys.m$print_str_nf
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rsi
    movsxd    rax,	dword [rax + r10*4]
    lea       r10,	[mm_tables.stdnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       rcx,	[L13530]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L9448:
L9445:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.setarraysize
mm_type.setarraysize:
;?>>
    %define mm_type.setarraysize.m 72
   %define R.lower rdi
   %define R.length rbx
   %define R.elemsize rsi
   %define R.target r12
   %define R.size r13
   %define R.pdim r14
   %define R.a r15
    %define mm_type.setarraysize.b -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       [rbp+72],	rcx
;---------------
    lea       rax,	[mm_decls.ttsizeset]
    mov       r10,	[rbp + mm_type.setarraysize.m]
    mov       al,	[rax + r10]
    test      al,	al
    jnz       L9460
L9462:
    lea       rax,	[mm_decls.ttdimexpr]
    mov       r10,	[rbp + mm_type.setarraysize.m]
    mov       r14,	[rax + r10*8]
    test      r14,	r14
    jz        L9464
    mov       r15,	[r14+16]
    mov       rax,	[r14+24]
    mov       [rbp + mm_type.setarraysize.b],	rax
    lea       rax,	[mm_decls.ttowner]
    mov       r10,	[rbp + mm_type.setarraysize.m]
    mov       rax,	[rax + r10*8]
    mov       rcx,	rax
    mov       rdx,	r14
    call      mm_name.rx_unit
    movzx     rax,	byte [r14]
    cmp       rax,	21
    jz        L9466
    cmp       rax,	27
    jz        L9467
    jmp       L9468
L9466:
    mov       rcx,	r15
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rcx,	[rbp + mm_type.setarraysize.b]
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rcx,	r15
    call      mm_type.getconstint
    mov       rdi,	rax
    mov       rcx,	[rbp + mm_type.setarraysize.b]
    call      mm_type.getconstint
    sub       rax,	rdi
    inc       rax
    mov       rbx,	rax
    jmp       L9465
L9467:
    mov       rcx,	r15
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rcx,	r15
    call      mm_type.getconstint
    mov       rdi,	rax
    mov       rax,	[rbp + mm_type.setarraysize.b]
    test      rax,	rax
    jz        L9470
    mov       rcx,	[rbp + mm_type.setarraysize.b]
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rcx,	[rbp + mm_type.setarraysize.b]
    call      mm_type.getconstint
    mov       rbx,	rax
    jmp       L9469
L9470:
    xor       rbx,	rbx
L9469:
    jmp       L9465
L9468:
    mov       rcx,	r14
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rcx,	r14
    call      mm_type.getconstint
    mov       rbx,	rax
    mov       rdi,	1
L9465:
    jmp       L9463
L9464:
    mov       rdi,	1
    xor       rbx,	rbx
L9463:
    cmp       rbx,	0
    jge       L9472
    lea       rcx,	[L13531]
    xor       edx,	edx
    call      mm_support.txerror
L9472:
    xor       eax,	eax
    lea       r10,	[mm_decls.ttdimexpr]
    mov       r11,	[rbp + mm_type.setarraysize.m]
    mov       [r10 + r11*8],	rax
    mov       eax,	edi
    lea       r10,	[mm_decls.ttlower]
    mov       r11,	[rbp + mm_type.setarraysize.m]
    mov       [r10 + r11*4],	eax
    mov       eax,	ebx
    lea       r10,	[mm_decls.ttlength]
    mov       r11,	[rbp + mm_type.setarraysize.m]
    mov       [r10 + r11*4],	eax
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	[rbp + mm_type.setarraysize.m]
    movsxd    rax,	dword [rax + r10*4]
    mov       r12,	rax
    mov       rcx,	r12
    call      mm_type.setmodesize
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	[rbp + mm_type.setarraysize.m]
    movsxd    rax,	dword [rax + r10*4]
    lea       r10,	[mm_decls.ttsize]
    mov       r10d,	[r10 + rax*4]
    mov       rsi,	r10
    mov       rax,	rbx
    imul      rax,	rsi
    mov       r13,	rax
    lea       r10,	[mm_decls.ttsize]
    mov       r11,	[rbp + mm_type.setarraysize.m]
    mov       [r10 + r11*4],	eax
    mov       al,	1
    lea       r10,	[mm_decls.ttsizeset]
    mov       r11,	[rbp + mm_type.setarraysize.m]
    mov       [r10 + r11],	al
    mov       rcx,	[rbp + mm_type.setarraysize.m]
    call      mm_type.checkblocktype
L9460:
;---------------
    add       rsp,	40
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.setslicesize
mm_type.setslicesize:
;?>>
   %define R.m rbx
   %define R.pdim rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    lea       rax,	[mm_decls.ttsize]
    mov       r10,	rbx
    mov       eax,	[rax + r10*4]
    test      eax,	eax
    jnz       L9473
L9475:
    lea       rax,	[mm_decls.ttdimexpr]
    mov       r10,	rbx
    mov       rdi,	[rax + r10*8]
    test      rdi,	rdi
    jz        L9477
    lea       rax,	[mm_decls.ttowner]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8]
    mov       rcx,	rax
    mov       rdx,	rdi
    call      mm_name.rx_unit
    mov       rcx,	rdi
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rcx,	rdi
    call      mm_type.getconstint
    lea       r10,	[mm_decls.ttlower]
    mov       r11,	rbx
    mov       [r10 + r11*4],	eax
    xor       eax,	eax
    lea       r10,	[mm_decls.ttdimexpr]
    mov       r11,	rbx
    mov       [r10 + r11*8],	rax
    jmp       L9476
L9477:
    mov       eax,	1
    lea       r10,	[mm_decls.ttlower]
    mov       r11,	rbx
    mov       [r10 + r11*4],	eax
L9476:
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	rbx
    movsxd    rax,	dword [rax + r10*4]
    mov       rcx,	rax
    call      mm_type.setmodesize
    lea       rax,	[mm_decls.ttsize]
    mov       eax,	[rax+44]
    lea       r10,	[mm_decls.ttsize]
    mov       r11,	rbx
    mov       [r10 + r11*4],	eax
L9473:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_module
mm_type.tx_module:
;?>>
   %define R.n rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       [mm_decls.currmoduleno],	rdi
    lea       rax,	[mm_decls.modules]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8]
    mov       rcx,	[rax+24]
    call      mm_type.tx_passdef
    mov       rax,	1
L9478:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_passdef
mm_type.tx_passdef:
;?>>
   %define R.p r12
   %define R.d rdi
   %define R.oldmmpos rbx
   %define R.q rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       r12,	rcx
;---------------
    movzx     rax,	word [r12+92]
    shr       eax,	2
    and       eax,	1
    test      rax,	rax
    jnz       L9479
L9481:
    mov       rbx,	[pc_decls.mmpos]
    mov       eax,	[r12+88]
    mov       [pc_decls.mmpos],	rax
    mov       rdi,	[r12+16]
    jmp       L9483
L9482:
    mov       rcx,	rdi
    call      mm_type.tx_passdef
    mov       rdi,	[rdi+32]
L9483:
    test      rdi,	rdi
    jnz       L9482
    mov       rsi,	[r12+64]
    movzx     rax,	byte [r12+78]
    cmp       rax,	6
    jz        L9486
    cmp       rax,	9
    jz        L9487
    cmp       rax,	10
    jz        L9488
    cmp       rax,	11
    jz        L9488
    cmp       rax,	12
    jz        L9488
    jmp       L9489
L9486:
    xor       eax,	eax
    mov       [mm_decls.currproc],	rax
    xor       eax,	eax
    mov       [mm_decls.currproc],	rax
    jmp       L9485
L9487:
    mov       rcx,	r12
    call      mm_type.tx_namedconst
    jmp       L9485
L9488:
    mov       rcx,	r12
    call      mm_type.tx_namedef
L9489:
L9485:
    lea       rax,	[r12+92]
    or        byte [rax],	4
    mov       [pc_decls.mmpos],	rbx
L9479:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_unitlist
mm_type.tx_unitlist:
;?>>
   %define R.p rdi
   %define R.t rbx
    %define mm_type.tx_unitlist.lv 48
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    jmp       L9492
L9491:
    mov       rcx,	rdi
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rdi,	[rdi+8]
L9492:
    test      rdi,	rdi
    jnz       L9491
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_namedef
mm_type.tx_namedef:
;?>>
   %define R.d r14
   %define R.m rdi
   %define R.mold rbx
   %define R.inidataold rsi
   %define R.dcode r12
   %define R.pequiv r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       r14,	rcx
;---------------
    movzx     rax,	word [r14+92]
    shr       eax,	3
    and       eax,	1
    test      rax,	rax
    jz        L9496
    lea       rcx,	[L13532]
    xor       edx,	edx
    call      mm_support.txerror
L9496:
    movzx     rax,	word [r14+92]
    shr       eax,	2
    and       eax,	1
    test      rax,	rax
    jnz       L9494
L9498:
    movsxd    rax,	dword [r14+72]
    mov       rdi,	rax
    mov       rcx,	rdi
    call      mm_type.setmodesize
    mov       r12,	[r14+64]
    lea       rax,	[r14+92]
    or        byte [rax],	8
    movzx     rax,	word [r14+92]
    shr       eax,	8
    and       eax,	1
    test      rax,	rax
    jz        L9500
    mov       r13,	[r14+96]
    movzx     rax,	byte [r13]
    cmp       rax,	55
    jnz       L9502
    mov       rax,	[r13+16]
    mov       rcx,	r13
    mov       rdx,	rax
    call      mm_lib.deleteunit
L9502:
    movzx     rax,	byte [r13]
    cmp       rax,	4
    jz        L9504
    lea       rcx,	[L13533]
    xor       edx,	edx
    call      mm_support.txerror
L9504:
    mov       rcx,	r13
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
L9500:
    test      r12,	r12
    jz        L9506
    movzx     rax,	byte [r14+78]
    cmp       rax,	11
    jz        L9506
    mov       rbx,	rdi
    mov       rcx,	rdi
    call      mm_lib.gettypebase
    mov       rdi,	rax
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rdi
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	11
    jnz       L9508
    movzx     rax,	byte [r12]
    cmp       rax,	1
    jnz       L9508
    movsxd    rax,	dword [r12+49]
    cmp       rax,	20
    jnz       L9508
    mov       rcx,	r12
    mov       rdx,	20
    xor       r8d,	r8d
    call      mm_type.tpass
    jmp       L9507
L9508:
    mov       rsi,	[mm_type.inidata]
    mov       rax,	1
    mov       [mm_type.inidata],	rax
    mov       rcx,	r12
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       [mm_type.inidata],	rsi
L9507:
    lea       rax,	[r14+92]
    and       byte [rax],	247
    lea       rax,	[r14+92]
    or        byte [rax],	4
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rdi
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	10
    jnz       L9510
    lea       rax,	[mm_decls.ttlength]
    mov       r10,	rdi
    movsxd    rax,	dword [rax + r10*4]
    test      rax,	rax
    jnz       L9510
    mov       eax,	[r12+49]
    mov       [r14+72],	eax
L9510:
    cmp       rbx,	rdi
    jz        L9512
    lea       rax,	[mm_decls.ttisinteger]
    mov       r10,	rdi
    mov       al,	[rax + r10]
    test      al,	al
    jz        L9514
    lea       rax,	[mm_decls.ttisshort]
    mov       r10,	rbx
    mov       al,	[rax + r10]
    test      al,	al
    jz        L9514
    mov       rax,	[r14+64]
    mov       rcx,	rax
    mov       rdx,	59
    call      mm_lib.insertunit
    mov       rax,	[r14+64]
    mov       r10d,	ebx
    mov       [rax+49],	r10d
    jmp       L9513
L9514:
    cmp       rbx,	2
    jnz       L9515
    mov       rax,	[r14+64]
    mov       r10d,	ebx
    mov       [rax+49],	r10d
L9515:
L9513:
L9512:
    movzx     rax,	byte [r14+78]
    cmp       rax,	10
    jnz       L9517
    mov       rcx,	[r14+64]
    call      mm_type.checkconstexpr
L9517:
    jmp       L9505
L9506:
    test      r12,	r12
    jz        L9518
    movzx     rax,	byte [r14+78]
    cmp       rax,	11
    jnz       L9518
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rdi
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	10
    jnz       L9518
    lea       rax,	[mm_decls.ttlength]
    mov       r10,	rdi
    movsxd    rax,	dword [rax + r10*4]
    test      rax,	rax
    jnz       L9518
    mov       rcx,	r12
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       eax,	[r12+49]
    mov       [r14+72],	eax
    lea       rax,	[r14+92]
    and       byte [rax],	247
    lea       rax,	[r14+92]
    or        byte [rax],	4
    jmp       L9505
L9518:
    lea       rax,	[r14+92]
    and       byte [rax],	247
    lea       rax,	[r14+92]
    or        byte [rax],	4
L9505:
L9494:
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_namedconst
mm_type.tx_namedconst:
;?>>
   %define R.d rsi
   %define R.m rdi
   %define R.q rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    movzx     rax,	word [rsi+92]
    shr       eax,	3
    and       eax,	1
    test      rax,	rax
    jz        L9521
    lea       rcx,	[L13534]
    xor       edx,	edx
    call      mm_support.txerror
L9521:
    movzx     rax,	word [rsi+92]
    shr       eax,	2
    and       eax,	1
    test      rax,	rax
    jnz       L9519
L9523:
    mov       rbx,	[rsi+64]
    movsxd    rax,	dword [rsi+72]
    mov       rdi,	rax
    lea       rax,	[rsi+92]
    or        byte [rax],	8
    cmp       rdi,	22
    jnz       L9525
    mov       rax,	23
    jmp       L9524
L9525:
    mov       rax,	rdi
L9524:
    mov       rcx,	rbx
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_type.tpass
    lea       rax,	[rsi+92]
    and       byte [rax],	247
    mov       rcx,	rbx
    call      mm_type.checkconstexpr
    cmp       rdi,	22
    jnz       L9527
    mov       eax,	[rbx+49]
    mov       [rsi+72],	eax
L9527:
    movsxd    rax,	dword [rsi+72]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    cmp       r10,	7
    jz        L9529
    jmp       L9530
L9529:
    movsxd    rax,	dword [rsi+72]
    cmp       rax,	20
    jz        L9532
    lea       rcx,	[L13535]
    xor       edx,	edx
    call      mm_support.txerror
L9532:
L9530:
L9528:
    lea       rax,	[rsi+92]
    or        byte [rax],	4
L9519:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.checkconstexpr
mm_type.checkconstexpr:
;?>>
   %define R.p rbx
   %define R.q rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rcx
;---------------
    movzx     rax,	byte [rbx]
    cmp       rax,	1
    jz        L9535
    cmp       rax,	62
    jz        L9535
    cmp       rax,	20
    jz        L9536
    cmp       rax,	58
    jz        L9537
    cmp       rax,	59
    jz        L9538
    cmp       rax,	55
    jz        L9539
    cmp       rax,	56
    jz        L9539
    cmp       rax,	4
    jz        L9540
    jmp       L9541
L9535:
    jmp       L9533
L9536:
    mov       rdi,	[rbx+16]
    jmp       L9543
L9542:
    mov       rcx,	rdi
    call      mm_type.checkconstexpr
    mov       rdi,	[rdi+8]
L9543:
    test      rdi,	rdi
    jnz       L9542
    jmp       L9534
L9537:
    mov       rax,	[rbx+16]
    movsxd    rax,	dword [rax+49]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    cmp       r10,	7
    jnz       L9546
    mov       eax,	[rbx+49]
    mov       r10,	[rbx+16]
    mov       [r10+49],	eax
    mov       rax,	[rbx+16]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mm_lib.deleteunit
    jmp       L9545
L9546:
    jmp       L9547
L9545:
    jmp       L9534
L9538:
    mov       rcx,	[rbx+16]
    call      mm_type.checkconstexpr
    jmp       L9534
L9539:
    mov       rax,	[rbx+16]
    movzx     rax,	byte [rax]
    cmp       rax,	4
    jnz       L9550
L9549:
    jmp       L9548
L9550:
    jmp       L9547
L9548:
    jmp       L9534
L9540:
    mov       rax,	[rbx+16]
    movzx     rax,	byte [rax+78]
    cmp       rax,	13
    jz        L9533
L9552:
    mov       rax,	[rbx+16]
    movzx     rax,	byte [rax+78]
    cmp       rax,	6
    jz        L9533
L9554:
    mov       rax,	[rbx+16]
    movzx     rax,	byte [rax+78]
    cmp       rax,	14
    jz        L9533
L9556:
    jmp       L9547
L9541:
;mm_type.checkconstexpr.error:
L9547:
    call      msys.m$print_startcon
    lea       rcx,	[L13536]
    call      msys.m$print_str_nf
    movzx     rax,	byte [rbx]
    lea       r10,	[mm_tables.jtagnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    movsxd    rax,	dword [rbx+49]
    mov       rcx,	rax
    mov       rdx,	1
    call      mm_lib.strmode
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	rbx
    xor       edx,	edx
    lea       r8,	[L13537]
    xor       r9d,	r9d
    call      mm_diags.printunit
    lea       rcx,	[L13538]
    xor       edx,	edx
    call      mm_support.txerror
L9534:
L9533:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.getconstint
mm_type.getconstint:
;?>>
   %define R.q rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    call      mm_type.checkconstexpr
    movsxd    rax,	dword [rdi+49]
    lea       r10,	[mm_decls.ttisinteger]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jnz       L9560
    movzx     rax,	byte [rdi]
    cmp       rax,	62
    jnz       L9559
L9560:
    mov       rax,	[rdi+16]
    jmp       L9557
L9559:
    movsxd    rax,	dword [rdi+49]
    lea       r10,	[mm_decls.ttisreal]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L9561
    movq      XMM4,	[rdi+16]
    cvttsd2si rax,	XMM4
    jmp       L9557
L9561:
    call      msys.m$print_startcon
    movsxd    rax,	dword [rdi+49]
    mov       rcx,	rax
    mov       rdx,	1
    call      mm_lib.strmode
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L13539]
    xor       edx,	edx
    call      mm_support.txerror
L9558:
    xor       eax,	eax
L9557:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_type.makenewconst
mm_type.makenewconst:
;?>>
   %define R.p rcx
   %define R.x rdx
   %define R.t r8
;?]]
;---------------
    mov       al,	1
    mov       [rcx],	al
    xor       eax,	eax
    mov       [rcx+24],	rax
    mov       [rcx+16],	rax
    mov       [rcx+16],	rdx
    mov       al,	1
    mov       [rcx+60],	al
    test      r8,	r8
    jz        L9564
    mov       [rcx+49],	r8d
L9564:
;---------------
    ret       
;End 
;Proc mm_type.tx_name
mm_type.tx_name:
;?>>
   %define R.p r12
    %define mm_type.tx_name.t 64
   %define R.lv r13
   %define R.d rdi
   %define R.oldmmpos rbx
   %define R.pcode rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r12,	rcx
    mov       r13,	r8
;---------------
    mov       rbx,	[pc_decls.mmpos]
    mov       al,	[r12+2]
    test      al,	al
    jnz       L9565
L9567:
    lea       rax,	[r12+2]
    inc       byte [rax]
    mov       rdi,	[r12+16]
    mov       eax,	[rdi+88]
    mov       [pc_decls.mmpos],	rax
    movzx     rax,	byte [rdi+78]
    cmp       rax,	9
    jz        L9569
    cmp       rax,	10
    jz        L9570
    cmp       rax,	11
    jz        L9570
    cmp       rax,	12
    jz        L9570
    cmp       rax,	6
    jz        L9571
    cmp       rax,	7
    jz        L9571
    cmp       rax,	14
    jz        L9572
    cmp       rax,	3
    jz        L9573
    cmp       rax,	13
    jz        L9574
    cmp       rax,	5
    jz        L9575
    cmp       rax,	8
    jz        L9576
    jmp       L9577
L9569:
    test      r13,	r13
    jz        L9579
    lea       rcx,	[L13540]
    xor       edx,	edx
    call      mm_support.txerror
L9579:
    mov       rcx,	rdi
    call      mm_type.tx_namedconst
    mov       rsi,	[rdi+64]
    mov       al,	1
    mov       [r12],	al
    xor       eax,	eax
    mov       [r12+16],	rax
    xor       eax,	eax
    mov       [r12+16],	rax
    xor       eax,	eax
    mov       [r12+32],	rax
    movzx     rax,	byte [rsi]
    cmp       rax,	58
    jnz       L9581
    mov       rax,	[rsi+16]
    mov       rax,	[rax+16]
    mov       [r12+16],	rax
    jmp       L9580
L9581:
    mov       rax,	[rsi+16]
    mov       [r12+16],	rax
L9580:
    mov       eax,	[rsi+40]
    mov       [r12+40],	eax
    mov       eax,	[rdi+72]
    mov       [r12+49],	eax
    mov       al,	1
    mov       [r12+60],	al
    mov       al,	[rsi+44]
    mov       [r12+44],	al
    jmp       L9568
L9570:
    movzx     rax,	word [rdi+92]
    shr       eax,	4
    and       eax,	1
    test      rax,	rax
    jz        L9583
    test      r13,	r13
    jz        L9583
    mov       rax,	[rdi]
    lea       rcx,	[L13541]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_support.txerror_s
L9583:
    mov       rcx,	rdi
    call      mm_type.tx_namedef
    mov       rax,	[mm_type.inassem]
    test      rax,	rax
    jnz       L9585
    mov       eax,	[rdi+72]
    mov       [r12+49],	eax
    movzx     rax,	byte [rdi+160]
    cmp       rax,	1
    jnz       L9587
    mov       al,	[r12+1]
    test      al,	al
    jnz       L9589
    lea       rax,	[r12+1]
    inc       byte [rax]
    mov       rcx,	r12
    mov       rdx,	53
    call      mm_lib.insertunit
    movsxd    rax,	dword [rdi+72]
    lea       r10,	[mm_decls.tttarget]
    mov       r10d,	[r10 + rax*4]
    mov       [r12+49],	r10d
L9589:
L9587:
    mov       rcx,	r12
    mov       rdx,	r13
    call      mm_type.twiden
    jmp       L9584
L9585:
    mov       eax,	20
    mov       [r12+49],	eax
L9584:
    jmp       L9568
L9571:
    mov       eax,	[mm_tables.trefproc]
    mov       [r12+49],	eax
    jmp       L9568
L9572:
    mov       eax,	[mm_tables.treflabel]
    mov       [r12+49],	eax
    jmp       L9568
L9573:
    mov       rax,	[rdi]
    lea       rcx,	[L13542]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_support.txerror_s
    jmp       L9568
L9574:
    mov       al,	1
    mov       [r12],	al
    xor       eax,	eax
    mov       [r12+16],	rax
    xor       eax,	eax
    mov       [r12+16],	rax
    xor       eax,	eax
    mov       [r12+32],	rax
    movsxd    rax,	dword [rdi+84]
    mov       [r12+16],	rax
    mov       eax,	3
    mov       [r12+49],	eax
    mov       al,	1
    mov       [r12+60],	al
    jmp       L9568
L9575:
    mov       al,	62
    mov       [r12],	al
    movsxd    rax,	dword [rdi+72]
    mov       [r12+16],	rax
    mov       eax,	3
    mov       [r12+49],	eax
    jmp       L9568
L9576:
    mov       rax,	[rdi+64]
    test      rax,	rax
    jz        L9591
    lea       rcx,	[L13543]
    xor       edx,	edx
    call      mm_support.txerror
L9591:
    mov       eax,	[rdi+72]
    mov       [r12+49],	eax
    jmp       L9568
L9577:
    mov       eax,	[r12+4]
    mov       [pc_decls.mmpos],	rax
    mov       rax,	[rdi]
    movzx     r10,	byte [rdi+78]
    lea       r11,	[mm_tables.namenames]
    mov       r11,	[r11 + r10*8]
    lea       rcx,	[L13544]
    mov       rdx,	r11
    mov       r8,	rax
    call      mm_support.txerror_ss
L9568:
    mov       [pc_decls.mmpos],	rbx
L9565:
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_bin
mm_type.tx_bin:
;?>>
   %define R.p rsi
   %define R.a r12
   %define R.b r13
   %define R.amode rdi
   %define R.bmode rbx
    %define mm_type.tx_bin.$T1 -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
;---------------
    mov       rcx,	r12
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rcx,	r13
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    movsxd    rax,	dword [r12+49]
    mov       rdi,	rax
    movsxd    rax,	dword [r13+49]
    mov       rbx,	rax
    movzx     rax,	byte [rsi+62]
    cmp       rax,	43
    jz        L9594
    cmp       rax,	44
    jz        L9595
    cmp       rax,	45
    jz        L9596
    cmp       rax,	46
    jz        L9597
    cmp       rax,	47
    jz        L9598
    cmp       rax,	48
    jz        L9598
    cmp       rax,	49
    jz        L9598
    cmp       rax,	50
    jz        L9598
    cmp       rax,	51
    jz        L9598
    cmp       rax,	52
    jz        L9598
    cmp       rax,	55
    jz        L9599
    cmp       rax,	56
    jz        L9599
    cmp       rax,	82
    jz        L9600
    cmp       rax,	83
    jz        L9601
    cmp       rax,	81
    jz        L9601
    cmp       rax,	53
    jz        L9602
    cmp       rax,	54
    jz        L9602
    jmp       L9603
L9594:
    mov       rcx,	rsi
    mov       rdx,	r12
    mov       r8,	r13
    call      mm_type.dobinnumx
    test      rax,	rax
    jnz       L9592
L9605:
    lea       rax,	[mm_decls.ttisref]
    mov       r10,	rdi
    mov       al,	[rax + r10]
    test      al,	al
    jz        L9607
    lea       rax,	[mm_decls.ttisref]
    mov       r10,	rbx
    mov       al,	[rax + r10]
    test      al,	al
    jz        L9609
    mov       al,	[r12+44]
    test      al,	al
    jz        L9609
    mov       al,	[r13+44]
    test      al,	al
    jz        L9609
    mov       rcx,	rsi
    call      mm_type.combinestrings
    jmp       L9592
L9609:
    cmp       rbx,	5
    jg        L9611
    mov       rcx,	r13
    mov       rdx,	3
    xor       r8d,	r8d
    call      mm_type.coerceunit
    mov       al,	57
    mov       [rsi+62],	al
    mov       [rsi+49],	edi
    jmp       L9592
L9611:
L9607:
    jmp       L9593
L9595:
    mov       rcx,	rsi
    mov       rdx,	r12
    mov       r8,	r13
    call      mm_type.dobinnumx
    test      rax,	rax
    jnz       L9592
L9613:
    lea       rax,	[mm_decls.ttisref]
    mov       r10,	rdi
    mov       al,	[rax + r10]
    test      al,	al
    jz        L9615
    lea       rax,	[mm_decls.ttisref]
    mov       r10,	rbx
    mov       al,	[rax + r10]
    test      al,	al
    jz        L9617
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mm_type.comparemodes
    test      rax,	rax
    jz        L9619
    mov       al,	59
    mov       [rsi+62],	al
    mov       eax,	3
    mov       [rsi+49],	eax
    jmp       L9592
L9619:
    lea       rcx,	[L13545]
    xor       edx,	edx
    call      mm_support.txerror
L9618:
L9617:
    cmp       rbx,	5
    jg        L9621
    mov       rcx,	r13
    mov       rdx,	3
    xor       r8d,	r8d
    call      mm_type.coerceunit
    mov       al,	58
    mov       [rsi+62],	al
    mov       [rsi+49],	edi
    jmp       L9592
L9621:
L9615:
    jmp       L9593
L9596:
    mov       rcx,	rsi
    mov       rdx,	r12
    mov       r8,	r13
    call      mm_type.dobinnumx
    test      rax,	rax
    jnz       L9592
L9623:
    lea       rax,	[mm_decls.ttisref]
    mov       r10,	rdi
    mov       al,	[rax + r10]
    test      al,	al
    jz        L9625
    mov       al,	[r12+44]
    test      al,	al
    jz        L9627
    movsxd    rax,	dword [r13+49]
    lea       r10,	[mm_decls.ttisinteger]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L9627
    movzx     rax,	byte [r13]
    cmp       rax,	1
    jnz       L9627
    mov       rcx,	rsi
    call      mm_type.mulstrings
    jmp       L9592
L9627:
L9625:
    jmp       L9593
L9597:
    mov       rax,	rdi
    cmp       rax,	3
    jz        L9630
    cmp       rax,	4
    jz        L9630
    cmp       rax,	5
    jnz       L9629
L9630:
    mov       rax,	rbx
    cmp       rax,	3
    jz        L9631
    cmp       rax,	4
    jz        L9631
    cmp       rax,	5
    jnz       L9629
L9631:
    mov       al,	47
    mov       [rsi+62],	al
    jmp       L9632
L9629:
    mov       rcx,	rsi
    mov       rdx,	r12
    mov       r8,	r13
    call      mm_type.dobinnumf
    test      rax,	rax
    jnz       L9592
L9634:
    cmp       rdi,	5
    jg        L9636
    cmp       rbx,	5
    jg        L9636
    mov       eax,	1
    mov       [rsi+49],	eax
    mov       rcx,	r12
    mov       rdx,	1
    xor       r8d,	r8d
    call      mm_type.coerceunit
    mov       rcx,	r13
    mov       rdx,	1
    xor       r8d,	r8d
    call      mm_type.coerceunit
    jmp       L9592
L9636:
    jmp       L9593
L9598:
;mm_type.tx_bin.doidiv:
L9632:
    mov       rcx,	rsi
    mov       rdx,	r12
    mov       r8,	r13
    call      mm_type.dobinnumi
    test      rax,	rax
    jnz       L9592
L9638:
    jmp       L9593
L9599:
    mov       rcx,	rsi
    mov       rdx,	r12
    mov       r8,	r13
    call      mm_type.dobinnumx
    test      rax,	rax
    jnz       L9592
L9640:
    jmp       L9593
L9600:
    mov       rcx,	rsi
    mov       rdx,	r12
    mov       r8,	r13
    call      mm_type.dobinnumx
    test      rax,	rax
    jnz       L9592
L9642:
    jmp       L9593
L9601:
    mov       rcx,	r12
    mov       rdx,	1
    xor       r8d,	r8d
    call      mm_type.coerceunit
    mov       rcx,	r13
    mov       rdx,	1
    xor       r8d,	r8d
    call      mm_type.coerceunit
    mov       eax,	1
    mov       [rsi+49],	eax
    jmp       L9592
L9602:
    mov       rax,	rdi
    cmp       rax,	3
    jz        L9645
    cmp       rax,	4
    jz        L9645
    cmp       rax,	5
    jnz       L9644
L9645:
    mov       rcx,	r13
    mov       rdx,	3
    xor       r8d,	r8d
    call      mm_type.coerceunit
    mov       [rsi+49],	edi
    jmp       L9592
L9644:
    jmp       L9593
L9603:
    mov       al,	[rsi+64]
    test      al,	al
    jz        L9647
    mov       rcx,	rsi
    mov       rdx,	r12
    mov       r8,	r13
    call      mm_type.dobinnumx
    test      rax,	rax
    jz        L9649
    mov       eax,	6
    mov       [rsi+49],	eax
    jmp       L9592
L9649:
    mov       eax,	6
    mov       [rsi+49],	eax
    lea       rax,	[mm_decls.ttisref]
    mov       r10,	rdi
    mov       al,	[rax + r10]
    test      al,	al
    jz        L9651
    lea       rax,	[mm_decls.ttisref]
    mov       r10,	rbx
    mov       al,	[rax + r10]
    test      al,	al
    jz        L9651
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mm_type.comparemodes
    test      rax,	rax
    jnz       L9653
    lea       rcx,	[L13546]
    xor       edx,	edx
    call      mm_support.txerror
L9653:
    jmp       L9592
L9651:
    movzx     rax,	byte [rsi+64]
    cmp       rax,	1
    jz        L9656
    cmp       rax,	2
    jnz       L9655
L9656:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mm_type.comparemodes
    test      rax,	rax
    jnz       L9592
L9658:
L9655:
    jmp       L9646
L9647:
    lea       rcx,	[L13547]
    xor       edx,	edx
    call      mm_support.txerror
L9646:
L9593:
    call      msys.m$print_startcon
    movzx     rax,	byte [rsi+62]
    lea       r10,	[pc_tables.pclnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	rbx
    mov       rdx,	1
    call      mm_lib.strmode2
    mov       [rbp + mm_type.tx_bin.$T1],	rax
    mov       rcx,	rdi
    mov       rdx,	1
    call      mm_lib.strmode
    lea       rcx,	[L13548]
    mov       rdx,	rax
    mov       r8,	[rbp + mm_type.tx_bin.$T1]
    call      mm_support.txerror_ss
L9592:
;---------------
    add       rsp,	40
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_binto
mm_type.tx_binto:
;?>>
   %define R.p r13
   %define R.a r14
   %define R.b r15
   %define R.abase rdi
   %define R.bbase rbx
   %define R.amode rsi
   %define R.bmode r12
    %define mm_type.tx_binto.$T1 -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       r13,	rcx
    mov       r14,	rdx
    mov       r15,	r8
;---------------
    mov       rcx,	r14
    mov       rdx,	23
    call      mm_type.tpasslv
    mov       rcx,	r15
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    movsxd    rax,	dword [r14+49]
    mov       rsi,	rax
    movsxd    rax,	dword [r15+49]
    mov       r12,	rax
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rsi
    movsxd    rax,	dword [rax + r10*4]
    mov       rdi,	rax
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	r12
    movsxd    rax,	dword [rax + r10*4]
    mov       rbx,	rax
    movzx     rax,	byte [r13+62]
    cmp       rax,	93
    jnz       L9661
    lea       rax,	[mm_decls.ttisinteger]
    mov       r10,	rdi
    mov       al,	[rax + r10]
    test      al,	al
    jz        L9661
    mov       al,	94
    mov       [r13+62],	al
L9661:
    xor       eax,	eax
    mov       [r13+49],	eax
    movzx     rax,	byte [r13+62]
    cmp       rax,	90
    jz        L9663
    cmp       rax,	91
    jz        L9664
    cmp       rax,	99
    jz        L9665
    cmp       rax,	100
    jz        L9665
    cmp       rax,	96
    jz        L9665
    cmp       rax,	97
    jz        L9665
    cmp       rax,	98
    jz        L9665
    jmp       L9666
L9663:
    cmp       rdi,	7
    jnz       L9668
    cmp       rbx,	7
    jnz       L9668
    lea       rcx,	[L13549]
    xor       edx,	edx
    call      mm_support.txerror
L9668:
    cmp       rdi,	7
    jnz       L9670
    cmp       rbx,	5
    jg        L9670
    mov       rcx,	r15
    mov       rdx,	3
    xor       r8d,	r8d
    call      mm_type.coerceunit
    mov       al,	103
    mov       [r13+62],	al
    jmp       L9659
L9670:
    jmp       L9662
L9664:
    cmp       rdi,	7
    jnz       L9672
    cmp       rbx,	5
    jg        L9672
    mov       rcx,	r15
    mov       rdx,	3
    xor       r8d,	r8d
    call      mm_type.coerceunit
    mov       al,	104
    mov       [r13+62],	al
    jmp       L9659
L9672:
    jmp       L9662
L9665:
    mov       rcx,	r15
    mov       rdx,	3
    xor       r8d,	r8d
    call      mm_type.coerceunit
    jmp       L9659
L9666:
L9662:
    cmp       rdi,	5
    jg        L9674
    cmp       rbx,	5
    jg        L9674
    mov       rcx,	r15
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mm_type.coerceunit
    jmp       L9673
L9674:
    lea       rax,	[mm_decls.ttisshort]
    mov       r10,	rdi
    mov       al,	[rax + r10]
    test      al,	al
    jz        L9675
    cmp       rbx,	5
    jg        L9675
    mov       rcx,	r15
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mm_type.coerceunit
    jmp       L9673
L9675:
    mov       rcx,	rsi
    mov       rdx,	r12
    call      mm_type.comparemodes
    test      rax,	rax
    jnz       L9677
    mov       rcx,	r12
    mov       rdx,	1
    call      mm_lib.strmode
    mov       [rbp + mm_type.tx_binto.$T1],	rax
    mov       rcx,	rsi
    mov       rdx,	1
    call      mm_lib.strmode
    lea       rcx,	[L13550]
    mov       rdx,	rax
    mov       r8,	[rbp + mm_type.tx_binto.$T1]
    call      mm_support.txerror_ss
L9677:
L9673:
L9659:
;---------------
    add       rsp,	40
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.getdominantmode
mm_type.getdominantmode:
;?>>
   %define R.amode rsi
   %define R.bmode r12
   %define R.abase rdi
   %define R.bbase rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rsi
    movsxd    rax,	dword [rax + r10*4]
    mov       rdi,	rax
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	r12
    movsxd    rax,	dword [rax + r10*4]
    mov       rbx,	rax
    cmp       rdi,	5
    jg        L9680
    cmp       rbx,	5
    jg        L9680
    mov       rax,	rdi
    mov       r10,	rbx
    cmp       rax,	r10
    cmovg     rax,	r10
    jmp       L9678
L9680:
    mov       rcx,	rsi
    mov       rdx,	r12
    call      mm_type.comparemodes
    test      rax,	rax
    jnz       L9682
    lea       rcx,	[L13551]
    xor       edx,	edx
    call      mm_support.txerror
L9682:
    mov       rax,	rsi
L9678:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_cmpchain
mm_type.tx_cmpchain:
;?>>
   %define R.p r15
    %define mm_type.tx_cmpchain.a 80
   %define R.u rdi
   %define R.genop rbx
   %define R.q rsi
   %define R.r r12
   %define R.av_1 r13
   %define R.i r14
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       r15,	rcx
    mov       [rbp+80],	rdx
;---------------
    mov       rsi,	[rbp + mm_type.tx_cmpchain.a]
    jmp       L9685
L9684:
    mov       rcx,	rsi
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    cmp       rsi,	[rbp + mm_type.tx_cmpchain.a]
    jnz       L9688
    movsxd    rax,	dword [rsi+49]
    mov       rdi,	rax
    jmp       L9687
L9688:
    movsxd    rax,	dword [rsi+49]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mm_type.getdominantmode
    mov       rdi,	rax
L9687:
    mov       rsi,	[rsi+8]
L9685:
    test      rsi,	rsi
    jnz       L9684
    mov       rsi,	[rbp + mm_type.tx_cmpchain.a]
    mov       rax,	[rbp + mm_type.tx_cmpchain.a]
    mov       r12,	[rax+8]
    jmp       L9690
L9689:
    mov       rcx,	rsi
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mm_type.coerceunit
    mov       rsi,	[rsi+8]
L9690:
    test      rsi,	rsi
    jnz       L9689
    mov       r14,	1
    mov       r13,	4
    cmp       r13,	1
    jl        L9694
L9692:
    lea       rax,	[r15+40]
    mov       r10,	r14
    movzx     rax,	byte [rax + r10-1]
    mov       rbx,	rax
    test      rbx,	rbx
    jnz       L9696
    jmp       L9694
L9696:
    mov       rcx,	rdi
    call      mm_lib.getpclmode
    lea       r10,	[r15+32]
    mov       r11,	r14
    mov       [r10 + r11*2-2],	ax
    inc       r14
    cmp       r14,	r13
    jle       L9692
L9694:
    mov       eax,	3
    mov       [r15+49],	eax
;---------------
    add       rsp,	40
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_callproc
mm_type.tx_callproc:
;?>>
   %define R.p r13
   %define R.a r14
    %define mm_type.tx_callproc.pargs 80
    %define mm_type.tx_callproc.t 88
   %define R.q rdi
   %define R.d rbx
   %define R.e rsi
   %define R.pm r12
    %define mm_type.tx_callproc.paramlist -800
    %define mm_type.tx_callproc.arglist -1600
    %define mm_type.tx_callproc.newarglist -2400
    %define mm_type.tx_callproc.nparams -2408
    %define mm_type.tx_callproc.i -2416
    %define mm_type.tx_callproc.j -2424
    %define mm_type.tx_callproc.k -2432
    %define mm_type.tx_callproc.nargs -2440
    %define mm_type.tx_callproc.m -2448
    %define mm_type.tx_callproc.kwdused -2456
    %define mm_type.tx_callproc.qm -2464
    %define mm_type.tx_callproc.ismproc -2472
    %define mm_type.tx_callproc.name -2480
    %define mm_type.tx_callproc.ulist -2488
    %define mm_type.tx_callproc.ulistx -2496
    %define mm_type.tx_callproc.$T1 -2504
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	2544
    mov       r13,	rcx
    mov       r14,	rdx
    mov       [rbp+80],	r8
    mov       [rbp+88],	r9
;---------------
    mov       rcx,	r14
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    xor       eax,	eax
    mov       [rbp + mm_type.tx_callproc.nparams],	rax
    mov       [rbp + mm_type.tx_callproc.nargs],	rax
    xor       eax,	eax
    mov       [rbp + mm_type.tx_callproc.ismproc],	rax
;mm_type.tx_callproc.retry:
L9698:
    movzx     rax,	byte [r14]
    cmp       rax,	4
    jz        L9700
    cmp       rax,	92
    jz        L9701
    cmp       rax,	112
    jz        L9701
    cmp       rax,	6
    jz        L9701
    jmp       L9702
L9700:
    mov       rbx,	[r14+16]
    movzx     rax,	byte [rbx+78]
    cmp       rax,	6
    jz        L9705
    cmp       rax,	7
    jnz       L9704
L9705:
    movzx     rax,	byte [rbx+78]
    cmp       rax,	6
    setz      al
    movzx     eax,	al
    mov       [rbp + mm_type.tx_callproc.ismproc],	rax
;mm_type.tx_callproc.getparams:
L9706:
    mov       rsi,	[rbx+16]
    jmp       L9708
L9707:
    movzx     rax,	byte [rsi+78]
    cmp       rax,	12
    jnz       L9711
    mov       rax,	[rbp + mm_type.tx_callproc.nparams]
    cmp       rax,	100
    jl        L9713
    lea       rcx,	[L13552]
    xor       edx,	edx
    call      mm_support.txerror
L9713:
    inc       qword [rbp + mm_type.tx_callproc.nparams]
    mov       rax,	[rbp + mm_type.tx_callproc.nparams]
    mov       r10,	rsi
    mov       [rbp + rax*8 + mm_type.tx_callproc.paramlist-8],	r10
L9711:
    mov       rsi,	[rsi+32]
L9708:
    test      rsi,	rsi
    jnz       L9707
    jmp       L9703
L9704:
    jmp       L9715
L9714:
    mov       rcx,	r14
    mov       rdx,	53
    call      mm_lib.insertunit
    movsxd    rax,	dword [r14+49]
    lea       r10,	[mm_decls.tttarget]
    mov       r10d,	[r10 + rax*4]
    mov       [r14+49],	r10d
L9715:
    movsxd    rax,	dword [r14+49]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    cmp       r10,	7
    jz        L9714
    jmp       L9717
L9703:
    jmp       L9699
L9701:
    lea       rcx,	[L13553]
    xor       edx,	edx
    call      mm_support.txerror
    jmp       L9699
L9702:
;mm_type.tx_callproc.dorefproc:
L9717:
    movzx     rax,	byte [r14]
    cmp       rax,	49
    jnz       L9719
    mov       rcx,	r13
    mov       rdx,	r14
    mov       r8,	[rbp + mm_type.tx_callproc.pargs]
    call      mm_type.tmethodcall
    mov       r14,	[r13+16]
    mov       rax,	[r13+24]
    mov       [rbp + mm_type.tx_callproc.pargs],	rax
    jmp       L9698
L9719:
    movsxd    rax,	dword [r14+49]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    cmp       r10,	24
    jz        L9721
    lea       rcx,	[L13554]
    xor       edx,	edx
    call      mm_support.txerror
L9721:
    movsxd    rax,	dword [r14+49]
    lea       r10,	[mm_decls.ttnamedef]
    mov       r10,	[r10 + rax*8]
    mov       rbx,	r10
    test      rbx,	rbx
    jnz       L9723
    lea       rcx,	[L13555]
    xor       edx,	edx
    call      mm_support.txerror
L9723:
    jmp       L9706
L9699:
    mov       rdi,	[rbp + mm_type.tx_callproc.pargs]
    jmp       L9725
L9724:
    mov       rax,	[rbp + mm_type.tx_callproc.nargs]
    cmp       rax,	100
    jl        L9728
    lea       rcx,	[L13556]
    xor       edx,	edx
    call      mm_support.txerror
L9728:
    inc       qword [rbp + mm_type.tx_callproc.nargs]
    mov       rax,	[rbp + mm_type.tx_callproc.nargs]
    mov       r10,	rdi
    mov       [rbp + rax*8 + mm_type.tx_callproc.arglist-8],	r10
    mov       rdi,	[rdi+8]
L9725:
    test      rdi,	rdi
    jnz       L9724
    mov       eax,	[rbx+72]
    mov       [r13+49],	eax
    mov       eax,	[r13+49]
    test      eax,	eax
    jz        L9730
    mov       rax,	[rbp + mm_type.tx_callproc.t]
    test      rax,	rax
    jz        L9730
    mov       rcx,	r13
    xor       edx,	edx
    call      mm_type.twiden
L9730:
    mov       al,	[rbx+123]
    test      al,	al
    jz        L9732
    mov       rax,	1
    mov       [rbp + mm_type.tx_callproc.i],	rax
    mov       rax,	[rbp + mm_type.tx_callproc.nargs]
    cmp       rax,	1
    jl        L9735
L9733:
    mov       rax,	[rbp + mm_type.tx_callproc.i]
    cmp       rax,	[rbp + mm_type.tx_callproc.nparams]
    jg        L9737
    mov       rax,	[rbp + mm_type.tx_callproc.i]
    mov       rax,	[rbp + rax*8 + mm_type.tx_callproc.paramlist-8]
    movsxd    rax,	dword [rax+72]
    mov       r10,	[rbp + mm_type.tx_callproc.i]
    mov       r10,	[rbp + r10*8 + mm_type.tx_callproc.arglist-8]
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_type.tpass
    jmp       L9736
L9737:
    mov       rax,	[rbp + mm_type.tx_callproc.i]
    mov       rax,	[rbp + rax*8 + mm_type.tx_callproc.arglist-8]
    mov       rcx,	rax
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
L9736:
    mov       rax,	[rbp + mm_type.tx_callproc.i]
    inc       rax
    mov       [rbp + mm_type.tx_callproc.i],	rax
    cmp       rax,	[rbp + mm_type.tx_callproc.nargs]
    jle       L9733
L9735:
    jmp       L9697
L9732:
    xor       eax,	eax
    mov       [rbp + mm_type.tx_callproc.k],	rax
    xor       eax,	eax
    mov       [rbp + mm_type.tx_callproc.kwdused],	rax
    mov       rax,	1
    mov       [rbp + mm_type.tx_callproc.i],	rax
    mov       rax,	[rbp + mm_type.tx_callproc.nparams]
    cmp       rax,	1
    jl        L9740
L9738:
    xor       eax,	eax
    mov       r10,	[rbp + mm_type.tx_callproc.i]
    mov       [rbp + r10*8 + mm_type.tx_callproc.newarglist-8],	rax
    mov       rax,	[rbp + mm_type.tx_callproc.i]
    inc       rax
    mov       [rbp + mm_type.tx_callproc.i],	rax
    cmp       rax,	[rbp + mm_type.tx_callproc.nparams]
    jle       L9738
L9740:
    mov       rax,	1
    mov       [rbp + mm_type.tx_callproc.i],	rax
    mov       rax,	[rbp + mm_type.tx_callproc.nargs]
    cmp       rax,	1
    jl        L9743
L9741:
    mov       rax,	[rbp + mm_type.tx_callproc.i]
    mov       rdi,	[rbp + rax*8 + mm_type.tx_callproc.arglist-8]
    movzx     rax,	byte [rdi]
    cmp       rax,	26
    jnz       L9746
L9745:
    mov       rax,	[rdi+16]
    mov       rax,	[rax+16]
    mov       rax,	[rax]
    mov       [rbp + mm_type.tx_callproc.name],	rax
    mov       rax,	1
    mov       [rbp + mm_type.tx_callproc.j],	rax
    mov       rax,	[rbp + mm_type.tx_callproc.nparams]
    cmp       rax,	1
    jl        L9750
L9747:
    mov       rax,	[rbp + mm_type.tx_callproc.j]
    mov       rax,	[rbp + rax*8 + mm_type.tx_callproc.paramlist-8]
    mov       rax,	[rax]
    mov       rcx,	rax
    mov       rdx,	[rbp + mm_type.tx_callproc.name]
    call      mlib.eqstring
    test      rax,	rax
    jnz       L9749
L9752:
    mov       rax,	[rbp + mm_type.tx_callproc.j]
    inc       rax
    mov       [rbp + mm_type.tx_callproc.j],	rax
    cmp       rax,	[rbp + mm_type.tx_callproc.nparams]
    jle       L9747
L9750:
    lea       rcx,	[L13557]
    mov       rdx,	[rbp + mm_type.tx_callproc.name]
    xor       r8d,	r8d
    call      mm_support.txerror_s
L9749:
    mov       rax,	[rbp + mm_type.tx_callproc.j]
    mov       rax,	[rbp + rax*8 + mm_type.tx_callproc.newarglist-8]
    test      rax,	rax
    jz        L9754
    lea       rcx,	[L13558]
    mov       rdx,	[rbp + mm_type.tx_callproc.name]
    xor       r8d,	r8d
    call      mm_support.txerror_s
L9754:
    mov       rax,	[rdi+24]
    mov       r10,	[rbp + mm_type.tx_callproc.j]
    mov       [rbp + r10*8 + mm_type.tx_callproc.newarglist-8],	rax
    mov       rax,	1
    mov       [rbp + mm_type.tx_callproc.kwdused],	rax
    jmp       L9744
L9746:
    mov       rax,	[rbp + mm_type.tx_callproc.kwdused]
    test      rax,	rax
    jz        L9756
    lea       rcx,	[L13559]
    xor       edx,	edx
    call      mm_support.txerror
L9756:
    mov       rax,	[rbp + mm_type.tx_callproc.k]
    cmp       rax,	[rbp + mm_type.tx_callproc.nparams]
    jl        L9758
    call      msys.m$print_startcon
    lea       rcx,	[L13560]
    call      msys.m$print_str_nf
    mov       rcx,	[rbp + mm_type.tx_callproc.k]
    call      msys.m$print_i64_nf
    lea       rcx,	[L13561]
    call      msys.m$print_str_nf
    mov       rcx,	[rbp + mm_type.tx_callproc.nparams]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L13562]
    xor       edx,	edx
    call      mm_support.txerror
L9758:
    movzx     rax,	byte [rdi]
    cmp       rax,	2
    jnz       L9760
    xor       eax,	eax
    jmp       L9759
L9760:
    mov       rax,	rdi
L9759:
    inc       qword [rbp + mm_type.tx_callproc.k]
    mov       r10,	[rbp + mm_type.tx_callproc.k]
    mov       [rbp + r10*8 + mm_type.tx_callproc.newarglist-8],	rax
L9744:
    mov       rax,	[rbp + mm_type.tx_callproc.i]
    inc       rax
    mov       [rbp + mm_type.tx_callproc.i],	rax
    cmp       rax,	[rbp + mm_type.tx_callproc.nargs]
    jle       L9741
L9743:
    mov       rax,	1
    mov       [rbp + mm_type.tx_callproc.i],	rax
    mov       rax,	[rbp + mm_type.tx_callproc.nparams]
    cmp       rax,	1
    jl        L9763
L9761:
    mov       rax,	[rbp + mm_type.tx_callproc.i]
    mov       rdi,	[rbp + rax*8 + mm_type.tx_callproc.newarglist-8]
    mov       rax,	[rbp + mm_type.tx_callproc.i]
    mov       r12,	[rbp + rax*8 + mm_type.tx_callproc.paramlist-8]
    test      rdi,	rdi
    jnz       L9765
    mov       al,	[r12+161]
    test      al,	al
    jnz       L9767
    mov       rcx,	[rbp + mm_type.tx_callproc.i]
    xor       edx,	edx
    call      msys.strint
    lea       rcx,	[L13563]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_support.txerror_s
L9767:
    mov       rax,	[r12+64]
    test      rax,	rax
    jz        L9769
    mov       eax,	[r13+4]
    mov       r10,	[r12+64]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mm_lib.duplunit
    mov       r10,	[rbp + mm_type.tx_callproc.i]
    mov       [rbp + r10*8 + mm_type.tx_callproc.newarglist-8],	rax
    jmp       L9768
L9769:
    xor       ecx,	ecx
    mov       rdx,	3
    call      mm_lib.createconstunit
    mov       r10,	[rbp + mm_type.tx_callproc.i]
    mov       [rbp + r10*8 + mm_type.tx_callproc.newarglist-8],	rax
L9768:
L9765:
    mov       rax,	[rbp + mm_type.tx_callproc.i]
    inc       rax
    mov       [rbp + mm_type.tx_callproc.i],	rax
    cmp       rax,	[rbp + mm_type.tx_callproc.nparams]
    jle       L9761
L9763:
    xor       eax,	eax
    mov       [rbp + mm_type.tx_callproc.ulist],	rax
    xor       eax,	eax
    mov       [rbp + mm_type.tx_callproc.ulistx],	rax
    mov       rax,	1
    mov       [rbp + mm_type.tx_callproc.i],	rax
    mov       rax,	[rbp + mm_type.tx_callproc.nparams]
    cmp       rax,	1
    jl        L9772
L9770:
    mov       rax,	[rbp + mm_type.tx_callproc.i]
    mov       r12,	[rbp + rax*8 + mm_type.tx_callproc.paramlist-8]
    mov       rax,	[rbp + mm_type.tx_callproc.i]
    mov       rdi,	[rbp + rax*8 + mm_type.tx_callproc.newarglist-8]
    movzx     rax,	byte [r12+160]
    cmp       rax,	1
    jnz       L9774
    movsxd    rax,	dword [r12+72]
    lea       r10,	[mm_decls.tttarget]
    movsxd    r10,	dword [r10 + rax*4]
    mov       [rbp + mm_type.tx_callproc.m],	r10
    mov       rcx,	rdi
    mov       rdx,	r10
    mov       r8,	1
    call      mm_type.tpass
    movsxd    rax,	dword [rdi+49]
    mov       [rbp + mm_type.tx_callproc.qm],	rax
    mov       rcx,	[rbp + mm_type.tx_callproc.qm]
    mov       rdx,	[rbp + mm_type.tx_callproc.m]
    call      mm_type.comparemodes
    test      rax,	rax
    jnz       L9776
    mov       rcx,	[rbp + mm_type.tx_callproc.m]
    mov       rdx,	1
    call      mm_lib.strmode
    mov       [rbp + mm_type.tx_callproc.$T1],	rax
    mov       rcx,	[rbp + mm_type.tx_callproc.qm]
    mov       rdx,	1
    call      mm_lib.strmode
    lea       rcx,	[L13564]
    mov       rdx,	rax
    mov       r8,	[rbp + mm_type.tx_callproc.$T1]
    call      mm_support.txerror_ss
L9776:
    mov       rcx,	rdi
    mov       rdx,	55
    call      mm_lib.insertunit
    mov       eax,	[r12+72]
    mov       [rdi+49],	eax
    jmp       L9773
L9774:
    movsxd    rax,	dword [r12+72]
    mov       rcx,	rdi
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_type.tpass
L9773:
    lea       rcx,	[rbp + mm_type.tx_callproc.ulist]
    lea       rdx,	[rbp + mm_type.tx_callproc.ulistx]
    mov       r8,	rdi
    call      mm_lib.addlistunit
    xor       eax,	eax
    mov       [rdi+8],	rax
    mov       rax,	[rbp + mm_type.tx_callproc.i]
    inc       rax
    mov       [rbp + mm_type.tx_callproc.i],	rax
    cmp       rax,	[rbp + mm_type.tx_callproc.nparams]
    jle       L9770
L9772:
    mov       rax,	[rbp + mm_type.tx_callproc.ulist]
    mov       [r13+24],	rax
L9697:
;---------------
    add       rsp,	2544
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_unary
mm_type.tx_unary:
;?>>
   %define R.p rsi
   %define R.a r12
   %define R.amode rdi
   %define R.resmode rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    mov       rcx,	r12
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    movsxd    rax,	dword [r12+49]
    mov       rdi,	rax
    mov       rbx,	rdi
    movzx     rax,	byte [rsi+62]
    cmp       rax,	73
    jz        L9779
    cmp       rax,	74
    jz        L9779
    cmp       rax,	75
    jz        L9779
    cmp       rax,	76
    jz        L9779
    cmp       rax,	67
    jz        L9779
    cmp       rax,	68
    jz        L9779
    cmp       rax,	69
    jz        L9779
    cmp       rax,	70
    jz        L9779
    cmp       rax,	71
    jz        L9779
    cmp       rax,	72
    jz        L9779
    cmp       rax,	78
    jz        L9779
    cmp       rax,	79
    jz        L9779
    cmp       rax,	60
    jz        L9780
    cmp       rax,	61
    jz        L9780
    cmp       rax,	66
    jz        L9780
    cmp       rax,	62
    jz        L9781
    cmp       rax,	63
    jz        L9781
    cmp       rax,	64
    jz        L9781
    cmp       rax,	80
    jz        L9782
    jmp       L9783
L9779:
    mov       rcx,	r12
    mov       rdx,	1
    xor       r8d,	r8d
    call      mm_type.coerceunit
    mov       rbx,	1
    jmp       L9778
L9780:
    cmp       rdi,	5
    jle       L9785
    lea       rcx,	[L13565]
    xor       edx,	edx
    call      mm_support.txerror
L9785:
    jmp       L9778
L9781:
    cmp       rdi,	2
    jg        L9787
    lea       rcx,	[L13566]
    xor       edx,	edx
    call      mm_support.txerror
L9787:
    jmp       L9778
L9782:
    mov       rbx,	3
    jmp       L9778
L9783:
    call      msys.m$print_startcon
    lea       rcx,	[L13567]
    call      msys.m$print_str_nf
    movzx     rax,	byte [rsi+62]
    lea       r10,	[pc_tables.pclnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L9778:
    mov       [rsi+49],	ebx
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_prop
mm_type.tx_prop:
;?>>
   %define R.p r14
   %define R.a r15
   %define R.size rdi
   %define R.amode rbx
   %define R.mbase rsi
   %define R.x r12
   %define R.resmode r13
    %define mm_type.tx_prop.$T1 -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       r14,	rcx
    mov       r15,	rdx
;---------------
    mov       rcx,	r15
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    movsxd    rax,	dword [r15+49]
    mov       rbx,	rax
    mov       r13,	rbx
    movzx     rax,	byte [r14+62]
    cmp       rax,	3
    jz        L9790
    cmp       rax,	4
    jz        L9790
    cmp       rax,	2
    jz        L9790
    cmp       rax,	5
    jz        L9790
    cmp       rax,	1
    jz        L9790
    cmp       rax,	7
    jz        L9791
    cmp       rax,	6
    jz        L9791
    cmp       rax,	9
    jz        L9792
    cmp       rax,	10
    jz        L9792
    cmp       rax,	8
    jz        L9793
    jmp       L9794
L9790:
    mov       rcx,	r14
    mov       rdx,	r15
    call      mm_type.do_bounds
    jmp       L9788
L9791:
    movzx     rax,	byte [r15]
    cmp       rax,	62
    jnz       L9796
    mov       rax,	[r15+16]
    jmp       L9795
L9796:
    movsxd    rax,	dword [r15+49]
L9795:
    lea       r10,	[mm_decls.ttsize]
    mov       r10d,	[r10 + rax*4]
    mov       [rbp + mm_type.tx_prop.$T1],	r10
    movzx     rax,	byte [r14+62]
    cmp       rax,	7
    jnz       L9798
    mov       rax,	1
    jmp       L9797
L9798:
    mov       rax,	8
L9797:
    mov       r10,	[rbp + mm_type.tx_prop.$T1]
    imul      r10,	rax
    mov       rdi,	r10
    mov       rcx,	r14
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mm_type.makenewconst
    mov       r13,	3
    jmp       L9789
L9792:
    mov       r13,	3
    movzx     rax,	byte [r15]
    cmp       rax,	62
    jnz       L9800
    mov       rax,	[r15+16]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    mov       rsi,	r10
    jmp       L9799
L9800:
    movsxd    rax,	dword [r15+49]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    mov       rsi,	r10
L9799:
    movzx     rax,	byte [r14+62]
    cmp       rax,	9
    jnz       L9802
    mov       rax,	rsi
    cmp       rax,	14
    jz        L9804
    cmp       rax,	15
    jz        L9805
    cmp       rax,	16
    jz        L9806
    cmp       rax,	3
    jz        L9807
    cmp       rax,	17
    jz        L9808
    cmp       rax,	18
    jz        L9808
    cmp       rax,	19
    jz        L9808
    cmp       rax,	4
    jz        L9808
    cmp       rax,	12
    jz        L9808
    cmp       rax,	5
    jz        L9808
    jmp       L9809
L9804:
    mov       r12,	-128
    jmp       L9803
L9805:
    mov       r12,	-32768
    jmp       L9803
L9806:
    mov       r12,	-2147483648
    jmp       L9803
L9807:
    mov       r12,	-9223372036854775808
    jmp       L9803
L9808:
    xor       r12,	r12
    jmp       L9803
L9809:
    mov       rcx,	rsi
    mov       rdx,	1
    call      mm_lib.strmode
    lea       rcx,	[L13568]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_support.txerror_s
L9803:
    jmp       L9801
L9802:
    mov       rax,	rsi
    cmp       rax,	14
    jz        L9811
    cmp       rax,	15
    jz        L9812
    cmp       rax,	16
    jz        L9813
    cmp       rax,	3
    jz        L9814
    cmp       rax,	17
    jz        L9815
    cmp       rax,	12
    jz        L9815
    cmp       rax,	18
    jz        L9816
    cmp       rax,	19
    jz        L9817
    cmp       rax,	4
    jz        L9818
    jmp       L9819
L9811:
    mov       r12,	127
    jmp       L9810
L9812:
    mov       r12,	32767
    jmp       L9810
L9813:
    mov       r12,	2147483647
    jmp       L9810
L9814:
    mov       r12,	9223372036854775807
    jmp       L9810
L9815:
    mov       r12,	255
    jmp       L9810
L9816:
    mov       r12,	65535
    jmp       L9810
L9817:
    mov       r12,	4294967295
    jmp       L9810
L9818:
    xor       r12,	r12
    dec       r12
    mov       r13,	4
    jmp       L9810
L9819:
    mov       rcx,	rsi
    mov       rdx,	1
    call      mm_lib.strmode
    lea       rcx,	[L13569]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_support.txerror_s
L9810:
L9801:
    mov       al,	1
    mov       [r14],	al
    xor       eax,	eax
    mov       [r14+16],	rax
    mov       [r14+16],	r12
    mov       al,	1
    mov       [r14+60],	al
    jmp       L9789
L9793:
    mov       al,	1
    mov       [r14],	al
    movzx     rax,	byte [r15]
    cmp       rax,	62
    jnz       L9821
    mov       rbx,	[r15+16]
    jmp       L9820
L9821:
    movsxd    rax,	dword [r15+49]
    mov       rbx,	rax
L9820:
    mov       eax,	20
    mov       [r14+49],	eax
    mov       rcx,	rbx
    mov       rdx,	1
    call      mm_lib.strmode
    mov       rcx,	rax
    call      mlib.pcm_copyheapstring
    mov       [r14+16],	rax
    mov       al,	1
    mov       [r14+44],	al
    mov       rax,	[r14+16]
    mov       rcx,	rax
    call      strlen
    mov       [r14+40],	eax
    jmp       L9788
L9794:
    call      msys.m$print_startcon
    lea       rcx,	[L13570]
    call      msys.m$print_str_nf
    movzx     rax,	byte [r14+62]
    lea       r10,	[pc_tables.pclnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L9789:
    mov       [r14+49],	r13d
L9788:
;---------------
    add       rsp,	40
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_unaryto
mm_type.tx_unaryto:
;?>>
   %define R.p rdi
   %define R.a rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rbx
    mov       rdx,	23
    call      mm_type.tpasslv
    movzx     rax,	byte [rdi+62]
    cmp       rax,	107
    jz        L9824
    cmp       rax,	108
    jz        L9824
    cmp       rax,	109
    jnz       L9825
L9824:
    movsxd    rax,	dword [rbx+49]
    cmp       rax,	2
    jg        L9827
    lea       rcx,	[L13571]
    xor       edx,	edx
    call      mm_support.txerror
L9827:
L9825:
L9823:
    xor       eax,	eax
    mov       [rdi+49],	eax
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_if
mm_type.tx_if:
;?>>
   %define R.p r12
   %define R.pcond r13
   %define R.plist r14
    %define mm_type.tx_if.pelse 88
    %define mm_type.tx_if.t 96
    %define mm_type.tx_if.lv 104
   %define R.pc rdi
   %define R.pl rbx
   %define R.u rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       r12,	rcx
    mov       r13,	rdx
    mov       r14,	r8
    mov       [rbp+88],	r9
;---------------
    mov       rdi,	r13
    mov       rbx,	r14
    xor       rsi,	rsi
    mov       rax,	[rbp + mm_type.tx_if.t]
    cmp       rax,	23
    jz        L9830
    mov       rsi,	[rbp + mm_type.tx_if.t]
L9830:
    jmp       L9834
L9831:
    mov       rcx,	rdi
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rcx,	rbx
    mov       rdx,	[rbp + mm_type.tx_if.t]
    mov       r8,	[rbp + mm_type.tx_if.lv]
    call      mm_type.tpass
    mov       rax,	[rbp + mm_type.tx_if.t]
    cmp       rax,	23
    jnz       L9836
    test      rsi,	rsi
    jnz       L9838
    movsxd    rax,	dword [rbx+49]
    mov       rsi,	rax
    jmp       L9837
L9838:
    mov       rax,	[rbp + mm_type.tx_if.lv]
    test      rax,	rax
    jz        L9839
    movsxd    rax,	dword [rbx+49]
    mov       rcx,	rsi
    mov       rdx,	rax
    call      mm_type.comparemodes
    test      rax,	rax
    jnz       L9841
    lea       rcx,	[L13572]
    xor       edx,	edx
    call      mm_support.txerror
L9841:
    jmp       L9837
L9839:
    movsxd    rax,	dword [rbx+49]
    mov       rcx,	rsi
    mov       rdx,	rax
    call      mm_type.getdominantmode
    mov       rsi,	rax
L9837:
L9836:
    mov       rdi,	[rdi+8]
    mov       rbx,	[rbx+8]
L9834:
    test      rdi,	rdi
    jnz       L9831
    mov       rax,	[rbp + mm_type.tx_if.t]
    test      rax,	rax
    jz        L9843
    mov       rax,	[rbp + mm_type.tx_if.pelse]
    test      rax,	rax
    jnz       L9843
    lea       rcx,	[L13573]
    xor       edx,	edx
    call      mm_support.txerror
L9843:
    mov       rcx,	[rbp + mm_type.tx_if.pelse]
    mov       rdx,	[rbp + mm_type.tx_if.t]
    mov       r8,	[rbp + mm_type.tx_if.lv]
    call      mm_type.tpass
    mov       rax,	[rbp + mm_type.tx_if.t]
    cmp       rax,	23
    jnz       L9845
    mov       rax,	[rbp + mm_type.tx_if.lv]
    test      rax,	rax
    jz        L9847
    mov       rax,	[rbp + mm_type.tx_if.pelse]
    movsxd    rax,	dword [rax+49]
    mov       rcx,	rsi
    mov       rdx,	rax
    call      mm_type.comparemodes
    test      rax,	rax
    jnz       L9849
    lea       rcx,	[L13574]
    xor       edx,	edx
    call      mm_support.txerror
    jmp       L9848
L9849:
    mov       rax,	[rbp + mm_type.tx_if.pelse]
    movsxd    rax,	dword [rax+49]
    mov       rcx,	rsi
    mov       rdx,	rax
    call      mm_type.getdominantmode
    mov       rsi,	rax
L9848:
L9847:
L9845:
    mov       rax,	[rbp + mm_type.tx_if.t]
    test      rax,	rax
    jz        L9851
    mov       rbx,	r14
    jmp       L9855
L9852:
    mov       rax,	[rbp + mm_type.tx_if.t]
    cmp       rax,	23
    jnz       L9857
    mov       rcx,	rbx
    mov       rdx,	rsi
    xor       r8d,	r8d
    call      mm_type.coerceunit
L9857:
    mov       rbx,	[rbx+8]
L9855:
    test      rbx,	rbx
    jnz       L9852
    mov       rax,	[rbp + mm_type.tx_if.t]
    cmp       rax,	23
    jnz       L9859
    mov       rcx,	[rbp + mm_type.tx_if.pelse]
    mov       rdx,	rsi
    xor       r8d,	r8d
    call      mm_type.coerceunit
L9859:
    mov       [r12+49],	esi
L9851:
    mov       rax,	[r13+8]
    mov       r10,	[r14+8]
    cmp       r10,	rax
    jnz       L9861
    test      r10,	r10
    jnz       L9861
    mov       rcx,	r13
    call      mm_type.iscondtrue
    test      rax,	rax
    jz        L9863
    mov       rcx,	r12
    mov       rdx,	r14
    call      mm_lib.deleteunit
    jmp       L9862
L9863:
    mov       rcx,	r13
    call      mm_type.iscondfalse
    test      rax,	rax
    jz        L9864
    mov       rax,	[rbp + mm_type.tx_if.pelse]
    test      rax,	rax
    jnz       L9866
    mov       rcx,	6
    call      mm_lib.createunit0
    mov       [rbp + mm_type.tx_if.pelse],	rax
L9866:
    mov       rcx,	r12
    mov       rdx,	[rbp + mm_type.tx_if.pelse]
    call      mm_lib.deleteunit
L9864:
L9862:
L9861:
;---------------
    add       rsp,	32
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_incrto
mm_type.tx_incrto:
;?>>
   %define R.p rdi
   %define R.a rbx
   %define R.t rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    mov       rcx,	rbx
    mov       rdx,	23
    call      mm_type.tpasslv
    test      rsi,	rsi
    jz        L9869
    movzx     rax,	byte [rdi+62]
    cmp       rax,	84
    jz        L9871
    cmp       rax,	85
    jz        L9872
    jmp       L9873
L9871:
    mov       al,	86
    mov       [rdi+62],	al
    jmp       L9870
L9872:
    mov       al,	87
    mov       [rdi+62],	al
L9873:
L9870:
    mov       eax,	[rbx+49]
    mov       [rdi+49],	eax
    jmp       L9868
L9869:
    movzx     rax,	byte [rdi+62]
    cmp       rax,	88
    jz        L9875
    cmp       rax,	89
    jz        L9876
    jmp       L9877
L9875:
    mov       al,	84
    mov       [rdi+62],	al
    jmp       L9874
L9876:
    mov       al,	85
    mov       [rdi+62],	al
L9877:
L9874:
    xor       eax,	eax
    mov       [rdi+49],	eax
L9868:
    mov       rcx,	rdi
    xor       edx,	edx
    call      mm_type.twiden
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_for
mm_type.tx_for:
;?>>
   %define R.pindex r12
   %define R.pfrom r13
   %define R.pbody r14
   %define R.pto rdi
   %define R.pstep rbx
   %define R.u rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       r12,	rcx
    mov       r13,	rdx
    mov       r14,	r8
;---------------
    mov       rdi,	[r13+8]
    mov       rbx,	[rdi+8]
    mov       rcx,	r12
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    movzx     rax,	byte [r12]
    cmp       rax,	4
    jz        L9880
    lea       rcx,	[L13575]
    xor       edx,	edx
    call      mm_support.txerror
L9880:
    movsxd    rax,	dword [r12+49]
    mov       rsi,	rax
    mov       rax,	[r12+8]
    mov       rcx,	rax
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rcx,	r13
    mov       rdx,	rsi
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rcx,	rdi
    mov       rdx,	rsi
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rcx,	rbx
    mov       rdx,	rsi
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rcx,	r14
    xor       edx,	edx
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rax,	[r14+8]
    mov       rcx,	rax
    xor       edx,	edx
    xor       r8d,	r8d
    call      mm_type.tpass
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_forall
mm_type.tx_forall:
;?>>
   %define R.pindex r15
    %define mm_type.tx_forall.plist 80
    %define mm_type.tx_forall.pbody 88
   %define R.plocal rdi
   %define R.pfrom rbx
   %define R.pto rsi
   %define R.passign r12
   %define R.mlist r13
   %define R.elemtype r14
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       r15,	rcx
    mov       [rbp+80],	rdx
    mov       [rbp+88],	r8
;---------------
    mov       rdi,	[r15+8]
    mov       rbx,	[rdi+8]
    mov       rsi,	[rbx+8]
    mov       rax,	[rbp + mm_type.tx_forall.plist]
    mov       r12,	[rax+8]
    mov       rcx,	r15
    mov       rdx,	3
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rcx,	rbx
    mov       rdx,	3
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rcx,	rsi
    mov       rdx,	3
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rcx,	[rbp + mm_type.tx_forall.plist]
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rax,	[rbp + mm_type.tx_forall.plist]
    movsxd    rax,	dword [rax+49]
    mov       r13,	rax
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	r13
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	10
    jz        L9883
    cmp       rax,	11
    jz        L9884
    jmp       L9885
L9883:
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	r13
    movsxd    rax,	dword [rax + r10*4]
    mov       r14,	rax
    jmp       L9882
L9884:
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	r13
    movsxd    rax,	dword [rax + r10*4]
    mov       r14,	rax
    jmp       L9882
L9885:
    lea       rcx,	[L13576]
    xor       edx,	edx
    call      mm_support.txerror
L9882:
    mov       rcx,	rdi
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    movsxd    rax,	dword [rdi+49]
    cmp       rax,	23
    jnz       L9887
    mov       [rdi+49],	r14d
    mov       rax,	[rdi+16]
    mov       r10d,	r14d
    mov       [rax+72],	r10d
L9887:
    mov       rcx,	r12
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rcx,	[rbp + mm_type.tx_forall.pbody]
    xor       edx,	edx
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rax,	[rbp + mm_type.tx_forall.pbody]
    mov       rax,	[rax+8]
    mov       rcx,	rax
    xor       edx,	edx
    xor       r8d,	r8d
    call      mm_type.tpass
;---------------
    add       rsp,	40
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_index
mm_type.tx_index:
;?>>
   %define R.p rbx
   %define R.a rsi
   %define R.b r12
   %define R.t r13
    %define mm_type.tx_index.lv 88
   %define R.amode rdi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
    mov       r13,	r9
;---------------
    mov       rcx,	rsi
    mov       rdx,	23
    mov       r8,	[rbp + mm_type.tx_index.lv]
    call      mm_type.tpass
    mov       rax,	r13
    cmp       rax,	0
    setnz     al
    movzx     eax,	al
    mov       rcx,	rsi
    mov       rdx,	rax
    call      mm_type.deref
    movsxd    rax,	dword [rsi+49]
    mov       rdi,	rax
    mov       rcx,	r12
    mov       rdx,	3
    xor       r8d,	r8d
    call      mm_type.tpass
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rdi
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	10
    jz        L9890
    cmp       rax,	11
    jz        L9890
    mov       rcx,	rdi
    mov       rdx,	1
    call      mm_lib.strmode
    lea       rcx,	[L13577]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_support.txerror_s
L9890:
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	rdi
    mov       eax,	[rax + r10*4]
    mov       [rbx+49],	eax
    mov       rcx,	rbx
    mov       rdx,	[rbp + mm_type.tx_index.lv]
    call      mm_type.twiden
;---------------
    add       rsp,	40
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_makerange
mm_type.tx_makerange:
;?>>
   %define R.p rsi
   %define R.a r12
   %define R.b r13
   %define R.amode rdi
   %define R.bmode rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
;---------------
    mov       rcx,	r12
    mov       rdx,	3
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rcx,	r13
    mov       rdx,	3
    xor       r8d,	r8d
    call      mm_type.tpass
    movsxd    rax,	dword [r12+49]
    mov       rdi,	rax
    movsxd    rax,	dword [r13+49]
    mov       rbx,	rax
    mov       rcx,	r12
    mov       rdx,	3
    xor       r8d,	r8d
    call      mm_type.coerceunit
    mov       rcx,	r13
    mov       rdx,	3
    xor       r8d,	r8d
    call      mm_type.coerceunit
    mov       eax,	9
    mov       [rsi+49],	eax
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_ptr
mm_type.tx_ptr:
;?>>
   %define R.p rdi
   %define R.a rbx
    %define mm_type.tx_ptr.t 56
   %define R.lv rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r9
;---------------
    mov       rcx,	rbx
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    movsxd    rax,	dword [rbx+49]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    test      r10,	r10
    jz        L9894
    cmp       r10,	7
    jz        L9895
    cmp       r10,	11
    jz        L9896
    jmp       L9897
L9894:
    lea       rcx,	[L13578]
    xor       edx,	edx
    call      mm_support.txerror
    jmp       L9893
L9895:
    movsxd    rax,	dword [rbx+49]
    lea       r10,	[mm_decls.tttarget]
    mov       r10d,	[r10 + rax*4]
    mov       [rdi+49],	r10d
    jmp       L9893
L9896:
    call      msys.m$print_startcon
    lea       rcx,	[L13579]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L9893
L9897:
    lea       rcx,	[L13580]
    xor       edx,	edx
    call      mm_support.txerror
L9893:
    mov       rcx,	rdi
    mov       rdx,	rsi
    call      mm_type.twiden
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.setrecordsize
mm_type.setrecordsize:
;?>>
   %define R.m r14
    %define mm_type.setrecordsize.fieldlist -1664
   %define R.nfields rdi
    %define mm_type.setrecordsize.size -1672
    %define mm_type.setrecordsize.index -1680
    %define mm_type.setrecordsize.maxalign -1688
   %define R.d rbx
   %define R.e rsi
   %define R.flags r12
   %define R.flag r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	1728
    mov       r14,	rcx
;---------------
    lea       rax,	[mm_decls.ttsize]
    mov       r10,	r14
    mov       eax,	[rax + r10*4]
    test      eax,	eax
    jnz       L9898
L9900:
    inc       qword [mm_type.setrecordsize.depth]
    mov       rax,	[mm_type.setrecordsize.depth]
    cmp       rax,	10
    jle       L9902
    lea       rcx,	[L13581]
    call      mm_support.serror
L9902:
    lea       rax,	[mm_decls.ttnamedef]
    mov       r10,	r14
    mov       rbx,	[rax + r10*8]
    mov       rsi,	[rbx+16]
    xor       rdi,	rdi
    inc       rdi
    mov       rax,	rdi
    mov       r10,	83
    mov       [rbp + rax*8 + mm_type.setrecordsize.fieldlist-8],	r10
    jmp       L9904
L9903:
    movzx     rax,	byte [rsi+78]
    cmp       rax,	13
    jnz       L9907
    cmp       rdi,	200
    jl        L9909
    lea       rcx,	[L13582]
    xor       edx,	edx
    call      mm_support.gerror
L9909:
    movsxd    rax,	dword [rsi+72]
    mov       rcx,	rax
    call      mm_type.setmodesize
    lea       rax,	[rsi+136]
    mov       r12,	rax
L9910:
    movzx     rax,	byte [r12]
    cmp       rax,	83
    jz        L9912
    cmp       rax,	85
    jnz       L9913
L9912:
    movzx     rax,	byte [r12]
    mov       r13,	rax
    inc       rdi
    mov       rax,	rdi
    mov       r10,	r13
    mov       [rbp + rax*8 + mm_type.setrecordsize.fieldlist-8],	r10
    inc       r12
    jmp       L9910
L9913:
    jmp       L9911
L9911:
    inc       rdi
    mov       rax,	rdi
    mov       r10,	rsi
    mov       [rbp + rax*8 + mm_type.setrecordsize.fieldlist-8],	r10
L9914:
    mov       rax,	r12
    inc       r12
    movzx     rax,	byte [rax]
    mov       r13,	rax
    mov       rax,	r13
    cmp       rax,	42
    jz        L9917
    cmp       rax,	69
    jz        L9918
    jmp       L9919
L9917:
    jmp       L9916
L9918:
    inc       rdi
    mov       rax,	rdi
    mov       r10,	69
    mov       [rbp + rax*8 + mm_type.setrecordsize.fieldlist-8],	r10
    jmp       L9916
L9919:
    jmp       L9915
L9916:
    jmp       L9914
L9915:
L9907:
    mov       rsi,	[rsi+32]
L9904:
    test      rsi,	rsi
    jnz       L9903
    inc       rdi
    mov       rax,	rdi
    mov       r10,	69
    mov       [rbp + rax*8 + mm_type.setrecordsize.fieldlist-8],	r10
    xor       eax,	eax
    mov       [rbp + rdi*8 + mm_type.setrecordsize.fieldlist],	rax
    xor       eax,	eax
    mov       [mm_type.countedfields],	rax
    mov       rax,	2
    mov       [rbp + mm_type.setrecordsize.index],	rax
    mov       rax,	1
    mov       [rbp + mm_type.setrecordsize.maxalign],	rax
    sub       rsp,	8
    lea       rax,	[rbp + mm_type.setrecordsize.maxalign]
    push      rax
    movzx     rax,	byte [rbx+149]
    push      rax
    push      0
    mov       rcx,	83
    lea       rdx,	[rbp + mm_type.setrecordsize.fieldlist]
    lea       r8,	[rbp + mm_type.setrecordsize.index]
    lea       r9,	[rbp + mm_type.setrecordsize.size]
    sub       rsp,	32
    call      mm_type.scanrecord
    add       rsp,	64
    mov       al,	[rbx+149]
    test      al,	al
    jz        L9921
    mov       rcx,	[rbp + mm_type.setrecordsize.size]
    mov       rdx,	[rbp + mm_type.setrecordsize.maxalign]
    call      mm_type.roundoffset
    mov       [rbp + mm_type.setrecordsize.size],	rax
    mov       ax,	[rbp + mm_type.setrecordsize.maxalign]
    mov       [rbx+166],	ax
    jmp       L9920
L9921:
    mov       ax,	1
    mov       [rbx+166],	ax
L9920:
    mov       eax,	[rbp + mm_type.setrecordsize.size]
    lea       r10,	[mm_decls.ttsize]
    mov       r11,	r14
    mov       [r10 + r11*4],	eax
    mov       eax,	[mm_type.countedfields]
    lea       r10,	[mm_decls.ttlength]
    mov       r11,	r14
    mov       [r10 + r11*4],	eax
    mov       eax,	1
    lea       r10,	[mm_decls.ttlower]
    mov       r11,	r14
    mov       [r10 + r11*4],	eax
    mov       rcx,	r14
    call      mm_type.checkblocktype
    dec       qword [mm_type.setrecordsize.depth]
L9898:
;---------------
    add       rsp,	1728
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.checkblocktype
mm_type.checkblocktype:
;?>>
   %define R.m rcx
;?]]
;---------------
    lea       rax,	[mm_decls.ttsize]
    mov       r10,	rcx
    mov       eax,	[rax + r10*4]
    cmp       rax,	1
    jz        L9924
    cmp       rax,	2
    jz        L9924
    cmp       rax,	4
    jz        L9924
    cmp       rax,	8
    jnz       L9925
L9924:
    xor       eax,	eax
    lea       r10,	[mm_decls.ttisblock]
    mov       r11,	rcx
    mov       [r10 + r11],	al
L9925:
L9923:
;---------------
    ret       
;End 
;Proc mm_type.scanrecord
mm_type.scanrecord:
;?>>
   %define R.state r13
   %define R.fields r14
    %define mm_type.scanrecord.index 80
    %define mm_type.scanrecord.isize 88
    %define mm_type.scanrecord.offset 96
    %define mm_type.scanrecord.calign 104
    %define mm_type.scanrecord.maxalign 112
   %define R.e rdi
   %define R.f rbx
   %define R.ea rsi
   %define R.size r12
    %define mm_type.scanrecord.fieldsize -8
    %define mm_type.scanrecord.bitoffset -16
    %define mm_type.scanrecord.alignment -24
    %define mm_type.scanrecord.newoffset -32
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       r13,	rcx
    mov       r14,	rdx
    mov       [rbp+80],	r8
    mov       [rbp+88],	r9
;---------------
    xor       r12,	r12
    xor       eax,	eax
    mov       [rbp + mm_type.scanrecord.bitoffset],	rax
    jmp       L9928
L9927:
    mov       rax,	rbx
    cmp       rax,	83
    jz        L9931
    cmp       rax,	85
    jz        L9931
    cmp       rax,	69
    jz        L9932
    jmp       L9933
L9931:
    sub       rsp,	8
    push      qword [rbp + mm_type.scanrecord.maxalign]
    push      qword [rbp + mm_type.scanrecord.calign]
    push      qword [rbp + mm_type.scanrecord.offset]
    mov       rcx,	rbx
    mov       rdx,	r14
    mov       r8,	[rbp + mm_type.scanrecord.index]
    lea       r9,	[rbp + mm_type.scanrecord.fieldsize]
    sub       rsp,	32
    call      mm_type.scanrecord
    add       rsp,	64
    jmp       L9930
L9932:
    cmp       r13,	85
    jnz       L9935
    inc       qword [mm_type.countedfields]
L9935:
    mov       rax,	r12
    mov       r10,	[rbp + mm_type.scanrecord.isize]
    mov       [r10],	rax
    jmp       L9926
L9933:
    movsxd    rax,	dword [rbx+72]
    cmp       rax,	27
    jnz       L9937
    xor       eax,	eax
    mov       [rbp + mm_type.scanrecord.fieldsize],	rax
    mov       rsi,	[rbx+128]
    mov       eax,	[rsi+84]
    mov       [rbx+84],	eax
    mov       al,	[rbp + mm_type.scanrecord.bitoffset]
    mov       [rbx+150],	al
    movzx     rax,	byte [rbx+148]
    add       [rbp + mm_type.scanrecord.bitoffset],	rax
    mov       rax,	[rbx+128]
    movsxd    rax,	dword [rax+72]
    lea       r10,	[mm_decls.ttsize]
    mov       r10d,	[r10 + rax*4]
    shl       r10,	3
    mov       rax,	[rbp + mm_type.scanrecord.bitoffset]
    cmp       rax,	r10
    jle       L9939
    lea       rcx,	[L13583]
    xor       edx,	edx
    call      mm_support.txerror
L9939:
    jmp       L9936
L9937:
    movzx     rax,	word [rbx+92]
    shr       eax,	7
    and       eax,	1
    test      rax,	rax
    jz        L9940
    xor       eax,	eax
    mov       [rbp + mm_type.scanrecord.bitoffset],	rax
    mov       rdi,	[rbx+128]
    xor       eax,	eax
    mov       [rbp + mm_type.scanrecord.fieldsize],	rax
    movsxd    rax,	dword [rdi+84]
    movzx     r10,	byte [rbx+151]
    add       rax,	r10
    mov       [rbx+84],	eax
    jmp       L9936
L9940:
    xor       eax,	eax
    mov       [rbp + mm_type.scanrecord.bitoffset],	rax
    cmp       r13,	83
    jnz       L9942
    inc       qword [mm_type.countedfields]
L9942:
    movsxd    rax,	dword [rbx+72]
    lea       r10,	[mm_decls.ttsize]
    mov       r10d,	[r10 + rax*4]
    mov       [rbp + mm_type.scanrecord.fieldsize],	r10
    mov       rax,	[rbp + mm_type.scanrecord.calign]
    test      rax,	rax
    jz        L9944
    movsxd    rax,	dword [rbx+72]
    mov       rcx,	rax
    call      mm_lib.getalignment
    mov       [rbp + mm_type.scanrecord.alignment],	rax
    mov       rax,	[rbp + mm_type.scanrecord.maxalign]
    mov       rax,	[rax]
    mov       r10,	[rbp + mm_type.scanrecord.alignment]
    cmp       r10,	rax
    jle       L9946
    mov       rax,	[rbp + mm_type.scanrecord.alignment]
    mov       r10,	[rbp + mm_type.scanrecord.maxalign]
    mov       [r10],	rax
L9946:
    mov       rcx,	[rbp + mm_type.scanrecord.offset]
    mov       rdx,	[rbp + mm_type.scanrecord.alignment]
    call      mm_type.roundoffset
    mov       [rbp + mm_type.scanrecord.newoffset],	rax
    mov       rax,	[rbp + mm_type.scanrecord.newoffset]
    sub       rax,	[rbp + mm_type.scanrecord.offset]
    add       r12,	rax
    jmp       L9943
L9944:
    mov       rax,	[rbp + mm_type.scanrecord.offset]
    mov       [rbp + mm_type.scanrecord.newoffset],	rax
L9943:
    mov       eax,	[rbp + mm_type.scanrecord.newoffset]
    mov       [rbx+84],	eax
    mov       rax,	[rbp + mm_type.scanrecord.newoffset]
    mov       [rbp + mm_type.scanrecord.offset],	rax
L9936:
L9930:
    cmp       r13,	83
    jnz       L9948
    mov       rax,	[rbp + mm_type.scanrecord.fieldsize]
    add       [rbp + mm_type.scanrecord.offset],	rax
    mov       rax,	[rbp + mm_type.scanrecord.fieldsize]
    add       r12,	rax
    jmp       L9947
L9948:
    mov       rax,	r12
    mov       r10,	[rbp + mm_type.scanrecord.fieldsize]
    cmp       rax,	r10
    cmovl     rax,	r10
    mov       r12,	rax
L9947:
L9928:
    mov       rax,	[rbp + mm_type.scanrecord.index]
    mov       r10,	[rax]
    inc       qword [rax]
    mov       r10,	[r14 + r10*8-8]
    mov       rbx,	r10
    test      r10,	r10
    jnz       L9927
L9926:
;---------------
    add       rsp,	64
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.roundoffset
mm_type.roundoffset:
;?>>
   %define R.offset rcx
   %define R.alignment rdx
   %define R.mask rdi
    push      rdi
;?]]
    sub       rsp,	16
;---------------
    cmp       rdx,	1
    jnz       L9951
    mov       rax,	rcx
    jmp       L9949
L9951:
    lea       rax,	[rdx-1]
    mov       rdi,	rax
    jmp       L9953
L9952:
    inc       rcx
L9953:
    mov       rax,	rcx
    and       rax,	rdi
    jnz       L9952
    mov       rax,	rcx
L9949:
;---------------
    add       rsp,	16
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_convert
mm_type.tx_convert:
;?>>
   %define R.p rdi
   %define R.a rbx
   %define R.hard rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    movzx     rax,	byte [rbx]
    cmp       rax,	20
    jnz       L9958
L9957:
    movsxd    rax,	dword [rdi+53]
    mov       r10,	[rbx+16]
    mov       rcx,	rbx
    mov       rdx,	r10
    mov       r8,	rax
    xor       r9d,	r9d
    call      mm_type.tx_makelist
    jmp       L9956
L9958:
    mov       rcx,	rbx
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    movsxd    rax,	dword [rdi+53]
    mov       rcx,	rbx
    mov       rdx,	rax
    mov       r8,	rsi
    call      mm_type.coerceunit
L9956:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mm_lib.deleteunit
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_makelist
mm_type.tx_makelist:
;?>>
   %define R.p r12
   %define R.a r13
    %define mm_type.tx_makelist.t 80
    %define mm_type.tx_makelist.lv 88
   %define R.alength rdi
   %define R.tlength rbx
   %define R.elemtype rsi
    %define mm_type.tx_makelist.newt -8
    %define mm_type.tx_makelist.isconst -16
    %define mm_type.tx_makelist.q -24
    %define mm_type.tx_makelist.e -32
    %define mm_type.tx_makelist.$T1 -40
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	80
    mov       r12,	rcx
    mov       r13,	rdx
    mov       [rbp+80],	r8
    mov       [rbp+88],	r9
;---------------
    mov       eax,	[r12+40]
    mov       rdi,	rax
    xor       eax,	eax
    mov       [rbp + mm_type.tx_makelist.newt],	rax
    mov       rax,	1
    mov       [rbp + mm_type.tx_makelist.isconst],	rax
    lea       rax,	[mm_decls.ttlength]
    mov       r10,	[rbp + mm_type.tx_makelist.t]
    movsxd    rax,	dword [rax + r10*4]
    mov       rbx,	rax
    test      rbx,	rbx
    jz        L9961
    cmp       rdi,	rbx
    jge       L9963
    mov       rcx,	rbx
    xor       edx,	edx
    call      msys.strint
    mov       [rbp + mm_type.tx_makelist.$T1],	rax
    mov       rcx,	rdi
    xor       edx,	edx
    call      msys.strint
    lea       rcx,	[L13584]
    mov       rdx,	rax
    mov       r8,	[rbp + mm_type.tx_makelist.$T1]
    call      mm_support.txerror_ss
    jmp       L9962
L9963:
    cmp       rdi,	rbx
    jle       L9964
    mov       rcx,	rbx
    xor       edx,	edx
    call      msys.strint
    mov       [rbp + mm_type.tx_makelist.$T1],	rax
    mov       rcx,	rdi
    xor       edx,	edx
    call      msys.strint
    lea       rcx,	[L13585]
    mov       rdx,	rax
    mov       r8,	[rbp + mm_type.tx_makelist.$T1]
    call      mm_support.txerror_ss
L9964:
L9962:
L9961:
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	[rbp + mm_type.tx_makelist.t]
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	10
    jz        L9966
    cmp       rax,	8
    jz        L9967
    cmp       rax,	11
    jz        L9968
    jmp       L9969
L9966:
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	[rbp + mm_type.tx_makelist.t]
    movsxd    rax,	dword [rax + r10*4]
    mov       rsi,	rax
    test      rbx,	rbx
    jnz       L9971
    sub       rsp,	8
    push      0
    lea       rax,	[mm_decls.ttlower]
    mov       r10,	[rbp + mm_type.tx_makelist.t]
    movsxd    rax,	dword [rax + r10*4]
    xor       ecx,	ecx
    mov       rdx,	rsi
    mov       r8,	rax
    mov       r9,	rdi
    sub       rsp,	32
    call      mm_lib.createarraymodek
    add       rsp,	48
    mov       [rbp + mm_type.tx_makelist.newt],	rax
    jmp       L9970
L9971:
    mov       rax,	[rbp + mm_type.tx_makelist.t]
    mov       [rbp + mm_type.tx_makelist.newt],	rax
L9970:
    mov       [rbp + mm_type.tx_makelist.q],	r13
    jmp       L9973
L9972:
    mov       rcx,	[rbp + mm_type.tx_makelist.q]
    mov       rdx,	rsi
    mov       r8,	[rbp + mm_type.tx_makelist.lv]
    call      mm_type.tpass
    mov       rax,	[rbp + mm_type.tx_makelist.q]
    movzx     rax,	byte [rax]
    cmp       rax,	1
    jz        L9976
    xor       eax,	eax
    mov       [rbp + mm_type.tx_makelist.isconst],	rax
L9976:
    mov       rax,	[rbp + mm_type.tx_makelist.q]
    mov       rax,	[rax+8]
    mov       [rbp + mm_type.tx_makelist.q],	rax
L9973:
    mov       rax,	[rbp + mm_type.tx_makelist.q]
    test      rax,	rax
    jnz       L9972
    mov       eax,	[rbp + mm_type.tx_makelist.newt]
    mov       [r12+49],	eax
    jmp       L9965
L9967:
    lea       rax,	[mm_decls.ttnamedef]
    mov       r10,	[rbp + mm_type.tx_makelist.t]
    mov       rax,	[rax + r10*8]
    mov       rax,	[rax+16]
    mov       [rbp + mm_type.tx_makelist.e],	rax
    mov       [rbp + mm_type.tx_makelist.q],	r13
    jmp       L9978
L9977:
    mov       rax,	[rbp + mm_type.tx_makelist.e]
    movzx     rax,	byte [rax+78]
    cmp       rax,	13
    jnz       L9981
    jmp       L9983
L9982:
    mov       rax,	[rbp + mm_type.tx_makelist.e]
    mov       rax,	[rax+32]
    mov       [rbp + mm_type.tx_makelist.e],	rax
    mov       rax,	[rbp + mm_type.tx_makelist.e]
    test      rax,	rax
    jz        L9984
L9986:
L9983:
    mov       rax,	[rbp + mm_type.tx_makelist.e]
    movsxd    rax,	dword [rax+72]
    cmp       rax,	27
    jz        L9982
L9984:
    mov       rax,	[rbp + mm_type.tx_makelist.e]
    movsxd    rax,	dword [rax+72]
    mov       rcx,	[rbp + mm_type.tx_makelist.q]
    mov       rdx,	rax
    mov       r8,	[rbp + mm_type.tx_makelist.lv]
    call      mm_type.tpass
    mov       rax,	[rbp + mm_type.tx_makelist.q]
    movzx     rax,	byte [rax]
    cmp       rax,	1
    jz        L9988
    xor       eax,	eax
    mov       [rbp + mm_type.tx_makelist.isconst],	rax
L9988:
    mov       rax,	[rbp + mm_type.tx_makelist.q]
    mov       rax,	[rax+8]
    mov       [rbp + mm_type.tx_makelist.q],	rax
L9981:
    mov       rax,	[rbp + mm_type.tx_makelist.e]
    mov       rax,	[rax+32]
    mov       [rbp + mm_type.tx_makelist.e],	rax
L9978:
    mov       rax,	[rbp + mm_type.tx_makelist.q]
    test      rax,	rax
    jz        L9989
    mov       rax,	[rbp + mm_type.tx_makelist.e]
    test      rax,	rax
    jnz       L9977
L9989:
    jmp       L9991
L9990:
    mov       rax,	[rbp + mm_type.tx_makelist.e]
    mov       rax,	[rax+32]
    mov       [rbp + mm_type.tx_makelist.e],	rax
L9991:
    mov       rax,	[rbp + mm_type.tx_makelist.e]
    test      rax,	rax
    jz        L9993
    mov       rax,	[rbp + mm_type.tx_makelist.e]
    movzx     rax,	byte [rax+78]
    cmp       rax,	13
    jnz       L9990
    mov       rax,	[rbp + mm_type.tx_makelist.e]
    movsxd    rax,	dword [rax+72]
    cmp       rax,	27
    jz        L9990
L9993:
    mov       rax,	[rbp + mm_type.tx_makelist.q]
    test      rax,	rax
    jnz       L9996
    mov       rax,	[rbp + mm_type.tx_makelist.e]
    test      rax,	rax
    jz        L9995
L9996:
    lea       rcx,	[L13586]
    xor       edx,	edx
    call      mm_support.txerror
L9995:
    mov       eax,	[rbp + mm_type.tx_makelist.t]
    mov       [r12+49],	eax
    mov       al,	1
    mov       [r12+61],	al
    jmp       L9965
L9968:
    call      msys.m$print_startcon
    lea       rcx,	[L13587]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L9965
L9969:
    mov       rcx,	[rbp + mm_type.tx_makelist.t]
    mov       rdx,	1
    call      mm_lib.strmode
    lea       rcx,	[L13588]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_support.txerror_s
L9965:
    mov       al,	[rbp + mm_type.tx_makelist.isconst]
    mov       [r12+60],	al
    mov       rax,	[r12+24]
    mov       rcx,	rax
    mov       rdx,	3
    xor       r8d,	r8d
    call      mm_type.tpass
    movzx     rax,	byte [r12]
    cmp       rax,	24
    jz        L9998
    mov       rax,	[mm_type.inidata]
    test      rax,	rax
    jnz       L10000
    mov       rax,	[rbp + mm_type.tx_makelist.isconst]
    test      rax,	rax
    jz        L10000
    mov       rcx,	[mm_decls.currproc]
    mov       rdx,	10
    call      mm_lib.getavname
    mov       [rbp + mm_type.tx_makelist.e],	rax
    mov       eax,	[rbp + mm_type.tx_makelist.t]
    mov       r10,	[rbp + mm_type.tx_makelist.e]
    mov       [r10+72],	eax
    mov       rcx,	[rbp + mm_type.tx_makelist.e]
    call      mm_lib.addstatic
    xor       ecx,	ecx
    call      mm_lib.createunit0
    mov       [rbp + mm_type.tx_makelist.q],	rax
    mov       rax,	r12
    mov       r10,	[rbp + mm_type.tx_makelist.q]
    push      r10
    mov       r14,	8
L13589:
    mov       r11,	[rax]
    mov       [r10],	r11
    add       r10,	8
    add       rax,	8
    dec       r14
    jnz       L13589
    mov       r11b,	[rax]
    mov       [r10],	r11b
    pop       r10
    mov       rax,	[rbp + mm_type.tx_makelist.q]
    mov       r10,	[rbp + mm_type.tx_makelist.e]
    mov       [r10+64],	rax
    mov       al,	4
    mov       [r12],	al
    mov       rax,	[rbp + mm_type.tx_makelist.e]
    mov       [r12+16],	rax
L10000:
L9998:
;---------------
    add       rsp,	80
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_makeslicefromlist
mm_type.tx_makeslicefromlist:
;?>>
    %define mm_type.tx_makeslicefromlist.p 16
    %define mm_type.tx_makeslicefromlist.a 24
    %define mm_type.tx_makeslicefromlist.t 32
;?]]
    sub       rsp,	40
;---------------
    call      msys.m$print_startcon
    lea       rcx,	[L13590]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L13591]
    xor       edx,	edx
    call      mm_support.txerror
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mm_type.tx_makeslice
mm_type.tx_makeslice:
;?>>
   %define R.p rdi
   %define R.a rbx
   %define R.b rsi
   %define R.t r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
    mov       r12,	r9
;---------------
    call      msys.m$print_startcon
    lea       rcx,	[L13592]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	rbx
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    movsxd    rax,	dword [rbx+49]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    cmp       r10,	7
    jz        L10004
    lea       rcx,	[L13593]
    xor       edx,	edx
    call      mm_support.txerror
L10004:
    movsxd    rax,	dword [rbx+49]
    lea       r10,	[mm_decls.tttarget]
    movsxd    r10,	dword [r10 + rax*4]
    test      r10,	r10
    jz        L10006
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	r12
    movsxd    rax,	dword [rax + r10*4]
    xor       ecx,	ecx
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_lib.createrefmode
    movsxd    r10,	dword [rbx+49]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mm_type.comparemodes
    test      rax,	rax
    jnz       L10008
    lea       rcx,	[L13594]
    xor       edx,	edx
    call      mm_support.txerror
L10008:
L10006:
    mov       rcx,	rsi
    mov       rdx,	3
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       [rdi+49],	r12d
    call      msys.m$print_startcon
    lea       rcx,	[L13595]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       al,	1
    mov       [rdi+61],	al
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_makeset
mm_type.tx_makeset:
;?>>
   %define R.p rdi
   %define R.a rbx
    %define mm_type.tx_makeset.t 48
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       al,	1
    mov       [rdi+60],	al
    jmp       L10013
L10010:
    mov       rcx,	rbx
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       al,	[rbx+60]
    test      al,	al
    jnz       L10015
    xor       eax,	eax
    mov       [rdi+60],	al
L10015:
    mov       rbx,	[rbx+8]
L10013:
    test      rbx,	rbx
    jnz       L10010
    xor       eax,	eax
    mov       [rdi+49],	eax
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_dot
mm_type.tx_dot:
;?>>
   %define R.p r13
   %define R.a r14
    %define mm_type.tx_dot.b 80
    %define mm_type.tx_dot.lv 88
   %define R.recmode rdi
   %define R.recbasemode rbx
   %define R.i rsi
   %define R.j r12
    %define mm_type.tx_dot.newtag -8
    %define mm_type.tx_dot.tmode -16
    %define mm_type.tx_dot.pindex -24
    %define mm_type.tx_dot.d -32
    %define mm_type.tx_dot.dequiv -40
    %define mm_type.tx_dot.$T1 -48
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	80
    mov       r13,	rcx
    mov       r14,	rdx
    mov       [rbp+80],	r8
    mov       [rbp+88],	r9
;---------------
    mov       rcx,	r14
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    movsxd    rax,	dword [r14+49]
    mov       rdi,	rax
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rdi
    movsxd    rax,	dword [rax + r10*4]
    mov       rbx,	rax
    jmp       L10018
L10017:
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	rdi
    movsxd    rax,	dword [rax + r10*4]
    mov       [rbp + mm_type.tx_dot.tmode],	rax
    mov       rcx,	r14
    mov       rdx,	53
    call      mm_lib.insertunit
    mov       eax,	[rbp + mm_type.tx_dot.tmode]
    mov       [r14+49],	eax
    mov       rdi,	rax
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rdi
    movsxd    rax,	dword [rax + r10*4]
    mov       rbx,	rax
L10018:
    cmp       rbx,	7
    jz        L10017
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rdi
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	8
    jz        L10021
    lea       rcx,	[L13596]
    xor       edx,	edx
    call      mm_support.txerror
L10021:
    mov       rax,	[rbp + mm_type.tx_dot.b]
    mov       rax,	[rax+16]
    mov       [rbp + mm_type.tx_dot.d],	rax
    mov       rax,	[rbp + mm_type.tx_dot.d]
    movzx     rax,	byte [rax+78]
    test      rax,	rax
    jnz       L10023
    mov       rcx,	[rbp + mm_type.tx_dot.d]
    mov       rdx,	rdi
    call      mm_type.resolvefield
    mov       r10,	[rbp + mm_type.tx_dot.b]
    mov       [r10+16],	rax
    mov       [rbp + mm_type.tx_dot.d],	rax
L10023:
    mov       rax,	[rbp + mm_type.tx_dot.d]
    movsxd    rax,	dword [rax+72]
    cmp       rax,	27
    jnz       L10025
    mov       rax,	[rbp + mm_type.tx_dot.d]
    movzx     rax,	byte [rax+150]
    mov       rsi,	rax
    mov       rax,	[rbp + mm_type.tx_dot.d]
    movzx     rax,	byte [rax+148]
    mov       r10,	rsi
    add       r10,	rax
    dec       r10
    mov       r12,	r10
    mov       rax,	[rbp + mm_type.tx_dot.d]
    mov       rax,	[rax+128]
    mov       [rbp + mm_type.tx_dot.dequiv],	rax
    mov       rax,	[rbp + mm_type.tx_dot.dequiv]
    mov       r10,	[rbp + mm_type.tx_dot.b]
    mov       [r10+16],	rax
    mov       rax,	[rbp + mm_type.tx_dot.dequiv]
    mov       eax,	[rax+72]
    mov       r10,	[rbp + mm_type.tx_dot.b]
    mov       [r10+49],	eax
    mov       rax,	[rbp + mm_type.tx_dot.d]
    mov       eax,	[rax+84]
    mov       [r13+40],	eax
    cmp       rsi,	r12
    jnz       L10027
    mov       rcx,	rsi
    mov       rdx,	3
    call      mm_lib.createconstunit
    mov       [rbp + mm_type.tx_dot.pindex],	rax
    mov       rax,	51
    mov       [rbp + mm_type.tx_dot.newtag],	rax
    jmp       L10026
L10027:
    mov       rcx,	r12
    mov       rdx,	3
    call      mm_lib.createconstunit
    mov       [rbp + mm_type.tx_dot.$T1],	rax
    mov       rcx,	rsi
    mov       rdx,	3
    call      mm_lib.createconstunit
    mov       rcx,	21
    mov       rdx,	rax
    mov       r8,	[rbp + mm_type.tx_dot.$T1]
    call      mm_lib.createunit2
    mov       [rbp + mm_type.tx_dot.pindex],	rax
    mov       eax,	9
    mov       r10,	[rbp + mm_type.tx_dot.pindex]
    mov       [r10+49],	eax
    mov       rax,	[rbp + mm_type.tx_dot.pindex]
    mov       rax,	[rax+16]
    mov       r10b,	1
    mov       [rax+61],	r10b
    mov       rax,	[rbp + mm_type.tx_dot.pindex]
    mov       rax,	[rax+24]
    mov       r10b,	1
    mov       [rax+61],	r10b
    mov       rax,	52
    mov       [rbp + mm_type.tx_dot.newtag],	rax
L10026:
    mov       rax,	[rbp + mm_type.tx_dot.b]
    mov       eax,	[rax+49]
    mov       [r13+49],	eax
    mov       rcx,	r13
    mov       rdx,	[rbp + mm_type.tx_dot.lv]
    call      mm_type.twiden
    mov       rcx,	r13
    mov       rdx,	[rbp + mm_type.tx_dot.newtag]
    call      mm_lib.insertunit
    mov       eax,	4
    mov       [r13+49],	eax
    mov       rax,	[rbp + mm_type.tx_dot.pindex]
    mov       [r13+24],	rax
    mov       rax,	[r13+16]
    mov       r10b,	1
    mov       [rax+61],	r10b
    mov       rax,	[r13+24]
    mov       r10b,	1
    mov       [rax+61],	r10b
    mov       al,	1
    mov       [r13+61],	al
    jmp       L10016
L10025:
    mov       rax,	[rbp + mm_type.tx_dot.d]
    mov       eax,	[rax+72]
    mov       r10,	[rbp + mm_type.tx_dot.b]
    mov       [r10+49],	eax
    mov       rax,	[rbp + mm_type.tx_dot.d]
    mov       eax,	[rax+72]
    mov       [r13+49],	eax
    mov       rax,	[rbp + mm_type.tx_dot.d]
    mov       eax,	[rax+84]
    mov       [r13+40],	eax
    mov       rcx,	r13
    mov       rdx,	[rbp + mm_type.tx_dot.lv]
    call      mm_type.twiden
L10016:
;---------------
    add       rsp,	80
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.resolvefield
mm_type.resolvefield:
;?>>
   %define R.d rsi
   %define R.m r12
   %define R.e rdi
   %define R.t rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	r12
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	8
    jz        L10030
    cmp       rax,	7
    jz        L10031
    jmp       L10032
L10030:
    jmp       L10029
L10031:
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	r12
    movsxd    rax,	dword [rax + r10*4]
    mov       r12,	rax
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	r12
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	8
    jz        L10034
    lea       rcx,	[L13597]
    xor       edx,	edx
    call      mm_support.txerror
L10034:
    jmp       L10029
L10032:
    lea       rcx,	[L13598]
    xor       edx,	edx
    call      mm_support.txerror
L10029:
    lea       rax,	[mm_decls.ttnamedef]
    mov       r10,	r12
    mov       rbx,	[rax + r10*8]
    mov       rcx,	rbx
    mov       rdx,	rsi
    call      mm_name.finddupl
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L10036
    mov       rax,	[rsi]
    lea       rcx,	[L13599]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_support.txerror_s
L10036:
    mov       rax,	rdi
L10028:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_andl
mm_type.tx_andl:
;?>>
   %define R.p rdi
   %define R.a rbx
   %define R.b rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    mov       rcx,	rbx
    mov       rdx,	6
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rcx,	rsi
    mov       rdx,	6
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       eax,	6
    mov       [rdi+49],	eax
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.convintconst
mm_type.convintconst:
;?>>
   %define R.p rcx
   %define R.x rdx
;?]]
;---------------
    mov       al,	1
    mov       [rcx],	al
    mov       eax,	3
    mov       [rcx+49],	eax
    xor       eax,	eax
    mov       [rcx+32],	rax
    mov       [rcx+24],	rax
    mov       [rcx+16],	rax
    mov       [rcx+16],	rdx
    mov       al,	1
    mov       [rcx+60],	al
;---------------
    ret       
;End 
;Proc mm_type.tx_sliceptr
mm_type.tx_sliceptr:
;?>>
   %define R.p rsi
   %define R.a r12
   %define R.m rdi
   %define R.tmode rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    mov       rcx,	r12
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    movsxd    rax,	dword [r12+49]
    mov       rdi,	rax
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rdi
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	11
    jnz       L10042
L10041:
    jmp       L10040
L10042:
    mov       rcx,	rdi
    mov       rdx,	1
    call      mm_lib.strmode
    lea       rcx,	[L13600]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_support.txerror_s
L10040:
    sub       rsp,	8
    push      0
    lea       rax,	[mm_decls.ttlower]
    mov       r10,	rdi
    movsxd    rax,	dword [rax + r10*4]
    lea       r10,	[mm_decls.tttarget]
    mov       r11,	rdi
    movsxd    r10,	dword [r10 + r11*4]
    xor       ecx,	ecx
    mov       rdx,	r10
    mov       r8,	rax
    xor       r9d,	r9d
    sub       rsp,	32
    call      mm_lib.createarraymodek
    add       rsp,	48
    mov       rbx,	rax
    xor       ecx,	ecx
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      mm_lib.createrefmode
    mov       [rsi+49],	eax
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_swap
mm_type.tx_swap:
;?>>
   %define R.p rdi
   %define R.a rbx
   %define R.b rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    mov       rcx,	rbx
    mov       rdx,	23
    call      mm_type.tpasslv
    mov       rcx,	rsi
    mov       rdx,	23
    call      mm_type.tpasslv
    movsxd    rax,	dword [rsi+49]
    movsxd    r10,	dword [rbx+49]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mm_type.comparemodes
    test      rax,	rax
    jnz       L10045
    lea       rcx,	[L13601]
    xor       edx,	edx
    call      mm_support.txerror
L10045:
    xor       eax,	eax
    mov       [rdi+49],	eax
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_select
mm_type.tx_select:
;?>>
   %define R.p rsi
   %define R.a r12
   %define R.b r13
   %define R.c r14
    %define mm_type.tx_select.t 96
    %define mm_type.tx_select.lv 104
   %define R.u rdi
   %define R.q rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
    mov       r14,	r9
;---------------
    mov       rcx,	r12
    mov       rdx,	3
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rbx,	r13
    jmp       L10048
L10047:
    mov       rcx,	rbx
    mov       rdx,	[rbp + mm_type.tx_select.t]
    mov       r8,	[rbp + mm_type.tx_select.lv]
    call      mm_type.tpass
    cmp       rbx,	r13
    jnz       L10051
    movsxd    rax,	dword [rbx+49]
    mov       rdi,	rax
    jmp       L10050
L10051:
    movsxd    rax,	dword [rbx+49]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mm_type.getdominantmode
    mov       rdi,	rax
L10050:
    mov       rbx,	[rbx+8]
L10048:
    test      rbx,	rbx
    jnz       L10047
    mov       rcx,	r14
    mov       rdx,	[rbp + mm_type.tx_select.t]
    mov       r8,	[rbp + mm_type.tx_select.lv]
    call      mm_type.tpass
    movsxd    rax,	dword [r14+49]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mm_type.getdominantmode
    mov       rdi,	rax
    mov       rbx,	r13
    jmp       L10053
L10052:
    mov       rcx,	rbx
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mm_type.coerceunit
    mov       rbx,	[rbx+8]
L10053:
    test      rbx,	rbx
    jnz       L10052
    mov       [rsi+49],	edi
;---------------
    add       rsp,	32
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_case
mm_type.tx_case:
;?>>
   %define R.p r13
   %define R.a r14
    %define mm_type.tx_case.b 80
    %define mm_type.tx_case.c 88
    %define mm_type.tx_case.t 96
    %define mm_type.tx_case.lv 104
   %define R.amode rdi
   %define R.u rbx
   %define R.wt rsi
   %define R.w r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       r13,	rcx
    mov       r14,	rdx
    mov       [rbp+80],	r8
    mov       [rbp+88],	r9
;---------------
    movzx     rax,	byte [r13]
    cmp       rax,	106
    jnz       L10057
    mov       rax,	[rbp + mm_type.tx_case.lv]
    test      rax,	rax
    jz        L10057
    lea       rcx,	[L13602]
    xor       edx,	edx
    call      mm_support.gerror
L10057:
    mov       rcx,	r14
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    test      r14,	r14
    jnz       L10059
    mov       rdi,	23
    jmp       L10058
L10059:
    movsxd    rax,	dword [r14+49]
    mov       rdi,	rax
L10058:
    lea       rax,	[mm_decls.ttisinteger]
    mov       r10,	rdi
    mov       al,	[rax + r10]
    test      al,	al
    jz        L10061
    lea       rax,	[mm_decls.ttsize]
    mov       r10,	rdi
    mov       eax,	[rax + r10*4]
    cmp       rax,	8
    jge       L10061
    mov       rcx,	r14
    mov       rdx,	3
    xor       r8d,	r8d
    call      mm_type.coerceunit
    mov       rdi,	3
L10061:
    xor       rbx,	rbx
    mov       rax,	[rbp + mm_type.tx_case.b]
    mov       rsi,	rax
    jmp       L10063
L10062:
    mov       r12,	[rsi+16]
    jmp       L10066
L10065:
    mov       rcx,	r12
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    movzx     rax,	byte [r12]
    cmp       rax,	21
    jnz       L10069
    lea       rax,	[mm_decls.ttisinteger]
    mov       r10,	rdi
    mov       al,	[rax + r10]
    test      al,	al
    jnz       L10071
    lea       rcx,	[L13603]
    xor       edx,	edx
    call      mm_support.txerror
L10071:
    jmp       L10068
L10069:
    cmp       rdi,	23
    jnz       L10073
    movzx     rax,	byte [r12]
    lea       r10,	[mm_tables.isbooltag]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jnz       L10075
    lea       rcx,	[L13604]
    xor       edx,	edx
    call      mm_support.txerror
    mov       rcx,	r12
    mov       rdx,	18
    call      mm_lib.insertunit
L10075:
    jmp       L10072
L10073:
    mov       rcx,	r12
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mm_type.coerceunit
L10072:
L10068:
    mov       r12,	[r12+8]
L10066:
    test      r12,	r12
    jnz       L10065
    mov       rax,	[rsi+24]
    mov       rcx,	rax
    mov       rdx,	[rbp + mm_type.tx_case.t]
    mov       r8,	[rbp + mm_type.tx_case.lv]
    call      mm_type.tpass
    mov       rax,	[rbp + mm_type.tx_case.t]
    test      rax,	rax
    jz        L10077
    test      rbx,	rbx
    jz        L10079
    mov       rax,	[rsi+24]
    movsxd    rax,	dword [rax+49]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mm_type.getdominantmode
    mov       rbx,	rax
    jmp       L10078
L10079:
    mov       rax,	[rsi+24]
    movsxd    rax,	dword [rax+49]
    mov       rbx,	rax
L10078:
L10077:
    mov       rsi,	[rsi+8]
L10063:
    test      rsi,	rsi
    jnz       L10062
    mov       rax,	[rbp + mm_type.tx_case.c]
    test      rax,	rax
    jz        L10081
    mov       rcx,	[rbp + mm_type.tx_case.c]
    mov       rdx,	[rbp + mm_type.tx_case.t]
    mov       r8,	[rbp + mm_type.tx_case.lv]
    call      mm_type.tpass
    mov       rax,	[rbp + mm_type.tx_case.t]
    cmp       rax,	23
    jnz       L10083
    mov       rax,	[rbp + mm_type.tx_case.c]
    movsxd    rax,	dword [rax+49]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mm_type.getdominantmode
    mov       rbx,	rax
L10083:
    jmp       L10080
L10081:
    mov       rax,	[rbp + mm_type.tx_case.t]
    test      rax,	rax
    jz        L10084
    lea       rcx,	[L13605]
    xor       edx,	edx
    call      mm_support.txerror
L10084:
L10080:
    mov       rax,	[rbp + mm_type.tx_case.t]
    test      rax,	rax
    jz        L10086
    mov       [r13+49],	ebx
    jmp       L10085
L10086:
    xor       eax,	eax
    mov       [r13+49],	eax
L10085:
;---------------
    add       rsp,	32
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_notl
mm_type.tx_notl:
;?>>
   %define R.p rdi
   %define R.a rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rbx
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       eax,	6
    mov       [rdi+49],	eax
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_typepun
mm_type.tx_typepun:
;?>>
   %define R.p rsi
   %define R.a r12
   %define R.smode rdi
   %define R.tmode rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    movzx     rax,	byte [r12]
    cmp       rax,	20
    jnz       L10091
L10090:
    lea       rcx,	[L13606]
    xor       edx,	edx
    call      mm_support.txerror
    jmp       L10089
L10091:
    mov       rcx,	r12
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    movsxd    rax,	dword [r12+49]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    mov       rdi,	r10
    movsxd    rax,	dword [rsi+53]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    mov       rbx,	r10
    lea       rax,	[mm_decls.ttisreal]
    mov       r10,	rdi
    mov       al,	[rax + r10]
    test      al,	al
    jz        L10094
    lea       rax,	[mm_decls.ttisinteger]
    mov       r10,	rbx
    mov       al,	[rax + r10]
    test      al,	al
    jnz       L10093
L10094:
    lea       rax,	[mm_decls.ttisinteger]
    mov       r10,	rdi
    mov       al,	[rax + r10]
    test      al,	al
    jz        L10095
    lea       rax,	[mm_decls.ttisreal]
    mov       r10,	rbx
    mov       al,	[rax + r10]
    test      al,	al
    jnz       L10093
L10095:
    lea       rcx,	[L13607]
    xor       edx,	edx
    call      mm_support.txerror
L10093:
    mov       rax,	rbx
    cmp       rax,	16
    jz        L10098
    cmp       rax,	19
    jnz       L10097
L10098:
    mov       rbx,	3
L10097:
    mov       [rsi+49],	ebx
L10089:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_exit
mm_type.tx_exit:
;?>>
   %define R.p rdi
   %define R.a rbx
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    test      rbx,	rbx
    jnz       L10101
    jmp       L10099
L10101:
    mov       rcx,	rbx
    mov       rdx,	3
    xor       r8d,	r8d
    call      mm_type.tpass
    movzx     rax,	byte [rbx]
    cmp       rax,	1
    jz        L10103
    lea       rcx,	[L13608]
    xor       edx,	edx
    call      mm_support.txerror
L10103:
    mov       rax,	[rbx+16]
    mov       [rdi+40],	eax
    xor       eax,	eax
    mov       [rdi+16],	rax
L10099:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_goto
mm_type.tx_goto:
;?>>
    %define mm_type.tx_goto.p 32
   %define R.a rbx
   %define R.m rdi
    push      rdi
    push      rbx
;?]]
    sub       rsp,	40
    mov       rbx,	rdx
;---------------
    mov       rcx,	rbx
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    movsxd    rax,	dword [rbx+49]
    mov       rdi,	rax
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rdi
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	7
    jnz       L10107
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	rdi
    movsxd    rax,	dword [rax + r10*4]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    cmp       r10,	25
    jz        L10106
L10107:
    lea       rcx,	[L13609]
    xor       edx,	edx
    call      mm_support.txerror
L10106:
;---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_switch
mm_type.tx_switch:
;?>>
   %define R.p r13
   %define R.a r14
    %define mm_type.tx_switch.b 80
    %define mm_type.tx_switch.c 88
    %define mm_type.tx_switch.t 96
    %define mm_type.tx_switch.lv 104
    %define mm_type.tx_switch.valueset -2048
   %define R.wt rdi
   %define R.w rbx
   %define R.ax rsi
   %define R.bx r12
    %define mm_type.tx_switch.i -2056
    %define mm_type.tx_switch.u -2064
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	2096
    mov       r13,	rcx
    mov       r14,	rdx
    mov       [rbp+80],	r8
    mov       [rbp+88],	r9
;---------------
    movzx     rax,	byte [r13]
    cmp       rax,	108
    jnz       L10110
    mov       rax,	[rbp + mm_type.tx_switch.lv]
    test      rax,	rax
    jz        L10110
    lea       rcx,	[L13610]
    xor       edx,	edx
    call      mm_support.gerror
L10110:
    movzx     rax,	byte [r13]
    cmp       rax,	110
    jnz       L10112
    mov       rcx,	r14
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rax,	[r14+8]
    mov       rcx,	rax
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    movsxd    rax,	dword [r14+49]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    cmp       r10,	7
    jz        L10114
    lea       rcx,	[L13611]
    xor       edx,	edx
    call      mm_support.txerror
L10114:
    jmp       L10111
L10112:
    mov       rcx,	r14
    mov       rdx,	3
    xor       r8d,	r8d
    call      mm_type.tpass
L10111:
    lea       rcx,	[rbp + mm_type.tx_switch.valueset]
    xor       edx,	edx
    mov       r8,	2048
    call      memset
    xor       eax,	eax
    mov       [rbp + mm_type.tx_switch.u],	rax
    mov       rdi,	[rbp + mm_type.tx_switch.b]
    jmp       L10116
L10115:
    mov       rbx,	[rdi+16]
    jmp       L10119
L10118:
    mov       rcx,	rbx
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rcx,	rbx
    call      mm_lib.isconstunit
    test      rax,	rax
    jnz       L10122
    mov       rcx,	rbx
    xor       edx,	edx
    lea       r8,	[L13612]
    xor       r9d,	r9d
    call      mm_diags.printunit
    lea       rcx,	[L13613]
    xor       edx,	edx
    call      mm_support.txerror
L10122:
    movsxd    rax,	dword [rbx+49]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    cmp       r10,	9
    jz        L10124
    jmp       L10125
L10124:
    mov       rax,	[rbx+16]
    mov       rsi,	[rax+16]
    mov       rax,	[rbx+24]
    mov       r12,	[rax+16]
;mm_type.tx_switch.dorange:
L10126:
    mov       [rbp + mm_type.tx_switch.i],	rsi
    mov       rax,	[rbp + mm_type.tx_switch.i]
    cmp       rax,	r12
    jg        L10129
L10127:
    mov       rax,	[rbp + mm_type.tx_switch.i]
    cmp       rax,	0
    jl        L10132
    mov       rax,	[rbp + mm_type.tx_switch.i]
    cmp       rax,	2047
    jle       L10131
L10132:
    lea       rcx,	[L13614]
    xor       edx,	edx
    call      mm_support.txerror
L10131:
    mov       rax,	[rbp + mm_type.tx_switch.i]
    mov       al,	[rbp + rax + mm_type.tx_switch.valueset]
    test      al,	al
    jz        L10134
    call      msys.m$print_startcon
    mov       rcx,	[rbp + mm_type.tx_switch.i]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L13615]
    xor       edx,	edx
    call      mm_support.txerror
L10134:
    mov       al,	1
    mov       r10,	[rbp + mm_type.tx_switch.i]
    mov       [rbp + r10 + mm_type.tx_switch.valueset],	al
    mov       rax,	[rbp + mm_type.tx_switch.i]
    inc       rax
    mov       [rbp + mm_type.tx_switch.i],	rax
    cmp       rax,	r12
    jle       L10127
L10129:
    jmp       L10123
L10125:
    mov       rcx,	rbx
    mov       rdx,	3
    xor       r8d,	r8d
    call      mm_type.coerceunit
    mov       rcx,	rbx
    call      mm_type.tevaluate
    movzx     rax,	byte [rbx]
    cmp       rax,	1
    jz        L10136
    lea       rcx,	[L13616]
    xor       edx,	edx
    call      mm_support.txerror
L10136:
    mov       rax,	[rbx+16]
    mov       r12,	rax
    mov       rsi,	rax
    jmp       L10126
L10123:
    mov       rbx,	[rbx+8]
L10119:
    test      rbx,	rbx
    jnz       L10118
    mov       rax,	[rdi+24]
    mov       rcx,	rax
    mov       rdx,	[rbp + mm_type.tx_switch.t]
    mov       r8,	[rbp + mm_type.tx_switch.lv]
    call      mm_type.tpass
    mov       rax,	[rbp + mm_type.tx_switch.t]
    cmp       rax,	23
    jnz       L10138
    mov       rax,	[rbp + mm_type.tx_switch.u]
    test      rax,	rax
    jz        L10140
    mov       rax,	[rdi+24]
    movsxd    rax,	dword [rax+49]
    mov       rcx,	[rbp + mm_type.tx_switch.u]
    mov       rdx,	rax
    call      mm_type.getdominantmode
    mov       [rbp + mm_type.tx_switch.u],	rax
    jmp       L10139
L10140:
    mov       rax,	[rdi+24]
    movsxd    rax,	dword [rax+49]
    mov       [rbp + mm_type.tx_switch.u],	rax
L10139:
L10138:
    mov       rdi,	[rdi+8]
L10116:
    test      rdi,	rdi
    jnz       L10115
    mov       rax,	[rbp + mm_type.tx_switch.c]
    test      rax,	rax
    jz        L10142
    mov       rcx,	[rbp + mm_type.tx_switch.c]
    mov       rdx,	[rbp + mm_type.tx_switch.t]
    mov       r8,	[rbp + mm_type.tx_switch.lv]
    call      mm_type.tpass
    mov       rax,	[rbp + mm_type.tx_switch.t]
    cmp       rax,	23
    jnz       L10144
    mov       rax,	[rbp + mm_type.tx_switch.c]
    movsxd    rax,	dword [rax+49]
    mov       rcx,	[rbp + mm_type.tx_switch.u]
    mov       rdx,	rax
    call      mm_type.getdominantmode
    mov       [rbp + mm_type.tx_switch.u],	rax
L10144:
    jmp       L10141
L10142:
    mov       rax,	[rbp + mm_type.tx_switch.t]
    test      rax,	rax
    jz        L10145
    lea       rcx,	[L13617]
    xor       edx,	edx
    call      mm_support.txerror
L10145:
L10141:
    mov       rax,	[rbp + mm_type.tx_switch.t]
    test      rax,	rax
    jz        L10147
    mov       rax,	[rbp + mm_type.tx_switch.b]
    mov       rbx,	[rax+16]
    jmp       L10149
L10148:
    mov       rax,	[rbp + mm_type.tx_switch.t]
    cmp       rax,	23
    jnz       L10152
    mov       rax,	[rbp + mm_type.tx_switch.b]
    mov       rax,	[rax+24]
    mov       rcx,	rax
    mov       rdx,	[rbp + mm_type.tx_switch.u]
    xor       r8d,	r8d
    call      mm_type.coerceunit
L10152:
    mov       rax,	[rbp + mm_type.tx_switch.b]
    mov       rax,	[rax+24]
    mov       eax,	[rax+49]
    mov       [rbx+49],	eax
    mov       rbx,	[rbx+8]
L10149:
    test      rbx,	rbx
    jnz       L10148
    mov       rax,	[rbp + mm_type.tx_switch.t]
    cmp       rax,	23
    jnz       L10154
    mov       rcx,	[rbp + mm_type.tx_switch.c]
    mov       rdx,	[rbp + mm_type.tx_switch.u]
    xor       r8d,	r8d
    call      mm_type.coerceunit
    mov       eax,	[rbp + mm_type.tx_switch.u]
    mov       [r13+49],	eax
    jmp       L10153
L10154:
    mov       eax,	[rbp + mm_type.tx_switch.t]
    mov       [r13+49],	eax
L10153:
    jmp       L10146
L10147:
    xor       eax,	eax
    mov       [r13+49],	eax
L10146:
;---------------
    add       rsp,	2096
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_addroffirst
mm_type.tx_addroffirst:
;?>>
   %define R.p rbx
   %define R.a rsi
    %define mm_type.tx_addroffirst.t 56
   %define R.m rdi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
;---------------
    mov       rcx,	rsi
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    movsxd    rax,	dword [rsi+49]
    mov       rdi,	rax
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rdi
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	10
    jz        L10157
    lea       rcx,	[L13618]
    xor       edx,	edx
    call      mm_support.txerror
L10157:
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	rdi
    movsxd    rax,	dword [rax + r10*4]
    xor       ecx,	ecx
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_lib.createrefmode
    mov       rdi,	rax
    movzx     rax,	byte [rsi]
    cmp       rax,	4
    jnz       L10159
    mov       al,	1
    mov       [rsi+40],	al
L10159:
    mov       [rbx+49],	edi
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_return
mm_type.tx_return:
;?>>
   %define R.p r14
   %define R.a r15
    %define mm_type.tx_return.t 88
   %define R.m rdi
   %define R.nret rbx
   %define R.i rsi
   %define R.pmult r12
   %define R.q r13
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       r14,	rcx
    mov       r15,	rdx
    mov       [rbp+88],	r8
;---------------
    mov       rax,	[mm_decls.currproc]
    movsxd    rax,	dword [rax+72]
    mov       rdi,	rax
    mov       rax,	[mm_decls.currproc]
    movzx     rax,	byte [rax+122]
    mov       rbx,	rax
    mov       rax,	[mm_decls.currproc]
    movsxd    rax,	dword [rax+72]
    lea       r10,	[mm_decls.ttmult]
    mov       r10,	[r10 + rax*8]
    mov       r12,	r10
    test      r15,	r15
    jnz       L10162
    test      rbx,	rbx
    jz        L10164
    lea       rcx,	[L13619]
    xor       edx,	edx
    call      mm_support.txerror
L10164:
    jmp       L10160
L10162:
    test      rbx,	rbx
    jnz       L10165
    lea       rcx,	[L13620]
    xor       edx,	edx
    call      mm_support.txerror
L10165:
L10161:
    movzx     rax,	byte [r15]
    cmp       rax,	20
    jnz       L10167
    mov       al,	25
    mov       [r15],	al
    mov       eax,	[r15+40]
    cmp       rax,	rbx
    jz        L10169
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rdi
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	8
    jz        L10171
    cmp       rax,	10
    jnz       L10172
L10171:
    lea       rcx,	[L13621]
    xor       edx,	edx
    call      mm_support.txerror
    jmp       L10170
L10172:
    lea       rcx,	[L13622]
    xor       edx,	edx
    call      mm_support.txerror
L10170:
L10169:
    mov       r13,	[r15+16]
    mov       rsi,	1
    cmp       rbx,	1
    jl        L10175
L10173:
    movsxd    rax,	dword [r12 + rsi*4-4]
    mov       rcx,	r13
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       r13,	[r13+8]
    inc       rsi
    cmp       rsi,	rbx
    jle       L10173
L10175:
    mov       rcx,	r14
    mov       rdx,	r15
    call      mm_lib.deleteunit
    mov       rax,	[rbp + mm_type.tx_return.t]
    test      rax,	rax
    jnz       L10177
    xor       eax,	eax
    mov       [r14+49],	eax
    jmp       L10176
L10177:
    mov       eax,	28
    mov       [r14+49],	eax
L10176:
    jmp       L10166
L10167:
    cmp       rbx,	1
    jle       L10179
    lea       rcx,	[L13623]
    xor       edx,	edx
    call      mm_support.txerror
L10179:
    mov       rcx,	r15
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rax,	[rbp + mm_type.tx_return.t]
    test      rax,	rax
    jnz       L10181
    xor       eax,	eax
    mov       [r14+49],	eax
    jmp       L10180
L10181:
    mov       rcx,	r14
    mov       rdx,	r15
    call      mm_lib.deleteunit
L10180:
L10166:
    movsxd    rax,	dword [r14+49]
    lea       r10,	[mm_decls.ttisshort]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L10183
    lea       rcx,	[L13624]
    xor       edx,	edx
    call      mm_support.txerror
L10183:
L10160:
;---------------
    add       rsp,	40
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_dotindex
mm_type.tx_dotindex:
;?>>
   %define R.p r12
   %define R.a r13
   %define R.b r14
    %define mm_type.tx_dotindex.lv 96
   %define R.pmode rdi
   %define R.i rbx
   %define R.j rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       r12,	rcx
    mov       r13,	rdx
    mov       r14,	r8
    mov       [rbp+96],	r9
;---------------
    mov       rcx,	r13
    mov       rdx,	23
    mov       r8,	[rbp + mm_type.tx_dotindex.lv]
    call      mm_type.tpass
    mov       rdi,	4
    movsxd    rax,	dword [r13+49]
    lea       r10,	[mm_decls.ttisinteger]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jnz       L10186
    movsxd    rax,	dword [r13+49]
    lea       r10,	[mm_decls.ttisreal]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L10188
    mov       rcx,	r13
    mov       rdx,	61
    call      mm_lib.insertunit
    mov       eax,	4
    mov       [r13+53],	eax
    mov       [r13+49],	eax
    mov       al,	1
    mov       [r13+61],	al
    jmp       L10187
L10188:
    lea       rcx,	[L13625]
    xor       edx,	edx
    call      mm_support.txerror
L10187:
L10186:
    mov       rcx,	r14
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    movsxd    rax,	dword [r14+49]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    cmp       r10,	9
    jz        L10190
    jmp       L10191
L10190:
    mov       rbx,	[r14+16]
    mov       rsi,	[r14+24]
    movzx     rax,	byte [rbx]
    movzx     r10,	byte [rsi]
    cmp       r10,	rax
    jnz       L10193
    cmp       r10,	1
    jnz       L10193
    mov       rax,	[rbx+16]
    mov       r10,	[rsi+16]
    cmp       rax,	r10
    jle       L10195
    lea       rax,	[r14+16]
    lea       r10,	[r14+24]
    mov       r11,	[rax]
    mov       r15,	[r10]
    mov       [r10],	r11
    mov       [rax],	r15
L10195:
L10193:
    jmp       L10189
L10191:
    mov       rcx,	r14
    mov       rdx,	3
    xor       r8d,	r8d
    call      mm_type.coerceunit
L10189:
    mov       [r12+49],	edi
;---------------
    add       rsp,	40
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_slice
mm_type.tx_slice:
;?>>
   %define R.p rdi
   %define R.a rbx
   %define R.b rsi
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
;---------------
    mov       rcx,	rbx
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rcx,	rsi
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    movsxd    rax,	dword [rbx+49]
    cmp       rax,	20
    jnz       L10198
    mov       rcx,	[mm_decls.currproc]
    mov       rdx,	12
    mov       r8,	1
    xor       r9d,	r9d
    call      mm_lib.createslicemodek
    mov       [rdi+49],	eax
    jmp       L10197
L10198:
    mov       rcx,	rbx
    mov       rdx,	1
    call      mm_type.deref
    movsxd    rax,	dword [rbx+49]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    cmp       r10,	10
    jz        L10200
    cmp       r10,	11
    jz        L10201
    jmp       L10202
L10200:
    movsxd    rax,	dword [rbx+49]
    lea       r10,	[mm_decls.tttarget]
    movsxd    r10,	dword [r10 + rax*4]
    mov       rcx,	[mm_decls.currproc]
    mov       rdx,	r10
    mov       r8,	1
    xor       r9d,	r9d
    call      mm_lib.createslicemodek
    mov       [rdi+49],	eax
    jmp       L10199
L10201:
    mov       eax,	[rbx+49]
    mov       [rdi+49],	eax
    jmp       L10199
L10202:
    call      msys.m$print_startcon
    lea       rcx,	[L13626]
    call      msys.m$print_str_nf
    movsxd    rax,	dword [rbx+49]
    mov       rcx,	rax
    mov       rdx,	1
    call      mm_lib.strmode
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L13627]
    xor       edx,	edx
    call      mm_support.txerror
L10199:
L10197:
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.twiden
mm_type.twiden:
;?>>
   %define R.p rsi
   %define R.lv r12
   %define R.m rdi
   %define R.mbase rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    movsxd    rax,	dword [rsi+49]
    mov       rdi,	rax
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    mov       rbx,	r10
    test      rbx,	rbx
    jnz       L10205
    jmp       L10203
L10205:
    test      r12,	r12
    jz        L10207
    jmp       L10203
L10207:
    lea       rax,	[mm_decls.ttisshort]
    mov       r10,	rbx
    mov       al,	[rax + r10]
    test      al,	al
    jz        L10203
L10209:
    movzx     rax,	byte [rsi]
    cmp       rax,	4
    jz        L10211
    cmp       rax,	53
    jz        L10211
    cmp       rax,	46
    jz        L10211
    cmp       rax,	49
    jz        L10211
    cmp       rax,	32
    jz        L10211
    cmp       rax,	40
    jnz       L10212
L10211:
    mov       rcx,	rsi
    mov       rdx,	58
    call      mm_lib.insertunit
    mov       al,	4
    mov       [rsi+62],	al
    mov       [rsi+53],	edi
    mov       rcx,	rdi
    call      mm_lib.gettypebase
    mov       [rsi+49],	eax
    jmp       L10210
L10212:
    mov       rcx,	rsi
    xor       edx,	edx
    lea       r8,	[L13628]
    xor       r9d,	r9d
    call      mm_diags.printunit
    movzx     rax,	byte [rsi]
    lea       r10,	[mm_tables.jtagnames]
    mov       r10,	[r10 + rax*8]
    lea       rcx,	[L13629]
    mov       rdx,	r10
    xor       r8d,	r8d
    call      mm_support.txerror_s
L10210:
L10203:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tstringslice
mm_type.tstringslice:
;?>>
   %define R.p r12
   %define R.slicemode r13
   %define R.a rdi
   %define R.b rbx
   %define R.prange rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    sub       rsp,	48
    mov       r12,	rcx
    mov       r13,	rdx
;---------------
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	r13
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	12
    jz        L10215
    lea       rcx,	[L13630]
    xor       edx,	edx
    call      mm_support.txerror
L10215:
    mov       rdi,	r12
    mov       rcx,	r12
    mov       rdx,	48
    call      mm_lib.insertunit
    mov       rax,	[r12+16]
    movzx     rax,	byte [rax]
    cmp       rax,	1
    jz        L10216
L10217:
    mov       rax,	[r12+16]
    mov       rcx,	rax
    xor       edx,	edx
    call      mm_lib.duplunit
    mov       rbx,	rax
    mov       rcx,	rbx
    mov       rdx,	36
    call      mm_lib.insertunit
    mov       rcx,	1
    mov       rdx,	3
    call      mm_lib.createconstunit
    mov       rcx,	21
    mov       rdx,	rax
    mov       r8,	rbx
    call      mm_lib.createunit2
    mov       rsi,	rax
    mov       eax,	9
    mov       [rsi+49],	eax
    mov       [r12+24],	rsi
L10216:
    mov       [r12+49],	r13d
;---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_bitfield
mm_type.tx_bitfield:
;?>>
   %define R.p r14
   %define R.a r15
    %define mm_type.tx_bitfield.lv 88
   %define R.i rdi
   %define R.j rbx
   %define R.bitsize rsi
   %define R.topbit r12
   %define R.r r13
    %define mm_type.tx_bitfield.$T1 -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       r14,	rcx
    mov       r15,	rdx
    mov       [rbp+88],	r8
;---------------
    mov       rcx,	r15
    mov       rdx,	23
    mov       r8,	[rbp + mm_type.tx_bitfield.lv]
    call      mm_type.tpass
    movsxd    rax,	dword [r15+49]
    lea       r10,	[mm_decls.ttisinteger]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jnz       L10220
    movsxd    rax,	dword [r15+49]
    lea       r10,	[mm_decls.ttisref]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jnz       L10220
    movsxd    rax,	dword [r15+49]
    lea       r10,	[mm_decls.ttisreal]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L10222
    mov       rcx,	r15
    mov       rdx,	61
    call      mm_lib.insertunit
    mov       eax,	4
    mov       [r15+53],	eax
    mov       [r15+49],	eax
    mov       al,	1
    mov       [r15+61],	al
    jmp       L10221
L10222:
    lea       rcx,	[L13631]
    xor       edx,	edx
    call      mm_support.txerror
L10221:
L10220:
    movsxd    rax,	dword [r15+49]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    lea       rax,	[mm_decls.ttsize]
    mov       eax,	[rax + r10*4]
    shl       rax,	3
    mov       rsi,	rax
    lea       rax,	[rsi-1]
    mov       r12,	rax
    movsx     rax,	word [r14+40]
    cmp       rax,	2
    jz        L10224
    cmp       rax,	1
    jz        L10225
    cmp       rax,	4
    jz        L10226
    cmp       rax,	7
    jz        L10227
    cmp       rax,	8
    jz        L10227
    cmp       rax,	3
    jz        L10228
    cmp       rax,	6
    jz        L10229
    cmp       rax,	5
    jz        L10230
    jmp       L10231
L10224:
    xor       rdi,	rdi
    mov       rax,	7
    mov       rbx,	rax
    jmp       L10223
L10225:
    mov       rbx,	r12
    lea       rax,	[r12-7]
    mov       rdi,	rax
    jmp       L10223
L10226:
    xor       eax,	eax
    mov       rbx,	rax
    mov       rdi,	rax
    jmp       L10223
L10227:
    mov       rax,	[rbp + mm_type.tx_bitfield.lv]
    test      rax,	rax
    jz        L10233
    lea       rcx,	[L13632]
    xor       edx,	edx
    call      mm_support.txerror
L10233:
    xor       eax,	eax
    mov       rbx,	rax
    mov       rdi,	rax
    jmp       L10223
L10228:
    mov       rax,	r12
    mov       rbx,	rax
    mov       rdi,	rax
    jmp       L10223
L10229:
    xor       rdi,	rdi
    mov       rax,	rsi
    sar       rax,	1
    dec       rax
    mov       rbx,	rax
    jmp       L10223
L10230:
    mov       rax,	rsi
    sar       rax,	1
    mov       rdi,	rax
    mov       rbx,	r12
    jmp       L10223
L10231:
    call      msys.m$print_startcon
    movsx     rax,	word [r14+40]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[L13633]
    xor       edx,	edx
    call      mm_support.txerror
L10223:
    cmp       rdi,	rbx
    jnz       L10235
    mov       al,	51
    mov       [r14],	al
    mov       rcx,	rdi
    mov       rdx,	3
    call      mm_lib.createconstunit
    mov       [r14+24],	rax
    mov       al,	1
    mov       [r14+61],	al
    mov       rax,	[r14+24]
    mov       r10b,	1
    mov       [rax+61],	r10b
    movsx     rax,	word [r14+40]
    cmp       rax,	8
    jnz       L10237
    mov       eax,	4
    mov       [r14+49],	eax
    mov       rcx,	r14
    call      mm_type.addnotl
L10237:
    jmp       L10234
L10235:
    mov       rcx,	rbx
    mov       rdx,	3
    call      mm_lib.createconstunit
    mov       [rbp + mm_type.tx_bitfield.$T1],	rax
    mov       rcx,	rdi
    mov       rdx,	3
    call      mm_lib.createconstunit
    mov       rcx,	21
    mov       rdx,	rax
    mov       r8,	[rbp + mm_type.tx_bitfield.$T1]
    call      mm_lib.createunit2
    mov       r13,	rax
    mov       rax,	[r13+16]
    mov       r10b,	1
    mov       [rax+61],	r10b
    mov       rax,	[r13+24]
    mov       r10b,	1
    mov       [rax+61],	r10b
    mov       eax,	9
    mov       [r13+49],	eax
    mov       al,	52
    mov       [r14],	al
    mov       [r14+24],	r13
L10234:
    mov       eax,	4
    mov       [r14+49],	eax
;---------------
    add       rsp,	40
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.deref
mm_type.deref:
;?>>
   %define R.a rsi
    %define mm_type.deref.needres 48
   %define R.abasemode rdi
   %define R.tmode rbx
    push      rdi
    push      rbx
    push      rsi
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    movsxd    rax,	dword [rsi+49]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    mov       rdi,	r10
    jmp       L10240
L10239:
    movsxd    rax,	dword [rsi+49]
    lea       r10,	[mm_decls.tttarget]
    movsxd    r10,	dword [r10 + rax*4]
    mov       rbx,	r10
    mov       rcx,	rsi
    mov       rdx,	53
    call      mm_lib.insertunit
    mov       [rsi+49],	ebx
    movsxd    rax,	dword [rsi+49]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    mov       rdi,	r10
L10240:
    cmp       rdi,	7
    jz        L10239
;---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tmethodcall
mm_type.tmethodcall:
;?>>
   %define R.p r15
    %define mm_type.tmethodcall.pdot 80
    %define mm_type.tmethodcall.pargs 88
   %define R.mrec rdi
   %define R.prec rbx
   %define R.pfield rsi
   %define R.pfunc r12
   %define R.d r13
   %define R.e r14
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       r15,	rcx
    mov       [rbp+80],	rdx
    mov       [rbp+88],	r8
;---------------
    mov       rax,	[rbp + mm_type.tmethodcall.pdot]
    mov       rbx,	[rax+16]
    mov       rax,	[rbp + mm_type.tmethodcall.pdot]
    mov       rsi,	[rax+24]
    movsxd    rax,	dword [rbx+49]
    mov       rdi,	rax
    mov       r13,	[rsi+16]
    mov       rcx,	r13
    mov       rdx,	rdi
    call      mm_type.resolvefield
    mov       r14,	rax
    test      r14,	r14
    jnz       L10244
    mov       rax,	[r13]
    lea       rcx,	[L13634]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_support.txerror_s
L10244:
    mov       rcx,	r14
    call      mm_lib.createname
    mov       r12,	rax
    mov       eax,	[r14+72]
    mov       [r12+49],	eax
    mov       rax,	[rbp + mm_type.tmethodcall.pargs]
    mov       [rbx+8],	rax
    mov       [r15+16],	r12
    mov       [r15+24],	rbx
;---------------
    add       rsp,	40
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.do_bounds
mm_type.do_bounds:
;?>>
   %define R.p rsi
   %define R.a r12
   %define R.m rdi
   %define R.mbase rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    mov       rcx,	r12
    mov       rdx,	1
    call      mm_type.deref
    movsxd    rax,	dword [r12+49]
    mov       rdi,	rax
    movzx     rax,	byte [r12]
    cmp       rax,	62
    jnz       L10247
    mov       rdi,	[r12+16]
L10247:
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rdi
    movsxd    rax,	dword [rax + r10*4]
    mov       rbx,	rax
    mov       eax,	3
    mov       [rsi+49],	eax
    movzx     rax,	byte [rsi+62]
    cmp       rax,	3
    jz        L10249
    cmp       rax,	4
    jz        L10250
    cmp       rax,	2
    jz        L10251
    cmp       rax,	5
    jz        L10252
    cmp       rax,	1
    jz        L10253
    jmp       L10254
L10249:
    mov       rax,	rbx
    cmp       rax,	10
    jz        L10256
    cmp       rax,	11
    jnz       L10257
L10256:
    lea       rax,	[mm_decls.ttlower]
    mov       r10,	rdi
    movsxd    rax,	dword [rax + r10*4]
    mov       rcx,	rsi
    mov       rdx,	rax
    call      mm_type.convintconst
    jmp       L10245
L10257:
;mm_type.do_bounds.error:
L10258:
    mov       rcx,	rdi
    mov       rdx,	1
    call      mm_lib.strmode
    lea       rcx,	[L13635]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_support.txerror_s
L10255:
    jmp       L10248
L10250:
    mov       rax,	rbx
    cmp       rax,	10
    jz        L10260
    cmp       rax,	11
    jz        L10261
    jmp       L10262
L10260:
    lea       rax,	[mm_decls.ttlower]
    mov       r10,	rdi
    movsxd    rax,	dword [rax + r10*4]
    lea       r10,	[mm_decls.ttlength]
    mov       r11,	rdi
    movsxd    r10,	dword [r10 + r11*4]
    add       rax,	r10
    dec       rax
    mov       rcx,	rsi
    mov       rdx,	rax
    call      mm_type.convintconst
    jmp       L10259
L10261:
    mov       al,	36
    mov       [rsi],	al
    jmp       L10259
L10262:
    jmp       L10258
L10259:
    jmp       L10248
L10251:
    mov       rax,	rbx
    cmp       rax,	10
    jz        L10264
    cmp       rax,	11
    jz        L10265
    jmp       L10266
L10264:
    lea       rax,	[mm_decls.ttlength]
    mov       r10,	rdi
    movsxd    rax,	dword [rax + r10*4]
    mov       rcx,	rsi
    mov       rdx,	rax
    call      mm_type.convintconst
    jmp       L10263
L10265:
    mov       al,	36
    mov       [rsi],	al
    jmp       L10263
L10266:
    jmp       L10258
L10263:
    jmp       L10248
L10252:
    mov       eax,	9
    mov       [rsi+49],	eax
    mov       rax,	rbx
    cmp       rax,	10
    jz        L10268
    cmp       rax,	11
    jz        L10269
    jmp       L10270
L10268:
    lea       rax,	[mm_decls.ttlower]
    mov       r10,	rdi
    movsxd    rax,	dword [rax + r10*4]
    mov       [rsi+16],	rax
    mov       rax,	[rsi+16]
    lea       r10,	[mm_decls.ttlength]
    mov       r11,	rdi
    movsxd    r10,	dword [r10 + r11*4]
    add       rax,	r10
    dec       rax
    mov       [rsi+24],	rax
    mov       al,	1
    mov       [rsi],	al
    xor       eax,	eax
    mov       [rsi+32],	rax
    mov       [rsi+24],	rax
    mov       [rsi+16],	rax
    mov       al,	1
    mov       [rsi+60],	al
    jmp       L10245
L10269:
    jmp       L10267
L10270:
    jmp       L10258
L10267:
    jmp       L10248
L10253:
    cmp       rbx,	11
    jz        L10272
    lea       rcx,	[L13636]
    xor       edx,	edx
    call      mm_support.txerror
L10272:
    mov       al,	36
    mov       [rsi],	al
L10254:
L10248:
L10245:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.addnotl
mm_type.addnotl:
;?>>
   %define R.p rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    mov       rcx,	rdi
    mov       rdx,	17
    call      mm_lib.insertunit
    mov       eax,	6
    mov       [rdi+49],	eax
    mov       al,	63
    mov       [rdi+62],	al
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_type.tevaluate
mm_type.tevaluate:
;?>>
   %define R.p r13
   %define R.a rdi
   %define R.b rbx
   %define R.pname rsi
    %define mm_type.tevaluate.offset -8
   %define R.tag r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       r13,	rcx
;---------------
    movzx     rax,	byte [r13]
    mov       r12,	rax
    lea       rax,	[mm_tables.jisexpr]
    mov       r10,	r12
    movzx     rax,	byte [rax + r10]
    cmp       rax,	2
    jnz       L10276
    mov       rcx,	r13
    call      mm_type.tevalbinop
    jmp       L10275
L10276:
    lea       rax,	[mm_tables.jisexpr]
    mov       r10,	r12
    movzx     rax,	byte [rax + r10]
    cmp       rax,	1
    jnz       L10277
    mov       rcx,	r13
    call      mm_type.tevalmonop
    jmp       L10275
L10277:
    mov       rax,	r12
    cmp       rax,	21
    jz        L10279
    cmp       rax,	55
    jz        L10280
    jmp       L10281
L10279:
    mov       rdi,	[r13+16]
    mov       rbx,	[r13+24]
    movsxd    rax,	dword [rdi+49]
    lea       r10,	[mm_decls.ttsize]
    mov       r10d,	[r10 + rax*4]
    cmp       r10,	8
    jg        L10283
    mov       rcx,	rdi
    call      mm_type.tevaluate
    mov       rcx,	rbx
    call      mm_type.tevaluate
    movzx     rax,	byte [rdi]
    cmp       rax,	1
    jnz       L10285
    movzx     rax,	byte [rbx]
    cmp       rax,	1
    jnz       L10285
    movzx     rax,	byte [rdi+60]
    movzx     r10,	byte [rbx+60]
    and       rax,	r10
    mov       [r13+60],	al
L10285:
L10283:
    jmp       L10278
L10280:
    mov       rdi,	[r13+16]
    mov       rcx,	rdi
    lea       rdx,	[rbp + mm_type.tevaluate.offset]
    call      mm_type.addrdotindex
    mov       rsi,	rax
    test      rsi,	rsi
    jz        L10287
    mov       rcx,	rdi
    mov       rdx,	rsi
    call      mm_lib.deleteunit
    mov       rax,	[r13+24]
    test      rax,	rax
    jnz       L10289
    mov       rcx,	[rbp + mm_type.tevaluate.offset]
    mov       rdx,	3
    call      mm_lib.createconstunit
    mov       [r13+24],	rax
    jmp       L10288
L10289:
    mov       rax,	[r13+24]
    lea       rax,	[rax+16]
    mov       r10,	[rbp + mm_type.tevaluate.offset]
    add       [rax],	r10
L10288:
L10287:
L10281:
L10278:
L10275:
;---------------
    add       rsp,	40
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.addrdotindex
mm_type.addrdotindex:
;?>>
   %define R.p rsi
   %define R.offset r12
   %define R.q rdi
   %define R.axmode rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    movzx     rax,	byte [rsi]
    cmp       rax,	49
    jz        L10292
    cmp       rax,	46
    jz        L10293
    jmp       L10294
L10292:
    mov       rax,	[rsi+16]
    movzx     rax,	byte [rax]
    cmp       rax,	4
    jnz       L10296
    mov       eax,	[rsi+40]
    mov       [r12],	rax
    mov       rax,	[rsi+16]
    jmp       L10295
L10296:
    mov       rax,	[rsi+16]
    mov       rcx,	rax
    mov       rdx,	r12
    call      mm_type.addrdotindex
    mov       rdi,	rax
    mov       eax,	[rsi+40]
    mov       r10,	r12
    add       [r10],	rax
    mov       rax,	rdi
L10295:
    jmp       L10291
L10293:
    mov       rax,	[rsi+16]
    movsxd    rax,	dword [rax+49]
    mov       rbx,	rax
    mov       rax,	[rsi+24]
    movzx     rax,	byte [rax]
    cmp       rax,	1
    jnz       L10298
    mov       rax,	[rsi+16]
    movzx     rax,	byte [rax]
    cmp       rax,	4
    jnz       L10300
    mov       rax,	[rsi+24]
    mov       rax,	[rax+16]
    lea       r10,	[mm_decls.ttlower]
    mov       r11,	rbx
    movsxd    r10,	dword [r10 + r11*4]
    sub       rax,	r10
    lea       r10,	[mm_decls.tttarget]
    mov       r11,	rbx
    movsxd    r10,	dword [r10 + r11*4]
    lea       r11,	[mm_decls.ttsize]
    mov       r11d,	[r11 + r10*4]
    imul      rax,	r11
    mov       [r12],	rax
    mov       rax,	[rsi+16]
    jmp       L10299
L10300:
    mov       rax,	[rsi+16]
    mov       rcx,	rax
    mov       rdx,	r12
    call      mm_type.addrdotindex
    mov       rdi,	rax
    test      rdi,	rdi
    jz        L10302
    mov       rax,	[rsi+24]
    mov       rax,	[rax+16]
    lea       r10,	[mm_decls.ttlower]
    mov       r11,	rbx
    movsxd    r10,	dword [r10 + r11*4]
    sub       rax,	r10
    lea       r10,	[mm_decls.tttarget]
    mov       r11,	rbx
    movsxd    r10,	dword [r10 + r11*4]
    lea       r11,	[mm_decls.ttsize]
    mov       r11d,	[r11 + r10*4]
    imul      rax,	r11
    mov       r10,	r12
    add       [r10],	rax
L10302:
    mov       rax,	rdi
L10299:
    jmp       L10297
L10298:
    xor       eax,	eax
L10297:
    jmp       L10291
L10294:
    xor       eax,	eax
L10291:
L10290:
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tevalbinop
mm_type.tevalbinop:
;?>>
   %define R.p r15
   %define R.a rdi
   %define R.b rbx
   %define R.c rsi
   %define R.offset r12
   %define R.x XMM15
   %define R.y XMM14
   %define R.z XMM13
   %define R.lhs r13
   %define R.rhs r14
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
    movq      rax,	XMM13
    push      rax
    movq      rax,	XMM14
    push      rax
    movq      rax,	XMM15
    push      rax
;?]]
    sub       rsp,	40
    mov       r15,	rcx
;---------------
    mov       r13,	[r15+16]
    mov       r14,	[r15+24]
    movzx     rax,	byte [r13]
    movzx     r10,	byte [r14]
    cmp       r10,	rax
    jnz       L10306
    cmp       r10,	1
    jz        L10305
L10306:
    movzx     rax,	byte [r13]
    cmp       rax,	55
    jnz       L10308
    movzx     rax,	byte [r14]
    cmp       rax,	1
    jnz       L10308
    mov       rax,	[r13+16]
    movzx     rax,	byte [rax]
    cmp       rax,	4
    jnz       L10310
    mov       rax,	[r14+16]
    movsxd    r10,	dword [r13+49]
    lea       r11,	[mm_decls.tttarget]
    movsxd    r11,	dword [r11 + r10*4]
    lea       r10,	[mm_decls.ttsize]
    mov       r10d,	[r10 + r11*4]
    imul      rax,	r10
    mov       r12,	rax
    movzx     rax,	byte [r15+62]
    cmp       rax,	58
    jnz       L10312
    mov       rax,	r12
    neg       rax
    mov       r12,	rax
L10312:
    mov       rax,	[r13+24]
    test      rax,	rax
    jnz       L10314
    mov       rcx,	r12
    mov       rdx,	3
    call      mm_lib.createconstunit
    mov       [r13+24],	rax
    jmp       L10313
L10314:
    mov       rax,	[r13+24]
    lea       rax,	[rax+16]
    mov       r10,	r12
    add       [rax],	r10
L10313:
    mov       rcx,	r15
    mov       rdx,	r13
    call      mm_lib.deleteunit
L10310:
L10308:
    jmp       L10303
L10305:
    movsxd    rax,	dword [r15+49]
    lea       r10,	[mm_decls.ttisreal]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L10316
    mov       rax,	[r15+16]
    movq      XMM4,	[rax+16]
    movq      XMM15,	XMM4
    mov       rax,	[r15+24]
    movq      XMM4,	[rax+16]
    movq      XMM14,	XMM4
    jmp       L10315
L10316:
    mov       rax,	[r15+16]
    mov       rdi,	[rax+16]
    mov       rax,	[r15+24]
    mov       rbx,	[rax+16]
L10315:
    movsxd    rax,	dword [r15+49]
    cmp       rax,	3
    jz        L10318
    cmp       rax,	4
    jz        L10318
    cmp       rax,	1
    jz        L10319
    cmp       rax,	2
    jz        L10319
    jmp       L10320
L10318:
    movzx     rax,	byte [r15+62]
    cmp       rax,	43
    jz        L10322
    cmp       rax,	44
    jz        L10323
    cmp       rax,	45
    jz        L10324
    cmp       rax,	47
    jz        L10325
    cmp       rax,	48
    jz        L10326
    cmp       rax,	53
    jz        L10327
    cmp       rax,	50
    jz        L10328
    cmp       rax,	51
    jz        L10329
    cmp       rax,	82
    jz        L10330
    jmp       L10331
L10322:
    mov       rax,	rdi
    add       rax,	rbx
    mov       rsi,	rax
    jmp       L10321
L10323:
    mov       rax,	rdi
    sub       rax,	rbx
    mov       rsi,	rax
    jmp       L10321
L10324:
    mov       rax,	rdi
    imul      rax,	rbx
    mov       rsi,	rax
    jmp       L10321
L10325:
    test      rbx,	rbx
    jnz       L10333
    lea       rcx,	[L13637]
    xor       edx,	edx
    call      mm_support.txerror
L10333:
    mov       rax,	rdi
    mov       r10,	rbx
    cqo       
    idiv      r10
    mov       rsi,	rax
    jmp       L10321
L10326:
    test      rbx,	rbx
    jnz       L10335
    lea       rcx,	[L13638]
    xor       edx,	edx
    call      mm_support.txerror
L10335:
    mov       rax,	rdi
    mov       r10,	rbx
    cqo       
    idiv      r10
    xchg      rax,	rdx
    mov       rsi,	rax
    jmp       L10321
L10327:
    mov       rax,	rdi
    mov       cl,	bl
    shl       rax,	cl
    mov       rsi,	rax
    jmp       L10321
L10328:
    mov       rax,	rdi
    and       rax,	rbx
    mov       rsi,	rax
    jmp       L10321
L10329:
    mov       rax,	rdi
    or        rax,	rbx
    mov       rsi,	rax
    jmp       L10321
L10330:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      msys.m$power_i64
    mov       rsi,	rax
    jmp       L10321
L10331:
    jmp       L10303
L10321:
    jmp       L10317
L10319:
    movzx     rax,	byte [r15+62]
    cmp       rax,	43
    jz        L10337
    cmp       rax,	44
    jz        L10338
    cmp       rax,	45
    jz        L10339
    cmp       rax,	82
    jz        L10340
    jmp       L10341
L10337:
    movq      XMM4,	XMM15
    addsd     XMM4,	XMM14
    movq      XMM13,	XMM4
    jmp       L10336
L10338:
    movq      XMM4,	XMM15
    subsd     XMM4,	XMM14
    movq      XMM13,	XMM4
    jmp       L10336
L10339:
    movq      XMM4,	XMM15
    mulsd     XMM4,	XMM14
    movq      XMM13,	XMM4
    jmp       L10336
L10340:
    movq      XMM0,	XMM15
    movq      XMM1,	XMM14
    call      pow
    movq      XMM13,	XMM0
    jmp       L10336
L10341:
    jmp       L10303
L10336:
    jmp       L10317
L10320:
    jmp       L10303
L10317:
    movsxd    rax,	dword [r15+49]
    lea       r10,	[mm_decls.ttisreal]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L10343
    movq      XMM4,	XMM13
    movq      rax,	XMM4
    mov       rcx,	r15
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_type.makenewconst
    jmp       L10342
L10343:
    mov       rcx,	r15
    mov       rdx,	rsi
    xor       r8d,	r8d
    call      mm_type.makenewconst
L10342:
L10303:
;---------------
    add       rsp,	40
    pop       rcx
    movq      XMM15,	rcx
    pop       rcx
    movq      XMM14,	rcx
    pop       rcx
    movq      XMM13,	rcx
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tevalmonop
mm_type.tevalmonop:
;?>>
   %define R.p rsi
   %define R.a rdi
   %define R.c rbx
   %define R.x XMM15
   %define R.z XMM14
    push      rdi
    push      rbx
    push      rsi
    movq      rax,	XMM14
    push      rax
    movq      rax,	XMM15
    push      rax
;?]]
    sub       rsp,	48
    mov       rsi,	rcx
;---------------
    mov       rax,	[rsi+16]
    movzx     rax,	byte [rax]
    cmp       rax,	1
    jnz       L10344
L10346:
    mov       rax,	[rsi+16]
    mov       rdi,	[rax+16]
    mov       rax,	[rsi+16]
    movq      XMM4,	[rax+16]
    movq      XMM15,	XMM4
    movsxd    rax,	dword [rsi+49]
    cmp       rax,	3
    jz        L10348
    cmp       rax,	4
    jz        L10348
    cmp       rax,	1
    jz        L10349
    cmp       rax,	2
    jz        L10349
    cmp       rax,	6
    jz        L10350
    jmp       L10351
L10348:
    movzx     rax,	byte [rsi]
    cmp       rax,	18
    jz        L10354
    cmp       rax,	19
    jnz       L10353
L10354:
    jmp       L10355
L10353:
    movzx     rax,	byte [rsi+62]
    cmp       rax,	60
    jz        L10357
    cmp       rax,	63
    jz        L10358
    cmp       rax,	62
    jz        L10359
    cmp       rax,	61
    jz        L10360
    jmp       L10361
L10357:
    mov       rax,	rdi
    neg       rax
    mov       rbx,	rax
    jmp       L10356
L10358:
    mov       rax,	rdi
    test      rax,	rax
    setz      al
    movzx     eax,	al
    mov       rbx,	rax
    mov       eax,	6
    mov       [rsi+49],	eax
    jmp       L10356
L10359:
    mov       rax,	rdi
    not       rax
    mov       rbx,	rax
    jmp       L10356
L10360:
    mov       rax,	rdi
    cmp       rax,	0
    jge       L13639
    neg       rax
L13639:
    mov       rbx,	rax
    jmp       L10356
L10361:
    jmp       L10344
L10356:
    jmp       L10347
L10349:
    movzx     rax,	byte [rsi+62]
    cmp       rax,	60
    jz        L10363
    cmp       rax,	73
    jz        L10364
    cmp       rax,	67
    jz        L10365
    jmp       L10366
L10363:
    movq      XMM4,	XMM15
    xorpd     XMM4,	[L12285]
    movq      XMM14,	XMM4
    jmp       L10362
L10364:
    movq      XMM0,	XMM15
    call      atan
    movq      XMM14,	XMM0
    jmp       L10362
L10365:
    movq      XMM4,	XMM15
    sqrtsd    XMM4,	XMM4
    movq      XMM14,	XMM4
    jmp       L10362
L10366:
    jmp       L10344
L10362:
    jmp       L10347
L10350:
;mm_type.tevalmonop.dobool:
L10355:
    movzx     rax,	byte [rsi]
    cmp       rax,	18
    jz        L10368
    cmp       rax,	19
    jz        L10369
    jmp       L10370
L10368:
    mov       rax,	rdi
    test      rax,	rax
    setnz     al
    movzx     eax,	al
    mov       rbx,	rax
    mov       eax,	6
    mov       [rsi+49],	eax
    jmp       L10367
L10369:
    mov       rax,	rdi
    test      rax,	rax
    setz      al
    movzx     eax,	al
    mov       rbx,	rax
    mov       eax,	6
    mov       [rsi+49],	eax
    jmp       L10367
L10370:
    movzx     rax,	byte [rsi+62]
    cmp       rax,	64
    jz        L10372
    cmp       rax,	63
    jz        L10373
    jmp       L10374
L10372:
    mov       rax,	rdi
    test      rax,	rax
    setnz     al
    movzx     eax,	al
    mov       rbx,	rax
    mov       eax,	6
    mov       [rsi+49],	eax
    jmp       L10371
L10373:
    mov       rax,	rdi
    test      rax,	rax
    setz      al
    movzx     eax,	al
    mov       rbx,	rax
    mov       eax,	6
    mov       [rsi+49],	eax
L10374:
L10371:
L10367:
    jmp       L10347
L10351:
    jmp       L10344
L10347:
    movsxd    rax,	dword [rsi+49]
    lea       r10,	[mm_decls.ttisreal]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L10376
    movq      XMM4,	XMM14
    movq      rax,	XMM4
    mov       rcx,	rsi
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_type.makenewconst
    jmp       L10375
L10376:
    mov       rcx,	rsi
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      mm_type.makenewconst
L10375:
L10344:
;---------------
    add       rsp,	48
    pop       rcx
    movq      XMM15,	rcx
    pop       rcx
    movq      XMM14,	rcx
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.iscondtrue
mm_type.iscondtrue:
;?>>
   %define R.p rcx
;?]]
;---------------
    movzx     rax,	byte [rcx]
    cmp       rax,	1
    jnz       L10378
    mov       rax,	[rcx+16]
    test      rax,	rax
    jz        L10378
    mov       rax,	1
    jmp       L10379
L10378:
    xor       eax,	eax
L10379:
L10377:
;---------------
    ret       
;End 
;Proc mm_type.iscondfalse
mm_type.iscondfalse:
;?>>
   %define R.p rcx
;?]]
;---------------
    movzx     rax,	byte [rcx]
    cmp       rax,	1
    jnz       L10381
    mov       rax,	[rcx+16]
    test      rax,	rax
    jnz       L10381
    mov       rax,	1
    jmp       L10382
L10381:
    xor       eax,	eax
L10382:
L10380:
;---------------
    ret       
;End 
;Proc mm_type.fixchararray
mm_type.fixchararray:
;?>>
   %define R.a rdi
    push      rdi
;?]]
    sub       rsp,	48
    mov       rdi,	rcx
;---------------
    test      rdi,	rdi
    jz        L10385
    movsxd    rax,	dword [rdi+49]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    cmp       r10,	10
    jnz       L10385
    movsxd    rax,	dword [rdi+49]
    lea       r10,	[mm_decls.tttarget]
    movsxd    r10,	dword [r10 + rax*4]
    cmp       r10,	12
    jnz       L10385
    mov       rcx,	rdi
    mov       rdx,	20
    xor       r8d,	r8d
    call      mm_type.coerceunit
L10385:
;---------------
    add       rsp,	48
    pop       rdi
    ret       
;End 
;Proc mm_type.combinestrings
mm_type.combinestrings:
;?>>
    %define mm_type.combinestrings.p 72
   %define R.a rdi
   %define R.b rbx
   %define R.alen rsi
   %define R.blen r12
   %define R.clen r13
   %define R.needterm r14
   %define R.atype r15b
    %define mm_type.combinestrings.btype -8
    %define mm_type.combinestrings.ctype -16
    %define mm_type.combinestrings.s -24
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
    mov       [rbp+72],	rcx
;---------------
    mov       rax,	[rbp + mm_type.combinestrings.p]
    mov       rdi,	[rax+16]
    mov       rax,	[rbp + mm_type.combinestrings.p]
    mov       rbx,	[rax+24]
    mov       eax,	[rdi+40]
    mov       rsi,	rax
    mov       eax,	[rbx+40]
    mov       r12,	rax
    mov       r15b,	[rdi+45]
    mov       al,	[rbx+45]
    mov       [rbp + mm_type.combinestrings.btype],	al
    movzx     rax,	r15b
    movzx     r10,	byte [rbp + mm_type.combinestrings.btype]
    cmp       r10,	rax
    jnz       L10388
    cmp       r10,	66
    jnz       L10388
    xor       r14,	r14
    mov       al,	66
    mov       [rbp + mm_type.combinestrings.ctype],	al
    jmp       L10387
L10388:
    movzx     rax,	r15b
    cmp       rax,	66
    jz        L10390
    movzx     rax,	byte [rbp + mm_type.combinestrings.btype]
    cmp       rax,	66
    jnz       L10389
L10390:
    lea       rcx,	[L13640]
    xor       edx,	edx
    call      mm_support.txerror
    jmp       L10387
L10389:
    dec       rsi
    dec       r12
    mov       r14,	1
    movzx     rax,	r15b
    cmp       rax,	83
    jz        L10393
    movzx     rax,	byte [rbp + mm_type.combinestrings.btype]
    cmp       rax,	83
    jnz       L10392
L10393:
    mov       al,	83
    mov       [rbp + mm_type.combinestrings.ctype],	al
    jmp       L10391
L10392:
    xor       eax,	eax
    mov       [rbp + mm_type.combinestrings.ctype],	al
L10391:
L10387:
    mov       rax,	rsi
    add       rax,	r12
    mov       r13,	rax
    test      r12,	r12
    jnz       L10395
    mov       rcx,	[rbp + mm_type.combinestrings.p]
    mov       rdx,	rdi
    call      mm_lib.deleteunit
    jmp       L10386
L10395:
    test      rsi,	rsi
    jnz       L10396
    mov       rcx,	[rbp + mm_type.combinestrings.p]
    mov       rdx,	rbx
    call      mm_lib.deleteunit
    jmp       L10386
L10396:
L10394:
    mov       rax,	r13
    add       rax,	r14
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [rbp + mm_type.combinestrings.s],	rax
    mov       rax,	[rdi+16]
    mov       rcx,	[rbp + mm_type.combinestrings.s]
    mov       rdx,	rax
    mov       r8,	rsi
    call      memcpy
    mov       rax,	[rbx+16]
    mov       r10,	[rbp + mm_type.combinestrings.s]
    mov       r11,	rsi
    lea       r10,	[r10 + r11]
    mov       rcx,	r10
    mov       rdx,	rax
    mov       r8,	r12
    call      memcpy
    test      r14,	r14
    jz        L10398
    xor       eax,	eax
    mov       r10,	[rbp + mm_type.combinestrings.s]
    mov       r11,	r13
    mov       [r10 + r11],	al
L10398:
    mov       rcx,	[rbp + mm_type.combinestrings.p]
    mov       rdx,	rdi
    call      mm_lib.deleteunit
    mov       rax,	r13
    add       rax,	r14
    mov       r10,	[rbp + mm_type.combinestrings.p]
    mov       [r10+40],	eax
    mov       rax,	[rbp + mm_type.combinestrings.s]
    mov       r10,	[rbp + mm_type.combinestrings.p]
    mov       [r10+16],	rax
    mov       al,	r15b
    mov       r10,	[rbp + mm_type.combinestrings.p]
    mov       [r10+45],	al
L10386:
;---------------
    add       rsp,	56
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.mulstrings
mm_type.mulstrings:
;?>>
    %define mm_type.mulstrings.p 72
   %define R.a rdi
   %define R.b rbx
   %define R.alen rsi
   %define R.scale r12
   %define R.clen r13
   %define R.needterm r14
   %define R.atype r15b
    %define mm_type.mulstrings.s -8
    %define mm_type.mulstrings.t -16
    %define mm_type.mulstrings.av_1 -24
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
    mov       [rbp+72],	rcx
;---------------
    mov       rax,	[rbp + mm_type.mulstrings.p]
    mov       rdi,	[rax+16]
    mov       rax,	[rbp + mm_type.mulstrings.p]
    mov       rbx,	[rax+24]
    mov       eax,	[rdi+40]
    mov       rsi,	rax
    mov       r12,	[rbx+16]
    mov       r15b,	[rdi+45]
    dec       rsi
    mov       r14,	1
    movzx     rax,	r15b
    cmp       rax,	83
    jnz       L10401
    mov       r14,	1
L10401:
    mov       rax,	rsi
    imul      rax,	r12
    mov       r13,	rax
    cmp       r12,	1
    jl        L10404
    cmp       r13,	1
    jl        L10404
    cmp       r13,	100000
    jg        L10404
    cmp       rsi,	1
    jge       L10403
L10404:
    lea       rcx,	[L13641]
    xor       edx,	edx
    call      mm_support.txerror
L10403:
    mov       rax,	r13
    add       rax,	r14
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [rbp + mm_type.mulstrings.s],	rax
    mov       [rbp + mm_type.mulstrings.t],	rax
    mov       [rbp + mm_type.mulstrings.av_1],	r12
    mov       rax,	[rbp + mm_type.mulstrings.av_1]
    cmp       rax,	0
    jle       L10407
L10405:
    mov       rax,	[rdi+16]
    mov       rcx,	[rbp + mm_type.mulstrings.t]
    mov       rdx,	rax
    mov       r8,	rsi
    call      memcpy
    mov       rax,	rsi
    add       [rbp + mm_type.mulstrings.t],	rax
    dec       qword [rbp + mm_type.mulstrings.av_1]
    jnz       L10405
L10407:
    test      r14,	r14
    jz        L10409
    xor       eax,	eax
    mov       r10,	[rbp + mm_type.mulstrings.s]
    mov       r11,	r13
    mov       [r10 + r11],	al
L10409:
    mov       rcx,	[rbp + mm_type.mulstrings.p]
    mov       rdx,	rdi
    call      mm_lib.deleteunit
    mov       rax,	r13
    add       rax,	r14
    mov       r10,	[rbp + mm_type.mulstrings.p]
    mov       [r10+40],	eax
    mov       rax,	[rbp + mm_type.mulstrings.s]
    mov       r10,	[rbp + mm_type.mulstrings.p]
    mov       [r10+16],	rax
    mov       al,	r15b
    mov       r10,	[rbp + mm_type.mulstrings.p]
    mov       [r10+45],	al
;---------------
    add       rsp,	56
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_strinclude
mm_type.tx_strinclude:
;?>>
   %define R.p rsi
   %define R.a r12
   %define R.fileno rdi
   %define R.pf rbx
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
;---------------
    mov       rcx,	r12
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    movzx     rax,	byte [r12]
    cmp       rax,	1
    jnz       L10413
    mov       al,	[r12+44]
    test      al,	al
    jnz       L10412
L10413:
    lea       rcx,	[L13642]
    xor       edx,	edx
    call      mm_support.txerror
L10412:
    movzx     rax,	byte [rsi+57]
    lea       r10,	[mm_decls.modules]
    mov       r10,	[r10 + rax*8]
    movsx     r10,	word [r10+20]
    mov       rdi,	r10
    lea       rax,	[mm_decls.sources]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8]
    mov       rax,	[rax+16]
    mov       r10,	[r12+16]
    mov       rcx,	r10
    lea       rdx,	[L13643]
    mov       r8,	rax
    call      mm_support.getsupportfile
    mov       rbx,	rax
    mov       rax,	[rbx+32]
    mov       [r12+16],	rax
    mov       rax,	[rbx+48]
    inc       rax
    mov       [r12+40],	eax
    mov       al,	[rsi+45]
    mov       [r12+45],	al
    movzx     rax,	byte [r12+45]
    cmp       rax,	66
    jnz       L10415
    lea       rax,	[r12+40]
    dec       dword [rax]
L10415:
    mov       rcx,	rsi
    mov       rdx,	r12
    call      mm_lib.deleteunit
;---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.coerceunit
mm_type.coerceunit:
;?>>
   %define R.p r13
    %define mm_type.coerceunit.t 64
    %define mm_type.coerceunit.hard 72
   %define R.opc rdi
   %define R.s rbx
   %define R.n rsi
   %define R.sbase r12
    %define mm_type.coerceunit.tbase -8
    %define mm_type.coerceunit.starg -16
    %define mm_type.coerceunit.ttarg -24
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
    mov       r13,	rcx
    mov       [rbp+64],	rdx
    mov       [rbp+72],	r8
;---------------
    movsxd    rax,	dword [r13+49]
    mov       rbx,	rax
    mov       rax,	[rbp + mm_type.coerceunit.t]
    test      rax,	rax
    jz        L10419
    cmp       rbx,	[rbp + mm_type.coerceunit.t]
    jnz       L10418
L10419:
    jmp       L10416
L10418:
    test      rbx,	rbx
    jnz       L10421
    lea       rcx,	[L13644]
    xor       edx,	edx
    call      mm_support.txerror
L10421:
    cmp       rbx,	[rbp + mm_type.coerceunit.t]
    jz        L10416
L10423:
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rbx
    movsxd    rax,	dword [rax + r10*4]
    mov       r12,	rax
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	[rbp + mm_type.coerceunit.t]
    movsxd    rax,	dword [rax + r10*4]
    mov       [rbp + mm_type.coerceunit.tbase],	rax
    xor       rdi,	rdi
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	rbx
    movsxd    rax,	dword [rax + r10*4]
    mov       [rbp + mm_type.coerceunit.starg],	rax
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	[rbp + mm_type.coerceunit.t]
    movsxd    rax,	dword [rax + r10*4]
    mov       [rbp + mm_type.coerceunit.ttarg],	rax
    cmp       rbx,	20
    jnz       L10425
    mov       r12,	20
L10425:
    mov       rax,	[rbp + mm_type.coerceunit.t]
    cmp       rax,	20
    jnz       L10427
    mov       rax,	20
    mov       [rbp + mm_type.coerceunit.tbase],	rax
L10427:
    mov       rax,	r12
    cmp       rax,	1
    jl        L10429
    cmp       rax,	5
    jg        L10429
    mov       rax,	[rbp + mm_type.coerceunit.tbase]
    cmp       rax,	1
    jl        L10431
    cmp       rax,	5
    jg        L10431
    lea       rax,	[mm_tables.softconvtable]
    mov       r10,	r12
    shl       r10,	1
    lea       r10,	[r10 + r10*4]
    lea       rax,	[rax + r10-10]
    mov       r10,	[rbp + mm_type.coerceunit.tbase]
    movsx     rax,	word [rax + r10*2-2]
    mov       rdi,	rax
    jmp       L10430
L10431:
    mov       rax,	[rbp + mm_type.coerceunit.tbase]
    cmp       rax,	7
    jz        L10433
    cmp       rax,	20
    jnz       L10434
L10433:
    mov       rdi,	7
;mm_type.coerceunit.checkhard:
L10435:
    mov       rax,	[rbp + mm_type.coerceunit.hard]
    test      rax,	rax
    jnz       L10437
    mov       rdi,	9
L10437:
    jmp       L10432
L10434:
    mov       rax,	[rbp + mm_type.coerceunit.tbase]
    cmp       rax,	12
    jl        L10439
    cmp       rax,	19
    jg        L10439
    lea       rax,	[mm_decls.ttisinteger]
    mov       r10,	r12
    mov       al,	[rax + r10]
    test      al,	al
    jz        L10441
    mov       rax,	[rbp + mm_type.coerceunit.hard]
    test      rax,	rax
    jnz       L10443
    mov       rdi,	10
    jmp       L10442
L10443:
    mov       rdi,	3
L10442:
L10441:
    jmp       L10438
L10439:
    mov       rax,	[rbp + mm_type.coerceunit.tbase]
    cmp       rax,	6
    jz        L10445
    cmp       rax,	26
    jz        L10446
    jmp       L10447
L10445:
    mov       rdi,	8
    jmp       L10444
L10446:
    mov       rdi,	7
L10447:
L10444:
L10438:
L10432:
L10430:
    jmp       L10428
L10429:
    mov       rax,	r12
    cmp       rax,	6
    jz        L10449
    cmp       rax,	7
    jz        L10450
    cmp       rax,	20
    jz        L10451
    cmp       rax,	10
    jz        L10452
    cmp       rax,	11
    jz        L10453
    cmp       rax,	26
    jz        L10454
    jmp       L10455
L10449:
    mov       rax,	[rbp + mm_type.coerceunit.tbase]
    cmp       rax,	3
    jz        L10458
    cmp       rax,	4
    jnz       L10457
L10458:
    mov       rdi,	7
L10457:
    jmp       L10448
L10450:
    mov       rax,	[rbp + mm_type.coerceunit.tbase]
    cmp       rax,	3
    jz        L10460
    cmp       rax,	4
    jz        L10460
    cmp       rax,	7
    jz        L10461
    cmp       rax,	20
    jz        L10462
    cmp       rax,	6
    jz        L10463
    jmp       L10464
L10460:
    mov       rdi,	7
    jmp       L10435
L10461:
    mov       rax,	[rbp + mm_type.coerceunit.starg]
    test      rax,	rax
    jz        L10467
    mov       rax,	[rbp + mm_type.coerceunit.ttarg]
    test      rax,	rax
    jnz       L10466
L10467:
    mov       rdi,	7
    jmp       L10465
L10466:
;mm_type.coerceunit.checkref:
L10468:
    mov       rdi,	7
    mov       rcx,	rbx
    mov       rdx,	[rbp + mm_type.coerceunit.t]
    call      mm_type.comparemodes
    test      rax,	rax
    jz        L10435
L10470:
L10465:
    jmp       L10459
L10462:
    jmp       L10468
L10463:
    mov       rdi,	8
L10464:
L10459:
    jmp       L10448
L10451:
    mov       rax,	[rbp + mm_type.coerceunit.tbase]
    cmp       rax,	3
    jz        L10472
    cmp       rax,	4
    jz        L10472
    cmp       rax,	7
    jz        L10473
    cmp       rax,	6
    jz        L10474
    cmp       rax,	11
    jz        L10475
    cmp       rax,	10
    jz        L10476
    jmp       L10477
L10472:
    mov       rdi,	7
    jmp       L10435
L10473:
    mov       rcx,	rbx
    mov       rdx,	[rbp + mm_type.coerceunit.t]
    call      mm_type.comparemodes
    test      rax,	rax
    jnz       L10480
    mov       rax,	[rbp + mm_type.coerceunit.hard]
    test      rax,	rax
    jz        L10479
L10480:
    mov       rdi,	7
    jmp       L10478
L10479:
    mov       rdi,	9
L10478:
    jmp       L10471
L10474:
    mov       rdi,	8
    jmp       L10471
L10475:
    mov       rax,	[rbp + mm_type.coerceunit.ttarg]
    cmp       rax,	12
    jz        L10483
    cmp       rax,	17
    jnz       L10482
L10483:
    mov       rdi,	11
L10482:
    jmp       L10471
L10476:
    movzx     rax,	byte [r13]
    cmp       rax,	1
    jnz       L10485
    mov       al,	[r13+45]
    test      al,	al
    jz        L10485
    mov       rdi,	7
    lea       rax,	[mm_decls.ttlength]
    mov       r10,	[rbp + mm_type.coerceunit.t]
    movsxd    rax,	dword [rax + r10*4]
    mov       rsi,	rax
    test      rsi,	rsi
    jnz       L10487
    mov       eax,	[r13+40]
    movsxd    r10,	dword [r13+49]
    lea       r11,	[mm_decls.tttarget]
    movsxd    r11,	dword [r11 + r10*4]
    lea       r10,	[mm_decls.ttsize]
    mov       r10d,	[r10 + r11*4]
    cqo       
    idiv      r10
    lea       r10,	[mm_decls.ttlength]
    mov       r11,	[rbp + mm_type.coerceunit.t]
    mov       [r10 + r11*4],	eax
    mov       eax,	[r13+40]
    lea       r10,	[mm_decls.ttsize]
    mov       r11,	[rbp + mm_type.coerceunit.t]
    mov       [r10 + r11*4],	eax
    jmp       L10486
L10487:
    lea       rcx,	[L13645]
    xor       edx,	edx
    call      mm_support.txerror
L10486:
L10485:
L10477:
L10471:
    jmp       L10448
L10452:
    mov       rax,	[rbp + mm_type.coerceunit.tbase]
    cmp       rax,	10
    jz        L10489
    cmp       rax,	11
    jz        L10490
    cmp       rax,	20
    jz        L10491
    cmp       rax,	7
    jz        L10492
    jmp       L10493
L10489:
    mov       rcx,	rbx
    mov       rdx,	[rbp + mm_type.coerceunit.t]
    call      mm_type.comparemodes
    test      rax,	rax
    jz        L10495
    mov       rdi,	7
L10495:
    jmp       L10488
L10490:
    mov       rcx,	[rbp + mm_type.coerceunit.starg]
    mov       rdx,	[rbp + mm_type.coerceunit.ttarg]
    call      mm_type.comparemodes
    test      rax,	rax
    jz        L10497
    mov       rdi,	12
L10497:
    jmp       L10488
L10491:
    mov       rax,	[rbp + mm_type.coerceunit.starg]
    cmp       rax,	12
    jz        L10500
    cmp       rax,	17
    jnz       L10499
L10500:
    mov       rdi,	13
L10499:
    jmp       L10488
L10492:
    mov       rax,	[rbp + mm_type.coerceunit.ttarg]
    test      rax,	rax
    jnz       L10502
    mov       rdi,	13
L10502:
L10493:
L10488:
    jmp       L10448
L10453:
    mov       rax,	[rbp + mm_type.coerceunit.tbase]
    cmp       rax,	11
    jz        L10504
    cmp       rax,	7
    jz        L10505
    jmp       L10506
L10504:
    mov       rcx,	rbx
    mov       rdx,	[rbp + mm_type.coerceunit.t]
    call      mm_type.comparemodes
    test      rax,	rax
    jz        L10508
    mov       rdi,	7
L10508:
    jmp       L10503
L10505:
    mov       rax,	[rbp + mm_type.coerceunit.ttarg]
    test      rax,	rax
    jz        L10511
    mov       rcx,	[rbp + mm_type.coerceunit.starg]
    mov       rdx,	[rbp + mm_type.coerceunit.ttarg]
    call      mm_type.comparemodes
    test      rax,	rax
    jz        L10510
L10511:
    lea       rcx,	[L13646]
    xor       edx,	edx
    call      mm_support.gerror
L10510:
L10506:
L10503:
    jmp       L10448
L10454:
    mov       rax,	[rbp + mm_type.coerceunit.tbase]
    cmp       rax,	5
    jg        L10513
    mov       rdi,	7
L10513:
L10455:
L10448:
L10428:
    mov       rcx,	r13
    mov       rdx,	rbx
    mov       r8,	[rbp + mm_type.coerceunit.t]
    mov       r9,	rdi
    call      mm_type.applyconversion
L10416:
;---------------
    add       rsp,	56
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.applyconversion
mm_type.applyconversion:
;?>>
   %define R.p rdi
   %define R.s rbx
   %define R.t rsi
   %define R.opc r12
    %define mm_type.applyconversion.$T1 -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
    mov       r12,	r9
;---------------
    mov       rax,	r12
    test      rax,	rax
    jz        L10516
    cmp       rax,	9
    jz        L10517
    cmp       rax,	7
    jz        L10518
    cmp       rax,	10
    jz        L10519
    cmp       rax,	12
    jz        L10520
    cmp       rax,	11
    jz        L10521
    cmp       rax,	13
    jz        L10522
    jmp       L10523
L10516:
    mov       rcx,	rsi
    mov       rdx,	1
    call      mm_lib.strmode2
    mov       [rbp + mm_type.applyconversion.$T1],	rax
    mov       rcx,	rbx
    mov       rdx,	1
    call      mm_lib.strmode
    lea       rcx,	[L13647]
    mov       rdx,	rax
    mov       r8,	[rbp + mm_type.applyconversion.$T1]
    call      mm_support.txerror_ss
    jmp       L10515
L10517:
    mov       rcx,	rsi
    mov       rdx,	1
    call      mm_lib.strmode2
    mov       [rbp + mm_type.applyconversion.$T1],	rax
    mov       rcx,	rbx
    mov       rdx,	1
    call      mm_lib.strmode
    lea       rcx,	[L13648]
    mov       rdx,	rax
    mov       r8,	[rbp + mm_type.applyconversion.$T1]
    call      mm_support.txerror_ss
    jmp       L10515
L10518:
    mov       [rdi+49],	esi
    jmp       L10514
L10519:
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	rsi
    mov       r9,	r12
    call      mm_type.tevalconvert
    test      rax,	rax
    jnz       L10514
L10525:
    mov       rcx,	rdi
    mov       rdx,	59
    call      mm_lib.insertunit
    mov       [rdi+49],	esi
    jmp       L10514
L10520:
    mov       rcx,	rdi
    mov       rdx,	48
    call      mm_lib.insertunit
    mov       [rdi+49],	esi
    jmp       L10514
L10521:
    mov       rcx,	rdi
    mov       rdx,	rsi
    call      mm_type.tstringslice
    jmp       L10514
L10522:
    mov       rcx,	rdi
    mov       rdx,	56
    call      mm_lib.insertunit
    mov       eax,	20
    mov       [rdi+49],	eax
    jmp       L10514
L10523:
L10515:
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	rsi
    mov       r9,	r12
    call      mm_type.tevalconvert
    test      rax,	rax
    jnz       L10514
L10527:
    mov       rcx,	rdi
    mov       rdx,	58
    call      mm_lib.insertunit
    mov       [rdi+62],	r12b
    mov       [rdi+53],	ebx
    mov       al,	1
    mov       [rdi+61],	al
    lea       rax,	[mm_decls.ttisshort]
    mov       r10,	rsi
    mov       al,	[rax + r10]
    test      al,	al
    jz        L10529
    mov       [rdi+53],	esi
    mov       rcx,	rsi
    call      mm_lib.gettypebase
    mov       rsi,	rax
L10529:
    mov       [rdi+49],	esi
L10514:
;---------------
    add       rsp,	48
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.checkmodes
mm_type.checkmodes:
;?>>
   %define R.s rdi
   %define R.t rbx
    %define mm_type.checkmodes.$T1 -8
    push      rdi
    push      rbx
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mm_type.comparemodes
    test      rax,	rax
    jnz       L10532
    mov       rcx,	rbx
    mov       rdx,	1
    call      mm_lib.strmode2
    mov       [rbp + mm_type.checkmodes.$T1],	rax
    mov       rcx,	rdi
    mov       rdx,	1
    call      mm_lib.strmode
    lea       rcx,	[L13649]
    mov       rdx,	rax
    mov       r8,	[rbp + mm_type.checkmodes.$T1]
    call      mm_support.txerror_ss
L10532:
;---------------
    add       rsp,	48
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.comparemodes
mm_type.comparemodes:
;?>>
   %define R.s r15
    %define mm_type.comparemodes.t 80
   %define R.sbase rdi
   %define R.tbase rbx
   %define R.starg rsi
   %define R.ttarg r12
   %define R.d r13
   %define R.e r14
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       r15,	rcx
    mov       [rbp+80],	rdx
;---------------
    cmp       r15,	[rbp + mm_type.comparemodes.t]
    jnz       L10535
    mov       rax,	1
    jmp       L10533
L10535:
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	r15
    movsxd    rax,	dword [rax + r10*4]
    mov       rdi,	rax
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	[rbp + mm_type.comparemodes.t]
    movsxd    rax,	dword [rax + r10*4]
    mov       rbx,	rax
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	r15
    movsxd    rax,	dword [rax + r10*4]
    mov       rsi,	rax
    lea       rax,	[mm_decls.tttarget]
    mov       r10,	[rbp + mm_type.comparemodes.t]
    movsxd    rax,	dword [rax + r10*4]
    mov       r12,	rax
    cmp       rdi,	rbx
    jnz       L10537
    mov       rax,	rdi
    cmp       rax,	7
    jz        L10539
    cmp       rax,	10
    jz        L10540
    cmp       rax,	11
    jz        L10541
    cmp       rax,	24
    jz        L10542
    jmp       L10543
L10539:
    test      rsi,	rsi
    jz        L10546
    test      r12,	r12
    jnz       L10545
L10546:
    mov       rax,	1
    jmp       L10533
L10545:
    mov       rcx,	rsi
    mov       rdx,	r12
    call      mm_type.comparemodes
    jmp       L10533
L10540:
    mov       rcx,	rsi
    mov       rdx,	r12
    call      mm_type.comparemodes
    test      rax,	rax
    jnz       L10548
    xor       eax,	eax
    jmp       L10533
L10548:
    lea       rax,	[mm_decls.ttlength]
    mov       r10,	r15
    movsxd    rax,	dword [rax + r10*4]
    lea       r10,	[mm_decls.ttlength]
    mov       r11,	[rbp + mm_type.comparemodes.t]
    movsxd    r10,	dword [r10 + r11*4]
    cmp       rax,	r10
    jz        L10551
    lea       rax,	[mm_decls.ttlength]
    mov       r10,	r15
    movsxd    rax,	dword [rax + r10*4]
    test      rax,	rax
    jz        L10551
    lea       rax,	[mm_decls.ttlength]
    mov       r10,	[rbp + mm_type.comparemodes.t]
    movsxd    rax,	dword [rax + r10*4]
    test      rax,	rax
    jnz       L10550
L10551:
    mov       rax,	1
    jmp       L10533
L10550:
    jmp       L10538
L10541:
    mov       rcx,	rsi
    mov       rdx,	r12
    call      mm_type.comparemodes
    jmp       L10533
L10542:
    lea       rax,	[mm_decls.ttnamedef]
    mov       r10,	r15
    mov       r13,	[rax + r10*8]
    lea       rax,	[mm_decls.ttnamedef]
    mov       r10,	[rbp + mm_type.comparemodes.t]
    mov       r14,	[rax + r10*8]
    test      r13,	r13
    jz        L10553
    test      r14,	r14
    jz        L10553
    movsxd    rax,	dword [r14+72]
    movsxd    r10,	dword [r13+72]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mm_type.comparemodes
    test      rax,	rax
    jnz       L10555
    xor       eax,	eax
    jmp       L10533
L10555:
    mov       rax,	[r13+112]
    test      rax,	rax
    jnz       L10557
    mov       rax,	[r14+112]
    test      rax,	rax
    jnz       L10557
    mov       rax,	1
    jmp       L10533
L10557:
L10553:
L10543:
L10538:
    jmp       L10536
L10537:
    cmp       rdi,	12
    jnz       L10560
    cmp       rbx,	17
    jz        L10559
L10560:
    cmp       rdi,	17
    jnz       L10558
    cmp       rbx,	12
    jnz       L10558
L10559:
    mov       rax,	1
    jmp       L10533
L10558:
L10536:
    xor       eax,	eax
L10533:
;---------------
    add       rsp,	40
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tevalconvert
mm_type.tevalconvert:
;?>>
   %define R.p r13
   %define R.s r14
    %define mm_type.tevalconvert.t 96
    %define mm_type.tevalconvert.opc 104
   %define R.x XMM15
   %define R.z XMM14
   %define R.a rdi
   %define R.c rbx
   %define R.sbase rsi
   %define R.tbase r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    movq      rax,	XMM14
    push      rax
    movq      rax,	XMM15
    push      rax
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       r13,	rcx
    mov       r14,	rdx
    mov       [rbp+96],	r8
;---------------
    movzx     rax,	byte [r13]
    cmp       rax,	1
    jz        L10563
    xor       eax,	eax
    jmp       L10561
L10563:
    mov       rdi,	[r13+16]
    movq      XMM4,	[r13+16]
    movq      XMM15,	XMM4
    mov       rax,	r14
    shl       rax,	16
    or        rax,	[rbp + mm_type.tevalconvert.t]
    cmp       rax,	196609
    jz        L10565
    cmp       rax,	196610
    jz        L10565
    cmp       rax,	65539
    jz        L10566
    cmp       rax,	65538
    jz        L10567
    cmp       rax,	196625
    jz        L10568
    cmp       rax,	196623
    jz        L10569
    jmp       L10570
L10565:
    mov       rax,	rdi
    cvtsi2sd  XMM4,	rax
    movq      XMM14,	XMM4
    jmp       L10564
L10566:
    movq      XMM4,	XMM15
    cvttsd2si rax,	XMM4
    mov       rbx,	rax
    jmp       L10564
L10567:
    movq      XMM4,	XMM15
    movq      XMM14,	XMM4
    jmp       L10564
L10568:
    mov       al,	dil
    movzx     rax,	al
    mov       rbx,	rax
    jmp       L10564
L10569:
    mov       ax,	di
    movsx     rax,	ax
    mov       rbx,	rax
    jmp       L10564
L10570:
    lea       rax,	[mm_decls.ttisinteger]
    mov       r10,	r14
    mov       al,	[rax + r10]
    test      al,	al
    jz        L10572
    lea       rax,	[mm_decls.ttisinteger]
    mov       r10,	[rbp + mm_type.tevalconvert.t]
    mov       al,	[rax + r10]
    test      al,	al
    jz        L10572
    lea       rax,	[mm_decls.ttsize]
    mov       r10,	r14
    mov       eax,	[rax + r10*4]
    lea       r10,	[mm_decls.ttsize]
    mov       r11,	[rbp + mm_type.tevalconvert.t]
    mov       r10d,	[r10 + r11*4]
    cmp       rax,	r10
    jnz       L10572
    mov       rbx,	rdi
    jmp       L10571
L10572:
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	r14
    movsxd    rax,	dword [rax + r10*4]
    mov       rsi,	rax
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	[rbp + mm_type.tevalconvert.t]
    movsxd    rax,	dword [rax + r10*4]
    mov       r12,	rax
    cmp       rsi,	r12
    jnz       L10574
    mov       rax,	1
    jmp       L10561
L10574:
    xor       eax,	eax
    jmp       L10561
L10571:
L10564:
    lea       rax,	[mm_decls.ttisreal]
    mov       r10,	[rbp + mm_type.tevalconvert.t]
    mov       al,	[rax + r10]
    test      al,	al
    jz        L10576
    movq      XMM4,	XMM14
    movq      rax,	XMM4
    mov       rcx,	r13
    mov       rdx,	rax
    mov       r8,	[rbp + mm_type.tevalconvert.t]
    call      mm_type.makenewconst
    jmp       L10575
L10576:
    mov       rcx,	r13
    mov       rdx,	rbx
    mov       r8,	[rbp + mm_type.tevalconvert.t]
    call      mm_type.makenewconst
L10575:
    mov       rax,	1
L10561:
;---------------
    add       rsp,	32
    pop       rbp
    pop       rcx
    movq      XMM15,	rcx
    pop       rcx
    movq      XMM14,	rcx
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_assign
mm_type.tx_assign:
;?>>
   %define R.p r12
   %define R.a r13
   %define R.b r14
    %define mm_type.tx_assign.t 88
   %define R.m rdi
   %define R.mm rbx
   %define R.needres rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       r12,	rcx
    mov       r13,	rdx
    mov       r14,	r8
    mov       [rbp+88],	r9
;---------------
    mov       rax,	[rbp + mm_type.tx_assign.t]
    cmp       rax,	0
    setnz     al
    movzx     eax,	al
    mov       rsi,	rax
    movzx     rax,	byte [r13]
    cmp       rax,	20
    jz        L10579
    cmp       rax,	51
    jz        L10580
    cmp       rax,	52
    jz        L10580
    jmp       L10581
L10579:
    movzx     rax,	byte [r14]
    cmp       rax,	20
    jnz       L10583
    test      rsi,	rsi
    jz        L10585
    lea       rcx,	[L13650]
    xor       edx,	edx
    call      mm_support.txerror
L10585:
    mov       rcx,	r12
    mov       rdx,	r13
    mov       r8,	r14
    call      mm_type.tx_assignmultmult
    jmp       L10582
L10583:
    mov       rcx,	r12
    mov       rdx,	r13
    mov       r8,	r14
    mov       r9,	[rbp + mm_type.tx_assign.t]
    call      mm_type.tx_assignmultscalar
L10582:
    jmp       L10577
L10580:
    mov       rax,	[r13+24]
    mov       r10,	[r13+16]
    mov       rcx,	r13
    mov       rdx,	r10
    mov       r8,	rax
    mov       r9,	1
    call      mm_type.tx_dotindex
    movsxd    rax,	dword [r13+49]
    mov       rcx,	r14
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       eax,	3
    mov       [r12+49],	eax
    jmp       L10577
L10581:
L10578:
    movzx     rax,	byte [r13]
    cmp       rax,	4
    jnz       L10587
    mov       rax,	[r13+16]
    movzx     rax,	word [rax+92]
    shr       eax,	4
    and       eax,	1
    test      rax,	rax
    jz        L10587
    mov       al,	[r12+59]
    test      al,	al
    jz        L10587
    mov       rcx,	r13
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    jmp       L10586
L10587:
    mov       rcx,	r13
    mov       rdx,	23
    call      mm_type.tpasslv
L10586:
    movsxd    rax,	dword [r13+49]
    mov       rdi,	rax
    mov       [r13+61],	sil
    lea       rax,	[mm_decls.ttbasetype]
    mov       r10,	rdi
    movsxd    rax,	dword [rax + r10*4]
    cmp       rax,	11
    jnz       L10589
    movzx     rax,	byte [r14]
    cmp       rax,	20
    jnz       L10589
    mov       rax,	[r14+16]
    mov       rcx,	r14
    mov       rdx,	rax
    mov       r8,	rdi
    call      mm_type.tx_makeslicefromlist
    mov       [r12+49],	edi
    jmp       L10588
L10589:
    movzx     rax,	byte [r14+62]
    cmp       rax,	47
    jz        L10592
    cmp       rax,	48
    jnz       L10591
L10592:
    mov       rcx,	r14
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    jmp       L10590
L10591:
    movzx     rax,	byte [r14]
    cmp       rax,	118
    jnz       L10593
    mov       rcx,	r14
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mm_type.tpass
    jmp       L10590
L10593:
    mov       rbx,	rdi
    lea       rax,	[mm_decls.ttisshort]
    mov       r10,	rdi
    mov       al,	[rax + r10]
    test      al,	al
    jz        L10595
    mov       rcx,	rdi
    call      mm_lib.gettypebase
    mov       rbx,	rax
L10595:
    movzx     rax,	byte [r14]
    cmp       rax,	60
    jz        L10597
    cmp       rax,	20
    jz        L10598
    jmp       L10599
L10597:
    mov       rcx,	r14
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      mm_type.tpass
    jmp       L10596
L10598:
    mov       rcx,	r14
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mm_type.tpass
    jmp       L10596
L10599:
    mov       rcx,	r14
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      mm_type.tpass
L10596:
    mov       [r12+49],	ebx
    movzx     rax,	byte [r14]
    cmp       rax,	58
    jnz       L10601
    movzx     rax,	byte [r14+62]
    cmp       rax,	4
    jnz       L10601
    movsxd    rax,	dword [r13+49]
    lea       r10,	[mm_decls.ttsize]
    mov       r10d,	[r10 + rax*4]
    movsxd    rax,	dword [r14+53]
    lea       r11,	[mm_decls.ttsize]
    mov       r11d,	[r11 + rax*4]
    cmp       r10,	r11
    jg        L10601
    test      rsi,	rsi
    jnz       L10601
    mov       rax,	[r14+16]
    mov       rcx,	r14
    mov       rdx,	rax
    call      mm_lib.deleteunit
L10601:
L10590:
L10588:
L10577:
;---------------
    add       rsp,	32
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_assignmultmult
mm_type.tx_assignmultmult:
;?>>
   %define R.pp r13
   %define R.a r14
   %define R.b r15
   %define R.p rdi
   %define R.q rbx
   %define R.lhs rsi
   %define R.rhs r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    sub       rsp,	48
    mov       r13,	rcx
    mov       r14,	rdx
    mov       r15,	r8
;---------------
    mov       al,	29
    mov       [r13],	al
    mov       eax,	[r14+40]
    mov       r10d,	[r15+40]
    cmp       rax,	r10
    jz        L10604
    lea       rcx,	[L13651]
    xor       edx,	edx
    call      mm_support.txerror
L10604:
    mov       eax,	[r14+40]
    test      rax,	rax
    jnz       L10606
    lea       rcx,	[L13652]
    xor       edx,	edx
    call      mm_support.txerror
L10606:
    mov       r12,	[r15+16]
    mov       rsi,	[r14+16]
    mov       rdi,	rsi
    jmp       L10610
L10607:
    mov       rcx,	rdi
    mov       rdx,	23
    call      mm_type.tpasslv
    mov       rdi,	[rdi+8]
L10610:
    test      rdi,	rdi
    jnz       L10607
    mov       rdi,	rsi
    mov       rbx,	r12
    jmp       L10614
L10611:
    movsxd    rax,	dword [rdi+49]
    mov       rcx,	rbx
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rdi,	[rdi+8]
    mov       rbx,	[rbx+8]
L10614:
    test      rbx,	rbx
    jnz       L10611
;---------------
    add       rsp,	48
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_assignmultscalar
mm_type.tx_assignmultscalar:
;?>>
   %define R.pp r13
   %define R.a r14
    %define mm_type.tx_assignmultscalar.b 80
    %define mm_type.tx_assignmultscalar.t 88
   %define R.p rdi
   %define R.alist rbx
   %define R.nretmodes rsi
   %define R.i r12
    %define mm_type.tx_assignmultscalar.alength -8
    %define mm_type.tx_assignmultscalar.pmult -16
    %define mm_type.tx_assignmultscalar.d -24
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       r13,	rcx
    mov       r14,	rdx
    mov       [rbp+80],	r8
    mov       [rbp+88],	r9
;---------------
    mov       rbx,	[r14+16]
    mov       eax,	[r14+40]
    mov       [rbp + mm_type.tx_assignmultscalar.alength],	rax
    xor       rsi,	rsi
    mov       al,	30
    mov       [r13],	al
    mov       rcx,	[rbp + mm_type.tx_assignmultscalar.b]
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rax,	[rbp + mm_type.tx_assignmultscalar.b]
    movsxd    rax,	dword [rax+49]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    cmp       r10,	28
    jz        L10617
    cmp       r10,	11
    jz        L10618
    cmp       r10,	9
    jz        L10619
    cmp       r10,	8
    jz        L10620
    jmp       L10621
L10617:
    mov       rcx,	[rbp + mm_type.tx_assignmultscalar.b]
    call      mm_lib.getprocretmodes
    mov       [rbp + mm_type.tx_assignmultscalar.d],	rax
    mov       rax,	[rbp + mm_type.tx_assignmultscalar.d]
    movzx     rax,	byte [rax+122]
    mov       rsi,	rax
    mov       rax,	[rbp + mm_type.tx_assignmultscalar.d]
    movsxd    rax,	dword [rax+72]
    lea       r10,	[mm_decls.ttbasetype]
    movsxd    r10,	dword [r10 + rax*4]
    cmp       r10,	28
    jz        L10623
    lea       rcx,	[L13653]
    xor       edx,	edx
    call      mm_support.txerror
L10623:
    mov       rax,	[rbp + mm_type.tx_assignmultscalar.alength]
    cmp       rax,	rsi
    jle       L10625
    lea       rcx,	[L13654]
    xor       edx,	edx
    call      mm_support.txerror
L10625:
    cmp       rsi,	1
    jg        L10627
    lea       rcx,	[L13655]
    xor       edx,	edx
    call      mm_support.txerror
L10627:
    mov       rdi,	rbx
    mov       rax,	[rbp + mm_type.tx_assignmultscalar.d]
    movsxd    rax,	dword [rax+72]
    lea       r10,	[mm_decls.ttmult]
    mov       r10,	[r10 + rax*8]
    mov       [rbp + mm_type.tx_assignmultscalar.pmult],	r10
    mov       r12,	1
    jmp       L10631
L10628:
    mov       rax,	r12
    inc       r12
    mov       r10,	[rbp + mm_type.tx_assignmultscalar.pmult]
    movsxd    r10,	dword [r10 + rax*4-4]
    mov       rcx,	rdi
    mov       rdx,	r10
    call      mm_type.tpasslv
    mov       rdi,	[rdi+8]
L10631:
    test      rdi,	rdi
    jnz       L10628
    jmp       L10616
L10618:
    mov       rax,	[rbp + mm_type.tx_assignmultscalar.alength]
    cmp       rax,	2
    jz        L10633
    lea       rcx,	[L13656]
    xor       edx,	edx
    call      mm_support.txerror
L10633:
    mov       rax,	[rbp + mm_type.tx_assignmultscalar.b]
    movsxd    rax,	dword [rax+49]
    lea       r10,	[mm_decls.tttarget]
    movsxd    r10,	dword [r10 + rax*4]
    xor       ecx,	ecx
    mov       rdx,	r10
    xor       r8d,	r8d
    call      mm_lib.createrefmode
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mm_type.tpasslv
    mov       rax,	[rbx+8]
    mov       rcx,	rax
    mov       rdx,	3
    call      mm_type.tpasslv
    jmp       L10616
L10619:
    jmp       L10616
L10620:
    jmp       L10616
L10621:
    mov       rax,	[rbp + mm_type.tx_assignmultscalar.b]
    movzx     rax,	byte [rax]
    cmp       rax,	35
    jnz       L10635
    mov       rax,	[rbp + mm_type.tx_assignmultscalar.b]
    movzx     rax,	byte [rax+62]
    cmp       rax,	49
    jnz       L10635
    mov       rax,	[rbp + mm_type.tx_assignmultscalar.alength]
    cmp       rax,	2
    jz        L10637
    lea       rcx,	[L13657]
    xor       edx,	edx
    call      mm_support.txerror
L10637:
    mov       rax,	[rbp + mm_type.tx_assignmultscalar.b]
    movsxd    rax,	dword [rax+49]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mm_type.tpasslv
    mov       rax,	[rbp + mm_type.tx_assignmultscalar.b]
    movsxd    rax,	dword [rax+49]
    mov       r10,	[rbx+8]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mm_type.tpasslv
    mov       al,	31
    mov       [r13],	al
    jmp       L10634
L10635:
    mov       rax,	[rbp + mm_type.tx_assignmultscalar.b]
    movsxd    rax,	dword [rax+49]
    mov       rcx,	rax
    mov       rdx,	1
    call      mm_lib.strmode
    lea       rcx,	[L13658]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mm_support.txerror_s
L10634:
L10616:
    mov       eax,	[rbp + mm_type.tx_assignmultscalar.t]
    mov       [r13+49],	eax
;---------------
    add       rsp,	64
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tpasslv
mm_type.tpasslv:
;?>>
   %define R.p rdi
   %define R.t rbx
    %define mm_type.tpasslv.$T1 -8
    push      rdi
    push      rbx
;?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
;---------------
    mov       rcx,	rdi
    mov       rdx,	23
    mov       r8,	1
    call      mm_type.tpass
    mov       rax,	rbx
    cmp       rax,	23
    jz        L10640
    test      rax,	rax
    jz        L10640
    movsxd    rax,	dword [rdi+49]
    mov       rcx,	rax
    mov       rdx,	rbx
    call      mm_type.comparemodes
    test      rax,	rax
    jnz       L10642
    mov       rcx,	rbx
    mov       rdx,	1
    call      mm_lib.strmode2
    mov       [rbp + mm_type.tpasslv.$T1],	rax
    movsxd    rax,	dword [rdi+49]
    mov       rcx,	rax
    mov       rdx,	1
    call      mm_lib.strmode
    lea       rcx,	[L13659]
    mov       rdx,	rax
    mov       r8,	[rbp + mm_type.tpasslv.$T1]
    call      mm_support.txerror_ss
L10642:
L10640:
;---------------
    add       rsp,	48
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.dobinnumx
mm_type.dobinnumx:
;?>>
   %define R.p r12
   %define R.a r13
   %define R.b r14
   %define R.amode rdi
   %define R.bmode rbx
   %define R.cmode rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       r12,	rcx
    mov       r13,	rdx
    mov       r14,	r8
;---------------
    movsxd    rax,	dword [r13+49]
    mov       rdi,	rax
    movsxd    rax,	dword [r14+49]
    mov       rbx,	rax
    cmp       rdi,	5
    jg        L10645
    cmp       rbx,	5
    jg        L10645
    mov       rax,	rdi
    mov       r10,	rbx
    cmp       rax,	r10
    cmovg     rax,	r10
    mov       rsi,	rax
    mov       [r12+49],	eax
    mov       rcx,	r13
    mov       rdx,	rsi
    xor       r8d,	r8d
    call      mm_type.coerceunit
    mov       rcx,	r14
    mov       rdx,	rsi
    xor       r8d,	r8d
    call      mm_type.coerceunit
    mov       rax,	1
    jmp       L10643
L10645:
    cmp       rdi,	5
    jg        L10647
    mov       rax,	rbx
    cmp       rax,	13
    jz        L10648
    cmp       rax,	6
    jnz       L10647
L10648:
    mov       [r12+49],	edi
    mov       rcx,	r14
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mm_type.coerceunit
    mov       rax,	1
    jmp       L10643
L10647:
    mov       rax,	rdi
    cmp       rax,	13
    jz        L10650
    cmp       rax,	6
    jnz       L10649
L10650:
    cmp       rbx,	5
    jg        L10649
    mov       [r12+49],	ebx
    mov       rcx,	r13
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      mm_type.coerceunit
    mov       rax,	1
    jmp       L10643
L10649:
L10646:
    xor       eax,	eax
L10643:
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.dobinnumf
mm_type.dobinnumf:
;?>>
   %define R.p r12
   %define R.a r13
   %define R.b r14
   %define R.amode rdi
   %define R.bmode rbx
   %define R.cmode rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       r12,	rcx
    mov       r13,	rdx
    mov       r14,	r8
;---------------
    movsxd    rax,	dword [r13+49]
    mov       rdi,	rax
    movsxd    rax,	dword [r14+49]
    mov       rbx,	rax
    cmp       rdi,	2
    jg        L10653
    cmp       rbx,	2
    jg        L10653
    mov       rax,	rdi
    mov       r10,	rbx
    cmp       rax,	r10
    cmovg     rax,	r10
    mov       rsi,	rax
    mov       [r12+49],	eax
    mov       rcx,	r13
    mov       rdx,	rsi
    xor       r8d,	r8d
    call      mm_type.coerceunit
    mov       rcx,	r14
    mov       rdx,	rsi
    xor       r8d,	r8d
    call      mm_type.coerceunit
    mov       rax,	1
    jmp       L10651
L10653:
    xor       eax,	eax
L10651:
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.dobinnumi
mm_type.dobinnumi:
;?>>
   %define R.p r12
   %define R.a r13
   %define R.b r14
   %define R.amode rdi
   %define R.bmode rbx
   %define R.cmode rsi
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
;?]]
    sub       rsp,	40
    mov       r12,	rcx
    mov       r13,	rdx
    mov       r14,	r8
;---------------
    movsxd    rax,	dword [r13+49]
    mov       rdi,	rax
    movsxd    rax,	dword [r14+49]
    mov       rbx,	rax
    mov       rax,	rdi
    cmp       rax,	3
    jz        L10657
    cmp       rax,	4
    jz        L10657
    cmp       rax,	5
    jnz       L10656
L10657:
    mov       rax,	rbx
    cmp       rax,	3
    jz        L10658
    cmp       rax,	4
    jz        L10658
    cmp       rax,	5
    jnz       L10656
L10658:
    mov       rax,	rdi
    mov       r10,	rbx
    cmp       rax,	r10
    cmovg     rax,	r10
    mov       rsi,	rax
    mov       [r12+49],	eax
    mov       rcx,	r13
    mov       rdx,	rsi
    xor       r8d,	r8d
    call      mm_type.coerceunit
    mov       rcx,	r14
    mov       rdx,	rsi
    xor       r8d,	r8d
    call      mm_type.coerceunit
    mov       rax,	1
    jmp       L10654
L10656:
    xor       eax,	eax
L10654:
;---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc mm_type.tx_in
mm_type.tx_in:
;?>>
   %define R.p r13
   %define R.a r14
   %define R.b r15
   %define R.simpleset rdi
   %define R.amode rbx
   %define R.bmode rsi
   %define R.q r12
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
;?]]
    sub       rsp,	48
    mov       r13,	rcx
    mov       r14,	rdx
    mov       r15,	r8
;---------------
    mov       rcx,	r14
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    mov       rcx,	r15
    mov       rdx,	23
    xor       r8d,	r8d
    call      mm_type.tpass
    movsxd    rax,	dword [r14+49]
    mov       rbx,	rax
    movsxd    rax,	dword [r15+49]
    mov       rsi,	rax
    mov       rcx,	r14
    mov       rdx,	3
    xor       r8d,	r8d
    call      mm_type.coerceunit
    mov       rdi,	1
    movzx     rax,	byte [r15]
    cmp       rax,	22
    jnz       L10661
    mov       r12,	[r15+16]
    jmp       L10665
L10662:
    movsxd    rax,	dword [r12+49]
    lea       r10,	[mm_decls.ttisinteger]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jnz       L10667
    xor       rdi,	rdi
    jmp       L10664
L10667:
    mov       r12,	[r12+8]
L10665:
    test      r12,	r12
    jnz       L10662
L10664:
L10661:
    movsxd    rax,	dword [r14+49]
    cmp       rax,	5
    jg        L10669
    movzx     rax,	byte [r15]
    cmp       rax,	21
    jz        L10670
    cmp       rax,	22
    jnz       L10669
L10670:
    test      rdi,	rdi
    jz        L10669
    movzx     rax,	byte [r15]
    cmp       rax,	21
    jnz       L10672
    mov       rax,	43
    jmp       L10671
L10672:
    mov       rax,	44
L10671:
    mov       [r13],	al
    jmp       L10668
L10669:
    lea       rcx,	[L13660]
    xor       edx,	edx
    call      mm_support.txerror
L10668:
    mov       eax,	6
    mov       [r13+49],	eax
    mov       al,	[r13+62]
    test      al,	al
    jz        L10674
    mov       rcx,	r13
    call      mm_type.addnotl
L10674:
    mov       rax,	1
L10659:
;---------------
    add       rsp,	48
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
;End 
;Proc msyswin.start
msyswin.start:
;?>>
;?]]
    sub       rsp,	40
;---------------
    call      msys.start
;---------------
    add       rsp,	40
    ret       
;End 
;Proc pcl.start
pcl.start:
;?>>
;?]]
    sub       rsp,	40
;---------------
    call      pc_api.start
    call      mc_genss.start
    call      mc_decls.start
    call      mc_writenasm.start
;---------------
    add       rsp,	40
    ret       
;End 
;Proc mm.start
mm.start:
;?>>
;?]]
    sub       rsp,	40
;---------------
    call      mm_genpcl.start
    call      mm_lex.start
    call      mm_tables.start
;---------------
    add       rsp,	40
    ret       
;End 
    segment .data
$procaddr:
    dq  mc_genmcl.px_nop
    dq  mc_genmcl.px_dupl
    dq  mc_genmcl.px_double
    dq  mc_genmcl.px_opnd
    dq  mc_genmcl.px_type
    dq  mc_genmcl.px_comment
    dq  mc_genmcl.px_proc
    dq  mc_genmcl.px_endproc
    dq  mc_genmcl.px_endprog
    dq  mc_genmcl.px_istatic
    dq  mc_genmcl.px_zstatic
    dq  mc_genmcl.px_data
    dq  mc_genmcl.px_label
    dq  mc_genmcl.px_load
    dq  mc_genmcl.px_store
    dq  mc_genmcl.px_add
    dq  mc_genmcl.px_sub
    dq  mc_genmcl.px_mul
    dq  mc_genmcl.px_div
    dq  mc_genmcl.px_eval
    dq  mc_genmcl.px_widen
    dq  mc_genmcl.px_jump
    dq  mc_genmcl.px_ijump
    dq  mc_genmcl.px_neg
    dq  mc_genmcl.px_abs
    dq  mc_genmcl.px_bitnot
    dq  mc_genmcl.px_not
    dq  mc_genmcl.px_toboolt
    dq  mc_genmcl.px_sqr
    dq  mc_genmcl.px_sqrt
    dq  mc_genmcl.px_jumpcc
    dq  mc_genmcl.px_jumpt
    dq  mc_genmcl.px_jumpf
    dq  mc_genmcl.px_bitand
    dq  mc_genmcl.px_bitor
    dq  mc_genmcl.px_bitxor
    dq  mc_genmcl.px_shl
    dq  mc_genmcl.px_shr
    dq  mc_genmcl.px_retproc
    dq  mc_genmcl.px_retfn
    dq  mc_genmcl.px_setcall
    dq  mc_genmcl.px_setarg
    dq  mc_genmcl.px_callp
    dq  mc_genmcl.px_jumpret
    dq  mc_genmcl.px_jumpretm
    dq  mc_genmcl.px_startmx
    dq  mc_genmcl.px_resetmx
    dq  mc_genmcl.px_stop
    dq  mc_genmcl.px_incrto
    dq  mc_genmcl.px_decrto
    dq  mc_genmcl.px_incrload
    dq  mc_genmcl.px_decrload
    dq  mc_genmcl.px_loadincr
    dq  mc_genmcl.px_loaddecr
    dq  mc_genmcl.px_forup
    dq  mc_genmcl.px_fordown
    dq  mc_genmcl.px_iload
    dq  mc_genmcl.px_iloadx
    dq  mc_genmcl.px_istore
    dq  mc_genmcl.px_istorex
    dq  mc_genmcl.px_storem
    dq  mc_genmcl.px_addpx
    dq  mc_genmcl.px_subpx
    dq  mc_genmcl.px_to
    dq  mc_genmcl.px_iswap
    dq  mc_genmcl.px_swapstk
    dq  mc_genmcl.px_labeldef
    dq  mc_genmcl.px_addto
    dq  mc_genmcl.px_subto
    dq  mc_genmcl.px_multo
    dq  mc_genmcl.px_bitandto
    dq  mc_genmcl.px_bitorto
    dq  mc_genmcl.px_bitxorto
    dq  mc_genmcl.px_shlto
    dq  mc_genmcl.px_shrto
    dq  mc_genmcl.px_fix
    dq  mc_genmcl.px_float
    dq  mc_genmcl.px_idiv
    dq  mc_genmcl.px_irem
    dq  mc_genmcl.px_idivrem
    dq  mc_genmcl.px_clear
    dq  mc_genmcl.px_subp
    dq  mc_genmcl.px_switch
    dq  mc_genmcl.px_switchu
    dq  mc_genmcl.px_swlabel
    dq  mc_genmcl.px_endsw
    dq  mc_genmcl.px_fwiden
    dq  mc_genmcl.px_fnarrow
    dq  mc_genmcl.px_truncate
    dq  mc_genmcl.px_typepun
    dq  mc_genmcl.px_unload
    dq  mc_genmcl.px_loadbit
    dq  mc_genmcl.px_assem
    dq  mc_genmcl.px_sin
    dq  mc_genmcl.px_cos
    dq  mc_genmcl.px_tan
    dq  mc_genmcl.px_asin
    dq  mc_genmcl.px_acos
    dq  mc_genmcl.px_atan
    dq  mc_genmcl.px_log
    dq  mc_genmcl.px_log10
    dq  mc_genmcl.px_exp
    dq  mc_genmcl.px_round
    dq  mc_genmcl.px_floor
    dq  mc_genmcl.px_ceil
    dq  mc_genmcl.px_atan2
    dq  mc_genmcl.px_fmod
    dq  mc_genmcl.px_setcc
    dq  mc_genmcl.px_min
    dq  mc_genmcl.px_max
    dq  mc_genmcl.px_power
    dq  mc_genmcl.px_minto
    dq  mc_genmcl.px_maxto
    dq  mc_genmcl.px_negto
    dq  mc_genmcl.px_absto
    dq  mc_genmcl.px_addpxto
    dq  mc_genmcl.px_subpxto
    dq  mc_genmcl.px_divto
    dq  mc_genmcl.px_bitnotto
    dq  mc_genmcl.px_notto
    dq  mc_genmcl.px_toboolto
    dq  mc_genmcl.px_sign
    dq  mc_genmcl.px_loadbf
    dq  mc_genmcl.px_storebit
    dq  mc_genmcl.px_storebf
    dq  mc_genmcl.px_loadall
    dq  mc_genmcl.px_setjmp
    dq  mc_genmcl.px_longjmp
    dq  mc_genmcl.px_initdswx
    dq  mc_auxmcl.do_addrmode
$procname:
    dq  L13661
    dq  L13662
    dq  L13663
    dq  L13664
    dq  L13665
    dq  L13666
    dq  L13667
    dq  L13668
    dq  L13669
    dq  L13670
    dq  L13671
    dq  L13672
    dq  L13673
    dq  L13674
    dq  L13675
    dq  L13676
    dq  L13677
    dq  L13678
    dq  L13679
    dq  L13680
    dq  L13681
    dq  L13682
    dq  L13683
    dq  L13684
    dq  L13685
    dq  L13686
    dq  L13687
    dq  L13688
    dq  L13689
    dq  L13690
    dq  L13691
    dq  L13692
    dq  L13693
    dq  L13694
    dq  L13695
    dq  L13696
    dq  L13697
    dq  L13698
    dq  L13699
    dq  L13700
    dq  L13701
    dq  L13702
    dq  L13703
    dq  L13704
    dq  L13705
    dq  L13706
    dq  L13707
    dq  L13708
    dq  L13709
    dq  L13710
    dq  L13711
    dq  L13712
    dq  L13713
    dq  L13714
    dq  L13715
    dq  L13716
    dq  L13717
    dq  L13718
    dq  L13719
    dq  L13720
    dq  L13721
    dq  L13722
    dq  L13723
    dq  L13724
    dq  L13725
    dq  L13726
    dq  L13727
    dq  L13728
    dq  L13729
    dq  L13730
    dq  L13731
    dq  L13732
    dq  L13733
    dq  L13734
    dq  L13735
    dq  L13736
    dq  L13737
    dq  L13738
    dq  L13739
    dq  L13740
    dq  L13741
    dq  L13742
    dq  L13743
    dq  L13744
    dq  L13745
    dq  L13746
    dq  L13747
    dq  L13748
    dq  L13749
    dq  L13750
    dq  L13751
    dq  L13752
    dq  L13753
    dq  L13754
    dq  L13755
    dq  L13756
    dq  L13757
    dq  L13758
    dq  L13759
    dq  L13760
    dq  L13761
    dq  L13762
    dq  L13763
    dq  L13764
    dq  L13765
    dq  L13766
    dq  L13767
    dq  L13768
    dq  L13769
    dq  L13770
    dq  L13771
    dq  L13772
    dq  L13773
    dq  L13774
    dq  L13775
    dq  L13776
    dq  L13777
    dq  L13778
    dq  L13779
    dq  L13780
    dq  L13781
    dq  L13782
    dq  L13783
    dq  L13784
    dq  L13785
    dq  L13786
    dq  L13787
    dq  L13788
    dq  L13789
    dq  L13790
$nprocs:
    dq  0x82
;Real Table
    align     8
L13373:
    dq  0x7FF0000000000000
L13372:
    dq  3.14159265358979310000
L13167:
    dq  10.00000000000000000000
L13166:
    dq  10.00000000000000000000
L13163:
    dq  10.00000000000000000000
L13162:
    dq  0.00000000000000000000
L13116:
    dq  100.00000000000000000000
L12392:
    dq  0x7FF0000000000000
L12390:
    dq  0x7FF0000000000000
L12373:
    dq  0.00000000000000000000
L12191:
    dq  0x7FF0000000000000
L12118:
    dq  9223372036854775800.00000000000000000000
L12117:
    dq  1.00000000000000000000
L12116:
    dq  9223372036854775800.00000000000000000000
L12094:
    dq  0.00000000000000000000
L12093:
    dq  1.00000000000000000000
L12092:
    dq  0.00000000000000000000
L12091:
    dq  -1.00000000000000000000
L12090:
    dq  0.00000000000000000000
L12087:
    dq  0.00000000000000000000
L12085:
    dq  0.00000000000000000000
;Real32 Table
    align     16
;lababs64
L12286:
    dq  0x7FFFFFFFFFFFFFFF
    dq  0x7FFFFFFFFFFFFFFF
;labneg64
L12285:
    dq  0x8000000000000000
    dq  0x8000000000000000
;mask63/offset64
L12294:
    dq  0x7FFFFFFFFFFFFFFF
L12295:
    dq  0x43E0000000000000
;String Table
    align     8
L13790:
    db        "do_addrmode"
    db        0
L13789:
    db        "px_initdswx"
    db        0
L13788:
    db        "px_longjmp"
    db        0
L13787:
    db        "px_setjmp"
    db        0
L13786:
    db        "px_loadall"
    db        0
L13785:
    db        "px_storebf"
    db        0
L13784:
    db        "px_storebit"
    db        0
L13783:
    db        "px_loadbf"
    db        0
L13782:
    db        "px_sign"
    db        0
L13781:
    db        "px_toboolto"
    db        0
L13780:
    db        "px_notto"
    db        0
L13779:
    db        "px_bitnotto"
    db        0
L13778:
    db        "px_divto"
    db        0
L13777:
    db        "px_subpxto"
    db        0
L13776:
    db        "px_addpxto"
    db        0
L13775:
    db        "px_absto"
    db        0
L13774:
    db        "px_negto"
    db        0
L13773:
    db        "px_maxto"
    db        0
L13772:
    db        "px_minto"
    db        0
L13771:
    db        "px_power"
    db        0
L13770:
    db        "px_max"
    db        0
L13769:
    db        "px_min"
    db        0
L13768:
    db        "px_setcc"
    db        0
L13767:
    db        "px_fmod"
    db        0
L13766:
    db        "px_atan2"
    db        0
L13765:
    db        "px_ceil"
    db        0
L13764:
    db        "px_floor"
    db        0
L13763:
    db        "px_round"
    db        0
L13762:
    db        "px_exp"
    db        0
L13761:
    db        "px_log10"
    db        0
L13760:
    db        "px_log"
    db        0
L13759:
    db        "px_atan"
    db        0
L13758:
    db        "px_acos"
    db        0
L13757:
    db        "px_asin"
    db        0
L13756:
    db        "px_tan"
    db        0
L13755:
    db        "px_cos"
    db        0
L13754:
    db        "px_sin"
    db        0
L13753:
    db        "px_assem"
    db        0
L13752:
    db        "px_loadbit"
    db        0
L13751:
    db        "px_unload"
    db        0
L13750:
    db        "px_typepun"
    db        0
L13749:
    db        "px_truncate"
    db        0
L13748:
    db        "px_fnarrow"
    db        0
L13747:
    db        "px_fwiden"
    db        0
L13746:
    db        "px_endsw"
    db        0
L13745:
    db        "px_swlabel"
    db        0
L13744:
    db        "px_switchu"
    db        0
L13743:
    db        "px_switch"
    db        0
L13742:
    db        "px_subp"
    db        0
L13741:
    db        "px_clear"
    db        0
L13740:
    db        "px_idivrem"
    db        0
L13739:
    db        "px_irem"
    db        0
L13738:
    db        "px_idiv"
    db        0
L13737:
    db        "px_float"
    db        0
L13736:
    db        "px_fix"
    db        0
L13735:
    db        "px_shrto"
    db        0
L13734:
    db        "px_shlto"
    db        0
L13733:
    db        "px_bitxorto"
    db        0
L13732:
    db        "px_bitorto"
    db        0
L13731:
    db        "px_bitandto"
    db        0
L13730:
    db        "px_multo"
    db        0
L13729:
    db        "px_subto"
    db        0
L13728:
    db        "px_addto"
    db        0
L13727:
    db        "px_labeldef"
    db        0
L13726:
    db        "px_swapstk"
    db        0
L13725:
    db        "px_iswap"
    db        0
L13724:
    db        "px_to"
    db        0
L13723:
    db        "px_subpx"
    db        0
L13722:
    db        "px_addpx"
    db        0
L13721:
    db        "px_storem"
    db        0
L13720:
    db        "px_istorex"
    db        0
L13719:
    db        "px_istore"
    db        0
L13718:
    db        "px_iloadx"
    db        0
L13717:
    db        "px_iload"
    db        0
L13716:
    db        "px_fordown"
    db        0
L13715:
    db        "px_forup"
    db        0
L13714:
    db        "px_loaddecr"
    db        0
L13713:
    db        "px_loadincr"
    db        0
L13712:
    db        "px_decrload"
    db        0
L13711:
    db        "px_incrload"
    db        0
L13710:
    db        "px_decrto"
    db        0
L13709:
    db        "px_incrto"
    db        0
L13708:
    db        "px_stop"
    db        0
L13707:
    db        "px_resetmx"
    db        0
L13706:
    db        "px_startmx"
    db        0
L13705:
    db        "px_jumpretm"
    db        0
L13704:
    db        "px_jumpret"
    db        0
L13703:
    db        "px_callp"
    db        0
L13702:
    db        "px_setarg"
    db        0
L13701:
    db        "px_setcall"
    db        0
L13700:
    db        "px_retfn"
    db        0
L13699:
    db        "px_retproc"
    db        0
L13698:
    db        "px_shr"
    db        0
L13697:
    db        "px_shl"
    db        0
L13696:
    db        "px_bitxor"
    db        0
L13695:
    db        "px_bitor"
    db        0
L13694:
    db        "px_bitand"
    db        0
L13693:
    db        "px_jumpf"
    db        0
L13692:
    db        "px_jumpt"
    db        0
L13691:
    db        "px_jumpcc"
    db        0
L13690:
    db        "px_sqrt"
    db        0
L13689:
    db        "px_sqr"
    db        0
L13688:
    db        "px_toboolt"
    db        0
L13687:
    db        "px_not"
    db        0
L13686:
    db        "px_bitnot"
    db        0
L13685:
    db        "px_abs"
    db        0
L13684:
    db        "px_neg"
    db        0
L13683:
    db        "px_ijump"
    db        0
L13682:
    db        "px_jump"
    db        0
L13681:
    db        "px_widen"
    db        0
L13680:
    db        "px_eval"
    db        0
L13679:
    db        "px_div"
    db        0
L13678:
    db        "px_mul"
    db        0
L13677:
    db        "px_sub"
    db        0
L13676:
    db        "px_add"
    db        0
L13675:
    db        "px_store"
    db        0
L13674:
    db        "px_load"
    db        0
L13673:
    db        "px_label"
    db        0
L13672:
    db        "px_data"
    db        0
L13671:
    db        "px_zstatic"
    db        0
L13670:
    db        "px_istatic"
    db        0
L13669:
    db        "px_endprog"
    db        0
L13668:
    db        "px_endproc"
    db        0
L13667:
    db        "px_proc"
    db        0
L13666:
    db        "px_comment"
    db        0
L13665:
    db        "px_type"
    db        0
L13664:
    db        "px_opnd"
    db        0
L13663:
    db        "px_double"
    db        0
L13662:
    db        "px_dupl"
    db        0
L13661:
    db        "px_nop"
    db        0
L13660:
    db        "doin"
    db        0
L13659:
    db        "PassLV type mismatch: #:=#"
    db        0
L13658:
    db        "Can't expand to mult values:"
    db        0
L13657:
    db        "(a,b):=divrem"
    db        0
L13656:
    db        "(a,b):=slice"
    db        0
L13655:
    db        "mult ass rhs needs fn yielding 2+ values"
    db        0
L13654:
    db        "mult ass/mult returns don't agree in number"
    db        0
L13653:
    db        "Not a tuple"
    db        0
L13652:
    db        "Invalid assignment"
    db        0
L13651:
    db        "Mult assign: count mismatch"
    db        0
L13650:
    db        "Mult assign has no result"
    db        0
L13649:
    db        "Type-compare error: # <-> #"
    db        0
L13648:
    db        "Need explicit cast: # => #"
    db        0
L13647:
    db        "Can't do conversion: # => #"
    db        0
L13646:
    db        "COERCE/SLICEPTR"
    db        0
L13645:
    db        "Array not empty"
    db        0
L13644:
    db        "Void expression/return value missing"
    db        0
L13643:
    db        0
L13642:
    db        "strincl/not string"
    db        0
L13641:
    db        "mulstr"
    db        0
L13640:
    db        "Mixed str+bin strings"
    db        0
L13638:
    db        "x rem 0"
    db        0
L13637:
    db        "x/0"
    db        0
L13636:
    db        "Not slice"
    db        0
L13635:
    db        "lwb/upb/len?"
    db        0
L13634:
    db        "Can't resolve method:"
    db        0
L13633:
    db        "BITFIELD"
    db        0
L13632:
    db        "Can't assign"
    db        0
L13631:
    db        "Int/ref needed"
    db        0
L13630:
    db        "Not char slice"
    db        0
L13629:
    db        "widen? #"
    db        0
L13628:
    db        "*"
    db        0
L13627:
    db        "a[i..j]: not array"
    db        0
L13626:
    db        "STRMODE(A.MODE)="
    db        0
L13625:
    db        "a.[i]: not int/str value"
    db        0
L13624:
    db        "SHORT RET TYPE"
    db        0
L13623:
    db        "RETERROR?"
    db        0
L13622:
    db        "Wrong number of return values"
    db        0
L13621:
    db        "return constructor not supported"
    db        0
L13620:
    db        "Superfluous return value"
    db        0
L13619:
    db        "return value(s) missing"
    db        0
L13618:
    db        "&. ref[] expected"
    db        0
L13617:
    db        "switch needs else"
    db        0
L13616:
    db        "Switch value: not const int"
    db        0
L13615:
    db        "Duplicate switch value"
    db        0
L13614:
    db        "switch: value out of range"
    db        0
L13613:
    db        "Switch not constant"
    db        0
L13612:
    db        "*"
    db        0
L13611:
    db        "not ref"
    db        0
L13610:
    db        "&doswitch"
    db        0
L13609:
    db        "goto: not label"
    db        0
L13608:
    db        "exit/etc not const"
    db        0
L13607:
    db        "Invalid type-punning; only real<->int"
    db        0
L13606:
    db        "TYPEPUN/LIST"
    db        0
L13605:
    db        "case needs else"
    db        0
L13604:
    db        "CASE/BOOL?"
    db        0
L13603:
    db        "case: need int index"
    db        0
L13602:
    db        "&docase"
    db        0
L13601:
    db        "SWAP: type mismatch"
    db        0
L13600:
    db        "SLICEPTR #"
    db        0
L13599:
    db        "Not a field: #"
    db        0
L13598:
    db        "4:record expected"
    db        0
L13597:
    db        "3:record expected"
    db        0
L13596:
    db        "Bad record type"
    db        0
L13595:
    db        "MKSLICE2"
    db        0
L13594:
    db        "slice/ptr mismatch"
    db        0
L13593:
    db        "slice init not ref"
    db        0
L13592:
    db        "MAKESLICE/TX"
    db        0
L13591:
    db        "MAKESLICE FROM LIST NOT READY"
    db        0
L13590:
    db        "MAKESLICE/TX"
    db        0
L13588:
    db        "Unknown makelist type: #"
    db        0
L13587:
    db        "TSLICE"
    db        0
L13586:
    db        "Can't initialise unions"
    db        0
L13585:
    db        "Too many elements"
    db        0
L13584:
    db        "Too few elements"
    db        0
L13583:
    db        "Bit fields overflow type"
    db        0
L13582:
    db        "srs:too many fields"
    db        0
L13581:
    db        "Recursive record?"
    db        0
L13580:
    db        "PTR: need ref T"
    db        0
L13579:
    db        "DEREF SLICE"
    db        0
L13578:
    db        "Deref Void"
    db        0
L13577:
    db        "Can't index: #"
    db        0
L13576:
    db        "forall/can't iterate"
    db        0
L13575:
    db        "Loop index not a variable"
    db        0
L13574:
    db        "IF/LV2?"
    db        0
L13573:
    db        "else needed"
    db        0
L13572:
    db        "IF/LV?"
    db        0
L13571:
    db        "Not int"
    db        0
L13570:
    db        "PROP"
    db        0
L13569:
    db        "Can't do maxvalue on #"
    db        0
L13568:
    db        "Can't do minvalue on #"
    db        0
L13567:
    db        "TTT"
    db        0
L13566:
    db        "toboolt"
    db        0
L13565:
    db        "not num"
    db        0
L13564:
    db        "&param: type mismatch"
    db        0
L13563:
    db        "Param not optional: #"
    db        0
L13562:
    db        "Too many params supplied"
    db        0
L13561:
    db        "NPARAMS="
    db        0
L13560:
    db        "K="
    db        0
L13559:
    db        "Normal param follows kwd"
    db        0
L13558:
    db        "Kwd: # already used or was implicit"
    db        0
L13557:
    db        "Can't find kwd param: #"
    db        0
L13556:
    db        "Param overflow"
    db        0
L13555:
    db        "Function expected"
    db        0
L13554:
    db        "Function pointer expected"
    db        0
L13553:
    db        "Can't do ifx/function"
    db        0
L13552:
    db        "Param overflow"
    db        0
L13551:
    db        "Getdom: no dominant mode"
    db        0
L13550:
    db        "BIN: modes not compatible: # #"
    db        0
L13549:
    db        "to:ref+ref"
    db        0
L13548:
    db        "BIN/CAN'T RESOLVE MODES"
    db        0
L13547:
    db        "txbin?"
    db        0
L13546:
    db        "Cmp ref/ref not compat"
    db        0
L13545:
    db        "ref-ref: not compat"
    db        0
L13544:
    db        "TNAME? # #"
    db        0
L13543:
    db        "Can't init dllvar"
    db        0
L13542:
    db        "Module name can't be used on it's own: #"
    db        0
L13541:
    db        "Can't use 'let' as lvalue: "
    db        0
L13540:
    db        "&const"
    db        0
L13539:
    db        "Getconstint: not i32/64"
    db        0
L13538:
    db        "Getconstexpr: not const"
    db        0
L13537:
    db        "*"
    db        0
L13536:
    db        "JTAGNAMES[P.TAG]="
    db        0
L13535:
    db        "Bad const type"
    db        0
L13534:
    db        "Circular const reference detected"
    db        0
L13533:
    db        "@name needed"
    db        0
L13532:
    db        "Circular reference detected"
    db        0
L13531:
    db        "Neg length"
    db        0
L13530:
    db        "Can't set mode size"
    db        0
L13529:
    db        "STDNAMES[TTBASETYPE[M]]="
    db        0
L13528:
    db        "M="
    db        0
L13527:
    db        "SIZE 0:"
    db        0
L13526:
    db        "SETMODESIZE/AUTO?"
    db        0
L13525:
    db        "TXUNIT: CAN'T DO:"
    db        0
L13524:
    db        "Clear scalar?"
    db        0
L13523:
    db        "sys: too many args"
    db        0
L13522:
    db        "sys: arg missing"
    db        0
L13521:
    db        "recase must be const"
    db        0
L13520:
    db        "repeat/const cond"
    db        0
L13519:
    db        "cast() needs type"
    db        0
L13518:
    db        "TX looping detected"
    db        0
L13517:
    db        "q"
    db        0
L13516:
    db        "10jlq"
    db        0
L13515:
    db        "Import "
    db        0
L13514:
    db        "Export"
    db        0
L13513:
    db        "Program"
    db        0
L13512:
    db        "Subprog"
    db        0
L13511:
    db        "Module"
    db        0
L13510:
    db        "5"
    db        0
L13509:
    db        "10jl"
    db        0
L13508:
    db        "dllprocid"
    db        0
L13507:
    db        "dllfuncid"
    db        0
L13506:
    db        "procid"
    db        0
L13505:
    db        "funcid"
    db        0
L13504:
    db        "18jl"
    db        0
L13503:
    db        "12jl"
    db        0
L13502:
    db        "10jl"
    db        0
L13501:
    db        "q"
    db        0
L13500:
    db        "16jl"
    db        0
L13499:
    db        "Writing"
    db        0
L13498:
    db        "wb"
    db        0
L13497:
    db        "proj"
    db        0
L13496:
    db        "Writing"
    db        0
L13495:
    db        "wb"
    db        0
L13494:
    db        "list"
    db        0
L13493:
    db        "=== END ==="
    db        0
L13492:
    db        "=== # # # #/# ==="
    db        0
L13491:
    db        "=== MA # ==="
    db        0
L13490:
    db        "Writing "
    db        0
L13489:
    db        0
L13488:
    db        "Can't create MA file "
    db        0
L13487:
    db        "wb"
    db        0
L13486:
    db        0
L13485:
    db        "MA: no files"
    db        0
L13484:
    db        "ma"
    db        0
L13483:
    db        "No file no"
    db        0
L13482:
    db        "Found:"
    db        0
L13481:
    db        0
L13480:
    db        "Can't find file: "
    db        0
L13479:
    db        "Checkfile:"
    db        0
L13478:
    db        "Get file:# (ext:#) (path:#)"
    db        0
L13477:
    db        " "
    db        0
L13476:
    db        "Stopping"
    db        0
L13475:
    db        "Load Error:"
    db        0
L13474:
    db        "****"
    db        0
L13473:
    db        "**** Lex Error:"
    db        0
L13472:
    db        "in file"
    db        0
L13471:
    db        "On line"
    db        0
L13470:
    db        "AX Code Gen Error: "
    db        0
L13469:
    db        "GX Code Gen Error: "
    db        0
L13468:
    db        "TX Type Error: "
    db        0
L13467:
    db        "RX Name Error: "
    db        0
L13466:
    db        "GETFILENO(POS)="
    db        0
L13465:
    db        "MMPOS"
    db        0
L13464:
    db        "P.POS"
    db        0
L13463:
    db        "PRESS key"
    db        0
L13462:
    db        "w"
    db        0
L13461:
    db        "$error.tmp"
    db        0
L13460:
    db        "^"
    db        0
L13459:
    db        " "
    db        0
L13458:
    db        "    Module:   # (#)"
    db        0
L13457:
    db        "    Function: #()"
    db        0
L13456:
    db        "    Line:     #"
    db        0
L13455:
    db        "Syntax Error:"
    db        0
L13454:
    db        "MC Error:"
    db        0
L13453:
    db        0
L13452:
    db        "Too many sources"
    db        0
L13451:
    db        "Empty sunit"
    db        0
L13450:
    db        "Readsunit: "
    db        34
    db        ";"
    db        34
    db        " expected, or bad unit starter"
    db        0
L13449:
    db        "Possibly var/let needed"
    db        0
L13448:
    db        "Unexpected EOF in proc"
    db        0
L13447:
    db        "macro def params"
    db        0
L13446:
    db        "readterm?"
    db        0
L13445:
    db        "LX.SYMBOL="
    db        0
L13444:
    db        "{...} not ready"
    db        0
L13443:
    db        "[$] No array"
    db        0
L13442:
    db        "Params not allowed"
    db        0
L13441:
    db        "Char const too long"
    db        0
L13440:
    db        "X{...} not ready"
    db        0
L13439:
    db        "cmpchain: Too many items"
    db        0
L13438:
    db        "AND:="
    db        0
L13437:
    db        "OR:="
    db        0
L13436:
    db        "dict: mixed elements"
    db        0
L13435:
    db        "readset?"
    db        0
L13434:
    db        "Too many return values"
    db        0
L13433:
    db        "Too many nested proc"
    db        0
L13432:
    db        "proc can't have ret value"
    db        0
L13431:
    db        "Proc can't return value"
    db        0
L13430:
    db        "Function needs return type"
    db        0
L13429:
    db        "Can't find @ field"
    db        0
L13428:
    db        "Not allowed in importmodule"
    db        0
L13427:
    db        "symbol"
    db        0
L13426:
    db        "Too many dll procs"
    db        0
L13425:
    db        "nested importdll"
    db        0
L13424:
    db        "LB?"
    db        0
L13423:
    db        "Let not allowed"
    db        0
L13422:
    db        "Empty union group"
    db        0
L13421:
    db        "Class eof?"
    db        0
L13420:
    db        "No table data"
    db        0
L13419:
    db        "enum=x, 1st row only"
    db        0
L13418:
    db        "tabledata:too many rows"
    db        0
L13417:
    db        "tabledata/too many columns"
    db        0
L13416:
    db        "Use 'enumdata'"
    db        0
L13415:
    db        "No fields declared"
    db        0
L13414:
    db        "Offset>255"
    db        0
L13413:
    db        "Name expected"
    db        0
L13412:
    db        "for i,x?"
    db        0
L13411:
    db        "Re-using nested loop index"
    db        0
L13410:
    db        "Too many for-loops"
    db        0
L13409:
    db        "No read items"
    db        0
L13408:
    db        "@ on read"
    db        0
L13407:
    db        "No fmt str"
    db        0
L13406:
    db        "No print items"
    db        0
L13405:
    db        "="
    db        0
L13404:
    db        "all"
    db        0
L13403:
    db        "switch expr missing"
    db        0
L13402:
    db        "then: not allowed"
    db        0
L13401:
    db        "nameparams1"
    db        0
L13400:
    db        "Type expected"
    db        0
L13399:
    db        "Wrong 'main/start' sig"
    db        0
L13398:
    db        "More than one main() in SP"
    db        0
L13397:
    db        "main"
    db        0
L13396:
    db        "start"
    db        0
L13395:
    db        "READPROCDEF @"
    db        0
L13394:
    db        "Proc can't return value"
    db        0
L13393:
    db        "Function needs ret type"
    db        0
L13392:
    db        0
L13391:
    db        "Can't do complex expr"
    db        0
L13390:
    db        "Unknown dot suffix"
    db        0
L13389:
    db        "RDS:TYPEOF"
    db        0
L13388:
    db        "Too many nested a[$]"
    db        0
L13387:
    db        "SLIST?"
    db        0
L13386:
    db        "null comma expr not allowed"
    db        0
L13385:
    db        "Bad type starter"
    db        0
L13384:
    db        "Top-level union not allowed"
    db        0
L13383:
    db        "Use 'record name =' syntax"
    db        0
L13382:
    db        "Too many array dims"
    db        0
L13381:
    db        "# expected, not #"
    db        0
L13380:
    db        "@ type missing"
    db        0
L13379:
    db        "compiler var not impl: #"
    db        0
L13378:
    db        "Compiler:M6.4"
    db        0
L13377:
    db        "z2"
    db        0
L13376:
    db        "#:#:#"
    db        0
L13375:
    db        "4"
    db        0
L13374:
    db        "#-#-#"
    db        0
L13371:
    db        "Too many opnds"
    db        0
L13370:
    db        "op:= not available"
    db        0
L13369:
    db        "Can't be used as unary op"
    db        0
L13368:
    db        "READOPC/SINGLE OPND?"
    db        0
L13367:
    db        "Needs (x,y)"
    db        0
L13366:
    db        "(x ..."
    db        0
L13365:
    db        ",, null expr not allowed"
    db        0
L13364:
    db        "No consts declared"
    db        0
L13363:
    db        "No vars declared"
    db        0
L13362:
    db        "let needs :=/="
    db        0
L13361:
    db        "let@"
    db        0
L13360:
    db        "Need 'static' for '='"
    db        0
L13359:
    db        "Can't use := for statics inside procs"
    db        0
L13358:
    db        "Non-variants can't use :="
    db        0
L13357:
    db        "Readvar?"
    db        0
L13356:
    db        " (from line #)"
    db        0
L13355:
    db        "Mismatched end "
    db        0
L13354:
    db        "'End' expected"
    db        0
L13353:
    db        34
    db        "="
    db        34
    db        " expected"
    db        0
L13352:
    db        0
L13351:
    db        "Code outside a function"
    db        0
L13350:
    db        "MODULE/DOT"
    db        0
L13349:
    db        "global global?"
    db        0
L13348:
    db        "DUPLFIELD"
    db        0
L13347:
    db        "Too many macro args"
    db        0
L13346:
    db        "Too few macro args"
    db        0
L13345:
    db        "NMACROARGS="
    db        0
L13344:
    db        "macro arg overflow"
    db        0
L13343:
    db        "macro param overflow"
    db        0
L13342:
    db        "Too many macro levels (recursive macro?)"
    db        0
L13339:
    db        "Fixtypes: too many passes (cyclic ref?)"
    db        0
L13338:
    db        9
    db        0
L13337:
    db        "Type phase errors - check these user types:"
    db        0
L13336:
    db        "2:Can't resolve tentative type: #"
    db        0
L13335:
    db        "Not a field: #"
    db        0
L13334:
    db        "Can't resolve sub.#"
    db        0
L13333:
    db        "Need export to import '#'"
    db        0
L13332:
    db        "Not a field: #"
    db        0
L13331:
    db        "Record expected"
    db        0
L13330:
    db        "2:Record expected"
    db        0
L13329:
    db        "Can't resolve .#"
    db        0
L13328:
    db        "Need global to import '#'"
    db        0
L13327:
    db        "Need export to import '#'"
    db        0
L13326:
    db        "pcl:Undefined: #"
    db        0
L13325:
    db        "Ambiguous ext name: #"
    db        0
L13324:
    db        "mclib"
    db        0
L13323:
    db        0
L13322:
    db        "MA error"
    db        0
L13321:
    db        0
L13320:
    db        "Too many files in MA"
    db        0
L13319:
    db        "end"
    db        0
L13318:
    db        0
L13317:
    db        "Unexpected EOF in MA file"
    db        0
L13316:
    db        0
L13315:
    db        "MA: bad header"
    db        0
L13314:
    db        "ma"
    db        0
L13313:
    db        0
L13312:
    db        "Can't find MA file "
    db        0
L13311:
    db        "kernel32"
    db        0
L13310:
    db        "gdi32"
    db        0
L13309:
    db        "user32"
    db        0
L13308:
    db        "msvcrt"
    db        0
L13307:
    db        "m"
    db        0
L13306:
    db        "LOADING FROM MA FILE"
    db        0
L13305:
    db        "ma"
    db        0
L13304:
    db        ".m"
    db        0
L13303:
    db        "SYSLIBNAME="
    db        0
L13302:
    db        "msyslinc"
    db        0
L13301:
    db        "msyswin"
    db        0
L13300:
    db        "msyswini"
    db        0
L13299:
    db        "msyswinc"
    db        0
L13298:
    db        "msysmin"
    db        0
L13297:
    db        "msysminc"
    db        0
L13296:
    db        "C:/mx/"
    db        0
L13295:
    db        0
L13294:
    db        "Too many libs"
    db        0
L13293:
    db        "m"
    db        0
L13292:
    db        "."
    db        0
L13291:
    db        "Dupl mod name:"
    db        0
L13290:
    db        0
L13289:
    db        "Can't load: "
    db        0
L13288:
    db        0
L13287:
    db        "Too many modules"
    db        0
L13286:
    db        0
L13285:
    db        "Too many subprogs"
    db        0
L13284:
    db        0
L13283:
    db        "Importing self"
    db        0
L13282:
    db        0
L13281:
    db        "Hdr cmd not ready"
    db        0
L13280:
    db        0
L13279:
    db        "Too many imports in header"
    db        0
L13278:
    db        "as"
    db        0
L13277:
    db        0
L13276:
    db        "Too many modules in header"
    db        0
L13275:
    db        0
L13274:
    db        "Subprog already loaded: "
    db        0
L13273:
    db        0
L13272:
    db        "Can't load lead module: "
    db        0
L13271:
    db        "m"
    db        0
L13270:
    db        0
L13269:
    db        "multass/need multfn"
    db        0
L13268:
    db        "ATL ERROR"
    db        0
L13267:
    db        "rb"
    db        0
L13266:
    db        "w"
    db        0
L13265:
    db        "PMODE=NIL"
    db        0
L13264:
    db        "GETALIGN SIZE NOT 1248"
    db        0
L13263:
    db        "GAL0"
    db        0
L13262:
    db        "."
    db        0
L13260:
    db        "NEWSTRMODE"
    db        0
L13259:
    db        "Alias for:"
    db        0
L13258:
    db        "bitfield"
    db        0
L13257:
    db        ")"
    db        0
L13256:
    db        ","
    db        0
L13255:
    db        "Tuple("
    db        0
L13254:
    db        ")"
    db        0
L13253:
    db        " "
    db        0
L13252:
    db        ","
    db        0
L13251:
    db        "proc("
    db        0
L13250:
    db        "void"
    db        0
L13249:
    db        ")"
    db        0
L13248:
    db        " "
    db        0
L13247:
    db        ","
    db        0
L13246:
    db        "("
    db        0
L13245:
    db        0
L13244:
    db        "#[#:]"
    db        0
L13243:
    db        "[]"
    db        0
L13242:
    db        "@#[#:]"
    db        0
L13241:
    db        "[#:]"
    db        0
L13240:
    db        "[]"
    db        0
L13239:
    db        "[#..#]"
    db        0
L13238:
    db        "[#]"
    db        0
L13237:
    db        "@[#<#>"
    db        0
L13236:
    db        "ref "
    db        0
L13235:
    db        "."
    db        0
L13234:
    db        "*"
    db        0
L13233:
    db        "CAN'T DO JEVAL"
    db        0
L13232:
    db        "strinclude "
    db        0
L13231:
    db        "incr "
    db        0
L13230:
    db        ")"
    db        0
L13229:
    db        "("
    db        0
L13228:
    db        ":"
    db        0
L13227:
    db        "."
    db        0
L13226:
    db        "$"
    db        0
L13225:
    db        ")"
    db        0
L13224:
    db        "TYPESTR("
    db        0
L13223:
    db        "&."
    db        0
L13222:
    db        "+"
    db        0
L13221:
    db        "&"
    db        0
L13220:
    db        "<nullunit>"
    db        0
L13219:
    db        "<JBLOCK>"
    db        0
L13218:
    db        "^"
    db        0
L13217:
    db        "-"
    db        0
L13216:
    db        ":"
    db        0
L13215:
    db        ")"
    db        0
L13214:
    db        "cast("
    db        0
L13213:
    db        ")"
    db        0
L13212:
    db        "shorten("
    db        0
L13211:
    db        ")"
    db        0
L13210:
    db        "("
    db        0
L13209:
    db        "@"
    db        0
L13208:
    db        ")"
    db        0
L13207:
    db        "|"
    db        0
L13206:
    db        "("
    db        0
L13205:
    db        ":="
    db        0
L13204:
    db        ")"
    db        0
L13203:
    db        ".."
    db        0
L13202:
    db        "("
    db        0
L13201:
    db        ")"
    db        0
L13200:
    db        ","
    db        0
L13199:
    db        "("
    db        0
L13198:
    db        "."
    db        0
L13197:
    db        "]"
    db        0
L13196:
    db        "["
    db        0
L13195:
    db        "."
    db        0
L13194:
    db        ")"
    db        0
L13193:
    db        ","
    db        0
L13192:
    db        "("
    db        0
L13191:
    db        ")"
    db        0
L13190:
    db        "("
    db        0
L13189:
    db        ")"
    db        0
L13188:
    db        "("
    db        0
L13187:
    db        ")"
    db        0
L13186:
    db        "("
    db        0
L13185:
    db        "<EVAL/CONST PROBABLY VOID>"
    db        0
L13184:
    db        34
    db        0
L13183:
    db        "LONGSTR)"
    db        0
L13182:
    db        "Uflags overflow/c"
    db        0
L13181:
    db        "Uflags overflow/a"
    db        0
L13180:
    db        "sv_"
    db        0
L13179:
    db        "av_"
    db        0
L13178:
    db        "Auto frame not in proc"
    db        0
L13177:
    db        "."
    db        0
L13176:
    db        "$T"
    db        0
L13175:
    db        "CREATEARRAYMODEK/TARGET NOT RESOLVED"
    db        0
L13174:
    db        "Too many types"
    db        0
L13173:
    db        "Too many type names"
    db        0
L13170:
    db        "Duplicate name"
    db        0
L13169:
    db        "in"
    db        0
L13168:
    db        "Decimal not ready"
    db        0
L13161:
    db        "r64lit too long"
    db        0
L13160:
    db        "expon?"
    db        0
L13159:
    db        "double expon"
    db        0
L13158:
    db        "bin overflow"
    db        0
L13157:
    db        "bin bad digit"
    db        0
L13156:
    db        "MAKEDEC"
    db        0
L13155:
    db        "Numlit too long"
    db        0
L13154:
    db        "bad bin digit"
    db        0
L13153:
    db        "bin overflow"
    db        0
L13152:
    db        "Bad hex digit"
    db        0
L13151:
    db        0
L13150:
    db        "String not terminated"
    db        0
L13149:
    db        "Unknown string escape: "
    db        92
    db        "%s"
    db        0
L13148:
    db        "Bad ` name"
    db        0
L13147:
    db        "Include file/macro overflow"
    db        0
L13146:
    db        9
    db        0
L13145:
    db        ": "
    db        0
L13144:
    db        "PS:"
    db        0
L13143:
    db        0
L13142:
    db        "m"
    db        0
L13141:
    db        "include: string expected"
    db        0
L13140:
    db        "Hashtable:"
    db        0
L13139:
    db        "SYS:HASHTABLE FULL"
    db        0
L13138:
    db        "Lex dupl name:"
    db        0
L13137:
    db        "HASHTABLE FULL"
    db        0
L13136:
    db        "Raw string not terminated"
    db        0
L13135:
    db        ".*"
    db        0
L13134:
    db        "v"
    db        0
L13133:
    db        "Unknown char"
    db        0
L13132:
    db        ".123 not done"
    db        0
L13131:
    db        92
    db        " not followed by eol"
    db        0
L13130:
    db        "Bad base"
    db        0
L13129:
    db        "Unit suffix after float not implem"
    db        0
L13128:
    db        "Can't do this unit index"
    db        0
L13127:
    db        "Total:"
    db        0
L13126:
    db        "-----------------------------"
    db        0
L13125:
    db        "EXE:"
    db        0
L13124:
    db        "SS:"
    db        0
L13123:
    db        "MCL:"
    db        0
L13122:
    db        "PCL:"
    db        0
L13121:
    db        "Type:"
    db        0
L13120:
    db        "Resolve:"
    db        0
L13119:
    db        "Parse:"
    db        0
L13118:
    db        "Load:"
    db        0
L13117:
    db        "5.1jr"
    db        0
L13115:
    db        "5"
    db        0
L13114:
    db        "12jl"
    db        0
L13113:
    db        "# # ms # %"
    db        0
L13112:
    db        "LX.FILENO="
    db        0
L13111:
    db        "SUBCODE:"
    db        0
L13110:
    db        "'"
    db        0
L13109:
    db        34
    db        0
L13108:
    db        "word"
    db        0
L13107:
    db        "int"
    db        0
L13106:
    db        " [#]"
    db        0
L13105:
    db        "%-18s"
    db        0
L13104:
    db        0
L13103:
    db        "PROC"
    db        0
L13102:
    db        "w"
    db        0
L13101:
    db        "End"
    db        10
    db        0
L13100:
    db        "20jl"
    db        0
L13099:
    db        "#"
    db        9
    db        "#.# (#) Mod:"
    db        0
L13098:
    db        "DLL Proc List:"
    db        0
L13097:
    db        "End"
    db        10
    db        0
L13096:
    db        "20jl"
    db        0
L13095:
    db        "#"
    db        9
    db        "#.# (#) Mod:"
    db        0
L13094:
    db        "Proc List:"
    db        0
L13093:
    db        "PROC"
    db        0
L13092:
    db        "mx.log"
    db        0
L13091:
    db        "Diagnostic outputs written to"
    db        0
L13090:
    db        "mm.m"
    db        0
L13089:
    db        "mx.log"
    db        0
L13088:
    db        92
    db        "m"
    db        92
    db        "ed.bat "
    db        0
L13087:
    db        "PRESS KEY..."
    db        0
L13086:
    db        "FLAT SYMBOL TABLE"
    db        0
L13085:
    db        "SYMBOL TABLE"
    db        0
L13084:
    db        "AST1"
    db        0
L13083:
    db        "AST2"
    db        0
L13082:
    db        "AST3"
    db        0
L13081:
    db        "PSYMTAB"
    db        0
L13080:
    db        "pcl"
    db        0
L13079:
    db        "asm"
    db        0
L13078:
    db        "PROC ASSEMBLY"
    db        0
L13077:
    db        "w"
    db        0
L13076:
    db        "mx.log"
    db        0
L13075:
    db        "16jl"
    db        0
L13074:
    db        "Link files"
    db        0
L13073:
    db        "7"
    db        0
L13072:
    db        "30jl"
    db        0
L13071:
    db        "20jl"
    db        0
L13070:
    db        "jl18"
    db        0
L13069:
    db        "jl16"
    db        0
L13068:
    db        "2"
    db        0
L13067:
    db        "  #:  Name=# File=# Path=# Spec=# Size=#"
    db        0
L13066:
    db        "Sourcefiles"
    db        0
L13065:
    db        ")"
    db        0
L13064:
    db        "("
    db        0
L13063:
    db        "Sys:"
    db        0
L13062:
    db        "MAINSUBPROGNO="
    db        0
L13061:
    db        "Subprograms"
    db        0
L13060:
    db        ":"
    db        0
L13059:
    db        " Alias:"
    db        0
L13058:
    db        "Fileno:"
    db        0
L13057:
    db        "Sub:"
    db        0
L13056:
    db        "Sys:"
    db        0
L13055:
    db        "16jl"
    db        0
L13054:
    db        "2"
    db        0
L13053:
    db        "  "
    db        0
L13052:
    db        "m "
    db        0
L13051:
    db        "h "
    db        0
L13050:
    db        "hm"
    db        0
L13049:
    db        "Modules"
    db        0
L13048:
    db        "---------------------------------------"
    db        0
L13047:
    db        "Project Structure:"
    db        0
L13046:
    db        "Isblock:"
    db        0
L13045:
    db        "Isref:"
    db        0
L13044:
    db        "Isshort:"
    db        0
L13043:
    db        "Isinteger:"
    db        0
L13042:
    db        "Isreal:"
    db        0
L13041:
    db        "Signed:"
    db        0
L13040:
    db        " "
    db        0
L13039:
    db        "Mult:"
    db        0
L13038:
    db        "# Bounds: #..#  Length:#"
    db        0
L13037:
    db        "Sizeset"
    db        0
L13036:
    db        "Size:"
    db        0
L13035:
    db        "Target:"
    db        0
L13034:
    db        "-"
    db        0
L13033:
    db        "ttnamedef:"
    db        0
L13032:
    db        "ttname:"
    db        0
L13031:
    db        "Basetype:"
    db        0
L13030:
    db        "4"
    db        0
L13029:
    db        "MODELIST"
    db        0
L13028:
    db        "z4"
    db        0
L13027:
    db        "Z2"
    db        0
L13026:
    db        "# # "
    db        0
L13025:
    db        " "
    db        0
L13024:
    db        "-----------------------------"
    db        0
L13023:
    db        "---"
    db        0
L13022:
    db        "RES"
    db        0
L13021:
    db        "# #:#"
    db        0
L13020:
    db        "S"
    db        0
L13019:
    db        "E"
    db        0
L13018:
    db        "S"
    db        0
L13017:
    db        "- "
    db        0
L13016:
    db        " Pclcond<#>"
    db        0
L13015:
    db        " Conv<#>"
    db        0
L13014:
    db        " Prop<#>"
    db        0
L13013:
    db        " no-op"
    db        0
L13012:
    db        " Pcl<#>"
    db        0
L13011:
    db        " Not const"
    db        0
L13010:
    db        " Is const"
    db        0
L13009:
    db        " "
    db        0
L13008:
    db        "#"
    db        0
L13007:
    db        "Offset:"
    db        0
L13006:
    db        " Makeax:"
    db        0
L13005:
    db        "Len:"
    db        0
L13004:
    db        " Convmode:"
    db        0
L13003:
    db        "Len:"
    db        0
L13002:
    db        " *L"
    db        0
L13001:
    db        " <isstr>(#)"
    db        0
L13000:
    db        " "
    db        0
L12999:
    db        "<PRINTUNIT BAD CONST PROBABLY VOID"
    db        0
L12998:
    db        "TYPENAME(T)="
    db        0
L12997:
    db        "P.SLENGTH="
    db        0
L12996:
    db        "P.STRTYPE="
    db        0
L12995:
    db        "<ARRAY>"
    db        0
L12994:
    db        "False"
    db        0
L12993:
    db        "True"
    db        0
L12992:
    db        "NIL"
    db        0
L12991:
    db        "#"
    db        0
L12990:
    db        34
    db        34
    db        0
L12989:
    db        34
    db        " *"
    db        0
L12988:
    db        34
    db        0
L12987:
    db        34
    db        " *"
    db        0
L12986:
    db        "(LONGSTR)"
    db        0
L12985:
    db        34
    db        0
L12984:
    db        "P.INDEX="
    db        0
L12983:
    db        " AV:"
    db        0
L12982:
    db        " Moduleno:"
    db        0
L12981:
    db        " Addroffirst."
    db        0
L12980:
    db        " Lastcall:"
    db        0
L12979:
    db        0
L12978:
    db        " {Dotted}"
    db        0
L12977:
    db        " "
    db        0
L12976:
    db        "}"
    db        0
L12975:
    db        " {"
    db        0
L12974:
    db        ": "
    db        0
L12973:
    db        ":"
    db        0
L12972:
    db        "1"
    db        0
L12971:
    db        " in record"
    db        0
L12970:
    db        "Mod"
    db        0
L12969:
    db        "Exp"
    db        0
L12968:
    db        "Prog"
    db        0
L12967:
    db        "Sub"
    db        0
L12966:
    db        "="
    db        0
L12965:
    db        " (From #:#)"
    db        0
L12964:
    db        ":"
    db        0
L12963:
    db        "     "
    db        0
L12962:
    db        ":"
    db        0
L12961:
    db        "5"
    db        0
L12960:
    db        "GLOBAL SYMBOL TABLE:"
    db        0
L12959:
    db        "*"
    db        0
L12958:
    db        " Lineno: ???"
    db        0
L12957:
    db        " +"
    db        0
L12956:
    db        " @"
    db        0
L12955:
    db        "<HAS BASECLASS>"
    db        0
L12954:
    db        "Baseclass:"
    db        0
L12953:
    db        "Const:"
    db        0
L12952:
    db        ":="
    db        0
L12951:
    db        "="
    db        0
L12950:
    db        " Truename:"
    db        0
L12949:
    db        "Index/PCaddr:"
    db        0
L12948:
    db        " Nret:"
    db        0
L12947:
    db        "Index:"
    db        0
L12946:
    db        "..."
    db        0
L12945:
    db        "/:="
    db        0
L12944:
    db        "-"
    db        0
L12943:
    db        " UFLAGS:"
    db        0
L12942:
    db        ".*"
    db        0
L12941:
    db        "v"
    db        0
L12940:
    db        "%.*s"
    db        0
L12939:
    db        ":"
    db        0
L12938:
    db        " Bitoffset:"
    db        0
L12937:
    db        " Offset:"
    db        0
L12936:
    db        " "
    db        0
L12935:
    db        ":"
    db        0
L12934:
    db        "Void "
    db        0
L12933:
    db        "()"
    db        0
L12932:
    db        "(#)"
    db        0
L12931:
    db        "]"
    db        0
L12930:
    db        "Threaded "
    db        0
L12929:
    db        "U "
    db        0
L12928:
    db        "Subno#"
    db        0
L12927:
    db        "Modno#"
    db        0
L12926:
    db        " "
    db        0
L12925:
    db        "Var:"
    db        0
L12924:
    db        "Opt "
    db        0
L12923:
    db        " "
    db        0
L12922:
    db        " maxalign:"
    db        0
L12921:
    db        "@@"
    db        0
L12920:
    db        "Stat"
    db        0
L12919:
    db        " "
    db        0
L12918:
    db        "Imp "
    db        0
L12917:
    db        "["
    db        0
L12915:
    db        ":"
    db        0
L12914:
    db        "    "
    db        0
L12913:
    db        " "
    db        0
L12912:
    db        "FIXASMLABEL: zero"
    db        0
L12911:
    db        "genasmopnd?"
    db        0
L12910:
    db        "ax:imm/add"
    db        0
L12909:
    db        "Can't do memexpr"
    db        0
L12908:
    db        0
L12907:
    db        "ASSEM/SYSFN?"
    db        0
L12906:
    db        "-name"
    db        0
L12905:
    db        0
L12904:
    db        "assume/unary"
    db        0
L12903:
    db        "pcmpistr/no imm"
    db        0
L12902:
    db        "ASM: Bad operand?"
    db        0
L12901:
    db        "BAD OPND"
    db        0
L12900:
    db        "Empty []"
    db        0
L12899:
    db        "Bad scale"
    db        0
L12898:
    db        "Bad prefix"
    db        0
L12897:
    db        "Too many asm opnds"
    db        0
L12896:
    db        "ASM???"
    db        0
L12895:
    db        "ASM"
    db        0
L12894:
    db        "x64 op expected"
    db        0
L12893:
    db        "ASM"
    db        0
L12892:
    db        "EOF: 'End' missing in Assembler code"
    db        0
L12891:
    db        "recase outside case stmt"
    db        0
L12890:
    db        "Bad mult assign element"
    db        0
L12889:
    db        "(a,b):=x; var only"
    db        0
L12888:
    db        "DECONSTR SLICE NOT READY"
    db        0
L12887:
    db        "multassign from fn: not simple fn"
    db        0
L12886:
    db        "Assignment not suitable for []char type"
    db        0
L12885:
    db        "ASSIGN BLOCK"
    db        0
L12884:
    db        "SYSCALL/GENERIC"
    db        0
L12883:
    db        "rd@dev?"
    db        0
L12882:
    db        "@dev no ref"
    db        0
L12881:
    db        "CAN'T READ THIS ITEM"
    db        0
L12880:
    db        "STRMODE(M)="
    db        0
L12879:
    db        "too many cases"
    db        0
L12878:
    db        "case"
    db        0
L12877:
    db        "case nested too deeply"
    db        0
L12876:
    db        "EMPTY CASE NOT DONE"
    db        0
L12875:
    db        "selectx: too many labels"
    db        0
L12874:
    db        "J3"
    db        0
L12873:
    db        "J2"
    db        0
L12872:
    db        "J1"
    db        0
L12871:
    db        "doswx in main?"
    db        0
L12870:
    db        "doswx not ref"
    db        0
L12869:
    db        "doswx not name"
    db        0
L12868:
    db        "Switch too big"
    db        0
L12867:
    db        "Switch when2: not const: #"
    db        0
L12866:
    db        "CONV/ERROR"
    db        0
L12865:
    db        "Bad for-step"
    db        0
L12864:
    db        "for/step non-const not ready"
    db        0
L12863:
    db        "Possibly using &param as for-loop limit"
    db        0
L12862:
    db        "PRINT/T=#"
    db        0
L12861:
    db        "PRINTSLICE"
    db        0
L12860:
    db        "PRINTRECORD"
    db        0
L12859:
    db        "PRINTARRAY"
    db        0
L12858:
    db        "string expected"
    db        0
L12857:
    db        "@dev?"
    db        0
L12856:
    db        "@dev no ref"
    db        0
L12855:
    db        "Mixed stack args"
    db        0
L12854:
    db        "maxparams"
    db        0
L12853:
    db        "call/not ptr"
    db        0
L12852:
    db        "Mult?"
    db        0
L12851:
    db        "Bad exit/loop index"
    db        0
L12850:
    db        "Can't assign"
    db        0
L12849:
    db        "Assign to proc?"
    db        0
L12848:
    db        "ASS/SLICE"
    db        0
L12847:
    db        "do_const"
    db        0
L12846:
    db        "1:B-str?"
    db        0
L12845:
    db        "Unimplemented: #"
    db        0
L12844:
    db        "jumpt/f"
    db        0
L12843:
    db        "empty set"
    db        0
L12842:
    db        "evalref"
    db        0
L12841:
    db        "*"
    db        0
L12840:
    db        "NOT ALLOWED BY ITSELF:"
    db        0
L12839:
    db        "*"
    db        0
L12838:
    db        "UNSUPPORTED TAG "
    db        0
L12837:
    db        " "
    db        0
L12836:
    db        "geteqv"
    db        0
L12835:
    db        "."
    db        0
L12834:
    db        "$procaddr"
    db        0
L12833:
    db        "$procname"
    db        0
L12832:
    db        "$nprocs"
    db        0
L12831:
    db        "PCL proctab overflow"
    db        0
L12830:
    db        "------------------------"
    db        0
L12829:
    db        "No m$unimpl"
    db        0
L12828:
    db        "Sysfn not found:"
    db        0
L12827:
    db        "m$"
    db        0
L12826:
    db        "Bad loop index"
    db        0
L12825:
    db        "Too many nested loops"
    db        0
L12824:
    db        "IDATA: "
    db        0
L12823:
    db        "Idata &frameXXX"
    db        0
L12822:
    db        "IDATA/ARRAY/NOT BLOCKDATA"
    db        0
L12821:
    db        "1:B-str?"
    db        0
L12820:
    db        "$cmdskip"
    db        0
L12819:
    db        "------------------------"
    db        0
L12818:
    db        0
L12817:
    db        "start"
    db        0
L12816:
    db        "dll"
    db        0
L12815:
    db        "M Compiler for 64-bit Windows"
    db        10
    db        10
    db        "Normal use:           Compiles lead module prog.m to:"
    db        10
    db        10
    db        "    mm      prog      prog.exe (default)"
    db        10
    db        "    mm -r   prog      in-memory native code then execute"
    db        10
    db        "    mm -i   prog      in-memory IL then interpret"
    db        10
    db        10
    db        "    mm -exe prog      prog.exe"
    db        10
    db        "    mm -dll prog      prog.dll"
    db        10
    db        "    mm -obj prog      prog.obj"
    db        10
    db        "    mm -a   prog      prog.asm"
    db        10
    db        "    mm -n   prog      prog.nasm"
    db        10
    db        "    mm -mx  prog      prog.mx"
    db        10
    db        "    mm -p   prog      prog.pcl (textual IL)"
    db        10
    db        "    mm -ma   prog     prog.ma (single amalgamated source file)"
    db        10
    db        10
    db        "Other options:"
    db        10
    db        10
    db        "    -ext              Used std headers external to compiler"
    db        10
    db        "    -opt              Optimise native code"
    db        10
    db        "    -out:file         Name output file (extension can be added)"
    db        10
    db        "    -rip              Use RIP address modes"
    db        10
    db        "    -himem            Generate PIC code (automatic with -obj/-dll)"
    db        10
    db        "    @file             Read files and options from a file"
    db        10
    db        0
L12814:
    db        "11:39:29"
    db        0
L12813:
    db        "29-Jun-2025"
    db        0
L12812:
    db        "M Compiler [M7.1]"
    db        0
L12811:
    db        0
L12810:
    db        "Path needs to end with "
    db        92
    db        " or /"
    db        0
L12809:
    db        0
L12808:
    db        "mixed out/path"
    db        0
L12807:
    db        0
L12806:
    db        "mixed out/path"
    db        0
L12805:
    db        0
L12804:
    db        "dupl debug option"
    db        0
L12803:
    db        0
L12802:
    db        "Wrong WRITEASM"
    db        0
L12801:
    db        0
L12800:
    db        "dupl prod option:"
    db        0
L12799:
    db        "New dest="
    db        0
L12798:
    db        "2.m"
    db        0
L12797:
    db        " -h           Show all options"
    db        0
L12796:
    db        "   "
    db        0
L12795:
    db        " prog[.m]  Compile prog.m to prog.exe"
    db        0
L12794:
    db        "   "
    db        0
L12793:
    db        "Usage:"
    db        0
L12792:
    db        "exe"
    db        0
L12791:
    db        "m"
    db        0
L12790:
    db        0
L12789:
    db        "Invalid params"
    db        0
L12788:
    db        0
L12787:
    db        "Lib files go in module headers"
    db        0
L12786:
    db        0
L12785:
    db        "Specify one lead module only"
    db        0
L12784:
    db        "Unknown option:"
    db        0
L12783:
    db        0
L12782:
    db        "ms.exe"
    db        0
L12781:
    db        "PSYMTAB"
    db        0
L12780:
    db        "$prog"
    db        0
L12779:
    db        "PROGRAM"
    db        0
L12778:
    db        "PSYMTAB"
    db        0
L12777:
    db        "asm"
    db        0
L12776:
    db        "PSYMTAB"
    db        0
L12775:
    db        "pcl"
    db        0
L12774:
    db        "WRITE C FILE:"
    db        0
L12773:
    db        "c"
    db        0
L12772:
    db        "AST3"
    db        0
L12771:
    db        "AST2"
    db        0
L12770:
    db        "AST1"
    db        0
L12769:
    db        "Compiling # to #"
    db        0
L12768:
    db        "mx"
    db        0
L12767:
    db        "dll"
    db        0
L12766:
    db        "exe"
    db        0
L12765:
    db        "obj"
    db        0
L12764:
    db        "Finished."
    db        0
L12763:
    db        "reloc?"
    db        0
L12762:
    db        "rel32/rel not imported"
    db        0
L12761:
    db        "0.1234"
    db        0
L12760:
    db        0
L12759:
    db        "No entry point found"
    db        0
L12758:
    db        "$cmdskip"
    db        0
L12757:
    db        "msys.$cmdskip"
    db        0
L12756:
    db        0
L12755:
    db        "Too many Imports"
    db        0
L12754:
    db        0
L12753:
    db        "Too many DLLs"
    db        0
L12752:
    db        "Dupl symbol:"
    db        0
L12751:
    db        "Can't find #"
    db        0
L12750:
    db        "ml"
    db        0
L12749:
    db        "Loading sublib"
    db        0
L12748:
    db        0
L12747:
    db        "imprel32?"
    db        0
L12746:
    db        "Undef"
    db        0
L12745:
    db        "Can't find DLL: #"
    db        0
L12744:
    db        0
L12743:
    db        "Too many libs"
    db        0
L12742:
    db        "Lib already exists:"
    db        0
L12741:
    db        "Aborting"
    db        0
L12740:
    db        0
L12739:
    db        "Can't alloc code memory"
    db        0
L12738:
    db        "Unknown directive:"
    db        0
L12737:
    db        "Bad sig - not MCX file"
    db        0
L12735:
    db        "NO MAIN FOUND"
    db        0
L12734:
    db        "reloc?"
    db        0
L12733:
    db        "rel32/rel not imported"
    db        0
L12732:
    db        "0.1234"
    db        0
L12730:
    db        "W:too many strings"
    db        0
L12729:
    db        ".text"
    db        0
L12728:
    db        ".data"
    db        0
L12727:
    db        ".bss"
    db        0
L12726:
    db        ".file"
    db        0
L12725:
    db        "as:Too many symbols"
    db        0
L12724:
    db        "OBJ/phighmem 1?"
    db        0
L12723:
    db        "wrelocs/bad seg"
    db        0
L12722:
    db        "Writing file:"
    db        0
L12721:
    db        ".text"
    db        0
L12720:
    db        ".data"
    db        0
L12719:
    db        "Too many relocs (exceeds 16-bit field)"
    db        0
L12718:
    db        ".bss"
    db        0
L12717:
    db        "GSN"
    db        0
L12716:
    db        "Too many blocks"
    db        0
L12714:
    db        "Too many exports - can't sort"
    db        0
L12713:
    db        "Entry point not found: main"
    db        0
L12712:
    db        "User entry point not found"
    db        0
L12710:
    db        "Can't do this rel type"
    db        0
L12709:
    db        "RELOCDATA/SEG?"
    db        0
L12708:
    db        "rel32/not imported"
    db        0
L12707:
    db        "gendll: Too many exports"
    db        0
L12706:
    db        "genexe: Too many imports"
    db        0
L12705:
    db        "2:Too many libs"
    db        0
L12704:
    db        ".dll"
    db        0
L12703:
    db        "Can't find external function"
    db        0
L12702:
    db        "Too many libs"
    db        0
L12701:
    db        ".dll"
    db        0
L12700:
    db        ".idata"
    db        0
L12699:
    db        ".bss"
    db        0
L12698:
    db        ".data"
    db        0
L12697:
    db        "10s,jr"
    db        0
L12696:
    db        "Zdata size:"
    db        0
L12695:
    db        "10s,jr"
    db        0
L12694:
    db        "Code+Idata:"
    db        0
L12693:
    db        "10s,jr"
    db        0
L12692:
    db        "Idata size:"
    db        0
L12691:
    db        "bytes"
    db        0
L12690:
    db        "10s,jr"
    db        0
L12689:
    db        "Code size: "
    db        0
L12688:
    db        ".text"
    db        0
L12687:
    db        "Can't load search lib"
    db        0
L12686:
    db        "File:"
    db        0
L12685:
    db        "Error writing exe file (possibly still running)"
    db        0
L12684:
    db        "10s,jr"
    db        0
L12683:
    db        "EXE size:  "
    db        0
L12682:
    db        0
L12681:
    db        "qword "
    db        0
L12680:
    db        "dword "
    db        0
L12679:
    db        "word "
    db        0
L12678:
    db        "byte "
    db        0
L12677:
    db        0
L12676:
    db        "#.$T#"
    db        0
L12675:
    db        "T"
    db        0
L12674:
    db        "R"
    db        0
L12673:
    db        "#.#"
    db        0
L12672:
    db        "XMM"
    db        0
L12671:
    db        "-"
    db        0
L12670:
    db        0
L12669:
    db        "Stropnd?"
    db        0
L12668:
    db        "L"
    db        0
L12667:
    db        34
    db        0
L12666:
    db        "M"
    db        0
L12665:
    db        "20.20"
    db        0
L12664:
    db        0
L12663:
    db        "+"
    db        0
L12662:
    db        0
L12661:
    db        "<BAD OPND>"
    db        0
L12660:
    db        "BAD OPND"
    db        0
L12659:
    db        "]"
    db        0
L12658:
    db        " + "
    db        0
L12657:
    db        "*"
    db        0
L12656:
    db        " + "
    db        0
L12655:
    db        0
L12654:
    db        "["
    db        0
L12653:
    db        "M#"
    db        0
L12652:
    db        "H"
    db        0
L12651:
    db        "0x"
    db        0
L12650:
    db        ","
    db        0
L12649:
    db        ","
    db        9
    db        0
L12648:
    db        " "
    db        0
L12647:
    db        "  "
    db        0
L12646:
    db        " "
    db        0
L12645:
    db        "alignb"
    db        0
L12644:
    db        "movsxd"
    db        0
L12643:
    db        "imul"
    db        0
L12642:
    db        "not"
    db        0
L12641:
    db        "xor"
    db        0
L12640:
    db        "or"
    db        0
L12639:
    db        "and"
    db        0
L12638:
    db        "cmov"
    db        0
L12637:
    db        "set"
    db        0
L12636:
    db        "j"
    db        0
L12635:
    db        "    segment .bss"
    db        0
L12634:
    db        "    segment .data"
    db        0
L12633:
    db        "    segment .text"
    db        0
L12632:
    db        " "
    db        0
L12631:
    db        "   %define "
    db        0
L12630:
    db        " "
    db        0
L12629:
    db        "    %define "
    db        0
L12628:
    db        "L#:"
    db        0
L12627:
    db        ":"
    db        0
L12626:
    db        10
    db        0
L12625:
    db        ":"
    db        0
L12624:
    db        0
L12623:
    db        "strmcl/lab"
    db        0
L12622:
    db        ";End "
    db        0
L12621:
    db        ";Proc "
    db        0
L12620:
    db        10
    db        0
L12619:
    db        "    global "
    db        0
L12618:
    db        10
    db        0
L12617:
    db        "    extern "
    db        0
L12616:
    db        10
    db        0
L12615:
    db        "    global main"
    db        10
    db        0
L12614:
    db        "    extern __getmainargs"
    db        10
    db        0
L12613:
    db        "    extern exit"
    db        10
    db        0
L12612:
    db        "    extern pow"
    db        10
    db        0
L12611:
    db        "    extern ceil"
    db        10
    db        0
L12610:
    db        "    extern floor"
    db        10
    db        0
L12609:
    db        "    extern exp"
    db        10
    db        0
L12608:
    db        "    extern log10"
    db        10
    db        0
L12607:
    db        "    extern log"
    db        10
    db        0
L12606:
    db        "    extern atan"
    db        10
    db        0
L12605:
    db        "    extern acos"
    db        10
    db        0
L12604:
    db        "    extern asin"
    db        10
    db        0
L12603:
    db        "    extern tan"
    db        10
    db        0
L12602:
    db        "    extern cos"
    db        10
    db        0
L12601:
    db        "    extern sin"
    db        10
    db        0
L12600:
    db        "    extern fmod"
    db        10
    db        0
L12599:
    db        "    default rel"
    db        10
    db        0
L12598:
    db        ";NASM VERSION"
    db        10
    db        0
L12597:
    db        "dshift/size"
    db        0
L12596:
    db        "bswap reg>"
    db        0
L12595:
    db        "fixrip disp?"
    db        0
L12594:
    db        "DISPSIZE="
    db        0
L12593:
    db        "movdq opnds"
    db        0
L12592:
    db        "movdq mem,?"
    db        0
L12591:
    db        "5:movdq size"
    db        0
L12590:
    db        "movdq xreg,?"
    db        0
L12589:
    db        "31:movdq size"
    db        0
L12588:
    db        "3:movdq size"
    db        0
L12587:
    db        "movdq reg,?"
    db        0
L12586:
    db        "1:movdq size"
    db        0
L12585:
    db        "float opnds"
    db        0
L12584:
    db        "fix opnds"
    db        0
L12583:
    db        "convertfloat opnds"
    db        0
L12582:
    db        "logicxmm opnds"
    db        0
L12581:
    db        "arithxmm opnds"
    db        0
L12580:
    db        "Wrong size"
    db        0
L12579:
    db        "A.SIZE="
    db        0
L12578:
    db        "Need size"
    db        0
L12577:
    db        "setcc opnd/size"
    db        0
L12576:
    db        "test opnds"
    db        0
L12575:
    db        "shift opnds2?"
    db        0
L12574:
    db        "cl or b10 needed"
    db        0
L12573:
    db        "shift/label"
    db        0
L12572:
    db        "shift opnds1?"
    db        0
L12571:
    db        "imul2 opnds"
    db        0
L12570:
    db        "mul/label"
    db        0
L12569:
    db        "imul2 size"
    db        0
L12568:
    db        "imul2 byte"
    db        0
L12567:
    db        "imul2 opnds"
    db        0
L12566:
    db        "movsxd opnds"
    db        0
L12565:
    db        "movsxd size"
    db        0
L12564:
    db        "exch size"
    db        0
L12563:
    db        "exch opnds"
    db        0
L12562:
    db        "exch size"
    db        0
L12561:
    db        "movsx not reg/mem"
    db        0
L12560:
    db        "movsx size 8"
    db        0
L12559:
    db        "movsx need size prefix"
    db        0
L12558:
    db        "movsx 4=>8 bytes?"
    db        0
L12557:
    db        "movsx size error"
    db        0
L12556:
    db        "movsx not reg"
    db        0
L12555:
    db        "LEA size error"
    db        0
L12554:
    db        "LEA not reg/mem"
    db        0
L12553:
    db        "neg/div/etc opnd?"
    db        0
L12552:
    db        "inc/opnd?"
    db        0
L12551:
    db        "pop opnd?"
    db        0
L12550:
    db        "pop not 64-bit"
    db        0
L12549:
    db        "popreg not 64-bit"
    db        0
L12548:
    db        "push opnd?"
    db        0
L12547:
    db        "push not 64-bit"
    db        0
L12546:
    db        "push imm value too large"
    db        0
L12545:
    db        "pushreg not 64-bit"
    db        0
L12544:
    db        "MOV ?/.."
    db        0
L12543:
    db        "MOV MEM/?"
    db        0
L12542:
    db        "mov imm?"
    db        0
L12541:
    db        "3:Opnd size mismatch"
    db        0
L12540:
    db        "MOV REG/??"
    db        0
L12539:
    db        "1:exceeding u32 value"
    db        0
L12538:
    db        "exceeding u16 value"
    db        0
L12537:
    db        "exceeding byte value"
    db        0
L12536:
    db        "mov imm?"
    db        0
L12535:
    db        "2:Opnd size mismatch"
    db        0
L12534:
    db        "1:Can't add to this opnd"
    db        0
L12533:
    db        "CODE="
    db        0
L12532:
    db        "ADD mem,???"
    db        0
L12531:
    db        "ADD reg,???"
    db        0
L12530:
    db        "Exceeding i8/u8 range"
    db        0
L12529:
    db        "add imm/size"
    db        0
L12528:
    db        "Addr32 can't use RIP, line"
    db        0
L12527:
    db        "Can't scale rstack"
    db        0
L12526:
    db        "Scaled rstack?"
    db        0
L12525:
    db        "genrm not mem"
    db        0
L12524:
    db        "2:exceeding u32 value"
    db        0
L12523:
    db        "exceeding u16 value"
    db        0
L12522:
    db        "exceeding byte value"
    db        0
L12521:
    db        "dbuffer error"
    db        0
L12520:
    db        "l#"
    db        0
L12519:
    db        "bsf size"
    db        0
L12518:
    db        "genrel8"
    db        0
L12517:
    db        "fmem int size"
    db        0
L12516:
    db        "fst i64?"
    db        0
L12515:
    db        "fmem size"
    db        0
L12514:
    db        "SIZE="
    db        0
L12513:
    db        "r80 not allowed"
    db        0
L12512:
    db        "fmem/not mem"
    db        0
L12511:
    db        "cmov/byte"
    db        0
L12510:
    db        "1:Opnd size mismatch"
    db        0
L12509:
    db        "jmp[]size"
    db        0
L12508:
    db        "call[]size"
    db        0
L12507:
    db        "Can't do jcxz fwd jump"
    db        0
L12506:
    db        "jcxz jmp out of range"
    db        0
L12505:
    db        "Can't do loopxx fwd jump"
    db        0
L12504:
    db        "loop jmp out of range"
    db        0
L12503:
    db        "Operand size not set"
    db        0
L12502:
    db        "genamode size 2/8"
    db        0
L12501:
    db        "GENAMODE/MODE?"
    db        0
L12500:
    db        "genam/3"
    db        0
L12499:
    db        "DOFWDREFS/CAN'T DO RELTYPE"
    db        0
L12498:
    db        "Fwd ref in zdata"
    db        0
L12497:
    db        "Rel label across segments2"
    db        0
L12496:
    db        "getdef/no def"
    db        0
L12495:
    db        "Rel label across segments"
    db        0
L12494:
    db        "OPND/8/VALTYPE?"
    db        0
L12493:
    db        "OPND/4/VALTYPE?"
    db        0
L12492:
    db        "8/16-BIT RELOC"
    db        0
L12491:
    db        "GENSS/NAME OPND"
    db        0
L12490:
    db        "STOPPING"
    db        0
L12489:
    db        "M_HALT="
    db        0
L12488:
    db        "M.OPCODE="
    db        0
L12487:
    db        "line"
    db        0
L12486:
    db        "*** Can't do opcode"
    db        0
L12485:
    db        "align?"
    db        0
L12484:
    db        "align2"
    db        0
L12483:
    db        "resb?"
    db        0
L12482:
    db        "retn?"
    db        0
L12481:
    db        "Zdata contains code or data"
    db        0
L12480:
    db        0
L12479:
    db        "delmcl?"
    db        0
L12478:
    db        " ncalldepth:"
    db        0
L12477:
    db        " noperands:"
    db        0
L12476:
    db        ") hwstack:"
    db        0
L12475:
    db        "0 "
    db        0
L12474:
    db        "1 "
    db        0
L12473:
    db        "XWR:("
    db        0
L12472:
    db        ") "
    db        0
L12471:
    db        "0 "
    db        0
L12470:
    db        "1 "
    db        0
L12469:
    db        "WR:("
    db        0
L12468:
    db        " "
    db        0
L12467:
    db        ") "
    db        0
L12466:
    db        ", "
    db        0
L12465:
    db        ">"
    db        0
L12464:
    db        "<"
    db        0
L12463:
    db        "@"
    db        0
L12462:
    db        ")"
    db        0
L12461:
    db        "("
    db        0
L12460:
    db        "T"
    db        0
L12459:
    db        "*"
    db        0
L12458:
    db        0
L12457:
    db        "W:"
    db        0
L12456:
    db        "X:"
    db        0
L12455:
    db        "Y:"
    db        0
L12454:
    db        "Z:"
    db        0
L12453:
    db        "#:("
    db        0
L12452:
    db        "========================================#:("
    db        0
L12451:
    db        0
L12450:
    db        "MSA"
    db        0
L12449:
    db        0
L12448:
    db        "makeopndind"
    db        0
L12447:
    db        0
L12446:
    db        "SOR1"
    db        0
L12445:
    db        0
L12444:
    db        "MOVE TO REG: XREG IN USE"
    db        0
L12443:
    db        0
L12442:
    db        "No more work xregs"
    db        0
L12441:
    db        0
L12440:
    db        "No more work regs"
    db        0
L12439:
    db        0
L12438:
    db        "poppcl/underflow"
    db        0
L12437:
    db        0
L12436:
    db        "PCL stack overflow"
    db        0
L12435:
    db        0
L12434:
    db        "PCL stack overflow"
    db        0
L12433:
    db        "getopnd"
    db        0
L12432:
    db        0
L12431:
    db        "Ext nametab overflow"
    db        0
L12430:
    db        "$B#"
    db        0
L12429:
    db        0
L12428:
    db        "Too many block temps"
    db        0
L12427:
    db        "AASEQ:"
    db        0
L12426:
    db        "AX ERROR:"
    db        0
L12425:
    db        "MCL Opnd not supported: # (#) [#]"
    db        0
L12424:
    db        0
L12423:
    db        "2:SIZE=0"
    db        0
L12422:
    db        0
L12421:
    db        "1:SIZE=0"
    db        0
L12420:
    db        0
L12419:
    db        "BAD SEG CODE"
    db        0
L12418:
    db        0
L12417:
    db        "CAN'T DO RODATA SEG"
    db        0
L12416:
    db        "MCLREC>64B"
    db        0
L12415:
    db        "__getmainargs*"
    db        0
L12414:
    db        "$info"
    db        0
L12413:
    db        "$env"
    db        0
L12412:
    db        "()"
    db        0
L12411:
    db        "High block arg not copied in"
    db        0
L12410:
    db        "No host fn:"
    db        0
L12409:
    db        "gethostfn?"
    db        0
L12408:
    db        "msysc.m$power_i64"
    db        0
L12407:
    db        "msys.m$power_i64"
    db        0
L12406:
    db        0
L12405:
    db        "storebf not imm"
    db        0
L12404:
    db        0
L12403:
    db        "Storebit: both vars"
    db        0
L12402:
    db        0
L12401:
    db        "STOREBIT/VAR"
    db        0
L12400:
    db        0
L12399:
    db        "LOADBF_VAR"
    db        0
L12398:
    db        "mask63/offset64"
    db        0
L12397:
    db        "labzero"
    db        0
L12396:
    db        "labneg64"
    db        0
L12395:
    db        "labneg32"
    db        0
L12394:
    db        "lababs64"
    db        0
L12393:
    db        "lababs32"
    db        0
L12391:
    db        "Real32 Table"
    db        0
L12389:
    db        "Real Table"
    db        0
L12388:
    db        "String Table"
    db        0
L12387:
    db        "ENDDATA"
    db        0
L12386:
    db        0
L12385:
    db        "div/u8"
    db        0
L12384:
    db        0
L12383:
    db        "Divide by zero"
    db        0
L12382:
    db        "---------------"
    db        0
L12381:
    db        "?]]"
    db        0
L12380:
    db        0
L12379:
    db        "Threaded proc has temps"
    db        0
L12378:
    db        0
L12377:
    db        "Threaded proc has locals/params"
    db        0
L12376:
    db        0
L12375:
    db        "@PARAM"
    db        0
L12374:
    db        "$1x"
    db        0
L12372:
    db        0
L12371:
    db        "SUBTOREF/EXTRA"
    db        0
L12370:
    db        "pow*"
    db        0
L12369:
    db        0
L12368:
    db        "setcc/block"
    db        0
L12367:
    db        "fmod*"
    db        0
L12366:
    db        "atan2*"
    db        0
L12365:
    db        "ceil*"
    db        0
L12364:
    db        "floor*"
    db        0
L12363:
    db        "round*"
    db        0
L12362:
    db        "exp*"
    db        0
L12361:
    db        "log10*"
    db        0
L12360:
    db        "log*"
    db        0
L12359:
    db        "atan*"
    db        0
L12358:
    db        "acos*"
    db        0
L12357:
    db        "asin*"
    db        0
L12356:
    db        "tan*"
    db        0
L12355:
    db        "cos*"
    db        0
L12354:
    db        "sin*"
    db        0
L12353:
    db        0
L12352:
    db        "No Assem handler"
    db        0
L12351:
    db        0
L12350:
    db        "SUB/REF NOT POWER OF xx"
    db        0
L12349:
    db        0
L12348:
    db        "float/short"
    db        0
L12347:
    db        0
L12346:
    db        "multo/byte"
    db        0
L12345:
    db        ":"
    db        0
L12344:
    db        0
L12343:
    db        "swap/block"
    db        0
L12342:
    db        0
L12341:
    db        "SUBREF/EXTRA"
    db        0
L12340:
    db        "EXTRA="
    db        0
L12339:
    db        0
L12338:
    db        "Storem not 16"
    db        0
L12337:
    db        "exit*"
    db        0
L12336:
    db        0
L12335:
    db        "Too many nested calls"
    db        0
L12334:
    db        "---"
    db        0
L12333:
    db        0
L12332:
    db        "JUMPCC/BLOCK"
    db        0
L12331:
    db        0
L12330:
    db        "DATA/not 1248"
    db        0
L12329:
    db        "STRPMODE(P.MODE)="
    db        0
L12328:
    db        "P.SIZE="
    db        0
L12327:
    db        "db/dq optype? #"
    db        0
L12326:
    db        "PCL STACK NOT EMPTY"
    db        0
L12325:
    db        "?>>"
    db        0
L12324:
    db        "Unimpl: # (#)"
    db        0
L12323:
    db        "                       "
    db        0
L12322:
    db        "Invalid handler name:"
    db        0
L12321:
    db        "px_"
    db        0
L12320:
    db        "********* ASM HAS PCL INFO *********"
    db        0
L12319:
    db        "$cmdskip"
    db        0
L12318:
    db        "Can't load lib:"
    db        0
L12317:
    db        "Can't find DLL func:"
    db        0
L12316:
    db        "in"
    db        0
L12315:
    db        "Unsupported operand:"
    db        0
L12314:
    db        "seq:"
    db        0
L12313:
    db        "PC Exec error:"
    db        0
L12312:
    db        0
L12311:
    db        "Not mem"
    db        0
L12310:
    db        "Null ptr access"
    db        0
L12309:
    db        "Stopped"
    db        0
L12308:
    db        "Run PCL:"
    db        0
L12307:
    db        0
L12306:
    db        "No 'main' entry point"
    db        0
L12305:
    db        0
L12304:
    db        "data &mem = nil"
    db        0
L12303:
    db        0
L12302:
    db        "data &mem"
    db        0
L12301:
    db        0
L12300:
    db        "FIX/DATA/MEM"
    db        0
L12299:
    db        "Unimpl: # at seq: #"
    db        0
L12298:
    db        "GETOPCODE="
    db        0
L12297:
    db        "# Enter:  # SP=# FP=#"
    db        0
L12296:
    db        "  "
    db        0
L12278:
    db        0
L12277:
    db        "swap/block"
    db        0
L12276:
    db        0
L12275:
    db        "setcc/r32"
    db        0
L12274:
    db        0
L12273:
    db        "setcc/r64"
    db        0
L12272:
    db        0
L12271:
    db        "ICALLF NIL PTR"
    db        0
L12270:
    db        0
L12269:
    db        "ICALLP NIL PTR"
    db        0
L12268:
    db        0
L12267:
    db        "RETF/SP mismatch: old=# curr=# "
    db        0
L12266:
    db        0
L12265:
    db        "ref/call underflow"
    db        0
L12264:
    db        0
L12263:
    db        "RETP/SP mismatch: old=# curr=# "
    db        0
L12262:
    db        0
L12261:
    db        "retp/call underflow"
    db        0
L12260:
    db        "Proc not defined:"
    db        0
L12259:
    db        0
L12258:
    db        "Stack overflow"
    db        0
L12257:
    db        "# Call:   # # SP=# FP=#"
    db        0
L12256:
    db        "  "
    db        0
L12255:
    db        "<Fn ptr>"
    db        0
L12254:
    db        "  Loc: # used:#, addrof:#"
    db        0
L12253:
    db        "  Pm: # used:#, addrof:#"
    db        0
L12252:
    db        "  Hasblocks:#"
    db        0
L12251:
    db        "  MCLdone:  #"
    db        0
L12250:
    db        "  Assem:    #"
    db        0
L12249:
    db        "  Nmaxargs: #"
    db        0
L12248:
    db        "  Leaf:     #"
    db        0
L12247:
    db        "  Locals:   #"
    db        0
L12246:
    db        "  Params:   #"
    db        0
L12245:
    db        "PROC INFO FOR: #"
    db        0
L12244:
    db        " Has statics"
    db        0
L12243:
    db        ")"
    db        0
L12242:
    db        "H"
    db        0
L12241:
    db        ") (D:"
    db        0
L12240:
    db        " (Proc:"
    db        0
L12239:
    db        ")"
    db        0
L12238:
    db        " "
    db        0
L12237:
    db        " ("
    db        0
L12236:
    db        "H"
    db        0
L12235:
    db        " .PCADDR ="
    db        0
L12234:
    db        " ENTRY PT"
    db        0
L12233:
    db        " Dot"
    db        0
L12232:
    db        " TC"
    db        0
L12231:
    db        " Var:"
    db        0
L12230:
    db        " Imp"
    db        0
L12229:
    db        " Exp"
    db        0
L12228:
    db        " Loc:"
    db        0
L12227:
    db        " Pm:"
    db        0
L12226:
    db        " "
    db        0
L12225:
    db        "4"
    db        0
L12224:
    db        "21jl"
    db        0
L12223:
    db        "    "
    db        0
L12222:
    db        "21jl"
    db        0
L12221:
    db        "    "
    db        0
L12220:
    db        "25jl"
    db        0
L12219:
    db        " "
    db        0
L12218:
    db        "H"
    db        0
L12217:
    db        "PROC PC Symbol table"
    db        0
L12216:
    db        " "
    db        0
L12215:
    db        "  "
    db        0
L12214:
    db        "    data mem:"
    db        0
L12213:
    db        " "
    db        0
L12212:
    db        ":"
    db        0
L12211:
    db        "#"
    db        0
L12210:
    db        " "
    db        0
L12209:
    db        10
    db        0
L12208:
    db        " 1"
    db        0
L12207:
    db        "extproc    "
    db        0
L12206:
    db        34
    db        0
L12205:
    db        "addlib    "
    db        34
    db        0
L12204:
    db        "!PROC PCL"
    db        0
L12203:
    db        "<BIGSTR>"
    db        0
L12202:
    db        "<PCLOPND?>"
    db        0
L12201:
    db        "---------"
    db        0
L12200:
    db        "<Data * # (#)>"
    db        0
L12199:
    db        0
L12198:
    db        "#"
    db        0
L12197:
    db        "## "
    db        0
L12196:
    db        "&"
    db        0
L12195:
    db        ":"
    db        0
L12194:
    db        34
    db        0
L12193:
    db        "e16.16"
    db        0
L12192:
    db        "infinity"
    db        0
L12190:
    db        0
L12189:
    db        " "
    db        0
L12188:
    db        "/"
    db        0
L12187:
    db        " "
    db        0
L12186:
    db        "/"
    db        0
L12185:
    db        "set"
    db        0
L12184:
    db        "jump"
    db        0
L12183:
    db        "    "
    db        0
L12182:
    db        "endprog"
    db        0
L12181:
    db        "endproc"
    db        0
L12180:
    db        "    variadic"
    db        0
L12179:
    db        "    rettype  "
    db        0
L12178:
    db        "       "
    db        0
L12177:
    db        "    local    "
    db        0
L12176:
    db        "       "
    db        0
L12175:
    db        "    param    "
    db        0
L12174:
    db        ":"
    db        0
L12173:
    db        "::"
    db        0
L12172:
    db        " "
    db        0
L12171:
    db        "proc"
    db        0
L12170:
    db        "tcproc"
    db        0
L12169:
    db        "! - - -"
    db        0
L12168:
    db        "!"
    db        0
L12167:
    db        ":"
    db        0
L12166:
    db        "! "
    db        0
L12165:
    db        " NOT USED"
    db        0
L12164:
    db        "z2h"
    db        0
L12162:
    db        "MCL Error: # (#) on Line: # in #, PCL:#"
    db        0
L12161:
    db        "Proc:"
    db        0
L12160:
    db        "?"
    db        0
L12159:
    db        "FILENAME="
    db        0
L12158:
    db        "LINENO="
    db        0
L12157:
    db        "No proc"
    db        0
L12156:
    db        "Dupl proc:"
    db        0
L12155:
    db        "Nested proc"
    db        0
L12154:
    db        0
L12153:
    db        "Too many libs"
    db        0
L12152:
    db        "w"
    db        0
L12151:
    db        "$error.tmp"
    db        0
L12150:
    db        "."
    db        0
L12149:
    db        "*"
    db        0
L12148:
    db        "`"
    db        0
L12147:
    db        "PCL Error:"
    db        0
L12146:
    db        ":"
    db        0
L12145:
    db        "PCL error:"
    db        0
L12144:
    db        "---"
    db        0
L12143:
    db        "mem:"
    db        0
L12142:
    db        0
L12141:
    db        "dummy"
    db        0
L12140:
    db        "PHIGHMEM="
    db        0
L12139:
    db        "w"
    db        0
L12138:
    db        "Writing"
    db        0
L12137:
    db        "w"
    db        0
L12136:
    db        0
L12135:
    db        "Writing PST"
    db        0
L12134:
    db        0
L12133:
    db        "Writing PCL"
    db        0
L12132:
    db        "PCL start?"
    db        0
L12131:
    db        "PCL API"
    db        0
L12130:
    db        "C:@@@@"
    db        92
    db        "m"
    db        92
    db        34
    db        0
L12129:
    db        "wb"
    db        0
L12128:
    db        "con"
    db        0
L12127:
    db        "rb"
    db        0
L12126:
    db        "con"
    db        0
L12125:
    db        "W64"
    db        0
L12124:
    db        "Regclass error: %lld %lld"
    db        10
    db        0
L12122:
    db        "pcc001"
    db        0
L12120:
    db        "Winexec error: %lld"
    db        10
    db        0
L12115:
    db        "@file item too long"
    db        0
L12114:
    db        "Unexpected EOF in @file"
    db        0
L12113:
    db        "mcx"
    db        0
L12112:
    db        "dll"
    db        0
L12111:
    db        "Can't open"
    db        0
L12110:
    db        13
    db        0
L12109:
    db        10
    db        0
L12108:
    db        " "
    db        0
L12107:
    db        0
L12106:
    db        "."
    db        0
L12105:
    db        0
L12104:
    db        "."
    db        0
L12103:
    db        "line too long"
    db        0
L12102:
    db        "rb"
    db        0
L12101:
    db        "wb"
    db        0
L12100:
    db        "rb"
    db        0
L12099:
    db        "ABORTING: Press key..."
    db        0
L12098:
    db        "Realloc mem failure"
    db        0
L12097:
    db        "Alloc mem failure"
    db        0
L12096:
    db        "Can't alloc pc heap"
    db        0
L12095:
    db        "pcm_alloc failure"
    db        0
L12089:
    db        "%.*s"
    db        0
L12088:
    db        "MCL-UNIMPL: %s"
    db        10
    db        0
L12086:
    db        "%lf%n"
    db        0
L12084:
    db        "READ CMDLINE"
    db        0
L12082:
    db        "<mindint>"
    db        0
L12081:
    db        "1000000000000000000000000000000000000000000000000000000000000000"
    db        0
L12080:
    db        "8000000000000000"
    db        0
L12079:
    db        "9223372036854775808"
    db        0
L12078:
    db        "|"
    db        0
L12077:
    db        "%.*s"
    db        0
L12076:
    db        " "
    db        0
L12075:
    db        13
    db        10
    db        0
L12074:
    db        "PRTSL"
    db        0
L12073:
    db        "<null>"
    db        0
L12072:
    db        "%f"
    db        0
L12071:
    db        "%llu"
    db        0
L12070:
    db        "False"
    db        0
L12069:
    db        "True"
    db        0
L12068:
    db        "z8H"
    db        0
L12067:
    db        "Too many io levels"
    db        10
    db        0
L12066:
    db        "Too many params"
    db        10
    db        0
L12065:
    db        "kkcx2ichar"
    db        0
L12064:
    db        "kkax2slice"
    db        0
L12063:
    db        "kkichar2sl"
    db        0
L12062:
    db        "kksofttrun"
    db        0
L12061:
    db        "kkharderr"
    db        0
L12060:
    db        "kktoboolt"
    db        0
L12059:
    db        "kksoftconv"
    db        0
L12058:
    db        "kkfnarrow"
    db        0
L12057:
    db        "kkfwiden"
    db        0
L12056:
    db        "kkwiden"
    db        0
L12055:
    db        "kktruncate"
    db        0
L12054:
    db        "kkfix"
    db        0
L12053:
    db        "kkfloat"
    db        0
L12052:
    db        "kkerror"
    db        0
L12051:
    db        "linkdll"
    db        0
L12050:
    db        "$sourcepath"
    db        0
L12049:
    db        "import"
    db        0
L12048:
    db        "module"
    db        0
L12047:
    db        "clear"
    db        0
L12046:
    db        "$caligned"
    db        0
L12045:
    db        "od"
    db        0
L12044:
    db        "esac"
    db        0
L12043:
    db        "fi"
    db        0
L12042:
    db        "even"
    db        0
L12041:
    db        "odd"
    db        0
L12040:
    db        "lsw"
    db        0
L12039:
    db        "msw"
    db        0
L12038:
    db        "lsbit"
    db        0
L12037:
    db        "msbit"
    db        0
L12036:
    db        "lsb"
    db        0
L12035:
    db        "msb"
    db        0
L12034:
    db        "typestr"
    db        0
L12033:
    db        "bytes"
    db        0
L12032:
    db        "bitwidth"
    db        0
L12031:
    db        "bounds"
    db        0
L12030:
    db        "upb"
    db        0
L12029:
    db        "lwb"
    db        0
L12028:
    db        "len"
    db        0
L12027:
    db        "sliceptr"
    db        0
L12026:
    db        "fmod"
    db        0
L12025:
    db        "atan2"
    db        0
L12024:
    db        "ceil"
    db        0
L12023:
    db        "floor"
    db        0
L12022:
    db        "round"
    db        0
L12021:
    db        "exp"
    db        0
L12020:
    db        "log10"
    db        0
L12019:
    db        "log"
    db        0
L12018:
    db        "atan"
    db        0
L12017:
    db        "acos"
    db        0
L12016:
    db        "asin"
    db        0
L12015:
    db        "tan"
    db        0
L12014:
    db        "cos"
    db        0
L12013:
    db        "sin"
    db        0
L12012:
    db        "sign"
    db        0
L12011:
    db        "sqrt"
    db        0
L12010:
    db        "sqr"
    db        0
L12009:
    db        "abs"
    db        0
L12008:
    db        "istrue"
    db        0
L12007:
    db        "inot"
    db        0
L12006:
    db        "not"
    db        0
L12005:
    db        "max"
    db        0
L12004:
    db        "min"
    db        0
L12003:
    db        "divrem"
    db        0
L12002:
    db        "rem"
    db        0
L12001:
    db        "inrev"
    db        0
L12000:
    db        "notin"
    db        0
L11999:
    db        "in"
    db        0
L11998:
    db        "ixor"
    db        0
L11997:
    db        "ior"
    db        0
L11996:
    db        "iand"
    db        0
L11995:
    db        "xor"
    db        0
L11994:
    db        "or"
    db        0
L11993:
    db        "and"
    db        0
L11992:
    db        "$"
    db        0
L11991:
    db        "infinity"
    db        0
L11990:
    db        "false"
    db        0
L11989:
    db        "true"
    db        0
L11988:
    db        "pi"
    db        0
L11987:
    db        "nil"
    db        0
L11986:
    db        "$typename"
    db        0
L11985:
    db        "$version"
    db        0
L11984:
    db        "$time"
    db        0
L11983:
    db        "$date"
    db        0
L11982:
    db        "$function"
    db        0
L11981:
    db        "$modulename"
    db        0
L11980:
    db        "$filename"
    db        0
L11979:
    db        "$strlineno"
    db        0
L11978:
    db        "$lineno"
    db        0
L11977:
    db        "billion"
    db        0
L11976:
    db        "million"
    db        0
L11975:
    db        "slice"
    db        0
L11974:
    db        "label"
    db        0
L11973:
    db        "bool8"
    db        0
L11972:
    db        "bool"
    db        0
L11971:
    db        "bool64"
    db        0
L11970:
    db        "c64"
    db        0
L11969:
    db        "c8"
    db        0
L11968:
    db        "char"
    db        0
L11967:
    db        "u64"
    db        0
L11966:
    db        "u32"
    db        0
L11965:
    db        "u16"
    db        0
L11964:
    db        "u8"
    db        0
L11963:
    db        "byte"
    db        0
L11962:
    db        "r64"
    db        0
L11961:
    db        "r32"
    db        0
L11960:
    db        "i64"
    db        0
L11959:
    db        "i32"
    db        0
L11958:
    db        "i16"
    db        0
L11957:
    db        "i8"
    db        0
L11956:
    db        "ivoid"
    db        0
L11955:
    db        "ichar"
    db        0
L11954:
    db        "real"
    db        0
L11953:
    db        "word"
    db        0
L11952:
    db        "int"
    db        0
L11951:
    db        "void"
    db        0
L11950:
    db        "swap"
    db        0
L11949:
    db        "export"
    db        0
L11948:
    db        "global"
    db        0
L11947:
    db        "unless"
    db        0
L11946:
    db        "project"
    db        0
L11945:
    db        "importdll"
    db        0
L11944:
    db        "$getprocaddr"
    db        0
L11943:
    db        "$getprocname"
    db        0
L11942:
    db        "$getnprocs"
    db        0
L11941:
    db        "const"
    db        0
L11940:
    db        "static"
    db        0
L11939:
    db        "asm"
    db        0
L11938:
    db        "assem"
    db        0
L11937:
    db        "macro"
    db        0
L11936:
    db        "strinclude"
    db        0
L11935:
    db        "sinclude"
    db        0
L11934:
    db        "binclude"
    db        0
L11933:
    db        "include"
    db        0
L11932:
    db        "let"
    db        0
L11931:
    db        "var"
    db        0
L11930:
    db        "ref"
    db        0
L11929:
    db        "union"
    db        0
L11928:
    db        "struct"
    db        0
L11927:
    db        "record"
    db        0
L11926:
    db        "type"
    db        0
L11925:
    db        "threadedproc"
    db        0
L11924:
    db        "fun"
    db        0
L11923:
    db        "proc"
    db        0
L11922:
    db        "func"
    db        0
L11921:
    db        "function"
    db        0
L11920:
    db        "cast"
    db        0
L11919:
    db        "readln"
    db        0
L11918:
    db        "read"
    db        0
L11917:
    db        "cpl"
    db        0
L11916:
    db        "cp"
    db        0
L11915:
    db        "fprintln"
    db        0
L11914:
    db        "fprint"
    db        0
L11913:
    db        "println"
    db        0
L11912:
    db        "print"
    db        0
L11911:
    db        "eval"
    db        0
L11910:
    db        "clamp"
    db        0
L11909:
    db        "enumdata"
    db        0
L11908:
    db        "tabledata"
    db        0
L11907:
    db        "doswitchx"
    db        0
L11906:
    db        "doswitchu"
    db        0
L11905:
    db        "doswitch"
    db        0
L11904:
    db        "switch"
    db        0
L11903:
    db        "goto"
    db        0
L11902:
    db        "exit"
    db        0
L11901:
    db        "nextloop"
    db        0
L11900:
    db        "redoloop"
    db        0
L11899:
    db        "stop"
    db        0
L11898:
    db        "return"
    db        0
L11897:
    db        "until"
    db        0
L11896:
    db        "repeat"
    db        0
L11895:
    db        "while"
    db        0
L11894:
    db        "end"
    db        0
L11893:
    db        "do"
    db        0
L11892:
    db        "by"
    db        0
L11891:
    db        "downto"
    db        0
L11890:
    db        "to"
    db        0
L11889:
    db        "for"
    db        0
L11888:
    db        "when"
    db        0
L11887:
    db        "recase"
    db        0
L11886:
    db        "docase"
    db        0
L11885:
    db        "case"
    db        0
L11884:
    db        "elseswitch"
    db        0
L11883:
    db        "elsecase"
    db        0
L11882:
    db        "dummyelse"
    db        0
L11881:
    db        "else"
    db        0
L11880:
    db        "elsif"
    db        0
L11879:
    db        "then"
    db        0
L11878:
    db        "if"
    db        0
L11877:
    db        "kkmaxval"
    db        0
L11876:
    db        "kkminval"
    db        0
L11875:
    db        "kktypestr"
    db        0
L11874:
    db        "kkbytesize"
    db        0
L11873:
    db        "kkbitwidth"
    db        0
L11872:
    db        "kkbounds"
    db        0
L11871:
    db        "kkupb"
    db        0
L11870:
    db        "kklwb"
    db        0
L11869:
    db        "kklen"
    db        0
L11868:
    db        "kksliceptr"
    db        0
L11867:
    db        "linkid"
    db        0
L11866:
    db        "macroparamid"
    db        0
L11865:
    db        "macroid"
    db        0
L11864:
    db        "labelid"
    db        0
L11863:
    db        "fieldid"
    db        0
L11862:
    db        "paramid"
    db        0
L11861:
    db        "frameid"
    db        0
L11860:
    db        "staticid"
    db        0
L11859:
    db        "constid"
    db        0
L11858:
    db        "dllvarid"
    db        0
L11857:
    db        "dllprocid"
    db        0
L11856:
    db        "procid"
    db        0
L11855:
    db        "typeid"
    db        0
L11854:
    db        "dllmoduleid"
    db        0
L11853:
    db        "moduleid"
    db        0
L11852:
    db        "subprogid"
    db        0
L11851:
    db        "programid"
    db        0
L11850:
    db        "nullid"
    db        0
L11849:
    db        "Byref "
    db        0
L11848:
    db        "Byval "
    db        0
L11847:
    db        "Export"
    db        0
L11846:
    db        "Program"
    db        0
L11845:
    db        "Global"
    db        0
L11844:
    db        "Local"
    db        0
L11843:
    db        "hdr_linkdll"
    db        0
L11842:
    db        "hdr_sourcepath"
    db        0
L11841:
    db        "hdr_import"
    db        0
L11840:
    db        "hdr_module"
    db        0
L11839:
    db        "ksyscallsym"
    db        0
L11838:
    db        "kassemsym"
    db        0
L11837:
    db        "kswapsym"
    db        0
L11836:
    db        "kclampsym"
    db        0
L11835:
    db        "ktabledatasym"
    db        0
L11834:
    db        "kevalsym"
    db        0
L11833:
    db        "dollarsym"
    db        0
L11832:
    db        "compilervarsym"
    db        0
L11831:
    db        "kcastsym"
    db        0
L11830:
    db        "kstaticsym"
    db        0
L11829:
    db        "kglobalsym"
    db        0
L11828:
    db        "kheadersym"
    db        0
L11827:
    db        "kclearsym"
    db        0
L11826:
    db        "kconstsym"
    db        0
L11825:
    db        "kmacrosym"
    db        0
L11824:
    db        "kslicesym"
    db        0
L11823:
    db        "kletsym"
    db        0
L11822:
    db        "kvarsym"
    db        0
L11821:
    db        "kvoidsym"
    db        0
L11820:
    db        "krefsym"
    db        0
L11819:
    db        "ktypesym"
    db        0
L11818:
    db        "kprojectsym"
    db        0
L11817:
    db        "kimportmodulesym"
    db        0
L11816:
    db        "kunionsym"
    db        0
L11815:
    db        "kstructsym"
    db        0
L11814:
    db        "krecordsym"
    db        0
L11813:
    db        "klabelsym"
    db        0
L11812:
    db        "kfunctionsym"
    db        0
L11811:
    db        "kprocsym"
    db        0
L11810:
    db        "kreadsym"
    db        0
L11809:
    db        "kprintsym"
    db        0
L11808:
    db        "kdoswitchsym"
    db        0
L11807:
    db        "kswitchsym"
    db        0
L11806:
    db        "kgotosym"
    db        0
L11805:
    db        "kloopsym"
    db        0
L11804:
    db        "kstopsym"
    db        0
L11803:
    db        "kreturnsym"
    db        0
L11802:
    db        "kuntilsym"
    db        0
L11801:
    db        "krepeatsym"
    db        0
L11800:
    db        "kwhilesym"
    db        0
L11799:
    db        "kdosym"
    db        0
L11798:
    db        "kbysym"
    db        0
L11797:
    db        "ktosym"
    db        0
L11796:
    db        "kforsym"
    db        0
L11795:
    db        "kwhensym"
    db        0
L11794:
    db        "krecasesym"
    db        0
L11793:
    db        "kdocasesym"
    db        0
L11792:
    db        "kcasesym"
    db        0
L11791:
    db        "kunlesssym"
    db        0
L11790:
    db        "kendsym"
    db        0
L11789:
    db        "kelseswitchsym"
    db        0
L11788:
    db        "kelsecasesym"
    db        0
L11787:
    db        "kelsesym"
    db        0
L11786:
    db        "kelsifsym"
    db        0
L11785:
    db        "kthensym"
    db        0
L11784:
    db        "kifsym"
    db        0
L11783:
    db        "kicharsym"
    db        0
L11782:
    db        "stdtypesym"
    db        0
L11781:
    db        "asmopcodesym"
    db        0
L11780:
    db        "segnamesym"
    db        0
L11779:
    db        "movccsym"
    db        0
L11778:
    db        "setccsym"
    db        0
L11777:
    db        "jmpccsym"
    db        0
L11776:
    db        "mregsym"
    db        0
L11775:
    db        "fregsym"
    db        0
L11774:
    db        "xregsym"
    db        0
L11773:
    db        "regsym"
    db        0
L11772:
    db        "kstrincludesym"
    db        0
L11771:
    db        "kincludesym"
    db        0
L11770:
    db        "namesym"
    db        0
L11769:
    db        "unitnamesym"
    db        0
L11768:
    db        "stringconstsym"
    db        0
L11767:
    db        "charconstsym"
    db        0
L11766:
    db        "realconstsym"
    db        0
L11765:
    db        "intconstsym"
    db        0
L11764:
    db        "incrsym"
    db        0
L11763:
    db        "rawxnamesym"
    db        0
L11762:
    db        "eofsym"
    db        0
L11761:
    db        "eolsym"
    db        0
L11760:
    db        "bitfieldsym"
    db        0
L11759:
    db        "maths2opsym"
    db        0
L11758:
    db        "mathsopsym"
    db        0
L11757:
    db        "propsym"
    db        0
L11756:
    db        "sqr"
    db        0
L11755:
    db        "sqrt"
    db        0
L11754:
    db        "sign"
    db        0
L11753:
    db        "abs"
    db        0
L11752:
    db        "inot"
    db        0
L11751:
    db        "istrue"
    db        0
L11750:
    db        "not"
    db        0
L11749:
    db        "inrev"
    db        0
L11748:
    db        "notin"
    db        0
L11747:
    db        "in"
    db        0
L11746:
    db        "**"
    db        0
L11745:
    db        "cmp"
    db        0
L11744:
    db        "="
    db        0
L11743:
    db        "xor"
    db        0
L11742:
    db        "or"
    db        0
L11741:
    db        "and"
    db        0
L11740:
    db        "max"
    db        0
L11739:
    db        "min"
    db        0
L11738:
    db        ">>"
    db        0
L11737:
    db        "<<"
    db        0
L11736:
    db        "ixor"
    db        0
L11735:
    db        "ior"
    db        0
L11734:
    db        "iand"
    db        0
L11733:
    db        "divrem"
    db        0
L11732:
    db        "rem"
    db        0
L11731:
    db        "%"
    db        0
L11730:
    db        "/"
    db        0
L11729:
    db        "*"
    db        0
L11728:
    db        "-"
    db        0
L11727:
    db        "+"
    db        0
L11726:
    db        "#"
    db        0
L11725:
    db        "..."
    db        0
L11724:
    db        ".."
    db        0
L11723:
    db        "&&"
    db        0
L11722:
    db        "&"
    db        0
L11721:
    db        "?"
    db        0
L11720:
    db        "@"
    db        0
L11719:
    db        "|"
    db        0
L11718:
    db        "^"
    db        0
L11717:
    db        "}"
    db        0
L11716:
    db        "{"
    db        0
L11715:
    db        "]"
    db        0
L11714:
    db        "["
    db        0
L11713:
    db        ")"
    db        0
L11712:
    db        "("
    db        0
L11711:
    db        "->"
    db        0
L11710:
    db        "=>"
    db        0
L11709:
    db        ":="
    db        0
L11708:
    db        ":"
    db        0
L11707:
    db        ";"
    db        0
L11706:
    db        ","
    db        0
L11705:
    db        "&."
    db        0
L11704:
    db        "."
    db        0
L11703:
    db        "prop_op"
    db        0
L11702:
    db        "mon_op"
    db        0
L11701:
    db        "bin_op"
    db        0
L11700:
    db        "no_op"
    db        0
L11699:
    db        "bf_even"
    db        0
L11698:
    db        "bf_odd"
    db        0
L11697:
    db        "bf_lsw"
    db        0
L11696:
    db        "bf_msw"
    db        0
L11695:
    db        "bf_lsbit"
    db        0
L11694:
    db        "bf_msbit"
    db        0
L11693:
    db        "bf_lsb"
    db        0
L11692:
    db        "bf_msb"
    db        0
L11691:
    db        "jclear"
    db        0
L11690:
    db        "jeval"
    db        0
L11689:
    db        "jstop"
    db        0
L11688:
    db        "jreadln"
    db        0
L11687:
    db        "jread"
    db        0
L11686:
    db        "jfprintln"
    db        0
L11685:
    db        "jfprint"
    db        0
L11684:
    db        "jprintln"
    db        0
L11683:
    db        "jprint"
    db        0
L11682:
    db        "jrecase"
    db        0
L11681:
    db        "jselect"
    db        0
L11680:
    db        "jswap"
    db        0
L11679:
    db        "jdoswitchx"
    db        0
L11678:
    db        "jdoswitchu"
    db        0
L11677:
    db        "jdoswitch"
    db        0
L11676:
    db        "jswitch"
    db        0
L11675:
    db        "jdocase"
    db        0
L11674:
    db        "jcase"
    db        0
L11673:
    db        "jdo"
    db        0
L11672:
    db        "jexit"
    db        0
L11671:
    db        "jnext"
    db        0
L11670:
    db        "jredo"
    db        0
L11669:
    db        "jlabeldef"
    db        0
L11668:
    db        "jgoto"
    db        0
L11667:
    db        "jrepeat"
    db        0
L11666:
    db        "jwhile"
    db        0
L11665:
    db        "jforallrev"
    db        0
L11664:
    db        "jforall"
    db        0
L11663:
    db        "jfordown"
    db        0
L11662:
    db        "jforup"
    db        0
L11661:
    db        "jif"
    db        0
L11660:
    db        "jto"
    db        0
L11659:
    db        "jsyscall"
    db        0
L11658:
    db        "jreturn"
    db        0
L11657:
    db        "jspace"
    db        0
L11656:
    db        "jnogap"
    db        0
L11655:
    db        "jfmtitem"
    db        0
L11654:
    db        "jwhenthen"
    db        0
L11653:
    db        "jcvfalse"
    db        0
L11652:
    db        "jcvtrue"
    db        0
L11651:
    db        "jcvinfinity"
    db        0
L11650:
    db        "jcvpi"
    db        0
L11649:
    db        "jcvnil"
    db        0
L11648:
    db        "jcvtypename"
    db        0
L11647:
    db        "jcvversion"
    db        0
L11646:
    db        "jcvtime"
    db        0
L11645:
    db        "jcvdate"
    db        0
L11644:
    db        "jcvfunction"
    db        0
L11643:
    db        "jcvfilename"
    db        0
L11642:
    db        "jcvmodulename"
    db        0
L11641:
    db        "jcvstrlineno"
    db        0
L11640:
    db        "jcvlineno"
    db        0
L11639:
    db        "jmaxvalue"
    db        0
L11638:
    db        "jminvalue"
    db        0
L11637:
    db        "jbitfield"
    db        0
L11636:
    db        "jtypestr"
    db        0
L11635:
    db        "jbytesize"
    db        0
L11634:
    db        "jbitwidth"
    db        0
L11633:
    db        "jupper"
    db        0
L11632:
    db        "joperator"
    db        0
L11631:
    db        "jtypeconst"
    db        0
L11630:
    db        "jtypepun"
    db        0
L11629:
    db        "jautocast"
    db        0
L11628:
    db        "jshorten"
    db        0
L11627:
    db        "jconvert"
    db        0
L11626:
    db        "jdaddrvv"
    db        0
L11625:
    db        "jaddroffirst"
    db        0
L11624:
    db        "jaddrof"
    db        0
L11623:
    db        "jptrlv"
    db        0
L11622:
    db        "jptr"
    db        0
L11621:
    db        "jdotslice"
    db        0
L11620:
    db        "jdotindex"
    db        0
L11619:
    db        "jdotlv"
    db        0
L11618:
    db        "jdot"
    db        0
L11617:
    db        "jslice"
    db        0
L11616:
    db        "jindexlv"
    db        0
L11615:
    db        "jindex"
    db        0
L11614:
    db        "jstringz"
    db        0
L11613:
    db        "jinset"
    db        0
L11612:
    db        "jinrange"
    db        0
L11611:
    db        "jinrev"
    db        0
L11610:
    db        "jin"
    db        0
L11609:
    db        "jincr"
    db        0
L11608:
    db        "junaryto"
    db        0
L11607:
    db        "jbinto"
    db        0
L11606:
    db        "jprop"
    db        0
L11605:
    db        "junary"
    db        0
L11604:
    db        "jbin"
    db        0
L11603:
    db        "jcmpchain"
    db        0
L11602:
    db        "jcmp"
    db        0
L11601:
    db        "jcall"
    db        0
L11600:
    db        "jassignmdrem"
    db        0
L11599:
    db        "jassignms"
    db        0
L11598:
    db        "jassignmm"
    db        0
L11597:
    db        "jassign"
    db        0
L11596:
    db        "jkeyvalue"
    db        0
L11595:
    db        "jkeyword"
    db        0
L11594:
    db        "jreturnmult"
    db        0
L11593:
    db        "jmakeslice"
    db        0
L11592:
    db        "jmakedict"
    db        0
L11591:
    db        "jmakeset"
    db        0
L11590:
    db        "jmakerange"
    db        0
L11589:
    db        "jmakelist"
    db        0
L11588:
    db        "jisfalsel"
    db        0
L11587:
    db        "jistruel"
    db        0
L11586:
    db        "jnotl"
    db        0
L11585:
    db        "jorl"
    db        0
L11584:
    db        "jandl"
    db        0
L11583:
    db        "jsourceline"
    db        0
L11582:
    db        "jstrinclude"
    db        0
L11581:
    db        "jassemmem"
    db        0
L11580:
    db        "jassemxreg"
    db        0
L11579:
    db        "jassemreg"
    db        0
L11578:
    db        "jassemmacro"
    db        0
L11577:
    db        "jassem"
    db        0
L11576:
    db        "jdecimal"
    db        0
L11575:
    db        "jblock"
    db        0
L11574:
    db        "jnamelv"
    db        0
L11573:
    db        "jname"
    db        0
L11572:
    db        "jvoidvar"
    db        0
L11571:
    db        "jnull"
    db        0
L11570:
    db        "jconst"
    db        0
L11569:
    db        "jnone"
    db        0
L11568:
    db        "sf_unimpl"
    db        0
L11567:
    db        "sf_power_i64"
    db        0
L11566:
    db        "sf_getprocaddr"
    db        0
L11565:
    db        "sf_getprocname"
    db        0
L11564:
    db        "sf_getnprocs"
    db        0
L11563:
    db        "sf_read_conline"
    db        0
L11562:
    db        "sf_read_strline"
    db        0
L11561:
    db        "sf_read_fileline"
    db        0
L11560:
    db        "sf_read_str"
    db        0
L11559:
    db        "sf_read_r64"
    db        0
L11558:
    db        "sf_read_i64"
    db        0
L11557:
    db        "sf_print_end"
    db        0
L11556:
    db        "sf_print_newline"
    db        0
L11555:
    db        "sf_print_bool"
    db        0
L11554:
    db        "sf_print_c8"
    db        0
L11553:
    db        "sf_print_ptr_nf"
    db        0
L11552:
    db        "sf_print_ptr"
    db        0
L11551:
    db        "sf_print_strsl"
    db        0
L11550:
    db        "sf_print_str_nf"
    db        0
L11549:
    db        "sf_print_str"
    db        0
L11548:
    db        "sf_print_r32"
    db        0
L11547:
    db        "sf_print_r64"
    db        0
L11546:
    db        "sf_print_u64"
    db        0
L11545:
    db        "sf_print_i64_nf"
    db        0
L11544:
    db        "sf_print_i64"
    db        0
L11543:
    db        "sf_print_space"
    db        0
L11542:
    db        "sf_print_nogap"
    db        0
L11541:
    db        "sf_print_setfmt"
    db        0
L11540:
    db        "sf_print_startcon"
    db        0
L11539:
    db        "sf_print_startptr"
    db        0
L11538:
    db        "sf_print_startstr"
    db        0
L11537:
    db        "sf_print_startfile"
    db        0
L11536:
    db        "sf_init"
    db        0
L11535:
    db        "last "
    db        0
L11534:
    db        "block"
    db        0
L11533:
    db        "pend"
    db        0
L11532:
    db        "tuple"
    db        0
L11531:
    db        "bitfl"
    db        0
L11530:
    db        "type"
    db        0
L11529:
    db        "label"
    db        0
L11528:
    db        "proc"
    db        0
L11527:
    db        "any"
    db        0
L11526:
    db        "auto"
    db        0
L11525:
    db        "refbit"
    db        0
L11524:
    db        "ichar"
    db        0
L11523:
    db        "u32"
    db        0
L11522:
    db        "u16"
    db        0
L11521:
    db        "u8"
    db        0
L11520:
    db        "i32"
    db        0
L11519:
    db        "i16"
    db        0
L11518:
    db        "i8"
    db        0
L11517:
    db        "b8"
    db        0
L11516:
    db        "c8"
    db        0
L11515:
    db        "slice"
    db        0
L11514:
    db        "array"
    db        0
L11513:
    db        "range"
    db        0
L11512:
    db        "rec"
    db        0
L11511:
    db        "ref"
    db        0
L11510:
    db        "bool64"
    db        0
L11509:
    db        "c64"
    db        0
L11508:
    db        "u64"
    db        0
L11507:
    db        "i64"
    db        0
L11506:
    db        "r32"
    db        0
L11505:
    db        "r64"
    db        0
L11504:
    db        "void"
    db        0
L11503:
    db        "Dec"
    db        0
L11502:
    db        "Nov"
    db        0
L11501:
    db        "Oct"
    db        0
L11500:
    db        "Sep"
    db        0
L11499:
    db        "Aug"
    db        0
L11498:
    db        "Jul"
    db        0
L11497:
    db        "Jun"
    db        0
L11496:
    db        "May"
    db        0
L11495:
    db        "Apr"
    db        0
L11494:
    db        "Mar"
    db        0
L11493:
    db        "Feb"
    db        0
L11492:
    db        "Jan"
    db        0
L11491:
    db        "m"
    db        0
L11490:
    db        "type dll0_int=ref function:int"
    db        10
    db        "type dll1_int=ref function(int)int"
    db        10
    db        "type dll2_int=ref function(int,int)int"
    db        10
    db        "type dll3_int=ref function(int,int,int)int"
    db        10
    db        "type dll4_int=ref function(int,int,int,int)int"
    db        10
    db        "type dll5_int=ref function(int,int,int,int,int)int"
    db        10
    db        "type dll6_int=ref function(int,int,int,int,int,int)int"
    db        10
    db        "type dll8_int=ref function(int,int,int,int, int,int,int,int)int"
    db        10
    db        "type dll9_int=ref function(int,int,int,int, int,int,int,int, int)int"
    db        10
    db        "type dll10_int=ref function(int,int,int,int, int,int,int,int, int,int)int"
    db        10
    db        "type dll11_int=ref function(int,int,int,int, int,int,int,int, int,int,int)int"
    db        10
    db        "type dll12_int=ref function(int,int,int,int, int,int,int,int, int,int,int,int)int"
    db        10
    db        "type dll14_int=ref function(int,int,int,int, int,int,int,int, int,int,int,int, int,int)int"
    db        10
    db        10
    db        "type dll0_r64=ref function:r64"
    db        10
    db        "type dll1_r64=ref function(int)r64"
    db        10
    db        "type dll2_r64=ref function(int,int)r64"
    db        10
    db        10
    db        "type dll0_r64x=ref function:r64"
    db        10
    db        "type dll1_r64x=ref function(real)r64"
    db        10
    db        "type dll2_r64x=ref function(real,real)r64"
    db        10
    db        10
    db        "type m_dll0_int=ref function:int"
    db        10
    db        "type m_dll1_int=ref function(int)int"
    db        10
    db        "type m_dll2_int=ref function(int,int)int"
    db        10
    db        "type m_dll3_int=ref function(int,int,int)int"
    db        10
    db        "type m_dll4_int=ref function(int,int,int,int)int"
    db        10
    db        "type m_dll5_int=ref function(int,int,int,int,int)int"
    db        10
    db        "type m_dll12_int=ref function(int,int,int,int, int,int,int,int, int,int,int,int)int"
    db        10
    db        10
    db        "type m_dll0_r64=ref function:r64"
    db        10
    db        "type m_dll1_r64=ref function(int)r64"
    db        10
    db        "type m_dll2_r64=ref function(int,int)r64"
    db        10
    db        10
    db        10
    db        "export function os_calldllfunction(ref proc fnaddr,"
    db        10
    db        9
    db        9
    db        "int retcode, nargs, ref[]i64 args, ref[]byte argcodes)u64 ="
    db        10
    db        "!retcode is 'R' or 'I'"
    db        10
    db        "!each argcodes element is 'R' or 'I' too"
    db        10
    db        "!The x64 version can work with any combination."
    db        10
    db        "!Here, for C, only some combinations are dealt with:"
    db        10
    db        "! I result, params all I (not all param counts)"
    db        10
    db        "! R result, params all I (not all param counts)"
    db        10
    db        "!Mixed params, for arbitrary return type, not handled (not really detected either)"
    db        10
    db        10
    db        9
    db        "u64 a"
    db        10
    db        9
    db        "r64 x"
    db        10
    db        9
    db        "int oddstack, nextra, pushedbytes"
    db        10
    db        10
    db        "!CPL "
    db        34
    db        "/////CCCCCCCCCCCCCCCCCC"
    db        34
    db        10
    db        10
    db        9
    db        "if retcode='I' then"
    db        10
    db        9
    db        9
    db        "return calldll_cint(fnaddr,args,nargs)"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "return calldll_creal(fnaddr,args,nargs)"
    db        10
    db        9
    db        "fi"
    db        10
    db        "end"
    db        9
    db        10
    db        10
    db        "global function os_pushargs(ref[]u64 args, int nargs, nextra,"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "ref proc fnaddr, int isfloat)u64="
    db        10
    db        9
    db        "u64 a"
    db        10
    db        9
    db        "r64 x"
    db        10
    db        "!ABORTPROGRAM("
    db        34
    db        "PUSHARGS/C NOT READY"
    db        34
    db        ")"
    db        10
    db        10
    db        9
    db        "return os_calldllfunction(fnaddr, (isfloat|0|'I'), nargs, cast(args), nil)"
    db        10
    db        10
    db        10
    db        "!"
    db        9
    db        "return a"
    db        10
    db        "end"
    db        10
    db        10
    db        "function calldll_cint (ref proc fnaddr,ref[]i64 params,int nparams)i64="
    db        10
    db        "switch nparams"
    db        10
    db        "when 0 then"
    db        10
    db        9
    db        "return dll0_int(fnaddr)^()"
    db        10
    db        "when 1 then"
    db        10
    db        9
    db        "return dll1_int(fnaddr)^(params^[1])"
    db        10
    db        "when 2 then"
    db        10
    db        9
    db        "return dll2_int(fnaddr)^(params^[1],params^[2])"
    db        10
    db        "when 3 then"
    db        10
    db        9
    db        "return dll3_int(fnaddr)^(params^[1],params^[2],params^[3])"
    db        10
    db        "when 4 then"
    db        10
    db        9
    db        "return dll4_int(fnaddr)^(params^[1],params^[2],params^[3],"
    db        10
    db        9
    db        9
    db        9
    db        "params^[4])"
    db        10
    db        "when 5 then"
    db        10
    db        9
    db        "return dll5_int(fnaddr)^(params^[1],params^[2],params^[3],"
    db        10
    db        9
    db        9
    db        9
    db        "params^[4], params^[5])"
    db        10
    db        "when 6 then"
    db        10
    db        9
    db        "return dll6_int(fnaddr)^(params^[1],params^[2],params^[3],"
    db        10
    db        9
    db        9
    db        9
    db        "params^[4], params^[5],params^[6])"
    db        10
    db        "when 8 then "
    db        10
    db        9
    db        "return (dll8_int(fnaddr))^(params^[1],params^[2],params^[3],params^[4],"
    db        9
    db        "params^[5],params^[6],"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "params^[7],params^[8])"
    db        10
    db        "when 9 then "
    db        10
    db        9
    db        "return (dll9_int(fnaddr))^(params^[1],params^[2],params^[3],params^[4],"
    db        9
    db        "params^[5],params^[6],"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "params^[7],params^[8],params^[9])"
    db        10
    db        "when 10 then "
    db        10
    db        9
    db        "return (dll10_int(fnaddr))^(params^[1],params^[2],params^[3],params^[4],"
    db        9
    db        "params^[5],params^[6],"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "params^[7],params^[8],params^[9],params^[10])"
    db        10
    db        "when 11 then "
    db        10
    db        9
    db        "return (dll11_int(fnaddr))^(params^[1],params^[2],params^[3],params^[4],"
    db        9
    db        "params^[5],params^[6],"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "params^[7],params^[8],params^[9],params^[10],"
    db        9
    db        "params^[11])"
    db        10
    db        10
    db        "when 12 then "
    db        10
    db        9
    db        "return (dll12_int(fnaddr))^(params^[1],params^[2],params^[3],params^[4],"
    db        9
    db        "params^[5],params^[6],"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "params^[7],params^[8],params^[9],params^[10],"
    db        9
    db        "params^[11],params^[12])"
    db        10
    db        10
    db        "!when 14 then "
    db        10
    db        "!"
    db        9
    db        "return (dll14_int(fnaddr))^(params^[1],params^[2],params^[3],params^[4],"
    db        9
    db        "params^[5],params^[6],"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "params^[7],params^[8],params^[9],params^[10],"
    db        9
    db        "params^[11],params^[12],"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "params^[13],params^[14])"
    db        10
    db        "!"
    db        10
    db        "else"
    db        10
    db        9
    db        "cpl nparams"
    db        10
    db        9
    db        "println "
    db        34
    db        "calldll/c/int unsupported # of params"
    db        34
    db        ", nparams"
    db        10
    db        9
    db        "stop 1"
    db        10
    db        "end switch"
    db        10
    db        "return 0"
    db        10
    db        "end"
    db        10
    db        10
    db        "function calldll_creal (ref proc fnaddr,ref[]i64 params,int nparams)i64="
    db        10
    db        "r64 x"
    db        10
    db        10
    db        "switch nparams"
    db        10
    db        "when 0 then"
    db        10
    db        9
    db        "return dll0_r64(fnaddr)^()"
    db        10
    db        "when 1 then"
    db        10
    db        9
    db        "os_dummycall(params^[1],params^[2],params^[3],params^[4])"
    db        10
    db        9
    db        "x:=dll1_r64(fnaddr)^(params^[1])"
    db        10
    db        "when 2 then"
    db        10
    db        9
    db        "x:=dll2_r64(fnaddr)^(params^[1],params^[2])"
    db        10
    db        "else"
    db        10
    db        9
    db        "println "
    db        34
    db        "calldll/c/real too many params"
    db        34
    db        10
    db        9
    db        "stop 1"
    db        10
    db        "end switch"
    db        10
    db        "return i64@(x)"
    db        10
    db        "end"
    db        10
    db        10
    db        10
    db        "global proc os_dummycall(r64 a,b,c,d)="
    db        10
    db        "end"
    db        10
    db        0
L11489:
    db        "export function os_calldllfunction("
    db        10
    db        9
    db        "ref proc fnaddr,"
    db        10
    db        9
    db        "int retcode, nargs,"
    db        10
    db        9
    db        "ref[]i64 args,"
    db        10
    db        9
    db        "ref[]byte argcodes)u64 ="
    db        10
    db        10
    db        9
    db        "u64 a"
    db        10
    db        9
    db        "r64 x"
    db        10
    db        9
    db        "int nextra := 0, pushedbytes"
    db        10
    db        10
    db        "!Stack is 16-byte aligned at this point"
    db        10
    db        10
    db        9
    db        "if nargs<4 then"
    db        10
    db        9
    db        9
    db        "nextra:=4-nargs"
    db        9
    db        9
    db        9
    db        "!need at least 4 slots for shadow space"
    db        10
    db        9
    db        "elsif nargs.odd then"
    db        9
    db        9
    db        "!need one more for a 16-byte-aligned stack"
    db        10
    db        9
    db        9
    db        "nextra:=1"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "pushedbytes:=(nextra+nargs)*8"
    db        10
    db        10
    db        9
    db        "to nextra do"
    db        10
    db        9
    db        9
    db        "asm push 0"
    db        10
    db        9
    db        "od"
    db        10
    db        10
    db        9
    db        "for i:=nargs downto 1 do"
    db        10
    db        9
    db        9
    db        "a:=args[i]"
    db        9
    db        9
    db        9
    db        9
    db        "!get generic 64-bit value to push"
    db        10
    db        9
    db        9
    db        "asm push u64 [a]"
    db        10
    db        9
    db        "od"
    db        10
    db        10
    db        "! blindly load first 4 args to both int/float regs, whether used or not,"
    db        10
    db        "! and assuming calling a variadic function whether it is or not"
    db        10
    db        10
    db        9
    db        "assem"
    db        10
    db        9
    db        9
    db        "mov D10,   [Dstack]"
    db        10
    db        9
    db        9
    db        "movq XMM0, [Dstack]"
    db        10
    db        9
    db        9
    db        "mov D11,   [Dstack+8]"
    db        10
    db        9
    db        9
    db        "movq XMM1, [Dstack+8]"
    db        10
    db        9
    db        9
    db        "mov D12,   [Dstack+16]"
    db        10
    db        9
    db        9
    db        "movq XMM2, [Dstack+16]"
    db        10
    db        9
    db        9
    db        "mov D13,   [Dstack+24]"
    db        10
    db        9
    db        9
    db        "movq XMM3, [Dstack+24]"
    db        10
    db        9
    db        "end"
    db        10
    db        10
    db        9
    db        "if retcode='I' then"
    db        10
    db        9
    db        9
    db        "a:=(ref func:i64(fnaddr))^()"
    db        10
    db        9
    db        9
    db        "asm add Dstack,[pushedbytes]"
    db        10
    db        9
    db        9
    db        "return a"
    db        10
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "x:=(ref func:r64(fnaddr))^()"
    db        10
    db        9
    db        9
    db        "asm add Dstack,[pushedbytes]"
    db        10
    db        9
    db        9
    db        "return u64@(x)"
    db        9
    db        9
    db        9
    db        "!(type-punning cast)"
    db        10
    db        10
    db        9
    db        "fi"
    db        10
    db        "end"
    db        9
    db        10
    db        0
L11488:
    db        "!import clib"
    db        10
    db        "!import mlib"
    db        10
    db        "!"
    db        10
    db        "!importlib cstd="
    db        10
    db        "!"
    db        9
    db        "clang proc     sleep"
    db        9
    db        "(word32)"
    db        10
    db        "!end"
    db        10
    db        10
    db        "record termios ="
    db        10
    db        9
    db        "i32 c_iflag"
    db        10
    db        9
    db        "i32 c_oflag"
    db        10
    db        9
    db        "i32 c_cflag"
    db        10
    db        9
    db        "i32 c_lflag"
    db        10
    db        9
    db        "char c_line"
    db        10
    db        9
    db        "[32]char c_cc"
    db        9
    db        9
    db        9
    db        9
    db        "!at offset 17"
    db        10
    db        9
    db        "[3]byte filler"
    db        10
    db        9
    db        "i32 c_ispeed"
    db        9
    db        9
    db        9
    db        9
    db        "!at offset 52"
    db        10
    db        9
    db        "i32 c_ospeed"
    db        10
    db        "end"
    db        10
    db        10
    db        "!importdll dlstuff="
    db        10
    db        "importdll msvcrt="
    db        10
    db        9
    db        "func dlopen"
    db        9
    db        9
    db        9
    db        "(ichar, i32)ref void"
    db        10
    db        9
    db        "func dlsym"
    db        9
    db        9
    db        9
    db        "(ref void, ichar)ref void"
    db        10
    db        9
    db        "func tcgetattr"
    db        9
    db        9
    db        "(i32, ref termios) i32"
    db        10
    db        9
    db        "func tcsetattr"
    db        9
    db        9
    db        "(i32, i32, ref termios) i32"
    db        10
    db        9
    db        "func gettimeofday"
    db        9
    db        "(ref timeval, ref void) i32"
    db        10
    db        9
    db        "func gmtime_r  "
    db        9
    db        "   (ref i64, ref tm_rec) ref void"
    db        10
    db        9
    db        "proc stdin"
    db        10
    db        9
    db        "proc stdout"
    db        10
    db        "end"
    db        10
    db        " "
    db        10
    db        "record timeval ="
    db        10
    db        9
    db        "i64 tv_sec"
    db        10
    db        9
    db        "i64 tv_usec"
    db        10
    db        "end"
    db        10
    db        10
    db        "record tm_rec ="
    db        10
    db        9
    db        "i32 tm_sec"
    db        10
    db        9
    db        "i32 tm_min"
    db        10
    db        9
    db        "i32 tm_hour"
    db        10
    db        9
    db        "i32 tm_mday"
    db        10
    db        10
    db        9
    db        "i32 tm_mon"
    db        10
    db        9
    db        "i32 tm_year"
    db        10
    db        9
    db        "i32 tm_wday"
    db        10
    db        9
    db        "i32 tm_yday"
    db        10
    db        9
    db        "i32 tm_isdst"
    db        10
    db        9
    db        "[20]byte padding"
    db        10
    db        "end"
    db        10
    db        10
    db        "!this record is used by some apps, so these fields must be present"
    db        10
    db        "export record rsystemtime ="
    db        10
    db        9
    db        "i32 year"
    db        10
    db        9
    db        "i32 month"
    db        10
    db        9
    db        "i32 dayofweek"
    db        10
    db        9
    db        "i32 day"
    db        10
    db        9
    db        "i32 hour"
    db        10
    db        9
    db        "i32 minute"
    db        10
    db        9
    db        "i32 second"
    db        10
    db        9
    db        "int milliseconds"
    db        10
    db        "end"
    db        10
    db        10
    db        "int init_flag=0"
    db        10
    db        10
    db        10
    db        "export proc os_init="
    db        10
    db        9
    db        "init_flag:=1"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_execwait(ichar cmdline,int newconsole=0,ichar workdir=nil)int ="
    db        10
    db        9
    db        "return system(cmdline)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_execcmd(ichar cmdline, int newconsole)int ="
    db        10
    db        9
    db        "return system(cmdline)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_getch:int="
    db        10
    db        9
    db        "const ICANON  = 2"
    db        10
    db        9
    db        "const ECHO    = 8"
    db        10
    db        9
    db        "const TCSANOW = 0"
    db        10
    db        9
    db        "const ISIG    = 1"
    db        10
    db        10
    db        9
    db        "termios old,new"
    db        10
    db        9
    db        "char ch"
    db        10
    db        10
    db        9
    db        "tcgetattr(0,&old)"
    db        10
    db        9
    db        "new:=old"
    db        10
    db        9
    db        "new.c_lflag iand:=inot ICANON"
    db        10
    db        9
    db        "new.c_lflag iand:=inot ECHO"
    db        10
    db        9
    db        "new.c_lflag iand:=inot ISIG"
    db        10
    db        10
    db        9
    db        "tcsetattr(0,TCSANOW,&new)"
    db        10
    db        10
    db        9
    db        "ch:=getchar()"
    db        10
    db        10
    db        9
    db        "tcsetattr(0,TCSANOW,&old)"
    db        10
    db        10
    db        9
    db        "return ch"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_kbhit:int="
    db        10
    db        9
    db        "abortprogram("
    db        34
    db        "kbhit"
    db        34
    db        ")"
    db        10
    db        9
    db        "return 0"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc os_flushkeys="
    db        10
    db        9
    db        "abortprogram("
    db        34
    db        "flushkeys"
    db        34
    db        ")"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_getconsolein:ref void="
    db        10
    db        9
    db        "return nil"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_getconsoleout:ref void="
    db        10
    db        9
    db        "return nil"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_proginstance:ref void="
    db        10
    db        9
    db        "abortprogram("
    db        34
    db        "PROGINST"
    db        34
    db        ")"
    db        10
    db        9
    db        "return nil"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_getdllinst(ichar name)u64="
    db        10
    db        9
    db        "const RTLD_LAZY=1"
    db        10
    db        9
    db        "ref void h"
    db        10
    db        10
    db        9
    db        "h:=dlopen(name,RTLD_LAZY)"
    db        10
    db        10
    db        9
    db        "if h=nil then"
    db        10
    db        9
    db        9
    db        "if strcmp(name,"
    db        34
    db        "msvcrt"
    db        34
    db        ")=0 then"
    db        9
    db        9
    db        9
    db        "!might be linux"
    db        10
    db        9
    db        9
    db        9
    db        "h:=dlopen("
    db        34
    db        "libc.so.6"
    db        34
    db        ",RTLD_LAZY);"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "return cast(h)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_getdllprocaddr(int hlib,ichar name)ref void="
    db        10
    db        9
    db        "ref void fnaddr"
    db        10
    db        10
    db        9
    db        "if hlib=0 then"
    db        10
    db        9
    db        9
    db        "return nil"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "fnaddr:=dlsym(cast(int(hlib)), name)"
    db        10
    db        9
    db        "return fnaddr"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc os_initwindows="
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_getchx:int="
    db        10
    db        9
    db        "abortprogram("
    db        34
    db        "getchx"
    db        34
    db        ")"
    db        10
    db        9
    db        "return 0"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_getos=>ichar="
    db        10
    db        "!"
    db        9
    db        "if $targetbits=32 then"
    db        10
    db        "!"
    db        9
    db        9
    db        "return "
    db        34
    db        "L32"
    db        34
    db        10
    db        "!"
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "return "
    db        34
    db        "L64"
    db        34
    db        10
    db        "!"
    db        9
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_gethostsize=>int="
    db        10
    db        9
    db        "return 64"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_iswindows:int="
    db        10
    db        9
    db        "return 0"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_shellexec(ichar opc, file)int="
    db        10
    db        9
    db        "abortprogram("
    db        34
    db        "SHELL EXEC"
    db        34
    db        ")"
    db        10
    db        9
    db        "return 0"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc  os_sleep(int a)="
    db        10
    db        "!*!"
    db        9
    db        "sleep(a)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_getstdin:filehandle ="
    db        10
    db        9
    db        "ref filehandle pf:=cast(stdin)"
    db        10
    db        9
    db        "return pf^"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_getstdout:filehandle ="
    db        10
    db        9
    db        "ref filehandle pf:=cast(stdout)"
    db        10
    db        9
    db        "return pf^"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_gethostname:ichar="
    db        10
    db        "!"
    db        9
    db        "abortprogram("
    db        34
    db        "gethostname"
    db        34
    db        ")"
    db        10
    db        9
    db        "return "
    db        34
    db        34
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_getmpath:ichar="
    db        10
    db        "!"
    db        9
    db        "abortprogram("
    db        34
    db        "getmpath"
    db        34
    db        ")"
    db        10
    db        9
    db        "return "
    db        34
    db        34
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc os_exitprocess(int x)="
    db        10
    db        9
    db        "stop"
    db        10
    db        "!"
    db        9
    db        "_exit(0)"
    db        10
    db        "!"
    db        9
    db        "ExitProcess(x)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_clock:i64="
    db        10
    db        9
    db        "if os_iswindows() then"
    db        10
    db        9
    db        9
    db        "return clock()"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "return clock()/1000"
    db        10
    db        9
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_ticks:i64="
    db        10
    db        9
    db        "return clock()"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_getclockspersec:i64="
    db        10
    db        9
    db        "return (os_iswindows()|1000|1000'000)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc os_setmesshandler(ref void addr)="
    db        10
    db        9
    db        "abortprogram("
    db        34
    db        "SETMESSHANDLER"
    db        34
    db        ")"
    db        10
    db        "!"
    db        9
    db        "wndproc_callbackfn:=addr"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_hpcounter:i64="
    db        10
    db        9
    db        "return 1"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_hpfrequency:i64="
    db        10
    db        9
    db        "return 1"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_filelastwritetime(ichar filename)i64="
    db        10
    db        9
    db        "return 0"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc os_getsystime(ref rsystemtime tm)="
    db        10
    db        9
    db        "timeval tv"
    db        10
    db        9
    db        "tm_rec tmr"
    db        10
    db        10
    db        10
    db        9
    db        "gettimeofday(&tv, nil)"
    db        10
    db        9
    db        "gmtime_r(&tv.tv_sec, &tmr)"
    db        10
    db        10
    db        9
    db        "tm.year := tmr.tm_year + 1900"
    db        10
    db        9
    db        "tm.month := tmr.tm_mon + 1"
    db        10
    db        9
    db        "tm.dayofweek := tmr.tm_wday + 1"
    db        10
    db        9
    db        "tm.day := tmr.tm_mday"
    db        10
    db        9
    db        "tm.hour := tmr.tm_hour"
    db        10
    db        9
    db        "tm.minute := tmr.tm_min"
    db        10
    db        9
    db        "tm.second := tmr.tm_sec"
    db        10
    db        9
    db        "tm.milliseconds := tv.tv_usec/1000"
    db        10
    db        "tm.month:=1"
    db        9
    db        9
    db        9
    db        "!avoid crashing the M compiler"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc os_peek="
    db        10
    db        "end"
    db        10
    db        10
    db        "export func  os_allocexecmem(int n)ref byte="
    db        10
    db        9
    db        "abortprogram("
    db        34
    db        "No allocexec"
    db        34
    db        ")"
    db        10
    db        9
    db        "nil"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func dirlist(ichar filespec, ref[]ichar dest, int capacity, t=1)int="
    db        10
    db        9
    db        "0"
    db        10
    db        "end"
    db        10
    db        0
L11487:
    db        "const wm_destroy=2"
    db        10
    db        10
    db        "export type wt_word"
    db        9
    db        "= u16"
    db        10
    db        "export type wt_wordpm"
    db        9
    db        "= u32"
    db        10
    db        "export type wt_bool"
    db        9
    db        "= u32"
    db        10
    db        "export type wt_dword"
    db        9
    db        "= u32"
    db        10
    db        "export type wt_wchar"
    db        9
    db        "= u16"
    db        10
    db        "export type wt_wcharpm"
    db        9
    db        "= u32"
    db        10
    db        "export type wt_char"
    db        9
    db        "= byte"
    db        10
    db        "export type wt_ichar"
    db        9
    db        "= ref char"
    db        10
    db        "export type wt_ptr"
    db        9
    db        9
    db        "= ref void"
    db        10
    db        "export type wt_wndproc"
    db        9
    db        "= ref proc"
    db        10
    db        "export type wt_handle"
    db        9
    db        "= ref void"
    db        10
    db        "export type wt_int"
    db        9
    db        9
    db        "= i32"
    db        10
    db        "export type wt_uint"
    db        9
    db        "= u32"
    db        10
    db        "export type wt_long"
    db        9
    db        "= i32"
    db        10
    db        "export type wt_wparam"
    db        9
    db        "= word"
    db        10
    db        "export type wt_lparam"
    db        9
    db        "= word"
    db        10
    db        "export type wt_point"
    db        9
    db        "= rpoint"
    db        10
    db        10
    db        "export record rsystemtime ="
    db        10
    db        9
    db        "wt_word year"
    db        10
    db        9
    db        "wt_word month"
    db        10
    db        9
    db        "wt_word dayofweek"
    db        10
    db        9
    db        "wt_word day"
    db        10
    db        9
    db        "wt_word hour"
    db        10
    db        9
    db        "wt_word minute"
    db        10
    db        9
    db        "wt_word second"
    db        10
    db        9
    db        "wt_word milliseconds"
    db        10
    db        "end"
    db        10
    db        10
    db        "importdll $windowsdlls="
    db        10
    db        "!"
    db        9
    db        "func "
    db        34
    db        "VirtualAlloc"
    db        34
    db        "(wt_ptr, dint,wt_dword,wt_dword)wt_ptr"
    db        10
    db        9
    db        "func "
    db        34
    db        "GetStdHandle"
    db        34
    db        "(wt_dword)wt_handle"
    db        10
    db        9
    db        "func "
    db        34
    db        "GetConsoleScreenBufferInfo"
    db        34
    db        "(wt_handle,wt_ptr)int"
    db        10
    db        9
    db        "func "
    db        34
    db        "SetConsoleCtrlHandler"
    db        34
    db        "(wt_wndproc,int)int"
    db        10
    db        9
    db        "func "
    db        34
    db        "SetConsoleMode"
    db        34
    db        "(wt_handle,wt_dword)int"
    db        10
    db        9
    db        "func "
    db        34
    db        "CreateProcessA"
    db        34
    db        "(wt_ichar,wt_ichar,wt_ptr,wt_ptr, int,"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "wt_dword, wt_ptr,wt_ichar,wt_ptr,wt_ptr)int"
    db        10
    db        9
    db        "func "
    db        34
    db        "GetLastError"
    db        34
    db        ":wt_dword"
    db        10
    db        9
    db        "func "
    db        34
    db        "WaitForSingleObject"
    db        34
    db        "(wt_handle,wt_dword)wt_dword"
    db        10
    db        9
    db        "func "
    db        34
    db        "GetExitCodeProcess"
    db        34
    db        "(wt_handle,wt_ptr)int"
    db        10
    db        9
    db        "func "
    db        34
    db        "CloseHandle"
    db        34
    db        "(wt_handle)int"
    db        10
    db        9
    db        "func "
    db        34
    db        "GetNumberOfConsoleInputEvents"
    db        34
    db        "(wt_handle,wt_ptr)int"
    db        10
    db        9
    db        "func "
    db        34
    db        "FlushConsoleInputBuffer"
    db        34
    db        "(wt_handle)int"
    db        10
    db        9
    db        "func "
    db        34
    db        "LoadLibraryA"
    db        34
    db        "(wt_ichar)wt_handle"
    db        10
    db        "!"
    db        9
    db        "func "
    db        34
    db        "GetProcAddress"
    db        34
    db        "(wt_handle,wt_ichar)wt_wndproc"
    db        10
    db        9
    db        "func "
    db        34
    db        "GetProcAddress"
    db        34
    db        "(wt_handle,wt_ichar)ref void"
    db        10
    db        9
    db        "func "
    db        34
    db        "LoadCursorA"
    db        34
    db        "(wt_handle,wt_ichar)wt_handle"
    db        10
    db        9
    db        "func "
    db        34
    db        "RegisterClassExA"
    db        34
    db        "(wt_ptr)wt_wordpm"
    db        10
    db        9
    db        "func "
    db        34
    db        "DefWindowProcA"
    db        34
    db        "(wt_handle,wt_uint,wt_wparam,wt_lparam)int"
    db        10
    db        9
    db        "func "
    db        34
    db        "ReadConsoleInputA"
    db        34
    db        "(wt_handle,wt_ptr,wt_dword,wt_ptr)int"
    db        10
    db        9
    db        "proc "
    db        34
    db        "Sleep"
    db        34
    db        "(wt_dword)"
    db        10
    db        9
    db        "func "
    db        34
    db        "GetModuleFileNameA"
    db        34
    db        "(wt_handle,wt_ichar,wt_dword)wt_dword"
    db        10
    db        10
    db        9
    db        "proc "
    db        34
    db        "ExitProcess"
    db        34
    db        "(wt_uint)"
    db        10
    db        9
    db        "proc "
    db        34
    db        "PostQuitMessage"
    db        34
    db        "(wt_int)"
    db        10
    db        10
    db        9
    db        "proc "
    db        34
    db        "MessageBoxA"
    db        34
    db        "(wt_int x=0,wt_ichar message, caption="
    db        34
    db        "Caption"
    db        34
    db        ",wt_int y=0)"
    db        10
    db        10
    db        9
    db        "func "
    db        34
    db        "QueryPerformanceCounter"
    db        34
    db        "(ref i64)wt_bool"
    db        10
    db        9
    db        "func "
    db        34
    db        "QueryPerformanceFrequency"
    db        34
    db        "(ref i64)wt_bool"
    db        10
    db        10
    db        9
    db        "func "
    db        34
    db        "CreateFileA"
    db        34
    db        "(wt_ichar,wt_dword,wt_dword,wt_ptr,wt_dword,wt_dword,wt_handle)wt_handle"
    db        10
    db        9
    db        "func "
    db        34
    db        "GetFileTime"
    db        34
    db        "(wt_handle,wt_ptr,wt_ptr,wt_ptr)wt_bool"
    db        10
    db        10
    db        9
    db        "proc "
    db        34
    db        "GetSystemTime"
    db        34
    db        "(ref rsystemtime)"
    db        10
    db        9
    db        "proc "
    db        34
    db        "GetLocalTime"
    db        34
    db        "(ref rsystemtime)"
    db        10
    db        10
    db        9
    db        "func "
    db        34
    db        "GetTickCount64"
    db        34
    db        ":u64"
    db        10
    db        9
    db        "func "
    db        34
    db        "PeekMessageA"
    db        34
    db        9
    db        9
    db        "(ref void, ref wt_handle, wt_uint,wt_uint,wt_uint)wt_bool"
    db        10
    db        10
    db        9
    db        "func "
    db        34
    db        "GetCommandLineA"
    db        34
    db        ":ichar"
    db        10
    db        10
    db        9
    db        "func "
    db        34
    db        "VirtualAlloc"
    db        34
    db        " (ref void, wt_dword, wt_dword, wt_dword)ref void"
    db        10
    db        9
    db        "func "
    db        34
    db        "VirtualProtect"
    db        34
    db        " (ref void, wt_dword, wt_dword, ref wt_dword)wt_bool"
    db        10
    db        10
    db        9
    db        "func "
    db        34
    db        "WriteConsoleA"
    db        34
    db        " (ref void, ref void, i32, ref i32, ref void)wt_bool"
    db        10
    db        10
    db        9
    db        "func "
    db        34
    db        "FindFirstFileA"
    db        34
    db        " (wt_ichar,ref rfinddata)wt_handle"
    db        10
    db        9
    db        "func "
    db        34
    db        "FindNextFileA"
    db        34
    db        "  (wt_handle, ref rfinddata)wt_bool"
    db        10
    db        9
    db        "func "
    db        34
    db        "FindClose"
    db        34
    db        "      (wt_handle)wt_bool"
    db        10
    db        10
    db        9
    db        "func "
    db        34
    db        "MessageBeep"
    db        34
    db        "    (i32)wt_bool"
    db        10
    db        9
    db        "func "
    db        34
    db        "Beep"
    db        34
    db        "    (i32 freq, dur)wt_bool"
    db        10
    db        "end"
    db        10
    db        10
    db        "record input_record = $caligned"
    db        10
    db        9
    db        "wt_word"
    db        9
    db        "eventtype"
    db        10
    db        "!"
    db        9
    db        "u16"
    db        9
    db        "padding"
    db        10
    db        9
    db        9
    db        "wt_bool"
    db        9
    db        "keydown"
    db        9
    db        9
    db        9
    db        "!key event record (was inside 'Event' union in win32)"
    db        10
    db        9
    db        9
    db        "wt_word"
    db        9
    db        "repeatcount"
    db        10
    db        9
    db        9
    db        "wt_word"
    db        9
    db        "virtualkeycode"
    db        10
    db        9
    db        9
    db        "wt_word"
    db        9
    db        "virtualscancode"
    db        10
    db        9
    db        9
    db        "union"
    db        10
    db        9
    db        9
    db        9
    db        "wt_word unicodechar"
    db        10
    db        9
    db        9
    db        9
    db        "wt_char asciichar"
    db        10
    db        9
    db        9
    db        "end"
    db        10
    db        9
    db        9
    db        "wt_dword controlkeystate"
    db        10
    db        "end"
    db        10
    db        10
    db        "record rspoint=(i16 x,y)"
    db        10
    db        10
    db        "record rsrect="
    db        10
    db        9
    db        "i16 leftx,top,rightx,bottom"
    db        10
    db        "end"
    db        10
    db        10
    db        "global record rpoint ="
    db        10
    db        9
    db        "wt_long x,y"
    db        10
    db        "end"
    db        10
    db        10
    db        "record rconsole="
    db        10
    db        9
    db        "rspoint size,pos"
    db        10
    db        9
    db        "u16 attributes"
    db        10
    db        9
    db        "rsrect window"
    db        10
    db        9
    db        "rspoint maxwindowsize"
    db        10
    db        "end"
    db        10
    db        10
    db        "record rstartupinfo ="
    db        10
    db        9
    db        "wt_dword"
    db        9
    db        "size"
    db        10
    db        9
    db        "u32 dummy1"
    db        10
    db        9
    db        "wt_ichar"
    db        9
    db        "reserved"
    db        10
    db        9
    db        "wt_ichar"
    db        9
    db        "desktop"
    db        10
    db        9
    db        "wt_ichar"
    db        9
    db        "title"
    db        10
    db        9
    db        "wt_dword"
    db        9
    db        "x"
    db        10
    db        9
    db        "wt_dword"
    db        9
    db        "y"
    db        10
    db        9
    db        "wt_dword"
    db        9
    db        "xsize"
    db        10
    db        9
    db        "wt_dword"
    db        9
    db        "ysize"
    db        10
    db        9
    db        "wt_dword"
    db        9
    db        "xcountchars"
    db        10
    db        9
    db        "wt_dword"
    db        9
    db        "ycountchars"
    db        10
    db        9
    db        "wt_dword"
    db        9
    db        "fillattribute"
    db        10
    db        9
    db        "wt_dword"
    db        9
    db        "flags"
    db        10
    db        9
    db        "wt_word"
    db        9
    db        9
    db        "showwindow"
    db        10
    db        9
    db        "wt_word"
    db        9
    db        9
    db        "reserved2"
    db        10
    db        9
    db        "u32 dummy2"
    db        10
    db        9
    db        "wt_ptr"
    db        9
    db        9
    db        "reserved4"
    db        10
    db        9
    db        "wt_handle"
    db        9
    db        "stdinput"
    db        10
    db        9
    db        "wt_handle"
    db        9
    db        "stdoutput"
    db        10
    db        9
    db        "wt_handle"
    db        9
    db        "stderror"
    db        10
    db        "end"
    db        10
    db        10
    db        "record rprocess_information ="
    db        10
    db        9
    db        "wt_handle process"
    db        10
    db        9
    db        "wt_handle thread"
    db        10
    db        9
    db        "wt_dword processid"
    db        10
    db        9
    db        "wt_dword threadid"
    db        10
    db        "end"
    db        10
    db        10
    db        "record rwndclassex ="
    db        10
    db        9
    db        "wt_uint"
    db        9
    db        9
    db        "size"
    db        10
    db        9
    db        "wt_uint"
    db        9
    db        9
    db        "style"
    db        10
    db        9
    db        "wt_wndproc"
    db        9
    db        "wndproc"
    db        10
    db        9
    db        "wt_int"
    db        9
    db        9
    db        "clsextra"
    db        10
    db        9
    db        "wt_int"
    db        9
    db        9
    db        "wndextra"
    db        10
    db        9
    db        "wt_handle"
    db        9
    db        "instance"
    db        10
    db        9
    db        "wt_handle"
    db        9
    db        "icon"
    db        10
    db        9
    db        "wt_handle"
    db        9
    db        "cursor"
    db        10
    db        9
    db        "wt_handle"
    db        9
    db        "background"
    db        10
    db        9
    db        "wt_ichar"
    db        9
    db        "menuname"
    db        10
    db        9
    db        "wt_ichar"
    db        9
    db        "classname"
    db        10
    db        9
    db        "wt_handle"
    db        9
    db        "iconsm"
    db        10
    db        "end"
    db        10
    db        10
    db        "global record rmsg ="
    db        10
    db        9
    db        "wt_handle"
    db        9
    db        "hwnd"
    db        10
    db        9
    db        "wt_uint"
    db        9
    db        9
    db        "message"
    db        10
    db        9
    db        "u32"
    db        9
    db        9
    db        "dummy1"
    db        10
    db        9
    db        "wt_wparam"
    db        9
    db        "wParam"
    db        10
    db        9
    db        "wt_lparam"
    db        9
    db        "lParam"
    db        10
    db        9
    db        "wt_dword"
    db        9
    db        "time"
    db        10
    db        9
    db        "u32"
    db        9
    db        9
    db        "dummy2"
    db        10
    db        9
    db        "wt_point"
    db        9
    db        "pt"
    db        10
    db        "end"
    db        10
    db        10
    db        "record rfiletime ="
    db        10
    db        9
    db        "wt_dword lowdatetime"
    db        10
    db        9
    db        "wt_dword highdatetime"
    db        10
    db        "end"
    db        10
    db        10
    db        "record rfinddata ="
    db        10
    db        9
    db        "wt_dword"
    db        9
    db        "fileattributes"
    db        10
    db        9
    db        "rfiletime"
    db        9
    db        "creationtime"
    db        10
    db        9
    db        "rfiletime"
    db        9
    db        "lastaccesstime"
    db        10
    db        9
    db        "rfiletime"
    db        9
    db        "lastwritetime"
    db        10
    db        9
    db        "wt_dword"
    db        9
    db        "filesizehigh"
    db        10
    db        9
    db        "wt_dword"
    db        9
    db        "filesizelow"
    db        10
    db        9
    db        "wt_dword"
    db        9
    db        "reserved0"
    db        10
    db        9
    db        "wt_dword"
    db        9
    db        "reserved1"
    db        10
    db        9
    db        "[260]char"
    db        9
    db        "filename"
    db        10
    db        9
    db        "[14]char"
    db        9
    db        9
    db        "altfilename"
    db        10
    db        9
    db        "wt_dword"
    db        9
    db        "obs1, obs2"
    db        10
    db        9
    db        "wt_word"
    db        9
    db        9
    db        "obs3"
    db        10
    db        "end"
    db        10
    db        10
    db        "const NORMAL_PRIORITY_CLASS=32"
    db        10
    db        "const CREATE_NEW_CONSOLE=16"
    db        10
    db        "const DETACHED_PROCESS=16"
    db        10
    db        10
    db        "const MEM_COMMIT"
    db        9
    db        9
    db        9
    db        9
    db        "= 4096"
    db        10
    db        "const MEM_RESERVE"
    db        9
    db        9
    db        9
    db        9
    db        "= 8192"
    db        10
    db        "const PAGE_EXECUTE"
    db        9
    db        9
    db        9
    db        9
    db        "= 16"
    db        10
    db        "const PAGE_EXECUTE_READ"
    db        9
    db        9
    db        9
    db        "= 32"
    db        10
    db        "const PAGE_EXECUTE_READWRITE"
    db        9
    db        "= 64"
    db        10
    db        "const PAGE_NOACCESS"
    db        9
    db        9
    db        9
    db        9
    db        "= 1"
    db        10
    db        10
    db        10
    db        "export wt_handle hconsole, hconsolein"
    db        10
    db        10
    db        "input_record lastkey, pendkey"
    db        10
    db        "int keypending"
    db        9
    db        9
    db        9
    db        "!whether pendkey contains a new key event detected by flushkbd"
    db        10
    db        10
    db        "int hpfreq"
    db        9
    db        9
    db        9
    db        9
    db        "!counts per msec"
    db        10
    db        10
    db        10
    db        "ref func (ref void)int wndproc_callbackfn=nil"
    db        9
    db        "!windows call-back: address of handler"
    db        10
    db        10
    db        "int init_flag=0"
    db        10
    db        10
    db        "export proc os_init="
    db        10
    db        "!general initialisation"
    db        10
    db        9
    db        "hconsole:=GetStdHandle(u32(-11))"
    db        10
    db        9
    db        "hconsolein:=GetStdHandle(u32(-10))"
    db        10
    db        10
    db        9
    db        "lastkey.repeatcount:=0"
    db        10
    db        9
    db        "keypending:=0"
    db        10
    db        10
    db        9
    db        "SetConsoleCtrlHandler(nil,1)"
    db        10
    db        10
    db        9
    db        "SetConsoleMode(hconsole,1 ior 2)"
    db        10
    db        10
    db        9
    db        "init_flag:=1"
    db        10
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_execwait(ichar cmdline,int newconsole=0,ichar workdir=nil)int ="
    db        10
    db        9
    db        "wt_dword exitcode"
    db        10
    db        9
    db        "int status"
    db        10
    db        9
    db        "int cflags:=0"
    db        10
    db        10
    db        9
    db        "rstartupinfo si"
    db        10
    db        9
    db        "rprocess_information xpi"
    db        10
    db        10
    db        9
    db        "clear si"
    db        10
    db        9
    db        "clear xpi"
    db        10
    db        10
    db        9
    db        "case newconsole"
    db        10
    db        9
    db        "when 0 then cflags := NORMAL_PRIORITY_CLASS"
    db        10
    db        9
    db        "when 1 then cflags := NORMAL_PRIORITY_CLASS ior CREATE_NEW_CONSOLE"
    db        10
    db        9
    db        "when 2 then cflags := NORMAL_PRIORITY_CLASS ior DETACHED_PROCESS"
    db        10
    db        9
    db        "esac"
    db        10
    db        10
    db        9
    db        "si.size := rstartupinfo.bytes"
    db        10
    db        10
    db        9
    db        "status:=CreateProcessA("
    db        10
    db        9
    db        9
    db        "nil,"
    db        10
    db        9
    db        9
    db        "cmdline,"
    db        10
    db        9
    db        9
    db        "nil,"
    db        10
    db        10
    db        9
    db        9
    db        "nil,"
    db        10
    db        9
    db        9
    db        "1,"
    db        10
    db        9
    db        9
    db        "cflags,"
    db        10
    db        10
    db        9
    db        9
    db        "nil,"
    db        10
    db        9
    db        9
    db        "nil,"
    db        10
    db        9
    db        9
    db        "&si,"
    db        10
    db        9
    db        9
    db        "&xpi )"
    db        10
    db        10
    db        9
    db        "if status=0 then"
    db        9
    db        9
    db        "!fails"
    db        10
    db        9
    db        9
    db        "status:=GetLastError()"
    db        10
    db        9
    db        9
    db        "printf("
    db        34
    db        "Winexec error: %lld"
    db        92
    db        "n"
    db        34
    db        ",status)"
    db        10
    db        9
    db        9
    db        "return -1"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "WaitForSingleObject(xpi.process, 0xFFFF'FFFF)"
    db        10
    db        9
    db        "GetExitCodeProcess(xpi.process,&exitcode)"
    db        10
    db        10
    db        9
    db        "CloseHandle(xpi.process)"
    db        10
    db        9
    db        "CloseHandle(xpi.thread)"
    db        10
    db        10
    db        9
    db        "return exitcode"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_execcmd(ichar cmdline, int newconsole=0)int ="
    db        10
    db        9
    db        "rstartupinfo si"
    db        10
    db        9
    db        "rprocess_information xpi"
    db        10
    db        10
    db        9
    db        "clear si"
    db        10
    db        9
    db        "clear xpi"
    db        10
    db        10
    db        9
    db        "si.size := rstartupinfo.bytes"
    db        10
    db        10
    db        9
    db        "CreateProcessA( nil,"
    db        10
    db        9
    db        9
    db        "cmdline,"
    db        10
    db        9
    db        9
    db        "nil,"
    db        10
    db        9
    db        9
    db        "nil,"
    db        10
    db        9
    db        9
    db        "1,"
    db        10
    db        9
    db        9
    db        "NORMAL_PRIORITY_CLASS ior (newconsole|CREATE_NEW_CONSOLE|0),"
    db        10
    db        9
    db        9
    db        "nil,"
    db        10
    db        9
    db        9
    db        "nil,"
    db        10
    db        9
    db        9
    db        "&si,"
    db        10
    db        9
    db        9
    db        "&xpi )"
    db        10
    db        10
    db        9
    db        "CloseHandle(xpi.process)"
    db        10
    db        9
    db        "CloseHandle(xpi.thread)"
    db        10
    db        10
    db        9
    db        "return 1"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_getch:int="
    db        10
    db        9
    db        "int k"
    db        10
    db        10
    db        9
    db        "k:=os_getchx() iand 255"
    db        10
    db        10
    db        9
    db        "return k"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_kbhit:int="
    db        10
    db        9
    db        "wt_dword count"
    db        10
    db        10
    db        9
    db        "unless init_flag then os_init() end"
    db        10
    db        10
    db        9
    db        "GetNumberOfConsoleInputEvents(hconsolein,&count)"
    db        10
    db        9
    db        "return count>1"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_getdllinst(ichar name)u64="
    db        10
    db        9
    db        "wt_handle hinst"
    db        10
    db        10
    db        9
    db        "hinst:=LoadLibraryA(name)"
    db        10
    db        9
    db        "return cast(hinst)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_getdllprocaddr(int hinst,ichar name)ref void="
    db        10
    db        9
    db        "return GetProcAddress(cast(hinst),name)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc os_initwindows="
    db        10
    db        9
    db        "os_init()"
    db        10
    db        9
    db        "os_gxregisterclass("
    db        34
    db        "pcc001"
    db        34
    db        ")"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc os_gxregisterclass(ichar classname)="
    db        10
    db        9
    db        "const idcarrow=32512"
    db        10
    db        9
    db        "rwndclassex r"
    db        10
    db        9
    db        "static byte registered"
    db        10
    db        10
    db        9
    db        "if registered then"
    db        10
    db        9
    db        9
    db        "return"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "clear r"
    db        10
    db        10
    db        9
    db        "r.size:=r.bytes"
    db        10
    db        9
    db        "r.style:=8 ior 32"
    db        10
    db        9
    db        "r.wndproc:=cast(&mainwndproc)"
    db        10
    db        9
    db        "r.instance:=nil"
    db        10
    db        10
    db        9
    db        "r.icon:=nil"
    db        10
    db        9
    db        "r.cursor:=LoadCursorA(nil,ref void(idcarrow))"
    db        10
    db        9
    db        "r.background:=cast(15+1)"
    db        10
    db        9
    db        "r.menuname:=nil"
    db        10
    db        9
    db        "r.classname:=classname"
    db        10
    db        9
    db        "r.iconsm:=nil"
    db        10
    db        10
    db        9
    db        "if RegisterClassExA(&r)=0 then"
    db        10
    db        9
    db        9
    db        "printf("
    db        34
    db        "Regclass error: %lld %lld"
    db        92
    db        "n"
    db        34
    db        ",classname,GetLastError())"
    db        10
    db        9
    db        9
    db        "stop 1"
    db        10
    db        9
    db        "end"
    db        10
    db        9
    db        "registered:=1"
    db        10
    db        "end"
    db        10
    db        10
    db        "global function mainwndproc ("
    db        10
    db        9
    db        9
    db        "wt_handle hwnd, wt_uint message, wt_wparam wParam, wt_lparam lParam)int="
    db        10
    db        9
    db        "rmsg m"
    db        10
    db        9
    db        "int result"
    db        10
    db        9
    db        "static int count=0"
    db        10
    db        10
    db        "!CPL "
    db        34
    db        "MAINWNDPROC"
    db        34
    db        ",HWND"
    db        10
    db        10
    db        9
    db        "m.hwnd:=hwnd"
    db        10
    db        9
    db        "m.message:=message"
    db        10
    db        9
    db        "m.wParam:=wParam"
    db        10
    db        9
    db        "m.lParam:=lParam"
    db        10
    db        9
    db        "m.pt.x:=0"
    db        10
    db        9
    db        "m.pt.y:=0"
    db        10
    db        9
    db        10
    db        9
    db        "if (wndproc_callbackfn) then"
    db        10
    db        9
    db        9
    db        "result:=(wndproc_callbackfn^)(&m)"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "result:=0"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "if m.message=wm_destroy then"
    db        10
    db        9
    db        9
    db        "return 0"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "if not result then"
    db        10
    db        9
    db        9
    db        "return DefWindowProcA(hwnd,message,wParam,lParam)"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "return 0"
    db        10
    db        9
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc os_setmesshandler(ref void addr)="
    db        10
    db        9
    db        "wndproc_callbackfn:=addr"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_getchx:int="
    db        10
    db        "!Q! function  os_getchx_c:int"
    db        10
    db        "!return a 32-bit value containing:"
    db        10
    db        "! 15..B0:"
    db        9
    db        "char code"
    db        10
    db        "! 23..16"
    db        9
    db        "virtual keycode"
    db        10
    db        "! 31..24"
    db        9
    db        "shift flags (.[24]=shift, .[25]=ctrl, .[26]=alt, .[27]=capslock)"
    db        10
    db        9
    db        "const rightaltmask"
    db        9
    db        "= 1"
    db        10
    db        9
    db        "const leftaltmask"
    db        9
    db        "= 2"
    db        10
    db        9
    db        "const leftctrlmask"
    db        9
    db        "= 8"
    db        10
    db        9
    db        "const rightctrlmask"
    db        9
    db        "= 4"
    db        10
    db        9
    db        "const shiftmask"
    db        9
    db        9
    db        "= 16"
    db        10
    db        9
    db        "const capsmask"
    db        9
    db        9
    db        "= 128"
    db        10
    db        9
    db        "const scrollmask"
    db        9
    db        "= 64"
    db        10
    db        9
    db        "int count"
    db        10
    db        9
    db        "int charcode,keyshift,keycode"
    db        10
    db        9
    db        "int altdown,ctrldown,shiftdown,capslock"
    db        10
    db        10
    db        "!os_init() unless init_flag"
    db        10
    db        9
    db        "unless init_flag then os_init() end"
    db        10
    db        10
    db        9
    db        "if keypending then"
    db        10
    db        9
    db        9
    db        "lastkey:=pendkey"
    db        10
    db        9
    db        9
    db        "keypending:=0"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "if lastkey.repeatcount=0 then"
    db        10
    db        9
    db        9
    db        9
    db        "repeat"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "count:=0"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "ReadConsoleInputA(hconsolein,&lastkey,1,&count)"
    db        10
    db        9
    db        9
    db        9
    db        "until (lastkey.eventtype=1 and lastkey.keydown=1)"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        "!set shift flags"
    db        10
    db        10
    db        9
    db        "altdown"
    db        9
    db        9
    db        ":= ((lastkey.controlkeystate iand (leftaltmask ior rightaltmask))|1|0)"
    db        10
    db        9
    db        "ctrldown"
    db        9
    db        ":= ((lastkey.controlkeystate iand (leftctrlmask ior rightctrlmask))|1|0)"
    db        10
    db        9
    db        "shiftdown"
    db        9
    db        ":= ((lastkey.controlkeystate iand shiftmask)|1|0)"
    db        10
    db        9
    db        "capslock"
    db        9
    db        ":= ((lastkey.controlkeystate iand capsmask)|1|0)"
    db        10
    db        10
    db        9
    db        "--lastkey.repeatcount"
    db        9
    db        9
    db        "!count this key out"
    db        10
    db        10
    db        9
    db        "charcode:=lastkey.asciichar"
    db        10
    db        9
    db        "keycode:=lastkey.virtualkeycode iand 255"
    db        10
    db        10
    db        9
    db        "if charcode<0 then"
    db        10
    db        9
    db        9
    db        "if charcode<-128 then"
    db        10
    db        9
    db        9
    db        9
    db        "charcode:=0"
    db        10
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        "charcode+:=256"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        "!for keycodes in range 186 to 223, which are all stand-alone punctuation keys, I might"
    db        10
    db        "!wish to set charcode to the appropriate printed char code (currently charcode will be"
    db        10
    db        "!zero, and keyboard handlers need to detect keycodes such as vkequals)"
    db        10
    db        "!...."
    db        10
    db        10
    db        9
    db        "if altdown and ctrldown and charcode=166 then"
    db        10
    db        9
    db        9
    db        "altdown:=ctrldown:=0"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "if altdown or ctrldown then"
    db        10
    db        9
    db        9
    db        9
    db        "charcode:=0"
    db        10
    db        9
    db        9
    db        9
    db        "if keycode>='A' and keycode<= 'Z' then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "charcode:=keycode-'@'"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "keyshift:=capslock<<3 ior altdown<<2 ior ctrldown<<1 ior shiftdown"
    db        10
    db        10
    db        9
    db        "return keyshift<<24 ior keycode<<16 ior charcode"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_getos=>ichar="
    db        10
    db        9
    db        "return "
    db        34
    db        "W64"
    db        34
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_gethostsize=>int="
    db        10
    db        9
    db        "return 64"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_shellexec(ichar opc, file)int="
    db        10
    db        9
    db        "return system(file)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc os_sleep(int a)="
    db        10
    db        9
    db        "Sleep(a)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_getstdin:filehandle ="
    db        10
    db        9
    db        "return fopen("
    db        34
    db        "con"
    db        34
    db        ","
    db        34
    db        "rb"
    db        34
    db        ")"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_getstdout:filehandle ="
    db        10
    db        9
    db        "return fopen("
    db        34
    db        "con"
    db        34
    db        ","
    db        34
    db        "wb"
    db        34
    db        ")"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_gethostname:ichar="
    db        10
    db        9
    db        "static [300]char name"
    db        10
    db        9
    db        "static int n"
    db        10
    db        10
    db        9
    db        "GetModuleFileNameA(nil,&.name,name.bytes)"
    db        10
    db        9
    db        "return &.name"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_getmpath:ichar="
    db        10
    db        "!BART"
    db        10
    db        "!"
    db        9
    db        "return "
    db        34
    db        "C:"
    db        92
    db        92
    db        "m"
    db        92
    db        92
    db        34
    db        10
    db        9
    db        "return F"
    db        34
    db        "C:@@@@"
    db        92
    db        "m"
    db        92
    db        34
    db        " !ABC"
    db        10
    db        "!"
    db        9
    db        "return "
    db        34
    db        "C:@@@@"
    db        92
    db        92
    db        "m"
    db        92
    db        92
    db        34
    db        " !ABC"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_clock:i64="
    db        10
    db        "!"
    db        9
    db        "return clock()"
    db        10
    db        9
    db        "return os_hpcounter()"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_ticks:i64="
    db        10
    db        9
    db        "return GetTickCount64()"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_iswindows:int="
    db        10
    db        9
    db        "return 1"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc os_getsystime(ref rsystemtime tm)="
    db        10
    db        9
    db        "GetLocalTime(tm)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc os_peek="
    db        10
    db        9
    db        "int ticks"
    db        10
    db        9
    db        "static int lastticks"
    db        10
    db        9
    db        "[100]byte m"
    db        10
    db        9
    db        "ticks:=GetTickCount64()"
    db        10
    db        9
    db        "if ticks-lastticks>=1000 then"
    db        10
    db        9
    db        9
    db        "lastticks:=ticks"
    db        10
    db        9
    db        9
    db        "PeekMessageA(&m,nil,0,0,0)"
    db        10
    db        9
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_allocexecmem(int n)ref byte="
    db        10
    db        9
    db        "ref byte p"
    db        10
    db        9
    db        "u32 oldprot"
    db        10
    db        9
    db        "int status"
    db        10
    db        10
    db        9
    db        "p := VirtualAlloc(nil, n, MEM_RESERVE ior MEM_COMMIT, PAGE_NOACCESS)"
    db        10
    db        9
    db        "if p = nil then return nil fi"
    db        10
    db        10
    db        9
    db        "status := VirtualProtect(p, n, PAGE_EXECUTE_READWRITE, &oldprot)"
    db        10
    db        9
    db        "if status = 0 then return nil fi"
    db        10
    db        10
    db        9
    db        "return p"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func dirlist(ichar filespec, ref[]ichar dest, int capacity, t=1)int="
    db        10
    db        "!filespec is a filename (eg. "
    db        34
    db        "*.dwg"
    db        34
    db        ") with possible drive/path; scan"
    db        10
    db        "!directory for all matching files:"
    db        10
    db        "! Store each file in dest array up to capacity"
    db        10
    db        "! Return:"
    db        10
    db        "!  -1:"
    db        9
    db        "capacity exceeded"
    db        10
    db        "!   N:  number of files found including 0 for no matching files"
    db        10
    db        10
    db        "!t has this value"
    db        10
    db        "! +1  Include normal files only, no sub-directory names"
    db        10
    db        "! +2  Include directories"
    db        10
    db        "! +3  (+1 +2) Include all files including directories"
    db        10
    db        "! +4  Convert to lower case"
    db        10
    db        9
    db        "ref void hfind"
    db        10
    db        9
    db        "rfinddata file"
    db        10
    db        9
    db        "int nfiles:=0"
    db        10
    db        9
    db        "[300]char path"
    db        10
    db        9
    db        "[300]char fullfilename"
    db        10
    db        10
    db        9
    db        "strcpy(path, extractpath(filespec))"
    db        10
    db        10
    db        10
    db        9
    db        "if (hfind:=findfirstfilea(filespec,&file))<>ref void(-1) then"
    db        9
    db        "!at least one file"
    db        10
    db        9
    db        9
    db        "repeat"
    db        10
    db        9
    db        9
    db        9
    db        "if (file.fileattributes iand 16) then"
    db        9
    db        9
    db        "!this is a directory"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "if (t iand 2)=0 then nextloop fi"
    db        9
    db        9
    db        "!no directories"
    db        10
    db        9
    db        9
    db        9
    db        "else"
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "!this is a file"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "if (t iand 1)=0 then nextloop fi"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        "if nfiles>=capacity then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "nfiles:=-1"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "exit"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        9
    db        9
    db        "if (t iand 4) then"
    db        9
    db        9
    db        9
    db        9
    db        "!to lower case"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "convlcstring(file.filename)"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "convlcstring(&.file.filename)"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        "strcpy(fullfilename, path)"
    db        10
    db        9
    db        9
    db        9
    db        "strcat(fullfilename, file.filename)"
    db        10
    db        10
    db        9
    db        9
    db        9
    db        "dest[++nfiles]:=pcm_copyheapstring(fullfilename)"
    db        10
    db        10
    db        9
    db        9
    db        "until not findnextfilea(hfind,&file)"
    db        10
    db        9
    db        9
    db        "findclose(hfind)"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "return nfiles"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_hpcounter:int a ="
    db        10
    db        "!return counter such that successive calls indicate duration in msec"
    db        10
    db        10
    db        9
    db        "if hpfreq=0 then"
    db        10
    db        9
    db        9
    db        "hpfreq:=os_hpfreq()/1000"
    db        9
    db        9
    db        "!counts per msec"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "QueryPerformanceCounter(&a)"
    db        10
    db        9
    db        "a/hpfreq"
    db        10
    db        "end"
    db        10
    db        10
    db        "export func os_hpfreq:int a ="
    db        10
    db        9
    db        "QueryPerformanceFrequency(&a)"
    db        10
    db        9
    db        "a"
    db        10
    db        "end"
    db        10
    db        10
    db        0
L11486:
    db        "export type filehandle=ref void"
    db        10
    db        10
    db        "importdll $cstd="
    db        10
    db        9
    db        "func malloc"
    db        9
    db        9
    db        "(u64)ref void"
    db        10
    db        9
    db        "func realloc"
    db        9
    db        "(ref void, word)ref void"
    db        10
    db        9
    db        "proc free"
    db        9
    db        9
    db        "(ref void)"
    db        10
    db        9
    db        "proc memset"
    db        9
    db        9
    db        "(ref void, i32, word)"
    db        10
    db        9
    db        "proc memcpy"
    db        9
    db        9
    db        "(ref void, ref void, word)"
    db        10
    db        9
    db        "proc memmove"
    db        9
    db        9
    db        "(ref void, ref void, word)"
    db        10
    db        9
    db        "func clock"
    db        9
    db        9
    db        ":i32"
    db        10
    db        9
    db        "func ftell"
    db        9
    db        9
    db        "(filehandle)i32"
    db        10
    db        9
    db        "func fseek"
    db        9
    db        9
    db        "(filehandle, i32, i32)i32"
    db        10
    db        9
    db        "func fread"
    db        9
    db        9
    db        "(ref void, word, word, filehandle)word"
    db        10
    db        9
    db        "func fwrite"
    db        9
    db        9
    db        "(ref void, word, word, filehandle)word"
    db        10
    db        9
    db        "func getc"
    db        9
    db        9
    db        "(filehandle)i32"
    db        10
    db        9
    db        "func ungetc"
    db        9
    db        9
    db        "(i32, filehandle)i32"
    db        10
    db        9
    db        "func fopen"
    db        9
    db        9
    db        "(ichar a, b="
    db        34
    db        "rb"
    db        34
    db        ")filehandle"
    db        10
    db        9
    db        "func fclose"
    db        9
    db        9
    db        "(filehandle)i32"
    db        10
    db        9
    db        "func fgets"
    db        9
    db        9
    db        "(ichar, int, filehandle)ichar"
    db        10
    db        9
    db        "func remove"
    db        9
    db        9
    db        "(ichar)i32"
    db        10
    db        9
    db        "func rename"
    db        9
    db        9
    db        "(ichar, ichar)i32"
    db        10
    db        9
    db        "func getchar"
    db        9
    db        ":i32"
    db        10
    db        9
    db        "proc putchar"
    db        9
    db        "(i32)"
    db        10
    db        9
    db        "proc setbuf"
    db        9
    db        9
    db        "(filehandle, ref byte)"
    db        10
    db        10
    db        9
    db        "func strlen"
    db        9
    db        9
    db        "(ichar)int"
    db        10
    db        9
    db        "func strcpy"
    db        9
    db        9
    db        "(ichar, ichar)ichar"
    db        10
    db        9
    db        "func strcmp"
    db        9
    db        9
    db        "(ichar, ichar)i32"
    db        10
    db        9
    db        "func strncmp"
    db        9
    db        "(ichar, ichar, word)i32"
    db        10
    db        9
    db        "func strncpy"
    db        9
    db        "(ichar, ichar, word)word"
    db        10
    db        9
    db        "func memcmp"
    db        9
    db        9
    db        "(ref void, ref void, word)i32"
    db        10
    db        9
    db        "func strcat"
    db        9
    db        9
    db        "(ichar, ichar)ichar"
    db        10
    db        9
    db        "func tolower"
    db        9
    db        "(i32)i32"
    db        10
    db        9
    db        "func toupper"
    db        9
    db        "(i32)i32"
    db        10
    db        9
    db        "func isalpha"
    db        9
    db        "(i32)i32"
    db        10
    db        9
    db        "func isupper"
    db        9
    db        "(i32)i32"
    db        10
    db        9
    db        "func islower"
    db        9
    db        "(i32)i32"
    db        10
    db        9
    db        "func isalnum"
    db        9
    db        "(i32)i32"
    db        10
    db        9
    db        "func isspace"
    db        9
    db        "(i32)i32"
    db        10
    db        9
    db        "func strstr"
    db        9
    db        9
    db        "(ichar, ichar)ichar"
    db        10
    db        9
    db        "func atol"
    db        9
    db        9
    db        "(ichar)int"
    db        10
    db        9
    db        "func atoi"
    db        9
    db        9
    db        "(ichar)i32"
    db        10
    db        9
    db        "func strtod"
    db        9
    db        9
    db        "(ichar,ref ref char)r64"
    db        10
    db        9
    db        "func _strdup"
    db        9
    db        "(ichar)ichar"
    db        10
    db        10
    db        9
    db        "func puts"
    db        9
    db        9
    db        "(ichar)i32"
    db        10
    db        9
    db        "func printf"
    db        9
    db        9
    db        "(ichar, ...)i32"
    db        10
    db        10
    db        9
    db        "func sprintf"
    db        9
    db        "(ichar, ichar, ...)i32"
    db        10
    db        10
    db        9
    db        "func sscanf"
    db        9
    db        9
    db        "(ichar, ichar, ...)i32"
    db        10
    db        9
    db        "func scanf"
    db        9
    db        9
    db        "(ichar, ...)i32"
    db        10
    db        10
    db        9
    db        "func rand"
    db        9
    db        9
    db        ":i32"
    db        10
    db        9
    db        "proc srand"
    db        9
    db        9
    db        "(u32)"
    db        10
    db        9
    db        "func system"
    db        9
    db        9
    db        "(ichar)i32"
    db        10
    db        10
    db        9
    db        "func fgetc"
    db        9
    db        9
    db        "(filehandle)i32"
    db        10
    db        9
    db        "func fputc"
    db        9
    db        9
    db        "(i32,  filehandle)i32"
    db        10
    db        9
    db        "func fprintf"
    db        9
    db        "(filehandle, ichar, ...)i32"
    db        10
    db        9
    db        "func fputs"
    db        9
    db        9
    db        "(ichar,  filehandle)i32"
    db        10
    db        9
    db        "func feof"
    db        9
    db        9
    db        "(filehandle)i32"
    db        10
    db        9
    db        "func getch"
    db        9
    db        9
    db        ":i32"
    db        10
    db        9
    db        "func _getch"
    db        9
    db        9
    db        ":i32"
    db        10
    db        9
    db        "func kbhit"
    db        9
    db        9
    db        ":i32"
    db        10
    db        9
    db        "func _mkdir"
    db        9
    db        9
    db        "(ichar)i32"
    db        10
    db        9
    db        "func mkdir"
    db        9
    db        9
    db        "(ichar)i32"
    db        10
    db        9
    db        "func strchr"
    db        9
    db        9
    db        "(ichar,i32)ichar"
    db        10
    db        10
    db        9
    db        "func _setmode"
    db        9
    db        "(i32,i32)i32"
    db        10
    db        10
    db        9
    db        "proc _exit"
    db        9
    db        9
    db        "(i32)"
    db        10
    db        9
    db        "proc "
    db        34
    db        "exit"
    db        34
    db        9
    db        9
    db        "(i32)"
    db        10
    db        "!"
    db        9
    db        "proc `exit"
    db        9
    db        9
    db        "(i32)"
    db        10
    db        9
    db        "func pow"
    db        9
    db        9
    db        "(real,real)real"
    db        10
    db        10
    db        9
    db        "func `sin "
    db        9
    db        9
    db        "(real)real"
    db        10
    db        9
    db        "func `cos"
    db        9
    db        9
    db        "(real)real"
    db        10
    db        9
    db        "func `tan"
    db        9
    db        9
    db        "(real)real"
    db        10
    db        9
    db        "func `asin"
    db        9
    db        9
    db        "(real)real"
    db        10
    db        9
    db        "func `acos"
    db        9
    db        9
    db        "(real)real"
    db        10
    db        9
    db        "func `atan "
    db        9
    db        9
    db        "(real)real"
    db        10
    db        9
    db        "func `log"
    db        9
    db        9
    db        "(real)real"
    db        10
    db        9
    db        "func `log10"
    db        9
    db        9
    db        "(real)real"
    db        10
    db        9
    db        "func `exp"
    db        9
    db        9
    db        "(real)real"
    db        10
    db        9
    db        "func `floor"
    db        9
    db        9
    db        "(real)real"
    db        10
    db        9
    db        "func `ceil"
    db        9
    db        9
    db        "(real)real"
    db        10
    db        10
    db        9
    db        "proc  qsort   "
    db        9
    db        "(ref void, u64, u64, ref proc)"
    db        10
    db        10
    db        "end"
    db        10
    db        10
    db        "export macro strdup=_strdup"
    db        10
    db        10
    db        "importdll $cstdextra="
    db        10
    db        9
    db        "func __getmainargs"
    db        9
    db        "(ref i32, ref void, ref void, int, ref void)i32"
    db        10
    db        "end"
    db        10
    db        10
    db        "export const c_eof"
    db        9
    db        9
    db        "=-1"
    db        10
    db        "export const seek_set"
    db        9
    db        "= 0"
    db        10
    db        "export const seek_curr"
    db        9
    db        "= 1"
    db        10
    db        "export const seek_end"
    db        9
    db        "= 2"
    db        10
    db        0
L11485:
    db        "!const mem_check=1"
    db        10
    db        "const mem_check=0"
    db        10
    db        10
    db        "global [0..300]u64 allocupper"
    db        10
    db        "global int alloccode"
    db        9
    db        9
    db        9
    db        9
    db        "!set by heapalloc"
    db        10
    db        "export int allocbytes"
    db        9
    db        9
    db        9
    db        9
    db        "!set by heapalloc"
    db        10
    db        "export int fdebug=0"
    db        10
    db        "export int rfsize"
    db        10
    db        10
    db        "const threshold=1<<25"
    db        10
    db        "const alloc_step=1<<25"
    db        10
    db        "word maxmemory"
    db        10
    db        "int  maxalloccode"
    db        10
    db        10
    db        "!GLOBAL REF VOID ALLOCBASE"
    db        10
    db        10
    db        "byte pcm_setup=0"
    db        10
    db        10
    db        "int show=0"
    db        10
    db        10
    db        "global int memtotal=0"
    db        10
    db        "export i64 smallmemtotal=0"
    db        10
    db        "global int smallmemobjs=0"
    db        10
    db        "global int maxmemtotal=0"
    db        10
    db        10
    db        "!store all allocated pointers"
    db        10
    db        "const int maxmemalloc=(mem_check|500000|2)"
    db        10
    db        "[maxmemalloc+1]ref i32 memalloctable"
    db        10
    db        "[maxmemalloc+1]i32 memallocsize"
    db        10
    db        10
    db        "const pcheapsize=1048576*2"
    db        10
    db        "ref byte pcheapstart"
    db        10
    db        "ref byte pcheapend"
    db        9
    db        9
    db        9
    db        "!points to first address past heap"
    db        10
    db        "ref byte pcheapptr"
    db        10
    db        10
    db        "const int maxblockindex = 8 "
    db        9
    db        9
    db        "!2048"
    db        10
    db        "export const int maxblocksize = 2048"
    db        10
    db        "export const int $maxblocksizexx = 2048"
    db        10
    db        10
    db        "[0:maxblocksize+1]byte sizeindextable"
    db        9
    db        "!convert byte size to block index 1..maxblockindex"
    db        10
    db        10
    db        "const int size16   = 1"
    db        9
    db        9
    db        9
    db        "!the various index codes"
    db        10
    db        "const int size32   = 2"
    db        10
    db        "const int size64   = 3"
    db        10
    db        "const int size128  = 4"
    db        10
    db        "const int size256  = 5"
    db        10
    db        "const int size512  = 6"
    db        10
    db        "const int size1024 = 7"
    db        10
    db        "const int size2048 = 8"
    db        10
    db        10
    db        "export [0:9]ref word freelist"
    db        10
    db        10
    db        "export record strbuffer ="
    db        10
    db        9
    db        "ichar strptr"
    db        10
    db        9
    db        "i32 length"
    db        10
    db        9
    db        "i32 allocated"
    db        10
    db        "end"
    db        10
    db        10
    db        "export enumdata [0:]ichar pmnames="
    db        10
    db        9
    db        "(pm_end=0,"
    db        9
    db        9
    db        "$),"
    db        10
    db        9
    db        "(pm_option,"
    db        9
    db        9
    db        "$),"
    db        10
    db        9
    db        "(pm_sourcefile,"
    db        9
    db        "$),"
    db        10
    db        9
    db        "(pm_libfile,"
    db        9
    db        "$),"
    db        10
    db        9
    db        "(pm_colon,"
    db        9
    db        9
    db        "$),"
    db        10
    db        9
    db        "(pm_extra,"
    db        9
    db        9
    db        "$),"
    db        10
    db        "end"
    db        10
    db        10
    db        "[2]int seed = (0x2989'8811'1111'1272',0x1673'2673'7335'8264)"
    db        10
    db        10
    db        "!PROC START="
    db        10
    db        "!CPL "
    db        34
    db        "MLIB START"
    db        34
    db        10
    db        "!END"
    db        10
    db        10
    db        10
    db        "export function pcm_alloc(int n)ref void ="
    db        10
    db        9
    db        "ref byte p"
    db        10
    db        10
    db        10
    db        9
    db        "if not pcm_setup then"
    db        10
    db        9
    db        9
    db        "pcm_init()"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        "!GOTO DOLARGE"
    db        10
    db        10
    db        9
    db        "if n>maxblocksize then"
    db        9
    db        9
    db        9
    db        "!large block allocation"
    db        10
    db        "!DOLARGE:"
    db        10
    db        9
    db        9
    db        "alloccode:=pcm_getac(n)"
    db        10
    db        9
    db        9
    db        "allocbytes:=allocupper[alloccode]"
    db        10
    db        10
    db        9
    db        9
    db        "p:=allocmem(allocbytes)"
    db        10
    db        9
    db        9
    db        "if not p then"
    db        10
    db        9
    db        9
    db        9
    db        "abortprogram("
    db        34
    db        "pcm_alloc failure"
    db        34
    db        ")"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        9
    db        "return p"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        "!CPL "
    db        34
    db        "DOSMALL"
    db        34
    db        10
    db        10
    db        9
    db        "alloccode:=sizeindextable[n]"
    db        9
    db        9
    db        "!Size code := 0,1,2 etc for 0, 16, 32 etc"
    db        10
    db        9
    db        "allocbytes:=allocupper[alloccode]"
    db        10
    db        "!"
    db        9
    db        "smallmemtotal+:=allocbytes"
    db        10
    db        10
    db        9
    db        "if p:=ref byte(freelist[alloccode]) then"
    db        9
    db        9
    db        "!Items of this block size available"
    db        10
    db        9
    db        9
    db        "freelist[alloccode]:=ref word(int((freelist[alloccode])^))"
    db        10
    db        10
    db        9
    db        9
    db        "return p"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        "!No items in freelists: allocate new space in this heap block"
    db        10
    db        9
    db        "p:=pcheapptr"
    db        9
    db        9
    db        9
    db        9
    db        "!Create item at start of remaining pool in heap block"
    db        10
    db        9
    db        "pcheapptr+:=allocbytes"
    db        9
    db        9
    db        9
    db        "!Shrink remaining pool"
    db        10
    db        10
    db        9
    db        "if pcheapptr>=pcheapend then"
    db        9
    db        9
    db        "!Overflows?"
    db        10
    db        9
    db        9
    db        "p:=pcm_newblock(allocbytes)"
    db        9
    db        9
    db        "!Create new heap block, and allocate from start of that"
    db        10
    db        9
    db        9
    db        "return p"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "return p"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc pcm_free(ref void p,int n) ="
    db        10
    db        "!n can be the actual size requested it does not need to be the allocated size"
    db        10
    db        9
    db        "int acode"
    db        10
    db        10
    db        9
    db        "return when n=0 or p=nil"
    db        10
    db        10
    db        9
    db        "if n>maxblocksize then"
    db        9
    db        9
    db        "!large block"
    db        10
    db        9
    db        9
    db        "free(p)"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "acode:=sizeindextable[n]"
    db        9
    db        9
    db        "!Size code := 0,1,2 etc for 0, 16, 32 etc"
    db        10
    db        9
    db        9
    db        "cast(p,ref word)^:=word(int(freelist[acode]))"
    db        10
    db        9
    db        9
    db        "freelist[acode]:=p"
    db        10
    db        9
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc pcm_freeac(ref void p,int alloc) ="
    db        10
    db        9
    db        "pcm_free(p,allocupper[alloc])"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc pcm_clearmem(ref void p,int n) ="
    db        10
    db        9
    db        "memset(p,0,n)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc pcm_init ="
    db        10
    db        "!set up sizeindextable too"
    db        10
    db        9
    db        "int j, k"
    db        10
    db        9
    db        "i64 size"
    db        10
    db        9
    db        "const limit=1<<33"
    db        10
    db        10
    db        9
    db        "alloccode:=0"
    db        10
    db        9
    db        "if pcm_setup then"
    db        10
    db        9
    db        9
    db        "return"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "pcm_newblock(0)"
    db        10
    db        10
    db        9
    db        "for i to maxblocksize do"
    db        9
    db        "!table converts eg. 78 to 4 (4th of 16,32,64,128)"
    db        10
    db        9
    db        9
    db        "j:=1"
    db        10
    db        9
    db        9
    db        "k:=16"
    db        10
    db        9
    db        9
    db        "while i>k do"
    db        10
    db        9
    db        9
    db        9
    db        "k:=k<<1"
    db        10
    db        9
    db        9
    db        9
    db        "++j"
    db        10
    db        9
    db        9
    db        "od"
    db        10
    db        9
    db        9
    db        "sizeindextable[i]:=j"
    db        10
    db        9
    db        "od"
    db        10
    db        10
    db        9
    db        "allocupper[1]:=16"
    db        10
    db        9
    db        "size:=16"
    db        10
    db        10
    db        9
    db        "for i:=2 to 27 do"
    db        10
    db        9
    db        9
    db        "size*:=2"
    db        10
    db        9
    db        9
    db        "allocupper[i]:=size"
    db        10
    db        9
    db        9
    db        "if size>=threshold then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "k:=i"
    db        10
    db        9
    db        9
    db        9
    db        "exit"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        "od"
    db        10
    db        10
    db        9
    db        "for i:=k+1 to allocupper.upb do"
    db        10
    db        9
    db        9
    db        "size+:=alloc_step"
    db        10
    db        9
    db        9
    db        "if size<limit then"
    db        10
    db        9
    db        9
    db        9
    db        "allocupper[i]:=size"
    db        10
    db        9
    db        9
    db        9
    db        "maxmemory:=size"
    db        10
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        "maxalloccode:=i-1"
    db        10
    db        9
    db        9
    db        9
    db        "exit"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        10
    db        9
    db        "od"
    db        10
    db        9
    db        "pcm_setup:=1"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function pcm_getac(int size)int ="
    db        10
    db        "! convert linear blocksize from 0..approx 2GB to 8-bit allocation code"
    db        10
    db        10
    db        "!sizeindextable scales values from 0 to 2048 to allocation code 0 to 9"
    db        10
    db        10
    db        9
    db        "if size<=maxblocksize then"
    db        10
    db        9
    db        9
    db        "return sizeindextable[size]"
    db        9
    db        9
    db        "!size 0 to 2KB"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "size:=(size+255)>>8"
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "!scale by 256"
    db        10
    db        10
    db        "!now same sizetable can be used for 2KB to 512KB (288 to 2KB)"
    db        10
    db        10
    db        9
    db        "if size<=maxblocksize then"
    db        10
    db        9
    db        9
    db        "return sizeindextable[size]+8"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        "!sizetable now used for 512KB to 128MB (to 2KB)"
    db        10
    db        9
    db        "size:=(size+63)>>6"
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "!scale by 256"
    db        10
    db        10
    db        9
    db        "if size<=maxblocksize then"
    db        10
    db        9
    db        9
    db        "return sizeindextable[size]+14"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        "!size>2048, which means it had been over 128MB."
    db        10
    db        9
    db        "size:=(size-2048+2047)/2048+22"
    db        10
    db        9
    db        "return size"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function pcm_newblock(int itemsize)ref void="
    db        10
    db        "!create new heap block (can be first)"
    db        10
    db        "!also optionally allocate small item at start"
    db        10
    db        "!return pointer to this item (and to the heap block)"
    db        10
    db        9
    db        "static int totalheapsize"
    db        10
    db        9
    db        "ref byte p"
    db        10
    db        10
    db        9
    db        "totalheapsize+:=pcheapsize"
    db        10
    db        9
    db        "alloccode:=0"
    db        10
    db        9
    db        "p:=allocmem(pcheapsize)"
    db        9
    db        "!can't free this block until appl terminates"
    db        10
    db        9
    db        "if p=nil then"
    db        10
    db        9
    db        9
    db        "abortprogram("
    db        34
    db        "Can't alloc pc heap"
    db        34
    db        ")"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "memset(p,0,pcheapsize)"
    db        10
    db        10
    db        9
    db        "pcheapptr:=p"
    db        10
    db        9
    db        "pcheapend:=p+pcheapsize"
    db        10
    db        10
    db        9
    db        "if pcheapstart=nil then"
    db        9
    db        9
    db        "!this is first block"
    db        10
    db        9
    db        9
    db        "pcheapstart:=p"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "pcheapptr+:=itemsize"
    db        10
    db        9
    db        "return ref u32(p)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function pcm_round(int n)int ="
    db        10
    db        "!for any size n, return actual number of bytes that would be allocated"
    db        10
    db        9
    db        "static [0:maxblockindex+1]i32 allocbytes=(0,16,32,64,128,256,512,1024,2048)"
    db        10
    db        10
    db        9
    db        "if n>maxblocksize then"
    db        10
    db        9
    db        9
    db        "return n"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "return allocbytes[sizeindextable[n]]"
    db        10
    db        9
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function pcm_allocz(int n)ref void ="
    db        10
    db        9
    db        "ref void p"
    db        10
    db        9
    db        "p:=pcm_alloc(n)"
    db        10
    db        10
    db        9
    db        "memset(p,0,n)"
    db        10
    db        9
    db        "return p"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function pcm_copyheapstring(ref char s)ref char ="
    db        10
    db        "!allocate enough bytes for string s: copy s to the heap"
    db        10
    db        "!return pointer to new string"
    db        10
    db        9
    db        "ref char q"
    db        10
    db        9
    db        "int n"
    db        10
    db        9
    db        "if s=nil then return nil fi"
    db        10
    db        10
    db        9
    db        "n:=strlen(s)+1"
    db        10
    db        9
    db        "q:=pcm_alloc(n)"
    db        10
    db        9
    db        "memcpy(q,s,n)"
    db        10
    db        9
    db        "return q"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function pcm_copyheapstringn(ref char s,int n)ref char ="
    db        10
    db        9
    db        "ref char q"
    db        10
    db        9
    db        "if s=nil then return nil fi"
    db        10
    db        10
    db        9
    db        "q:=pcm_alloc(n+1)"
    db        10
    db        9
    db        "memcpy(q,s,n)"
    db        10
    db        9
    db        "(q+n)^:=0"
    db        10
    db        9
    db        "return q"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function pcm_copyheapblock(ref char s, int length)ref char ="
    db        10
    db        "!allocate enough bytes for string s: copy s to the heap"
    db        10
    db        "!return pointer to new string"
    db        10
    db        9
    db        "ref char q"
    db        10
    db        9
    db        "if length=0 then return nil fi"
    db        10
    db        10
    db        9
    db        "q:=pcm_alloc(length)"
    db        10
    db        9
    db        "memcpy(q,s,length)"
    db        10
    db        9
    db        "return q"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function allocmem(int n)ref void ="
    db        10
    db        9
    db        "ref void p"
    db        10
    db        10
    db        9
    db        "p:=malloc(n)"
    db        10
    db        9
    db        "if p then"
    db        10
    db        9
    db        9
    db        "return p"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "println n,memtotal"
    db        10
    db        9
    db        "abortprogram("
    db        34
    db        "Alloc mem failure"
    db        34
    db        ")"
    db        10
    db        9
    db        "return nil"
    db        10
    db        "end"
    db        10
    db        10
    db        "global function reallocmem(ref void p,int n)ref void ="
    db        10
    db        9
    db        "p:=realloc(p,n)"
    db        10
    db        9
    db        "return p when p"
    db        10
    db        9
    db        "println n"
    db        10
    db        9
    db        "abortprogram("
    db        34
    db        "Realloc mem failure"
    db        34
    db        ")"
    db        10
    db        9
    db        "return nil"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc abortprogram(ref char s) ="
    db        10
    db        9
    db        "println s"
    db        10
    db        9
    db        "print   "
    db        34
    db        "ABORTING: Press key..."
    db        34
    db        10
    db        "!os_getch()"
    db        10
    db        9
    db        "stop 5"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function getfilesize(filehandle handlex)int="
    db        10
    db        9
    db        "u32 p,size"
    db        10
    db        10
    db        9
    db        "p:=ftell(handlex)"
    db        9
    db        9
    db        "!current position"
    db        10
    db        9
    db        "fseek(handlex,0,2)"
    db        9
    db        9
    db        "!get to eof"
    db        10
    db        9
    db        "size:=ftell(handlex)"
    db        9
    db        9
    db        "!size in bytes"
    db        10
    db        9
    db        "fseek(handlex,p,seek_set)"
    db        9
    db        "!restore position"
    db        10
    db        9
    db        "return size"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc readrandom(filehandle handlex, ref byte memx, int offset, size) ="
    db        10
    db        9
    db        "int a"
    db        10
    db        9
    db        "fseek(handlex,offset,seek_set)"
    db        10
    db        9
    db        "a:=fread(memx,1,size,handlex)"
    db        9
    db        9
    db        9
    db        "!assign so as to remove gcc warning"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function writerandom(filehandle handlex, ref byte memx, int offset,size)int ="
    db        10
    db        9
    db        "fseek(handlex,offset,seek_set)"
    db        10
    db        9
    db        "return fwrite(memx,1,size,handlex)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function setfilepos(filehandle file,int offset)int="
    db        10
    db        9
    db        "return fseek(file,offset,0)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function getfilepos(filehandle file)int="
    db        10
    db        9
    db        "return ftell(file)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function readfile(ref char filename)ref byte ="
    db        10
    db        9
    db        "filehandle f"
    db        10
    db        9
    db        "int size"
    db        10
    db        9
    db        "ref byte m,p"
    db        10
    db        10
    db        9
    db        "f:=fopen(filename,"
    db        34
    db        "rb"
    db        34
    db        ")"
    db        10
    db        9
    db        "if f=nil then"
    db        10
    db        9
    db        9
    db        "return nil"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "rfsize:=size:=getfilesize(f)"
    db        10
    db        10
    db        9
    db        "m:=malloc(size+2)"
    db        9
    db        9
    db        "!allow space for etx/zeof etc"
    db        10
    db        10
    db        9
    db        "if m=nil then"
    db        10
    db        9
    db        9
    db        "return nil"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "readrandom(f,m,0,size)"
    db        10
    db        9
    db        "p:=m+size"
    db        9
    db        9
    db        9
    db        "!point to following byte"
    db        10
    db        9
    db        "(ref u16(p)^:=0)"
    db        9
    db        "!add two zero bytes"
    db        10
    db        10
    db        9
    db        "fclose(f)"
    db        10
    db        9
    db        "return m"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function writefile(ref char filename,ref byte data,int size)int ="
    db        10
    db        9
    db        "filehandle f"
    db        10
    db        9
    db        "int n"
    db        10
    db        10
    db        9
    db        "f:=fopen(filename,"
    db        34
    db        "wb"
    db        34
    db        ")"
    db        10
    db        9
    db        "if f=nil then"
    db        10
    db        9
    db        9
    db        "return 0"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "n:=writerandom(f,data,0,size)"
    db        10
    db        9
    db        "fclose(f)"
    db        10
    db        9
    db        "return n"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function checkfile(ref char file)int="
    db        10
    db        9
    db        "filehandle f"
    db        10
    db        9
    db        "if f:=fopen(file,"
    db        34
    db        "rb"
    db        34
    db        ") then"
    db        10
    db        9
    db        9
    db        "fclose(f)"
    db        10
    db        9
    db        9
    db        "return 1"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "return 0"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc readlinen(filehandle handlex,ref char buffer,int size) ="
    db        10
    db        "!size>2"
    db        10
    db        9
    db        "int ch"
    db        10
    db        9
    db        "ref char p"
    db        10
    db        9
    db        "int n"
    db        10
    db        9
    db        "byte crseen"
    db        10
    db        10
    db        9
    db        "if handlex=nil then"
    db        10
    db        9
    db        9
    db        "handlex:=filehandle(os_getstdin())"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "if handlex=nil then"
    db        10
    db        9
    db        9
    db        "n:=0"
    db        10
    db        9
    db        9
    db        "p:=buffer"
    db        10
    db        9
    db        9
    db        "do"
    db        10
    db        9
    db        9
    db        9
    db        "ch:=getchar()"
    db        10
    db        9
    db        9
    db        9
    db        "if ch=13 or ch=10 or ch=-1 then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "p^:=0"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "return"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        "p++^:=ch"
    db        10
    db        9
    db        9
    db        9
    db        "++n"
    db        10
    db        9
    db        9
    db        9
    db        "if n>=(size-2) then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "p^:=0"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "return"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "od"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "buffer^:=0"
    db        10
    db        9
    db        "if fgets(buffer,size-2,handlex)=nil then"
    db        10
    db        9
    db        9
    db        "return"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "n:=strlen(buffer)"
    db        10
    db        9
    db        "if n=0 then"
    db        10
    db        9
    db        9
    db        "return"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "p:=buffer+n-1"
    db        9
    db        9
    db        "!point to last char"
    db        10
    db        9
    db        "crseen:=0"
    db        10
    db        9
    db        "while (p>=buffer and (p^=13 or p^=10)) do"
    db        10
    db        9
    db        9
    db        "if p^=13 or p^=10 then crseen:=1 fi"
    db        10
    db        9
    db        9
    db        "p--^ :=0"
    db        10
    db        9
    db        "od"
    db        10
    db        10
    db        "!NOTE: this check doesn't work when a line simply doesn't end with cr-lf"
    db        10
    db        10
    db        9
    db        "if not crseen and (n+4>size) then"
    db        10
    db        9
    db        9
    db        "cpl size,n"
    db        10
    db        9
    db        9
    db        "abortprogram("
    db        34
    db        "line too long"
    db        34
    db        ")"
    db        10
    db        9
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc iconvlcn(ref char s,int n) ="
    db        10
    db        9
    db        "to n do"
    db        10
    db        9
    db        9
    db        "s^:=tolower(s^)"
    db        10
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        "od"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc iconvucn(ref char s,int n) ="
    db        10
    db        9
    db        "to n do"
    db        10
    db        9
    db        9
    db        "s^:=toupper(s^)"
    db        10
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        "od"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function convlcstring(ref char s)ichar s0="
    db        10
    db        9
    db        "s0:=s"
    db        10
    db        9
    db        "while (s^) do"
    db        10
    db        9
    db        9
    db        "s^:=tolower(s^)"
    db        10
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        "od"
    db        10
    db        9
    db        "s0"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function convucstring(ref char s)ichar s0="
    db        10
    db        9
    db        "s0:=s"
    db        10
    db        9
    db        "while (s^) do"
    db        10
    db        9
    db        9
    db        "s^:=toupper(s^)"
    db        10
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        "od"
    db        10
    db        9
    db        "s0"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function changeext(ref char s,newext)ichar="
    db        10
    db        "!whether filespec has an extension or not, change it to newext"
    db        10
    db        "!newext should start with "
    db        34
    db        "."
    db        34
    db        10
    db        "!return new string (locally stored static string, so must be used before calling again)"
    db        10
    db        9
    db        "static [260]char newfile"
    db        10
    db        9
    db        "[32]char newext2"
    db        10
    db        9
    db        "ref char sext"
    db        10
    db        9
    db        "int n"
    db        10
    db        10
    db        9
    db        "strcpy(&newfile[1],s)"
    db        10
    db        10
    db        9
    db        "case newext^"
    db        10
    db        9
    db        "when 0 then"
    db        10
    db        9
    db        9
    db        "newext2[1]:=0"
    db        10
    db        9
    db        9
    db        "newext2[2]:=0"
    db        10
    db        9
    db        "when '.' then"
    db        10
    db        9
    db        9
    db        "strcpy(&newext2[1],newext)"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "strcpy(&newext2[1],"
    db        34
    db        "."
    db        34
    db        ")"
    db        10
    db        9
    db        9
    db        "strcat(&newext2[1],newext)"
    db        10
    db        9
    db        "esac"
    db        10
    db        10
    db        10
    db        9
    db        "sext:=extractext(s,1)"
    db        9
    db        9
    db        9
    db        "!include "
    db        34
    db        "."
    db        34
    db        " when it is only extension"
    db        10
    db        10
    db        9
    db        "case sext^"
    db        10
    db        9
    db        "when 0 then"
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "!no extension not even "
    db        34
    db        "."
    db        34
    db        10
    db        9
    db        9
    db        "strcat(&newfile[1],&newext2[1])"
    db        10
    db        9
    db        "when '.' then"
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "!no extension not even "
    db        34
    db        "."
    db        34
    db        10
    db        9
    db        9
    db        "strcat(&newfile[1],&newext2[2])"
    db        10
    db        9
    db        "else"
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "!has extension"
    db        10
    db        9
    db        9
    db        "n:=sext-s-2"
    db        9
    db        9
    db        9
    db        "!n is number of chars before the "
    db        34
    db        "."
    db        34
    db        10
    db        9
    db        9
    db        "strcpy(&newfile[1]+n+1,&newext2[1])"
    db        10
    db        9
    db        "esac"
    db        10
    db        10
    db        9
    db        "return &newfile[1]"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function extractext(ref char s,int period=0)ichar="
    db        10
    db        "!if filespec s has an extension, then return pointer to it otherwise return "
    db        34
    db        34
    db        10
    db        "!if s ends with "
    db        34
    db        "."
    db        34
    db        ", then returns "
    db        34
    db        "."
    db        34
    db        10
    db        9
    db        "ref char t,u"
    db        10
    db        10
    db        9
    db        "t:=extractfile(s)"
    db        10
    db        10
    db        9
    db        "if t^=0 then"
    db        9
    db        9
    db        9
    db        "!s contains no filename"
    db        10
    db        9
    db        9
    db        "return "
    db        34
    db        34
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        "!t contains filename+ext"
    db        10
    db        9
    db        "u:=t+strlen(t)-1"
    db        9
    db        9
    db        "!u points to last char of t"
    db        10
    db        10
    db        9
    db        "while u>=t do"
    db        10
    db        9
    db        9
    db        "if u^='.' then"
    db        9
    db        9
    db        "!start extension found"
    db        10
    db        9
    db        9
    db        9
    db        "if (u+1)^=0 then"
    db        9
    db        9
    db        "!null extension"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "return (period|"
    db        34
    db        "."
    db        34
    db        "|"
    db        34
    db        34
    db        ")"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        "return u+1"
    db        9
    db        9
    db        9
    db        "!return last part of filename as extension exclude the dot"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "--u"
    db        10
    db        9
    db        "od"
    db        10
    db        9
    db        "return "
    db        34
    db        34
    db        9
    db        9
    db        9
    db        "!no extension seen"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function extractpath(ref char s)ichar="
    db        10
    db        9
    db        "static [0:260]char str"
    db        10
    db        9
    db        "ref char t"
    db        10
    db        9
    db        "int n"
    db        10
    db        10
    db        9
    db        "t:=s+strlen(s)-1"
    db        9
    db        9
    db        "!t points to last char"
    db        10
    db        10
    db        9
    db        "while (t>=s) do"
    db        10
    db        9
    db        9
    db        "case t^"
    db        10
    db        9
    db        9
    db        "when '"
    db        92
    db        92
    db        "','/',':' then"
    db        9
    db        9
    db        "!path separator or drive letter terminator assume no extension"
    db        10
    db        9
    db        9
    db        9
    db        "n:=t-s+1"
    db        9
    db        9
    db        9
    db        "!n is number of chars in path, which includes rightmost / or "
    db        92
    db        " or :"
    db        10
    db        9
    db        9
    db        9
    db        "memcpy(&.str,s,n)"
    db        10
    db        9
    db        9
    db        9
    db        "str[n]:=0"
    db        10
    db        9
    db        9
    db        9
    db        "return &.str"
    db        10
    db        9
    db        9
    db        "esac"
    db        10
    db        9
    db        9
    db        "--t"
    db        10
    db        9
    db        "od"
    db        10
    db        9
    db        "return "
    db        34
    db        34
    db        9
    db        9
    db        9
    db        "!no path found"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function extractfile(ref char s)ichar="
    db        10
    db        9
    db        "ref char t"
    db        10
    db        10
    db        9
    db        "t:=extractpath(s)"
    db        10
    db        10
    db        9
    db        "if t^=0 then"
    db        9
    db        9
    db        9
    db        "!s contains no path"
    db        10
    db        9
    db        9
    db        "return s"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "return s+strlen(t)"
    db        9
    db        9
    db        "!point to last part of s that contains the file"
    db        10
    db        9
    db        "end"
    db        10
    db        10
    db        "export function extractbasefile(ref char s)ichar="
    db        10
    db        9
    db        "static [0:100]char str"
    db        10
    db        9
    db        "ref char f,e"
    db        10
    db        9
    db        "int n,flen"
    db        10
    db        10
    db        9
    db        "f:=extractfile(s)"
    db        10
    db        9
    db        "flen:=strlen(f)"
    db        10
    db        9
    db        "if flen=0 then"
    db        9
    db        9
    db        "!s contains no path"
    db        10
    db        9
    db        9
    db        "return "
    db        34
    db        34
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "e:=extractext(f,0)"
    db        10
    db        10
    db        9
    db        "if e^ then"
    db        9
    db        9
    db        9
    db        "!not null extension"
    db        10
    db        9
    db        9
    db        "n:=flen-strlen(e)-1"
    db        10
    db        9
    db        9
    db        "memcpy(&str,f,n)"
    db        10
    db        9
    db        9
    db        "str[n]:=0"
    db        10
    db        9
    db        9
    db        "return &.str"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "if (f+flen-1)^='.' then"
    db        10
    db        9
    db        9
    db        "memcpy(&str,f,flen-1)"
    db        10
    db        9
    db        9
    db        "str[flen-1]:=0"
    db        10
    db        9
    db        9
    db        "return &.str"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "return f"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function addext(ref char s,ref char newext)ichar="
    db        10
    db        "!when filespec has no extension of its own, add newext"
    db        10
    db        9
    db        "ref char sext"
    db        10
    db        10
    db        9
    db        "sext:=extractext(s,1)"
    db        10
    db        10
    db        9
    db        "if sext^=0 then"
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "!no extension not even "
    db        34
    db        "."
    db        34
    db        10
    db        9
    db        9
    db        "return changeext(s,newext)"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "return s"
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "!has own extension; use that"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function pcm_alloc32:ref void ="
    db        10
    db        9
    db        "ref byte p"
    db        10
    db        10
    db        9
    db        "allocbytes:=32"
    db        10
    db        "!"
    db        9
    db        "smallmemtotal+:=32"
    db        10
    db        10
    db        9
    db        "if p:=ref byte(freelist[2]) then"
    db        9
    db        9
    db        "!Items of this block size available"
    db        10
    db        9
    db        9
    db        "freelist[2]:=ref word(int((freelist[2])^))"
    db        10
    db        9
    db        9
    db        "return p"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        "!No items in freelists: allocate new space in this heap block"
    db        10
    db        9
    db        "return pcm_alloc(32)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc pcm_free32(ref void p) ="
    db        10
    db        "!n can be the actual size requested it does not need to be the allocated size"
    db        10
    db        10
    db        "!"
    db        9
    db        "smallmemtotal-:=32"
    db        10
    db        10
    db        9
    db        "cast(p,ref word)^:=word(int(freelist[2]))"
    db        10
    db        9
    db        "freelist[2]:=p"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc outbyte(filehandle f,int x)="
    db        10
    db        9
    db        "fwrite(&x,1,1,f)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc outu16(filehandle f,word x)="
    db        10
    db        9
    db        "fwrite(&x,2,1,f)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc outu32(filehandle f,word x)="
    db        10
    db        9
    db        "fwrite(&x,4,1,f)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc outu64(filehandle f,u64 x)="
    db        10
    db        9
    db        "fwrite(&x,8,1,f)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc outstring(filehandle f, ichar s)="
    db        10
    db        9
    db        "fwrite(s,strlen(s)+1,1,f)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc outblock(filehandle f, ref void p, int n)="
    db        10
    db        9
    db        "fwrite(p,n,1,f)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function myeof(filehandle f)int="
    db        10
    db        9
    db        "int c"
    db        10
    db        10
    db        9
    db        "c:=fgetc(f)"
    db        10
    db        9
    db        "if c=c_eof then return 1 fi"
    db        10
    db        9
    db        "ungetc(c,f)"
    db        10
    db        9
    db        "return 0"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc strbuffer_add(ref strbuffer dest, ichar s, int n=-1)="
    db        10
    db        9
    db        "int newlen,oldlen"
    db        10
    db        9
    db        "ichar newptr"
    db        10
    db        10
    db        "!"
    db        9
    db        "IF N=0 THEN CPL "
    db        34
    db        "N=0"
    db        34
    db        " FI"
    db        10
    db        10
    db        9
    db        "if n=-1 then"
    db        10
    db        9
    db        9
    db        "n:=strlen(s)"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "oldlen:=dest.length"
    db        10
    db        10
    db        9
    db        "if oldlen=0 then"
    db        9
    db        9
    db        9
    db        9
    db        "!first string"
    db        10
    db        9
    db        9
    db        "dest.strptr:=pcm_alloc(n+1)"
    db        10
    db        9
    db        9
    db        "dest.allocated:=allocbytes"
    db        10
    db        9
    db        9
    db        "dest.length:=n"
    db        9
    db        9
    db        9
    db        9
    db        "!length always excludes terminator"
    db        10
    db        9
    db        9
    db        "memcpy(dest.strptr,s,n)"
    db        10
    db        9
    db        9
    db        "(dest.strptr+n)^:=0"
    db        10
    db        9
    db        9
    db        "return"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "newlen:=oldlen+n"
    db        10
    db        9
    db        "if newlen+1>dest.allocated then"
    db        10
    db        9
    db        9
    db        "newptr:=pcm_alloc(newlen+1)"
    db        10
    db        9
    db        9
    db        "memcpy(newptr,dest.strptr,oldlen)"
    db        10
    db        9
    db        9
    db        "dest.strptr:=newptr"
    db        10
    db        9
    db        9
    db        "dest.allocated:=allocbytes"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "memcpy(dest.strptr+oldlen,s,n)"
    db        10
    db        9
    db        "(dest.strptr+newlen)^:=0"
    db        10
    db        10
    db        9
    db        "dest.length:=newlen"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc gs_init(ref strbuffer dest)="
    db        10
    db        9
    db        "pcm_clearmem(dest,strbuffer.bytes)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc gs_free(ref strbuffer dest)="
    db        10
    db        9
    db        "if dest.allocated then"
    db        10
    db        9
    db        9
    db        "pcm_free(dest.strptr,dest.allocated)"
    db        10
    db        9
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc gs_str(ref strbuffer dest,ichar s)="
    db        10
    db        9
    db        "strbuffer_add(dest,s)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc gs_char(ref strbuffer dest,int c)="
    db        10
    db        9
    db        "[16]char s"
    db        10
    db        10
    db        9
    db        "s[1]:=c"
    db        10
    db        9
    db        "s[2]:=0"
    db        10
    db        10
    db        9
    db        "strbuffer_add(dest,&.s,1)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc gs_strn(ref strbuffer dest,ichar s,int length)="
    db        10
    db        9
    db        "strbuffer_add(dest,s,length)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc gs_strvar(ref strbuffer dest,s)="
    db        10
    db        9
    db        "strbuffer_add(dest,s.strptr)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc gs_strint(ref strbuffer dest,i64 a)="
    db        10
    db        9
    db        "strbuffer_add(dest,strint(a))"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc gs_strln(ref strbuffer dest,ichar s)="
    db        10
    db        9
    db        "gs_str(dest,s)"
    db        10
    db        9
    db        "gs_line(dest)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc gs_strsp(ref strbuffer dest,ichar s)="
    db        10
    db        9
    db        "gs_str(dest,s)"
    db        10
    db        9
    db        "gs_str(dest,"
    db        34
    db        " "
    db        34
    db        ")"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc gs_line(ref strbuffer dest)="
    db        10
    db        "!"
    db        9
    db        "strbuffer_add(dest,"
    db        34
    db        92
    db        "w"
    db        34
    db        ")"
    db        10
    db        9
    db        "strbuffer_add(dest,"
    db        34
    db        92
    db        "n"
    db        34
    db        ")"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function gs_getcol(ref strbuffer dest)int="
    db        10
    db        9
    db        "return dest.length"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc gs_leftstr(ref strbuffer dest, ichar s, int w, padch=' ')="
    db        10
    db        9
    db        "int col,i,n,slen"
    db        10
    db        9
    db        "[2560]char str"
    db        10
    db        9
    db        "col:=dest.length"
    db        10
    db        9
    db        "strcpy(&.str,s)"
    db        10
    db        9
    db        "slen:=strlen(s)"
    db        10
    db        9
    db        "n:=w-slen"
    db        10
    db        9
    db        "if n>0 then"
    db        10
    db        9
    db        9
    db        "for i:=1 to n do"
    db        10
    db        9
    db        9
    db        9
    db        "str[slen+i]:=padch"
    db        10
    db        9
    db        9
    db        "od"
    db        10
    db        9
    db        9
    db        "str[slen+n+1]:=0"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "gs_str(dest,&.str)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc gs_leftint(ref strbuffer dest, int a, int w, padch=' ')="
    db        10
    db        9
    db        "gs_leftstr(dest,strint(a),w,padch)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc gs_padto(ref strbuffer dest,int col, ch=' ')="
    db        10
    db        9
    db        "int n"
    db        10
    db        9
    db        "[2560]char str"
    db        10
    db        10
    db        9
    db        "n:=col-dest.length"
    db        10
    db        9
    db        "if n<=0 then return fi"
    db        10
    db        9
    db        "for i:=1 to n do"
    db        10
    db        9
    db        9
    db        "str[i]:=ch"
    db        10
    db        9
    db        "od"
    db        10
    db        9
    db        "str[n+1]:=0"
    db        10
    db        9
    db        "gs_str(dest,&.str)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc gs_println(ref strbuffer dest,filehandle f=nil)="
    db        10
    db        9
    db        "if dest.length=0 then return fi"
    db        10
    db        9
    db        "(dest.strptr+dest.length)^:=0"
    db        10
    db        10
    db        9
    db        "if f=nil then"
    db        10
    db        9
    db        9
    db        "println dest.strptr,,"
    db        34
    db        92
    db        "c"
    db        34
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "println @f,dest.strptr,,"
    db        34
    db        92
    db        "c"
    db        34
    db        10
    db        9
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function nextcmdparamnew(int &paramno, ichar &name, &value, ichar defext=nil)int="
    db        10
    db        9
    db        "static int infile=0"
    db        10
    db        9
    db        "static ichar filestart=nil"
    db        10
    db        9
    db        "static ichar fileptr=nil"
    db        10
    db        9
    db        "static byte colonseen=0"
    db        10
    db        9
    db        "ref char q"
    db        10
    db        9
    db        "ichar item,fileext"
    db        10
    db        9
    db        "int length"
    db        10
    db        9
    db        "static [300]char str"
    db        10
    db        10
    db        9
    db        "reenter:"
    db        10
    db        9
    db        "value:=nil"
    db        10
    db        9
    db        "name:=nil"
    db        10
    db        10
    db        9
    db        "if infile then"
    db        10
    db        9
    db        9
    db        "if readnextfileitem(fileptr,item)=0 then"
    db        9
    db        9
    db        "!eof"
    db        10
    db        9
    db        9
    db        9
    db        "free(filestart)"
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "!file allocated via malloc"
    db        10
    db        9
    db        9
    db        9
    db        "infile:=0"
    db        10
    db        9
    db        9
    db        9
    db        "goto reenter"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "if paramno>ncmdparams then"
    db        10
    db        9
    db        9
    db        9
    db        "return pm_end"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "item:=cmdparams[paramno]"
    db        10
    db        9
    db        9
    db        "++paramno"
    db        10
    db        10
    db        9
    db        9
    db        "length:=strlen(item)"
    db        10
    db        10
    db        9
    db        9
    db        "if item^='@' then"
    db        9
    db        9
    db        "!@ file"
    db        10
    db        9
    db        9
    db        9
    db        "filestart:=fileptr:=readfile(item+1)"
    db        10
    db        9
    db        9
    db        9
    db        "if filestart=nil then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "println "
    db        34
    db        "Can't open"
    db        34
    db        ",item"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "stop 7"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        "infile:=1"
    db        10
    db        9
    db        9
    db        9
    db        "goto reenter"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        9
    db        "if item^=':' then"
    db        10
    db        9
    db        9
    db        9
    db        "colonseen:=1"
    db        10
    db        9
    db        9
    db        9
    db        "return pm_colon"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "value:=nil"
    db        10
    db        9
    db        "if item^='-' then"
    db        10
    db        9
    db        9
    db        "name:=item+(colonseen|0|1)"
    db        10
    db        9
    db        9
    db        "q:=strchr(item,':')"
    db        10
    db        9
    db        9
    db        "if not q then"
    db        10
    db        9
    db        9
    db        9
    db        "q:=strchr(item,'=')"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "if q then"
    db        10
    db        9
    db        9
    db        9
    db        "value:=q+1"
    db        10
    db        9
    db        9
    db        9
    db        "q^:=0"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "return (colonseen|pm_extra|pm_option)"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "fileext:=extractext(item,0)"
    db        10
    db        9
    db        "name:=item"
    db        10
    db        10
    db        9
    db        "if fileext^=0 then"
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "!no extension"
    db        10
    db        9
    db        9
    db        "strcpy(&.str,name)"
    db        10
    db        9
    db        9
    db        "if defext and not colonseen then"
    db        10
    db        9
    db        9
    db        9
    db        "name:=addext(&.str,defext)"
    db        9
    db        9
    db        9
    db        9
    db        "!try .c"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        "!"
    db        9
    db        "elsif eqstring(fileext,"
    db        34
    db        "dll"
    db        34
    db        ") then"
    db        10
    db        9
    db        "elsif eqstring(fileext,"
    db        34
    db        "dll"
    db        34
    db        ") or eqstring(fileext,"
    db        34
    db        "mcx"
    db        34
    db        ") then"
    db        10
    db        9
    db        9
    db        "return (colonseen|pm_extra|pm_libfile)"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "return (colonseen|pm_extra|pm_sourcefile)"
    db        10
    db        "end"
    db        10
    db        10
    db        "function readnextfileitem(ichar &fileptr,&item)int="
    db        10
    db        9
    db        "ref char p,pstart,pend"
    db        10
    db        9
    db        "int n"
    db        10
    db        9
    db        "static [256]char str"
    db        10
    db        10
    db        9
    db        "p:=fileptr"
    db        10
    db        10
    db        9
    db        "reenter:"
    db        10
    db        9
    db        "do"
    db        10
    db        9
    db        9
    db        "case p^"
    db        10
    db        9
    db        9
    db        "when ' ','"
    db        92
    db        "t',13,10 then"
    db        9
    db        "!skip white space"
    db        10
    db        9
    db        9
    db        9
    db        "++p"
    db        10
    db        9
    db        9
    db        "when 26,0 then"
    db        9
    db        9
    db        9
    db        9
    db        "!eof"
    db        10
    db        9
    db        9
    db        9
    db        "return 0"
    db        10
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        "exit"
    db        10
    db        9
    db        9
    db        "esac"
    db        10
    db        9
    db        "od"
    db        10
    db        10
    db        9
    db        "case p^"
    db        10
    db        9
    db        "when '!', '#' then"
    db        9
    db        9
    db        9
    db        "!comment"
    db        10
    db        9
    db        9
    db        "++p"
    db        10
    db        9
    db        9
    db        "docase p++^"
    db        10
    db        9
    db        9
    db        "when 10 then"
    db        10
    db        9
    db        9
    db        9
    db        "goto reenter"
    db        10
    db        9
    db        9
    db        "when 26,0 then"
    db        10
    db        9
    db        9
    db        9
    db        "fileptr:=p-1"
    db        10
    db        9
    db        9
    db        9
    db        "return 0"
    db        10
    db        9
    db        9
    db        "else"
    db        10
    db        10
    db        9
    db        9
    db        "end docase"
    db        10
    db        9
    db        "esac"
    db        10
    db        10
    db        10
    db        9
    db        "case p^"
    db        10
    db        9
    db        "when '"
    db        34
    db        "' then"
    db        9
    db        9
    db        9
    db        9
    db        "!read until closing "
    db        34
    db        10
    db        9
    db        9
    db        "pstart:=++p"
    db        10
    db        9
    db        9
    db        "do"
    db        10
    db        9
    db        9
    db        9
    db        "case p^"
    db        10
    db        9
    db        9
    db        9
    db        "when 0,26 then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "println "
    db        34
    db        "Unexpected EOF in @file"
    db        34
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "stop 8"
    db        10
    db        9
    db        9
    db        9
    db        "when '"
    db        34
    db        "' then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "pend:=p++"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "if p^=',' then ++p fi"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "exit"
    db        10
    db        9
    db        9
    db        9
    db        "esac"
    db        10
    db        9
    db        9
    db        9
    db        "++p"
    db        10
    db        9
    db        9
    db        "od"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "pstart:=p"
    db        10
    db        9
    db        9
    db        "do"
    db        10
    db        9
    db        9
    db        9
    db        "case p^"
    db        10
    db        9
    db        9
    db        9
    db        "when 0,26 then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "pend:=p"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "exit"
    db        10
    db        9
    db        9
    db        9
    db        "when ' ','"
    db        92
    db        "t',',',13,10 then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "pend:=p++"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "exit"
    db        10
    db        9
    db        9
    db        9
    db        "esac"
    db        10
    db        9
    db        9
    db        9
    db        "++p"
    db        10
    db        9
    db        9
    db        "od"
    db        10
    db        9
    db        "esac"
    db        10
    db        10
    db        9
    db        "n:=pend-pstart"
    db        10
    db        9
    db        "if n>=str.len then"
    db        10
    db        9
    db        9
    db        "println "
    db        34
    db        "@file item too long"
    db        34
    db        10
    db        9
    db        9
    db        "stop 9"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "memcpy(&.str,pstart,n)"
    db        10
    db        9
    db        "str[n+1]:=0"
    db        10
    db        9
    db        "item:=&.str"
    db        10
    db        9
    db        "fileptr:=p"
    db        10
    db        10
    db        9
    db        "return 1"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc ipadstr(ref char s,int width,ref char padchar="
    db        34
    db        " "
    db        34
    db        ")="
    db        10
    db        9
    db        "int n"
    db        10
    db        10
    db        9
    db        "n:=strlen(s)"
    db        10
    db        9
    db        "to width-n do"
    db        10
    db        9
    db        9
    db        "strcat(s,padchar)"
    db        10
    db        9
    db        "od"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function padstr(ref char s,int width,ref char padchar="
    db        34
    db        " "
    db        34
    db        ")ichar="
    db        10
    db        9
    db        "static [256]char str"
    db        10
    db        10
    db        9
    db        "strcpy(&.str,s)"
    db        10
    db        9
    db        "ipadstr(&.str,width,padchar)"
    db        10
    db        9
    db        "return &.str"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function chr(int c)ichar="
    db        10
    db        9
    db        "static [8]char str"
    db        10
    db        10
    db        9
    db        "str[1]:=c"
    db        10
    db        9
    db        "str[2]:=0"
    db        10
    db        9
    db        "return &.str"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function cmpstring(ichar s,t)int="
    db        10
    db        9
    db        "int res"
    db        10
    db        9
    db        "if (res:=strcmp(s,t))<0 then"
    db        10
    db        9
    db        9
    db        "return -1"
    db        10
    db        9
    db        "elsif res>0 then"
    db        10
    db        9
    db        9
    db        "return 1"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "return 0"
    db        10
    db        9
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function cmpstringn(ichar s,t,int n)int="
    db        10
    db        9
    db        "int res"
    db        10
    db        9
    db        "if (res:=strncmp(s,t,n))<0 then"
    db        10
    db        9
    db        9
    db        "return -1"
    db        10
    db        9
    db        "elsif res>0 then"
    db        10
    db        9
    db        9
    db        "return 1"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "return 0"
    db        10
    db        9
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function eqstring(ichar s,t)int="
    db        10
    db        9
    db        "return strcmp(s,t)=0"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function cmpbytes(ref void p,q,int n)int="
    db        10
    db        9
    db        "int res"
    db        10
    db        9
    db        "if (res:=memcmp(p,q,n))<0 then"
    db        10
    db        9
    db        9
    db        "return -1"
    db        10
    db        9
    db        "elsif res>0 then"
    db        10
    db        9
    db        9
    db        "return 1"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "return 0"
    db        10
    db        9
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function eqbytes(ref void p,q,int n)int="
    db        10
    db        9
    db        "return memcmp(p,q,n)=0"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc mseed(u64 a,b=0)="
    db        10
    db        9
    db        "seed[1]:=a"
    db        10
    db        9
    db        "if b then"
    db        10
    db        9
    db        9
    db        "seed[2]:=b"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "seed[2] ixor:=a"
    db        10
    db        9
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function mrandom:word ="
    db        10
    db        "!return pure 64-bit word value, 0 to 2**64-1"
    db        10
    db        "!(cast result for signed value)"
    db        10
    db        "!"
    db        9
    db        "u64 x,y"
    db        10
    db        9
    db        "int x,y"
    db        10
    db        9
    db        "x:=seed[1]"
    db        10
    db        9
    db        "y:=seed[2]"
    db        10
    db        9
    db        "seed[1]:=y"
    db        10
    db        9
    db        "x ixor:=(x<<23)"
    db        10
    db        9
    db        "seed[2]:= x ixor y ixor (x>>17) ixor (y>>26)"
    db        10
    db        9
    db        "return seed[2]+y"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function mrandomp:int ="
    db        10
    db        "!pure 64-bit int value, positive only, 0 to 2**63-1"
    db        10
    db        9
    db        "return mrandom() iand 0x7FFF'FFFF'FFFF'FFFF"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function mrandomint(int n)int="
    db        10
    db        "!positive random int value from 0 to n-1"
    db        10
    db        9
    db        "return mrandomp() rem n"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function mrandomrange(int a,b)int="
    db        10
    db        "!random int value from a to b inclusive"
    db        10
    db        "!span extent must be 1 to 2**63-1"
    db        10
    db        9
    db        "int span"
    db        10
    db        9
    db        "span:=b-a+1"
    db        10
    db        9
    db        "if span<=0 then"
    db        10
    db        9
    db        9
    db        "return 0"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "return (mrandomp() rem span)+a"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function mrandomreal:real x="
    db        10
    db        "!positive random real value from 0 to just under (but not including) 1.0"
    db        10
    db        9
    db        "repeat x:=mrandomp()/9223372036854775808.0 until x<>1.0"
    db        10
    db        9
    db        "return x"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function mrandomreal1:real="
    db        10
    db        "!positive random real value from 0 to 1.0 inclusive"
    db        10
    db        9
    db        "return mrandomp()/9223372036854775807.0"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function readline:ichar="
    db        10
    db        9
    db        "readln"
    db        10
    db        9
    db        "return rd_buffer"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function findfunction(ichar name)ref void="
    db        10
    db        9
    db        "for i to $getnprocs() do"
    db        10
    db        9
    db        9
    db        "if eqstring($getprocname(i),name) then"
    db        10
    db        9
    db        9
    db        9
    db        "return $getprocaddr(i)"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        "od"
    db        10
    db        9
    db        "return nil"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function roundtoblock(int n,align)int="
    db        10
    db        "!round up n until it is a multiple of filealign (which is a power of two)"
    db        10
    db        "!return aligned value. Returns original if already aligned"
    db        10
    db        9
    db        "if n iand (align-1)=0 then return n fi"
    db        10
    db        9
    db        "return n+(align-(n iand (align-1)))"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function pcm_allocnfz(int n)ref void ="
    db        10
    db        "!non-freeing allocator for small objects"
    db        10
    db        "!n should be a multiple of 8 bytes, but is rounded up here if needed"
    db        10
    db        9
    db        "ref byte p"
    db        10
    db        10
    db        "!make n a multiple of 8"
    db        10
    db        9
    db        "if n iand 7 then"
    db        10
    db        9
    db        9
    db        "n:=n+(8-(n iand 7))"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "p:=pcheapptr"
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "!Create item at start of remaining pool in heap block"
    db        10
    db        9
    db        "pcheapptr+:=n"
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "!Shrink remaining pool"
    db        10
    db        10
    db        9
    db        "if pcheapptr>=pcheapend then"
    db        9
    db        "!Overflows?"
    db        10
    db        9
    db        9
    db        "p:=pcm_newblock(n)"
    db        9
    db        9
    db        9
    db        "!Create new heap block, and allocate from start of that"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "return p"
    db        10
    db        "end"
    db        10
    db        10
    db        "!export proc freddy="
    db        10
    db        "!"
    db        9
    db        "PRINTLN "
    db        34
    db        "FREDDY"
    db        34
    db        10
    db        "!end"
    db        10
    db        0
L11484:
    db        "!import clib"
    db        10
    db        "!export type filehandle=ref void"
    db        10
    db        10
    db        "!importdll $cstd="
    db        10
    db        "importdll msvcrt="
    db        10
    db        9
    db        "func malloc"
    db        9
    db        "(u64)ref void"
    db        10
    db        9
    db        "proc free"
    db        9
    db        9
    db        "(ref void)"
    db        10
    db        "!"
    db        9
    db        "func pow"
    db        9
    db        9
    db        "(real,real)real"
    db        10
    db        "!"
    db        10
    db        9
    db        "func printf (ref char,...)i32"
    db        10
    db        "!"
    db        9
    db        "func fprintf (ref void,ref char,...)i32"
    db        10
    db        9
    db        "func puts (ref char)i32"
    db        10
    db        9
    db        "proc `exit(i32)"
    db        10
    db        9
    db        "func getchar"
    db        9
    db        ":i32"
    db        10
    db        9
    db        "proc memcpy"
    db        9
    db        9
    db        "(ref void, ref void, word)"
    db        10
    db        9
    db        "proc memset"
    db        9
    db        9
    db        "(ref void, i32, u64)"
    db        10
    db        9
    db        "func strlen"
    db        9
    db        9
    db        "(ichar)u64"
    db        10
    db        9
    db        "func strcpy"
    db        9
    db        9
    db        "(ichar,ichar)ichar"
    db        10
    db        9
    db        "func strcat"
    db        9
    db        9
    db        "(ichar,ichar)ichar"
    db        10
    db        9
    db        "func strcmp"
    db        9
    db        9
    db        "(ichar,ichar)i32"
    db        10
    db        10
    db        9
    db        "func _strdup"
    db        9
    db        "(ichar)ichar"
    db        10
    db        "end"
    db        10
    db        10
    db        "export macro strdup=_strdup"
    db        10
    db        10
    db        "!export proc free(ref void) = end"
    db        10
    db        10
    db        10
    db        "int needgap"
    db        10
    db        10
    db        "!proc start="
    db        10
    db        "!"
    db        9
    db        "CPL "
    db        34
    db        "MIN/START"
    db        34
    db        10
    db        "!end"
    db        10
    db        10
    db        10
    db        "global proc m$print_startcon="
    db        10
    db        "end"
    db        10
    db        10
    db        "global proc m$print_end="
    db        10
    db        9
    db        "needgap:=0"
    db        10
    db        "end"
    db        10
    db        10
    db        "!global proc m$print_ptr(u64 a,ichar fmtstyle=nil)="
    db        10
    db        "!!"
    db        9
    db        "nextfmtchars()"
    db        10
    db        "!"
    db        9
    db        "printf("
    db        34
    db        "%p"
    db        34
    db        ",a)"
    db        10
    db        "!"
    db        9
    db        "needgap:=1"
    db        10
    db        "!end"
    db        10
    db        10
    db        "global proc m$print_ptr_nf(u64 a)="
    db        10
    db        9
    db        "nextfmtchars()"
    db        10
    db        9
    db        "printf("
    db        34
    db        "%p"
    db        34
    db        ",a)"
    db        10
    db        9
    db        "needgap:=1"
    db        10
    db        "end"
    db        10
    db        "!"
    db        10
    db        "!global proc m$print_i64(i64 a,ichar fmtstyle=nil)="
    db        10
    db        "!"
    db        9
    db        "nextfmtchars()"
    db        10
    db        "!"
    db        9
    db        "printf("
    db        34
    db        "%lld"
    db        34
    db        ",a)"
    db        10
    db        "!"
    db        9
    db        "needgap:=1"
    db        10
    db        "!end"
    db        10
    db        10
    db        "!global proc m$print_i128(i64 a,ichar fmtstyle=nil)="
    db        10
    db        "!"
    db        9
    db        "puts("
    db        34
    db        "<128>"
    db        34
    db        ")"
    db        10
    db        "!!"
    db        9
    db        "nextfmtchars()"
    db        10
    db        "!!"
    db        9
    db        "printf("
    db        34
    db        "%lld"
    db        34
    db        ",a)"
    db        10
    db        "!!"
    db        9
    db        "needgap:=1"
    db        10
    db        "!end"
    db        10
    db        10
    db        "global proc m$print_i64_nf(i64 a)="
    db        10
    db        "!puts("
    db        34
    db        "PRINTI64_nf"
    db        34
    db        ")"
    db        10
    db        9
    db        "nextfmtchars()"
    db        10
    db        9
    db        "printf("
    db        34
    db        "%lld"
    db        34
    db        ",a)"
    db        10
    db        9
    db        "needgap:=1"
    db        10
    db        "end"
    db        10
    db        10
    db        "global proc m$print_u64(u64 a,ichar fmtstyle=nil)="
    db        10
    db        9
    db        "nextfmtchars()"
    db        10
    db        9
    db        "printf("
    db        34
    db        "%llu"
    db        34
    db        ",a)"
    db        10
    db        9
    db        "needgap:=1"
    db        10
    db        "end"
    db        10
    db        10
    db        "global proc m$print_r64(real x,ichar fmtstyle=nil)="
    db        10
    db        9
    db        "nextfmtchars()"
    db        10
    db        9
    db        "printf("
    db        34
    db        "%f"
    db        34
    db        ",x)"
    db        10
    db        9
    db        "needgap:=1"
    db        10
    db        "end"
    db        10
    db        10
    db        "global proc m$print_r32(real x,ichar fmtstyle=nil)="
    db        10
    db        9
    db        "nextfmtchars()"
    db        10
    db        9
    db        "printf("
    db        34
    db        "%f"
    db        34
    db        ",x)"
    db        10
    db        9
    db        "needgap:=1"
    db        10
    db        "end"
    db        10
    db        10
    db        "!global proc m$print_c8(i64 a,ichar fmtstyle=nil)="
    db        10
    db        "!"
    db        9
    db        "nextfmtchars()"
    db        10
    db        "!"
    db        9
    db        "printf("
    db        34
    db        "%c"
    db        34
    db        ",a)"
    db        10
    db        "!"
    db        9
    db        "needgap:=1"
    db        10
    db        "!end"
    db        10
    db        "!"
    db        10
    db        "!global proc m$print_str(ichar s, fmtstyle=nil)="
    db        10
    db        "!"
    db        9
    db        "nextfmtchars()"
    db        10
    db        "!"
    db        9
    db        "printf("
    db        34
    db        "%s"
    db        34
    db        ",s)"
    db        10
    db        "!"
    db        9
    db        "needgap:=1"
    db        10
    db        "!end"
    db        10
    db        10
    db        "global proc m$print_str_nf(ichar s)="
    db        10
    db        9
    db        "nextfmtchars()"
    db        10
    db        9
    db        "printf("
    db        34
    db        "%s"
    db        34
    db        ",s)"
    db        10
    db        9
    db        "needgap:=1"
    db        10
    db        "end"
    db        10
    db        10
    db        "global proc m$print_space="
    db        10
    db        9
    db        "needgap:=0"
    db        10
    db        9
    db        "printf("
    db        34
    db        " "
    db        34
    db        ")"
    db        10
    db        "end"
    db        10
    db        10
    db        "global proc m$print_newline="
    db        10
    db        9
    db        "needgap:=0"
    db        10
    db        9
    db        "printf("
    db        34
    db        92
    db        "n"
    db        34
    db        ")"
    db        10
    db        "end"
    db        10
    db        10
    db        "global proc m$unimpl="
    db        10
    db        9
    db        "puts("
    db        34
    db        "Sysfn unimpl"
    db        34
    db        ")"
    db        10
    db        9
    db        "stop 1"
    db        10
    db        "end"
    db        10
    db        10
    db        "global proc m$print_nogap="
    db        10
    db        9
    db        "needgap:=0"
    db        10
    db        "end"
    db        10
    db        10
    db        "!global proc nextfmtchars(int lastx=0)="
    db        10
    db        "global proc nextfmtchars="
    db        10
    db        9
    db        "if needgap then"
    db        10
    db        9
    db        9
    db        "printf("
    db        34
    db        " "
    db        34
    db        ")"
    db        10
    db        9
    db        9
    db        "needgap:=0"
    db        10
    db        9
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "!global proc m$stop(int stopcode)="
    db        10
    db        "!"
    db        9
    db        "`exit(stopcode)"
    db        10
    db        "!end"
    db        10
    db        "!"
    db        10
    db        "!global func strint(i64 a, ichar fmtstyle=nil)ichar="
    db        10
    db        "!"
    db        9
    db        "return "
    db        34
    db        "?"
    db        34
    db        10
    db        "!end"
    db        10
    db        "!"
    db        10
    db        10
    db        "!global function m$power_i64(i64 a,n)i64="
    db        10
    db        "!"
    db        9
    db        "if n<0 then"
    db        10
    db        "!"
    db        9
    db        9
    db        "return 0"
    db        10
    db        "!"
    db        9
    db        "elsif n=0 then"
    db        10
    db        "!"
    db        9
    db        9
    db        "return 1"
    db        10
    db        "!"
    db        9
    db        "elsif n=1 then"
    db        10
    db        "!"
    db        9
    db        9
    db        "return a"
    db        10
    db        "!"
    db        9
    db        "elsif (n iand 1)=0 then"
    db        10
    db        "!"
    db        9
    db        9
    db        "return m$power_i64(sqr a,n/2)"
    db        10
    db        "!"
    db        9
    db        "else"
    db        9
    db        9
    db        9
    db        "!assume odd"
    db        10
    db        "!"
    db        9
    db        9
    db        "return m$power_i64(sqr a,(n-1)/2)*a"
    db        10
    db        "!"
    db        9
    db        "fi"
    db        10
    db        "!end"
    db        10
    db        "!"
    db        10
    db        "!"
    db        10
    db        0
L11483:
    db        "global record procinforec="
    db        10
    db        9
    db        "u16"
    db        9
    db        9
    db        "fnindex"
    db        10
    db        9
    db        "byte"
    db        9
    db        9
    db        "rettype"
    db        10
    db        9
    db        "byte"
    db        9
    db        9
    db        "nparams"
    db        10
    db        9
    db        "[12]byte"
    db        9
    db        "paramlist"
    db        10
    db        "end"
    db        10
    db        10
    db        "!for print/read routines"
    db        10
    db        "!------------------------------------------"
    db        10
    db        "export record fmtrec="
    db        9
    db        "! (default)"
    db        10
    db        9
    db        "byte"
    db        9
    db        "minwidth"
    db        9
    db        "! n (0)   min field width (0 if not used or don't care)"
    db        10
    db        9
    db        "i8"
    db        9
    db        9
    db        "precision"
    db        9
    db        "! .n (0)   number of decimals/significant figures/max width"
    db        10
    db        9
    db        "byte"
    db        9
    db        "base"
    db        9
    db        9
    db        "! B,H or Xn (10)  2 to 16"
    db        10
    db        10
    db        9
    db        "char"
    db        9
    db        "quotechar"
    db        9
    db        "! Qc (0)   0 or '"
    db        34
    db        "' or c"
    db        10
    db        9
    db        "char"
    db        9
    db        "padchar"
    db        9
    db        9
    db        "! Pc, Z (' ')"
    db        10
    db        9
    db        "char"
    db        9
    db        "realfmt"
    db        9
    db        9
    db        "! E,F,G ('f') 'e' or 'f' or 'g'"
    db        10
    db        10
    db        9
    db        "char"
    db        9
    db        "plus"
    db        9
    db        9
    db        "! (0)   0 or '+'"
    db        10
    db        9
    db        "char"
    db        9
    db        "sepchar"
    db        9
    db        9
    db        "! Sc (0)   0 or ',' or c placed every 3 (base=10) or 4 digits"
    db        10
    db        9
    db        "char"
    db        9
    db        "lettercase"
    db        9
    db        "! A,a ('A') 'A' or 'a'"
    db        10
    db        9
    db        "char"
    db        9
    db        "justify"
    db        9
    db        9
    db        "! JL, JR, JC ('R') 'L' or 'R' or 'C'?"
    db        10
    db        9
    db        "char"
    db        9
    db        "suffix"
    db        9
    db        9
    db        "! Tc (0)   0 or 'B' or 'H' or c"
    db        10
    db        9
    db        "char"
    db        9
    db        "usigned"
    db        9
    db        9
    db        "! W (0)   0 or 'W' force unsigned o/p for ints (eg. for hex display)"
    db        10
    db        9
    db        "char"
    db        9
    db        "charmode"
    db        9
    db        "! C,M (0)  0 or 'C' or 'M'"
    db        9
    db        "o/p int as int or single char or multi-char"
    db        10
    db        9
    db        "char"
    db        9
    db        "heapmode"
    db        9
    db        "! D (0)  'D' for str-functions, return ptr to heap string"
    db        10
    db        9
    db        "char"
    db        9
    db        "param"
    db        9
    db        9
    db        "! Use int value for <fmtparam>"
    db        10
    db        9
    db        "byte"
    db        9
    db        "spare : (showtype:1, newline:1)"
    db        10
    db        "end"
    db        10
    db        10
    db        "int fmtparam"
    db        9
    db        9
    db        9
    db        "!as set with :'V'"
    db        10
    db        10
    db        "enumdata ="
    db        10
    db        9
    db        "std_io,file_io,str_io"
    db        10
    db        "end"
    db        10
    db        10
    db        "const comma = ','"
    db        10
    db        10
    db        "export int $cmdskip"
    db        9
    db        9
    db        9
    db        "!0 unless set by READMCX/etc"
    db        10
    db        10
    db        "export int needgap"
    db        9
    db        9
    db        9
    db        "= 0"
    db        10
    db        "int outdev"
    db        9
    db        9
    db        9
    db        "= std_io"
    db        10
    db        "filehandle outchan"
    db        9
    db        "= nil"
    db        10
    db        "ref char fmtstr "
    db        9
    db        "= nil"
    db        10
    db        10
    db        "const maxiostack=10"
    db        10
    db        "[maxiostack]filehandle"
    db        9
    db        "outchan_stack"
    db        10
    db        "[maxiostack]int"
    db        9
    db        9
    db        9
    db        "outdev_stack"
    db        10
    db        "[maxiostack]ref char"
    db        9
    db        "fmtstr_stack"
    db        10
    db        "[maxiostack]byte"
    db        9
    db        9
    db        "needgap_stack"
    db        10
    db        10
    db        "[maxiostack]ref char"
    db        9
    db        "ptr_stack"
    db        9
    db        9
    db        "!this one doesn't need pushing, as each is pointed to from outchan"
    db        10
    db        "int niostack=0"
    db        10
    db        10
    db        "[0:]char digits=A"
    db        34
    db        "0123456789ABCDEF"
    db        34
    db        10
    db        "const onesixty=360"
    db        10
    db        "fmtrec defaultfmt = (0,0, 10, 0,' ','f', 0,0,0,'R',0,0, 0,0,0,0)"
    db        10
    db        10
    db        "!Read buffer vars"
    db        10
    db        "export const rd_buffersize = 16384"
    db        9
    db        "!total capacity of line buffer"
    db        10
    db        10
    db        "export ref char rd_buffer"
    db        9
    db        9
    db        "! point to start of read buffer"
    db        10
    db        "export int rd_length"
    db        9
    db        9
    db        9
    db        "! length of this line (as read by readln)"
    db        10
    db        "export ref char rd_pos"
    db        9
    db        9
    db        9
    db        "! current position it's up to (next read starts here)"
    db        10
    db        "export ref char rd_lastpos"
    db        9
    db        9
    db        "! set by sread() just before reading used for reread()"
    db        10
    db        10
    db        "int termchar"
    db        9
    db        9
    db        9
    db        "! terminator char set by readxxx()"
    db        10
    db        "int itemerror"
    db        9
    db        9
    db        9
    db        "!"
    db        9
    db        "set by some read functions, eg for reals"
    db        10
    db        10
    db        "[4096]char printbuffer"
    db        10
    db        "ichar printptr"
    db        10
    db        "int printlen"
    db        10
    db        10
    db        "!------------------------------------------"
    db        10
    db        10
    db        "export int ncmdparams"
    db        10
    db        "!export ref[]ichar cmdparams"
    db        10
    db        "export ref[0:]ichar cmdparams"
    db        10
    db        10
    db        "proc $getcommands(int ncmd, ref[0:]ichar cmds, int cmdskipL)="
    db        10
    db        "!CPL =$CMDSKIP"
    db        10
    db        "!CPL =CMDSKIPL"
    db        10
    db        9
    db        "ncmdparams:=ncmd-1"
    db        10
    db        9
    db        "cmdparams:=cmds"
    db        10
    db        "end"
    db        10
    db        10
    db        "!export proc m$init(int nargs, ref[]ichar args)="
    db        10
    db        "!"
    db        9
    db        "nsysparams:=nargs"
    db        10
    db        "!"
    db        10
    db        "!"
    db        9
    db        "if nsysparams>maxparam then"
    db        10
    db        "!"
    db        9
    db        9
    db        "printf("
    db        34
    db        "Too many params"
    db        92
    db        "n"
    db        34
    db        ")"
    db        10
    db        "!"
    db        9
    db        9
    db        "stop 1"
    db        10
    db        "!"
    db        9
    db        "fi"
    db        10
    db        "!"
    db        10
    db        "!"
    db        9
    db        "for i:=1 to nargs do"
    db        10
    db        "!"
    db        9
    db        9
    db        "sysparams[i]:=args[i]"
    db        10
    db        "!"
    db        9
    db        "od"
    db        10
    db        "!"
    db        10
    db        "!!assume nsysparams is >=1, since first is always the program name"
    db        10
    db        "!"
    db        9
    db        "ncmdparams:=nsysparams-($cmdskip+1)"
    db        10
    db        "!"
    db        9
    db        "cmdparams:=cast(&sysparams[$cmdskip+1])"
    db        10
    db        "!"
    db        10
    db        "!"
    db        9
    db        "int j:=1"
    db        10
    db        "!"
    db        9
    db        "nenvstrings:=0"
    db        10
    db        "!!"
    db        9
    db        "while envstrings[j] do"
    db        10
    db        "!!"
    db        9
    db        9
    db        "++nenvstrings"
    db        10
    db        "!!"
    db        9
    db        9
    db        "++j"
    db        10
    db        "!!"
    db        9
    db        "od"
    db        10
    db        "!"
    db        10
    db        "!end"
    db        10
    db        10
    db        "proc pushio="
    db        10
    db        9
    db        "if niostack>=maxiostack then"
    db        10
    db        9
    db        9
    db        "printf("
    db        34
    db        "Too many io levels"
    db        92
    db        "n"
    db        34
    db        ")"
    db        10
    db        9
    db        9
    db        "stop 53"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "++niostack"
    db        10
    db        9
    db        "outchan_stack[niostack]"
    db        9
    db        ":= outchan"
    db        10
    db        9
    db        "outdev_stack[niostack]"
    db        9
    db        ":= outdev"
    db        10
    db        9
    db        "fmtstr_stack[niostack]"
    db        9
    db        ":= fmtstr"
    db        10
    db        9
    db        "needgap_stack[niostack]"
    db        9
    db        ":= needgap"
    db        10
    db        9
    db        "needgap:=0"
    db        10
    db        9
    db        "fmtstr:=nil"
    db        10
    db        9
    db        "outchan:=nil"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_startfile(ref void dev)="
    db        10
    db        9
    db        "pushio()"
    db        10
    db        9
    db        "outchan:=cast(dev)"
    db        10
    db        9
    db        "if dev then"
    db        10
    db        9
    db        9
    db        "outdev:=file_io"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "outdev:=std_io"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "resetprintbuffer()"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_startstr(ref char s)="
    db        10
    db        9
    db        "ref ref char p"
    db        10
    db        9
    db        "pushio()"
    db        10
    db        10
    db        9
    db        "ptr_stack[niostack]:=s"
    db        10
    db        9
    db        "p:=&ptr_stack[niostack]"
    db        10
    db        10
    db        9
    db        "outchan:=cast(p)"
    db        10
    db        9
    db        "outdev:=str_io"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_startptr(ref ref char p)="
    db        10
    db        9
    db        "pushio()"
    db        10
    db        10
    db        9
    db        "outchan:=cast(p)"
    db        10
    db        9
    db        "outdev:=str_io"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_startcon="
    db        10
    db        9
    db        "pushio()"
    db        10
    db        9
    db        "outdev:=std_io"
    db        10
    db        9
    db        "resetprintbuffer()"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_setfmt(ref char format)="
    db        10
    db        9
    db        "fmtstr:=format"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_end="
    db        10
    db        9
    db        "needgap:=0"
    db        10
    db        9
    db        "nextfmtchars(1)"
    db        10
    db        9
    db        "if niostack=1 and outdev in [std_io,file_io] then"
    db        10
    db        9
    db        9
    db        "dumpprintbuffer()"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "if niostack=0 then return fi"
    db        10
    db        9
    db        "outchan"
    db        9
    db        ":= outchan_stack[niostack]"
    db        10
    db        9
    db        "outdev"
    db        9
    db        ":= outdev_stack[niostack]"
    db        10
    db        9
    db        "fmtstr"
    db        9
    db        ":= fmtstr_stack[niostack]"
    db        10
    db        9
    db        "needgap"
    db        9
    db        ":= needgap_stack[niostack]"
    db        10
    db        10
    db        9
    db        "--niostack"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_ptr(u64 a,ichar fmtstyle=nil)="
    db        10
    db        9
    db        "if fmtstyle=nil then"
    db        10
    db        9
    db        9
    db        "fmtstyle:="
    db        34
    db        "z8H"
    db        34
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "m$print_u64(a,fmtstyle)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_ptr_nf(u64 a)="
    db        10
    db        9
    db        "m$print_ptr(a)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_i64(i64 a,ichar fmtstyle=nil)="
    db        10
    db        9
    db        "[40]char s"
    db        10
    db        9
    db        "fmtrec fmt"
    db        10
    db        9
    db        "int n"
    db        10
    db        10
    db        9
    db        "nextfmtchars()"
    db        10
    db        9
    db        "if fmtstyle=nil then"
    db        10
    db        9
    db        9
    db        "if a>=0 then"
    db        10
    db        9
    db        9
    db        9
    db        "n:=u64tostr(a,&.s,10,0)"
    db        10
    db        9
    db        9
    db        "elsif a=i64.min then"
    db        10
    db        9
    db        9
    db        9
    db        "fmt:=defaultfmt"
    db        10
    db        9
    db        9
    db        9
    db        "dofmt"
    db        10
    db        10
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        "s[1]:='-'"
    db        10
    db        9
    db        9
    db        9
    db        "n:=u64tostr(-a,&s[2],10,0)+1"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        9
    db        "printstr_n(&.s,n)"
    db        10
    db        10
    db        9
    db        "else"
    db        10
    db        10
    db        9
    db        9
    db        "strtofmt(fmtstyle,-1,&fmt)"
    db        10
    db        9
    db        9
    db        "if fmt.param='V' then"
    db        10
    db        9
    db        9
    db        9
    db        "fmtparam:=a"
    db        10
    db        9
    db        9
    db        9
    db        "needgap:=0"
    db        10
    db        9
    db        9
    db        "else"
    db        10
    db        "dofmt:"
    db        10
    db        9
    db        9
    db        9
    db        "tostr_i64(a,&fmt)"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "needgap:=1"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_i64_nf(i64 a)="
    db        10
    db        9
    db        "m$print_i64(a)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_bool(i64 a, ichar fmtstyle=nil)="
    db        10
    db        9
    db        "if a then"
    db        10
    db        9
    db        9
    db        "m$print_str("
    db        34
    db        "True"
    db        34
    db        ",fmtstyle)"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "m$print_str("
    db        34
    db        "False"
    db        34
    db        ",fmtstyle)"
    db        10
    db        9
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_u64(u64 a,ichar fmtstyle=nil)="
    db        10
    db        9
    db        "[40]char s"
    db        10
    db        9
    db        "fmtrec fmt"
    db        10
    db        10
    db        9
    db        "nextfmtchars()"
    db        10
    db        9
    db        "if fmtstyle=nil then"
    db        10
    db        9
    db        9
    db        "sprintf(&.s,"
    db        34
    db        "%llu"
    db        34
    db        ",a)"
    db        10
    db        9
    db        9
    db        "printstr(&.s)"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "strtofmt(fmtstyle,-1,&fmt)"
    db        10
    db        9
    db        9
    db        "tostr_u64(a,&fmt)"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "needgap:=1"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_r64(real x,ichar fmtstyle=nil)="
    db        10
    db        9
    db        "[360]char s"
    db        10
    db        9
    db        "fmtrec fmt"
    db        10
    db        10
    db        9
    db        "nextfmtchars()"
    db        10
    db        9
    db        "if fmtstyle=nil then"
    db        10
    db        9
    db        9
    db        "sprintf(&.s,"
    db        34
    db        "%f"
    db        34
    db        ",x)"
    db        10
    db        9
    db        9
    db        "printstr(&.s)"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "strtofmt(fmtstyle,-1,&fmt)"
    db        10
    db        9
    db        9
    db        "tostr_r64(x,&fmt)"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "needgap:=1"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_r32(r32 x,ichar fmtstyle=nil)="
    db        10
    db        9
    db        "m$print_r64(x,fmtstyle)"
    db        10
    db        "end"
    db        10
    db        10
    db        "global proc m$print_c8(i64 a,ichar fmtstyle=nil)="
    db        10
    db        9
    db        "[32]char s"
    db        10
    db        "!"
    db        9
    db        "int cc@s"
    db        10
    db        9
    db        "fmtrec fmt"
    db        10
    db        9
    db        "int n"
    db        10
    db        9
    db        "byte charmode:=0"
    db        10
    db        10
    db        9
    db        "nextfmtchars()"
    db        10
    db        10
    db        9
    db        "if fmtstyle then"
    db        10
    db        9
    db        9
    db        "strtofmt(fmtstyle,-1, &fmt)"
    db        10
    db        9
    db        9
    db        "charmode:=fmt.charmode"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "if charmode='M' then"
    db        10
    db        9
    db        9
    db        "n:=domultichar(ref char(&a), 8, &.s, &fmt)"
    db        10
    db        "!"
    db        9
    db        9
    db        "n:=domultichar(ref char(&a), 8, &.str, fmt)"
    db        10
    db        9
    db        "else"
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "!assume 'C'"
    db        10
    db        9
    db        9
    db        "(ref int(&s)^):=a"
    db        9
    db        10
    db        "!"
    db        9
    db        9
    db        "cc:=a"
    db        9
    db        10
    db        9
    db        9
    db        "s[9]:=0"
    db        10
    db        10
    db        9
    db        9
    db        "n:=getutfsize(s)"
    db        9
    db        9
    db        9
    db        "!isolate size of next char"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "printstr_n(s,n)"
    db        10
    db        10
    db        9
    db        "needgap:=1"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_str(ichar s, fmtstyle=nil)="
    db        10
    db        9
    db        "nextfmtchars()"
    db        10
    db        10
    db        9
    db        "if s=nil then"
    db        10
    db        9
    db        9
    db        "printstr("
    db        34
    db        "<null>"
    db        34
    db        ")"
    db        10
    db        9
    db        9
    db        "return"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "fmtrec fmt"
    db        10
    db        9
    db        "if fmtstyle=nil then"
    db        10
    db        9
    db        9
    db        "printstr(s)"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "strtofmt(fmtstyle,-1,&fmt)"
    db        10
    db        9
    db        9
    db        "tostr_str(s,-1,&fmt)"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "needgap:=1"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_strn(ichar s, int length, ichar fmtstyle=nil)="
    db        10
    db        9
    db        "nextfmtchars()"
    db        10
    db        10
    db        9
    db        "if s=nil then"
    db        10
    db        9
    db        9
    db        "printstr("
    db        34
    db        "<null>"
    db        34
    db        ")"
    db        10
    db        9
    db        9
    db        "return"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "fmtrec fmt"
    db        10
    db        9
    db        "if fmtstyle=nil then"
    db        10
    db        9
    db        9
    db        "printstr_n(s,length)"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "strtofmt(fmtstyle,-1,&fmt)"
    db        10
    db        9
    db        9
    db        "tostr_str(s,length,&fmt)"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "needgap:=1"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_str_nf(ichar s)="
    db        10
    db        9
    db        "m$print_str(s)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_strsl(slice[]char s, ichar fmtstyle=nil)="
    db        10
    db        "ABORTPROGRAM("
    db        34
    db        "PRTSL"
    db        34
    db        ")"
    db        10
    db        "!"
    db        9
    db        "nextfmtchars()"
    db        10
    db        "!"
    db        10
    db        "!!"
    db        9
    db        "fmtrec fmt"
    db        10
    db        "!"
    db        10
    db        "!"
    db        9
    db        "if fmtstyle=nil then"
    db        10
    db        "!"
    db        9
    db        9
    db        "printstr_n(cast(s.sliceptr),s.len)"
    db        10
    db        "!!"
    db        9
    db        9
    db        "printstr_n(cast(ss.str),ss.length)"
    db        10
    db        "!"
    db        9
    db        "else"
    db        10
    db        "!"
    db        9
    db        9
    db        "abortprogram("
    db        34
    db        "FORMATED PRINT SLICE NOT READY"
    db        34
    db        ")"
    db        10
    db        "!!"
    db        9
    db        9
    db        "strtofmt(fmtstyle,-1,&fmt)"
    db        10
    db        "!!"
    db        9
    db        9
    db        "tostr_str(s,s.len,&fmt)"
    db        10
    db        "!"
    db        9
    db        "fi"
    db        10
    db        "!"
    db        9
    db        "needgap:=1"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_newline="
    db        10
    db        "!PUTS("
    db        34
    db        "<NEWLINE>"
    db        34
    db        ")"
    db        10
    db        9
    db        "needgap:=0"
    db        10
    db        9
    db        "nextfmtchars(1)"
    db        10
    db        9
    db        "printstr("
    db        34
    db        92
    db        "w"
    db        34
    db        ")"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_nogap="
    db        10
    db        9
    db        "needgap:=0"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_space="
    db        10
    db        9
    db        "needgap:=0"
    db        10
    db        9
    db        "printstr("
    db        34
    db        " "
    db        34
    db        ")"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc printstr(ichar s)="
    db        10
    db        9
    db        "printstr_n(s,strlen(s))"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc printstr_n(ichar s,int n)="
    db        10
    db        10
    db        "!"
    db        9
    db        "return when n=0"
    db        10
    db        10
    db        "!"
    db        9
    db        "if niostack=1 and outdev in [std_io,file_io] then"
    db        10
    db        "!!puts("
    db        34
    db        "ADDTO BUFF"
    db        34
    db        ")"
    db        10
    db        "!"
    db        9
    db        9
    db        "addtobuffer(s,n)"
    db        10
    db        "!"
    db        9
    db        "else"
    db        10
    db        "!printf("
    db        34
    db        "DUMPSTR %lld"
    db        92
    db        "n"
    db        34
    db        ", n)"
    db        10
    db        9
    db        9
    db        "dumpstr(s,n)"
    db        10
    db        "!"
    db        9
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc printstrn_app(ichar s, int length, filehandle f=nil)="
    db        10
    db        "if length then"
    db        10
    db        9
    db        "if f=nil then"
    db        10
    db        9
    db        9
    db        "printf("
    db        34
    db        "%.*s"
    db        34
    db        ",length,s)"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "fprintf(f,"
    db        34
    db        "%.*s"
    db        34
    db        ",length,s)"
    db        10
    db        9
    db        "fi"
    db        10
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "proc printchar(int ch)="
    db        10
    db        9
    db        "[4]char str"
    db        10
    db        10
    db        9
    db        "str[1]:=ch"
    db        10
    db        9
    db        "str[2]:=0"
    db        10
    db        9
    db        "printstr_n(str,1)"
    db        10
    db        "end"
    db        10
    db        10
    db        "global proc nextfmtchars(int lastx=0)="
    db        10
    db        9
    db        "char c"
    db        10
    db        9
    db        "ref char pstart"
    db        10
    db        9
    db        "int n"
    db        10
    db        9
    db        "if not fmtstr then"
    db        9
    db        9
    db        9
    db        "!format not in use"
    db        10
    db        9
    db        9
    db        "if needgap then"
    db        10
    db        9
    db        9
    db        9
    db        "printchar(' ')"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "needgap:=0"
    db        10
    db        9
    db        9
    db        "return"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "pstart:=fmtstr"
    db        10
    db        9
    db        "n:=0"
    db        10
    db        10
    db        9
    db        "do"
    db        10
    db        9
    db        9
    db        "c:=fmtstr^"
    db        10
    db        9
    db        9
    db        "case c"
    db        10
    db        9
    db        9
    db        "when '#' then"
    db        10
    db        9
    db        9
    db        9
    db        "if lastx then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "goto skip"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        "++fmtstr"
    db        10
    db        9
    db        9
    db        9
    db        "if n then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "printstr_n(pstart,n)"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        "return"
    db        10
    db        9
    db        9
    db        "when 0 then"
    db        10
    db        9
    db        9
    db        9
    db        "if n then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "printstr_n(pstart,n)"
    db        10
    db        9
    db        9
    db        9
    db        "elsif not lastx then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "printstr_n("
    db        34
    db        "|"
    db        34
    db        ",1)"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        "return"
    db        10
    db        9
    db        9
    db        "when '~' then"
    db        10
    db        9
    db        9
    db        9
    db        "if n then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "printstr_n(pstart,n)"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "n:=0"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        "++fmtstr"
    db        10
    db        9
    db        9
    db        9
    db        "c:=fmtstr^"
    db        10
    db        9
    db        9
    db        9
    db        "if c then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "++fmtstr"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "printchar(c)"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        "pstart:=fmtstr"
    db        10
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        "skip:"
    db        10
    db        9
    db        9
    db        9
    db        "++n"
    db        10
    db        9
    db        9
    db        9
    db        "++fmtstr"
    db        10
    db        9
    db        9
    db        "esac"
    db        10
    db        9
    db        "od"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc strtofmt(ref char s,int slen,ref fmtrec fmt) ="
    db        9
    db        9
    db        "!PC_STRTOFMT"
    db        10
    db        "!convert format code string in s, to fmtrec at fmt^"
    db        10
    db        "!Format code is a string containing the following char codes (upper or lower when mostly)"
    db        10
    db        "!n"
    db        9
    db        "Width"
    db        10
    db        "!.n"
    db        9
    db        "Max width/precision"
    db        10
    db        "!A"
    db        9
    db        "Convert to upper case"
    db        10
    db        "!a"
    db        9
    db        "Convert to lower case"
    db        10
    db        "!B"
    db        9
    db        "Binary"
    db        10
    db        "!C"
    db        9
    db        "Show int as single n-bit (unicode) character"
    db        10
    db        "!D"
    db        9
    db        "Duplicate string returned via STRINT etc on heap"
    db        10
    db        "!E,F,G"
    db        9
    db        "Specify format for double (corresponds to C format codes)"
    db        10
    db        "!F"
    db        10
    db        "!G"
    db        10
    db        "!H"
    db        9
    db        "Hex"
    db        10
    db        "!JC"
    db        9
    db        "Justify centre"
    db        10
    db        "!JL"
    db        9
    db        "Justify left"
    db        10
    db        "!JR"
    db        9
    db        "Justify right"
    db        10
    db        "!M"
    db        9
    db        "Show int as multi-bit (unicode) character"
    db        10
    db        "!M"
    db        9
    db        "HEAPMODE???"
    db        10
    db        "!O"
    db        9
    db        "Octal"
    db        10
    db        "!Pc"
    db        9
    db        "Use padding char c"
    db        10
    db        "!Q"
    db        9
    db        "Add double quotes around string (and deal with embedded quotes)"
    db        10
    db        "!'"
    db        9
    db        "Add single quotes around string (and deal with embedded quotes)"
    db        10
    db        "!Sc"
    db        9
    db        "Use separator char c between every 3 or 4 digits"
    db        10
    db        "!Tc"
    db        9
    db        "Use terminator char c (typically B or H)"
    db        10
    db        "!U"
    db        9
    db        "Show ints as unsigned"
    db        10
    db        "!V"
    db        9
    db        "For ints, don't display: store value as parameter for subsequent '*'"
    db        10
    db        "!W"
    db        9
    db        "Unsigned"
    db        10
    db        "!Xn"
    db        9
    db        "Use base n (n is hex 0 to F)"
    db        10
    db        "!Z"
    db        9
    db        "Use "
    db        34
    db        "0"
    db        34
    db        " padding"
    db        10
    db        "!+"
    db        9
    db        "Always have + or - in front of integers"
    db        10
    db        "!~"
    db        9
    db        "Quote char is ~"
    db        10
    db        "!*"
    db        9
    db        "Same as n but uses parameter set with :'V' on previous int"
    db        10
    db        10
    db        9
    db        "int c, base"
    db        10
    db        9
    db        "byte wset"
    db        10
    db        9
    db        "int n"
    db        10
    db        9
    db        "[0:100]char str"
    db        10
    db        10
    db        9
    db        "fmt^:=defaultfmt"
    db        10
    db        10
    db        9
    db        "if s=nil then return fi"
    db        10
    db        10
    db        9
    db        "if slen=-1 then slen:=strlen(s) fi"
    db        10
    db        10
    db        9
    db        "memcpy(&.str,s,slen)"
    db        9
    db        9
    db        "!convert s/slen to zero-terminated string"
    db        10
    db        9
    db        "str[slen]:=0"
    db        10
    db        9
    db        "s:=&.str"
    db        10
    db        10
    db        9
    db        "wset:=0"
    db        10
    db        9
    db        "while s^ do"
    db        10
    db        9
    db        9
    db        "c:=s^"
    db        10
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        9
    db        "if c='A' then fmt.lettercase:='A'"
    db        10
    db        9
    db        9
    db        "elsif c='a' then fmt.lettercase:='a'"
    db        10
    db        9
    db        9
    db        "elseswitch toupper(c)"
    db        10
    db        9
    db        9
    db        "when 'B' then fmt.base:=2"
    db        10
    db        9
    db        9
    db        "when 'H' then fmt.base:=16"
    db        10
    db        9
    db        9
    db        "when 'O' then fmt.base:=8"
    db        10
    db        9
    db        9
    db        "when 'X' then"
    db        10
    db        9
    db        9
    db        9
    db        "base:=0"
    db        10
    db        9
    db        9
    db        9
    db        "do"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "c:=s^"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "if c in '0'..'9' then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "base:=base*10+c-'0'"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "exit"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        "od"
    db        10
    db        9
    db        9
    db        9
    db        "if base in 2..16 then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "fmt.base:=base"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        9
    db        "when 'Q' then fmt.quotechar:='"
    db        34
    db        "'"
    db        10
    db        9
    db        9
    db        "when 'J' then"
    db        10
    db        9
    db        9
    db        9
    db        "fmt.justify:=toupper(s^)"
    db        10
    db        9
    db        9
    db        9
    db        "if s^ then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "when 'Z' then fmt.padchar:='0'"
    db        10
    db        9
    db        9
    db        "when 'S' then"
    db        10
    db        9
    db        9
    db        9
    db        "fmt.sepchar:=s^"
    db        10
    db        9
    db        9
    db        9
    db        "if s^ then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "when 'P' then"
    db        10
    db        9
    db        9
    db        9
    db        "fmt.padchar:=s^"
    db        10
    db        9
    db        9
    db        9
    db        "if s^ then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "when 'T' then"
    db        10
    db        9
    db        9
    db        9
    db        "fmt.suffix:=s^"
    db        10
    db        9
    db        9
    db        9
    db        "if s^ then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "when 'U' then fmt.usigned:='W'"
    db        10
    db        9
    db        9
    db        "when 'E' then fmt.realfmt:='e'"
    db        10
    db        9
    db        9
    db        "when 'F' then fmt.realfmt:='f'"
    db        10
    db        9
    db        9
    db        "when 'G' then fmt.realfmt:='g'"
    db        10
    db        9
    db        9
    db        "when 'D' then fmt.heapmode:='D'"
    db        10
    db        9
    db        9
    db        "when 'C' then fmt.charmode:='C'"
    db        10
    db        9
    db        9
    db        "when 'M' then fmt.charmode:='M'"
    db        10
    db        9
    db        9
    db        "when 'V' then fmt.param:='V'"
    db        10
    db        9
    db        9
    db        "when 'Y' then fmt.showtype:=1"
    db        10
    db        9
    db        9
    db        "when 'N' then fmt.newline:=1"
    db        10
    db        9
    db        9
    db        "elsecase c"
    db        10
    db        9
    db        9
    db        "when '.' then"
    db        10
    db        9
    db        9
    db        9
    db        "wset:=1"
    db        10
    db        9
    db        9
    db        "when comma,'_' then fmt.sepchar:=c"
    db        10
    db        9
    db        9
    db        "when '+' then fmt.plus:='+'"
    db        10
    db        9
    db        9
    db        "when '~' then fmt.quotechar:='~'"
    db        10
    db        9
    db        9
    db        "when '*' then"
    db        10
    db        9
    db        9
    db        9
    db        "n:=fmtparam"
    db        10
    db        9
    db        9
    db        9
    db        "goto gotwidth"
    db        10
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        "if c>='0' and c<='9' then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "n:=c-'0'"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "do"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "c:=s^"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "if s^=0 then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "exit"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "if c>='0' and c<='9' then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "n:=n*10+c-'0'"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "exit"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "od"
    db        10
    db        "gotwidth:"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "if not wset then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "fmt.minwidth:=n"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "wset:=1"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "fmt.precision:=n"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        "od"
    db        10
    db        "end"
    db        10
    db        10
    db        "function domultichar (ref char p,int n,ref char dest,ref fmtrec fmt)int ="
    db        10
    db        "!there are n (4 or 8) chars at p.!"
    db        10
    db        "!There could be 0 to 4 or 8 printable chars converted to string at dest"
    db        10
    db        9
    db        "[0:20]char str"
    db        10
    db        9
    db        "ref char q"
    db        10
    db        9
    db        "int nchars"
    db        10
    db        10
    db        9
    db        "q:=&.str"
    db        10
    db        10
    db        9
    db        "nchars:=n"
    db        10
    db        10
    db        9
    db        "to n do"
    db        10
    db        9
    db        9
    db        "if p^=0 then exit fi"
    db        10
    db        9
    db        9
    db        "q^:=p^"
    db        10
    db        9
    db        9
    db        "++q"
    db        10
    db        9
    db        9
    db        "++p"
    db        10
    db        9
    db        "od"
    db        10
    db        9
    db        "q^:=0"
    db        10
    db        10
    db        9
    db        "return expandstr(&.str,dest,strlen(&.str),fmt)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function expandstr(ref char s,ref char t,int n,ref fmtrec fmt)int ="
    db        9
    db        9
    db        "!EXPANDSTR"
    db        10
    db        "!s contains a partly stringified value."
    db        10
    db        "!widen s if necessary, according to fmt, and copy result to t"
    db        10
    db        "!n is current length of s"
    db        10
    db        "!note) = for non-numeric strings, fmt.base should be set to 0, to avoid moving"
    db        10
    db        "!a leading +/- when right-justifying with '0' padding."
    db        10
    db        "!t MUST be big enough for the expanded string; caller must take care of this"
    db        10
    db        "!result will be zero-terminated, for use in this module"
    db        10
    db        10
    db        9
    db        "int i,w,m"
    db        10
    db        10
    db        "!check to see if result is acceptable as it is"
    db        10
    db        9
    db        "w:=fmt.minwidth"
    db        10
    db        9
    db        "if w=0 or w<=n then"
    db        9
    db        9
    db        "! allow str to be longer than minwidth"
    db        10
    db        9
    db        9
    db        "strncpy(t,s,n)"
    db        10
    db        9
    db        9
    db        "(t+n)^:=0"
    db        10
    db        9
    db        9
    db        "return n"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "if fmt.justify='L' then"
    db        9
    db        "! left-justify"
    db        10
    db        9
    db        9
    db        "strncpy(t,s,n)"
    db        10
    db        9
    db        9
    db        "t+:=n"
    db        10
    db        9
    db        9
    db        "for i:=1 to w-n do"
    db        10
    db        9
    db        9
    db        9
    db        "t^:=fmt.padchar"
    db        10
    db        9
    db        9
    db        9
    db        "++t"
    db        10
    db        9
    db        9
    db        "od"
    db        10
    db        9
    db        9
    db        "t^:=0"
    db        10
    db        9
    db        "elsif fmt.justify='R' then"
    db        10
    db        9
    db        9
    db        "if fmt.padchar='0' and fmt.base and (s^='-' or s^='+') then ! need to move sign outside "
    db        10
    db        9
    db        9
    db        9
    db        "t^:=s^"
    db        10
    db        9
    db        9
    db        9
    db        "++t"
    db        10
    db        9
    db        9
    db        9
    db        "to w-n do"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "t^:=fmt.padchar"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "++t"
    db        10
    db        9
    db        9
    db        9
    db        "od"
    db        10
    db        9
    db        9
    db        9
    db        "strncpy(t,s+1,n-1)"
    db        10
    db        9
    db        9
    db        9
    db        "(t+n-1)^:=0"
    db        10
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        "to w-n do"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "t^:=fmt.padchar"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "++t"
    db        10
    db        9
    db        9
    db        9
    db        "od"
    db        10
    db        9
    db        9
    db        9
    db        "strncpy(t,s,n)"
    db        10
    db        9
    db        9
    db        9
    db        "(t+n)^:=0"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "else"
    db        9
    db        9
    db        9
    db        9
    db        "! centre-justify?"
    db        10
    db        10
    db        9
    db        9
    db        "m:=(w-n+1)/2"
    db        10
    db        9
    db        9
    db        "to m do"
    db        10
    db        9
    db        9
    db        9
    db        "t^:=fmt.padchar"
    db        10
    db        9
    db        9
    db        9
    db        "++t"
    db        10
    db        9
    db        9
    db        "od"
    db        10
    db        9
    db        9
    db        "strncpy(t,s,n)"
    db        10
    db        9
    db        9
    db        "t+:=n"
    db        10
    db        9
    db        9
    db        "to w-n-m do"
    db        10
    db        9
    db        9
    db        9
    db        "t^:=fmt.padchar"
    db        10
    db        9
    db        9
    db        9
    db        "++t"
    db        10
    db        9
    db        9
    db        "od"
    db        10
    db        9
    db        9
    db        "t^:=0"
    db        10
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "return w"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function u64tostr(u64 aa,ref char s,word base,int sep)int ="
    db        9
    db        9
    db        "!U64TOSTR"
    db        10
    db        "!convert 64-bit int a to string in s^"
    db        10
    db        "!base is number base, usually 10 but can be 2 or 16. Other bases allowed"
    db        10
    db        "!result when a=minint (will give "
    db        34
    db        "<minint>"
    db        34
    db        ")"
    db        10
    db        9
    db        "[0:onesixty]char t"
    db        10
    db        9
    db        "u64 dd"
    db        10
    db        9
    db        "int i,j,k,g"
    db        10
    db        9
    db        "ref char s0"
    db        10
    db        10
    db        9
    db        "i:=0"
    db        10
    db        9
    db        "k:=0"
    db        10
    db        9
    db        "g:=(base=10|3|4)"
    db        10
    db        10
    db        9
    db        "repeat"
    db        10
    db        "!"
    db        9
    db        9
    db        "if base=10 then"
    db        9
    db        9
    db        9
    db        "!BUGGY FOR AA OVER I64.MAX"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        "assem"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "mov"
    db        9
    db        9
    db        "rcx, [aa]"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "mov"
    db        9
    db        9
    db        "rax, rcx"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "mov"
    db        9
    db        9
    db        "rdx, 7378697629483820647"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "imul"
    db        9
    db        "rdx"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "mov"
    db        9
    db        9
    db        "rax, rdx"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "mov"
    db        9
    db        9
    db        "rdx, rcx"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "sar"
    db        9
    db        9
    db        "rdx, 63"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "sar"
    db        9
    db        9
    db        "rax, 2"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "sub"
    db        9
    db        9
    db        "rax, rdx"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "lea"
    db        9
    db        9
    db        "rdx, [rax+rax*4]"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "add"
    db        9
    db        9
    db        "rdx, rdx"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "sub"
    db        9
    db        9
    db        "rcx, rdx"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "mov"
    db        9
    db        9
    db        "[dd], rcx"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "mov"
    db        9
    db        9
    db        "[aa], rax"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        "end"
    db        10
    db        "!"
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        "dd:=aa rem base"
    db        10
    db        9
    db        9
    db        9
    db        "aa:=aa/base"
    db        10
    db        "!"
    db        9
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        9
    db        "t[++i]:=digits[dd]"
    db        10
    db        10
    db        "!BUG in separator logic, doesn't work when leading zeros used, eg. printing"
    db        10
    db        "!out a full length binary"
    db        10
    db        "!so perhaps move this out to expandstr"
    db        10
    db        9
    db        9
    db        "++k"
    db        10
    db        9
    db        9
    db        "if sep and aa<>0 and k=g then"
    db        10
    db        9
    db        9
    db        9
    db        "t[++i]:=sep"
    db        10
    db        9
    db        9
    db        9
    db        "k:=0"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        "until aa=0"
    db        10
    db        10
    db        9
    db        "j:=i"
    db        10
    db        9
    db        "s0:=s"
    db        10
    db        9
    db        "while i do"
    db        10
    db        9
    db        9
    db        "s^:=t[i--]"
    db        10
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        "od"
    db        10
    db        9
    db        "s^:=0"
    db        10
    db        10
    db        9
    db        "return j"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function i64tostrfmt(i64 aa,ref char s,ref fmtrec fmt)int ="
    db        10
    db        "!a is signed 64-bit int/long, fmt is a ref to a filled-in fmtrec"
    db        10
    db        "!convert a to a string in s, according to fmt"
    db        10
    db        "!a basic conversion is done first,: the field manipulation is done"
    db        10
    db        "!signed=1 for int, 0 for u32 (fmt.unsigned forces ints to be treated as longs)"
    db        10
    db        "!returns length of s"
    db        10
    db        9
    db        "[0:onesixty]char str"
    db        9
    db        9
    db        9
    db        9
    db        "! allow for binary with separators!"
    db        10
    db        9
    db        "int n, usigned"
    db        10
    db        9
    db        "const i64 mindint=0x8000'0000'0000'0000"
    db        10
    db        10
    db        9
    db        "usigned:=0"
    db        10
    db        9
    db        "if fmt.usigned then"
    db        10
    db        9
    db        9
    db        "usigned:=1"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "if aa=mindint and not usigned then"
    db        9
    db        9
    db        "! minint"
    db        10
    db        10
    db        9
    db        9
    db        "str[0]:='-'"
    db        10
    db        9
    db        9
    db        "n:=i64mintostr(&str[1],fmt.base,fmt.sepchar)+1"
    db        10
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "if (not usigned and aa<0) or fmt.plus then"
    db        10
    db        9
    db        9
    db        9
    db        "if aa<0 then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "aa:=-aa"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "str[0]:='-'"
    db        10
    db        9
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "str[0]:='+'"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        "n:=u64tostr(aa,&str[1],fmt.base,fmt.sepchar)+1"
    db        10
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        "n:=u64tostr(aa,&.str,fmt.base,fmt.sepchar)"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "if fmt.suffix then"
    db        10
    db        9
    db        9
    db        "str[n]:=fmt.suffix"
    db        10
    db        9
    db        9
    db        "str[++n]:=0"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        "!str uses upper cases for hex/etc see if lc needed"
    db        10
    db        9
    db        "if (fmt.base>10 or fmt.suffix) and fmt.lettercase='a'"
    db        9
    db        "then"
    db        9
    db        "! need lower when"
    db        10
    db        9
    db        9
    db        "convlcstring(&.str)"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        "!at this point, n is the str length including signs and suffix"
    db        10
    db        9
    db        "return expandstr(&.str,s,n,fmt)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function u64tostrfmt(i64 aa,ref char s,ref fmtrec fmt)int ="
    db        9
    db        9
    db        "!U64TOSTRFMT"
    db        10
    db        "!see i64tostrfmt"
    db        10
    db        9
    db        "[0:onesixty]char str"
    db        9
    db        9
    db        9
    db        9
    db        "! allow for binary with separators!"
    db        10
    db        9
    db        "int n"
    db        10
    db        10
    db        9
    db        "n:=u64tostr(aa,&.str,fmt.base,fmt.sepchar)"
    db        10
    db        10
    db        9
    db        "if fmt.suffix then"
    db        10
    db        9
    db        9
    db        "str[n]:=fmt.suffix"
    db        10
    db        9
    db        9
    db        "str[++n]:=0"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        "!str uses upper cases for hex/etc see if lc needed"
    db        10
    db        9
    db        "if fmt.base>10 or fmt.suffix and fmt.lettercase='a'"
    db        9
    db        "then"
    db        9
    db        "! need lower when"
    db        10
    db        "!"
    db        9
    db        9
    db        "convlcstring(&.str)"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        "!at this point, n is the str length including signs and suffix"
    db        10
    db        9
    db        "return expandstr(&.str,s,n,fmt)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function i64mintostr(ref char s,int base,int sep)int ="
    db        9
    db        9
    db        "!I64MINTOSTR"
    db        10
    db        "!convert minint to string in s do not include minus sign"
    db        10
    db        "!return number of chars in string"
    db        10
    db        9
    db        "[0:onesixty]char t"
    db        10
    db        9
    db        "int i,j,k,g"
    db        10
    db        10
    db        9
    db        "case base"
    db        10
    db        9
    db        "when 10 then"
    db        10
    db        9
    db        9
    db        "strcpy(&t[0],"
    db        34
    db        "9223372036854775808"
    db        34
    db        ")"
    db        10
    db        9
    db        9
    db        "j:=3"
    db        10
    db        9
    db        "when 16 then"
    db        10
    db        9
    db        9
    db        "strcpy(&t[0],"
    db        34
    db        "8000000000000000"
    db        34
    db        ")"
    db        10
    db        9
    db        9
    db        "j:=1"
    db        10
    db        9
    db        "when 2 then"
    db        10
    db        9
    db        9
    db        "strcpy(&t[0],"
    db        34
    db        "1000000000000000000000000000000000000000000000000000000000000000"
    db        34
    db        ")"
    db        10
    db        9
    db        9
    db        "j:=7"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "strcpy(&t[0],"
    db        34
    db        "<mindint>"
    db        34
    db        ")"
    db        10
    db        9
    db        "esac"
    db        10
    db        10
    db        9
    db        "i:=strlen(&t[0])"
    db        10
    db        9
    db        "s+:=i"
    db        10
    db        9
    db        "if sep then"
    db        10
    db        9
    db        9
    db        "s+:=j"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "s^:=0"
    db        10
    db        10
    db        9
    db        "k:=0"
    db        10
    db        9
    db        "g:=(base=10|3|4)"
    db        10
    db        10
    db        9
    db        "while i do"
    db        10
    db        9
    db        9
    db        "--s"
    db        10
    db        9
    db        9
    db        "s^:=t[i-- -1]"
    db        10
    db        9
    db        9
    db        "if sep and i and ++k=g then"
    db        10
    db        9
    db        9
    db        9
    db        "--s"
    db        10
    db        9
    db        9
    db        9
    db        "s^:=sep"
    db        10
    db        9
    db        9
    db        9
    db        "k:=0"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        "od"
    db        10
    db        9
    db        "return strlen(s)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function strtostrfmt(ref char s,ref char t,int n,ref fmtrec fmt)int ="
    db        10
    db        "!s is a string process according to fmtrec fmt^, and return result in t"
    db        10
    db        "!caller should check whether any changes are required to s (now it can just use s), but this"
    db        10
    db        "!check is done here anyway (with a simple copy to t)"
    db        10
    db        "!n is current length of s"
    db        10
    db        "!return length of t"
    db        10
    db        "!Three processing stages:"
    db        10
    db        "!1 Basic input string s"
    db        10
    db        "!2 Additions or mods: quotes, suffix, when conversion"
    db        10
    db        "!3 Width adjustment"
    db        10
    db        "!1 is detected here, 2 is done here, 3 is done by expandstr"
    db        10
    db        9
    db        "ref char u,v"
    db        10
    db        9
    db        "[256]char str"
    db        10
    db        9
    db        "int w,nheap"
    db        9
    db        9
    db        "! whether any heap storage is used  bytes allocated"
    db        10
    db        10
    db        9
    db        "nheap:=0"
    db        10
    db        10
    db        9
    db        "if fmt.quotechar or fmt.lettercase then"
    db        9
    db        9
    db        "! need local copy"
    db        10
    db        9
    db        9
    db        "if n<256 then"
    db        10
    db        9
    db        9
    db        9
    db        "u:=&.str"
    db        10
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        "nheap:=n+3"
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "! allow for quotes+terminator"
    db        10
    db        9
    db        9
    db        9
    db        "u:=pcm_alloc(nheap)"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "if fmt.quotechar then"
    db        10
    db        9
    db        9
    db        9
    db        "v:=u"
    db        10
    db        9
    db        9
    db        9
    db        "v^:=fmt.quotechar"
    db        10
    db        9
    db        9
    db        9
    db        "++v"
    db        10
    db        9
    db        9
    db        9
    db        "if n then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "strcpy(v,s)"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "v+:=n"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        "v^:=fmt.quotechar"
    db        10
    db        9
    db        9
    db        9
    db        "++v"
    db        10
    db        9
    db        9
    db        9
    db        "v^:=0"
    db        10
    db        9
    db        9
    db        9
    db        "n+:=2"
    db        10
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        "memcpy(u,s,n)"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "case fmt.lettercase"
    db        10
    db        9
    db        9
    db        "when 'a' then"
    db        9
    db        "! need lower when"
    db        10
    db        9
    db        9
    db        9
    db        "convlcstring(u)"
    db        10
    db        9
    db        9
    db        "when 'A' then"
    db        10
    db        9
    db        9
    db        9
    db        "convucstring(u)"
    db        10
    db        9
    db        9
    db        "esac"
    db        10
    db        9
    db        9
    db        "s:=u"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "w:=fmt.minwidth"
    db        10
    db        9
    db        "if w>n then"
    db        10
    db        9
    db        9
    db        "n:=expandstr(s,t,n,fmt)"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "memcpy(t,s,n)"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "if nheap then"
    db        10
    db        9
    db        9
    db        "pcm_free(u,nheap)"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "return n"
    db        10
    db        "end"
    db        10
    db        10
    db        "proc tostr_i64(i64 a, ref fmtrec fmt)="
    db        10
    db        9
    db        "[360]char str"
    db        10
    db        9
    db        "int n"
    db        10
    db        10
    db        9
    db        "case fmt.charmode"
    db        10
    db        9
    db        "when 0 then"
    db        10
    db        9
    db        9
    db        "n:=i64tostrfmt(a,&.str,fmt)"
    db        10
    db        9
    db        "when 'M' then"
    db        10
    db        9
    db        9
    db        "n:=domultichar(ref char(&a),8,&.str,fmt)"
    db        10
    db        10
    db        9
    db        "else"
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "!assume 'C'"
    db        10
    db        9
    db        9
    db        "m$print_c8(a, nil)"
    db        10
    db        "!"
    db        9
    db        9
    db        "printchar(a)"
    db        9
    db        9
    db        9
    db        "!no other formatting allowed"
    db        10
    db        9
    db        9
    db        "return"
    db        10
    db        9
    db        "esac"
    db        10
    db        10
    db        9
    db        "printstr_n(&.str,n)"
    db        10
    db        "end"
    db        10
    db        10
    db        "proc tostr_u64(u64 a, ref fmtrec fmt)="
    db        10
    db        9
    db        "[360]char str"
    db        10
    db        9
    db        "int n"
    db        10
    db        10
    db        9
    db        "case fmt.charmode"
    db        10
    db        9
    db        "when 'M' then"
    db        10
    db        9
    db        9
    db        "n:=domultichar(ref char(&a),8,&.str,fmt)"
    db        10
    db        10
    db        9
    db        "when 'C' then"
    db        10
    db        9
    db        9
    db        "m$print_c8(a, nil)"
    db        10
    db        "!"
    db        9
    db        9
    db        "printchar(a)"
    db        9
    db        9
    db        9
    db        "!no other formatting allowed"
    db        10
    db        9
    db        9
    db        "return"
    db        10
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "n:=u64tostrfmt(a,&.str,fmt)"
    db        10
    db        9
    db        "esac"
    db        10
    db        10
    db        9
    db        "printstr_n(&.str,n)"
    db        10
    db        "end"
    db        10
    db        10
    db        "proc tostr_r64(real x,ref fmtrec fmt) ="
    db        10
    db        9
    db        "[360]char str,str2"
    db        10
    db        9
    db        "[0:10]char cfmt"
    db        10
    db        9
    db        "int n"
    db        10
    db        10
    db        9
    db        "cfmt[0]:='%'"
    db        10
    db        10
    db        9
    db        "if fmt.precision then"
    db        10
    db        9
    db        9
    db        "cfmt[1]:='.'"
    db        10
    db        9
    db        9
    db        "cfmt[2]:='*'"
    db        10
    db        9
    db        9
    db        "cfmt[3]:=fmt.realfmt"
    db        10
    db        9
    db        9
    db        "cfmt[4]:=0"
    db        10
    db        9
    db        9
    db        "sprintf(&.str,&.cfmt,fmt.precision,x)"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "cfmt[1]:=fmt.realfmt"
    db        10
    db        9
    db        9
    db        "cfmt[2]:=0"
    db        10
    db        9
    db        9
    db        "sprintf(&.str,&.cfmt,x)"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        "!at this point, n is the str length including signs and suffix"
    db        10
    db        10
    db        9
    db        "n:=strlen(&.str)"
    db        9
    db        9
    db        "! current length"
    db        10
    db        10
    db        9
    db        "if n<fmt.minwidth then"
    db        10
    db        9
    db        9
    db        "n:=expandstr(&.str,&.str2,n,fmt)"
    db        10
    db        9
    db        9
    db        "strcpy(&.str,&.str2)"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "printstr_n(&.str,n)"
    db        10
    db        "end"
    db        10
    db        10
    db        "proc tostr_str(ref char s, int oldlen, ref fmtrec fmt) ="
    db        10
    db        9
    db        "int newlen,n"
    db        10
    db        9
    db        "ref char t"
    db        10
    db        10
    db        "!try and work out size of formatted string"
    db        10
    db        9
    db        "if oldlen=-1 then"
    db        10
    db        9
    db        9
    db        "oldlen:=strlen(s)"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "newlen:=oldlen"
    db        10
    db        10
    db        9
    db        "if fmt.quotechar or fmt.minwidth>newlen or fmt.lettercase or fmt.precision then"
    db        10
    db        9
    db        9
    db        "if fmt.quotechar then"
    db        10
    db        9
    db        9
    db        9
    db        "newlen+:=2"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "if fmt.minwidth>newlen then"
    db        10
    db        9
    db        9
    db        9
    db        "newlen:=fmt.minwidth"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "t:=pcm_alloc(newlen+1)"
    db        10
    db        9
    db        9
    db        "n:=strtostrfmt(s,t,oldlen,fmt)"
    db        10
    db        9
    db        9
    db        "if fmt.precision then"
    db        10
    db        9
    db        9
    db        9
    db        "n min:=fmt.precision"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        9
    db        "printstr_n(t,n)"
    db        10
    db        9
    db        9
    db        "pcm_free(t,newlen+1)"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "printstr_n(s,oldlen)"
    db        10
    db        9
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "function getfmt(ichar fmtstyle)ref fmtrec="
    db        10
    db        9
    db        "static fmtrec fmt"
    db        10
    db        9
    db        "if fmtstyle then"
    db        10
    db        9
    db        9
    db        "strtofmt(fmtstyle,-1,&fmt)"
    db        10
    db        9
    db        9
    db        "return &fmt"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "return &defaultfmt"
    db        10
    db        9
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function strint(i64 a, ichar fmtstyle=nil)ichar="
    db        10
    db        9
    db        "static [100]char str"
    db        10
    db        9
    db        "ref fmtrec fmt"
    db        10
    db        10
    db        9
    db        "m$print_startstr(&.str)"
    db        10
    db        9
    db        "tostr_i64(a,fmt:=getfmt(fmtstyle))"
    db        10
    db        9
    db        "m$print_end()"
    db        10
    db        9
    db        "return getstr(&.str,fmt)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc getstrint(i64 a, ichar dest)="
    db        10
    db        9
    db        "m$print_startstr(dest)"
    db        10
    db        9
    db        "tostr_i64(a,getfmt(nil))"
    db        10
    db        9
    db        "m$print_end()"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function strword(u64 a, ichar fmtstyle=nil)ichar="
    db        10
    db        9
    db        "static [100]char str"
    db        10
    db        9
    db        "ref fmtrec fmt"
    db        10
    db        10
    db        9
    db        "m$print_startstr(&.str)"
    db        10
    db        9
    db        "tostr_u64(a,fmt:=getfmt(fmtstyle))"
    db        10
    db        9
    db        "m$print_end()"
    db        10
    db        9
    db        "return getstr(&.str,fmt)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function strreal(real a, ichar fmtstyle=nil)ichar="
    db        10
    db        9
    db        "static [320]char str"
    db        10
    db        9
    db        "ref fmtrec fmt"
    db        10
    db        10
    db        9
    db        "m$print_startstr(&.str)"
    db        10
    db        9
    db        "tostr_r64(a,fmt:=getfmt(fmtstyle))"
    db        10
    db        9
    db        "m$print_end()"
    db        10
    db        9
    db        "return getstr(&.str,fmt)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function getstr(ichar s, ref fmtrec fmt)ichar="
    db        10
    db        9
    db        "if fmt.heapmode then"
    db        10
    db        9
    db        9
    db        "return pcm_copyheapstring(s)"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "return s"
    db        10
    db        9
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "proc initreadbuffer="
    db        10
    db        9
    db        "if rd_buffer then return fi"
    db        10
    db        9
    db        "rd_buffer:=pcm_alloc(rd_buffersize)"
    db        10
    db        9
    db        "rd_buffer^:=0"
    db        10
    db        9
    db        "rd_pos:=rd_lastpos:=rd_buffer"
    db        10
    db        "end"
    db        10
    db        10
    db        "global proc m$read_conline="
    db        10
    db        9
    db        "initreadbuffer()"
    db        10
    db        10
    db        9
    db        "readlinen(nil,rd_buffer,rd_buffersize)"
    db        10
    db        10
    db        9
    db        "rd_length:=strlen(rd_buffer)"
    db        10
    db        9
    db        "rd_pos:=rd_buffer"
    db        10
    db        9
    db        "rd_lastpos:=nil"
    db        10
    db        "end"
    db        10
    db        10
    db        "global proc m$read_fileline(filehandle f)="
    db        10
    db        9
    db        "initreadbuffer()"
    db        10
    db        10
    db        9
    db        "if f=filehandle(1) then"
    db        10
    db        "ABORTPROGRAM("
    db        34
    db        "READ CMDLINE"
    db        34
    db        ")"
    db        10
    db        "!"
    db        9
    db        9
    db        "rd_buffer^:=0"
    db        10
    db        "!"
    db        9
    db        9
    db        "p:=getcommandlinea()"
    db        10
    db        "!"
    db        9
    db        9
    db        "repeat"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        "++p"
    db        10
    db        "!"
    db        9
    db        9
    db        "until p^ in [' ','"
    db        92
    db        "t',0]"
    db        10
    db        "!"
    db        9
    db        9
    db        "strcpy(rd_buffer, p)"
    db        10
    db        "!"
    db        9
    db        9
    db        "rd_length:=strlen(rd_buffer)"
    db        10
    db        "!"
    db        9
    db        9
    db        "rd_pos:=rd_buffer"
    db        10
    db        "!"
    db        9
    db        9
    db        "rd_lastpos:=nil"
    db        10
    db        9
    db        9
    db        "return"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "readlinen(f,rd_buffer,rd_buffersize)"
    db        10
    db        10
    db        9
    db        "rd_length:=strlen(rd_buffer)"
    db        10
    db        9
    db        "rd_pos:=rd_buffer"
    db        10
    db        9
    db        "rd_lastpos:=nil"
    db        10
    db        "end"
    db        10
    db        10
    db        "global proc m$read_strline(ichar s)="
    db        10
    db        9
    db        "int n"
    db        10
    db        10
    db        9
    db        "initreadbuffer()"
    db        10
    db        9
    db        "n:=strlen(s)"
    db        10
    db        10
    db        9
    db        "if n<rd_buffersize then"
    db        10
    db        9
    db        9
    db        "strcpy(rd_buffer,s)"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "memcpy(rd_buffer,s,rd_buffersize-1)"
    db        10
    db        9
    db        9
    db        "(rd_buffer+rd_buffersize-1)^:=0"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "rd_length:=n"
    db        10
    db        9
    db        "rd_pos:=rd_buffer"
    db        10
    db        9
    db        "rd_lastpos:=nil"
    db        10
    db        "end"
    db        10
    db        10
    db        "function readitem(int &itemlength)ref char ="
    db        10
    db        "!read next item from rd_buffer"
    db        10
    db        "!identify a substring that can contain a name, int, real, string or filename"
    db        10
    db        "!return updated position of s that points past the item and past the immediate"
    db        10
    db        "!terminator "
    db        10
    db        "!information about the read item is returned in itemstr, which points to"
    db        10
    db        "!the start of the item, and in itemlength. Item excludes any surrounding whitespace"
    db        10
    db        "!Item can be quoted, then the item points inside the quotes"
    db        10
    db        "!Any embedded quotes are removed, and the characters moved up. The item will"
    db        10
    db        "!be that reduced subsequence"
    db        10
    db        "!NOTE THAT THIS IS DESTRUCTIVE. On reread, the input will be different."
    db        10
    db        "!I can mitigate this by adding spaces between the end of the item, and the next item,"
    db        10
    db        "!overwriting also the terminator. But this won't restore the line if one of the next"
    db        10
    db        "!reads is literal, using 'L' or 'C' codes."
    db        10
    db        9
    db        "ref char p,s,itemstr"
    db        10
    db        9
    db        "char quotechar, c"
    db        10
    db        10
    db        9
    db        "unless rd_buffer then "
    db        10
    db        9
    db        9
    db        "initreadbuffer()"
    db        10
    db        9
    db        "end unless"
    db        10
    db        10
    db        9
    db        "s:=rd_pos"
    db        10
    db        10
    db        "!scan string, eliminating leading white space"
    db        10
    db        9
    db        "while s^=' ' or s^=9 do"
    db        10
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        "od"
    db        10
    db        10
    db        9
    db        "itemstr:=s"
    db        10
    db        9
    db        "rd_lastpos:=rd_pos:=s"
    db        10
    db        10
    db        9
    db        "if s^=0 then"
    db        10
    db        9
    db        9
    db        "termchar:=0"
    db        10
    db        9
    db        9
    db        "itemlength:=0"
    db        10
    db        9
    db        9
    db        "return s"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "quotechar:=0"
    db        10
    db        9
    db        "if s^='"
    db        34
    db        "' then"
    db        10
    db        9
    db        9
    db        "quotechar:='"
    db        34
    db        "'"
    db        10
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        "elsif s^='"
    db        92
    db        "'' then"
    db        10
    db        9
    db        9
    db        "quotechar:='"
    db        92
    db        "''"
    db        10
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        "!loop reading characters until separator or end reached"
    db        10
    db        9
    db        "p:=itemstr:=s"
    db        10
    db        10
    db        9
    db        "while s^ do"
    db        10
    db        9
    db        9
    db        "c:=s++^"
    db        10
    db        9
    db        9
    db        "case c"
    db        10
    db        9
    db        9
    db        "when ' ', 9, comma, '=' then"
    db        9
    db        9
    db        "! separator"
    db        10
    db        9
    db        9
    db        9
    db        "if quotechar or p=s then"
    db        9
    db        9
    db        9
    db        "!can be considered part of name if inside quotes, or is only char"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "goto normalchar"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        "termchar:=c"
    db        10
    db        9
    db        9
    db        9
    db        "exit"
    db        10
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        "normalchar:"
    db        10
    db        9
    db        9
    db        9
    db        "if c=quotechar then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "if s^=quotechar then"
    db        9
    db        "! embedded quote"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "p^:=c"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "++p"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "else"
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "! end of name"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "termchar:=s^"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "if termchar in [',', '='] then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "termchar:=s^"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "exit"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "p^:=c"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "++p"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "esac"
    db        10
    db        9
    db        "od"
    db        10
    db        10
    db        9
    db        "if s^=0 then"
    db        10
    db        9
    db        9
    db        "termchar:=0"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "itemlength:=p-itemstr"
    db        9
    db        9
    db        9
    db        9
    db        "! actual length of token"
    db        10
    db        9
    db        "rd_pos:=s"
    db        10
    db        10
    db        9
    db        "return itemstr"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function strtoint(ichar s,int length=-1, word base=10)i64="
    db        10
    db        "!return point to next char after terminator (which can be just off length of string)"
    db        10
    db        9
    db        "byte signd"
    db        10
    db        9
    db        "u64 aa"
    db        10
    db        9
    db        "word c,d"
    db        10
    db        10
    db        9
    db        "itemerror:=0"
    db        10
    db        10
    db        9
    db        "if length=-1 then"
    db        10
    db        9
    db        9
    db        "length:=strlen(s)"
    db        10
    db        9
    db        "fi"
    db        10
    db        "!check for sign"
    db        10
    db        9
    db        "signd:=0"
    db        10
    db        9
    db        "if length and s^='-' then"
    db        10
    db        9
    db        9
    db        "signd:=1; ++s; --length"
    db        10
    db        9
    db        "elsif length and s^='+' then"
    db        10
    db        9
    db        9
    db        "++s; --length"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "aa:=0"
    db        10
    db        9
    db        "while length do"
    db        10
    db        9
    db        9
    db        "c:=s++^"
    db        10
    db        9
    db        9
    db        "--length"
    db        10
    db        9
    db        9
    db        "if c in 'A'..'F' then d:=c-'A'+10"
    db        10
    db        9
    db        9
    db        "elsif c in 'a'..'f' then d:=c-'a'+10"
    db        10
    db        9
    db        9
    db        "elsif c in '0'..'9' then d:=c-'0'"
    db        10
    db        9
    db        9
    db        "elsif c in ['_', '"
    db        92
    db        "''] then"
    db        10
    db        9
    db        9
    db        9
    db        "nextloop"
    db        10
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        "itemerror:=1"
    db        10
    db        9
    db        9
    db        9
    db        "exit"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        9
    db        "if d>=base then"
    db        10
    db        9
    db        9
    db        9
    db        "itemerror:=1"
    db        10
    db        9
    db        9
    db        9
    db        "exit"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "aa:=aa*base+d"
    db        10
    db        9
    db        "od"
    db        10
    db        10
    db        9
    db        "if signd then"
    db        10
    db        9
    db        9
    db        "return -aa"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "return aa"
    db        10
    db        9
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "global function m$read_i64(int fmt=0)i64="
    db        10
    db        9
    db        "ref char s"
    db        10
    db        9
    db        "int length"
    db        10
    db        10
    db        9
    db        "fmt:=toupper(fmt)"
    db        10
    db        10
    db        9
    db        "case fmt"
    db        10
    db        9
    db        "when 'C' then"
    db        10
    db        9
    db        9
    db        "rd_lastpos:=rd_pos"
    db        10
    db        9
    db        9
    db        "if rd_pos^ then"
    db        10
    db        9
    db        9
    db        9
    db        "return rd_pos++^"
    db        10
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        "return 0"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        "when 'T' then"
    db        10
    db        9
    db        9
    db        "return termchar"
    db        10
    db        9
    db        "when 'E' then"
    db        10
    db        9
    db        9
    db        "return itemerror"
    db        10
    db        9
    db        "esac"
    db        10
    db        10
    db        9
    db        "s:=readitem(length)"
    db        10
    db        10
    db        9
    db        "case fmt"
    db        10
    db        9
    db        "when 0,'I' then"
    db        10
    db        9
    db        9
    db        "return strtoint(s,length)"
    db        10
    db        9
    db        "when 'B' then"
    db        10
    db        9
    db        9
    db        "return strtoint(s,length,2)"
    db        10
    db        9
    db        "when 'H' then"
    db        10
    db        9
    db        9
    db        "return strtoint(s,length,16)"
    db        10
    db        9
    db        "esac"
    db        10
    db        9
    db        "return 0"
    db        10
    db        "end"
    db        10
    db        10
    db        "global function m$read_r64(int fmt=0)real="
    db        10
    db        9
    db        "[512]char str"
    db        10
    db        9
    db        "ref char s"
    db        10
    db        9
    db        "int length"
    db        10
    db        9
    db        "i32 numlength"
    db        10
    db        9
    db        "real x"
    db        10
    db        10
    db        9
    db        "s:=readitem(length)"
    db        10
    db        10
    db        9
    db        "if length=0 or length>=str.len then"
    db        9
    db        9
    db        "!assume not a real"
    db        10
    db        9
    db        9
    db        "return 0.0"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "memcpy(&.str,s,length)"
    db        10
    db        9
    db        "str[length+1]:=0"
    db        10
    db        10
    db        9
    db        "itemerror:=0"
    db        10
    db        10
    db        9
    db        "if sscanf(&.str,"
    db        34
    db        "%lf%n"
    db        34
    db        ", &x, &numlength)=0 or numlength<>length then"
    db        10
    db        9
    db        9
    db        "x:=0.0"
    db        10
    db        9
    db        9
    db        "itemerror:=1"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "return x"
    db        10
    db        "end"
    db        10
    db        10
    db        "global proc m$read_str(ref char dest, int destlen=0,fmt=0)="
    db        10
    db        9
    db        "ref char s"
    db        10
    db        9
    db        "int length"
    db        10
    db        10
    db        9
    db        "itemerror:=0"
    db        10
    db        9
    db        "if fmt in ['L','l'] then"
    db        10
    db        9
    db        9
    db        "s:=rd_pos"
    db        10
    db        9
    db        9
    db        "length:=rd_buffer+rd_length-rd_pos"
    db        10
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "s:=readitem(length)"
    db        10
    db        10
    db        9
    db        9
    db        "if fmt in ['N','n'] then"
    db        10
    db        9
    db        9
    db        9
    db        "iconvlcn(s,length)"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "if destlen>0 then"
    db        10
    db        9
    db        9
    db        "if length>=destlen then"
    db        10
    db        9
    db        9
    db        9
    db        "length:=destlen-1"
    db        10
    db        9
    db        9
    db        9
    db        "itemerror:=1"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "memcpy(dest,s,length)"
    db        10
    db        9
    db        "(dest+length)^:=0"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc readstr(ref char dest, int fmt=0,destlen=0)="
    db        10
    db        9
    db        "m$read_str(dest,destlen,fmt)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc rereadln="
    db        10
    db        9
    db        "rd_pos:=rd_buffer"
    db        10
    db        9
    db        "rd_lastpos:=rd_pos"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc reread="
    db        10
    db        9
    db        "rd_pos:=rd_lastpos"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function valint(ichar s, int fmt=0)i64="
    db        10
    db        9
    db        "ref char old_pos, old_lastpos"
    db        10
    db        9
    db        "i64 aa"
    db        10
    db        10
    db        9
    db        "initreadbuffer()"
    db        10
    db        9
    db        "old_pos:=rd_pos"
    db        10
    db        9
    db        "old_lastpos:=rd_lastpos"
    db        10
    db        10
    db        9
    db        "rd_pos:=s"
    db        10
    db        9
    db        "aa:=m$read_i64(fmt)"
    db        10
    db        9
    db        "rd_pos:=old_pos"
    db        10
    db        9
    db        "rd_lastpos:=old_lastpos"
    db        10
    db        9
    db        "return aa"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function valreal(ichar s)real="
    db        10
    db        9
    db        "ref char old_pos, old_lastpos"
    db        10
    db        9
    db        "real x"
    db        10
    db        10
    db        9
    db        "initreadbuffer()"
    db        10
    db        9
    db        "old_pos:=rd_pos"
    db        10
    db        9
    db        "old_lastpos:=rd_lastpos"
    db        10
    db        10
    db        9
    db        "rd_pos:=s"
    db        10
    db        9
    db        "x:=m$read_r64()"
    db        10
    db        9
    db        "rd_pos:=old_pos"
    db        10
    db        9
    db        "rd_lastpos:=old_lastpos"
    db        10
    db        9
    db        "return x"
    db        10
    db        "end"
    db        10
    db        10
    db        "proc mclunimpl(ichar mess)="
    db        10
    db        9
    db        "printf("
    db        34
    db        "MCL-UNIMPL: %s"
    db        92
    db        "n"
    db        34
    db        ",mess)"
    db        10
    db        9
    db        "stop 1"
    db        10
    db        "end"
    db        10
    db        10
    db        "proc dumpstr(ichar s, int n, fbuffer=0)="
    db        10
    db        "!fbuffer=1 when outputting contents of buffer"
    db        10
    db        10
    db        9
    db        "ref ref char p"
    db        10
    db        10
    db        9
    db        "if outdev=str_io then"
    db        10
    db        9
    db        9
    db        "p:=cast(outchan)"
    db        10
    db        9
    db        9
    db        "if n then"
    db        10
    db        9
    db        9
    db        9
    db        "memcpy(p^,s,n)"
    db        10
    db        9
    db        9
    db        9
    db        "p^+:=n"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "p^^:=0"
    db        10
    db        9
    db        9
    db        "return"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "return when n=0"
    db        10
    db        9
    db        "if fbuffer and n>=2 and outdev=std_io then"
    db        10
    db        9
    db        9
    db        "--printptr"
    db        9
    db        9
    db        9
    db        9
    db        "!point to last char"
    db        10
    db        9
    db        9
    db        "if printptr^=10 then"
    db        10
    db        9
    db        9
    db        9
    db        "if (printptr-1)^=13 then"
    db        9
    db        9
    db        "!crlf"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "(printptr-1)^:=0"
    db        10
    db        9
    db        9
    db        9
    db        "else"
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "!lf only"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "printptr^:=0"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        "puts(printbuffer)"
    db        10
    db        9
    db        9
    db        9
    db        "return"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "case outdev"
    db        10
    db        9
    db        "when std_io then"
    db        10
    db        9
    db        9
    db        "printf("
    db        34
    db        "%.*s"
    db        34
    db        ",n,s)"
    db        10
    db        9
    db        "when file_io then"
    db        10
    db        9
    db        9
    db        "fprintf(outchan,"
    db        34
    db        "%.*s"
    db        34
    db        ",n,s)"
    db        10
    db        9
    db        "esac"
    db        10
    db        "end"
    db        10
    db        10
    db        "proc dumpprintbuffer="
    db        10
    db        9
    db        "if printlen then"
    db        10
    db        9
    db        9
    db        "dumpstr(&.printbuffer,printlen,1)"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "resetprintbuffer()"
    db        10
    db        "end"
    db        10
    db        10
    db        "proc resetprintbuffer="
    db        10
    db        9
    db        "printptr:=&.printbuffer"
    db        10
    db        9
    db        "printlen:=0"
    db        10
    db        "end"
    db        10
    db        10
    db        "proc addtobuffer(ichar s, int n)="
    db        10
    db        9
    db        "if printlen+n>=(printbuffer.len-8) then"
    db        10
    db        9
    db        9
    db        "dumpprintbuffer()"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "if n<printbuffer.len then"
    db        10
    db        9
    db        9
    db        "memcpy(printptr,s,n)"
    db        10
    db        9
    db        9
    db        "printptr+:=n"
    db        10
    db        9
    db        9
    db        "printlen+:=n"
    db        10
    db        9
    db        9
    db        "return"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "dumpstr(s, n)"
    db        9
    db        9
    db        9
    db        "!don't bother with buffer"
    db        10
    db        "end"
    db        10
    db        10
    db        "func getutfsize(ref char s)int ="
    db        10
    db        "!work out the size in bytes of the ascii or utf8 character that s points to"
    db        10
    db        9
    db        "int a"
    db        10
    db        10
    db        9
    db        "a:=s++^"
    db        10
    db        10
    db        9
    db        "if a=0 then"
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "!end of string"
    db        10
    db        9
    db        9
    db        "0"
    db        10
    db        9
    db        "elsif a.[7]=0 then"
    db        9
    db        9
    db        9
    db        9
    db        "!ascii"
    db        10
    db        9
    db        9
    db        "1"
    db        10
    db        9
    db        "elsif a.[7..5]=2x110 then"
    db        10
    db        9
    db        9
    db        "2"
    db        10
    db        9
    db        "elsif a.[7..4]=2x1110 then"
    db        10
    db        9
    db        9
    db        "3"
    db        10
    db        9
    db        "elsif a.[7..3]=2x11110 then"
    db        10
    db        9
    db        9
    db        "4"
    db        10
    db        9
    db        "else"
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "!error: just assume a byte of random binary"
    db        10
    db        9
    db        9
    db        "1"
    db        10
    db        9
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "!export fun fraction(real x)real = fmod(x,1.0)"
    db        10
    db        10
    db        "export fun m$sign_i64(int a)int = (a<0|-1| (a>0|1|0))"
    db        10
    db        10
    db        "export func m$sign_r64(real x)real ="
    db        10
    db        9
    db        "if x<0 then return -1 fi"
    db        10
    db        9
    db        "if x>0 then return 1 fi"
    db        10
    db        9
    db        "0"
    db        10
    db        "end"
    db        10
    db        0
L11482:
    db        "global record procinforec="
    db        10
    db        9
    db        "u16"
    db        9
    db        9
    db        9
    db        "fnindex"
    db        10
    db        9
    db        "byte"
    db        9
    db        9
    db        "rettype"
    db        10
    db        9
    db        "byte"
    db        9
    db        9
    db        "nparams"
    db        10
    db        9
    db        "[12]byte"
    db        9
    db        "paramlist"
    db        10
    db        "end"
    db        10
    db        10
    db        "!for print/read routines"
    db        10
    db        "!------------------------------------------"
    db        10
    db        "export record fmtrec="
    db        9
    db        "! (default)"
    db        10
    db        9
    db        "byte"
    db        9
    db        "minwidth"
    db        9
    db        "! n (0)   min field width (0 if not used or don't care)"
    db        10
    db        9
    db        "i8"
    db        9
    db        9
    db        "precision"
    db        9
    db        "! .n (0)   number of decimals/significant figures/max width"
    db        10
    db        9
    db        "byte"
    db        9
    db        "base"
    db        9
    db        9
    db        "! B,H or Xn (10)  2 to 16"
    db        10
    db        10
    db        9
    db        "char"
    db        9
    db        "quotechar"
    db        9
    db        "! Qc (0)   0 or '"
    db        34
    db        "' or c"
    db        10
    db        9
    db        "char"
    db        9
    db        "padchar"
    db        9
    db        9
    db        "! Pc, Z (' ')"
    db        10
    db        9
    db        "char"
    db        9
    db        "realfmt"
    db        9
    db        9
    db        "! E,F,G ('f') 'e' or 'f' or 'g'"
    db        10
    db        10
    db        9
    db        "char"
    db        9
    db        "plus"
    db        9
    db        9
    db        "! (0)   0 or '+'"
    db        10
    db        9
    db        "char"
    db        9
    db        "sepchar"
    db        9
    db        9
    db        "! Sc (0)   0 or ',' or c placed every 3 (base=10) or 4 digits"
    db        10
    db        9
    db        "char"
    db        9
    db        "lettercase"
    db        9
    db        "! A,a ('A') 'A' or 'a'"
    db        10
    db        9
    db        "char"
    db        9
    db        "justify"
    db        9
    db        9
    db        "! JL, JR, JC ('R') 'L' or 'R' or 'C'?"
    db        10
    db        9
    db        "char"
    db        9
    db        "suffix"
    db        9
    db        9
    db        "! Tc (0)   0 or 'B' or 'H' or c"
    db        10
    db        9
    db        "char"
    db        9
    db        "usigned"
    db        9
    db        9
    db        "! W (0)   0 or 'W' force unsigned o/p for ints (eg. for hex display)"
    db        10
    db        9
    db        "char"
    db        9
    db        "charmode"
    db        9
    db        "! C,M (0)  0 or 'C' or 'M'"
    db        9
    db        "o/p int as int or single char or multi-char"
    db        10
    db        9
    db        "char"
    db        9
    db        "heapmode"
    db        9
    db        "! D (0)  'D' for str-functions, return ptr to heap string"
    db        10
    db        9
    db        "char"
    db        9
    db        "param"
    db        9
    db        9
    db        "! Use int value for <fmtparam>"
    db        10
    db        9
    db        "byte"
    db        9
    db        "spare : (showtype:1, newline:1)"
    db        10
    db        "end"
    db        10
    db        10
    db        "int fmtparam"
    db        9
    db        9
    db        9
    db        "!as set with :'V'"
    db        10
    db        10
    db        "enumdata ="
    db        10
    db        9
    db        "std_io,file_io,str_io"
    db        10
    db        "end"
    db        10
    db        10
    db        "const comma = ','"
    db        10
    db        10
    db        "export int $cmdskip"
    db        9
    db        9
    db        9
    db        "!0 unless set by READMCX/etc"
    db        10
    db        10
    db        "export int needgap"
    db        9
    db        9
    db        9
    db        "= 0"
    db        10
    db        "int outdev"
    db        9
    db        9
    db        9
    db        "= std_io"
    db        10
    db        "filehandle outchan"
    db        9
    db        "= nil"
    db        10
    db        "ref char fmtstr "
    db        9
    db        "= nil"
    db        10
    db        10
    db        "const maxiostack=10"
    db        10
    db        "[maxiostack]filehandle"
    db        9
    db        "outchan_stack"
    db        10
    db        "[maxiostack]int"
    db        9
    db        9
    db        9
    db        "outdev_stack"
    db        10
    db        "[maxiostack]ref char"
    db        9
    db        "fmtstr_stack"
    db        10
    db        "[maxiostack]byte"
    db        9
    db        9
    db        "needgap_stack"
    db        10
    db        10
    db        "[maxiostack]ref char"
    db        9
    db        "ptr_stack"
    db        9
    db        9
    db        "!this one doesn't need pushing, as each is pointed to from outchan"
    db        10
    db        "int niostack=0"
    db        10
    db        10
    db        "[0:]char digits=s"
    db        34
    db        "0123456789ABCDEF"
    db        34
    db        10
    db        "const onesixty=360"
    db        10
    db        "fmtrec defaultfmt = (0,0, 10, 0,' ','f', 0,0,0,'R',0,0, 0,0,0,0)"
    db        10
    db        10
    db        "!Read buffer vars"
    db        10
    db        "export const rd_buffersize = 16384"
    db        9
    db        "!total capacity of line buffer"
    db        10
    db        10
    db        "export ref char rd_buffer"
    db        9
    db        9
    db        "! point to start of read buffer"
    db        10
    db        "export int rd_length"
    db        9
    db        9
    db        9
    db        "! length of this line (as read by readln)"
    db        10
    db        "export ref char rd_pos"
    db        9
    db        9
    db        9
    db        "! current position it's up to (next read starts here)"
    db        10
    db        "export ref char rd_lastpos"
    db        9
    db        9
    db        "! set by sread() just before reading used for reread()"
    db        10
    db        10
    db        "int termchar"
    db        9
    db        9
    db        9
    db        "! terminator char set by readxxx()"
    db        10
    db        "int itemerror"
    db        9
    db        9
    db        9
    db        "!"
    db        9
    db        "set by some read functions, eg for reals"
    db        10
    db        10
    db        "[4096]char printbuffer"
    db        10
    db        "ichar printptr"
    db        10
    db        "int printlen"
    db        10
    db        10
    db        "!------------------------------------------"
    db        10
    db        10
    db        "const maxparam=128"
    db        10
    db        "export int nsysparams"
    db        10
    db        "export int ncmdparams"
    db        10
    db        "export int nenvstrings"
    db        10
    db        "export [maxparam]ichar sysparams"
    db        10
    db        "!export ref[]ichar cmdparams"
    db        10
    db        "export ref[0:]ichar cmdparams"
    db        10
    db        "export ref[]ichar envstrings"
    db        10
    db        "!export [maxparam]ichar envstrings"
    db        10
    db        10
    db        "proc start="
    db        10
    db        9
    db        "i32 nargs"
    db        10
    db        9
    db        "int nargs64"
    db        10
    db        9
    db        "ref[]ichar args"
    db        10
    db        9
    db        "static [128]byte startupinfo"
    db        9
    db        9
    db        9
    db        "! 68 or 104 bytes"
    db        10
    db        9
    db        "int res"
    db        10
    db        10
    db        "!res:=1234567"
    db        10
    db        "!res:=0x1234567"
    db        10
    db        "!"
    db        10
    db        "!CPL "
    db        34
    db        "MSYS/START"
    db        34
    db        10
    db        10
    db        9
    db        "res:=__getmainargs(&nargs,cast(&args),cast(&envstrings),0,cast(&startupinfo))"
    db        10
    db        "!"
    db        9
    db        "res:=__getmainargs(&nargs,cast(&args),nil,0,cast(&startupinfo))"
    db        10
    db        9
    db        10
    db        9
    db        "nsysparams:=nargs"
    db        10
    db        10
    db        9
    db        "if nsysparams>maxparam then"
    db        10
    db        9
    db        9
    db        "printf("
    db        34
    db        "Too many params"
    db        92
    db        "n"
    db        34
    db        ")"
    db        10
    db        9
    db        9
    db        "stop 50"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "nargs64:=nargs"
    db        9
    db        9
    db        9
    db        "!bug when using 32-bit limit when compiled with mm"
    db        10
    db        9
    db        "for i:=1 to nargs64 do"
    db        10
    db        9
    db        9
    db        "sysparams[i]:=args[i]"
    db        10
    db        9
    db        "od"
    db        10
    db        9
    db        10
    db        "!assume nsysparams is >=1, since first is always the program name"
    db        10
    db        9
    db        "ncmdparams:=nsysparams-($cmdskip+1)"
    db        10
    db        9
    db        "cmdparams:=cast(&sysparams[$cmdskip+1])"
    db        10
    db        10
    db        9
    db        "int j:=1"
    db        10
    db        9
    db        "nenvstrings:=0"
    db        10
    db        9
    db        "while envstrings[j] do"
    db        10
    db        9
    db        9
    db        "++nenvstrings"
    db        10
    db        9
    db        9
    db        "++j"
    db        10
    db        9
    db        "od"
    db        10
    db        "end"
    db        10
    db        10
    db        "proc pushio="
    db        10
    db        9
    db        "if niostack>=maxiostack then"
    db        10
    db        9
    db        9
    db        "printf("
    db        34
    db        "Too many io levels"
    db        92
    db        "n"
    db        34
    db        ")"
    db        10
    db        9
    db        9
    db        "stop 53"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "++niostack"
    db        10
    db        9
    db        "outchan_stack[niostack]"
    db        9
    db        ":= outchan"
    db        10
    db        9
    db        "outdev_stack[niostack]"
    db        9
    db        ":= outdev"
    db        10
    db        9
    db        "fmtstr_stack[niostack]"
    db        9
    db        ":= fmtstr"
    db        10
    db        9
    db        "needgap_stack[niostack]"
    db        9
    db        ":= needgap"
    db        10
    db        9
    db        "needgap:=0"
    db        10
    db        9
    db        "fmtstr:=nil"
    db        10
    db        9
    db        "outchan:=nil"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_startfile(ref void dev)="
    db        10
    db        9
    db        "pushio()"
    db        10
    db        9
    db        "outchan:=cast(dev)"
    db        10
    db        9
    db        "if dev then"
    db        10
    db        9
    db        9
    db        "outdev:=file_io"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "outdev:=std_io"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "resetprintbuffer()"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_startstr(ref char s)="
    db        10
    db        9
    db        "ref ref char p"
    db        10
    db        9
    db        "pushio()"
    db        10
    db        10
    db        9
    db        "ptr_stack[niostack]:=s"
    db        10
    db        9
    db        "p:=&ptr_stack[niostack]"
    db        10
    db        10
    db        9
    db        "outchan:=cast(p)"
    db        10
    db        9
    db        "outdev:=str_io"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_startptr(ref ref char p)="
    db        10
    db        9
    db        "pushio()"
    db        10
    db        10
    db        9
    db        "outchan:=cast(p)"
    db        10
    db        9
    db        "outdev:=str_io"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_startcon="
    db        10
    db        9
    db        "pushio()"
    db        10
    db        9
    db        "outdev:=std_io"
    db        10
    db        9
    db        "resetprintbuffer()"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_setfmt(ref char format)="
    db        10
    db        9
    db        "fmtstr:=format"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_end="
    db        10
    db        9
    db        "needgap:=0"
    db        10
    db        9
    db        "nextfmtchars(1)"
    db        10
    db        9
    db        "if niostack=1 and outdev in [std_io,file_io] then"
    db        10
    db        9
    db        9
    db        "dumpprintbuffer()"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "if niostack=0 then return fi"
    db        10
    db        9
    db        "outchan"
    db        9
    db        ":= outchan_stack[niostack]"
    db        10
    db        9
    db        "outdev"
    db        9
    db        ":= outdev_stack[niostack]"
    db        10
    db        9
    db        "fmtstr"
    db        9
    db        ":= fmtstr_stack[niostack]"
    db        10
    db        9
    db        "needgap"
    db        9
    db        ":= needgap_stack[niostack]"
    db        10
    db        10
    db        9
    db        "--niostack"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_ptr(u64 a,ichar fmtstyle=nil)="
    db        10
    db        9
    db        "if fmtstyle=nil then"
    db        10
    db        9
    db        9
    db        "fmtstyle:="
    db        34
    db        "z8H"
    db        34
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "m$print_u64(a,fmtstyle)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_ptr_nf(u64 a)="
    db        10
    db        9
    db        "m$print_ptr(a)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_i64(i64 a,ichar fmtstyle=nil)="
    db        10
    db        9
    db        "[40]char s"
    db        10
    db        9
    db        "fmtrec fmt"
    db        10
    db        9
    db        "int n"
    db        10
    db        10
    db        9
    db        "nextfmtchars()"
    db        10
    db        9
    db        "if fmtstyle=nil then"
    db        10
    db        9
    db        9
    db        "if a>=0 then"
    db        10
    db        9
    db        9
    db        9
    db        "n:=u64tostr(a,&.s,10,0)"
    db        10
    db        9
    db        9
    db        "elsif a=i64.min then"
    db        10
    db        9
    db        9
    db        9
    db        "fmt:=defaultfmt"
    db        10
    db        9
    db        9
    db        9
    db        "dofmt"
    db        10
    db        10
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        "s[1]:='-'"
    db        10
    db        9
    db        9
    db        9
    db        "n:=u64tostr(-a,&s[2],10,0)+1"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        9
    db        "printstr_n(&.s,n)"
    db        10
    db        10
    db        9
    db        "else"
    db        10
    db        10
    db        9
    db        9
    db        "strtofmt(fmtstyle,-1,&fmt)"
    db        10
    db        9
    db        9
    db        "if fmt.param='V' then"
    db        10
    db        9
    db        9
    db        9
    db        "fmtparam:=a"
    db        10
    db        9
    db        9
    db        9
    db        "needgap:=0"
    db        10
    db        9
    db        9
    db        "else"
    db        10
    db        "dofmt:"
    db        10
    db        9
    db        9
    db        9
    db        "tostr_i64(a,&fmt)"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "needgap:=1"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_i64_nf(i64 a)="
    db        10
    db        9
    db        "m$print_i64(a)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_bool(i64 a, ichar fmtstyle=nil)="
    db        10
    db        9
    db        "if a then"
    db        10
    db        9
    db        9
    db        "m$print_str("
    db        34
    db        "True"
    db        34
    db        ",fmtstyle)"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "m$print_str("
    db        34
    db        "False"
    db        34
    db        ",fmtstyle)"
    db        10
    db        9
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_u64(u64 a,ichar fmtstyle=nil)="
    db        10
    db        9
    db        "[40]char s"
    db        10
    db        9
    db        "fmtrec fmt"
    db        10
    db        10
    db        9
    db        "nextfmtchars()"
    db        10
    db        9
    db        "if fmtstyle=nil then"
    db        10
    db        9
    db        9
    db        "sprintf(&.s,"
    db        34
    db        "%llu"
    db        34
    db        ",a)"
    db        10
    db        9
    db        9
    db        "printstr(&.s)"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "strtofmt(fmtstyle,-1,&fmt)"
    db        10
    db        9
    db        9
    db        "tostr_u64(a,&fmt)"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "needgap:=1"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_r64(real x,ichar fmtstyle=nil)="
    db        10
    db        9
    db        "[360]char s"
    db        10
    db        9
    db        "fmtrec fmt"
    db        10
    db        10
    db        9
    db        "nextfmtchars()"
    db        10
    db        9
    db        "if fmtstyle=nil then"
    db        10
    db        9
    db        9
    db        "sprintf(&.s,"
    db        34
    db        "%f"
    db        34
    db        ",x)"
    db        10
    db        9
    db        9
    db        "printstr(&.s)"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "strtofmt(fmtstyle,-1,&fmt)"
    db        10
    db        9
    db        9
    db        "tostr_r64(x,&fmt)"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "needgap:=1"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_r32(r32 x,ichar fmtstyle=nil)="
    db        10
    db        9
    db        "m$print_r64(x,fmtstyle)"
    db        10
    db        "end"
    db        10
    db        10
    db        "global proc m$print_c8(i64 a,ichar fmtstyle=nil)="
    db        10
    db        9
    db        "[32]char s"
    db        10
    db        "!"
    db        9
    db        "int cc@s"
    db        10
    db        9
    db        "fmtrec fmt"
    db        10
    db        9
    db        "int n"
    db        10
    db        9
    db        "byte charmode:=0"
    db        10
    db        10
    db        9
    db        "nextfmtchars()"
    db        10
    db        10
    db        9
    db        "if fmtstyle then"
    db        10
    db        9
    db        9
    db        "strtofmt(fmtstyle,-1, &fmt)"
    db        10
    db        9
    db        9
    db        "charmode:=fmt.charmode"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "if charmode='M' then"
    db        10
    db        9
    db        9
    db        "n:=domultichar(ref char(&a), 8, &.s, &fmt)"
    db        10
    db        "!"
    db        9
    db        9
    db        "n:=domultichar(ref char(&a), 8, &.str, fmt)"
    db        10
    db        9
    db        "else"
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "!assume 'C'"
    db        10
    db        9
    db        9
    db        "(ref int(&s)^):=a"
    db        9
    db        10
    db        9
    db        9
    db        "s[9]:=0"
    db        10
    db        10
    db        9
    db        9
    db        "n:=getutfsize(s)"
    db        9
    db        9
    db        9
    db        "!isolate size of next char"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "printstr_n(s,n)"
    db        10
    db        10
    db        9
    db        "needgap:=1"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_str(ichar s, fmtstyle=nil)="
    db        10
    db        9
    db        "nextfmtchars()"
    db        10
    db        10
    db        9
    db        "if s=nil then"
    db        10
    db        9
    db        9
    db        "printstr("
    db        34
    db        "<null>"
    db        34
    db        ")"
    db        10
    db        9
    db        9
    db        "return"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "fmtrec fmt"
    db        10
    db        9
    db        "if fmtstyle=nil then"
    db        10
    db        9
    db        9
    db        "printstr(s)"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "strtofmt(fmtstyle,-1,&fmt)"
    db        10
    db        9
    db        9
    db        "tostr_str(s,-1,&fmt)"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "needgap:=1"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_strn(ichar s, int length, ichar fmtstyle=nil)="
    db        10
    db        9
    db        "nextfmtchars()"
    db        10
    db        10
    db        9
    db        "if s=nil then"
    db        10
    db        9
    db        9
    db        "printstr("
    db        34
    db        "<null>"
    db        34
    db        ")"
    db        10
    db        9
    db        9
    db        "return"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "fmtrec fmt"
    db        10
    db        9
    db        "if fmtstyle=nil then"
    db        10
    db        9
    db        9
    db        "printstr_n(s,length)"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "strtofmt(fmtstyle,-1,&fmt)"
    db        10
    db        9
    db        9
    db        "tostr_str(s,length,&fmt)"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "needgap:=1"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_str_nf(ichar s)="
    db        10
    db        9
    db        "m$print_str(s)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_strsl(slice[]char s, ichar fmtstyle=nil)="
    db        10
    db        "ABORTPROGRAM("
    db        34
    db        "PRTSL"
    db        34
    db        ")"
    db        10
    db        "!"
    db        9
    db        "nextfmtchars()"
    db        10
    db        "!"
    db        10
    db        "!!"
    db        9
    db        "fmtrec fmt"
    db        10
    db        "!"
    db        10
    db        "!"
    db        9
    db        "if fmtstyle=nil then"
    db        10
    db        "!"
    db        9
    db        9
    db        "printstr_n(cast(s.sliceptr),s.len)"
    db        10
    db        "!!"
    db        9
    db        9
    db        "printstr_n(cast(ss.str),ss.length)"
    db        10
    db        "!"
    db        9
    db        "else"
    db        10
    db        "!"
    db        9
    db        9
    db        "abortprogram("
    db        34
    db        "FORMATED PRINT SLICE NOT READY"
    db        34
    db        ")"
    db        10
    db        "!!"
    db        9
    db        9
    db        "strtofmt(fmtstyle,-1,&fmt)"
    db        10
    db        "!!"
    db        9
    db        9
    db        "tostr_str(s,s.len,&fmt)"
    db        10
    db        "!"
    db        9
    db        "fi"
    db        10
    db        "!"
    db        9
    db        "needgap:=1"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_newline="
    db        10
    db        "!PUTS("
    db        34
    db        "<NEWLINE>"
    db        34
    db        ")"
    db        10
    db        9
    db        "needgap:=0"
    db        10
    db        9
    db        "nextfmtchars(1)"
    db        10
    db        9
    db        "printstr("
    db        34
    db        92
    db        "w"
    db        34
    db        ")"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_nogap="
    db        10
    db        9
    db        "needgap:=0"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc m$print_space="
    db        10
    db        9
    db        "needgap:=0"
    db        10
    db        9
    db        "printstr("
    db        34
    db        " "
    db        34
    db        ")"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc printstr(ichar s)="
    db        10
    db        9
    db        "printstr_n(s,strlen(s))"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc printstr_n(ichar s,int n)="
    db        10
    db        10
    db        "!"
    db        9
    db        "return when n=0"
    db        10
    db        10
    db        "!"
    db        9
    db        "if niostack=1 and outdev in [std_io,file_io] then"
    db        10
    db        "!!puts("
    db        34
    db        "ADDTO BUFF"
    db        34
    db        ")"
    db        10
    db        "!"
    db        9
    db        9
    db        "addtobuffer(s,n)"
    db        10
    db        "!"
    db        9
    db        "else"
    db        10
    db        "!printf("
    db        34
    db        "DUMPSTR %lld"
    db        92
    db        "n"
    db        34
    db        ", n)"
    db        10
    db        9
    db        9
    db        "dumpstr(s,n)"
    db        10
    db        "!"
    db        9
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc printstrn_app(ichar s, int length, filehandle f=nil)="
    db        10
    db        "if length then"
    db        10
    db        9
    db        "if f=nil then"
    db        10
    db        9
    db        9
    db        "printf("
    db        34
    db        "%.*s"
    db        34
    db        ",length,s)"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "fprintf(f,"
    db        34
    db        "%.*s"
    db        34
    db        ",length,s)"
    db        10
    db        9
    db        "fi"
    db        10
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "proc printchar(int ch)="
    db        10
    db        9
    db        "[4]char str"
    db        10
    db        10
    db        9
    db        "str[1]:=ch"
    db        10
    db        9
    db        "str[2]:=0"
    db        10
    db        9
    db        "printstr_n(str,1)"
    db        10
    db        "end"
    db        10
    db        10
    db        "global proc nextfmtchars(int lastx=0)="
    db        10
    db        9
    db        "char c"
    db        10
    db        9
    db        "ref char pstart"
    db        10
    db        9
    db        "int n"
    db        10
    db        9
    db        "if not fmtstr then"
    db        9
    db        9
    db        9
    db        "!format not in use"
    db        10
    db        9
    db        9
    db        "if needgap then"
    db        10
    db        9
    db        9
    db        9
    db        "printchar(' ')"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "needgap:=0"
    db        10
    db        9
    db        9
    db        "return"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "pstart:=fmtstr"
    db        10
    db        9
    db        "n:=0"
    db        10
    db        10
    db        9
    db        "do"
    db        10
    db        9
    db        9
    db        "c:=fmtstr^"
    db        10
    db        9
    db        9
    db        "case c"
    db        10
    db        9
    db        9
    db        "when '#' then"
    db        10
    db        9
    db        9
    db        9
    db        "if lastx then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "goto skip"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        "++fmtstr"
    db        10
    db        9
    db        9
    db        9
    db        "if n then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "printstr_n(pstart,n)"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        "return"
    db        10
    db        9
    db        9
    db        "when 0 then"
    db        10
    db        9
    db        9
    db        9
    db        "if n then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "printstr_n(pstart,n)"
    db        10
    db        9
    db        9
    db        9
    db        "elsif not lastx then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "printstr_n("
    db        34
    db        "|"
    db        34
    db        ",1)"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        "return"
    db        10
    db        9
    db        9
    db        "when '~' then"
    db        10
    db        9
    db        9
    db        9
    db        "if n then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "printstr_n(pstart,n)"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "n:=0"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        "++fmtstr"
    db        10
    db        9
    db        9
    db        9
    db        "c:=fmtstr^"
    db        10
    db        9
    db        9
    db        9
    db        "if c then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "++fmtstr"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "printchar(c)"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        "pstart:=fmtstr"
    db        10
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        "skip:"
    db        10
    db        9
    db        9
    db        9
    db        "++n"
    db        10
    db        9
    db        9
    db        9
    db        "++fmtstr"
    db        10
    db        9
    db        9
    db        "esac"
    db        10
    db        9
    db        "od"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc strtofmt(ref char s,int slen,ref fmtrec fmt) ="
    db        9
    db        9
    db        "!PC_STRTOFMT"
    db        10
    db        "!convert format code string in s, to fmtrec at fmt^"
    db        10
    db        "!Format code is a string containing the following char codes (upper or lower when mostly)"
    db        10
    db        "!n"
    db        9
    db        "Width"
    db        10
    db        "!.n"
    db        9
    db        "Max width/precision"
    db        10
    db        "!A"
    db        9
    db        "Convert to upper case"
    db        10
    db        "!a"
    db        9
    db        "Convert to lower case"
    db        10
    db        "!B"
    db        9
    db        "Binary"
    db        10
    db        "!C"
    db        9
    db        "Show int as single n-bit (unicode) character"
    db        10
    db        "!D"
    db        9
    db        "Duplicate string returned via STRINT etc on heap"
    db        10
    db        "!E,F,G"
    db        9
    db        "Specify format for double (corresponds to C format codes)"
    db        10
    db        "!F"
    db        10
    db        "!G"
    db        10
    db        "!H"
    db        9
    db        "Hex"
    db        10
    db        "!JC"
    db        9
    db        "Justify centre"
    db        10
    db        "!JL"
    db        9
    db        "Justify left"
    db        10
    db        "!JR"
    db        9
    db        "Justify right"
    db        10
    db        "!M"
    db        9
    db        "Show int as multi-bit (unicode) character"
    db        10
    db        "!M"
    db        9
    db        "HEAPMODE???"
    db        10
    db        "!O"
    db        9
    db        "Octal"
    db        10
    db        "!Pc"
    db        9
    db        "Use padding char c"
    db        10
    db        "!Q"
    db        9
    db        "Add double quotes around string (and deal with embedded quotes)"
    db        10
    db        "!'"
    db        9
    db        "Add single quotes around string (and deal with embedded quotes)"
    db        10
    db        "!Sc"
    db        9
    db        "Use separator char c between every 3 or 4 digits"
    db        10
    db        "!Tc"
    db        9
    db        "Use terminator char c (typically B or H)"
    db        10
    db        "!U"
    db        9
    db        "Show ints as unsigned"
    db        10
    db        "!V"
    db        9
    db        "For ints, don't display: store value as parameter for subsequent '*'"
    db        10
    db        "!W"
    db        9
    db        "Unsigned"
    db        10
    db        "!Xn"
    db        9
    db        "Use base n (n is hex 0 to F)"
    db        10
    db        "!Z"
    db        9
    db        "Use "
    db        34
    db        "0"
    db        34
    db        " padding"
    db        10
    db        "!+"
    db        9
    db        "Always have + or - in front of integers"
    db        10
    db        "!~"
    db        9
    db        "Quote char is ~"
    db        10
    db        "!*"
    db        9
    db        "Same as n but uses parameter set with :'V' on previous int"
    db        10
    db        10
    db        9
    db        "int c, base"
    db        10
    db        9
    db        "byte wset"
    db        10
    db        9
    db        "int n"
    db        10
    db        9
    db        "[0:100]char str"
    db        10
    db        10
    db        9
    db        "fmt^:=defaultfmt"
    db        10
    db        10
    db        9
    db        "if s=nil then return fi"
    db        10
    db        10
    db        9
    db        "if slen=-1 then slen:=strlen(s) fi"
    db        10
    db        10
    db        9
    db        "memcpy(&.str,s,slen)"
    db        9
    db        9
    db        "!convert s/slen to zero-terminated string"
    db        10
    db        9
    db        "str[slen]:=0"
    db        10
    db        9
    db        "s:=&.str"
    db        10
    db        10
    db        9
    db        "wset:=0"
    db        10
    db        9
    db        "while s^ do"
    db        10
    db        9
    db        9
    db        "c:=s^"
    db        10
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        9
    db        "if c='A' then fmt.lettercase:='A'"
    db        10
    db        9
    db        9
    db        "elsif c='a' then fmt.lettercase:='a'"
    db        10
    db        9
    db        9
    db        "elseswitch toupper(c)"
    db        10
    db        9
    db        9
    db        "when 'B' then fmt.base:=2"
    db        10
    db        9
    db        9
    db        "when 'H' then fmt.base:=16"
    db        10
    db        9
    db        9
    db        "when 'O' then fmt.base:=8"
    db        10
    db        9
    db        9
    db        "when 'X' then"
    db        10
    db        9
    db        9
    db        9
    db        "base:=0"
    db        10
    db        9
    db        9
    db        9
    db        "do"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "c:=s^"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "if c in '0'..'9' then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "base:=base*10+c-'0'"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "exit"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        "od"
    db        10
    db        9
    db        9
    db        9
    db        "if base in 2..16 then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "fmt.base:=base"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        9
    db        "when 'Q' then fmt.quotechar:='"
    db        34
    db        "'"
    db        10
    db        9
    db        9
    db        "when 'J' then"
    db        10
    db        9
    db        9
    db        9
    db        "fmt.justify:=toupper(s^)"
    db        10
    db        9
    db        9
    db        9
    db        "if s^ then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "when 'Z' then fmt.padchar:='0'"
    db        10
    db        9
    db        9
    db        "when 'S' then"
    db        10
    db        9
    db        9
    db        9
    db        "fmt.sepchar:=s^"
    db        10
    db        9
    db        9
    db        9
    db        "if s^ then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "when 'P' then"
    db        10
    db        9
    db        9
    db        9
    db        "fmt.padchar:=s^"
    db        10
    db        9
    db        9
    db        9
    db        "if s^ then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "when 'T' then"
    db        10
    db        9
    db        9
    db        9
    db        "fmt.suffix:=s^"
    db        10
    db        9
    db        9
    db        9
    db        "if s^ then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "when 'U' then fmt.usigned:='W'"
    db        10
    db        9
    db        9
    db        "when 'E' then fmt.realfmt:='e'"
    db        10
    db        9
    db        9
    db        "when 'F' then fmt.realfmt:='f'"
    db        10
    db        9
    db        9
    db        "when 'G' then fmt.realfmt:='g'"
    db        10
    db        9
    db        9
    db        "when 'D' then fmt.heapmode:='D'"
    db        10
    db        9
    db        9
    db        "when 'C' then fmt.charmode:='C'"
    db        10
    db        9
    db        9
    db        "when 'M' then fmt.charmode:='M'"
    db        10
    db        9
    db        9
    db        "when 'V' then fmt.param:='V'"
    db        10
    db        9
    db        9
    db        "when 'Y' then fmt.showtype:=1"
    db        10
    db        9
    db        9
    db        "when 'N' then fmt.newline:=1"
    db        10
    db        9
    db        9
    db        "elsecase c"
    db        10
    db        9
    db        9
    db        "when '.' then"
    db        10
    db        9
    db        9
    db        9
    db        "wset:=1"
    db        10
    db        9
    db        9
    db        "when comma,'_' then fmt.sepchar:=c"
    db        10
    db        9
    db        9
    db        "when '+' then fmt.plus:='+'"
    db        10
    db        9
    db        9
    db        "when '~' then fmt.quotechar:='~'"
    db        10
    db        9
    db        9
    db        "when '*' then"
    db        10
    db        9
    db        9
    db        9
    db        "n:=fmtparam"
    db        10
    db        9
    db        9
    db        9
    db        "goto gotwidth"
    db        10
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        "if c>='0' and c<='9' then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "n:=c-'0'"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "do"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "c:=s^"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "if s^=0 then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "exit"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "if c>='0' and c<='9' then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "n:=n*10+c-'0'"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "exit"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "od"
    db        10
    db        "gotwidth:"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "if not wset then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "fmt.minwidth:=n"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "wset:=1"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "fmt.precision:=n"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        "od"
    db        10
    db        "end"
    db        10
    db        10
    db        "function domultichar (ref char p,int n,ref char dest,ref fmtrec fmt)int ="
    db        10
    db        "!there are n (4 or 8) chars at p.!"
    db        10
    db        "!There could be 0 to 4 or 8 printable chars converted to string at dest"
    db        10
    db        9
    db        "[0:20]char str"
    db        10
    db        9
    db        "ref char q"
    db        10
    db        9
    db        "int nchars"
    db        10
    db        10
    db        9
    db        "q:=&.str"
    db        10
    db        10
    db        9
    db        "nchars:=n"
    db        10
    db        10
    db        9
    db        "to n do"
    db        10
    db        9
    db        9
    db        "if p^=0 then exit fi"
    db        10
    db        9
    db        9
    db        "q^:=p^"
    db        10
    db        9
    db        9
    db        "++q"
    db        10
    db        9
    db        9
    db        "++p"
    db        10
    db        9
    db        "od"
    db        10
    db        9
    db        "q^:=0"
    db        10
    db        10
    db        9
    db        "return expandstr(&.str,dest,strlen(&.str),fmt)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function expandstr(ref char s,ref char t,int n,ref fmtrec fmt)int ="
    db        9
    db        9
    db        "!EXPANDSTR"
    db        10
    db        "!s contains a partly stringified value."
    db        10
    db        "!widen s if necessary, according to fmt, and copy result to t"
    db        10
    db        "!n is current length of s"
    db        10
    db        "!note) = for non-numeric strings, fmt.base should be set to 0, to avoid moving"
    db        10
    db        "!a leading +/- when right-justifying with '0' padding."
    db        10
    db        "!t MUST be big enough for the expanded string; caller must take care of this"
    db        10
    db        "!result will be zero-terminated, for use in this module"
    db        10
    db        10
    db        9
    db        "int i,w,m"
    db        10
    db        10
    db        "!check to see if result is acceptable as it is"
    db        10
    db        9
    db        "w:=fmt.minwidth"
    db        10
    db        9
    db        "if w=0 or w<=n then"
    db        9
    db        9
    db        "! allow str to be longer than minwidth"
    db        10
    db        9
    db        9
    db        "strncpy(t,s,n)"
    db        10
    db        9
    db        9
    db        "(t+n)^:=0"
    db        10
    db        9
    db        9
    db        "return n"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "if fmt.justify='L' then"
    db        9
    db        "! left-justify"
    db        10
    db        9
    db        9
    db        "strncpy(t,s,n)"
    db        10
    db        9
    db        9
    db        "t+:=n"
    db        10
    db        9
    db        9
    db        "for i:=1 to w-n do"
    db        10
    db        9
    db        9
    db        9
    db        "t^:=fmt.padchar"
    db        10
    db        9
    db        9
    db        9
    db        "++t"
    db        10
    db        9
    db        9
    db        "od"
    db        10
    db        9
    db        9
    db        "t^:=0"
    db        10
    db        9
    db        "elsif fmt.justify='R' then"
    db        10
    db        9
    db        9
    db        "if fmt.padchar='0' and fmt.base and (s^='-' or s^='+') then ! need to move sign outside "
    db        10
    db        9
    db        9
    db        9
    db        "t^:=s^"
    db        10
    db        9
    db        9
    db        9
    db        "++t"
    db        10
    db        9
    db        9
    db        9
    db        "to w-n do"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "t^:=fmt.padchar"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "++t"
    db        10
    db        9
    db        9
    db        9
    db        "od"
    db        10
    db        9
    db        9
    db        9
    db        "strncpy(t,s+1,n-1)"
    db        10
    db        9
    db        9
    db        9
    db        "(t+n-1)^:=0"
    db        10
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        "to w-n do"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "t^:=fmt.padchar"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "++t"
    db        10
    db        9
    db        9
    db        9
    db        "od"
    db        10
    db        9
    db        9
    db        9
    db        "strncpy(t,s,n)"
    db        10
    db        9
    db        9
    db        9
    db        "(t+n)^:=0"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "else"
    db        9
    db        9
    db        9
    db        9
    db        "! centre-justify?"
    db        10
    db        10
    db        9
    db        9
    db        "m:=(w-n+1)/2"
    db        10
    db        9
    db        9
    db        "to m do"
    db        10
    db        9
    db        9
    db        9
    db        "t^:=fmt.padchar"
    db        10
    db        9
    db        9
    db        9
    db        "++t"
    db        10
    db        9
    db        9
    db        "od"
    db        10
    db        9
    db        9
    db        "strncpy(t,s,n)"
    db        10
    db        9
    db        9
    db        "t+:=n"
    db        10
    db        9
    db        9
    db        "to w-n-m do"
    db        10
    db        9
    db        9
    db        9
    db        "t^:=fmt.padchar"
    db        10
    db        9
    db        9
    db        9
    db        "++t"
    db        10
    db        9
    db        9
    db        "od"
    db        10
    db        9
    db        9
    db        "t^:=0"
    db        10
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "return w"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function u64tostr(u64 aa,ref char s,word base,int sep)int ="
    db        9
    db        9
    db        "!U64TOSTR"
    db        10
    db        "!convert 64-bit int a to string in s^"
    db        10
    db        "!base is number base, usually 10 but can be 2 or 16. Other bases allowed"
    db        10
    db        "!result when a=minint (will give "
    db        34
    db        "<minint>"
    db        34
    db        ")"
    db        10
    db        9
    db        "[0:onesixty]char t"
    db        10
    db        9
    db        "u64 dd"
    db        10
    db        9
    db        "int i,j,k,g"
    db        10
    db        9
    db        "ref char s0"
    db        10
    db        10
    db        9
    db        "i:=0"
    db        10
    db        9
    db        "k:=0"
    db        10
    db        9
    db        "g:=(base=10|3|4)"
    db        10
    db        10
    db        9
    db        "repeat"
    db        10
    db        "!"
    db        9
    db        9
    db        "if base=10 then"
    db        9
    db        9
    db        9
    db        "!BUGGY FOR AA OVER I64.MAX"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        "assem"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "mov"
    db        9
    db        9
    db        "rcx, [aa]"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "mov"
    db        9
    db        9
    db        "rax, rcx"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "mov"
    db        9
    db        9
    db        "rdx, 7378697629483820647"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "imul"
    db        9
    db        "rdx"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "mov"
    db        9
    db        9
    db        "rax, rdx"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "mov"
    db        9
    db        9
    db        "rdx, rcx"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "sar"
    db        9
    db        9
    db        "rdx, 63"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "sar"
    db        9
    db        9
    db        "rax, 2"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "sub"
    db        9
    db        9
    db        "rax, rdx"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "lea"
    db        9
    db        9
    db        "rdx, [rax+rax*4]"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "add"
    db        9
    db        9
    db        "rdx, rdx"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "sub"
    db        9
    db        9
    db        "rcx, rdx"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "mov"
    db        9
    db        9
    db        "[dd], rcx"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        9
    db        "mov"
    db        9
    db        9
    db        "[aa], rax"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        "end"
    db        10
    db        "!"
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        "dd:=aa rem base"
    db        10
    db        9
    db        9
    db        9
    db        "aa:=aa/base"
    db        10
    db        "!"
    db        9
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        9
    db        "t[++i]:=digits[dd]"
    db        10
    db        10
    db        "!BUG in separator logic, doesn't work when leading zeros used, eg. printing"
    db        10
    db        "!out a full length binary"
    db        10
    db        "!so perhaps move this out to expandstr"
    db        10
    db        9
    db        9
    db        "++k"
    db        10
    db        9
    db        9
    db        "if sep and aa<>0 and k=g then"
    db        10
    db        9
    db        9
    db        9
    db        "t[++i]:=sep"
    db        10
    db        9
    db        9
    db        9
    db        "k:=0"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        "until aa=0"
    db        10
    db        10
    db        9
    db        "j:=i"
    db        10
    db        9
    db        "s0:=s"
    db        10
    db        9
    db        "while i do"
    db        10
    db        9
    db        9
    db        "s^:=t[i--]"
    db        10
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        "od"
    db        10
    db        9
    db        "s^:=0"
    db        10
    db        10
    db        9
    db        "return j"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function i64tostrfmt(i64 aa,ref char s,ref fmtrec fmt)int ="
    db        10
    db        "!a is signed 64-bit int/long, fmt is a ref to a filled-in fmtrec"
    db        10
    db        "!convert a to a string in s, according to fmt"
    db        10
    db        "!a basic conversion is done first,: the field manipulation is done"
    db        10
    db        "!signed=1 for int, 0 for u32 (fmt.unsigned forces ints to be treated as longs)"
    db        10
    db        "!returns length of s"
    db        10
    db        9
    db        "[0:onesixty]char str"
    db        9
    db        9
    db        9
    db        9
    db        "! allow for binary with separators!"
    db        10
    db        9
    db        "int n, usigned"
    db        10
    db        9
    db        "const i64 mindint=0x8000'0000'0000'0000"
    db        10
    db        10
    db        9
    db        "usigned:=0"
    db        10
    db        9
    db        "if fmt.usigned then"
    db        10
    db        9
    db        9
    db        "usigned:=1"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "if aa=mindint and not usigned then"
    db        9
    db        9
    db        "! minint"
    db        10
    db        10
    db        9
    db        9
    db        "str[0]:='-'"
    db        10
    db        9
    db        9
    db        "n:=i64mintostr(&str[1],fmt.base,fmt.sepchar)+1"
    db        10
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "if (not usigned and aa<0) or fmt.plus then"
    db        10
    db        9
    db        9
    db        9
    db        "if aa<0 then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "aa:=-aa"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "str[0]:='-'"
    db        10
    db        9
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "str[0]:='+'"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        "n:=u64tostr(aa,&str[1],fmt.base,fmt.sepchar)+1"
    db        10
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        "n:=u64tostr(aa,&.str,fmt.base,fmt.sepchar)"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "if fmt.suffix then"
    db        10
    db        9
    db        9
    db        "str[n]:=fmt.suffix"
    db        10
    db        9
    db        9
    db        "str[++n]:=0"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        "!str uses upper cases for hex/etc see if lc needed"
    db        10
    db        9
    db        "if (fmt.base>10 or fmt.suffix) and fmt.lettercase='a'"
    db        9
    db        "then"
    db        9
    db        "! need lower when"
    db        10
    db        9
    db        9
    db        "convlcstring(&.str)"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        "!at this point, n is the str length including signs and suffix"
    db        10
    db        9
    db        "return expandstr(&.str,s,n,fmt)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function u64tostrfmt(i64 aa,ref char s,ref fmtrec fmt)int ="
    db        9
    db        9
    db        "!U64TOSTRFMT"
    db        10
    db        "!see i64tostrfmt"
    db        10
    db        9
    db        "[0:onesixty]char str"
    db        9
    db        9
    db        9
    db        9
    db        "! allow for binary with separators!"
    db        10
    db        9
    db        "int n"
    db        10
    db        10
    db        9
    db        "n:=u64tostr(aa,&.str,fmt.base,fmt.sepchar)"
    db        10
    db        10
    db        9
    db        "if fmt.suffix then"
    db        10
    db        9
    db        9
    db        "str[n]:=fmt.suffix"
    db        10
    db        9
    db        9
    db        "str[++n]:=0"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        "!str uses upper cases for hex/etc see if lc needed"
    db        10
    db        9
    db        "if fmt.base>10 or fmt.suffix and fmt.lettercase='a'"
    db        9
    db        "then"
    db        9
    db        "! need lower when"
    db        10
    db        "!"
    db        9
    db        9
    db        "convlcstring(&.str)"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        "!at this point, n is the str length including signs and suffix"
    db        10
    db        9
    db        "return expandstr(&.str,s,n,fmt)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function i64mintostr(ref char s,int base,int sep)int ="
    db        9
    db        9
    db        "!I64MINTOSTR"
    db        10
    db        "!convert minint to string in s do not include minus sign"
    db        10
    db        "!return number of chars in string"
    db        10
    db        9
    db        "[0:onesixty]char t"
    db        10
    db        9
    db        "int i,j,k,g"
    db        10
    db        10
    db        9
    db        "case base"
    db        10
    db        9
    db        "when 10 then"
    db        10
    db        9
    db        9
    db        "strcpy(&t[0],"
    db        34
    db        "9223372036854775808"
    db        34
    db        ")"
    db        10
    db        9
    db        9
    db        "j:=3"
    db        10
    db        9
    db        "when 16 then"
    db        10
    db        9
    db        9
    db        "strcpy(&t[0],"
    db        34
    db        "8000000000000000"
    db        34
    db        ")"
    db        10
    db        9
    db        9
    db        "j:=1"
    db        10
    db        9
    db        "when 2 then"
    db        10
    db        9
    db        9
    db        "strcpy(&t[0],"
    db        34
    db        "1000000000000000000000000000000000000000000000000000000000000000"
    db        34
    db        ")"
    db        10
    db        9
    db        9
    db        "j:=7"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "strcpy(&t[0],"
    db        34
    db        "<mindint>"
    db        34
    db        ")"
    db        10
    db        9
    db        "esac"
    db        10
    db        10
    db        9
    db        "i:=strlen(&t[0])"
    db        10
    db        9
    db        "s+:=i"
    db        10
    db        9
    db        "if sep then"
    db        10
    db        9
    db        9
    db        "s+:=j"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "s^:=0"
    db        10
    db        10
    db        9
    db        "k:=0"
    db        10
    db        9
    db        "g:=(base=10|3|4)"
    db        10
    db        10
    db        9
    db        "while i do"
    db        10
    db        9
    db        9
    db        "--s"
    db        10
    db        9
    db        9
    db        "s^:=t[i-- -1]"
    db        10
    db        9
    db        9
    db        "if sep and i and ++k=g then"
    db        10
    db        9
    db        9
    db        9
    db        "--s"
    db        10
    db        9
    db        9
    db        9
    db        "s^:=sep"
    db        10
    db        9
    db        9
    db        9
    db        "k:=0"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        "od"
    db        10
    db        9
    db        "return strlen(s)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function strtostrfmt(ref char s,ref char t,int n,ref fmtrec fmt)int ="
    db        10
    db        "!s is a string process according to fmtrec fmt^, and return result in t"
    db        10
    db        "!caller should check whether any changes are required to s (now it can just use s), but this"
    db        10
    db        "!check is done here anyway (with a simple copy to t)"
    db        10
    db        "!n is current length of s"
    db        10
    db        "!return length of t"
    db        10
    db        "!Three processing stages:"
    db        10
    db        "!1 Basic input string s"
    db        10
    db        "!2 Additions or mods: quotes, suffix, when conversion"
    db        10
    db        "!3 Width adjustment"
    db        10
    db        "!1 is detected here, 2 is done here, 3 is done by expandstr"
    db        10
    db        9
    db        "ref char u,v"
    db        10
    db        9
    db        "[256]char str"
    db        10
    db        9
    db        "int w,nheap"
    db        9
    db        9
    db        "! whether any heap storage is used  bytes allocated"
    db        10
    db        10
    db        9
    db        "nheap:=0"
    db        10
    db        10
    db        9
    db        "if fmt.quotechar or fmt.lettercase then"
    db        9
    db        9
    db        "! need local copy"
    db        10
    db        9
    db        9
    db        "if n<256 then"
    db        10
    db        9
    db        9
    db        9
    db        "u:=&.str"
    db        10
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        "nheap:=n+3"
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "! allow for quotes+terminator"
    db        10
    db        9
    db        9
    db        9
    db        "u:=pcm_alloc(nheap)"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "if fmt.quotechar then"
    db        10
    db        9
    db        9
    db        9
    db        "v:=u"
    db        10
    db        9
    db        9
    db        9
    db        "v^:=fmt.quotechar"
    db        10
    db        9
    db        9
    db        9
    db        "++v"
    db        10
    db        9
    db        9
    db        9
    db        "if n then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "strcpy(v,s)"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "v+:=n"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        "v^:=fmt.quotechar"
    db        10
    db        9
    db        9
    db        9
    db        "++v"
    db        10
    db        9
    db        9
    db        9
    db        "v^:=0"
    db        10
    db        9
    db        9
    db        9
    db        "n+:=2"
    db        10
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        "memcpy(u,s,n)"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "case fmt.lettercase"
    db        10
    db        9
    db        9
    db        "when 'a' then"
    db        9
    db        "! need lower when"
    db        10
    db        9
    db        9
    db        9
    db        "convlcstring(u)"
    db        10
    db        9
    db        9
    db        "when 'A' then"
    db        10
    db        9
    db        9
    db        9
    db        "convucstring(u)"
    db        10
    db        9
    db        9
    db        "esac"
    db        10
    db        9
    db        9
    db        "s:=u"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "w:=fmt.minwidth"
    db        10
    db        9
    db        "if w>n then"
    db        10
    db        9
    db        9
    db        "n:=expandstr(s,t,n,fmt)"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "memcpy(t,s,n)"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "if nheap then"
    db        10
    db        9
    db        9
    db        "pcm_free(u,nheap)"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "return n"
    db        10
    db        "end"
    db        10
    db        10
    db        "proc tostr_i64(i64 a, ref fmtrec fmt)="
    db        10
    db        9
    db        "[360]char str"
    db        10
    db        9
    db        "int n"
    db        10
    db        10
    db        9
    db        "case fmt.charmode"
    db        10
    db        9
    db        "when 0 then"
    db        10
    db        9
    db        9
    db        "n:=i64tostrfmt(a,&.str,fmt)"
    db        10
    db        9
    db        "when 'M' then"
    db        10
    db        9
    db        9
    db        "n:=domultichar(ref char(&a),8,&.str,fmt)"
    db        10
    db        10
    db        9
    db        "else"
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "!assume 'C'"
    db        10
    db        9
    db        9
    db        "m$print_c8(a, nil)"
    db        10
    db        "!"
    db        9
    db        9
    db        "printchar(a)"
    db        9
    db        9
    db        9
    db        "!no other formatting allowed"
    db        10
    db        9
    db        9
    db        "return"
    db        10
    db        9
    db        "esac"
    db        10
    db        10
    db        9
    db        "printstr_n(&.str,n)"
    db        10
    db        "end"
    db        10
    db        10
    db        "proc tostr_u64(u64 a, ref fmtrec fmt)="
    db        10
    db        9
    db        "[360]char str"
    db        10
    db        9
    db        "int n"
    db        10
    db        10
    db        9
    db        "case fmt.charmode"
    db        10
    db        9
    db        "when 'M' then"
    db        10
    db        9
    db        9
    db        "n:=domultichar(ref char(&a),8,&.str,fmt)"
    db        10
    db        10
    db        9
    db        "when 'C' then"
    db        10
    db        9
    db        9
    db        "m$print_c8(a, nil)"
    db        10
    db        "!"
    db        9
    db        9
    db        "printchar(a)"
    db        9
    db        9
    db        9
    db        "!no other formatting allowed"
    db        10
    db        9
    db        9
    db        "return"
    db        10
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "n:=u64tostrfmt(a,&.str,fmt)"
    db        10
    db        9
    db        "esac"
    db        10
    db        10
    db        9
    db        "printstr_n(&.str,n)"
    db        10
    db        "end"
    db        10
    db        10
    db        "proc tostr_r64(real x,ref fmtrec fmt) ="
    db        10
    db        9
    db        "[360]char str,str2"
    db        10
    db        9
    db        "[0:10]char cfmt"
    db        10
    db        9
    db        "int n"
    db        10
    db        10
    db        9
    db        "cfmt[0]:='%'"
    db        10
    db        10
    db        9
    db        "if fmt.precision then"
    db        10
    db        9
    db        9
    db        "cfmt[1]:='.'"
    db        10
    db        9
    db        9
    db        "cfmt[2]:='*'"
    db        10
    db        9
    db        9
    db        "cfmt[3]:=fmt.realfmt"
    db        10
    db        9
    db        9
    db        "cfmt[4]:=0"
    db        10
    db        9
    db        9
    db        "sprintf(&.str,&.cfmt,fmt.precision,x)"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "cfmt[1]:=fmt.realfmt"
    db        10
    db        9
    db        9
    db        "cfmt[2]:=0"
    db        10
    db        9
    db        9
    db        "sprintf(&.str,&.cfmt,x)"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        "!at this point, n is the str length including signs and suffix"
    db        10
    db        10
    db        9
    db        "n:=strlen(&.str)"
    db        9
    db        9
    db        "! current length"
    db        10
    db        10
    db        9
    db        "if n<fmt.minwidth then"
    db        10
    db        9
    db        9
    db        "n:=expandstr(&.str,&.str2,n,fmt)"
    db        10
    db        9
    db        9
    db        "strcpy(&.str,&.str2)"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "printstr_n(&.str,n)"
    db        10
    db        "end"
    db        10
    db        10
    db        "proc tostr_str(ref char s, int oldlen, ref fmtrec fmt) ="
    db        10
    db        9
    db        "int newlen,n"
    db        10
    db        9
    db        "ref char t"
    db        10
    db        10
    db        "!try and work out size of formatted string"
    db        10
    db        9
    db        "if oldlen=-1 then"
    db        10
    db        9
    db        9
    db        "oldlen:=strlen(s)"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "newlen:=oldlen"
    db        10
    db        10
    db        9
    db        "if fmt.quotechar or fmt.minwidth>newlen or fmt.lettercase or fmt.precision then"
    db        10
    db        9
    db        9
    db        "if fmt.quotechar then"
    db        10
    db        9
    db        9
    db        9
    db        "newlen+:=2"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "if fmt.minwidth>newlen then"
    db        10
    db        9
    db        9
    db        9
    db        "newlen:=fmt.minwidth"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "t:=pcm_alloc(newlen+1)"
    db        10
    db        9
    db        9
    db        "n:=strtostrfmt(s,t,oldlen,fmt)"
    db        10
    db        9
    db        9
    db        "if fmt.precision then"
    db        10
    db        9
    db        9
    db        9
    db        "n min:=fmt.precision"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        9
    db        "printstr_n(t,n)"
    db        10
    db        9
    db        9
    db        "pcm_free(t,newlen+1)"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "printstr_n(s,oldlen)"
    db        10
    db        9
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "function getfmt(ichar fmtstyle)ref fmtrec="
    db        10
    db        9
    db        "static fmtrec fmt"
    db        10
    db        9
    db        "if fmtstyle then"
    db        10
    db        9
    db        9
    db        "strtofmt(fmtstyle,-1,&fmt)"
    db        10
    db        9
    db        9
    db        "return &fmt"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "return &defaultfmt"
    db        10
    db        9
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function strint(i64 a, ichar fmtstyle=nil)ichar="
    db        10
    db        9
    db        "static [100]char str"
    db        10
    db        9
    db        "ref fmtrec fmt"
    db        10
    db        10
    db        9
    db        "m$print_startstr(&.str)"
    db        10
    db        9
    db        "tostr_i64(a,fmt:=getfmt(fmtstyle))"
    db        10
    db        9
    db        "m$print_end()"
    db        10
    db        9
    db        "return getstr(&.str,fmt)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc getstrint(i64 a, ichar dest)="
    db        10
    db        9
    db        "m$print_startstr(dest)"
    db        10
    db        9
    db        "tostr_i64(a,getfmt(nil))"
    db        10
    db        9
    db        "m$print_end()"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function strword(u64 a, ichar fmtstyle=nil)ichar="
    db        10
    db        9
    db        "static [100]char str"
    db        10
    db        9
    db        "ref fmtrec fmt"
    db        10
    db        10
    db        9
    db        "m$print_startstr(&.str)"
    db        10
    db        9
    db        "tostr_u64(a,fmt:=getfmt(fmtstyle))"
    db        10
    db        9
    db        "m$print_end()"
    db        10
    db        9
    db        "return getstr(&.str,fmt)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function strreal(real a, ichar fmtstyle=nil)ichar="
    db        10
    db        9
    db        "static [320]char str"
    db        10
    db        9
    db        "ref fmtrec fmt"
    db        10
    db        10
    db        9
    db        "m$print_startstr(&.str)"
    db        10
    db        9
    db        "tostr_r64(a,fmt:=getfmt(fmtstyle))"
    db        10
    db        9
    db        "m$print_end()"
    db        10
    db        9
    db        "return getstr(&.str,fmt)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function getstr(ichar s, ref fmtrec fmt)ichar="
    db        10
    db        9
    db        "if fmt.heapmode then"
    db        10
    db        9
    db        9
    db        "return pcm_copyheapstring(s)"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "return s"
    db        10
    db        9
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "proc initreadbuffer="
    db        10
    db        9
    db        "if rd_buffer then return fi"
    db        10
    db        9
    db        "rd_buffer:=pcm_alloc(rd_buffersize)"
    db        10
    db        9
    db        "rd_buffer^:=0"
    db        10
    db        9
    db        "rd_pos:=rd_lastpos:=rd_buffer"
    db        10
    db        "end"
    db        10
    db        10
    db        "global proc m$read_conline="
    db        10
    db        9
    db        "initreadbuffer()"
    db        10
    db        10
    db        9
    db        "readlinen(nil,rd_buffer,rd_buffersize)"
    db        10
    db        10
    db        9
    db        "rd_length:=strlen(rd_buffer)"
    db        10
    db        9
    db        "rd_pos:=rd_buffer"
    db        10
    db        9
    db        "rd_lastpos:=nil"
    db        10
    db        "end"
    db        10
    db        10
    db        "global proc m$read_fileline(filehandle f)="
    db        10
    db        9
    db        "initreadbuffer()"
    db        10
    db        10
    db        9
    db        "if f=filehandle(1) then"
    db        10
    db        "ABORTPROGRAM("
    db        34
    db        "READ CMDLINE"
    db        34
    db        ")"
    db        10
    db        "!"
    db        9
    db        9
    db        "rd_buffer^:=0"
    db        10
    db        "!"
    db        9
    db        9
    db        "p:=getcommandlinea()"
    db        10
    db        "!"
    db        9
    db        9
    db        "repeat"
    db        10
    db        "!"
    db        9
    db        9
    db        9
    db        "++p"
    db        10
    db        "!"
    db        9
    db        9
    db        "until p^ in [' ','"
    db        92
    db        "t',0]"
    db        10
    db        "!"
    db        9
    db        9
    db        "strcpy(rd_buffer, p)"
    db        10
    db        "!"
    db        9
    db        9
    db        "rd_length:=strlen(rd_buffer)"
    db        10
    db        "!"
    db        9
    db        9
    db        "rd_pos:=rd_buffer"
    db        10
    db        "!"
    db        9
    db        9
    db        "rd_lastpos:=nil"
    db        10
    db        9
    db        9
    db        "return"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "readlinen(f,rd_buffer,rd_buffersize)"
    db        10
    db        10
    db        9
    db        "rd_length:=strlen(rd_buffer)"
    db        10
    db        9
    db        "rd_pos:=rd_buffer"
    db        10
    db        9
    db        "rd_lastpos:=nil"
    db        10
    db        "end"
    db        10
    db        10
    db        "global proc m$read_strline(ichar s)="
    db        10
    db        9
    db        "int n"
    db        10
    db        10
    db        9
    db        "initreadbuffer()"
    db        10
    db        9
    db        "n:=strlen(s)"
    db        10
    db        10
    db        9
    db        "if n<rd_buffersize then"
    db        10
    db        9
    db        9
    db        "strcpy(rd_buffer,s)"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "memcpy(rd_buffer,s,rd_buffersize-1)"
    db        10
    db        9
    db        9
    db        "(rd_buffer+rd_buffersize-1)^:=0"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "rd_length:=n"
    db        10
    db        9
    db        "rd_pos:=rd_buffer"
    db        10
    db        9
    db        "rd_lastpos:=nil"
    db        10
    db        "end"
    db        10
    db        10
    db        "function readitem(int &itemlength)ref char ="
    db        10
    db        "!read next item from rd_buffer"
    db        10
    db        "!identify a substring that can contain a name, int, real, string or filename"
    db        10
    db        "!return updated position of s that points past the item and past the immediate"
    db        10
    db        "!terminator "
    db        10
    db        "!information about the read item is returned in itemstr, which points to"
    db        10
    db        "!the start of the item, and in itemlength. Item excludes any surrounding whitespace"
    db        10
    db        "!Item can be quoted, then the item points inside the quotes"
    db        10
    db        "!Any embedded quotes are removed, and the characters moved up. The item will"
    db        10
    db        "!be that reduced subsequence"
    db        10
    db        "!NOTE THAT THIS IS DESTRUCTIVE. On reread, the input will be different."
    db        10
    db        "!I can mitigate this by adding spaces between the end of the item, and the next item,"
    db        10
    db        "!overwriting also the terminator. But this won't restore the line if one of the next"
    db        10
    db        "!reads is literal, using 'L' or 'C' codes."
    db        10
    db        9
    db        "ref char p,s,itemstr"
    db        10
    db        9
    db        "char quotechar, c"
    db        10
    db        10
    db        9
    db        "unless rd_buffer then "
    db        10
    db        9
    db        9
    db        "initreadbuffer()"
    db        10
    db        9
    db        "end unless"
    db        10
    db        10
    db        9
    db        "s:=rd_pos"
    db        10
    db        10
    db        "!scan string, eliminating leading white space"
    db        10
    db        9
    db        "while s^=' ' or s^=9 do"
    db        10
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        "od"
    db        10
    db        10
    db        9
    db        "itemstr:=s"
    db        10
    db        9
    db        "rd_lastpos:=rd_pos:=s"
    db        10
    db        10
    db        9
    db        "if s^=0 then"
    db        10
    db        9
    db        9
    db        "termchar:=0"
    db        10
    db        9
    db        9
    db        "itemlength:=0"
    db        10
    db        9
    db        9
    db        "return s"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "quotechar:=0"
    db        10
    db        9
    db        "if s^='"
    db        34
    db        "' then"
    db        10
    db        9
    db        9
    db        "quotechar:='"
    db        34
    db        "'"
    db        10
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        "elsif s^='"
    db        92
    db        "'' then"
    db        10
    db        9
    db        9
    db        "quotechar:='"
    db        92
    db        "''"
    db        10
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        "!loop reading characters until separator or end reached"
    db        10
    db        9
    db        "p:=itemstr:=s"
    db        10
    db        10
    db        9
    db        "while s^ do"
    db        10
    db        9
    db        9
    db        "c:=s++^"
    db        10
    db        9
    db        9
    db        "case c"
    db        10
    db        9
    db        9
    db        "when ' ', 9, comma, '=' then"
    db        9
    db        9
    db        "! separator"
    db        10
    db        9
    db        9
    db        9
    db        "if quotechar or p=s then"
    db        9
    db        9
    db        9
    db        "!can be considered part of name if inside quotes, or is only char"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "goto normalchar"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        "termchar:=c"
    db        10
    db        9
    db        9
    db        9
    db        "exit"
    db        10
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        "normalchar:"
    db        10
    db        9
    db        9
    db        9
    db        "if c=quotechar then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "if s^=quotechar then"
    db        9
    db        "! embedded quote"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "p^:=c"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "++p"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "else"
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "! end of name"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "termchar:=s^"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "if termchar in [',', '='] then"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "++s"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "termchar:=s^"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "exit"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "p^:=c"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "++p"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "esac"
    db        10
    db        9
    db        "od"
    db        10
    db        10
    db        9
    db        "if s^=0 then"
    db        10
    db        9
    db        9
    db        "termchar:=0"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "itemlength:=p-itemstr"
    db        9
    db        9
    db        9
    db        9
    db        "! actual length of token"
    db        10
    db        9
    db        "rd_pos:=s"
    db        10
    db        10
    db        9
    db        "return itemstr"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function strtoint(ichar s,int length=-1, word base=10)i64="
    db        10
    db        "!return point to next char after terminator (which can be just off length of string)"
    db        10
    db        9
    db        "byte signd"
    db        10
    db        9
    db        "u64 aa"
    db        10
    db        9
    db        "word c,d"
    db        10
    db        10
    db        9
    db        "itemerror:=0"
    db        10
    db        10
    db        9
    db        "if length=-1 then"
    db        10
    db        9
    db        9
    db        "length:=strlen(s)"
    db        10
    db        9
    db        "fi"
    db        10
    db        "!check for sign"
    db        10
    db        9
    db        "signd:=0"
    db        10
    db        9
    db        "if length and s^='-' then"
    db        10
    db        9
    db        9
    db        "signd:=1; ++s; --length"
    db        10
    db        9
    db        "elsif length and s^='+' then"
    db        10
    db        9
    db        9
    db        "++s; --length"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "aa:=0"
    db        10
    db        9
    db        "while length do"
    db        10
    db        9
    db        9
    db        "c:=s++^"
    db        10
    db        9
    db        9
    db        "--length"
    db        10
    db        9
    db        9
    db        "if c in 'A'..'F' then d:=c-'A'+10"
    db        10
    db        9
    db        9
    db        "elsif c in 'a'..'f' then d:=c-'a'+10"
    db        10
    db        9
    db        9
    db        "elsif c in '0'..'9' then d:=c-'0'"
    db        10
    db        9
    db        9
    db        "elsif c in ['_', '"
    db        92
    db        "''] then"
    db        10
    db        9
    db        9
    db        9
    db        "nextloop"
    db        10
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        "itemerror:=1"
    db        10
    db        9
    db        9
    db        9
    db        "exit"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        9
    db        "if d>=base then"
    db        10
    db        9
    db        9
    db        9
    db        "itemerror:=1"
    db        10
    db        9
    db        9
    db        9
    db        "exit"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "aa:=aa*base+d"
    db        10
    db        9
    db        "od"
    db        10
    db        10
    db        9
    db        "if signd then"
    db        10
    db        9
    db        9
    db        "return -aa"
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "return aa"
    db        10
    db        9
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "global function m$read_i64(int fmt=0)i64="
    db        10
    db        9
    db        "ref char s"
    db        10
    db        9
    db        "int length"
    db        10
    db        10
    db        9
    db        "fmt:=toupper(fmt)"
    db        10
    db        10
    db        9
    db        "case fmt"
    db        10
    db        9
    db        "when 'C' then"
    db        10
    db        9
    db        9
    db        "rd_lastpos:=rd_pos"
    db        10
    db        9
    db        9
    db        "if rd_pos^ then"
    db        10
    db        9
    db        9
    db        9
    db        "return rd_pos++^"
    db        10
    db        9
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        9
    db        "return 0"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        "when 'T' then"
    db        10
    db        9
    db        9
    db        "return termchar"
    db        10
    db        9
    db        "when 'E' then"
    db        10
    db        9
    db        9
    db        "return itemerror"
    db        10
    db        9
    db        "esac"
    db        10
    db        10
    db        9
    db        "s:=readitem(length)"
    db        10
    db        10
    db        9
    db        "case fmt"
    db        10
    db        9
    db        "when 0,'I' then"
    db        10
    db        9
    db        9
    db        "return strtoint(s,length)"
    db        10
    db        9
    db        "when 'B' then"
    db        10
    db        9
    db        9
    db        "return strtoint(s,length,2)"
    db        10
    db        9
    db        "when 'H' then"
    db        10
    db        9
    db        9
    db        "return strtoint(s,length,16)"
    db        10
    db        9
    db        "esac"
    db        10
    db        9
    db        "return 0"
    db        10
    db        "end"
    db        10
    db        10
    db        "global function m$read_r64(int fmt=0)real="
    db        10
    db        9
    db        "[512]char str"
    db        10
    db        9
    db        "ref char s"
    db        10
    db        9
    db        "int length"
    db        10
    db        9
    db        "i32 numlength"
    db        10
    db        9
    db        "real x"
    db        10
    db        10
    db        9
    db        "s:=readitem(length)"
    db        10
    db        10
    db        9
    db        "if length=0 or length>=str.len then"
    db        9
    db        9
    db        "!assume not a real"
    db        10
    db        9
    db        9
    db        "return 0.0"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "memcpy(&.str,s,length)"
    db        10
    db        9
    db        "str[length+1]:=0"
    db        10
    db        10
    db        9
    db        "itemerror:=0"
    db        10
    db        10
    db        9
    db        "if sscanf(&.str,"
    db        34
    db        "%lf%n"
    db        34
    db        ", &x, &numlength)=0 or numlength<>length then"
    db        10
    db        9
    db        9
    db        "x:=0.0"
    db        10
    db        9
    db        9
    db        "itemerror:=1"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "return x"
    db        10
    db        "end"
    db        10
    db        10
    db        "global proc m$read_str(ref char dest, int destlen=0,fmt=0)="
    db        10
    db        9
    db        "ref char s"
    db        10
    db        9
    db        "int length"
    db        10
    db        10
    db        9
    db        "itemerror:=0"
    db        10
    db        9
    db        "if fmt in ['L','l'] then"
    db        10
    db        9
    db        9
    db        "s:=rd_pos"
    db        10
    db        9
    db        9
    db        "length:=rd_buffer+rd_length-rd_pos"
    db        10
    db        10
    db        9
    db        "else"
    db        10
    db        9
    db        9
    db        "s:=readitem(length)"
    db        10
    db        10
    db        9
    db        9
    db        "if fmt in ['N','n'] then"
    db        10
    db        9
    db        9
    db        9
    db        "iconvlcn(s,length)"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "if destlen>0 then"
    db        10
    db        9
    db        9
    db        "if length>=destlen then"
    db        10
    db        9
    db        9
    db        9
    db        "length:=destlen-1"
    db        10
    db        9
    db        9
    db        9
    db        "itemerror:=1"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        "fi"
    db        10
    db        9
    db        "memcpy(dest,s,length)"
    db        10
    db        9
    db        "(dest+length)^:=0"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc readstr(ref char dest, int fmt=0,destlen=0)="
    db        10
    db        9
    db        "m$read_str(dest,destlen,fmt)"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc rereadln="
    db        10
    db        9
    db        "rd_pos:=rd_buffer"
    db        10
    db        9
    db        "rd_lastpos:=rd_pos"
    db        10
    db        "end"
    db        10
    db        10
    db        "export proc reread="
    db        10
    db        9
    db        "rd_pos:=rd_lastpos"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function valint(ichar s, int fmt=0)i64="
    db        10
    db        9
    db        "ref char old_pos, old_lastpos"
    db        10
    db        9
    db        "i64 aa"
    db        10
    db        10
    db        9
    db        "initreadbuffer()"
    db        10
    db        9
    db        "old_pos:=rd_pos"
    db        10
    db        9
    db        "old_lastpos:=rd_lastpos"
    db        10
    db        10
    db        9
    db        "rd_pos:=s"
    db        10
    db        9
    db        "aa:=m$read_i64(fmt)"
    db        10
    db        9
    db        "rd_pos:=old_pos"
    db        10
    db        9
    db        "rd_lastpos:=old_lastpos"
    db        10
    db        9
    db        "return aa"
    db        10
    db        "end"
    db        10
    db        10
    db        "export function valreal(ichar s)real="
    db        10
    db        9
    db        "ref char old_pos, old_lastpos"
    db        10
    db        9
    db        "real x"
    db        10
    db        10
    db        9
    db        "initreadbuffer()"
    db        10
    db        9
    db        "old_pos:=rd_pos"
    db        10
    db        9
    db        "old_lastpos:=rd_lastpos"
    db        10
    db        10
    db        9
    db        "rd_pos:=s"
    db        10
    db        9
    db        "x:=m$read_r64()"
    db        10
    db        9
    db        "rd_pos:=old_pos"
    db        10
    db        9
    db        "rd_lastpos:=old_lastpos"
    db        10
    db        9
    db        "return x"
    db        10
    db        "end"
    db        10
    db        10
    db        "proc mclunimpl(ichar mess)="
    db        10
    db        9
    db        "printf("
    db        34
    db        "MCL-UNIMPL: %s"
    db        92
    db        "n"
    db        34
    db        ",mess)"
    db        10
    db        9
    db        "stop 1"
    db        10
    db        "end"
    db        10
    db        10
    db        "proc dumpstr(ichar s, int n, fbuffer=0)="
    db        10
    db        "!fbuffer=1 when outputting contents of buffer"
    db        10
    db        10
    db        9
    db        "ref ref char p"
    db        10
    db        10
    db        9
    db        "if outdev=str_io then"
    db        10
    db        9
    db        9
    db        "p:=cast(outchan)"
    db        10
    db        9
    db        9
    db        "if n then"
    db        10
    db        9
    db        9
    db        9
    db        "memcpy(p^,s,n)"
    db        10
    db        9
    db        9
    db        9
    db        "p^+:=n"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        "p^^:=0"
    db        10
    db        9
    db        9
    db        "return"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "return when n=0"
    db        10
    db        9
    db        "if fbuffer and n>=2 and outdev=std_io then"
    db        10
    db        9
    db        9
    db        "--printptr"
    db        9
    db        9
    db        9
    db        9
    db        "!point to last char"
    db        10
    db        9
    db        9
    db        "if printptr^=10 then"
    db        10
    db        9
    db        9
    db        9
    db        "if (printptr-1)^=13 then"
    db        9
    db        9
    db        "!crlf"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "(printptr-1)^:=0"
    db        10
    db        9
    db        9
    db        9
    db        "else"
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "!lf only"
    db        10
    db        9
    db        9
    db        9
    db        9
    db        "printptr^:=0"
    db        10
    db        9
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        9
    db        9
    db        "puts(printbuffer)"
    db        10
    db        9
    db        9
    db        9
    db        "return"
    db        10
    db        9
    db        9
    db        "fi"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "case outdev"
    db        10
    db        9
    db        "when std_io then"
    db        10
    db        9
    db        9
    db        "printf("
    db        34
    db        "%.*s"
    db        34
    db        ",n,s)"
    db        10
    db        9
    db        "when file_io then"
    db        10
    db        9
    db        9
    db        "fprintf(outchan,"
    db        34
    db        "%.*s"
    db        34
    db        ",n,s)"
    db        10
    db        9
    db        "esac"
    db        10
    db        "end"
    db        10
    db        10
    db        "proc dumpprintbuffer="
    db        10
    db        9
    db        "if printlen then"
    db        10
    db        9
    db        9
    db        "dumpstr(&.printbuffer,printlen,1)"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "resetprintbuffer()"
    db        10
    db        "end"
    db        10
    db        10
    db        "proc resetprintbuffer="
    db        10
    db        9
    db        "printptr:=&.printbuffer"
    db        10
    db        9
    db        "printlen:=0"
    db        10
    db        "end"
    db        10
    db        10
    db        "proc addtobuffer(ichar s, int n)="
    db        10
    db        9
    db        "if printlen+n>=(printbuffer.len-8) then"
    db        10
    db        9
    db        9
    db        "dumpprintbuffer()"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "if n<printbuffer.len then"
    db        10
    db        9
    db        9
    db        "memcpy(printptr,s,n)"
    db        10
    db        9
    db        9
    db        "printptr+:=n"
    db        10
    db        9
    db        9
    db        "printlen+:=n"
    db        10
    db        9
    db        9
    db        "return"
    db        10
    db        9
    db        "fi"
    db        10
    db        10
    db        9
    db        "dumpstr(s, n)"
    db        9
    db        9
    db        9
    db        "!don't bother with buffer"
    db        10
    db        "end"
    db        10
    db        10
    db        "global function m$power_i64(i64 a,n)i64="
    db        10
    db        9
    db        "if n<0 then"
    db        10
    db        9
    db        9
    db        "return 0"
    db        10
    db        9
    db        "elsif n=0 then"
    db        10
    db        9
    db        9
    db        "return 1"
    db        10
    db        9
    db        "elsif n=1 then"
    db        10
    db        9
    db        9
    db        "return a"
    db        10
    db        9
    db        "elsif (n iand 1)=0 then"
    db        10
    db        9
    db        9
    db        "return m$power_i64(sqr a,n/2)"
    db        10
    db        9
    db        "else"
    db        9
    db        9
    db        9
    db        "!assume odd"
    db        10
    db        9
    db        9
    db        "return m$power_i64(sqr a,(n-1)/2)*a"
    db        10
    db        9
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "func getutfsize(ref char s)int ="
    db        10
    db        "!work out the size in bytes of the ascii or utf8 character that s points to"
    db        10
    db        9
    db        "int a"
    db        10
    db        10
    db        9
    db        "a:=s++^"
    db        10
    db        10
    db        9
    db        "if a=0 then"
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "!end of string"
    db        10
    db        9
    db        9
    db        "0"
    db        10
    db        9
    db        "elsif a.[7]=0 then"
    db        9
    db        9
    db        9
    db        9
    db        "!ascii"
    db        10
    db        9
    db        9
    db        "1"
    db        10
    db        9
    db        "elsif a.[7..5]=2x110 then"
    db        10
    db        9
    db        9
    db        "2"
    db        10
    db        9
    db        "elsif a.[7..4]=2x1110 then"
    db        10
    db        9
    db        9
    db        "3"
    db        10
    db        9
    db        "elsif a.[7..3]=2x11110 then"
    db        10
    db        9
    db        9
    db        "4"
    db        10
    db        9
    db        "else"
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        9
    db        "!error: just assume a byte of random binary"
    db        10
    db        9
    db        9
    db        "1"
    db        10
    db        9
    db        "fi"
    db        10
    db        "end"
    db        10
    db        10
    db        "!export fun `fract(real x)real = fmod(x,1.0)"
    db        10
    db        "!export fun fraction(real x)real = fmod(x,1.0)"
    db        10
    db        10
    db        "export fun m$sign_i64(int a)int = (a<0|-1| (a>0|1|0))"
    db        10
    db        "export func m$sign_r64(real x)real ="
    db        10
    db        9
    db        "if x<0 then return -1 fi"
    db        10
    db        9
    db        "if x>0 then return 1 fi"
    db        10
    db        9
    db        "0"
    db        10
    db        "end"
    db        10
    db        0
L11481:
    db        "module msysc"
    db        10
    db        "module mlib"
    db        10
    db        "module mclib"
    db        10
    db        "module mlinux"
    db        10
    db        "module mwindllc"
    db        10
    db        0
L11480:
    db        "module msys"
    db        10
    db        "module mlib"
    db        10
    db        "module mclib"
    db        10
    db        "module mwindows"
    db        10
    db        "module mwindllc"
    db        10
    db        0
L11479:
    db        "module msysc"
    db        10
    db        "module mlib"
    db        10
    db        "module mclib"
    db        10
    db        "module mwindows"
    db        10
    db        "module mwindllc"
    db        10
    db        0
L11478:
    db        "module msys"
    db        10
    db        "module mlib"
    db        10
    db        "module mclib"
    db        10
    db        "module mwindows"
    db        10
    db        "module mwindll"
    db        10
    db        10
    db        "!proc start="
    db        10
    db        "!"
    db        9
    db        "CPL "
    db        34
    db        "MSYSWIN/START"
    db        34
    db        10
    db        "!END"
    db        10
    db        0
L11477:
    db        "mwindllc.m"
    db        0
L11476:
    db        "mwindll.m"
    db        0
L11475:
    db        "mlinux.m"
    db        0
L11474:
    db        "mwindows.m"
    db        0
L11473:
    db        "mclib.m"
    db        0
L11472:
    db        "mlib.m"
    db        0
L11471:
    db        "msysmin.m"
    db        0
L11470:
    db        "msysc.m"
    db        0
L11469:
    db        "msys.m"
    db        0
L11468:
    db        "msyslinc.m"
    db        0
L11467:
    db        "msyswini.m"
    db        0
L11466:
    db        "msyswinc.m"
    db        0
L11465:
    db        "msyswin.m"
    db        0
L11464:
    db        "18446744073709551615"
    db        0
L11463:
    db        "    "
    db        0
L11462:
    db        9
    db        0
L11461:
    db        "dsptr"
    db        0
L11460:
    db        "dprog"
    db        0
L11459:
    db        "dstack"
    db        0
L11458:
    db        "astack"
    db        0
L11457:
    db        "dframe"
    db        0
L11456:
    db        "aframe"
    db        0
L11455:
    db        0
L11454:
    db        "himem"
    db        0
L11453:
    db        "norip"
    db        0
L11452:
    db        "unused"
    db        0
L11451:
    db        "outpath"
    db        0
L11450:
    db        "o"
    db        0
L11449:
    db        "ext"
    db        0
L11448:
    db        "help"
    db        0
L11447:
    db        "h"
    db        0
L11446:
    db        "ss"
    db        0
L11445:
    db        "cs"
    db        0
L11444:
    db        "q"
    db        0
L11443:
    db        "vv"
    db        0
L11442:
    db        "v"
    db        0
L11441:
    db        "time"
    db        0
L11440:
    db        "pst"
    db        0
L11439:
    db        "shortnames"
    db        0
L11438:
    db        "modules"
    db        0
L11437:
    db        "showss"
    db        0
L11436:
    db        "types"
    db        0
L11435:
    db        "stflat"
    db        0
L11434:
    db        "st"
    db        0
L11433:
    db        "showasm"
    db        0
L11432:
    db        "showpcl"
    db        0
L11431:
    db        "showc"
    db        0
L11430:
    db        "ast3"
    db        0
L11429:
    db        "ast2"
    db        0
L11428:
    db        "ast1"
    db        0
L11427:
    db        "noregs"
    db        0
L11426:
    db        "nopeep"
    db        0
L11425:
    db        "no"
    db        0
L11424:
    db        "linux"
    db        0
L11423:
    db        "nosys"
    db        0
L11422:
    db        "min"
    db        0
L11421:
    db        "sys"
    db        0
L11420:
    db        "dss"
    db        0
L11419:
    db        "dmcl"
    db        0
L11418:
    db        "dpcl"
    db        0
L11417:
    db        "dtype"
    db        0
L11416:
    db        "dname"
    db        0
L11415:
    db        "dfixup"
    db        0
L11414:
    db        "dparse"
    db        0
L11413:
    db        "dload"
    db        0
L11412:
    db        "r"
    db        0
L11411:
    db        "mx"
    db        0
L11410:
    db        "exe"
    db        0
L11409:
    db        "d"
    db        0
L11408:
    db        "dll"
    db        0
L11407:
    db        "obj"
    db        0
L11406:
    db        "nasm"
    db        0
L11405:
    db        "a"
    db        0
L11404:
    db        "i"
    db        0
L11403:
    db        "p"
    db        0
L11402:
    db        "getproj"
    db        0
L11401:
    db        "getst"
    db        0
L11400:
    db        "ma"
    db        0
L11399:
    db        "dss_pass"
    db        0
L11398:
    db        "dmcl_pass"
    db        0
L11397:
    db        "dpcl_pass"
    db        0
L11396:
    db        "dtype_pass"
    db        0
L11395:
    db        "dname_pass"
    db        0
L11394:
    db        "dfixup_pass"
    db        0
L11393:
    db        "dparse_pass"
    db        0
L11392:
    db        "dload_pass"
    db        0
L11391:
    db        "(run)"
    db        0
L11390:
    db        "mx"
    db        0
L11389:
    db        "exe"
    db        0
L11388:
    db        "dll"
    db        0
L11387:
    db        "obj"
    db        0
L11386:
    db        "asm"
    db        0
L11385:
    db        "(int)"
    db        0
L11384:
    db        "pcl"
    db        0
L11383:
    db        "proj"
    db        0
L11382:
    db        "list"
    db        0
L11381:
    db        "ma"
    db        0
L11380:
    db        0
L11379:
    db        "impdata_rseg"
    db        0
L11378:
    db        "rodata_rseg"
    db        0
L11377:
    db        "zdata_rseg"
    db        0
L11376:
    db        "idata_rseg"
    db        0
L11375:
    db        "code_rseg"
    db        0
L11374:
    db        "no_seg"
    db        0
L11373:
    db        "imprel32"
    db        0
L11372:
    db        "impabs64"
    db        0
L11371:
    db        "impabs32"
    db        0
L11370:
    db        "locabs64"
    db        0
L11369:
    db        "locabs32"
    db        0
L11368:
    db        "no_rel"
    db        0
L11367:
    db        "end_dir"
    db        0
L11366:
    db        "entry_dir"
    db        0
L11365:
    db        "exportoffsets_dir"
    db        0
L11364:
    db        "exportsegs_dir"
    db        0
L11363:
    db        "exportsymbols_dir"
    db        0
L11362:
    db        "importsymbols_dir"
    db        0
L11361:
    db        "libs_dir"
    db        0
L11360:
    db        "dlls_dir"
    db        0
L11359:
    db        "reloc_dir"
    db        0
L11358:
    db        "zdata_dir"
    db        0
L11357:
    db        "idata_dir"
    db        0
L11356:
    db        "code_dir"
    db        0
L11355:
    db        "version_dir"
    db        0
L11354:
    db        "pad_dir"
    db        0
L11353:
    db        "rel8_rel"
    db        0
L11352:
    db        "rel321_rel"
    db        0
L11351:
    db        "rel32_rel"
    db        0
L11350:
    db        "addr32nb_rel"
    db        0
L11349:
    db        "addr32_rel"
    db        0
L11348:
    db        "addr64_rel"
    db        0
L11347:
    db        "abs_rel"
    db        0
L11346:
    db        "xmm15"
    db        0
L11345:
    db        "xmm13"
    db        0
L11344:
    db        "xmm12"
    db        0
L11343:
    db        "xmm11"
    db        0
L11342:
    db        "xmm10"
    db        0
L11341:
    db        "xmm9"
    db        0
L11340:
    db        "xmm8"
    db        0
L11339:
    db        "xmm7"
    db        0
L11338:
    db        "xmm6"
    db        0
L11337:
    db        "xmm5"
    db        0
L11336:
    db        "xmm4"
    db        0
L11335:
    db        "xmm3"
    db        0
L11334:
    db        "xmm2"
    db        0
L11333:
    db        "xmm1"
    db        0
L11332:
    db        "xmm0"
    db        0
L11331:
    db        "-"
    db        0
L11330:
    db        "temp"
    db        0
L11329:
    db        "regvar"
    db        0
L11328:
    db        "reg"
    db        0
L11327:
    db        "pend"
    db        0
L11326:
    db        "a_xreg"
    db        0
L11325:
    db        "a_cond"
    db        0
L11324:
    db        "a_mem"
    db        0
L11323:
    db        "a_imm"
    db        0
L11322:
    db        "a_reg"
    db        0
L11321:
    db        "a_none"
    db        0
L11320:
    db        "back_ref"
    db        0
L11319:
    db        "fwd_ref"
    db        0
L11318:
    db        "extern_ref"
    db        0
L11317:
    db        "impdata_seg"
    db        0
L11316:
    db        "rodata_seg"
    db        0
L11315:
    db        "zdata_seg"
    db        0
L11314:
    db        "idata_seg"
    db        0
L11313:
    db        "code_seg"
    db        0
L11312:
    db        "no_seg"
    db        0
L11311:
    db        "cmovg"
    db        0
L11310:
    db        "cmovle"
    db        0
L11309:
    db        "cmovge"
    db        0
L11308:
    db        "cmovl"
    db        0
L11307:
    db        "cmovnp"
    db        0
L11306:
    db        "cmovp"
    db        0
L11305:
    db        "cmovns"
    db        0
L11304:
    db        "cmovs"
    db        0
L11303:
    db        "cmova"
    db        0
L11302:
    db        "cmovbe"
    db        0
L11301:
    db        "cmovnz"
    db        0
L11300:
    db        "cmovz"
    db        0
L11299:
    db        "cmovae"
    db        0
L11298:
    db        "cmovb"
    db        0
L11297:
    db        "cmovno"
    db        0
L11296:
    db        "cmovo"
    db        0
L11295:
    db        "setg"
    db        0
L11294:
    db        "setle"
    db        0
L11293:
    db        "setge"
    db        0
L11292:
    db        "setl"
    db        0
L11291:
    db        "setnp"
    db        0
L11290:
    db        "setp"
    db        0
L11289:
    db        "setns"
    db        0
L11288:
    db        "sets"
    db        0
L11287:
    db        "seta"
    db        0
L11286:
    db        "setbe"
    db        0
L11285:
    db        "setnz"
    db        0
L11284:
    db        "setz"
    db        0
L11283:
    db        "setae"
    db        0
L11282:
    db        "setb"
    db        0
L11281:
    db        "setno"
    db        0
L11280:
    db        "seto"
    db        0
L11279:
    db        "jnc"
    db        0
L11278:
    db        "jc"
    db        0
L11277:
    db        "jg"
    db        0
L11276:
    db        "jle"
    db        0
L11275:
    db        "jge"
    db        0
L11274:
    db        "jl"
    db        0
L11273:
    db        "jnp"
    db        0
L11272:
    db        "jp"
    db        0
L11271:
    db        "jns"
    db        0
L11270:
    db        "js"
    db        0
L11269:
    db        "ja"
    db        0
L11268:
    db        "jbe"
    db        0
L11267:
    db        "jnz"
    db        0
L11266:
    db        "jz"
    db        0
L11265:
    db        "jae"
    db        0
L11264:
    db        "jb"
    db        0
L11263:
    db        "jno"
    db        0
L11262:
    db        "jo"
    db        0
L11261:
    db        "mmx7"
    db        0
L11260:
    db        "mmx6"
    db        0
L11259:
    db        "mmx5"
    db        0
L11258:
    db        "mmx4"
    db        0
L11257:
    db        "mmx3"
    db        0
L11256:
    db        "mmx2"
    db        0
L11255:
    db        "mmx1"
    db        0
L11254:
    db        "mmx0"
    db        0
L11253:
    db        "st7"
    db        0
L11252:
    db        "st6"
    db        0
L11251:
    db        "st5"
    db        0
L11250:
    db        "st4"
    db        0
L11249:
    db        "st3"
    db        0
L11248:
    db        "st2"
    db        0
L11247:
    db        "st1"
    db        0
L11246:
    db        "st0"
    db        0
L11245:
    db        "xmm15"
    db        0
L11244:
    db        "xmm14"
    db        0
L11243:
    db        "xmm13"
    db        0
L11242:
    db        "xmm12"
    db        0
L11241:
    db        "xmm11"
    db        0
L11240:
    db        "xmm10"
    db        0
L11239:
    db        "xmm9"
    db        0
L11238:
    db        "xmm8"
    db        0
L11237:
    db        "xmm7"
    db        0
L11236:
    db        "xmm6"
    db        0
L11235:
    db        "xmm5"
    db        0
L11234:
    db        "xmm4"
    db        0
L11233:
    db        "xmm3"
    db        0
L11232:
    db        "xmm2"
    db        0
L11231:
    db        "xmm1"
    db        0
L11230:
    db        "xmm0"
    db        0
L11229:
    db        "r15b"
    db        0
L11228:
    db        "r14b"
    db        0
L11227:
    db        "r13b"
    db        0
L11226:
    db        "r12b"
    db        0
L11225:
    db        "r11b"
    db        0
L11224:
    db        "r10b"
    db        0
L11223:
    db        "r9b"
    db        0
L11222:
    db        "r8b"
    db        0
L11221:
    db        "spl"
    db        0
L11220:
    db        "bpl"
    db        0
L11219:
    db        "dil"
    db        0
L11218:
    db        "sil"
    db        0
L11217:
    db        "dh"
    db        0
L11216:
    db        "ch"
    db        0
L11215:
    db        "bh"
    db        0
L11214:
    db        "ah"
    db        0
L11213:
    db        "dl"
    db        0
L11212:
    db        "cl"
    db        0
L11211:
    db        "bl"
    db        0
L11210:
    db        "al"
    db        0
L11209:
    db        "r15w"
    db        0
L11208:
    db        "r14w"
    db        0
L11207:
    db        "r13w"
    db        0
L11206:
    db        "r12w"
    db        0
L11205:
    db        "r11w"
    db        0
L11204:
    db        "r10w"
    db        0
L11203:
    db        "r9w"
    db        0
L11202:
    db        "r8w"
    db        0
L11201:
    db        "sp"
    db        0
L11200:
    db        "bp"
    db        0
L11199:
    db        "di"
    db        0
L11198:
    db        "si"
    db        0
L11197:
    db        "dx"
    db        0
L11196:
    db        "cx"
    db        0
L11195:
    db        "bx"
    db        0
L11194:
    db        "ax"
    db        0
L11193:
    db        "r15d"
    db        0
L11192:
    db        "r14d"
    db        0
L11191:
    db        "r13d"
    db        0
L11190:
    db        "r12d"
    db        0
L11189:
    db        "r11d"
    db        0
L11188:
    db        "r10d"
    db        0
L11187:
    db        "r9d"
    db        0
L11186:
    db        "r8d"
    db        0
L11185:
    db        "esp"
    db        0
L11184:
    db        "ebp"
    db        0
L11183:
    db        "edi"
    db        0
L11182:
    db        "esi"
    db        0
L11181:
    db        "edx"
    db        0
L11180:
    db        "ecx"
    db        0
L11179:
    db        "ebx"
    db        0
L11178:
    db        "eax"
    db        0
L11177:
    db        "r15"
    db        0
L11176:
    db        "r14"
    db        0
L11175:
    db        "r13"
    db        0
L11174:
    db        "r12"
    db        0
L11173:
    db        "r11"
    db        0
L11172:
    db        "r10"
    db        0
L11171:
    db        "r9"
    db        0
L11170:
    db        "r8"
    db        0
L11169:
    db        "rsp"
    db        0
L11168:
    db        "rbp"
    db        0
L11167:
    db        "rdi"
    db        0
L11166:
    db        "rsi"
    db        0
L11165:
    db        "rdx"
    db        0
L11164:
    db        "rcx"
    db        0
L11163:
    db        "rbx"
    db        0
L11162:
    db        "rax"
    db        0
L11161:
    db        "_b20"
    db        0
L11160:
    db        "b19"
    db        0
L11159:
    db        "b18"
    db        0
L11158:
    db        "b17"
    db        0
L11157:
    db        "b16"
    db        0
L11156:
    db        "b15"
    db        0
L11155:
    db        "b14"
    db        0
L11154:
    db        "b13"
    db        0
L11153:
    db        "b12"
    db        0
L11152:
    db        "b11"
    db        0
L11151:
    db        "b10"
    db        0
L11150:
    db        "b9"
    db        0
L11149:
    db        "b8"
    db        0
L11148:
    db        "b7"
    db        0
L11147:
    db        "b6"
    db        0
L11146:
    db        "b5"
    db        0
L11145:
    db        "b4"
    db        0
L11144:
    db        "b3"
    db        0
L11143:
    db        "b2"
    db        0
L11142:
    db        "b1"
    db        0
L11141:
    db        "b0"
    db        0
L11140:
    db        "w15"
    db        0
L11139:
    db        "w14"
    db        0
L11138:
    db        "w13"
    db        0
L11137:
    db        "w12"
    db        0
L11136:
    db        "w11"
    db        0
L11135:
    db        "w10"
    db        0
L11134:
    db        "w9"
    db        0
L11133:
    db        "w8"
    db        0
L11132:
    db        "w7"
    db        0
L11131:
    db        "w6"
    db        0
L11130:
    db        "w5"
    db        0
L11129:
    db        "w4"
    db        0
L11128:
    db        "w3"
    db        0
L11127:
    db        "w2"
    db        0
L11126:
    db        "w1"
    db        0
L11125:
    db        "w0"
    db        0
L11124:
    db        "a15"
    db        0
L11123:
    db        "a14"
    db        0
L11122:
    db        "a13"
    db        0
L11121:
    db        "a12"
    db        0
L11120:
    db        "a11"
    db        0
L11119:
    db        "a10"
    db        0
L11118:
    db        "a9"
    db        0
L11117:
    db        "a8"
    db        0
L11116:
    db        "a7"
    db        0
L11115:
    db        "a6"
    db        0
L11114:
    db        "a5"
    db        0
L11113:
    db        "a4"
    db        0
L11112:
    db        "a3"
    db        0
L11111:
    db        "a2"
    db        0
L11110:
    db        "a1"
    db        0
L11109:
    db        "a0"
    db        0
L11108:
    db        "d15"
    db        0
L11107:
    db        "d14"
    db        0
L11106:
    db        "d13"
    db        0
L11105:
    db        "d12"
    db        0
L11104:
    db        "d11"
    db        0
L11103:
    db        "d10"
    db        0
L11102:
    db        "d9"
    db        0
L11101:
    db        "d8"
    db        0
L11100:
    db        "d7"
    db        0
L11099:
    db        "d6"
    db        0
L11098:
    db        "d5"
    db        0
L11097:
    db        "d4"
    db        0
L11096:
    db        "d3"
    db        0
L11095:
    db        "d2"
    db        0
L11094:
    db        "d1"
    db        0
L11093:
    db        "d0"
    db        0
L11092:
    db        "a"
    db        0
L11091:
    db        "be"
    db        0
L11090:
    db        "ae"
    db        0
L11089:
    db        "b"
    db        0
L11088:
    db        "g"
    db        0
L11087:
    db        "le"
    db        0
L11086:
    db        "ge"
    db        0
L11085:
    db        "l"
    db        0
L11084:
    db        "np"
    db        0
L11083:
    db        "p"
    db        0
L11082:
    db        "ns"
    db        0
L11081:
    db        "s"
    db        0
L11080:
    db        "a"
    db        0
L11079:
    db        "be"
    db        0
L11078:
    db        "nz"
    db        0
L11077:
    db        "z"
    db        0
L11076:
    db        "ae"
    db        0
L11075:
    db        "b"
    db        0
L11074:
    db        "no"
    db        0
L11073:
    db        "o"
    db        0
L11072:
    db        "fgt"
    db        0
L11071:
    db        "fle"
    db        0
L11070:
    db        "fge"
    db        0
L11069:
    db        "flt"
    db        0
L11068:
    db        "gt"
    db        0
L11067:
    db        "le"
    db        0
L11066:
    db        "ge"
    db        0
L11065:
    db        "lt"
    db        0
L11064:
    db        "np"
    db        0
L11063:
    db        "p"
    db        0
L11062:
    db        "ns"
    db        0
L11061:
    db        "s"
    db        0
L11060:
    db        "gtu"
    db        0
L11059:
    db        "leu"
    db        0
L11058:
    db        "ne"
    db        0
L11057:
    db        "eq"
    db        0
L11056:
    db        "geu"
    db        0
L11055:
    db        "ltu"
    db        0
L11054:
    db        "nov"
    db        0
L11053:
    db        "ov"
    db        0
L11052:
    db        "r19"
    db        0
L11051:
    db        "r18"
    db        0
L11050:
    db        "r17"
    db        0
L11049:
    db        "r16"
    db        0
L11048:
    db        "r15"
    db        0
L11047:
    db        "r14"
    db        0
L11046:
    db        "r13"
    db        0
L11045:
    db        "r12"
    db        0
L11044:
    db        "r11"
    db        0
L11043:
    db        "r10"
    db        0
L11042:
    db        "r9"
    db        0
L11041:
    db        "r8"
    db        0
L11040:
    db        "r7"
    db        0
L11039:
    db        "r6"
    db        0
L11038:
    db        "r5"
    db        0
L11037:
    db        "r4"
    db        0
L11036:
    db        "r3"
    db        0
L11035:
    db        "r2"
    db        0
L11034:
    db        "r1"
    db        0
L11033:
    db        "r0"
    db        0
L11032:
    db        "rnone"
    db        0
L11031:
    db        "m_halt"
    db        0
L11030:
    db        "m_xxxx"
    db        0
L11029:
    db        "m_cpuid"
    db        0
L11028:
    db        "m_fldln2"
    db        0
L11027:
    db        "m_fldlg2"
    db        0
L11026:
    db        "m_fld2e"
    db        0
L11025:
    db        "m_fld2t"
    db        0
L11024:
    db        "m_fldpi"
    db        0
L11023:
    db        "m_fld1"
    db        0
L11022:
    db        "m_fldz"
    db        0
L11021:
    db        "m_finit"
    db        0
L11020:
    db        "m_bswap"
    db        0
L11019:
    db        "m_popcnt"
    db        0
L11018:
    db        "m_rdtsc"
    db        0
L11017:
    db        "m_cmpsq"
    db        0
L11016:
    db        "m_cmpsd"
    db        0
L11015:
    db        "m_cmpsw"
    db        0
L11014:
    db        "m_cmpsb"
    db        0
L11013:
    db        "m_jrcxz"
    db        0
L11012:
    db        "m_jecxz"
    db        0
L11011:
    db        "m_loopcx"
    db        0
L11010:
    db        "m_loopz"
    db        0
L11009:
    db        "m_loopnz"
    db        0
L11008:
    db        "m_xlat"
    db        0
L11007:
    db        "m_resq"
    db        0
L11006:
    db        "m_resd"
    db        0
L11005:
    db        "m_resw"
    db        0
L11004:
    db        "m_resb"
    db        0
L11003:
    db        "m_align"
    db        0
L11002:
    db        "m_csegment"
    db        0
L11001:
    db        "m_zsegment"
    db        0
L11000:
    db        "m_isegment"
    db        0
L10999:
    db        "m_dq"
    db        0
L10998:
    db        "m_dd"
    db        0
L10997:
    db        "m_dw"
    db        0
L10996:
    db        "m_db"
    db        0
L10995:
    db        "m_maxsd"
    db        0
L10994:
    db        "m_minsd"
    db        0
L10993:
    db        "m_maxss"
    db        0
L10992:
    db        "m_minss"
    db        0
L10991:
    db        "m_fchs"
    db        0
L10990:
    db        "m_fabs"
    db        0
L10989:
    db        "m_fpatan"
    db        0
L10988:
    db        "m_fptan"
    db        0
L10987:
    db        "m_fsincos"
    db        0
L10986:
    db        "m_fcos"
    db        0
L10985:
    db        "m_fsin"
    db        0
L10984:
    db        "m_fsqrt"
    db        0
L10983:
    db        "m_fdiv"
    db        0
L10982:
    db        "m_fmul"
    db        0
L10981:
    db        "m_fsub"
    db        0
L10980:
    db        "m_fadd"
    db        0
L10979:
    db        "m_fistp"
    db        0
L10978:
    db        "m_fist"
    db        0
L10977:
    db        "m_fild"
    db        0
L10976:
    db        "m_fstp"
    db        0
L10975:
    db        "m_fst"
    db        0
L10974:
    db        "m_fld"
    db        0
L10973:
    db        "m_pcmpistrm"
    db        0
L10972:
    db        "m_pcmpistri"
    db        0
L10971:
    db        "m_movdqu"
    db        0
L10970:
    db        "m_movdqa"
    db        0
L10969:
    db        "m_cvtss2sd"
    db        0
L10968:
    db        "m_cvtsd2ss"
    db        0
L10967:
    db        "m_cvtsi2sd"
    db        0
L10966:
    db        "m_cvtsi2ss"
    db        0
L10965:
    db        "m_cvttsd2si"
    db        0
L10964:
    db        "m_cvttss2si"
    db        0
L10963:
    db        "m_cvtsd2si"
    db        0
L10962:
    db        "m_cvtss2si"
    db        0
L10961:
    db        "m_pand"
    db        0
L10960:
    db        "m_pxor"
    db        0
L10959:
    db        "m_andpd"
    db        0
L10958:
    db        "m_andps"
    db        0
L10957:
    db        "m_xorpd"
    db        0
L10956:
    db        "m_xorps"
    db        0
L10955:
    db        "m_ucomisd"
    db        0
L10954:
    db        "m_comisd"
    db        0
L10953:
    db        "m_comiss"
    db        0
L10952:
    db        "m_divsd"
    db        0
L10951:
    db        "m_divss"
    db        0
L10950:
    db        "m_mulsd"
    db        0
L10949:
    db        "m_mulss"
    db        0
L10948:
    db        "m_subsd"
    db        0
L10947:
    db        "m_subss"
    db        0
L10946:
    db        "m_addsd"
    db        0
L10945:
    db        "m_addss"
    db        0
L10944:
    db        "m_sqrtsd"
    db        0
L10943:
    db        "m_sqrtss"
    db        0
L10942:
    db        "m_shrd"
    db        0
L10941:
    db        "m_shld"
    db        0
L10940:
    db        "m_bsr"
    db        0
L10939:
    db        "m_bsf"
    db        0
L10938:
    db        "m_setcc"
    db        0
L10937:
    db        "m_cqo"
    db        0
L10936:
    db        "m_cdq"
    db        0
L10935:
    db        "m_cwd"
    db        0
L10934:
    db        "m_cbw"
    db        0
L10933:
    db        "m_dec"
    db        0
L10932:
    db        "m_inc"
    db        0
L10931:
    db        "m_notx"
    db        0
L10930:
    db        "m_neg"
    db        0
L10929:
    db        "m_rcr"
    db        0
L10928:
    db        "m_rcl"
    db        0
L10927:
    db        "m_ror"
    db        0
L10926:
    db        "m_rol"
    db        0
L10925:
    db        "m_shr"
    db        0
L10924:
    db        "m_sar"
    db        0
L10923:
    db        "m_shl"
    db        0
L10922:
    db        "m_cmp"
    db        0
L10921:
    db        "m_test"
    db        0
L10920:
    db        "m_xorx"
    db        0
L10919:
    db        "m_orx"
    db        0
L10918:
    db        "m_andx"
    db        0
L10917:
    db        "m_div"
    db        0
L10916:
    db        "m_idiv"
    db        0
L10915:
    db        "m_imul3"
    db        0
L10914:
    db        "m_imul2"
    db        0
L10913:
    db        "m_mul"
    db        0
L10912:
    db        "m_imul"
    db        0
L10911:
    db        "m_sbb"
    db        0
L10910:
    db        "m_adc"
    db        0
L10909:
    db        "m_sub"
    db        0
L10908:
    db        "m_add"
    db        0
L10907:
    db        "m_xchg"
    db        0
L10906:
    db        "m_jmpcc"
    db        0
L10905:
    db        "m_jmp"
    db        0
L10904:
    db        "m_retn"
    db        0
L10903:
    db        "m_leave"
    db        0
L10902:
    db        "m_ret"
    db        0
L10901:
    db        "m_call"
    db        0
L10900:
    db        "m_movsxd"
    db        0
L10899:
    db        "m_movzx"
    db        0
L10898:
    db        "m_movsx"
    db        0
L10897:
    db        "m_movq"
    db        0
L10896:
    db        "m_movd"
    db        0
L10895:
    db        "m_cmovcc"
    db        0
L10894:
    db        "m_lea"
    db        0
L10893:
    db        "m_pop"
    db        0
L10892:
    db        "m_push"
    db        0
L10891:
    db        "m_mov"
    db        0
L10890:
    db        "m_nop"
    db        0
L10889:
    db        "m_labelx"
    db        0
L10888:
    db        "m_endx"
    db        0
L10887:
    db        "m_trace"
    db        0
L10886:
    db        "m_definereg"
    db        0
L10885:
    db        "m_define"
    db        0
L10884:
    db        "m_labelname"
    db        0
L10883:
    db        "m_comment"
    db        0
L10882:
    db        "m_procend"
    db        0
L10881:
    db        "m_procstart"
    db        0
L10880:
    db        "temp_val"
    db        0
L10879:
    db        "name_val"
    db        0
L10878:
    db        "label_val"
    db        0
L10877:
    db        "def_val"
    db        0
L10876:
    db        "stringimm_val"
    db        0
L10875:
    db        "realmem_val"
    db        0
L10874:
    db        "realimm_val"
    db        0
L10873:
    db        "intimm_val"
    db        0
L10872:
    db        "no_val"
    db        0
L10871:
    db        "Program"
    db        0
L10870:
    db        "Misc"
    db        0
L10869:
    db        "Export"
    db        0
L10868:
    db        "Label"
    db        0
L10867:
    db        "Param"
    db        0
L10866:
    db        "Local"
    db        0
L10865:
    db        "Static"
    db        0
L10864:
    db        "Proc"
    db        0
L10863:
    db        "Import"
    db        0
L10862:
    db        "--"
    db        0
L10861:
    db        "gt"
    db        0
L10860:
    db        "ge"
    db        0
L10859:
    db        "le"
    db        0
L10858:
    db        "lt"
    db        0
L10857:
    db        "ne"
    db        0
L10856:
    db        "eq"
    db        0
L10855:
    db        "xx"
    db        0
L10854:
    db        "extproc"
    db        0
L10853:
    db        "addlib"
    db        0
L10852:
    db        "variadic"
    db        0
L10851:
    db        "rettype"
    db        0
L10850:
    db        "local"
    db        0
L10849:
    db        "param"
    db        0
L10848:
    db        "endprog"
    db        0
L10847:
    db        "comment"
    db        0
L10846:
    db        "eval"
    db        0
L10845:
    db        "loadall"
    db        0
L10844:
    db        "setarg"
    db        0
L10843:
    db        "setcall"
    db        0
L10842:
    db        "longjmp"
    db        0
L10841:
    db        "setjmp"
    db        0
L10840:
    db        "labeldef"
    db        0
L10839:
    db        "label"
    db        0
L10838:
    db        "initdswx"
    db        0
L10837:
    db        "data"
    db        0
L10836:
    db        "zstatic"
    db        0
L10835:
    db        "istatic"
    db        0
L10834:
    db        "endproc"
    db        0
L10833:
    db        "tcproc"
    db        0
L10832:
    db        "proc"
    db        0
L10831:
    db        "endmx"
    db        0
L10830:
    db        "resetmx"
    db        0
L10829:
    db        "startmx"
    db        0
L10828:
    db        "fnarrow"
    db        0
L10827:
    db        "fwiden"
    db        0
L10826:
    db        "widen"
    db        0
L10825:
    db        "truncate"
    db        0
L10824:
    db        "fix"
    db        0
L10823:
    db        "float"
    db        0
L10822:
    db        "typepun"
    db        0
L10821:
    db        "toboolto"
    db        0
L10820:
    db        "notto"
    db        0
L10819:
    db        "bitnotto"
    db        0
L10818:
    db        "absto"
    db        0
L10817:
    db        "negto"
    db        0
L10816:
    db        "subpxto"
    db        0
L10815:
    db        "addpxto"
    db        0
L10814:
    db        "maxto"
    db        0
L10813:
    db        "minto"
    db        0
L10812:
    db        "shrto"
    db        0
L10811:
    db        "shlto"
    db        0
L10810:
    db        "bitxorto"
    db        0
L10809:
    db        "bitorto"
    db        0
L10808:
    db        "bitandto"
    db        0
L10807:
    db        "iremto"
    db        0
L10806:
    db        "idivto"
    db        0
L10805:
    db        "divto"
    db        0
L10804:
    db        "multo"
    db        0
L10803:
    db        "subto"
    db        0
L10802:
    db        "addto"
    db        0
L10801:
    db        "loaddecr"
    db        0
L10800:
    db        "loadincr"
    db        0
L10799:
    db        "decrload"
    db        0
L10798:
    db        "incrload"
    db        0
L10797:
    db        "decrto"
    db        0
L10796:
    db        "incrto"
    db        0
L10795:
    db        "fmod"
    db        0
L10794:
    db        "power"
    db        0
L10793:
    db        "atan2"
    db        0
L10792:
    db        "sign"
    db        0
L10791:
    db        "ceil"
    db        0
L10790:
    db        "floor"
    db        0
L10789:
    db        "round"
    db        0
L10788:
    db        "exp"
    db        0
L10787:
    db        "log10"
    db        0
L10786:
    db        "log"
    db        0
L10785:
    db        "atan"
    db        0
L10784:
    db        "acos"
    db        0
L10783:
    db        "asin"
    db        0
L10782:
    db        "tan"
    db        0
L10781:
    db        "cos"
    db        0
L10780:
    db        "sin"
    db        0
L10779:
    db        "sqrt"
    db        0
L10778:
    db        "sqr"
    db        0
L10777:
    db        "toboolf"
    db        0
L10776:
    db        "toboolt"
    db        0
L10775:
    db        "not"
    db        0
L10774:
    db        "bitnot"
    db        0
L10773:
    db        "abs"
    db        0
L10772:
    db        "neg"
    db        0
L10771:
    db        "subp"
    db        0
L10770:
    db        "subpx"
    db        0
L10769:
    db        "addpx"
    db        0
L10768:
    db        "max"
    db        0
L10767:
    db        "min"
    db        0
L10766:
    db        "shr"
    db        0
L10765:
    db        "shl"
    db        0
L10764:
    db        "bitxor"
    db        0
L10763:
    db        "bitor"
    db        0
L10762:
    db        "bitand"
    db        0
L10761:
    db        "idivrem"
    db        0
L10760:
    db        "irem"
    db        0
L10759:
    db        "idiv"
    db        0
L10758:
    db        "div"
    db        0
L10757:
    db        "mul"
    db        0
L10756:
    db        "sub"
    db        0
L10755:
    db        "add"
    db        0
L10754:
    db        "assem"
    db        0
L10753:
    db        "clear"
    db        0
L10752:
    db        "endsw"
    db        0
L10751:
    db        "swlabel"
    db        0
L10750:
    db        "switchu"
    db        0
L10749:
    db        "switch"
    db        0
L10748:
    db        "iswap"
    db        0
L10747:
    db        "fordown"
    db        0
L10746:
    db        "forup"
    db        0
L10745:
    db        "to"
    db        0
L10744:
    db        "stop"
    db        0
L10743:
    db        "setcc"
    db        0
L10742:
    db        "jumpretm"
    db        0
L10741:
    db        "jumpret"
    db        0
L10740:
    db        "jumpf"
    db        0
L10739:
    db        "jumpt"
    db        0
L10738:
    db        "jumpcc"
    db        0
L10737:
    db        "ijump"
    db        0
L10736:
    db        "jump"
    db        0
L10735:
    db        "retfn"
    db        0
L10734:
    db        "icallf"
    db        0
L10733:
    db        "callf"
    db        0
L10732:
    db        "retproc"
    db        0
L10731:
    db        "icallp"
    db        0
L10730:
    db        "callp"
    db        0
L10729:
    db        "storebf"
    db        0
L10728:
    db        "storebit"
    db        0
L10727:
    db        "loadbf"
    db        0
L10726:
    db        "loadbit"
    db        0
L10725:
    db        "type"
    db        0
L10724:
    db        "opnd"
    db        0
L10723:
    db        "unload"
    db        0
L10722:
    db        "swapstk"
    db        0
L10721:
    db        "double"
    db        0
L10720:
    db        "dupl"
    db        0
L10719:
    db        "storem"
    db        0
L10718:
    db        "istorex"
    db        0
L10717:
    db        "istore"
    db        0
L10716:
    db        "store"
    db        0
L10715:
    db        "iloadx"
    db        0
L10714:
    db        "iload"
    db        0
L10713:
    db        "load"
    db        0
L10712:
    db        "nop"
    db        0
L10711:
    db        "any_opnd"
    db        0
L10710:
    db        "data_opnd"
    db        0
L10709:
    db        "realimm32_opnd"
    db        0
L10708:
    db        "realimm_opnd"
    db        0
L10707:
    db        "assem_opnd"
    db        0
L10706:
    db        "strimm_opnd"
    db        0
L10705:
    db        "string_opnd"
    db        0
L10704:
    db        "r32_opnd"
    db        0
L10703:
    db        "real_opnd"
    db        0
L10702:
    db        "int_opnd"
    db        0
L10701:
    db        "label_opnd"
    db        0
L10700:
    db        "memaddr_opnd"
    db        0
L10699:
    db        "mem_opnd"
    db        0
L10698:
    db        "no_opnd"
    db        0
L10697:
    db        "$last"
    db        0
L10696:
    db        "vec"
    db        0
L10695:
    db        "mem"
    db        0
L10694:
    db        "i64"
    db        0
L10693:
    db        "i32"
    db        0
L10692:
    db        "i16"
    db        0
L10691:
    db        "i8"
    db        0
L10690:
    db        "u64"
    db        0
L10689:
    db        "u32"
    db        0
L10688:
    db        "u16"
    db        0
L10687:
    db        "u8"
    db        0
L10686:
    db        "r64"
    db        0
L10685:
    db        "r32"
    db        0
L10684:
    db        "void"
    db        0
L10683:
    db        "pm_extra"
    db        0
L10682:
    db        "pm_colon"
    db        0
L10681:
    db        "pm_libfile"
    db        0
L10680:
    db        "pm_sourcefile"
    db        0
L10679:
    db        "pm_option"
    db        0
L10678:
    db        "pm_end"
    db        0



