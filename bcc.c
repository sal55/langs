/*
Toy C compiler for Windows.

Generated C code (not the original non-C sources); build with gcc or tcc.

This is a demonstration version that builds on Windows and Linux.
It will not be able to generate EXE files, only ASM or OBJ or I (preprocessed)
files (using -s, -c or -e options respectively).

Build using one of the following (needs 64-bit compiler):

    gcc bcc.c -obcc.exe               # Windows
    tcc bcc.c

    gcc bcc.c -obcc -lm -ldl          # Linux
    tcc bcc.c -obcc -lm -ldl

May not work with msvc due to overlong string constants.

Standard headers are incorporated into the executable.

For options, try one of:

  bcc
  bcc -help

  ./bcc
  ./bcc -help

*/

/*
  M to C  Whole Program Translator
  Input:  cc.m plus imported modules
  Output: cc.c (this file, or renamed from that)
          File represents entire program
  Target: C 64-bit
  OS:     Neutral

  Modules:
  Module 1: cc.m
  Module 2: <Built-in: msysnewc.m>
  Module 3: <Built-in: clibnewc.m>
  Module 4: <Built-in: mlib.m>
  Module 5: <Built-in: osnos.m>
  Module 6: ./cc_decls.m
  Module 7: ./cc_tables.m
  Module 8: ./cc_support.m
  Module 9: ./cc_lex.m
  Module 10: ./cc_headers.m
  Module 11: ./cc_lib.m
  Module 12: ./cc_parse.m
  Module 13: ./cc_genmcl.m
  Module 14: ./cc_libmcl.m
  Module 15: ./cc_blockmcl.m
  Module 16: ./cc_genasm.m
  Module 17: ./cc_export.m
  Module 18: ./cc_assembler.m
  Module 19: c:/ax/ax_tables.m
  Module 20: c:/ax/ax_decls.m
  Module 21: c:/ax/ax_lex.m
  Module 22: c:/ax/ax_parse.m
  Module 23: c:/ax/ax_lib.m
  Module 24: c:/ax/ax_genss.m
  Module 25: c:/ax/ax_objdecls.m
  Module 26: c:/ax/ax_writeexe.m
  Module 27: c:/ax/ax_disasm.m
  Module 28: c:/ax/ax_writeobj.m

*********** Start of C Code **********/


#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <ctype.h>
#include <string.h>
#include <math.h>
#include <time.h>
#include <sys/types.h>
#include <sys/stat.h>

#pragma pack(1)

typedef int8_t i8;
typedef int16_t i16;
typedef int32_t i32;
typedef int64_t i64;

typedef uint8_t u8;
typedef uint16_t u16;
typedef uint32_t u32;
typedef uint64_t u64;

typedef unsigned char byte;

typedef void* var;

#ifndef CALLBACK
#define CALLBACK
#endif

#if (UINTPTR_MAX<0xFFFFFFFFFFFFFFFF)
	#error "Need 64-bit target. Try -m64"
#endif

/* Forward Struct Declarations */
struct msysnewc_procinforec;
struct msysnewc_fmtrec;
struct mlib_strbuffer;
struct osnos_rsystemtime;
struct osnos_os_getdllprocaddr_rec;
struct cc_decls_tokenrec;
struct cc_decls_mparamrec;
struct cc_decls_caserec;
struct cc_decls_paramrec;
struct cc_decls_attribrec;
struct cc_decls_fieldrec;
struct cc_decls_strec;
struct cc_decls_unitrec;
struct cc_decls_modulerec;
struct cc_decls_dllprocrec;
struct cc_decls_procrec;
struct cc_lex_stackinforec;
struct cc_parse_readdeclspec_declrec;
struct cc_libmcl_opndrec;
struct cc_libmcl_mclrec;
struct cc_genasm_genrealtable_fprec;
struct ax_decls_fwdrec;
struct ax_decls_opndrec;
struct ax_decls_strec;
struct ax_decls_relocrec;
struct ax_decls_dbuffer;
struct ax_decls_modulerec;
struct ax_decls_stlistrec;
struct ax_lib_mclrec;
struct ax_objdecls_imagefileheader;
struct ax_objdecls_imagedir;
struct ax_objdecls_optionalheader;
struct ax_objdecls_imagesectionheader;
struct ax_objdecls_imagesymbol;
struct ax_objdecls_importdirrec;
struct ax_objdecls_coffrelocrec;
struct ax_objdecls_auxsectionrec;
struct ax_objdecls_sectionrec;
struct ax_objdecls_importrec;
struct ax_objdecls_exportrec;
struct ax_objdecls_dllrec;
struct ax_objdecls_exportdirrec;
struct ax_writeexe_basereloc;

/* Struct Definitions */
struct msysnewc_procinforec {
    u16 fnindex;
    byte rettype;
    byte nparams;
    byte paramlist[12];
};

struct msysnewc_fmtrec {
    byte minwidth;
    i8 precision;
    byte base;
    byte quotechar;
    byte padchar;
    byte realfmt;
    byte plus;
    byte sepchar;
    byte lettercase;
    byte justify;
    byte suffix;
    byte usigned;
    byte charmode;
    byte heapmode;
    byte param;
    byte spare;
};

struct mlib_strbuffer {
    byte *  strptr;
    i32 length;
    i32 allocated;
};

struct osnos_rsystemtime {
    i64 year;
    i64 month;
    i64 dayofweek;
    i64 day;
    i64 hour;
    i64 minute;
    i64 second;
    i64 milliseconds;
};

struct osnos_os_getdllprocaddr_rec {
    byte *  name;
    void *  addr;
};

struct cc_decls_tokenrec {
    union {
        i64 value;
        double xvalue;
        u64 uvalue;
        byte *  svalue;
        struct cc_decls_strec *  symptr;
    };
    struct cc_decls_tokenrec* nexttoken;
    union {
        struct {
            byte subcode;
            byte flags;
        };
        u16 subcodex;
    };
    byte symbol;
    byte fileno;
    u32 lineno;
    i32 length;
    union {
        i32 numberoffset;
        i16 paramno;
        i16 pasteno;
    };
};

struct cc_decls_mparamrec {
    struct cc_decls_strec *  def;
    struct cc_decls_mparamrec* nextmparam;
};

struct cc_decls_caserec {
    struct cc_decls_caserec* nextcase;
    i64 value;
};

struct cc_decls_paramrec {
    struct cc_decls_strec *  def;
    struct cc_decls_paramrec* nextparam;
    i32 mode;
    i16 nparams;
    i16 flags;
};

struct cc_decls_attribrec {
    byte ax_static;
    byte ax_equals;
    byte ax_varparams;
    byte ax_used;
    byte ax_forward;
    byte ax_frame;
    byte ax_autovar;
    byte ax_nparams;
    byte ax_callback;
    byte ax_moduleno;
    byte ax_loop;
    union {
        byte ax_align;
        byte ax_dllindex;
        byte ax_extmodno;
        byte ax_flmacro;
    };
};

struct cc_decls_fieldrec {
    struct cc_decls_strec *  def;
    struct cc_decls_strec *  gendef;
    struct cc_decls_fieldrec* nextfield;
    i64 offset;
};

struct cc_decls_strec {
    byte *  name;
    struct cc_decls_strec* owner;
    struct cc_decls_strec* deflist;
    struct cc_decls_strec* deflistx;
    struct cc_decls_strec* nextdef;
    struct cc_decls_strec* nextdupl;
    struct cc_decls_strec* prevdupl;
    union {
        void *  mclcode;
        void *  opnd;
    };
    union {
        struct cc_decls_paramrec *  nextparam;
        struct cc_decls_unitrec *  callchain;
        struct cc_decls_strec* nextmacro;
        struct cc_decls_fieldrec *  nextfield;
    };
    union {
        struct cc_decls_unitrec *  code;
        struct cc_decls_tokenrec *  tokenlist;
    };
    union {
        struct cc_decls_paramrec *  paramlist;
        struct cc_decls_mparamrec *  mparamlist;
        byte *  macrovalue;
    };
    union {
        void *  address;
        i64 offset;
        byte oldsymbol;
    };
    u32 lineno;
    i32 index;
    union {
        struct {
            u16 blockno;
            u16 namespace;
        };
        u32 nsblock;
    };
    i16 subcode;
    i16 mode;
    byte namelen;
    byte symbol;
    byte nameid;
    byte scope;
    struct cc_decls_attribrec attribs;
};

struct cc_decls_unitrec {
    union {
        struct cc_decls_strec *  def;
        i64 value;
        u64 uvalue;
        double xvalue;
        byte *  svalue;
        u16 *  wsvalue;
        struct cc_decls_strec *  labeldef;
        struct cc_decls_caserec *  nextcase;
        i32 ptrscale;
        i32 offset;
    };
    struct cc_decls_unitrec* nextunit;
    struct cc_decls_unitrec* a;
    struct cc_decls_unitrec* b;
    struct cc_decls_unitrec* c;
    i32 tag;
    u32 lineno;
    union {
        i32 opcode;
        i32 index;
        u32 uindex;
        i32 slength;
        i32 wslength;
        i32 alength;
        i32 scale;
        i32 aparams;
        i32 count;
    };
    i32 mode;
    byte simple;
    byte fileno;
    union {
        byte callconv;
        byte convmem;
        byte isstrconst;
    };
    union {
        byte strarray;
        byte convtomem;
    };
    byte iswstrconst;
    byte spare1;
    u16 spare2;
};

struct cc_decls_modulerec {
    byte *  name;
    struct cc_decls_strec *  stmodule;
    i64 fileno;
    byte *  asmstr;
    byte *  mhdrstr;
    byte importmap[200];
};

struct cc_decls_dllprocrec {
    byte *  name;
    void (*address)(void);
    i64 dllindex;
};

struct cc_decls_procrec {
    struct cc_decls_strec *  def;
    struct cc_decls_procrec* nextproc;
};

struct cc_lex_stackinforec {
    byte *  startptr;
    byte *  sptr;
    i32 lineno;
    i32 fileno;
};

struct cc_parse_readdeclspec_declrec {
    i32 typeno;
    byte isconst;
    byte isvolatile;
    byte isrestrict;
    byte linkage;
    byte isinline;
    byte isshort;
    byte islong;
    byte isllong;
    byte issigned;
    byte isunsigned;
    byte isusertype;
};

struct cc_libmcl_opndrec {
    struct cc_decls_strec *  def;
    union {
        i64 value;
        double xvalue;
        byte *  svalue;
        u16 *  wsvalue;
    };
    i32 size;
    union {
        i32 index;
        i32 slength;
        i32 wslength;
    };
    byte mode;
    byte reg;
    byte regix;
    byte valtype;
    byte scale;
    byte isglobal;
    byte isfloat;
    byte s3;
};

struct cc_libmcl_mclrec {
    struct cc_libmcl_mclrec* nextmcl;
    struct cc_libmcl_opndrec *  a;
    struct cc_libmcl_opndrec *  b;
    byte opcode;
    byte cond;
    byte fileno;
    byte spare;
    i32 lineno;
};

struct cc_genasm_genrealtable_fprec {
    union {
        double x64;
        i64 ix64;
    };
    union {
        float x32;
        i32 ix32;
    };
};

struct ax_decls_fwdrec {
    struct ax_decls_fwdrec* nextfwd;
    i32 offset;
    i16 reltype;
    i16 seg;
};

struct ax_decls_opndrec {
    struct ax_decls_strec *  labeldef;
    union {
        i64 value;
        double xvalue;
        byte *  svalue;
    };
    byte mode;
    byte size;
    byte reg;
    byte regix;
    byte scale;
    byte addrsize;
    byte valtype;
    byte spare2;
};

struct ax_decls_strec {
    byte *  name;
    struct ax_decls_fwdrec *  fwdrefs;
    struct ax_decls_opndrec *  expr;
    i32 offset;
    i32 stindex;
    i32 importindex;
    byte symbol;
    byte ksymbol;
    byte subcode;
    byte regsize;
    byte scope;
    byte reftype;
    byte segment;
    byte namelen;
    struct ax_decls_strec* basedef;
    struct ax_decls_strec* nextdef;
    struct ax_decls_strec* nextdupl;
    i32 moduleno;
    u32 htindex;
    u32 htfirstindex;
    byte spare[48];
};

struct ax_decls_relocrec {
    struct ax_decls_relocrec* nextreloc;
    i64 reloctype;
    i64 offset;
    i64 stindex;
};

struct ax_decls_dbuffer {
    byte *  pstart;
    union {
        byte *  pcurr;
        u16 *  pcurr16;
        u32 *  pcurr32;
        u64 *  pcurr64;
    };
    byte *  pend;
    i64 alloc;
};

struct ax_decls_modulerec {
    byte *  filename;
    byte *  name;
    byte *  source;
};

struct ax_decls_stlistrec {
    struct ax_decls_strec *  def;
    struct ax_decls_stlistrec* nextitem;
};

struct ax_lib_mclrec {
    struct ax_lib_mclrec* nextmcl;
    struct ax_decls_opndrec *  a;
    struct ax_decls_opndrec *  b;
    u16 opcode;
    u16 c;
    i64 lineno;
};

struct ax_objdecls_imagefileheader {
    u16 machine;
    u16 nsections;
    u32 timedatestamp;
    u32 symtaboffset;
    u32 nsymbols;
    u16 optheadersize;
    u16 characteristics;
};

struct ax_objdecls_imagedir {
    u32 virtualaddr;
    u32 size;
};

struct ax_objdecls_optionalheader {
    u16 magic;
    byte majorlv;
    byte minorlv;
    u32 codesize;
    u32 idatasize;
    u32 zdatasize;
    u32 entrypoint;
    u32 codebase;
    u64 imagebase;
    u32 sectionalignment;
    u32 filealignment;
    u16 majorosv;
    u16 minorosv;
    u16 majorimagev;
    u16 minorimagev;
    u16 majorssv;
    u16 minorssv;
    u32 win32version;
    u32 imagesize;
    u32 headerssize;
    u32 checksum;
    u16 subsystem;
    u16 dllcharacteristics;
    u64 stackreserve;
    u64 stackcommit;
    u64 heapreserve;
    u64 heapcommit;
    u32 loaderflags;
    u32 rvadims;
    struct ax_objdecls_imagedir exporttable;
    struct ax_objdecls_imagedir importtable;
    struct ax_objdecls_imagedir resourcetable;
    struct ax_objdecls_imagedir exceptiontable;
    struct ax_objdecls_imagedir certtable;
    struct ax_objdecls_imagedir basereloctable;
    struct ax_objdecls_imagedir debug;
    struct ax_objdecls_imagedir architecture;
    struct ax_objdecls_imagedir globalptr;
    struct ax_objdecls_imagedir tlstable;
    struct ax_objdecls_imagedir loadconfigtable;
    struct ax_objdecls_imagedir boundimport;
    struct ax_objdecls_imagedir iat;
    struct ax_objdecls_imagedir delayimportdescr;
    struct ax_objdecls_imagedir clrheader;
    struct ax_objdecls_imagedir reserved;
};

struct ax_objdecls_imagesectionheader {
    byte name[8];
    union {
        u32 physical_address;
        u32 virtual_size;
    };
    u32 virtual_address;
    u32 rawdata_size;
    u32 rawdata_offset;
    u32 relocations_ptr;
    u32 linenos_offset;
    u16 nrelocs;
    u16 nlinenos;
    u32 characteristics;
};

struct ax_objdecls_imagesymbol {
    union {
        byte shortname[8];
        struct {
            u32 shortx;
            u32 longx;
        };
        u64 longname;
    };
    u32 value;
    i16 sectionno;
    u16 symtype;
    byte storageclass;
    byte nauxsymbols;
};

struct ax_objdecls_importdirrec {
    u32 implookuprva;
    u32 timedatestamp;
    u32 fwdchain;
    u32 namerva;
    u32 impaddressrva;
};

struct ax_objdecls_coffrelocrec {
    i32 virtualaddr;
    i32 stindex;
    i16 reloctype;
};

struct ax_objdecls_auxsectionrec {
    i32 length;
    i16 nrelocs;
    i16 nlines;
    i32 checksum;
    i16 sectionno;
    i32 dummy;
};

struct ax_objdecls_sectionrec {
    union {
        struct ax_decls_dbuffer *  data;
        byte *  bytedata;
    };
    byte *  name;
    i64 segtype;
    i64 rawsize;
    i64 rawoffset;
    i64 virtsize;
    i64 virtoffset;
    struct ax_decls_relocrec *  relocs;
    i64 nrelocs;
};

struct ax_objdecls_importrec {
    struct ax_decls_strec *  def;
    i64 libno;
    byte *  name;
    i64 hintnameoffset;
    i64 iatoffset;
    i64 thunkoffset;
};

struct ax_objdecls_exportrec {
    struct ax_decls_strec *  def;
    byte *  name;
};

struct ax_objdecls_dllrec {
    byte *  name;
    i64 nprocs;
    i64 nametableoffset;
    i64 addrtableoffset;
    i64 dllnameoffset;
    i64 dllextraoffset;
};

struct ax_objdecls_exportdirrec {
    u32 exportflags;
    u32 timedatestamp;
    u16 majorversion;
    u16 minorversion;
    u32 namerva;
    u32 ordinalbase;
    u32 naddrtable;
    u32 nnamepointers;
    u32 expaddressrva;
    u32 namepointerrva;
    u32 ordtablerva;
};

struct ax_writeexe_basereloc {
    struct ax_writeexe_basereloc* nextitem;
    u32 address;
    i32 reloctype;
};


/* PROCDECLS */
void start(void);
static void cc_compilemodules(i64 a,i64 b,i64 pass);
static void cc_debugcompile(void);
static void cc_do_loadmodule(i64 n);
static void cc_do_preprocess(i64 n);
static void cc_do_parsemodule(i64 n);
static void cc_do_genmcl(i64 n);
static void cc_do_genasm(i64 n);
static void cc_do_runprog(void);
static i64 cc_loadmainmodule(byte * filespec);
static i64 cc_addmodule(byte * modulename,i64 fileno,i64 id);
static void cc_initlogfile(void);
static void cc_closelogfile(void);
static void cc_initdata(void);
static void cc_initsearchdirs(void);
static void cc_showsearchdirs(void);
static void cc_showast(i64 n);
static void cc_showstflat(byte * caption);
static void cc_showsttree(byte * caption,i64 n);
static void cc_showmcl(byte * caption,i64 n);
static void cc_showasm(i64 n);
static void cc_showfiles(void);
static void cc_starttiming(void);
static void cc_showtiming(void);
static void cc_getinputoptions(void);
static void cc_do_option(i64 sw,byte * value);
static void cc_showincludepaths(void);
static void cc_showhelp(void);
static void cc_showextrainfo(void);
static void cc_showcaption(void);
static void cc_do_genlink(void);
static void cc_resetcompiler(void);
static i64 cc_addnewmodules(void);
static void cc_writeatfile(void);
i64 msysnewc_m_getdotindex(u64 a,i64 i);
void msysnewc_m_setdotindex(u64 * a,i64 i,i64 x);
i64 msysnewc_m_getdotslice(u64 a,i64 i,i64 j);
void msysnewc_m_setdotslice(u64 * a,i64 i,i64 j,u64 x);
i64 msysnewc_m_get_nprocs(void);
i64 msysnewc_m_get_nexports(void);
void * msysnewc_m_get_procname(i64 n);
byte * msysnewc_m_get_procaddr(i64 n);
void * msysnewc_m_get_procexport(i64 n);
static void msysnewc_pushio(void);
void msysnewc_m_print_startfile(void * dev);
void msysnewc_m_print_startstr(byte * s);
void msysnewc_m_print_startptr(byte * * p);
void msysnewc_m_print_startcon(void);
void msysnewc_m_print_setfmt(byte * format);
void msysnewc_m_print_end(void);
void msysnewc_m_print_ptr(void * a,byte * fmtstyle);
void msysnewc_m_print_i64(i64 a,byte * fmtstyle);
void msysnewc_m_print_u64(u64 a,byte * fmtstyle);
void msysnewc_m_print_r64(double x,byte * fmtstyle);
void msysnewc_m_print_r32(float x,byte * fmtstyle);
void msysnewc_m_print_c8(i64 a,byte * fmtstyle);
void msysnewc_m_print_str(byte * s,byte * fmtstyle);
void msysnewc_m_print_newline(void);
void msysnewc_m_print_nogap(void);
void msysnewc_printstr(byte * s);
void msysnewc_printstr_n(byte * s,i64 n);
void msysnewc_printstrn_app(byte * s,i64 length,void * f);
static byte * msysnewc_makezstring(byte * s,i64 n,byte * local);
static void msysnewc_freezstring(byte * t,i64 n);
static void msysnewc_printchar(i64 ch);
void msysnewc_nextfmtchars(i64 lastx);
void msysnewc_strtofmt(byte * s,i64 slen,struct msysnewc_fmtrec * fmt);
static i64 msysnewc_domultichar(byte * p,i64 n,byte * dest,struct msysnewc_fmtrec * fmt);
static i64 msysnewc_expandstr(byte * s,byte * t,i64 n,struct msysnewc_fmtrec * fmt);
static u64 msysnewc_xdivrem(u64 a,u64 b,u64 * remainder);
static i64 msysnewc_u64tostr(u64 aa,byte * s,u64 base,i64 sep);
static i64 msysnewc_i64tostrfmt(i64 aa,byte * s,struct msysnewc_fmtrec * fmt);
static i64 msysnewc_u64tostrfmt(i64 aa,byte * s,struct msysnewc_fmtrec * fmt);
static i64 msysnewc_i64mintostr(byte * s,i64 base,i64 sep);
static i64 msysnewc_strtostrfmt(byte * s,byte * t,i64 n,struct msysnewc_fmtrec * fmt);
static void msysnewc_tostr_i64(i64 a,struct msysnewc_fmtrec * fmt);
static void msysnewc_tostr_u64(u64 a,struct msysnewc_fmtrec * fmt);
static void msysnewc_tostr_r64(double x,struct msysnewc_fmtrec * fmt);
static void msysnewc_tostr_str(byte * s,struct msysnewc_fmtrec * fmt);
static struct msysnewc_fmtrec * msysnewc_getfmt(byte * fmtstyle);
byte * msysnewc_strint(i64 a,byte * fmtstyle);
void msysnewc_getstrint(i64 a,byte * dest);
byte * msysnewc_strword(u64 a,byte * fmtstyle);
byte * msysnewc_strreal(double a,byte * fmtstyle);
static byte * msysnewc_getstr(byte * s,struct msysnewc_fmtrec * fmt);
static void msysnewc_initreadbuffer(void);
void msysnewc_m_read_conline(void);
void msysnewc_m_read_fileline(void * f);
void msysnewc_m_read_strline(byte * s);
static byte * msysnewc_readitem(i64 * itemlength);
i64 msysnewc_strtoint(byte * s,i64 length,i64 base);
i64 msysnewc_m_read_i64(i64 fmt);
double msysnewc_m_read_r64(i64 fmt);
void msysnewc_m_read_str(byte * dest,i64 destlen,i64 fmt);
void msysnewc_readstr(byte * dest,i64 fmt,i64 destlen);
void msysnewc_rereadln(void);
void msysnewc_reread(void);
i64 msysnewc_valint(byte * s,i64 fmt);
double msysnewc_valreal(byte * s);
static void msysnewc_iconvlcn(byte * s,i64 n);
static void msysnewc_iconvucn(byte * s,i64 n);
static void msysnewc_convlcstring(byte * s);
static void msysnewc_convucstring(byte * s);
i64 msysnewc_m_power_i64(i64 n,i64 a);
void msysnewc_m_intoverflow(void);
void msysnewc_m_dotindex(u64 i,u64 a);
void msysnewc_m_dotslice(u64 j,u64 i,u64 a);
void msysnewc_m_popdotindex(u64 i,u64 * p,u64 x);
void msysnewc_m_popdotslice(u64 j,u64 i,u64 * p,u64 x);
i64 msysnewc_m_imin(i64 a,i64 b);
i64 msysnewc_m_imax(i64 a,i64 b);
double msysnewc_m_sign(double x);
void * mlib_pcm_alloc(i64 n);
void mlib_pcm_freestr(byte * s);
void mlib_pcm_free(void * p,i64 n);
void mlib_pcm_freeac(void * p,i64 alloc);
void mlib_pcm_copymem4(void * p,void * q,i64 n);
void mlib_pcm_clearmem(void * p,i64 n);
void mlib_pcm_init(void);
i64 mlib_pcm_getac(i64 size);
void * mlib_pcm_newblock(i64 itemsize);
i64 mlib_pcm_round(i64 n);
i64 mlib_pcm_array(i64 n);
void mlib_pcm_printfreelist(i64 size,u64 * p);
void mlib_pcm_diags(byte * caption);
void * mlib_pcm_allocz(i64 n);
byte * mlib_pcm_copyheapstring(byte * s);
byte * mlib_pcm_copyheapstringn(byte * s,i64 n);
byte * mlib_pcm_copyheapblock(byte * s,i64 length);
static void mlib_addtomemalloc(i32 * ptr,i64 size);
static void mlib_removefrommemalloc(i32 * ptr,i64 size);
void * mlib_allocmem(i64 n);
void * mlib_reallocmem(void * p,i64 n);
void mlib_abortprogram(byte * s);
i64 mlib_getfilesize(void * handlex);
void mlib_readrandom(void * handlex,byte * mem,i64 offset,i64 size);
i64 mlib_writerandom(void * handlex,byte * mem,i64 offset,i64 size);
i64 mlib_setfilepos(void * file,i64 offset);
i64 mlib_getfilepos(void * file);
byte * mlib_readfile(byte * filename);
i64 mlib_writefile(byte * filename,byte * data,i64 size);
i64 mlib_checkfile(byte * file);
void mlib_readlinen(void * handlex,byte * buffer,i64 size);
void mlib_iconvlcn(byte * s,i64 n);
void mlib_iconvucn(byte * s,i64 n);
void mlib_convlcstring(byte * s);
void mlib_convucstring(byte * s);
byte * mlib_changeext(byte * s,byte * newext);
byte * mlib_extractext(byte * s,i64 period);
byte * mlib_extractpath(byte * s);
byte * mlib_extractfile(byte * s);
byte * mlib_extractbasefile(byte * s);
byte * mlib_addext(byte * s,byte * newext);
void * mlib_alloctable(i64 n,i64 size);
void * mlib_zalloctable(i64 n,i64 size);
void mlib_checkfreelists(byte * s);
void * mlib_pcm_alloc32(void);
void mlib_pcm_free32(void * p);
void mlib_outbyte(void * f,i64 x);
void mlib_outword16(void * f,u64 x);
void mlib_outword(void * f,u64 x);
void mlib_outword64(void * f,u64 x);
i64 mlib_myeof(void * f);
void * mlib_pcm_smallallocz(i64 n);
void * mlib_pcm_smallalloc(i64 n);
void mlib_strbuffer_add(struct mlib_strbuffer * dest,byte * s,i64 n);
void mlib_gs_init(struct mlib_strbuffer * dest);
void mlib_gs_free(struct mlib_strbuffer * dest);
void mlib_gs_str(struct mlib_strbuffer * dest,byte * s);
void mlib_gs_char(struct mlib_strbuffer * dest,i64 c);
void mlib_gs_strn(struct mlib_strbuffer * dest,byte * s,i64 length);
void mlib_gs_strvar(struct mlib_strbuffer * dest,struct mlib_strbuffer * s);
void mlib_gs_strint(struct mlib_strbuffer * dest,i64 a);
void mlib_gs_strln(struct mlib_strbuffer * dest,byte * s);
void mlib_gs_strsp(struct mlib_strbuffer * dest,byte * s);
void mlib_gs_line(struct mlib_strbuffer * dest);
i64 mlib_gs_getcol(struct mlib_strbuffer * dest);
void mlib_gs_leftstr(struct mlib_strbuffer * dest,byte * s,i64 w,i64 padch);
void mlib_gs_leftint(struct mlib_strbuffer * dest,i64 a,i64 w,i64 padch);
void mlib_gs_padto(struct mlib_strbuffer * dest,i64 col,i64 ch);
void mlib_gs_println(struct mlib_strbuffer * dest,void * f);
i64 mlib_nextcmdparam(i64 * paramno,byte * * name,byte * * value,byte * defext);
static i64 mlib_readnextfileitem(byte * * fileptr,byte * * item);
void mlib_ipadstr(byte * s,i64 width,byte * padchar);
byte * mlib_padstr(byte * s,i64 width,byte * padchar);
byte * mlib_chr(i64 c);
i64 mlib_cmpstring(byte * s,byte * t);
i64 mlib_cmpstringn(byte * s,byte * t,i64 n);
i64 mlib_eqstring(byte * s,byte * t);
i64 mlib_cmpbytes(void * p,void * q,i64 n);
i64 mlib_eqbytes(void * p,void * q,i64 n);
void mlib_mseed(u64 a,u64 b);
u64 mlib_mrandom(void);
i64 mlib_mrandomp(void);
i64 mlib_mrandomint(i64 n);
i64 mlib_mrandomrange(i64 a,i64 b);
double mlib_mrandomreal(void);
double mlib_mrandomreal1(void);
byte * mlib_checkpackfile(void);
void osnos_os_init(void);
i64 osnos_os_execwait(byte * cmdline,i64 newconsole,byte * workdir);
i64 osnos_os_execcmd(byte * cmdline,i64 newconsole);
i64 osnos_os_getch(void);
i64 osnos_os_kbhit(void);
void osnos_os_flushkeys(void);
void * osnos_os_getconsolein(void);
void * osnos_os_getconsoleout(void);
void * osnos_os_proginstance(void);
u64 osnos_os_getdllinst(byte * name);
void (*osnos_os_getdllprocaddr(i64 hinst,byte * name))(void);
void osnos_os_initwindows(void);
i64 osnos_os_getchx(void);
byte * osnos_os_getos(void);
i64 osnos_os_getoscode(void);
i64 osnos_os_iswindows(void);
i64 osnos_os_shellexec(byte * opc,byte * file);
void osnos_os_sleep(i64 a);
void * osnos_os_getstdin(void);
void * osnos_os_getstdout(void);
byte * osnos_os_gethostname(void);
i64 osnos_os_gethostsize(void);
byte * osnos_os_getmpath(void);
void osnos_os_exitprocess(i64 x);
i64 osnos_os_gettimestamp(void);
i64 osnos_os_gettickcount(void);
i64 osnos_os_clock(void);
i64 osnos_os_getclockspersec(void);
void osnos_os_setmesshandler(void * addr);
i64 osnos_os_filelastwritetime(byte * filename);
i64 osnos_os_hpcounter(void);
i64 osnos_os_hpfrequency(void);
void osnos_os_getsystime(void * tm);
void osnos_os_peek(void);
static void cc_support_stopcompiler(byte * filename,i64 lineno);
void cc_support_mcerror(byte * mess);
void cc_support_serror(byte * mess);
void cc_support_serror_gen(byte * mess);
void cc_support_serror_ss(byte * mess,byte * a,byte * b);
void cc_support_serror_s(byte * mess,byte * a);
void cc_support_terror_gen(byte * mess);
void cc_support_terror(byte * mess);
void cc_support_terror_s(byte * mess,byte * a);
void cc_support_terror_ss(byte * mess,byte * a,byte * b);
void cc_support_gerror_gen(byte * mess,struct cc_decls_unitrec * p);
void cc_support_gerror(byte * mess,struct cc_decls_unitrec * p);
void cc_support_gerror_s(byte * mess,byte * s,struct cc_decls_unitrec * p);
void cc_support_nxerror(byte * mess,struct cc_decls_unitrec * p);
i64 cc_support_testelem(byte (*p)[],i64 n);
void cc_support_setelem(byte (*p)[],i64 n);
i64 cc_support_nextpoweroftwo(i64 x);
void cc_support_loaderror(byte * mess,byte * mess2);
i64 cc_support_loadfromstdin(byte * file);
i64 cc_support_loadsourcefile(byte * file,byte * shortfile);
static byte * cc_support_splicelines(byte * s);
i64 cc_support_loadbuiltin(byte * shortfile,byte * hdrtext);
static void cc_support_gs_copytostr(struct mlib_strbuffer * source,byte * s);
void cc_support_gs_additem(struct mlib_strbuffer * dest,byte * s);
static i64 cc_support_isalphanum(i64 c);
static void cc_support_showmacrolineno(void);
void cc_lex_lex_preprocess_only(byte * infile,i64 showtokens,i64 nn,i64 toconsole);
void cc_lex_lexreadtoken(void);
static void cc_lex_readrealnumber(byte * pstart,byte * intstart,i64 intlen,i64 base);
static i64 cc_lex_readexponent(i64 * badexpon);
static void cc_lex_lxerror(byte * mess);
void cc_lex_printsymbol(struct cc_decls_tokenrec * lp);
void cc_lex_lexsetup(void);
void cc_lex_printstrn(byte * s,i64 length,void * f);
static byte * cc_lex_scannumber(i64 base);
static i64 cc_lex_lookup(void);
u64 cc_lex_gethashvalue(byte * s,i64 length);
static void cc_lex_inithashtable(void);
static void cc_lex_fillhashtable(void);
static i64 cc_lex_dolexdirective(void);
static i64 cc_lex_getlexdirective(void);
void cc_lex_startlex(byte * caption,i64 fileno);
void cc_lex_endlex(void);
void cc_lex_ps(byte * caption);
void cc_lex_psnext(byte * caption);
i64 cc_lex_gethashtablesize(void);
static void cc_lex_readlinecomment(void);
static void cc_lex_readblockcomment(void);
static void cc_lex_readhex(byte * pstart);
static void cc_lex_readbinary(byte * pstart);
static void cc_lex_readoctal(byte * pstart);
static void cc_lex_readdecimal(byte * pstart);
static i64 cc_lex_checknumbersuffix(void);
static void cc_lex_stacksourcefile(byte * file,i64 syshdr);
static void cc_lex_unstacksourcefile(void);
static i64 cc_lex_getsourcefile(byte * file,i64 syshdr);
void cc_lex_lex(void);
static void cc_lex_shownumberstr(struct cc_decls_tokenrec * l,void * f);
struct cc_decls_strec * cc_lex_addnamestr(byte * name);
static void cc_lex_lxreadstring(i64 termchar,i64 fwide);
static void cc_lex_addlisttoken(struct cc_decls_tokenrec * * ulist,struct cc_decls_tokenrec * * ulistx,struct cc_decls_tokenrec * p);
static void cc_lex_addlisttoken_copy(struct cc_decls_tokenrec * * ulist,struct cc_decls_tokenrec * * ulistx,struct cc_decls_tokenrec * q);
static void cc_lex_addlist_nextlx(struct cc_decls_tokenrec * * ulist,struct cc_decls_tokenrec * * ulistx);
static void cc_lex_addlisttoken_seq(struct cc_decls_tokenrec * * ulist,struct cc_decls_tokenrec * * ulistx,struct cc_decls_tokenrec * seq);
static void cc_lex_addlistmparam(struct cc_decls_mparamrec * * ulist,struct cc_decls_mparamrec * * ulistx,struct cc_decls_mparamrec * p);
static void cc_lex_dodefine(void);
static void cc_lex_readalphanumeric(byte * pstart);
static i64 cc_lex_inmacrostack(struct cc_decls_strec * d,struct cc_decls_tokenrec * macrostack);
static void cc_lex_showtokens(byte * caption,struct cc_decls_tokenrec * tk);
static void cc_lex_lexa(struct cc_decls_tokenrec * * tk);
static void cc_lex_lexm(void);
static i64 cc_lex_peeklb(void);
static i64 cc_lex_peektk(struct cc_decls_tokenrec * tk);
static struct cc_decls_tokenrec * cc_lex_expandobjmacro(struct cc_decls_strec * m,struct cc_decls_tokenrec * macrostack,struct cc_decls_tokenrec * * tksource,i64 frombaselevel);
static struct cc_decls_tokenrec * cc_lex_expandfnmacro(struct cc_decls_strec * m,struct cc_decls_tokenrec * macrostack,struct cc_decls_tokenrec * * tksource,i64 frombaselevel,i64 * endlineno);
static struct cc_decls_tokenrec * cc_lex_scantokenseq(struct cc_decls_tokenrec * tk,struct cc_decls_tokenrec * macrostack,i64 * expanded);
static i64 cc_lex_readmacrocall(struct cc_decls_strec * d,struct cc_decls_tokenrec * (*args)[],struct cc_decls_tokenrec * * tksource);
static struct cc_decls_tokenrec * cc_lex_substituteargs(struct cc_decls_strec * m,struct cc_decls_tokenrec * (*args)[],struct cc_decls_tokenrec * (*expargs)[],i64 nargs,struct cc_decls_tokenrec * macrostack);
static byte * cc_lex_strtoken(struct cc_decls_tokenrec * lp,i64 * length);
static byte * cc_lex_strstring(byte * s,i64 length,i64 * newlength,i64 quotechar);
void cc_lex_emittoken(struct cc_decls_tokenrec * lp,struct mlib_strbuffer * dest,i64 forcespace);
void cc_lex_showtoken(struct cc_decls_tokenrec * lp);
static void cc_lex_stringify(struct cc_decls_tokenrec * seq,struct cc_decls_tokenrec * dest);
static void cc_lex_pastetokens(struct cc_decls_tokenrec * tk,struct cc_decls_tokenrec * * tknext);
static i64 cc_lex_getifexpr(void);
static i64 cc_lex_evalcondexpr(i64 * sx);
static i64 cc_lex_evalorexpr(i64 * sx);
static i64 cc_lex_evalandexpr(i64 * sx);
static i64 cc_lex_evaliorexpr(i64 * sx);
static i64 cc_lex_evalixorexpr(i64 * sx);
static i64 cc_lex_evaliandexpr(i64 * sx);
static i64 cc_lex_evaleqexpr(i64 * sx);
static i64 cc_lex_evalcmpexpr(i64 * sx);
static i64 cc_lex_evalshiftexpr(i64 * sx);
static i64 cc_lex_evaladdexpr(i64 * sx);
static i64 cc_lex_evalmulexpr(i64 * sx);
static i64 cc_lex_evalunaryexpr(i64 * sx);
static i64 cc_lex_evalterm(i64 * sx);
static i64 cc_lex_getifdef(void);
static i64 cc_lex_skipcode(void);
static void cc_lex_freetokens(struct cc_decls_tokenrec * tk);
void cc_lex_fastreadtoken(void);
static struct cc_decls_tokenrec * cc_lex_alloctoken(void);
static struct cc_decls_tokenrec * cc_lex_alloctokenz(void);
static void cc_lex_expandpredefmacro(i64 pdmcode,struct cc_decls_tokenrec * tk,i64 lineno);
static void cc_lex_dopragmadir(void);
static i64 cc_lex_needspace(i64 a,i64 b);
void cc_lex_dospecialinclude(void);
static void cc_lex_addautomodule(byte * headername,i64 fileno);
static void cc_lex_setnumberoffset(i64 offset);
static void cc_lex_setfileno(i64 fileno);
static void cc_lex_setfilenox(struct cc_decls_tokenrec * tk,i64 fileno);
static i64 cc_lex_getfileno(void);
static i64 cc_lex_getfilenox(struct cc_decls_tokenrec * tk);
static i64 cc_lex_getnumberoffsetx(struct cc_decls_tokenrec * tk);
void cc_lex_freehashtable(void);
static void cc_lex_freestentry(struct cc_decls_strec * d);
static void cc_lex_regenlookup(struct cc_decls_strec * d);
static void cc_lex_printhashtable(byte * caption);
static void cc_lex_newhashtable(void);
static void cc_lex_old_readrealnumber(byte * pstart,byte * intstart,i64 intlen,i64 base);
byte * cc_headers_findheader(byte * name);
void cc_headers_writeheaders(void);
void cc_headers_checkbcclib(void);
byte * cc_headers_getbcclib(void);
i64 cc_headers_isheaderfile(byte * file);
static struct cc_decls_strec * cc_lib_newstrec(void);
void cc_lib_initcclib(void);
void cc_lib_printst(void * f,struct cc_decls_strec * p,i64 level);
static void cc_lib_printstrec(void * f,struct cc_decls_strec * p,i64 level);
void cc_lib_printstflat(void * f);
struct cc_decls_unitrec * cc_lib_createname(struct cc_decls_strec * p);
struct cc_decls_unitrec * cc_lib_createunit0(i64 tag);
struct cc_decls_unitrec * cc_lib_createunit1(i64 tag,struct cc_decls_unitrec * p);
struct cc_decls_unitrec * cc_lib_createunit2(i64 tag,struct cc_decls_unitrec * p,struct cc_decls_unitrec * q);
struct cc_decls_unitrec * cc_lib_createunit3(i64 tag,struct cc_decls_unitrec * p,struct cc_decls_unitrec * q,struct cc_decls_unitrec * r);
struct cc_decls_unitrec * cc_lib_createconstunit(u64 a,i64 t);
struct cc_decls_unitrec * cc_lib_createstringconstunit(byte * s,i64 length);
struct cc_decls_unitrec * cc_lib_createwstringconstunit(u16 * s,i64 length);
i64 cc_lib_getoptocode(i64 opc);
i64 cc_lib_getconstvalue(struct cc_decls_unitrec * p,i64 id);
byte * cc_lib_nextautotype(void);
i64 cc_lib_createconstmode(i64 m);
i64 cc_lib_createrefmode(i64 m);
i64 cc_lib_createprocmode(i64 m,struct cc_decls_paramrec * pm);
i64 cc_lib_createarraymode(i64 m,i64 length);
i64 cc_lib_createenummode(struct cc_decls_strec * e);
i64 cc_lib_createstructmode(struct cc_decls_strec * s,i64 smode);
void cc_lib_setnameptr(struct cc_decls_unitrec * p);
void cc_lib_printcode_all(void * f,byte * caption);
void cc_lib_printcode(void * f,byte * caption,i64 n);
void cc_lib_printunit(void * dev,struct cc_decls_unitrec * p,i64 level,byte * prefix);
static void cc_lib_printunitlist(void * dev,struct cc_decls_unitrec * p,i64 level,byte * prefix);
static byte * cc_lib_getprefix(i64 level,byte * prefix,struct cc_decls_unitrec * p);
byte * cc_lib_getdottedname(struct cc_decls_strec * p);
static byte * cc_lib_getlineinfok(void);
struct cc_decls_strec * cc_lib_getautofieldname(void);
void cc_lib_convertstring(byte * s,byte * t,i64 length);
struct mlib_strbuffer * cc_lib_strexpr(struct cc_decls_unitrec * p);
static void cc_lib_jeval(struct mlib_strbuffer * dest,struct cc_decls_unitrec * p);
byte * cc_lib_getopcjname(i64 opc);
byte * cc_lib_strmode(i64 m,i64 expand);
byte * cc_lib_strmode2(i64 m,i64 expand);
void cc_lib_istrmode(i64 m,i64 expand,byte * dest);
i64 cc_lib_countunits(struct cc_decls_unitrec * p);
static void cc_lib_purgesymbol(struct cc_decls_strec * p,struct cc_decls_strec * prev,i64 del);
void cc_lib_purgesymbollist(struct cc_decls_strec * p,i64 ismodule,i64 del);
void cc_lib_purgeprocs(struct cc_decls_strec * p,i64 del);
void cc_lib_purgeproc(struct cc_decls_strec * p,i64 del);
void cc_lib_printmodelist(void * f);
byte * cc_lib_typename(i64 m);
struct cc_decls_unitrec * cc_lib_allocunitrec(void);
static i64 cc_lib_copymode(i64 m);
static i64 cc_lib_createnewmode(i64 m);
void cc_lib_addlistunit(struct cc_decls_unitrec * * ulist,struct cc_decls_unitrec * * ulistx,struct cc_decls_unitrec * p);
void cc_lib_addlistdef(struct cc_decls_strec * * ulist,struct cc_decls_strec * * ulistx,struct cc_decls_strec * p);
void cc_lib_addlistparam(struct cc_decls_paramrec * * ulist,struct cc_decls_paramrec * * ulistx,struct cc_decls_paramrec * p);
void cc_lib_checksymbol(i64 symbol);
void cc_lib_skipsymbol(i64 symbol);
void cc_lib_inittypetables(void);
struct cc_decls_strec * cc_lib_createdupldef(struct cc_decls_strec * owner,struct cc_decls_strec * symptr,i64 id);
struct cc_decls_strec * cc_lib_createnewmoduledef(struct cc_decls_strec * owner,struct cc_decls_strec * symptr);
struct cc_decls_strec * cc_lib_createnewproc(struct cc_decls_strec * owner,struct cc_decls_strec * symptr);
struct cc_decls_strec * cc_lib_resolvename(struct cc_decls_strec * owner,struct cc_decls_strec * symptr,i64 ns,i64 blockno);
struct cc_decls_strec * cc_lib_resolvelabel(struct cc_decls_strec * owner,struct cc_decls_strec * symptr);
struct cc_decls_strec * cc_lib_checkdupl(struct cc_decls_strec * owner,struct cc_decls_strec * symptr,i64 ns,i64 blockno);
struct cc_decls_strec * cc_lib_checkdupl_inproc(struct cc_decls_strec * owner,struct cc_decls_strec * symptr,i64 ns,i64 blockno);
i64 cc_lib_getalignment(i64 m);
i64 cc_lib_isexported(struct cc_decls_strec * d);
i64 cc_lib_isimported(struct cc_decls_strec * d);
i64 cc_lib_isstructunion(i64 m);
byte * cc_lib_getstname(struct cc_decls_strec * d);
i64 cc_lib_isrealcc(i64 m);
i64 cc_lib_isintcc(i64 m);
static void cc_parse_readmodule(void);
i64 cc_parse_parsemodule(i64 n);
static i64 cc_parse_readdeclspec(struct cc_decls_strec * owner,i64 * linkage);
static i64 cc_parse_istypestarter(void);
static struct cc_decls_unitrec * cc_parse_readexpression(void);
static struct cc_decls_unitrec * cc_parse_readassignexpr(void);
static struct cc_decls_unitrec * cc_parse_readcondexpr(void);
static struct cc_decls_unitrec * cc_parse_readorlexpr(void);
static struct cc_decls_unitrec * cc_parse_readandlexpr(void);
static struct cc_decls_unitrec * cc_parse_readiorexpr(void);
static struct cc_decls_unitrec * cc_parse_readixorexpr(void);
static struct cc_decls_unitrec * cc_parse_readiandexpr(void);
static struct cc_decls_unitrec * cc_parse_readeqexpr(void);
static struct cc_decls_unitrec * cc_parse_readrelexpr(void);
static struct cc_decls_unitrec * cc_parse_readshiftexpr(void);
static struct cc_decls_unitrec * cc_parse_readaddexpr(void);
static struct cc_decls_unitrec * cc_parse_readmulexpr(void);
static struct cc_decls_unitrec * cc_parse_readterm(void);
static struct cc_decls_unitrec * cc_parse_readexprlist(struct cc_decls_unitrec * p);
static struct cc_decls_strec * cc_parse_readmodulevar(struct cc_decls_strec * d,i64 m,i64 linkage);
static struct cc_decls_strec * cc_parse_readframevar(struct cc_decls_strec * d,i64 m,i64 linkage);
static i64 cc_parse_readtype(struct cc_decls_strec * owner,struct cc_decls_strec * * d,i64 m,struct cc_decls_paramrec * * pm);
static void cc_parse_readnamedtype(struct cc_decls_strec * owner,struct cc_decls_strec * * d,i64 (*modtype)[],void * (*modvalue)[],i64 * nmodifiers);
static i64 cc_parse_readconstintexpr(void);
static struct cc_decls_unitrec * cc_parse_readinitexpr(struct cc_decls_strec * owner,i64 m);
static struct cc_decls_unitrec * cc_parse_readinitexpr2(struct cc_decls_strec * owner,i64 m,i64 istop);
static void cc_parse_pushblock(void);
static void cc_parse_popblock(void);
static struct cc_decls_unitrec * cc_parse_readcompoundstmt(i64 params);
static struct cc_decls_unitrec * cc_parse_readblock(i64 ifelse);
static struct cc_decls_unitrec * cc_parse_readstatement(void);
static struct cc_decls_unitrec * cc_parse_readifstmt(void);
static struct cc_decls_unitrec * cc_parse_readforstmt(void);
static struct cc_decls_unitrec * cc_parse_readwhilestmt(void);
static struct cc_decls_unitrec * cc_parse_readdostmt(void);
static struct cc_decls_unitrec * cc_parse_readreturnstmt(void);
static struct cc_decls_unitrec * cc_parse_readgotostmt(void);
static struct cc_decls_unitrec * cc_parse_readswitchstmt(void);
static struct cc_decls_unitrec * cc_parse_readcaselabel(void);
static struct cc_decls_unitrec * cc_parse_readexprstmt(void);
static struct cc_decls_unitrec * cc_parse_readcond(void);
static i64 cc_parse_isusertype(struct cc_decls_strec * owner);
static struct cc_decls_unitrec * cc_parse_readlocaldecl(void);
static struct cc_decls_strec * cc_parse_createtypedef(struct cc_decls_strec * owner,struct cc_decls_strec * symptr,i64 mode);
static struct cc_decls_paramrec * cc_parse_readparams(struct cc_decls_strec * owner);
static i64 cc_parse_readcasttype(struct cc_decls_strec * * d,i64 allowname,struct cc_decls_paramrec * * pm);
static struct cc_decls_strec * cc_parse_readfunction(struct cc_decls_strec * d,i64 m,i64 linkage,struct cc_decls_paramrec * pm,i64 * wasdef);
static void cc_parse_readfunctionbody(struct cc_decls_strec * f);
static struct cc_decls_unitrec * cc_parse_createnegop(struct cc_decls_unitrec * p);
static struct cc_decls_unitrec * cc_parse_createabsop(struct cc_decls_unitrec * p);
static struct cc_decls_unitrec * cc_parse_createsqrtop(struct cc_decls_unitrec * p);
static struct cc_decls_unitrec * cc_parse_createinotop(struct cc_decls_unitrec * p);
static struct cc_decls_unitrec * cc_parse_createptrop(struct cc_decls_unitrec * p);
static struct cc_decls_unitrec * cc_parse_createincrop(i64 opc,struct cc_decls_unitrec * p);
static struct cc_decls_unitrec * cc_parse_createlengthofop(struct cc_decls_unitrec * p);
static struct cc_decls_unitrec * cc_parse_createaddrofop(struct cc_decls_unitrec * p);
static struct cc_decls_unitrec * cc_parse_createaddop(struct cc_decls_unitrec * x,struct cc_decls_unitrec * y);
static struct cc_decls_unitrec * cc_parse_createsubop(struct cc_decls_unitrec * x,struct cc_decls_unitrec * y);
static struct cc_decls_unitrec * cc_parse_createmulop(struct cc_decls_unitrec * x,struct cc_decls_unitrec * y);
static struct cc_decls_unitrec * cc_parse_createdivop(struct cc_decls_unitrec * x,struct cc_decls_unitrec * y);
static struct cc_decls_unitrec * cc_parse_createremop(struct cc_decls_unitrec * x,struct cc_decls_unitrec * y);
static void cc_parse_insertunit(struct cc_decls_unitrec * p,i64 tag);
static struct cc_decls_unitrec * cc_parse_eval_add(i64 opc,struct cc_decls_unitrec * x,struct cc_decls_unitrec * y,i64 t);
static struct cc_decls_unitrec * cc_parse_eval_sub(i64 opc,struct cc_decls_unitrec * x,struct cc_decls_unitrec * y,i64 t);
static struct cc_decls_unitrec * cc_parse_eval_mul(i64 opc,struct cc_decls_unitrec * x,struct cc_decls_unitrec * y,i64 t);
static struct cc_decls_unitrec * cc_parse_eval_div(i64 opc,struct cc_decls_unitrec * x,struct cc_decls_unitrec * y,i64 t);
static struct cc_decls_unitrec * cc_parse_eval_rem(i64 opc,struct cc_decls_unitrec * x,struct cc_decls_unitrec * y,i64 t);
static i64 cc_parse_eval_convert(struct cc_decls_unitrec * p,i64 t,i64 opc);
static void cc_parse_coercecond(struct cc_decls_unitrec * p);
static void cc_parse_coercebasetype(struct cc_decls_unitrec * p);
static void cc_parse_checklvalue(struct cc_decls_unitrec * p);
static struct cc_decls_unitrec * cc_parse_createcall(struct cc_decls_unitrec * p,struct cc_decls_unitrec * q);
static struct cc_decls_unitrec * cc_parse_arraytopointer(struct cc_decls_unitrec * p);
static struct cc_decls_unitrec * cc_parse_createindexop(struct cc_decls_unitrec * p,struct cc_decls_unitrec * q);
static i64 cc_parse_readstructdecl(struct cc_decls_strec * owner);
static i64 cc_parse_checkpointertypes(i64 s,i64 t,i64 hard);
static i64 cc_parse_comparemode(i64 s,i64 t);
static i64 cc_parse_readenumdecl(struct cc_decls_strec * owner);
static void cc_parse_readenumnames(struct cc_decls_strec * owner);
static struct cc_decls_unitrec * cc_parse_createdotop(i64 opc,struct cc_decls_unitrec * p,struct cc_decls_strec * d);
static struct cc_decls_unitrec * cc_parse_mulunit(struct cc_decls_unitrec * p,i64 elemtype);
static struct cc_decls_unitrec * cc_parse_divunit(struct cc_decls_unitrec * p,i64 elemtype);
static struct cc_decls_unitrec * cc_parse_createassignopref(i64 opc,struct cc_decls_unitrec * p,struct cc_decls_unitrec * q);
static void cc_parse_addnewfield(struct cc_decls_fieldrec * * flist,struct cc_decls_strec * d,i64 offset);
static void cc_parse_pushloop(i64 looptype);
static void cc_parse_poploop(void);
static void cc_parse_addcasevalue(i64 value);
static i64 cc_parse_roundoffset(i64 offset,i64 alignment);
static void cc_parse_fixmemopnd(struct cc_decls_unitrec * p);
static struct cc_decls_unitrec * cc_parse_docast(struct cc_decls_unitrec * p,i64 t,i64 hard,i64 inplace);
static struct cc_decls_unitrec * cc_parse_coercemode(struct cc_decls_unitrec * p,i64 t);
static void cc_parse_coercemode_inplace(struct cc_decls_unitrec * p,i64 t);
static void cc_parse_dostaticassert(void);
static struct cc_decls_unitrec * cc_parse_createsizeofop(struct cc_decls_unitrec * p);
static struct cc_decls_unitrec * cc_parse_readgeneric(void);
static void cc_parse_readstructinfosym(void);
static i64 cc_parse_getmemmode(struct cc_decls_unitrec * p);
static struct cc_decls_unitrec * cc_parse_readstrinclude(void);
i64 cc_genmcl_codegen_mcl(i64 n);
static void cc_genmcl_genprocdef(struct cc_decls_strec * p);
static i64 cc_genmcl_checkblockreturn(struct cc_decls_unitrec * p);
static void cc_genmcl_dolabel(struct cc_decls_strec * d);
static void cc_genmcl_dolabel_fn(struct cc_decls_strec * d,i64 dollar);
static void cc_genmcl_dostaticvar(struct cc_decls_strec * d);
static void cc_genmcl_dostaticvar_fn(struct cc_decls_strec * d);
static void cc_genmcl_genprocentry(i64 fbytes,i64 pbytes);
static void cc_genmcl_genidata(struct cc_decls_unitrec * p,i64 doterm,i64 am,i64 offset);
static void cc_genmcl_genmainprelude(void);
void cc_libmcl_mclinit(void);
i64 cc_libmcl_gettargetdata(i64 f64);
void cc_libmcl_initmcdest(void);
void cc_libmcl_genmc(i64 opcode,struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
void cc_libmcl_genmc_cond(i64 opcode,i64 cond,struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
struct cc_libmcl_mclrec * cc_libmcl_lastmc(void);
void cc_libmcl_genmcstr(i64 opcode,byte * s);
static struct cc_libmcl_opndrec * cc_libmcl_newopnd(void);
struct cc_libmcl_opndrec * cc_libmcl_duplopnd(struct cc_libmcl_opndrec * a);
struct cc_libmcl_opndrec * cc_libmcl_genxreg(i64 xreg,i64 size);
struct cc_libmcl_opndrec * cc_libmcl_genindex(i64 areg,i64 ireg,i64 scale,i64 offset,i64 size,i64 labno,struct cc_decls_strec * def);
static void cc_libmcl_writemclblock(struct cc_libmcl_mclrec * m);
struct mlib_strbuffer * cc_libmcl_writemclcode(byte * caption,i64 nmodule);
void cc_libmcl_gencomment(byte * s);
struct cc_libmcl_opndrec * cc_libmcl_genstrimm(byte * s,i64 length);
struct cc_libmcl_opndrec * cc_libmcl_genwstrimm(u16 * s,i64 length);
struct cc_libmcl_opndrec * cc_libmcl_genname(byte * s);
static void cc_libmcl_writemcl(i64 index,struct cc_libmcl_mclrec * mcl);
byte * cc_libmcl_strmcl(struct cc_libmcl_mclrec * mcl);
byte * cc_libmcl_stropnd(struct cc_libmcl_opndrec * a,i64 sizeprefix,i64 debug);
byte * cc_libmcl_strvalue(struct cc_libmcl_opndrec * a);
void cc_libmcl_setsegment(i64 seg,i64 align);
byte * cc_libmcl_getprocname(struct cc_decls_strec * d);
i64 cc_libmcl_widenstr(byte * s,i64 w);
void cc_libmcl_genassem(byte * s);
byte * cc_libmcl_strlabel(i64 n);
struct cc_libmcl_opndrec * cc_libmcl_makeindirect(struct cc_libmcl_opndrec * a,i64 size);
struct cc_libmcl_opndrec * cc_libmcl_applyoffset(struct cc_libmcl_opndrec * a,i64 offset,i64 size);
struct cc_libmcl_opndrec * cc_libmcl_applysize(struct cc_libmcl_opndrec * a,i64 size);
i64 cc_libmcl_isframe(struct cc_decls_strec * d);
void cc_libmcl_genreturn(i64 fbytes,i64 pbytes);
byte * cc_libmcl_getsizeprefix(i64 size,i64 enable);
i64 cc_libmcl_needsizeprefix(i64 opcode,struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
struct cc_libmcl_opndrec * cc_libmcl_changeopndsize(struct cc_libmcl_opndrec * a,i64 size);
struct cc_libmcl_opndrec * cc_libmcl_genint(i64 x,i64 size);
struct cc_libmcl_opndrec * cc_libmcl_genreal(double x,i64 size);
struct cc_libmcl_opndrec * cc_libmcl_genimm(struct cc_decls_unitrec * p,i64 size);
struct cc_libmcl_opndrec * cc_libmcl_genlabel(i64 x,i64 isglobal);
struct cc_libmcl_opndrec * cc_libmcl_genmem_u(struct cc_decls_unitrec * p,i64 size);
struct cc_libmcl_opndrec * cc_libmcl_genmem_d(struct cc_decls_strec * d,i64 size);
struct cc_libmcl_opndrec * cc_libmcl_genmemaddr_u(struct cc_decls_unitrec * p);
struct cc_libmcl_opndrec * cc_libmcl_genmemaddr_d(struct cc_decls_strec * d);
struct cc_libmcl_opndrec * cc_libmcl_genreg(i64 reg,i64 size);
struct cc_libmcl_opndrec * cc_libmcl_genireg(i64 reg,i64 size);
i64 cc_libmcl_getopndsize_u(struct cc_decls_unitrec * p);
i64 cc_libmcl_getopndsize_d(struct cc_decls_strec * d);
i64 cc_libmcl_getmclcond(i64 opc,i64 m);
byte * cc_libmcl_getfullname(struct cc_decls_strec * d);
i64 cc_libmcl_roundsizetg(i64 size);
i64 cc_libmcl_iscallbackfn(struct cc_decls_strec * p);
byte * cc_libmcl_getregname(i64 reg,i64 size);
byte * cc_libmcl_getblockname(i64 reg,i64 size);
byte * cc_libmcl_fgetregname(i64 reg,i64 size);
i64 cc_libmcl_issimple(struct cc_decls_unitrec * p);
static i64 cc_libmcl_issimple0(struct cc_decls_unitrec * p,i64 level);
i64 cc_libmcl_issimplepm(struct cc_decls_unitrec * p);
i64 cc_libmcl_getaregs(struct cc_libmcl_opndrec * ax);
i64 cc_libmcl_getlregs(struct cc_libmcl_opndrec * ax);
i64 cc_libmcl_isintconst(struct cc_decls_unitrec * p);
i64 cc_libmcl__getnextreg(struct cc_libmcl_opndrec * ax,i64 reg);
i64 cc_libmcl_getnextreg(struct cc_libmcl_opndrec * ax,i64 r);
i64 cc_libmcl_ispoweroftwo(i64 x);
static i64 cc_libmcl_sameoperand(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static struct cc_libmcl_mclrec * cc_libmcl_findlastmcl(void);
void cc_libmcl_genmsource(i64 lineno);
i64 cc_libmcl_roundto(i64 a,i64 n);
void cc_libmcl_pushstack(i64 n);
void cc_libmcl_pushstackfp(i64 n);
void cc_libmcl_popstack(i64 n);
i64 cc_libmcl_definelabel(void);
i64 cc_libmcl_createfwdlabel(void);
void cc_libmcl_definefwdlabel(i64 lab);
void cc_libmcl_genjumpl(i64 lab);
void cc_libmcl_setalign(i64 align);
i64 cc_libmcl_gettypecat(struct cc_decls_unitrec * a);
void cc_libmcl_doblockcall(i64 size);
struct cc_libmcl_opndrec * cc_libmcl_getblockreg(i64 size);
void cc_libmcl_copyretvalue(i64 size);
void cc_libmcl_enterproc(byte * name);
void cc_libmcl_leaveproc(byte * name);
void cc_blockmcl_do_stmt(struct cc_decls_unitrec * p);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_expr(struct cc_decls_unitrec * p,i64 reg,i64 am);
static void cc_blockmcl_loneexpr(struct cc_decls_unitrec * p);
static void cc_blockmcl_do_assign(struct cc_decls_unitrec * a,struct cc_decls_unitrec * b);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_assign(struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg);
static i64 cc_blockmcl_saveexpr(struct cc_decls_unitrec * a,i64 reg);
static i64 cc_blockmcl_fsaveexpr(struct cc_decls_unitrec * a,i64 reg);
static struct cc_libmcl_opndrec * cc_blockmcl_restoreexpr(i64 tx,i64 reg);
static struct cc_libmcl_opndrec * cc_blockmcl_frestoreexpr(i64 tx,i64 reg);
static struct cc_libmcl_opndrec * cc_blockmcl_getlvalueopnd(struct cc_decls_unitrec * a,i64 reg);
static void cc_blockmcl_storeopnd(struct cc_libmcl_opndrec * ax,struct cc_libmcl_opndrec * bx);
static void cc_blockmcl_pushexpr(struct cc_decls_unitrec * a,i64 reg);
static void cc_blockmcl_fpushexpr(struct cc_decls_unitrec * a,i64 reg);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_const(struct cc_decls_unitrec * p,i64 reg);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_constant(struct cc_decls_strec * d,i64 reg);
static void cc_blockmcl_do_labeldef(struct cc_decls_strec * d);
static void cc_blockmcl_do_goto(struct cc_decls_strec * d);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_add(struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_fadd(i64 opc,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg);
static struct cc_libmcl_opndrec * cc_blockmcl_loadexpr(struct cc_decls_unitrec * a,i64 reg,i64 isassign);
static struct cc_libmcl_opndrec * cc_blockmcl_evalexpr(struct cc_decls_unitrec * p,i64 reg);
static struct cc_libmcl_opndrec * cc_blockmcl_evaladdr(struct cc_decls_unitrec * p,i64 reg);
static struct cc_libmcl_opndrec * cc_blockmcl_evalptr(struct cc_decls_unitrec * p,i64 reg);
static struct cc_libmcl_opndrec * cc_blockmcl_floadexpr(struct cc_decls_unitrec * a,i64 xreg);
static struct cc_libmcl_opndrec * cc_blockmcl_fevalexpr(struct cc_decls_unitrec * p,i64 xreg);
static void cc_blockmcl_do_if(struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,struct cc_decls_unitrec * c);
static void cc_blockmcl_genjumpcond(i64 opc,struct cc_decls_unitrec * p,i64 lab,i64 reg);
static void cc_blockmcl_gcomparejump(i64 jumpopc,struct cc_decls_unitrec * p,struct cc_decls_unitrec * lhs,struct cc_decls_unitrec * rhs,i64 lab,i64 reg);
static i64 cc_blockmcl_reversecond(i64 op);
static void cc_blockmcl_do_preincr(struct cc_decls_unitrec * a,i64 addop,i64 incrop);
static i64 cc_blockmcl_reversemclcond(i64 cond);
static void cc_blockmcl_do_while(struct cc_decls_unitrec * pcond,struct cc_decls_unitrec * pbody);
static void cc_blockmcl_do_while1(struct cc_decls_unitrec * pbody);
static void cc_blockmcl_stacklooplabels(i64 a,i64 b);
static void cc_blockmcl_do_dowhile(struct cc_decls_unitrec * pbody,struct cc_decls_unitrec * pcond);
static void cc_blockmcl_do_for(struct cc_decls_unitrec * pinit,struct cc_decls_unitrec * pbody);
static i64 cc_blockmcl_pushffparams(struct cc_decls_unitrec * p,i64 variadic);
static void cc_blockmcl_pushoneparam(struct cc_decls_unitrec * q,i64 variadic);
static void cc_blockmcl_pushfloatparam(struct cc_decls_unitrec * q);
static void cc_blockmcl_loadfloatparam(struct cc_decls_unitrec * q,i64 regoffset,i64 iscomplex);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_call(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg);
static void cc_blockmcl_do_return(struct cc_decls_unitrec * a);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_sub(struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_mul(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_div(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_shl(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_iand(i64 opc,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_preincrx(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,i64 reg);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_postincrx(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,i64 reg);
static struct cc_libmcl_opndrec * cc_blockmcl_makeindexopnd(struct cc_decls_unitrec * a,struct cc_decls_unitrec * index,i64 scale,i64 size,i64 offset,i64 reg);
static void cc_blockmcl_mulreg(i64 reg,i64 x);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_ptr(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,i64 reg,i64 am);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_addptr(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg,i64 am);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_subptr(struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg,i64 am);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_convert(struct cc_decls_unitrec * a,i64 t,i64 opc,i64 reg);
static void cc_blockmcl_do_decl(struct cc_decls_strec * d);
static struct cc_libmcl_opndrec * cc_blockmcl_do_assignblock(struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 regx);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_widen(struct cc_decls_unitrec * a,i64 m,i64 reg);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_neg(struct cc_decls_unitrec * a,i64 reg);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_fneg(struct cc_decls_unitrec * a,i64 reg);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_inot(struct cc_decls_unitrec * a,i64 reg);
static void cc_blockmcl_do_switch(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_rem(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_ifx(struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,struct cc_decls_unitrec * c,i64 reg);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_addto(i64 opc,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 regx);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_faddto(i64 opc,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 regx);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_eq(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg);
static void cc_blockmcl_do_exprlist(struct cc_decls_unitrec * a);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_exprlist(struct cc_decls_unitrec * a,i64 reg);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_shlto(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 regx);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_multo(struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 regx);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_notl(struct cc_decls_unitrec * a,i64 reg);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_istruel(struct cc_decls_unitrec * a,i64 reg);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_andorl(struct cc_decls_unitrec * p,i64 reg);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_sqrt(struct cc_decls_unitrec * a,i64 reg);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_scale(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_divto(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 regx);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_name(struct cc_decls_unitrec * p,i64 reg,i64 am);
static void cc_blockmcl_divreg(i64 reg,i64 x);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_addrof(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,i64 reg,i64 am);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_dot(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg,i64 am);
static void cc_blockmcl_loadviaptr(struct cc_libmcl_opndrec * w,struct cc_libmcl_opndrec * ptropnd,i64 sgned);
i64 cc_genasm_codegen_writeasm(i64 moduleno,byte * outfile);
void cc_genasm_inita64(void);
void cc_genasm_terma64(void);
static void cc_genasm_writetoasm(struct cc_libmcl_mclrec * m);
void cc_genasm_mcltoa64(struct cc_libmcl_mclrec * m);
static void cc_genasm_passthru(i64 opc);
static void cc_genasm_convmcl(void);
static void cc_genasm_do_changeop(i64 opc);
static void cc_genasm_do_comment(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_blank(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_end(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_label(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_labelname(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_mov(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_push(struct cc_libmcl_opndrec * a);
static void cc_genasm_do_pop(struct cc_libmcl_opndrec * a);
static void cc_genasm_do_lea(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_cmovcc(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b,i64 cond);
static void cc_genasm_do_fmov(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_iwiden(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_uwiden(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_inarrow(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_unarrow(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_call(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_ret(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_retn(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_jmp(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_jmpcc(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b,i64 cond);
static void cc_genasm_do_exch(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_add(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_sub(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_imul(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_idiv(struct cc_libmcl_opndrec * a);
static void cc_genasm_do_irem(struct cc_libmcl_opndrec * a);
static void cc_genasm_do_urem(struct cc_libmcl_opndrec * a);
static void cc_genasm_do_and(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_or(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_xor(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_test(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_cmp(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_shl(i64 opc,struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_neg(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_not(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_inc(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_dec(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_setcc(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b,i64 cond);
static void cc_genasm_do_fneg(struct cc_libmcl_opndrec * a);
static void cc_genasm_do_fabs(struct cc_libmcl_opndrec * a);
static void cc_genasm_do_fsqrt(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_ufix(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_ifix(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_ufloat(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_ifloat(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_db(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_dw(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_dd(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_dq(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_align(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_segment(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_assem(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_strmclasm(struct cc_libmcl_mclrec * mcl);
void cc_genasm_stropndx(struct cc_libmcl_opndrec * a,i64 sizeprefix,i64 debug);
static void cc_genasm_strmclx(struct cc_libmcl_mclrec * mcl);
static byte * cc_genasm_fgetregnamex(i64 reg);
byte * cc_genasm_getstringname(i64 n);
byte * cc_genasm_getwstringname(i64 n);
byte * cc_genasm_getrealname(i64 n);
byte * cc_genasm_getsrealname(i64 n);
byte * cc_genasm_getdintname(i64 n);
i64 cc_genasm_getstringindex(byte * s,i64 length);
i64 cc_genasm_getwstringindex(u16 * s,i64 length);
static i64 cc_genasm_getrealindex(double x);
static i64 cc_genasm_getdintindex(i64 x);
static void cc_genasm_strvaluex(struct cc_libmcl_opndrec * a);
static void cc_genasm_convertimm(struct cc_libmcl_opndrec * a,i64 sx);
static void cc_genasm_genstringtable(void);
static void cc_genasm_genwstringtable(void);
static void cc_genasm_do_defstr(byte * s,i64 length);
static void cc_genasm_do_defwstr(u16 * s,i64 length);
static void cc_genasm_genrealtable(void);
static void cc_genasm_gendinttable(void);
static void cc_genasm_writefabs(void);
static void cc_genasm_domclseq(struct cc_libmcl_mclrec * m);
static void cc_genasm_asmstr(byte * s);
static void cc_genasm_asmstrln(byte * s);
static void cc_genasm_asmline(void);
static void cc_genasm_asmln(void);
static void cc_genasm_asmint(i64 a);
static void cc_genasm_asmchar(i64 c);
static void cc_genasm_asmterm(void);
static void cc_genasm_initasmline(void);
static byte * cc_genasm_getregnamex(i64 reg,i64 size);
static void cc_genasm_genstring(byte * s,i64 length);
static void cc_genasm_genwstring(u16 * s,i64 length);
static void cc_genasm_extendrealtable(void);
static void cc_genasm_extenddinttable(void);
static void cc_genasm_extendstringtable(void);
void cc_export_writemheader(byte * infile);
static void cc_export_showmacroseq(struct cc_decls_tokenrec * tk);
static void cc_export_mmstr(byte * s);
static void cc_export_mmleftstr(byte * s,i64 n);
static void cc_export_mmstrln(byte * s);
static void cc_export_mmint(i64 a);
static void cc_export_mmline(void);
static void cc_export_writefunction(struct cc_decls_strec * d);
static void cc_export_mmmode(i64 m,i64 expand);
static void cc_export_writerecord(i64 m,i64 rectype,i64 level);
static void cc_export_writefnptr(i64 m);
static byte * cc_export_fixname(byte * name);
i64 cc_assembler_assembler(byte * outputfile,byte * (*asmfiles)[],byte * (*dllfiles)[],i64 nasmfiles,i64 ndllfiles,i64 fobj,i64 fcaption,byte * (*assemsources)[],byte * entrypointname);
static void cc_assembler_loadsourcefiles(byte * (*assemsources)[]);
static void cc_assembler_parsemodules(void);
static void cc_assembler_fixopnd(struct ax_decls_opndrec * a);
static void cc_assembler_initall(void);
static void cc_assembler_loaderror(byte * mess);
static void cc_assembler_loaderror_s(byte * mess,byte * s);
static void cc_assembler_addmodule(byte * name);
static void cc_assembler_addsearchlib(byte * name);
static struct ax_decls_strec * cc_assembler_getemptyst(struct ax_decls_strec * d);
static struct ax_decls_strec * cc_assembler_findduplname(struct ax_decls_strec * d);
static void cc_assembler_adddupl(struct ax_decls_strec * d);
static void cc_assembler_scanglobals(void);
static void cc_assembler_resethashtable(void);
void ax_lex_lex(void);
void ax_lex_initlex(void);
static void ax_lex_readreal(byte (*s)[],i64 slen,i64 intlen,i64 exponseen);
static void ax_lex_readnumber(i64 c);
static void ax_lex_readbinary(void);
static void ax_lex_readhex(void);
void ax_lex_ps(byte * caption);
void ax_lex_printsymbol(void * dev);
static void ax_lex_clearhashtable(void);
static void ax_lex_inithashtable(void);
static void ax_lex_addreservedword(byte * name,i64 symbol,i64 subcode);
void ax_lex_printhashtable(void * devx,byte * caption);
static i64 ax_lex_lookuplex(byte * name,i64 length);
void ax_lex_initsourcefile(byte * source);
struct ax_decls_strec * ax_lex_addnamestr(byte * name);
void ax_lex_lxerror(byte * m);
i64 ax_lex_gethashvalue(byte * s);
void ax_lex_skiptoeol(void);
static byte * ax_lex_makestring(byte * p,i64 length);
void ax_parse_readmodule(i64 moduleno);
void ax_parse_checkundefined(void);
static void ax_parse_checksymbol(i64 symbol);
static void ax_parse_readinstr(void);
static void ax_parse_readcondinstr(i64 opc);
static struct ax_decls_opndrec * ax_parse_readoperand(void);
static struct ax_decls_opndrec * ax_parse_readexpression(void);
static void ax_parse_readterm(void);
static void ax_parse_readreg(i64 * reg,i64 * regsize,i64 * scale);
static struct ax_decls_opndrec * ax_parse_readaddrmode(i64 size);
void ax_lib_initlib(void);
void ax_lib_genmc(i64 opcode,struct ax_decls_opndrec * a,struct ax_decls_opndrec * b);
void ax_lib_genmcstr(i64 opcode,byte * s);
static struct ax_decls_opndrec * ax_lib_newopnd(i64 mode);
struct ax_decls_opndrec * ax_lib_genxreg(i64 xreg);
struct ax_decls_opndrec * ax_lib_genindex(i64 areg,i64 ireg,i64 scale,struct ax_decls_opndrec * x,i64 size,i64 addrsize);
struct mlib_strbuffer * ax_lib_writemclblock(void);
void ax_lib_gencomment(byte * s);
struct ax_decls_opndrec * ax_lib_genstrimm(byte * s);
static byte * ax_lib_getsizetag(i64 size);
static void ax_lib_writemcl(i64 index,struct ax_lib_mclrec * mcl);
byte * ax_lib_strmcl(struct ax_lib_mclrec * mcl);
byte * ax_lib_stropnd(struct ax_decls_opndrec * a,i64 sizeprefix);
static byte * ax_lib_strdef(struct ax_decls_strec * def);
void ax_lib_setsegment(i64 seg);
static byte * ax_lib_getsizeprefix(i64 size,i64 enable);
static i64 ax_lib_needsizeprefix(i64 opcode,struct ax_decls_opndrec * a,struct ax_decls_opndrec * b);
struct ax_decls_opndrec * ax_lib_genimm_expr(struct ax_decls_strec * d,i64 value,i64 t,i64 size);
struct ax_decls_opndrec * ax_lib_genint(i64 x,i64 size);
struct ax_decls_opndrec * ax_lib_genlab(struct ax_decls_strec * d,i64 size);
struct ax_decls_opndrec * ax_lib_genmem(struct ax_decls_strec * d,i64 size);
struct ax_decls_opndrec * ax_lib_genreg0(i64 reg,i64 size);
byte * ax_lib_getfullname(struct ax_decls_strec * d);
byte * ax_lib_getregname(i64 reg,i64 size);
byte * ax_lib_xgetregname(i64 reg);
void ax_lib_printst(void * f);
void ax_lib_printstrec(void * f,struct ax_decls_strec * d);
void ax_lib_adddef(struct ax_decls_strec * d);
void ax_lib_addimport(struct ax_decls_strec * d);
void ax_lib_createlabel(struct ax_decls_strec * symptr,i64 symbol);
void ax_lib_createnamedconst(struct ax_decls_strec * symptr,struct ax_decls_opndrec * expr);
void ax_lib_createregalias(struct ax_decls_strec * symptr,i64 regindex,i64 regsize);
void ax_lib_createxregalias(struct ax_decls_strec * symptr,i64 regindex);
void ax_lib_gerror(byte * mess);
void ax_lib_serror(byte * mess);
void ax_lib_serror_s(byte * mess,byte * param);
static byte * ax_lib_inttostr(i64 a);
static byte * ax_lib_realtostr(double a);
struct ax_decls_dbuffer * ax_lib_buffercreate(i64 size);
static void ax_lib_bufferexpand(struct ax_decls_dbuffer * a);
void ax_lib_buffercheck(struct ax_decls_dbuffer * a,i64 n);
i64 ax_lib_bufferlength(struct ax_decls_dbuffer * a);
void * ax_lib_bufferelemptr(struct ax_decls_dbuffer * a,i64 offset);
void ax_lib_addbyte(struct ax_decls_dbuffer * a,i64 x);
void ax_lib_addword(struct ax_decls_dbuffer * a,i64 x);
void ax_lib_adddword(struct ax_decls_dbuffer * a,i64 x);
void ax_lib_addqword(struct ax_decls_dbuffer * a,i64 x);
void ax_lib_printmodulesymbols(void * f);
void ax_lib_printimportsymbols(void * f);
void ax_lib_printdupltable(void * f);
void ax_genss_genss(void);
static void ax_genss_doinstr(struct ax_lib_mclrec * m,i64 index);
static void ax_genss_genbyte(i64 x);
static void ax_genss_genword(i64 x);
static void ax_genss_gendword(i64 x);
static void ax_genss_genqword(i64 x);
static void ax_genss_genopnd(struct ax_decls_opndrec * a,i64 size);
static void ax_genss_addrelocitem(i64 reloctype,struct ax_decls_strec * d);
static i64 ax_genss_getstindex(struct ax_decls_strec * d);
static void ax_genss_genrel32(struct ax_decls_opndrec * a);
static void ax_genss_genabs32(struct ax_decls_opndrec * a);
static void ax_genss_genabs64(struct ax_decls_opndrec * a);
static i64 ax_genss_getrel32(struct ax_decls_strec * d,i64 offset);
static void ax_genss_dofwdrefs(struct ax_decls_strec * d);
static void ax_genss_genrex(void);
static i64 ax_genss_isbytesized(i64 x);
static i64 ax_genss_isdwordsized(i64 x);
static void ax_genss_do_push(struct ax_decls_opndrec * a);
static void ax_genss_do_pop(struct ax_decls_opndrec * a);
static void ax_genss_do_inc(struct ax_decls_opndrec * a,i64 code);
static void ax_genss_do_neg(struct ax_decls_opndrec * a,i64 code);
static void ax_genss_genamode(struct ax_decls_opndrec * a,i64 am);
static i64 ax_genss_makemodrm(i64 mode,i64 opc,i64 rm);
static void ax_genss_setopsize(struct ax_decls_opndrec * a);
static void ax_genss_setaddrsize(struct ax_decls_opndrec * a);
static i64 ax_genss_getdispsize(struct ax_decls_opndrec * a,i64 mand);
static i64 ax_genss_genrm(struct ax_decls_opndrec * a,i64 opc);
static void ax_genss_genrmbyte(i64 mode,i64 opc,i64 rm);
static i64 ax_genss_makeam(i64 m,i64 s,i64 d);
static void ax_genss_do_arith(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b,i64 code);
static void ax_genss_do_mov(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b);
static i64 ax_genss_getregcoder(i64 reg);
static i64 ax_genss_getregcodeb(i64 reg);
static i64 ax_genss_getregcodebx(i64 reg);
static i64 ax_genss_getregcoderx(i64 reg);
static void ax_genss_do_lea(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b);
static void ax_genss_do_movsx(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b,i64 opc);
static void ax_genss_checkhighreg(struct ax_decls_opndrec * a);
static void ax_genss_do_exch(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b);
static void ax_genss_do_movsxd(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b);
static void ax_genss_do_imul2(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b);
static void ax_genss_do_imul3(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b,struct ax_decls_opndrec * c);
static void ax_genss_do_shift(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b,i64 opc);
static void ax_genss_do_test(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b);
static void ax_genss_do_loop(struct ax_decls_opndrec * a,i64 opc);
static void ax_genss_do_jcxz(struct ax_decls_opndrec * a,i64 opsize);
static void ax_genss_do_setcc(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b);
static void ax_genss_do_movxmm(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b,i64 size);
static void ax_genss_do_arithxmm(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b,i64 prefix,i64 opc);
static void ax_genss_do_logicxmm(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b,i64 opc,i64 size);
static void ax_genss_do_convertfloat(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b,i64 prefix);
static void ax_genss_do_fix(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b,i64 prefix,i64 opc);
static void ax_genss_do_float(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b,i64 prefix);
static void ax_genss_do_call(struct ax_decls_opndrec * a);
static void ax_genss_do_jmp(struct ax_decls_opndrec * a,struct ax_lib_mclrec * m);
static i64 ax_genss_getcurrdatalen(i64 id);
static void ax_genss_do_cmovcc(struct ax_decls_opndrec * c,struct ax_decls_opndrec * a,struct ax_decls_opndrec * b);
static void ax_genss_do_fmem(struct ax_decls_opndrec * a,i64 freal,i64 code);
static i64 ax_genss_getr32bits(double x);
static void ax_genss_genrel8(struct ax_decls_opndrec * a);
static i64 ax_genss_checkshortjump(struct ax_lib_mclrec * m,struct ax_decls_strec * d);
static struct ax_decls_fwdrec * ax_genss_addfwdref(struct ax_decls_fwdrec * p,i64 offset,i64 reltype,i64 seg);
static void ax_genss_switchseg(i64 newseg);
static void ax_genss_do_movdqx(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b,i64 opc);
static void ax_genss_do_popcnt(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b);
static void ax_genss_do_bsf(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b,i64 opc);
static void ax_genss_extendsymboltable(void);
static void ax_genss_do_pcmpistri(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b,i64 c,i64 opc);
void ax_writeexe_writeexe(byte * outfile,i64 dodll);
void ax_writeexe_genexe(byte * entrypoint,byte * outfile,i64 dodll);
static void ax_writeexe_loadlibs(void);
void ax_writeexe_initsectiontable(void);
static i64 ax_writeexe_roundtoblock(i64 n,i64 align);
static byte * ax_writeexe_extractlibname(byte * name,i64 * libno,i64 moduleno);
static void ax_writeexe_scanst(void);
static void ax_writeexe_relocdata(struct ax_objdecls_sectionrec * s);
static void ax_writeexe_getbaserelocs(struct ax_objdecls_sectionrec * s);
static void ax_writeexe_writerecordx(void * r,i64 length);
static void ax_writeexe_writedosstub(void);
static void ax_writeexe_writepesig(void);
static void ax_writeexe_writepadding(i64 offset);
static void ax_writeexe_writefileheader(void);
static void ax_writeexe_writeoptheader(void);
static void ax_writeexe_writesectionheader(struct ax_objdecls_sectionrec * s);
static void ax_writeexe_writesectiondata(struct ax_objdecls_sectionrec * s);
static void ax_writeexe_getoffsets(void);
static i64 ax_writeexe_getsectionno(i64 segment);
static void ax_writeexe_writeexporttable(byte * pstart);
static i64 ax_writeexe_getexporttablesize(void);
static void ax_writeexe_newbasereloc(i64 addr,i64 reltype);
static void ax_writeexe_scanbaserelocs(void);
static void ax_writeexe_writebasereloctable(byte * pstart);
static void ax_writeexe_sortexports(i64 (*sortindex)[]);
byte * ax_disasm_decodeinstr(byte * * cptr,byte * baseaddr);
static void ax_disasm_decodetwobyteinstr(void);
static void ax_disasm_decodeaddr(i64 w);
static i64 ax_disasm_readbyte(void);
static i64 ax_disasm_readsbyte(void);
static u64 ax_disasm_readword16(void);
static i64 ax_disasm_readint16(void);
static u64 ax_disasm_readword32(void);
static i64 ax_disasm_readint32(void);
static i64 ax_disasm_readint64(void);
static i64 ax_disasm_getreg(i64 regcode,i64 upper);
byte * ax_disasm_strreg(i64 reg,i64 opsize);
static byte * ax_disasm_strfreg(i64 freg);
static void ax_disasm_printaddrmode(i64 xmm);
static void ax_disasm_genstr(byte * s);
static void ax_disasm_genintd(i64 a);
static void ax_disasm_genhex(i64 a);
static i64 ax_disasm_readimm(void);
static i64 ax_disasm_readimm8(void);
static byte * ax_disasm_strxmm(i64 reg);
static byte * ax_disasm_strmmx(i64 reg);
static void ax_disasm_decode8087(i64 ttt);
static void ax_disasm_do87arith(byte * opcstr,i64 ttt,i64 freg);
static void ax_disasm_do87mem(byte * opcstr,i64 mf);
static void ax_disasm_getsil(i64 * reg);
static void ax_disasm_getsilx(i64 * reg);
void ax_writeobj_writess(byte * outfile);
static void ax_writeobj_writerecord(void * r,i64 length);
static void ax_writeobj_writerelocs(struct ax_decls_relocrec * r,i64 nrelocs);
static void ax_writeobj_writedata(struct ax_decls_dbuffer * data);
static void ax_writeobj_writesymboltable(void);
static void ax_writeobj_writestringtable(void);
static struct ax_objdecls_imagesymbol * ax_writeobj_makesymbol(byte * name,i64 namelen,i64 value,i64 sectionno,i64 symtype,i64 storage,i64 naux);
static void ax_writeobj_addsymbol(struct ax_objdecls_imagesymbol * r);
static void ax_writeobj_initsymboltable(byte * filename);
static struct ax_objdecls_imagesymbol * ax_writeobj_strtoaux(byte * s);
static struct ax_objdecls_auxsectionrec * ax_writeobj_sectiontoaux(struct ax_decls_dbuffer * data,i64 nrelocs);
static i64 ax_writeobj_addstringentry(byte * s,i64 length);
static void ax_writeobj_convertsymboltable(void);
static void ax_writeobj_writecoff(byte * outfile);

/* VARS */
static byte *  cc_modenames[4] = {(byte*)"preprocess_mode",(byte*)"compile_mode",(byte*)"link_mode",(byte*)"run_mode"};
static i64 cc_cc_mode;
static byte *  cc_linkoption;
static byte *  cc_destfilename;
static byte *  cc_destfileext;
static byte cc_fdebugcompiler;
static byte cc_fshowpaths;
static byte cc_fshowheaders;
static byte cc_fwriteheaders;
static byte cc_fgetlib;
static byte cc_fshowinfo;
static byte cc_fstdin;
static byte cc_fstdout;
static byte cc_fmheaders;
static byte cc_fshowlog;
static byte cc_fatfile;
static byte cc_fshowtiming;
static byte cc_fbcclib;
static byte *  cc_entrypointname;
static byte *  cc_optionnames[32] = {
    (byte*)"e",
    (byte*)"c",
    (byte*)"s",
    (byte*)"obj",
    (byte*)"exe",
    (byte*)"run",
    (byte*)"paths",
    (byte*)"headers",
    (byte*)"stdin",
    (byte*)"stdout",
    (byte*)"i",
    (byte*)"includes",
    (byte*)"time",
    (byte*)"v",
    (byte*)"v2",
    (byte*)"q",
    (byte*)"h",
    (byte*)"help",
    (byte*)"info",
    (byte*)"ext",
    (byte*)"writeheaders",
    (byte*)"old",
    (byte*)"getlib",
    (byte*)"mheaders",
    (byte*)"auto",
    (byte*)"out",
    (byte*)"at",
    (byte*)"debug",
    (byte*)"bcclib",
    (byte*)"callback",
    (byte*)"entry",
    (byte*)"splicing"
};
static i64 cc_totallines = (i64)0;
static i64 cc_nstringobjects = (i64)0;
static byte *  cc_extraparams[128];
static byte *  cc_extravalues[128];
static i64 cc_nextraparams = (i64)0;
i64 cc_progstart;
i64 cc_progend;
static void *  msysnewc__fnaddresses[]= {
    &start,
    &cc_compilemodules,
    &cc_debugcompile,
    &cc_do_loadmodule,
    &cc_do_preprocess,
    &cc_do_parsemodule,
    &cc_do_genmcl,
    &cc_do_genasm,
    &cc_do_runprog,
    &cc_loadmainmodule,
    &cc_addmodule,
    &cc_initlogfile,
    &cc_closelogfile,
    &cc_initdata,
    &cc_initsearchdirs,
    &cc_showsearchdirs,
    &cc_showast,
    &cc_showstflat,
    &cc_showsttree,
    &cc_showmcl,
    &cc_showasm,
    &cc_showfiles,
    &cc_starttiming,
    &cc_showtiming,
    &cc_getinputoptions,
    &cc_do_option,
    &cc_showincludepaths,
    &cc_showhelp,
    &cc_showextrainfo,
    &cc_showcaption,
    &cc_do_genlink,
    &cc_resetcompiler,
    &cc_addnewmodules,
    &cc_writeatfile,
    &msysnewc_m_getdotindex,
    &msysnewc_m_setdotindex,
    &msysnewc_m_getdotslice,
    &msysnewc_m_setdotslice,
    &msysnewc_m_get_nprocs,
    &msysnewc_m_get_nexports,
    &msysnewc_m_get_procname,
    &msysnewc_m_get_procaddr,
    &msysnewc_m_get_procexport,
    &msysnewc_pushio,
    &msysnewc_m_print_startfile,
    &msysnewc_m_print_startstr,
    &msysnewc_m_print_startptr,
    &msysnewc_m_print_startcon,
    &msysnewc_m_print_setfmt,
    &msysnewc_m_print_end,
    &msysnewc_m_print_ptr,
    &msysnewc_m_print_i64,
    &msysnewc_m_print_u64,
    &msysnewc_m_print_r64,
    &msysnewc_m_print_r32,
    &msysnewc_m_print_c8,
    &msysnewc_m_print_str,
    &msysnewc_m_print_newline,
    &msysnewc_m_print_nogap,
    &msysnewc_printstr,
    &msysnewc_printstr_n,
    &msysnewc_printstrn_app,
    &msysnewc_makezstring,
    &msysnewc_freezstring,
    &msysnewc_printchar,
    &msysnewc_nextfmtchars,
    &msysnewc_strtofmt,
    &msysnewc_domultichar,
    &msysnewc_expandstr,
    &msysnewc_xdivrem,
    &msysnewc_u64tostr,
    &msysnewc_i64tostrfmt,
    &msysnewc_u64tostrfmt,
    &msysnewc_i64mintostr,
    &msysnewc_strtostrfmt,
    &msysnewc_tostr_i64,
    &msysnewc_tostr_u64,
    &msysnewc_tostr_r64,
    &msysnewc_tostr_str,
    &msysnewc_getfmt,
    &msysnewc_strint,
    &msysnewc_getstrint,
    &msysnewc_strword,
    &msysnewc_strreal,
    &msysnewc_getstr,
    &msysnewc_initreadbuffer,
    &msysnewc_m_read_conline,
    &msysnewc_m_read_fileline,
    &msysnewc_m_read_strline,
    &msysnewc_readitem,
    &msysnewc_strtoint,
    &msysnewc_m_read_i64,
    &msysnewc_m_read_r64,
    &msysnewc_m_read_str,
    &msysnewc_readstr,
    &msysnewc_rereadln,
    &msysnewc_reread,
    &msysnewc_valint,
    &msysnewc_valreal,
    &msysnewc_iconvlcn,
    &msysnewc_iconvucn,
    &msysnewc_convlcstring,
    &msysnewc_convucstring,
    &msysnewc_m_power_i64,
    &msysnewc_m_intoverflow,
    &msysnewc_m_dotindex,
    &msysnewc_m_dotslice,
    &msysnewc_m_popdotindex,
    &msysnewc_m_popdotslice,
    &msysnewc_m_imin,
    &msysnewc_m_imax,
    &msysnewc_m_sign,
    &mlib_pcm_alloc,
    &mlib_pcm_freestr,
    &mlib_pcm_free,
    &mlib_pcm_freeac,
    &mlib_pcm_copymem4,
    &mlib_pcm_clearmem,
    &mlib_pcm_init,
    &mlib_pcm_getac,
    &mlib_pcm_newblock,
    &mlib_pcm_round,
    &mlib_pcm_array,
    &mlib_pcm_printfreelist,
    &mlib_pcm_diags,
    &mlib_pcm_allocz,
    &mlib_pcm_copyheapstring,
    &mlib_pcm_copyheapstringn,
    &mlib_pcm_copyheapblock,
    &mlib_addtomemalloc,
    &mlib_removefrommemalloc,
    &mlib_allocmem,
    &mlib_reallocmem,
    &mlib_abortprogram,
    &mlib_getfilesize,
    &mlib_readrandom,
    &mlib_writerandom,
    &mlib_setfilepos,
    &mlib_getfilepos,
    &mlib_readfile,
    &mlib_writefile,
    &mlib_checkfile,
    &mlib_readlinen,
    &mlib_iconvlcn,
    &mlib_iconvucn,
    &mlib_convlcstring,
    &mlib_convucstring,
    &mlib_changeext,
    &mlib_extractext,
    &mlib_extractpath,
    &mlib_extractfile,
    &mlib_extractbasefile,
    &mlib_addext,
    &mlib_alloctable,
    &mlib_zalloctable,
    &mlib_checkfreelists,
    &mlib_pcm_alloc32,
    &mlib_pcm_free32,
    &mlib_outbyte,
    &mlib_outword16,
    &mlib_outword,
    &mlib_outword64,
    &mlib_myeof,
    &mlib_pcm_smallallocz,
    &mlib_pcm_smallalloc,
    &mlib_strbuffer_add,
    &mlib_gs_init,
    &mlib_gs_free,
    &mlib_gs_str,
    &mlib_gs_char,
    &mlib_gs_strn,
    &mlib_gs_strvar,
    &mlib_gs_strint,
    &mlib_gs_strln,
    &mlib_gs_strsp,
    &mlib_gs_line,
    &mlib_gs_getcol,
    &mlib_gs_leftstr,
    &mlib_gs_leftint,
    &mlib_gs_padto,
    &mlib_gs_println,
    &mlib_nextcmdparam,
    &mlib_readnextfileitem,
    &mlib_ipadstr,
    &mlib_padstr,
    &mlib_chr,
    &mlib_cmpstring,
    &mlib_cmpstringn,
    &mlib_eqstring,
    &mlib_cmpbytes,
    &mlib_eqbytes,
    &mlib_mseed,
    &mlib_mrandom,
    &mlib_mrandomp,
    &mlib_mrandomint,
    &mlib_mrandomrange,
    &mlib_mrandomreal,
    &mlib_mrandomreal1,
    &mlib_checkpackfile,
    &osnos_os_init,
    &osnos_os_execwait,
    &osnos_os_execcmd,
    &osnos_os_getch,
    &osnos_os_kbhit,
    &osnos_os_flushkeys,
    &osnos_os_getconsolein,
    &osnos_os_getconsoleout,
    &osnos_os_proginstance,
    &osnos_os_getdllinst,
    &osnos_os_getdllprocaddr,
    &osnos_os_initwindows,
    &osnos_os_getchx,
    &osnos_os_getos,
    &osnos_os_getoscode,
    &osnos_os_iswindows,
    &osnos_os_shellexec,
    &osnos_os_sleep,
    &osnos_os_getstdin,
    &osnos_os_getstdout,
    &osnos_os_gethostname,
    &osnos_os_gethostsize,
    &osnos_os_getmpath,
    &osnos_os_exitprocess,
    &osnos_os_gettimestamp,
    &osnos_os_gettickcount,
    &osnos_os_clock,
    &osnos_os_getclockspersec,
    &osnos_os_setmesshandler,
    &osnos_os_filelastwritetime,
    &osnos_os_hpcounter,
    &osnos_os_hpfrequency,
    &osnos_os_getsystime,
    &osnos_os_peek,
    &cc_support_stopcompiler,
    &cc_support_mcerror,
    &cc_support_serror,
    &cc_support_serror_gen,
    &cc_support_serror_ss,
    &cc_support_serror_s,
    &cc_support_terror_gen,
    &cc_support_terror,
    &cc_support_terror_s,
    &cc_support_terror_ss,
    &cc_support_gerror_gen,
    &cc_support_gerror,
    &cc_support_gerror_s,
    &cc_support_nxerror,
    &cc_support_testelem,
    &cc_support_setelem,
    &cc_support_nextpoweroftwo,
    &cc_support_loaderror,
    &cc_support_loadfromstdin,
    &cc_support_loadsourcefile,
    &cc_support_splicelines,
    &cc_support_loadbuiltin,
    &cc_support_gs_copytostr,
    &cc_support_gs_additem,
    &cc_support_isalphanum,
    &cc_support_showmacrolineno,
    &cc_lex_lex_preprocess_only,
    &cc_lex_lexreadtoken,
    &cc_lex_readrealnumber,
    &cc_lex_readexponent,
    &cc_lex_lxerror,
    &cc_lex_printsymbol,
    &cc_lex_lexsetup,
    &cc_lex_printstrn,
    &cc_lex_scannumber,
    &cc_lex_lookup,
    &cc_lex_gethashvalue,
    &cc_lex_inithashtable,
    &cc_lex_fillhashtable,
    &cc_lex_dolexdirective,
    &cc_lex_getlexdirective,
    &cc_lex_startlex,
    &cc_lex_endlex,
    &cc_lex_ps,
    &cc_lex_psnext,
    &cc_lex_gethashtablesize,
    &cc_lex_readlinecomment,
    &cc_lex_readblockcomment,
    &cc_lex_readhex,
    &cc_lex_readbinary,
    &cc_lex_readoctal,
    &cc_lex_readdecimal,
    &cc_lex_checknumbersuffix,
    &cc_lex_stacksourcefile,
    &cc_lex_unstacksourcefile,
    &cc_lex_getsourcefile,
    &cc_lex_lex,
    &cc_lex_shownumberstr,
    &cc_lex_addnamestr,
    &cc_lex_lxreadstring,
    &cc_lex_addlisttoken,
    &cc_lex_addlisttoken_copy,
    &cc_lex_addlist_nextlx,
    &cc_lex_addlisttoken_seq,
    &cc_lex_addlistmparam,
    &cc_lex_dodefine,
    &cc_lex_readalphanumeric,
    &cc_lex_inmacrostack,
    &cc_lex_showtokens,
    &cc_lex_lexa,
    &cc_lex_lexm,
    &cc_lex_peeklb,
    &cc_lex_peektk,
    &cc_lex_expandobjmacro,
    &cc_lex_expandfnmacro,
    &cc_lex_scantokenseq,
    &cc_lex_readmacrocall,
    &cc_lex_substituteargs,
    &cc_lex_strtoken,
    &cc_lex_strstring,
    &cc_lex_emittoken,
    &cc_lex_showtoken,
    &cc_lex_stringify,
    &cc_lex_pastetokens,
    &cc_lex_getifexpr,
    &cc_lex_evalcondexpr,
    &cc_lex_evalorexpr,
    &cc_lex_evalandexpr,
    &cc_lex_evaliorexpr,
    &cc_lex_evalixorexpr,
    &cc_lex_evaliandexpr,
    &cc_lex_evaleqexpr,
    &cc_lex_evalcmpexpr,
    &cc_lex_evalshiftexpr,
    &cc_lex_evaladdexpr,
    &cc_lex_evalmulexpr,
    &cc_lex_evalunaryexpr,
    &cc_lex_evalterm,
    &cc_lex_getifdef,
    &cc_lex_skipcode,
    &cc_lex_freetokens,
    &cc_lex_fastreadtoken,
    &cc_lex_alloctoken,
    &cc_lex_alloctokenz,
    &cc_lex_expandpredefmacro,
    &cc_lex_dopragmadir,
    &cc_lex_needspace,
    &cc_lex_dospecialinclude,
    &cc_lex_addautomodule,
    &cc_lex_setnumberoffset,
    &cc_lex_setfileno,
    &cc_lex_setfilenox,
    &cc_lex_getfileno,
    &cc_lex_getfilenox,
    &cc_lex_getnumberoffsetx,
    &cc_lex_freehashtable,
    &cc_lex_freestentry,
    &cc_lex_regenlookup,
    &cc_lex_printhashtable,
    &cc_lex_newhashtable,
    &cc_lex_old_readrealnumber,
    &cc_headers_findheader,
    &cc_headers_writeheaders,
    &cc_headers_checkbcclib,
    &cc_headers_getbcclib,
    &cc_headers_isheaderfile,
    &cc_lib_newstrec,
    &cc_lib_initcclib,
    &cc_lib_printst,
    &cc_lib_printstrec,
    &cc_lib_printstflat,
    &cc_lib_createname,
    &cc_lib_createunit0,
    &cc_lib_createunit1,
    &cc_lib_createunit2,
    &cc_lib_createunit3,
    &cc_lib_createconstunit,
    &cc_lib_createstringconstunit,
    &cc_lib_createwstringconstunit,
    &cc_lib_getoptocode,
    &cc_lib_getconstvalue,
    &cc_lib_nextautotype,
    &cc_lib_createconstmode,
    &cc_lib_createrefmode,
    &cc_lib_createprocmode,
    &cc_lib_createarraymode,
    &cc_lib_createenummode,
    &cc_lib_createstructmode,
    &cc_lib_setnameptr,
    &cc_lib_printcode_all,
    &cc_lib_printcode,
    &cc_lib_printunit,
    &cc_lib_printunitlist,
    &cc_lib_getprefix,
    &cc_lib_getdottedname,
    &cc_lib_getlineinfok,
    &cc_lib_getautofieldname,
    &cc_lib_convertstring,
    &cc_lib_strexpr,
    &cc_lib_jeval,
    &cc_lib_getopcjname,
    &cc_lib_strmode,
    &cc_lib_strmode2,
    &cc_lib_istrmode,
    &cc_lib_countunits,
    &cc_lib_purgesymbol,
    &cc_lib_purgesymbollist,
    &cc_lib_purgeprocs,
    &cc_lib_purgeproc,
    &cc_lib_printmodelist,
    &cc_lib_typename,
    &cc_lib_allocunitrec,
    &cc_lib_copymode,
    &cc_lib_createnewmode,
    &cc_lib_addlistunit,
    &cc_lib_addlistdef,
    &cc_lib_addlistparam,
    &cc_lib_checksymbol,
    &cc_lib_skipsymbol,
    &cc_lib_inittypetables,
    &cc_lib_createdupldef,
    &cc_lib_createnewmoduledef,
    &cc_lib_createnewproc,
    &cc_lib_resolvename,
    &cc_lib_resolvelabel,
    &cc_lib_checkdupl,
    &cc_lib_checkdupl_inproc,
    &cc_lib_getalignment,
    &cc_lib_isexported,
    &cc_lib_isimported,
    &cc_lib_isstructunion,
    &cc_lib_getstname,
    &cc_lib_isrealcc,
    &cc_lib_isintcc,
    &cc_parse_readmodule,
    &cc_parse_parsemodule,
    &cc_parse_readdeclspec,
    &cc_parse_istypestarter,
    &cc_parse_readexpression,
    &cc_parse_readassignexpr,
    &cc_parse_readcondexpr,
    &cc_parse_readorlexpr,
    &cc_parse_readandlexpr,
    &cc_parse_readiorexpr,
    &cc_parse_readixorexpr,
    &cc_parse_readiandexpr,
    &cc_parse_readeqexpr,
    &cc_parse_readrelexpr,
    &cc_parse_readshiftexpr,
    &cc_parse_readaddexpr,
    &cc_parse_readmulexpr,
    &cc_parse_readterm,
    &cc_parse_readexprlist,
    &cc_parse_readmodulevar,
    &cc_parse_readframevar,
    &cc_parse_readtype,
    &cc_parse_readnamedtype,
    &cc_parse_readconstintexpr,
    &cc_parse_readinitexpr,
    &cc_parse_readinitexpr2,
    &cc_parse_pushblock,
    &cc_parse_popblock,
    &cc_parse_readcompoundstmt,
    &cc_parse_readblock,
    &cc_parse_readstatement,
    &cc_parse_readifstmt,
    &cc_parse_readforstmt,
    &cc_parse_readwhilestmt,
    &cc_parse_readdostmt,
    &cc_parse_readreturnstmt,
    &cc_parse_readgotostmt,
    &cc_parse_readswitchstmt,
    &cc_parse_readcaselabel,
    &cc_parse_readexprstmt,
    &cc_parse_readcond,
    &cc_parse_isusertype,
    &cc_parse_readlocaldecl,
    &cc_parse_createtypedef,
    &cc_parse_readparams,
    &cc_parse_readcasttype,
    &cc_parse_readfunction,
    &cc_parse_readfunctionbody,
    &cc_parse_createnegop,
    &cc_parse_createabsop,
    &cc_parse_createsqrtop,
    &cc_parse_createinotop,
    &cc_parse_createptrop,
    &cc_parse_createincrop,
    &cc_parse_createlengthofop,
    &cc_parse_createaddrofop,
    &cc_parse_createaddop,
    &cc_parse_createsubop,
    &cc_parse_createmulop,
    &cc_parse_createdivop,
    &cc_parse_createremop,
    &cc_parse_insertunit,
    &cc_parse_eval_add,
    &cc_parse_eval_sub,
    &cc_parse_eval_mul,
    &cc_parse_eval_div,
    &cc_parse_eval_rem,
    &cc_parse_eval_convert,
    &cc_parse_coercecond,
    &cc_parse_coercebasetype,
    &cc_parse_checklvalue,
    &cc_parse_createcall,
    &cc_parse_arraytopointer,
    &cc_parse_createindexop,
    &cc_parse_readstructdecl,
    &cc_parse_checkpointertypes,
    &cc_parse_comparemode,
    &cc_parse_readenumdecl,
    &cc_parse_readenumnames,
    &cc_parse_createdotop,
    &cc_parse_mulunit,
    &cc_parse_divunit,
    &cc_parse_createassignopref,
    &cc_parse_addnewfield,
    &cc_parse_pushloop,
    &cc_parse_poploop,
    &cc_parse_addcasevalue,
    &cc_parse_roundoffset,
    &cc_parse_fixmemopnd,
    &cc_parse_docast,
    &cc_parse_coercemode,
    &cc_parse_coercemode_inplace,
    &cc_parse_dostaticassert,
    &cc_parse_createsizeofop,
    &cc_parse_readgeneric,
    &cc_parse_readstructinfosym,
    &cc_parse_getmemmode,
    &cc_parse_readstrinclude,
    &cc_genmcl_codegen_mcl,
    &cc_genmcl_genprocdef,
    &cc_genmcl_checkblockreturn,
    &cc_genmcl_dolabel,
    &cc_genmcl_dolabel_fn,
    &cc_genmcl_dostaticvar,
    &cc_genmcl_dostaticvar_fn,
    &cc_genmcl_genprocentry,
    &cc_genmcl_genidata,
    &cc_genmcl_genmainprelude,
    &cc_libmcl_mclinit,
    &cc_libmcl_gettargetdata,
    &cc_libmcl_initmcdest,
    &cc_libmcl_genmc,
    &cc_libmcl_genmc_cond,
    &cc_libmcl_lastmc,
    &cc_libmcl_genmcstr,
    &cc_libmcl_newopnd,
    &cc_libmcl_duplopnd,
    &cc_libmcl_genxreg,
    &cc_libmcl_genindex,
    &cc_libmcl_writemclblock,
    &cc_libmcl_writemclcode,
    &cc_libmcl_gencomment,
    &cc_libmcl_genstrimm,
    &cc_libmcl_genwstrimm,
    &cc_libmcl_genname,
    &cc_libmcl_writemcl,
    &cc_libmcl_strmcl,
    &cc_libmcl_stropnd,
    &cc_libmcl_strvalue,
    &cc_libmcl_setsegment,
    &cc_libmcl_getprocname,
    &cc_libmcl_widenstr,
    &cc_libmcl_genassem,
    &cc_libmcl_strlabel,
    &cc_libmcl_makeindirect,
    &cc_libmcl_applyoffset,
    &cc_libmcl_applysize,
    &cc_libmcl_isframe,
    &cc_libmcl_genreturn,
    &cc_libmcl_getsizeprefix,
    &cc_libmcl_needsizeprefix,
    &cc_libmcl_changeopndsize,
    &cc_libmcl_genint,
    &cc_libmcl_genreal,
    &cc_libmcl_genimm,
    &cc_libmcl_genlabel,
    &cc_libmcl_genmem_u,
    &cc_libmcl_genmem_d,
    &cc_libmcl_genmemaddr_u,
    &cc_libmcl_genmemaddr_d,
    &cc_libmcl_genreg,
    &cc_libmcl_genireg,
    &cc_libmcl_getopndsize_u,
    &cc_libmcl_getopndsize_d,
    &cc_libmcl_getmclcond,
    &cc_libmcl_getfullname,
    &cc_libmcl_roundsizetg,
    &cc_libmcl_iscallbackfn,
    &cc_libmcl_getregname,
    &cc_libmcl_getblockname,
    &cc_libmcl_fgetregname,
    &cc_libmcl_issimple,
    &cc_libmcl_issimple0,
    &cc_libmcl_issimplepm,
    &cc_libmcl_getaregs,
    &cc_libmcl_getlregs,
    &cc_libmcl_isintconst,
    &cc_libmcl__getnextreg,
    &cc_libmcl_getnextreg,
    &cc_libmcl_ispoweroftwo,
    &cc_libmcl_sameoperand,
    &cc_libmcl_findlastmcl,
    &cc_libmcl_genmsource,
    &cc_libmcl_roundto,
    &cc_libmcl_pushstack,
    &cc_libmcl_pushstackfp,
    &cc_libmcl_popstack,
    &cc_libmcl_definelabel,
    &cc_libmcl_createfwdlabel,
    &cc_libmcl_definefwdlabel,
    &cc_libmcl_genjumpl,
    &cc_libmcl_setalign,
    &cc_libmcl_gettypecat,
    &cc_libmcl_doblockcall,
    &cc_libmcl_getblockreg,
    &cc_libmcl_copyretvalue,
    &cc_libmcl_enterproc,
    &cc_libmcl_leaveproc,
    &cc_blockmcl_do_stmt,
    &cc_blockmcl_dx_expr,
    &cc_blockmcl_loneexpr,
    &cc_blockmcl_do_assign,
    &cc_blockmcl_dx_assign,
    &cc_blockmcl_saveexpr,
    &cc_blockmcl_fsaveexpr,
    &cc_blockmcl_restoreexpr,
    &cc_blockmcl_frestoreexpr,
    &cc_blockmcl_getlvalueopnd,
    &cc_blockmcl_storeopnd,
    &cc_blockmcl_pushexpr,
    &cc_blockmcl_fpushexpr,
    &cc_blockmcl_dx_const,
    &cc_blockmcl_dx_constant,
    &cc_blockmcl_do_labeldef,
    &cc_blockmcl_do_goto,
    &cc_blockmcl_dx_add,
    &cc_blockmcl_dx_fadd,
    &cc_blockmcl_loadexpr,
    &cc_blockmcl_evalexpr,
    &cc_blockmcl_evaladdr,
    &cc_blockmcl_evalptr,
    &cc_blockmcl_floadexpr,
    &cc_blockmcl_fevalexpr,
    &cc_blockmcl_do_if,
    &cc_blockmcl_genjumpcond,
    &cc_blockmcl_gcomparejump,
    &cc_blockmcl_reversecond,
    &cc_blockmcl_do_preincr,
    &cc_blockmcl_reversemclcond,
    &cc_blockmcl_do_while,
    &cc_blockmcl_do_while1,
    &cc_blockmcl_stacklooplabels,
    &cc_blockmcl_do_dowhile,
    &cc_blockmcl_do_for,
    &cc_blockmcl_pushffparams,
    &cc_blockmcl_pushoneparam,
    &cc_blockmcl_pushfloatparam,
    &cc_blockmcl_loadfloatparam,
    &cc_blockmcl_dx_call,
    &cc_blockmcl_do_return,
    &cc_blockmcl_dx_sub,
    &cc_blockmcl_dx_mul,
    &cc_blockmcl_dx_div,
    &cc_blockmcl_dx_shl,
    &cc_blockmcl_dx_iand,
    &cc_blockmcl_dx_preincrx,
    &cc_blockmcl_dx_postincrx,
    &cc_blockmcl_makeindexopnd,
    &cc_blockmcl_mulreg,
    &cc_blockmcl_dx_ptr,
    &cc_blockmcl_dx_addptr,
    &cc_blockmcl_dx_subptr,
    &cc_blockmcl_dx_convert,
    &cc_blockmcl_do_decl,
    &cc_blockmcl_do_assignblock,
    &cc_blockmcl_dx_widen,
    &cc_blockmcl_dx_neg,
    &cc_blockmcl_dx_fneg,
    &cc_blockmcl_dx_inot,
    &cc_blockmcl_do_switch,
    &cc_blockmcl_dx_rem,
    &cc_blockmcl_dx_ifx,
    &cc_blockmcl_dx_addto,
    &cc_blockmcl_dx_faddto,
    &cc_blockmcl_dx_eq,
    &cc_blockmcl_do_exprlist,
    &cc_blockmcl_dx_exprlist,
    &cc_blockmcl_dx_shlto,
    &cc_blockmcl_dx_multo,
    &cc_blockmcl_dx_notl,
    &cc_blockmcl_dx_istruel,
    &cc_blockmcl_dx_andorl,
    &cc_blockmcl_dx_sqrt,
    &cc_blockmcl_dx_scale,
    &cc_blockmcl_dx_divto,
    &cc_blockmcl_dx_name,
    &cc_blockmcl_divreg,
    &cc_blockmcl_dx_addrof,
    &cc_blockmcl_dx_dot,
    &cc_blockmcl_loadviaptr,
    &cc_genasm_codegen_writeasm,
    &cc_genasm_inita64,
    &cc_genasm_terma64,
    &cc_genasm_writetoasm,
    &cc_genasm_mcltoa64,
    &cc_genasm_passthru,
    &cc_genasm_convmcl,
    &cc_genasm_do_changeop,
    &cc_genasm_do_comment,
    &cc_genasm_do_blank,
    &cc_genasm_do_end,
    &cc_genasm_do_label,
    &cc_genasm_do_labelname,
    &cc_genasm_do_mov,
    &cc_genasm_do_push,
    &cc_genasm_do_pop,
    &cc_genasm_do_lea,
    &cc_genasm_do_cmovcc,
    &cc_genasm_do_fmov,
    &cc_genasm_do_iwiden,
    &cc_genasm_do_uwiden,
    &cc_genasm_do_inarrow,
    &cc_genasm_do_unarrow,
    &cc_genasm_do_call,
    &cc_genasm_do_ret,
    &cc_genasm_do_retn,
    &cc_genasm_do_jmp,
    &cc_genasm_do_jmpcc,
    &cc_genasm_do_exch,
    &cc_genasm_do_add,
    &cc_genasm_do_sub,
    &cc_genasm_do_imul,
    &cc_genasm_do_idiv,
    &cc_genasm_do_irem,
    &cc_genasm_do_urem,
    &cc_genasm_do_and,
    &cc_genasm_do_or,
    &cc_genasm_do_xor,
    &cc_genasm_do_test,
    &cc_genasm_do_cmp,
    &cc_genasm_do_shl,
    &cc_genasm_do_neg,
    &cc_genasm_do_not,
    &cc_genasm_do_inc,
    &cc_genasm_do_dec,
    &cc_genasm_do_setcc,
    &cc_genasm_do_fneg,
    &cc_genasm_do_fabs,
    &cc_genasm_do_fsqrt,
    &cc_genasm_do_ufix,
    &cc_genasm_do_ifix,
    &cc_genasm_do_ufloat,
    &cc_genasm_do_ifloat,
    &cc_genasm_do_db,
    &cc_genasm_do_dw,
    &cc_genasm_do_dd,
    &cc_genasm_do_dq,
    &cc_genasm_do_align,
    &cc_genasm_do_segment,
    &cc_genasm_do_assem,
    &cc_genasm_strmclasm,
    &cc_genasm_stropndx,
    &cc_genasm_strmclx,
    &cc_genasm_fgetregnamex,
    &cc_genasm_getstringname,
    &cc_genasm_getwstringname,
    &cc_genasm_getrealname,
    &cc_genasm_getsrealname,
    &cc_genasm_getdintname,
    &cc_genasm_getstringindex,
    &cc_genasm_getwstringindex,
    &cc_genasm_getrealindex,
    &cc_genasm_getdintindex,
    &cc_genasm_strvaluex,
    &cc_genasm_convertimm,
    &cc_genasm_genstringtable,
    &cc_genasm_genwstringtable,
    &cc_genasm_do_defstr,
    &cc_genasm_do_defwstr,
    &cc_genasm_genrealtable,
    &cc_genasm_gendinttable,
    &cc_genasm_writefabs,
    &cc_genasm_domclseq,
    &cc_genasm_asmstr,
    &cc_genasm_asmstrln,
    &cc_genasm_asmline,
    &cc_genasm_asmln,
    &cc_genasm_asmint,
    &cc_genasm_asmchar,
    &cc_genasm_asmterm,
    &cc_genasm_initasmline,
    &cc_genasm_getregnamex,
    &cc_genasm_genstring,
    &cc_genasm_genwstring,
    &cc_genasm_extendrealtable,
    &cc_genasm_extenddinttable,
    &cc_genasm_extendstringtable,
    &cc_export_writemheader,
    &cc_export_showmacroseq,
    &cc_export_mmstr,
    &cc_export_mmleftstr,
    &cc_export_mmstrln,
    &cc_export_mmint,
    &cc_export_mmline,
    &cc_export_writefunction,
    &cc_export_mmmode,
    &cc_export_writerecord,
    &cc_export_writefnptr,
    &cc_export_fixname,
    &cc_assembler_assembler,
    &cc_assembler_loadsourcefiles,
    &cc_assembler_parsemodules,
    &cc_assembler_fixopnd,
    &cc_assembler_initall,
    &cc_assembler_loaderror,
    &cc_assembler_loaderror_s,
    &cc_assembler_addmodule,
    &cc_assembler_addsearchlib,
    &cc_assembler_getemptyst,
    &cc_assembler_findduplname,
    &cc_assembler_adddupl,
    &cc_assembler_scanglobals,
    &cc_assembler_resethashtable,
    &ax_lex_lex,
    &ax_lex_initlex,
    &ax_lex_readreal,
    &ax_lex_readnumber,
    &ax_lex_readbinary,
    &ax_lex_readhex,
    &ax_lex_ps,
    &ax_lex_printsymbol,
    &ax_lex_clearhashtable,
    &ax_lex_inithashtable,
    &ax_lex_addreservedword,
    &ax_lex_printhashtable,
    &ax_lex_lookuplex,
    &ax_lex_initsourcefile,
    &ax_lex_addnamestr,
    &ax_lex_lxerror,
    &ax_lex_gethashvalue,
    &ax_lex_skiptoeol,
    &ax_lex_makestring,
    &ax_parse_readmodule,
    &ax_parse_checkundefined,
    &ax_parse_checksymbol,
    &ax_parse_readinstr,
    &ax_parse_readcondinstr,
    &ax_parse_readoperand,
    &ax_parse_readexpression,
    &ax_parse_readterm,
    &ax_parse_readreg,
    &ax_parse_readaddrmode,
    &ax_lib_initlib,
    &ax_lib_genmc,
    &ax_lib_genmcstr,
    &ax_lib_newopnd,
    &ax_lib_genxreg,
    &ax_lib_genindex,
    &ax_lib_writemclblock,
    &ax_lib_gencomment,
    &ax_lib_genstrimm,
    &ax_lib_getsizetag,
    &ax_lib_writemcl,
    &ax_lib_strmcl,
    &ax_lib_stropnd,
    &ax_lib_strdef,
    &ax_lib_setsegment,
    &ax_lib_getsizeprefix,
    &ax_lib_needsizeprefix,
    &ax_lib_genimm_expr,
    &ax_lib_genint,
    &ax_lib_genlab,
    &ax_lib_genmem,
    &ax_lib_genreg0,
    &ax_lib_getfullname,
    &ax_lib_getregname,
    &ax_lib_xgetregname,
    &ax_lib_printst,
    &ax_lib_printstrec,
    &ax_lib_adddef,
    &ax_lib_addimport,
    &ax_lib_createlabel,
    &ax_lib_createnamedconst,
    &ax_lib_createregalias,
    &ax_lib_createxregalias,
    &ax_lib_gerror,
    &ax_lib_serror,
    &ax_lib_serror_s,
    &ax_lib_inttostr,
    &ax_lib_realtostr,
    &ax_lib_buffercreate,
    &ax_lib_bufferexpand,
    &ax_lib_buffercheck,
    &ax_lib_bufferlength,
    &ax_lib_bufferelemptr,
    &ax_lib_addbyte,
    &ax_lib_addword,
    &ax_lib_adddword,
    &ax_lib_addqword,
    &ax_lib_printmodulesymbols,
    &ax_lib_printimportsymbols,
    &ax_lib_printdupltable,
    &ax_genss_genss,
    &ax_genss_doinstr,
    &ax_genss_genbyte,
    &ax_genss_genword,
    &ax_genss_gendword,
    &ax_genss_genqword,
    &ax_genss_genopnd,
    &ax_genss_addrelocitem,
    &ax_genss_getstindex,
    &ax_genss_genrel32,
    &ax_genss_genabs32,
    &ax_genss_genabs64,
    &ax_genss_getrel32,
    &ax_genss_dofwdrefs,
    &ax_genss_genrex,
    &ax_genss_isbytesized,
    &ax_genss_isdwordsized,
    &ax_genss_do_push,
    &ax_genss_do_pop,
    &ax_genss_do_inc,
    &ax_genss_do_neg,
    &ax_genss_genamode,
    &ax_genss_makemodrm,
    &ax_genss_setopsize,
    &ax_genss_setaddrsize,
    &ax_genss_getdispsize,
    &ax_genss_genrm,
    &ax_genss_genrmbyte,
    &ax_genss_makeam,
    &ax_genss_do_arith,
    &ax_genss_do_mov,
    &ax_genss_getregcoder,
    &ax_genss_getregcodeb,
    &ax_genss_getregcodebx,
    &ax_genss_getregcoderx,
    &ax_genss_do_lea,
    &ax_genss_do_movsx,
    &ax_genss_checkhighreg,
    &ax_genss_do_exch,
    &ax_genss_do_movsxd,
    &ax_genss_do_imul2,
    &ax_genss_do_imul3,
    &ax_genss_do_shift,
    &ax_genss_do_test,
    &ax_genss_do_loop,
    &ax_genss_do_jcxz,
    &ax_genss_do_setcc,
    &ax_genss_do_movxmm,
    &ax_genss_do_arithxmm,
    &ax_genss_do_logicxmm,
    &ax_genss_do_convertfloat,
    &ax_genss_do_fix,
    &ax_genss_do_float,
    &ax_genss_do_call,
    &ax_genss_do_jmp,
    &ax_genss_getcurrdatalen,
    &ax_genss_do_cmovcc,
    &ax_genss_do_fmem,
    &ax_genss_getr32bits,
    &ax_genss_genrel8,
    &ax_genss_checkshortjump,
    &ax_genss_addfwdref,
    &ax_genss_switchseg,
    &ax_genss_do_movdqx,
    &ax_genss_do_popcnt,
    &ax_genss_do_bsf,
    &ax_genss_extendsymboltable,
    &ax_genss_do_pcmpistri,
    &ax_writeexe_writeexe,
    &ax_writeexe_genexe,
    &ax_writeexe_loadlibs,
    &ax_writeexe_initsectiontable,
    &ax_writeexe_roundtoblock,
    &ax_writeexe_extractlibname,
    &ax_writeexe_scanst,
    &ax_writeexe_relocdata,
    &ax_writeexe_getbaserelocs,
    &ax_writeexe_writerecordx,
    &ax_writeexe_writedosstub,
    &ax_writeexe_writepesig,
    &ax_writeexe_writepadding,
    &ax_writeexe_writefileheader,
    &ax_writeexe_writeoptheader,
    &ax_writeexe_writesectionheader,
    &ax_writeexe_writesectiondata,
    &ax_writeexe_getoffsets,
    &ax_writeexe_getsectionno,
    &ax_writeexe_writeexporttable,
    &ax_writeexe_getexporttablesize,
    &ax_writeexe_newbasereloc,
    &ax_writeexe_scanbaserelocs,
    &ax_writeexe_writebasereloctable,
    &ax_writeexe_sortexports,
    &ax_disasm_decodeinstr,
    &ax_disasm_decodetwobyteinstr,
    &ax_disasm_decodeaddr,
    &ax_disasm_readbyte,
    &ax_disasm_readsbyte,
    &ax_disasm_readword16,
    &ax_disasm_readint16,
    &ax_disasm_readword32,
    &ax_disasm_readint32,
    &ax_disasm_readint64,
    &ax_disasm_getreg,
    &ax_disasm_strreg,
    &ax_disasm_strfreg,
    &ax_disasm_printaddrmode,
    &ax_disasm_genstr,
    &ax_disasm_genintd,
    &ax_disasm_genhex,
    &ax_disasm_readimm,
    &ax_disasm_readimm8,
    &ax_disasm_strxmm,
    &ax_disasm_strmmx,
    &ax_disasm_decode8087,
    &ax_disasm_do87arith,
    &ax_disasm_do87mem,
    &ax_disasm_getsil,
    &ax_disasm_getsilx,
    &ax_writeobj_writess,
    &ax_writeobj_writerecord,
    &ax_writeobj_writerelocs,
    &ax_writeobj_writedata,
    &ax_writeobj_writesymboltable,
    &ax_writeobj_writestringtable,
    &ax_writeobj_makesymbol,
    &ax_writeobj_addsymbol,
    &ax_writeobj_initsymboltable,
    &ax_writeobj_strtoaux,
    &ax_writeobj_sectiontoaux,
    &ax_writeobj_addstringentry,
    &ax_writeobj_convertsymboltable,
    &ax_writeobj_writecoff,
0};
static byte *  msysnewc__fnnames[]= {
    (byte*)"start",
    (byte*)"compilemodules",
    (byte*)"debugcompile",
    (byte*)"do_loadmodule",
    (byte*)"do_preprocess",
    (byte*)"do_parsemodule",
    (byte*)"do_genmcl",
    (byte*)"do_genasm",
    (byte*)"do_runprog",
    (byte*)"loadmainmodule",
    (byte*)"addmodule",
    (byte*)"initlogfile",
    (byte*)"closelogfile",
    (byte*)"initdata",
    (byte*)"initsearchdirs",
    (byte*)"showsearchdirs",
    (byte*)"showast",
    (byte*)"showstflat",
    (byte*)"showsttree",
    (byte*)"showmcl",
    (byte*)"showasm",
    (byte*)"showfiles",
    (byte*)"starttiming",
    (byte*)"showtiming",
    (byte*)"getinputoptions",
    (byte*)"do_option",
    (byte*)"showincludepaths",
    (byte*)"showhelp",
    (byte*)"showextrainfo",
    (byte*)"showcaption",
    (byte*)"do_genlink",
    (byte*)"resetcompiler",
    (byte*)"addnewmodules",
    (byte*)"writeatfile",
    (byte*)"m_getdotindex",
    (byte*)"m_setdotindex",
    (byte*)"m_getdotslice",
    (byte*)"m_setdotslice",
    (byte*)"m_get_nprocs",
    (byte*)"m_get_nexports",
    (byte*)"m_get_procname",
    (byte*)"m_get_procaddr",
    (byte*)"m_get_procexport",
    (byte*)"pushio",
    (byte*)"m_print_startfile",
    (byte*)"m_print_startstr",
    (byte*)"m_print_startptr",
    (byte*)"m_print_startcon",
    (byte*)"m_print_setfmt",
    (byte*)"m_print_end",
    (byte*)"m_print_ptr",
    (byte*)"m_print_i64",
    (byte*)"m_print_u64",
    (byte*)"m_print_r64",
    (byte*)"m_print_r32",
    (byte*)"m_print_c8",
    (byte*)"m_print_str",
    (byte*)"m_print_newline",
    (byte*)"m_print_nogap",
    (byte*)"printstr",
    (byte*)"printstr_n",
    (byte*)"printstrn_app",
    (byte*)"makezstring",
    (byte*)"freezstring",
    (byte*)"printchar",
    (byte*)"nextfmtchars",
    (byte*)"strtofmt",
    (byte*)"domultichar",
    (byte*)"expandstr",
    (byte*)"xdivrem",
    (byte*)"u64tostr",
    (byte*)"i64tostrfmt",
    (byte*)"u64tostrfmt",
    (byte*)"i64mintostr",
    (byte*)"strtostrfmt",
    (byte*)"tostr_i64",
    (byte*)"tostr_u64",
    (byte*)"tostr_r64",
    (byte*)"tostr_str",
    (byte*)"getfmt",
    (byte*)"strint",
    (byte*)"getstrint",
    (byte*)"strword",
    (byte*)"strreal",
    (byte*)"getstr",
    (byte*)"initreadbuffer",
    (byte*)"m_read_conline",
    (byte*)"m_read_fileline",
    (byte*)"m_read_strline",
    (byte*)"readitem",
    (byte*)"strtoint",
    (byte*)"m_read_i64",
    (byte*)"m_read_r64",
    (byte*)"m_read_str",
    (byte*)"readstr",
    (byte*)"rereadln",
    (byte*)"reread",
    (byte*)"valint",
    (byte*)"valreal",
    (byte*)"iconvlcn",
    (byte*)"iconvucn",
    (byte*)"convlcstring",
    (byte*)"convucstring",
    (byte*)"m_power_i64",
    (byte*)"m_intoverflow",
    (byte*)"m_dotindex",
    (byte*)"m_dotslice",
    (byte*)"m_popdotindex",
    (byte*)"m_popdotslice",
    (byte*)"m_imin",
    (byte*)"m_imax",
    (byte*)"m_sign",
    (byte*)"pcm_alloc",
    (byte*)"pcm_freestr",
    (byte*)"pcm_free",
    (byte*)"pcm_freeac",
    (byte*)"pcm_copymem4",
    (byte*)"pcm_clearmem",
    (byte*)"pcm_init",
    (byte*)"pcm_getac",
    (byte*)"pcm_newblock",
    (byte*)"pcm_round",
    (byte*)"pcm_array",
    (byte*)"pcm_printfreelist",
    (byte*)"pcm_diags",
    (byte*)"pcm_allocz",
    (byte*)"pcm_copyheapstring",
    (byte*)"pcm_copyheapstringn",
    (byte*)"pcm_copyheapblock",
    (byte*)"addtomemalloc",
    (byte*)"removefrommemalloc",
    (byte*)"allocmem",
    (byte*)"reallocmem",
    (byte*)"abortprogram",
    (byte*)"getfilesize",
    (byte*)"readrandom",
    (byte*)"writerandom",
    (byte*)"setfilepos",
    (byte*)"getfilepos",
    (byte*)"readfile",
    (byte*)"writefile",
    (byte*)"checkfile",
    (byte*)"readlinen",
    (byte*)"iconvlcn",
    (byte*)"iconvucn",
    (byte*)"convlcstring",
    (byte*)"convucstring",
    (byte*)"changeext",
    (byte*)"extractext",
    (byte*)"extractpath",
    (byte*)"extractfile",
    (byte*)"extractbasefile",
    (byte*)"addext",
    (byte*)"alloctable",
    (byte*)"zalloctable",
    (byte*)"checkfreelists",
    (byte*)"pcm_alloc32",
    (byte*)"pcm_free32",
    (byte*)"outbyte",
    (byte*)"outword16",
    (byte*)"outword",
    (byte*)"outword64",
    (byte*)"myeof",
    (byte*)"pcm_smallallocz",
    (byte*)"pcm_smallalloc",
    (byte*)"strbuffer_add",
    (byte*)"gs_init",
    (byte*)"gs_free",
    (byte*)"gs_str",
    (byte*)"gs_char",
    (byte*)"gs_strn",
    (byte*)"gs_strvar",
    (byte*)"gs_strint",
    (byte*)"gs_strln",
    (byte*)"gs_strsp",
    (byte*)"gs_line",
    (byte*)"gs_getcol",
    (byte*)"gs_leftstr",
    (byte*)"gs_leftint",
    (byte*)"gs_padto",
    (byte*)"gs_println",
    (byte*)"nextcmdparam",
    (byte*)"readnextfileitem",
    (byte*)"ipadstr",
    (byte*)"padstr",
    (byte*)"chr",
    (byte*)"cmpstring",
    (byte*)"cmpstringn",
    (byte*)"eqstring",
    (byte*)"cmpbytes",
    (byte*)"eqbytes",
    (byte*)"mseed",
    (byte*)"mrandom",
    (byte*)"mrandomp",
    (byte*)"mrandomint",
    (byte*)"mrandomrange",
    (byte*)"mrandomreal",
    (byte*)"mrandomreal1",
    (byte*)"checkpackfile",
    (byte*)"os_init",
    (byte*)"os_execwait",
    (byte*)"os_execcmd",
    (byte*)"os_getch",
    (byte*)"os_kbhit",
    (byte*)"os_flushkeys",
    (byte*)"os_getconsolein",
    (byte*)"os_getconsoleout",
    (byte*)"os_proginstance",
    (byte*)"os_getdllinst",
    (byte*)"os_getdllprocaddr",
    (byte*)"os_initwindows",
    (byte*)"os_getchx",
    (byte*)"os_getos",
    (byte*)"os_getoscode",
    (byte*)"os_iswindows",
    (byte*)"os_shellexec",
    (byte*)"os_sleep",
    (byte*)"os_getstdin",
    (byte*)"os_getstdout",
    (byte*)"os_gethostname",
    (byte*)"os_gethostsize",
    (byte*)"os_getmpath",
    (byte*)"os_exitprocess",
    (byte*)"os_gettimestamp",
    (byte*)"os_gettickcount",
    (byte*)"os_clock",
    (byte*)"os_getclockspersec",
    (byte*)"os_setmesshandler",
    (byte*)"os_filelastwritetime",
    (byte*)"os_hpcounter",
    (byte*)"os_hpfrequency",
    (byte*)"os_getsystime",
    (byte*)"os_peek",
    (byte*)"stopcompiler",
    (byte*)"mcerror",
    (byte*)"serror",
    (byte*)"serror_gen",
    (byte*)"serror_ss",
    (byte*)"serror_s",
    (byte*)"terror_gen",
    (byte*)"terror",
    (byte*)"terror_s",
    (byte*)"terror_ss",
    (byte*)"gerror_gen",
    (byte*)"gerror",
    (byte*)"gerror_s",
    (byte*)"nxerror",
    (byte*)"testelem",
    (byte*)"setelem",
    (byte*)"nextpoweroftwo",
    (byte*)"loaderror",
    (byte*)"loadfromstdin",
    (byte*)"loadsourcefile",
    (byte*)"splicelines",
    (byte*)"loadbuiltin",
    (byte*)"gs_copytostr",
    (byte*)"gs_additem",
    (byte*)"isalphanum",
    (byte*)"showmacrolineno",
    (byte*)"lex_preprocess_only",
    (byte*)"lexreadtoken",
    (byte*)"readrealnumber",
    (byte*)"readexponent",
    (byte*)"lxerror",
    (byte*)"printsymbol",
    (byte*)"lexsetup",
    (byte*)"printstrn",
    (byte*)"scannumber",
    (byte*)"lookup",
    (byte*)"gethashvalue",
    (byte*)"inithashtable",
    (byte*)"fillhashtable",
    (byte*)"dolexdirective",
    (byte*)"getlexdirective",
    (byte*)"startlex",
    (byte*)"endlex",
    (byte*)"ps",
    (byte*)"psnext",
    (byte*)"gethashtablesize",
    (byte*)"readlinecomment",
    (byte*)"readblockcomment",
    (byte*)"readhex",
    (byte*)"readbinary",
    (byte*)"readoctal",
    (byte*)"readdecimal",
    (byte*)"checknumbersuffix",
    (byte*)"stacksourcefile",
    (byte*)"unstacksourcefile",
    (byte*)"getsourcefile",
    (byte*)"lex",
    (byte*)"shownumberstr",
    (byte*)"addnamestr",
    (byte*)"lxreadstring",
    (byte*)"addlisttoken",
    (byte*)"addlisttoken_copy",
    (byte*)"addlist_nextlx",
    (byte*)"addlisttoken_seq",
    (byte*)"addlistmparam",
    (byte*)"dodefine",
    (byte*)"readalphanumeric",
    (byte*)"inmacrostack",
    (byte*)"showtokens",
    (byte*)"lexa",
    (byte*)"lexm",
    (byte*)"peeklb",
    (byte*)"peektk",
    (byte*)"expandobjmacro",
    (byte*)"expandfnmacro",
    (byte*)"scantokenseq",
    (byte*)"readmacrocall",
    (byte*)"substituteargs",
    (byte*)"strtoken",
    (byte*)"strstring",
    (byte*)"emittoken",
    (byte*)"showtoken",
    (byte*)"stringify",
    (byte*)"pastetokens",
    (byte*)"getifexpr",
    (byte*)"evalcondexpr",
    (byte*)"evalorexpr",
    (byte*)"evalandexpr",
    (byte*)"evaliorexpr",
    (byte*)"evalixorexpr",
    (byte*)"evaliandexpr",
    (byte*)"evaleqexpr",
    (byte*)"evalcmpexpr",
    (byte*)"evalshiftexpr",
    (byte*)"evaladdexpr",
    (byte*)"evalmulexpr",
    (byte*)"evalunaryexpr",
    (byte*)"evalterm",
    (byte*)"getifdef",
    (byte*)"skipcode",
    (byte*)"freetokens",
    (byte*)"fastreadtoken",
    (byte*)"alloctoken",
    (byte*)"alloctokenz",
    (byte*)"expandpredefmacro",
    (byte*)"dopragmadir",
    (byte*)"needspace",
    (byte*)"dospecialinclude",
    (byte*)"addautomodule",
    (byte*)"setnumberoffset",
    (byte*)"setfileno",
    (byte*)"setfilenox",
    (byte*)"getfileno",
    (byte*)"getfilenox",
    (byte*)"getnumberoffsetx",
    (byte*)"freehashtable",
    (byte*)"freestentry",
    (byte*)"regenlookup",
    (byte*)"printhashtable",
    (byte*)"newhashtable",
    (byte*)"old_readrealnumber",
    (byte*)"findheader",
    (byte*)"writeheaders",
    (byte*)"checkbcclib",
    (byte*)"getbcclib",
    (byte*)"isheaderfile",
    (byte*)"newstrec",
    (byte*)"initcclib",
    (byte*)"printst",
    (byte*)"printstrec",
    (byte*)"printstflat",
    (byte*)"createname",
    (byte*)"createunit0",
    (byte*)"createunit1",
    (byte*)"createunit2",
    (byte*)"createunit3",
    (byte*)"createconstunit",
    (byte*)"createstringconstunit",
    (byte*)"createwstringconstunit",
    (byte*)"getoptocode",
    (byte*)"getconstvalue",
    (byte*)"nextautotype",
    (byte*)"createconstmode",
    (byte*)"createrefmode",
    (byte*)"createprocmode",
    (byte*)"createarraymode",
    (byte*)"createenummode",
    (byte*)"createstructmode",
    (byte*)"setnameptr",
    (byte*)"printcode_all",
    (byte*)"printcode",
    (byte*)"printunit",
    (byte*)"printunitlist",
    (byte*)"getprefix",
    (byte*)"getdottedname",
    (byte*)"getlineinfok",
    (byte*)"getautofieldname",
    (byte*)"convertstring",
    (byte*)"strexpr",
    (byte*)"jeval",
    (byte*)"getopcjname",
    (byte*)"strmode",
    (byte*)"strmode2",
    (byte*)"istrmode",
    (byte*)"countunits",
    (byte*)"purgesymbol",
    (byte*)"purgesymbollist",
    (byte*)"purgeprocs",
    (byte*)"purgeproc",
    (byte*)"printmodelist",
    (byte*)"typename",
    (byte*)"allocunitrec",
    (byte*)"copymode",
    (byte*)"createnewmode",
    (byte*)"addlistunit",
    (byte*)"addlistdef",
    (byte*)"addlistparam",
    (byte*)"checksymbol",
    (byte*)"skipsymbol",
    (byte*)"inittypetables",
    (byte*)"createdupldef",
    (byte*)"createnewmoduledef",
    (byte*)"createnewproc",
    (byte*)"resolvename",
    (byte*)"resolvelabel",
    (byte*)"checkdupl",
    (byte*)"checkdupl_inproc",
    (byte*)"getalignment",
    (byte*)"isexported",
    (byte*)"isimported",
    (byte*)"isstructunion",
    (byte*)"getstname",
    (byte*)"isrealcc",
    (byte*)"isintcc",
    (byte*)"readmodule",
    (byte*)"parsemodule",
    (byte*)"readdeclspec",
    (byte*)"istypestarter",
    (byte*)"readexpression",
    (byte*)"readassignexpr",
    (byte*)"readcondexpr",
    (byte*)"readorlexpr",
    (byte*)"readandlexpr",
    (byte*)"readiorexpr",
    (byte*)"readixorexpr",
    (byte*)"readiandexpr",
    (byte*)"readeqexpr",
    (byte*)"readrelexpr",
    (byte*)"readshiftexpr",
    (byte*)"readaddexpr",
    (byte*)"readmulexpr",
    (byte*)"readterm",
    (byte*)"readexprlist",
    (byte*)"readmodulevar",
    (byte*)"readframevar",
    (byte*)"readtype",
    (byte*)"readnamedtype",
    (byte*)"readconstintexpr",
    (byte*)"readinitexpr",
    (byte*)"readinitexpr2",
    (byte*)"pushblock",
    (byte*)"popblock",
    (byte*)"readcompoundstmt",
    (byte*)"readblock",
    (byte*)"readstatement",
    (byte*)"readifstmt",
    (byte*)"readforstmt",
    (byte*)"readwhilestmt",
    (byte*)"readdostmt",
    (byte*)"readreturnstmt",
    (byte*)"readgotostmt",
    (byte*)"readswitchstmt",
    (byte*)"readcaselabel",
    (byte*)"readexprstmt",
    (byte*)"readcond",
    (byte*)"isusertype",
    (byte*)"readlocaldecl",
    (byte*)"createtypedef",
    (byte*)"readparams",
    (byte*)"readcasttype",
    (byte*)"readfunction",
    (byte*)"readfunctionbody",
    (byte*)"createnegop",
    (byte*)"createabsop",
    (byte*)"createsqrtop",
    (byte*)"createinotop",
    (byte*)"createptrop",
    (byte*)"createincrop",
    (byte*)"createlengthofop",
    (byte*)"createaddrofop",
    (byte*)"createaddop",
    (byte*)"createsubop",
    (byte*)"createmulop",
    (byte*)"createdivop",
    (byte*)"createremop",
    (byte*)"insertunit",
    (byte*)"eval_add",
    (byte*)"eval_sub",
    (byte*)"eval_mul",
    (byte*)"eval_div",
    (byte*)"eval_rem",
    (byte*)"eval_convert",
    (byte*)"coercecond",
    (byte*)"coercebasetype",
    (byte*)"checklvalue",
    (byte*)"createcall",
    (byte*)"arraytopointer",
    (byte*)"createindexop",
    (byte*)"readstructdecl",
    (byte*)"checkpointertypes",
    (byte*)"comparemode",
    (byte*)"readenumdecl",
    (byte*)"readenumnames",
    (byte*)"createdotop",
    (byte*)"mulunit",
    (byte*)"divunit",
    (byte*)"createassignopref",
    (byte*)"addnewfield",
    (byte*)"pushloop",
    (byte*)"poploop",
    (byte*)"addcasevalue",
    (byte*)"roundoffset",
    (byte*)"fixmemopnd",
    (byte*)"docast",
    (byte*)"coercemode",
    (byte*)"coercemode_inplace",
    (byte*)"dostaticassert",
    (byte*)"createsizeofop",
    (byte*)"readgeneric",
    (byte*)"readstructinfosym",
    (byte*)"getmemmode",
    (byte*)"readstrinclude",
    (byte*)"codegen_mcl",
    (byte*)"genprocdef",
    (byte*)"checkblockreturn",
    (byte*)"dolabel",
    (byte*)"dolabel_fn",
    (byte*)"dostaticvar",
    (byte*)"dostaticvar_fn",
    (byte*)"genprocentry",
    (byte*)"genidata",
    (byte*)"genmainprelude",
    (byte*)"mclinit",
    (byte*)"gettargetdata",
    (byte*)"initmcdest",
    (byte*)"genmc",
    (byte*)"genmc_cond",
    (byte*)"lastmc",
    (byte*)"genmcstr",
    (byte*)"newopnd",
    (byte*)"duplopnd",
    (byte*)"genxreg",
    (byte*)"genindex",
    (byte*)"writemclblock",
    (byte*)"writemclcode",
    (byte*)"gencomment",
    (byte*)"genstrimm",
    (byte*)"genwstrimm",
    (byte*)"genname",
    (byte*)"writemcl",
    (byte*)"strmcl",
    (byte*)"stropnd",
    (byte*)"strvalue",
    (byte*)"setsegment",
    (byte*)"getprocname",
    (byte*)"widenstr",
    (byte*)"genassem",
    (byte*)"strlabel",
    (byte*)"makeindirect",
    (byte*)"applyoffset",
    (byte*)"applysize",
    (byte*)"isframe",
    (byte*)"genreturn",
    (byte*)"getsizeprefix",
    (byte*)"needsizeprefix",
    (byte*)"changeopndsize",
    (byte*)"genint",
    (byte*)"genreal",
    (byte*)"genimm",
    (byte*)"genlabel",
    (byte*)"genmem_u",
    (byte*)"genmem_d",
    (byte*)"genmemaddr_u",
    (byte*)"genmemaddr_d",
    (byte*)"genreg",
    (byte*)"genireg",
    (byte*)"getopndsize_u",
    (byte*)"getopndsize_d",
    (byte*)"getmclcond",
    (byte*)"getfullname",
    (byte*)"roundsizetg",
    (byte*)"iscallbackfn",
    (byte*)"getregname",
    (byte*)"getblockname",
    (byte*)"fgetregname",
    (byte*)"issimple",
    (byte*)"issimple0",
    (byte*)"issimplepm",
    (byte*)"getaregs",
    (byte*)"getlregs",
    (byte*)"isintconst",
    (byte*)"_getnextreg",
    (byte*)"getnextreg",
    (byte*)"ispoweroftwo",
    (byte*)"sameoperand",
    (byte*)"findlastmcl",
    (byte*)"genmsource",
    (byte*)"roundto",
    (byte*)"pushstack",
    (byte*)"pushstackfp",
    (byte*)"popstack",
    (byte*)"definelabel",
    (byte*)"createfwdlabel",
    (byte*)"definefwdlabel",
    (byte*)"genjumpl",
    (byte*)"setalign",
    (byte*)"gettypecat",
    (byte*)"doblockcall",
    (byte*)"getblockreg",
    (byte*)"copyretvalue",
    (byte*)"enterproc",
    (byte*)"leaveproc",
    (byte*)"do_stmt",
    (byte*)"dx_expr",
    (byte*)"loneexpr",
    (byte*)"do_assign",
    (byte*)"dx_assign",
    (byte*)"saveexpr",
    (byte*)"fsaveexpr",
    (byte*)"restoreexpr",
    (byte*)"frestoreexpr",
    (byte*)"getlvalueopnd",
    (byte*)"storeopnd",
    (byte*)"pushexpr",
    (byte*)"fpushexpr",
    (byte*)"dx_const",
    (byte*)"dx_constant",
    (byte*)"do_labeldef",
    (byte*)"do_goto",
    (byte*)"dx_add",
    (byte*)"dx_fadd",
    (byte*)"loadexpr",
    (byte*)"evalexpr",
    (byte*)"evaladdr",
    (byte*)"evalptr",
    (byte*)"floadexpr",
    (byte*)"fevalexpr",
    (byte*)"do_if",
    (byte*)"genjumpcond",
    (byte*)"gcomparejump",
    (byte*)"reversecond",
    (byte*)"do_preincr",
    (byte*)"reversemclcond",
    (byte*)"do_while",
    (byte*)"do_while1",
    (byte*)"stacklooplabels",
    (byte*)"do_dowhile",
    (byte*)"do_for",
    (byte*)"pushffparams",
    (byte*)"pushoneparam",
    (byte*)"pushfloatparam",
    (byte*)"loadfloatparam",
    (byte*)"dx_call",
    (byte*)"do_return",
    (byte*)"dx_sub",
    (byte*)"dx_mul",
    (byte*)"dx_div",
    (byte*)"dx_shl",
    (byte*)"dx_iand",
    (byte*)"dx_preincrx",
    (byte*)"dx_postincrx",
    (byte*)"makeindexopnd",
    (byte*)"mulreg",
    (byte*)"dx_ptr",
    (byte*)"dx_addptr",
    (byte*)"dx_subptr",
    (byte*)"dx_convert",
    (byte*)"do_decl",
    (byte*)"do_assignblock",
    (byte*)"dx_widen",
    (byte*)"dx_neg",
    (byte*)"dx_fneg",
    (byte*)"dx_inot",
    (byte*)"do_switch",
    (byte*)"dx_rem",
    (byte*)"dx_ifx",
    (byte*)"dx_addto",
    (byte*)"dx_faddto",
    (byte*)"dx_eq",
    (byte*)"do_exprlist",
    (byte*)"dx_exprlist",
    (byte*)"dx_shlto",
    (byte*)"dx_multo",
    (byte*)"dx_notl",
    (byte*)"dx_istruel",
    (byte*)"dx_andorl",
    (byte*)"dx_sqrt",
    (byte*)"dx_scale",
    (byte*)"dx_divto",
    (byte*)"dx_name",
    (byte*)"divreg",
    (byte*)"dx_addrof",
    (byte*)"dx_dot",
    (byte*)"loadviaptr",
    (byte*)"codegen_writeasm",
    (byte*)"inita64",
    (byte*)"terma64",
    (byte*)"writetoasm",
    (byte*)"mcltoa64",
    (byte*)"passthru",
    (byte*)"convmcl",
    (byte*)"do_changeop",
    (byte*)"do_comment",
    (byte*)"do_blank",
    (byte*)"do_end",
    (byte*)"do_label",
    (byte*)"do_labelname",
    (byte*)"do_mov",
    (byte*)"do_push",
    (byte*)"do_pop",
    (byte*)"do_lea",
    (byte*)"do_cmovcc",
    (byte*)"do_fmov",
    (byte*)"do_iwiden",
    (byte*)"do_uwiden",
    (byte*)"do_inarrow",
    (byte*)"do_unarrow",
    (byte*)"do_call",
    (byte*)"do_ret",
    (byte*)"do_retn",
    (byte*)"do_jmp",
    (byte*)"do_jmpcc",
    (byte*)"do_exch",
    (byte*)"do_add",
    (byte*)"do_sub",
    (byte*)"do_imul",
    (byte*)"do_idiv",
    (byte*)"do_irem",
    (byte*)"do_urem",
    (byte*)"do_and",
    (byte*)"do_or",
    (byte*)"do_xor",
    (byte*)"do_test",
    (byte*)"do_cmp",
    (byte*)"do_shl",
    (byte*)"do_neg",
    (byte*)"do_not",
    (byte*)"do_inc",
    (byte*)"do_dec",
    (byte*)"do_setcc",
    (byte*)"do_fneg",
    (byte*)"do_fabs",
    (byte*)"do_fsqrt",
    (byte*)"do_ufix",
    (byte*)"do_ifix",
    (byte*)"do_ufloat",
    (byte*)"do_ifloat",
    (byte*)"do_db",
    (byte*)"do_dw",
    (byte*)"do_dd",
    (byte*)"do_dq",
    (byte*)"do_align",
    (byte*)"do_segment",
    (byte*)"do_assem",
    (byte*)"strmclasm",
    (byte*)"stropndx",
    (byte*)"strmclx",
    (byte*)"fgetregnamex",
    (byte*)"getstringname",
    (byte*)"getwstringname",
    (byte*)"getrealname",
    (byte*)"getsrealname",
    (byte*)"getdintname",
    (byte*)"getstringindex",
    (byte*)"getwstringindex",
    (byte*)"getrealindex",
    (byte*)"getdintindex",
    (byte*)"strvaluex",
    (byte*)"convertimm",
    (byte*)"genstringtable",
    (byte*)"genwstringtable",
    (byte*)"do_defstr",
    (byte*)"do_defwstr",
    (byte*)"genrealtable",
    (byte*)"gendinttable",
    (byte*)"writefabs",
    (byte*)"domclseq",
    (byte*)"asmstr",
    (byte*)"asmstrln",
    (byte*)"asmline",
    (byte*)"asmln",
    (byte*)"asmint",
    (byte*)"asmchar",
    (byte*)"asmterm",
    (byte*)"initasmline",
    (byte*)"getregnamex",
    (byte*)"genstring",
    (byte*)"genwstring",
    (byte*)"extendrealtable",
    (byte*)"extenddinttable",
    (byte*)"extendstringtable",
    (byte*)"writemheader",
    (byte*)"showmacroseq",
    (byte*)"mmstr",
    (byte*)"mmleftstr",
    (byte*)"mmstrln",
    (byte*)"mmint",
    (byte*)"mmline",
    (byte*)"writefunction",
    (byte*)"mmmode",
    (byte*)"writerecord",
    (byte*)"writefnptr",
    (byte*)"fixname",
    (byte*)"assembler",
    (byte*)"loadsourcefiles",
    (byte*)"parsemodules",
    (byte*)"fixopnd",
    (byte*)"initall",
    (byte*)"loaderror",
    (byte*)"loaderror_s",
    (byte*)"addmodule",
    (byte*)"addsearchlib",
    (byte*)"getemptyst",
    (byte*)"findduplname",
    (byte*)"adddupl",
    (byte*)"scanglobals",
    (byte*)"resethashtable",
    (byte*)"lex",
    (byte*)"initlex",
    (byte*)"readreal",
    (byte*)"readnumber",
    (byte*)"readbinary",
    (byte*)"readhex",
    (byte*)"ps",
    (byte*)"printsymbol",
    (byte*)"clearhashtable",
    (byte*)"inithashtable",
    (byte*)"addreservedword",
    (byte*)"printhashtable",
    (byte*)"lookuplex",
    (byte*)"initsourcefile",
    (byte*)"addnamestr",
    (byte*)"lxerror",
    (byte*)"gethashvalue",
    (byte*)"skiptoeol",
    (byte*)"makestring",
    (byte*)"readmodule",
    (byte*)"checkundefined",
    (byte*)"checksymbol",
    (byte*)"readinstr",
    (byte*)"readcondinstr",
    (byte*)"readoperand",
    (byte*)"readexpression",
    (byte*)"readterm",
    (byte*)"readreg",
    (byte*)"readaddrmode",
    (byte*)"initlib",
    (byte*)"genmc",
    (byte*)"genmcstr",
    (byte*)"newopnd",
    (byte*)"genxreg",
    (byte*)"genindex",
    (byte*)"writemclblock",
    (byte*)"gencomment",
    (byte*)"genstrimm",
    (byte*)"getsizetag",
    (byte*)"writemcl",
    (byte*)"strmcl",
    (byte*)"stropnd",
    (byte*)"strdef",
    (byte*)"setsegment",
    (byte*)"getsizeprefix",
    (byte*)"needsizeprefix",
    (byte*)"genimm_expr",
    (byte*)"genint",
    (byte*)"genlab",
    (byte*)"genmem",
    (byte*)"genreg0",
    (byte*)"getfullname",
    (byte*)"getregname",
    (byte*)"xgetregname",
    (byte*)"printst",
    (byte*)"printstrec",
    (byte*)"adddef",
    (byte*)"addimport",
    (byte*)"createlabel",
    (byte*)"createnamedconst",
    (byte*)"createregalias",
    (byte*)"createxregalias",
    (byte*)"gerror",
    (byte*)"serror",
    (byte*)"serror_s",
    (byte*)"inttostr",
    (byte*)"realtostr",
    (byte*)"buffercreate",
    (byte*)"bufferexpand",
    (byte*)"buffercheck",
    (byte*)"bufferlength",
    (byte*)"bufferelemptr",
    (byte*)"addbyte",
    (byte*)"addword",
    (byte*)"adddword",
    (byte*)"addqword",
    (byte*)"printmodulesymbols",
    (byte*)"printimportsymbols",
    (byte*)"printdupltable",
    (byte*)"genss",
    (byte*)"doinstr",
    (byte*)"genbyte",
    (byte*)"genword",
    (byte*)"gendword",
    (byte*)"genqword",
    (byte*)"genopnd",
    (byte*)"addrelocitem",
    (byte*)"getstindex",
    (byte*)"genrel32",
    (byte*)"genabs32",
    (byte*)"genabs64",
    (byte*)"getrel32",
    (byte*)"dofwdrefs",
    (byte*)"genrex",
    (byte*)"isbytesized",
    (byte*)"isdwordsized",
    (byte*)"do_push",
    (byte*)"do_pop",
    (byte*)"do_inc",
    (byte*)"do_neg",
    (byte*)"genamode",
    (byte*)"makemodrm",
    (byte*)"setopsize",
    (byte*)"setaddrsize",
    (byte*)"getdispsize",
    (byte*)"genrm",
    (byte*)"genrmbyte",
    (byte*)"makeam",
    (byte*)"do_arith",
    (byte*)"do_mov",
    (byte*)"getregcoder",
    (byte*)"getregcodeb",
    (byte*)"getregcodebx",
    (byte*)"getregcoderx",
    (byte*)"do_lea",
    (byte*)"do_movsx",
    (byte*)"checkhighreg",
    (byte*)"do_exch",
    (byte*)"do_movsxd",
    (byte*)"do_imul2",
    (byte*)"do_imul3",
    (byte*)"do_shift",
    (byte*)"do_test",
    (byte*)"do_loop",
    (byte*)"do_jcxz",
    (byte*)"do_setcc",
    (byte*)"do_movxmm",
    (byte*)"do_arithxmm",
    (byte*)"do_logicxmm",
    (byte*)"do_convertfloat",
    (byte*)"do_fix",
    (byte*)"do_float",
    (byte*)"do_call",
    (byte*)"do_jmp",
    (byte*)"getcurrdatalen",
    (byte*)"do_cmovcc",
    (byte*)"do_fmem",
    (byte*)"getr32bits",
    (byte*)"genrel8",
    (byte*)"checkshortjump",
    (byte*)"addfwdref",
    (byte*)"switchseg",
    (byte*)"do_movdqx",
    (byte*)"do_popcnt",
    (byte*)"do_bsf",
    (byte*)"extendsymboltable",
    (byte*)"do_pcmpistri",
    (byte*)"writeexe",
    (byte*)"genexe",
    (byte*)"loadlibs",
    (byte*)"initsectiontable",
    (byte*)"roundtoblock",
    (byte*)"extractlibname",
    (byte*)"scanst",
    (byte*)"relocdata",
    (byte*)"getbaserelocs",
    (byte*)"writerecordx",
    (byte*)"writedosstub",
    (byte*)"writepesig",
    (byte*)"writepadding",
    (byte*)"writefileheader",
    (byte*)"writeoptheader",
    (byte*)"writesectionheader",
    (byte*)"writesectiondata",
    (byte*)"getoffsets",
    (byte*)"getsectionno",
    (byte*)"writeexporttable",
    (byte*)"getexporttablesize",
    (byte*)"newbasereloc",
    (byte*)"scanbaserelocs",
    (byte*)"writebasereloctable",
    (byte*)"sortexports",
    (byte*)"decodeinstr",
    (byte*)"decodetwobyteinstr",
    (byte*)"decodeaddr",
    (byte*)"readbyte",
    (byte*)"readsbyte",
    (byte*)"readword16",
    (byte*)"readint16",
    (byte*)"readword32",
    (byte*)"readint32",
    (byte*)"readint64",
    (byte*)"getreg",
    (byte*)"strreg",
    (byte*)"strfreg",
    (byte*)"printaddrmode",
    (byte*)"genstr",
    (byte*)"genintd",
    (byte*)"genhex",
    (byte*)"readimm",
    (byte*)"readimm8",
    (byte*)"strxmm",
    (byte*)"strmmx",
    (byte*)"decode8087",
    (byte*)"do87arith",
    (byte*)"do87mem",
    (byte*)"getsil",
    (byte*)"getsilx",
    (byte*)"writess",
    (byte*)"writerecord",
    (byte*)"writerelocs",
    (byte*)"writedata",
    (byte*)"writesymboltable",
    (byte*)"writestringtable",
    (byte*)"makesymbol",
    (byte*)"addsymbol",
    (byte*)"initsymboltable",
    (byte*)"strtoaux",
    (byte*)"sectiontoaux",
    (byte*)"addstringentry",
    (byte*)"convertsymboltable",
    (byte*)"writecoff",
(byte*)""};
static struct msysnewc_procinforec msysnewc__fnexports[]= {
	{0, 0,0, {0,0,0, 0,0,0, 0,0,0, 0,0,0}}}
;
static i64 msysnewc__fnnprocs=1032;
static i64 msysnewc__fnnexports=0;
static i64 msysnewc_fmtparam;
i64 msysnewc_needgap = (i64)0;
static i64 msysnewc_outdev = (i64)1;
static void *  msysnewc_outchan = 0;
static byte *  msysnewc_fmtstr = 0;
static void *  msysnewc_outchan_stack[10];
static i64 msysnewc_outdev_stack[10];
static byte *  msysnewc_fmtstr_stack[10];
static byte msysnewc_needgap_stack[10];
static byte *  msysnewc_ptr_stack[10];
static i64 msysnewc_niostack = (i64)0;
static byte msysnewc_digits[16] = {
    '0',
    '1',
    '2',
    '3',
    '4',
    '5',
    '6',
    '7',
    '8',
    '9',
    'A',
    'B',
    'C',
    'D',
    'E',
    'F'
};
static struct msysnewc_fmtrec msysnewc_defaultfmt = {
    (u8)0u,
    (i8)0,
    (u8)10u,
    (u64)0u,
    ' ',
    'f',
    (u64)0u,
    (u64)0u,
    (u64)0u,
    'R',
    (u64)0u,
    (u64)0u,
    (u64)0u,
    (u64)0u,
    (u64)0u,
    (u8)0u
};
static byte *  msysnewc_rd_buffer;
static i64 msysnewc_rd_length;
static byte *  msysnewc_rd_pos;
static byte *  msysnewc_rd_lastpos;
static i64 msysnewc_termchar;
static i64 msysnewc_itemerror;
i64 msysnewc_nsysparams;
byte *  msysnewc_sysparams[128];
static u64 msysnewc_callbackstack[9][8];
static i64 msysnewc_ncallbacks = (i64)0;
static u64 msysnewc_mask63 = (u64)9223372036854775807u;
static double msysnewc_offset64 = (double)9223372036854775800.;
static double msysnewc_offset32 = (double)9223372036854775800.;
i64 mlib_mdebug;
u64 mlib_allocupper[301];
i64 mlib_alloccode;
i64 mlib_allocbytes;
i64 mlib_fdebug = (i64)0;
i64 mlib_rfsize;
static u64 mlib_maxmemory;
static i64 mlib_maxalloccode;
static byte mlib_pcm_setup = (u8)0u;
static i64 mlib_show = (i64)0;
i64 mlib_memtotal = (i64)0;
i64 mlib_smallmemtotal = (i64)0;
i64 mlib_smallmemobjs = (i64)0;
i64 mlib_maxmemtotal = (i64)0;
static i32 *  mlib_memalloctable[500001];
static i32 mlib_memallocsize[500001];
static byte *  mlib_pcheapstart;
static byte *  mlib_pcheapend;
static byte *  mlib_pcheapptr;
static byte mlib_sizeindextable[2049];
u64 *  mlib_freelist[9];
byte *  mlib_pmnames[6] = {(byte*)"pm_end",(byte*)"pm_option",(byte*)"pm_sourcefile",(byte*)"pm_libfile",(byte*)"pm_colon",(byte*)"pm_extra"};
static i64 mlib_seed[2] = {(i64)2993073034246558322,(i64)1617678968452121188};
static i64 osnos_init_flag = (i64)0;
i64 cc_decls_ntypes;
i64 cc_decls_ntypesreset;
struct cc_decls_strec *  cc_decls_ttnamedef[20000];
i64 cc_decls_ttbasetype[20000];
i64 cc_decls_ttlength[20000];
byte cc_decls_ttconst[20000];
byte cc_decls_ttrestrict[20000];
byte cc_decls_ttvolatile[20000];
i64 cc_decls_ttusertype[20000];
i64 cc_decls_tttarget[20000];
i64 cc_decls_ttreftype[20000];
i64 cc_decls_ttconsttype[20000];
i64 cc_decls_ttsize[20000];
i64 cc_decls_ttbitwidth[20000];
byte cc_decls_ttisref[20000];
struct cc_decls_paramrec *  cc_decls_ttparams[20000];
struct cc_decls_strec *  cc_decls_tttypedef[20000];
i64 cc_decls_trefchar;
i64 cc_decls_trefwchar;
struct cc_decls_modulerec cc_decls_moduletable[201];
byte *  cc_decls_inputfiles[201];
byte *  cc_decls_libfiles[201];
byte *  cc_decls_sourcefilenames[601];
byte *  cc_decls_sourcefilepaths[601];
byte *  cc_decls_sourcefiletext[601];
i32 cc_decls_sourcefilesizes[601];
byte *  cc_decls_automodulenames[201];
i64 cc_decls_nmodules;
i64 cc_decls_nautomodules;
i64 cc_decls_nsourcefiles;
i64 cc_decls_ninputfiles;
i64 cc_decls_nlibfiles;
i64 cc_decls_currmoduleno;
struct cc_decls_modulerec *  cc_decls_currmodule;
byte *  cc_decls_searchdirs[20];
i64 cc_decls_nsearchdirs = (i64)0;
byte *  cc_decls_includepaths[20];
i64 cc_decls_nincludepaths = (i64)0;
struct cc_decls_strec *  cc_decls_stprogram;
struct cc_decls_strec *  cc_decls_stmodule;
void *  cc_decls_logdev;
i64 cc_decls_logdest = (i64)0;
i64 cc_decls_optflag = (i64)0;
struct cc_decls_unitrec *  cc_decls_nullunit;
i64 cc_decls_fverbose = (i64)0;
i64 cc_decls_fquiet = (i64)0;
i64 cc_decls_fshownames = (i64)0;
i64 cc_decls_fshowincludes = (i64)0;
i64 cc_decls_fautomodules = (i64)0;
i64 cc_decls_fmodern = (i64)1;
i64 cc_decls_foptimise = (i64)0;
i64 cc_decls_wintarget = (i64)1;
i64 cc_decls_lintarget = (i64)0;
i64 cc_decls_nostarget = (i64)0;
i64 cc_decls_clineno = (i64)0;
i64 cc_decls_fastasm = (i64)0;
i64 cc_decls_fcallback = (i64)0;
i64 cc_decls_flinesplicing = (i64)0;
struct cc_decls_tokenrec cc_decls_lx;
struct cc_decls_tokenrec cc_decls_nextlx;
i64 cc_decls_debug = (i64)0;
i64 cc_decls_hstsize = (i64)16384;
i64 cc_decls_hstmask;
struct cc_decls_strec * (*cc_decls_hashtable)[];
i32 cc_decls_blockowner[2101];
i32 cc_decls_blockcounts[2101];
i32 cc_decls_blockstack[101];
i64 cc_decls_currblockno;
i64 cc_decls_nextblockno;
i64 cc_decls_blocklevel;
struct cc_decls_strec *  cc_decls_currproc;
i64 cc_decls_labelno = (i64)0;
i64 cc_decls_dointheaders = (i64)1;
byte *  cc_decls_dheaderfile = 0;
i64 cc_decls_structpadding = (i64)1;
i64 cc_decls_callbackflag = (i64)0;
i64 cc_decls_slineno;
i64 cc_decls_sfileno;
byte *  cc_decls_oemname = (byte*)"BCC";
i64 cc_decls_nlookups;
i64 cc_decls_nclashes;
byte *  cc_tables_stdtypenames[23] = {
    (byte*)"none",
    (byte*)"void",
    (byte*)"schar",
    (byte*)"short",
    (byte*)"int",
    (byte*)"llong",
    (byte*)"bool",
    (byte*)"uchar",
    (byte*)"ushort",
    (byte*)"uint",
    (byte*)"ullong",
    (byte*)"float",
    (byte*)"double",
    (byte*)"ldouble",
    (byte*)"complex",
    (byte*)"enum",
    (byte*)"ref",
    (byte*)"proc",
    (byte*)"label",
    (byte*)"array",
    (byte*)"struct",
    (byte*)"union",
    (byte*)"tlast"
};
byte cc_tables_stdtypewidths[23] = {
    (u8)0u,
    (u8)0u,
    (u8)8u,
    (u8)16u,
    (u8)32u,
    (u8)64u,
    (u8)8u,
    (u8)8u,
    (u8)16u,
    (u8)32u,
    (u8)64u,
    (u8)32u,
    (u8)64u,
    (u8)128u,
    (u8)128u,
    (u8)0u,
    (u8)64u,
    (u8)64u,
    (u8)64u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u
};
byte cc_tables_stdtypesigned[23] = {
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u
};
byte cc_tables_stdexpandtypes[23] = {
    (u8)0u,
    (u8)0u,
    (u8)4u,
    (u8)4u,
    (u8)0u,
    (u8)0u,
    (u8)9u,
    (u8)9u,
    (u8)9u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u
};
byte cc_tables_stdtypecat[23] = {
    (u8)0u,
    (u8)0u,
    (u8)73u,
    (u8)73u,
    (u8)73u,
    (u8)73u,
    (u8)85u,
    (u8)85u,
    (u8)85u,
    (u8)85u,
    (u8)85u,
    (u8)82u,
    (u8)82u,
    (u8)82u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u
};
byte *  cc_tables_stdtypemnames[23] = {
    (byte*)"",
    (byte*)"void",
    (byte*)"i8",
    (byte*)"i16",
    (byte*)"i32",
    (byte*)"i64",
    (byte*)"byte",
    (byte*)"byte",
    (byte*)"u16",
    (byte*)"u32",
    (byte*)"u64",
    (byte*)"r32",
    (byte*)"r64",
    (byte*)"r64",
    (byte*)"",
    (byte*)"",
    (byte*)"",
    (byte*)"",
    (byte*)"",
    (byte*)"",
    (byte*)"",
    (byte*)"",
    (byte*)""
};
byte *  cc_tables_typespecnames[16] = {
    (byte*)"ts_void",
    (byte*)"ts_char",
    (byte*)"ts_short",
    (byte*)"ts_long",
    (byte*)"ts_int",
    (byte*)"ts_float",
    (byte*)"ts_double",
    (byte*)"ts_signed",
    (byte*)"ts_unsigned",
    (byte*)"ts_bool",
    (byte*)"ts_complex",
    (byte*)"ts_user",
    (byte*)"ts_struct",
    (byte*)"ts_union",
    (byte*)"ts_enum",
    (byte*)"ts_atomic"
};
i32 cc_tables_typespectypes[16] = {
    (i32)1,
    (i32)2,
    (i32)0,
    (i32)0,
    (i32)4,
    (i32)11,
    (i32)12,
    (i32)0,
    (i32)0,
    (i32)6,
    (i32)14,
    (i32)0,
    (i32)0,
    (i32)0,
    (i32)0,
    (i32)0
};
byte cc_tables_typespecsizes[16] = {
    (u8)0u,
    (u8)1u,
    (u8)2u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)8u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)4u,
    (u8)0u
};
byte *  cc_tables_pmflagnames[4] = {(byte*)"pm_normal",(byte*)"pm_notset",(byte*)"pm_empty",(byte*)"pm_variadic"};
byte *  cc_tables_scopenames[5] = {(byte*)"-",(byte*)"Fn",(byte*)"Loc",(byte*)"Imp",(byte*)"Exp"};
byte *  cc_tables_ccnames[6] = {(byte*)"open_cc",(byte*)"own_cc",(byte*)"clang_cc",(byte*)"stdcall_cc",(byte*)"callback_cc",(byte*)"dummy_cc"};
byte *  cc_tables_linkagenames[6] = {(byte*)"none_ss",(byte*)"static_ss",(byte*)"auto_ss",(byte*)"register_ss",(byte*)"extern_ss",(byte*)"typedef_ss"};
byte *  cc_tables_typequalnames[4] = {(byte*)"const_qual",(byte*)"volatile_qual",(byte*)"restrict_qual",(byte*)"atomic_qual"};
byte *  cc_tables_fnspecnames[3] = {(byte*)"inline_fnspec",(byte*)"noreturn_fnspec",(byte*)"callback_fnspec"};
byte *  cc_tables_jtagnames[79] = {
    (byte*)"j_none",
    (byte*)"j_const",
    (byte*)"j_null",
    (byte*)"j_name",
    (byte*)"j_widenmem",
    (byte*)"j_funcname",
    (byte*)"j_block",
    (byte*)"j_tempdecl",
    (byte*)"j_decl",
    (byte*)"j_callproc",
    (byte*)"j_return",
    (byte*)"j_returnx",
    (byte*)"j_assign",
    (byte*)"j_if",
    (byte*)"j_for",
    (byte*)"j_while",
    (byte*)"j_dowhile",
    (byte*)"j_goto",
    (byte*)"j_labelstmt",
    (byte*)"j_casestmt",
    (byte*)"j_defaultstmt",
    (byte*)"j_break",
    (byte*)"j_continue",
    (byte*)"j_switch",
    (byte*)"j_breaksw",
    (byte*)"&& andl",
    (byte*)"|| orl",
    (byte*)"! notl",
    (byte*)"j_istruel",
    (byte*)"j_makelist",
    (byte*)"j_exprlist",
    (byte*)"j_callfn",
    (byte*)"j_ifx",
    (byte*)"&&",
    (byte*)"==",
    (byte*)"!=",
    (byte*)"<",
    (byte*)"<=",
    (byte*)">",
    (byte*)">=",
    (byte*)"+ add",
    (byte*)"- sub",
    (byte*)"* mul",
    (byte*)"/ div",
    (byte*)"% mod",
    (byte*)"& iand",
    (byte*)"| ior",
    (byte*)"^ ixor",
    (byte*)"<<",
    (byte*)">>",
    (byte*)"j_dot",
    (byte*)"j_idot",
    (byte*)"j_index",
    (byte*)"ptr",
    (byte*)"addptr",
    (byte*)"subptr",
    (byte*)"addrof &",
    (byte*)"j_convert",
    (byte*)"j_scale",
    (byte*)"- neg",
    (byte*)"abs",
    (byte*)"~ inot",
    (byte*)"+=",
    (byte*)"-=",
    (byte*)"*=",
    (byte*)"/=",
    (byte*)"%=",
    (byte*)"&=",
    (byte*)"|=",
    (byte*)"^=",
    (byte*)"<<=",
    (byte*)">>=",
    (byte*)"sqrt",
    (byte*)"++ preincr",
    (byte*)"-- preincr",
    (byte*)"++ postincr",
    (byte*)"-- postdecr",
    (byte*)"cputime",
    (byte*)"j_dummy"
};
byte *  cc_tables_symbolnames[105] = {
    (byte*)"errorsym",
    (byte*)"dotsym",
    (byte*)"idotsym",
    (byte*)"lexhashsym",
    (byte*)"hashsym",
    (byte*)"lithashsym",
    (byte*)"hashhashsym",
    (byte*)"commasym",
    (byte*)"semisym",
    (byte*)"colonsym",
    (byte*)"assignsym",
    (byte*)"assignsym2",
    (byte*)"lbracksym",
    (byte*)"rbracksym",
    (byte*)"lsqsym",
    (byte*)"rsqsym",
    (byte*)"lcurlysym",
    (byte*)"rcurlysym",
    (byte*)"questionsym",
    (byte*)"curlsym",
    (byte*)"ellipsissym",
    (byte*)"backslashsym",
    (byte*)"addsym",
    (byte*)"subsym",
    (byte*)"mulsym",
    (byte*)"divsym",
    (byte*)"remsym",
    (byte*)"iorsym",
    (byte*)"iandsym",
    (byte*)"ixorsym",
    (byte*)"orlsym",
    (byte*)"andlsym",
    (byte*)"shlsym",
    (byte*)"shrsym",
    (byte*)"inotsym",
    (byte*)"notlsym",
    (byte*)"incrsym",
    (byte*)"decrsym",
    (byte*)"abssym",
    (byte*)"eqsym",
    (byte*)"nesym",
    (byte*)"ltsym",
    (byte*)"lesym",
    (byte*)"gesym",
    (byte*)"gtsym",
    (byte*)"addtosym",
    (byte*)"subtosym",
    (byte*)"multosym",
    (byte*)"divtosym",
    (byte*)"remtosym",
    (byte*)"iortosym",
    (byte*)"iandtosym",
    (byte*)"ixortosym",
    (byte*)"shltosym",
    (byte*)"shrtosym",
    (byte*)"sqrtsym",
    (byte*)"eolsym",
    (byte*)"eofsym",
    (byte*)"rawnumbersym",
    (byte*)"intconstsym",
    (byte*)"realconstsym",
    (byte*)"charconstsym",
    (byte*)"wcharconstsym",
    (byte*)"stringconstsym",
    (byte*)"wstringconstsym",
    (byte*)"whitespacesym",
    (byte*)"placeholdersym",
    (byte*)"kstrincludesym",
    (byte*)"namesym",
    (byte*)"ksourcedirsym",
    (byte*)"predefmacrosym",
    (byte*)"ktypespecsym",
    (byte*)"kifsym",
    (byte*)"kelsesym",
    (byte*)"kcasesym",
    (byte*)"kdefaultsym",
    (byte*)"kforsym",
    (byte*)"kwhilesym",
    (byte*)"kdosym",
    (byte*)"kreturnsym",
    (byte*)"kbreaksym",
    (byte*)"kcontinuesym",
    (byte*)"kgotosym",
    (byte*)"kswitchsym",
    (byte*)"kstructsym",
    (byte*)"kunionsym",
    (byte*)"klinkagesym",
    (byte*)"ktypequalsym",
    (byte*)"kfnspecsym",
    (byte*)"kalignassym",
    (byte*)"kenumsym",
    (byte*)"ksizeofsym",
    (byte*)"klengthofsym",
    (byte*)"kdefinedsym",
    (byte*)"kgenericsym",
    (byte*)"kalignofsym",
    (byte*)"kshowmodesym",
    (byte*)"kshowtypesym",
    (byte*)"ktypeofsym",
    (byte*)"kstrtypesym",
    (byte*)"kmccassertsym",
    (byte*)"kcputimesym",
    (byte*)"kconstantsym",
    (byte*)"kstructinfosym",
    (byte*)"kdummysym"
};
byte *  cc_tables_shortsymbolnames[105] = {
    (byte*)"",
    (byte*)".",
    (byte*)"->",
    (byte*)"#",
    (byte*)"#",
    (byte*)"#",
    (byte*)"##",
    (byte*)",",
    (byte*)";",
    (byte*)":",
    (byte*)"=",
    (byte*)":=",
    (byte*)"(",
    (byte*)")",
    (byte*)"[",
    (byte*)"]",
    (byte*)"{",
    (byte*)"}",
    (byte*)"?",
    (byte*)"~",
    (byte*)"...",
    (byte*)"\\",
    (byte*)"+",
    (byte*)"-",
    (byte*)"*",
    (byte*)"/",
    (byte*)"%",
    (byte*)"|",
    (byte*)"&",
    (byte*)"^",
    (byte*)"||",
    (byte*)"&&",
    (byte*)"<<",
    (byte*)">>",
    (byte*)"~",
    (byte*)"!",
    (byte*)"++",
    (byte*)"--",
    (byte*)"abs",
    (byte*)"==",
    (byte*)"!=",
    (byte*)"<",
    (byte*)"<=",
    (byte*)">=",
    (byte*)">",
    (byte*)"+=",
    (byte*)"-=",
    (byte*)"*=",
    (byte*)"/=",
    (byte*)"%=",
    (byte*)"|=",
    (byte*)"&=",
    (byte*)"^=",
    (byte*)"<<=",
    (byte*)">>=",
    (byte*)"sqrt",
    (byte*)"",
    (byte*)"",
    (byte*)"n",
    (byte*)"n",
    (byte*)"n",
    (byte*)"s",
    (byte*)"s",
    (byte*)"s",
    (byte*)"s",
    (byte*)"w",
    (byte*)"",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)""
};
byte cc_tables_symboltojtag[105] = {
    (u8)0u,
    (u8)50u,
    (u8)51u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)12u,
    (u8)12u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)40u,
    (u8)41u,
    (u8)42u,
    (u8)43u,
    (u8)44u,
    (u8)46u,
    (u8)45u,
    (u8)47u,
    (u8)26u,
    (u8)25u,
    (u8)48u,
    (u8)49u,
    (u8)61u,
    (u8)27u,
    (u8)73u,
    (u8)74u,
    (u8)60u,
    (u8)34u,
    (u8)35u,
    (u8)36u,
    (u8)37u,
    (u8)39u,
    (u8)38u,
    (u8)62u,
    (u8)63u,
    (u8)64u,
    (u8)65u,
    (u8)66u,
    (u8)68u,
    (u8)67u,
    (u8)69u,
    (u8)70u,
    (u8)71u,
    (u8)72u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u
};
byte *  cc_tables_sourcedirnames[20] = {
    (byte*)"definedir",
    (byte*)"emitdir",
    (byte*)"ifdir",
    (byte*)"elifdir",
    (byte*)"elsedir",
    (byte*)"endifdir",
    (byte*)"includedir",
    (byte*)"ifdefdir",
    (byte*)"ifndefdir",
    (byte*)"undefdir",
    (byte*)"errordir",
    (byte*)"warningdir",
    (byte*)"messagedir",
    (byte*)"pausedir",
    (byte*)"debugondir",
    (byte*)"debugoffdir",
    (byte*)"showmacrodir",
    (byte*)"blankdir",
    (byte*)"linedir",
    (byte*)"pragmadir"
};
byte *  cc_tables_namespacenames[5] = {(byte*)"ns_none",(byte*)"ns_general",(byte*)"ns_tags",(byte*)"ns_labels",(byte*)"ns_fields"};
byte *  cc_tables_namenames[16] = {
    (byte*)"nullid",
    (byte*)"macroid",
    (byte*)"programid",
    (byte*)"moduleid",
    (byte*)"extmoduleid",
    (byte*)"typeid",
    (byte*)"procid",
    (byte*)"staticid",
    (byte*)"frameid",
    (byte*)"paramid",
    (byte*)"fieldid",
    (byte*)"enumid",
    (byte*)"enumtagid",
    (byte*)"structtagid",
    (byte*)"constantid",
    (byte*)"labelid"
};
i32 cc_tables_namespaces[16] = {
    (i32)0,
    (i32)0,
    (i32)0,
    (i32)0,
    (i32)0,
    (i32)1,
    (i32)1,
    (i32)1,
    (i32)1,
    (i32)1,
    (i32)4,
    (i32)1,
    (i32)2,
    (i32)2,
    (i32)1,
    (i32)3
};
byte *  cc_tables_stnames[77] = {
    (byte*)"if",
    (byte*)"else",
    (byte*)"case",
    (byte*)"default",
    (byte*)"for",
    (byte*)"do",
    (byte*)"while",
    (byte*)"return",
    (byte*)"break",
    (byte*)"continue",
    (byte*)"goto",
    (byte*)"switch",
    (byte*)"struct",
    (byte*)"union",
    (byte*)"include",
    (byte*)"define",
    (byte*)"elif",
    (byte*)"ifdef",
    (byte*)"ifndef",
    (byte*)"endif",
    (byte*)"undef",
    (byte*)"error",
    (byte*)"warning",
    (byte*)"message",
    (byte*)"MESSAGE",
    (byte*)"pragma",
    (byte*)"line",
    (byte*)"pause",
    (byte*)"debugon",
    (byte*)"debugoff",
    (byte*)"showmacro",
    (byte*)"strinclude",
    (byte*)"auto",
    (byte*)"register",
    (byte*)"static",
    (byte*)"extern",
    (byte*)"typedef",
    (byte*)"const",
    (byte*)"volatile",
    (byte*)"restrict",
    (byte*)"_Atomic",
    (byte*)"inline",
    (byte*)"_Noreturn",
    (byte*)"$callback",
    (byte*)"_Alignas",
    (byte*)"enum",
    (byte*)"void",
    (byte*)"char",
    (byte*)"short",
    (byte*)"long",
    (byte*)"int",
    (byte*)"float",
    (byte*)"double",
    (byte*)"signed",
    (byte*)"unsigned",
    (byte*)"_Bool",
    (byte*)"_Complex",
    (byte*)"__DATE__",
    (byte*)"__FILE__",
    (byte*)"__LINE__",
    (byte*)"__TIME__",
    (byte*)"__BCC__",
    (byte*)"__func__",
    (byte*)"__FUNCTION__",
    (byte*)"sizeof",
    (byte*)"$sqrt",
    (byte*)"defined",
    (byte*)"_Generic",
    (byte*)"_Alignof",
    (byte*)"$showmode",
    (byte*)"$showtype",
    (byte*)"typeof",
    (byte*)"strtype",
    (byte*)"_Static_assert",
    (byte*)"cputime",
    (byte*)"structinfo",
    (byte*)"$$dummy"
};
i32 cc_tables_stsymbols[77] = {
    (i32)73,
    (i32)74,
    (i32)75,
    (i32)76,
    (i32)77,
    (i32)79,
    (i32)78,
    (i32)80,
    (i32)81,
    (i32)82,
    (i32)83,
    (i32)84,
    (i32)85,
    (i32)86,
    (i32)70,
    (i32)70,
    (i32)70,
    (i32)70,
    (i32)70,
    (i32)70,
    (i32)70,
    (i32)70,
    (i32)70,
    (i32)70,
    (i32)70,
    (i32)70,
    (i32)70,
    (i32)70,
    (i32)70,
    (i32)70,
    (i32)70,
    (i32)68,
    (i32)87,
    (i32)87,
    (i32)87,
    (i32)87,
    (i32)87,
    (i32)88,
    (i32)88,
    (i32)88,
    (i32)88,
    (i32)89,
    (i32)89,
    (i32)89,
    (i32)90,
    (i32)91,
    (i32)72,
    (i32)72,
    (i32)72,
    (i32)72,
    (i32)72,
    (i32)72,
    (i32)72,
    (i32)72,
    (i32)72,
    (i32)72,
    (i32)72,
    (i32)71,
    (i32)71,
    (i32)71,
    (i32)71,
    (i32)71,
    (i32)71,
    (i32)71,
    (i32)92,
    (i32)56,
    (i32)94,
    (i32)95,
    (i32)96,
    (i32)97,
    (i32)98,
    (i32)99,
    (i32)100,
    (i32)101,
    (i32)102,
    (i32)104,
    (i32)0
};
i32 cc_tables_stsubcodes[77] = {
    (i32)13,
    (i32)0,
    (i32)0,
    (i32)0,
    (i32)0,
    (i32)0,
    (i32)0,
    (i32)0,
    (i32)0,
    (i32)0,
    (i32)0,
    (i32)0,
    (i32)0,
    (i32)0,
    (i32)7,
    (i32)1,
    (i32)4,
    (i32)8,
    (i32)9,
    (i32)6,
    (i32)10,
    (i32)11,
    (i32)12,
    (i32)13,
    (i32)13,
    (i32)20,
    (i32)19,
    (i32)14,
    (i32)15,
    (i32)16,
    (i32)17,
    (i32)0,
    (i32)2,
    (i32)3,
    (i32)1,
    (i32)4,
    (i32)5,
    (i32)1,
    (i32)2,
    (i32)3,
    (i32)4,
    (i32)1,
    (i32)2,
    (i32)3,
    (i32)0,
    (i32)0,
    (i32)1,
    (i32)2,
    (i32)3,
    (i32)4,
    (i32)5,
    (i32)6,
    (i32)7,
    (i32)8,
    (i32)9,
    (i32)2,
    (i32)11,
    (i32)1,
    (i32)3,
    (i32)4,
    (i32)2,
    (i32)7,
    (i32)5,
    (i32)5,
    (i32)0,
    (i32)0,
    (i32)0,
    (i32)0,
    (i32)0,
    (i32)0,
    (i32)0,
    (i32)0,
    (i32)0,
    (i32)0,
    (i32)0,
    (i32)0,
    (i32)0
};
byte *  cc_tables_convnames[14] = {
    (byte*)"no_conv",
    (byte*)"soft_c",
    (byte*)"hard_c",
    (byte*)"swiden_c",
    (byte*)"uwiden_c",
    (byte*)"sfloat_c",
    (byte*)"ufloat_c",
    (byte*)"sfix_c",
    (byte*)"ufix_c",
    (byte*)"fwiden_c",
    (byte*)"fnarrow_c",
    (byte*)"narrow_c",
    (byte*)"truncate_c",
    (byte*)"bool_c"
};
byte cc_tables_dominantmode[32][32];
byte cc_tables_conversionops[16][16];
byte cc_tables_dominantsetuptable[144][3] = {
    {(u8)2u,(u8)2u,(u8)4u},
    {(u8)2u,(u8)3u,(u8)4u},
    {(u8)2u,(u8)4u,(u8)4u},
    {(u8)2u,(u8)5u,(u8)5u},
    {(u8)2u,(u8)6u,(u8)4u},
    {(u8)2u,(u8)7u,(u8)4u},
    {(u8)2u,(u8)8u,(u8)4u},
    {(u8)2u,(u8)9u,(u8)4u},
    {(u8)2u,(u8)10u,(u8)5u},
    {(u8)2u,(u8)11u,(u8)11u},
    {(u8)2u,(u8)12u,(u8)12u},
    {(u8)2u,(u8)13u,(u8)13u},
    {(u8)3u,(u8)2u,(u8)4u},
    {(u8)3u,(u8)3u,(u8)4u},
    {(u8)3u,(u8)4u,(u8)4u},
    {(u8)3u,(u8)5u,(u8)5u},
    {(u8)3u,(u8)6u,(u8)4u},
    {(u8)3u,(u8)7u,(u8)4u},
    {(u8)3u,(u8)8u,(u8)4u},
    {(u8)3u,(u8)9u,(u8)4u},
    {(u8)3u,(u8)10u,(u8)5u},
    {(u8)3u,(u8)11u,(u8)11u},
    {(u8)3u,(u8)12u,(u8)12u},
    {(u8)3u,(u8)13u,(u8)13u},
    {(u8)4u,(u8)2u,(u8)4u},
    {(u8)4u,(u8)3u,(u8)4u},
    {(u8)4u,(u8)4u,(u8)4u},
    {(u8)4u,(u8)5u,(u8)5u},
    {(u8)4u,(u8)6u,(u8)4u},
    {(u8)4u,(u8)7u,(u8)4u},
    {(u8)4u,(u8)8u,(u8)4u},
    {(u8)4u,(u8)9u,(u8)9u},
    {(u8)4u,(u8)10u,(u8)5u},
    {(u8)4u,(u8)11u,(u8)11u},
    {(u8)4u,(u8)12u,(u8)12u},
    {(u8)4u,(u8)13u,(u8)13u},
    {(u8)5u,(u8)2u,(u8)5u},
    {(u8)5u,(u8)3u,(u8)5u},
    {(u8)5u,(u8)4u,(u8)5u},
    {(u8)5u,(u8)5u,(u8)5u},
    {(u8)5u,(u8)6u,(u8)5u},
    {(u8)5u,(u8)7u,(u8)5u},
    {(u8)5u,(u8)8u,(u8)5u},
    {(u8)5u,(u8)9u,(u8)5u},
    {(u8)5u,(u8)10u,(u8)10u},
    {(u8)5u,(u8)11u,(u8)11u},
    {(u8)5u,(u8)12u,(u8)12u},
    {(u8)5u,(u8)13u,(u8)13u},
    {(u8)6u,(u8)2u,(u8)4u},
    {(u8)6u,(u8)3u,(u8)4u},
    {(u8)6u,(u8)4u,(u8)4u},
    {(u8)6u,(u8)5u,(u8)5u},
    {(u8)6u,(u8)6u,(u8)9u},
    {(u8)6u,(u8)7u,(u8)9u},
    {(u8)6u,(u8)8u,(u8)9u},
    {(u8)6u,(u8)9u,(u8)9u},
    {(u8)6u,(u8)10u,(u8)10u},
    {(u8)6u,(u8)11u,(u8)11u},
    {(u8)6u,(u8)12u,(u8)12u},
    {(u8)6u,(u8)13u,(u8)13u},
    {(u8)7u,(u8)2u,(u8)4u},
    {(u8)7u,(u8)3u,(u8)4u},
    {(u8)7u,(u8)4u,(u8)4u},
    {(u8)7u,(u8)5u,(u8)5u},
    {(u8)7u,(u8)6u,(u8)0u},
    {(u8)7u,(u8)7u,(u8)9u},
    {(u8)7u,(u8)8u,(u8)9u},
    {(u8)7u,(u8)9u,(u8)9u},
    {(u8)7u,(u8)10u,(u8)10u},
    {(u8)7u,(u8)11u,(u8)11u},
    {(u8)7u,(u8)12u,(u8)12u},
    {(u8)7u,(u8)13u,(u8)13u},
    {(u8)8u,(u8)2u,(u8)4u},
    {(u8)8u,(u8)3u,(u8)4u},
    {(u8)8u,(u8)4u,(u8)4u},
    {(u8)8u,(u8)5u,(u8)5u},
    {(u8)8u,(u8)6u,(u8)9u},
    {(u8)8u,(u8)7u,(u8)9u},
    {(u8)8u,(u8)8u,(u8)9u},
    {(u8)8u,(u8)9u,(u8)9u},
    {(u8)8u,(u8)10u,(u8)10u},
    {(u8)8u,(u8)11u,(u8)11u},
    {(u8)8u,(u8)12u,(u8)12u},
    {(u8)8u,(u8)13u,(u8)13u},
    {(u8)9u,(u8)2u,(u8)4u},
    {(u8)9u,(u8)3u,(u8)4u},
    {(u8)9u,(u8)4u,(u8)9u},
    {(u8)9u,(u8)5u,(u8)5u},
    {(u8)9u,(u8)6u,(u8)9u},
    {(u8)9u,(u8)7u,(u8)9u},
    {(u8)9u,(u8)8u,(u8)9u},
    {(u8)9u,(u8)9u,(u8)9u},
    {(u8)9u,(u8)10u,(u8)10u},
    {(u8)9u,(u8)11u,(u8)11u},
    {(u8)9u,(u8)12u,(u8)12u},
    {(u8)9u,(u8)13u,(u8)13u},
    {(u8)10u,(u8)2u,(u8)10u},
    {(u8)10u,(u8)3u,(u8)10u},
    {(u8)10u,(u8)4u,(u8)10u},
    {(u8)10u,(u8)5u,(u8)10u},
    {(u8)10u,(u8)6u,(u8)10u},
    {(u8)10u,(u8)7u,(u8)10u},
    {(u8)10u,(u8)8u,(u8)10u},
    {(u8)10u,(u8)9u,(u8)10u},
    {(u8)10u,(u8)10u,(u8)10u},
    {(u8)10u,(u8)11u,(u8)11u},
    {(u8)10u,(u8)12u,(u8)12u},
    {(u8)10u,(u8)13u,(u8)13u},
    {(u8)11u,(u8)2u,(u8)12u},
    {(u8)11u,(u8)3u,(u8)12u},
    {(u8)11u,(u8)4u,(u8)12u},
    {(u8)11u,(u8)5u,(u8)12u},
    {(u8)11u,(u8)6u,(u8)12u},
    {(u8)11u,(u8)7u,(u8)12u},
    {(u8)11u,(u8)8u,(u8)12u},
    {(u8)11u,(u8)9u,(u8)12u},
    {(u8)11u,(u8)10u,(u8)12u},
    {(u8)11u,(u8)11u,(u8)11u},
    {(u8)11u,(u8)12u,(u8)12u},
    {(u8)11u,(u8)13u,(u8)13u},
    {(u8)12u,(u8)2u,(u8)12u},
    {(u8)12u,(u8)3u,(u8)12u},
    {(u8)12u,(u8)4u,(u8)12u},
    {(u8)12u,(u8)5u,(u8)12u},
    {(u8)12u,(u8)6u,(u8)12u},
    {(u8)12u,(u8)7u,(u8)12u},
    {(u8)12u,(u8)8u,(u8)12u},
    {(u8)12u,(u8)9u,(u8)12u},
    {(u8)12u,(u8)10u,(u8)12u},
    {(u8)12u,(u8)11u,(u8)12u},
    {(u8)12u,(u8)12u,(u8)12u},
    {(u8)12u,(u8)13u,(u8)13u},
    {(u8)13u,(u8)2u,(u8)12u},
    {(u8)13u,(u8)3u,(u8)12u},
    {(u8)13u,(u8)4u,(u8)12u},
    {(u8)13u,(u8)5u,(u8)12u},
    {(u8)13u,(u8)6u,(u8)12u},
    {(u8)13u,(u8)7u,(u8)12u},
    {(u8)13u,(u8)8u,(u8)12u},
    {(u8)13u,(u8)9u,(u8)12u},
    {(u8)13u,(u8)10u,(u8)12u},
    {(u8)13u,(u8)11u,(u8)12u},
    {(u8)13u,(u8)12u,(u8)12u},
    {(u8)13u,(u8)13u,(u8)13u}
};
byte cc_tables_convsetuptable[144][3] = {
    {(u8)2u,(u8)2u,(u8)3u},
    {(u8)2u,(u8)3u,(u8)3u},
    {(u8)2u,(u8)4u,(u8)3u},
    {(u8)2u,(u8)5u,(u8)3u},
    {(u8)2u,(u8)6u,(u8)13u},
    {(u8)2u,(u8)7u,(u8)1u},
    {(u8)2u,(u8)8u,(u8)3u},
    {(u8)2u,(u8)9u,(u8)3u},
    {(u8)2u,(u8)10u,(u8)3u},
    {(u8)2u,(u8)11u,(u8)5u},
    {(u8)2u,(u8)12u,(u8)5u},
    {(u8)2u,(u8)13u,(u8)5u},
    {(u8)3u,(u8)2u,(u8)12u},
    {(u8)3u,(u8)3u,(u8)0u},
    {(u8)3u,(u8)4u,(u8)3u},
    {(u8)3u,(u8)5u,(u8)3u},
    {(u8)3u,(u8)6u,(u8)13u},
    {(u8)3u,(u8)7u,(u8)12u},
    {(u8)3u,(u8)8u,(u8)1u},
    {(u8)3u,(u8)9u,(u8)3u},
    {(u8)3u,(u8)10u,(u8)3u},
    {(u8)3u,(u8)11u,(u8)5u},
    {(u8)3u,(u8)12u,(u8)5u},
    {(u8)3u,(u8)13u,(u8)5u},
    {(u8)4u,(u8)2u,(u8)12u},
    {(u8)4u,(u8)3u,(u8)12u},
    {(u8)4u,(u8)4u,(u8)0u},
    {(u8)4u,(u8)5u,(u8)3u},
    {(u8)4u,(u8)6u,(u8)13u},
    {(u8)4u,(u8)7u,(u8)12u},
    {(u8)4u,(u8)8u,(u8)12u},
    {(u8)4u,(u8)9u,(u8)1u},
    {(u8)4u,(u8)10u,(u8)3u},
    {(u8)4u,(u8)11u,(u8)5u},
    {(u8)4u,(u8)12u,(u8)5u},
    {(u8)4u,(u8)13u,(u8)5u},
    {(u8)5u,(u8)2u,(u8)12u},
    {(u8)5u,(u8)3u,(u8)12u},
    {(u8)5u,(u8)4u,(u8)12u},
    {(u8)5u,(u8)5u,(u8)0u},
    {(u8)5u,(u8)6u,(u8)13u},
    {(u8)5u,(u8)7u,(u8)12u},
    {(u8)5u,(u8)8u,(u8)12u},
    {(u8)5u,(u8)9u,(u8)12u},
    {(u8)5u,(u8)10u,(u8)1u},
    {(u8)5u,(u8)11u,(u8)5u},
    {(u8)5u,(u8)12u,(u8)5u},
    {(u8)5u,(u8)13u,(u8)5u},
    {(u8)6u,(u8)2u,(u8)1u},
    {(u8)6u,(u8)3u,(u8)4u},
    {(u8)6u,(u8)4u,(u8)4u},
    {(u8)6u,(u8)5u,(u8)4u},
    {(u8)6u,(u8)6u,(u8)0u},
    {(u8)6u,(u8)7u,(u8)1u},
    {(u8)6u,(u8)8u,(u8)4u},
    {(u8)6u,(u8)9u,(u8)4u},
    {(u8)6u,(u8)10u,(u8)4u},
    {(u8)6u,(u8)11u,(u8)6u},
    {(u8)6u,(u8)12u,(u8)6u},
    {(u8)6u,(u8)13u,(u8)6u},
    {(u8)7u,(u8)2u,(u8)1u},
    {(u8)7u,(u8)3u,(u8)4u},
    {(u8)7u,(u8)4u,(u8)4u},
    {(u8)7u,(u8)5u,(u8)4u},
    {(u8)7u,(u8)6u,(u8)13u},
    {(u8)7u,(u8)7u,(u8)1u},
    {(u8)7u,(u8)8u,(u8)4u},
    {(u8)7u,(u8)9u,(u8)4u},
    {(u8)7u,(u8)10u,(u8)4u},
    {(u8)7u,(u8)11u,(u8)6u},
    {(u8)7u,(u8)12u,(u8)6u},
    {(u8)7u,(u8)13u,(u8)6u},
    {(u8)8u,(u8)2u,(u8)12u},
    {(u8)8u,(u8)3u,(u8)1u},
    {(u8)8u,(u8)4u,(u8)4u},
    {(u8)8u,(u8)5u,(u8)4u},
    {(u8)8u,(u8)6u,(u8)13u},
    {(u8)8u,(u8)7u,(u8)12u},
    {(u8)8u,(u8)8u,(u8)0u},
    {(u8)8u,(u8)9u,(u8)4u},
    {(u8)8u,(u8)10u,(u8)4u},
    {(u8)8u,(u8)11u,(u8)6u},
    {(u8)8u,(u8)12u,(u8)6u},
    {(u8)8u,(u8)13u,(u8)6u},
    {(u8)9u,(u8)2u,(u8)12u},
    {(u8)9u,(u8)3u,(u8)12u},
    {(u8)9u,(u8)4u,(u8)1u},
    {(u8)9u,(u8)5u,(u8)4u},
    {(u8)9u,(u8)6u,(u8)13u},
    {(u8)9u,(u8)7u,(u8)12u},
    {(u8)9u,(u8)8u,(u8)12u},
    {(u8)9u,(u8)9u,(u8)0u},
    {(u8)9u,(u8)10u,(u8)4u},
    {(u8)9u,(u8)11u,(u8)6u},
    {(u8)9u,(u8)12u,(u8)6u},
    {(u8)9u,(u8)13u,(u8)6u},
    {(u8)10u,(u8)2u,(u8)12u},
    {(u8)10u,(u8)3u,(u8)12u},
    {(u8)10u,(u8)4u,(u8)12u},
    {(u8)10u,(u8)5u,(u8)1u},
    {(u8)10u,(u8)6u,(u8)13u},
    {(u8)10u,(u8)7u,(u8)12u},
    {(u8)10u,(u8)8u,(u8)12u},
    {(u8)10u,(u8)9u,(u8)12u},
    {(u8)10u,(u8)10u,(u8)0u},
    {(u8)10u,(u8)11u,(u8)6u},
    {(u8)10u,(u8)12u,(u8)6u},
    {(u8)10u,(u8)13u,(u8)6u},
    {(u8)11u,(u8)2u,(u8)7u},
    {(u8)11u,(u8)3u,(u8)7u},
    {(u8)11u,(u8)4u,(u8)7u},
    {(u8)11u,(u8)5u,(u8)7u},
    {(u8)11u,(u8)6u,(u8)8u},
    {(u8)11u,(u8)7u,(u8)8u},
    {(u8)11u,(u8)8u,(u8)8u},
    {(u8)11u,(u8)9u,(u8)8u},
    {(u8)11u,(u8)10u,(u8)8u},
    {(u8)11u,(u8)11u,(u8)0u},
    {(u8)11u,(u8)12u,(u8)9u},
    {(u8)11u,(u8)13u,(u8)9u},
    {(u8)12u,(u8)2u,(u8)7u},
    {(u8)12u,(u8)3u,(u8)7u},
    {(u8)12u,(u8)4u,(u8)7u},
    {(u8)12u,(u8)5u,(u8)7u},
    {(u8)12u,(u8)6u,(u8)8u},
    {(u8)12u,(u8)7u,(u8)8u},
    {(u8)12u,(u8)8u,(u8)8u},
    {(u8)12u,(u8)9u,(u8)8u},
    {(u8)12u,(u8)10u,(u8)8u},
    {(u8)12u,(u8)11u,(u8)10u},
    {(u8)12u,(u8)12u,(u8)0u},
    {(u8)12u,(u8)13u,(u8)0u},
    {(u8)13u,(u8)2u,(u8)7u},
    {(u8)13u,(u8)3u,(u8)7u},
    {(u8)13u,(u8)4u,(u8)7u},
    {(u8)13u,(u8)5u,(u8)7u},
    {(u8)13u,(u8)6u,(u8)8u},
    {(u8)13u,(u8)7u,(u8)8u},
    {(u8)13u,(u8)8u,(u8)8u},
    {(u8)13u,(u8)9u,(u8)8u},
    {(u8)13u,(u8)10u,(u8)8u},
    {(u8)13u,(u8)11u,(u8)10u},
    {(u8)13u,(u8)12u,(u8)0u},
    {(u8)13u,(u8)13u,(u8)0u}
};
i64 cc_tables_badexprs[34] = {
    (i64)1,
    (i64)3,
    (i64)32,
    (i64)25,
    (i64)26,
    (i64)27,
    (i64)28,
    (i64)30,
    (i64)33,
    (i64)34,
    (i64)35,
    (i64)36,
    (i64)37,
    (i64)39,
    (i64)38,
    (i64)40,
    (i64)41,
    (i64)42,
    (i64)43,
    (i64)44,
    (i64)45,
    (i64)46,
    (i64)47,
    (i64)48,
    (i64)49,
    (i64)50,
    (i64)51,
    (i64)52,
    (i64)53,
    (i64)54,
    (i64)55,
    (i64)59,
    (i64)60,
    (i64)61
};
byte cc_support_bytemasks[8] = {(u8)1u,(u8)2u,(u8)4u,(u8)8u,(u8)16u,(u8)32u,(u8)64u,(u8)128u};
static struct cc_decls_tokenrec *  cc_lex_tkptr = 0;
static i64 cc_lex_dowhitespace = (i64)0;
static i64 cc_lex_nincludes;
static struct cc_decls_tokenrec cc_lex_normaltkx;
static struct cc_decls_tokenrec *  cc_lex_normaltk = &cc_lex_normaltkx;
static i64 cc_lex_noexpand = (i64)0;
static struct cc_lex_stackinforec cc_lex_lx_stack[20];
static i64 cc_lex_lx_stackindex;
static i64 cc_lex_ifcondlevel = (i64)0;
static byte *  cc_lex_headerpathlist[20];
static byte cc_lex_headerpath[300];
static byte *  cc_lex_lxstart;
static byte *  cc_lex_lxsptr;
static i64 cc_lex_lxhashvalue;
static byte *  cc_lex_lxsvalue;
static byte cc_lex_alphamap[256];
static byte cc_lex_digitmap[256];
static byte cc_lex_commentmap[256];
static byte cc_lex_linecommentmap[256];
static byte cc_lex_spacemap[256];
static struct mlib_strbuffer *  cc_lex_destcopy;
static byte *  cc_lex_pastedtokenlist[87000];
static i64 cc_lex_npastedtokens = (i64)0;
static i64 cc_lex_isincludefile = (i64)0;
static i64 cc_lex_firstsymbol = (i64)1;
static byte *  cc_lex_reallxsptr;
i64 cc_lex_nhstsymbols;
static i64 cc_lex_hstthreshold;
static i64 cc_lex_lasttoken = (i64)0;
static byte *  cc_headers_bcclibstr = \
(byte*)";\tbcc support library\r\n\r\n;Offsets in buffer:\r\nkreturn\t= 0\r\nkstack\t= 8\r\nkframe\t= 16\r\n\r\n\tsegment code\r\n$mccsetjmp::\r\n\r\n;on entry to setjmp:\r\n;Dstack\t\tpoints to return address\r\n;D10\t\tpoints to address of buffer to store restore info\r\n;Caller will have subtracted 32 from Dstack, and will add it again on return\r\n\r\n; Store current state\r\n\r\n\tmov [D10+kstack],Dstack\r\n\tmov [D10+kframe],Dframe\r\n\tmov D0,[Dstack]\t\t\t; return address\r\n\tmov [D10+kreturn],D0\r\n\r\n\tmov\tA0,0\r\n\tret\r\n\r\n$mcclongjmp::\r\n\r\n;on entry to longjmp:\r\n;Dstack\t\tpoints to return address\r\n;D10\t\tpoints to address of buffer containing store restore info\r\n;D11\t\thas return value to use\r\n;Caller will have subtracted 32 from Dstack, and will add it again on return\r\n\r\n; Restore state as it was on call to setjmp\r\n\r\n\r\n\tmov Dstack,[D10+kstack]\t\t; restore stack value\r\n\tmov Dframe,[D10+kframe]\t\t; restore frame ptr\r\n\r\n\tmov D0,[D10+kreturn]\t\t; stored return address\r\n\tmov [Dstack+0],D0\t\t\t; replace return address, as it will return elsewhere\r\n\tmov A0,A11\t\t\t\t\t; return value (from 'setjmp', as it will be)\r\n\r\n\tret\r\n\r\n;Float routines for unsigned\r\n;Input passed in D10\r\n;Output in XMM15\r\n\r\nm$ufloat_r64u32::\r\n\tmov D10,D10\t\t\t\t\t; clear top half (already done if value just moved there)\r\n\tcvtsi2sd XMM15,D10\r\n\tret\r\n\r\nm$ufloat_r32u32::\r\n\tmov D10,D10\r\n\tcvtsi2ss XMM15,D10\r\n\tret\r\n\r\nm$ufloat_r64u64::\r\n\tcmp D10,0\r\n\tjl fl1\r\n;number is positive, so can treat like i64\r\n\tcvtsi2sd XMM15,D10\r\n\tret\r\nfl1:\t\t\t\t\t\t;negative value\r\n\tand D10,[mask63]\t\t;clear top bit (subtract 2**63)\r\n\tcvtsi2sd XMM15,D10\r\n\taddsd XMM15,[offset64]\t;(add 2**63 back to result)\r\n\tret\r\n\r\nm$ufloat_r32u64::\r\n\tcmp D10,0\r\n\tjl fl2\r\n;number is positive, so can treat like i64\r\n\tcvtsi2ss XMM15,D10\r\n\tret\r\nfl2:\t\t\t\t\t\t;negative value\r\n\tand D10,[mask63]\t\t;clear top bit (subtract 2**63)\r\n\tcvtsi2ss XMM15,D10\r\n\taddss XMM15,[offset32]\t;(add 2**63 back to result)\r\n\tret\r\n\r\n\tsegment idata\r\nmask63:\r\n\tdq 0x7fffffffffffffff\r\noffset64:\r\n\tdq 9223372036854775808.0\t\t! 2**63 as r64\r\noffset32:\r\n\tdd 9223372036854775808.0\t\t; 2**63 as r32\r\n\r\n\tsegment code\r\n__rdtsc::\r\n!\trdtsc\r\n\tmov eax,eax\r\n\tshl rdx,32\r\n\tor rax,rdx\r\n\tret\r\n\r\n\tsegment zdata\r\ncallbackstack:\r\n\tresb 576\t\t\t!8-level stack\r\n;\tresb 5'120'000\r\n\r\nncallbacks:\r\n\tresb 4\r\n\r\nsegment code\r\n\r\nm$pushcallback::\r\n\tinc dword [ncallbacks]\r\n\tmov A2,[ncallbacks]\r\n\tshl A2,6\t\t\t\t\t!8x8 bytes is size per entry\r\n\tlea D2,[A2+callbackstack]\r\n\r\n\tmov [D2],rbx\r\n\tmov [D2+8],rsi\r\n\tmov [D2+16],rdi\r\n\r\n\tmov [D2+24],r12\r\n\tmov [D2+32],r13\r\n\tmov [D2+40],r14\r\n\tmov [D2+48],r15\r\n\tret\r\n\r\nm$popcallback::\r\n\tmov A2,[ncallbacks]\r\n\tshl A2,6\t\t\t\t\t!8x8 bytes is size per entry\r\n\tlea D2,[A2+callbackstack]\r\n\r\n\tmov rbx,[D2]\r\n\tmov rsi,[D2+8]\r\n\tmov rdi,[D2+16]\r\n\r\n\tmov r12,[D2+24]\r\n\tmov r13,[D2+32]\r\n\tmov r14,[D2+40]\r\n\tmov r15,[D2+48]\r\n\tdec dword [ncallbacks]\r\n\tret\r\n\r\n\r\n";
static byte *  cc_headers_h_assert = (byte*)"/* Header assert.h */\r\n\r\n//#define assert(x) 0\r\n#define assert(x)\r\n";
static byte *  cc_headers_h_ctype = (byte*)"/* Header ctype.h */\r\n\r\nint tolower(int);\r\nint toupper(int);\r\nint isalpha(int);\r\nint isdigit(int);\r\nint isspace(int);\r\nint isalnum(int);\r\nint isupper(int);\r\nint islower(int);\r\n\r\nint isxdigit(int);\r\nint iscntrl(int);\r\nint isgraph(int);\r\nint ispunct(int);\r\nint isprint(int);\r\nint __isascii(int);\r\n#define isascii __isascii\r\n\r\nint __toascii(int);\r\n#define toascii __toascii\r\n";
static byte *  cc_headers_h_errno = (byte*)"/* Header errno.h */\r\n\r\n#ifndef $errno\r\n#define $errno\r\n\r\nextern int* _errno(void);\r\n#define errno (*_errno())\r\n\r\n#define EPERM 1\r\n#define ENOENT 2\r\n#define ESRCH 3\r\n#define EINTR 4\r\n#define EIO 5\r\n#define ENXIO 6\r\n#define E2BIG 7\r\n#define ENOEXEC 8\r\n#define EBADF 9\r\n#define ECHILD 10\r\n#define EAGAIN 11\r\n#define ENOMEM 12\r\n#define EACCES 13\r\n#define EFAULT 14\r\n#define ENOTBLK 15\r\n#define EBUSY 16\r\n#define EEXIST 17\r\n#define EXDEV 18\r\n#define ENODEV 19\r\n#define ENOTDIR 20\r\n#define EISDIR 21\r\n#define EINVAL 22\r\n#define ENFILE 23\r\n#define EMFILE 24\r\n#define ENOTTY 25\r\n#define ETXTBSY 26\r\n#define EFBIG 27\r\n#define ENOSPC 28\r\n#define ESPIPE 29\r\n#define EROFS 30\r\n#define EMLINK 31\r\n#define EPIPE 32\r\n#define EDOM 33\r\n#define ERANGE 34\r\n#define ENOMSG 35\r\n#define EIDRM 36\r\n#define ECHRNG 37\r\n#define EL2NSYNC 38\r\n#define EL3HLT 39\r\n#define EL3RST 40\r\n#define ELNRNG 41\r\n#define EUNATCH 42\r\n#define ENOCSI 43\r\n#define EL2HLT 44\r\n#define EDEADLK 45\r\n#define ENOLCK 46\r\n#define EBADE 50\r\n#define EBADR 51\r\n#define EXFULL 52\r\n#define ENOANO 53\r\n#define EBADRQC 54\r\n#define EBADSLT 55\r\n#define EDEADLOCK 56\r\n#define EBFONT 57\r\n#define ENOSTR 60\r\n#define ENODATA 61\r\n#define ETIME 62\r\n#define ENOSR 63\r\n#define ENONET 64\r\n#define ENOPKG 65\r\n#define EREMOTE 66\r\n#define ENOLINK 67\r\n#define EADV 68\r\n#define ESRMNT 69\r\n#define ECOMM 70\r\n#define EPROTO 71\r\n#define EMULTIHOP 74\r\n#define ELBIN 75\r\n#define EOVERFLOW 76\r\n#define EBADMSG 77\r\n#define ENOTUNIQ 80\r\n#define EBADFD 81\r\n#define EREMCHG 82\r\n#define ELIBACC 83\r\n#define ELIBBAD 84\r\n#define ELIBSCN 85\r\n#define ELIBMAX 86\r\n#define ELIBEXEC 87\r\n#define ENOSYS 88\r\n#define ENMFILE 89\r\n#define ENOTEMPTY 90\r\n#define ENAMETOOLONG 91\r\n#define EILSEQ 92\r\n#define __ELASTERROR 2000\r\n\r\n#endif\r\n";
static byte *  cc_headers_h_fenv = (byte*)"/* Header fenv.h */\r\n\r\nint feclearexcept(int);\r\nint fetestexcept(int);\r\n\r\n#define FE_INVALID 1\r\n#define FE_DENORMAL 2\r\n#define FE_INEXACT 32\r\n#define FE_DIVBYZERO 4 \r\n#define FE_OVERFLOW 8\r\n#define FE_UNDERFLOW 16\r\n#define FE_STACKFAULT 64\r\n#define FE_ALL_EXCEPT (FE_INVALID|FE_DENORMAL|FE_INEXACT|FE_DIVBYZERO|FE_OVERFLOW|FE_UNDERFLOW)\r\n";
static byte *  cc_headers_h_float = (byte*)"/* Header float.h */\r\n\r\n//#define DBL_MAX_10_EXP 308\r\n//#define DBL_MANT_DIG 53\r\n\r\n#define FLT_RADIX 2\r\n\r\n#define FLT_DIG 6\r\n#define FLT_MIN_EXP -125\r\n#define FLT_MIN 1.17549435E-38F // decimal constant\r\n#define FLT_MIN 0X1P-126F // hex constant\r\n#define FLT_TRUE_MIN 1.40129846E-45F // decimal constant\r\n#define FLT_TRUE_MIN 0X1P-149F // hex constant\r\n#define FLT_HAS_SUBNORM 1\r\n#define FLT_MIN_10_EXP -37\r\n#define FLT_MAX_EXP +128\r\n#define FLT_MAX 3.40282347E+38F // decimal constant\r\n#define FLT_MAX 0X1.fffffeP127F // hex constant\r\n#define FLT_MAX_10_EXP +38\r\n#define FLT_EPSILON 1.19209290e-07F\r\n#define FLT_MANT_DIG 23\r\n\r\n#define DBL_MANT_DIG 53\r\n#define DBL_EPSILON 2.2204460492503131E-16 // decimal constant\r\n//#define DBL_EPSILON 0X1P-52 // hex constant\r\n#define DBL_DECIMAL_DIG 17\r\n#define DBL_DIG 15\r\n#define DBL_MIN_EXP -1021\r\n#define DBL_MIN 2.2250738585072014E-308 // decimal constant\r\n//#define DBL_MIN 0X1P-1022 // hex constant\r\n#define DBL_TRUE_MIN 4.9406564584124654E-324 // decimal constant\r\n//#define DBL_TRUE_MIN 0X1P-1074 // hex constant\r\n#define DBL_HAS_SUBNORM 1\r\n#define DBL_MIN_10_EXP -307\r\n#define DBL_MAX_EXP +1024\r\n#define DBL_MAX 1.7976931348623157E+308 // decimal constant\r\n//#define DBL_MAX 0X1.fffffffffffffP1023 // h\r\n#define DBL_MAX_10_EXP +308\r\n\r\n#define LDBL_MIN DBL_MIN\r\n#define LDBL_MAX DBL_MAX\r\n#define LDBL_EPSILON 2.2204460492503131E-16\r\n#define LDBL_MANT_DIG 53\r\n#define LDBL_MIN_EXP -1021\r\n#define LDBL_MAX_EXP +1024\r\n\r\nint     _isnan(double);\r\n#define isnan _isnan\r\n";
static byte *  cc_headers_h_inttypes = (byte*)"/* Header inttypes.h */\r\n\r\n#include <stdint.h>\r\n\r\n/* fprintf macros for signed types */\r\n#define PRId8 \"d\"\r\n#define PRId16 \"d\"\r\n#define PRId32 \"d\"\r\n#define PRId64 \"I64d\"\r\n\r\n#define PRIdLEAST8 \"d\"\r\n#define PRIdLEAST16 \"d\"\r\n#define PRIdLEAST32 \"d\"\r\n#define PRIdLEAST64 \"I64d\"\r\n\r\n#define PRIdFAST8 \"d\"\r\n#define PRIdFAST16 \"d\"\r\n#define PRIdFAST32 \"d\"\r\n#define PRIdFAST64 \"I64d\"\r\n\r\n#define PRIdMAX \"I64d\"\r\n\r\n#define PRIi8 \"i\"\r\n#define PRIi16 \"i\"\r\n#define PRIi32 \"i\"\r\n#define PRIi64 \"I64i\"\r\n\r\n#define PRIiLEAST8 \"i\"\r\n#define PRIiLEAST16 \"i\"\r\n#define PRIiLEAST32 \"i\"\r\n#define PRIiLEAST64 \"I64i\"\r\n\r\n#define PRIiFAST8 \"i\"\r\n#define PRIiFAST16 \"i\"\r\n#define PRIiFAST32 \"i\"\r\n#define PRIiFAST64 \"I64i\"\r\n\r\n#define PRIiMAX \"I64i\"\r\n\r\n#define PRIo8 \"o\"\r\n#define PRIo16 \"o\"\r\n#define PRIo32 \"o\"\r\n#define PRIo64 \"I64o\"\r\n\r\n#define PRIoLEAST8 \"o\"\r\n#define PRIoLEAST16 \"o\"\r\n#define PRIoLEAST32 \"o\"\r\n#define PRIoLEAST64 \"I64o\"\r\n\r\n#define PRIoFAST8 \"o\"\r\n#define PRIoFAST16 \"o\"\r\n#define PRIoFAST32 \"o\"\r\n#define PRIoFAST64 \"I64o\"\r\n\r\n#define PRIoMAX \"I64o\"\r\n\r\n/* fprintf macros for unsigned types */\r\n#define PRIu8 \"u\"\r\n#define PRIu16 \"u\"\r\n#define PRIu32 \"u\"\r\n#define PRIu64 \"I64u\"\r\n\r\n\r\n#define PRIuLEAST8 \"u\"\r\n#define PRIuLEAST16 \"u\"\r\n#define PRIuLEAST32 \"u\"\r\n#define PRIuLEAST64 \"I64u\"\r\n\r\n#define PRIuFAST8 \"u\"\r\n#define PRIuFAST16 \"u\"\r\n#define PRIuFAST32 \"u\"\r\n#define PRIuFAST64 \"I64u\"\r\n\r\n#define PRIuMAX \"I64u\"\r\n\r\n#define PRIx8 \"x\"\r\n#define PRIx16 \"x\"\r\n#define PRIx32 \"x\"\r\n#define PRIx64 \"I64x\"\r\n\r\n#define PRIxLEAST8 \"x\"\r\n#define PRIxLEAST16 \"x\"\r\n#define PRIxLEAST32 \"x\"\r\n#define PRIxLEAST64 \"I64x\"\r\n\r\n#define PRIxFAST8 \"x\"\r\n#define PRIxFAST16 \"x\"\r\n#define PRIxFAST32 \"x\"\r\n#define PRIxFAST64 \"I64x\"\r\n\r\n#define PRIxMAX \"I64x\"\r\n\r\n#define PRIX8 \"X\"\r\n#define PRIX16 \"X\"\r\n#define PRIX32 \"X\"\r\n#define PRIX64 \"I64X\"\r\n\r\n#define PRIXLEAST8 \"X\"\r\n#define PRIXLEAST16 \"X\"\r\n#define PRIXLEAST32 \"X\"\r\n#define PRIXLEAST64 \"I64X\"\r\n\r\n#define PRIXFAST8 \"X\"\r\n#define PRIXFAST16 \"X\"\r\n#define PRIXFAST32 \"X\"\r\n#define PRIXFAST64 \"I64X\"\r\n\r\n#define PRIXMAX \"I64X\"\r\n\r\n";
static byte *  cc_headers_h_stdint = (byte*)"/* Header stdint.h */\r\n\r\n#ifndef $stdint\r\n#define $stdint\r\n\r\ntypedef signed char int8_t;\r\ntypedef short int16_t;\r\ntypedef int int32_t;\r\ntypedef long long int int64_t;\r\n\r\ntypedef unsigned char uint8_t;\r\ntypedef unsigned short uint16_t;\r\ntypedef unsigned int uint32_t;\r\ntypedef unsigned long long int uint64_t;\r\n\r\ntypedef long long int intptr_t;\r\ntypedef unsigned long long int uintptr_t;\r\ntypedef long long intmax_t;\r\ntypedef unsigned long long uintmax_t;\r\n\r\n#define INT8_MIN -128\r\n#define INT8_MAX 127\r\n#define INT16_MIN -32768\r\n#define INT16_MAX 32767\r\n#define INT32_MIN 0x80000000\r\n#define INT32_MAX 0x7FFFFFFF\r\n#define INT64_MIN 0x8000000000000000\r\n#define INT64_MAX 0x7FFFFFFFFFFFFFFF\r\n\r\n#define UINT8_MAX 255\r\n#define UINT16_MAX 65535\r\n#define UINT32_MAX 0xFFFFFFFF\r\n#define UINT64_MAX 0xFFFFFFFFFFFFFFFF\r\n\r\n#define INTPTR_MIN 0x8000000000000000\r\n#define INTPTR_MAX 0x7FFFFFFFFFFFFFFF\r\n#define UINTPTR_MAX 0xFFFFFFFFFFFFFFFF\r\n\r\n#define UINT64_MAX 0xFFFFFFFFFFFFFFFF\r\n#define SIZE_MAX 0xFFFFFFFFFFFFFFFF\r\n\r\n#define PTRDIFF_MIN 0x8000000000000000\r\n#define PTRDIFF_MAX 0x7FFFFFFFFFFFFFFF\r\n\r\n#define WCHAR_MIN 0\r\n#define WCHAR_MAX 65535\r\n\r\n#define WINT_MIN 0\r\n#define WINT_MAX 65535\r\n\r\n#define UINT64_C(x) (x##ull)\r\n\r\n#endif\r\n";
static byte *  cc_headers_h_limits = (byte*)"/* Header limits.h */\r\n\r\n#define CHAR_BIT 8\r\n\r\n#define CHAR_MIN 0\r\n#define CHAR_MAX 255\r\n\r\n#define UCHAR_MIN 0\r\n#define UCHAR_MAX 255\r\n\r\n#define SCHAR_MIN -128\r\n#define SCHAR_MAX 127\r\n\r\n#define SHRT_MIN -32768\r\n#define SHRT_MAX 32767\r\n\r\n#define USHRT_MIN 0\r\n#define USHRT_MAX 65536\r\n\r\n#define INT_MIN -2147483648\r\n#define INT_MAX  2147483647\r\n\r\n#define UINT_MIN 0\r\n#define UINT_MAX 4294967295\r\n\r\n#define LONG_MIN -2147483648\r\n#define LONG_MAX  2147483647\r\n\r\n#define ULONG_MIN 0\r\n#define ULONG_MAX 4294967295\r\n\r\n#define LLONG_MIN -9223372036854775808LL\r\n#define LLONG_MAX  9223372036854775807LL\r\n\r\n#define ULLONG_MIN 0\r\n#define ULLONG_MAX 0xFFFFFFFFFFFFFFFFLL\r\n";
static byte *  cc_headers_h_locale = (byte*)"/* Header locale.h */\r\n\r\n#ifndef $locale\r\n#define $locale\r\n\r\n#define LC_ALL 0\r\n#define LC_COLLATE 1\r\n#define LC_CTYPE 2\r\n#define LC_MONETARY 3\r\n#define LC_NUMERIC 4\r\n#define LC_TIME 5\r\n\r\nstruct lconv {\r\n\tchar *decimal_point;\r\n\tchar *thousands_sep;\r\n\tchar *grouping;\r\n\tchar *int_curr_symbol;\r\n\tchar *currency_symbol;\r\n\tchar *mon_decimal_point;\r\n\tchar *mon_thousands_sep;\r\n\tchar *mon_grouping;\r\n\tchar *positive_sign;\r\n\tchar *negative_sign;\r\n\tchar int_frac_digits;\r\n\tchar frac_digits;\r\n\tchar p_cs_precedes;\r\n\tchar p_sep_by_space;\r\n\tchar n_cs_precedes;\r\n\tchar n_sep_by_space;\r\n\tchar p_sign_posn;\r\n\tchar n_sign_posn;\r\n};\r\nchar *setlocale(int category, const char *locale);\r\n\r\nstruct lconv *localeconv(void);\r\n\r\nchar * setlocale(int,const char *);\r\n#endif\r\n";
static byte *  cc_headers_h__ansi = (byte*)"/* Header _ansi.h */\r\n";
static byte *  cc_headers_h_math = \
(byte*)"/* Header math.h */\r\n\r\n#define HUGE_VAL 1.7976931348623156e+308\r\n\r\ndouble floor(double);\r\ndouble ceil(double);\r\ndouble sqrt(double);\r\ndouble sin(double);\r\ndouble cos(double);\r\ndouble tan(double);\r\ndouble fmod(double,double);\r\ndouble asin(double);\r\ndouble acos(double);\r\ndouble atan(double);\r\ndouble log(double);\r\ndouble log10(double);\r\ndouble exp(double);\r\ndouble modf(double,double*);\r\ndouble atan2(double,double);\r\ndouble pow(double,double);\r\ndouble fabs(double);\r\ndouble sinh(double);\r\ndouble cosh(double);\r\ndouble tanh(double);\r\ndouble frexp(double,int*);\r\ndouble ldexp(double,int);\r\nint isnan(double);\r\n\r\nfloat sinf(float);\r\nfloat cosf(float);\r\nfloat tanf(float);\r\n\r\nfloat sqrtf(float);\r\nfloat acosf(float);\r\nfloat atan2f(float,float);\r\nfloat ceilf(float);\r\n\r\ndouble acosh (double);\r\nlong double acoshl(long double);\r\nlong double acoshl(long double);\r\nfloat acoshf(float);\r\n\r\ndouble asinh (double);\r\nlong double asinhl(long double);\r\nlong double sinhl(long double);\r\nfloat asinhf(float);\r\n\r\ndouble atanh(double);\r\nlong double atanhl(long double);\r\nfloat atanhf(float);\r\n\r\nlong double expm1l(long double);\r\ndouble expm1(double);\r\nfloat expm1f(float);\r\ndouble _expm1i(int);\r\n\r\ndouble cbrt(double);\r\nlong double cbrtl(long double);\r\nfloat cbrtf(float);\r\n\r\ndouble trunc(double x);\r\nlong double truncl(long double);\r\nfloat truncf(float);\r\n\r\ndouble round(double);\r\nfloat roundf(float);\r\nlong double roundl(long double);\r\ndouble _roundi(int);\r\n\r\nlong double fminl(long double,long double);\r\nfloat fminf(float ,float);\r\ndouble fmin(double,double);\r\nfloat fabsf(float);\r\n\r\ndouble lgamma (double);\r\nlong double lgammal(long double);\r\nfloat lgammaf(float);\r\n\r\nlong double tgammal(long double);\r\ndouble tgamma(double);\r\nfloat tgammaf(float);\r\n\r\ndouble log1p(double);\r\nlong double log1pl(long double);\r\nfloat log1pf(float);\r\n\r\nlong double log10l(long double);\r\nfloat log10f(float);\r\ndouble _log10i(int);\r\ndouble log10(double);\r\n\r\ndouble erf(double);\r\nlong double erfl(long double);\r\nfloat erff(float);\r\n\r\ndouble hypot (double, double);\r\ndouble _hypot(double,double);\r\nlong double hypotl(long double,long double);\r\nfloat hypotf(float,float);\r\n\r\ndouble nextafter (double, double);\r\nlong double nextafterl(long double,long double);\r\nfloat nextafterf(float,float);\r\n\r\ndouble nexttoward(double,long double);\r\nlong double nexttowardl(long double,long double);\r\nfloat nexttowardf(float,long double);\r\n\r\ndouble erfc(double);\r\nlong double erfcl(long double);\r\nfloat erfcf(float);\r\n\r\nint _finite(double);\r\n#define finite _finite\r\n\r\nfloat floorf(float);\r\n\r\ndouble _copysign(double,double);\r\n#define copysign _copysign\r\n\r\nlong double fmaxl(long double,long double);\r\ndouble fmax(double,double);\r\nfloat fmaxf(float,float);\r\nfloat fmodf(float,float);\r\n\r\n//long double exp2l(long double);\r\ndouble exp2(double);\r\nfloat exp2f(float);\r\n\r\n//double log2(double);\r\n#define log2(x) (log(x)*1.442695041)\r\n\r\n#define M_PI 3.1415926535897932384625433\r\n#define M_PI_2 (M_PI/2.0)\r\n#define M_2_PI 0.63661977236758134308\r\n\r\nint isinf(double);\r\n\r\nint _finite(double);\r\n\r\n#define isfinite _finite\r\n\r\nint isfinitef(float);\r\nint isfinitel(long double);\r\n\r\n";
static byte *  cc_headers_h_setjmp = (byte*)"/* Header setjmp.h */\r\n\r\n\r\n#ifndef $setjmp\r\n#define $setjmp 1\r\n\r\ntypedef int jmp_buf[128];\r\n\r\n//void longjmp(char*, int);\r\n\r\n//void $mcclongjmp(char*, int);\r\nvoid $mcclongjmp(jmp_buf, int);\r\n\r\n//int $mccsetjmp(char*);\r\nint $mccsetjmp(jmp_buf);\r\n\r\n\r\n//int\t_setjmp(char*);\r\n//int\tsetjmp(char*);\r\n\r\n#define setjmp $mccsetjmp\r\n#define longjmp $mcclongjmp\r\n\r\n#endif\r\n\r\n";
static byte *  cc_headers_h_signal = (byte*)"/* Header signal.h */\r\n\r\n#define SIGINT    2\r\n#define SIGILL    4\r\n#define SIGFPE    8\r\n#define SIGSEGV  11\r\n#define SIGTERM  15\r\n#define SIGBREAK 21\r\n#define SIGABRT  22\r\n\r\n#define SIG_DFL (void (*)(int))0\r\n#define SIG_IGN (void (*)(int))1\r\n#define SIG_SGE (void (*)(int))3\r\n#define SIG_ACK (void (*)(int))4\r\n\r\n#define SIG_ERR (void (*)(int))-1\r\n\r\nextern void (*signal(int, void (*)(int)))(int);\r\n\r\nextern int raise(int);\r\n\r\n\r\ntypedef int sig_atomic_t;\r\n";
static byte *  cc_headers_h_stdarg = (byte*)"/* Header stdarg.h */\r\n\r\n#ifndef $STDARG\r\n #define $STDARG\r\n\r\n//coded for x64 target as used by mcc (with first four params also on stack)\r\n\r\n typedef char *\tva_list;\r\n #define va_start(ap,v) ap=((va_list)&v+8)\r\n #define va_arg(ap,t) *(t*)((ap+=8)-8)\r\n #define va_copy(dest,src) (dest=src)\r\n #define va_end(ap)\t( ap = (va_list)0 )\r\n#endif\r\n";
static byte *  cc_headers_h_stdbool = (byte*)"/* Header stdbool.h */\r\n\r\n#define bool unsigned char\r\n#define true 1\r\n#define false 0\r\n\r\n\r\n";
static byte *  cc_headers_h_stddef = (byte*)"/* Header stddef.h */\r\n\r\n#ifndef $stddef\r\n#define $stddef\r\n\r\ntypedef signed long long int ssize_t;\r\ntypedef unsigned long long int size_t;\r\n\r\n#define _WCHAR_T_DEFINED\r\ntypedef unsigned short wchar_t;\r\n//typedef signed short wchar_t;\r\n\r\n#define NULL ((void*)0)\r\n\r\n#define offsetof(a,b) (size_t) &( ((a*)0) -> b)\r\n\r\ntypedef long long int ptrdiff_t;\r\n\r\n#endif // stddef\r\n";
static byte *  cc_headers_h_stdio = \
(byte*)"/* Header stdio.h */\r\n\r\n#ifndef $stdio\r\n#define $stdio 1\r\n\r\n#define __attribute__(x)\r\n\r\n//#message \"STDIO included\"\r\n\r\n#ifndef $valist\r\n\ttypedef char* va_list;\r\n\t#define $valist\r\n#endif\r\n\r\n#include <stddef.h>\r\n\r\ntypedef long long int fpos_t;\r\n\r\n#define SEEK_SET 0\r\n#define SEEK_CUR 1\r\n#define SEEK_END 2\r\n\r\n#define\tSTDIN_FILENO\t0\r\n#define\tSTDOUT_FILENO\t1\r\n#define\tSTDERR_FILENO\t2\r\n\r\n#define EOF (-1)\r\n#define FILENAME_MAX 260\r\n\r\n#define L_tmpnam 10\r\n\r\ntypedef struct {\r\n\tchar *_ptr;\r\n\tint   _cnt;\r\n\tchar *_base;\r\n\tint   _flag;\r\n\tint   _file;\r\n\tint   _charbuf;\r\n\tint   _bufsiz;\r\n\tchar *_tmpfname;\r\n\t} FILE;\r\n\r\n// _iob-based \r\n//extern FILE _iob[];\r\n//#define stdin (&_iob[0])\r\n//#define stdout (&_iob[1])\r\n//#define stderr (&_iob[2])\r\n//\r\n\r\n// __iob_func-based\r\nextern char* __iob_func(void);\r\n\r\n#define stdin ((FILE*)(__iob_func()))\r\n#define stdout ((FILE*)(__iob_func()+sizeof(FILE)))\r\n#define stderr ((FILE*)(__iob_func()+sizeof(FILE)*2))\r\n\r\n#define _IOREAD 0x0001\r\n#define _IOWRT 0x0002\r\n\r\n#define _IOFBF 0x0000\r\n#define _IOLBF 0x0040\r\n#define _IONBF 0x0004\r\n\r\n#define _IOMYBUF 0x0008\r\n#define _IOEOF 0x0010\r\n#define _IOERR 0x0020\r\n#define _IOSTRG 0x0040\r\n#define _IORW 0x0080\r\n\r\n#define BUFSIZ 512\r\n\r\nFILE* fopen(const char*, const char*);\r\nint fclose(FILE*);\r\nlong ftell(FILE*);\r\nlong long int _ftelli64(FILE*);\r\nint fseek(FILE*,long,int);\r\nint _fseeki64(FILE*,long long int,int);\r\n\r\nsize_t fread(void*, size_t, size_t, FILE*);\r\nsize_t fwrite(const void*, size_t, size_t, FILE*);\r\nint remove(const char*);\r\nint rename(const char *,const char *);\r\nFILE* freopen(const char*, const char*, FILE*);\r\nFILE* _wfopen(const wchar_t*,const wchar_t *);\r\n\r\nint printf(const char*, ...);\r\nint sprintf(char*,const char*, ...);\r\nint fprintf(FILE*,const char*, ...);\r\nint sscanf(const char*, const char*, ...);\r\nint scanf(const char*, ...);\r\nint fscanf(FILE *,const char *, ...);\r\nint _snprintf(char *,size_t,const char*,...);\r\n#define snprintf _snprintf\r\nint _vsnprintf(char*, size_t, const char*, va_list);\r\nint vsnprintf(char*,size_t,const char*,va_list);\r\nint vsprintf(char*, const char*, va_list);\r\nint _wremove(const wchar_t*);\r\nint _wrename(const wchar_t*,const wchar_t*);\r\n\r\ntypedef char* va_list;\r\n\r\nint vfprintf(FILE*, const char*, va_list);\r\nint vprintf(const char*, va_list);\r\n\r\nint puts(const char*);\r\nchar* fgets(char*, int, FILE*);\r\nint fputs(const char*, FILE*);\r\nint fgetc(FILE*);\r\nint fputc(int, FILE*);\r\nint ungetc(int, FILE*);\r\nint getchar(void);\r\nint putchar(int);\r\nint fflush(FILE *);\r\nint getc(FILE *);\r\nint putc(int, FILE *);\r\n\r\nint feof(FILE*);\r\nint ferror(FILE*);\r\nvoid clearerr(FILE*);\r\n\r\nint fileno(FILE*);\r\nint _fileno(FILE*);\r\nint setvbuf(FILE*,char*,int,size_t);\r\nFILE* _popen(const char*, const char*);\r\nint _pclose(FILE*);\r\nint _unlink(const char *);\r\n#define unlink _unlink;\r\nFILE* _fdopen(int, const char *);\r\n#define fdopen _fdopen\r\nint fgetpos(FILE*, fpos_t*);\r\nint fsetpos(FILE*, const fpos_t*);\r\nvoid perror(char*);\r\nvoid setbuf(FILE*, char*);\r\n\r\nvoid rewind(FILE*);\r\n\r\nFILE* tmpfile(void);\r\n\r\nchar* tmpnam(char*);\r\nwchar_t getwc(FILE *);\r\n\r\nextern void* _wenviron;\r\n\r\n#endif\r\n\r\n";
static byte *  cc_headers_h_stdlib = (byte*)"/* Header stdlib.h */\r\n\r\n#ifndef $stdlib\r\n#define $stdlib 1\r\n\r\n#include <stddef.h>\r\n\r\n#define EXIT_FAILURE 1\r\n#define EXIT_SUCCESS 0\r\n\r\n#define RAND_MAX 32767\r\n\r\nvoid* malloc(size_t);\r\nvoid* realloc(void*, size_t);\r\nvoid* calloc(size_t, size_t);\r\n\r\nvoid free(void*);\r\n\r\nvoid exit(int);\r\n\r\nint system(const char*);\r\nint _wsystem(const wchar_t*);\r\n\r\nint abs(int);\r\nlong labs(long);\r\nlong long llabs(long);\r\nint rand(void);\r\nvoid srand(unsigned int);\r\nint atoi(const char*);\r\nlong atol(const char*);\r\ndouble atof(const char *);\r\nint\tatexit(void (*)(void));\r\n\r\nvoid qsort(void*, size_t, size_t, int (*)(void*, void*));\r\n\r\ntypedef struct {\r\n\tlong long int quot;\r\n\tlong long int rem;\r\n} lldiv_t;\r\n\r\nlldiv_t lldiv(long long int, long long int);\r\n\r\nchar* getenv(const char*);\r\nwchar_t* _wgetenv(const wchar_t*);\r\nint _wputenv(const wchar_t*);\r\n\r\n\r\ndouble strtod(const char*, char**);\r\n\r\n//float strtof(const char *, char**);\r\n#define strtof strtod\r\n\r\nlong double strtold(const char*, char**);\r\nvoid abort(void);\r\nlong int strtol(const char*, char**, int);\r\n\r\nlong double strtold(const char *,char **);\r\n\r\nlong long int _strtoi64(const char *,char **,int);\r\n#define strtoll _strtoi64\r\n\r\nunsigned long long int _strtoui64(const char *,char **,int);\r\n\r\nunsigned long long int strtoull(const char*, char**, int);\r\nunsigned long strtoul(const char*, char**, int);\r\n\r\nsize_t _msize(void *);\r\n#define msize _msize\r\n\r\nvoid* bsearch(const void *,const void *, size_t, size_t,\r\n\t\tint (*_compar)(const void *,const void *));\r\n\r\n\r\n#endif\r\n";
static byte *  cc_headers_h__syslist = (byte*)"/* Header _syslist.h */\r\n";
static byte *  cc_headers_h_string = (byte*)"/* Header string.h */\r\n\r\n#include <stddef.h>\r\n\r\nvoid* memcpy(void*, const void*, size_t);\r\nvoid* memmove(const void*, const void*, size_t);\r\nvoid* memset(void*, int, size_t);\r\nint memcmp(const void*, const void*, size_t);\r\nvoid* memchr(const void *, int, size_t);\r\n\r\nsize_t strlen(const char*);\r\nchar* strcpy(char*, const char*);\r\nchar* strncpy(char*, const char*, size_t);\r\nchar* strcat(char*, const char*);\r\nint strcmp(const char*, const char*);\r\nint strncmp(const char*, const char*, size_t);\r\nchar* strchr(const char*, int);\r\nchar* strstr(const char*, const char*);\r\nchar* strrchr(const char*, int);\r\nint _stricmp(const char*, const char*);\r\n#define stricmp _stricmp\r\n\r\nint _strnicmp(const char*, const char*, size_t);\r\n#define strnicmp _strnicmp\r\nchar* strncat(char*, const char*, size_t);\r\nchar* strtok(char*, const char*);\r\n\r\nsize_t strcspn(const char*, const char*);\r\nsize_t strspn(const char*, const char*);\r\nint strcoll(const char *, const char *);\r\n\r\nunsigned long strtoul(const char*, char**, int);\r\n\r\nchar* strerror(int);\r\nchar* strpbrk(const char*, const char*);\r\nsize_t strxfrm(char*, const char *, size_t);\r\n\r\nchar* _strupr(char*);\r\nchar* _strlwr(char*);\r\n#define strupr _strupr\r\n#define strlwr _strlwr\r\n\r\nchar*strnupr(char*,size_t);\r\nchar*strnlwr(char*,size_t);\r\nint strtrim(char*);\r\nchar*strrev(char*);\r\n\r\nchar* _strdup(const char*);\r\n#define strdup _strdup\r\n\r\nint _wcsicmp(const wchar_t *,const wchar_t *);\r\n\r\nwchar_t *wcspbrk(const wchar_t*,const wchar_t*);\r\n\r\nsize_t wcslen(const wchar_t*);\r\n";
static byte *  cc_headers_h_time = (byte*)"/* Header time.h */\r\n\r\n#ifndef $time\r\n#define $time\r\n\r\n#include <stddef.h>\r\n\r\ntypedef long clock_t;\r\nclock_t clock(void);\r\n\r\n//typedef long time_t;\r\n#ifndef _TIME_T_DEFINED\r\n#define _TIME_T_DEFINED\r\ntypedef long long int time_t;\r\n#endif\r\n\r\nstruct tm\r\n{\r\n  int\ttm_sec;\r\n  int\ttm_min;\r\n  int\ttm_hour;\r\n  int\ttm_mday;\r\n  int\ttm_mon;\r\n  int\ttm_year;\r\n  int\ttm_wday;\r\n  int\ttm_yday;\r\n  int\ttm_isdst;\r\n};\r\n\r\n//struct tm *localtime(time_t*);\r\nstruct tm* _localtime32(time_t*);\r\n#define localtime _localtime32\r\n\r\ntime_t _time64(time_t *_timer);\r\n#define time _time64\r\n\r\n#define CLOCKS_PER_SEC 1000\r\n\r\nstruct tm *gmtime(const time_t*);\r\nsize_t strftime(char *, size_t, const char *, const struct tm *);\r\ntime_t mktime(struct tm *);\r\ndouble difftime(time_t, time_t);\r\n\r\nchar* asctime(const struct tm*);\r\n//char* ctime(const time_t *_time);\r\nchar* _ctime64(const time_t *_time);\r\n#define ctime _ctime64\r\n\r\n#endif\r\n";
static byte *  cc_headers_h_utime = (byte*)"/* utime.h header */\r\n\r\n#include <sys/utime.h>\r\n";
static byte *  cc_headers_h_unistd = (byte*)"/* unistd.h header */\r\n\r\nunsigned int _sleep(unsigned int);\r\n#define sleep _sleep\r\n\r\n#define alarm(x) {puts(\"ALARM\"); exit(1);}\r\n\r\nint _write(int,void*,unsigned int);\r\n#define write _write\r\n\r\nint _close(int);\r\n#define close _close\r\n";
static byte *  cc_headers_h_safelib = (byte*)"/* Header safelib.h */\r\n";
static byte *  cc_headers_h_wchar = (byte*)"/* Header wchar.h */\r\n\r\n#include <stddef.h>\r\n\r\n\r\n#define _WCHAR_T_DEFINED\r\ntypedef unsigned short wint_t;\r\ntypedef unsigned short wchar_t;\r\n//typedef signed short wchar_t;\r\n\r\nsize_t wcslen(const wchar_t*);\r\nwchar_t* wcscpy(wchar_t*,const wchar_t*);\r\n//wchar_t* _wgetenv(constwchar_t*);\r\nwchar_t* wcstok(wchar_t*,wchar_t*,wchar_t**);\r\nwchar_t* wcstok_s(wchar_t*,wchar_t*,wchar_t**);\r\n\r\nwchar_t* wcschr(wchar_t*,wchar_t);\r\nwchar_t* wcsstr(const wchar_t*,const wchar_t*);\r\n\r\n\r\nint wcscmp(const wchar_t*,const wchar_t*);\r\ntypedef long _off_t;\r\n";
static byte *  cc_headers_h_wctype = (byte*)"/* Header wctype.h */\r\n";
static byte *  cc_headers_h_systypes = (byte*)"/* types.h */\r\n#ifndef $systypes\r\n#define $systypes 1\r\n\r\ntypedef long int off_t;\r\ntypedef long int ino_t;\r\ntypedef unsigned int dev_t;\r\n\r\ntypedef long long time_t;\r\n\r\n#endif\r\n";
static byte *  cc_headers_h_sysstat = \
(byte*)"/* stat.h */\r\n\r\n#ifndef $sysstat\r\n#define $sysstat\r\n\r\n#include <stddef.h>\r\n\r\nstruct _stat {\r\n\tunsigned int\tst_dev;\r\n\tunsigned short\tst_ino;\r\n\tunsigned short\tst_mode;\r\n\tshort\t\t\tst_nlink;\r\n\tshort\t\t\tst_uid;\r\n\tshort\t\t\tst_gid;\r\n\tunsigned long\tst_rdev;\r\n\tunsigned int\tst_size;\r\n\tunsigned long long int\tst_atime;\r\n\tunsigned long long int\tst_mtime;\r\n\tunsigned long long int\tst_ctime;\r\n};\r\n\r\n#define stat _stat\r\n#define _stati64 _stat\r\n\r\n#define _S_IFMT 0xF000\r\n#define _S_IFDIR 0x4000\r\n#define _S_IFCHR 0x2000\r\n#define _S_IFIFO 0x1000\r\n#define _S_IFREG 0x8000\r\n#define _S_IREAD 0x0100\r\n#define _S_IWRITE 0x0080\r\n#define _S_IEXEC 0x0040\r\n\r\n#define S_IFMT 0xF000\r\n#define S_IFDIR 0x4000\r\n#define S_IFCHR 0x2000\r\n#define S_IFIFO 0x1000\r\n#define S_IFREG 0x8000\r\n#define S_IREAD 0x0100\r\n#define S_IWRITE 0x0080\r\n#define S_IEXEC 0x0040\r\n\r\n#define S_ISCHR(nd) (((nd) & S_IFMT) == S_IFCHR)\r\n#define S_ISDIR(nd) (((nd) & S_IFMT) == S_IFDIR)\r\n#define S_ISFIFO(nd) (((nd) & S_IFMT) == S_IFIFO)\r\n#define S_ISREG(nd) (((nd) & S_IFMT) == S_IFREG)\r\n\r\n\r\n#define\t_S_IRWXU\t(_S_IREAD | _S_IWRITE | _S_IEXEC)\r\n#define\t_S_IXUSR\t_S_IEXEC\r\n#define\t_S_IWUSR\t_S_IWRITE\r\n\r\n#define\tS_IRWXU\t\t_S_IRWXU\r\n#define\tS_IXUSR\t\t_S_IXUSR\r\n#define\tS_IWUSR\t\t_S_IWUSR\r\n#define\tS_IRUSR\t\t_S_IRUSR\r\n#define\t_S_IRUSR\t_S_IREAD\r\n\r\n#define S_IRGRP    (S_IRUSR >> 3)\r\n#define S_IWGRP    (S_IWUSR >> 3)\r\n#define S_IXGRP    (S_IXUSR >> 3)\r\n#define S_IRWXG    (S_IRWXU >> 3)\r\n\r\n#define S_IROTH    (S_IRGRP >> 3)\r\n#define S_IWOTH    (S_IWGRP >> 3)\r\n#define S_IXOTH    (S_IXGRP >> 3)\r\n#define S_IRWXO    (S_IRWXG >> 3)\r\n\r\n//#define\tS_ISDIR(m)\t(((m) & S_IFMT) == S_IFDIR)\r\n//#define\tS_ISFIFO(m)\t(((m) & S_IFMT) == S_IFIFO)\r\n//#define\tS_ISCHR(m)\t(((m) & S_IFMT) == S_IFCHR)\r\n#define\tS_IFBLK\t0x3000\t/* Block: Is this ever set under w32? */\r\n#define\tS_ISBLK(m)\t(((m) & S_IFMT) == S_IFBLK)\r\n#define\tS_ISREG(m)\t(((m) & S_IFMT) == S_IFREG)\r\n\r\n\r\n\r\nint stat(const char *, struct stat*);\r\n\r\nint _fstati64(int, struct stat*);\r\n\r\nint fstat(int, struct stat *);\r\n#define _fstat fstat\r\n\r\nint _wstati64(const wchar_t,struct _stati64 *buffer);  \r\n\r\n\r\n\r\n#endif\r\n";
static byte *  cc_headers_h_systimeb = (byte*)"/* timeb.h */\r\n\r\n#ifndef $timeb\r\n#define $timeb\r\n\r\n#include <time.h>\r\n\r\nstruct _timeb {\r\n\ttime_t time;\r\n\tunsigned short millitm;\r\n\tshort timezone;\r\n\tshort dstflag;\r\n};\r\n#define timeb _timeb\r\n\r\nvoid _ftime64(struct _timeb*);\r\n#define _ftime _ftime64\r\n#define ftime _ftime64\r\n\r\n#endif\r\n";
static byte *  cc_headers_h_sysutime = (byte*)"/* sys/utime.h header */\r\n\r\n#ifndef $utime\r\n#define $utime\r\n\r\nstruct _utimbuf {\r\n\tlong actime;\r\n\tlong modtime;\r\n};\r\n\r\n\r\n#endif\r\n";
static byte *  cc_headers_h_memory = (byte*)"#include <malloc.h>\r\n";
static byte *  cc_headers_h_windows = \
(byte*)"#ifndef $windows\r\n#define $windows 1\r\n\r\n#include <stdarg.h>\r\n#include <stddef.h>\r\n\r\n#define NEAR\r\n#define LPTR 64\r\n\r\n#define APIENTRY\r\n#define WAVE_MAPPER 0xFFFFFFFF\r\n#define CALLBACK_FUNCTION 0x30000\r\n\r\n#define IMAGE_NT_SIGNATURE\r\n#define DUMMYUNIONNAME\r\n\r\n#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES 16\r\n//#define IMAGE_SIZEOF_SHORT_NAME 8\r\n\r\n//#define IMAGE_DIRECTORY_ENTRY_BASERELOC 5\r\n\r\n#define IMAGE_DOS_SIGNATURE 0x5A4D\r\n#define IMAGE_OS2_SIGNATURE 0x454E\r\n#define IMAGE_OS2_SIGNATURE_LE 0x454C\r\n#define IMAGE_VXD_SIGNATURE 0x454C\r\n#define IMAGE_NT_SIGNATURE 0x4550\r\n#define IMAGE_SIZEOF_FILE_HEADER 20\r\n#define IMAGE_FILE_RELOCS_STRIPPED 1\r\n#define IMAGE_FILE_EXECUTABLE_IMAGE 2\r\n#define IMAGE_FILE_LINE_NUMS_STRIPPED 4\r\n#define IMAGE_FILE_LOCAL_SYMS_STRIPPED 8\r\n#define IMAGE_FILE_BYTES_REVERSED_LO 128\r\n#define IMAGE_FILE_32BIT_MACHINE 256\r\n#define IMAGE_FILE_DEBUG_STRIPPED 512\r\n#define IMAGE_FILE_SYSTEM 0x1000\r\n#define IMAGE_FILE_DLL 0x2000\r\n#define IMAGE_FILE_BYTES_REVERSED_HI 0x8000\r\n#define IMAGE_FILE_MACHINE_UNKNOWN 0\r\n#define IMAGE_FILE_MACHINE_I386 0x14c\r\n#define IMAGE_FILE_MACHINE_R3000 0x162\r\n#define IMAGE_FILE_MACHINE_R4000 0x166\r\n#define IMAGE_FILE_MACHINE_R10000 0x168\r\n#define IMAGE_FILE_MACHINE_ALPHA 0x184\r\n#define IMAGE_FILE_MACHINE_POWERPC 0x1F0\r\n#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES 16\r\n#define IMAGE_SIZEOF_ROM_OPTIONAL_HEADER 56\r\n#define IMAGE_SIZEOF_STD_OPTIONAL_HEADER 28\r\n#define IMAGE_SIZEOF_NT_OPTIONAL_HEADER 224\r\n#define IMAGE_NT_OPTIONAL_HDR_MAGIC 0x10b\r\n#define IMAGE_ROM_OPTIONAL_HDR_MAGIC 0x107\r\n#define IMAGE_FIRST_SECTION(nth) ((PIMAGE_SECTION_HEADER) \\\r\n ((DWORD)nth + FIELD_OFFSET( IMAGE_NT_HEADERS,OptionalHeader ) + \\\r\n ((PIMAGE_NT_HEADERS)(nth))->FileHeader.SizeOfOptionalHeader))\r\n#define IMAGE_SUBSYSTEM_UNKNOWN 0\r\n#define IMAGE_SUBSYSTEM_NATIVE 1\r\n#define IMAGE_SUBSYSTEM_WINDOWS_GUI 2\r\n#define IMAGE_SUBSYSTEM_WINDOWS_CUI 3\r\n#define IMAGE_SUBSYSTEM_OS2_CUI 5\r\n#define IMAGE_SUBSYSTEM_POSIX_CUI 7\r\n#define IMAGE_SUBSYSTEM_WINDOWS_CE_GUI 9\r\n#define IMAGE_DIRECTORY_ENTRY_EXPORT 0\r\n#define IMAGE_DIRECTORY_ENTRY_IMPORT 1\r\n#define IMAGE_DIRECTORY_ENTRY_RESOURCE 2\r\n#define IMAGE_DIRECTORY_ENTRY_EXCEPTION 3\r\n#define IMAGE_DIRECTORY_ENTRY_SECURITY 4\r\n#define IMAGE_DIRECTORY_ENTRY_BASERELOC 5\r\n#define IMAGE_DIRECTORY_ENTRY_DEBUG 6\r\n#define IMAGE_DIRECTORY_ENTRY_COPYRIGHT 7\r\n#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR 8\r\n#define IMAGE_DIRECTORY_ENTRY_TLS 9\r\n#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG 10\r\n#define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT 11\r\n#define IMAGE_DIRECTORY_ENTRY_IAT 12\r\n#define IMAGE_SIZEOF_SHORT_NAME 8\r\n#define IMAGE_SIZEOF_SECTION_HEADER 40\r\n#define IMAGE_SCN_TYPE_NO_PAD 8\r\n#define IMAGE_SCN_CNT_CODE 32\r\n#define IMAGE_SCN_CNT_INITIALIZED_DATA 64\r\n#define IMAGE_SCN_CNT_UNINITIALIZED_DATA 128\r\n#define IMAGE_SCN_LNK_OTHER 256\r\n#define IMAGE_SCN_LNK_INFO 512\r\n#define IMAGE_SCN_LNK_REMOVE 0x800\r\n#define IMAGE_SCN_LNK_COMDAT 0x1000\r\n#define IMAGE_SCN_MEM_FARDATA 0x8000\r\n#define IMAGE_SCN_MEM_PURGEABLE 0x20000\r\n#define IMAGE_SCN_MEM_16BIT 0x20000\r\n#define IMAGE_SCN_MEM_LOCKED 0x40000\r\n#define IMAGE_SCN_MEM_PRELOAD 0x80000\r\n#define IMAGE_SCN_ALIGN_1BYTES 0x100000\r\n#define IMAGE_SCN_ALIGN_2BYTES 0x200000\r\n#define IMAGE_SCN_ALIGN_4BYTES 0x300000\r\n#define IMAGE_SCN_ALIGN_8BYTES 0x400000\r\n#define IMAGE_SCN_ALIGN_16BYTES 0x500000\r\n#define IMAGE_SCN_ALIGN_32BYTES 0x600000\r\n#define IMAGE_SCN_ALIGN_64BYTES 0x700000\r\n#define IMAGE_SCN_LNK_NRELOC_OVFL 0x1000000\r\n#define IMAGE_SCN_MEM_DISCARDABLE 0x2000000\r\n#define IMAGE_SCN_MEM_NOT_CACHED 0x4000000\r\n#define IMAGE_SCN_MEM_NOT_PAGED 0x8000000\r\n#define IMAGE_SCN_MEM_SHARED 0x10000000\r\n#define IMAGE_SCN_MEM_EXECUTE 0x20000000\r\n#define IMAGE_SCN_MEM_READ 0x40000000\r\n#define IMAGE_SCN_MEM_WRITE 0x80000000\r\n#define IMAGE_SIZEOF_SYMBOL 18\r\n#define IMAGE_SYM_UNDEFINED (SHORT)0\r\n#define IMAGE_SYM_ABSOLUTE (SHORT)-1\r\n#define IMAGE_SYM_DEBUG (SHORT)-2\r\n#define IMAGE_SYM_TYPE_NULL 0\r\n#define IMAGE_SYM_TYPE_VOID 1\r\n#define IMAGE_SYM_TYPE_CHAR 2\r\n#define IMAGE_SYM_TYPE_SHORT 3\r\n#define IMAGE_SYM_TYPE_INT 4\r\n#define IMAGE_SYM_TYPE_LONG 5\r\n#define IMAGE_SYM_TYPE_FLOAT 6\r\n#define IMAGE_SYM_TYPE_DOUBLE 7\r\n#define IMAGE_SYM_TYPE_STRUCT 8\r\n#define IMAGE_SYM_TYPE_UNION 9\r\n#define IMAGE_SYM_TYPE_ENUM 10\r\n#define IMAGE_SYM_TYPE_MOE 11\r\n#define IMAGE_SYM_TYPE_BYTE 12\r\n#define IMAGE_SYM_TYPE_WORD 13\r\n#define IMAGE_SYM_TYPE_UINT 14\r\n#define IMAGE_SYM_TYPE_DWORD 15\r\n#define IMAGE_SYM_TYPE_PCODE 0x8000\r\n#define IMAGE_SYM_DTYPE_NULL 0\r\n#define IMAGE_SYM_DTYPE_POINTER 1\r\n#define IMAGE_SYM_DTYPE_FUNCTION 2\r\n#define IMAGE_SYM_DTYPE_ARRAY 3\r\n#define IMAGE_SYM_CLASS_END_OF_FUNCTION (BYTE )-1\r\n#define IMAGE_SYM_CLASS_NULL 0\r\n#define IMAGE_SYM_CLASS_AUTOMATIC 1\r\n#define IMAGE_SYM_CLASS_EXTERNAL 2\r\n#define IMAGE_SYM_CLASS_STATIC 3\r\n#define IMAGE_SYM_CLASS_REGISTER 4\r\n#define IMAGE_SYM_CLASS_EXTERNAL_DEF 5\r\n#define IMAGE_SYM_CLASS_LABEL 6\r\n#define IMAGE_SYM_CLASS_UNDEFINED_LABEL 7\r\n#define IMAGE_SYM_CLASS_MEMBER_OF_STRUCT 8\r\n#define IMAGE_SYM_CLASS_ARGUMENT 9\r\n#define IMAGE_SYM_CLASS_STRUCT_TAG 10\r\n#define IMAGE_SYM_CLASS_MEMBER_OF_UNION 11\r\n#define IMAGE_SYM_CLASS_UNION_TAG 12\r\n#define IMAGE_SYM_CLASS_TYPE_DEFINITION 13\r\n#define IMAGE_SYM_CLASS_UNDEFINED_STATIC 14\r\n#define IMAGE_SYM_CLASS_ENUM_TAG 15\r\n#define IMAGE_SYM_CLASS_MEMBER_OF_ENUM 16\r\n#define IMAGE_SYM_CLASS_REGISTER_PARAM 17\r\n#define IMAGE_SYM_CLASS_BIT_FIELD 18\r\n#define IMAGE_SYM_CLASS_FAR_EXTERNAL 0x44\r\n#define IMAGE_SYM_CLASS_BLOCK 0x64\r\n#define IMAGE_SYM_CLASS_FUNCTION 0x65\r\n#define IMAGE_SYM_CLASS_END_OF_STRUCT 0x66\r\n#define IMAGE_SYM_CLASS_FILE 0x67\r\n#define IMAGE_SYM_CLASS_SECTION 0x68\r\n#define IMAGE_SYM_CLASS_WEAK_EXTERNAL 0x69\r\n\r\n\r\n\r\n#define MAKEWORD(a,b)\t((WORD)(((BYTE)(((DWORD_PTR)(a))&0xFF))|(((WORD)((BYTE)(((DWORD_PTR)(b))&0xFF)))<<8)))\r\n#define LOBYTE(w)\t((BYTE)(((DWORD_PTR)(w))&0xFF))\r\n#define HIBYTE(w)\t((BYTE)((((DWORD_PTR)(w))>>8)&0xFF))\r\n\r\n#define MAKELANGID(p,s)\t((((WORD)(s))<<10)|(WORD)(p))\r\n#define SUBLANG_DEFAULT\t0x01\r\n#define LANG_NEUTRAL 0x00\r\n\r\n\r\n//#define __int64 long long int\r\n#define TA_BASELINE\t24\r\n#define TA_BOTTOM\t8\r\n#define TA_TOP\t0\r\n#define TA_CENTER\t6\r\n#define TA_LEFT\t0\r\n#define TA_RIGHT\t2\r\n#define TA_RTLREADING\t256\r\n#define TA_MASK\t(TA_BASELINE+TA_CENTER+TA_UPDATECP+TA_RTLREADING)\r\n#define TA_NOUPDATECP\t0\r\n#define TA_UPDATECP\t1\r\n\r\n#define GetRValue(rgb) ((BYTE) (rgb))\r\n#define GetGValue(rgb) ((BYTE) (((WORD) (rgb)) >> 8))\r\n#define GetBValue(rgb) ((BYTE) ((rgb) >> 16))\r\n\r\n#define ANSI_CHARSET 0\r\n\r\n#define OUT_DEFAULT_PRECIS\t0\r\n#define OUT_STRING_PRECIS\t1\r\n#define OUT_CHARACTER_PRECIS\t2\r\n#define OUT_STROKE_PRECIS\t3\r\n#define OUT_TT_PRECIS\t4\r\n#define OUT_DEVICE_PRECIS\t5\r\n#define OUT_RASTER_PRECIS\t6\r\n#define OUT_TT_ONLY_PRECIS\t7\r\n#define OUT_OUTLINE_PRECIS\t8\r\n#define CLIP_DEFAULT_PRECIS\t0\r\n#define CLIP_CHARACTER_PRECIS\t1\r\n#define CLIP_STROKE_PRECIS\t2\r\n#define CLIP_MASK\t15\r\n#define CLIP_LH_ANGLES\t16\r\n#define CLIP_TT_ALWAYS\t32\r\n#define CLIP_EMBEDDED\t128\r\n#define DEFAULT_QUALITY\t0\r\n#define DRAFT_QUALITY\t1\r\n#define PROOF_QUALITY\t2\r\n#define NONANTIALIASED_QUALITY\t3\r\n#define ANTIALIASED_QUALITY\t4\r\n#define DEFAULT_PITCH\t0\r\n#define FIXED_PITCH\t1\r\n#define VARIABLE_PITCH\t2\r\n#define FF_DECORATIVE\t80\r\n#define FF_DONTCARE\t0\r\n#define FF_MODERN\t48\r\n#define FF_ROMAN\t16\r\n#define FF_SCRIPT\t64\r\n#define FF_SWISS\t32\r\n#define HS_BDIAGONAL\t3\r\n#define HS_CROSS\t4\r\n#define HS_DIAGCROSS\t5\r\n#define HS_FDIAGONAL\t2\r\n#define HS_HORIZONTAL\t0\r\n#define HS_VERTICAL\t1\r\n#define LR_DEFAULTCOLOR\t0\r\n#define LR_LOADREALSIZE\t128\r\n#define LR_MONOCHROME\t1\r\n#define LR_COPYRETURNORG 4\r\n#define LR_COPYDELETEORG 8\r\n#define LR_LOADFROMFILE\t16\r\n#define LR_LOADTRANSPARENT 32\r\n#define LR_DEFAULTSIZE\t64\r\n#define LR_VGACOLOR\t0x80\r\n#define LR_LOADMAP3DCOLORS 0x1000\r\n#define LR_CREATEDIBSECTION 0x2000\r\n#define LR_COPYFROMRESOURCE 0x4000\r\n#define LR_SHARED\t0x8000\r\n\r\n#define FW_DONTCARE\t0\r\n#define FW_THIN\t100\r\n#define FW_EXTRALIGHT\t200\r\n#define FW_LIGHT\t300\r\n#define FW_NORMAL\t400\r\n#define FW_REGULAR\t400\r\n#define FW_MEDIUM\t500\r\n#define FW_SEMIBOLD\t600\r\n#define FW_BOLD\t700\r\n#define FW_EXTRABOLD\t800\r\n#define FW_HEAVY\t900\r\n\r\n#define\tSM_CXSCREEN\t0\r\n#define\tSM_CYSCREEN\t1\r\n#define\tSM_CXVSCROLL\t2\r\n#define\tSM_CYHSCROLL\t3\r\n#define\tSM_CYCAPTION\t4\r\n#define\tSM_CXBORDER\t5\r\n#define\tSM_CYBORDER\t6\r\n#define\tSM_CXDLGFRAME\t7\r\n#define\tSM_CYDLGFRAME\t8\r\n#define\tSM_CYVTHUMB\t9\r\n#define\tSM_CXHTHUMB\t10\r\n#define\tSM_CXICON\t11\r\n#define\tSM_CYICON\t12\r\n#define\tSM_CXCURSOR\t13\r\n#define\tSM_CYCURSOR\t14\r\n#define\tSM_CYMENU\t15\r\n#define\tSM_CXFULLSCREEN\t16\r\n#define\tSM_CYFULLSCREEN\t17\r\n#define\tSM_CYKANJIWINDOW\t18\r\n#define\tSM_MOUSEPRESENT\t19\r\n#define\tSM_CYVSCROLL\t20\r\n#define\tSM_CXHSCROLL\t21\r\n#define\tSM_DEBUG\t22\r\n#define\tSM_SWAPBUTTON\t23\r\n#define\tSM_RESERVED1\t24\r\n#define\tSM_RESERVED2\t25\r\n#define\tSM_RESERVED3\t26\r\n#define\tSM_RESERVED4\t27\r\n#define\tSM_CXMIN\t28\r\n#define\tSM_CYMIN\t29\r\n#define\tSM_CXSIZE\t30\r\n#define\tSM_CYSIZE\t31\r\n#define\tSM_CXFRAME\t32\r\n#define\tSM_CYFRAME\t33\r\n#define\tSM_CXMINTRACK\t34\r\n#define\tSM_CYMINTRACK\t35\r\n#define\tSM_CXDOUBLECLK\t36\r\n#define\tSM_CYDOUBLECLK\t37\r\n#define\tSM_CXICONSPACING\t38\r\n#define\tSM_CYICONSPACING\t39\r\n#define\tSM_MENUDROPALIGNMENT\t40\r\n#define\tSM_PENWINDOWS\t41\r\n#define\tSM_DBCSENABLED\t42\r\n#define\tSM_CMOUSEBUTTONS\t43\r\n#define\tSM_CXFIXEDFRAME\tSM_CXDLGFRAME\r\n#define\tSM_CYFIXEDFRAME\tSM_CYDLGFRAME\r\n#define\tSM_CXSIZEFRAME\tSM_CXFRAME\r\n#define\tSM_CYSIZEFRAME\tSM_CYFRAME\r\n#define\tSM_SECURE\t44\r\n#define\tSM_CXEDGE\t45\r\n#define\tSM_CYEDGE\t46\r\n#define\tSM_CXMINSPACING\t47\r\n#define\tSM_CYMINSPACING\t48\r\n#define\tSM_CXSMICON\t49\r\n#define\tSM_CYSMICON\t50\r\n#define\tSM_CYSMCAPTION\t51\r\n#define\tSM_CXSMSIZE\t52\r\n#define\tSM_CYSMSIZE\t53\r\n#define\tSM_CXMENUSIZE\t54\r\n#define\tSM_CYMENUSIZE\t55\r\n#define\tSM_ARRANGE\t56\r\n#define\tSM_CXMINIMIZED\t57\r\n#define\tSM_CYMINIMIZED\t58\r\n#define\tSM_CXMAXTRACK\t59\r\n#define\tSM_CYMAXTRACK\t60\r\n#define\tSM_CXMAXIMIZED\t61\r\n#define\tSM_CYMAXIMIZED\t62\r\n#define\tSM_NETWORK\t63\r\n#define\tSM_CLEANBOOT\t67\r\n#define\tSM_CXDRAG\t68\r\n#define\tSM_CYDRAG\t69\r\n#define\tSM_SHOWSOUNDS\t70\r\n#define\tSM_CXMENUCHECK\t71\r\n#define\tSM_CYMENUCHECK\t72\r\n#define\tSM_SLOWMACHINE\t73\r\n#define\tSM_MIDEASTENABLED\t74\r\n#define\tSM_MOUSEWHEELPRESENT\t75\r\n#define\tSM_XVIRTUALSCREEN\t76\r\n#define\tSM_YVIRTUALSCREEN\t77\r\n#define\tSM_CXVIRTUALSCREEN\t78\r\n#define\tSM_CYVIRTUALSCREEN\t79\r\n#define\tSM_CMONITORS\t80\r\n#define\tSM_SAMEDISPLAYFORMAT\t81\r\n#define\tSM_CMETRICS\t76\r\n\r\n#define SWP_DRAWFRAME\t32\r\n#define SWP_FRAMECHANGED\t32\r\n#define SWP_HIDEWINDOW\t128\r\n#define SWP_NOACTIVATE\t16\r\n#define SWP_NOCOPYBITS\t256\r\n#define SWP_NOMOVE\t2\r\n#define SWP_NOSIZE\t1\r\n#define SWP_NOREDRAW\t8\r\n#define SWP_NOZORDER\t4\r\n#define SWP_SHOWWINDOW\t64\r\n#define SWP_NOOWNERZORDER\t512\r\n#define SWP_NOREPOSITION\t512\r\n#define SWP_NOSENDCHANGING\t1024\r\n\r\n#define LF_FACESIZE\t32\r\n#define LF_FULLFACESIZE\t64\r\n\r\n#define FOREGROUND_BLUE\t1\r\n#define FOREGROUND_GREEN\t2\r\n#define FOREGROUND_RED\t4\r\n#define FOREGROUND_INTENSITY\t8\r\n#define BACKGROUND_BLUE\t16\r\n#define BACKGROUND_GREEN\t32\r\n#define BACKGROUND_RED\t64\r\n\r\n#define CTRL_C_EVENT\t0\r\n#define CTRL_BREAK_EVENT\t1\r\n#define CTRL_CLOSE_EVENT\t2\r\n#define CTRL_LOGOFF_EVENT\t5\r\n#define CTRL_SHUTDOWN_EVENT\t6\r\n\r\n#define INVALID_HANDLE_VALUE (HANDLE)(0xFFFFFFFFFFFFFFFF)\r\n#define INVALID_FILE_SIZE ((DWORD)0xFFFFFFFFFFFFFFFF)\r\n#define INVALID_SET_FILE_POINTER ((DWORD)-1)\r\n#define INVALID_FILE_ATTRIBUTES ((DWORD)-1)\r\n\r\n#define Int32x32To64(a,b)(((long long)((long)(a))) *((long long)((long)(b))))\r\n\r\n#define PAGE_READONLY 2\r\n#define PAGE_READWRITE 4\r\n#define PAGE_WRITECOPY 8\r\n\r\n#define FILE_BEGIN 0\r\n#define FILE_CURRENT 1\r\n#define FILE_END 2\r\n\r\n#define FILE_READ_DATA\t1\r\n#define FILE_LIST_DIRECTORY\t1\r\n#define FILE_WRITE_DATA\t2\r\n#define FILE_ADD_FILE\t2\r\n#define FILE_APPEND_DATA\t4\r\n#define FILE_ADD_SUBDIRECTORY\t4\r\n#define FILE_CREATE_PIPE_INSTANCE 4\r\n#define FILE_READ_EA\t8\r\n#define FILE_WRITE_EA\t0x10\r\n#define FILE_EXECUTE\t0x20\r\n#define FILE_TRAVERSE\t0x0020\r\n#define FILE_DELETE_CHILD\t0x0040\r\n#define FILE_READ_ATTRIBUTES\t0x0080\r\n#define FILE_WRITE_ATTRIBUTES\t0x100\r\n#define FILE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|0x1FF)\r\n#define FILE_GENERIC_READ (STANDARD_RIGHTS_READ|FILE_READ_DATA| FILE_READ_ATTRIBUTES|FILE_READ_EA|SYNCHRONIZE)\r\n#define FILE_GENERIC_WRITE (STANDARD_RIGHTS_WRITE|FILE_WRITE_DATA|FILE_WRITE_ATTRIBUTES|FILE_WRITE_EA|FILE_APPEND_DATA|SYNCHRONIZE)\r\n#define FILE_GENERIC_EXECUTE (STANDARD_RIGHTS_EXECUTE|FILE_READ_ATTRIBUTES|FILE_EXECUTE|SYNCHRONIZE)\r\n\r\n#define FILE_FLAG_WRITE_THROUGH 0x80000000\r\n#define FILE_FLAG_OVERLAPPED 1073741824\r\n#define FILE_FLAG_NO_BUFFERING 536870912\r\n#define FILE_FLAG_RANDOM_ACCESS 268435456\r\n#define FILE_FLAG_SEQUENTIAL_SCAN 134217728\r\n#define FILE_FLAG_DELETE_ON_CLOSE 67108864\r\n#define FILE_FLAG_BACKUP_SEMANTICS 33554432\r\n#define FILE_FLAG_POSIX_SEMANTICS 16777216\r\n#define FILE_FLAG_OPEN_REPARSE_POINT 0x200000\r\n#define FILE_FLAG_OPEN_NO_RECALL 0x100000\r\n#define FILE_FLAG_FIRST_PIPE_INSTANCE 0x00080000\r\n\r\n#define SMTO_ABORTIFHUNG 2\r\n#define SMTO_BLOCK 1\r\n#define SMTO_NORMAL 0\r\n\r\n#define FORMAT_MESSAGE_ALLOCATE_BUFFER 256\r\n#define FORMAT_MESSAGE_IGNORE_INSERTS 512\r\n#define FORMAT_MESSAGE_FROM_STRING 1024\r\n#define FORMAT_MESSAGE_FROM_HMODULE 2048\r\n#define FORMAT_MESSAGE_FROM_SYSTEM 4096\r\n#define FORMAT_MESSAGE_ARGUMENT_ARRAY 8192\r\n#define FORMAT_MESSAGE_MAX_WIDTH_MASK 255\r\n\r\n#define HWND_BOTTOM (HWND)1\r\n#define HWND_NOTOPMOST (HWND)(-2)\r\n#define HWND_TOP (HWND)0\r\n#define HWND_TOPMOST (HWND)(-1)\r\n#define HWND_BROADCAST (HWND)65535\r\n#define VER_PLATFORM_WIN32s 0\r\n#define VER_PLATFORM_WIN32_WINDOWS 1\r\n#define VER_PLATFORM_WIN32_NT 2\r\n\r\n#define CP_ACP 0\r\n#define CP_MACCP 2\r\n#define CP_OEMCP 1\r\n#define CP_THREAD_ACP 3\r\n#define CP_SYMBOL 42\r\n#define CP_UTF7 65000\r\n#define CP_UTF8 65001\r\n\r\n#define WAIT_OBJECT_0 0\r\n#define WAIT_ABANDONED_0 0x80\r\n#define WAIT_TIMEOUT 0x102\r\n#define WAIT_IO_COMPLETION 0xC0\r\n#define WAIT_ABANDONED 0x80\r\n#define WAIT_FAILED 0xFFFFFFFF\r\n\r\n#define GENERIC_READ  0x80000000\r\n#define GENERIC_WRITE 0x40000000\r\n#define FILE_SHARE_READ 1\r\n#define FILE_SHARE_WRITE 2\r\n#define FILE_SHARE_DELETE 4\r\n#define CREATE_NEW 1\r\n#define CREATE_ALWAYS 2\r\n#define OPEN_EXISTING 3\r\n#define OPEN_ALWAYS 4\r\n#define TRUNCATE_EXISTING 5\r\n\r\n//#define CALLBACK\r\n#define WINAPI\r\n#define UINT32 unsigned int\r\n#define HANDLE_FLAG_INHERIT 1\r\n\r\n#define STARTF_USESHOWWINDOW 1\r\n#define STARTF_USESIZE 2\r\n#define STARTF_USEPOSITION 4\r\n#define STARTF_USECOUNTCHARS 8\r\n#define STARTF_USEFILLATTRIBUTE 16\r\n#define STARTF_RUNFULLSCREEN 32\r\n#define STARTF_FORCEONFEEDBACK 64\r\n#define STARTF_FORCEOFFFEEDBACK 128\r\n#define STARTF_USESTDHANDLES 256\r\n#define STARTF_USEHOTKEY 512\r\n\r\n#define FILE_ATTRIBUTE_ARCHIVE 32\r\n#define FILE_ATTRIBUTE_COMPRESSED 2048\r\n#define FILE_ATTRIBUTE_NORMAL 128\r\n#define FILE_ATTRIBUTE_DIRECTORY 16\r\n#define FILE_ATTRIBUTE_HIDDEN 2\r\n#define FILE_ATTRIBUTE_READONLY 1\r\n#define FILE_ATTRIBUTE_SYSTEM 4\r\n#define FILE_ATTRIBUTE_TEMPORARY 256\r\n#define FILE_ATTRIBUTE_SPARSE_FILE 0x200\r\n#define FILE_ATTRIBUTE_REPARSE_POINT 0x400\r\n#define FILE_ATTRIBUTE_OFFLINE 0x1000\r\n#define FILE_ATTRIBUTE_NOT_CONTENT_INDEXED 0x00002000\r\n#define FILE_ATTRIBUTE_ENCRYPTED 0x4000\r\n\r\n#define CREATE_UNICODE_ENVIRONMENT 1024\r\n\r\n#define STILL_ACTIVE 0x103\r\n#define FALSE 0\r\n#define TRUE 1\r\n#define INFINITE (-1)\r\n\r\n#define CF_TEXT 1\r\n\r\n#define GMEM_FIXED 0\r\n#define GMEM_MOVEABLE 2\r\n#define GMEM_MODIFY 128\r\n#define GMEM_VALID_FLAGS 0x7F72\r\n\r\n#define DIB_PAL_COLORS 1\r\n#define DIB_RGB_COLORS 0\r\n\r\n#define BI_RGB 0\r\n#define BI_RLE8 1\r\n#define BI_RLE4 2\r\n#define BI_BITFIELDS 3\r\n#define BI_JPEG 4\r\n#define BI_PNG 5\r\n\r\n#define MK_CONTROL 8\r\n#define MK_LBUTTON 1\r\n#define MK_MBUTTON 16\r\n#define MK_RBUTTON 2\r\n#define MK_SHIFT 4\r\n\r\n#define MAKEINTRESOURCE(i) (LPSTR) ((DWORD) ((WORD) (i)))\r\n#define MAKELONG(a,b) ((LONG) (((WORD) (a)) | ((DWORD) ((WORD) (b))) << 16))\r\n#define MAKELPARAM(l,h) ((LPARAM) MAKELONG(l,h))\r\n#define RGB(r,g,b) ((DWORD)(((BYTE)(r)|((WORD)(g) << 8))|(((DWORD)(BYTE)(b)) << 16)))\r\n\r\n#define BLACKNESS 0x42\r\n#define NOTSRCERASE 0x1100A6\r\n#define NOTSRCCOPY 0x330008\r\n#define SRCERASE 0x440328\r\n#define DSTINVERT 0x550009\r\n#define PATINVERT 0x5A0049\r\n#define SRCINVERT 0x660046\r\n#define SRCAND 0x8800C6\r\n#define MERGEPAINT 0xBB0226\r\n#define MERGECOPY 0xC000CA\r\n#define SRCCOPY 0xCC0020\r\n#define SRCPAINT 0xEE0086\r\n#define PATCOPY 0xF00021\r\n#define PATPAINT 0xFB0A09\r\n#define WHITENESS 0xFF0062\r\n#define NOMIRRORBITMAP 0x80000000\r\n#define CAPTUREBLT 0x40000000\r\n\r\n#define GWL_EXSTYLE (-20)\r\n#define GWL_STYLE (-16)\r\n#define GWL_WNDPROC (-4)\r\n#define GWL_HINSTANCE (-6)\r\n#define GWL_HWNDPARENT (-8)\r\n#define GWL_ID (-12)\r\n#define GWL_USERDATA (-21)\r\n#define GWLP_WNDPROC (-4)\r\n#define GWLP_HINSTANCE (-6)\r\n#define GWLP_HWNDPARENT (-8)\r\n#define GWLP_USERDATA (-21)\r\n#define GWLP_ID (-12)\r\n\r\n#define COLOR_HOTLIGHT 26\r\n#define COLOR_GRADIENTACTIVECAPTION 27\r\n#define COLOR_GRADIENTINACTIVECAPTION 28\r\n#define COLOR_MENUHILIGHT 29\r\n#define COLOR_MENUBAR 30\r\n#define COLOR_3DDKSHADOW 21\r\n#define COLOR_3DFACE 15\r\n#define COLOR_3DHILIGHT 20\r\n#define COLOR_3DHIGHLIGHT 20\r\n#define COLOR_3DLIGHT 22\r\n#define COLOR_BTNHILIGHT 20\r\n#define COLOR_3DSHADOW 16\r\n#define COLOR_ACTIVEBORDER 10\r\n#define COLOR_ACTIVECAPTION 2\r\n#define COLOR_APPWORKSPACE 12\r\n#define COLOR_BACKGROUND 1\r\n#define COLOR_DESKTOP 1\r\n#define COLOR_BTNFACE 15\r\n#define COLOR_BTNHIGHLIGHT 20\r\n#define COLOR_BTNSHADOW 16\r\n#define COLOR_BTNTEXT 18\r\n#define COLOR_CAPTIONTEXT 9\r\n#define COLOR_GRAYTEXT 17\r\n#define COLOR_HIGHLIGHT 13\r\n#define COLOR_HIGHLIGHTTEXT 14\r\n#define COLOR_INACTIVEBORDER 11\r\n#define COLOR_INACTIVECAPTION 3\r\n#define COLOR_INACTIVECAPTIONTEXT 19\r\n#define COLOR_INFOBK 24\r\n#define COLOR_INFOTEXT 23\r\n#define COLOR_MENU 4\r\n#define COLOR_MENUTEXT 7\r\n#define COLOR_SCROLLBAR 0\r\n#define COLOR_WINDOW 5\r\n#define COLOR_WINDOWFRAME 6\r\n#define COLOR_WINDOWTEXT 8\r\n\r\n#define SW_HIDE 0\r\n#define SW_NORMAL 1\r\n#define SW_MAXIMIZE 3\r\n#define SW_MINIMIZE 6\r\n#define SW_RESTORE 9\r\n#define SW_SHOW 5\r\n#define SW_SHOWDEFAULT 10\r\n#define SW_SHOWMAXIMIZED 3\r\n#define SW_SHOWMINIMIZED 2\r\n#define SW_SHOWMINNOACTIVE 7\r\n#define SW_SHOWNA 8\r\n#define SW_SHOWNOACTIVATE 4\r\n#define SW_SHOWNORMAL 1\r\n\r\n#define PS_GEOMETRIC 65536\r\n#define PS_COSMETIC 0\r\n#define PS_ALTERNATE 8\r\n#define PS_SOLID 0\r\n#define PS_DASH 1\r\n#define PS_DOT 2\r\n#define PS_DASHDOT 3\r\n#define PS_DASHDOTDOT 4\r\n#define PS_NULL 5\r\n#define PS_USERSTYLE 7\r\n#define PS_INSIDEFRAME 6\r\n#define PS_ENDCAP_ROUND 0\r\n#define PS_ENDCAP_SQUARE 256\r\n#define PS_ENDCAP_FLAT 512\r\n#define PS_JOIN_BEVEL 4096\r\n#define PS_JOIN_MITER 8192\r\n#define PS_JOIN_ROUND 0\r\n#define PS_STYLE_MASK 15\r\n#define PS_ENDCAP_MASK 3840\r\n#define PS_TYPE_MASK 983040\r\n\r\n#define HTBOTTOM 15\r\n#define HTBOTTOMLEFT 16\r\n#define HTBOTTOMRIGHT 17\r\n#define HTCAPTION 2\r\n#define HTCLIENT 1\r\n#define HTERROR (-2)\r\n#define HTGROWBOX 4\r\n#define HTHSCROLL 6\r\n#define HTLEFT 10\r\n#define HTMENU 5\r\n#define HTNOWHERE 0\r\n#define HTREDUCE 8\r\n#define HTRIGHT 11\r\n#define HTSIZE 4\r\n#define HTSYSMENU 3\r\n#define HTTOP 12\r\n#define HTTOPLEFT 13\r\n#define HTTOPRIGHT 14\r\n#define HTTRANSPARENT (-1)\r\n#define HTVSCROLL 7\r\n#define HTZOOM 9\r\n#define HTOBJECT 19\r\n#define HTCLOSE 20\r\n#define HTHELP 21\r\n#define HTBORDER 18\r\n#define HTMINBUTTON 8\r\n#define HTMAXBUTTON 9\r\n\r\n#define VK_LBUTTON 1\r\n#define VK_RBUTTON 2\r\n#define VK_CANCEL 3\r\n#define VK_MBUTTON 4\r\n#define VK_BACK 8\r\n#define VK_TAB 9\r\n#define VK_CLEAR 12\r\n#define VK_RETURN 13\r\n#define VK_SHIFT 16\r\n#define VK_CONTROL 17\r\n#define VK_MENU 18\r\n#define VK_PAUSE 19\r\n#define VK_PRINT 42\r\n#define VK_CAPITAL 20\r\n#define VK_KANA 0x15\r\n#define VK_HANGEUL 0x15\r\n#define VK_HANGUL 0x15\r\n#define VK_JUNJA 0x17\r\n#define VK_FINAL 0x18\r\n#define VK_HANJA 0x19\r\n#define VK_KANJI 0x19\r\n#define VK_CONVERT 0x1C\r\n#define VK_NONCONVERT 0x1D\r\n#define VK_ACCEPT 0x1E\r\n#define VK_MODECHANGE 0x1F\r\n#define VK_ESCAPE 27\r\n#define VK_SPACE 32\r\n#define VK_PRIOR 33\r\n#define VK_NEXT 34\r\n#define VK_END 35\r\n#define VK_HOME 36\r\n#define VK_LEFT 37\r\n#define VK_UP 38\r\n#define VK_RIGHT 39\r\n#define VK_DOWN 40\r\n#define VK_SELECT 41\r\n#define VK_EXECUTE 43\r\n#define VK_SNAPSHOT 44\r\n#define VK_INSERT 45\r\n#define VK_DELETE 46\r\n#define VK_HELP 47\r\n#define VK_0 48\r\n#define VK_1 49\r\n#define VK_2 50\r\n#define VK_3 51\r\n#define VK_4 52\r\n#define VK_5 53\r\n#define VK_6 54\r\n#define VK_7 55\r\n#define VK_8 56\r\n#define VK_9 57\r\n#define VK_A 65\r\n#define VK_B 66\r\n#define VK_C 67\r\n#define VK_D 68\r\n#define VK_E 69\r\n#define VK_F 70\r\n#define VK_G 71\r\n#define VK_H 72\r\n#define VK_I 73\r\n#define VK_J 74\r\n#define VK_K 75\r\n#define VK_L 76\r\n#define VK_M 77\r\n#define VK_N 78\r\n#define VK_O 79\r\n#define VK_P 80\r\n#define VK_Q 81\r\n#define VK_R 82\r\n#define VK_S 83\r\n#define VK_T 84\r\n#define VK_U 85\r\n#define VK_V 86\r\n#define VK_W 87\r\n#define VK_X 88\r\n#define VK_Y 89\r\n#define VK_Z 90\r\n#define VK_LWIN 0x5B\r\n#define VK_RWIN 0x5C\r\n#define VK_APPS 0x5D\r\n#define VK_NUMPAD0 96\r\n#define VK_NUMPAD1 97\r\n#define VK_NUMPAD2 98\r\n#define VK_NUMPAD3 99\r\n#define VK_NUMPAD4 100\r\n#define VK_NUMPAD5 101\r\n#define VK_NUMPAD6 102\r\n#define VK_NUMPAD7 103\r\n#define VK_NUMPAD8 104\r\n#define VK_NUMPAD9 105\r\n#define VK_MULTIPLY 106\r\n#define VK_ADD 107\r\n#define VK_SEPARATOR 108\r\n#define VK_SUBTRACT 109\r\n#define VK_DECIMAL 110\r\n#define VK_DIVIDE 111\r\n#define VK_F1 112\r\n#define VK_F2 113\r\n#define VK_F3 114\r\n#define VK_F4 115\r\n#define VK_F5 116\r\n#define VK_F6 117\r\n#define VK_F7 118\r\n#define VK_F8 119\r\n#define VK_F9 120\r\n#define VK_F10 121\r\n#define VK_F11 122\r\n#define VK_F12 123\r\n#define VK_F13 124\r\n#define VK_F14 125\r\n#define VK_F15 126\r\n#define VK_F16 127\r\n#define VK_F17 128\r\n#define VK_F18 129\r\n#define VK_F19 130\r\n#define VK_F20 131\r\n#define VK_F21 132\r\n#define VK_F22 133\r\n#define VK_F23 134\r\n#define VK_F24 135\r\n#define VK_NUMLOCK 144\r\n#define VK_SCROLL 145\r\n#define VK_LSHIFT 160\r\n#define VK_LCONTROL 162\r\n#define VK_LMENU 164\r\n#define VK_RSHIFT 161\r\n#define VK_RCONTROL 163\r\n#define VK_RMENU 165\r\n\r\n#define FILE_TYPE_UNKNOWN 0\r\n#define FILE_TYPE_DISK 1\r\n#define FILE_TYPE_CHAR 2\r\n#define FILE_TYPE_PIPE 3\r\n#define FILE_TYPE_REMOTE 0x8000\r\n\r\n#define FILE_MAP_ALL_ACCESS 0xf001f\r\n#define FILE_MAP_READ 4\r\n#define FILE_MAP_WRITE 2\r\n#define FILE_MAP_COPY 1\r\n\r\n#define PM_NOREMOVE 0\r\n#define PM_REMOVE 1\r\n#define PM_NOYIELD 2\r\n\r\n#define LOWORD(l) (((WORD) (l)) & 0xFFFF)\r\n#define HIWORD(l) ((WORD) (((DWORD) (l) >> 16) & 0xFFFF))\r\n\r\n//#define ERROR_BROKEN_PIPE 109\r\n\r\n#define WM_NULL 0\r\n#define WM_APP 0x8000\r\n#define WM_ACTIVATE 6\r\n#define WM_ACTIVATEAPP 28\r\n#define WM_ASKCBFORMATNAME 780\r\n#define WM_CANCELJOURNAL 75\r\n#define WM_CANCELMODE 31\r\n#define WM_CAPTURECHANGED 533\r\n#define WM_CHANGECBCHAIN 781\r\n#define WM_CHAR 258\r\n#define WM_CHARTOITEM 47\r\n#define WM_CHILDACTIVATE 34\r\n#define WM_CHOOSEFONT_GETLOGFONT 1025\r\n#define WM_CHOOSEFONT_SETLOGFONT 1125\r\n#define WM_CHOOSEFONT_SETFLAGS 1126\r\n#define WM_CLEAR 771\r\n#define WM_CLOSE 16\r\n\r\n//!=================\r\n\r\n#define WM_COMMAND 273\r\n#define WM_COMPACTING 65\r\n#define WM_COMPAREITEM 57\r\n#define WM_CONTEXTMENU 123\r\n#define WM_COPY 769\r\n#define WM_COPYDATA 74\r\n#define WM_CREATE 1\r\n#define WM_CTLCOLORBTN 309\r\n#define WM_CTLCOLORDLG 310\r\n#define WM_CTLCOLOREDIT 307\r\n#define WM_CTLCOLORLISTBOX 308\r\n#define WM_CTLCOLORMSGBOX 306\r\n#define WM_CTLCOLORSCROLLBAR 311\r\n#define WM_CTLCOLORSTATIC 312\r\n#define WM_CUT 768\r\n#define WM_DEADCHAR 259\r\n#define WM_DELETEITEM 45\r\n#define WM_DESTROY 2\r\n#define WM_DESTROYCLIPBOARD 775\r\n#define WM_DEVICECHANGE 537\r\n#define WM_DEVMODECHANGE 27\r\n#define WM_DISPLAYCHANGE 126\r\n#define WM_DRAWCLIPBOARD 776\r\n#define WM_DRAWITEM 43\r\n#define WM_DROPFILES 563\r\n#define WM_ENABLE 10\r\n#define WM_ENDSESSION 22\r\n#define WM_ENTERIDLE 289\r\n#define WM_ENTERMENULOOP 529\r\n#define WM_ENTERSIZEMOVE 561\r\n#define WM_ERASEBKGND 20\r\n#define WM_EXITMENULOOP 530\r\n#define WM_EXITSIZEMOVE 562\r\n#define WM_FONTCHANGE 29\r\n#define WM_GETDLGCODE 135\r\n#define WM_GETFONT 49\r\n#define WM_GETHOTKEY 51\r\n#define WM_GETICON 127\r\n#define WM_GETMINMAXINFO 36\r\n#define WM_GETTEXT 13\r\n#define WM_GETTEXTLENGTH 14\r\n#define WM_HELP 83\r\n#define WM_HOTKEY 786\r\n#define WM_HSCROLL 276\r\n#define WM_HSCROLLCLIPBOARD 782\r\n#define WM_ICONERASEBKGND 39\r\n#define WM_IME_CHAR 646\r\n#define WM_IME_COMPOSITION 271\r\n#define WM_IME_COMPOSITIONFULL 644\r\n#define WM_IME_CONTROL 643\r\n#define WM_IME_ENDCOMPOSITION 270\r\n#define WM_IME_KEYDOWN 656\r\n#define WM_IME_KEYUP 657\r\n#define WM_IME_NOTIFY 642\r\n#define WM_IME_SELECT 645\r\n#define WM_IME_SETCONTEXT 641\r\n#define WM_IME_STARTCOMPOSITION 269\r\n#define WM_INITDIALOG 272\r\n#define WM_INITMENU 278\r\n#define WM_INITMENUPOPUP 279\r\n#define WM_INPUTLANGCHANGE 81\r\n#define WM_INPUTLANGCHANGEREQUEST 80\r\n#define WM_INPUT 0xff\r\n#define WM_KEYDOWN 256\r\n#define WM_KEYUP 257\r\n#define WM_KILLFOCUS 8\r\n#define WM_LBUTTONDBLCLK 515\r\n#define WM_LBUTTONDOWN 513\r\n#define WM_LBUTTONUP 514\r\n#define WM_MBUTTONDBLCLK 521\r\n#define WM_MBUTTONDOWN 519\r\n#define WM_MBUTTONUP 520\r\n#define WM_MDIACTIVATE 546\r\n#define WM_MDICASCADE 551\r\n#define WM_MDICREATE 544\r\n#define WM_MDIDESTROY 545\r\n#define WM_MDIGETACTIVE 553\r\n#define WM_MDIICONARRANGE 552\r\n#define WM_MDIMAXIMIZE 549\r\n#define WM_MDINEXT 548\r\n#define WM_MDIREFRESHMENU 564\r\n#define WM_MDIRESTORE 547\r\n#define WM_MDISETMENU 560\r\n#define WM_MDITILE 550\r\n#define WM_MEASUREITEM 44\r\n#define WM_MENUCHAR 288\r\n#define WM_MENUSELECT 287\r\n#define WM_MENURBUTTONUP 0x0122\r\n#define WM_MENUDRAG 0x0123\r\n#define WM_MENUGETOBJECT 0x0124\r\n#define WM_UNINITMENUPOPUP 0x0125\r\n#define WM_MENUCOMMAND 0x0126\r\n//#define WM_CHANGEUISTATE 0x0127\r\n#define WM_UPDATEUISTATE 0x0128\r\n#define WM_QUERYUISTATE 0x0129\r\n#define UIS_SET 1\r\n#define UIS_CLEAR 2\r\n#define UIS_INITIALIZE  3\r\n#define WM_MOUSEACTIVATE 33\r\n#define WM_MOUSEMOVE 512\r\n#define WM_MOUSEHOVER 0x2a1\r\n#define WM_MOUSELEAVE 0x2a3\r\n#define WM_MOUSEWHEEL 0x20A\r\n#define WM_MOVE 3\r\n#define WM_MOVING 534\r\n#define WM_NCACTIVATE 134\r\n#define WM_NCCALCSIZE 131\r\n#define WM_NCCREATE 129\r\n#define WM_NCDESTROY 130\r\n#define WM_NCHITTEST 132\r\n#define WM_NCLBUTTONDBLCLK 163\r\n#define WM_NCLBUTTONDOWN 161\r\n#define WM_NCLBUTTONUP 162\r\n#define WM_NCMBUTTONDBLCLK 169\r\n#define WM_NCMBUTTONDOWN 167\r\n#define WM_NCMBUTTONUP 168\r\n#define WM_NCMOUSEMOVE 160\r\n#define WM_NCPAINT 133\r\n#define WM_NCRBUTTONDBLCLK 166\r\n#define WM_NCRBUTTONDOWN 164\r\n#define WM_NCRBUTTONUP 165\r\n#define WM_NEXTDLGCTL 40\r\n#define WM_NOTIFY 78\r\n#define WM_NOTIFYFORMAT 85\r\n#define WM_PAINT 15\r\n#define WM_PAINTCLIPBOARD 777\r\n#define WM_PAINTICON 38\r\n#define WM_PALETTECHANGED 785\r\n#define WM_PALETTEISCHANGING 784\r\n#define WM_PARENTNOTIFY 528\r\n#define WM_PASTE 770\r\n#define WM_PENWINFIRST 896\r\n#define WM_SYNCPAINT 0x0088\r\n#define WM_AFXFIRST 0x0360\r\n#define WM_AFXLAST 0x037F\r\n#define WM_HANDHELDFIRST 0x0358\r\n#define WM_HANDHELDLAST 0x035F\r\n#define WM_PENWINLAST 911\r\n#define WM_POWER 72\r\n#define WM_POWERBROADCAST 536\r\n#define WM_PRINT 791\r\n#define WM_PRINTCLIENT 792\r\n#define WM_PSD_ENVSTAMPRECT 1029\r\n#define WM_PSD_FULLPAGERECT 1025\r\n#define WM_PSD_GREEKTEXTRECT 1028\r\n#define WM_PSD_MARGINRECT 1027\r\n#define WM_PSD_MINMARGINRECT 1026\r\n#define WM_PSD_PAGESETUPDLG 1024\r\n#define WM_PSD_YAFULLPAGERECT 1030\r\n#define WM_QUERYDRAGICON 55\r\n#define WM_QUERYENDSESSION 17\r\n#define WM_QUERYNEWPALETTE 783\r\n#define WM_QUERYOPEN 19\r\n#define WM_QUEUESYNC 35\r\n#define WM_QUIT 18\r\n#define WM_RBUTTONDBLCLK 518\r\n#define WM_RBUTTONDOWN 516\r\n#define WM_RBUTTONUP 517\r\n#define WM_RENDERALLFORMATS 774\r\n#define WM_RENDERFORMAT 773\r\n#define WM_SETCURSOR 32\r\n#define WM_SETFOCUS 7\r\n#define WM_SETFONT 48\r\n#define WM_SETHOTKEY 50\r\n#define WM_SETICON 128\r\n#define WM_SETREDRAW 11\r\n#define WM_SETTEXT 12\r\n#define WM_SETTINGCHANGE 26\r\n#define WM_SHOWWINDOW 24\r\n#define WM_SIZE 5\r\n#define WM_SIZECLIPBOARD 779\r\n#define WM_SIZING 532\r\n#define WM_SPOOLERSTATUS 42\r\n#define WM_STYLECHANGED 125\r\n#define WM_STYLECHANGING 124\r\n#define WM_SYSCHAR 262\r\n#define WM_SYSCOLORCHANGE 21\r\n#define WM_SYSCOMMAND 274\r\n#define WM_SYSDEADCHAR 263\r\n#define WM_SYSKEYDOWN 260\r\n#define WM_SYSKEYUP 261\r\n#define WM_TCARD 82\r\n#define WM_TIMECHANGE 30\r\n#define WM_TIMER 275\r\n#define WM_UNDO 772\r\n#define WM_USER 1024\r\n#define WM_USERCHANGED 84\r\n#define WM_VKEYTOITEM 46\r\n#define WM_VSCROLL 277\r\n#define WM_VSCROLLCLIPBOARD 778\r\n#define WM_WINDOWPOSCHANGED 71\r\n#define WM_WINDOWPOSCHANGING 70\r\n#define WM_XBUTTONDOWN 0x020B\r\n#define WM_XBUTTONUP 0x020C\r\n#define WM_XBUTTONDBLCLK 0x020D\r\n#define WM_WININICHANGE 26\r\n#define WM_KEYFIRST 256\r\n#define WM_KEYLAST 264\r\n#define WM_MOUSEFIRST 512\r\n#define WM_MOUSELAST 0x020D\r\n#define WM_NEXTMENU 0x0213\r\n//#define WM_CHANGEUISTATE 0x0127\r\n//#define WM_UPDATEUISTATE 0x0128\r\n//#define WM_QUERYUISTATE 0x0129\r\n#define WM_WTSSESSION_CHANGE 0x02B1\r\n#define WM_LBTRACKPOINT 0x0131\r\n#define WM_GETOBJECT 0x003D\r\n#define WM_COMMNOTIFY 0x0044\r\n#define WM_TABLET_FIRST 0x02c0\r\n#define WM_TABLET_LAST 0x02df\r\n#define WM_IME_REQUEST 0x0288\r\n#define WM_IME_KEYLAST  0x010F\r\n#define WM_NCMOUSEHOVER 0x02A0\r\n#define WM_NCMOUSELEAVE 0x02A2\r\n\r\n#define WS_BORDER 0x800000\r\n#define WS_CAPTION 0xc00000\r\n#define WS_CHILD 0x40000000\r\n#define WS_CHILDWINDOW 0x40000000\r\n#define WS_CLIPCHILDREN 0x2000000\r\n#define WS_CLIPSIBLINGS 0x4000000\r\n#define WS_DISABLED 0x8000000\r\n#define WS_DLGFRAME 0x400000\r\n#define WS_GROUP 0x20000\r\n#define WS_HSCROLL 0x100000\r\n#define WS_ICONIC 0x20000000\r\n#define WS_MAXIMIZE 0x1000000\r\n#define WS_MAXIMIZEBOX 0x10000\r\n#define WS_MINIMIZE 0x20000000\r\n#define WS_MINIMIZEBOX 0x20000\r\n#define WS_OVERLAPPED 0\r\n#define WS_OVERLAPPEDWINDOW 0xcf0000\r\n#define WS_POPUP 0x80000000\r\n#define WS_POPUPWINDOW 0x80880000\r\n#define WS_SIZEBOX 0x40000\r\n#define WS_SYSMENU 0x80000\r\n#define WS_TABSTOP 0x10000\r\n#define WS_THICKFRAME 0x40000\r\n#define WS_TILED 0\r\n#define WS_TILEDWINDOW 0xcf0000\r\n#define WS_VISIBLE 0x10000000\r\n#define WS_VSCROLL 0x200000\r\n\r\n#define HORZRES\t8\r\n#define VERTRES\t10\r\n#define DESKTOPHORZRES\t118\r\n#define DESKTOPVERTRES\t117\r\n\r\n//!=================\r\n\r\n\r\n//#define INVALID_HANDLE_VALUE (HANDLE)(0xffffffff)\r\n#define MEM_RESERVE 8192\r\n#define MEM_COMMIT 4096\r\n#define PAGE_READWRITE 4\r\n#define PAGE_WRITECOPY 8\r\n#define PAGE_EXECUTE_READ 32\r\n#define MEM_TOP_DOWN 1048576\r\n#define MEM_RELEASE 32768\r\n#define MAX_PATH 260\r\n//#define FORMAT_MESSAGE_IGNORE_INSERTS 512\r\n//#define FORMAT_MESSAGE_FROM_SYSTEM 4096\r\n//#define WAIT_OBJECT_0 0\r\n#define STD_INPUT_HANDLE (DWORD)(0xfffffff6)\r\n#define STD_OUTPUT_HANDLE (DWORD)(0xfffffff5)\r\n#define STD_ERROR_HANDLE (DWORD)(0xfffffff4)\r\n#define ENABLE_LINE_INPUT 2\r\n#define ENABLE_ECHO_INPUT 4\r\n#define ENABLE_PROCESSED_INPUT 1\r\n#define ENABLE_WINDOW_INPUT 8\r\n#define ENABLE_MOUSE_INPUT 16\r\n#define ENABLE_PROCESSED_OUTPUT 1\r\n#define CONST const\r\n\r\n#define CAPSLOCK_ON 128\r\n#define ENHANCED_KEY 256\r\n#define LEFT_ALT_PRESSED 2\r\n#define LEFT_CTRL_PRESSED 8\r\n#define NUMLOCK_ON 32\r\n#define RIGHT_ALT_PRESSED 1\r\n#define RIGHT_CTRL_PRESSED 4\r\n#define SCROLLLOCK_ON 64\r\n#define SHIFT_PRESSED 16\r\n#define FROM_LEFT_1ST_BUTTON_PRESSED 1\r\n#define RIGHTMOST_BUTTON_PRESSED 2\r\n#define FROM_LEFT_2ND_BUTTON_PRESSED 4\r\n#define FROM_LEFT_3RD_BUTTON_PRESSED 8\r\n#define FROM_LEFT_4TH_BUTTON_PRESSED 16\r\n#define DOUBLE_CLICK 2\r\n#define MOUSE_MOVED 1\r\n#define KEY_EVENT 1\r\n#define MOUSE_EVENT 2\r\n#define WINDOW_BUFFER_SIZE_EVENT 4\r\n#define MENU_EVENT 8\r\n#define FOCUS_EVENT 16\r\n\r\n//for PlaySound\r\n#define SND_SYNC 0 \r\n#define SND_ASYNC 1 \r\n#define SND_NODEFAULT 2 \r\n#define SND_MEMORY 4 \r\n#define SND_LOOP 8 \r\n#define SND_NOSTOP 16 \r\n#define SND_NOWAIT 8192 \r\n#define SND_ALIAS 65536 \r\n#define SND_ALIAS_ID 0x110000 \r\n#define SND_FILENAME 0x20000 \r\n#define SND_RESOURCE 0x40004 \r\n\r\n#define CW_USEDEFAULT 0x80000000\r\n#define CS_BYTEALIGNCLIENT 4096\r\n#define CS_BYTEALIGNWINDOW 8192\r\n#define CS_KEYCVTWINDOW 4\r\n#define CS_NOKEYCVT 256\r\n#define CS_CLASSDC 64\r\n#define CS_DBLCLKS 8\r\n#define CS_GLOBALCLASS 16384\r\n#define CS_IME 0x10000\r\n#define CS_DROPSHADOW 0x20000\r\n#define CS_HREDRAW 2\r\n#define CS_NOCLOSE 512\r\n#define CS_OWNDC 32\r\n#define CS_PARENTDC 128\r\n#define CS_SAVEBITS 2048\r\n#define CS_VREDRAW 1\r\n\r\n#define IDI_APPLICATION MAKEINTRESOURCE(32512)\r\n#define IDC_ARROW MAKEINTRESOURCE(32512)\r\n\r\n#define BLACK_BRUSH 4\r\n#define DKGRAY_BRUSH 3\r\n#define GRAY_BRUSH 2\r\n#define HOLLOW_BRUSH 5\r\n#define LTGRAY_BRUSH 1\r\n#define NULL_BRUSH 5\r\n#define WHITE_BRUSH 0\r\n#define BLACK_PEN 7\r\n#define NULL_PEN 8\r\n#define WHITE_PEN 6\r\n\r\n#define MB_USERICON 128\r\n#define MB_ICONASTERISK 64\r\n#define MB_ICONEXCLAMATION 0x30\r\n#define MB_ICONWARNING 0x30\r\n#define MB_ICONERROR 16\r\n#define MB_ICONHAND 16\r\n#define MB_ICONQUESTION 32\r\n#define MB_OK 0\r\n#define MB_ABORTRETRYIGNORE 2\r\n#define MB_APPLMODAL 0\r\n#define MB_DEFAULT_DESKTOP_ONLY 0x20000\r\n#define MB_HELP 0x4000\r\n#define MB_RIGHT 0x80000\r\n#define MB_RTLREADING 0x100000\r\n#define MB_TOPMOST 0x40000\r\n#define MB_DEFBUTTON1 0\r\n#define MB_DEFBUTTON2 256\r\n#define MB_DEFBUTTON3 512\r\n#define MB_DEFBUTTON4 0x300\r\n#define MB_ICONINFORMATION 64\r\n#define MB_ICONSTOP 16\r\n#define MB_OKCANCEL 1\r\n#define MB_RETRYCANCEL 0x5\r\n#define MB_SERVICE_NOTIFICATION 0x40000\r\n#define MB_SETFOREGROUND 0x10000\r\n#define MB_SYSTEMMODAL 4096\r\n#define MB_TASKMODAL 0x2000\r\n#define MB_YESNO 4\r\n#define MB_YESNOCANCEL 3\r\n\r\n#define DT_BOTTOM 8\r\n#define DT_CALCRECT 1024\r\n#define DT_CENTER 1\r\n#define DT_EDITCONTROL 8192\r\n#define DT_END_ELLIPSIS 32768\r\n#define DT_PATH_ELLIPSIS 16384\r\n#define DT_EXPANDTABS 64\r\n#define DT_EXTERNALLEADING 512\r\n#define DT_LEFT 0\r\n#define DT_MODIFYSTRING 65536\r\n#define DT_NOCLIP 256\r\n#define DT_NOPREFIX 2048\r\n#define DT_RIGHT 2\r\n#define DT_RTLREADING 131072\r\n#define DT_SINGLELINE 32\r\n#define DT_TABSTOP 128\r\n#define DT_TOP 0\r\n#define DT_VCENTER 4\r\n#define DT_WORDBREAK 16\r\n#define DT_INTERNAL 4096\r\n#define DT_WORD_ELLIPSIS 0x40000\r\n#define DT_NOFULLWIDTHCHARBREAK 0x80000\r\n#define DT_HIDEPREFIX 0x100000\r\n#define DT_PREFIXONLY 0x200000\r\n\r\n#define HKEY_CLASSES_ROOT (HKEY)0x80000000\r\n#define HKEY_CURRENT_USER (HKEY)0x80000001\r\n#define HKEY_LOCAL_MACHINE (HKEY)0x80000002\r\n#define HKEY_USERS (HKEY)(-2147483645)\r\n#define HKEY_PERFORMANCE_DATA (HKEY)(-2147483644)\r\n#define HKEY_CURRENT_CONFIG (HKEY)(-2147483643)\r\n#define HKEY_DYN_DATA ((HKEY)(0x80000006))\r\n\r\n#define KEY_QUERY_VALUE 1\r\n#define KEY_SET_VALUE 2\r\n#define KEY_CREATE_SUB_KEY 4\r\n#define KEY_ENUMERATE_SUB_KEYS 8\r\n#define KEY_NOTIFY 16\r\n#define KEY_CREATE_LINK 32\r\n#define KEY_ALL_ACCESS 0xF003F\r\n#define KEY_EXECUTE 0x20019\r\n#define KEY_READ 0x20019\r\n#define KEY_WRITE 0x20006\r\n\r\n#define NO_ERROR 0\r\n#define ERROR_SUCCESS 0\r\n#define ERROR_INVALID_FUNCTION 1\r\n#define ERROR_FILE_NOT_FOUND 2\r\n#define ERROR_PATH_NOT_FOUND 3\r\n#define ERROR_TOO_MANY_OPEN_FILES 4\r\n#define ERROR_ACCESS_DENIED 5\r\n#define ERROR_INVALID_HANDLE 6\r\n#define ERROR_ARENA_TRASHED 7\r\n#define ERROR_NOT_ENOUGH_MEMORY 8\r\n#define ERROR_INVALID_BLOCK 9\r\n#define ERROR_BAD_ENVIRONMENT 10\r\n#define ERROR_BAD_FORMAT 11\r\n#define ERROR_INVALID_ACCESS 12\r\n#define ERROR_INVALID_DATA 13\r\n#define ERROR_OUTOFMEMORY 14\r\n#define ERROR_INVALID_DRIVE 15\r\n#define ERROR_CURRENT_DIRECTORY 16\r\n#define ERROR_NOT_SAME_DEVICE 17\r\n#define ERROR_NO_MORE_FILES 18\r\n#define ERROR_WRITE_PROTECT 19\r\n#define ERROR_BAD_UNIT 20\r\n#define ERROR_NOT_READY 21\r\n#define ERROR_BAD_COMMAND 22\r\n#define ERROR_CRC 23\r\n#define ERROR_BAD_LENGTH 24\r\n#define ERROR_SEEK 25\r\n#define ERROR_NOT_DOS_DISK 26\r\n#define ERROR_SECTOR_NOT_FOUND 27\r\n#define ERROR_OUT_OF_PAPER 28\r\n#define ERROR_WRITE_FAULT 29\r\n#define ERROR_READ_FAULT 30\r\n#define ERROR_GEN_FAILURE 31\r\n#define ERROR_SHARING_VIOLATION 32\r\n#define ERROR_LOCK_VIOLATION 33\r\n#define ERROR_WRONG_DISK 34\r\n#define ERROR_SHARING_BUFFER_EXCEEDED 36\r\n#define ERROR_HANDLE_EOF 38\r\n#define ERROR_HANDLE_DISK_FULL 39\r\n#define ERROR_NOT_SUPPORTED 50\r\n#define ERROR_REM_NOT_LIST 51\r\n#define ERROR_DUP_NAME 52\r\n#define ERROR_BAD_NETPATH 53\r\n#define ERROR_NETWORK_BUSY 54\r\n#define ERROR_DEV_NOT_EXIST 55\r\n#define ERROR_TOO_MANY_CMDS 56\r\n#define ERROR_ADAP_HDW_ERR 57\r\n#define ERROR_BAD_NET_RESP 58\r\n#define ERROR_UNEXP_NET_ERR 59\r\n#define ERROR_BAD_REM_ADAP 60\r\n#define ERROR_PRINTQ_FULL 61\r\n#define ERROR_NO_SPOOL_SPACE 62\r\n#define ERROR_PRINT_CANCELLED 63\r\n#define ERROR_NETNAME_DELETED 64\r\n#define ERROR_NETWORK_ACCESS_DENIED 65\r\n#define ERROR_BAD_DEV_TYPE 66\r\n#define ERROR_BAD_NET_NAME 67\r\n#define ERROR_TOO_MANY_NAMES 68\r\n#define ERROR_TOO_MANY_SESS 69\r\n#define ERROR_SHARING_PAUSED 70\r\n#define ERROR_REQ_NOT_ACCEP 71\r\n#define ERROR_REDIR_PAUSED 72\r\n#define ERROR_FILE_EXISTS 80\r\n#define ERROR_CANNOT_MAKE 82\r\n#define ERROR_FAIL_I24 83\r\n#define ERROR_OUT_OF_STRUCTURES 84\r\n#define ERROR_ALREADY_ASSIGNED 85\r\n#define ERROR_INVALID_PASSWORD 86\r\n#define ERROR_INVALID_PARAMETER 87\r\n#define ERROR_NET_WRITE_FAULT 88\r\n#define ERROR_NO_PROC_SLOTS 89\r\n#define ERROR_TOO_MANY_SEMAPHORES 100\r\n#define ERROR_EXCL_SEM_ALREADY_OWNED 101\r\n#define ERROR_SEM_IS_SET 102\r\n#define ERROR_TOO_MANY_SEM_REQUESTS 103\r\n#define ERROR_INVALID_AT_INTERRUPT_TIME 104\r\n#define ERROR_SEM_OWNER_DIED 105\r\n#define ERROR_SEM_USER_LIMIT 106\r\n#define ERROR_DISK_CHANGE 107\r\n#define ERROR_DRIVE_LOCKED 108\r\n#define ERROR_BROKEN_PIPE 109\r\n#define ERROR_OPEN_FAILED 110\r\n#define ERROR_BUFFER_OVERFLOW 111\r\n#define ERROR_DISK_FULL 112\r\n#define ERROR_NO_MORE_SEARCH_HANDLES 113\r\n#define ERROR_INVALID_TARGET_HANDLE 114\r\n#define ERROR_INVALID_CATEGORY 117\r\n#define ERROR_INVALID_VERIFY_SWITCH 118\r\n#define ERROR_BAD_DRIVER_LEVEL 119\r\n#define ERROR_CALL_NOT_IMPLEMENTED 120\r\n#define ERROR_SEM_TIMEOUT 121\r\n#define ERROR_INSUFFICIENT_BUFFER 122\r\n#define ERROR_INVALID_NAME 123\r\n#define ERROR_INVALID_LEVEL 124\r\n#define ERROR_NO_VOLUME_LABEL 125\r\n#define ERROR_MOD_NOT_FOUND 126\r\n#define ERROR_PROC_NOT_FOUND 127\r\n#define ERROR_WAIT_NO_CHILDREN 128\r\n#define ERROR_CHILD_NOT_COMPLETE 129\r\n#define ERROR_DIRECT_ACCESS_HANDLE 130\r\n#define ERROR_NEGATIVE_SEEK 131\r\n#define ERROR_SEEK_ON_DEVICE 132\r\n#define ERROR_IS_JOIN_TARGET 133\r\n#define ERROR_IS_JOINED 134\r\n#define ERROR_IS_SUBSTED 135\r\n#define ERROR_NOT_JOINED 136\r\n#define ERROR_NOT_SUBSTED 137\r\n#define ERROR_JOIN_TO_JOIN 138\r\n#define ERROR_SUBST_TO_SUBST 139\r\n#define ERROR_JOIN_TO_SUBST 140\r\n#define ERROR_SUBST_TO_JOIN 141\r\n#define ERROR_BUSY_DRIVE 142\r\n#define ERROR_SAME_DRIVE 143\r\n#define ERROR_DIR_NOT_ROOT 144\r\n#define ERROR_DIR_NOT_EMPTY 145\r\n#define ERROR_IS_SUBST_PATH 146\r\n#define ERROR_IS_JOIN_PATH 147\r\n#define ERROR_PATH_BUSY 148\r\n#define ERROR_IS_SUBST_TARGET 149\r\n#define ERROR_SYSTEM_TRACE 150\r\n#define ERROR_INVALID_EVENT_COUNT 151\r\n#define ERROR_TOO_MANY_MUXWAITERS 152\r\n#define ERROR_INVALID_LIST_FORMAT 153\r\n#define ERROR_LABEL_TOO_LONG 154\r\n#define ERROR_TOO_MANY_TCBS 155\r\n#define ERROR_SIGNAL_REFUSED 156\r\n#define ERROR_DISCARDED 157\r\n#define ERROR_NOT_LOCKED 158\r\n#define ERROR_BAD_THREADID_ADDR 159\r\n#define ERROR_BAD_ARGUMENTS 160\r\n#define ERROR_BAD_PATHNAME 161\r\n#define ERROR_SIGNAL_PENDING 162\r\n#define ERROR_MAX_THRDS_REACHED 164\r\n#define ERROR_LOCK_FAILED 167\r\n#define ERROR_BUSY 170\r\n#define ERROR_CANCEL_VIOLATION 173\r\n#define ERROR_ATOMIC_LOCKS_NOT_SUPPORTED 174\r\n#define ERROR_INVALID_SEGMENT_NUMBER 180\r\n#define ERROR_INVALID_ORDINAL 182\r\n#define ERROR_ALREADY_EXISTS 183\r\n#define ERROR_INVALID_FLAG_NUMBER 186\r\n#define ERROR_SEM_NOT_FOUND 187\r\n#define ERROR_INVALID_STARTING_CODESEG 188\r\n#define ERROR_INVALID_STACKSEG 189\r\n#define ERROR_INVALID_MODULETYPE 190\r\n#define ERROR_INVALID_EXE_SIGNATURE 191\r\n#define ERROR_EXE_MARKED_INVALID 192\r\n#define ERROR_EXE_MACHINE_TYPE_MISMATCH 216\r\n#define ERROR_BAD_EXE_FORMAT 193\r\n#define ERROR_ITERATED_DATA_EXCEEDS_64k 194\r\n#define ERROR_INVALID_MINALLOCSIZE 195\r\n#define ERROR_DYNLINK_FROM_INVALID_RING 196\r\n#define ERROR_IOPL_NOT_ENABLED 197\r\n#define ERROR_INVALID_SEGDPL 198\r\n#define ERROR_AUTODATASEG_EXCEEDS_64k 199\r\n#define ERROR_RING2SEG_MUST_BE_MOVABLE 200\r\n#define ERROR_RELOC_CHAIN_XEEDS_SEGLIM 201\r\n#define ERROR_INFLOOP_IN_RELOC_CHAIN 202\r\n#define ERROR_ENVVAR_NOT_FOUND 203\r\n#define ERROR_NO_SIGNAL_SENT 205\r\n#define ERROR_FILENAME_EXCED_RANGE 206\r\n#define ERROR_RING2_STACK_IN_USE 207\r\n#define ERROR_META_EXPANSION_TOO_LONG 208\r\n#define ERROR_INVALID_SIGNAL_NUMBER 209\r\n#define ERROR_THREAD_1_INACTIVE 210\r\n#define ERROR_LOCKED 212\r\n#define ERROR_TOO_MANY_MODULES 214\r\n#define ERROR_NESTING_NOT_ALLOWED 215\r\n#define ERROR_BAD_PIPE 230\r\n#define ERROR_PIPE_BUSY 231\r\n#define ERROR_NO_DATA 232\r\n#define ERROR_PIPE_NOT_CONNECTED 233\r\n#define ERROR_MORE_DATA 234\r\n#define ERROR_VC_DISCONNECTED 240\r\n#define ERROR_INVALID_EA_NAME 254\r\n#define ERROR_EA_LIST_INCONSISTENT 255\r\n#define ERROR_NO_MORE_ITEMS 259\r\n#define ERROR_CANNOT_COPY 266\r\n#define ERROR_DIRECTORY 267\r\n#define ERROR_EAS_DIDNT_FIT 275\r\n#define ERROR_EA_FILE_CORRUPT 276\r\n#define ERROR_EA_TABLE_FULL 277\r\n#define ERROR_INVALID_EA_HANDLE 278\r\n#define ERROR_EAS_NOT_SUPPORTED 282\r\n#define ERROR_NOT_OWNER 288\r\n#define ERROR_TOO_MANY_POSTS 298\r\n#define ERROR_PARTIAL_COPY 299\r\n#define ERROR_MR_MID_NOT_FOUND 317\r\n#define ERROR_INVALID_ADDRESS 487\r\n#define ERROR_ARITHMETIC_OVERFLOW 534\r\n#define ERROR_PIPE_CONNECTED 535\r\n#define ERROR_PIPE_LISTENING 536\r\n#define ERROR_EA_ACCESS_DENIED 994\r\n#define ERROR_OPERATION_ABORTED 995\r\n#define ERROR_IO_INCOMPLETE 996\r\n#define ERROR_IO_PENDING 997\r\n#define ERROR_NOACCESS 998\r\n#define ERROR_SWAPERROR 999\r\n#define ERROR_STACK_OVERFLOW 1001\r\n#define ERROR_INVALID_MESSAGE 1002\r\n#define ERROR_CAN_NOT_COMPLETE 1003\r\n#define ERROR_INVALID_FLAGS 1004\r\n#define ERROR_UNRECOGNIZED_VOLUME 1005\r\n#define ERROR_FILE_INVALID 1006\r\n#define ERROR_FULLSCREEN_MODE 1007\r\n#define ERROR_NO_TOKEN 1008\r\n#define ERROR_BADDB 1009\r\n#define ERROR_BADKEY 1010\r\n#define ERROR_CANTOPEN 1011\r\n#define ERROR_CANTREAD 1012\r\n#define ERROR_CANTWRITE 1013\r\n#define ERROR_REGISTRY_RECOVERED 1014\r\n#define ERROR_REGISTRY_CORRUPT 1015\r\n#define ERROR_REGISTRY_IO_FAILED 1016\r\n#define ERROR_NOT_REGISTRY_FILE 1017\r\n#define ERROR_KEY_DELETED 1018\r\n#define ERROR_NO_LOG_SPACE 1019\r\n#define ERROR_KEY_HAS_CHILDREN 1020\r\n#define ERROR_CHILD_MUST_BE_VOLATILE 1021\r\n#define ERROR_NOTIFY_ENUM_DIR 1022\r\n#define ERROR_DEPENDENT_SERVICES_RUNNING 1051\r\n#define ERROR_INVALID_SERVICE_CONTROL 1052\r\n#define ERROR_SERVICE_REQUEST_TIMEOUT 1053\r\n#define ERROR_SERVICE_NO_THREAD 1054\r\n#define ERROR_SERVICE_DATABASE_LOCKED 1055\r\n#define ERROR_SERVICE_ALREADY_RUNNING 1056\r\n#define ERROR_INVALID_SERVICE_ACCOUNT 1057\r\n#define ERROR_SERVICE_DISABLED 1058\r\n#define ERROR_CIRCULAR_DEPENDENCY 1059\r\n#define ERROR_SERVICE_DOES_NOT_EXIST 1060\r\n#define ERROR_SERVICE_CANNOT_ACCEPT_CTRL 1061\r\n#define ERROR_SERVICE_NOT_ACTIVE 1062\r\n#define ERROR_FAILED_SERVICE_CONTROLLER_CONNECT 1063\r\n#define ERROR_EXCEPTION_IN_SERVICE 1064\r\n#define ERROR_DATABASE_DOES_NOT_EXIST 1065\r\n#define ERROR_SERVICE_SPECIFIC_ERROR 1066\r\n#define ERROR_PROCESS_ABORTED 1067\r\n#define ERROR_SERVICE_DEPENDENCY_FAIL 1068\r\n#define ERROR_SERVICE_LOGON_FAILED 1069\r\n#define ERROR_SERVICE_START_HANG 1070\r\n#define ERROR_INVALID_SERVICE_LOCK 1071\r\n#define ERROR_SERVICE_MARKED_FOR_DELETE 1072\r\n#define ERROR_SERVICE_EXISTS 1073\r\n#define ERROR_ALREADY_RUNNING_LKG 1074\r\n#define ERROR_SERVICE_DEPENDENCY_DELETED 1075\r\n#define ERROR_BOOT_ALREADY_ACCEPTED 1076\r\n#define ERROR_SERVICE_NEVER_STARTED 1077\r\n#define ERROR_DUPLICATE_SERVICE_NAME 1078\r\n#define ERROR_DIFFERENT_SERVICE_ACCOUNT 1079\r\n#define ERROR_END_OF_MEDIA 1100\r\n#define ERROR_FILEMARK_DETECTED 1101\r\n#define ERROR_BEGINNING_OF_MEDIA 1102\r\n#define ERROR_SETMARK_DETECTED 1103\r\n#define ERROR_NO_DATA_DETECTED 1104\r\n#define ERROR_PARTITION_FAILURE 1105\r\n#define ERROR_INVALID_BLOCK_LENGTH 1106\r\n\r\n#define ERROR_DEVICE_NOT_PARTITIONED 1107\r\n#define ERROR_UNABLE_TO_LOCK_MEDIA 1108\r\n#define ERROR_UNABLE_TO_UNLOAD_MEDIA 1109\r\n#define ERROR_MEDIA_CHANGED 1110\r\n#define ERROR_BUS_RESET 1111\r\n#define ERROR_NO_MEDIA_IN_DRIVE 1112\r\n#define ERROR_NO_UNICODE_TRANSLATION 1113\r\n#define ERROR_DLL_INIT_FAILED 1114\r\n#define ERROR_SHUTDOWN_IN_PROGRESS 1115\r\n#define ERROR_NO_SHUTDOWN_IN_PROGRESS 1116\r\n#define ERROR_IO_DEVICE 1117\r\n#define ERROR_SERIAL_NO_DEVICE 1118\r\n#define ERROR_IRQ_BUSY 1119\r\n#define ERROR_MORE_WRITES 1120\r\n#define ERROR_COUNTER_TIMEOUT 1121\r\n#define ERROR_FLOPPY_ID_MARK_NOT_FOUND 1122\r\n#define ERROR_FLOPPY_WRONG_CYLINDER 1123\r\n#define ERROR_FLOPPY_UNKNOWN_ERROR 1124\r\n#define ERROR_FLOPPY_BAD_REGISTERS 1125\r\n#define ERROR_DISK_RECALIBRATE_FAILED 1126\r\n#define ERROR_DISK_OPERATION_FAILED 1127\r\n#define ERROR_DISK_RESET_FAILED 1128\r\n#define ERROR_EOM_OVERFLOW 1129\r\n#define ERROR_NOT_ENOUGH_SERVER_MEMORY 1130\r\n#define ERROR_POSSIBLE_DEADLOCK 1131\r\n#define ERROR_MAPPED_ALIGNMENT 1132\r\n#define ERROR_SET_POWER_STATE_VETOED 1140\r\n#define ERROR_SET_POWER_STATE_FAILED 1141\r\n#define ERROR_TOO_MANY_LINKS 1142\r\n#define ERROR_OLD_WIN_VERSION 1150\r\n#define ERROR_APP_WRONG_OS 1151\r\n#define ERROR_SINGLE_INSTANCE_APP 1152\r\n#define ERROR_RMODE_APP 1153\r\n#define ERROR_INVALID_DLL 1154\r\n#define ERROR_NO_ASSOCIATION 1155\r\n#define ERROR_DDE_FAIL 1156\r\n#define ERROR_DLL_NOT_FOUND 1157\r\n#define ERROR_BAD_USERNAME 2202\r\n#define ERROR_NOT_CONNECTED 2250\r\n#define ERROR_OPEN_FILES 2401\r\n#define ERROR_ACTIVE_CONNECTIONS 2402\r\n#define ERROR_DEVICE_IN_USE 2404\r\n#define ERROR_BAD_DEVICE 1200\r\n#define ERROR_CONNECTION_UNAVAIL 1201\r\n#define ERROR_DEVICE_ALREADY_REMEMBERED 1202\r\n#define ERROR_NO_NET_OR_BAD_PATH 1203\r\n#define ERROR_BAD_PROVIDER 1204\r\n#define ERROR_CANNOT_OPEN_PROFILE 1205\r\n#define ERROR_BAD_PROFILE 1206\r\n#define ERROR_NOT_CONTAINER 1207\r\n#define ERROR_EXTENDED_ERROR 1208\r\n#define ERROR_INVALID_GROUPNAME 1209\r\n#define ERROR_INVALID_COMPUTERNAME 1210\r\n#define ERROR_INVALID_EVENTNAME 1211\r\n#define ERROR_INVALID_DOMAINNAME 1212\r\n#define ERROR_INVALID_SERVICENAME 1213\r\n#define ERROR_INVALID_NETNAME 1214\r\n#define ERROR_INVALID_SHARENAME 1215\r\n#define ERROR_INVALID_PASSWORDNAME 1216\r\n#define ERROR_INVALID_MESSAGENAME 1217\r\n#define ERROR_INVALID_MESSAGEDEST 1218\r\n#define ERROR_SESSION_CREDENTIAL_CONFLICT 1219\r\n#define ERROR_REMOTE_SESSION_LIMIT_EXCEEDED 1220\r\n#define ERROR_DUP_DOMAINNAME 1221\r\n#define ERROR_NO_NETWORK 1222\r\n#define ERROR_CANCELLED 1223\r\n#define ERROR_USER_MAPPED_FILE 1224\r\n#define ERROR_CONNECTION_REFUSED 1225\r\n#define ERROR_GRACEFUL_DISCONNECT 1226\r\n#define ERROR_ADDRESS_ALREADY_ASSOCIATED 1227\r\n#define ERROR_ADDRESS_NOT_ASSOCIATED 1228\r\n#define ERROR_CONNECTION_INVALID 1229\r\n#define ERROR_CONNECTION_ACTIVE 1230\r\n#define ERROR_NETWORK_UNREACHABLE 1231\r\n#define ERROR_HOST_UNREACHABLE 1232\r\n#define ERROR_PROTOCOL_UNREACHABLE 1233\r\n#define ERROR_PORT_UNREACHABLE 1234\r\n#define ERROR_REQUEST_ABORTED 1235\r\n#define ERROR_CONNECTION_ABORTED 1236\r\n#define ERROR_RETRY 1237\r\n#define ERROR_CONNECTION_COUNT_LIMIT 1238\r\n#define ERROR_LOGIN_TIME_RESTRICTION 1239\r\n#define ERROR_LOGIN_WKSTA_RESTRICTION 1240\r\n#define ERROR_INCORRECT_ADDRESS 1241\r\n#define ERROR_ALREADY_REGISTERED 1242\r\n#define ERROR_SERVICE_NOT_FOUND 1243\r\n#define ERROR_NOT_AUTHENTICATED 1244\r\n#define ERROR_NOT_LOGGED_ON 1245\r\n#define ERROR_CONTINUE 1246\r\n#define ERROR_ALREADY_INITIALIZED 1247\r\n#define ERROR_NO_MORE_DEVICES 1248\r\n#define ERROR_NOT_ALL_ASSIGNED 1300\r\n#define ERROR_SOME_NOT_MAPPED 1301\r\n#define ERROR_NO_QUOTAS_FOR_ACCOUNT 1302\r\n#define ERROR_LOCAL_USER_SESSION_KEY 1303\r\n#define ERROR_NULL_LM_PASSWORD 1304\r\n#define ERROR_UNKNOWN_REVISION 1305\r\n#define ERROR_REVISION_MISMATCH 1306\r\n#define ERROR_INVALID_OWNER 1307\r\n#define ERROR_INVALID_PRIMARY_GROUP 1308\r\n#define ERROR_NO_IMPERSONATION_TOKEN 1309\r\n#define ERROR_CANT_DISABLE_MANDATORY 1310\r\n#define ERROR_NO_LOGON_SERVERS 1311\r\n#define ERROR_NO_SUCH_LOGON_SESSION 1312\r\n#define ERROR_NO_SUCH_PRIVILEGE 1313\r\n#define ERROR_PRIVILEGE_NOT_HELD 1314\r\n#define ERROR_INVALID_ACCOUNT_NAME 1315\r\n#define ERROR_USER_EXISTS 1316\r\n#define ERROR_NO_SUCH_USER 1317\r\n#define ERROR_GROUP_EXISTS 1318\r\n#define ERROR_NO_SUCH_GROUP 1319\r\n#define ERROR_MEMBER_IN_GROUP 1320\r\n#define ERROR_MEMBER_NOT_IN_GROUP 1321\r\n#define ERROR_LAST_ADMIN 1322\r\n#define ERROR_WRONG_PASSWORD 1323\r\n#define ERROR_ILL_FORMED_PASSWORD 1324\r\n#define ERROR_PASSWORD_RESTRICTION 1325\r\n#define ERROR_LOGON_FAILURE 1326\r\n#define ERROR_ACCOUNT_RESTRICTION 1327\r\n#define ERROR_INVALID_LOGON_HOURS 1328\r\n#define ERROR_INVALID_WORKSTATION 1329\r\n#define ERROR_PASSWORD_EXPIRED 1330\r\n#define ERROR_ACCOUNT_DISABLED 1331\r\n#define ERROR_NONE_MAPPED 1332\r\n#define ERROR_TOO_MANY_LUIDS_REQUESTED 1333\r\n#define ERROR_LUIDS_EXHAUSTED 1334\r\n#define ERROR_INVALID_SUB_AUTHORITY 1335\r\n#define ERROR_INVALID_ACL 1336\r\n#define ERROR_INVALID_SID 1337\r\n#define ERROR_INVALID_SECURITY_DESCR 1338\r\n#define ERROR_BAD_INHERITANCE_ACL 1340\r\n#define ERROR_SERVER_DISABLED 1341\r\n#define ERROR_SERVER_NOT_DISABLED 1342\r\n#define ERROR_INVALID_ID_AUTHORITY 1343\r\n#define ERROR_ALLOTTED_SPACE_EXCEEDED 1344\r\n#define ERROR_INVALID_GROUP_ATTRIBUTES 1345\r\n#define ERROR_BAD_IMPERSONATION_LEVEL 1346\r\n#define ERROR_CANT_OPEN_ANONYMOUS 1347\r\n#define ERROR_BAD_VALIDATION_CLASS 1348\r\n#define ERROR_BAD_TOKEN_TYPE 1349\r\n#define ERROR_NO_SECURITY_ON_OBJECT 1350\r\n#define ERROR_CANT_ACCESS_DOMAIN_INFO 1351\r\n#define ERROR_INVALID_SERVER_STATE 1352\r\n#define ERROR_INVALID_DOMAIN_STATE 1353\r\n#define ERROR_INVALID_DOMAIN_ROLE 1354\r\n#define ERROR_NO_SUCH_DOMAIN 1355\r\n#define ERROR_DOMAIN_EXISTS 1356\r\n#define ERROR_DOMAIN_LIMIT_EXCEEDED 1357\r\n#define ERROR_INTERNAL_DB_CORRUPTION 1358\r\n#define ERROR_INTERNAL_ERROR 1359\r\n#define ERROR_GENERIC_NOT_MAPPED 1360\r\n#define ERROR_BAD_DESCRIPTOR_FORMAT 1361\r\n#define ERROR_NOT_LOGON_PROCESS 1362\r\n#define ERROR_LOGON_SESSION_EXISTS 1363\r\n#define ERROR_NO_SUCH_PACKAGE 1364\r\n#define ERROR_BAD_LOGON_SESSION_STATE 1365\r\n#define ERROR_LOGON_SESSION_COLLISION 1366\r\n#define ERROR_INVALID_LOGON_TYPE 1367\r\n#define ERROR_CANNOT_IMPERSONATE 1368\r\n#define ERROR_RXACT_INVALID_STATE 1369\r\n#define ERROR_RXACT_COMMIT_FAILURE 1370\r\n#define ERROR_SPECIAL_ACCOUNT 1371\r\n#define ERROR_SPECIAL_GROUP 1372\r\n#define ERROR_SPECIAL_USER 1373\r\n#define ERROR_MEMBERS_PRIMARY_GROUP 1374\r\n#define ERROR_TOKEN_ALREADY_IN_USE 1375\r\n#define ERROR_NO_SUCH_ALIAS 1376\r\n#define ERROR_MEMBER_NOT_IN_ALIAS 1377\r\n#define ERROR_MEMBER_IN_ALIAS 1378\r\n#define ERROR_ALIAS_EXISTS 1379\r\n#define ERROR_LOGON_NOT_GRANTED 1380\r\n#define ERROR_TOO_MANY_SECRETS 1381\r\n#define ERROR_SECRET_TOO_LONG 1382\r\n#define ERROR_INTERNAL_DB_ERROR 1383\r\n#define ERROR_TOO_MANY_CONTEXT_IDS 1384\r\n#define ERROR_LOGON_TYPE_NOT_GRANTED 1385\r\n#define ERROR_NT_CROSS_ENCRYPTION_REQUIRED 1386\r\n#define ERROR_NO_SUCH_MEMBER 1387\r\n#define ERROR_INVALID_MEMBER 1388\r\n#define ERROR_TOO_MANY_SIDS 1389\r\n#define ERROR_LM_CROSS_ENCRYPTION_REQUIRED 1390\r\n#define ERROR_NO_INHERITANCE 1391\r\n#define ERROR_FILE_CORRUPT 1392\r\n#define ERROR_DISK_CORRUPT 1393\r\n#define ERROR_NO_USER_SESSION_KEY 1394\r\n#define ERROR_LICENSE_QUOTA_EXCEEDED 1395\r\n#define ERROR_INVALID_WINDOW_HANDLE 1400\r\n#define ERROR_INVALID_MENU_HANDLE 1401\r\n#define ERROR_INVALID_CURSOR_HANDLE 1402\r\n#define ERROR_INVALID_ACCEL_HANDLE 1403\r\n#define ERROR_INVALID_HOOK_HANDLE 1404\r\n#define ERROR_INVALID_DWP_HANDLE 1405\r\n#define ERROR_TLW_WITH_WSCHILD 1406\r\n#define ERROR_CANNOT_FIND_WND_CLASS 1407\r\n#define ERROR_WINDOW_OF_OTHER_THREAD 1408\r\n#define ERROR_HOTKEY_ALREADY_REGISTERED 1409\r\n#define ERROR_CLASS_ALREADY_EXISTS 1410\r\n#define ERROR_CLASS_DOES_NOT_EXIST 1411\r\n#define ERROR_CLASS_HAS_WINDOWS 1412\r\n#define ERROR_INVALID_INDEX 1413\r\n#define ERROR_INVALID_ICON_HANDLE 1414\r\n#define ERROR_PRIVATE_DIALOG_INDEX 1415\r\n#define ERROR_LISTBOX_ID_NOT_FOUND 1416\r\n#define ERROR_NO_WILDCARD_CHARACTERS 1417\r\n#define ERROR_CLIPBOARD_NOT_OPEN 1418\r\n#define ERROR_HOTKEY_NOT_REGISTERED 1419\r\n#define ERROR_WINDOW_NOT_DIALOG 1420\r\n#define ERROR_CONTROL_ID_NOT_FOUND 1421\r\n#define ERROR_INVALID_COMBOBOX_MESSAGE 1422\r\n#define ERROR_WINDOW_NOT_COMBOBOX 1423\r\n#define ERROR_INVALID_EDIT_HEIGHT 1424\r\n#define ERROR_DC_NOT_FOUND 1425\r\n#define ERROR_INVALID_HOOK_FILTER 1426\r\n#define ERROR_INVALID_FILTER_PROC 1427\r\n#define ERROR_HOOK_NEEDS_HMOD 1428\r\n#define ERROR_GLOBAL_ONLY_HOOK 1429\r\n#define ERROR_JOURNAL_HOOK_SET 1430\r\n#define ERROR_HOOK_NOT_INSTALLED 1431\r\n#define ERROR_INVALID_LB_MESSAGE 1432\r\n#define ERROR_SETCOUNT_ON_BAD_LB 1433\r\n#define ERROR_LB_WITHOUT_TABSTOPS 1434\r\n#define ERROR_DESTROY_OBJECT_OF_OTHER_THREAD 1435\r\n#define ERROR_CHILD_WINDOW_MENU 1436\r\n#define ERROR_NO_SYSTEM_MENU 1437\r\n#define ERROR_INVALID_MSGBOX_STYLE 1438\r\n#define ERROR_INVALID_SPI_VALUE 1439\r\n#define ERROR_SCREEN_ALREADY_LOCKED 1440\r\n#define ERROR_HWNDS_HAVE_DIFF_PARENT 1441\r\n#define ERROR_NOT_CHILD_WINDOW 1442\r\n#define ERROR_INVALID_GW_COMMAND 1443\r\n#define ERROR_INVALID_THREAD_ID 1444\r\n#define ERROR_NON_MDICHILD_WINDOW 1445\r\n#define ERROR_POPUP_ALREADY_ACTIVE 1446\r\n#define ERROR_NO_SCROLLBARS 1447\r\n#define ERROR_INVALID_SCROLLBAR_RANGE 1448\r\n#define ERROR_INVALID_SHOWWIN_COMMAND 1449\r\n#define ERROR_NO_SYSTEM_RESOURCES 1450\r\n#define ERROR_NONPAGED_SYSTEM_RESOURCES 1451\r\n#define ERROR_PAGED_SYSTEM_RESOURCES 1452\r\n#define ERROR_WORKING_SET_QUOTA 1453\r\n#define ERROR_PAGEFILE_QUOTA 1454\r\n#define ERROR_COMMITMENT_LIMIT 1455\r\n#define ERROR_MENU_ITEM_NOT_FOUND 1456\r\n#define ERROR_INVALID_KEYBOARD_HANDLE 1457\r\n#define ERROR_HOOK_TYPE_NOT_ALLOWED 1458\r\n#define ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION 1459\r\n#define ERROR_EVENTLOG_FILE_CORRUPT 1500\r\n#define ERROR_EVENTLOG_CANT_START 1501\r\n#define ERROR_LOG_FILE_FULL 1502\r\n#define ERROR_EVENTLOG_FILE_CHANGED 1503\r\n\r\n#define OWNER_SECURITY_INFORMATION 0x00000001\r\n#define GROUP_SECURITY_INFORMATION 0x00000002\r\n\r\n#define TOKEN_QUERY (0x0008)\r\n\r\n\r\n/*\r\nproc\r\n*/\r\n#define DECLARE_HANDLE(n) typedef HANDLE n\r\n\r\ntypedef float FLOAT;\r\ntypedef int INT;\r\ntypedef unsigned char BYTE;\r\ntypedef BYTE* LPBYTE;\r\ntypedef struct {int dummy;} *HWND;\r\ntypedef const char *LPCSTR;\r\ntypedef char *LPSTR;\r\ntypedef unsigned int UINT;\r\ntypedef void* HANDLE;\r\ntypedef void* HINSTANCE;\r\ntypedef void* HMODULE;\r\ntypedef void* HLOCAL;\r\ntypedef void* LPVOID;\r\ntypedef void* HFONT;\r\ntypedef void* HDWP;\r\ntypedef unsigned short *LPWSTR;\r\n//typedef short *LPWSTR;\r\n//typedef const signed short *LPCWSTR;\r\ntypedef const unsigned short *LPCWSTR;\r\ntypedef const void* LPCVOID;\r\ntypedef void* PVOID;\r\ntypedef int LONG;\r\ntypedef unsigned int ULONG;\r\ntypedef unsigned short WORD;\r\ntypedef unsigned long DWORD;\r\ntypedef DWORD* PDWORD;\r\ntypedef DWORD* LPDWORD;\r\ntypedef int BOOL;\r\ntypedef void VOID;\r\ntypedef long LONG_PTR;\r\ntypedef unsigned long ULONG_PTR;\r\ntypedef ULONG_PTR DWORD_PTR;\r\ntypedef unsigned long long ULONGLONG;\r\ntypedef signed long long LONGLONG;\r\ntypedef char CHAR;\r\ntypedef unsigned short WCHAR;\r\ntypedef short int SHORT;\r\ntypedef WORD* LPWORD;\r\ntypedef BOOL (CALLBACK *PHANDLER_ROUTINE) (DWORD);\r\ntypedef unsigned long long UINT_PTR;\r\ntypedef UINT_PTR WPARAM;\r\ntypedef LONG_PTR LPARAM;\r\ntypedef BYTE *PBYTE;\r\ntypedef unsigned long COLORREF;\r\ntypedef WORD ATOM;\r\ntypedef long LRESULT;\r\ntypedef HANDLE HICON;\r\ntypedef LRESULT (CALLBACK *WNDPROC) (HWND,UINT,WPARAM,LPARAM);\r\ntypedef HANDLE HCURSOR;\r\ntypedef char *PSTR;\r\ntypedef const unsigned short *LPCTSTR;\r\ntypedef DWORD (CALLBACK *PTHREAD_START_ROUTINE) (LPVOID);\r\ntypedef PTHREAD_START_ROUTINE LPTHREAD_START_ROUTINE;\r\ntypedef HANDLE HGLOBAL;\r\ntypedef HANDLE HDC;\r\ntypedef HANDLE HBITMAP;\r\ntypedef HANDLE HPEN;\r\ntypedef HANDLE HBRUSH;\r\ntypedef HANDLE *PHANDLE;\r\ntypedef HANDLE HMENU;\r\ntypedef HANDLE HGLRC;\r\ntypedef HANDLE HGDIOBJ;\r\ntypedef HANDLE HKEY,*PHKEY;\r\ntypedef DWORD ACCESS_MASK;\r\ntypedef ACCESS_MASK REGSAM;\r\ntypedef BOOL *LPBOOL;\r\ntypedef int *PINT;\r\ntypedef long *PLONG;\r\ntypedef short *PSHORT;\r\ntypedef ULONG_PTR SIZE_T;\r\ntypedef SIZE_T *PSIZE_T;\r\ntypedef HANDLE *LPHANDLE;\r\ntypedef long long int LONG64;\r\ntypedef unsigned short *PWORD;\r\ntypedef HANDLE HWAVEOUT;\r\ntypedef int MMRESULT;\r\ntypedef void* LPWAVEOUT;\r\ntypedef long long int INT_PTR;\r\ntypedef unsigned long long int UINT_PTR;\r\ntypedef BOOL (CALLBACK *DLGPROC) (HWND,UINT,WPARAM,LPARAM);\r\ntypedef int *LPINT;\r\n//typedef const unsigned short *LPCWSTR;\r\ntypedef const unsigned short *PCWSTR;\r\n\r\n/*\r\nproc\r\n*/\r\n\r\ntypedef struct _nmhdr {\r\n  HWND hwndFrom;\r\n  UINT idFrom;\r\n  UINT code;\r\n} NMHDR;\r\n\r\ntypedef struct tagWINDOWPOS {\r\n  HWND hwnd;\r\n  HWND hwndInsertAfter;\r\n  int  x;\r\n  int  y;\r\n  int  cx;\r\n  int  cy;\r\n  UINT flags;\r\n} WINDOWPOS, *LPWINDOWPOS, *PWINDOWPOS;\r\n\r\ntypedef struct tagPOINT {\r\n\tLONG x;\r\n\tLONG y;\r\n} POINT,*PPOINT;\r\n#define LPPOINT PPOINT\r\n\r\ntypedef struct tagMSG {\r\n\tHWND hwnd;\r\n\tUINT message;\r\n\tWPARAM wParam;\r\n\tLPARAM lParam;\r\n\tDWORD time;\r\n\tPOINT pt;\r\n} MSG,*LPMSG,*PMSG;\r\n\r\ntypedef struct _LIST_ENTRY {\r\n\tstruct _LIST_ENTRY *Flink;\r\n\tstruct _LIST_ENTRY *Blink;\r\n} LIST_ENTRY,*PLIST_ENTRY;\r\n\r\ntypedef struct _CONSOLE_CURSOR_INFO {\r\n\tDWORD dwSize;\r\n\tBOOL bVisible;\r\n} CONSOLE_CURSOR_INFO,*PCONSOLE_CURSOR_INFO;\r\n\r\ntypedef struct {\r\n\tPVOID BaseAddress;\r\n\tPVOID AllocationBase;\r\n\tDWORD AllocationProtect;\r\n\tDWORD RegionSize;\r\n\tDWORD State;\r\n\tDWORD Protect;\r\n\tDWORD Type;\r\n} MEMORY_BASIC_INFORMATION;\r\n\r\ntypedef struct _RTL_CRITICAL_SECTION_DEBUG {\r\n\tWORD Type;\r\n\tWORD CreatorBackTraceIndex;\r\n\tstruct _RTL_CRITICAL_SECTION *CriticalSection;\r\n\tLIST_ENTRY ProcessLocksList;\r\n\tDWORD EntryCount;\r\n\tDWORD ContentionCount;\r\n\tDWORD Spare[ 2];\r\n} RTL_CRITICAL_SECTION_DEBUG,*PRTL_CRITICAL_SECTION_DEBUG;\r\n\r\ntypedef struct {\r\n\tPRTL_CRITICAL_SECTION_DEBUG DebugInfo;\r\n\tLONG LockCount;\r\n\tLONG RecursionCount;\r\n\tHANDLE OwningThread;\r\n\tHANDLE LockSemaphore;\r\n\tULONG_PTR SpinCount;\r\n} RTL_CRITICAL_SECTION, *PRTL_CRITICAL_SECTION;\r\n\r\ntypedef RTL_CRITICAL_SECTION CRITICAL_SECTION,*LPCRITICAL_SECTION;\r\n\r\ntypedef struct _SECURITY_ATTRIBUTES {\r\n\tDWORD nLength;\r\n\tLPVOID lpSecurityDescriptor;\r\n\tBOOL bInheritHandle;\r\n} SECURITY_ATTRIBUTES,*LPSECURITY_ATTRIBUTES;\r\n\r\ntypedef enum _GET_FILEEX_INFO_LEVELS { GetFileExInfoStandard, GetFileExMaxInfoLevel } GET_FILEEX_INFO_LEVELS;\r\n\r\ntypedef struct tagFILETIME {\r\n\tDWORD dwLowDateTime;\r\n\tDWORD dwHighDateTime;\r\n} FILETIME,*LPFILETIME,*PFILETIME;\r\n\r\ntypedef struct _WIN32_FIND_DATAA {\r\n\tDWORD dwFileAttributes;\r\n\tFILETIME ftCreationTime;\r\n\tFILETIME ftLastAccessTime;\r\n\tFILETIME ftLastWriteTime;\r\n\tDWORD nFileSizeHigh;\r\n\tDWORD nFileSizeLow;\r\n\tDWORD dwReserved0;\r\n\tDWORD dwReserved1;\r\n\tCHAR   cFileName[ MAX_PATH ];\r\n\tCHAR   cAlternateFileName[ 14 ];\r\n} WIN32_FIND_DATAA, *PWIN32_FIND_DATAA, *LPWIN32_FIND_DATAA;\r\n\r\ntypedef struct _WIN32_FIND_DATAW {\r\n\tDWORD dwFileAttributes;\r\n\tFILETIME ftCreationTime;\r\n\tFILETIME ftLastAccessTime;\r\n\tFILETIME ftLastWriteTime;\r\n\tDWORD nFileSizeHigh;\r\n\tDWORD nFileSizeLow;\r\n\tDWORD dwReserved0;\r\n\tDWORD dwReserved1;\r\n\tWCHAR  cFileName[ MAX_PATH ];\r\n\tWCHAR  cAlternateFileName[ 14 ];\r\n} WIN32_FIND_DATAW, *PWIN32_FIND_DATAW, *LPWIN32_FIND_DATAW;\r\n\r\ntypedef struct _COORD {\r\n\tSHORT X;\r\n\tSHORT Y;\r\n} COORD;\r\n//!=================\r\n\r\ntypedef struct _CHAR_INFO {\r\n\tunion { WCHAR UnicodeChar; CHAR AsciiChar; } Char;\r\n\tWORD Attributes;\r\n} CHAR_INFO,*PCHAR_INFO;\r\n\r\ntypedef struct _SMALL_RECT {\r\n\tSHORT Left;\r\n\tSHORT Top;\r\n\tSHORT Right;\r\n\tSHORT Bottom;\r\n} SMALL_RECT,*PSMALL_RECT;\r\n\r\ntypedef struct _FOCUS_EVENT_RECORD {\r\n\tBOOL bSetFocus;\r\n} FOCUS_EVENT_RECORD;\r\n\r\ntypedef struct _CONSOLE_SCREEN_BUFFER_INFO {\r\n\tCOORD dwSize;\r\n\tCOORD dwCursorPosition;\r\n\tWORD wAttributes;\r\n\tSMALL_RECT srWindow;\r\n\tCOORD dwMaximumWindowSize;\r\n} CONSOLE_SCREEN_BUFFER_INFO,*PCONSOLE_SCREEN_BUFFER_INFO;\r\n\r\ntypedef struct _KEY_EVENT_RECORD {\r\n\tBOOL bKeyDown;\r\n\tWORD wRepeatCount;\r\n\tWORD wVirtualKeyCode;\r\n\tWORD wVirtualScanCode;\r\n\tunion { WCHAR UnicodeChar; CHAR AsciiChar; } uChar;\r\n\tDWORD dwControlKeyState;\r\n} KEY_EVENT_RECORD;\r\n\r\ntypedef struct _MOUSE_EVENT_RECORD {\r\n\tCOORD dwMousePosition;\r\n\tDWORD dwButtonState;\r\n\tDWORD dwControlKeyState;\r\n\tDWORD dwEventFlags;\r\n} MOUSE_EVENT_RECORD;\r\n\r\ntypedef struct _WINDOW_BUFFER_SIZE_RECORD {\r\n\tCOORD dwSize;\r\n} WINDOW_BUFFER_SIZE_RECORD;\r\n\r\ntypedef struct _MENU_EVENT_RECORD {\r\n\tUINT dwCommandId;\r\n} MENU_EVENT_RECORD,*PMENU_EVENT_RECORD;\r\n\r\ntypedef struct _INPUT_RECORD {\r\n\tWORD EventType;\r\n\tWORD __alignmentDummy;\r\n\tunion {\r\n\t\tKEY_EVENT_RECORD KeyEvent;\r\n\t\tMOUSE_EVENT_RECORD MouseEvent;\r\n\t\tWINDOW_BUFFER_SIZE_RECORD WindowBufferSizeEvent;\r\n\t\tMENU_EVENT_RECORD MenuEvent;\r\n\t\tFOCUS_EVENT_RECORD FocusEvent;\r\n\t} Event;\r\n} INPUT_RECORD,*PINPUT_RECORD;\r\n\r\ntypedef struct _STARTUPINFOW {\r\n\tDWORD cb;\r\n\tLPWSTR lpReserved;\r\n\tLPWSTR lpDesktop;\r\n\tLPWSTR lpTitle;\r\n\tDWORD dwX;\r\n\tDWORD dwY;\r\n\tDWORD dwXSize;\r\n\tDWORD dwYSize;\r\n\tDWORD dwXCountChars;\r\n\tDWORD dwYCountChars;\r\n\tDWORD dwFillAttribute;\r\n\tDWORD dwFlags;\r\n\tWORD wShowWindow;\r\n\tWORD cbReserved2;\r\n\tLPBYTE lpReserved2;\r\n\tHANDLE hStdInput;\r\n\tHANDLE hStdOutput;\r\n\tHANDLE hStdError;\r\n} STARTUPINFOW, *LPSTARTUPINFOW;\r\n\r\ntypedef struct _PROCESS_INFORMATION {\r\n\tHANDLE hProcess;\r\n\tHANDLE hThread;\r\n\tDWORD dwProcessId;\r\n\tDWORD dwThreadId;\r\n} PROCESS_INFORMATION,*LPPROCESS_INFORMATION;\r\n\r\ntypedef struct _WIN32_FILE_ATTRIBUTE_DATA {\r\n\tDWORD dwFileAttributes;\r\n\tFILETIME ftCreationTime;\r\n\tFILETIME ftLastAccessTime;\r\n\tFILETIME ftLastWriteTime;\r\n\tDWORD nFileSizeHigh;\r\n\tDWORD nFileSizeLow;\r\n} WIN32_FILE_ATTRIBUTE_DATA,*LPWIN32_FILE_ATTRIBUTE_DATA;\r\ntypedef struct tagWNDCLASSA {\r\n\tUINT\tstyle;\r\n\tWNDPROC\tlpfnWndProc;\r\n\tint\tcbClsExtra;\r\n\tint\tcbWndExtra;\r\n\tHINSTANCE\thInstance;\r\n\tHICON\thIcon;\r\n\tHCURSOR\thCursor;\r\n\tHBRUSH\thbrBackground;\r\n\tLPCSTR\tlpszMenuName;\r\n\tLPCSTR\tlpszClassName;\r\n} WNDCLASSA, *PWNDCLASSA,*NPWNDCLASSA,*LPWNDCLASSA;\r\ntypedef struct tagWNDCLASSW {\r\n\tUINT\tstyle;\r\n\tWNDPROC\tlpfnWndProc;\r\n\tint\tcbClsExtra;\r\n\tint\tcbWndExtra;\r\n\tHINSTANCE hInstance;\r\n\tHICON\thIcon;\r\n\tHCURSOR\thCursor;\r\n\tHBRUSH\thbrBackground;\r\n\tLPCWSTR\tlpszMenuName;\r\n\tLPCWSTR\tlpszClassName;\r\n} WNDCLASSW, *PWNDCLASSW,*NPWNDCLASSW,*LPWNDCLASSW;\r\ntypedef struct tagWNDCLASSEXA {\r\n\tUINT\tcbSize;\r\n\tUINT\tstyle;\r\n\tWNDPROC\tlpfnWndProc;\r\n\tint\tcbClsExtra;\r\n\tint\tcbWndExtra;\r\n\tHINSTANCE\thInstance;\r\n\tHICON\thIcon;\r\n\tHCURSOR\thCursor;\r\n\tHBRUSH\thbrBackground;\r\n\tLPCSTR\tlpszMenuName;\r\n\tLPCSTR\tlpszClassName;\r\n\tHICON\thIconSm;\r\n} WNDCLASSEXA, *PWNDCLASSEXA,*NPWNDCLASSEXA,*LPWNDCLASSEXA;\r\ntypedef struct tagWNDCLASSEXW {\r\n\tUINT cbSize;\r\n\tUINT style;\r\n\tWNDPROC lpfnWndProc;\r\n\tint cbClsExtra;\r\n\tint cbWndExtra;\r\n\tHINSTANCE hInstance;\r\n\tHICON hIcon;\r\n\tHCURSOR hCursor;\r\n\tHBRUSH hbrBackground;\r\n\tLPCWSTR lpszMenuName;\r\n\tLPCWSTR lpszClassName;\r\n\tHICON hIconSm;\r\n} WNDCLASSEXW,*PWNDCLASSEXW,*NPWNDCLASSEXW,*LPWNDCLASSEXW;\r\n#ifdef UNICODE\r\n\ttypedef WNDCLASSW WNDCLASS;\r\n\ttypedef PWNDCLASSW PWNDCLASS;\r\n\ttypedef NPWNDCLASSW NPWNDCLASS;\r\n\ttypedef LPWNDCLASSW LPWNDCLASS;\r\n\ttypedef WNDCLASSEXW WNDCLASSEX;\r\n#else\r\n\ttypedef WNDCLASSA WNDCLASS;\r\n\ttypedef PWNDCLASSA PWNDCLASS;\r\n\ttypedef NPWNDCLASSA NPWNDCLASS;\r\n\ttypedef LPWNDCLASSA LPWNDCLASS;\r\n\ttypedef WNDCLASSEXA WNDCLASSEX;\r\n#endif\r\ntypedef struct _RECT {\r\n\tLONG left;\r\n\tLONG top;\r\n\tLONG right;\r\n\tLONG bottom;\r\n} RECT,*LPRECT;\r\n\r\ntypedef const RECT *LPCRECT;\r\n\r\ntypedef struct tagPAINTSTRUCT {\r\n\tHDC hdc;\r\n\tBOOL fErase;\r\n\tRECT rcPaint;\r\n\tBOOL fRestore;\r\n\tBOOL fIncUpdate;\r\n\tBYTE rgbReserved[32];\r\n} PAINTSTRUCT,*LPPAINTSTRUCT;\r\ntypedef struct tagCREATESTRUCT {\r\n\tLPVOID lpCreateParams;\r\n\tHINSTANCE hInstance;\r\n\tHMENU hMenu;\r\n\tHWND hwndParent;\r\n\tint cy;\r\n\tint cx;\r\n\tint y;\r\n\tint x;\r\n\tLONG style;\r\n\tLPCTSTR lpszName;\r\n\tLPCTSTR lpszClass;\r\n\tDWORD dwExStyle;\r\n} CREATESTRUCT,*LPCREATESTRUCT;\r\n\r\ntypedef struct tagBITMAP {\r\n\tLONG bmType;\r\n\tLONG bmWidth;\r\n\tLONG bmHeight;\r\n\tLONG bmWidthBytes;\r\n\tWORD bmPlanes;\r\n\tWORD bmBitsPixel;\r\n\tLPVOID bmBits;\r\n} BITMAP,*PBITMAP,*NPBITMAP,*LPBITMAP;\r\ntypedef struct tagBITMAPCOREHEADER {\r\n\tDWORD bcSize;\r\n\tWORD bcWidth;\r\n\tWORD bcHeight;\r\n\tWORD bcPlanes;\r\n\tWORD bcBitCount;\r\n} BITMAPCOREHEADER;\r\n /* was missing jn */\r\ntypedef BITMAPCOREHEADER *LPBITMAPCOREHEADER;\r\ntypedef struct tagRGBTRIPLE {\r\n\tBYTE rgbtBlue;\r\n\tBYTE rgbtGreen;\r\n\tBYTE rgbtRed;\r\n} RGBTRIPLE;\r\ntypedef struct _BITMAPCOREINFO {\r\n\tBITMAPCOREHEADER bmciHeader;\r\n\tRGBTRIPLE bmciColors[1];\r\n} BITMAPCOREINFO;\r\n/* was missing jn */\r\ntypedef BITMAPCOREINFO *LPBITMAPCOREINFO;\r\ntypedef struct tagBITMAPFILEHEADER {\r\n\tWORD bfType;\r\n\tDWORD bfSize;\r\n\tWORD bfReserved1;\r\n\tWORD bfReserved2;\r\n\tDWORD bfOffBits;\r\n} BITMAPFILEHEADER,*LPBITMAPFILEHEADER,*PBITMAPFILEHEADER;\r\ntypedef struct tagBITMAPINFOHEADER {\r\n\tDWORD biSize;\r\n\tLONG biWidth;\r\n\tLONG biHeight;\r\n\tWORD biPlanes;\r\n\tWORD biBitCount;\r\n\tDWORD biCompression;\r\n\tDWORD biSizeImage;\r\n\tLONG biXPelsPerMeter;\r\n\tLONG biYPelsPerMeter;\r\n\tDWORD biClrUsed;\r\n\tDWORD biClrImportant;\r\n} BITMAPINFOHEADER,*LPBITMAPINFOHEADER,*PBITMAPINFOHEADER;\r\ntypedef struct tagRGBQUAD {\r\n\tBYTE rgbBlue;\r\n\tBYTE rgbGreen;\r\n\tBYTE rgbRed;\r\n\tBYTE rgbReserved;\r\n} RGBQUAD,*LPRGBQUAD;\r\ntypedef struct tagBITMAPINFO {\r\n\tBITMAPINFOHEADER bmiHeader;\r\n\tRGBQUAD bmiColors[1];\r\n} BITMAPINFO,*LPBITMAPINFO,*PBITMAPINFO;\r\ntypedef union _LARGE_INTEGER {\r\n\tstruct { DWORD LowPart; LONG HighPart;};\r\n\tstruct { DWORD LowPart; LONG HighPart; } u;\r\n\tlong long int QuadPart;\r\n} LARGE_INTEGER,*PLARGE_INTEGER;\r\ntypedef VOID (CALLBACK *TIMERPROC) (HWND,UINT,UINT,DWORD);\r\n\r\ntypedef struct _STARTUPINFOA {\r\n\tDWORD cb;\r\n\tLPSTR lpReserved;\r\n\tLPSTR lpDesktop;\r\n\tLPSTR lpTitle;\r\n\tDWORD dwX;\r\n\tDWORD dwY;\r\n\tDWORD dwXSize;\r\n\tDWORD dwYSize;\r\n\tDWORD dwXCountChars;\r\n\tDWORD dwYCountChars;\r\n\tDWORD dwFillAttribute;\r\n\tDWORD dwFlags;\r\n\tWORD wShowWindow;\r\n\tWORD cbReserved2;\r\n\tLPBYTE lpReserved2;\r\n\tHANDLE hStdInput;\r\n\tHANDLE hStdOutput;\r\n\tHANDLE hStdError;\r\n} STARTUPINFOA, *LPSTARTUPINFOA;\r\ntypedef struct _SYSTEMTIME {\r\n\tWORD wYear;\r\n\tWORD wMonth;\r\n\tWORD wDayOfWeek;\r\n\tWORD wDay;\r\n\tWORD wHour;\r\n\tWORD wMinute;\r\n\tWORD wSecond;\r\n\tWORD wMilliseconds;\r\n} SYSTEMTIME,*LPSYSTEMTIME,*PSYSTEMTIME;\r\ntypedef struct _SYSTEM_INFO {\r\n\tWORD wProcessorArchitecture;\r\n\tWORD wReserved;\r\n\tDWORD dwPageSize;\r\n\tLPVOID lpMinimumApplicationAddress;\r\n\tLPVOID lpMaximumApplicationAddress;\r\n\tDWORD dwActiveProcessorMask;\r\n\tDWORD dwNumberOfProcessors;\r\n\tDWORD dwProcessorType;\r\n\tDWORD dwAllocationGranularity;\r\n\tWORD wProcessorLevel;\r\n\tWORD wProcessorRevision;\r\n} SYSTEM_INFO,*LPSYSTEM_INFO;\r\ntypedef struct _OVERLAPPED {\r\n\tDWORD Internal;\r\n\tDWORD InternalHigh;\r\n\tDWORD Offset;\r\n\tDWORD OffsetHigh;\r\n\tHANDLE hEvent;\r\n} OVERLAPPED,*LPOVERLAPPED;\r\ntypedef struct _IO_COUNTERS {\r\n\tULONGLONG ReadOperationCount;\r\n\tULONGLONG WriteOperationCount;\r\n\tULONGLONG OtherOperationCount;\r\n\tULONGLONG ReadTransferCount;\r\n\tULONGLONG WriteTransferCount;\r\n\tULONGLONG OtherTransferCount;\r\n} IO_COUNTERS;\r\ntypedef IO_COUNTERS *PIO_COUNTERS;\r\ntypedef union _ULARGE_INTEGER {\r\n\tstruct {DWORD LowPart; DWORD HighPart;};\r\n\tlong long QuadPart;\r\n} ULARGE_INTEGER,*PULARGE_INTEGER;\r\ntypedef struct tagLOGFONTW\r\n{\r\n\tLONG\tlfHeight;\r\n\tLONG\tlfWidth;\r\n\tLONG\tlfEscapement;\r\n\tLONG\tlfOrientation;\r\n\tLONG\tlfWeight;\r\n\tBYTE\tlfItalic;\r\n\tBYTE\tlfUnderline;\r\n\tBYTE\tlfStrikeOut;\r\n\tBYTE\tlfCharSet;\r\n\tBYTE\tlfOutPrecision;\r\n\tBYTE\tlfClipPrecision;\r\n\tBYTE\tlfQuality;\r\n\tBYTE\tlfPitchAndFamily;\r\n\tWCHAR\tlfFaceName[LF_FACESIZE];\r\n} LOGFONTW, *PLOGFONTW, *NPLOGFONTW, *LPLOGFONTW;\r\ntypedef struct _BY_HANDLE_FILE_INFORMATION {\r\n\tDWORD dwFileAttributes;\r\n\tFILETIME ftCreationTime;\r\n\tFILETIME ftLastAccessTime;\r\n\tFILETIME ftLastWriteTime;\r\n\tDWORD dwVolumeSerialNumber;\r\n\tDWORD nFileSizeHigh;\r\n\tDWORD nFileSizeLow;\r\n\tDWORD nNumberOfLinks;\r\n\tDWORD nFileIndexHigh;\r\n\tDWORD nFileIndexLow;\r\n} BY_HANDLE_FILE_INFORMATION,*LPBY_HANDLE_FILE_INFORMATION;\r\ntypedef struct _IMAGE_DOS_HEADER {\r\n\tWORD e_magic;\r\n\tWORD e_cblp;\r\n\tWORD e_cp;\r\n\tWORD e_crlc;\r\n\tWORD e_cparhdr;\r\n\tWORD e_minalloc;\r\n\tWORD e_maxalloc;\r\n\tWORD e_ss;\r\n\tWORD e_sp;\r\n\tWORD e_csum;\r\n\tWORD e_ip;\r\n\tWORD e_cs;\r\n\tWORD e_lfarlc;\r\n\tWORD e_ovno;\r\n\tWORD e_res[4];\r\n\tWORD e_oemid;\r\n\tWORD e_oeminfo;\r\n\tWORD e_res2[10];\r\n\tLONG e_lfanew;\r\n} IMAGE_DOS_HEADER,*PIMAGE_DOS_HEADER;\r\ntypedef struct _IMAGE_FILE_HEADER {\r\n\tWORD Machine;\r\n\tWORD NumberOfSections;\r\n\tDWORD TimeDateStamp;\r\n\tDWORD PointerToSymbolTable;\r\n\tDWORD NumberOfSymbols;\r\n\tWORD SizeOfOptionalHeader;\r\n\tWORD Characteristics;\r\n} IMAGE_FILE_HEADER,*PIMAGE_FILE_HEADER;\r\ntypedef struct _IMAGE_DATA_DIRECTORY {\r\n\tDWORD VirtualAddress;\r\n\tDWORD Size;\r\n} IMAGE_DATA_DIRECTORY,*PIMAGE_DATA_DIRECTORY;\r\n\r\ntypedef struct _IMAGE_OPTIONAL_HEADER {\r\n    //\r\n    // Standard fields.\r\n    //\r\n\r\n    WORD    Magic;\r\n    BYTE    MajorLinkerVersion;\r\n    BYTE    MinorLinkerVersion;\r\n    DWORD   SizeOfCode;\r\n    DWORD   SizeOfInitializedData;\r\n    DWORD   SizeOfUninitializedData;\r\n    DWORD   AddressOfEntryPoint;\r\n    DWORD   BaseOfCode;\r\n    DWORD   BaseOfData;\r\n\r\n    //\r\n    // NT additional fields.\r\n    //\r\n\r\n    DWORD   ImageBase;\r\n    DWORD   SectionAlignment;\r\n    DWORD   FileAlignment;\r\n    WORD    MajorOperatingSystemVersion;\r\n    WORD    MinorOperatingSystemVersion;\r\n    WORD    MajorImageVersion;\r\n    WORD    MinorImageVersion;\r\n    WORD    MajorSubsystemVersion;\r\n    WORD    MinorSubsystemVersion;\r\n    DWORD   Win32VersionValue;\r\n    DWORD   SizeOfImage;\r\n    DWORD   SizeOfHeaders;\r\n    DWORD   CheckSum;\r\n    WORD    Subsystem;\r\n    WORD    DllCharacteristics;\r\n    DWORD   SizeOfStackReserve;\r\n    DWORD   SizeOfStackCommit;\r\n    DWORD   SizeOfHeapReserve;\r\n    DWORD   SizeOfHeapCommit;\r\n    DWORD   LoaderFlags;\r\n    DWORD   NumberOfRvaAndSizes;\r\n    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];\r\n} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;\r\n\r\n\r\ntypedef struct _IMAGE_OPTIONAL_HEADER64 {\r\n    WORD        Magic;\r\n    BYTE        MajorLinkerVersion;\r\n    BYTE        MinorLinkerVersion;\r\n    DWORD       SizeOfCode;\r\n    DWORD       SizeOfInitializedData;\r\n    DWORD       SizeOfUninitializedData;\r\n    DWORD       AddressOfEntryPoint;\r\n    DWORD       BaseOfCode;\r\n    ULONGLONG   ImageBase;\r\n    DWORD       SectionAlignment;\r\n    DWORD       FileAlignment;\r\n    WORD        MajorOperatingSystemVersion;\r\n    WORD        MinorOperatingSystemVersion;\r\n    WORD        MajorImageVersion;\r\n    WORD        MinorImageVersion;\r\n    WORD        MajorSubsystemVersion;\r\n    WORD        MinorSubsystemVersion;\r\n    DWORD       Win32VersionValue;\r\n    DWORD       SizeOfImage;\r\n    DWORD       SizeOfHeaders;\r\n    DWORD       CheckSum;\r\n    WORD        Subsystem;\r\n    WORD        DllCharacteristics;\r\n    ULONGLONG   SizeOfStackReserve;\r\n    ULONGLONG   SizeOfStackCommit;\r\n    ULONGLONG   SizeOfHeapReserve;\r\n    ULONGLONG   SizeOfHeapCommit;\r\n    DWORD       LoaderFlags;\r\n    DWORD       NumberOfRvaAndSizes;\r\n    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];\r\n} IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;\r\n\r\n#define IMAGE_SIZEOF_NT_OPTIONAL64_HEADER\t240\r\n\r\ntypedef struct _IMAGE_SECTION_HEADER {\r\n\tBYTE Name[IMAGE_SIZEOF_SHORT_NAME];\r\n\tunion {\r\n\t\tDWORD PhysicalAddress;\r\n\t\tDWORD VirtualSize;\r\n\t} Misc;\r\n\tDWORD VirtualAddress;\r\n\tDWORD SizeOfRawData;\r\n\tDWORD PointerToRawData;\r\n\tDWORD PointerToRelocations;\r\n\tDWORD PointerToLinenumbers;\r\n\tWORD NumberOfRelocations;\r\n\tWORD NumberOfLinenumbers;\r\n\tDWORD Characteristics;\r\n} IMAGE_SECTION_HEADER,*PIMAGE_SECTION_HEADER;\r\n\r\ntypedef struct _IMAGE_IMPORT_BY_NAME {\r\n\tWORD Hint;\r\n\tBYTE Name[1];\r\n} IMAGE_IMPORT_BY_NAME,*PIMAGE_IMPORT_BY_NAME;\r\ntypedef struct _IMAGE_THUNK_DATA {\r\n\tunion {\r\n\t\tPBYTE ForwarderString;\r\n\t\tPDWORD Function;\r\n\t\tDWORD Ordinal;\r\n\t\tPIMAGE_IMPORT_BY_NAME AddressOfData;\r\n\t} ;\r\n} IMAGE_THUNK_DATA,*PIMAGE_THUNK_DATA;\r\n\r\ntypedef struct _IMAGE_IMPORT_DESCRIPTOR {\r\n    union {\r\n        DWORD   Characteristics;            // 0 for terminating null import descriptor\r\n        DWORD   OriginalFirstThunk;         // RVA to original unbound IAT (PIMAGE_THUNK_DATA)\r\n    } DUMMYUNIONNAME;\r\n    DWORD   TimeDateStamp;                  // 0 if not bound,\r\n                                            // -1 if bound, and real date\\time stamp\r\n                                            //     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)\r\n                                            // O.W. date/time stamp of DLL bound to (Old BIND)\r\n\r\n    DWORD   ForwarderChain;                 // -1 if no forwarders\r\n    DWORD   Name;\r\n    DWORD   FirstThunk;                     // RVA to IAT (if bound this IAT has actual addresses)\r\n} IMAGE_IMPORT_DESCRIPTOR;\r\n\r\ntypedef struct _IMAGE_EXPORT_DIRECTORY {\r\n    DWORD   Characteristics;\r\n    DWORD   TimeDateStamp;\r\n    WORD    MajorVersion;\r\n    WORD    MinorVersion;\r\n    DWORD   Name;\r\n    DWORD   Base;\r\n    DWORD   NumberOfFunctions;\r\n    DWORD   NumberOfNames;\r\n    DWORD   AddressOfFunctions;     // RVA from base of image\r\n    DWORD   AddressOfNames;         // RVA from base of image\r\n    DWORD   AddressOfNameOrdinals;  // RVA from base of image\r\n} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;\r\n\r\n//typedef struct _OSVERSIONINFOA {\r\n//\tDWORD dwOSVersionInfoSize;\r\n//\tDWORD dwMajorVersion;\r\n//\tDWORD dwMinorVersion;\r\n//\tDWORD dwBuildNumber;\r\n//\tDWORD dwPlatformId;\r\n//\tCHAR szCSDVersion[128];\r\n//} OSVERSIONINFOA, *POSVERSIONINFOA, *LPOSVERSIONINFOA;\r\n//\r\n//typedef struct _OSVERSIONINFOW {\r\n//\tDWORD dwOSVersionInfoSize;\r\n//\tDWORD dwMajorVersion;\r\n//\tDWORD dwMinorVersion;\r\n//\tDWORD dwBuildNumber;\r\n//\tDWORD dwPlatformId;\r\n//\tWCHAR szCSDVersion[128];\r\n//} OSVERSIONINFOW, *POSVERSIONINFOW, *LPOSVERSIONINFOW, RTL_OSVERSIONINFOW, *PRTL_OSVERSIONINFOW;\r\n\r\ntypedef struct {\r\n  WORD  wFormatTag;\r\n  WORD  nChannels;\r\n  DWORD nSamplesPerSec;\r\n  DWORD nAvgBytesPerSec;\r\n  WORD  nBlockAlign;\r\n  WORD  wBitsPerSample;\r\n  WORD  cbSize;\r\n} WAVEFORMATEX;\r\n\r\ntypedef struct wavehdr_tag {\r\n  LPSTR              lpData;\r\n  DWORD              dwBufferLength;\r\n  DWORD              dwBytesRecorded;\r\n  DWORD_PTR          dwUser;\r\n  DWORD              dwFlags;\r\n  DWORD              dwLoops;\r\n  struct wavehdr_tag  *lpNext;\r\n  DWORD_PTR          reserved;\r\n} WAVEHDR, *LPWAVEHDR;\r\n\r\ntypedef struct {\r\n\tDWORD style;\r\n\tDWORD dwExtendedStyle;\r\n\tWORD cdit;\r\n\tshort x;\r\n\tshort y;\r\n\tshort cx;\r\n\tshort cy;\r\n} DLGTEMPLATE,*LPDLGTEMPLATE;\r\ntypedef const DLGTEMPLATE *LPCDLGTEMPLATE;\r\n\r\ntypedef DWORD SECURITY_INFORMATION, *PSECURITY_INFORMATION;\r\ntypedef PVOID PSID;\r\ntypedef struct _ACL {\r\nBYTE AclRevision;\r\nBYTE Sbz1;\r\nWORD AclSize;\r\nWORD AceCount;\r\nWORD Sbz2;\r\n} ACL, *PACL;\r\ntypedef WORD SECURITY_DESCRIPTOR_CONTROL, *PSECURITY_DESCRIPTOR_CONTROL;\r\ntypedef struct _SECURITY_DESCRIPTOR {\r\nBYTE Revision;\r\nBYTE Sbz1;\r\nSECURITY_DESCRIPTOR_CONTROL Control;\r\nPSID Owner;\r\nPSID Group;\r\nPACL Sacl;\r\nPACL Dacl;\r\n} SECURITY_DESCRIPTOR, *PSECURITY_DESCRIPTOR, *PISECURITY_DESCRIPTOR;\r\ntypedef enum _SID_NAME_USE {\r\nSidTypeUser=1,\r\nSidTypeGroup,\r\nSidTypeDomain,\r\nSidTypeAlias,\r\nSidTypeWellKnownGroup,\r\nSidTypeDeletedAccount,\r\nSidTypeInvalid,\r\nSidTypeUnknown,\r\nSidTypeComputer\r\n} SID_NAME_USE,*PSID_NAME_USE;\r\ntypedef struct _SID_AND_ATTRIBUTES {\r\nPSID Sid;\r\nDWORD Attributes;\r\n} SID_AND_ATTRIBUTES, *PSID_AND_ATTRIBUTES;\r\ntypedef struct _TOKEN_USER {\r\nSID_AND_ATTRIBUTES User;\r\n} TOKEN_USER, *PTOKEN_USER;\r\ntypedef enum _TOKEN_INFORMATION_CLASS {\r\nTokenUser=1,\r\n} TOKEN_INFORMATION_CLASS;\r\n\r\n#define _FILETIME\r\n\r\n/*\r\nproc\r\n*/\r\n\r\n#ifdef UNICODE\r\n\ttypedef WIN32_FIND_DATAW WIN32_FIND_DATA;\r\n\ttypedef PWIN32_FIND_DATAW PWIN32_FIND_DATA;\r\n\ttypedef LPWIN32_FIND_DATAW LPWIN32_FIND_DATA;\r\n\ttypedef struct _OSVERSIONINFOW {\r\n\t\tDWORD dwOSVersionInfoSize;\r\n\t\tDWORD dwMajorVersion;\r\n\t\tDWORD dwMinorVersion;\r\n\t\tDWORD dwBuildNumber;\r\n\t\tDWORD dwPlatformId;\r\n\t\tWCHAR szCSDVersion[128];\r\n\t} OSVERSIONINFOW, *POSVERSIONINFOW, *LPOSVERSIONINFOW, RTL_OSVERSIONINFOW, *PRTL_OSVERSIONINFOW;\r\n\ttypedef LPOSVERSIONINFOW LPOSVERSIONINFO;\r\n#else\r\n\ttypedef WIN32_FIND_DATAA WIN32_FIND_DATA;\r\n\ttypedef PWIN32_FIND_DATAA PWIN32_FIND_DATA;\r\n\ttypedef LPWIN32_FIND_DATAA LPWIN32_FIND_DATA;\r\n\ttypedef struct _OSVERSIONINFOA {\r\n\t\tDWORD dwOSVersionInfoSize;\r\n\t\tDWORD dwMajorVersion;\r\n\t\tDWORD dwMinorVersion;\r\n\t\tDWORD dwBuildNumber;\r\n\t\tDWORD dwPlatformId;\r\n\t\tCHAR szCSDVersion[128];\r\n\t} OSVERSIONINFOA, *POSVERSIONINFOA, *LPOSVERSIONINFOA;\r\n\ttypedef LPOSVERSIONINFOA LPOSVERSIONINFO;\r\n#endif\r\n\r\nint MessageBoxA(HWND,LPCSTR,LPCSTR,UINT);\r\n#define MessageBox MessageBoxA\r\nint MessageBoxW(HWND,LPCWSTR,LPCWSTR,UINT);\r\n\r\ntypedef struct {int dummy;} _Dummystruct;\r\n\r\n//typedef int (*FARPROC)();\r\n//typedef int (*FARPROC)(void);\r\n//typedef int (*FARPROC)(_Dummystruct);\r\ntypedef int (*FARPROC)(struct {});\r\n\r\nFARPROC GetProcAddress(HINSTANCE,const char*);\r\nHINSTANCE LoadLibraryA(LPCSTR);\r\nHMODULE GetModuleHandleA(char*);\r\nHINSTANCE  LoadLibraryExW(LPCWSTR,HANDLE,DWORD);\r\nHINSTANCE  LoadLibraryExA(LPCSTR,HANDLE,DWORD);\r\n\r\nBOOL  SetEvent(HANDLE);\r\nDWORD  WaitForMultipleObjects(DWORD,CONST HANDLE *,BOOL,DWORD);\r\nLPVOID VirtualAlloc(LPVOID,DWORD,DWORD,DWORD);\r\nBOOL VirtualFree(LPVOID,DWORD,DWORD);\r\nBOOL VirtualProtect(LPVOID,DWORD,DWORD,PDWORD);\r\nDWORD VirtualQuery(LPCVOID,MEMORY_BASIC_INFORMATION*,DWORD);\r\nHLOCAL LocalFree(HLOCAL);\r\nLPWSTR GetCommandLineW(VOID);\r\nLPSTR GetCommandLineA(VOID);\r\nLPWSTR* CommandLineToArgvW(LPCWSTR,int*);\r\nDWORD GetModuleFileNameA(HINSTANCE,LPSTR,DWORD);\r\nDWORD GetModuleFileNameW(HINSTANCE,LPWSTR,DWORD);\r\nDWORD GetLastError(VOID);\r\n\r\nDWORD FormatMessageA(DWORD,LPCVOID,DWORD,DWORD,LPSTR,DWORD,va_list *);\r\n\r\nLONG InterlockedCompareExchange(LONG volatile*, LONG, LONG);\r\n//LONG64 InterlockedCompareExchange64(LONG64 volatile*, LONG64, LONG64);\r\n\r\nVOID InitializeCriticalSection(LPCRITICAL_SECTION);\r\nVOID DeleteCriticalSection(LPCRITICAL_SECTION);\r\nVOID EnterCriticalSection(LPCRITICAL_SECTION);\r\nVOID LeaveCriticalSection(LPCRITICAL_SECTION);\r\nDWORD GetCurrentThreadId(VOID);\r\nBOOL CloseHandle(HANDLE);\r\nBOOL FreeLibrary(HINSTANCE);\r\nBOOL AreFileApisANSI(VOID);\r\nVOID OutputDebugStringA(LPCSTR);\r\nHANDLE CreateFileA(LPCSTR,DWORD,DWORD,LPSECURITY_ATTRIBUTES,DWORD,DWORD,HANDLE);\r\nHANDLE CreateFileW(LPCWSTR,DWORD,DWORD,LPSECURITY_ATTRIBUTES,DWORD,DWORD,HANDLE);\r\nHANDLE CreateFileMappingW(HANDLE,LPSECURITY_ATTRIBUTES,DWORD,DWORD,DWORD,LPCWSTR);\r\nHANDLE CreateFileMappingA(HANDLE,LPSECURITY_ATTRIBUTES,DWORD,DWORD,DWORD,LPCSTR);\r\nHANDLE CreateMutexW(LPSECURITY_ATTRIBUTES,BOOL,LPCWSTR);\r\nHANDLE CreateMutexA(LPSECURITY_ATTRIBUTES,BOOL,LPCSTR);\r\nBOOL DeleteFileA(LPCSTR);\r\nBOOL DeleteFileW(LPCWSTR);\r\nBOOL FlushFileBuffers(HANDLE);\r\nDWORD FormatMessageW(DWORD,LPCVOID,DWORD,DWORD,LPWSTR,DWORD,va_list *);\r\n//DWORD FormatMessageA(DWORD,LPCVOID,DWORD,DWORD,LPSTR,DWORD,va_list *);\r\nDWORD GetCurrentProcessId(VOID);\r\nBOOL GetDiskFreeSpaceW(LPCWSTR,LPDWORD,LPDWORD,LPDWORD,LPDWORD);\r\nBOOL GetDiskFreeSpaceA(LPCSTR,LPDWORD,LPDWORD,LPDWORD,LPDWORD);\r\nDWORD GetFileAttributesW(LPCWSTR);\r\nDWORD GetFileAttributesA(LPCSTR);\r\nBOOL GetFileAttributesExA(LPCSTR,GET_FILEEX_INFO_LEVELS,LPVOID);\r\nBOOL GetFileAttributesExW(LPCWSTR,GET_FILEEX_INFO_LEVELS,LPVOID);\r\nDWORD GetFileSize(HANDLE,LPDWORD);\r\nBOOL SetConsoleMode(HANDLE,DWORD);\r\nBOOL GetConsoleMode(HANDLE,LPDWORD);\r\nHANDLE GetStdHandle(DWORD);\r\nBOOL PeekConsoleInputW(HANDLE,PINPUT_RECORD,DWORD,LPDWORD);\r\nBOOL ReadConsoleInputW(HANDLE,PINPUT_RECORD,DWORD,LPDWORD);\r\nBOOL WriteConsoleInputW(HANDLE,CONST INPUT_RECORD *,DWORD,LPDWORD);\r\nBOOL ReadConsoleOutputW(HANDLE,PCHAR_INFO,COORD,COORD,PSMALL_RECT);\r\nBOOL WriteConsoleOutputW(HANDLE,CONST CHAR_INFO *,COORD,COORD,PSMALL_RECT);\r\nBOOL ReadConsoleOutputCharacterW(HANDLE,LPWSTR,DWORD,COORD,LPDWORD);\r\nBOOL WriteConsoleOutputCharacterW(HANDLE,LPCWSTR,DWORD,COORD,LPDWORD);\r\nBOOL FillConsoleOutputCharacterW(HANDLE,WCHAR,DWORD,COORD,LPDWORD);\r\nBOOL ScrollConsoleScreenBufferW(HANDLE,CONST SMALL_RECT *,CONST SMALL_RECT *,COORD,CONST CHAR_INFO *);\r\nBOOL ScrollConsoleScreenBufferA(HANDLE,CONST SMALL_RECT *,CONST SMALL_RECT *,COORD,CONST CHAR_INFO *);\r\nDWORD GetConsoleTitleW(LPWSTR,DWORD);\r\nBOOL SetConsoleTitleW(LPCWSTR);\r\nBOOL ReadConsoleW(HANDLE,LPVOID,DWORD,LPDWORD,LPVOID);\r\nBOOL WriteConsoleW(HANDLE,CONST VOID *,DWORD,LPDWORD,LPVOID);\r\nBOOL ReadConsoleOutputAttribute(HANDLE,LPWORD,DWORD,COORD,LPDWORD);\r\nBOOL WriteConsoleOutputAttribute(HANDLE,CONST WORD *,DWORD,COORD,LPDWORD);\r\nBOOL FillConsoleOutputAttribute(HANDLE,WORD,DWORD,COORD,LPDWORD);\r\nBOOL GetConsoleMode(HANDLE,LPDWORD);\r\nBOOL GetNumberOfConsoleInputEvents(HANDLE,LPDWORD);\r\nBOOL GetConsoleScreenBufferInfo(HANDLE,PCONSOLE_SCREEN_BUFFER_INFO);\r\nCOORD GetLargestConsoleWindowSize(HANDLE);\r\nBOOL GetConsoleCursorInfo(HANDLE,PCONSOLE_CURSOR_INFO);\r\nBOOL GetNumberOfConsoleMouseButtons(LPDWORD);\r\nBOOL SetConsoleMode(HANDLE,DWORD);\r\nBOOL SetConsoleActiveScreenBuffer(HANDLE);\r\nBOOL FlushConsoleInputBuffer(HANDLE);\r\nBOOL SetConsoleScreenBufferSize(HANDLE,COORD);\r\nBOOL SetConsoleCursorPosition(HANDLE,COORD);\r\nBOOL SetConsoleCursorInfo(HANDLE,CONST CONSOLE_CURSOR_INFO *);\r\nBOOL SetConsoleWindowInfo(HANDLE,BOOL,CONST SMALL_RECT *);\r\nBOOL SetConsoleTextAttribute(HANDLE,WORD);\r\nBOOL SetConsoleCtrlHandler(PHANDLER_ROUTINE,BOOL);\r\nBOOL GenerateConsoleCtrlEvent(DWORD,DWORD);\r\nBOOL AllocConsole(VOID);\r\nBOOL FreeConsole(VOID);\r\nHANDLE CreateConsoleScreenBuffer(DWORD,DWORD,CONST SECURITY_ATTRIBUTES *,DWORD,LPVOID);\r\nDWORD GetFileType(HANDLE);\r\nDWORD WaitForSingleObject(HANDLE,DWORD);\r\nBOOL PeekNamedPipe(HANDLE,LPVOID,DWORD,LPDWORD,LPDWORD,LPDWORD);\r\nBOOL CreatePipe(PHANDLE,PHANDLE,LPSECURITY_ATTRIBUTES,DWORD);\r\nBOOL GetMessageA(LPMSG,HWND,UINT,UINT);\r\nSHORT GetKeyState(int);\r\nBOOL TranslateMessage(CONST MSG *);\r\nBOOL PeekMessageA(LPMSG,HWND,UINT,UINT,UINT);\r\nLONG DispatchMessageA(CONST MSG *);\r\nBOOL IsWindow(HWND);\r\nBOOL IsMenu(HMENU);\r\nBOOL IsChild(HWND,HWND);\r\nBOOL DestroyWindow(HWND);\r\nBOOL ShowWindow(HWND,int);\r\nSHORT GetKeyState(int);\r\nSHORT GetAsyncKeyState(int);\r\nBOOL GetKeyboardState(PBYTE);\r\nBOOL SetKeyboardState(LPBYTE);\r\nint GetKeyboardType(int);\r\nBOOL GetExitCodeProcess(HANDLE,LPDWORD);\r\nBOOL TerminateProcess(HANDLE,UINT);\r\nBOOL SetHandleInformation(HANDLE,DWORD,DWORD);\r\nHANDLE FindFirstFileA(LPCSTR,LPWIN32_FIND_DATA);\r\nHPEN CreatePen(int,int,COLORREF);\r\nHBRUSH CreateSolidBrush(COLORREF);\r\nHGDIOBJ SelectObject(HDC,HGDIOBJ);\r\nVOID PostQuitMessage(int);\r\n\r\nBOOL PlaySoundA(LPCSTR,HMODULE,DWORD);\r\nHICON LoadIconW(HINSTANCE,LPCWSTR);\r\nHICON LoadIconA(HINSTANCE,LPCSTR);\r\nHCURSOR LoadCursorW(HINSTANCE,LPCWSTR);\r\nHCURSOR LoadCursorA(HINSTANCE,LPCSTR);\r\nHGDIOBJ GetStockObject(int);\r\nATOM RegisterClassW(CONST WNDCLASS *);\r\nATOM RegisterClassA(CONST WNDCLASS *);\r\nBOOL UpdateWindow(HWND);\r\nHDC BeginPaint( HWND,LPPAINTSTRUCT);\r\nBOOL EndPaint(HWND,CONST PAINTSTRUCT *);\r\nBOOL GetClientRect(HWND,LPRECT);\r\nint DrawTextW(HDC,LPCWSTR,int,LPRECT,UINT);\r\nint DrawTextA(HDC,LPCSTR,int,LPRECT,UINT);\r\nLRESULT DefWindowProcW(HWND,UINT,WPARAM,LPARAM);\r\nLRESULT DefWindowProcA(HWND,UINT,WPARAM,LPARAM);\r\nBOOL FillConsoleOutputCharacterA(HANDLE,WCHAR,DWORD,COORD,LPDWORD);\r\nBOOL FillConsoleOutputCharacterW(HANDLE,WCHAR,DWORD,COORD,LPDWORD);\r\nVOID Sleep(DWORD);\r\nHANDLE CreateEventW(LPSECURITY_ATTRIBUTES,BOOL,BOOL,LPCWSTR);\r\nHANDLE CreateEventA(LPSECURITY_ATTRIBUTES,BOOL,BOOL,LPCSTR);\r\nHANDLE CreateThread(LPSECURITY_ATTRIBUTES,DWORD,LPTHREAD_START_ROUTINE,LPVOID,DWORD,LPDWORD);\r\nLPVOID MapViewOfFile(HANDLE,DWORD,DWORD,DWORD,DWORD);\r\nBOOL ReadConsoleOutputCharacterW(HANDLE,LPWSTR,DWORD,COORD,LPDWORD);\r\nBOOL ReadConsoleOutputCharacterA(HANDLE,LPSTR,DWORD,COORD,LPDWORD);\r\nBOOL WriteConsoleInputW(HANDLE,CONST INPUT_RECORD *,DWORD,LPDWORD);\r\nBOOL WriteConsoleInputA(HANDLE,CONST INPUT_RECORD *,DWORD,LPDWORD);\r\nUINT GetSystemDirectoryW(LPWSTR,UINT);\r\nUINT GetSystemDirectoryA(LPSTR,UINT);\r\nDWORD SearchPathW(LPCWSTR,LPCWSTR,LPCWSTR,DWORD,LPWSTR,LPWSTR *);\r\nDWORD SearchPathA(LPCSTR,LPCSTR,LPCSTR,DWORD,LPSTR,LPSTR *);\r\nDWORD GetTickCount(VOID);\r\nATOM RegisterClassExW(CONST WNDCLASSEX *);\r\nATOM RegisterClassExA(CONST WNDCLASSEX *);\r\nHWND CreateWindowExW(DWORD,LPCWSTR,LPCWSTR,DWORD,int,int,int,int,HWND,HMENU,HINSTANCE,LPVOID);\r\nHWND CreateWindowExA(DWORD,LPCSTR,LPCSTR,DWORD,int,int,int,int,HWND,HMENU,HINSTANCE,LPVOID);\r\nCOLORREF SetPixel(HDC,int,int,COLORREF);\r\nCOLORREF GetPixel(HDC,int,int);\r\nBOOL LineTo(HDC,int,int);\r\nVOID GetSystemTimeAsFileTime(LPFILETIME);\r\nBOOL MoveWindow(HWND,int,int,int,int,BOOL);\r\nBOOL GetWindowRect(HWND,LPRECT);\r\nBOOL ScreenToClient(HWND,LPPOINT);\r\nHWND GetParent(HWND);\r\nHWND SetFocus(HWND);\r\nBOOL InvalidateRect(HWND,CONST RECT *,BOOL);\r\nBOOL DeleteObject(HGDIOBJ);\r\nLONG GetWindowLongA(HWND,int);\r\nLONG GetWindowLongW(HWND,int);\r\nLONG SetWindowLongA(HWND,int,LONG);\r\nLONG SetWindowLongW(HWND,int,LONG);\r\nHDC CreateCompatibleDC(HDC);\r\nBOOL BitBlt(HDC,int,int,int,int,HDC,int,int,DWORD);\r\nBOOL DeleteDC(HDC);\r\nLRESULT SendMessageW(HWND,UINT,WPARAM,LPARAM);\r\nLRESULT SendMessageA(HWND,UINT,WPARAM,LPARAM);\r\nLRESULT SendMessageTimeoutW(HWND,UINT,WPARAM,LPARAM,UINT,UINT,LPDWORD);\r\nLRESULT SendMessageTimeoutA(HWND,UINT,WPARAM,LPARAM,UINT,UINT,LPDWORD);\r\nBOOL ClientToScreen(HWND,LPPOINT);\r\nHDC GetDC(HWND);\r\nHBITMAP CreateDIBSection(HDC,CONST BITMAPINFO *,UINT,VOID **,HANDLE,DWORD);\r\nBOOL OpenClipboard(HWND);\r\nBOOL CloseClipboard(VOID);\r\nBOOL EmptyClipboard(VOID);\r\nBOOL IsClipboardFormatAvailable(UINT);\r\nHANDLE SetClipboardData(UINT,HANDLE);\r\nHANDLE GetClipboardData(UINT);\r\nHGLOBAL GlobalAlloc(UINT,DWORD);\r\nLPVOID GlobalLock(HGLOBAL);\r\nLPVOID GlobalUnlock(HGLOBAL);\r\nBOOL Rectangle(HDC,int,int,int,int);\r\nHWND GetDesktopWindow(VOID);\r\nBOOL AdjustWindowRect(LPRECT,DWORD,BOOL);\r\nBOOL MoveToEx(HDC,int,int,LPPOINT);\r\nHWND SetCapture(HWND hWnd);\r\nBOOL ReleaseCapture(VOID);\r\nint MapWindowPoints(HWND,HWND,LPPOINT,UINT);\r\nBOOL GetCursorPos(LPPOINT);\r\nDWORD GetLogicalDriveStringsW(DWORD,LPWSTR);\r\nDWORD GetLogicalDriveStringsA(DWORD,LPSTR);\r\nHANDLE FindFirstFileW(LPCWSTR,LPWIN32_FIND_DATAW);\r\nHANDLE FindFirstFileA(LPCSTR,LPWIN32_FIND_DATA);\r\nBOOL FindNextFileW(HANDLE,LPWIN32_FIND_DATAW);\r\nBOOL FindNextFileA(HANDLE,LPWIN32_FIND_DATAA);\r\nBOOL FindClose(HANDLE);\r\nBOOL QueryPerformanceCounter(LARGE_INTEGER *);\r\nBOOL QueryPerformanceFrequency(LARGE_INTEGER *);\r\nUINT SetTimer(HWND,UINT,UINT,TIMERPROC);\r\nBOOL KillTimer(HWND,UINT);\r\nHBITMAP CreateCompatibleBitmap(HDC,int,int);\r\nHBITMAP CreateDiscardableBitmap(HDC,int,int);\r\nHDC CreateCompatibleDC(HDC);\r\nint FillRect(HDC,CONST RECT *,HBRUSH);\r\nLONG RegOpenKeyExW(HKEY,LPCWSTR,DWORD,REGSAM,PHKEY);\r\nLONG RegOpenKeyExA(HKEY,LPCSTR,DWORD,REGSAM,PHKEY);\r\nLONG RegQueryValueExW(HKEY,LPCWSTR,LPDWORD,LPDWORD,LPBYTE,LPDWORD);\r\nLONG RegQueryValueExA (HKEY,LPCSTR,LPDWORD,LPDWORD,LPBYTE,LPDWORD);\r\nLONG RegSetValueExW(HKEY,LPCWSTR,DWORD,DWORD,BYTE*,DWORD);\r\nLONG RegSetValueExA(HKEY,LPCSTR,DWORD,DWORD,BYTE*,DWORD);\r\nLONG RegCloseKey (HKEY);\r\nBOOL SystemTimeToFileTime(CONST SYSTEMTIME *,LPFILETIME);\r\nBOOL FileTimeToLocalFileTime(CONST FILETIME *,LPFILETIME);\r\nBOOL LocalFileTimeToFileTime(CONST FILETIME *,LPFILETIME);\r\nBOOL FileTimeToSystemTime(CONST FILETIME *,LPSYSTEMTIME);\r\nLONG CompareFileTime(CONST FILETIME *,CONST FILETIME *);\r\nDWORD GetFullPathNameW(LPCWSTR,DWORD,LPWSTR,LPWSTR *);\r\nDWORD GetFullPathNameA(LPCSTR,DWORD,LPSTR,LPSTR *);\r\nVOID GetSystemInfo(LPSYSTEM_INFO);\r\nVOID GetSystemTime(LPSYSTEMTIME);\r\nDWORD GetTempPathW(DWORD,LPWSTR);\r\nDWORD GetTempPathA(DWORD,LPSTR);\r\nBOOL GetVersionExW(LPOSVERSIONINFO);\r\nBOOL GetVersionExA(LPOSVERSIONINFO);\r\nHANDLE HeapCreate(DWORD,DWORD,DWORD);\r\nBOOL HeapDestroy(HANDLE);\r\nLPVOID HeapAlloc(HANDLE,DWORD,DWORD);\r\nLPVOID HeapReAlloc(HANDLE,DWORD,LPVOID,DWORD);\r\nBOOL HeapFree(HANDLE,DWORD,LPVOID);\r\nDWORD HeapSize(HANDLE,DWORD,LPCVOID);\r\nBOOL HeapValidate(HANDLE,DWORD,LPCVOID);\r\nUINT HeapCompact(HANDLE,DWORD);\r\nHINSTANCE LoadLibraryW(LPCWSTR);\r\nHINSTANCE LoadLibraryExW(LPCWSTR,HANDLE,DWORD);\r\nHINSTANCE LoadLibraryA(LPCSTR);\r\nHINSTANCE LoadLibraryExA(LPCSTR,HANDLE,DWORD);\r\nBOOL LockFile( HANDLE,DWORD,DWORD,DWORD,DWORD);\r\nBOOL UnlockFile(HANDLE,DWORD,DWORD,DWORD,DWORD);\r\nBOOL LockFileEx(HANDLE,DWORD,DWORD,DWORD,DWORD,LPOVERLAPPED);\r\nBOOL UnlockFileEx(HANDLE,DWORD,DWORD,DWORD,LPOVERLAPPED);\r\nint MultiByteToWideChar(UINT,DWORD,LPCSTR,int,LPWSTR,int);\r\nint WideCharToMultiByte(UINT,DWORD,LPCWSTR,int,LPSTR,int,LPCSTR,LPBOOL);\r\nBOOL WriteFile(HANDLE,LPCVOID,DWORD,LPDWORD,LPOVERLAPPED);\r\nBOOL ReadFile(HANDLE,LPVOID,DWORD,LPDWORD,LPOVERLAPPED);\r\nBOOL SetEndOfFile(HANDLE);\r\nDWORD SetFilePointer(HANDLE,LONG,PLONG,DWORD);\r\nDWORD WaitForSingleObject(HANDLE,DWORD);\r\nDWORD WaitForMultipleObjects(DWORD,CONST HANDLE *,BOOL,DWORD);\r\nDWORD WaitForSingleObjectEx(HANDLE,DWORD,BOOL);\r\nDWORD WaitForMultipleObjectsEx(DWORD,CONST HANDLE *,BOOL,DWORD,BOOL);\r\nVOID OutputDebugStringW(LPCWSTR);\r\nVOID OutputDebugStringA(LPCSTR);\r\nHANDLE GetProcessHeap(VOID);\r\nDWORD WINAPI GetProcessIdOfThread(HANDLE);\r\nDWORD WINAPI GetProcessId(HANDLE);\r\nDWORD WINAPI GetCurrentProcessorNumber(void);\r\nBOOL WINAPI GetProcessHandleCount(HANDLE,PDWORD);\r\nBOOL WINAPI GetProcessIoCounters(HANDLE,PIO_COUNTERS);\r\nBOOL WINAPI GetProcessWorkingSetSize(HANDLE,PSIZE_T,PSIZE_T);\r\nBOOL WINAPI GetProcessWorkingSetSizeEx(HANDLE,PSIZE_T,PSIZE_T,PDWORD);\r\nBOOL WINAPI SetProcessWorkingSetSize(HANDLE,SIZE_T,SIZE_T);\r\nBOOL WINAPI SetProcessWorkingSetSizeEx(HANDLE,SIZE_T,SIZE_T,DWORD);\r\nDWORD GetProcessHeaps(DWORD,PHANDLE);\r\nDWORD GetProcessVersion(DWORD);\r\nLPVOID MapViewOfFile(HANDLE,DWORD,DWORD,DWORD,DWORD);\r\nBOOL FlushViewOfFile(LPCVOID,DWORD);\r\nBOOL UnmapViewOfFile(LPCVOID);\r\nHANDLE GetCurrentProcess(VOID);\r\nBOOL SetFileTime(HANDLE,CONST FILETIME *,CONST FILETIME *,CONST FILETIME *);\r\nDWORD GetEnvironmentVariableW(LPCWSTR,LPWSTR,DWORD);\r\nBOOL SetEnvironmentVariableW(LPCWSTR,LPCWSTR);\r\nDWORD GetEnvironmentVariableA(LPCSTR,LPSTR,DWORD);\r\nBOOL SetEnvironmentVariableA(LPCSTR,LPCSTR);\r\nBOOL SetCurrentDirectoryW(LPCWSTR);\r\nDWORD GetCurrentDirectoryW(DWORD,LPWSTR);\r\nBOOL SetCurrentDirectoryA(LPCSTR);\r\nDWORD GetCurrentDirectoryA(DWORD,LPSTR);\r\nVOID DebugBreak(VOID);\r\nHMENU GetMenu(HWND);\r\nBOOL AdjustWindowRectEx(LPRECT,DWORD,BOOL,DWORD);\r\nBOOL SetWindowPos(HWND,HWND,int,int,int,int,UINT);\r\nHBRUSH GetSysColorBrush(int);\r\nBOOL GetUpdateRect(HWND,LPRECT,BOOL);\r\nBOOL AngleArc(HDC,int,int,DWORD,FLOAT,FLOAT);\r\nBOOL BeginPath(HDC);\r\nBOOL CloseFigure(HDC);\r\nBOOL EndPath(HDC);\r\nBOOL FillPath(HDC);\r\nBOOL FlattenPath(HDC);\r\nBOOL StrokeAndFillPath(HDC);\r\nBOOL StrokePath(HDC);\r\nBOOL WidenPath(HDC);\r\nBOOL Ellipse(HDC,int,int,int,int);\r\nint ReleaseDC(HWND,HDC);\r\nDWORD GetWindowThreadProcessId(HWND,LPDWORD);\r\nint GetSystemMetrics(int);\r\nHFONT CreateFontW(int,int,int,int,int,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,LPCWSTR);\r\nHFONT CreateFontA(int,int,int,int,int,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,LPCSTR);\r\nBOOL Polygon(HDC,CONST POINT *,int);\r\nCOLORREF SetTextColor(HDC,COLORREF);\r\nCOLORREF SetBkColor(HDC,COLORREF);\r\nUINT SetTextAlign(HDC,UINT);\r\nBOOL TextOutW(HDC,int,int,LPCWSTR,int);\r\nBOOL TextOutA(HDC,int,int,LPCSTR,int);\r\nDWORD GetLogicalDrives(VOID);\r\nBOOL GetFileInformationByHandle(HANDLE,LPBY_HANDLE_FILE_INFORMATION);\r\nHANDLE CreateFileMappingW(HANDLE,LPSECURITY_ATTRIBUTES,DWORD,DWORD,DWORD,LPCWSTR);\r\nHANDLE CreateFileMappingA(HANDLE,LPSECURITY_ATTRIBUTES,DWORD,DWORD,DWORD,LPCSTR);\r\nHWND GetTopWindow(HWND);\r\nHWND GetActiveWindow(VOID);\r\nBOOL SetWindowTextA(HWND,LPCSTR);\r\nMMRESULT waveOutUnprepareHeader(HWAVEOUT, LPWAVEHDR, UINT);\r\nMMRESULT waveOutPrepareHeader(HWAVEOUT, LPWAVEHDR, UINT);\r\nMMRESULT waveOutWrite(HWAVEOUT, LPWAVEHDR, UINT);\r\nMMRESULT waveOutOpen(void*, UINT, void*, DWORD_PTR, DWORD_PTR, DWORD);\r\nHWND WINAPI GetConsoleWindow(void);\r\nBOOL EndDeferWindowPos(HDWP hWinPosInfo);\r\nBOOL SetCursorPos(int,int);\r\nint GetDeviceCaps(HDC,int);\r\nBOOL StretchBlt(HDC,int,int,int,int,HDC,int,int,int,int,DWORD);\r\nBOOL WINAPI LookupAccountNameW(LPCWSTR,LPCWSTR,PSID,PDWORD,LPWSTR,PDWORD,PSID_NAME_USE);\r\nBOOL WINAPI LookupAccountSidW(LPCWSTR,PSID,LPWSTR,PDWORD,LPWSTR,PDWORD,PSID_NAME_USE);\r\nHANDLE WINAPI GetCurrentProcess(void);\r\nHANDLE WINAPI GetCurrentThread(void);\r\nBOOL WINAPI OpenProcessToken(HANDLE,DWORD,PHANDLE);\r\nBOOL WINAPI OpenThreadToken(HANDLE,DWORD,BOOL,PHANDLE);\r\nBOOL WINAPI GetTokenInformation(HANDLE,TOKEN_INFORMATION_CLASS,PVOID,DWORD,PDWORD);\r\nHGLOBAL WINAPI GlobalFree(HGLOBAL);\r\nHLOCAL WINAPI LocalAlloc(UINT,SIZE_T);\r\n\r\n\r\n//!=================\r\n\r\n/*\r\nproc\r\n*/\r\n#define GetWindowLongPtrW GetWindowLongW\r\n#define GetWindowLongPtrA GetWindowLongA\r\n#define SetWindowLongPtrW SetWindowLongW\r\n#define SetWindowLongPtrA SetWindowLongA\r\n\r\n#ifdef UNICODE\r\n\t#define GetModuleHandle GetModuleHandleW\r\n\t#define LoadLibrary LoadLibraryW\r\n\t#define LoadLibraryEx LoadLibraryExW\r\n\t#define OutputDebugString OutputDebugStringW\r\n\t#define GetMessage GetMessageW\r\n\t#define PeekMessage PeekMessageW\r\n\t#define DispatchMessage DispatchMessageW\r\n\t#define PlaySound PlaySoundW\r\n\t#define TEXT(quote) L##quote\r\n\t#define LoadIcon LoadIconW\r\n\ttypedef unsigned short *LPTSTR;\r\n\ttypedef unsigned short TCHAR;\r\n\t#define LoadCursor LoadCursorW\r\n\t#define RegisterClass RegisterClassW\r\n\t#define CreateWindowEx CreateWindowExW\r\n\t#define CreateWindowW(Class,Name,Style,x,y,W,H,Parent,Menu,Inst,Param) CreateWindowExW(0,Class,Name,Style,x,y,W,H,Parent,Menu,Inst,Param)\r\n\t#define CreateWindow CreateWindowW\r\n\t#define DrawText DrawTextW\r\n\t#define DefWindowProc DefWindowProcW\r\n\t#define FillConsoleOutputCharacter FillConsoleOutputCharacterW\r\n\t#define CreateEvent CreateEventW\r\n\t#define ReadConsoleOutputCharacter ReadConsoleOutputCharacterW\r\n\t#define WriteConsoleInput WriteConsoleInputW\r\n\t#define GetSystemDirectory GetSystemDirectoryW\r\n\t#define SearchPath SearchPathW\r\n\t#define RegisterClassEx RegisterClassExA\r\n\t#define GetWindowLong GetWindowLongW\r\n\t#define GetWindowLongPtr GetWindowLongPtrW\r\n\t#define SetWindowLong SetWindowLongW\r\n\t#define SetWindowLongPtr SetWindowLongPtrW\r\n\t#define SendMessage SendMessageW\r\n\t#define SendMessageTimeout SendMessageTimeoutW\r\n\t#define GetLogicalDriveStrings GetLogicalDriveStringsW\r\n\t#define FindFirstFile FindFirstFileW\r\n\t#define FindNextFile FindNextFileW\r\n\t#define GetCommandLine GetCommandLineW\r\n\t#define ScrollConsoleScreenBuffer ScrollConsoleScreenBufferW\r\n\t#define CreateProcess CreateProcessW\r\n\t#define LPSTARTUPINFO LPSTARTUPINFOW\r\n\t#define CreateFile CreateFileW\r\n\t#define RegOpenKeyEx RegOpenKeyExW\r\n\t#define RegQueryValueEx RegQueryValueExW\r\n\t#define RegSetValueEx RegSetValueExW\r\n\t#define GetFullPathname GetFullPathNameW\r\n\t#define GetTempPath GetTempPathW\r\n\t#define GetEnvironmentVariable GetEnvironmentVariableW\r\n\t#define SetEnvironmentVariable SetEnvironmentVariableW\r\n\t#define GetCurrentDirectory GetCurrentDirectoryW\r\n\t#define SetCurrentDirectory SetCurrentDirectoryW\r\n\t#define CreateFont CreateFontW\r\n\t#define TextOut TextOutW\r\n\t#define CreateFileMapping CreateFileMappingW\r\n\t#define OSVERSIONINFO OSVERSIONINFOW\r\n\t#define STARTUPINFO STARTUPINFOW\r\n#else\r\n\t#define GetModuleHandle GetModuleHandleA\r\n\t#define LoadLibrary LoadLibraryA\r\n\r\n\t#define LoadLibraryEx LoadLibraryExA\r\n\t#define OutputDebugString OutputDebugStringA\r\n\t#define GetMessage GetMessageA\r\n\t#define PeekMessage PeekMessageA\r\n\t#define DispatchMessage DispatchMessageA\r\n\t#define PlaySound PlaySoundA\r\n\t#define TEXT(quote) quote\r\n\t#define LoadIcon LoadIconA\r\n\ttypedef unsigned char *LPTSTR;\r\n\ttypedef char TCHAR;\r\n\t#define LoadCursor LoadCursorA\r\n\t#define RegisterClass RegisterClassA\r\n\t#define CreateWindowEx CreateWindowExA\r\n\t#define CreateWindowA(C,WN,S,x,y,W,H,hW,hM,hI,l) CreateWindowExA(0,C,WN,S,x,y,W,H,hW,hM,hI,l)\r\n\t#define CreateWindow CreateWindowA\r\n\t#define DrawText DrawTextA\r\n\t#define DefWindowProc DefWindowProcA\r\n\t#define FillConsoleOutputCharacter FillConsoleOutputCharacterA\r\n\t#define CreateEvent CreateEventA\r\n\t#define ReadConsoleOutputCharacter ReadConsoleOutputCharacterA\r\n\t#define WriteConsoleInput WriteConsoleInputA\r\n\t#define GetSystemDirectory GetSystemDirectoryA\r\n\t#define SearchPath SearchPathA\r\n\t#define RegisterClassEx RegisterClassExA\r\n\t#define GetWindowLong GetWindowLongA\r\n\t#define GetWindowLongPtr GetWindowLongPtrA\r\n\t#define SetWindowLong SetWindowLongA\r\n\t#define SetWindowLongPtr SetWindowLongPtrA\r\n\t#define SendMessage SendMessageA\r\n\t#define SendMessageTimeout SendMessageTimeoutA\r\n\t#define GetLogicalDriveStrings GetLogicalDriveStringsA\r\n\t#define FindFirstFile FindFirstFileA\r\n\t#define FindNextFile FindNextFileA\r\n\t#define GetCommandLine GetCommandLineA\r\n\t#define ScrollConsoleScreenBuffer ScrollConsoleScreenBufferA\r\n\t#define CreateProcess CreateProcessA\r\n\t#define LPSTARTUPINFO LPSTARTUPINFOA\r\n\t#define CreateFile CreateFileA\r\n\t#define RegOpenKeyEx RegOpenKeyExA\r\n\t#define RegQueryValueEx RegQueryValueExA\r\n\t#define RegSetValueEx RegSetValueExA\r\n\t#define GetFullPathname GetFullPathNameA\r\n\t#define GetVersionEx GetVersionExA\r\n\t#define GetEnvironmentVariable GetEnvironmentVariableA\r\n\t#define SetEnvironmentVariable SetEnvironmentVariableA\r\n\t#define GetCurrentDirectory GetCurrentDirectoryA\r\n\t#define SetCurrentDirectory SetCurrentDirectoryA\r\n\t#define CreateFont CreateFontA\r\n\t#define TextOut TextOutA\r\n\t#define CreateFileMapping CreateFileMappingA\r\n\t#define OSVERSIONINFO OSVERSIONINFOA\r\n\t#define STARTUPINFO STARTUPINFOA\r\n\t#define SetWindowText SetWindowTextA\r\n#endif // windows.h\r\n\r\nBOOL CreateProcessW(LPCWSTR,LPWSTR,LPSECURITY_ATTRIBUTES,LPSECURITY_ATTRIBUTES,BOOL,DWORD,LPVOID,LPCWSTR,LPSTARTUPINFOW,LPPROCESS_INFORMATION);\r\nBOOL CreateProcessA(LPCSTR,LPSTR,LPSECURITY_ATTRIBUTES, LPSECURITY_ATTRIBUTES,BOOL,DWORD,LPVOID,LPCSTR,LPSTARTUPINFOA,LPPROCESS_INFORMATION);\r\n\r\n#endif\r\n";
static byte *  cc_headers_h_fcntl = (byte*)"/* FCNTL.H */\r\n\r\nint _setmode(int,int);\r\n\r\n#ifndef _INC_FCNTL\r\n#define _INC_FCNTL\r\n\r\n#define _O_RDONLY 0x0000\r\n#define _O_WRONLY 0x0001\r\n#define _O_RDWR 0x0002\r\n#define _O_APPEND 0x0008\r\n#define _O_CREAT 0x0100\r\n#define _O_TRUNC 0x0200\r\n#define _O_EXCL 0x0400\r\n#define _O_TEXT 0x4000\r\n#define _O_BINARY 0x8000\r\n#define _O_WTEXT 0x10000\r\n#define _O_U16TEXT 0x20000\r\n#define _O_U8TEXT 0x40000\r\n#define _O_ACCMODE (_O_RDONLY|_O_WRONLY|_O_RDWR)\r\n\r\n#define _O_RAW _O_BINARY\r\n#define _O_NOINHERIT 0x0080\r\n#define _O_TEMPORARY 0x0040\r\n#define _O_SHORT_LIVED 0x1000\r\n\r\n#define _O_SEQUENTIAL 0x0020\r\n#define _O_RANDOM 0x0010\r\n\r\n#if !defined(NO_OLDNAMES) || defined(_POSIX)\r\n#define O_RDONLY _O_RDONLY\r\n#define O_WRONLY _O_WRONLY\r\n#define O_RDWR _O_RDWR\r\n#define O_APPEND _O_APPEND\r\n#define O_CREAT _O_CREAT\r\n#define O_TRUNC _O_TRUNC\r\n#define O_EXCL _O_EXCL\r\n#define O_TEXT _O_TEXT\r\n#define O_BINARY _O_BINARY\r\n#define O_RAW _O_BINARY\r\n#define O_TEMPORARY _O_TEMPORARY\r\n#define O_NOINHERIT _O_NOINHERIT\r\n#define O_SEQUENTIAL _O_SEQUENTIAL\r\n#define O_RANDOM _O_RANDOM\r\n#define O_ACCMODE _O_ACCMODE\r\n#endif\r\n\r\n#endif\r\n";
static byte *  cc_headers_h_io = (byte*)"\r\n#ifndef $io\r\n#define $io\r\n\r\n#include <stdint.h>\r\n#include <wchar.h>\r\n#include <time.h>\r\n\r\n/* io.h */\r\n\r\n#define _A_NORMAL 0x00\r\n#define _A_RDONLY 0x01\r\n#define _A_HIDDEN 0x02\r\n#define _A_SYSTEM 0x04\r\n#define _A_SUBDIR 0x10\r\n#define _A_ARCH 0x20\r\n\r\n\r\n//#message \"IO included\"\r\nstruct _finddata_t {\r\n        unsigned    attrib;\r\n        time_t      time_create;\r\n        time_t      time_access;\r\n        time_t      time_write;\r\n        unsigned long    size;\r\n        char        name[260];\r\n};\r\n\r\nint _isatty(int);\r\n\r\nint _read(int, void*, unsigned int);\r\n#define read _read\r\n\r\nint _open(const char*, int, ...);\r\n#define open _open\r\n\r\nlong _lseek(int, long, int);\r\n#define lseek _lseek\r\n\r\nint _close(int);\r\n#define close _close\r\n\r\nintptr_t _get_osfhandle(int);\r\nint _open_osfhandle(intptr_t,int);\r\n\r\nint _setmode(int,int);\r\n#define setmode _setmode\r\n\r\nint _wchmod(const wchar_t*, int);\r\n\r\nint _chmod(const char *, int);\r\n#define chmod _chmod\r\n\r\nint _dup(int);\r\n#define dup _dup\r\n\r\nintptr_t _findfirst(const char*, struct _finddata_t*);\r\nint _findnext(intptr_t, struct _finddata_t*);\r\nint _findclose(intptr_t);\r\n\r\nint _access(const char*,int);\r\n#define access _access\r\n\r\nint _wunlink(const wchar_t*);\r\n\r\n\r\n#endif\r\n";
static byte *  cc_headers_h_direct = (byte*)"#ifndef $direct\r\n#define $direct\r\n\r\ntypedef struct {\r\n unsigned int total_clusters;\r\n unsigned int avail_clusters;\r\n unsigned int sectors_per_cluster;\r\n unsigned int bytes_per_sector;\r\n} diskfree_t;\r\n\r\nint chdir(const char *);\r\nchar* _getcwd(char *, int);\r\n#define getcwd _getcwd\r\nint _mkdir(const char *);\r\nint _rmdir(const char *);\r\nint _wrmdir(const wchar_t*);\r\nint _wmkdir(const wchar_t*);\r\n\r\n#define mkdir _mkdir\r\n#define rmdir _rmdir\r\n\r\nint _chdrive(int);\r\nchar* _getdcwd(int, char *, int);\r\nwchar_t* _wgetcwd(wchar_t*, int);\r\nint _wchdir(const wchar_t*);\r\nint _getdrive(void);\r\nint _chdir(const char*);\r\n#define chdir _chdir\r\n\r\nunsigned long _getdrives(void);\r\nunsigned int _getdiskfree(unsigned int, diskfree_t*);\r\n\r\n#endif\r\n\r\n";
static byte *  cc_headers_h_process = (byte*)"/* Header process.h */\r\n#ifndef $process\r\n#define $process\r\n\r\n#include <stdint.h>\r\n\r\n#define P_WAIT\t\t0\r\n#define P_NOWAIT\t1\r\n#define P_OVERLAY\t2\r\n#define P_DETACH\t4\r\n#define WAIT_CHILD 0\r\n#define _P_WAIT P_WAIT\r\n#define _P_NOWAIT P_NOWAIT\r\n#define _P_OVERLAY P_OVERLAY\r\n\r\nint _spawnvp(int, const char*, const char*const*);\r\n#define spawnvp _spawnvp\r\n\r\nvoid endthread(void);\r\nunsigned long _beginthreadex(void *,unsigned,unsigned (*)(void *),void *,unsigned,unsigned *);\r\nvoid _endthreadex(unsigned);\r\nint _cwait(int*, int, int);\r\n#define cwait _cwait\r\n//int _System(const char *cmd,int nCmdShow);\r\n\r\nintptr_t _execve(const char*, const char*const*, const char*const*);\r\n#define execve _execve\r\n\r\n//#define _WAIT_CHILD\t0\r\n//#endif\r\n#endif\r\n\r\n";
static byte *  cc_headers_h_malloc = (byte*)"#include <stddef.h>\r\n\r\nvoid* malloc(size_t);\r\nvoid* realloc(void *, size_t);\r\nvoid  free(void *);\r\n";
static byte *  cc_headers_h_bcc = (byte*)"#define __attribute__(x)\r\n#define _WIN32\r\n#define WIN32\r\n#define __WIN32__\r\n#define __inline\r\n#define __dllimport(x)\r\n#define __declspec(x)\r\n#define __stdcall\r\n#define CALLBACK $callback\r\n#define __cdecl\r\n#define EXTERN_C extern\r\n#define DECLSPEC_IMPORT\r\n#define __32BIT__\r\n";
static byte *  cc_headers_h_conio = (byte*)"/* conio.h */\r\n#include <stddef.h>\r\n#include <wchar.h>\r\n\r\nint _getch(void);\r\nint _kbhit(void);\r\nwint_t _getwch(void);\r\n\r\n#define getch _getch\r\n#define kbhit _kbhit\r\n\r\nint _putch(int);\r\nint _cprintf(char *, ...);\r\nint _getche(void);\r\nint _ungetch(int);\r\n\r\n#define putch _putch\r\n#define cprintf _cprintf\r\n#define getche _getche\r\n#define ungetch _ungetch\r\n";
static byte *  cc_headers_h_winsock2 = \
(byte*)"#ifndef _WINSOCK2_H\r\n#define _WINSOCK2_H\r\n\r\n#include <_mingw.h>\r\n#include <windows.h>\r\n\r\n#ifndef FD_SETSIZE\r\n#define FD_SETSIZE 64\r\n#endif\r\n\r\ntypedef unsigned int SOCKET;\r\n\r\ntypedef struct fd_set {\r\n  unsigned int   fd_count;\r\n  SOCKET  fd_array[FD_SETSIZE];\r\n} fd_set;\r\n\r\nextern int __stdcall __WSAFDIsSet(SOCKET,fd_set *);\r\n\r\n#ifndef FD_CLR\r\n#define FD_CLR(fd,set) do { unsigned int __i;\\\r\nfor (__i = 0; __i < ((fd_set *)(set))->fd_count ; __i++) {\\\r\n    if (((fd_set *)(set))->fd_array[__i] == (fd)) {\\\r\n    while (__i < ((fd_set *)(set))->fd_count-1) {\\\r\n        ((fd_set*)(set))->fd_array[__i] = ((fd_set*)(set))->fd_array[__i+1];\\\r\n        __i++;\\\r\n    }\\\r\n    ((fd_set*)(set))->fd_count--;\\\r\n    break;\\\r\n    }\\\r\n}\\\r\n} while (0)\r\n#endif\r\n\r\n#ifndef FD_SET\r\n/* this differs from the define in winsock.h and in cygwin sys/types.h */\r\n#define FD_SET(fd, set) do { unsigned int __i;\\\r\nfor (__i = 0; __i < ((fd_set *)(set))->fd_count ; __i++) {\\\r\n    if (((fd_set *)(set))->fd_array[__i] == (fd)) {\\\r\n        break;\\\r\n    }\\\r\n}\\\r\nif (__i == ((fd_set *)(set))->fd_count) {\\\r\n    if (((fd_set *)(set))->fd_count < FD_SETSIZE) {\\\r\n        ((fd_set *)(set))->fd_array[__i] = (fd);\\\r\n        ((fd_set *)(set))->fd_count++;\\\r\n    }\\\r\n}\\\r\n} while(0)\r\n#endif\r\n\r\n#ifndef FD_ZERO\r\n#define FD_ZERO(set) (((fd_set *)(set))->fd_count=0)\r\n#endif\r\n\r\n#ifndef FD_ISSET\r\n#define FD_ISSET(fd, set) __WSAFDIsSet((SOCKET)(fd), (fd_set *)(set))\r\n#endif\r\n\r\n#ifndef _TIMEVAL_DEFINED /* also in sys/time.h */\r\n#define _TIMEVAL_DEFINED\r\nstruct timeval {\r\n    long tv_sec;\r\n    long tv_usec;\r\n};\r\n#endif\r\n\r\nstruct in_addr {\r\n    union {\r\n        struct { unsigned char s_b1,s_b2,s_b3,s_b4; } S_un_b;\r\n        struct { unsigned short s_w1,s_w2; } S_un_w;\r\n        unsigned long S_addr;\r\n    } S_un;\r\n};\r\n#define s_addr  S_un.S_addr\r\n\r\nstruct sockaddr_in {\r\n    short sin_family;\r\n    unsigned short sin_port;\r\n    struct in_addr sin_addr;\r\n    char sin_zero[8];\r\n};\r\n\r\nstruct sockaddr {\r\n    unsigned short sa_family;\r\n    char sa_data[14];\r\n};\r\n\r\nstruct hostent {\r\n    char *h_name;\r\n    char **h_aliases;\r\n    short h_addrtype;\r\n    short h_length;\r\n    char **h_addr_list;\r\n};\r\n#define h_addr h_addr_list[0]\r\n\r\n#define WSADESCRIPTION_LEN  256\r\n#define WSASYS_STATUS_LEN   128\r\ntypedef struct WSAData {\r\n    WORD wVersion;\r\n    WORD wHighVersion;\r\n    char szDescription[WSADESCRIPTION_LEN+1];\r\n    char szSystemStatus[WSASYS_STATUS_LEN+1];\r\n    unsigned short iMaxSockets;\r\n    unsigned short iMaxUdpDg;\r\n    char *lpVendorInfo;\r\n} WSADATA;\r\ntypedef WSADATA *LPWSADATA;\r\n\r\n#define INVALID_SOCKET (SOCKET)(~0)\r\n#define SOCK_STREAM  1\r\n#define SO_REUSEADDR 4\r\n#define AF_INET 2\r\n#define MSG_PEEK 0x2\r\n#define INADDR_ANY (unsigned long)0x00000000\r\n#define INADDR_LOOPBACK 0x7f000001\r\n#define SOL_SOCKET 0xffff\r\n\r\n#define SD_RECEIVE  0x00\r\n#define SD_SEND     0x01\r\n#define SD_BOTH     0x02\r\n\r\n#define h_errno WSAGetLastError()\r\n\r\n#define WSABASEERR 10000\r\n#define TRY_AGAIN (WSABASEERR+1002)\r\n\r\nSOCKET __stdcall accept(SOCKET, struct sockaddr *, int *);\r\nint __stdcall bind(SOCKET, const struct sockaddr *, int);\r\nint __stdcall closesocket(SOCKET);\r\nint __stdcall connect(SOCKET, const struct sockaddr *, int);\r\nstruct hostent *__stdcall gethostbyname(const char *);\r\nint __stdcall gethostname(char *, int);\r\nint __stdcall getpeername(SOCKET, struct sockaddr *, int *);\r\nint __stdcall getsockname(SOCKET, struct sockaddr *, int *);\r\nunsigned long __stdcall htonl(unsigned long);\r\nunsigned short __stdcall htons(unsigned short);\r\nint __stdcall listen(SOCKET, int);\r\nunsigned long __stdcall ntohl(unsigned long);\r\nunsigned short __stdcall ntohs(unsigned short);\r\nint __stdcall recv(SOCKET, char *, int, int);\r\nint __stdcall recvfrom(SOCKET, char *, int, int, struct sockaddr *, int *);\r\nint __stdcall select(int nfds, fd_set *, fd_set *, fd_set *, const struct timeval *);\r\nint __stdcall send(SOCKET, const char *, int, int);\r\nint __stdcall sendto(SOCKET, const char *, int, int, const struct sockaddr *, int);\r\nint __stdcall setsockopt(SOCKET, int, int, const char *, int);\r\nint __stdcall shutdown(SOCKET, int);\r\nint __stdcall WSACleanup(void);\r\nint __stdcall WSAGetLastError(void);\r\nint __stdcall WSAStartup(WORD, LPWSADATA);\r\n\r\nSOCKET __stdcall socket(int, int, int);\r\n\r\n#endif\r\n\r\n";
static byte *  cc_headers_h__mingw = \
(byte*)"/*\r\n * _mingw.h\r\n *\r\n *  This file is for TinyCC and not part of the Mingw32 package.\r\n *\r\n *  THIS SOFTWARE IS NOT COPYRIGHTED\r\n *\r\n *  This source code is offered for use in the public domain. You may\r\n *  use, modify or distribute it freely.\r\n *\r\n *  This code is distributed in the hope that it will be useful but\r\n *  WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY\r\n *  DISCLAIMED. This includes but is not limited to warranties of\r\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\r\n *\r\n */\r\n\r\n#ifndef __MINGW_H\r\n#define __MINGW_H\r\n\r\n/* some winapi files define these before including _mingw.h --> */\r\n#undef __cdecl\r\n#undef _X86_\r\n#undef WIN32\r\n/* <-- */\r\n\r\n#include <stddef.h>\r\n#include <stdarg.h>\r\n\r\n#define __int8 char\r\n#define __int16 short\r\n#define __int32 int\r\n#define __int64 long long\r\n#define _HAVE_INT64\r\n\r\n#define __cdecl\r\n#define __declspec(x) __attribute__((x))\r\n#define __unaligned __attribute__((packed))\r\n#define __fastcall __attribute__((fastcall))\r\n\r\n#define __MSVCRT__ 1\r\n#undef _MSVCRT_\r\n#define __MINGW_IMPORT extern __declspec(dllimport)\r\n#define __MINGW_ATTRIB_NORETURN\r\n#define __MINGW_ATTRIB_CONST\r\n#define __MINGW_ATTRIB_DEPRECATED\r\n#define __MINGW_ATTRIB_MALLOC\r\n#define __MINGW_ATTRIB_PURE\r\n#define __MINGW_ATTRIB_NONNULL(arg)\r\n#define __MINGW_NOTHROW\r\n#define __GNUC_VA_LIST\r\n\r\n#define _CRTIMP extern\r\n#define __CRT_INLINE extern __inline__\r\n\r\n#define _CRT_ALIGN(x) __attribute__((aligned(x)))\r\n#define DECLSPEC_ALIGN(x) __attribute__((aligned(x)))\r\n#define _CRT_PACKING 8\r\n#define __CRT_UNALIGNED\r\n#define _CONST_RETURN\r\n\r\n#ifndef _TRUNCATE\r\n#define _TRUNCATE ((size_t)-1)\r\n#endif\r\n\r\n#define __CRT_STRINGIZE(_Value) #_Value\r\n#define _CRT_STRINGIZE(_Value) __CRT_STRINGIZE(_Value)\r\n#define __CRT_WIDE(_String) L ## _String\r\n#define _CRT_WIDE(_String) __CRT_WIDE(_String)\r\n\r\n#ifdef _WIN64\r\n#define __stdcall\r\n#define _AMD64_ 1\r\n#define __x86_64 1\r\n#define _M_X64 100 /* Visual Studio */\r\n#define _M_AMD64 100 /* Visual Studio */\r\n#define USE_MINGW_SETJMP_TWO_ARGS\r\n#define mingw_getsp tinyc_getbp\r\n#define __TRY__\r\n#else\r\n#define __stdcall __attribute__((__stdcall__))\r\n#define _X86_ 1\r\n#define _M_IX86 300 /* Visual Studio */\r\n#define WIN32 1\r\n#define _USE_32BIT_TIME_T\r\n#ifdef __arm__\r\n#define __TRY__\r\n#else\r\n#define __TRY__ void __try__(void**), *_sehrec[6]; __try__(_sehrec);\r\n#endif\r\n#endif\r\n\r\n/* in stddef.h */\r\n#define _SIZE_T_DEFINED\r\n#define _SSIZE_T_DEFINED\r\n#define _PTRDIFF_T_DEFINED\r\n#define _WCHAR_T_DEFINED\r\n#define _UINTPTR_T_DEFINED\r\n#define _INTPTR_T_DEFINED\r\n#define _INTEGRAL_MAX_BITS 64\r\n\r\n#ifndef _TIME32_T_DEFINED\r\n#define _TIME32_T_DEFINED\r\ntypedef long __time32_t;\r\n#endif\r\n\r\n#ifndef _TIME64_T_DEFINED\r\n#define _TIME64_T_DEFINED\r\ntypedef long long __time64_t;\r\n#endif\r\n\r\n#ifndef _TIME_T_DEFINED\r\n#define _TIME_T_DEFINED\r\n#ifdef _USE_32BIT_TIME_T\r\ntypedef __time32_t time_t;\r\n#else\r\ntypedef __time64_t time_t;\r\n#endif\r\n#endif\r\n\r\n#ifndef _WCTYPE_T_DEFINED\r\n#define _WCTYPE_T_DEFINED\r\ntypedef wchar_t wctype_t;\r\n#endif\r\n\r\n#ifndef _WINT_T\r\n#define _WINT_T\r\ntypedef short wint_t;\r\n#endif\r\n\r\ntypedef int errno_t;\r\n#define _ERRCODE_DEFINED\r\n\r\ntypedef struct threadlocaleinfostruct *pthreadlocinfo;\r\ntypedef struct threadmbcinfostruct *pthreadmbcinfo;\r\ntypedef struct localeinfo_struct _locale_tstruct,*_locale_t;\r\n\r\n/* for winapi */\r\n#define _ANONYMOUS_UNION\r\n#define _ANONYMOUS_STRUCT\r\n#define DECLSPEC_NORETURN\r\n#define DECLARE_STDCALL_P(type) __stdcall type\r\n#define NOSERVICE 1\r\n#define NOMCX 1\r\n#define NOIME 1\r\n#define __INTRIN_H_\r\n#ifndef DUMMYUNIONNAME\r\n#  define DUMMYUNIONNAME\r\n#  define DUMMYUNIONNAME1\r\n#  define DUMMYUNIONNAME2\r\n#  define DUMMYUNIONNAME3\r\n#  define DUMMYUNIONNAME4\r\n#  define DUMMYUNIONNAME5\r\n#endif\r\n#ifndef DUMMYSTRUCTNAME\r\n#  define DUMMYSTRUCTNAME\r\n#endif\r\n#ifndef WINVER\r\n# define WINVER 0x0502\r\n#endif\r\n#ifndef _WIN32_WINNT\r\n# define _WIN32_WINNT 0x502\r\n#endif\r\n\r\n#define __C89_NAMELESS\r\n#define __MINGW_EXTENSION\r\n#define WINAPI_FAMILY_PARTITION(X) 1\r\n#define MINGW_HAS_SECURE_API\r\n\r\n#endif /* __MINGW_H */\r\n";
static byte *  cc_headers_h_windowsx = (byte*)"/* Header windowsx.h */\r\n\r\n#ifndef $windowsx\r\n#define $windowsx 1\r\n\r\n#define GET_X_LPARAM(lp)                        ((int)(short)LOWORD(lp))\r\n#define GET_Y_LPARAM(lp)                        ((int)(short)HIWORD(lp))\r\n\r\n#endif // windowsx\r\n\r\n";
byte *  cc_headers_stdhdrnames[42] = {
    (byte*)"bcc.h",
    (byte*)"assert.h",
    (byte*)"ctype.h",
    (byte*)"errno.h",
    (byte*)"fenv.h",
    (byte*)"float.h",
    (byte*)"inttypes.h",
    (byte*)"stdint.h",
    (byte*)"limits.h",
    (byte*)"locale.h",
    (byte*)"_ansi.h",
    (byte*)"math.h",
    (byte*)"setjmp.h",
    (byte*)"signal.h",
    (byte*)"stdarg.h",
    (byte*)"stdbool.h",
    (byte*)"stddef.h",
    (byte*)"stdio.h",
    (byte*)"stdlib.h",
    (byte*)"_syslist.h",
    (byte*)"string.h",
    (byte*)"time.h",
    (byte*)"utime.h",
    (byte*)"unistd.h",
    (byte*)"safelib.h",
    (byte*)"wchar.h",
    (byte*)"wctype.h",
    (byte*)"sys/types.h",
    (byte*)"sys/stat.h",
    (byte*)"sys/timeb.h",
    (byte*)"sys/utime.h",
    (byte*)"malloc.h",
    (byte*)"windows.h",
    (byte*)"fcntl.h",
    (byte*)"io.h",
    (byte*)"direct.h",
    (byte*)"process.h",
    (byte*)"memory.h",
    (byte*)"conio.h",
    (byte*)"winsock2.h",
    (byte*)"_mingw.h",
    (byte*)"windowsx.h"
};
byte * *  cc_headers_stdhdrtext[42] = {
    &cc_headers_h_bcc,
    &cc_headers_h_assert,
    &cc_headers_h_ctype,
    &cc_headers_h_errno,
    &cc_headers_h_fenv,
    &cc_headers_h_float,
    &cc_headers_h_inttypes,
    &cc_headers_h_stdint,
    &cc_headers_h_limits,
    &cc_headers_h_locale,
    &cc_headers_h__ansi,
    &cc_headers_h_math,
    &cc_headers_h_setjmp,
    &cc_headers_h_signal,
    &cc_headers_h_stdarg,
    &cc_headers_h_stdbool,
    &cc_headers_h_stddef,
    &cc_headers_h_stdio,
    &cc_headers_h_stdlib,
    &cc_headers_h__syslist,
    &cc_headers_h_string,
    &cc_headers_h_time,
    &cc_headers_h_utime,
    &cc_headers_h_unistd,
    &cc_headers_h_safelib,
    &cc_headers_h_wchar,
    &cc_headers_h_wctype,
    &cc_headers_h_systypes,
    &cc_headers_h_sysstat,
    &cc_headers_h_systimeb,
    &cc_headers_h_sysutime,
    &cc_headers_h_malloc,
    &cc_headers_h_windows,
    &cc_headers_h_fcntl,
    &cc_headers_h_io,
    &cc_headers_h_direct,
    &cc_headers_h_process,
    &cc_headers_h_memory,
    &cc_headers_h_conio,
    &cc_headers_h_winsock2,
    &cc_headers_h__mingw,
    &cc_headers_h_windowsx
};
i64 cc_lib_autotypeno = (i64)0;
static i64 cc_lib_currlineno;
i64 cc_lib_nextafindex = (i64)0;
static struct mlib_strbuffer cc_lib_exprstrvar;
static struct mlib_strbuffer *  cc_lib_exprstr = &cc_lib_exprstrvar;
static struct cc_decls_unitrec *  cc_lib_unitheapptr = 0;
static i64 cc_lib_remainingunits = (i64)0;
static struct cc_decls_strec *  cc_parse_ist_symptr;
static i64 cc_parse_insidefor;
static i64 cc_parse_intypeof;
static byte cc_parse_looptypestack[100];
static i64 cc_parse_loopindex;
static struct cc_decls_caserec *  cc_parse_casevaluestack[100];
static byte cc_parse_iscallbackfnx;
static byte cc_parse_constantseen = (u8)0u;
static byte cc_parse_ingeneric = (u8)0u;
i64 cc_libmcl_nmemaddr;
i64 cc_libmcl_nmem;
i64 cc_libmcl_fshowfullnames = (i64)1;
i64 cc_libmcl_fshowmsource = (i64)0;
i64 cc_libmcl_fabsused = (i64)0;
i64 cc_libmcl_fchsused = (i64)0;
i64 cc_libmcl_kk0used = (i64)0;
i64 cc_libmcl_retindex;
i64 cc_libmcl_stackaligned;
byte *  cc_libmcl_mclnames[104] = {
    (byte*)"m_comment",
    (byte*)"m_blank",
    (byte*)"m_label",
    (byte*)"m_labelname",
    (byte*)"m_mov",
    (byte*)"m_push",
    (byte*)"m_pop",
    (byte*)"m_lea",
    (byte*)"m_cmovcc",
    (byte*)"m_fmov",
    (byte*)"m_iwiden",
    (byte*)"m_uwiden",
    (byte*)"m_inarrow",
    (byte*)"m_unarrow",
    (byte*)"m_call",
    (byte*)"m_ret",
    (byte*)"m_retn",
    (byte*)"m_jmp",
    (byte*)"m_jmpcc",
    (byte*)"m_exch",
    (byte*)"m_add",
    (byte*)"m_sub",
    (byte*)"m_imul",
    (byte*)"m_idiv",
    (byte*)"m_udiv",
    (byte*)"m_irem",
    (byte*)"m_urem",
    (byte*)"m_and",
    (byte*)"m_or",
    (byte*)"m_xor",
    (byte*)"m_test",
    (byte*)"m_cmp",
    (byte*)"m_shl",
    (byte*)"m_ishr",
    (byte*)"m_ushr",
    (byte*)"m_neg",
    (byte*)"m_not",
    (byte*)"m_inc",
    (byte*)"m_dec",
    (byte*)"m_setcc",
    (byte*)"m_fneg",
    (byte*)"m_fabs",
    (byte*)"m_fsqrt",
    (byte*)"m_fadd",
    (byte*)"m_fsub",
    (byte*)"m_fmul",
    (byte*)"m_fdiv",
    (byte*)"m_fcmp",
    (byte*)"m_ufix",
    (byte*)"m_ifix",
    (byte*)"m_ufloat",
    (byte*)"m_ifloat",
    (byte*)"m_fwiden",
    (byte*)"m_fnarrow",
    (byte*)"m_fmin",
    (byte*)"m_fmax",
    (byte*)"m_resb",
    (byte*)"m_db",
    (byte*)"m_dw",
    (byte*)"m_dd",
    (byte*)"m_dq",
    (byte*)"m_defstr",
    (byte*)"m_defwstr",
    (byte*)"m_align",
    (byte*)"m_segment",
    (byte*)"m_cdq",
    (byte*)"m_assem",
    (byte*)"m_end",
    (byte*)"mx_imul2",
    (byte*)"mx_sar",
    (byte*)"mx_shr",
    (byte*)"mx_div",
    (byte*)"mx_movzx",
    (byte*)"mx_movsx",
    (byte*)"mx_inot",
    (byte*)"mx_mul",
    (byte*)"mx_movd",
    (byte*)"mx_movq",
    (byte*)"mx_addss",
    (byte*)"mx_addsd",
    (byte*)"mx_subss",
    (byte*)"mx_subsd",
    (byte*)"mx_mulss",
    (byte*)"mx_mulsd",
    (byte*)"mx_divss",
    (byte*)"mx_divsd",
    (byte*)"mx_comiss",
    (byte*)"mx_comisd",
    (byte*)"mx_cvtsi2ss",
    (byte*)"mx_cvtsi2sd",
    (byte*)"mx_cvtss2sd",
    (byte*)"mx_cvtsd2ss",
    (byte*)"mx_cvttss2si",
    (byte*)"mx_cvttsd2si",
    (byte*)"mx_sqrtss",
    (byte*)"mx_sqrtsd",
    (byte*)"mx_minss",
    (byte*)"mx_maxss",
    (byte*)"mx_minsd",
    (byte*)"mx_maxsd",
    (byte*)"mx_xorps",
    (byte*)"mx_xorpd",
    (byte*)"mx_andps",
    (byte*)"mx_andpd"
};
byte *  cc_libmcl_opndnames[7] = {(byte*)"a_none",(byte*)"a_reg",(byte*)"a_imm",(byte*)"a_strimm",(byte*)"a_mem",(byte*)"a_code",(byte*)"a_xreg"};
byte *  cc_libmcl_regnames[18] = {
    (byte*)"rnone",
    (byte*)"r0",
    (byte*)"r1",
    (byte*)"r2",
    (byte*)"r3",
    (byte*)"r4",
    (byte*)"r5",
    (byte*)"r6",
    (byte*)"r7",
    (byte*)"r8",
    (byte*)"r9",
    (byte*)"r10",
    (byte*)"r11",
    (byte*)"r12",
    (byte*)"r13",
    (byte*)"rframe",
    (byte*)"rstack",
    (byte*)"rfpu"
};
byte *  cc_libmcl_xregnames[17] = {
    (byte*)"xnone",
    (byte*)"xr0",
    (byte*)"xr1",
    (byte*)"xr2",
    (byte*)"xr3",
    (byte*)"xr4",
    (byte*)"xr5",
    (byte*)"xr6",
    (byte*)"xr7",
    (byte*)"xr8",
    (byte*)"xr9",
    (byte*)"xr10",
    (byte*)"xr11",
    (byte*)"xr12",
    (byte*)"xr13",
    (byte*)"xr14",
    (byte*)"xr15"
};
byte *  cc_libmcl_condnames[22] = {
    (byte*)"ov",
    (byte*)"nov",
    (byte*)"ltu",
    (byte*)"geu",
    (byte*)"eq",
    (byte*)"ne",
    (byte*)"leu",
    (byte*)"gtu",
    (byte*)"s",
    (byte*)"ns",
    (byte*)"p",
    (byte*)"np",
    (byte*)"lt",
    (byte*)"ge",
    (byte*)"le",
    (byte*)"gt",
    (byte*)"flt",
    (byte*)"fge",
    (byte*)"fle",
    (byte*)"fgt",
    (byte*)"feq",
    (byte*)"fne"
};
byte *  cc_libmcl_asmcondnames[22] = {
    (byte*)"o",
    (byte*)"no",
    (byte*)"b",
    (byte*)"ae",
    (byte*)"z",
    (byte*)"nz",
    (byte*)"be",
    (byte*)"a",
    (byte*)"s",
    (byte*)"ns",
    (byte*)"p",
    (byte*)"np",
    (byte*)"l",
    (byte*)"ge",
    (byte*)"le",
    (byte*)"g",
    (byte*)"b",
    (byte*)"ae",
    (byte*)"be",
    (byte*)"a",
    (byte*)"z",
    (byte*)"nz"
};
byte *  cc_libmcl_valtypenames[11] = {
    (byte*)"no_val",
    (byte*)"int_val",
    (byte*)"real_val",
    (byte*)"string_val",
    (byte*)"wstring_val",
    (byte*)"label_val",
    (byte*)"name_val",
    (byte*)"stringix_val",
    (byte*)"wstringix_val",
    (byte*)"intix_val",
    (byte*)"realix_val"
};
struct cc_libmcl_mclrec *  cc_libmcl_mccode;
struct cc_libmcl_mclrec *  cc_libmcl_mccodex;
struct cc_libmcl_mclrec *  cc_libmcl_modulecode;
i64 cc_libmcl_currsegment = (i64)0;
i64 cc_libmcl_currzdataalign = (i64)0;
i64 cc_libmcl_curridataalign = (i64)0;
i64 cc_libmcl_framebytes;
i64 cc_libmcl_parambytes;
i64 cc_libmcl_frameoffset;
i64 cc_libmcl_isthreadedproc;
i64 cc_libmcl_iscallbackproc;
i64 cc_libmcl_structretoffset;
struct cc_libmcl_mclrec *  cc_libmcl_stacksetinstr;
i64 cc_libmcl_currblocksize;
i64 cc_libmcl_retbeforeblock;
struct cc_libmcl_opndrec *  cc_libmcl_dstackopnd;
struct cc_libmcl_opndrec *  cc_libmcl_dframeopnd;
struct cc_libmcl_opndrec *  cc_libmcl_zero_opnd = 0;
struct cc_decls_unitrec *  cc_libmcl_zero_unit;
static struct mlib_strbuffer cc_libmcl_sbuffer;
struct mlib_strbuffer *  cc_libmcl_dest = &cc_libmcl_sbuffer;
i64 cc_blockmcl_naddto;
i64 cc_blockmcl_naddtox;
static i64 cc_blockmcl_continuestack[100];
static i64 cc_blockmcl_breakstack[100];
static i64 cc_blockmcl_loopindex;
static i64 (*cc_blockmcl_sw_labeltable)[];
static i64 (*cc_blockmcl_sw_valuetable)[];
static i64 cc_blockmcl_sw_lower;
static i64 cc_blockmcl_sw_ncases;
static byte cc_blockmcl_sw_defaultseen;
static i64 cc_blockmcl_sw_defaultlabel;
static i64 cc_blockmcl_sw_breaklabel;
static i64 cc_blockmcl_maxreg = (i64)0;
static struct cc_libmcl_mclrec *  cc_genasm_currmcl;
static u16 *  cc_genasm_wstringtable[1024];
static i64 cc_genasm_wstringlentable[1024];
static byte * (*cc_genasm_stringtable)[];
static i64 (*cc_genasm_stringlentable)[];
static double (*cc_genasm_realtable)[];
static i64 (*cc_genasm_dinttable)[];
static i64 cc_genasm_stringtablesize;
static i64 cc_genasm_realtablesize;
static i64 cc_genasm_dinttablesize;
i64 cc_genasm_nwstrings = (i64)0;
i64 cc_genasm_nstrings = (i64)0;
i64 cc_genasm_nreals = (i64)0;
i64 cc_genasm_ndints = (i64)0;
static byte *  cc_genasm_asmstart;
static byte *  cc_genasm_asmptr;
static byte *  cc_genasm_asmend;
static byte cc_genasm_asmbuffer[20000];
static i64 cc_export_nallprocs;
static i64 cc_export_nallrecs;
static struct mlib_strbuffer cc_export_mmbuffer;
static struct mlib_strbuffer *  cc_export_mm = &cc_export_mmbuffer;
byte *  ax_tables_symbolnames[33] = {
    (byte*)"errorsym",
    (byte*)"commasym",
    (byte*)"colonsym",
    (byte*)"dcolonsym",
    (byte*)"lsqsym",
    (byte*)"rsqsym",
    (byte*)"addsym",
    (byte*)"subsym",
    (byte*)"mulsym",
    (byte*)"eqsym",
    (byte*)"eolsym",
    (byte*)"eofsym",
    (byte*)"hashsym",
    (byte*)"intconstsym",
    (byte*)"realconstsym",
    (byte*)"stringconstsym",
    (byte*)"namesym",
    (byte*)"namedconstsym",
    (byte*)"fwdlocalsym",
    (byte*)"localsym",
    (byte*)"importedsym",
    (byte*)"exportedsym",
    (byte*)"kopcodesym",
    (byte*)"kregsym",
    (byte*)"kxregsym",
    (byte*)"kfregsym",
    (byte*)"kmregsym",
    (byte*)"kjmpccsym",
    (byte*)"ksetccsym",
    (byte*)"kmovccsym",
    (byte*)"kprefixsym",
    (byte*)"ksegnamesym",
    (byte*)"kdummysym"
};
byte *  ax_tables_mclnames[145] = {
    (byte*)"m_comment",
    (byte*)"m_blank",
    (byte*)"m_end",
    (byte*)"m_label",
    (byte*)"m_nop",
    (byte*)"m_param",
    (byte*)"m_assem",
    (byte*)"m_proc",
    (byte*)"m_mov",
    (byte*)"m_push",
    (byte*)"m_pop",
    (byte*)"m_lea",
    (byte*)"m_cmovcc",
    (byte*)"m_movd",
    (byte*)"m_movq",
    (byte*)"m_movsx",
    (byte*)"m_movzx",
    (byte*)"m_movsxd",
    (byte*)"m_call",
    (byte*)"m_ret",
    (byte*)"m_retn",
    (byte*)"m_leave",
    (byte*)"m_jmp",
    (byte*)"m_jmpcc",
    (byte*)"m_xchg",
    (byte*)"m_add",
    (byte*)"m_sub",
    (byte*)"m_adc",
    (byte*)"m_sbb",
    (byte*)"m_imul",
    (byte*)"m_mul",
    (byte*)"m_imul2",
    (byte*)"m_imul3",
    (byte*)"m_idiv",
    (byte*)"m_div",
    (byte*)"m_and",
    (byte*)"m_or",
    (byte*)"m_xor",
    (byte*)"m_test",
    (byte*)"m_cmp",
    (byte*)"m_shl",
    (byte*)"m_sar",
    (byte*)"m_shr",
    (byte*)"m_rol",
    (byte*)"m_ror",
    (byte*)"m_rcl",
    (byte*)"m_rcr",
    (byte*)"m_neg",
    (byte*)"m_not",
    (byte*)"m_inc",
    (byte*)"m_dec",
    (byte*)"m_cbw",
    (byte*)"m_cwd",
    (byte*)"m_cdq",
    (byte*)"m_cqo",
    (byte*)"m_setcc",
    (byte*)"m_bsf",
    (byte*)"m_bsr",
    (byte*)"m_sqrtsd",
    (byte*)"m_sqrtss",
    (byte*)"m_addss",
    (byte*)"m_subss",
    (byte*)"m_mulss",
    (byte*)"m_divss",
    (byte*)"m_addsd",
    (byte*)"m_subsd",
    (byte*)"m_mulsd",
    (byte*)"m_divsd",
    (byte*)"m_comiss",
    (byte*)"m_comisd",
    (byte*)"m_xorpd",
    (byte*)"m_xorps",
    (byte*)"m_andpd",
    (byte*)"m_andps",
    (byte*)"m_pxor",
    (byte*)"m_pand",
    (byte*)"m_cvtss2si",
    (byte*)"m_cvtsd2si",
    (byte*)"m_cvttss2si",
    (byte*)"m_cvttsd2si",
    (byte*)"m_cvtsi2ss",
    (byte*)"m_cvtsi2sd",
    (byte*)"m_cvtsd2ss",
    (byte*)"m_cvtss2sd",
    (byte*)"m_movdqa",
    (byte*)"m_movdqu",
    (byte*)"m_pcmpistri",
    (byte*)"m_pcmpistrm",
    (byte*)"m_fld",
    (byte*)"m_fst",
    (byte*)"m_fstp",
    (byte*)"m_fild",
    (byte*)"m_fist",
    (byte*)"m_fistp",
    (byte*)"m_fadd",
    (byte*)"m_fsub",
    (byte*)"m_fmul",
    (byte*)"m_fdiv",
    (byte*)"m_fsqrt",
    (byte*)"m_fsin",
    (byte*)"m_fcos",
    (byte*)"m_fsincos",
    (byte*)"m_fptan",
    (byte*)"m_fpatan",
    (byte*)"m_fabs",
    (byte*)"m_fchs",
    (byte*)"m_minss",
    (byte*)"m_maxss",
    (byte*)"m_minsd",
    (byte*)"m_maxsd",
    (byte*)"m_db",
    (byte*)"m_dw",
    (byte*)"m_dd",
    (byte*)"m_dq",
    (byte*)"m_ddoffset",
    (byte*)"m_segment",
    (byte*)"m_isegment",
    (byte*)"m_zsegment",
    (byte*)"m_csegment",
    (byte*)"m_align",
    (byte*)"m_resb",
    (byte*)"m_resw",
    (byte*)"m_resd",
    (byte*)"m_resq",
    (byte*)"m_xlat",
    (byte*)"m_loopnz",
    (byte*)"m_loopz",
    (byte*)"m_loopcx",
    (byte*)"m_jecxz",
    (byte*)"m_jrcxz",
    (byte*)"m_cmpsb",
    (byte*)"m_cmpsw",
    (byte*)"m_cmpsd",
    (byte*)"m_cmpsq",
    (byte*)"m_rdtsc",
    (byte*)"m_popcnt",
    (byte*)"m_finit",
    (byte*)"m_fldz",
    (byte*)"m_fld1",
    (byte*)"m_fldpi",
    (byte*)"m_fld2t",
    (byte*)"m_fld2e",
    (byte*)"m_fldlg2",
    (byte*)"m_fldln2",
    (byte*)"m_halt"
};
byte ax_tables_mclnopnds[145] = {
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)2u,
    (u8)1u,
    (u8)1u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)1u,
    (u8)0u,
    (u8)1u,
    (u8)0u,
    (u8)1u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)1u,
    (u8)1u,
    (u8)2u,
    (u8)3u,
    (u8)1u,
    (u8)1u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)3u,
    (u8)3u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)2u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u
};
byte ax_tables_mclcodes[145] = {
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)144u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)232u,
    (u8)195u,
    (u8)0u,
    (u8)201u,
    (u8)233u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)5u,
    (u8)2u,
    (u8)3u,
    (u8)5u,
    (u8)4u,
    (u8)0u,
    (u8)0u,
    (u8)7u,
    (u8)6u,
    (u8)4u,
    (u8)1u,
    (u8)6u,
    (u8)0u,
    (u8)7u,
    (u8)4u,
    (u8)7u,
    (u8)5u,
    (u8)0u,
    (u8)1u,
    (u8)2u,
    (u8)3u,
    (u8)3u,
    (u8)2u,
    (u8)0u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)188u,
    (u8)189u,
    (u8)81u,
    (u8)81u,
    (u8)88u,
    (u8)92u,
    (u8)89u,
    (u8)94u,
    (u8)88u,
    (u8)92u,
    (u8)89u,
    (u8)94u,
    (u8)0u,
    (u8)0u,
    (u8)87u,
    (u8)87u,
    (u8)84u,
    (u8)84u,
    (u8)239u,
    (u8)219u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)102u,
    (u8)243u,
    (u8)99u,
    (u8)98u,
    (u8)0u,
    (u8)2u,
    (u8)3u,
    (u8)0u,
    (u8)2u,
    (u8)3u,
    (u8)193u,
    (u8)233u,
    (u8)201u,
    (u8)249u,
    (u8)250u,
    (u8)254u,
    (u8)255u,
    (u8)251u,
    (u8)242u,
    (u8)243u,
    (u8)225u,
    (u8)224u,
    (u8)93u,
    (u8)95u,
    (u8)93u,
    (u8)95u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)2u,
    (u8)4u,
    (u8)8u,
    (u8)215u,
    (u8)224u,
    (u8)225u,
    (u8)226u,
    (u8)227u,
    (u8)227u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)49u,
    (u8)0u,
    (u8)0u,
    (u8)238u,
    (u8)232u,
    (u8)235u,
    (u8)233u,
    (u8)234u,
    (u8)236u,
    (u8)237u,
    (u8)244u
};
byte *  ax_tables_regnames[21] = {
    (byte*)"rnone",
    (byte*)"r0",
    (byte*)"r1",
    (byte*)"r2",
    (byte*)"r3",
    (byte*)"r4",
    (byte*)"r5",
    (byte*)"r6",
    (byte*)"r7",
    (byte*)"r8",
    (byte*)"r9",
    (byte*)"r10",
    (byte*)"r11",
    (byte*)"r12",
    (byte*)"r13",
    (byte*)"r14",
    (byte*)"r15",
    (byte*)"r16",
    (byte*)"r17",
    (byte*)"r18",
    (byte*)"r19"
};
byte ax_tables_regcodes[21] = {
    (u8)0u,
    (u8)0u,
    (u8)10u,
    (u8)11u,
    (u8)7u,
    (u8)3u,
    (u8)6u,
    (u8)12u,
    (u8)13u,
    (u8)14u,
    (u8)15u,
    (u8)1u,
    (u8)2u,
    (u8)8u,
    (u8)9u,
    (u8)5u,
    (u8)4u,
    (u8)4u,
    (u8)7u,
    (u8)5u,
    (u8)6u
};
byte *  ax_tables_dregnames[136] = {
    (byte*)"d0",
    (byte*)"d1",
    (byte*)"d2",
    (byte*)"d3",
    (byte*)"d4",
    (byte*)"d5",
    (byte*)"d6",
    (byte*)"d7",
    (byte*)"d8",
    (byte*)"d9",
    (byte*)"d10",
    (byte*)"d11",
    (byte*)"d12",
    (byte*)"d13",
    (byte*)"d14",
    (byte*)"d15",
    (byte*)"a0",
    (byte*)"a1",
    (byte*)"a2",
    (byte*)"a3",
    (byte*)"a4",
    (byte*)"a5",
    (byte*)"a6",
    (byte*)"a7",
    (byte*)"a8",
    (byte*)"a9",
    (byte*)"a10",
    (byte*)"a11",
    (byte*)"a12",
    (byte*)"a13",
    (byte*)"a14",
    (byte*)"a15",
    (byte*)"w0",
    (byte*)"w1",
    (byte*)"w2",
    (byte*)"w3",
    (byte*)"w4",
    (byte*)"w5",
    (byte*)"w6",
    (byte*)"w7",
    (byte*)"w8",
    (byte*)"w9",
    (byte*)"w10",
    (byte*)"w11",
    (byte*)"w12",
    (byte*)"w13",
    (byte*)"w14",
    (byte*)"w15",
    (byte*)"b0",
    (byte*)"b1",
    (byte*)"b2",
    (byte*)"b3",
    (byte*)"b4",
    (byte*)"b5",
    (byte*)"b6",
    (byte*)"b7",
    (byte*)"b8",
    (byte*)"b9",
    (byte*)"b10",
    (byte*)"b11",
    (byte*)"b12",
    (byte*)"b13",
    (byte*)"b14",
    (byte*)"b15",
    (byte*)"b16",
    (byte*)"b17",
    (byte*)"b18",
    (byte*)"b19",
    (byte*)"rax",
    (byte*)"rbx",
    (byte*)"rcx",
    (byte*)"rdx",
    (byte*)"rsi",
    (byte*)"rdi",
    (byte*)"rbp",
    (byte*)"rsp",
    (byte*)"r8",
    (byte*)"r9",
    (byte*)"r10",
    (byte*)"r11",
    (byte*)"r12",
    (byte*)"r13",
    (byte*)"r14",
    (byte*)"r15",
    (byte*)"eax",
    (byte*)"ebx",
    (byte*)"ecx",
    (byte*)"edx",
    (byte*)"esi",
    (byte*)"edi",
    (byte*)"ebp",
    (byte*)"esp",
    (byte*)"r8d",
    (byte*)"r9d",
    (byte*)"r10d",
    (byte*)"r11d",
    (byte*)"r12d",
    (byte*)"r13d",
    (byte*)"r14d",
    (byte*)"r15d",
    (byte*)"ax",
    (byte*)"bx",
    (byte*)"cx",
    (byte*)"dx",
    (byte*)"si",
    (byte*)"di",
    (byte*)"bp",
    (byte*)"sp",
    (byte*)"r8w",
    (byte*)"r9w",
    (byte*)"r10w",
    (byte*)"r11w",
    (byte*)"r12w",
    (byte*)"r13w",
    (byte*)"r14w",
    (byte*)"r15w",
    (byte*)"al",
    (byte*)"bl",
    (byte*)"cl",
    (byte*)"dl",
    (byte*)"ah",
    (byte*)"bh",
    (byte*)"ch",
    (byte*)"dh",
    (byte*)"sil",
    (byte*)"dil",
    (byte*)"bpl",
    (byte*)"spl",
    (byte*)"r8b",
    (byte*)"r9b",
    (byte*)"r10b",
    (byte*)"r11b",
    (byte*)"r12b",
    (byte*)"r13b",
    (byte*)"r14b",
    (byte*)"r15b"
};
byte ax_tables_regsizes[136] = {
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u
};
byte ax_tables_regindices[136] = {
    (u8)1u,
    (u8)2u,
    (u8)3u,
    (u8)4u,
    (u8)5u,
    (u8)6u,
    (u8)7u,
    (u8)8u,
    (u8)9u,
    (u8)10u,
    (u8)11u,
    (u8)12u,
    (u8)13u,
    (u8)14u,
    (u8)15u,
    (u8)16u,
    (u8)1u,
    (u8)2u,
    (u8)3u,
    (u8)4u,
    (u8)5u,
    (u8)6u,
    (u8)7u,
    (u8)8u,
    (u8)9u,
    (u8)10u,
    (u8)11u,
    (u8)12u,
    (u8)13u,
    (u8)14u,
    (u8)15u,
    (u8)16u,
    (u8)1u,
    (u8)2u,
    (u8)3u,
    (u8)4u,
    (u8)5u,
    (u8)6u,
    (u8)7u,
    (u8)8u,
    (u8)9u,
    (u8)10u,
    (u8)11u,
    (u8)12u,
    (u8)13u,
    (u8)14u,
    (u8)15u,
    (u8)16u,
    (u8)1u,
    (u8)2u,
    (u8)3u,
    (u8)4u,
    (u8)5u,
    (u8)6u,
    (u8)7u,
    (u8)8u,
    (u8)9u,
    (u8)10u,
    (u8)11u,
    (u8)12u,
    (u8)13u,
    (u8)14u,
    (u8)15u,
    (u8)16u,
    (u8)17u,
    (u8)18u,
    (u8)19u,
    (u8)20u,
    (u8)1u,
    (u8)5u,
    (u8)11u,
    (u8)12u,
    (u8)6u,
    (u8)4u,
    (u8)15u,
    (u8)16u,
    (u8)13u,
    (u8)14u,
    (u8)2u,
    (u8)3u,
    (u8)7u,
    (u8)8u,
    (u8)9u,
    (u8)10u,
    (u8)1u,
    (u8)5u,
    (u8)11u,
    (u8)12u,
    (u8)6u,
    (u8)4u,
    (u8)15u,
    (u8)16u,
    (u8)13u,
    (u8)14u,
    (u8)2u,
    (u8)3u,
    (u8)7u,
    (u8)8u,
    (u8)9u,
    (u8)10u,
    (u8)1u,
    (u8)5u,
    (u8)11u,
    (u8)12u,
    (u8)6u,
    (u8)4u,
    (u8)15u,
    (u8)16u,
    (u8)13u,
    (u8)14u,
    (u8)2u,
    (u8)3u,
    (u8)7u,
    (u8)8u,
    (u8)9u,
    (u8)10u,
    (u8)1u,
    (u8)5u,
    (u8)11u,
    (u8)12u,
    (u8)17u,
    (u8)18u,
    (u8)19u,
    (u8)20u,
    (u8)6u,
    (u8)4u,
    (u8)15u,
    (u8)16u,
    (u8)13u,
    (u8)14u,
    (u8)2u,
    (u8)3u,
    (u8)7u,
    (u8)8u,
    (u8)9u,
    (u8)10u
};
byte *  ax_tables_xregnames[16] = {
    (byte*)"xmm0",
    (byte*)"xmm1",
    (byte*)"xmm2",
    (byte*)"xmm3",
    (byte*)"xmm4",
    (byte*)"xmm5",
    (byte*)"xmm6",
    (byte*)"xmm7",
    (byte*)"xmm8",
    (byte*)"xmm9",
    (byte*)"xmm10",
    (byte*)"xmm11",
    (byte*)"xmm12",
    (byte*)"xmm13",
    (byte*)"xmm14",
    (byte*)"xmm15"
};
byte *  ax_tables_fregnames[8] = {(byte*)"st0",(byte*)"st1",(byte*)"st2",(byte*)"st3",(byte*)"st4",(byte*)"st5",(byte*)"st6",(byte*)"st7"};
byte *  ax_tables_mregnames[8] = {(byte*)"mmx0",(byte*)"mmx1",(byte*)"mmx2",(byte*)"mmx3",(byte*)"mmx4",(byte*)"mmx5",(byte*)"mmx6",(byte*)"mmx7"};
byte *  ax_tables_condnames[16] = {
    (byte*)"o",
    (byte*)"no",
    (byte*)"b",
    (byte*)"ae",
    (byte*)"z",
    (byte*)"nz",
    (byte*)"be",
    (byte*)"a",
    (byte*)"s",
    (byte*)"ns",
    (byte*)"p",
    (byte*)"np",
    (byte*)"l",
    (byte*)"ge",
    (byte*)"le",
    (byte*)"g"
};
byte *  ax_tables_jmpccnames[18] = {
    (byte*)"jo",
    (byte*)"jno",
    (byte*)"jb",
    (byte*)"jae",
    (byte*)"jz",
    (byte*)"jnz",
    (byte*)"jbe",
    (byte*)"ja",
    (byte*)"js",
    (byte*)"jns",
    (byte*)"jp",
    (byte*)"jnp",
    (byte*)"jl",
    (byte*)"jge",
    (byte*)"jle",
    (byte*)"jg",
    (byte*)"jc",
    (byte*)"jnc"
};
byte ax_tables_jmpcccodes[18] = {
    (u8)0u,
    (u8)1u,
    (u8)2u,
    (u8)3u,
    (u8)4u,
    (u8)5u,
    (u8)6u,
    (u8)7u,
    (u8)8u,
    (u8)9u,
    (u8)10u,
    (u8)11u,
    (u8)12u,
    (u8)13u,
    (u8)14u,
    (u8)15u,
    (u8)2u,
    (u8)3u
};
byte *  ax_tables_setccnames[18] = {
    (byte*)"seto",
    (byte*)"setno",
    (byte*)"setb",
    (byte*)"setae",
    (byte*)"setz",
    (byte*)"setnz",
    (byte*)"setbe",
    (byte*)"seta",
    (byte*)"sets",
    (byte*)"setns",
    (byte*)"setp",
    (byte*)"setnp",
    (byte*)"setl",
    (byte*)"setge",
    (byte*)"setle",
    (byte*)"setg",
    (byte*)"setc",
    (byte*)"setnc"
};
byte ax_tables_setcccodes[18] = {
    (u8)0u,
    (u8)1u,
    (u8)2u,
    (u8)3u,
    (u8)4u,
    (u8)5u,
    (u8)6u,
    (u8)7u,
    (u8)8u,
    (u8)9u,
    (u8)10u,
    (u8)11u,
    (u8)12u,
    (u8)13u,
    (u8)14u,
    (u8)15u,
    (u8)2u,
    (u8)3u
};
byte *  ax_tables_cmovccnames[18] = {
    (byte*)"cmovo",
    (byte*)"cmovno",
    (byte*)"cmovb",
    (byte*)"cmovae",
    (byte*)"cmovz",
    (byte*)"cmovnz",
    (byte*)"cmovbe",
    (byte*)"cmova",
    (byte*)"cmovs",
    (byte*)"cmovns",
    (byte*)"cmovp",
    (byte*)"cmovnp",
    (byte*)"cmovl",
    (byte*)"cmovge",
    (byte*)"cmovle",
    (byte*)"cmovg",
    (byte*)"cmovc",
    (byte*)"cmovnc"
};
byte ax_tables_cmovcccodes[18] = {
    (u8)0u,
    (u8)1u,
    (u8)2u,
    (u8)3u,
    (u8)4u,
    (u8)5u,
    (u8)6u,
    (u8)7u,
    (u8)8u,
    (u8)9u,
    (u8)10u,
    (u8)11u,
    (u8)12u,
    (u8)13u,
    (u8)14u,
    (u8)15u,
    (u8)2u,
    (u8)3u
};
byte *  ax_tables_prefixnames[8] = {(byte*)"byte",(byte*)"word",(byte*)"word16",(byte*)"word32",(byte*)"dword",(byte*)"word64",(byte*)"qword",(byte*)"word128"};
byte ax_tables_prefixsizes[8] = {(u8)1u,(u8)2u,(u8)2u,(u8)4u,(u8)4u,(u8)8u,(u8)8u,(u8)16u};
byte *  ax_tables_reftypenames[3] = {(byte*)"extern_ref",(byte*)"fwd_ref",(byte*)"back_ref"};
byte *  ax_tables_segmentnames[5] = {(byte*)"code_seg",(byte*)"idata_seg",(byte*)"zdata_seg",(byte*)"rodata_seg",(byte*)"impdata_seg"};
i64 ax_decls_lxfileno = (i64)0;
i64 ax_decls_lxlineno = (i64)0;
i64 ax_decls_nsourcefiles = (i64)0;
struct ax_decls_modulerec ax_decls_moduletable[200];
byte *  ax_decls_searchlibs[30];
i64 ax_decls_nmodules;
i64 ax_decls_nsearchlibs;
struct ax_decls_strec *  ax_decls_lexhashtable[8388608];
struct ax_decls_strec *  ax_decls_dupltable[8388608];
void *  ax_decls_logdev;
i64 ax_decls_fverbose = (i64)0;
i64 ax_decls_fquiet = (i64)0;
i64 ax_decls_linecount = (i64)0;
i64 ax_decls_nundefined = (i64)0;
i64 ax_decls_alineno = (i64)0;
i64 ax_decls_ss_zdatalen;
struct ax_decls_dbuffer *  ax_decls_ss_zdata;
struct ax_decls_dbuffer *  ax_decls_ss_idata;
struct ax_decls_dbuffer *  ax_decls_ss_code;
struct ax_decls_relocrec *  ax_decls_ss_idatarelocs;
struct ax_decls_relocrec *  ax_decls_ss_coderelocs;
i64 ax_decls_ss_nidatarelocs;
i64 ax_decls_ss_ncoderelocs;
struct ax_decls_strec * (*ax_decls_ss_symboltable)[];
i64 ax_decls_ss_nsymbols;
i64 ax_decls_ss_symboltablesize;
struct ax_decls_stlistrec *  ax_decls_globalimportlist;
struct ax_decls_strec *  ax_decls_modulenamelist;
i64 ax_decls_currmoduleno;
i64 ax_decls_nmclasm;
i64 ax_decls_nmclopndsasm;
i64 ax_lex_lxsymbol;
i64 ax_lex_lxsubcode;
i64 ax_lex_lxvalue;
double ax_lex_lxxvalue;
byte *  ax_lex_lxsvalue;
i64 ax_lex_lxlength;
static i64 ax_lex_lxhashvalue;
byte *  ax_lex_lxsptr;
static byte *  ax_lex_lxstart;
struct ax_decls_strec *  ax_lex_lxsymptr;
static byte ax_lex_alphamap[256];
static byte ax_lex_digitmap[256];
static byte ax_lex_commentmap[256];
static struct ax_decls_strec *  ax_parse_exprlabeldef;
static i64 ax_parse_exprvalue;
static i64 ax_parse_exprtype;
static struct ax_decls_fwdrec ax_lib_dummy1;
byte *  ax_lib_opndnames[7] = {(byte*)"a_none",(byte*)"a_reg",(byte*)"a_imm",(byte*)"a_mem",(byte*)"a_cond",(byte*)"a_xreg",(byte*)"a_string"};
i64 ax_lib_currsegment = (i64)0;
struct ax_decls_opndrec ax_lib_dstackopnd;
struct ax_decls_opndrec ax_lib_dframeopnd;
i64 ax_lib_labelno = (i64)0;
struct ax_decls_opndrec *  ax_lib_zero_opnd = 0;
struct ax_lib_mclrec *  ax_lib_mccode;
struct ax_lib_mclrec *  ax_lib_mccodex;
static struct mlib_strbuffer ax_lib_destv;
struct mlib_strbuffer *  ax_lib_dest = &ax_lib_destv;
struct ax_decls_opndrec *  ax_lib_regtable[20][8];
static i64 ax_genss_rex;
static i64 ax_genss_sizeoverride;
static i64 ax_genss_addroverride;
static i64 ax_genss_f2override;
static i64 ax_genss_f3override;
static struct ax_decls_opndrec *  ax_genss_extraparam;
static i64 ax_genss_currseg = (i64)0;
static struct ax_decls_dbuffer *  ax_genss_currdata;
static struct ax_decls_relocrec *  ax_genss_currrelocs;
static i64 ax_genss_nrelocs;
static struct ax_lib_mclrec *  ax_genss_currmcl;
byte *  ax_objdecls_relocnames[7] = {(byte*)"abs_rel",(byte*)"addr64_rel",(byte*)"addr32_rel",(byte*)"addr32nb_rel",(byte*)"rel32_rel",(byte*)"rel321_rel",(byte*)"rel8_rel"};
byte *  ax_objdecls_coffscopenames[3] = {(byte*)"cofflocal_scope",(byte*)"export_scope",(byte*)"import_scope"};
static i64 ax_writeexe_libinsttable[30];
static byte *  ax_writeexe_libinstnames[30];
static i64 ax_writeexe_libnotable[30];
static struct ax_writeexe_basereloc *  ax_writeexe_basereloclist;
static i64 ax_writeexe_nbaserelocs;
static i64 ax_writeexe_maxrelocaddr;
static i64 ax_writeexe_blockbases[500];
static i32 ax_writeexe_blockcounts[500];
static i32 ax_writeexe_blockbytes[500];
static byte ax_writeexe_blockpadding[500];
static i64 ax_writeexe_nbaseblocks;
static i64 ax_writeexe_basetablesize;
u64 ax_writeexe_imagebase;
static i64 ax_writeexe_imagesize;
static i64 ax_writeexe_filesize;
static i64 (*ax_writeexe_thunktable)[];
static i64 ax_writeexe_fileiatoffset;
static i64 ax_writeexe_fileiatsize;
static struct ax_decls_strec *  ax_writeexe_stentrypoint;
static struct ax_decls_strec *  ax_writeexe_stentrypoint2;
static struct ax_decls_strec *  ax_writeexe_stentrypoint3;
struct ax_objdecls_sectionrec ax_writeexe_sectiontable[10];
i64 ax_writeexe_nsections;
static byte *  ax_writeexe_importdir;
struct ax_objdecls_importrec ax_writeexe_importtable[3000];
i64 ax_writeexe_nimports;
struct ax_objdecls_exportrec ax_writeexe_exporttable[3000];
i64 ax_writeexe_nexports;
static byte *  ax_writeexe_dllfilename;
static i64 ax_writeexe_isdll;
struct ax_objdecls_dllrec ax_writeexe_dlltable[50];
i64 ax_writeexe_ndlls;
byte *  ax_writeexe_datastart;
byte *  ax_writeexe_dataptr;
byte *  ax_writeexe_userentrypoint;
static i64 ax_writeexe_exportdirvirtaddr;
static i64 ax_writeexe_exportdirvirtsize;
static i64 ax_writeexe_exportdiroffset;
static i64 ax_writeexe_blockdirvirtaddr;
static i64 ax_writeexe_blockdirvirtsize;
static i64 ax_writeexe_blockdiroffset;
static i64 ax_disasm_nmodules;
static i64 ax_disasm_xfchsmask_pd;
static byte *  ax_disasm_opnames[8] = {(byte*)"add",(byte*)"or",(byte*)"adc",(byte*)"sbb",(byte*)"and",(byte*)"sub",(byte*)"xor",(byte*)"cmp"};
static byte *  ax_disasm_condnames[16] = {
    (byte*)"o",
    (byte*)"no",
    (byte*)"b",
    (byte*)"ae",
    (byte*)"z",
    (byte*)"nz",
    (byte*)"be",
    (byte*)"a",
    (byte*)"s",
    (byte*)"ns",
    (byte*)"p",
    (byte*)"np",
    (byte*)"l",
    (byte*)"ge",
    (byte*)"le",
    (byte*)"g"
};
static byte *  ax_disasm_addrmodenames[3] = {(byte*)"amreg",(byte*)"ammem",(byte*)"amrel"};
static i64 ax_disasm_rex;
static i64 ax_disasm_addrmode;
static i64 ax_disasm_rmreg;
static i64 ax_disasm_rmopc;
static i64 ax_disasm_basereg;
static i64 ax_disasm_indexreg;
static i64 ax_disasm_scale;
static i64 ax_disasm_opsize;
static i64 ax_disasm_offset;
static i64 ax_disasm_offsetsize;
static i64 ax_disasm_sizeoverride;
static i64 ax_disasm_addroverride;
static i64 ax_disasm_f2override;
static i64 ax_disasm_f3override;
static byte ax_disasm_deststr[256];
static byte *  ax_disasm_destptr;
static byte *  ax_disasm_codeptr;
static i64 ax_writeobj_symtaboffset;
static byte *  ax_writeobj_datastart;
static byte *  ax_writeobj_dataptr;
static struct ax_objdecls_imagesymbol ax_writeobj_symboltable[10001];
static i64 ax_writeobj_nsymbols;
static i64 ax_writeobj_stoffset = (i64)0;
static byte *  ax_writeobj_stringtable[5000];
static i64 ax_writeobj_stringlengths[5000];
static i64 ax_writeobj_nextstringoffset = (i64)0;
static i64 ax_writeobj_nstrings = (i64)0;

/* PROCDEFS */
// START
void start(void) {
    i64 pass;
    i64 nextmodule;
    cc_starttiming();
    cc_initdata();
    cc_getinputoptions();
    if (!!((u64)(cc_fdebugcompiler))) {
        cc_debugcompile();
        exit(0);
    };
    if ((cc_cc_mode >= (i64)3)) {
        cc_decls_fastasm = (i64)1;
    };
    cc_initsearchdirs();
    cc_initlogfile();
    nextmodule = (i64)1;
    pass = (i64)1;
    L1 :;
    do {
        cc_compilemodules(nextmodule,cc_decls_ninputfiles,pass++);
        nextmodule = cc_addnewmodules();
L2 :;
    } while (!(nextmodule == (i64)0));L3 :;
    ;
    if ((cc_cc_mode >= (i64)3)) {
        cc_do_genlink();
    };
    if ((cc_cc_mode == (i64)4)) {
        cc_do_runprog();
    };
    if (!!((u64)(cc_fshowtiming))) {
        cc_showtiming();
    };
    if (!!((u64)(cc_fmheaders))) {
        cc_export_writemheader(cc_decls_inputfiles[((i64)1)]);
    };
    if (!!((u64)(cc_fatfile))) {
        cc_writeatfile();
    };
    exit((i64)0);
}

int main(int nargs, char** args) {
int i;
	msysnewc_nsysparams=nargs;
	if (msysnewc_nsysparams>nargs) {puts("Too many params"); exit(1);}
	for (i=1; i<=nargs; ++i) msysnewc_sysparams[i-1]=(byte*)args[i-1];


	start();
	return 0;
}

static void cc_compilemodules(i64 a,i64 b,i64 pass) {
    byte str[256];
    byte *  ext;
    i64 m;
    if ((cc_destfileext == 0)) {
        if ((cc_cc_mode == (i64)1)) {
            ext = (byte*)"i";
        } else if (!(!!(cc_decls_fautomodules))) {
            ext = (byte*)"asm";
            if (((cc_decls_ninputfiles == (i64)1) && (cc_cc_mode >= (i64)3))) {
                ext = cc_linkoption;
            };
        } else {
            ext = (byte*)"asm";
        };
    } else {
        ext = cc_destfileext;
    };
    L4 :;
    for (m=a;m<=b;m+=(i64)1) {
L5 :;
        if (!!(cc_decls_fautomodules)) {
            msysnewc_m_print_startstr(str);
            msysnewc_m_print_setfmt((byte*)"## Compiling # to # (Pass #)");
            msysnewc_m_print_str(((pass == (i64)1)?(byte*)"  ":(byte*)"* "),NULL);
            msysnewc_m_print_i64(m,(byte*)"2");
            msysnewc_m_print_str(cc_decls_inputfiles[(m)],(byte*)"jl12");
            msysnewc_m_print_str(mlib_changeext(cc_decls_inputfiles[(m)],ext),(byte*)"jl16");
            msysnewc_m_print_i64(pass,NULL);
            msysnewc_m_print_end();
            ;
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(str,NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
        } else if (!(!!(cc_decls_fquiet))) {
            if ((cc_cc_mode == (i64)1)) {
                msysnewc_m_print_startcon();
                msysnewc_m_print_str((byte*)"Preprocessing",NULL);
                msysnewc_m_print_str(cc_decls_inputfiles[(m)],NULL);
                msysnewc_m_print_str((byte*)"to",NULL);
                msysnewc_m_print_str(mlib_changeext(cc_decls_inputfiles[(m)],(byte*)"i"),NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
            } else if ((cc_decls_ninputfiles == (i64)1)) {
                msysnewc_m_print_startcon();
                msysnewc_m_print_str((byte*)"Compiling",NULL);
                msysnewc_m_print_str(cc_decls_inputfiles[(m)],NULL);
                msysnewc_m_print_str((byte*)"to",NULL);
                msysnewc_m_print_str(mlib_changeext(cc_destfilename,ext),NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
            } else {
                msysnewc_m_print_startcon();
                msysnewc_m_print_str((byte*)"Compiling",NULL);
                msysnewc_m_print_str(cc_decls_inputfiles[(m)],NULL);
                msysnewc_m_print_str((byte*)"to",NULL);
                msysnewc_m_print_str(mlib_changeext(cc_decls_inputfiles[(m)],(byte*)"asm"),NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
            };
        };
        cc_do_loadmodule(m);
        if ((cc_cc_mode == (i64)1)) {
            cc_do_preprocess(m);
            cc_resetcompiler();
            goto L6 ;
        };
        cc_do_parsemodule(m);
        if (!(!!((u64)(cc_fatfile)))) {
            cc_do_genmcl(m);
            cc_do_genasm(m);
        };
        if (!(!!((u64)(cc_fmheaders)))) {
            cc_resetcompiler();
        };
L6 :;
    }L7 :;
    ;
}

static void cc_debugcompile(void) {
    cc_initsearchdirs();
    cc_decls_logdest = (i64)2;
    cc_initlogfile();
    cc_do_loadmodule((i64)1);
    cc_do_parsemodule((i64)1);
    cc_showast((i64)1);
    cc_do_genmcl((i64)1);
    cc_showmcl((byte*)"MCL",(i64)1);
    cc_do_genasm((i64)1);
    cc_showasm((i64)1);
    cc_showsttree((byte*)"ST",(i64)1);
    cc_showstflat((byte*)"STFLAT");
    cc_lib_printmodelist(cc_decls_logdev);
    cc_closelogfile();
}

static void cc_do_loadmodule(i64 n) {
    if (!!(cc_decls_fverbose)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"Loading:",NULL);
        msysnewc_m_print_str(cc_decls_inputfiles[(n)],NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
    cc_loadmainmodule(cc_decls_inputfiles[(n)]);
}

static void cc_do_preprocess(i64 n) {
    cc_lex_lex_preprocess_only(cc_decls_inputfiles[(n)],(i64)1,n,(i64)(cc_fstdout));
}

static void cc_do_parsemodule(i64 n) {
    if (!!(cc_decls_fverbose)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"Parsing:",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
    cc_parse_parsemodule(n);
}

static void cc_do_genmcl(i64 n) {
    cc_genmcl_codegen_mcl(n);
}

static void cc_do_genasm(i64 n) {
    byte *  outfileasm;
    outfileasm = mlib_pcm_copyheapstring(mlib_changeext(cc_decls_inputfiles[(n)],(byte*)"asm"));
    cc_genasm_codegen_writeasm(n,outfileasm);
}

static void cc_do_runprog(void) {
    byte str[300];
    i64 i;
    strcpy((i8 *)(str),(i8 *)(cc_destfilename));
    L8 :;
    for (i=(i64)1;i<=cc_nextraparams;i+=(i64)1) {
L9 :;
        strcat((i8 *)(str),(i8 *)((byte*)" "));
        strcat((i8 *)(str),(i8 *)(cc_extraparams[(i)-1]));
        if (!!(cc_extravalues[(i)-1])) {
            strcat((i8 *)(str),(i8 *)((byte*)":"));
            strcat((i8 *)(str),(i8 *)(cc_extravalues[(i)-1]));
        };
L10 :;
    }L11 :;
    ;
    osnos_os_execwait(str,(i64)0,(byte *)(0));
}

static i64 cc_loadmainmodule(byte * filespec) {
    byte modulename[100];
    byte path[300];
    i64 i;
    i64 fileno;
    mlib_pcm_clearmem((void *)(&cc_decls_moduletable[((i64)0)]),(i64)240);
    cc_decls_sourcefilenames[((i64)0)] = (byte*)"<dummy file>";
    cc_decls_sourcefilepaths[((i64)0)] = (byte*)"<dummy path>";
    cc_decls_sourcefiletext[((i64)0)] = (byte*)"<sourcefile0>";
    cc_decls_sourcefilesizes[((i64)0)] = (i64)(strlen((i8 *)(cc_decls_sourcefiletext[((i64)0)])));
    cc_decls_moduletable[((i64)0)].name = (byte*)"PROGRAM";
    cc_decls_moduletable[((i64)0)].fileno = (i64)0;
    cc_decls_stprogram = cc_lib_createdupldef((struct cc_decls_strec *)(0),cc_lex_addnamestr((byte*)"$prog"),(i64)2);
    cc_decls_moduletable[((i64)0)].stmodule = cc_decls_stprogram;
    if ((!(!!(mlib_checkfile(filespec))) && !(!!((u64)(cc_fstdin))))) {
        cc_support_loaderror((byte*)"Can't load main module: %s",filespec);
    };
    if (!!((u64)(cc_fstdin))) {
        fileno = cc_support_loadfromstdin(filespec);
    } else {
        fileno = cc_support_loadsourcefile(filespec,filespec);
    };
    strcpy((i8 *)(modulename),(i8 *)(mlib_extractbasefile(filespec)));
    strcpy((i8 *)(path),(i8 *)(mlib_extractpath(filespec)));
    if (!!((u64)(path[((i64)1)-1]))) {
        ++cc_decls_nsearchdirs;
        L12 :;
        for (i=cc_decls_nsearchdirs;i>=(i64)2;i-=(i64)1) {
L13 :;
            cc_decls_searchdirs[(i)-1] = cc_decls_searchdirs[((i - (i64)1))-1];
L14 :;
        }L15 :;
        ;
        cc_decls_searchdirs[((i64)1)-1] = mlib_pcm_copyheapstring(path);
    };
    cc_addmodule(modulename,fileno,(i64)3);
    return (i64)1;
}

static i64 cc_addmodule(byte * modulename,i64 fileno,i64 id) {
    struct cc_decls_modulerec m;
    struct cc_decls_modulerec *  pmodule;
    mlib_pcm_clearmem((void *)(&m),(i64)240);
    m.name = mlib_pcm_copyheapstring(modulename);
    m.fileno = fileno;
    cc_decls_stmodule = cc_lib_createnewmoduledef(cc_decls_stprogram,cc_lex_addnamestr(m.name));
    m.stmodule = cc_decls_stmodule;
    if ((cc_decls_nmodules >= (i64)200)) {
        cc_support_loaderror((byte*)"Too many modules %s",modulename);
    };
    pmodule = &cc_decls_moduletable[(++cc_decls_nmodules)];
    (*pmodule) = m;
    (*m.stmodule).attribs.ax_moduleno = (u64)(cc_decls_nmodules);
    if ((cc_decls_nmodules >= (i64)200)) {
        cc_support_loaderror((byte*)"Too many modules %s",modulename);
    };
    return cc_decls_nmodules;
}

static void cc_initlogfile(void) {
    if ((cc_decls_logdest==(i64)2)) {
        remove((i8 *)((byte*)"bcc.log"));
        cc_decls_logdev = fopen((i8 *)((byte*)"bcc.log"),(i8 *)((byte*)"w"));
    }else if ((cc_decls_logdest==(i64)0) || (cc_decls_logdest==(i64)1)) {
        cc_decls_logdev = osnos_os_getstdout();
    };
}

static void cc_closelogfile(void) {
    byte str[100];
    if ((cc_decls_logdest == (i64)2)) {
        fclose(cc_decls_logdev);
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_str((byte*)"\\m\\med.bat",NULL);
        msysnewc_m_print_str((byte*)"bcc.log",NULL);
        msysnewc_m_print_end();
        ;
        if (!!(mlib_checkfile((byte*)"cc.m"))) {
            osnos_os_execwait(str,(i64)1,(byte *)(0));
        } else {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((byte*)"Diagnostic outputs written to",NULL);
            msysnewc_m_print_str((byte*)"bcc.log",NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
        };
    };
}

static void cc_initdata(void) {
    mlib_pcm_init();
    cc_lex_lexsetup();
    cc_lib_inittypetables();
    cc_lib_initcclib();
    cc_headers_checkbcclib();
}

static void cc_initsearchdirs(void) {
    i64 i;
    cc_decls_searchdirs[(++cc_decls_nsearchdirs)-1] = (byte*)"";
    if ((cc_decls_dointheaders == (i64)0)) {
        cc_decls_searchdirs[(++cc_decls_nsearchdirs)-1] = (byte*)"/cx/headers/";
    };
    L16 :;
    for (i=(i64)1;i<=cc_decls_nincludepaths;i+=(i64)1) {
L17 :;
        if (!!((u64)((*cc_decls_includepaths[(i)-1])))) {
            cc_decls_searchdirs[(++cc_decls_nsearchdirs)-1] = cc_decls_includepaths[(i)-1];
        };
L18 :;
    }L19 :;
    ;
}

static void cc_showsearchdirs(void) {
    i64 i;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"Include search paths:",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    if (!!(cc_decls_dointheaders)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"0: Internal standard headers (disable with -ext)",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
    L20 :;
    for (i=(i64)1;i<=cc_decls_nsearchdirs;i+=(i64)1) {
L21 :;
        if (!!((u64)((*cc_decls_searchdirs[(i)-1])))) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_i64(i,NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_str((byte*)":",NULL);
            msysnewc_m_print_str(cc_decls_searchdirs[(i)-1],NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
        } else {
            msysnewc_m_print_startcon();
            msysnewc_m_print_i64(i,NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_str((byte*)": .",NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
        };
L22 :;
    }L23 :;
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
}

static void cc_showast(i64 n) {
    if (!!(cc_decls_logdest)) {
        if ((cc_decls_logdest == (i64)2)) {
            msysnewc_m_print_startfile(cc_decls_logdev);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
        };
        cc_lib_printcode(cc_decls_logdev,(byte*)"PROC AST",n);
        msysnewc_m_print_startfile(cc_decls_logdev);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
}

static void cc_showstflat(byte * caption) {
    if (!!(cc_decls_logdest)) {
        msysnewc_m_print_startfile(cc_decls_logdev);
        msysnewc_m_print_str((byte*)"PROC",NULL);
        msysnewc_m_print_str(caption,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        cc_lib_printstflat(cc_decls_logdev);
        msysnewc_m_print_startfile(cc_decls_logdev);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
}

static void cc_showsttree(byte * caption,i64 n) {
    if (!!(cc_decls_logdest)) {
        msysnewc_m_print_startfile(cc_decls_logdev);
        msysnewc_m_print_str((byte*)"PROC",NULL);
        msysnewc_m_print_str(caption,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        cc_lib_printst(cc_decls_logdev,cc_decls_moduletable[(n)].stmodule,(i64)0);
        msysnewc_m_print_startfile(cc_decls_logdev);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
}

static void cc_showmcl(byte * caption,i64 n) {
    struct mlib_strbuffer *  mclstr;
    if (!!(cc_decls_logdest)) {
        mclstr = cc_libmcl_writemclcode(caption,n);
        mlib_gs_println(mclstr,cc_decls_logdev);
    };
}

static void cc_showasm(i64 n) {
    byte *  asmstr;
    byte *  caption;
    caption = (byte*)"PROC ASSEMBLY LISTING";
    asmstr = cc_decls_moduletable[(n)].asmstr;
    if ((asmstr == 0)) {
        return;
    };
    if (!!(cc_decls_logdest)) {
        msysnewc_m_print_startfile(cc_decls_logdev);
        msysnewc_m_print_str(caption,NULL);
        msysnewc_m_print_i64(n,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        msysnewc_m_print_startfile(cc_decls_logdev);
        msysnewc_m_print_str(asmstr,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
}

static void cc_showfiles(void) {
    i64 i;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"Sourcefiles:",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    L24 :;
    for (i=(i64)1;i<=cc_decls_nsourcefiles;i+=(i64)1) {
L25 :;
        msysnewc_m_print_startcon();
        msysnewc_m_print_i64(i,NULL);
        msysnewc_m_print_str((byte*)":",NULL);
        msysnewc_m_print_str(cc_decls_sourcefilepaths[(i)],NULL);
        msysnewc_m_print_str(cc_decls_sourcefilenames[(i)],NULL);
        msysnewc_m_print_str((byte*)"Size:",NULL);
        msysnewc_m_print_i64(cc_decls_sourcefilesizes[(i)],NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
L26 :;
    }L27 :;
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
}

static void cc_starttiming(void) {
    cc_progstart = osnos_os_clock();
}

static void cc_showtiming(void) {
}

static void cc_getinputoptions(void) {
    i64 paramno;
    i64 pmtype;
    i64 sw;
    i64 ncolons;
    byte *  name;
    byte *  value;
    byte *  ext;
    i64 av_1;
    paramno = (i64)2;
    ncolons = (i64)0;
    L28 :;
    while (1) {
        pmtype = mlib_nextcmdparam(&paramno,&name,&value,(byte*)".c");
        if ((pmtype==(i64)1)) {
            mlib_convlcstring(name);
            L30 :;
            for (sw=(i64)1;sw<=(i64)32;sw+=(i64)1) {
L31 :;
                if (!!(mlib_eqstring(name,cc_optionnames[(sw)-1]))) {
                    cc_do_option(sw,value);
                    goto L33 ;
                };
L32 :;
            }
            {
                msysnewc_m_print_startcon();
                msysnewc_m_print_str((byte*)"Unknown option:",NULL);
                msysnewc_m_print_str(name,NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
                exit((i64)1);
            }L33 :;
            ;
        }else if ((pmtype==(i64)2)) {
            if ((cc_decls_ninputfiles >= (i64)200)) {
                cc_support_loaderror((byte*)"Too many input files",(byte*)"");
            };
            cc_decls_inputfiles[(++cc_decls_ninputfiles)] = mlib_pcm_copyheapstring(name);
        }else if ((pmtype==(i64)3)) {
            if ((cc_decls_nlibfiles >= (i64)200)) {
                cc_support_loaderror((byte*)"Too many lib files",(byte*)"");
            };
            cc_decls_libfiles[(++cc_decls_nlibfiles)] = mlib_pcm_copyheapstring(name);
        }else if ((pmtype==(i64)4)) {
            if ((++ncolons > (i64)1)) {
                name = (byte*)":";
                value = (byte *)(0);
                goto L34 ;
;
            };
        }else if ((pmtype==(i64)5)) {
            //doextra:
L34 :;
;
            cc_extraparams[(++cc_nextraparams)-1] = mlib_pcm_copyheapstring(name);
            cc_extravalues[(cc_nextraparams)-1] = mlib_pcm_copyheapstring(value);
        }else if ((pmtype==(i64)0)) {
            goto L29 ;
        };
    }L29 :;
    ;
    if ((cc_cc_mode == (i64)0)) {
        cc_cc_mode = (i64)3;
    };
    if ((cc_linkoption == 0)) {
        cc_linkoption = (byte*)"exe";
    };
    if ((((cc_decls_ninputfiles == (i64)0) && !(!!((u64)(cc_fwriteheaders)))) && !(!!((u64)(cc_fgetlib))))) {
        cc_showcaption();
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"Usage:",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"\t",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str(msysnewc_sysparams[((i64)1)-1],NULL);
        msysnewc_m_print_str((byte*)"prog[.c]                 # Compile prog.c to prog.exe",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"\t",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str(msysnewc_sysparams[((i64)1)-1],NULL);
        msysnewc_m_print_str((byte*)"-help                    # Show options",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"\t",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str(msysnewc_sysparams[((i64)1)-1],NULL);
        msysnewc_m_print_str((byte*)"-info                    # Further info",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        exit((i64)22);
    };
    if (!!((u64)(cc_fwriteheaders))) {
        cc_headers_writeheaders();
        exit((i64)20);
    };
    ext = cc_linkoption;
    if ((cc_cc_mode==(i64)1)) {
        ext = (byte*)"i";
    }else if ((cc_cc_mode==(i64)2)) {
        ext = (byte*)"asm";
    } else {
        ext = cc_linkoption;
    };
    if ((cc_destfilename == 0)) {
        cc_destfilename = mlib_pcm_copyheapstring(mlib_changeext(cc_decls_inputfiles[((i64)1)],ext));
    } else if (!!(mlib_eqstring(cc_destfileext,(byte*)""))) {
        cc_destfileext = ext;
    };
    if ((!!((u64)(cc_fmheaders)) && (cc_decls_ninputfiles > (i64)1))) {
        cc_support_loaderror((byte*)"-mheaders works on one file only",(byte*)"");
    };
}

static void cc_do_option(i64 sw,byte * value) {
    byte str[300];
    i64 length;
    if ((sw==(i64)4)) {
        cc_linkoption = (byte*)"obj";
        cc_cc_mode = (i64)3;
    }else if ((sw==(i64)5)) {
        cc_linkoption = (byte*)"exe";
        cc_cc_mode = (i64)3;
    }else if ((sw==(i64)1)) {
        cc_cc_mode = (i64)1;
    }else if ((sw==(i64)2)) {
        cc_linkoption = (byte*)"obj";
        cc_cc_mode = (i64)3;
    }else if ((sw==(i64)3)) {
        cc_cc_mode = (i64)2;
    }else if ((sw==(i64)6)) {
        cc_cc_mode = (i64)4;
    }else if ((sw==(i64)7)) {
        cc_fshowpaths = (u64)((i64)1);
    }else if ((sw==(i64)8)) {
        cc_fshowheaders = (u64)((i64)1);
    }else if ((sw==(i64)11)) {
        if ((cc_decls_nincludepaths > (i64)20)) {
            cc_support_loaderror((byte*)"Too many include paths",(byte*)"");
        };
        length = (i64)(strlen((i8 *)(value)));
        if (((i64)((*((value + length) - (i64)1)))==(i64)92) || ((i64)((*((value + length) - (i64)1)))==(i64)47)) {
        } else {
            strcpy((i8 *)(str),(i8 *)(value));
            strcat((i8 *)(str),(i8 *)((byte*)"/"));
            value = str;
        };
        cc_decls_includepaths[(++cc_decls_nincludepaths)-1] = mlib_pcm_copyheapstring(value);
    }else if ((sw==(i64)14)) {
        cc_decls_fverbose = (i64)1;
    }else if ((sw==(i64)15)) {
        cc_decls_fverbose = (i64)1;
    }else if ((sw==(i64)16)) {
        cc_decls_fquiet = (i64)1;
    }else if ((sw==(i64)17) || (sw==(i64)18)) {
        cc_showhelp();
    }else if ((sw==(i64)19)) {
        cc_showextrainfo();
    }else if ((sw==(i64)20)) {
        cc_decls_dointheaders = (i64)0;
    }else if ((sw==(i64)21)) {
        cc_fwriteheaders = (u64)((i64)1);
    }else if ((sw==(i64)23)) {
        cc_fgetlib = (u64)((i64)1);
    }else if ((sw==(i64)22)) {
        cc_decls_fmodern = (i64)0;
    }else if ((sw==(i64)9)) {
        cc_fstdin = (u64)((i64)1);
    }else if ((sw==(i64)10)) {
        cc_fstdout = (u64)((i64)1);
    }else if ((sw==(i64)12)) {
        cc_decls_fshowincludes = (i64)1;
    }else if ((sw==(i64)24)) {
        cc_fmheaders = (u64)((i64)1);
    }else if ((sw==(i64)25)) {
        cc_decls_fautomodules = (i64)1;
    }else if ((sw==(i64)26)) {
        cc_destfilename = mlib_pcm_copyheapstring(value);
        cc_destfileext = mlib_pcm_copyheapstring(mlib_extractext(value,(i64)0));
    }else if ((sw==(i64)27)) {
        cc_fatfile = (u64)((i64)1);
    }else if ((sw==(i64)13)) {
        cc_fshowtiming = (u64)((i64)1);
    }else if ((sw==(i64)28)) {
        cc_fdebugcompiler = (u64)((i64)1);
    }else if ((sw==(i64)29)) {
        cc_fbcclib = (u64)((i64)1);
    }else if ((sw==(i64)30)) {
        cc_decls_fcallback = (i64)1;
    }else if ((sw==(i64)31)) {
        cc_entrypointname = mlib_pcm_copyheapstring(value);
    }else if ((sw==(i64)32)) {
        cc_decls_flinesplicing = (i64)1;
    };
}

static void cc_showincludepaths(void) {
    i64 i;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"Include paths",NULL);
    msysnewc_m_print_i64(cc_decls_nincludepaths,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    L35 :;
    for (i=(i64)1;i<=cc_decls_nincludepaths;i+=(i64)1) {
L36 :;
        msysnewc_m_print_startcon();
        msysnewc_m_print_i64(i,NULL);
        msysnewc_m_print_str(cc_decls_includepaths[(i)-1],NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
L37 :;
    }L38 :;
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
}

static void cc_showhelp(void) {
    cc_showcaption();
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"C Subset Compiler for 64-bit Windows\r\n\r\nNormal use:\r\n\r\n    bcc prog            Compile file prog.c to prog.exe\r\n    bcc prog.c          Same (extension is optional)\r\n    bcc a b c d.dll     Compile a.c, b.c, c.c and link with d.dll to a.exe\r\n\r\nOptions:\r\n\r\n    -e              Write preprocessed output to prog.i\r\n    -s              Compile only, to .asm\r\n    -c              Same as -obj\r\n    -exe            (DEFAULT) compile and link to .exe file\r\n\r\n    -i:path         Add include path\r\n    -ext            Don't use internal standard headers\r\n    -old            Allow features such as () parameter lists, for old programs\r\n    -out:file       Name exe file\r\n\r\n    -obj            Link to single .obj file rather .exe\r\n    -run            Link to .exe then run that program\r\n    -auto           Locate .c files matched to headers and add to modules\r\n    @file           Read further files and options from a file\r\n\r\nOther Options:\r\n\r\n    -info           Show further information\r\n    -time           Show compiler timing stats\r\n    -writeheaders   Write out internal headers as .hdr (not .h) files\r\n    -at             Create an @ file of filenames suitable for most compilers\r\n    -stdin          Read C file from console\r\n    -stdout         Write preprocessor output to console, rather than .i file\r\n",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    exit((i64)23);
}

static void cc_showextrainfo(void) {
    static byte *  infotext = \
(byte*)"    The 'BCC' C Compiler. Included in the one executable file:\r\n\r\n       * A compiler that produces .asm (external or internal)\r\n       * A minimal set of standard headers\r\n       * A very minimal windows.h\r\n       * An assembler/linker generating one .exe or .obj file\r\n       * The bcclib.asm file (written out as needed)\r\n\r\n    BCC only targets x64 with Win64 call convention. It will compile\r\n    single or multiple .c files to one .asm, .exe or .obj file:\r\n\r\n      -e    Preprocess each module to .i file\r\n      -s    Compile all modules to one .asm file (NOT multiple)\r\n      -exe  (DEFAULT) Compile all modules to one .exe file\r\n      -obj  Compile all modules to one .obj file (NOT multiple)\r\n      -c    Same as -obj\r\n      -run  Compile to .exe then run the new program. Provide\r\n            params after \" : \" (spaces needed)\r\n\r\n    When there is one output file, it will be named based on the first\r\n    input file. Otherwise use -out option (see bcc -help).\r\n\r\n    .obj files can be linked using gcc on Windows. This option is\r\n    needed to be able to generate .dll files.\r\n\r\n    Libraries msvcrt.dll, gdi32.dll, user32.dll and kernel32.dll are\r\n    automatically included as search libraries for imported functions.\r\n\r\n    For other libraries, add .dll files to bcc command line or @ list.\r\n    (Note that when any .dll is specified, the default set of DLLs\r\n    is no longer included. You may need to explicitly specify msvcrt.dll etc.)\r\n    Other kinds of binary libraries (.a, .lib etc) are not supported.\r\n\r\n    (Programs using setjmp and certain internal ops will need bcclib.asm.\r\n    This file is automatically written by bcc if not present, and\r\n    automatically linked.)\r\n\r\n    Omissions, Restrictsions and Bugs (highlights only as there are dozens):\r\n\r\n       * No VLAs, compound literals, designated initialisers\r\n       * Restrictions on complexity of data initialisers\r\n       * Callback functions are buggy if called from external code (not\r\n         compiled with bcc). Fix by adding $callback attribute to such\r\n         functions, or the portable #pragma $callback just before.\r\n         Typically, functions passed to qsort().\r\n";
    msysnewc_m_print_startcon();
    msysnewc_m_print_str(infotext,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    exit((i64)24);
}

static void cc_showcaption(void) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"BCC 'C' Compiler",NULL);
    msysnewc_m_print_str((byte*)"9-Feb-2021",NULL);
    msysnewc_m_print_str((byte*)"00:45:34",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
}

static void cc_do_genlink(void) {
    byte *  asmfiles[200];
    byte *  dllfiles[200];
    byte *  assemsources[200];
    byte *  exefile;
    byte *  ext;
    i64 nfiles;
    i64 i;
    nfiles = cc_decls_ninputfiles;
    L39 :;
    for (i=(i64)1;i<=cc_decls_ninputfiles;i+=(i64)1) {
L40 :;
        asmfiles[(i)-1] = mlib_pcm_copyheapstring(mlib_changeext(cc_decls_inputfiles[(i)],(byte*)"asm"));
        if (!!(cc_decls_fastasm)) {
            assemsources[(i)-1] = cc_decls_moduletable[(i)].asmstr;
        };
L41 :;
    }L42 :;
    ;
    if ((!(!!(mlib_eqstring(cc_linkoption,(byte*)"obj"))) || !!((u64)(cc_fbcclib)))) {
        ++nfiles;
        asmfiles[(nfiles)-1] = (byte*)"bcclib.asm";
        if (!!(cc_decls_fastasm)) {
            assemsources[(nfiles)-1] = cc_headers_getbcclib();
        };
    };
    L43 :;
    for (i=(i64)1;i<=cc_decls_nlibfiles;i+=(i64)1) {
L44 :;
        dllfiles[(i)-1] = mlib_pcm_copyheapstring(cc_decls_libfiles[(i)]);
L45 :;
    }L46 :;
    ;
    if ((cc_destfileext == 0)) {
        ext = cc_linkoption;
    } else {
        ext = cc_destfileext;
    };
    exefile = mlib_pcm_copyheapstring(mlib_changeext(cc_destfilename,ext));
    if (!(!!(cc_assembler_assembler(exefile,&asmfiles,&dllfiles,nfiles,cc_decls_nlibfiles,mlib_eqstring(cc_linkoption,(byte*)"obj"),(!!(cc_decls_fautomodules) || (cc_decls_ninputfiles > (i64)1)),(!!(cc_decls_fastasm)?&assemsources:(byte * (*)[])(0)),cc_entrypointname)))) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"Couldn't assemble or link",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        exit((i64)1);
    };
}

static void cc_resetcompiler(void) {
    i64 i;
    cc_lex_freehashtable();
    cc_decls_ntypes = cc_decls_ntypesreset;
    cc_genasm_nstrings = (cc_genasm_nreals = (cc_genasm_ndints = (i64)0));
    cc_decls_stprogram = (cc_decls_stmodule = (struct cc_decls_strec *)(0));
    cc_decls_currblockno = (cc_decls_nextblockno = (cc_decls_blocklevel = (i64)0));
    cc_lib_autotypeno = (i64)0;
    cc_lib_nextafindex = (i64)0;
    cc_decls_labelno = (i64)0;
    L47 :;
    for (i=(i64)1;i<=cc_decls_nsourcefiles;i+=(i64)1) {
L48 :;
        if (((i64)(cc_decls_sourcefilesizes[(i)]) > (i64)2048)) {
            free((void *)(cc_decls_sourcefiletext[(i)]));
        };
L49 :;
    }L50 :;
    ;
    cc_decls_nsourcefiles = (i64)0;
    mlib_pcm_clearmem((void *)(&cc_decls_ttnamedef),(i64)160000);
    mlib_pcm_clearmem((void *)(&cc_decls_ttbasetype),(i64)160000);
    mlib_pcm_clearmem((void *)(&cc_decls_ttlength),(i64)160000);
    mlib_pcm_clearmem((void *)(&cc_decls_ttconst),(i64)20000);
    mlib_pcm_clearmem((void *)(&cc_decls_ttrestrict),(i64)20000);
    mlib_pcm_clearmem((void *)(&cc_decls_ttvolatile),(i64)20000);
    mlib_pcm_clearmem((void *)(&cc_decls_ttusertype),(i64)160000);
    mlib_pcm_clearmem((void *)(&cc_decls_tttarget),(i64)160000);
    mlib_pcm_clearmem((void *)(&cc_decls_ttreftype),(i64)160000);
    mlib_pcm_clearmem((void *)(&cc_decls_ttconsttype),(i64)160000);
    mlib_pcm_clearmem((void *)(&cc_decls_ttsize),(i64)160000);
    mlib_pcm_clearmem((void *)(&cc_decls_ttbitwidth),(i64)160000);
    mlib_pcm_clearmem((void *)(&cc_decls_ttisref),(i64)20000);
    mlib_pcm_clearmem((void *)(&cc_decls_ttparams),(i64)160000);
    mlib_pcm_clearmem((void *)(&cc_decls_tttypedef),(i64)160000);
    cc_lib_inittypetables();
}

static i64 cc_addnewmodules(void) {
    i64 nextinputfile;
    i64 n;
    i64 newfile;
    i64 i;
    i64 j;
    nextinputfile = (cc_decls_ninputfiles + (i64)1);
    n = (i64)0;
    L51 :;
    for (i=(i64)1;i<=cc_decls_nautomodules;i+=(i64)1) {
L52 :;
        newfile = (i64)1;
        L55 :;
        for (j=(i64)1;j<=cc_decls_ninputfiles;j+=(i64)1) {
L56 :;
            if (!!(mlib_eqstring(cc_decls_inputfiles[(j)],cc_decls_automodulenames[(i)]))) {
                newfile = (i64)0;
                goto L58 ;
            };
L57 :;
        }L58 :;
        ;
        if (!!(newfile)) {
            cc_decls_inputfiles[(++cc_decls_ninputfiles)] = cc_decls_automodulenames[(i)];
            ++n;
        };
L53 :;
    }L54 :;
    ;
    cc_decls_nautomodules = (i64)0;
    if ((n == (i64)0)) {
        return (i64)0;
    };
    return nextinputfile;
}

static void cc_writeatfile(void) {
    void *  f;
    byte *  file;
    i64 i;
    f = fopen((i8 *)((file = mlib_changeext(cc_destfilename,(byte*)""))),(i8 *)((byte*)"w"));
    if (!(!!(f))) {
        return;
    };
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"Writing @ file",NULL);
    msysnewc_m_print_str(file,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    L59 :;
    for (i=(i64)1;i<=cc_decls_ninputfiles;i+=(i64)1) {
L60 :;
        msysnewc_m_print_startfile(f);
        msysnewc_m_print_str((byte*)"\t",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str(cc_decls_inputfiles[(i)],NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
L61 :;
    }L62 :;
    ;
    L63 :;
    for (i=(i64)1;i<=cc_decls_nlibfiles;i+=(i64)1) {
L64 :;
        msysnewc_m_print_startfile(f);
        msysnewc_m_print_str((byte*)"\t",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str(cc_decls_libfiles[(i)],NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
L65 :;
    }L66 :;
    ;
    fclose(f);
}

i64 msysnewc_m_getdotindex(u64 a,i64 i) {
    return (((i64)(a) & ((i64)1 << i)) >> i);
}

void msysnewc_m_setdotindex(u64 * a,i64 i,i64 x) {
    u32 *  a32;
    if ((i >= (i64)32)) {
        (*a) = (u64)((((i64)((*a)) & ~(((i64)1 << i))) | (i64)(((u64)(x) << i))));
    } else {
        a32 = (u32 *)(a);
        (*a32) = (u64)((((i64)((u64)((*a32))) & ~(((i64)1 << i))) | (i64)(((u64)(x) << i))));
    };
}

i64 msysnewc_m_getdotslice(u64 a,i64 i,i64 j) {
    if ((i >= j)) {
        return (i64)(((a >> j) & ~(((u64)18446744073709551615u << ((i - j) + (i64)1)))));
    } else {
        return (i64)(((a >> i) & ~(((u64)18446744073709551615u << ((j - i) + (i64)1)))));
    };
}

void msysnewc_m_setdotslice(u64 * a,i64 i,i64 j,u64 x) {
    u64 mask64;
    u64 mask;
    u32 *  a32;
    if ((i > j)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"SETDOTSLICE?",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        exit((i64)52);
    };
    if ((j >= (i64)32)) {
        mask64 = (~(((u64)18446744073709551615u << ((j - i) + (i64)1))) << i);
        (*a) = (((*a) & ~(mask64)) | (x << i));
    } else {
        a32 = (u32 *)(a);
        mask = (~(((u64)18446744073709551615u << ((j - i) + (i64)1))) << i);
        (*a32) = (((u64)((*a32)) & ~(mask)) | (x << i));
    };
}

i64 msysnewc_m_get_nprocs(void) {
    return msysnewc__fnnprocs;
}

i64 msysnewc_m_get_nexports(void) {
    return msysnewc__fnnexports;
}

void * msysnewc_m_get_procname(i64 n) {
    return (void *)(msysnewc__fnnames[(n)-1]);
}

byte * msysnewc_m_get_procaddr(i64 n) {
    return (byte *)(msysnewc__fnaddresses[(n)-1]);
}

void * msysnewc_m_get_procexport(i64 n) {
    return (void *)(&msysnewc__fnexports[(n)-1]);
}

static void msysnewc_pushio(void) {
    if ((msysnewc_niostack >= (i64)10)) {
        printf((i8 *)((byte*)"Too many io levels\n"));
        exit((i64)53);
    };
    ++msysnewc_niostack;
    msysnewc_outchan_stack[(msysnewc_niostack)-1] = msysnewc_outchan;
    msysnewc_outdev_stack[(msysnewc_niostack)-1] = msysnewc_outdev;
    msysnewc_fmtstr_stack[(msysnewc_niostack)-1] = msysnewc_fmtstr;
    msysnewc_needgap_stack[(msysnewc_niostack)-1] = (u64)(msysnewc_needgap);
    msysnewc_needgap = (i64)0;
    msysnewc_fmtstr = (byte *)(0);
    msysnewc_outchan = 0;
}

void msysnewc_m_print_startfile(void * dev) {
    msysnewc_pushio();
    msysnewc_outchan = dev;
    if (!!(dev)) {
        msysnewc_outdev = (i64)2;
    } else {
        msysnewc_outdev = (i64)1;
    };
}

void msysnewc_m_print_startstr(byte * s) {
    byte * *  p;
    msysnewc_pushio();
    msysnewc_ptr_stack[(msysnewc_niostack)-1] = s;
    p = &msysnewc_ptr_stack[(msysnewc_niostack)-1];
    msysnewc_outchan = (void *)(p);
    msysnewc_outdev = (i64)3;
}

void msysnewc_m_print_startptr(byte * * p) {
    msysnewc_pushio();
    msysnewc_outchan = (void *)(p);
    msysnewc_outdev = (i64)3;
}

void msysnewc_m_print_startcon(void) {
    msysnewc_pushio();
    msysnewc_outdev = (i64)1;
}

void msysnewc_m_print_setfmt(byte * format) {
    msysnewc_fmtstr = format;
}

void msysnewc_m_print_end(void) {
    msysnewc_needgap = (i64)0;
    msysnewc_nextfmtchars((i64)1);
    if ((msysnewc_niostack == (i64)0)) {
        return;
    };
    msysnewc_outchan = msysnewc_outchan_stack[(msysnewc_niostack)-1];
    msysnewc_outdev = msysnewc_outdev_stack[(msysnewc_niostack)-1];
    msysnewc_fmtstr = msysnewc_fmtstr_stack[(msysnewc_niostack)-1];
    msysnewc_needgap = (i64)(msysnewc_needgap_stack[(msysnewc_niostack)-1]);
    --msysnewc_niostack;
}

void msysnewc_m_print_ptr(void * a,byte * fmtstyle) {
    msysnewc_nextfmtchars((i64)0);
    msysnewc_printstr(msysnewc_strword((u64)(a),(byte*)"z8h"));
    msysnewc_needgap = (i64)1;
}

void msysnewc_m_print_i64(i64 a,byte * fmtstyle) {
    byte s[40];
    struct msysnewc_fmtrec fmt;
    i64 n;
    msysnewc_nextfmtchars((i64)0);
    if ((fmtstyle == 0)) {
        if ((a >= (i64)0)) {
            n = msysnewc_u64tostr((u64)(a),s,(u64)((i64)10),(i64)0);
        } else {
            s[((i64)1)-1] = '-';
            n = (msysnewc_u64tostr((u64)(-(a)),&s[((i64)2)-1],(u64)((i64)10),(i64)0) + (i64)1);
        };
        msysnewc_printstr_n(s,n);
    } else {
        msysnewc_strtofmt(fmtstyle,(i64)-1,&fmt);
        if (((u64)(fmt.param) == 'V')) {
            msysnewc_fmtparam = a;
            msysnewc_needgap = (i64)0;
        } else {
            msysnewc_tostr_i64(a,&fmt);
        };
    };
    msysnewc_needgap = (i64)1;
}

void msysnewc_m_print_u64(u64 a,byte * fmtstyle) {
    struct msysnewc_fmtrec fmt;
    msysnewc_nextfmtchars((i64)0);
    if ((fmtstyle == 0)) {
        msysnewc_printstr(msysnewc_strword(a,(byte *)(0)));
    } else {
        msysnewc_strtofmt(fmtstyle,(i64)-1,&fmt);
        msysnewc_tostr_u64(a,&fmt);
    };
    msysnewc_needgap = (i64)1;
}

void msysnewc_m_print_r64(double x,byte * fmtstyle) {
    byte s[360];
    struct msysnewc_fmtrec fmt;
    msysnewc_nextfmtchars((i64)0);
    if ((fmtstyle == 0)) {
        sprintf((i8 *)(s),(i8 *)((byte*)"%f"),x);
        msysnewc_printstr(s);
    } else {
        msysnewc_strtofmt(fmtstyle,(i64)-1,&fmt);
        msysnewc_tostr_r64(x,&fmt);
    };
    msysnewc_needgap = (i64)1;
}

void msysnewc_m_print_r32(float x,byte * fmtstyle) {
    msysnewc_m_print_r64((double)(x),fmtstyle);
}

void msysnewc_m_print_c8(i64 a,byte * fmtstyle) {
    byte s[40];
    msysnewc_nextfmtchars((i64)0);
    s[((i64)1)-1] = (u64)(a);
    s[((i64)2)-1] = (u64)0u;
    msysnewc_printstr(s);
    msysnewc_needgap = (i64)1;
}

void msysnewc_m_print_str(byte * s,byte * fmtstyle) {
    struct msysnewc_fmtrec fmt;
    msysnewc_nextfmtchars((i64)0);
    if ((fmtstyle == 0)) {
        msysnewc_printstr(s);
    } else {
        msysnewc_strtofmt(fmtstyle,(i64)-1,&fmt);
        msysnewc_tostr_str(s,&fmt);
    };
    msysnewc_needgap = (i64)1;
}

void msysnewc_m_print_newline(void) {
    msysnewc_needgap = (i64)0;
    msysnewc_nextfmtchars((i64)1);
    msysnewc_printstr((byte*)"\r\n");
}

void msysnewc_m_print_nogap(void) {
    msysnewc_needgap = (i64)0;
}

void msysnewc_printstr(byte * s) {
    byte * *  p;
    if ((msysnewc_outdev==(i64)1)) {
        printf((i8 *)((byte*)"%s"),s);
    }else if ((msysnewc_outdev==(i64)2)) {
        fprintf(msysnewc_outchan,(i8 *)((byte*)"%s"),s);
    }else if ((msysnewc_outdev==(i64)3)) {
        p = (byte * *)(msysnewc_outchan);
        strcpy((i8 *)((*p)),(i8 *)(s));
        (*p) += (i64)(strlen((i8 *)(s)));
    };
}

void msysnewc_printstr_n(byte * s,i64 n) {
    byte str[256];
    byte * *  p;
    if ((n==(i64)-1)) {
        n = (i64)(strlen((i8 *)(s)));
    }else if ((n==(i64)0)) {
        return;
    };
    if ((msysnewc_outdev==(i64)3)) {
        p = (byte * *)(msysnewc_outchan);
        memcpy((void *)((*p)),(void *)(s),(u64)(n));
        (*p) += n;
        (*(*p)) = (u64)0u;
    }else if ((msysnewc_outdev==(i64)2)) {
        s = msysnewc_makezstring(s,n,str);
        fprintf(msysnewc_outchan,(i8 *)((byte*)"%s"),s);
        msysnewc_freezstring(s,n);
    }else if ((msysnewc_outdev==(i64)1)) {
        s = msysnewc_makezstring(s,n,str);
        printf((i8 *)((byte*)"%s"),s);
        msysnewc_freezstring(s,n);
    };
}

void msysnewc_printstrn_app(byte * s,i64 length,void * f) {
    if (!!(length)) {
        if ((f == 0)) {
            printf("%.*s",(i32)length,s);;
        } else {
            fprintf(f,"%.*s",(i32)length,s);;
        };
    };
}

static byte * msysnewc_makezstring(byte * s,i64 n,byte * local) {
    byte *  t;
    if ((n < (i64)256)) {
        memcpy((void *)(local),(void *)(s),(u64)(n));
        (*(local + n)) = (u64)0u;
        return local;
    } else {
        t = (byte *)(mlib_pcm_alloc((n + (i64)1)));
        memcpy((void *)(t),(void *)(s),(u64)(n));
        (*(t + n)) = (u64)0u;
        return t;
    };
}

static void msysnewc_freezstring(byte * t,i64 n) {
    if ((n >= (i64)256)) {
        mlib_pcm_free((void *)(t),(n + (i64)1));
    };
}

static void msysnewc_printchar(i64 ch) {
    byte * *  p;
    if ((msysnewc_outdev==(i64)1)) {
        printf("%c",(int)ch);
    }else if ((msysnewc_outdev==(i64)2)) {
        fprintf(msysnewc_outchan,"%c",(int)ch);
    }else if ((msysnewc_outdev==(i64)3)) {
        p = (byte * *)(msysnewc_outchan);
        (*(*p)) = (u64)(ch);
        (*p) += (i64)1;
        (*(*p)) = (u64)0u;
    };
}

void msysnewc_nextfmtchars(i64 lastx) {
    byte c;
    byte *  pstart;
    i64 n;
    if (!(!!(msysnewc_fmtstr))) {
        if (!!(msysnewc_needgap)) {
            msysnewc_printchar((i64)32);
        };
        msysnewc_needgap = (i64)0;
        return;
    };
    pstart = msysnewc_fmtstr;
    n = (i64)0;
    L67 :;
    while (!!((i64)1)) {
        c = (u64)((*msysnewc_fmtstr));
        switch ((i64)(c)) {
        case 35:;
        {
            if (!!(lastx)) {
                goto L70 ;
;
            };
            ++msysnewc_fmtstr;
            if (!!(n)) {
                msysnewc_printstr_n(pstart,n);
            };
            return;
        }break;
        case 0:;
        {
            if (!!(n)) {
                msysnewc_printstr_n(pstart,n);
            } else if (!(!!(lastx))) {
                msysnewc_printstr_n((byte*)"|",(i64)1);
            };
            return;
        }break;
        case 126:;
        {
            if (!!(n)) {
                msysnewc_printstr_n(pstart,n);
                n = (i64)0;
            };
            ++msysnewc_fmtstr;
            c = (u64)((*msysnewc_fmtstr));
            if (!!((u64)(c))) {
                ++msysnewc_fmtstr;
                msysnewc_printchar((i64)(c));
            };
            pstart = msysnewc_fmtstr;
        }break;
        default: {
            //skip:
L70 :;
;
            ++n;
            ++msysnewc_fmtstr;
        }
        } //SW
;
L68 :;
    }L69 :;
    ;
}

void msysnewc_strtofmt(byte * s,i64 slen,struct msysnewc_fmtrec * fmt) {
    byte c;
    byte wset;
    i64 n;
    byte str[100];
    (*fmt) = msysnewc_defaultfmt;
    if ((s == 0)) {
        return;
    };
    if ((slen == (i64)-1)) {
        slen = (i64)(strlen((i8 *)(s)));
    };
    memcpy((void *)(str),(void *)(s),(u64)(slen));
    str[(slen)] = (u64)0u;
    s = str;
    wset = (u64)((i64)0);
    L71 :;
    while (!!((u64)((*s)))) {
        c = (u64)((*s));
        ++s;
        switch ((i64)(c)) {
        case 66:;
        case 98:;
        {
            (*fmt).base = (u64)((i64)2);
        }break;
        case 72:;
        case 104:;
        {
            (*fmt).base = (u64)((i64)16);
        }break;
        case 79:;
        case 111:;
        {
            (*fmt).base = (u64)((i64)8);
        }break;
        case 88:;
        case 120:;
        {
            c = (u64)((*s));
            if (!!((u64)(c))) {
                switch ((i64)(c)) {
                case 48:;
                case 49:;
                case 50:;
                case 51:;
                case 52:;
                case 53:;
                case 54:;
                case 55:;
                case 56:;
                case 57:;
                {
                    c = ((u64)(c) - '0');
                }break;
                case 65:;
                case 66:;
                case 67:;
                case 68:;
                case 69:;
                case 70:;
                {
                    c = (u64)((((u64)(c) - 'A') + (i64)10));
                }break;
                case 97:;
                case 98:;
                case 99:;
                case 100:;
                case 101:;
                case 102:;
                {
                    c = (u64)((((u64)(c) - 'a') + (i64)10));
                }break;
                default: {
                    c = (u64)10u;
                }
                } //SW
;
                (*fmt).base = (u64)(c);
                ++s;
            };
        }break;
        case 81:;
        case 113:;
        {
            (*fmt).quotechar = '"';
        }break;
        case 126:;
        {
            (*fmt).quotechar = '~';
        }break;
        case 74:;
        case 106:;
        {
            (*fmt).justify = (u64)(toupper((i64)((i32)((*s)))));
            if (!!((u64)((*s)))) {
                ++s;
            };
        }break;
        case 65:;
        {
            (*fmt).lettercase = 'A';
        }break;
        case 97:;
        {
            (*fmt).lettercase = 'a';
        }break;
        case 90:;
        case 122:;
        {
            (*fmt).padchar = '0';
        }break;
        case 83:;
        case 115:;
        {
            (*fmt).sepchar = (u64)((*s));
            if (!!((u64)((*s)))) {
                ++s;
            };
        }break;
        case 80:;
        case 112:;
        {
            (*fmt).padchar = (u64)((*s));
            if (!!((u64)((*s)))) {
                ++s;
            };
        }break;
        case 84:;
        case 116:;
        {
            (*fmt).suffix = (u64)((*s));
            if (!!((u64)((*s)))) {
                ++s;
            };
        }break;
        case 87:;
        case 119:;
        {
            (*fmt).usigned = 'W';
        }break;
        case 69:;
        case 101:;
        {
            (*fmt).realfmt = 'e';
        }break;
        case 70:;
        case 102:;
        {
            (*fmt).realfmt = 'f';
        }break;
        case 71:;
        case 103:;
        {
            (*fmt).realfmt = 'g';
        }break;
        case 46:;
        {
            wset = (u64)((i64)1);
        }break;
        case 44:;
        case 95:;
        {
            (*fmt).sepchar = (u64)(c);
        }break;
        case 43:;
        {
            (*fmt).plus = '+';
        }break;
        case 68:;
        case 100:;
        {
            (*fmt).charmode = 'D';
        }break;
        case 67:;
        case 99:;
        {
            (*fmt).charmode = 'C';
        }break;
        case 77:;
        case 109:;
        {
            (*fmt).heapmode = 'M';
        }break;
        case 86:;
        case 118:;
        {
            (*fmt).param = 'V';
        }break;
        case 42:;
        {
            n = msysnewc_fmtparam;
            goto L74 ;
;
        }break;
        default: {
            if ((((u64)(c) >= '0') && ((u64)(c) <= '9'))) {
                n = ((u64)(c) - '0');
                L75 :;
                while (1) {
                    c = (u64)((*s));
                    if (((i64)((*s)) == (i64)0)) {
                        goto L76 ;
                    };
                    if ((((u64)(c) >= '0') && ((u64)(c) <= '9'))) {
                        ++s;
                        n = (((n * (i64)10) + (i64)(c)) - (i64)48);
                    } else {
                        goto L76 ;
                    };
                }L76 :;
                ;
                //gotwidth:
L74 :;
;
                if (!(!!((u64)(wset)))) {
                    (*fmt).minwidth = (u64)(n);
                    wset = (u64)((i64)1);
                } else {
                    (*fmt).precision = n;
                };
            };
        }
        } //SW
;
L72 :;
    }L73 :;
    ;
}

static i64 msysnewc_domultichar(byte * p,i64 n,byte * dest,struct msysnewc_fmtrec * fmt) {
    byte str[20];
    byte *  q;
    i64 nchars;
    i64 av_1;
    q = str;
    nchars = n;
    av_1 = n;
    while (av_1-- > 0) {
L77 :;
        if (((i64)((*p)) == (i64)0)) {
            goto L79 ;
        };
        (*q) = (u64)((*p));
        ++q;
        ++p;
L78 :;
    }L79 :;
    ;
    (*q) = (u64)0u;
    return msysnewc_expandstr(str,dest,(i64)(strlen((i8 *)(str))),fmt);
}

static i64 msysnewc_expandstr(byte * s,byte * t,i64 n,struct msysnewc_fmtrec * fmt) {
    i64 i;
    i64 w;
    i64 m;
    i64 av_1;
    i64 av_2;
    i64 av_3;
    i64 av_4;
    i64 av_5;
    w = (i64)((*fmt).minwidth);
    if (((w == (i64)0) || (w <= n))) {
        strncpy((i8 *)(t),(i8 *)(s),(u64)(n));
        (*(t + n)) = (u64)0u;
        return n;
    };
    if (((u64)((*fmt).justify) == 'L')) {
        strncpy((i8 *)(t),(i8 *)(s),(u64)(n));
        t += n;
        L80 :;
        for (i=(i64)1;i<=(w - n);i+=(i64)1) {
L81 :;
            (*t) = (u64)((*fmt).padchar);
            ++t;
L82 :;
        }L83 :;
        ;
        (*t) = (u64)0u;
    } else if (((u64)((*fmt).justify) == 'R')) {
        if (((((u64)((*fmt).padchar) == '0') && !!((u64)((*fmt).base))) && (((u64)((*s)) == '-') || ((u64)((*s)) == '+')))) {
            (*t) = (u64)((*s));
            ++t;
            av_2 = (w - n);
            while (av_2-- > 0) {
L84 :;
                (*t) = (u64)((*fmt).padchar);
                ++t;
L85 :;
            }L86 :;
            ;
            strncpy((i8 *)(t),(i8 *)((s + (i64)1)),(u64)((n - (i64)1)));
            (*((t + n) - (i64)1)) = (u64)0u;
        } else {
            av_3 = (w - n);
            while (av_3-- > 0) {
L87 :;
                (*t) = (u64)((*fmt).padchar);
                ++t;
L88 :;
            }L89 :;
            ;
            strncpy((i8 *)(t),(i8 *)(s),(u64)(n));
            (*(t + n)) = (u64)0u;
        };
    } else {
        m = (((w - n) + (i64)1) / (i64)2);
        av_4 = m;
        while (av_4-- > 0) {
L90 :;
            (*t) = (u64)((*fmt).padchar);
            ++t;
L91 :;
        }L92 :;
        ;
        strncpy((i8 *)(t),(i8 *)(s),(u64)(n));
        t += n;
        av_5 = ((w - n) - m);
        while (av_5-- > 0) {
L93 :;
            (*t) = (u64)((*fmt).padchar);
            ++t;
L94 :;
        }L95 :;
        ;
        (*t) = (u64)0u;
    };
    return w;
}

static u64 msysnewc_xdivrem(u64 a,u64 b,u64 * remainder) {
    u64 q;
    mlib_abortprogram((byte*)"XDIVREM");
    return q;
}

static i64 msysnewc_u64tostr(u64 aa,byte * s,u64 base,i64 sep) {
    byte t[360];
    i64 i;
    i64 j;
    i64 k;
    i64 g;
    byte *  s0;
    i = (i64)0;
    k = (i64)0;
    g = (((i64)(base) == (i64)10)?(i64)3:(i64)4);
    L96 :;
    do {
        t[(++i)] = (u64)(msysnewc_digits[((i64)((aa % base)))]);
        aa = (aa / base);
        ++k;
        if (((!!(sep) && ((i64)(aa) != (i64)0)) && (k == g))) {
            t[(++i)] = (u64)(sep);
            k = (i64)0;
        };
L97 :;
    } while (!((i64)(aa) == (i64)0));L98 :;
    ;
    j = i;
    s0 = s;
    L99 :;
    while (!!(i)) {
        (*s) = (u64)(t[(i--)]);
        ++s;
L100 :;
    }L101 :;
    ;
    (*s) = (u64)0u;
    return j;
}

static i64 msysnewc_i64tostrfmt(i64 aa,byte * s,struct msysnewc_fmtrec * fmt) {
    byte str[360];
    i64 n;
    i64 usigned;
    static u64 mindint = (u64)9223372036854775808u;
    usigned = (i64)0;
    if (!!((u64)((*fmt).usigned))) {
        usigned = (i64)1;
    };
    if (((aa == (i64)(mindint)) && !(!!(usigned)))) {
        str[((i64)0)] = '-';
        n = (msysnewc_i64mintostr(&str[((i64)1)],(i64)((*fmt).base),(i64)((*fmt).sepchar)) + (i64)1);
    } else {
        if (((!(!!(usigned)) && (aa < (i64)0)) || !!((u64)((*fmt).plus)))) {
            if ((aa < (i64)0)) {
                aa = -(aa);
                str[((i64)0)] = '-';
            } else {
                str[((i64)0)] = '+';
            };
            n = (msysnewc_u64tostr((u64)(aa),&str[((i64)1)],(u64)((*fmt).base),(i64)((*fmt).sepchar)) + (i64)1);
        } else {
            n = msysnewc_u64tostr((u64)(aa),str,(u64)((*fmt).base),(i64)((*fmt).sepchar));
        };
    };
    if (!!((u64)((*fmt).suffix))) {
        str[(n)] = (u64)((*fmt).suffix);
        str[(++n)] = (u64)0u;
    };
    if (((((i64)((u64)((*fmt).base)) > (i64)10) || !!((u64)((*fmt).suffix))) && ((u64)((*fmt).lettercase) == 'a'))) {
        msysnewc_convlcstring(str);
    };
    return msysnewc_expandstr(str,s,n,fmt);
}

static i64 msysnewc_u64tostrfmt(i64 aa,byte * s,struct msysnewc_fmtrec * fmt) {
    byte str[360];
    i64 n;
    n = msysnewc_u64tostr((u64)(aa),str,(u64)((*fmt).base),(i64)((*fmt).sepchar));
    if (!!((u64)((*fmt).suffix))) {
        str[(n)] = (u64)((*fmt).suffix);
        str[(++n)] = (u64)0u;
    };
    if ((((i64)((u64)((*fmt).base)) > (i64)10) || (!!((u64)((*fmt).suffix)) && ((u64)((*fmt).lettercase) == 'a')))) {
        msysnewc_convlcstring(str);
    };
    return msysnewc_expandstr(str,s,n,fmt);
}

static i64 msysnewc_i64mintostr(byte * s,i64 base,i64 sep) {
    byte t[360];
    i64 i;
    i64 j;
    i64 k;
    i64 g;
    switch (base) {
    case 10:;
    {
        strcpy((i8 *)(&t[((i64)0)]),(i8 *)((byte*)"9223372036854775808"));
        j = (i64)3;
    }break;
    case 16:;
    {
        strcpy((i8 *)(&t[((i64)0)]),(i8 *)((byte*)"8000000000000000"));
        j = (i64)1;
    }break;
    case 2:;
    {
        strcpy((i8 *)(&t[((i64)0)]),(i8 *)((byte*)"1000000000000000000000000000000000000000000000000000000000000000"));
        j = (i64)7;
    }break;
    default: {
        strcpy((i8 *)(&t[((i64)0)]),(i8 *)((byte*)"<mindint>"));
    }
    } //SW
;
    i = (i64)(strlen((i8 *)(&t[((i64)0)])));
    s += i;
    if (!!(sep)) {
        s += j;
    };
    (*s) = (u64)0u;
    k = (i64)0;
    g = ((base == (i64)10)?(i64)3:(i64)4);
    L102 :;
    while (!!(i)) {
        --s;
        (*s) = (u64)(t[((i-- - (i64)1))]);
        if (((!!(sep) && !!(i)) && (++k == g))) {
            --s;
            (*s) = (u64)(sep);
            k = (i64)0;
        };
L103 :;
    }L104 :;
    ;
    return (i64)(strlen((i8 *)(s)));
}

static i64 msysnewc_strtostrfmt(byte * s,byte * t,i64 n,struct msysnewc_fmtrec * fmt) {
    byte *  u;
    byte *  v;
    byte str[256];
    i64 w;
    i64 nheap;
    nheap = (i64)0;
    if ((!!((u64)((*fmt).quotechar)) || !!((u64)((*fmt).lettercase)))) {
        if ((n < (i64)256)) {
            u = str;
        } else {
            nheap = (n + (i64)3);
            u = (byte *)(mlib_pcm_alloc(nheap));
        };
        if (!!((u64)((*fmt).quotechar))) {
            v = u;
            (*v) = (u64)((*fmt).quotechar);
            ++v;
            if (!!(n)) {
                strcpy((i8 *)(v),(i8 *)(s));
                v += n;
            };
            (*v) = (u64)((*fmt).quotechar);
            ++v;
            (*v) = (u64)0u;
            n += (i64)2;
        } else {
            memcpy((void *)(u),(void *)(s),(u64)(n));
        };
        switch ((i64)((*fmt).lettercase)) {
        case 97:;
        {
            msysnewc_convlcstring(u);
        }break;
        case 65:;
        {
            msysnewc_convucstring(u);
        }break;
        default: {
        }
        } //SW
;
        s = u;
    };
    w = (i64)((*fmt).minwidth);
    if ((w > n)) {
        n = msysnewc_expandstr(s,t,n,fmt);
    } else {
        memcpy((void *)(t),(void *)(s),(u64)(n));
    };
    if (!!(nheap)) {
        mlib_pcm_free((void *)(u),nheap);
    };
    return n;
}

static void msysnewc_tostr_i64(i64 a,struct msysnewc_fmtrec * fmt) {
    byte str[360];
    i64 n;
    if (((i64)((*fmt).charmode)==(i64)0)) {
        n = msysnewc_i64tostrfmt(a,str,fmt);
    }else if (((i64)((*fmt).charmode)==(i64)68) || ((i64)((*fmt).charmode)==(i64)100)) {
        n = msysnewc_domultichar((byte *)(&a),(i64)8,str,fmt);
    } else {
        msysnewc_printchar(a);
        return;
    };
    msysnewc_printstr_n(str,n);
}

static void msysnewc_tostr_u64(u64 a,struct msysnewc_fmtrec * fmt) {
    byte str[360];
    i64 n;
    if (((i64)((*fmt).charmode)==(i64)68) || ((i64)((*fmt).charmode)==(i64)100)) {
        n = msysnewc_domultichar((byte *)(&a),(i64)8,str,fmt);
    }else if (((i64)((*fmt).charmode)==(i64)67) || ((i64)((*fmt).charmode)==(i64)99)) {
        msysnewc_printchar((i64)(a));
        return;
    } else {
        n = msysnewc_u64tostrfmt((i64)(a),str,fmt);
    };
    msysnewc_printstr_n(str,n);
}

static void msysnewc_tostr_r64(double x,struct msysnewc_fmtrec * fmt) {
    byte str[360];
    byte str2[360];
    byte cfmt[10];
    i64 n;
    cfmt[((i64)0)] = '%';
    if (!!((i64)((*fmt).precision))) {
        cfmt[((i64)1)] = '.';
        cfmt[((i64)2)] = '*';
        cfmt[((i64)3)] = (u64)((*fmt).realfmt);
        cfmt[((i64)4)] = (u64)0u;
        sprintf((i8 *)(str),(i8 *)(cfmt),(i64)((*fmt).precision),x);
    } else {
        cfmt[((i64)1)] = (u64)((*fmt).realfmt);
        cfmt[((i64)2)] = (u64)0u;
        sprintf((i8 *)(str),(i8 *)(cfmt),x);
    };
    n = (i64)(strlen((i8 *)(str)));
    if ((n < (i64)((u64)((*fmt).minwidth)))) {
        n = msysnewc_expandstr(str,str2,n,fmt);
        strcpy((i8 *)(str),(i8 *)(str2));
    };
    msysnewc_printstr_n(str,n);
}

static void msysnewc_tostr_str(byte * s,struct msysnewc_fmtrec * fmt) {
    i64 oldlen;
    i64 newlen;
    i64 n;
    byte *  t;
    oldlen = (i64)(strlen((i8 *)(s)));
    newlen = oldlen;
    if (((!!((u64)((*fmt).quotechar)) || ((i64)((u64)((*fmt).minwidth)) > newlen)) || !!((u64)((*fmt).lettercase)))) {
        if (!!((u64)((*fmt).quotechar))) {
            newlen += (i64)2;
        };
        if (((i64)((u64)((*fmt).minwidth)) > newlen)) {
            newlen = (i64)((*fmt).minwidth);
        };
        t = (byte *)(mlib_pcm_alloc((newlen + (i64)1)));
        n = msysnewc_strtostrfmt(s,t,oldlen,fmt);
        msysnewc_printstr_n(t,n);
        mlib_pcm_free((void *)(t),(newlen + (i64)1));
    } else {
        msysnewc_printstr_n(s,oldlen);
    };
}

static struct msysnewc_fmtrec * msysnewc_getfmt(byte * fmtstyle) {
    static struct msysnewc_fmtrec fmt;
    if (!!(fmtstyle)) {
        msysnewc_strtofmt(fmtstyle,(i64)-1,&fmt);
        return &fmt;
    } else {
        return &msysnewc_defaultfmt;
    };
}

byte * msysnewc_strint(i64 a,byte * fmtstyle) {
    static byte str[100];
    struct msysnewc_fmtrec *  fmt;
    msysnewc_m_print_startstr(str);
    msysnewc_tostr_i64(a,(fmt = msysnewc_getfmt(fmtstyle)));
    msysnewc_m_print_end();
    return msysnewc_getstr(str,fmt);
}

void msysnewc_getstrint(i64 a,byte * dest) {
    msysnewc_m_print_startstr(dest);
    msysnewc_tostr_i64(a,msysnewc_getfmt((byte *)(0)));
    msysnewc_m_print_end();
}

byte * msysnewc_strword(u64 a,byte * fmtstyle) {
    static byte str[100];
    struct msysnewc_fmtrec *  fmt;
    msysnewc_m_print_startstr(str);
    msysnewc_tostr_u64(a,(fmt = msysnewc_getfmt(fmtstyle)));
    msysnewc_m_print_end();
    return msysnewc_getstr(str,fmt);
}

byte * msysnewc_strreal(double a,byte * fmtstyle) {
    static byte str[320];
    struct msysnewc_fmtrec *  fmt;
    msysnewc_m_print_startstr(str);
    msysnewc_tostr_r64(a,(fmt = msysnewc_getfmt(fmtstyle)));
    msysnewc_m_print_end();
    return msysnewc_getstr(str,fmt);
}

static byte * msysnewc_getstr(byte * s,struct msysnewc_fmtrec * fmt) {
    if (!!((u64)((*fmt).heapmode))) {
        return mlib_pcm_copyheapstring(s);
    } else {
        return s;
    };
}

static void msysnewc_initreadbuffer(void) {
    if (!!(msysnewc_rd_buffer)) {
        return;
    };
    msysnewc_rd_buffer = (byte *)(mlib_pcm_alloc((i64)16384));
    (*msysnewc_rd_buffer) = (u64)0u;
    msysnewc_rd_pos = (msysnewc_rd_lastpos = msysnewc_rd_buffer);
}

void msysnewc_m_read_conline(void) {
    msysnewc_initreadbuffer();
    mlib_readlinen(0,msysnewc_rd_buffer,(i64)16384);
    msysnewc_rd_length = (i64)(strlen((i8 *)(msysnewc_rd_buffer)));
    msysnewc_rd_pos = msysnewc_rd_buffer;
    msysnewc_rd_lastpos = (byte *)(0);
}

void msysnewc_m_read_fileline(void * f) {
    msysnewc_initreadbuffer();
    mlib_readlinen(f,msysnewc_rd_buffer,(i64)16384);
    msysnewc_rd_length = (i64)(strlen((i8 *)(msysnewc_rd_buffer)));
    msysnewc_rd_pos = msysnewc_rd_buffer;
    msysnewc_rd_lastpos = (byte *)(0);
}

void msysnewc_m_read_strline(byte * s) {
    i64 n;
    msysnewc_initreadbuffer();
    n = (i64)(strlen((i8 *)(s)));
    if ((n < (i64)16384)) {
        strcpy((i8 *)(msysnewc_rd_buffer),(i8 *)(s));
    } else {
        memcpy((void *)(msysnewc_rd_buffer),(void *)(s),(u64)((i64)16383));
        (*((msysnewc_rd_buffer + (i64)16384) - (i64)1)) = (u64)0u;
    };
    msysnewc_rd_length = n;
    msysnewc_rd_pos = msysnewc_rd_buffer;
    msysnewc_rd_lastpos = (byte *)(0);
}

static byte * msysnewc_readitem(i64 * itemlength) {
    byte *  p;
    byte *  s;
    byte *  itemstr;
    byte quotechar;
    byte c;
    if (!(!!(msysnewc_rd_buffer))) {
        msysnewc_initreadbuffer();
    };
    s = msysnewc_rd_pos;
    L105 :;
    while ((((u64)((*s)) == ' ') || ((i64)((*s)) == (i64)9))) {
        ++s;
L106 :;
    }L107 :;
    ;
    itemstr = s;
    msysnewc_rd_lastpos = (msysnewc_rd_pos = s);
    if (((i64)((*s)) == (i64)0)) {
        msysnewc_termchar = (i64)0;
        (*itemlength) = (i64)0;
        return s;
    };
    quotechar = (u64)0u;
    if (((u64)((*s)) == '"')) {
        quotechar = '"';
        ++s;
    } else if (((u64)((*s)) == (u64)39u)) {
        quotechar = (u64)39u;
        ++s;
    };
    p = (itemstr = s);
    L108 :;
    while (!!((u64)((*s)))) {
        c = (u64)((*s++));
        switch ((i64)(c)) {
        case 32:;
        case 9:;
        case 44:;
        case 61:;
        {
            if ((!!((u64)(quotechar)) || (p == s))) {
                goto L111 ;
;
            };
            msysnewc_termchar = (i64)(c);
            goto L110 ;
        }break;
        default: {
            //normalchar:
L111 :;
;
            if (((u64)(c) == (u64)(quotechar))) {
                if (((u64)((*s)) == (u64)(quotechar))) {
                    (*p) = (u64)(c);
                    ++s;
                    ++p;
                } else {
                    msysnewc_termchar = (i64)((*s));
                    if (((msysnewc_termchar == (i64)44) || (msysnewc_termchar == (i64)61))) {
                        ++s;
                        msysnewc_termchar = (i64)((*s));
                    };
                    goto L110 ;
                };
            } else {
                (*p) = (u64)(c);
                ++p;
            };
        }
        } //SW
;
L109 :;
    }L110 :;
    ;
    if (((i64)((*s)) == (i64)0)) {
        msysnewc_termchar = (i64)0;
    };
    (*itemlength) = (p - itemstr);
    msysnewc_rd_pos = s;
    return itemstr;
}

i64 msysnewc_strtoint(byte * s,i64 length,i64 base) {
    byte signd;
    u64 aa;
    byte c;
    byte d;
    msysnewc_itemerror = (i64)0;
    if ((length == (i64)-1)) {
        length = (i64)(strlen((i8 *)(s)));
    };
    signd = (u64)((i64)0);
    if ((!!(length) && ((u64)((*s)) == '-'))) {
        signd = (u64)((i64)1);
        ++s;
        --length;
    } else if ((!!(length) && ((u64)((*s)) == '+'))) {
        ++s;
        --length;
    };
    aa = (u64)((i64)0);
    L112 :;
    while (!!(length)) {
        c = (u64)((*s++));
        --length;
        switch ((i64)(c)) {
        case 65:;
        case 66:;
        case 67:;
        case 68:;
        case 69:;
        case 70:;
        {
            d = (u64)((((u64)(c) - 'A') + (i64)10));
        }break;
        case 97:;
        case 98:;
        case 99:;
        case 100:;
        case 101:;
        case 102:;
        {
            d = (u64)((((u64)(c) - 'a') + (i64)10));
        }break;
        case 48:;
        case 49:;
        case 50:;
        case 51:;
        case 52:;
        case 53:;
        case 54:;
        case 55:;
        case 56:;
        case 57:;
        {
            d = ((u64)(c) - '0');
        }break;
        case 95:;
        case 39:;
        {
            goto L113 ;
        }break;
        default: {
            msysnewc_itemerror = (i64)1;
            goto L114 ;
        }
        } //SW
;
        if (((i64)(d) >= base)) {
            msysnewc_itemerror = (i64)1;
            goto L114 ;
        };
        aa = (u64)((((i64)(aa) * base) + (i64)(d)));
L113 :;
    }L114 :;
    ;
    if (!!((u64)(signd))) {
        return (i64)(-(aa));
    } else {
        return (i64)(aa);
    };
}

i64 msysnewc_m_read_i64(i64 fmt) {
    byte *  s;
    i64 length;
    if ((fmt==(i64)67) || (fmt==(i64)99)) {
        msysnewc_rd_lastpos = msysnewc_rd_pos;
        if (!!((u64)((*msysnewc_rd_pos)))) {
            return (i64)((*msysnewc_rd_pos++));
        } else {
            return (i64)0;
        };
    }else if ((fmt==(i64)84) || (fmt==(i64)116)) {
        return msysnewc_termchar;
    }else if ((fmt==(i64)69) || (fmt==(i64)101)) {
        return msysnewc_itemerror;
    };
    s = msysnewc_readitem(&length);
    if ((fmt==(i64)0) || (fmt==(i64)73) || (fmt==(i64)105)) {
        return msysnewc_strtoint(s,length,(i64)10);
    }else if ((fmt==(i64)66) || (fmt==(i64)98)) {
        return msysnewc_strtoint(s,length,(i64)2);
    }else if ((fmt==(i64)72) || (fmt==(i64)104)) {
        return msysnewc_strtoint(s,length,(i64)16);
    };
    return (i64)0;
}

double msysnewc_m_read_r64(i64 fmt) {
    byte str[512];
    byte *  s;
    i64 length;
    i32 numlength;
    double x;
    s = msysnewc_readitem(&length);
    if (((length == (i64)0) || (length >= (i64)512))) {
        return (double)0.;
    };
    memcpy((void *)(str),(void *)(s),(u64)(length));
    str[((length + (i64)1))-1] = (u64)0u;
    msysnewc_itemerror = (i64)0;
    if ((((i64)(sscanf((i8 *)(str),(i8 *)((byte*)"%lf%n"),&x,&numlength)) == (i64)0) || ((i64)(numlength) != length))) {
        x = (double)0.;
        msysnewc_itemerror = (i64)1;
    };
    return x;
}

void msysnewc_m_read_str(byte * dest,i64 destlen,i64 fmt) {
    byte *  s;
    i64 length;
    msysnewc_itemerror = (i64)0;
    if (((fmt == (i64)76) || (fmt == (i64)108))) {
        s = msysnewc_rd_pos;
        length = ((msysnewc_rd_buffer + msysnewc_rd_length) - msysnewc_rd_pos);
    } else {
        s = msysnewc_readitem(&length);
        if (((fmt == (i64)78) || (fmt == (i64)110))) {
            msysnewc_iconvlcn(s,length);
        };
    };
    if ((destlen > (i64)0)) {
        if ((length >= destlen)) {
            length = (destlen - (i64)1);
            msysnewc_itemerror = (i64)1;
        };
    };
    memcpy((void *)(dest),(void *)(s),(u64)(length));
    (*(dest + length)) = (u64)0u;
}

void msysnewc_readstr(byte * dest,i64 fmt,i64 destlen) {
    msysnewc_m_read_str(dest,destlen,fmt);
}

void msysnewc_rereadln(void) {
    msysnewc_rd_pos = msysnewc_rd_buffer;
    msysnewc_rd_lastpos = msysnewc_rd_pos;
}

void msysnewc_reread(void) {
    msysnewc_rd_pos = msysnewc_rd_lastpos;
}

i64 msysnewc_valint(byte * s,i64 fmt) {
    byte *  old_pos;
    byte *  old_lastpos;
    i64 aa;
    msysnewc_initreadbuffer();
    old_pos = msysnewc_rd_pos;
    old_lastpos = msysnewc_rd_lastpos;
    msysnewc_rd_pos = s;
    aa = msysnewc_m_read_i64(fmt);
    msysnewc_rd_pos = old_pos;
    msysnewc_rd_lastpos = old_lastpos;
    return aa;
}

double msysnewc_valreal(byte * s) {
    byte *  old_pos;
    byte *  old_lastpos;
    double x;
    msysnewc_initreadbuffer();
    old_pos = msysnewc_rd_pos;
    old_lastpos = msysnewc_rd_lastpos;
    msysnewc_rd_pos = s;
    x = msysnewc_m_read_r64((i64)0);
    msysnewc_rd_pos = old_pos;
    msysnewc_rd_lastpos = old_lastpos;
    return x;
}

static void msysnewc_iconvlcn(byte * s,i64 n) {
    i64 av_1;
    av_1 = n;
    while (av_1-- > 0) {
L115 :;
        (*s) = (u64)(tolower((i64)((i32)((*s)))));
        ++s;
L116 :;
    }L117 :;
    ;
}

static void msysnewc_iconvucn(byte * s,i64 n) {
    i64 av_1;
    av_1 = n;
    while (av_1-- > 0) {
L118 :;
        (*s) = (u64)(toupper((i64)((i32)((*s)))));
        ++s;
L119 :;
    }L120 :;
    ;
}

static void msysnewc_convlcstring(byte * s) {
    L121 :;
    while (!!((u64)((*s)))) {
        (*s) = (u64)(tolower((i64)((i32)((*s)))));
        ++s;
L122 :;
    }L123 :;
    ;
}

static void msysnewc_convucstring(byte * s) {
    L124 :;
    while (!!((u64)((*s)))) {
        (*s) = (u64)(toupper((i64)((i32)((*s)))));
        ++s;
L125 :;
    }L126 :;
    ;
}

i64 msysnewc_m_power_i64(i64 n,i64 a) {
    if ((n < (i64)0)) {
        return (i64)0;
    } else if ((n == (i64)0)) {
        return (i64)1;
    } else if ((n == (i64)1)) {
        return a;
    } else if (((n & (i64)1) == (i64)0)) {
        return msysnewc_m_power_i64((n / (i64)2),(a * a));
    } else {
        return (msysnewc_m_power_i64(((n - (i64)1) / (i64)2),(a * a)) * a);
    };
}

void msysnewc_m_intoverflow(void) {
    mlib_abortprogram((byte*)"Integer overflow detected");
}

void msysnewc_m_dotindex(u64 i,u64 a) {
    mlib_abortprogram((byte*)"DOT INDEX");
}

void msysnewc_m_dotslice(u64 j,u64 i,u64 a) {
    mlib_abortprogram((byte*)"DOT SLICE");
}

void msysnewc_m_popdotindex(u64 i,u64 * p,u64 x) {
    mlib_abortprogram((byte*)"POP DOT INDEX");
}

void msysnewc_m_popdotslice(u64 j,u64 i,u64 * p,u64 x) {
    mlib_abortprogram((byte*)"POP DOT SLICE");
}

i64 msysnewc_m_imin(i64 a,i64 b) {
    return (a<b?a:b);
}

i64 msysnewc_m_imax(i64 a,i64 b) {
    return (a>b?a:b);
}

double msysnewc_m_sign(double x) {
    if ((x > (double)0.)) {
        return (double)1.;
    } else if ((x < (double)0.)) {
        return (double)-1.;
    } else {
        return (double)0.;
    };
}

void * mlib_pcm_alloc(i64 n) {
    byte *  p;
    if (!(!!((u64)(mlib_pcm_setup)))) {
        mlib_pcm_init();
    };
    if ((n > (i64)2048)) {
        mlib_alloccode = mlib_pcm_getac(n);
        mlib_allocbytes = (i64)(mlib_allocupper[(mlib_alloccode)]);
        p = (byte *)(mlib_allocmem(mlib_allocbytes));
        if (!(!!(p))) {
            mlib_abortprogram((byte*)"pcm_alloc failure");
        };
        if (!!((i64)0)) {
            mlib_addtomemalloc((i32 *)(p),mlib_allocbytes);
        };
        return (void *)(p);
    };
    mlib_alloccode = (i64)(mlib_sizeindextable[(n)]);
    if ((mlib_alloccode == (i64)0)) {
        mlib_alloccode = (i64)1;
    };
    mlib_allocbytes = (i64)(mlib_allocupper[(mlib_alloccode)]);
    mlib_smallmemtotal += mlib_allocbytes;
    if (!!((p = (byte *)(mlib_freelist[(mlib_alloccode)])))) {
        if (!!((i64)0)) {
            mlib_addtomemalloc((i32 *)(p),mlib_allocbytes);
        };
        mlib_freelist[(mlib_alloccode)] = (u64 *)((i64)((*mlib_freelist[(mlib_alloccode)])));
        return (void *)(p);
    };
    p = mlib_pcheapptr;
    mlib_pcheapptr += mlib_allocbytes;
    if ((mlib_pcheapptr >= mlib_pcheapend)) {
        p = (byte *)(mlib_pcm_newblock(mlib_allocbytes));
        return (void *)(p);
    };
    if (!!((i64)0)) {
        mlib_addtomemalloc((i32 *)(p),mlib_allocbytes);
    };
    return (void *)(p);
}

void mlib_pcm_freestr(byte * s) {
    mlib_pcm_free((void *)(s),((i64)(strlen((i8 *)(s))) + (i64)1));
}

void mlib_pcm_free(void * p,i64 n) {
    i64 acode;
    if ((n == (i64)0)) {
        return;
    };
    if ((n > (i64)2048)) {
        if (!!((i64)0)) {
            mlib_removefrommemalloc((i32 *)(p),n);
        };
        free(p);
        return;
    };
    if (!!(p)) {
        acode = (i64)(mlib_sizeindextable[(n)]);
        mlib_smallmemtotal -= (i64)(mlib_allocupper[(acode)]);
        if (!!((i64)0)) {
            mlib_removefrommemalloc((i32 *)(p),(i64)(mlib_allocupper[(acode)]));
        };
        (*(u64 *)(p)) = (u64)((i64)(mlib_freelist[(acode)]));
        mlib_freelist[(acode)] = (u64 *)(p);
    };
}

void mlib_pcm_freeac(void * p,i64 alloc) {
    mlib_pcm_free(p,(i64)(mlib_allocupper[(alloc)]));
}

void mlib_pcm_copymem4(void * p,void * q,i64 n) {
    memcpy(p,q,(u64)(n));
}

void mlib_pcm_clearmem(void * p,i64 n) {
    memset(p,(i64)0,(u64)(n));
}

void mlib_pcm_init(void) {
    i64 j;
    i64 k;
    i64 size;
    i64 av_1;
    i64 i;
    if (!!((u64)(mlib_pcm_setup))) {
        return;
    };
    mlib_pcm_newblock((i64)0);
    L127 :;
    for (i=(i64)1;i<=(i64)2048;i+=(i64)1) {
L128 :;
        j = (i64)1;
        k = (i64)16;
        L131 :;
        while ((i > k)) {
            k = (k << (i64)1);
            ++j;
L132 :;
        }L133 :;
        ;
        mlib_sizeindextable[(i)] = (u64)(j);
L129 :;
    }L130 :;
    ;
    mlib_allocupper[((i64)1)] = (u64)((i64)16);
    size = (i64)16;
    L134 :;
    for (i=(i64)2;i<=(i64)27;i+=(i64)1) {
L135 :;
        size *= (i64)2;
        mlib_allocupper[(i)] = (u64)(size);
        if ((size >= (i64)33554432)) {
            k = i;
            goto L137 ;
        };
L136 :;
    }L137 :;
    ;
    L138 :;
    for (i=(k + (i64)1);i<=(i64)300;i+=(i64)1) {
L139 :;
        size += (i64)33554432;
        if ((size < (i64)8589934592)) {
            mlib_allocupper[(i)] = (u64)(size);
            mlib_maxmemory = (u64)(size);
        } else {
            mlib_maxalloccode = (i - (i64)1);
            goto L141 ;
        };
L140 :;
    }L141 :;
    ;
    mlib_pcm_setup = (u64)((i64)1);
}

i64 mlib_pcm_getac(i64 size) {
    if ((size <= (i64)2048)) {
        return (i64)(mlib_sizeindextable[(size)]);
    };
    size = ((size + (i64)255) >> (i64)8);
    if ((size <= (i64)2048)) {
        return ((i64)((u64)(mlib_sizeindextable[(size)])) + (i64)8);
    };
    size = ((size + (i64)63) >> (i64)6);
    if ((size <= (i64)2048)) {
        return ((i64)((u64)(mlib_sizeindextable[(size)])) + (i64)14);
    };
    size = ((((size - (i64)2048) + (i64)2047) / (i64)2048) + (i64)22);
    return size;
}

void * mlib_pcm_newblock(i64 itemsize) {
    static i64 totalheapsize;
    byte *  p;
    totalheapsize += (i64)2097152;
    mlib_alloccode = (i64)0;
    p = (byte *)(mlib_allocmem((i64)2097152));
    if ((p == 0)) {
        mlib_abortprogram((byte*)"Can't alloc pc heap");
    };
    mlib_pcheapptr = p;
    mlib_pcheapend = (p + (i64)2097152);
    if ((mlib_pcheapstart == 0)) {
        mlib_pcheapstart = p;
    };
    mlib_pcheapptr += itemsize;
    return (void *)((u32 *)(p));
}

i64 mlib_pcm_round(i64 n) {
    static i32 allocbytes[9] = {(i32)0,(i32)16,(i32)32,(i32)64,(i32)128,(i32)256,(i32)512,(i32)1024,(i32)2048};
    if ((n > (i64)2048)) {
        return n;
    } else {
        return (i64)(allocbytes[((i64)(mlib_sizeindextable[(n)]))]);
    };
}

i64 mlib_pcm_array(i64 n) {
    i64 m;
    if ((n <= (i64)2048)) {
        return mlib_pcm_round(n);
    } else {
        m = (i64)2048;
        L142 :;
        while ((n > m)) {
            m <<= (i64)1;
L143 :;
        }L144 :;
        ;
        return m;
    };
}

void mlib_pcm_printfreelist(i64 size,u64 * p) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"Size: ",NULL);
    msysnewc_m_print_i64(size,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    L145 :;
    while (!!(p)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)" ",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_ptr(p,(byte*)"h");
        msysnewc_m_print_end();
        ;
        p = (u64 *)((i64)((*p)));
L146 :;
    }L147 :;
    ;
    puts((i8 *)((byte*)""));
}

void mlib_pcm_diags(byte * caption) {
    i64 m;
    i64 i;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"HEAP FREELISTS:",NULL);
    msysnewc_m_print_str(caption,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    m = (i64)16;
    L148 :;
    for (i=(i64)1;i<=(i64)8;i+=(i64)1) {
L149 :;
        mlib_pcm_printfreelist(m,mlib_freelist[(i)]);
        m <<= (i64)1;
L150 :;
    }L151 :;
    ;
}

void * mlib_pcm_allocz(i64 n) {
    void *  p;
    p = mlib_pcm_alloc(n);
    memset(p,(i64)0,(u64)(n));
    return p;
}

byte * mlib_pcm_copyheapstring(byte * s) {
    byte *  q;
    i64 n;
    if ((s == 0)) {
        return (byte *)(0);
    };
    n = ((i64)(strlen((i8 *)(s))) + (i64)1);
    q = (byte *)(mlib_pcm_alloc(n));
    memcpy((void *)(q),(void *)(s),(u64)(n));
    return q;
}

byte * mlib_pcm_copyheapstringn(byte * s,i64 n) {
    byte *  q;
    if ((s == 0)) {
        return (byte *)(0);
    };
    q = (byte *)(mlib_pcm_alloc((n + (i64)1)));
    memcpy((void *)(q),(void *)(s),(u64)(n));
    (*(q + n)) = (u64)0u;
    return q;
}

byte * mlib_pcm_copyheapblock(byte * s,i64 length) {
    byte *  q;
    if ((length == (i64)0)) {
        return (byte *)(0);
    };
    q = (byte *)(mlib_pcm_alloc(length));
    memcpy((void *)(q),(void *)(s),(u64)(length));
    return q;
}

static void mlib_addtomemalloc(i32 * ptr,i64 size) {
    i64 i;
    L152 :;
    for (i=(i64)1;i<=(i64)500000;i+=(i64)1) {
L153 :;
        if ((mlib_memalloctable[(i)-1] == ptr)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((byte*)"ALLOC ERROR:",NULL);
            msysnewc_m_print_ptr(ptr,NULL);
            msysnewc_m_print_str((byte*)"ALREADY ALLOCATED\n\n\n",NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            msysnewc_m_print_startcon();
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            msysnewc_m_print_startcon();
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            exit((i64)2);
        };
        if ((mlib_memalloctable[(i)-1] == 0)) {
            mlib_memalloctable[(i)-1] = ptr;
            mlib_memallocsize[(i)-1] = size;
            return;
        };
L154 :;
    }L155 :;
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"MEMALLOCTABLE FULL\n\n\n\n",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    osnos_os_getch();
    exit((i64)3);
}

static void mlib_removefrommemalloc(i32 * ptr,i64 size) {
    i64 i;
    L156 :;
    for (i=(i64)1;i<=(i64)500000;i+=(i64)1) {
L157 :;
        if ((mlib_memalloctable[(i)-1] == ptr)) {
            if (((i64)(mlib_memallocsize[(i)-1]) != size)) {
                msysnewc_m_print_startcon();
                msysnewc_m_print_str((byte*)"REMOVE:FOUND",NULL);
                msysnewc_m_print_ptr(ptr,NULL);
                msysnewc_m_print_str((byte*)"IN MEMALLOCTABLE, FREESIZE=",NULL);
                msysnewc_m_print_i64(size,NULL);
                msysnewc_m_print_str((byte*)", BUT STORED AS BLOCK SIZE:",NULL);
                msysnewc_m_print_i64(mlib_memallocsize[(i)-1],NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
                msysnewc_m_print_startcon();
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
                msysnewc_m_print_startcon();
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
                mlib_abortprogram((byte*)"MEMSIZE");
            };
            mlib_memalloctable[(i)-1] = (i32 *)(0);
            return;
        };
L158 :;
    }L159 :;
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"CAN'T FIND",NULL);
    msysnewc_m_print_ptr(ptr,NULL);
    msysnewc_m_print_str((byte*)"IN MEMALLOCTABLE",NULL);
    msysnewc_m_print_i64(size,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    mlib_abortprogram((byte*)"MEM");
    exit((i64)4);
}

void * mlib_allocmem(i64 n) {
    void *  p;
    p = malloc((u64)(n));
    if (!!(p)) {
        return p;
    };
    msysnewc_m_print_startcon();
    msysnewc_m_print_i64(n,NULL);
    msysnewc_m_print_i64(mlib_memtotal,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    mlib_abortprogram((byte*)"Alloc mem failure");
    return 0;
}

void * mlib_reallocmem(void * p,i64 n) {
    p = realloc(p,(u64)(n));
    if (!!(p)) {
        return p;
    };
    msysnewc_m_print_startcon();
    msysnewc_m_print_i64(n,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    mlib_abortprogram((byte*)"Realloc mem failure");
    return 0;
}

void mlib_abortprogram(byte * s) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_str(s,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"ABORTING: Press key...",NULL);
    msysnewc_m_print_end();
    ;
    osnos_os_getch();
    exit((i64)5);
}

i64 mlib_getfilesize(void * handlex) {
    u32 p;
    u32 size;
    p = (u64)(ftell(handlex));
    fseek(handlex,(i64)0,(i64)2);
    size = (u64)(ftell(handlex));
    fseek(handlex,(i64)((i32)(p)),(i64)0);
    return (i64)(size);
}

void mlib_readrandom(void * handlex,byte * mem,i64 offset,i64 size) {
    i64 a;
    fseek(handlex,(i64)((i32)(offset)),(i64)0);
    a = (i64)(fread((void *)(mem),(u64)((i64)1),(u64)(size),handlex));
}

i64 mlib_writerandom(void * handlex,byte * mem,i64 offset,i64 size) {
    fseek(handlex,(i64)((i32)(offset)),(i64)0);
    return (i64)(fwrite((void *)(mem),(u64)((i64)1),(u64)(size),handlex));
}

i64 mlib_setfilepos(void * file,i64 offset) {
    return (i64)(fseek(file,(i64)((i32)(offset)),(i64)0));
}

i64 mlib_getfilepos(void * file) {
    return (i64)(ftell(file));
}

byte * mlib_readfile(byte * filename) {
    void *  f;
    i64 size;
    byte *  m;
    byte *  p;
    f = fopen((i8 *)(filename),(i8 *)((byte*)"rb"));
    if ((f == 0)) {
        return (byte *)(0);
    };
    mlib_rfsize = (size = mlib_getfilesize(f));
    m = (byte *)(malloc((u64)((size + (i64)4))));
    if ((m == 0)) {
        return (byte *)(0);
    };
    mlib_readrandom(f,m,(i64)0,size);
    p = (m + size);
    (*p) = (u64)((i64)0);
    (*(p + (i64)1)) = (u64)((i64)26);
    (*(p + (i64)2)) = (u64)((i64)0);
    fclose(f);
    return m;
}

i64 mlib_writefile(byte * filename,byte * data,i64 size) {
    void *  f;
    i64 n;
    f = fopen((i8 *)(filename),(i8 *)((byte*)"wb"));
    if ((f == 0)) {
        return (i64)0;
    };
    n = mlib_writerandom(f,data,(i64)0,size);
    fclose(f);
    return n;
}

i64 mlib_checkfile(byte * file) {
    void *  f;
    if (!!((f = fopen((i8 *)(file),(i8 *)((byte*)"rb"))))) {
        fclose(f);
        return (i64)1;
    };
    return (i64)0;
}

void mlib_readlinen(void * handlex,byte * buffer,i64 size) {
    i64 ch;
    byte *  p;
    i64 n;
    byte crseen;
    if ((handlex == 0)) {
        handlex = osnos_os_getstdin();
    };
    if ((handlex == 0)) {
        n = (i64)0;
        p = buffer;
        L160 :;
        while (1) {
            ch = (i64)(getchar());
            if ((((ch == (i64)13) || (ch == (i64)10)) || (ch == (i64)-1))) {
                (*p) = (u64)0u;
                return;
            };
            (*p++) = (u64)(ch);
            ++n;
            if ((n >= (size - (i64)2))) {
                (*p) = (u64)0u;
                return;
            };
        }L161 :;
        ;
    };
    (*buffer) = (u64)0u;
    if ((fgets((i8 *)(buffer),(size - (i64)2),handlex) == 0)) {
        return;
    };
    n = (i64)(strlen((i8 *)(buffer)));
    if ((n == (i64)0)) {
        return;
    };
    p = ((buffer + n) - (i64)1);
    crseen = (u64)((i64)0);
    L162 :;
    while (((p >= buffer) && (((i64)((*p)) == (i64)13) || ((i64)((*p)) == (i64)10)))) {
        if ((((i64)((*p)) == (i64)13) || ((i64)((*p)) == (i64)10))) {
            crseen = (u64)((i64)1);
        };
        (*p--) = (u64)0u;
L163 :;
    }L164 :;
    ;
    if ((!(!!((u64)(crseen))) && ((n + (i64)4) > size))) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_i64(size,NULL);
        msysnewc_m_print_i64(n,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        mlib_abortprogram((byte*)"line too long");
    };
}

void mlib_iconvlcn(byte * s,i64 n) {
    i64 av_1;
    av_1 = n;
    while (av_1-- > 0) {
L165 :;
        (*s) = (u64)(tolower((i64)((i32)((*s)))));
        ++s;
L166 :;
    }L167 :;
    ;
}

void mlib_iconvucn(byte * s,i64 n) {
    i64 av_1;
    av_1 = n;
    while (av_1-- > 0) {
L168 :;
        (*s) = (u64)(toupper((i64)((i32)((*s)))));
        ++s;
L169 :;
    }L170 :;
    ;
}

void mlib_convlcstring(byte * s) {
    L171 :;
    while (!!((u64)((*s)))) {
        (*s) = (u64)(tolower((i64)((i32)((*s)))));
        ++s;
L172 :;
    }L173 :;
    ;
}

void mlib_convucstring(byte * s) {
    L174 :;
    while (!!((u64)((*s)))) {
        (*s) = (u64)(toupper((i64)((i32)((*s)))));
        ++s;
L175 :;
    }L176 :;
    ;
}

byte * mlib_changeext(byte * s,byte * newext) {
    static byte newfile[260];
    byte newext2[32];
    byte *  sext;
    i64 n;
    strcpy((i8 *)(&newfile[((i64)1)-1]),(i8 *)(s));
    if (((i64)((*newext))==(i64)0)) {
        newext2[((i64)1)-1] = (u64)0u;
        newext2[((i64)2)-1] = (u64)0u;
    }else if (((i64)((*newext))==(i64)46)) {
        strcpy((i8 *)(&newext2[((i64)1)-1]),(i8 *)(newext));
    } else {
        strcpy((i8 *)(&newext2[((i64)1)-1]),(i8 *)((byte*)"."));
        strcat((i8 *)(&newext2[((i64)1)-1]),(i8 *)(newext));
    };
    sext = mlib_extractext(s,(i64)1);
    if (((i64)((*sext))==(i64)0)) {
        strcat((i8 *)(&newfile[((i64)1)-1]),(i8 *)(&newext2[((i64)1)-1]));
    }else if (((i64)((*sext))==(i64)46)) {
        strcat((i8 *)(&newfile[((i64)1)-1]),(i8 *)(&newext2[((i64)2)-1]));
    } else {
        n = ((sext - s) - (i64)2);
        strcpy((i8 *)(((&newfile[((i64)1)-1] + n) + (i64)1)),(i8 *)(&newext2[((i64)1)-1]));
    };
    return &newfile[((i64)1)-1];
}

byte * mlib_extractext(byte * s,i64 period) {
    byte *  t;
    byte *  u;
    t = mlib_extractfile(s);
    if (((i64)((*t)) == (i64)0)) {
        return (byte*)"";
    };
    u = ((t + (i64)(strlen((i8 *)(t)))) - (i64)1);
    L177 :;
    while ((u >= t)) {
        if (((u64)((*u)) == '.')) {
            if (((i64)((*(u + (i64)1))) == (i64)0)) {
                return (!!(period)?(byte*)".":(byte*)"");
            };
            return (u + (i64)1);
        };
        --u;
L178 :;
    }L179 :;
    ;
    return (byte*)"";
}

byte * mlib_extractpath(byte * s) {
    static byte str[260];
    byte *  t;
    i64 n;
    t = ((s + (i64)(strlen((i8 *)(s)))) - (i64)1);
    L180 :;
    while ((t >= s)) {
        switch ((i64)((*t))) {
        case 92:;
        case 47:;
        case 58:;
        {
            n = ((t - s) + (i64)1);
            memcpy((void *)(str),(void *)(s),(u64)(n));
            str[(n)] = (u64)0u;
            return str;
        }break;
        default: {
        }
        } //SW
;
        --t;
L181 :;
    }L182 :;
    ;
    return (byte*)"";
}

byte * mlib_extractfile(byte * s) {
    byte *  t;
    t = mlib_extractpath(s);
    if (((i64)((*t)) == (i64)0)) {
        return s;
    };
    return (s + (i64)(strlen((i8 *)(t))));
}

byte * mlib_extractbasefile(byte * s) {
    static byte str[100];
    byte *  f;
    byte *  e;
    i64 n;
    i64 flen;
    f = mlib_extractfile(s);
    flen = (i64)(strlen((i8 *)(f)));
    if ((flen == (i64)0)) {
        return (byte*)"";
    };
    e = mlib_extractext(f,(i64)0);
    if (!!((u64)((*e)))) {
        n = ((flen - (i64)(strlen((i8 *)(e)))) - (i64)1);
        memcpy((void *)(&str),(void *)(f),(u64)(n));
        str[(n)] = (u64)0u;
        return str;
    };
    if (((u64)((*((f + flen) - (i64)1))) == '.')) {
        memcpy((void *)(&str),(void *)(f),(u64)((flen - (i64)1)));
        str[((flen - (i64)1))] = (u64)0u;
        return str;
    };
    return f;
}

byte * mlib_addext(byte * s,byte * newext) {
    byte *  sext;
    sext = mlib_extractext(s,(i64)1);
    if (((i64)((*sext)) == (i64)0)) {
        return mlib_changeext(s,newext);
    };
    return s;
}

void * mlib_alloctable(i64 n,i64 size) {
    void *  p;
    p = malloc((u64)(((n + (i64)1) * size)));
    if (!(!!(p))) {
        mlib_abortprogram((byte*)"Alloctable failure");
    };
    return p;
}

void * mlib_zalloctable(i64 n,i64 size) {
    i64 *  p;
    p = (i64 *)(mlib_alloctable(n,size));
    mlib_pcm_clearmem((void *)(p),((n + (i64)1) * size));
    return (void *)(p);
}

void mlib_checkfreelists(byte * s) {
    u64 *  p;
    u64 *  q;
    i64 aa;
    i64 i;
    L183 :;
    for (i=(i64)2;i<=(i64)2;i+=(i64)1) {
L184 :;
        p = mlib_freelist[(i)];
        L187 :;
        while (!!(p)) {
            aa = (i64)(p);
            if (((aa > (i64)4294967295) || (aa < (i64)100))) {
                msysnewc_m_print_startcon();
                msysnewc_m_print_str(s,NULL);
                msysnewc_m_print_str((byte*)"FREE LIST ERROR",NULL);
                msysnewc_m_print_i64(i,NULL);
                msysnewc_m_print_ptr(p,NULL);
                msysnewc_m_print_ptr(q,NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
            };
            q = p;
            p = (u64 *)((i64)((*p)));
L188 :;
        }L189 :;
        ;
L185 :;
    }L186 :;
    ;
}

void * mlib_pcm_alloc32(void) {
    mlib_allocbytes = (i64)32;
    return mlib_pcm_alloc((i64)32);
}

void mlib_pcm_free32(void * p) {
    mlib_smallmemtotal -= (i64)32;
    if (!!((i64)0)) {
        mlib_removefrommemalloc((i32 *)(p),(i64)32);
    };
    (*(u64 *)(p)) = (u64)((i64)(mlib_freelist[((i64)2)]));
    mlib_freelist[((i64)2)] = (u64 *)(p);
}

void mlib_outbyte(void * f,i64 x) {
    fwrite((void *)(&x),(u64)((i64)1),(u64)((i64)1),f);
}

void mlib_outword16(void * f,u64 x) {
    fwrite((void *)(&x),(u64)((i64)2),(u64)((i64)1),f);
}

void mlib_outword(void * f,u64 x) {
    fwrite((void *)(&x),(u64)((i64)4),(u64)((i64)1),f);
}

void mlib_outword64(void * f,u64 x) {
    fwrite((void *)(&x),(u64)((i64)8),(u64)((i64)1),f);
}

i64 mlib_myeof(void * f) {
    i64 c;
    c = (i64)(fgetc(f));
    if ((c == (i64)-1)) {
        return (i64)1;
    };
    ungetc((i64)((i32)(c)),f);
    return (i64)0;
}

void * mlib_pcm_smallallocz(i64 n) {
    byte *  p;
    if (((mlib_alloccode = (i64)(mlib_sizeindextable[(n)])) == (i64)0)) {
        mlib_alloccode = (i64)1;
    };
    mlib_allocbytes = (i64)(mlib_allocupper[(mlib_alloccode)]);
    p = mlib_pcheapptr;
    mlib_pcheapptr += mlib_allocbytes;
    if ((mlib_pcheapptr >= mlib_pcheapend)) {
        p = (byte *)(mlib_pcm_newblock(mlib_allocbytes));
        memset((void *)(p),(i64)0,(u64)(n));
        return (void *)(p);
    };
    memset((void *)(p),(i64)0,(u64)(n));
    return (void *)(p);
}

void * mlib_pcm_smallalloc(i64 n) {
    byte *  p;
    if (((mlib_alloccode = (i64)(mlib_sizeindextable[(n)])) == (i64)0)) {
        mlib_alloccode = (i64)1;
    };
    mlib_allocbytes = (i64)(mlib_allocupper[(mlib_alloccode)]);
    p = mlib_pcheapptr;
    mlib_pcheapptr += mlib_allocbytes;
    if ((mlib_pcheapptr >= mlib_pcheapend)) {
        p = (byte *)(mlib_pcm_newblock(mlib_allocbytes));
        return (void *)(p);
    };
    return (void *)(p);
}

void mlib_strbuffer_add(struct mlib_strbuffer * dest,byte * s,i64 n) {
    i64 newlen;
    i64 oldlen;
    byte *  newptr;
    if ((n == (i64)0)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"N=0",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
    if ((n == (i64)-1)) {
        n = (i64)(strlen((i8 *)(s)));
    };
    oldlen = (i64)((*dest).length);
    if ((oldlen == (i64)0)) {
        (*dest).strptr = (byte *)(mlib_pcm_alloc((n + (i64)1)));
        (*dest).allocated = mlib_allocbytes;
        (*dest).length = n;
        memcpy((void *)((*dest).strptr),(void *)(s),(u64)(n));
        (*((*dest).strptr + n)) = (u64)0u;
        return;
    };
    newlen = (oldlen + n);
    if (((newlen + (i64)1) > (i64)((*dest).allocated))) {
        newptr = (byte *)(mlib_pcm_alloc((newlen + (i64)1)));
        memcpy((void *)(newptr),(void *)((*dest).strptr),(u64)(oldlen));
        (*dest).strptr = newptr;
        (*dest).allocated = mlib_allocbytes;
    };
    memcpy((void *)(((*dest).strptr + oldlen)),(void *)(s),(u64)(n));
    (*((*dest).strptr + newlen)) = (u64)0u;
    (*dest).length = newlen;
}

void mlib_gs_init(struct mlib_strbuffer * dest) {
    mlib_pcm_clearmem((void *)(dest),(i64)16);
}

void mlib_gs_free(struct mlib_strbuffer * dest) {
    if (!!((i64)((*dest).allocated))) {
        mlib_pcm_free((void *)((*dest).strptr),(i64)((*dest).allocated));
    };
}

void mlib_gs_str(struct mlib_strbuffer * dest,byte * s) {
    mlib_strbuffer_add(dest,s,(i64)-1);
}

void mlib_gs_char(struct mlib_strbuffer * dest,i64 c) {
    byte s[16];
    s[((i64)1)-1] = (u64)(c);
    s[((i64)2)-1] = (u64)0u;
    mlib_strbuffer_add(dest,s,(i64)1);
}

void mlib_gs_strn(struct mlib_strbuffer * dest,byte * s,i64 length) {
    mlib_strbuffer_add(dest,s,length);
}

void mlib_gs_strvar(struct mlib_strbuffer * dest,struct mlib_strbuffer * s) {
    mlib_strbuffer_add(dest,(*s).strptr,(i64)-1);
}

void mlib_gs_strint(struct mlib_strbuffer * dest,i64 a) {
    mlib_strbuffer_add(dest,msysnewc_strint(a,(byte *)(0)),(i64)-1);
}

void mlib_gs_strln(struct mlib_strbuffer * dest,byte * s) {
    mlib_gs_str(dest,s);
    mlib_gs_line(dest);
}

void mlib_gs_strsp(struct mlib_strbuffer * dest,byte * s) {
    mlib_gs_str(dest,s);
    mlib_gs_str(dest,(byte*)" ");
}

void mlib_gs_line(struct mlib_strbuffer * dest) {
    mlib_strbuffer_add(dest,(byte*)"\r\n",(i64)-1);
}

i64 mlib_gs_getcol(struct mlib_strbuffer * dest) {
    return (i64)((*dest).length);
}

void mlib_gs_leftstr(struct mlib_strbuffer * dest,byte * s,i64 w,i64 padch) {
    i64 col;
    i64 i;
    i64 n;
    i64 slen;
    byte str[2560];
    col = (i64)((*dest).length);
    strcpy((i8 *)(str),(i8 *)(s));
    slen = (i64)(strlen((i8 *)(s)));
    n = (w - slen);
    if ((n > (i64)0)) {
        L190 :;
        for (i=(i64)1;i<=n;i+=(i64)1) {
L191 :;
            str[((slen + i))-1] = (u64)(padch);
L192 :;
        }L193 :;
        ;
        str[(((slen + n) + (i64)1))-1] = (u64)0u;
    };
    mlib_gs_str(dest,str);
}

void mlib_gs_leftint(struct mlib_strbuffer * dest,i64 a,i64 w,i64 padch) {
    mlib_gs_leftstr(dest,msysnewc_strint(a,(byte *)(0)),w,padch);
}

void mlib_gs_padto(struct mlib_strbuffer * dest,i64 col,i64 ch) {
    i64 n;
    byte str[2560];
    i64 i;
    n = (col - (i64)((*dest).length));
    if ((n <= (i64)0)) {
        return;
    };
    L194 :;
    for (i=(i64)1;i<=n;i+=(i64)1) {
L195 :;
        str[(i)-1] = (u64)(ch);
L196 :;
    }L197 :;
    ;
    str[((n + (i64)1))-1] = (u64)0u;
    mlib_gs_str(dest,str);
}

void mlib_gs_println(struct mlib_strbuffer * dest,void * f) {
    (*((*dest).strptr + (i64)((*dest).length))) = (u64)0u;
    if ((f == 0)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((*dest).strptr,NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str((byte*)"\r",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    } else {
        msysnewc_m_print_startfile(f);
        msysnewc_m_print_str((*dest).strptr,NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str((byte*)"\r",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
}

i64 mlib_nextcmdparam(i64 * paramno,byte * * name,byte * * value,byte * defext) {
    static i64 infile = (i64)0;
    static byte *  filestart = 0;
    static byte *  fileptr = 0;
    static byte colonseen = (u8)0u;
    byte *  q;
    byte *  item;
    byte *  fileext;
    i64 length;
    static byte str[300];
    //reenter:
L198 :;
;
    (*value) = (byte *)(0);
    (*name) = (byte *)(0);
    if (!!(infile)) {
        if ((mlib_readnextfileitem(&fileptr,&item) == (i64)0)) {
            free((void *)(filestart));
            infile = (i64)0;
            goto L198 ;
;
        };
    } else {
        if (((*paramno) > msysnewc_nsysparams)) {
            return (i64)0;
        };
        item = msysnewc_sysparams[((*paramno))-1];
        ++(*paramno);
        length = (i64)(strlen((i8 *)(item)));
        if (((u64)((*item)) == '@')) {
            filestart = (fileptr = (byte *)(mlib_readfile((item + (i64)1))));
            if ((filestart == 0)) {
                msysnewc_m_print_startcon();
                msysnewc_m_print_str((byte*)"Can't open",NULL);
                msysnewc_m_print_str(item,NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
                exit((i64)7);
            };
            infile = (i64)1;
            goto L198 ;
;
        };
        if (((u64)((*item)) == ':')) {
            colonseen = (u64)((i64)1);
            return (i64)4;
        };
    };
    (*value) = (byte *)(0);
    if (((u64)((*item)) == '-')) {
        (*name) = (item + (!!((u64)(colonseen))?(i64)0:(i64)1));
        q = (byte *)(strchr((i8 *)(item),(i64)58));
        if (!(!!(q))) {
            q = (byte *)(strchr((i8 *)(item),(i64)61));
        };
        if (!!(q)) {
            (*value) = (q + (i64)1);
            (*q) = (u64)0u;
        };
        return (!!((u64)(colonseen))?(i64)5:(i64)1);
    };
    fileext = mlib_extractext(item,(i64)0);
    (*name) = item;
    if (((i64)((*fileext)) == (i64)0)) {
        strcpy((i8 *)(str),(i8 *)((*name)));
        if ((!!(defext) && !(!!((u64)(colonseen))))) {
            (*name) = mlib_addext(str,defext);
        };
    } else if (!!(mlib_eqstring(fileext,(byte*)"dll"))) {
        return (!!((u64)(colonseen))?(i64)5:(i64)3);
    };
    return (!!((u64)(colonseen))?(i64)5:(i64)2);
}

static i64 mlib_readnextfileitem(byte * * fileptr,byte * * item) {
    byte *  p;
    byte *  pstart;
    byte *  pend;
    i64 n;
    static byte str[256];
    p = (*fileptr);
    //reenter:
L199 :;
;
    L200 :;
    while (1) {
        if (((i64)((*p))==(i64)32) || ((i64)((*p))==(i64)9) || ((i64)((*p))==(i64)13) || ((i64)((*p))==(i64)10)) {
            ++p;
        }else if (((i64)((*p))==(i64)26) || ((i64)((*p))==(i64)0)) {
            return (i64)0;
        } else {
            goto L201 ;
        };
    }L201 :;
    ;
    if (((i64)((*p))==(i64)33) || ((i64)((*p))==(i64)35)) {
        ++p;
        L202 :;
        if (((i64)((*p++))==(i64)10)) {
            goto L199 ;
;
        }else if (((i64)((*p++))==(i64)26) || ((i64)((*p++))==(i64)0)) {
            (*fileptr) = (p - (i64)1);
            return (i64)0;
        } else {
        }goto L202 ;
L203 :;
        ;
    };
    if (((i64)((*p))==(i64)34)) {
        pstart = ++p;
        L204 :;
        while (1) {
            if (((i64)((*p))==(i64)0) || ((i64)((*p))==(i64)26)) {
                msysnewc_m_print_startcon();
                msysnewc_m_print_str((byte*)"Unexpected EOF in @file",NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
                exit((i64)8);
            }else if (((i64)((*p))==(i64)34)) {
                pend = p++;
                if (((u64)((*p)) == ',')) {
                    ++p;
                };
                goto L205 ;
            };
            ++p;
        }L205 :;
        ;
    } else {
        pstart = p;
        L206 :;
        while (1) {
            if (((i64)((*p))==(i64)0) || ((i64)((*p))==(i64)26)) {
                pend = p;
                goto L207 ;
            }else if (((i64)((*p))==(i64)32) || ((i64)((*p))==(i64)9) || ((i64)((*p))==(i64)44) || ((i64)((*p))==(i64)13) || ((i64)((*p))==(i64)10)) {
                pend = p++;
                goto L207 ;
            };
            ++p;
        }L207 :;
        ;
    };
    n = (pend - pstart);
    if ((n >= (i64)256)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"@file item too long",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        exit((i64)9);
    };
    memcpy((void *)(str),(void *)(pstart),(u64)(n));
    str[((n + (i64)1))-1] = (u64)0u;
    (*item) = str;
    (*fileptr) = p;
    return (i64)1;
}

void mlib_ipadstr(byte * s,i64 width,byte * padchar) {
    i64 n;
    i64 av_1;
    n = (i64)(strlen((i8 *)(s)));
    av_1 = (width - n);
    while (av_1-- > 0) {
L208 :;
        strcat((i8 *)(s),(i8 *)(padchar));
L209 :;
    }L210 :;
    ;
}

byte * mlib_padstr(byte * s,i64 width,byte * padchar) {
    static byte str[256];
    strcpy((i8 *)(str),(i8 *)(s));
    mlib_ipadstr(str,width,padchar);
    return str;
}

byte * mlib_chr(i64 c) {
    static byte str[8];
    str[((i64)1)-1] = (u64)(c);
    str[((i64)2)-1] = (u64)0u;
    return str;
}

i64 mlib_cmpstring(byte * s,byte * t) {
    i64 res;
    if (((res = (i64)(strcmp((i8 *)(s),(i8 *)(t)))) < (i64)0)) {
        return (i64)-1;
    } else if ((res > (i64)0)) {
        return (i64)1;
    } else {
        return (i64)0;
    };
}

i64 mlib_cmpstringn(byte * s,byte * t,i64 n) {
    i64 res;
    if (((res = (i64)(strncmp((i8 *)(s),(i8 *)(t),(u64)(n)))) < (i64)0)) {
        return (i64)-1;
    } else if ((res > (i64)0)) {
        return (i64)1;
    } else {
        return (i64)0;
    };
}

i64 mlib_eqstring(byte * s,byte * t) {
    return ((i64)(strcmp((i8 *)(s),(i8 *)(t))) == (i64)0);
}

i64 mlib_cmpbytes(void * p,void * q,i64 n) {
    i64 res;
    if (((res = (i64)(memcmp(p,q,(u64)(n)))) < (i64)0)) {
        return (i64)-1;
    } else if ((res > (i64)0)) {
        return (i64)1;
    } else {
        return (i64)0;
    };
}

i64 mlib_eqbytes(void * p,void * q,i64 n) {
    return ((i64)(memcmp(p,q,(u64)(n))) == (i64)0);
}

void mlib_mseed(u64 a,u64 b) {
    mlib_seed[((i64)1)-1] = (i64)(a);
    if (!!(b)) {
        mlib_seed[((i64)2)-1] = (i64)(b);
    } else {
        mlib_seed[((i64)2)-1] ^= (i64)(a);
    };
}

u64 mlib_mrandom(void) {
    u64 x;
    u64 y;
    x = (u64)(mlib_seed[((i64)1)-1]);
    y = (u64)(mlib_seed[((i64)2)-1]);
    mlib_seed[((i64)1)-1] = (i64)(y);
    x ^= (x << (i64)23);
    mlib_seed[((i64)2)-1] = (i64)((((x ^ y) ^ (x >> (i64)17)) ^ (y >> (i64)26)));
    return (u64)((mlib_seed[((i64)2)-1] + (i64)(y)));
}

i64 mlib_mrandomp(void) {
    return (i64)((mlib_mrandom() & (u64)9223372036854775807u));
}

i64 mlib_mrandomint(i64 n) {
    return (mlib_mrandomp() % n);
}

i64 mlib_mrandomrange(i64 a,i64 b) {
    i64 span;
    span = ((b - a) + (i64)1);
    if ((span <= (i64)0)) {
        return (i64)0;
    };
    return ((mlib_mrandomp() % span) + a);
}

double mlib_mrandomreal(void) {
    double x;
    L211 :;
    do {
        x = ((double)(mlib_mrandomp()) / (double)9223372036854775800.);
L212 :;
    } while (!(x != (double)1.));L213 :;
    ;
    return x;
}

double mlib_mrandomreal1(void) {
    return (double)((mlib_mrandomp() / (i64)((u64)9223372036854775807u)));
}

byte * mlib_checkpackfile(void) {
    i64 a;
    i64 offset;
    byte exefile[300];
    byte *  packexeptr;
    i64 packexesize;
    byte *  packfilename;
    i64 packfilesize;
    byte *  packfileptr;
    strcpy((i8 *)(&exefile[((i64)1)-1]),(i8 *)(osnos_os_gethostname()));
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"Attempting to open",NULL);
    msysnewc_m_print_ptr(&exefile,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    packexeptr = mlib_readfile(&exefile[((i64)1)-1]);
    if (!(!!(packexeptr))) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"Can't open",NULL);
        msysnewc_m_print_ptr(&exefile,NULL);
        msysnewc_m_print_ptr(&packexeptr,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        exit(0);
    };
    packexesize = mlib_rfsize;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"File read OK. Size",NULL);
    msysnewc_m_print_i64(packexesize,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    a = (i64)((*(i32 *)((packexeptr + (packexesize - (i64)4)))));
    if ((a != (i64)1262568272)) {
        free((void *)(packexeptr));
        packfileptr = (byte *)(0);
        return (byte *)(0);
    };
    offset = (i64)((*(i32 *)((packexeptr + (packexesize - (i64)8)))));
    packfilename = (byte *)((packexeptr + offset));
    offset += ((i64)(strlen((i8 *)(packfilename))) + (i64)1);
    packfilesize = (i64)((*(i32 *)((packexeptr + offset))));
    packfileptr = ((packexeptr + offset) + (i64)4);
    return packfileptr;
}

void osnos_os_init(void) {
    osnos_init_flag = (i64)1;
}

i64 osnos_os_execwait(byte * cmdline,i64 newconsole,byte * workdir) {
    return (i64)(system((i8 *)(cmdline)));
}

i64 osnos_os_execcmd(byte * cmdline,i64 newconsole) {
    return (i64)(system((i8 *)(cmdline)));
}

i64 osnos_os_getch(void) {
    return (i64)0;
}

i64 osnos_os_kbhit(void) {
    mlib_abortprogram((byte*)"kbhit");
    return (i64)0;
}

void osnos_os_flushkeys(void) {
    mlib_abortprogram((byte*)"flushkeys");
}

void * osnos_os_getconsolein(void) {
    return 0;
}

void * osnos_os_getconsoleout(void) {
    return 0;
}

void * osnos_os_proginstance(void) {
    mlib_abortprogram((byte*)"PROGINST");
    return 0;
}

u64 osnos_os_getdllinst(byte * name) {
    return (u64)((i64)0);
}

void (*osnos_os_getdllprocaddr(i64 hinst,byte * name))(void) {
    static struct osnos_os_getdllprocaddr_rec table[23] = {
    {(byte*)"malloc",(void *)(&malloc)},
    {(byte*)"realloc",(void *)(&realloc)},
    {(byte*)"free",(void *)(&free)},
    {(byte*)"printf",(void *)(&printf)},
    {(byte*)"puts",(void *)(&puts)},
    {(byte*)"fgetc",(void *)(&fgetc)},
    {(byte*)"fputc",(void *)(&fputc)},
    {(byte*)"getchar",(void *)(&getchar)},
    {(byte*)"fopen",(void *)(&fopen)},
    {(byte*)"fclose",(void *)(&fclose)},
    {(byte*)"fseek",(void *)(&fseek)},
    {(byte*)"ftell",(void *)(&ftell)},
    {(byte*)"fread",(void *)(&fread)},
    {(byte*)"fwrite",(void *)(&fwrite)},
    {(byte*)"clock",(void *)(&clock)},
    {(byte*)"isalpha",(void *)(&isalpha)},
    {(byte*)"tolower",(void *)(&tolower)},
    {(byte*)"feof",(void *)(&feof)},
    {(byte*)"memset",(void *)(&memset)},
    {(byte*)"memcpy",(void *)(&memcpy)},
    {(byte*)"ungetc",(void *)(&ungetc)},
    {(byte*)"remove",(void *)(&remove)},
    {(byte*)"system",(void *)(&system)}
};
    i64 av_1;
    i64 i;
    L214 :;
    for (i=(i64)1;i<=(i64)23;i+=(i64)1) {
L215 :;
        if (!!(mlib_eqstring(table[(i)-1].name,name))) {
            return (void (*)(void))(table[(i)-1].addr);
        };
L216 :;
    }L217 :;
    ;
    return (void (*)(void))(0);
}

void osnos_os_initwindows(void) {
}

i64 osnos_os_getchx(void) {
    mlib_abortprogram((byte*)"getchx");
    return (i64)0;
}

byte * osnos_os_getos(void) {
    return (byte*)"NO-OS";
}

i64 osnos_os_getoscode(void) {
    return (i64)78;
}

i64 osnos_os_iswindows(void) {
    static i64 iswindows = (i64)-1;
    void *  f;
    if ((iswindows == (i64)-1)) {
        f = fopen((i8 *)((byte*)"c:/windows/notepad.exe"),(i8 *)((byte*)"rb"));
        if (!!(f)) {
            fclose(f);
            iswindows = (i64)1;
        } else {
            iswindows = (i64)0;
        };
    };
    return iswindows;
}

i64 osnos_os_shellexec(byte * opc,byte * file) {
    mlib_abortprogram((byte*)"SHELL EXEC");
    return (i64)0;
}

void osnos_os_sleep(i64 a) {
    mlib_abortprogram((byte*)"sleep");
}

void * osnos_os_getstdin(void) {
    return 0;
}

void * osnos_os_getstdout(void) {
    return 0;
}

byte * osnos_os_gethostname(void) {
    return (byte*)"";
}

i64 osnos_os_gethostsize(void) {
    return (i64)64;
}

byte * osnos_os_getmpath(void) {
    return (byte*)"";
}

void osnos_os_exitprocess(i64 x) {
    exit(0);
}

i64 osnos_os_gettimestamp(void) {
    return (i64)(clock());
}

i64 osnos_os_gettickcount(void) {
    return (i64)(clock());
}

i64 osnos_os_clock(void) {
    if (!!(osnos_os_iswindows())) {
        return (i64)(clock());
    } else {
        return ((i64)(clock()) / (i64)1000);
    };
}

i64 osnos_os_getclockspersec(void) {
    return (!!(osnos_os_iswindows())?(i64)1000:(i64)1000000);
}

void osnos_os_setmesshandler(void * addr) {
    mlib_abortprogram((byte*)"SETMESSHANDLER");
}

i64 osnos_os_filelastwritetime(byte * filename) {
    return (i64)0;
}

i64 osnos_os_hpcounter(void) {
    return (i64)1;
}

i64 osnos_os_hpfrequency(void) {
    return (i64)1;
}

void osnos_os_getsystime(void * tm) {
}

void osnos_os_peek(void) {
}

static void cc_support_stopcompiler(byte * filename,i64 lineno) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    exit((i64)1);
}

void cc_support_mcerror(byte * mess) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"MC Error:",NULL);
    msysnewc_m_print_str(mess,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    exit((i64)40);
}

void cc_support_serror(byte * mess) {
    cc_support_serror_gen(mess);
}

void cc_support_serror_gen(byte * mess) {
    if (!!(cc_decls_currproc)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"In function",NULL);
        msysnewc_m_print_str((*cc_decls_currproc).name,NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str((byte*)" ",NULL);
        msysnewc_m_print_end();
        ;
    };
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"On line",NULL);
    msysnewc_m_print_u64(cc_decls_lx.lineno,NULL);
    msysnewc_m_print_str((byte*)"in file",NULL);
    msysnewc_m_print_str(cc_decls_sourcefilepaths[((i64)(cc_decls_lx.fileno))],NULL);
    msysnewc_m_print_str(cc_decls_sourcefilenames[((i64)(cc_decls_lx.fileno))],NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    cc_support_showmacrolineno();
    msysnewc_m_print_startcon();
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"**** Syntax Error:",NULL);
    msysnewc_m_print_str(mess,NULL);
    msysnewc_m_print_str((byte*)"****",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    cc_support_stopcompiler(cc_decls_sourcefilepaths[((i64)(cc_decls_lx.fileno))],(i64)(cc_decls_lx.lineno));
}

void cc_support_serror_ss(byte * mess,byte * a,byte * b) {
    byte str[256];
    sprintf((i8 *)(str),(i8 *)(mess),a,b);
    cc_support_serror_gen(str);
}

void cc_support_serror_s(byte * mess,byte * a) {
    byte str[256];
    sprintf((i8 *)(str),(i8 *)(mess),a);
    cc_support_serror_gen(str);
}

void cc_support_terror_gen(byte * mess) {
    if (!!(cc_decls_currproc)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"In function",NULL);
        msysnewc_m_print_str((*cc_decls_currproc).name,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"Type error:",NULL);
    msysnewc_m_print_str(mess,NULL);
    msysnewc_m_print_str((byte*)"on line",NULL);
    msysnewc_m_print_u64(cc_decls_lx.lineno,NULL);
    msysnewc_m_print_str(cc_decls_sourcefilepaths[((i64)(cc_decls_lx.fileno))],NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    cc_support_showmacrolineno();
    cc_support_stopcompiler(cc_decls_sourcefilepaths[((i64)(cc_decls_lx.fileno))],(i64)(cc_decls_lx.lineno));
}

void cc_support_terror(byte * mess) {
    cc_support_terror_gen(mess);
}

void cc_support_terror_s(byte * mess,byte * a) {
    byte str[256];
    sprintf((i8 *)(str),(i8 *)(mess),a);
    cc_support_terror_gen(str);
}

void cc_support_terror_ss(byte * mess,byte * a,byte * b) {
    byte str[256];
    sprintf((i8 *)(str),(i8 *)(mess),a,b);
    cc_support_terror_gen(str);
}

void cc_support_gerror_gen(byte * mess,struct cc_decls_unitrec * p) {
    i64 lineno;
    if (!!(p)) {
        lineno = (i64)((*p).lineno);
    } else {
        lineno = cc_decls_clineno;
    };
    if (!!(cc_decls_currproc)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"In function",NULL);
        msysnewc_m_print_str((*cc_decls_currproc).name,NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str((byte*)" ",NULL);
        msysnewc_m_print_end();
        ;
    };
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"On line",NULL);
    msysnewc_m_print_i64((lineno & (i64)16777215),NULL);
    msysnewc_m_print_str((byte*)"in file",NULL);
    msysnewc_m_print_str(cc_decls_sourcefilepaths[((lineno >> (i64)24))],NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"**** Code Gen Error:",NULL);
    msysnewc_m_print_str(mess,NULL);
    msysnewc_m_print_str((byte*)"****",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    cc_support_stopcompiler(cc_decls_sourcefilepaths[((lineno >> (i64)24))],lineno);
}

void cc_support_gerror(byte * mess,struct cc_decls_unitrec * p) {
    cc_support_gerror_gen(mess,p);
}

void cc_support_gerror_s(byte * mess,byte * s,struct cc_decls_unitrec * p) {
    byte str[256];
    sprintf((i8 *)(str),(i8 *)(mess),s);
    cc_support_gerror_gen(str,p);
}

void cc_support_nxerror(byte * mess,struct cc_decls_unitrec * p) {
    i64 lineno;
    if (!!(p)) {
        lineno = (i64)((*p).lineno);
    } else {
        lineno = (i64)0;
    };
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"NX error:",NULL);
    msysnewc_m_print_str(mess,NULL);
    msysnewc_m_print_str((byte*)"on line",NULL);
    msysnewc_m_print_i64(lineno,NULL);
    msysnewc_m_print_str((*cc_decls_stmodule).name,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    cc_support_stopcompiler((*cc_decls_stmodule).name,lineno);
}

i64 cc_support_testelem(byte (*p)[],i64 n) {
    return (!!(((u64)((*p)[((n >> (i64)3))]) & (u64)(cc_support_bytemasks[((n & (i64)7))])))?(i64)1:(i64)0);
}

void cc_support_setelem(byte (*p)[],i64 n) {
    (*p)[((n >> (i64)3))] |= cc_support_bytemasks[((n & (i64)7))];
}

i64 cc_support_nextpoweroftwo(i64 x) {
    i64 a;
    if ((x == (i64)0)) {
        return (i64)0;
    };
    a = (i64)1;
    L218 :;
    while ((a < x)) {
        a <<= (i64)1;
L219 :;
    }L220 :;
    ;
    return a;
}

void cc_support_loaderror(byte * mess,byte * mess2) {
    byte str[512];
    sprintf((i8 *)(str),(i8 *)(mess),mess2);
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"Load Error:",NULL);
    msysnewc_m_print_str(str,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"Stopping",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    exit((i64)45);
}

i64 cc_support_loadfromstdin(byte * file) {
    byte src[30000];
    byte *  p;
    i64 n;
    i64 c;
    if ((cc_decls_nsourcefiles > (i64)600)) {
        cc_support_loaderror((byte*)"Too many source files",(byte*)"");
    };
    ++cc_decls_nsourcefiles;
    cc_decls_sourcefilepaths[(cc_decls_nsourcefiles)] = mlib_pcm_copyheapstring(file);
    cc_decls_sourcefilenames[(cc_decls_nsourcefiles)] = mlib_pcm_copyheapstring(file);
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"Reading from stdin. Finish with Ctrl-Z:",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    p = src;
    n = (i64)0;
    L221 :;
    while (((c = (i64)(getchar())) != (i64)-1)) {
        (*p++) = (u64)(c);
        if ((++n >= (i64)30000)) {
            cc_support_loaderror((byte*)"stdin overflow",(byte*)"");
        };
L222 :;
    }L223 :;
    ;
    (*p) = (u64)0u;
    cc_decls_sourcefiletext[(cc_decls_nsourcefiles)] = mlib_pcm_copyheapstring(src);
    cc_decls_sourcefilesizes[(cc_decls_nsourcefiles)] = (i64)(strlen((i8 *)(src)));
    return cc_decls_nsourcefiles;
}

i64 cc_support_loadsourcefile(byte * file,byte * shortfile) {
    byte *  s;
    if ((cc_decls_nsourcefiles > (i64)600)) {
        cc_support_loaderror((byte*)"Too many source files",(byte*)"");
    };
    ++cc_decls_nsourcefiles;
    cc_decls_sourcefilepaths[(cc_decls_nsourcefiles)] = mlib_pcm_copyheapstring(file);
    cc_decls_sourcefilenames[(cc_decls_nsourcefiles)] = mlib_pcm_copyheapstring(shortfile);
    s = (byte *)(mlib_readfile(file));
    if (!(!!(s))) {
        cc_support_loaderror((byte*)"LSF can't load ",file);
    };
    if (!!(cc_decls_flinesplicing)) {
        s = cc_support_splicelines(s);
    };
    cc_decls_sourcefiletext[(cc_decls_nsourcefiles)] = s;
    cc_decls_sourcefilesizes[(cc_decls_nsourcefiles)] = mlib_rfsize;
    (*(s + mlib_rfsize)) = (u64)0u;
    return cc_decls_nsourcefiles;
}

static byte * cc_support_splicelines(byte * s) {
    byte *  t;
    byte *  u;
    t = (u = (byte *)(mlib_pcm_alloc(((i64)(strlen((i8 *)(s))) + (i64)1))));
    L224 :;
    while (!!((u64)((*s)))) {
        if ((((u64)((*s)) == (u64)92u) && ((i64)((*(s + (i64)1))) == (i64)10))) {
            s += (i64)2;
        } else if (((((u64)((*s)) == (u64)92u) && ((i64)((*(s + (i64)1))) == (i64)13)) && ((i64)((*(s + (i64)2))) == (i64)10))) {
            s += (i64)3;
        } else {
            (*t++) = (u64)((*s++));
        };
        (*t) = (u64)0u;
L225 :;
    }L226 :;
    ;
    return u;
}

i64 cc_support_loadbuiltin(byte * shortfile,byte * hdrtext) {
    if ((cc_decls_nsourcefiles > (i64)600)) {
        cc_support_loaderror((byte*)"Too many source files",(byte*)"");
    };
    ++cc_decls_nsourcefiles;
    cc_decls_sourcefilepaths[(cc_decls_nsourcefiles)] = (byte*)"<builtin>";
    cc_decls_sourcefilenames[(cc_decls_nsourcefiles)] = mlib_pcm_copyheapstring(shortfile);
    cc_decls_sourcefiletext[(cc_decls_nsourcefiles)] = mlib_pcm_copyheapstring(hdrtext);
    cc_decls_sourcefilesizes[(cc_decls_nsourcefiles)] = (i64)(strlen((i8 *)(hdrtext)));
    return cc_decls_nsourcefiles;
}

static void cc_support_gs_copytostr(struct mlib_strbuffer * source,byte * s) {
    if (!!((i64)((*source).length))) {
        memcpy((void *)(s),(void *)((*source).strptr),(u64)((*source).length));
        (*(s + (i64)((*source).length))) = (u64)0u;
    } else {
        (*s) = (u64)0u;
    };
}

void cc_support_gs_additem(struct mlib_strbuffer * dest,byte * s) {
    byte *  d;
    i64 lastchar;
    i64 nextchar;
    d = (*dest).strptr;
    if (!!((i64)((*dest).length))) {
        lastchar = (i64)((*((d + (i64)((*dest).length)) - (i64)1)));
        nextchar = (i64)((*s));
        if ((!!(cc_support_isalphanum(lastchar)) && !!(cc_support_isalphanum(nextchar)))) {
            mlib_strbuffer_add(dest,(byte*)" ",(i64)-1);
        };
    };
    mlib_strbuffer_add(dest,s,(i64)-1);
}

static i64 cc_support_isalphanum(i64 c) {
    if (((((c >= (i64)65) && (c <= (i64)90)) || ((c >= (i64)97) && (c <= (i64)122))) || ((c >= (i64)48) && (c <= (i64)57)))) {
        return (i64)1;
    };
    return (i64)0;
}

static void cc_support_showmacrolineno(void) {
    if (!!(cc_decls_slineno)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"\t(Last macro invoked near line",NULL);
        msysnewc_m_print_i64(cc_decls_slineno,NULL);
        msysnewc_m_print_str((byte*)"in file",NULL);
        msysnewc_m_print_str(cc_decls_sourcefilenames[(cc_decls_sfileno)],NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str((byte*)")",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
}

void cc_lex_lex_preprocess_only(byte * infile,i64 showtokens,i64 nn,i64 toconsole) {
    byte *  psource;
    i64 ntokens;
    i64 nlines;
    i64 fileno;
    i64 size;
    i64 t;
    i64 hashtot;
    i64 symtot;
    static struct mlib_strbuffer sbuffer;
    static struct mlib_strbuffer *  dest = &sbuffer;
    void *  f;
    byte outfile[300];
    cc_lex_dowhitespace = (i64)1;
    fileno = cc_support_loadsourcefile(infile,infile);
    strcpy((i8 *)(outfile),(i8 *)(mlib_changeext(infile,(byte*)"i")));
    psource = cc_decls_sourcefiletext[(fileno)];
    size = (i64)(cc_decls_sourcefilesizes[(fileno)]);
    nlines = (ntokens = (i64)0);
    hashtot = (symtot = (i64)0);
    t = osnos_os_clock();
    cc_lex_destcopy = dest;
    mlib_gs_init(dest);
    cc_lex_lxsptr = psource;
    cc_lex_lxstart = cc_lex_lxsptr;
    cc_decls_nextlx.lineno = (u64)((i64)1);
    cc_lex_setfileno((i64)1);
    cc_lex_ifcondlevel = (i64)0;
    cc_lex_stacksourcefile((byte*)"bcc.h",(i64)1);
    cc_decls_nextlx.symbol = (u64)((i64)57);
    L227 :;
    do {
        cc_lex_lexm();
        ++ntokens;
        if (!!(showtokens)) {
            cc_lex_emittoken(&cc_decls_nextlx,dest,(i64)0);
        };
L228 :;
    } while (!((i64)((u64)(cc_decls_nextlx.symbol)) == (i64)58));L229 :;
    ;
    if (!!(cc_lex_ifcondlevel)) {
        cc_lex_lxerror((byte*)"#endif missing");
    };
    if (!!(showtokens)) {
        if (!!(toconsole)) {
            mlib_gs_println(dest,0);
        } else {
            f = fopen((i8 *)(outfile),(i8 *)((byte*)"wb"));
            mlib_gs_println(dest,f);
            fclose(f);
        };
    };
}

void cc_lex_lexreadtoken(void) {
    u64 c;
    u64 hsum;
    byte *  ss;
    cc_decls_nextlx.subcodex = (u64)((i64)0);
    L230 :;
    switch ((i64)((*cc_lex_lxsptr++))) {
    case 65:;
    case 66:;
    case 67:;
    case 68:;
    case 69:;
    case 70:;
    case 71:;
    case 72:;
    case 73:;
    case 74:;
    case 75:;
    case 76:;
    case 77:;
    case 78:;
    case 79:;
    case 80:;
    case 81:;
    case 82:;
    case 83:;
    case 84:;
    case 85:;
    case 86:;
    case 87:;
    case 88:;
    case 89:;
    case 90:;
    case 97:;
    case 98:;
    case 99:;
    case 100:;
    case 101:;
    case 102:;
    case 103:;
    case 104:;
    case 105:;
    case 106:;
    case 107:;
    case 108:;
    case 109:;
    case 110:;
    case 111:;
    case 112:;
    case 113:;
    case 114:;
    case 115:;
    case 116:;
    case 117:;
    case 118:;
    case 119:;
    case 120:;
    case 121:;
    case 122:;
    case 36:;
    case 95:;
    {
        //doname:
L232 :;
;
        cc_lex_lxsvalue = (cc_lex_lxsptr - (i64)1);
        hsum = (u64)((*cc_lex_lxsvalue));
        L233 :;
        while (!!((u64)(cc_lex_alphamap[((i64)((c = (u64)((*cc_lex_lxsptr++)))))]))) {
            hsum = (((hsum << (i64)4) - hsum) + c);
L234 :;
        }L235 :;
        ;
        --cc_lex_lxsptr;
        cc_decls_nextlx.symbol = (u64)((i64)69);
        cc_decls_nextlx.length = (cc_lex_lxsptr - cc_lex_lxsvalue);
        if ((c==(u64)39u) || (c==(u64)34u)) {
            if (((i64)(cc_decls_nextlx.length) == (i64)1)) {
                if (((i64)((*cc_lex_lxsvalue))==(i64)108) || ((i64)((*cc_lex_lxsvalue))==(i64)76) || ((i64)((*cc_lex_lxsvalue))==(i64)117) || ((i64)((*cc_lex_lxsvalue))==(i64)85)) {
                    ++cc_lex_lxsptr;
                    cc_lex_lxreadstring((i64)(c),(i64)1);
                    return;
                };
            };
        };
        cc_lex_lxhashvalue = (i64)(((hsum << (i64)5) - hsum));
        ss = (byte *)(mlib_pcm_alloc(((i64)(cc_decls_nextlx.length) + (i64)1)));
        memcpy((void *)(ss),(void *)(cc_lex_lxsvalue),(u64)(cc_decls_nextlx.length));
        (*(ss + (i64)(cc_decls_nextlx.length))) = (u64)0u;
        cc_lex_lxsvalue = ss;
        cc_lex_lookup();
        return;
    }break;
    case 49:;
    case 50:;
    case 51:;
    case 52:;
    case 53:;
    case 54:;
    case 55:;
    case 56:;
    case 57:;
    {
        if (((i64)((*cc_lex_lxsptr))==(i64)32) || ((i64)((*cc_lex_lxsptr))==(i64)41) || ((i64)((*cc_lex_lxsptr))==(i64)13) || ((i64)((*cc_lex_lxsptr))==(i64)44) || ((i64)((*cc_lex_lxsptr))==(i64)59)) {
            cc_decls_nextlx.symbol = (u64)((i64)60);
            cc_decls_nextlx.subcode = (u64)((i64)4);
            cc_decls_nextlx.value = ((u64)((*(cc_lex_lxsptr - (i64)1))) - '0');
            cc_decls_nextlx.length = (i64)1;
            cc_lex_setnumberoffset(((cc_lex_lxsptr - (i64)1) - cc_lex_lxstart));
        } else {
            cc_lex_readdecimal((cc_lex_lxsptr - (i64)1));
        };
        return;
    }break;
    case 48:;
    {
        switch ((i64)((*cc_lex_lxsptr))) {
        case 120:;
        case 88:;
        {
            ++cc_lex_lxsptr;
            cc_lex_readhex((cc_lex_lxsptr - (i64)2));
            return;
        }break;
        case 98:;
        case 66:;
        {
            ++cc_lex_lxsptr;
            cc_lex_readbinary((cc_lex_lxsptr - (i64)2));
            return;
        }break;
        case 46:;
        {
            cc_lex_readrealnumber((cc_lex_lxsptr - (i64)1),(cc_lex_lxsptr - (i64)1),(i64)1,(i64)10);
            return;
        }break;
        case 117:;
        case 85:;
        case 108:;
        case 76:;
        {
            cc_lex_readdecimal((cc_lex_lxsptr - (i64)1));
            return;
        }break;
        case 44:;
        case 41:;
        case 93:;
        case 125:;
        case 59:;
        case 32:;
        case 58:;
        case 13:;
        case 10:;
        case 38:;
        case 61:;
        case 63:;
        {
            cc_decls_nextlx.symbol = (u64)((i64)60);
            cc_decls_nextlx.subcode = (u64)((i64)4);
            cc_decls_nextlx.value = (i64)0;
            cc_decls_nextlx.length = (i64)1;
            cc_lex_setnumberoffset(((cc_lex_lxsptr - (i64)1) - cc_lex_lxstart));
            return;
        }break;
        default: {
            cc_lex_readoctal((cc_lex_lxsptr - (i64)1));
            return;
        }
        } //SW
;
    }break;
    case 35:;
    {
        if (((i64)((u64)(cc_decls_nextlx.symbol)) == (i64)57)) {
            cc_decls_nextlx.symbol = (u64)((i64)4);
            return;
        } else if (((u64)((*cc_lex_lxsptr)) == '#')) {
            ++cc_lex_lxsptr;
            cc_decls_nextlx.symbol = (u64)((i64)7);
            return;
        } else {
            cc_decls_nextlx.symbol = (u64)((i64)5);
            return;
        };
    }break;
    case 92:;
    {
        L236 :;
        if (((i64)((*cc_lex_lxsptr))==(i64)13) || ((i64)((*cc_lex_lxsptr))==(i64)10)) {
            goto L237 ;
        }else if (((i64)((*cc_lex_lxsptr))==(i64)32) || ((i64)((*cc_lex_lxsptr))==(i64)9)) {
            ++cc_lex_lxsptr;
        } else {
            cc_decls_nextlx.symbol = (u64)((i64)22);
            return;
        }goto L236 ;
L237 :;
        ;
        (*(cc_lex_lxsptr - (i64)1)) = ' ';
        ++cc_decls_nextlx.lineno;
        if (((i64)((*cc_lex_lxsptr))==(i64)13)) {
            ++cc_lex_lxsptr;
            (*cc_lex_lxsptr++) = ' ';
        }else if (((i64)((*cc_lex_lxsptr))==(i64)10)) {
            (*cc_lex_lxsptr++) = ' ';
        } else {
        };
    }break;
    case 123:;
    {
        cc_decls_nextlx.symbol = (u64)((i64)17);
        return;
    }break;
    case 125:;
    {
        cc_decls_nextlx.symbol = (u64)((i64)18);
        return;
    }break;
    case 46:;
    {
        switch ((i64)((*cc_lex_lxsptr))) {
        case 46:;
        {
            ++cc_lex_lxsptr;
            if (((u64)((*cc_lex_lxsptr)) == '.')) {
                ++cc_lex_lxsptr;
                cc_decls_nextlx.symbol = (u64)((i64)21);
            } else {
                --cc_lex_lxsptr;
                cc_decls_nextlx.symbol = (u64)((i64)2);
                return;
            };
            return;
        }break;
        case 48:;
        case 49:;
        case 50:;
        case 51:;
        case 52:;
        case 53:;
        case 54:;
        case 55:;
        case 56:;
        case 57:;
        {
            --cc_lex_lxsptr;
            cc_lex_readrealnumber(cc_lex_lxsptr,cc_lex_lxsptr,(i64)0,(i64)10);
            return;
        }break;
        default: {
            cc_decls_nextlx.symbol = (u64)((i64)2);
            return;
        }
        } //SW
;
    }break;
    case 44:;
    {
        cc_decls_nextlx.symbol = (u64)((i64)8);
        return;
    }break;
    case 59:;
    {
        cc_decls_nextlx.symbol = (u64)((i64)9);
        return;
    }break;
    case 58:;
    {
        if (((i64)((*cc_lex_lxsptr))==(i64)61)) {
            ++cc_lex_lxsptr;
            cc_decls_nextlx.symbol = (u64)((i64)11);
        } else {
            cc_decls_nextlx.symbol = (u64)((i64)10);
        };
        return;
    }break;
    case 40:;
    {
        cc_decls_nextlx.symbol = (u64)((i64)13);
        return;
    }break;
    case 41:;
    {
        cc_decls_nextlx.symbol = (u64)((i64)14);
        return;
    }break;
    case 91:;
    {
        cc_decls_nextlx.symbol = (u64)((i64)15);
        return;
    }break;
    case 93:;
    {
        cc_decls_nextlx.symbol = (u64)((i64)16);
        return;
    }break;
    case 124:;
    {
        if (((i64)((*cc_lex_lxsptr))==(i64)124)) {
            ++cc_lex_lxsptr;
            cc_decls_nextlx.symbol = (u64)((i64)31);
        }else if (((i64)((*cc_lex_lxsptr))==(i64)61)) {
            ++cc_lex_lxsptr;
            cc_decls_nextlx.symbol = (u64)((i64)51);
        } else {
            cc_decls_nextlx.symbol = (u64)((i64)28);
        };
        return;
    }break;
    case 94:;
    {
        if (((u64)((*cc_lex_lxsptr)) == '=')) {
            ++cc_lex_lxsptr;
            cc_decls_nextlx.symbol = (u64)((i64)53);
        } else {
            cc_decls_nextlx.symbol = (u64)((i64)30);
        };
        return;
    }break;
    case 63:;
    {
        cc_decls_nextlx.symbol = (u64)((i64)19);
        return;
    }break;
    case 126:;
    {
        cc_decls_nextlx.symbol = (u64)((i64)35);
        return;
    }break;
    case 43:;
    {
        if (((i64)((*cc_lex_lxsptr))==(i64)43)) {
            ++cc_lex_lxsptr;
            cc_decls_nextlx.symbol = (u64)((i64)37);
        }else if (((i64)((*cc_lex_lxsptr))==(i64)61)) {
            ++cc_lex_lxsptr;
            cc_decls_nextlx.symbol = (u64)((i64)46);
        } else {
            cc_decls_nextlx.symbol = (u64)((i64)23);
        };
        return;
    }break;
    case 45:;
    {
        if (((i64)((*cc_lex_lxsptr))==(i64)45)) {
            ++cc_lex_lxsptr;
            cc_decls_nextlx.symbol = (u64)((i64)38);
        }else if (((i64)((*cc_lex_lxsptr))==(i64)62)) {
            ++cc_lex_lxsptr;
            cc_decls_nextlx.symbol = (u64)((i64)3);
        }else if (((i64)((*cc_lex_lxsptr))==(i64)61)) {
            ++cc_lex_lxsptr;
            cc_decls_nextlx.symbol = (u64)((i64)47);
        } else {
            cc_decls_nextlx.symbol = (u64)((i64)24);
        };
        return;
    }break;
    case 42:;
    {
        if (((u64)((*cc_lex_lxsptr)) == '=')) {
            ++cc_lex_lxsptr;
            cc_decls_nextlx.symbol = (u64)((i64)48);
        } else {
            cc_decls_nextlx.symbol = (u64)((i64)25);
        };
        return;
    }break;
    case 47:;
    {
        if (((i64)((*cc_lex_lxsptr))==(i64)47)) {
            cc_lex_readlinecomment();
            cc_decls_nextlx.symbol = (u64)((i64)57);
            cc_decls_nextlx.length = (i64)0;
            return;
        }else if (((i64)((*cc_lex_lxsptr))==(i64)42)) {
            cc_lex_readblockcomment();
        }else if (((i64)((*cc_lex_lxsptr))==(i64)61)) {
            ++cc_lex_lxsptr;
            cc_decls_nextlx.symbol = (u64)((i64)49);
            return;
        } else {
            cc_decls_nextlx.symbol = (u64)((i64)26);
            return;
        };
    }break;
    case 37:;
    {
        if (((u64)((*cc_lex_lxsptr)) == '=')) {
            ++cc_lex_lxsptr;
            cc_decls_nextlx.symbol = (u64)((i64)50);
        } else {
            cc_decls_nextlx.symbol = (u64)((i64)27);
        };
        return;
    }break;
    case 61:;
    {
        if (((i64)((*cc_lex_lxsptr))==(i64)61)) {
            cc_decls_nextlx.symbol = (u64)((i64)40);
            ++cc_lex_lxsptr;
        } else {
            cc_decls_nextlx.symbol = (u64)((i64)11);
        };
        return;
    }break;
    case 60:;
    {
        switch ((i64)((*cc_lex_lxsptr))) {
        case 61:;
        {
            ++cc_lex_lxsptr;
            cc_decls_nextlx.symbol = (u64)((i64)43);
        }break;
        case 60:;
        {
            if (((u64)((*++cc_lex_lxsptr)) == '=')) {
                ++cc_lex_lxsptr;
                cc_decls_nextlx.symbol = (u64)((i64)54);
            } else {
                cc_decls_nextlx.symbol = (u64)((i64)33);
            };
        }break;
        default: {
            cc_decls_nextlx.symbol = (u64)((i64)42);
        }
        } //SW
;
        return;
    }break;
    case 62:;
    {
        switch ((i64)((*cc_lex_lxsptr))) {
        case 61:;
        {
            ++cc_lex_lxsptr;
            cc_decls_nextlx.symbol = (u64)((i64)44);
        }break;
        case 62:;
        {
            if (((u64)((*++cc_lex_lxsptr)) == '=')) {
                ++cc_lex_lxsptr;
                cc_decls_nextlx.symbol = (u64)((i64)55);
            } else {
                cc_decls_nextlx.symbol = (u64)((i64)34);
            };
        }break;
        default: {
            cc_decls_nextlx.symbol = (u64)((i64)45);
        }
        } //SW
;
        return;
    }break;
    case 38:;
    {
        if (((i64)((*cc_lex_lxsptr))==(i64)38)) {
            ++cc_lex_lxsptr;
            cc_decls_nextlx.symbol = (u64)((i64)32);
        }else if (((i64)((*cc_lex_lxsptr))==(i64)61)) {
            ++cc_lex_lxsptr;
            cc_decls_nextlx.symbol = (u64)((i64)52);
        } else {
            cc_decls_nextlx.symbol = (u64)((i64)29);
        };
        return;
    }break;
    case 39:;
    {
        cc_lex_lxreadstring((i64)39,(i64)0);
        return;
    }break;
    case 34:;
    {
        cc_lex_lxreadstring((i64)34,(i64)0);
        return;
    }break;
    case 32:;
    case 9:;
    {
    }break;
    case 10:;
    {
        ++cc_decls_nextlx.lineno;
        cc_decls_nextlx.symbol = (u64)((i64)57);
        cc_decls_nextlx.length = (i64)0;
        if (!!(cc_lex_dowhitespace)) {
            cc_decls_nextlx.svalue = cc_lex_lxsptr;
            L238 :;
            switch ((i64)((*cc_lex_lxsptr++))) {
            case 32:;
            case 9:;
            {
            }break;
            default: {
                --cc_lex_lxsptr;
                goto L239 ;
            }
            } //SW
goto L238 ;
L239 :;
            ;
            cc_decls_nextlx.length = (cc_lex_lxsptr - cc_decls_nextlx.svalue);
        };
        return;
    }break;
    case 13:;
    {
    }break;
    case 33:;
    {
        if (((i64)((*cc_lex_lxsptr))==(i64)61)) {
            cc_decls_nextlx.symbol = (u64)((i64)41);
            ++cc_lex_lxsptr;
        } else {
            cc_decls_nextlx.symbol = (u64)((i64)36);
        };
        return;
    }break;
    case 64:;
    {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"@ SEEN",NULL);
        msysnewc_m_print_u64(cc_decls_nextlx.lineno,NULL);
        msysnewc_m_print_str(cc_decls_sourcefilenames[((i64)(cc_decls_nextlx.fileno))],NULL);
        msysnewc_m_print_i64(cc_lex_lx_stackindex,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    }break;
    case 0:;
    {
        //doeof:
L240 :;
;
        --cc_lex_lxsptr;
        if (!!(cc_lex_lx_stackindex)) {
            cc_lex_unstacksourcefile();
            cc_decls_nextlx.symbol = (u64)((i64)57);
        } else {
            cc_decls_nextlx.symbol = (u64)((i64)58);
        };
        return;
    }break;
    case 12:;
    {
    }break;
    case 239:;
    {
        cc_lex_lxsptr += (i64)2;
    }break;
    default: {
        if ((((i64)128 <= (i64)((*(cc_lex_lxsptr - (i64)1)))) && ((i64)((*(cc_lex_lxsptr - (i64)1))) <= (i64)255))) {
            goto L232 ;
;
        };
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"ERROR CHAR",NULL);
        msysnewc_m_print_c8((*(cc_lex_lxsptr - (i64)1)),NULL);
        msysnewc_m_print_i64((i64)((*(cc_lex_lxsptr - (i64)1))),NULL);
        msysnewc_m_print_i64(cc_lex_lx_stackindex,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        cc_lex_lxerror((byte*)"ERROR CHAR");
        cc_decls_nextlx.symbol = (u64)((i64)1);
        return;
    }
    } //SW
goto L230 ;
L231 :;
    ;
}

static void cc_lex_readrealnumber(byte * pstart,byte * intstart,i64 intlen,i64 base) {
    byte *  fractstart;
    i64 fractlen;
    i64 expon;
    i64 badexpon;
    double basex;
    double x;
    double expbase;
    i64 pref;
    byte realstr[512];
    byte *  rs;
    byte expstr[32];
    if ((base != (i64)10)) {
        cc_lex_old_readrealnumber(pstart,intstart,intlen,base);
        return;
    };
    fractstart = (byte *)(0);
    fractlen = (i64)0;
    expon = (i64)0;
    if (((u64)((*cc_lex_lxsptr)) == '.')) {
        fractstart = ++cc_lex_lxsptr;
        fractlen = (cc_lex_scannumber(base) - fractstart);
    };
    badexpon = (i64)0;
    if (((i64)((*cc_lex_lxsptr))==(i64)101) || ((i64)((*cc_lex_lxsptr))==(i64)69)) {
        if ((base != (i64)16)) {
            ++cc_lex_lxsptr;
            expon = cc_lex_readexponent(&badexpon);
        };
    }else if (((i64)((*cc_lex_lxsptr))==(i64)112) || ((i64)((*cc_lex_lxsptr))==(i64)80)) {
        if ((base == (i64)16)) {
            ++cc_lex_lxsptr;
            expon = cc_lex_readexponent(&badexpon);
        };
    };
    if (!!(badexpon)) {
        --cc_lex_lxsptr;
        cc_lex_readalphanumeric(pstart);
        return;
    };
    if (((i64)((*cc_lex_lxsptr))==(i64)102) || ((i64)((*cc_lex_lxsptr))==(i64)70) || ((i64)((*cc_lex_lxsptr))==(i64)108) || ((i64)((*cc_lex_lxsptr))==(i64)76)) {
        ++cc_lex_lxsptr;
    } else {
        if (!!((u64)(cc_lex_alphamap[((i64)((*cc_lex_lxsptr)))]))) {
            cc_lex_readalphanumeric(pstart);
            return;
        };
    };
    if ((base == (i64)16)) {
        realstr[((i64)1)-1] = '0';
        realstr[((i64)2)-1] = 'x';
        rs = &realstr[((i64)3)-1];
        pref = (i64)2;
    } else {
        rs = &realstr[((i64)1)-1];
        pref = (i64)0;
    };
    if (((intlen + fractlen) > (i64)500)) {
        cc_lex_lxerror((byte*)"Real too long");
    };
    if (!!(intlen)) {
        memcpy((void *)(rs),(void *)(intstart),(u64)(intlen));
    };
    if (!!(fractlen)) {
        memcpy((void *)((rs + intlen)),(void *)(fractstart),(u64)(fractlen));
    };
    expbase = (basex = (double)(base));
    if ((base == (i64)10)) {
        expon -= fractlen;
    } else {
        expon -= (fractlen * (i64)4);
        expbase = (double)2.;
    };
    realstr[((((pref + intlen) + fractlen) + (i64)1))-1] = (u64)0u;
    msysnewc_m_print_startstr(expstr);
    msysnewc_m_print_str(((base == (i64)10)?(byte*)"e":(byte*)"p"),NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_i64(expon,NULL);
    msysnewc_m_print_end();
    ;
    strcat((i8 *)(realstr),(i8 *)(expstr));
    if ((base != (i64)10)) {
        cc_lex_lxerror((byte*)"Non-base-10 floats temporarily unavailable");
    };
    x = strtod((i8 *)(realstr),0);
    cc_decls_nextlx.symbol = (u64)((i64)61);
    cc_decls_nextlx.subcode = (u64)((i64)12);
    cc_decls_nextlx.xvalue = x;
    cc_lex_setnumberoffset((intstart - cc_lex_lxstart));
    cc_decls_nextlx.length = (cc_lex_lxsptr - intstart);
}

static i64 cc_lex_readexponent(i64 * badexpon) {
    byte *  numstart;
    i64 length;
    i64 neg;
    i64 c;
    i64 a;
    i64 av_1;
    neg = (i64)0;
    if (((i64)((*cc_lex_lxsptr))==(i64)43)) {
        ++cc_lex_lxsptr;
    }else if (((i64)((*cc_lex_lxsptr))==(i64)45)) {
        ++cc_lex_lxsptr;
        neg = (i64)1;
    };
    numstart = cc_lex_lxsptr;
    length = (cc_lex_scannumber((i64)10) - numstart);
    if ((length == (i64)0)) {
        (*badexpon) = (i64)1;
        return (i64)0;
    };
    a = (i64)0;
    av_1 = length;
    while (av_1-- > 0) {
L241 :;
        c = (i64)((*numstart++));
        a = (((a * (i64)10) + c) - (i64)48);
L242 :;
    }L243 :;
    ;
    return (!!(neg)?-(a):a);
}

static void cc_lex_lxerror(byte * mess) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"Lex error",NULL);
    msysnewc_m_print_str(mess,NULL);
    msysnewc_m_print_str((byte*)"in:",NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_str(cc_decls_sourcefilepaths[(cc_lex_getfileno())],NULL);
    msysnewc_m_print_str((byte*)"Line:",NULL);
    msysnewc_m_print_u64(cc_decls_nextlx.lineno,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    osnos_os_getch();
    exit((i64)11);
}

void cc_lex_printsymbol(struct cc_decls_tokenrec * lp) {
    struct cc_decls_tokenrec l;
    l = (*lp);
    printf((i8 *)((byte*)"%-18s"),cc_tables_symbolnames[((i64)(l.symbol))-1]);
    if (((i64)(l.symbol)==(i64)69)) {
        cc_lex_printstrn((*l.symptr).name,(i64)((*l.symptr).namelen),0);
    }else if (((i64)(l.symbol)==(i64)60)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_i64(l.value,NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str((byte*)" ",NULL);
        msysnewc_m_print_end();
        ;
        cc_lex_shownumberstr(lp,0);
    }else if (((i64)(l.symbol)==(i64)61)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_r64(l.xvalue,NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str((byte*)" ",NULL);
        msysnewc_m_print_end();
        ;
        cc_lex_shownumberstr(lp,0);
    }else if (((i64)(l.symbol)==(i64)64)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"\"",NULL);
        msysnewc_m_print_end();
        ;
        cc_lex_printstrn(l.svalue,(i64)(l.length),0);
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"\"",NULL);
        msysnewc_m_print_end();
        ;
    }else if (((i64)(l.symbol)==(i64)62)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"'",NULL);
        msysnewc_m_print_end();
        ;
        cc_lex_printstrn(l.svalue,(i64)(l.length),0);
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"'",NULL);
        msysnewc_m_print_end();
        ;
    } else {
        if (!!((u64)(l.subcode))) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((byte*)"#",NULL);
            msysnewc_m_print_u64(l.subcode,NULL);
            msysnewc_m_print_end();
            ;
        };
    };
    msysnewc_m_print_startcon();
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
}

void cc_lex_lexsetup(void) {
    i64 i;
    cc_lex_inithashtable();
    cc_lex_fillhashtable();
    L244 :;
    for (i=(i64)0;i<=(i64)255;i+=(i64)1) {
L245 :;
        switch (i) {
        case 65:;
        case 66:;
        case 67:;
        case 68:;
        case 69:;
        case 70:;
        case 71:;
        case 72:;
        case 73:;
        case 74:;
        case 75:;
        case 76:;
        case 77:;
        case 78:;
        case 79:;
        case 80:;
        case 81:;
        case 82:;
        case 83:;
        case 84:;
        case 85:;
        case 86:;
        case 87:;
        case 88:;
        case 89:;
        case 90:;
        case 97:;
        case 98:;
        case 99:;
        case 100:;
        case 101:;
        case 102:;
        case 103:;
        case 104:;
        case 105:;
        case 106:;
        case 107:;
        case 108:;
        case 109:;
        case 110:;
        case 111:;
        case 112:;
        case 113:;
        case 114:;
        case 115:;
        case 116:;
        case 117:;
        case 118:;
        case 119:;
        case 120:;
        case 121:;
        case 122:;
        case 36:;
        case 95:;
        case 48:;
        case 49:;
        case 50:;
        case 51:;
        case 52:;
        case 53:;
        case 54:;
        case 55:;
        case 56:;
        case 57:;
        case 128:;
        case 129:;
        case 130:;
        case 131:;
        case 132:;
        case 133:;
        case 134:;
        case 135:;
        case 136:;
        case 137:;
        case 138:;
        case 139:;
        case 140:;
        case 141:;
        case 142:;
        case 143:;
        case 144:;
        case 145:;
        case 146:;
        case 147:;
        case 148:;
        case 149:;
        case 150:;
        case 151:;
        case 152:;
        case 153:;
        case 154:;
        case 155:;
        case 156:;
        case 157:;
        case 158:;
        case 159:;
        case 160:;
        case 161:;
        case 162:;
        case 163:;
        case 164:;
        case 165:;
        case 166:;
        case 167:;
        case 168:;
        case 169:;
        case 170:;
        case 171:;
        case 172:;
        case 173:;
        case 174:;
        case 175:;
        case 176:;
        case 177:;
        case 178:;
        case 179:;
        case 180:;
        case 181:;
        case 182:;
        case 183:;
        case 184:;
        case 185:;
        case 186:;
        case 187:;
        case 188:;
        case 189:;
        case 190:;
        case 191:;
        case 192:;
        case 193:;
        case 194:;
        case 195:;
        case 196:;
        case 197:;
        case 198:;
        case 199:;
        case 200:;
        case 201:;
        case 202:;
        case 203:;
        case 204:;
        case 205:;
        case 206:;
        case 207:;
        case 208:;
        case 209:;
        case 210:;
        case 211:;
        case 212:;
        case 213:;
        case 214:;
        case 215:;
        case 216:;
        case 217:;
        case 218:;
        case 219:;
        case 220:;
        case 221:;
        case 222:;
        case 223:;
        case 224:;
        case 225:;
        case 226:;
        case 227:;
        case 228:;
        case 229:;
        case 230:;
        case 231:;
        case 232:;
        case 233:;
        case 234:;
        case 235:;
        case 236:;
        case 237:;
        case 238:;
        case 239:;
        case 240:;
        case 241:;
        case 242:;
        case 243:;
        case 244:;
        case 245:;
        case 246:;
        case 247:;
        case 248:;
        case 249:;
        case 250:;
        case 251:;
        case 252:;
        case 253:;
        case 254:;
        case 255:;
        {
            cc_lex_alphamap[(i)] = (u64)1u;
        }break;
        default: {
        }
        } //SW
;
        switch (i) {
        case 48:;
        case 49:;
        case 50:;
        case 51:;
        case 52:;
        case 53:;
        case 54:;
        case 55:;
        case 56:;
        case 57:;
        {
            cc_lex_digitmap[(i)] = (u64)1u;
        }break;
        default: {
        }
        } //SW
;
        cc_lex_commentmap[(i)] = (u64)1u;
        cc_lex_linecommentmap[(i)] = (u64)1u;
        cc_lex_spacemap[(i)] = (u64)0u;
L246 :;
    }L247 :;
    ;
    cc_lex_commentmap[((i64)42)] = (u64)0u;
    cc_lex_commentmap[((i64)0)] = (u64)0u;
    cc_lex_commentmap[((i64)10)] = (u64)0u;
    cc_lex_linecommentmap[((i64)0)] = (u64)0u;
    cc_lex_linecommentmap[((i64)92)] = (u64)0u;
    cc_lex_linecommentmap[((i64)10)] = (u64)0u;
    cc_lex_spacemap[((i64)32)] = (u64)1u;
    cc_lex_spacemap[((i64)9)] = (u64)1u;
    cc_lex_normaltkx.symbol = (u64)((i64)57);
    cc_lex_npastedtokens = (i64)0;
}

void cc_lex_printstrn(byte * s,i64 length,void * f) {
    if (!!(length)) {
        if ((f == 0)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_i64(length,(byte*)"v");
            msysnewc_m_print_nogap();
            msysnewc_m_print_str(s,(byte*)".*");
            msysnewc_m_print_end();
            ;
        } else {
            msysnewc_m_print_startfile(f);
            msysnewc_m_print_i64(length,(byte*)"v");
            msysnewc_m_print_nogap();
            msysnewc_m_print_str(s,(byte*)".*");
            msysnewc_m_print_end();
            ;
        };
    };
}

static byte * cc_lex_scannumber(i64 base) {
    byte *  dest;
    i64 c;
    dest = cc_lex_lxsptr;
    L248 :;
    switch ((c = (i64)((*cc_lex_lxsptr++)))) {
    case 48:;
    case 49:;
    case 50:;
    case 51:;
    case 52:;
    case 53:;
    case 54:;
    case 55:;
    case 56:;
    case 57:;
    {
        (*dest++) = (u64)(c);
        if ((c >= ((i64)48 + base))) {
            cc_lex_lxerror((byte*)"Digit out of range");
        };
    }break;
    case 65:;
    case 66:;
    case 67:;
    case 68:;
    case 69:;
    case 70:;
    case 97:;
    case 98:;
    case 99:;
    case 100:;
    case 101:;
    case 102:;
    {
        if ((base == (i64)16)) {
            (*dest++) = (u64)(c);
        } else {
            --cc_lex_lxsptr;
            goto L249 ;
        };
    }break;
    case 95:;
    case 39:;
    case 96:;
    {
    }break;
    default: {
        --cc_lex_lxsptr;
        goto L249 ;
    }
    } //SW
goto L248 ;
L249 :;
    ;
    return dest;
}

static i64 cc_lex_lookup(void) {
    i64 j;
    i64 wrapped;
    i64 length;
    //retry:
L250 :;
;
    j = (cc_lex_lxhashvalue & cc_decls_hstmask);
    wrapped = (i64)0;
    L251 :;
    while (1) {
        cc_decls_nextlx.symptr = (*cc_decls_hashtable)[(j)];
        length = (i64)((*cc_decls_nextlx.symptr).namelen);
        if (!(!!(length))) {
            goto L252 ;
        };
        if ((length == (i64)(cc_decls_nextlx.length))) {
            if (((i64)(memcmp((void *)((*cc_decls_nextlx.symptr).name),(void *)(cc_lex_lxsvalue),(u64)(length))) == (i64)0)) {
                return (i64)1;
            };
        };
        if ((++j >= cc_decls_hstsize)) {
            if (!!(wrapped)) {
                mlib_abortprogram((byte*)"HASHTABLE FULL");
            };
            wrapped = (i64)1;
            j = (i64)0;
        };
    }L252 :;
    ;
    if ((cc_lex_nhstsymbols >= cc_lex_hstthreshold)) {
        cc_lex_newhashtable();
        cc_lex_lxhashvalue = (i64)(cc_lex_gethashvalue(cc_lex_lxsvalue,(i64)(cc_decls_nextlx.length)));
        goto L250 ;
;
    };
    (*cc_decls_nextlx.symptr).name = cc_lex_lxsvalue;
    (*cc_decls_nextlx.symptr).namelen = (u64)(cc_decls_nextlx.length);
    (*cc_decls_nextlx.symptr).symbol = (u64)((i64)69);
    ++cc_lex_nhstsymbols;
    return (i64)0;
}

u64 cc_lex_gethashvalue(byte * s,i64 length) {
    u64 hsum;
    i64 av_1;
    if ((length == (i64)-1)) {
        length = (i64)(strlen((i8 *)(s)));
    };
    hsum = (u64)((i64)0);
    av_1 = length;
    while (av_1-- > 0) {
L253 :;
        hsum = (((hsum << (i64)4) - hsum) + (u64)((*s++)));
L254 :;
    }L255 :;
    ;
    return ((hsum << (i64)5) - hsum);
}

static void cc_lex_inithashtable(void) {
    i64 i;
    cc_decls_hashtable = (struct cc_decls_strec * (*)[])(mlib_pcm_alloc((cc_decls_hstsize * (i64)8)));
    cc_decls_hstmask = (cc_decls_hstsize - (i64)1);
    L256 :;
    for (i=(i64)0;i<=cc_decls_hstmask;i+=(i64)1) {
L257 :;
        (*cc_decls_hashtable)[(i)] = (struct cc_decls_strec *)(mlib_pcm_allocz((i64)128));
L258 :;
    }L259 :;
    ;
    cc_lex_nhstsymbols = (i64)0;
    cc_lex_hstthreshold = (((i64)6 * cc_decls_hstsize) / (i64)10);
}

static void cc_lex_fillhashtable(void) {
    i64 i;
    i64 av_1;
    L260 :;
    for (i=(i64)1;i<=(i64)77;i+=(i64)1) {
L261 :;
        cc_lex_lxsvalue = cc_tables_stnames[(i)-1];
        if (((i64)(cc_tables_stsymbols[(i)-1]) == (i64)70)) {
            cc_lex_lxsvalue = mlib_pcm_copyheapstring(cc_lex_lxsvalue);
        };
        cc_decls_nextlx.length = (i64)(strlen((i8 *)(cc_lex_lxsvalue)));
        cc_lex_lxhashvalue = (i64)(cc_lex_gethashvalue(cc_lex_lxsvalue,(i64)(cc_decls_nextlx.length)));
        if (!!(cc_lex_lookup())) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(cc_tables_stnames[(i)-1],NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            mlib_abortprogram((byte*)"Duplicate symbol table entry");
        };
        (*cc_decls_nextlx.symptr).symbol = (u64)(cc_tables_stsymbols[(i)-1]);
        (*cc_decls_nextlx.symptr).subcode = (i64)(cc_tables_stsubcodes[(i)-1]);
L262 :;
    }L263 :;
    ;
}

static i64 cc_lex_dolexdirective(void) {
    struct cc_decls_strec *  d;
    byte *  p;
    byte *  pstart;
    byte *  s;
    i64 cond;
    i64 c;
    i64 syshdr;
    i64 dir;
    i64 length;
    i64 allowmacros;
    byte filename[300];
    pstart = cc_lex_lxsptr;
    dir = cc_lex_getlexdirective();
    if ((dir == (i64)0)) {
        cc_lex_printstrn(pstart,(cc_lex_lxsptr - pstart),0);
        msysnewc_m_print_startcon();
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        cc_lex_lxerror((byte*)"Invalid # directive");
    };
    if ((dir==(i64)7)) {
        cc_lex_isincludefile = (i64)1;
        L264 :;
        while ((((u64)((*cc_lex_lxsptr)) == ' ') || ((i64)((*cc_lex_lxsptr)) == (i64)9))) {
            ++cc_lex_lxsptr;
L265 :;
        }L266 :;
        ;
        allowmacros = ((u64)((*cc_lex_lxsptr)) != '<');
        cc_lex_lexm();
        cc_lex_isincludefile = (i64)0;
        if (((i64)((u64)(cc_decls_nextlx.symbol)) == (i64)42)) {
            syshdr = (i64)1;
            p = filename;
            if (!!(allowmacros)) {
                L267 :;
                while (1) {
                    cc_lex_lexm();
                    if (((i64)(cc_decls_nextlx.symbol)==(i64)58) || ((i64)(cc_decls_nextlx.symbol)==(i64)57)) {
                        cc_lex_lxerror((byte*)"Bad include file");
                    }else if (((i64)(cc_decls_nextlx.symbol)==(i64)45)) {
                        goto L268 ;
                    } else {
                        s = cc_lex_strtoken(&cc_decls_nextlx,&length);
                        memcpy((void *)(p),(void *)(s),(u64)(length));
                        p += length;
                    };
                }L268 :;
                ;
            } else {
                L269 :;
                while (1) {
                    c = (i64)((*cc_lex_lxsptr++));
                    if ((c==(i64)62)) {
                        goto L270 ;
                    }else if ((c==(i64)10) || (c==(i64)0)) {
                        cc_lex_lxerror((byte*)"include: > expected");
                    } else {
                        (*p++) = (u64)(c);
                    };
                }L270 :;
                ;
            };
            (*p) = (u64)0u;
        } else if (((i64)((u64)(cc_decls_nextlx.symbol)) == (i64)64)) {
            syshdr = (i64)0;
            strcpy((i8 *)(filename),(i8 *)(cc_decls_nextlx.svalue));
        } else {
            cc_lex_lxerror((byte*)"include?");
        };
        cc_lex_lexm();
        if (!!(cc_decls_fshowincludes)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((byte*)"INCLUDE",NULL);
            msysnewc_m_print_str(filename,NULL);
            msysnewc_m_print_str((byte*)"FROM",NULL);
            msysnewc_m_print_str(cc_decls_sourcefilepaths[(cc_lex_getfileno())],NULL);
            msysnewc_m_print_u64(cc_decls_nextlx.lineno,NULL);
            msysnewc_m_print_str((byte*)"NSOURCEFILES=",NULL);
            msysnewc_m_print_i64(cc_decls_nsourcefiles,NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
        };
        ++cc_lex_nincludes;
        cc_lex_stacksourcefile(filename,syshdr);
        if (!(!!(syshdr))) {
            cc_lex_addautomodule(filename,cc_lex_getfileno());
        };
    }else if ((dir==(i64)1)) {
        cc_lex_dodefine();
    }else if ((dir==(i64)10)) {
        cc_lex_lexreadtoken();
        if (((i64)((u64)(cc_decls_nextlx.symbol)) != (i64)69)) {
            cc_lex_lxerror((byte*)"undef: name expected");
        };
        d = cc_decls_nextlx.symptr;
        if (((i64)((u64)((*d).nameid)) != (i64)1)) {
        } else {
            (*d).nameid = (u64)((i64)0);
            (*d).symbol = (u64)((*cc_decls_nextlx.symptr).oldsymbol);
            (*d).mparamlist = (struct cc_decls_mparamrec *)(0);
            (*d).attribs.ax_flmacro = (u64)((i64)0);
        };
    }else if ((dir==(i64)8)) {
        cond = cc_lex_getifdef();
        goto L271 ;
;
    }else if ((dir==(i64)9)) {
        cond = !(cc_lex_getifdef());
        goto L271 ;
;
    }else if ((dir==(i64)3)) {
        cond = cc_lex_getifexpr();
        //doif:
L271 :;
;
        ++cc_lex_ifcondlevel;
        if (!!(cond)) {
            return (i64)0;
        } else {
            //doskipcode:
L272 :;
;
            dir = cc_lex_skipcode();
            if ((dir==(i64)4)) {
                cond = cc_lex_getifexpr();
                if (!!(cond)) {
                    return (i64)0;
                };
                goto L272 ;
;
            }else if ((dir==(i64)5)) {
            }else if ((dir==(i64)6)) {
                --cc_lex_ifcondlevel;
            };
        };
    }else if ((dir==(i64)4) || (dir==(i64)5)) {
        if (!(!!(cc_lex_ifcondlevel))) {
            cc_lex_lxerror((byte*)"#if missing/elif/else");
        };
        L273 :;
        do {
            dir = cc_lex_skipcode();
L274 :;
        } while (!(dir == (i64)6));L275 :;
        ;
        --cc_lex_ifcondlevel;
    }else if ((dir==(i64)6)) {
        if (!(!!(cc_lex_ifcondlevel))) {
            cc_lex_lxerror((byte*)"#if missing/endif");
        };
        --cc_lex_ifcondlevel;
    }else if ((dir==(i64)18)) {
    }else if ((dir==(i64)19)) {
        L276 :;
        do {
            cc_lex_lexreadtoken();
L277 :;
        } while (!((i64)((u64)(cc_decls_nextlx.symbol)) == (i64)57));L278 :;
        ;
    }else if ((dir==(i64)11)) {
        cc_lex_lexm();
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"#ERROR:",NULL);
        msysnewc_m_print_end();
        ;
        cc_lex_showtoken(&cc_decls_nextlx);
        msysnewc_m_print_startcon();
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        cc_lex_lxerror((byte*)"ABORTING");
        goto L279 ;
;
    }else if ((dir==(i64)13)) {
        cc_lex_lexm();
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"#MESSAGE ",NULL);
        msysnewc_m_print_end();
        ;
        if (((i64)((u64)(cc_decls_nextlx.symbol)) == (i64)57)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((byte*)" Line",NULL);
            msysnewc_m_print_i64(((i64)((u64)(cc_decls_nextlx.lineno)) + (i64)1),NULL);
            msysnewc_m_print_str(cc_decls_sourcefilenames[(cc_lex_getfileno())],NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
        } else {
            cc_lex_showtoken(&cc_decls_nextlx);
            msysnewc_m_print_startcon();
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
        };
        goto L279 ;
;
    }else if ((dir==(i64)12) || (dir==(i64)14)) {
        cc_lex_lexm();
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"#WARNING:",NULL);
        msysnewc_m_print_end();
        ;
        cc_lex_showtoken(&cc_decls_nextlx);
        msysnewc_m_print_startcon();
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        //dowarning2:
L279 :;
;
        L280 :;
        while ((((i64)((u64)(cc_decls_nextlx.symbol)) != (i64)57) && ((i64)((u64)(cc_decls_nextlx.symbol)) != (i64)58))) {
            cc_lex_lexm();
L281 :;
        }L282 :;
        ;
        if ((dir == (i64)14)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((byte*)"Press key...",NULL);
            msysnewc_m_print_end();
            ;
            osnos_os_getch();
            msysnewc_m_print_startcon();
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
        };
    }else if ((dir==(i64)20)) {
        cc_lex_dopragmadir();
    }else if ((dir==(i64)15)) {
        cc_decls_debug = (i64)1;
    }else if ((dir==(i64)16)) {
        cc_decls_debug = (i64)0;
    }else if ((dir==(i64)17)) {
        cc_lex_lexreadtoken();
        if (((i64)((u64)(cc_decls_nextlx.symbol)) == (i64)69)) {
            d = cc_decls_nextlx.symptr;
            msysnewc_m_print_startcon();
            msysnewc_m_print_u64(cc_decls_nextlx.lineno,NULL);
            msysnewc_m_print_str(cc_decls_sourcefilenames[(cc_lex_getfileno())],NULL);
            msysnewc_m_print_str((byte*)":",NULL);
            msysnewc_m_print_end();
            ;
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((byte*)"SHOW MACRO",NULL);
            msysnewc_m_print_str(cc_lib_getstname(d),NULL);
            msysnewc_m_print_str((byte*)":",NULL);
            msysnewc_m_print_end();
            ;
            if (((i64)((u64)((*d).nameid)) == (i64)1)) {
                cc_lex_showtokens((byte*)"tokens:",(*d).tokenlist);
                msysnewc_m_print_startcon();
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
            } else {
                msysnewc_m_print_startcon();
                msysnewc_m_print_str((byte*)"not a macro",NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
            };
        } else {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((byte*)"Not a name",NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
        };
    } else {
        //skip:
L283 :;
;
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"DIRECTIVE NOT IMPL:",NULL);
        msysnewc_m_print_str(cc_tables_sourcedirnames[(dir)-1],NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        cc_lex_lxsptr = pstart;
        cc_decls_nextlx.symbol = (u64)((i64)4);
        return (i64)1;
        cc_lex_lxerror((byte*)"Directive not implemented");
    };
    return (i64)0;
}

static i64 cc_lex_getlexdirective(void) {
    struct cc_decls_strec *  d;
    cc_lex_lexreadtoken();
    if (((i64)(cc_decls_nextlx.symbol)==(i64)69)) {
    }else if (((i64)(cc_decls_nextlx.symbol)==(i64)57)) {
        return (i64)18;
    }else if (((i64)(cc_decls_nextlx.symbol)==(i64)60)) {
        L284 :;
        do {
            cc_lex_lexreadtoken();
L285 :;
        } while (!(((i64)((u64)(cc_decls_nextlx.symbol)) == (i64)57) || ((i64)((u64)(cc_decls_nextlx.symbol)) == (i64)58)));L286 :;
        ;
        return (i64)18;
    } else {
        return (i64)0;
    };
    if (((i64)((*cc_decls_nextlx.symptr).symbol)==(i64)70)) {
        return (i64)((*cc_decls_nextlx.symptr).subcode);
    }else if (((i64)((*cc_decls_nextlx.symptr).symbol)==(i64)73)) {
        return (i64)3;
    }else if (((i64)((*cc_decls_nextlx.symptr).symbol)==(i64)74)) {
        return (i64)5;
    }else if (((i64)((*cc_decls_nextlx.symptr).symbol)==(i64)57)) {
        return (i64)18;
    };
    d = cc_decls_nextlx.symptr;
    if (((i64)((u64)((*d).nameid)) == (i64)1)) {
        if (((i64)((u64)((*d).oldsymbol)) == (i64)70)) {
            return (i64)((*d).subcode);
        };
    };
    return (i64)0;
}

void cc_lex_startlex(byte * caption,i64 fileno) {
    cc_lex_ifcondlevel = (i64)0;
    cc_lex_lx_stackindex = (i64)0;
    cc_lex_noexpand = (i64)0;
    cc_lex_normaltk = &cc_lex_normaltkx;
    cc_lex_lx_stackindex = (i64)0;
    cc_lex_ifcondlevel = (i64)0;
    cc_lex_firstsymbol = (i64)1;
    cc_lex_npastedtokens = (i64)0;
    cc_lex_isincludefile = (i64)0;
    cc_lex_tkptr = (struct cc_decls_tokenrec *)(0);
    cc_lex_lxstart = (cc_lex_lxsptr = cc_decls_sourcefiletext[(fileno)]);
    cc_lex_setfileno(fileno);
    cc_decls_nextlx.lineno = (u64)((i64)1);
    cc_decls_nextlx.numberoffset = (i64)0;
    cc_decls_nextlx.symbol = (u64)((i64)57);
    cc_decls_nextlx.subcode = (u64)((i64)0);
    cc_lex_lex();
}

void cc_lex_endlex(void) {
    if (!!(cc_lex_ifcondlevel)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_i64(cc_lex_ifcondlevel,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        cc_lex_lxerror((byte*)"#endif missing");
    };
}

void cc_lex_ps(byte * caption) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_str(caption,NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_str((byte*)":::",NULL);
    msysnewc_m_print_end();
    ;
    cc_lex_printsymbol(&cc_decls_lx);
}

void cc_lex_psnext(byte * caption) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_str(caption,NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_str((byte*)":##",NULL);
    msysnewc_m_print_end();
    ;
    cc_lex_printsymbol(&cc_decls_nextlx);
}

i64 cc_lex_gethashtablesize(void) {
    i64 i;
    i64 n;
    n = (i64)0;
    L287 :;
    for (i=(i64)0;i<=cc_decls_hstmask;i+=(i64)1) {
L288 :;
        if (!!((*(*cc_decls_hashtable)[(i)]).name)) {
            ++n;
        };
L289 :;
    }L290 :;
    ;
    return n;
}

static void cc_lex_readlinecomment(void) {
    L291 :;
    while (1) {
        L293 :;
        while (!!((u64)(cc_lex_linecommentmap[((i64)((*++cc_lex_lxsptr)))]))) {
L294 :;
        }L295 :;
        ;
        if (((i64)((*cc_lex_lxsptr))==(i64)10)) {
            ++cc_lex_lxsptr;
            goto L292 ;
        }else if (((i64)((*cc_lex_lxsptr))==(i64)0)) {
            goto L292 ;
        }else if (((i64)((*cc_lex_lxsptr))==(i64)92)) {
            ++cc_lex_lxsptr;
            if (((i64)((*cc_lex_lxsptr))==(i64)13)) {
                cc_lex_lxsptr += (i64)2;
                ++cc_decls_nextlx.lineno;
            }else if (((i64)((*cc_lex_lxsptr))==(i64)10)) {
                ++cc_lex_lxsptr;
                ++cc_decls_nextlx.lineno;
            };
        };
    }L292 :;
    ;
    ++cc_decls_nextlx.lineno;
}

static void cc_lex_readblockcomment(void) {
    L296 :;
    while (1) {
        L298 :;
        while (!!((u64)(cc_lex_commentmap[((i64)((*++cc_lex_lxsptr)))]))) {
L299 :;
        }L300 :;
        ;
        if (((i64)((*cc_lex_lxsptr))==(i64)10)) {
            ++cc_decls_nextlx.lineno;
        }else if (((i64)((*cc_lex_lxsptr))==(i64)0)) {
            cc_lex_lxerror((byte*)"block comment eof");
        }else if (((i64)((*cc_lex_lxsptr))==(i64)42)) {
            if (((u64)((*(cc_lex_lxsptr + (i64)1))) == '/')) {
                cc_lex_lxsptr += (i64)2;
                goto L297 ;
            };
        };
    }L297 :;
    ;
}

static void cc_lex_readhex(byte * pstart) {
    u64 aa;
    u64 c;
    i64 length;
    i64 leading;
    i64 ll;
    i64 usigned;
    byte *  p;
    aa = (u64)((i64)0);
    p = cc_lex_lxsptr;
    leading = (i64)1;
    ll = (usigned = (i64)0);
    length = (i64)0;
    L301 :;
    switch ((i64)((c = (u64)((*cc_lex_lxsptr++))))) {
    case 49:;
    case 50:;
    case 51:;
    case 52:;
    case 53:;
    case 54:;
    case 55:;
    case 56:;
    case 57:;
    {
        leading = (i64)0;
        aa = (u64)((((i64)(aa) * (i64)16) + (i64)((c - (u64)48u))));
        ++length;
    }break;
    case 48:;
    {
        if (!!(leading)) {
            ++p;
        } else {
            ++length;
            aa = (u64)(((i64)(aa) * (i64)16));
        };
    }break;
    case 65:;
    case 66:;
    case 67:;
    case 68:;
    case 69:;
    case 70:;
    {
        leading = (i64)0;
        ++length;
        aa = (u64)(((i64)((aa * (u64)((i64)16))) + ((i64)((c - (u64)65u)) + (i64)10)));
    }break;
    case 97:;
    case 98:;
    case 99:;
    case 100:;
    case 101:;
    case 102:;
    {
        leading = (i64)0;
        ++length;
        aa = (u64)(((i64)((aa * (u64)((i64)16))) + ((i64)((c - (u64)97u)) + (i64)10)));
    }break;
    case 46:;
    case 80:;
    case 112:;
    {
        --cc_lex_lxsptr;
        cc_lex_readrealnumber(pstart,p,(cc_lex_lxsptr - p),(i64)16);
        return;
    }break;
    case 76:;
    case 108:;
    {
        ++ll;
        if ((ll > (i64)2)) {
            cc_lex_lxerror((byte*)"-LL?");
        };
    }break;
    case 85:;
    case 117:;
    {
        if (!!(usigned)) {
            cc_lex_lxerror((byte*)"-U?");
        };
        usigned = (i64)1;
    }break;
    default: {
        --cc_lex_lxsptr;
        goto L302 ;
    }
    } //SW
goto L301 ;
L302 :;
    ;
    cc_lex_setnumberoffset((pstart - cc_lex_lxstart));
    cc_decls_nextlx.length = (cc_lex_lxsptr - pstart);
    if ((length > (i64)16)) {
        cc_lex_lxerror((byte*)"Overflow in hex number");
    };
    cc_decls_nextlx.symbol = (u64)((i64)60);
    if ((aa > (u64)9223372036854775807u)) {
        cc_decls_nextlx.subcode = (u64)((i64)10);
    } else if (((i64)(aa) > (i64)4294967295)) {
        cc_decls_nextlx.subcode = (u64)((i64)5);
    } else if (((i64)(aa) > (i64)2147483647)) {
        cc_decls_nextlx.subcode = (u64)((i64)9);
    } else {
        cc_decls_nextlx.subcode = (u64)((i64)4);
    };
    cc_decls_nextlx.value = (i64)(aa);
    cc_lex_checknumbersuffix();
}

static void cc_lex_readbinary(byte * pstart) {
    u64 aa;
    i64 c;
    i64 length;
    i64 leading;
    byte *  p;
    i64 av_1;
    aa = (u64)((i64)0);
    p = cc_lex_lxsptr;
    leading = (i64)1;
    L303 :;
    switch ((c = (i64)((*cc_lex_lxsptr++)))) {
    case 49:;
    {
        leading = (i64)0;
    }break;
    case 48:;
    {
        if (!!(leading)) {
            ++p;
        };
    }break;
    case 50:;
    case 51:;
    case 52:;
    case 53:;
    case 54:;
    case 55:;
    case 56:;
    case 57:;
    {
        cc_lex_lxerror((byte*)"Binary bad digit");
    }break;
    case 46:;
    {
        cc_lex_lxerror((byte*)"Binary fp");
    }break;
    default: {
        --cc_lex_lxsptr;
        goto L304 ;
    }
    } //SW
goto L303 ;
L304 :;
    ;
    length = (cc_lex_lxsptr - p);
    cc_lex_setnumberoffset((pstart - cc_lex_lxstart));
    cc_decls_nextlx.length = (cc_lex_lxsptr - pstart);
    if ((length > (i64)64)) {
        cc_lex_lxerror((byte*)"Overflow in binary number");
    };
    av_1 = length;
    while (av_1-- > 0) {
L305 :;
        aa = (u64)(((((i64)(aa) * (i64)2) + (i64)((*p++))) - (i64)48));
L306 :;
    }L307 :;
    ;
    cc_decls_nextlx.symbol = (u64)((i64)60);
    cc_decls_nextlx.subcode = (u64)((i64)4);
    if (((i64)(aa) >= (i64)2147483647)) {
        cc_decls_nextlx.subcode = (u64)((i64)5);
    };
    cc_decls_nextlx.value = (i64)(aa);
    cc_lex_checknumbersuffix();
}

static void cc_lex_readoctal(byte * pstart) {
    u64 aa;
    i64 c;
    i64 length;
    i64 res;
    i64 leading;
    i64 ll;
    i64 usigned;
    byte *  p;
    i64 av_1;
    aa = (u64)((i64)0);
    p = cc_lex_lxsptr;
    leading = (i64)1;
    ll = (usigned = (i64)0);
    length = (i64)0;
    L308 :;
    switch ((c = (i64)((*cc_lex_lxsptr++)))) {
    case 49:;
    case 50:;
    case 51:;
    case 52:;
    case 53:;
    case 54:;
    case 55:;
    {
        leading = (i64)0;
        ++length;
    }break;
    case 48:;
    {
        if (!!(leading)) {
            ++p;
        } else {
            ++length;
        };
    }break;
    case 46:;
    {
        --cc_lex_lxsptr;
        cc_lex_readrealnumber(pstart,p,(cc_lex_lxsptr - p),(i64)10);
        return;
    }break;
    case 76:;
    case 108:;
    {
        ++ll;
        if ((ll > (i64)2)) {
            cc_lex_lxerror((byte*)"-LL?");
        };
    }break;
    case 85:;
    case 117:;
    {
        if (!!(usigned)) {
            cc_lex_lxerror((byte*)"-U?");
        };
        usigned = (i64)1;
    }break;
    default: {
        if (!!((u64)(cc_lex_alphamap[(c)]))) {
            //doalpha:
L310 :;
;
            cc_lex_readalphanumeric(pstart);
            return;
        };
        --cc_lex_lxsptr;
        goto L309 ;
    }
    } //SW
goto L308 ;
L309 :;
    ;
    cc_lex_setnumberoffset((pstart - cc_lex_lxstart));
    cc_decls_nextlx.length = (cc_lex_lxsptr - pstart);
    if (((length > (i64)22) || ((length == (i64)22) && ((res = mlib_cmpstringn(p,(byte*)"1777777777777777777777",(i64)22)) > (i64)0)))) {
        cc_lex_lxerror((byte*)"Overflow in octal number");
    };
    av_1 = length;
    while (av_1-- > 0) {
L311 :;
        aa = (u64)(((((i64)(aa) * (i64)8) + (i64)((*p++))) - (i64)48));
L312 :;
    }L313 :;
    ;
    cc_decls_nextlx.symbol = (u64)((i64)60);
    cc_decls_nextlx.subcode = (u64)((i64)4);
    if (((i64)(aa) >= (i64)2147483647)) {
        cc_decls_nextlx.subcode = (u64)((i64)5);
    };
    cc_decls_nextlx.value = (i64)(aa);
    cc_lex_checknumbersuffix();
}

static void cc_lex_readdecimal(byte * pstart) {
    u64 aa;
    i64 c;
    i64 length;
    i64 res;
    byte ll;
    byte usigned;
    byte *  p;
    i64 av_1;
    aa = (u64)((i64)0);
    ll = (u64)((usigned = (u64)((i64)0)));
    p = --cc_lex_lxsptr;
    L314 :;
    while (!!((u64)(cc_lex_digitmap[((i64)((*++cc_lex_lxsptr)))]))) {
L315 :;
    }L316 :;
    ;
    L317 :;
    while (((u64)((*p)) == '0')) {
        ++p;
L318 :;
    }L319 :;
    ;
    length = (cc_lex_lxsptr - p);
    L320 :;
    switch ((c = (i64)((*cc_lex_lxsptr++)))) {
    case 46:;
    case 69:;
    case 101:;
    {
        --cc_lex_lxsptr;
        cc_lex_readrealnumber(pstart,p,(cc_lex_lxsptr - p),(i64)10);
        return;
    }break;
    case 76:;
    case 108:;
    {
        ++ll;
        if (((i64)((u64)(ll)) > (i64)2)) {
            cc_lex_lxerror((byte*)"-LL?");
        };
    }break;
    case 85:;
    case 117:;
    {
        if (!!((u64)(usigned))) {
            cc_lex_lxerror((byte*)"-U?");
        };
        usigned = (u64)((i64)1);
    }break;
    default: {
        if (!!((u64)(cc_lex_alphamap[(c)]))) {
            cc_lex_readalphanumeric(pstart);
            return;
        };
        --cc_lex_lxsptr;
        goto L321 ;
    }
    } //SW
goto L320 ;
L321 :;
    ;
    cc_lex_setnumberoffset((pstart - cc_lex_lxstart));
    cc_decls_nextlx.length = (cc_lex_lxsptr - pstart);
    if (((length > (i64)20) || ((length == (i64)20) && ((res = mlib_cmpstringn(p,(byte*)"18446744073709551615",(i64)20)) > (i64)0)))) {
        cc_lex_lxerror((byte*)"Overflow in decimal number");
    };
    av_1 = length;
    while (av_1-- > 0) {
L322 :;
        aa = ((aa * (u64)((i64)10)) + ((u64)((*p++)) - '0'));
L323 :;
    }L324 :;
    ;
    cc_decls_nextlx.symbol = (u64)((i64)60);
    cc_decls_nextlx.subcode = (u64)((i64)4);
    if (((i64)(ll)==(i64)0) || ((i64)(ll)==(i64)1)) {
        if (!!((u64)(usigned))) {
            if (((i64)(aa) >= (i64)4294967295)) {
                cc_decls_nextlx.subcode = (u64)((i64)10);
            } else {
                cc_decls_nextlx.subcode = (u64)((i64)9);
            };
        } else {
            if (((i64)(aa) >= (i64)2147483647)) {
                cc_decls_nextlx.subcode = (u64)((i64)5);
            };
        };
    } else {
        if (!!((u64)(usigned))) {
            cc_decls_nextlx.subcode = (u64)((i64)10);
        } else {
            cc_decls_nextlx.subcode = (u64)((i64)5);
        };
    };
    cc_decls_nextlx.value = (i64)(aa);
}

static i64 cc_lex_checknumbersuffix(void) {
    byte c;
    L325 :;
    switch ((i64)((c = (u64)((*cc_lex_lxsptr++))))) {
    case 76:;
    case 108:;
    case 117:;
    case 85:;
    {
    }break;
    default: {
        if (!!((u64)(cc_lex_alphamap[((i64)(c))]))) {
        };
        --cc_lex_lxsptr;
        goto L326 ;
    }
    } //SW
goto L325 ;
L326 :;
    ;
    return (i64)4;
}

static void cc_lex_stacksourcefile(byte * file,i64 syshdr) {
    i64 fileno;
    struct cc_lex_stackinforec info;
    byte fullpath[500];
    fileno = cc_lex_getsourcefile(file,syshdr);
    if ((fileno == (i64)0)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str(file,NULL);
        msysnewc_m_print_u64(strlen((i8 *)(file)),NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        cc_lex_lxerror((byte*)"Can't find include file");
    };
    if ((cc_lex_lx_stackindex >= (i64)20)) {
        cc_lex_lxerror((byte*)"Too many nested includes");
    };
    ++cc_lex_lx_stackindex;
    fullpath[((i64)1)-1] = (u64)0u;
    if ((cc_lex_lx_stackindex > (i64)1)) {
        strcpy((i8 *)(fullpath),(i8 *)(cc_lex_headerpathlist[((cc_lex_lx_stackindex - (i64)1))-1]));
    };
    if (!!((u64)(cc_lex_headerpath[((i64)1)-1]))) {
        strcat((i8 *)(fullpath),(i8 *)(mlib_pcm_copyheapstring(cc_lex_headerpath)));
    };
    cc_lex_headerpathlist[(cc_lex_lx_stackindex)-1] = mlib_pcm_copyheapstring(fullpath);
    info.startptr = cc_lex_lxstart;
    info.sptr = cc_lex_lxsptr;
    info.lineno = (i64)(cc_decls_nextlx.lineno);
    info.fileno = cc_lex_getfileno();
    cc_lex_lx_stack[(cc_lex_lx_stackindex)-1] = info;
    cc_lex_lxstart = (cc_lex_lxsptr = cc_decls_sourcefiletext[(fileno)]);
    cc_lex_setfileno(fileno);
    cc_decls_nextlx.lineno = (u64)((i64)1);
}

static void cc_lex_unstacksourcefile(void) {
    byte *  path;
    struct cc_lex_stackinforec info;
    path = cc_lex_headerpathlist[(cc_lex_lx_stackindex)-1];
    mlib_pcm_free((void *)(path),(i64)(strlen((i8 *)(path))));
    info = cc_lex_lx_stack[(cc_lex_lx_stackindex--)-1];
    cc_lex_lxstart = info.startptr;
    cc_lex_lxsptr = info.sptr;
    cc_decls_nextlx.lineno = (u64)(info.lineno);
    cc_lex_setfileno((i64)(info.fileno));
}

static i64 cc_lex_getsourcefile(byte * file,i64 syshdr) {
    static byte filespec[300];
    byte *  hdrtext;
    i64 i;
    cc_lex_headerpath[((i64)1)-1] = (u64)0u;
    strcpy((i8 *)(filespec),(i8 *)(file));
    mlib_convlcstring(filespec);
    L327 :;
    for (i=(i64)1;i<=cc_decls_nsourcefiles;i+=(i64)1) {
L328 :;
        if (!!(mlib_eqstring(filespec,cc_decls_sourcefilenames[(i)]))) {
            return i;
        };
L329 :;
    }L330 :;
    ;
    if (!!(cc_decls_dointheaders)) {
        hdrtext = cc_headers_findheader(filespec);
        if (!!(hdrtext)) {
            return cc_support_loadbuiltin(filespec,hdrtext);
        };
    };
    strcpy((i8 *)(cc_lex_headerpath),(i8 *)(mlib_extractpath(file)));
    if ((((u64)(cc_lex_headerpath[((i64)1)-1]) == '/') || (((u64)(cc_lex_headerpath[((i64)2)-1]) == ':') && ((u64)(cc_lex_headerpath[((i64)3)-1]) == '/')))) {
        if (!!(mlib_checkfile(file))) {
            return cc_support_loadsourcefile(file,file);
        };
        return (i64)0;
    };
    L331 :;
    for (i=cc_lex_lx_stackindex;i>=(i64)1;i-=(i64)1) {
L332 :;
        strcpy((i8 *)(filespec),(i8 *)(cc_lex_headerpathlist[(i)-1]));
        strcat((i8 *)(filespec),(i8 *)(file));
        if (!!(mlib_checkfile(filespec))) {
            return cc_support_loadsourcefile(filespec,file);
        };
L333 :;
    }L334 :;
    ;
    L335 :;
    for (i=(i64)1;i<=cc_decls_nsearchdirs;i+=(i64)1) {
L336 :;
        strcpy((i8 *)(filespec),(i8 *)(cc_decls_searchdirs[(i)-1]));
        strcat((i8 *)(filespec),(i8 *)(file));
        if (!!(mlib_checkfile(filespec))) {
            strcpy((i8 *)(cc_lex_headerpath),(i8 *)(mlib_extractpath(filespec)));
            return cc_support_loadsourcefile(filespec,file);
        };
L337 :;
    }L338 :;
    ;
    return (i64)0;
}

void cc_lex_lex(void) {
    //reenter:
L339 :;
;
    cc_decls_lx = cc_decls_nextlx;
    cc_lex_lexm();
    if ((((i64)((u64)(cc_decls_lx.symbol)) == (i64)69) && (cc_lex_lx_stackindex == (i64)0))) {
        (*((*cc_decls_lx.symptr).name + (i64)(cc_decls_lx.length))) = (u64)0u;
    };
    L340 :;
    if (((i64)(cc_decls_nextlx.symbol)==(i64)69)) {
        cc_decls_nextlx.symbol = (u64)((*cc_decls_nextlx.symptr).symbol);
        if (((i64)((u64)(cc_decls_nextlx.symbol)) == (i64)70)) {
            cc_decls_nextlx.symbol = (u64)((i64)69);
        };
        cc_decls_nextlx.subcode = (u64)((*cc_decls_nextlx.symptr).subcode);
        return;
    }else if (((i64)(cc_decls_nextlx.symbol)==(i64)57)) {
        cc_lex_lexm();
    } else {
        return;
    }goto L340 ;
L341 :;
    ;
}

static void cc_lex_shownumberstr(struct cc_decls_tokenrec * l,void * f) {
    byte *  s;
    if (!!(cc_lex_getfilenox(l))) {
        s = (cc_decls_sourcefiletext[(cc_lex_getfilenox(l))] + cc_lex_getnumberoffsetx(l));
    } else {
        s = cc_lex_pastedtokenlist[((i64)((*l).pasteno))-1];
    };
    cc_lex_printstrn(s,(i64)((*l).length),f);
}

struct cc_decls_strec * cc_lex_addnamestr(byte * name) {
    struct cc_decls_tokenrec oldlx;
    struct cc_decls_strec *  symptr;
    oldlx = cc_decls_nextlx;
    cc_decls_nextlx.length = (i64)(strlen((i8 *)(name)));
    cc_lex_lxhashvalue = (i64)(cc_lex_gethashvalue(name,(i64)(cc_decls_nextlx.length)));
    cc_lex_lxsvalue = (byte *)(mlib_pcm_alloc(((i64)(cc_decls_nextlx.length) + (i64)1)));
    memcpy((void *)(cc_lex_lxsvalue),(void *)(name),(u64)(((i64)(cc_decls_nextlx.length) + (i64)1)));
    cc_lex_lookup();
    symptr = cc_decls_nextlx.symptr;
    cc_decls_nextlx = oldlx;
    return symptr;
}

static void cc_lex_lxreadstring(i64 termchar,i64 fwide) {
    byte str[2048];
    byte *  dest;
    byte *  ws;
    u16 *  wd;
    u16 *  wd0;
    i64 c;
    i64 d;
    i64 length;
    i64 av_1;
    i64 av_2;
    if ((termchar == (i64)34)) {
        cc_decls_nextlx.symbol = (!!(fwide)?(u64)((i64)65):(u64)((i64)64));
    } else {
        cc_decls_nextlx.symbol = (u64)((i64)62);
    };
    cc_decls_nextlx.svalue = cc_lex_lxsptr;
    if (((cc_lex_lx_stackindex == (i64)0) || !!(fwide))) {
        dest = cc_lex_lxsptr;
        ws = dest;
    } else {
        dest = str;
    };
    length = (i64)0;
    L342 :;
    while (1) {
        switch ((c = (i64)((*cc_lex_lxsptr++)))) {
        case 92:;
        {
            if (!!(cc_lex_isincludefile)) {
                c = (i64)47;
                goto L344 ;
;
            };
            c = (i64)((*cc_lex_lxsptr++));
            //reenter:
L345 :;
;
            switch (c) {
            case 97:;
            {
                c = (i64)7;
            }break;
            case 98:;
            {
                c = (i64)8;
            }break;
            case 102:;
            {
                c = (i64)12;
            }break;
            case 110:;
            {
                c = (i64)10;
            }break;
            case 114:;
            {
                c = (i64)13;
            }break;
            case 116:;
            {
                c = (i64)9;
            }break;
            case 118:;
            {
                c = (i64)11;
            }break;
            case 120:;
            {
                c = (i64)0;
                L346 :;
                while (1) {
                    switch ((d = (i64)((*cc_lex_lxsptr++)))) {
                    case 65:;
                    case 66:;
                    case 67:;
                    case 68:;
                    case 69:;
                    case 70:;
                    {
                        c = ((((c * (i64)16) + d) - (i64)65) + (i64)10);
                    }break;
                    case 97:;
                    case 98:;
                    case 99:;
                    case 100:;
                    case 101:;
                    case 102:;
                    {
                        c = ((((c * (i64)16) + d) - (i64)97) + (i64)10);
                    }break;
                    case 48:;
                    case 49:;
                    case 50:;
                    case 51:;
                    case 52:;
                    case 53:;
                    case 54:;
                    case 55:;
                    case 56:;
                    case 57:;
                    {
                        c = (((c * (i64)16) + d) - (i64)48);
                    }break;
                    default: {
                        --cc_lex_lxsptr;
                        goto L347 ;
                    }
                    } //SW
;
                }L347 :;
                ;
            }break;
            case 48:;
            case 49:;
            case 50:;
            case 51:;
            case 52:;
            case 53:;
            case 54:;
            case 55:;
            {
                c -= (i64)48;
                av_1 = (i64)2;
                while (av_1-- > 0) {
L348 :;
                    switch ((d = (i64)((*cc_lex_lxsptr++)))) {
                    case 48:;
                    case 49:;
                    case 50:;
                    case 51:;
                    case 52:;
                    case 53:;
                    case 54:;
                    case 55:;
                    {
                        c = (((c * (i64)8) + d) - (i64)48);
                    }break;
                    default: {
                        --cc_lex_lxsptr;
                        goto L350 ;
                    }
                    } //SW
;
L349 :;
                }L350 :;
                ;
            }break;
            case 34:;
            {
                c = (i64)34;
            }break;
            case 92:;
            {
                c = (i64)92;
            }break;
            case 39:;
            {
                c = (i64)39;
            }break;
            case 13:;
            {
                ++cc_decls_nextlx.lineno;
                if (((i64)((*cc_lex_lxsptr)) == (i64)10)) {
                    ++cc_lex_lxsptr;
                };
                goto L342 ;
            }break;
            case 10:;
            {
                goto L342 ;
            }break;
            default: {
            }
            } //SW
;
        }break;
        case 34:;
        case 39:;
        {
            if ((c == termchar)) {
                goto L343 ;
            };
        }break;
        case 0:;
        {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((byte*)"NEXTLX.LINENO=",NULL);
            msysnewc_m_print_u64(cc_decls_nextlx.lineno,NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            cc_lex_lxerror((byte*)"String not terminated");
        }break;
        default: {
        }
        } //SW
;
        //normalchar:
L344 :;
;
        if ((cc_lex_lx_stackindex == (i64)0)) {
            (*dest++) = (u64)(c);
        } else if ((++length < (i64)2048)) {
            (*dest++) = (u64)(c);
        } else {
            cc_lex_lxerror((byte*)"Local str too long");
        };
    }L343 :;
    ;
    (*dest) = (u64)0u;
    if (!!(fwide)) {
        length = (i64)((cc_decls_nextlx.length = (dest - cc_decls_nextlx.svalue)));
        wd0 = (wd = (u16 *)(mlib_pcm_alloc(((length * (i64)2) + (i64)2))));
        av_2 = length;
        while (av_2-- > 0) {
L351 :;
            (*wd++) = (u64)((*ws++));
L352 :;
        }L353 :;
        ;
        (*wd) = (u64)((i64)0);
        cc_decls_nextlx.svalue = (byte *)(wd0);
    } else {
        if ((cc_lex_lx_stackindex == (i64)0)) {
            cc_decls_nextlx.length = (dest - cc_decls_nextlx.svalue);
        } else {
            cc_decls_nextlx.length = length;
            cc_decls_nextlx.svalue = (byte *)(mlib_pcm_alloc((length + (i64)1)));
            memcpy((void *)(cc_decls_nextlx.svalue),(void *)(str),(u64)((length + (i64)1)));
        };
    };
}

static void cc_lex_addlisttoken(struct cc_decls_tokenrec * * ulist,struct cc_decls_tokenrec * * ulistx,struct cc_decls_tokenrec * p) {
    if (((*ulist) == 0)) {
        (*ulist) = ((*ulistx) = p);
    } else {
        (*(*ulistx)).nexttoken = p;
    };
    (*p).nexttoken = (struct cc_decls_tokenrec *)(0);
    (*ulistx) = p;
}

static void cc_lex_addlisttoken_copy(struct cc_decls_tokenrec * * ulist,struct cc_decls_tokenrec * * ulistx,struct cc_decls_tokenrec * q) {
    struct cc_decls_tokenrec *  p;
    p = cc_lex_alloctoken();
    (*p) = (*q);
    (*p).nexttoken = (struct cc_decls_tokenrec *)(0);
    if (((*ulist) == 0)) {
        (*ulist) = ((*ulistx) = p);
    } else {
        (*(*ulistx)).nexttoken = p;
    };
    (*p).nexttoken = (struct cc_decls_tokenrec *)(0);
    (*ulistx) = p;
}

static void cc_lex_addlist_nextlx(struct cc_decls_tokenrec * * ulist,struct cc_decls_tokenrec * * ulistx) {
    struct cc_decls_tokenrec *  p;
    p = cc_lex_alloctoken();
    (*p) = cc_decls_nextlx;
    (*p).nexttoken = (struct cc_decls_tokenrec *)(0);
    if (((*ulist) == 0)) {
        (*ulist) = ((*ulistx) = p);
    } else {
        (*(*ulistx)).nexttoken = p;
    };
    (*p).nexttoken = (struct cc_decls_tokenrec *)(0);
    (*ulistx) = p;
}

static void cc_lex_addlisttoken_seq(struct cc_decls_tokenrec * * ulist,struct cc_decls_tokenrec * * ulistx,struct cc_decls_tokenrec * seq) {
    struct cc_decls_tokenrec *  tk;
    L354 :;
    while (!!(seq)) {
        tk = cc_lex_alloctoken();
        (*tk) = (*seq);
        if (((*ulist) == 0)) {
            (*ulist) = ((*ulistx) = tk);
        } else {
            (*(*ulistx)).nexttoken = tk;
        };
        (*tk).nexttoken = (struct cc_decls_tokenrec *)(0);
        (*ulistx) = tk;
        seq = (*seq).nexttoken;
L355 :;
    }L356 :;
    ;
}

static void cc_lex_addlistmparam(struct cc_decls_mparamrec * * ulist,struct cc_decls_mparamrec * * ulistx,struct cc_decls_mparamrec * p) {
    if (((*ulist) == 0)) {
        (*ulist) = ((*ulistx) = p);
    } else {
        (*(*ulistx)).nextmparam = p;
    };
    (*ulistx) = p;
}

static void cc_lex_dodefine(void) {
    struct cc_decls_mparamrec *  stlist;
    struct cc_decls_mparamrec *  stlistx;
    struct cc_decls_mparamrec *  p;
    struct cc_decls_mparamrec *  q;
    struct cc_decls_strec *  stname;
    struct cc_decls_strec *  d;
    struct cc_decls_tokenrec *  tklist;
    struct cc_decls_tokenrec *  tklistx;
    struct cc_decls_tokenrec *  tk;
    i64 nparams;
    i64 ntokens;
    i64 paramno;
    cc_lex_lexreadtoken();
    if (((i64)((u64)(cc_decls_nextlx.symbol)) != (i64)69)) {
        cc_lex_lxerror((byte*)"define: name expected");
    };
    stname = cc_decls_nextlx.symptr;
    (*stname).lineno = (u64)(((i64)((u64)(cc_decls_nextlx.lineno)) + (cc_lex_getfileno() << (i64)24)));
    (*stname).oldsymbol = (u64)((*stname).symbol);
    (*stname).symbol = (u64)((i64)69);
    (*stname).nameid = (u64)((i64)1);
    nparams = (i64)0;
    if (((u64)((*cc_lex_lxsptr)) == '(')) {
        ++cc_lex_lxsptr;
        stlist = (stlistx = (struct cc_decls_mparamrec *)(0));
        (*stname).attribs.ax_flmacro = (u64)((i64)1);
        cc_lex_lexreadtoken();
        L357 :;
        while (1) {
            if (((i64)(cc_decls_nextlx.symbol)==(i64)69)) {
                d = cc_decls_nextlx.symptr;
                p = stlist;
                L359 :;
                while (!!(p)) {
                    if (((*p).def == d)) {
                        cc_lex_lxerror((byte*)"Dupl macro param");
                    };
                    p = (*p).nextmparam;
L360 :;
                }L361 :;
                ;
                q = (struct cc_decls_mparamrec *)(mlib_pcm_alloc((i64)16));
                (*q).def = d;
                (*q).nextmparam = (struct cc_decls_mparamrec *)(0);
                cc_lex_addlistmparam(&stlist,&stlistx,q);
                ++nparams;
                cc_lex_lexreadtoken();
                if (((i64)((u64)(cc_decls_nextlx.symbol)) == (i64)8)) {
                    cc_lex_lexreadtoken();
                };
            }else if (((i64)(cc_decls_nextlx.symbol)==(i64)14)) {
                goto L358 ;
            }else if (((i64)(cc_decls_nextlx.symbol)==(i64)21)) {
                d = cc_lex_addnamestr((byte*)"__VA_ARGS__");
                (*stname).attribs.ax_varparams = (u64)((i64)1);
                cc_lex_lexreadtoken();
                if (((i64)((u64)(cc_decls_nextlx.symbol)) != (i64)14)) {
                    cc_lex_lxerror((byte*)"')' expected");
                };
                q = (struct cc_decls_mparamrec *)(mlib_pcm_alloc((i64)16));
                (*q).def = d;
                (*q).nextmparam = (struct cc_decls_mparamrec *)(0);
                cc_lex_addlistmparam(&stlist,&stlistx,q);
                ++nparams;
                goto L358 ;
            } else {
                cc_lex_lxerror((byte*)"macro params?");
            };
        }L358 :;
        ;
        (*stname).mparamlist = stlist;
    };
    tklist = (tklistx = (struct cc_decls_tokenrec *)(0));
    ntokens = (i64)0;
    L362 :;
    while (1) {
        cc_lex_lexreadtoken();
        if (((i64)(cc_decls_nextlx.symbol)==(i64)57) || ((i64)(cc_decls_nextlx.symbol)==(i64)58)) {
            goto L363 ;
        }else if (((i64)(cc_decls_nextlx.symbol)==(i64)69)) {
            p = (*stname).mparamlist;
            paramno = (i64)1;
            L364 :;
            while (!!(p)) {
                if (((*p).def == cc_decls_nextlx.symptr)) {
                    cc_decls_nextlx.flags |= (u8)2u;
                    cc_decls_nextlx.paramno = paramno;
                    goto L366 ;
                };
                p = (*p).nextmparam;
                ++paramno;
L365 :;
            }L366 :;
            ;
            if ((cc_decls_nextlx.symptr == stname)) {
                cc_decls_nextlx.flags |= (u8)1u;
            };
        };
        ++ntokens;
        tk = cc_lex_alloctoken();
        (*tk) = cc_decls_nextlx;
        cc_lex_addlisttoken(&tklist,&tklistx,tk);
    }L363 :;
    ;
    (*stname).tokenlist = tklist;
    (*stname).attribs.ax_nparams = (u64)(nparams);
}

static void cc_lex_readalphanumeric(byte * pstart) {
    L367 :;
    while (!!((u64)(cc_lex_alphamap[((i64)((*cc_lex_lxsptr++)))]))) {
L368 :;
    }L369 :;
    ;
    --cc_lex_lxsptr;
    cc_decls_nextlx.svalue = pstart;
    cc_decls_nextlx.symbol = (u64)((i64)59);
    cc_decls_nextlx.length = (cc_lex_lxsptr - pstart);
}

static i64 cc_lex_inmacrostack(struct cc_decls_strec * d,struct cc_decls_tokenrec * macrostack) {
    L370 :;
    while (!!(macrostack)) {
        if (((*macrostack).symptr == d)) {
            return (i64)1;
        };
        macrostack = (*macrostack).nexttoken;
L371 :;
    }L372 :;
    ;
    return (i64)0;
}

static void cc_lex_showtokens(byte * caption,struct cc_decls_tokenrec * tk) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_str(caption,NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_str((byte*)"<",NULL);
    msysnewc_m_print_end();
    ;
    L373 :;
    while (!!(tk)) {
        cc_lex_showtoken(tk);
        tk = (*tk).nexttoken;
L374 :;
    }L375 :;
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)">",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
}

static void cc_lex_lexa(struct cc_decls_tokenrec * * tk) {
    if (((*tk) == cc_lex_normaltk)) {
        cc_lex_lexreadtoken();
        return;
    };
    if (((*tk) == 0)) {
        cc_decls_nextlx.symbol = (u64)((i64)58);
        return;
    };
    cc_decls_nextlx = (*(*tk));
    (*tk) = (*(*tk)).nexttoken;
}

static void cc_lex_lexm(void) {
    struct cc_decls_strec *  d;
    static i64 doreset = (i64)0;
    i64 newlineno;
    L376 :;
    while (1) {
        if (!!(cc_lex_tkptr)) {
            cc_decls_nextlx = (*cc_lex_tkptr);
            cc_lex_tkptr = (*cc_lex_tkptr).nexttoken;
            if ((cc_lex_tkptr == 0)) {
                if (((((i64)((u64)(cc_decls_nextlx.symbol)) == (i64)69) && ((i64)((u64)((*cc_decls_nextlx.symptr).nameid)) == (i64)1)) && !!(cc_lex_peeklb()))) {
                    cc_lex_setfileno(cc_decls_sfileno);
                    cc_decls_nextlx.lineno = (u64)(cc_decls_slineno);
                    doreset = (i64)0;
                    goto L378 ;
;
                };
                doreset = (i64)1;
            };
            return;
        };
        if (!!(doreset)) {
            cc_lex_setfileno(cc_decls_sfileno);
            cc_decls_nextlx.lineno = (u64)(cc_decls_slineno);
            doreset = (i64)0;
        };
        if (!!(cc_lex_firstsymbol)) {
            cc_lex_firstsymbol = (i64)0;
            cc_lex_dospecialinclude();
        };
        cc_lex_lexreadtoken();
        //test1:
L378 :;
;
        if (((i64)(cc_decls_nextlx.symbol)==(i64)4)) {
            if (!!(cc_lex_dolexdirective())) {
                return;
            };
            goto L376 ;
        }else if (((i64)(cc_decls_nextlx.symbol)==(i64)69)) {
            d = cc_decls_nextlx.symptr;
            if (((i64)((*d).symbol)==(i64)71)) {
                cc_decls_sfileno = cc_lex_getfileno();
                cc_decls_slineno = (i64)(cc_decls_nextlx.lineno);
                cc_lex_expandpredefmacro((i64)((*d).subcode),&cc_decls_nextlx,cc_decls_slineno);
                doreset = (i64)1;
                return;
            } else {
                if ((((i64)((u64)((*d).nameid)) != (i64)1) || !!(cc_lex_noexpand))) {
                    return;
                };
            };
        } else {
            return;
        };
        cc_decls_sfileno = cc_lex_getfileno();
        cc_decls_slineno = (i64)(cc_decls_nextlx.lineno);
        if (!!((u64)((*d).attribs.ax_flmacro))) {
            if (!(!!(cc_lex_peeklb()))) {
                return;
            };
            cc_lex_tkptr = cc_lex_expandfnmacro(d,(struct cc_decls_tokenrec *)(0),&cc_lex_normaltk,(i64)1,&newlineno);
            cc_decls_slineno = newlineno;
        } else {
            cc_lex_tkptr = cc_lex_expandobjmacro(d,(struct cc_decls_tokenrec *)(0),&cc_lex_normaltk,(i64)1);
        };
        if ((cc_lex_tkptr == 0)) {
            doreset = (i64)1;
        };
    }L377 :;
    ;
}

static i64 cc_lex_peeklb(void) {
    if ((((u64)((*cc_lex_lxsptr)) == '(') || (((u64)((*cc_lex_lxsptr)) == ' ') && ((u64)((*(cc_lex_lxsptr + (i64)1))) == '(')))) {
        return (i64)1;
    };
    return (i64)0;
}

static i64 cc_lex_peektk(struct cc_decls_tokenrec * tk) {
    tk = (*tk).nexttoken;
    if ((tk == 0)) {
        return (i64)0;
    };
    if (((i64)((u64)((*tk).symbol)) == (i64)13)) {
        return (i64)1;
    };
    return (i64)0;
}

static struct cc_decls_tokenrec * cc_lex_expandobjmacro(struct cc_decls_strec * m,struct cc_decls_tokenrec * macrostack,struct cc_decls_tokenrec * * tksource,i64 frombaselevel) {
    struct cc_decls_tokenrec *  tk;
    struct cc_decls_tokenrec *  p;
    struct cc_decls_tokenrec *  repl;
    struct cc_decls_tokenrec newmacro;
    i64 iscomplex;
    i64 useshh;
    i64 expanded;
    struct cc_decls_strec *  d;
    p = (tk = (*m).tokenlist);
    iscomplex = (useshh = (i64)0);
    L379 :;
    while (!!(p)) {
        if (((i64)((u64)((*p).symbol)) == (i64)69)) {
            d = (*p).symptr;
            if ((((i64)((u64)((*d).nameid)) == (i64)1) || ((i64)((u64)((*d).symbol)) == (i64)71))) {
                iscomplex = (i64)1;
                goto L381 ;
            };
        } else if (((i64)((u64)((*p).symbol)) == (i64)7)) {
            iscomplex = (useshh = (i64)1);
            goto L381 ;
        };
        p = (*p).nexttoken;
L380 :;
    }L381 :;
    ;
    if (!(!!(iscomplex))) {
        return tk;
    };
    newmacro.symptr = m;
    newmacro.nexttoken = macrostack;
    if (!!(useshh)) {
        repl = cc_lex_substituteargs(m,(struct cc_decls_tokenrec * (*)[])(0),(struct cc_decls_tokenrec * (*)[])(0),(i64)0,(struct cc_decls_tokenrec *)(0));
    } else {
        repl = (*m).tokenlist;
    };
    tk = cc_lex_scantokenseq(repl,&newmacro,&expanded);
    return tk;
}

static struct cc_decls_tokenrec * cc_lex_expandfnmacro(struct cc_decls_strec * m,struct cc_decls_tokenrec * macrostack,struct cc_decls_tokenrec * * tksource,i64 frombaselevel,i64 * endlineno) {
    struct cc_decls_tokenrec *  args[200];
    struct cc_decls_tokenrec *  expargs[200];
    struct cc_decls_tokenrec *  repl;
    struct cc_decls_tokenrec newmacro;
    i64 nargs;
    i64 i;
    i64 expanded;
    nargs = cc_lex_readmacrocall(m,&args,tksource);
    if (!!(frombaselevel)) {
        (*endlineno) = (i64)(cc_decls_nextlx.lineno);
    };
    L382 :;
    for (i=(i64)1;i<=nargs;i+=(i64)1) {
L383 :;
        expargs[(i)-1] = (struct cc_decls_tokenrec *)(0);
L384 :;
    }L385 :;
    ;
    repl = cc_lex_substituteargs(m,&args,&expargs,nargs,macrostack);
    newmacro.symptr = m;
    newmacro.nexttoken = macrostack;
    repl = cc_lex_scantokenseq(repl,&newmacro,&expanded);
    return repl;
}

static struct cc_decls_tokenrec * cc_lex_scantokenseq(struct cc_decls_tokenrec * tk,struct cc_decls_tokenrec * macrostack,i64 * expanded) {
    struct cc_decls_tokenrec *  newtk;
    struct cc_decls_tokenrec *  newtkx;
    struct cc_decls_tokenrec *  expandtk;
    struct cc_decls_tokenrec *  oldtk;
    struct cc_decls_strec *  m;
    i64 noexpandflag;
    i64 simple;
    i64 dummy;
    //reenter:
L386 :;
;
    (*expanded) = (i64)0;
    newtk = (newtkx = (struct cc_decls_tokenrec *)(0));
    noexpandflag = (i64)0;
    simple = (i64)1;
    oldtk = tk;
    L387 :;
    while (!!(tk)) {
        if (((i64)((*tk).symbol)==(i64)69)) {
            if ((((i64)((u64)((*(*tk).symptr).nameid)) == (i64)1) || ((i64)((u64)((*(*tk).symptr).symbol)) == (i64)71))) {
                simple = (i64)0;
                goto L389 ;
            };
        };
        if ((tk == 0)) {
            goto L389 ;
        };
        tk = (*tk).nexttoken;
L388 :;
    }L389 :;
    ;
    if (!!(simple)) {
        return oldtk;
    };
    tk = oldtk;
    L390 :;
    while (!!(tk)) {
        if (((i64)((*tk).symbol)==(i64)69)) {
            m = (*tk).symptr;
            if ((((i64)((u64)((*m).nameid)) == (i64)1) && !(!!(noexpandflag)))) {
                if ((!!(((i64)((u64)((*tk).flags)) & (i64)4)) || !!(cc_lex_noexpand))) {
                    goto L393 ;
;
                };
                if (!!(cc_lex_inmacrostack(m,macrostack))) {
                    cc_lex_addlisttoken_copy(&newtk,&newtkx,tk);
                    (*newtkx).flags |= (u8)4u;
                    goto L394 ;
;
                };
                simple = (i64)0;
                if (!!((u64)((*m).attribs.ax_flmacro))) {
                    if (!(!!(cc_lex_peektk(tk)))) {
                        goto L393 ;
;
                    };
                    cc_lex_lexa(&tk);
                    expandtk = cc_lex_expandfnmacro(m,macrostack,&tk,(i64)1,&dummy);
                    cc_lex_addlisttoken_seq(&newtk,&newtkx,expandtk);
                    (*expanded) = (i64)1;
                    goto L391 ;
                } else {
                    expandtk = cc_lex_expandobjmacro(m,macrostack,&tk,(i64)0);
                    (*expanded) = (i64)1;
                    cc_lex_addlisttoken_seq(&newtk,&newtkx,expandtk);
                };
            } else if (((i64)((u64)((*m).symbol)) == (i64)94)) {
                noexpandflag = (i64)1;
                goto L393 ;
;
            } else if (((i64)((u64)((*m).symbol)) == (i64)71)) {
                expandtk = cc_lex_alloctokenz();
                cc_lex_expandpredefmacro((i64)((*m).subcode),expandtk,cc_decls_slineno);
                cc_lex_addlisttoken_copy(&newtk,&newtkx,expandtk);
                goto L395 ;
;
            } else {
                noexpandflag = (i64)0;
                goto L393 ;
;
            };
        } else {
            //simpletoken:
L393 :;
;
            cc_lex_addlisttoken_copy(&newtk,&newtkx,tk);
        };
        //skip:
L394 :;
;
        if ((tk == 0)) {
            goto L392 ;
        };
        //skip2:
L395 :;
;
        tk = (*tk).nexttoken;
L391 :;
    }L392 :;
    ;
    if (!!((*expanded))) {
        tk = newtk;
        goto L386 ;
;
    };
    return newtk;
}

static i64 cc_lex_readmacrocall(struct cc_decls_strec * d,struct cc_decls_tokenrec * (*args)[],struct cc_decls_tokenrec * * tksource) {
    i64 nparams;
    i64 lbcount;
    i64 paramno;
    i64 nargs;
    i64 usesvargs;
    i64 varg;
    struct cc_decls_tokenrec *  tklist;
    struct cc_decls_tokenrec *  tklistx;
    cc_lex_lexa(tksource);
    if (((i64)((u64)(cc_decls_nextlx.symbol)) != (i64)13)) {
        cc_lex_lxerror((byte*)"rmc: no '('");
    };
    nparams = (i64)((*d).attribs.ax_nparams);
    nargs = (i64)0;
    if ((nparams == (i64)0)) {
        cc_lex_lexa(tksource);
        if (((i64)((u64)(cc_decls_nextlx.symbol)) != (i64)14)) {
            cc_lex_lxerror((byte*)"rmc: ')' expected");
        };
        return (i64)0;
    };
    paramno = (i64)1;
    lbcount = (i64)1;
    tklist = (tklistx = (struct cc_decls_tokenrec *)(0));
    usesvargs = (i64)((*d).attribs.ax_varparams);
    varg = (i64)0;
    L396 :;
    while (1) {
        if (((paramno == nparams) && !!(usesvargs))) {
            varg = (i64)1;
        };
        cc_lex_lexa(tksource);
        if (((i64)(cc_decls_nextlx.symbol)==(i64)8)) {
            if (((lbcount == (i64)1) && !(!!(varg)))) {
                if ((tklist == 0)) {
                    tklist = cc_lex_alloctokenz();
                    cc_lex_setfilenox(tklist,cc_lex_getfileno());
                    (*tklist).symbol = (u64)((i64)67);
                };
                (*args)[(paramno)-1] = tklist;
                tklist = (tklistx = (struct cc_decls_tokenrec *)(0));
                ++paramno;
            } else {
                goto L398 ;
;
            };
        }else if (((i64)(cc_decls_nextlx.symbol)==(i64)58)) {
            cc_lex_lxerror((byte*)"EOS in macro call");
        }else if (((i64)(cc_decls_nextlx.symbol)==(i64)13)) {
            ++lbcount;
            goto L398 ;
;
        }else if (((i64)(cc_decls_nextlx.symbol)==(i64)14)) {
            if ((lbcount > (i64)1)) {
                --lbcount;
                cc_lex_addlist_nextlx(&tklist,&tklistx);
            } else {
                if ((tklist == 0)) {
                    tklist = cc_lex_alloctokenz();
                    cc_lex_setfilenox(tklist,cc_lex_getfileno());
                    (*tklist).symbol = (u64)((i64)67);
                };
                (*args)[(paramno)-1] = tklist;
                goto L397 ;
            };
        } else {
            //addtoken:
L398 :;
;
            cc_lex_addlist_nextlx(&tklist,&tklistx);
        };
    }L397 :;
    ;
    if ((paramno != nparams)) {
        if ((((paramno + (i64)1) == nparams) && !!(usesvargs))) {
            (*args)[(nparams)-1] = (struct cc_decls_tokenrec *)(0);
        } else {
            cc_lex_lxerror((byte*)"Wrong # macro params");
        };
    };
    return nparams;
}

static struct cc_decls_tokenrec * cc_lex_substituteargs(struct cc_decls_strec * m,struct cc_decls_tokenrec * (*args)[],struct cc_decls_tokenrec * (*expargs)[],i64 nargs,struct cc_decls_tokenrec * macrostack) {
    struct cc_decls_mparamrec *  params;
    struct cc_decls_tokenrec *  seq;
    struct cc_decls_tokenrec *  seqstart;
    struct cc_decls_tokenrec *  lasttoken;
    struct cc_decls_tokenrec *  newtk;
    struct cc_decls_tokenrec *  newtkx;
    struct cc_decls_tokenrec *  niltk;
    struct cc_decls_tokenrec *  tkexp;
    struct cc_decls_tokenrec tk;
    i64 n;
    i64 i;
    i64 expanded;
    struct cc_decls_tokenrec *  hhpoints[100];
    i64 nhashhash;
    params = (*m).mparamlist;
    seq = (seqstart = (*m).tokenlist);
    newtk = (newtkx = (struct cc_decls_tokenrec *)(0));
    nhashhash = (i64)0;
    lasttoken = (struct cc_decls_tokenrec *)(0);
    L399 :;
    while (!!(seq)) {
        if (((i64)((*seq).symbol)==(i64)5)) {
            if (!!(nargs)) {
                seq = (*seq).nexttoken;
                if ((seq == 0)) {
                    cc_lex_lxerror((byte*)"# at end");
                };
                if (!(!!(((i64)((u64)((*seq).flags)) & (i64)2)))) {
                    cc_lex_lxerror((byte*)"# not followed by param");
                };
                n = (i64)((*seq).paramno);
                cc_lex_stringify((*args)[(n)-1],&tk);
                cc_lex_addlisttoken_copy(&newtk,&newtkx,&tk);
            } else {
                cc_lex_addlisttoken(&newtk,&newtkx,seq);
                (*newtkx).symbol = (u64)((i64)6);
            };
        }else if (((i64)((*seq).symbol)==(i64)7)) {
            if ((seq == seqstart)) {
                cc_lex_lxerror((byte*)"## at start");
            };
            if ((nhashhash >= (i64)100)) {
                cc_lex_lxerror((byte*)"Too many ##");
            };
            hhpoints[(++nhashhash)-1] = newtkx;
        } else {
            if (((((i64)((u64)((*seq).symbol)) == (i64)69) && !!(((i64)((u64)((*seq).flags)) & (i64)2))) && !!(nargs))) {
                n = (i64)((*seq).paramno);
                if (((!!((*seq).nexttoken) && ((i64)((u64)((*(*seq).nexttoken).symbol)) == (i64)7)) || (!!(lasttoken) && ((i64)((u64)((*lasttoken).symbol)) == (i64)7)))) {
                    cc_lex_addlisttoken_seq(&newtk,&newtkx,(*args)[(n)-1]);
                } else {
                    tkexp = (*expargs)[(n)-1];
                    if ((tkexp == 0)) {
                        tkexp = ((*expargs)[(n)-1] = cc_lex_scantokenseq((*args)[(n)-1],macrostack,&expanded));
                    };
                    cc_lex_addlisttoken_seq(&newtk,&newtkx,tkexp);
                };
            } else {
                //doother:
L402 :;
;
                cc_lex_addlisttoken_copy(&newtk,&newtkx,seq);
            };
        };
        lasttoken = seq;
        seq = (*seq).nexttoken;
L400 :;
    }L401 :;
    ;
    if (!!(nhashhash)) {
        niltk = (struct cc_decls_tokenrec *)(0);
        L403 :;
        for (i=(i64)1;i<=nhashhash;i+=(i64)1) {
L404 :;
            cc_lex_pastetokens(hhpoints[(i)-1],((i < nhashhash)?&hhpoints[((i + (i64)1))-1]:&niltk));
L405 :;
        }L406 :;
        ;
    };
    return newtk;
}

static byte * cc_lex_strtoken(struct cc_decls_tokenrec * lp,i64 * length) {
    byte *  name;
    byte *  s;
    struct cc_decls_tokenrec l;
    l = (*lp);
    if (((i64)(l.symbol)==(i64)69)) {
        //doname:
L407 :;
;
        (*length) = (i64)((*l.symptr).namelen);
        return (*l.symptr).name;
    }else if (((i64)(l.symbol)==(i64)60) || ((i64)(l.symbol)==(i64)61)) {
        (*length) = (i64)(l.length);
        if (!!(cc_lex_getfilenox(&l))) {
            return (cc_decls_sourcefiletext[(cc_lex_getfilenox(&l))] + cc_lex_getnumberoffsetx(&l));
        } else {
            return cc_lex_pastedtokenlist[((i64)(l.pasteno))-1];
        };
    }else if (((i64)(l.symbol)==(i64)59)) {
        (*length) = (i64)(l.length);
        return l.svalue;
    }else if (((i64)(l.symbol)==(i64)64) || ((i64)(l.symbol)==(i64)65)) {
        s = cc_lex_strstring(l.svalue,(i64)(l.length),length,(i64)34);
        return s;
    }else if (((i64)(l.symbol)==(i64)62)) {
        s = cc_lex_strstring(l.svalue,(i64)(l.length),length,(i64)39);
        return s;
    }else if (((i64)(l.symbol)==(i64)57)) {
        if (!!(cc_lex_dowhitespace)) {
            (*length) = ((i64)(l.length) + (i64)1);
            s = (byte *)(mlib_pcm_alloc((*length)));
            (*s) = (u64)10u;
            memcpy((void *)((s + (i64)1)),(void *)(l.svalue),(u64)(l.length));
        } else {
            (*length) = (i64)1;
            return (byte*)"\n";
        };
        return s;
    }else if (((i64)(l.symbol)==(i64)58)) {
        (*length) = (i64)0;
        return (byte*)"";
    }else if (((i64)(l.symbol)==(i64)72) || ((i64)(l.symbol)==(i64)88) || ((i64)(l.symbol)==(i64)87) || ((i64)(l.symbol)==(i64)89)) {
        goto L407 ;
;
    } else {
        name = cc_tables_shortsymbolnames[((i64)(l.symbol))-1];
        if (!!(((*length) = (i64)(strlen((i8 *)(name)))))) {
            if (((u64)((*name)) != 'k')) {
                return name;
            } else {
                (*length) = (i64)(strlen((i8 *)((cc_tables_symbolnames[((i64)(l.symbol))-1] + (i64)1))));
                return (cc_tables_symbolnames[((i64)(l.symbol))-1] + (i64)1);
            };
        } else {
            return (byte*)"";
        };
    };
    return (byte*)"";
}

static byte * cc_lex_strstring(byte * s,i64 length,i64 * newlength,i64 quotechar) {
    byte *  t;
    byte *  u;
    t = (u = (byte *)(mlib_pcm_alloc(((length * (i64)2) + (i64)4))));
    if (!!(quotechar)) {
        (*u) = (u64)(quotechar);
        ++u;
    };
    cc_lib_convertstring(s,u,length);
    (*newlength) = (i64)(strlen((i8 *)(t)));
    if (!!(quotechar)) {
        (*(t + (*newlength))) = (u64)(quotechar);
        ++(*newlength);
    };
    return t;
}

void cc_lex_emittoken(struct cc_decls_tokenrec * lp,struct mlib_strbuffer * dest,i64 forcespace) {
    i64 length;
    byte *  s;
    if ((((i64)((u64)((*lp).symbol)) == (i64)57) && (cc_lex_lasttoken == (i64)57))) {
        return;
    };
    s = cc_lex_strtoken(lp,&length);
    if ((!!(forcespace) || !!(cc_lex_needspace(cc_lex_lasttoken,(i64)((*lp).symbol))))) {
        mlib_gs_char(dest,(i64)32);
    };
    mlib_gs_strn(dest,s,length);
    cc_lex_lasttoken = (i64)((*lp).symbol);
}

void cc_lex_showtoken(struct cc_decls_tokenrec * lp) {
    static struct mlib_strbuffer buffer;
    static struct mlib_strbuffer *  dest = &buffer;
    mlib_gs_init(dest);
    cc_lex_emittoken(lp,dest,(i64)0);
    msysnewc_m_print_startcon();
    msysnewc_m_print_i64((*dest).length,(byte*)"v");
    msysnewc_m_print_nogap();
    msysnewc_m_print_str((*dest).strptr,(byte*)".*");
    msysnewc_m_print_end();
    ;
}

static void cc_lex_stringify(struct cc_decls_tokenrec * seq,struct cc_decls_tokenrec * dest) {
    byte *  s;
    i64 length;
    i64 addspace;
    static struct mlib_strbuffer buffer;
    static struct mlib_strbuffer *  deststr = &buffer;
    (*dest).symbol = (u64)((i64)64);
    (*dest).nexttoken = (struct cc_decls_tokenrec *)(0);
    if (((*seq).nexttoken == 0)) {
        s = cc_lex_strtoken(seq,&length);
        (*dest).length = length;
        (*dest).svalue = s;
        return;
    };
    mlib_gs_init(deststr);
    cc_lex_lasttoken = (i64)0;
    addspace = (i64)0;
    L408 :;
    while (!!(seq)) {
        cc_lex_emittoken(seq,deststr,addspace);
        addspace = (i64)1;
        seq = (*seq).nexttoken;
L409 :;
    }L410 :;
    ;
    (*dest).length = length;
    (*dest).svalue = (*deststr).strptr;
    (*dest).length = (i64)((*deststr).length);
}

static void cc_lex_pastetokens(struct cc_decls_tokenrec * tk,struct cc_decls_tokenrec * * tknext) {
    struct cc_decls_tokenrec *  tk2;
    i64 length1;
    i64 length2;
    byte *  s;
    byte *  t;
    byte *  u;
    struct cc_decls_tokenrec oldtoken;
    struct cc_decls_tokenrec token;
    byte *  oldlxsptr;
    i64 oldlx_stackindex;
    tk2 = (*tk).nexttoken;
    if ((tk2 == (*tknext))) {
        (*tknext) = tk;
    };
    (*tk).nexttoken = (*tk2).nexttoken;
    if (((i64)((u64)((*tk).symbol)) == (i64)67)) {
        if (((i64)((u64)((*tk2).symbol)) == (i64)67)) {
        } else {
            (*tk) = (*tk2);
        };
    } else if (((i64)((u64)((*tk2).symbol)) == (i64)67)) {
    } else {
        s = cc_lex_strtoken(tk,&length1);
        t = cc_lex_strtoken(tk2,&length2);
        u = (byte *)(mlib_pcm_alloc((length1 + length2)));
        memcpy((void *)(u),(void *)(s),(u64)(length1));
        memcpy((void *)((u + length1)),(void *)(t),(u64)(length2));
        (*((u + length1) + length2)) = (u64)0u;
        if ((cc_lex_npastedtokens >= (i64)87000)) {
            cc_lex_lxerror((byte*)"Too many pasted tokens");
        };
        cc_lex_pastedtokenlist[(++cc_lex_npastedtokens)-1] = u;
        oldtoken = cc_decls_nextlx;
        oldlxsptr = cc_lex_lxsptr;
        oldlx_stackindex = cc_lex_lx_stackindex;
        cc_lex_lxsptr = u;
        cc_lex_lx_stackindex = (i64)0;
        cc_lex_setfileno((i64)0);
        cc_decls_nextlx.lineno = (u64)((i64)0);
        cc_lex_lexreadtoken();
        token = cc_decls_nextlx;
        cc_lex_lexreadtoken();
        if (((i64)((u64)(cc_decls_nextlx.symbol)) != (i64)58)) {
        };
        cc_decls_nextlx = oldtoken;
        cc_lex_lxsptr = oldlxsptr;
        cc_lex_lx_stackindex = oldlx_stackindex;
        token.nexttoken = (*tk).nexttoken;
        cc_lex_setfilenox(&token,(i64)0);
        token.pasteno = cc_lex_npastedtokens;
        token.flags |= (u8)8u;
        (*tk) = token;
    };
}

static i64 cc_lex_getifexpr(void) {
    i64 sx;
    i64 x;
    cc_lex_lexm();
    x = cc_lex_evalcondexpr(&sx);
    if (((i64)((u64)(cc_decls_nextlx.symbol)) != (i64)57)) {
        cc_lex_lxerror((byte*)"#if:eol expected");
    };
    return (x != (i64)0);
}

static i64 cc_lex_evalcondexpr(i64 * sx) {
    i64 x;
    i64 y;
    i64 z;
    i64 sy;
    i64 sz;
    x = cc_lex_evalorexpr(sx);
    if (((i64)((u64)(cc_decls_nextlx.symbol)) == (i64)19)) {
        cc_lex_lexm();
        y = cc_lex_evalcondexpr(&sy);
        if (((i64)((u64)(cc_decls_nextlx.symbol)) != (i64)10)) {
            cc_lex_lxerror((byte*)": expected");
        };
        cc_lex_lexm();
        z = cc_lex_evalcondexpr(&sz);
        if (!!(x)) {
            (*sx) = sy;
            x = y;
        } else {
            (*sx) = sz;
            x = z;
        };
    };
    return x;
}

static i64 cc_lex_evalorexpr(i64 * sx) {
    i64 x;
    i64 y;
    i64 sy;
    x = cc_lex_evalandexpr(sx);
    L411 :;
    while (((i64)((u64)(cc_decls_nextlx.symbol)) == (i64)31)) {
        cc_lex_lexm();
        y = cc_lex_evalandexpr(&sy);
        x = ((!!(x) || !!(y))?(i64)1:(i64)0);
L412 :;
    }L413 :;
    ;
    return x;
}

static i64 cc_lex_evalandexpr(i64 * sx) {
    i64 x;
    i64 y;
    i64 sy;
    x = cc_lex_evaliorexpr(sx);
    L414 :;
    while (((i64)((u64)(cc_decls_nextlx.symbol)) == (i64)32)) {
        cc_lex_lexm();
        y = cc_lex_evaliorexpr(&sy);
        x = ((!!(x) && !!(y))?(i64)1:(i64)0);
L415 :;
    }L416 :;
    ;
    return x;
}

static i64 cc_lex_evaliorexpr(i64 * sx) {
    i64 x;
    i64 sy;
    x = cc_lex_evalixorexpr(sx);
    L417 :;
    while (((i64)((u64)(cc_decls_nextlx.symbol)) == (i64)28)) {
        cc_lex_lexm();
        x |= cc_lex_evalixorexpr(&sy);
L418 :;
    }L419 :;
    ;
    return x;
}

static i64 cc_lex_evalixorexpr(i64 * sx) {
    i64 x;
    i64 sy;
    x = cc_lex_evaliandexpr(sx);
    L420 :;
    while (((i64)((u64)(cc_decls_nextlx.symbol)) == (i64)30)) {
        cc_lex_lexm();
        x ^= cc_lex_evaliandexpr(&sy);
L421 :;
    }L422 :;
    ;
    return x;
}

static i64 cc_lex_evaliandexpr(i64 * sx) {
    i64 x;
    i64 sy;
    x = cc_lex_evaleqexpr(sx);
    L423 :;
    while (((i64)((u64)(cc_decls_nextlx.symbol)) == (i64)29)) {
        cc_lex_lexm();
        x &= cc_lex_evaleqexpr(&sy);
L424 :;
    }L425 :;
    ;
    return x;
}

static i64 cc_lex_evaleqexpr(i64 * sx) {
    i64 x;
    i64 y;
    i64 sy;
    i64 opc;
    x = cc_lex_evalcmpexpr(sx);
    L426 :;
    while ((((opc = (i64)(cc_decls_nextlx.symbol)) == (i64)40) || (opc == (i64)41))) {
        cc_lex_lexm();
        y = cc_lex_evalcmpexpr(&sy);
        if ((opc==(i64)40)) {
            x = (x == y);
        }else if ((opc==(i64)41)) {
            x = (x != y);
        };
L427 :;
    }L428 :;
    ;
    return x;
}

static i64 cc_lex_evalcmpexpr(i64 * sx) {
    i64 x;
    i64 y;
    i64 sy;
    i64 opc;
    x = cc_lex_evalshiftexpr(sx);
    L429 :;
    while ((((((opc = (i64)(cc_decls_nextlx.symbol)) == (i64)42) || (opc == (i64)43)) || (opc == (i64)44)) || (opc == (i64)45))) {
        cc_lex_lexm();
        y = cc_lex_evalshiftexpr(&sy);
        if ((opc==(i64)42)) {
            x = (x < y);
        }else if ((opc==(i64)43)) {
            x = (x <= y);
        }else if ((opc==(i64)44)) {
            x = (x >= y);
        }else if ((opc==(i64)45)) {
            x = (x > y);
        };
L430 :;
    }L431 :;
    ;
    return x;
}

static i64 cc_lex_evalshiftexpr(i64 * sx) {
    i64 x;
    i64 y;
    i64 sy;
    i64 opc;
    x = cc_lex_evaladdexpr(sx);
    L432 :;
    while ((((opc = (i64)(cc_decls_nextlx.symbol)) == (i64)33) || (opc == (i64)34))) {
        cc_lex_lexm();
        y = cc_lex_evaladdexpr(&sy);
        if ((opc==(i64)34)) {
            x = (x >> y);
        }else if ((opc==(i64)33)) {
            x = (x << y);
        };
L433 :;
    }L434 :;
    ;
    return x;
}

static i64 cc_lex_evaladdexpr(i64 * sx) {
    i64 x;
    i64 y;
    i64 sy;
    i64 opc;
    x = cc_lex_evalmulexpr(sx);
    L435 :;
    while ((((opc = (i64)(cc_decls_nextlx.symbol)) == (i64)23) || (opc == (i64)24))) {
        cc_lex_lexm();
        y = cc_lex_evalmulexpr(&sy);
        if ((opc==(i64)23)) {
            x += y;
        }else if ((opc==(i64)24)) {
            x -= y;
        };
L436 :;
    }L437 :;
    ;
    return x;
}

static i64 cc_lex_evalmulexpr(i64 * sx) {
    i64 x;
    i64 y;
    i64 sy;
    i64 opc;
    x = cc_lex_evalunaryexpr(sx);
    L438 :;
    while (((((opc = (i64)(cc_decls_nextlx.symbol)) == (i64)25) || (opc == (i64)26)) || (opc == (i64)27))) {
        cc_lex_lexm();
        y = cc_lex_evalunaryexpr(&sy);
        if (((y == (i64)0) && (opc != (i64)25))) {
            cc_lex_lxerror((byte*)"#if:div by zero");
        };
        if ((opc==(i64)25)) {
            x *= y;
        }else if ((opc==(i64)26)) {
            x = (x / y);
        }else if ((opc==(i64)27)) {
            x = (x % y);
        };
L439 :;
    }L440 :;
    ;
    return x;
}

static i64 cc_lex_evalunaryexpr(i64 * sx) {
    i64 x;
    i64 opc;
    if (((i64)(cc_decls_nextlx.symbol)==(i64)23) || ((i64)(cc_decls_nextlx.symbol)==(i64)24) || ((i64)(cc_decls_nextlx.symbol)==(i64)36) || ((i64)(cc_decls_nextlx.symbol)==(i64)35)) {
        opc = (i64)(cc_decls_nextlx.symbol);
        cc_lex_lexm();
        x = cc_lex_evalunaryexpr(sx);
        if ((opc==(i64)23)) {
            return x;
        }else if ((opc==(i64)24)) {
            return -(x);
        }else if ((opc==(i64)36)) {
            return !(x);
        }else if ((opc==(i64)35)) {
            return ~(x);
        };
    };
    return cc_lex_evalterm(sx);
}

static i64 cc_lex_evalterm(i64 * sx) {
    i64 res;
    i64 lb;
    (*sx) = (i64)1;
    if (((i64)(cc_decls_nextlx.symbol)==(i64)69)) {
        if (((i64)((*cc_decls_nextlx.symptr).symbol)==(i64)94)) {
            cc_lex_noexpand = (i64)1;
            lb = (i64)0;
            cc_lex_lexm();
            if (((i64)((u64)(cc_decls_nextlx.symbol)) == (i64)13)) {
                lb = (i64)1;
                cc_lex_lexm();
            };
            if (((i64)((u64)(cc_decls_nextlx.symbol)) != (i64)69)) {
                cc_lex_lxerror((byte*)"defined?");
            };
            res = ((i64)((u64)((*cc_decls_nextlx.symptr).nameid)) == (i64)1);
            cc_lex_lexm();
            if (!!(lb)) {
                if (((i64)((u64)(cc_decls_nextlx.symbol)) != (i64)14)) {
                    cc_lex_lxerror((byte*)"')' expected");
                };
                cc_lex_lexm();
            };
            cc_lex_noexpand = (i64)0;
        }else if (((i64)((*cc_decls_nextlx.symptr).symbol)==(i64)92)) {
            cc_lex_lexm();
            if (((i64)((u64)(cc_decls_nextlx.symbol)) != (i64)13)) {
                cc_lex_lxerror((byte*)"'(' expected");
            };
            cc_lex_lexm();
            if (((i64)((u64)(cc_decls_nextlx.symbol)) != (i64)69)) {
                cc_lex_lxerror((byte*)"name expected");
            };
            if (((i64)((*cc_decls_nextlx.symptr).symbol)==(i64)72)) {
                res = (i64)(cc_tables_typespecsizes[((i64)((*cc_decls_nextlx.symptr).subcode))-1]);
            } else {
                cc_lex_lxerror((byte*)"sizeof2");
            };
            cc_lex_lexm();
            if (((i64)((u64)(cc_decls_nextlx.symbol)) != (i64)14)) {
                cc_lex_lxerror((byte*)"')' expected");
            };
            cc_lex_lexm();
        } else {
            cc_lex_lexm();
            return (i64)0;
        };
    }else if (((i64)(cc_decls_nextlx.symbol)==(i64)60)) {
        res = cc_decls_nextlx.value;
        cc_lex_lexm();
    }else if (((i64)(cc_decls_nextlx.symbol)==(i64)62)) {
        if (((i64)(cc_decls_nextlx.length) == (i64)0)) {
            res = (i64)0;
        } else {
            res = (i64)((*cc_decls_nextlx.svalue));
        };
        cc_lex_lexm();
    }else if (((i64)(cc_decls_nextlx.symbol)==(i64)13)) {
        cc_lex_lexm();
        res = cc_lex_evalcondexpr(sx);
        if (((i64)((u64)(cc_decls_nextlx.symbol)) != (i64)14)) {
            cc_lex_lxerror((byte*)") expected");
        };
        cc_lex_lexm();
    } else {
        cc_lex_printsymbol(&cc_decls_nextlx);
        cc_lex_printstrn(cc_decls_nextlx.svalue,(i64)(cc_decls_nextlx.length),0);
        msysnewc_m_print_startcon();
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        cc_lex_lxerror((byte*)"evalterm?");
    };
    return res;
}

static i64 cc_lex_getifdef(void) {
    i64 res;
    struct cc_decls_strec *  d;
    cc_lex_noexpand = (i64)1;
    cc_lex_lexreadtoken();
    cc_lex_noexpand = (i64)0;
    if (((i64)((u64)(cc_decls_nextlx.symbol)) != (i64)69)) {
        cc_lex_lxerror((byte*)"Name expected");
    };
    d = cc_decls_nextlx.symptr;
    res = (i64)0;
    if (((i64)((u64)((*d).nameid)) == (i64)1)) {
        res = (i64)1;
    } else if (((i64)((u64)((*d).symbol)) == (i64)71)) {
        res = (i64)1;
    };
    cc_lex_lexreadtoken();
    if (((i64)((u64)(cc_decls_nextlx.symbol)) != (i64)57)) {
        cc_lex_lxerror((byte*)"EOL expected");
    };
    return res;
}

static i64 cc_lex_skipcode(void) {
    i64 level;
    i64 dir;
    level = (i64)0;
    L441 :;
    while (1) {
        cc_lex_fastreadtoken();
        if (((i64)(cc_decls_nextlx.symbol)==(i64)4)) {
            dir = cc_lex_getlexdirective();
            if ((dir==(i64)3) || (dir==(i64)8) || (dir==(i64)9)) {
                ++level;
            }else if ((dir==(i64)4) || (dir==(i64)5)) {
                if ((level == (i64)0)) {
                    return dir;
                };
            }else if ((dir==(i64)6)) {
                if ((level == (i64)0)) {
                    return dir;
                };
                --level;
            };
        }else if (((i64)(cc_decls_nextlx.symbol)==(i64)58)) {
            cc_lex_lxerror((byte*)"#if:Unexpected eof");
        };
    }L442 :;
    ;
    return (i64)0;
}

static void cc_lex_freetokens(struct cc_decls_tokenrec * tk) {
    struct cc_decls_tokenrec *  nexttk;
    L443 :;
    while (!!(tk)) {
        nexttk = (*tk).nexttoken;
        tk = nexttk;
L444 :;
    }L445 :;
    ;
}

void cc_lex_fastreadtoken(void) {
    i64 dodir;
    byte *  p;
    cc_decls_nextlx.subcodex = (u64)((i64)0);
    L446 :;
    switch ((i64)((*cc_lex_lxsptr++))) {
    case 35:;
    {
        p = (cc_lex_lxsptr - (i64)2);
        dodir = (i64)0;
        L448 :;
        while ((p >= cc_lex_lxstart)) {
            if (((i64)((*p))==(i64)10)) {
                dodir = (i64)1;
                goto L450 ;
            }else if (((i64)((*p))==(i64)9) || ((i64)((*p))==(i64)32)) {
            } else {
                goto L450 ;
            };
            --p;
L449 :;
        }L450 :;
        ;
        if ((!!(dodir) || (p < cc_lex_lxstart))) {
            cc_decls_nextlx.symbol = (u64)((i64)4);
            return;
        } else if (((u64)((*cc_lex_lxsptr)) == '#')) {
            ++cc_lex_lxsptr;
        };
    }break;
    case 47:;
    {
        if (((i64)((*cc_lex_lxsptr))==(i64)47)) {
            cc_lex_readlinecomment();
        }else if (((i64)((*cc_lex_lxsptr))==(i64)42)) {
            cc_lex_readblockcomment();
        };
    }break;
    case 39:;
    {
        cc_lex_lxreadstring((i64)39,(i64)0);
    }break;
    case 34:;
    {
        cc_lex_lxreadstring((i64)34,(i64)0);
    }break;
    case 13:;
    {
        ++cc_decls_nextlx.lineno;
        cc_decls_nextlx.symbol = (u64)((i64)57);
        cc_decls_nextlx.length = (i64)0;
        ++cc_lex_lxsptr;
    }break;
    case 10:;
    {
        ++cc_decls_nextlx.lineno;
        cc_decls_nextlx.symbol = (u64)((i64)57);
        cc_decls_nextlx.length = (i64)0;
    }break;
    case 0:;
    {
        --cc_lex_lxsptr;
        if (!!(cc_lex_lx_stackindex)) {
            cc_lex_unstacksourcefile();
        } else {
            cc_decls_nextlx.symbol = (u64)((i64)58);
            return;
        };
    }break;
    case 12:;
    {
    }break;
    default: {
    }
    } //SW
goto L446 ;
L447 :;
    ;
}

static struct cc_decls_tokenrec * cc_lex_alloctoken(void) {
    struct cc_decls_tokenrec *  tk;
    tk = (struct cc_decls_tokenrec *)(mlib_pcm_alloc((i64)32));
    return tk;
}

static struct cc_decls_tokenrec * cc_lex_alloctokenz(void) {
    struct cc_decls_tokenrec *  tk;
    tk = (struct cc_decls_tokenrec *)(mlib_pcm_alloc((i64)32));
    (*tk).nexttoken = (struct cc_decls_tokenrec *)(0);
    return tk;
}

static void cc_lex_expandpredefmacro(i64 pdmcode,struct cc_decls_tokenrec * tk,i64 lineno) {
    byte str[256];
    static byte *  monthnames[12] = {
    (byte*)"Jan",
    (byte*)"Feb",
    (byte*)"Mar",
    (byte*)"Apr",
    (byte*)"May",
    (byte*)"Jun",
    (byte*)"Jul",
    (byte*)"Aug",
    (byte*)"Sep",
    (byte*)"Oct",
    (byte*)"Nov",
    (byte*)"Dec"
};
    struct osnos_rsystemtime tm;
    byte *  s;
    i64 fileno;
    if (!!(cc_lex_noexpand)) {
        return;
    };
    if ((pdmcode==(i64)1)) {
        osnos_os_getsystime((void *)(&tm));
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_setfmt((byte*)"#-#-#");
        msysnewc_m_print_i64(tm.day,NULL);
        msysnewc_m_print_str(monthnames[(tm.month)-1],NULL);
        msysnewc_m_print_i64(tm.year,(byte*)"4");
        msysnewc_m_print_end();
        ;
        (*tk).symbol = (u64)((i64)64);
        (*tk).svalue = mlib_pcm_copyheapstring(str);
    }else if ((pdmcode==(i64)2)) {
        osnos_os_getsystime((void *)(&tm));
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_setfmt((byte*)"#:#:#");
        msysnewc_m_print_i64(tm.hour,(byte*)"2");
        msysnewc_m_print_i64(tm.minute,(byte*)"z2");
        msysnewc_m_print_i64(tm.second,(byte*)"z2");
        msysnewc_m_print_end();
        ;
        (*tk).symbol = (u64)((i64)64);
        (*tk).svalue = mlib_pcm_copyheapstring(str);
    }else if ((pdmcode==(i64)3)) {
        (*tk).symbol = (u64)((i64)64);
        fileno = cc_lex_getfilenox(tk);
        if ((fileno == (i64)0)) {
            fileno = cc_decls_sfileno;
        };
        if (!!(cc_decls_sfileno)) {
            (*tk).svalue = cc_decls_sourcefilenames[(cc_decls_sfileno)];
        } else {
            (*tk).svalue = (byte*)"(File not available)";
        };
    }else if ((pdmcode==(i64)5)) {
        (*tk).symbol = (u64)((i64)64);
        if (!!(cc_decls_currproc)) {
            (*tk).svalue = (*cc_decls_currproc).name;
        } else {
            (*tk).svalue = (byte*)"???";
        };
    }else if ((pdmcode==(i64)4)) {
        (*tk).symbol = (u64)((i64)60);
        (*tk).value = lineno;
    }else if ((pdmcode==(i64)8)) {
        (*tk).symbol = (u64)((i64)60);
        (*tk).value = (i64)1;
    }else if ((pdmcode==(i64)7)) {
        (*tk).symbol = (u64)((i64)60);
        (*tk).value = (i64)1;
    } else {
        msysnewc_m_print_startcon();
        msysnewc_m_print_i64(pdmcode,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        cc_lex_lxerror((byte*)"PDM");
    };
    if (((i64)((u64)((*tk).symbol)) == (i64)64)) {
        (*tk).length = (i64)(strlen((i8 *)((*tk).svalue)));
        (*tk).subcode = (u64)(cc_decls_trefchar);
    } else {
        (*tk).subcode = (u64)((i64)4);
        s = (byte *)(mlib_pcm_alloc((i64)16));
        msysnewc_getstrint((*tk).value,s);
        (*tk).length = (i64)(strlen((i8 *)(s)));
        if ((cc_lex_npastedtokens >= (i64)87000)) {
            cc_lex_lxerror((byte*)"2:Too many pasted tokens");
        };
        cc_lex_pastedtokenlist[(++cc_lex_npastedtokens)-1] = s;
        cc_lex_setfilenox(tk,(i64)0);
        (*tk).pasteno = cc_lex_npastedtokens;
    };
}

static void cc_lex_dopragmadir(void) {
    cc_lex_lexm();
    if (((i64)((u64)(cc_decls_nextlx.symbol)) == (i64)69)) {
        if (((i64)(memcmp((void *)((*cc_decls_nextlx.symptr).name),(void *)((byte*)"pack"),(u64)((i64)4))) == (i64)0)) {
            cc_lex_lexm();
            if (((i64)((u64)(cc_decls_nextlx.symbol)) != (i64)13)) {
                cc_lex_lxerror((byte*)"'(' expected");
            };
            cc_lex_lexm();
            if (((i64)((u64)(cc_decls_nextlx.symbol)) == (i64)60)) {
                if ((cc_decls_nextlx.value==(i64)1)) {
                    cc_decls_structpadding = (i64)0;
                } else {
                    goto L451 ;
;
                    cc_lex_lxerror((byte*)"Only pack(1) or () allowed");
                };
                cc_lex_lexm();
            } else if (((i64)((u64)(cc_decls_nextlx.symbol)) == (i64)14)) {
                cc_decls_structpadding = (i64)1;
            };
        } else if (((i64)(memcmp((void *)((*cc_decls_nextlx.symptr).name),(void *)((byte*)"$callback"),(u64)((i64)9))) == (i64)0)) {
            cc_decls_callbackflag = (i64)1;
        };
    };
    //finish:
L451 :;
;
    L452 :;
    while ((((i64)((u64)(cc_decls_nextlx.symbol)) != (i64)57) && ((i64)((u64)(cc_decls_nextlx.symbol)) != (i64)58))) {
        cc_lex_lexm();
L453 :;
    }L454 :;
    ;
}

static i64 cc_lex_needspace(i64 a,i64 b) {
    byte *  aname;
    byte *  bname;
    if ((a == (i64)0)) {
        return (i64)0;
    };
    aname = cc_tables_shortsymbolnames[(a)-1];
    bname = cc_tables_shortsymbolnames[(b)-1];
    if (((i64)((*bname))==(i64)110) || ((i64)((*bname))==(i64)107)) {
        if (((i64)((*aname))==(i64)110) || ((i64)((*aname))==(i64)107)) {
            return (i64)1;
        };
    }else if (((i64)((*bname))==(i64)45) || ((i64)((*bname))==(i64)43)) {
        if (((i64)((*aname))==(i64)45) || ((i64)((*aname))==(i64)43)) {
            return (i64)1;
        };
    };
    return (i64)0;
}

void cc_lex_dospecialinclude(void) {
    ++cc_lex_nincludes;
    cc_lex_stacksourcefile((byte*)"bcc.h",(i64)1);
    if (!!(cc_decls_dheaderfile)) {
        cc_lex_stacksourcefile(cc_decls_dheaderfile,(i64)1);
    };
}

static void cc_lex_addautomodule(byte * headername,i64 fileno) {
    byte *  cfilename;
    byte *  headerfile;
    i64 present;
    i64 i;
    headerfile = cc_decls_sourcefilepaths[(fileno)];
    if (!(!!(cc_decls_fautomodules))) {
        return;
    };
    if (!!(mlib_eqstring(mlib_extractext(headerfile,(i64)0),(byte*)"c"))) {
        return;
    };
    cfilename = mlib_changeext(headerfile,(byte*)"c");
    if (!!(mlib_checkfile(cfilename))) {
        present = (i64)1;
        L455 :;
        for (i=(i64)1;i<=cc_decls_nautomodules;i+=(i64)1) {
L456 :;
            if (!!(mlib_eqstring(cc_decls_automodulenames[(i)],cfilename))) {
                present = (i64)0;
                goto L458 ;
            };
L457 :;
        }L458 :;
        ;
        if (!!(present)) {
            cc_decls_automodulenames[(++cc_decls_nautomodules)] = mlib_pcm_copyheapstring(cfilename);
        };
    };
}

static void cc_lex_setnumberoffset(i64 offset) {
    cc_decls_nextlx.numberoffset = (((i64)(cc_decls_nextlx.numberoffset) & (i64)4278190080) | (offset & (i64)16777215));
}

static void cc_lex_setfileno(i64 fileno) {
    cc_decls_nextlx.fileno = (u64)((fileno & (i64)255));
    cc_decls_nextlx.numberoffset = (((i64)(cc_decls_nextlx.numberoffset) & (i64)16777215) | ((fileno & (i64)65280) << (i64)16));
}

static void cc_lex_setfilenox(struct cc_decls_tokenrec * tk,i64 fileno) {
    (*tk).fileno = (u64)((fileno & (i64)255));
    (*tk).numberoffset = (((i64)((*tk).numberoffset) & (i64)16777215) | ((fileno & (i64)65280) << (i64)16));
}

static i64 cc_lex_getfileno(void) {
    return ((((i64)(cc_decls_nextlx.numberoffset) >> (i64)24) << (i64)8) | (i64)((u64)(cc_decls_nextlx.fileno)));
}

static i64 cc_lex_getfilenox(struct cc_decls_tokenrec * tk) {
    return ((((i64)((*tk).numberoffset) >> (i64)24) << (i64)8) | (i64)((u64)((*tk).fileno)));
}

static i64 cc_lex_getnumberoffsetx(struct cc_decls_tokenrec * tk) {
    return ((i64)((*tk).numberoffset) & (i64)16777215);
}

void cc_lex_freehashtable(void) {
    struct cc_decls_strec *  d;
    struct cc_decls_strec *  e;
    struct cc_decls_strec *  f;
    i64 i;
    L459 :;
    for (i=(i64)0;i<=cc_decls_hstmask;i+=(i64)1) {
L460 :;
        d = (*cc_decls_hashtable)[(i)];
        if ((!!((*d).name) && ((i64)((u64)((*d).symbol)) == (i64)69))) {
            if (((i64)((u64)((*d).nameid)) == (i64)1)) {
                cc_lex_freetokens((*d).tokenlist);
            };
            f = (*d).nextdupl;
            L463 :;
            while (!!(f)) {
                cc_lex_freestentry(f);
                e = (*f).nextdupl;
                mlib_pcm_free((void *)(f),(i64)128);
                f = e;
L464 :;
            }L465 :;
            ;
            mlib_pcm_clearmem((void *)((*cc_decls_hashtable)[(i)]),(i64)128);
        } else if (!!((*d).name)) {
            (*d).nextdupl = (struct cc_decls_strec *)(0);
        };
L461 :;
    }L462 :;
    ;
}

static void cc_lex_freestentry(struct cc_decls_strec * d) {
}

static void cc_lex_regenlookup(struct cc_decls_strec * d) {
    i64 j;
    i64 wrapped;
    i64 length;
    struct cc_decls_strec *  e;
    j = ((i64)(cc_lex_gethashvalue((*d).name,(i64)((*d).namelen))) & cc_decls_hstmask);
    wrapped = (i64)0;
    L466 :;
    while (1) {
        e = (*cc_decls_hashtable)[(j)];
        length = (i64)((*e).namelen);
        if (!(!!(length))) {
            mlib_pcm_free((void *)((*cc_decls_hashtable)[(j)]),(i64)128);
            (*cc_decls_hashtable)[(j)] = d;
            ++cc_lex_nhstsymbols;
            return;
        };
        if ((length == (i64)((u64)((*d).namelen)))) {
            if (((i64)(memcmp((void *)((*e).name),(void *)((*d).name),(u64)(length))) == (i64)0)) {
                cc_lex_lxerror((byte*)"regenhst dupl?");
            };
        };
        if ((++j >= cc_decls_hstsize)) {
            if (!!(wrapped)) {
                mlib_abortprogram((byte*)"REGENHST FULL?");
            };
            wrapped = (i64)1;
            j = (i64)0;
        };
    }L467 :;
    ;
}

static void cc_lex_printhashtable(byte * caption) {
    struct cc_decls_strec *  d;
    i64 av_1;
    i64 i;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str(caption,NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_str((byte*)":",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    L468 :;
    for (i=(i64)0;i<=(cc_decls_hstsize - (i64)1);i+=(i64)1) {
L469 :;
        d = (*cc_decls_hashtable)[(i)];
        if (!!((*d).name)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_i64(i,NULL);
            msysnewc_m_print_str((byte*)":",NULL);
            msysnewc_m_print_str((*d).name,NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
        } else {
            msysnewc_m_print_startcon();
            msysnewc_m_print_i64(i,NULL);
            msysnewc_m_print_str((byte*)": ----",NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
        };
L470 :;
    }L471 :;
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
}

static void cc_lex_newhashtable(void) {
    struct cc_decls_strec * (*oldhashtable)[];
    i64 oldhstsize;
    struct cc_decls_strec *  d;
    i64 av_1;
    i64 i;
    oldhashtable = cc_decls_hashtable;
    oldhstsize = cc_decls_hstsize;
    cc_decls_hstsize *= (i64)2;
    cc_decls_hstmask = (cc_decls_hstsize - (i64)1);
    cc_lex_nhstsymbols = (i64)0;
    cc_lex_hstthreshold = (((i64)6 * cc_decls_hstsize) / (i64)10);
    cc_decls_hashtable = (struct cc_decls_strec * (*)[])(mlib_pcm_alloc((cc_decls_hstsize * (i64)8)));
    L472 :;
    for (i=(i64)0;i<=cc_decls_hstmask;i+=(i64)1) {
L473 :;
        (*cc_decls_hashtable)[(i)] = (struct cc_decls_strec *)(mlib_pcm_allocz((i64)128));
L474 :;
    }L475 :;
    ;
    L476 :;
    for (i=(i64)0;i<=(oldhstsize - (i64)1);i+=(i64)1) {
L477 :;
        d = (*oldhashtable)[(i)];
        if (!!((*d).name)) {
            cc_lex_regenlookup(d);
        };
L478 :;
    }L479 :;
    ;
    mlib_pcm_free((void *)(oldhashtable),(oldhstsize * (i64)8));
}

static void cc_lex_old_readrealnumber(byte * pstart,byte * intstart,i64 intlen,i64 base) {
    byte *  fractstart;
    i64 fractlen;
    i64 expon;
    i64 i;
    i64 c;
    i64 badexpon;
    double basex;
    double x;
    double expbase;
    byte realstr[500];
    i64 av_1;
    i64 av_2;
    i64 av_3;
    fractstart = (byte *)(0);
    fractlen = (i64)0;
    expon = (i64)0;
    if (((u64)((*cc_lex_lxsptr)) == '.')) {
        fractstart = ++cc_lex_lxsptr;
        fractlen = (cc_lex_scannumber(base) - fractstart);
    };
    badexpon = (i64)0;
    if (((i64)((*cc_lex_lxsptr))==(i64)101) || ((i64)((*cc_lex_lxsptr))==(i64)69)) {
        if ((base != (i64)16)) {
            ++cc_lex_lxsptr;
            expon = cc_lex_readexponent(&badexpon);
        };
    }else if (((i64)((*cc_lex_lxsptr))==(i64)112) || ((i64)((*cc_lex_lxsptr))==(i64)80)) {
        if ((base == (i64)16)) {
            ++cc_lex_lxsptr;
            expon = cc_lex_readexponent(&badexpon);
        };
    };
    if (!!(badexpon)) {
        --cc_lex_lxsptr;
        cc_lex_readalphanumeric(pstart);
        return;
    };
    if (((i64)((*cc_lex_lxsptr))==(i64)102) || ((i64)((*cc_lex_lxsptr))==(i64)70)) {
        ++cc_lex_lxsptr;
    } else {
        if (!!((u64)(cc_lex_alphamap[((i64)((*cc_lex_lxsptr)))]))) {
            cc_lex_readalphanumeric(pstart);
            return;
        };
    };
    if (((intlen + fractlen) > (i64)500)) {
        cc_lex_lxerror((byte*)"Real too long");
    };
    if (!!(intlen)) {
        memcpy((void *)(&realstr),(void *)(intstart),(u64)(intlen));
    };
    if (!!(fractlen)) {
        memcpy((void *)((&realstr[((i64)1)-1] + intlen)),(void *)(fractstart),(u64)(fractlen));
    };
    expbase = (basex = (double)(base));
    if ((base == (i64)10)) {
        expon -= fractlen;
    } else {
        expon -= (fractlen * (i64)4);
        expbase = (double)2.;
    };
    x = (double)0.;
    L480 :;
    for (i=(i64)1;i<=(intlen + fractlen);i+=(i64)1) {
L481 :;
        c = (i64)(realstr[(i)-1]);
        if (((c >= (i64)48) && (c <= (i64)57))) {
            x = ((x * basex) + (double)((c - (i64)48)));
        } else if ((c > (i64)97)) {
            x = ((((x * basex) + (double)(c)) - (double)97.) + (double)10.);
        } else {
            x = ((((x * basex) + (double)(c)) - (double)65.) + (double)10.);
        };
L482 :;
    }L483 :;
    ;
    if ((expon >= (i64)0)) {
        av_2 = expon;
        while (av_2-- > 0) {
L484 :;
            x *= expbase;
L485 :;
        }L486 :;
        ;
    } else {
        av_3 = -(expon);
        while (av_3-- > 0) {
L487 :;
            x /= expbase;
L488 :;
        }L489 :;
        ;
    };
    cc_decls_nextlx.symbol = (u64)((i64)61);
    cc_decls_nextlx.subcode = (u64)((i64)12);
    cc_decls_nextlx.xvalue = x;
    cc_lex_setnumberoffset((intstart - cc_lex_lxstart));
    cc_decls_nextlx.length = (cc_lex_lxsptr - intstart);
}

byte * cc_headers_findheader(byte * name) {
    i64 i;
    byte newname[256];
    byte *  s;
    byte *  t;
    i64 av_1;
    if (!!(strchr((i8 *)(name),(i64)92))) {
        s = name;
        t = newname;
        L490 :;
        while (!!((u64)((*s)))) {
            if (((u64)((*s)) == (u64)92u)) {
                (*t++) = '/';
            } else {
                (*t++) = (u64)((*s));
            };
            ++s;
L491 :;
        }L492 :;
        ;
        (*t) = (u64)0u;
        name = newname;
    };
    L493 :;
    for (i=(i64)1;i<=(i64)42;i+=(i64)1) {
L494 :;
        if (!!(mlib_eqstring(name,cc_headers_stdhdrnames[(i)-1]))) {
            return (*cc_headers_stdhdrtext[(i)-1]);
        };
L495 :;
    }L496 :;
    ;
    return (byte *)(0);
}

void cc_headers_writeheaders(void) {
    void *  f;
    byte *  ifile;
    i64 i;
    i64 av_1;
    L497 :;
    for (i=(i64)1;i<=(i64)42;i+=(i64)1) {
L498 :;
        ifile = mlib_changeext(cc_headers_stdhdrnames[(i)-1],(byte*)"hdr");
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"Writing internal",NULL);
        msysnewc_m_print_str(cc_headers_stdhdrnames[(i)-1],NULL);
        msysnewc_m_print_str((byte*)"as",NULL);
        msysnewc_m_print_str(ifile,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        f = fopen((i8 *)(ifile),(i8 *)((byte*)"wb"));
        fwrite((void *)((*cc_headers_stdhdrtext[(i)-1])),(u64)((i64)1),strlen((i8 *)((*cc_headers_stdhdrtext[(i)-1]))),f);
        fclose(f);
L499 :;
    }L500 :;
    ;
}

void cc_headers_checkbcclib(void) {
    void *  f;
    if (!(!!(mlib_checkfile((byte*)"bcclib.asm")))) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"Writing",NULL);
        msysnewc_m_print_str((byte*)"bcclib.asm",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        f = fopen((i8 *)((byte*)"bcclib.asm"),(i8 *)((byte*)"wb"));
        fwrite((void *)(cc_headers_bcclibstr),(u64)((i64)1),strlen((i8 *)(cc_headers_bcclibstr)),f);
        fclose(f);
    };
}

byte * cc_headers_getbcclib(void) {
    byte *  s;
    i64 slen;
    slen = (i64)(strlen((i8 *)(cc_headers_bcclibstr)));
    s = (byte *)(malloc((u64)((slen + (i64)1))));
    memcpy((void *)(s),(void *)(cc_headers_bcclibstr),(u64)((slen + (i64)1)));
    return s;
}

i64 cc_headers_isheaderfile(byte * file) {
    i64 av_1;
    i64 i;
    L501 :;
    for (i=(i64)1;i<=(i64)42;i+=(i64)1) {
L502 :;
        if (!!(mlib_eqstring(cc_headers_stdhdrnames[(i)-1],file))) {
            return (i64)1;
        };
L503 :;
    }L504 :;
    ;
    return (i64)0;
}

static struct cc_decls_strec * cc_lib_newstrec(void) {
    struct cc_decls_strec *  p;
    p = (struct cc_decls_strec *)(mlib_pcm_alloc((i64)128));
    memset((void *)(p),(i64)0,(u64)((i64)128));
    (*p).lineno = (u64)(((i64)((u64)(cc_decls_lx.lineno)) + ((i64)(cc_decls_lx.fileno) << (i64)24)));
    (*p).attribs.ax_moduleno = (u64)(cc_decls_currmoduleno);
    return p;
}

void cc_lib_initcclib(void) {
}

void cc_lib_printst(void * f,struct cc_decls_strec * p,i64 level) {
    struct cc_decls_strec *  q;
    if (((i64)((u64)((*p).symbol)) != (i64)69)) {
        cc_support_mcerror((byte*)"PRINTST not name");
    };
    cc_lib_printstrec(f,p,level);
    q = (*p).deflist;
    L505 :;
    while ((q != 0)) {
        cc_lib_printst(f,q,(level + (i64)1));
        q = (*q).nextdef;
L506 :;
    }L507 :;
    ;
}

static void cc_lib_printstrec(void * f,struct cc_decls_strec * p,i64 level) {
    struct cc_decls_attribrec attrs;
    struct mlib_strbuffer v;
    struct mlib_strbuffer *  d;
    i64 col;
    i64 offset;
    byte str[256];
    struct cc_decls_paramrec *  pm;
    i64 av_1;
    d = &v;
    mlib_gs_init(d);
    offset = (i64)0;
    av_1 = level;
    while (av_1-- > 0) {
L508 :;
        mlib_gs_str(d,(byte*)"    ");
        offset += (i64)4;
L509 :;
    }L510 :;
    ;
    mlib_gs_str(d,(byte*)":");
    if (!!((u64)((*p).blockno))) {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_str((*p).name,NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str((byte*)".",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_u64((*p).blockno,NULL);
        msysnewc_m_print_end();
        ;
        mlib_gs_leftstr(d,str,((i64)28 - offset),(i64)45);
    } else {
        mlib_gs_leftstr(d,(*p).name,((i64)28 - offset),(i64)45);
    };
    mlib_gs_leftstr(d,cc_tables_namenames[((i64)((*p).nameid))],(i64)12,(i64)46);
    col = mlib_gs_getcol(d);
    attrs = (*p).attribs;
    mlib_gs_str(d,(byte*)"[");
    mlib_gs_str(d,cc_tables_scopenames[((i64)((*p).scope))]);
    mlib_gs_str(d,(byte*)" ");
    if (!!((u64)(attrs.ax_static))) {
        mlib_gs_str(d,(byte*)"Stat");
    };
    if (!!((u64)(attrs.ax_align))) {
        mlib_gs_str(d,(byte*)"@@");
        mlib_gs_strint(d,(i64)(attrs.ax_align));
        mlib_gs_str(d,(byte*)" ");
    };
    if (!!((u64)(attrs.ax_varparams))) {
        mlib_gs_str(d,(byte*)"Var ");
    };
    if (!!((u64)(attrs.ax_used))) {
        mlib_gs_str(d,(byte*)"Used ");
    };
    if (!!((u64)(attrs.ax_forward))) {
        mlib_gs_str(d,(byte*)"Fwd ");
    };
    if (!!((u64)(attrs.ax_frame))) {
        mlib_gs_str(d,(byte*)"Frm ");
    };
    if (!!((u64)(attrs.ax_autovar))) {
        mlib_gs_str(d,(byte*)"AV ");
    };
    if (!!((u64)(attrs.ax_nparams))) {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_setfmt((byte*)"Pm:# ");
        msysnewc_m_print_u64(attrs.ax_nparams,NULL);
        msysnewc_m_print_end();
        ;
        mlib_gs_str(d,str);
    };
    if (!!((u64)(attrs.ax_moduleno))) {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_setfmt((byte*)"M# ");
        msysnewc_m_print_u64(attrs.ax_moduleno,NULL);
        msysnewc_m_print_end();
        ;
        mlib_gs_str(d,str);
    };
    if (!!((u64)(attrs.ax_equals))) {
        mlib_gs_str(d,(byte*)"= ");
    };
    mlib_gs_str(d,(byte*)"]");
    mlib_gs_padto(d,(col + (i64)10),(i64)61);
    if (!!((*p).owner)) {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_setfmt((byte*)"(#)");
        msysnewc_m_print_str((*(*p).owner).name,NULL);
        msysnewc_m_print_end();
        ;
        mlib_gs_leftstr(d,str,(i64)18,(i64)32);
    } else {
        mlib_gs_leftstr(d,(byte*)"()",(i64)18,(i64)32);
    };
    if (((i64)((*p).mode)==(i64)1)) {
        mlib_gs_str(d,(byte*)"Void ");
    } else {
        mlib_gs_strsp(d,cc_lib_strmode((i64)((*p).mode),(i64)1));
    };
    if (((i64)((*p).nameid)==(i64)10)) {
        mlib_gs_str(d,(byte*)"Offset:");
        mlib_gs_strint(d,(*p).offset);
    }else if (((i64)((*p).nameid)==(i64)8) || ((i64)((*p).nameid)==(i64)9)) {
        if (!!((*p).code)) {
            mlib_gs_str(d,(byte*)"=");
            mlib_gs_strvar(d,cc_lib_strexpr((*p).code));
        };
        mlib_gs_str(d,(byte*)" Offset: ");
        mlib_gs_strint(d,(*p).offset);
    }else if (((i64)((*p).nameid)==(i64)6)) {
        mlib_gs_str(d,(byte*)"Index:");
        mlib_gs_strint(d,(i64)((*p).index));
        mlib_gs_str(d,(byte*)" Address:");
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_ptr((*p).address,NULL);
        msysnewc_m_print_end();
        ;
        mlib_gs_str(d,str);
        if (!!((u64)((*p).attribs.ax_callback))) {
            mlib_gs_str(d,(byte*)"<callback fn>");
        };
    }else if (((i64)((*p).nameid)==(i64)11)) {
        mlib_gs_str(d,(byte*)"Enum:");
        mlib_gs_strint(d,(i64)((*p).index));
    }else if (((i64)((*p).nameid)==(i64)7)) {
        if (!!((*p).code)) {
            mlib_gs_str(d,(byte*)"=");
            mlib_gs_strvar(d,cc_lib_strexpr((*p).code));
        };
        mlib_gs_str(d,(byte*)"STATIC********");
    };
    mlib_gs_str(d,(byte*)" ");
    mlib_gs_str(d,(byte*)"Lineno:");
    mlib_gs_strint(d,((i64)((u64)((*p).lineno)) & (i64)16777215));
    mlib_gs_str(d,(byte*)" ");
    mlib_gs_str(d,cc_decls_sourcefilenames[((i64)(((u64)((*p).lineno) >> (i64)24)))]);
    if (((i64)((u64)((*p).nameid)) == (i64)6)) {
        mlib_gs_line(d);
        pm = (*p).paramlist;
        L511 :;
        while (!!(pm)) {
            mlib_gs_str(d,(byte*)"\t\tParam: ");
            mlib_gs_leftstr(d,(!!((*pm).def)?(*(*pm).def).name:(byte*)"Anon"),(i64)10,(i64)45);
            mlib_gs_str(d,cc_tables_pmflagnames[((i64)((*pm).flags))]);
            mlib_gs_line(d);
            pm = (*pm).nextparam;
L512 :;
        }L513 :;
        ;
    };
    mlib_gs_str(d,(byte*)" MODE:");
    mlib_gs_strint(d,(i64)((*p).mode));
    mlib_gs_println(d,f);
    if (!!((*p).code)) {
        if (((i64)((*p).nameid)==(i64)8) || ((i64)((*p).nameid)==(i64)7)) {
            cc_lib_printunit(f,(*p).code,(i64)-3,(byte*)"*");
        };
    };
}

void cc_lib_printstflat(void * f) {
    i64 i;
    struct cc_decls_strec *  p;
    i64 av_1;
    msysnewc_m_print_startfile(f);
    msysnewc_m_print_str((byte*)"GLOBAL SYMBOL TABLE:",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    L514 :;
    for (i=(i64)0;i<=(cc_decls_hstsize - (i64)1);i+=(i64)1) {
L515 :;
        p = (*cc_decls_hashtable)[(i)];
        if (!!((*p).name)) {
            if (((i64)((*p).symbol)==(i64)69)) {
                msysnewc_m_print_startfile(f);
                msysnewc_m_print_i64(i,NULL);
                msysnewc_m_print_ptr(p,NULL);
                msysnewc_m_print_str((byte*)":",NULL);
                msysnewc_m_print_str(cc_lib_getstname(p),NULL);
                msysnewc_m_print_str(cc_tables_symbolnames[((i64)((*p).symbol))-1],NULL);
                msysnewc_m_print_str(cc_tables_namenames[((i64)((*p).nameid))],NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
                p = (*p).nextdupl;
                L518 :;
                while (!!(p)) {
                    msysnewc_m_print_startfile(f);
                    msysnewc_m_print_str((byte*)"\t",NULL);
                    msysnewc_m_print_ptr(p,NULL);
                    msysnewc_m_print_str(cc_lib_getstname(p),NULL);
                    msysnewc_m_print_str(cc_tables_symbolnames[((i64)((*p).symbol))-1],NULL);
                    msysnewc_m_print_str(cc_tables_namenames[((i64)((*p).nameid))],NULL);
                    msysnewc_m_print_ptr((*p).prevdupl,NULL);
                    msysnewc_m_print_end();
                    ;
                    msysnewc_m_print_startfile(f);
                    msysnewc_m_print_str((byte*)"(From",NULL);
                    msysnewc_m_print_str((!!((*p).owner)?cc_lib_getstname((*p).owner):(byte*)"-"),NULL);
                    msysnewc_m_print_nogap();
                    msysnewc_m_print_str((byte*)")",NULL);
                    msysnewc_m_print_newline();
                    msysnewc_m_print_end();
                    ;
                    p = (*p).nextdupl;
L519 :;
                }L520 :;
                ;
            };
        };
L516 :;
    }L517 :;
    ;
}

struct cc_decls_unitrec * cc_lib_createname(struct cc_decls_strec * p) {
    struct cc_decls_unitrec *  u;
    u = cc_lib_allocunitrec();
    (*u).tag = (i64)3;
    (*u).def = p;
    (*u).simple = (u64)((i64)1);
    return u;
}

struct cc_decls_unitrec * cc_lib_createunit0(i64 tag) {
    struct cc_decls_unitrec *  u;
    u = cc_lib_allocunitrec();
    (*u).tag = tag;
    return u;
}

struct cc_decls_unitrec * cc_lib_createunit1(i64 tag,struct cc_decls_unitrec * p) {
    struct cc_decls_unitrec *  u;
    u = cc_lib_allocunitrec();
    (*u).tag = tag;
    (*u).a = p;
    return u;
}

struct cc_decls_unitrec * cc_lib_createunit2(i64 tag,struct cc_decls_unitrec * p,struct cc_decls_unitrec * q) {
    struct cc_decls_unitrec *  u;
    u = cc_lib_allocunitrec();
    (*u).tag = tag;
    (*u).a = p;
    (*u).b = q;
    return u;
}

struct cc_decls_unitrec * cc_lib_createunit3(i64 tag,struct cc_decls_unitrec * p,struct cc_decls_unitrec * q,struct cc_decls_unitrec * r) {
    struct cc_decls_unitrec *  u;
    u = cc_lib_allocunitrec();
    (*u).tag = tag;
    (*u).a = p;
    (*u).b = q;
    (*u).c = r;
    return u;
}

struct cc_decls_unitrec * cc_lib_createconstunit(u64 a,i64 t) {
    struct cc_decls_unitrec *  u;
    u = cc_lib_allocunitrec();
    (*u).tag = (i64)1;
    (*u).value = (i64)(a);
    (*u).mode = t;
    (*u).simple = (u64)((i64)1);
    return u;
}

struct cc_decls_unitrec * cc_lib_createstringconstunit(byte * s,i64 length) {
    struct cc_decls_unitrec *  u;
    u = cc_lib_allocunitrec();
    (*u).tag = (i64)1;
    (*u).svalue = s;
    (*u).mode = cc_decls_trefchar;
    if ((length == (i64)-1)) {
        (*u).slength = (i64)(strlen((i8 *)(s)));
    } else {
        (*u).slength = length;
    };
    (*u).isstrconst = (u64)((i64)1);
    (*u).simple = (u64)((i64)1);
    return u;
}

struct cc_decls_unitrec * cc_lib_createwstringconstunit(u16 * s,i64 length) {
    struct cc_decls_unitrec *  u;
    u = cc_lib_allocunitrec();
    (*u).tag = (i64)1;
    (*u).wsvalue = s;
    (*u).mode = cc_decls_trefwchar;
    (*u).wslength = length;
    (*u).iswstrconst = (u64)((i64)1);
    (*u).simple = (u64)((i64)1);
    return u;
}

i64 cc_lib_getoptocode(i64 opc) {
    static i16 opctotable[79];
    i64 opcto;
    i64 i;
    byte str[20];
    i64 av_1;
    opcto = (i64)(opctotable[(opc)]);
    if (!!(opcto)) {
        return opcto;
    };
    strcpy((i8 *)(str),(i8 *)(cc_tables_jtagnames[(opc)]));
    strcat((i8 *)(str),(i8 *)((byte*)"to"));
    L521 :;
    for (i=(i64)0;i<=(i64)78;i+=(i64)1) {
L522 :;
        if (!!(mlib_eqstring(cc_tables_jtagnames[(i)],str))) {
            opctotable[(opc)] = i;
            return i;
        };
L523 :;
    }L524 :;
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str(cc_tables_jtagnames[(opc)],NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    cc_support_serror((byte*)"Can't find -to version");
    return (i64)0;
}

i64 cc_lib_getconstvalue(struct cc_decls_unitrec * p,i64 id) {
    if ((!!(p) && ((i64)((*p).tag) == (i64)1))) {
        return (*p).value;
    };
    cc_support_serror((byte*)"GCV Not constant");
    return (i64)0;
}

byte * cc_lib_nextautotype(void) {
    static byte str[32];
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_str((byte*)"$T",NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_i64(++cc_lib_autotypeno,NULL);
    msysnewc_m_print_end();
    ;
    return str;
}

i64 cc_lib_createconstmode(i64 m) {
    i64 newm;
    if (!!((u64)(cc_decls_ttconst[(m)]))) {
        return m;
    };
    if (!!(cc_decls_ttconsttype[(m)])) {
        return cc_decls_ttconsttype[(m)];
    };
    newm = cc_lib_copymode(m);
    cc_decls_ttconsttype[(m)] = newm;
    cc_decls_ttconst[(newm)] = (u64)((i64)1);
    cc_decls_ttconsttype[(newm)] = m;
    return newm;
}

i64 cc_lib_createrefmode(i64 m) {
    i64 newm;
    if (!!(cc_decls_ttreftype[(m)])) {
        return cc_decls_ttreftype[(m)];
    };
    newm = cc_lib_createnewmode((i64)16);
    cc_decls_ttreftype[(m)] = newm;
    cc_decls_tttarget[(newm)] = m;
    cc_decls_ttisref[(newm)] = (u64)((i64)1);
    return newm;
}

i64 cc_lib_createprocmode(i64 m,struct cc_decls_paramrec * pm) {
    i64 newm;
    newm = cc_lib_createnewmode((i64)17);
    cc_decls_ttparams[(newm)] = pm;
    cc_decls_tttarget[(newm)] = m;
    return newm;
}

i64 cc_lib_createarraymode(i64 m,i64 length) {
    i64 newm;
    i64 i;
    if ((cc_decls_ntypes > (i64)10000)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"NTYPES=",NULL);
        msysnewc_m_print_i64(cc_decls_ntypes,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
    L525 :;
    for (i=(i64)1;i<=cc_decls_ntypes;i+=(i64)1) {
L526 :;
        if ((((cc_decls_ttbasetype[(i)] == (i64)19) && (cc_decls_tttarget[(i)] == m)) && (cc_decls_ttlength[(i)] == length))) {
            return i;
        };
L527 :;
    }L528 :;
    ;
    newm = cc_lib_createnewmode((i64)19);
    cc_decls_tttarget[(newm)] = m;
    cc_decls_ttlength[(newm)] = length;
    cc_decls_ttsize[(newm)] = (length * cc_decls_ttsize[(m)]);
    return newm;
}

i64 cc_lib_createenummode(struct cc_decls_strec * e) {
    i64 newm;
    newm = cc_lib_createnewmode((i64)15);
    cc_decls_ttnamedef[(newm)] = e;
    return newm;
}

i64 cc_lib_createstructmode(struct cc_decls_strec * s,i64 smode) {
    i64 newm;
    newm = cc_lib_createnewmode(smode);
    cc_decls_ttnamedef[(newm)] = s;
    return newm;
}

void cc_lib_setnameptr(struct cc_decls_unitrec * p) {
    (*(*p).def).code = p;
}

void cc_lib_printcode_all(void * f,byte * caption) {
    i64 i;
    L529 :;
    for (i=(i64)1;i<=cc_decls_nmodules;i+=(i64)1) {
L530 :;
        cc_lib_printcode(f,caption,i);
L531 :;
    }L532 :;
    ;
}

void cc_lib_printcode(void * f,byte * caption,i64 n) {
    struct cc_decls_strec *  p;
    p = (*cc_decls_moduletable[(n)].stmodule).deflist;
    msysnewc_m_print_startfile(f);
    msysnewc_m_print_str(caption,NULL);
    msysnewc_m_print_str((byte*)"MODULE:",NULL);
    msysnewc_m_print_str(cc_decls_moduletable[(n)].name,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    L533 :;
    while (!!(p)) {
        if (((i64)((*p).nameid)==(i64)6)) {
            if (!!((*p).code)) {
                msysnewc_m_print_startfile(f);
                msysnewc_m_print_str((*p).name,NULL);
                msysnewc_m_print_nogap();
                msysnewc_m_print_str((byte*)"=",NULL);
                msysnewc_m_print_str(cc_tables_scopenames[((i64)((*p).scope))],NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
                cc_lib_printunit(f,(*p).code,(i64)0,(byte*)"1");
                msysnewc_m_print_startfile(f);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
            };
        };
        p = (*p).nextdef;
L534 :;
    }L535 :;
    ;
}

void cc_lib_printunit(void * dev,struct cc_decls_unitrec * p,i64 level,byte * prefix) {
    struct cc_decls_strec *  d;
    i64 t;
    i64 n;
    i64 lincr;
    byte *  idname;
    struct cc_decls_caserec *  pc;
    if ((p == 0)) {
        return;
    };
    if (((i64)((*p).tag) >= (i64)78)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"print unit: bad tag",NULL);
        msysnewc_m_print_i64((*p).tag,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        osnos_os_getch();
        exit((i64)30);
    };
    if (!!((u64)((*p).lineno))) {
        cc_lib_currlineno = (i64)((*p).lineno);
    };
    lincr = (i64)1;
    if ((level < (i64)0)) {
        lincr = (i64)-1;
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((byte*)"             ",NULL);
        msysnewc_m_print_end();
        ;
    };
    msysnewc_m_print_startfile(dev);
    msysnewc_m_print_str(cc_lib_getprefix(labs(level),prefix,p),NULL);
    msysnewc_m_print_end();
    ;
    idname = cc_tables_jtagnames[((i64)((*p).tag))];
    if (((u64)((*idname)) == 'j')) {
        idname += (i64)2;
    };
    msysnewc_m_print_startfile(dev);
    msysnewc_m_print_str(idname,NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_str((byte*)": ",NULL);
    msysnewc_m_print_end();
    ;
    if (((i64)((*p).tag)==(i64)3) || ((i64)((*p).tag)==(i64)5)) {
        d = (*p).def;
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((*d).name,NULL);
        msysnewc_m_print_str(cc_tables_namenames[((i64)((*d).nameid))],NULL);
        msysnewc_m_print_end();
        ;
        if (!!((*d).code)) {
            msysnewc_m_print_startfile(dev);
            msysnewc_m_print_str((byte*)" {",NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_str(cc_tables_jtagnames[((i64)((*(*d).code).tag))],NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_str((byte*)"}",NULL);
            msysnewc_m_print_end();
            ;
        };
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((byte*)" ",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str(cc_lib_getdottedname(d),NULL);
        msysnewc_m_print_end();
        ;
        if (!!((*p).c)) {
            msysnewc_m_print_startfile(dev);
            msysnewc_m_print_str((byte*)" Lastcall:",NULL);
            msysnewc_m_print_ptr((*p).c,NULL);
            msysnewc_m_print_end();
            ;
        };
    }else if (((i64)((*p).tag)==(i64)7) || ((i64)((*p).tag)==(i64)8) || ((i64)((*p).tag)==(i64)17)) {
        d = (*p).def;
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((*d).name,NULL);
        msysnewc_m_print_str(cc_tables_namenames[((i64)((*d).nameid))],NULL);
        msysnewc_m_print_end();
        ;
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        cc_lib_printunit(dev,(*d).code,(level + lincr),(byte*)"1");
        return;
    }else if (((i64)((*p).tag)==(i64)17)) {
        d = (*p).def;
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((*d).name,NULL);
        msysnewc_m_print_str(cc_tables_namenames[((i64)((*d).nameid))],NULL);
        msysnewc_m_print_end();
        ;
    }else if (((i64)((*p).tag)==(i64)18)) {
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((*(*p).def).name,NULL);
        msysnewc_m_print_end();
        ;
    }else if (((i64)((*p).tag)==(i64)19)) {
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((byte*)"Index:",NULL);
        msysnewc_m_print_i64((*p).index,NULL);
        msysnewc_m_print_end();
        ;
    }else if (((i64)((*p).tag)==(i64)1)) {
        t = (i64)((*p).mode);
        if ((t == cc_decls_trefchar)) {
            if (!(!!((u64)((*p).isstrconst)))) {
                goto L536 ;
;
            };
            //dostring:
L537 :;
;
            if (((i64)((*p).slength) > (i64)256)) {
                msysnewc_m_print_startfile(dev);
                msysnewc_m_print_str((byte*)"\"",NULL);
                msysnewc_m_print_nogap();
                msysnewc_m_print_str((byte*)"(LONGSTR)",NULL);
                msysnewc_m_print_str((byte*)"\" *",NULL);
                msysnewc_m_print_nogap();
                msysnewc_m_print_i64((*p).slength,NULL);
                msysnewc_m_print_end();
                ;
            } else {
                msysnewc_m_print_startfile(dev);
                msysnewc_m_print_str((byte*)"\"",NULL);
                msysnewc_m_print_nogap();
                msysnewc_m_print_str((*p).svalue,NULL);
                msysnewc_m_print_nogap();
                msysnewc_m_print_str((byte*)"\" *",NULL);
                msysnewc_m_print_nogap();
                msysnewc_m_print_i64((*p).slength,NULL);
                msysnewc_m_print_end();
                ;
            };
        } else if ((t == cc_decls_trefwchar)) {
            if (!(!!((u64)((*p).iswstrconst)))) {
                goto L536 ;
;
            };
            msysnewc_m_print_startfile(dev);
            msysnewc_m_print_str((byte*)"\"",NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_str((byte*)"(WSTRING)",NULL);
            msysnewc_m_print_str((byte*)"\" *",NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_i64((*p).wslength,NULL);
            msysnewc_m_print_end();
            ;
        } else if (((t >= (i64)2) && (t <= (i64)5))) {
            msysnewc_m_print_startfile(dev);
            msysnewc_m_print_i64((*p).value,NULL);
            msysnewc_m_print_end();
            ;
        } else if (((t >= (i64)7) && (t <= (i64)10))) {
            msysnewc_m_print_startfile(dev);
            msysnewc_m_print_u64((*p).uvalue,NULL);
            msysnewc_m_print_end();
            ;
        } else if (!!(cc_lib_isrealcc(t))) {
            msysnewc_m_print_startfile(dev);
            msysnewc_m_print_r64((*p).xvalue,NULL);
            msysnewc_m_print_end();
            ;
        } else if ((cc_decls_ttbasetype[(t)] == (i64)16)) {
            if (!!((u64)((*p).isstrconst))) {
                goto L537 ;
;
            };
            //doref:
L536 :;
;
            msysnewc_m_print_startfile(dev);
            msysnewc_m_print_ptr((void *)((*p).value),NULL);
            msysnewc_m_print_end();
            ;
        } else if ((cc_decls_ttbasetype[(t)] == (i64)19)) {
            if (!!((u64)((*p).isstrconst))) {
                goto L537 ;
;
            };
            cc_support_serror((byte*)"PRINTUNIT/CONST/aRRAY");
        } else {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(cc_lib_typename(t),NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            cc_support_serror((byte*)"PRINTUNIT BAD CONST");
        };
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((byte*)" ",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str(cc_lib_strmode(t,(i64)1),NULL);
        msysnewc_m_print_end();
        ;
        if (!!((u64)((*p).isstrconst))) {
            msysnewc_m_print_startfile(dev);
            msysnewc_m_print_str((byte*)"<STRCONST>",NULL);
            msysnewc_m_print_end();
            ;
        };
        if (!!((u64)((*p).iswstrconst))) {
            msysnewc_m_print_startfile(dev);
            msysnewc_m_print_str((byte*)"<WSTRCONST>",NULL);
            msysnewc_m_print_end();
            ;
        };
    }else if (((i64)((*p).tag)==(i64)57)) {
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str(cc_tables_convnames[((i64)((*p).opcode))],NULL);
        msysnewc_m_print_end();
        ;
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((byte*)" ",NULL);
        msysnewc_m_print_end();
        ;
        if (!!((u64)((*p).convmem))) {
            msysnewc_m_print_startfile(dev);
            msysnewc_m_print_str((byte*)"Mem:",NULL);
            msysnewc_m_print_end();
            ;
        };
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str(cc_lib_typename((i64)((*(*p).a).mode)),NULL);
        msysnewc_m_print_end();
        ;
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((byte*)" => ",NULL);
        msysnewc_m_print_end();
        ;
        if (!!((u64)((*p).convtomem))) {
            msysnewc_m_print_startfile(dev);
            msysnewc_m_print_str((byte*)"Mem:",NULL);
            msysnewc_m_print_end();
            ;
        };
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str(cc_lib_typename((i64)((*p).mode)),NULL);
        msysnewc_m_print_end();
        ;
    }else if (((i64)((*p).tag)==(i64)58)) {
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((byte*)"Scale:",NULL);
        msysnewc_m_print_i64((*p).scale,NULL);
        msysnewc_m_print_end();
        ;
    }else if (((i64)((*p).tag)==(i64)54) || ((i64)((*p).tag)==(i64)55)) {
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((byte*)"Ptrscale:",NULL);
        msysnewc_m_print_i64((*p).ptrscale,NULL);
        msysnewc_m_print_end();
        ;
    }else if (((i64)((*p).tag)==(i64)23)) {
        pc = (*p).nextcase;
        n = (i64)0;
        L538 :;
        while (!!(pc)) {
            ++n;
            pc = (*pc).nextcase;
L539 :;
        }L540 :;
        ;
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_ptr((*p).nextcase,NULL);
        msysnewc_m_print_i64(n,NULL);
        msysnewc_m_print_end();
        ;
    }else if (((i64)((*p).tag)==(i64)31)) {
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((byte*)" Aparams:",NULL);
        msysnewc_m_print_i64((*p).aparams,NULL);
        msysnewc_m_print_end();
        ;
    }else if (((i64)((*p).tag)==(i64)53)) {
    }else if (((i64)((*p).tag)==(i64)50)) {
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((byte*)" Offset:",NULL);
        msysnewc_m_print_i64((*p).offset,NULL);
        msysnewc_m_print_end();
        ;
    };
    if (!!((i64)((*p).alength))) {
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((byte*)" ALENGTH=",NULL);
        msysnewc_m_print_i64((*p).alength,NULL);
        msysnewc_m_print_end();
        ;
    };
    msysnewc_m_print_startfile(dev);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    cc_lib_printunitlist(dev,(*p).a,(level + lincr),(byte*)"1");
    cc_lib_printunitlist(dev,(*p).b,(level + lincr),(byte*)"2");
    if (((i64)((*p).tag) != (i64)6)) {
        cc_lib_printunitlist(dev,(*p).c,(level + lincr),(byte*)"3");
    };
}

static void cc_lib_printunitlist(void * dev,struct cc_decls_unitrec * p,i64 level,byte * prefix) {
    if ((p == 0)) {
        return;
    };
    L541 :;
    while (!!(p)) {
        cc_lib_printunit(dev,p,level,prefix);
        p = (*p).nextunit;
L542 :;
    }L543 :;
    ;
}

static byte * cc_lib_getprefix(i64 level,byte * prefix,struct cc_decls_unitrec * p) {
    static byte str[512];
    byte indentstr[512];
    byte *  modestr;
    i64 length;
    i64 av_1;
    indentstr[((i64)1)-1] = (u64)0u;
    if ((level > (i64)10)) {
        level = (i64)10;
    };
    strcpy((i8 *)(indentstr),(i8 *)((byte*)"-----------------------"));
    modestr = cc_lib_strmode((i64)((*p).mode),(i64)0);
    length = (i64)(strlen((i8 *)(modestr)));
    if ((length < (i64)(strlen((i8 *)(indentstr))))) {
        memcpy((void *)(indentstr),(void *)(modestr),(u64)(length));
    } else {
        strcpy((i8 *)(indentstr),(i8 *)(modestr));
    };
    av_1 = level;
    while (av_1-- > 0) {
L544 :;
        strcat((i8 *)(indentstr),(i8 *)((byte*)"|---"));
L545 :;
    }L546 :;
    ;
    strcpy((i8 *)(str),(i8 *)(cc_lib_getlineinfok()));
    strcat((i8 *)(str),(i8 *)(indentstr));
    strcat((i8 *)(str),(i8 *)(prefix));
    if (!!((u64)((*prefix)))) {
        strcat((i8 *)(str),(i8 *)((byte*)" "));
    };
    return str;
}

byte * cc_lib_getdottedname(struct cc_decls_strec * p) {
    static byte str[256];
    byte str2[256];
    struct cc_decls_strec *  owner;
    strcpy((i8 *)(str),(i8 *)((*p).name));
    owner = (*p).owner;
    L547 :;
    while ((!!(owner) && ((i64)((u64)((*owner).nameid)) != (i64)2))) {
        strcpy((i8 *)(str2),(i8 *)(str));
        strcpy((i8 *)(str),(i8 *)((*owner).name));
        strcat((i8 *)(str),(i8 *)((byte*)"."));
        strcat((i8 *)(str),(i8 *)(str2));
        owner = (*owner).owner;
L548 :;
    }L549 :;
    ;
    if (!!((u64)((*p).blockno))) {
        msysnewc_m_print_startstr(str2);
        msysnewc_m_print_str((byte*)".",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_u64((*p).blockno,NULL);
        msysnewc_m_print_end();
        ;
        strcat((i8 *)(str),(i8 *)(str2));
    };
    return str;
}

static byte * cc_lib_getlineinfok(void) {
    static byte str[40];
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_setfmt((byte*)"# ");
    msysnewc_m_print_i64(cc_lib_currlineno,(byte*)"z5");
    msysnewc_m_print_end();
    ;
    return str;
}

struct cc_decls_strec * cc_lib_getautofieldname(void) {
    byte str[32];
    byte *  name;
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_str((byte*)"$F",NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_i64(++cc_lib_nextafindex,NULL);
    msysnewc_m_print_end();
    ;
    name = mlib_pcm_copyheapstring(str);
    return cc_lex_addnamestr(name);
}

void cc_lib_convertstring(byte * s,byte * t,i64 length) {
    i64 c;
    byte str[20];
    byte *  t0;
    i64 av_1;
    if ((length == (i64)-1)) {
        length = (i64)(strlen((i8 *)(s)));
    };
    t0 = t;
    av_1 = length;
    while (av_1-- > 0) {
L550 :;
        c = (i64)((*s++));
        switch (c) {
        case 34:;
        {
            (*t++) = (u64)92u;
            (*t++) = '"';
        }break;
        case 39:;
        {
            (*t++) = (u64)92u;
            (*t++) = (u64)39u;
        }break;
        case 10:;
        {
            (*t++) = (u64)92u;
            (*t++) = 'n';
        }break;
        case 13:;
        {
            (*t++) = (u64)92u;
            (*t++) = 'r';
        }break;
        case 9:;
        {
            (*t++) = (u64)92u;
            (*t++) = 't';
        }break;
        case 92:;
        {
            (*t++) = (u64)92u;
            (*t++) = (u64)92u;
        }break;
        case 7:;
        {
            (*t++) = (u64)92u;
            (*t++) = 'a';
        }break;
        case 8:;
        {
            (*t++) = (u64)92u;
            (*t++) = 'b';
        }break;
        case 12:;
        {
            (*t++) = (u64)92u;
            (*t++) = 'f';
        }break;
        case 11:;
        {
            (*t++) = (u64)92u;
            (*t++) = 'v';
        }break;
        default: {
            if (((c < (i64)32) || (c >= (i64)127))) {
                msysnewc_m_print_startstr(str);
                msysnewc_m_print_setfmt((byte*)"\\#o");
                msysnewc_m_print_i64(c,(byte*)"z3");
                msysnewc_m_print_end();
                ;
                (*t++) = (u64)(str[((i64)1)-1]);
                (*t++) = (u64)(str[((i64)2)-1]);
                (*t++) = (u64)(str[((i64)3)-1]);
                (*t++) = (u64)(str[((i64)4)-1]);
            } else {
                (*t++) = (u64)(c);
            };
        }
        } //SW
;
L551 :;
    }L552 :;
    ;
    (*t) = (u64)0u;
}

struct mlib_strbuffer * cc_lib_strexpr(struct cc_decls_unitrec * p) {
    mlib_gs_init(cc_lib_exprstr);
    cc_lib_jeval(cc_lib_exprstr,p);
    return cc_lib_exprstr;
}

static void cc_lib_jeval(struct mlib_strbuffer * dest,struct cc_decls_unitrec * p) {
    struct cc_decls_unitrec *  q;
    byte str[16000];
    i64 lb;
    i64 t;
    if (((i64)((*p).tag)==(i64)1)) {
        if (((t = (i64)((*p).mode)) == cc_decls_trefchar)) {
            if (((i64)((*p).slength) == (i64)0)) {
                goto L553 ;
;
            };
            if (!(!!((u64)((*p).isstrconst)))) {
                goto L553 ;
;
            };
            if (((i64)((*p).slength) > (i64)8000)) {
                strcpy((i8 *)(str),(i8 *)((byte*)"LONGSTR)"));
            } else {
                cc_lib_convertstring((*p).svalue,str,(i64)-1);
            };
            cc_support_gs_additem(dest,(byte*)"\"");
            cc_support_gs_additem(dest,str);
            cc_support_gs_additem(dest,(byte*)"\"");
            return;
        } else if (((t >= (i64)2) && (t <= (i64)5))) {
            msysnewc_getstrint((*p).value,str);
        } else if (((t >= (i64)7) && (t <= (i64)10))) {
            strcpy((i8 *)(str),(i8 *)(msysnewc_strword((*p).uvalue,(byte *)(0))));
        } else if (((t == (i64)12) || (t == (i64)11))) {
            strcpy((i8 *)(str),(i8 *)(msysnewc_strreal((*p).xvalue,(byte *)(0))));
        } else {
            if ((cc_decls_ttbasetype[((i64)((*p).mode))]==(i64)16)) {
                //doref:
L553 :;
;
                msysnewc_m_print_startstr(str);
                msysnewc_m_print_ptr((void *)((*p).svalue),NULL);
                msysnewc_m_print_end();
                ;
            }else if ((cc_decls_ttbasetype[((i64)((*p).mode))]==(i64)19)) {
                strcpy((i8 *)(str),(i8 *)((byte*)"ARRAY"));
            } else {
                msysnewc_m_print_startcon();
                msysnewc_m_print_str(cc_lib_typename((i64)((*p).mode)),NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
                cc_support_nxerror((byte*)"EVAL/CONST",p);
            };
        };
        cc_support_gs_additem(dest,str);
    }else if (((i64)((*p).tag)==(i64)3)) {
        cc_support_gs_additem(dest,(*(*p).def).name);
    }else if (((i64)((*p).tag)==(i64)5)) {
        mlib_gs_str(dest,(byte*)"&");
        cc_support_gs_additem(dest,(*(*p).def).name);
    }else if (((i64)((*p).tag)==(i64)25) || ((i64)((*p).tag)==(i64)26) || ((i64)((*p).tag)==(i64)33) || ((i64)((*p).tag)==(i64)34) || ((i64)((*p).tag)==(i64)35) || ((i64)((*p).tag)==(i64)36) || ((i64)((*p).tag)==(i64)37) || ((i64)((*p).tag)==(i64)38) || ((i64)((*p).tag)==(i64)39) || ((i64)((*p).tag)==(i64)40) || ((i64)((*p).tag)==(i64)41) || ((i64)((*p).tag)==(i64)42) || ((i64)((*p).tag)==(i64)43) || ((i64)((*p).tag)==(i64)44) || ((i64)((*p).tag)==(i64)45) || ((i64)((*p).tag)==(i64)46) || ((i64)((*p).tag)==(i64)47) || ((i64)((*p).tag)==(i64)48) || ((i64)((*p).tag)==(i64)49) || ((i64)((*p).tag)==(i64)62) || ((i64)((*p).tag)==(i64)63) || ((i64)((*p).tag)==(i64)64) || ((i64)((*p).tag)==(i64)65) || ((i64)((*p).tag)==(i64)66) || ((i64)((*p).tag)==(i64)67) || ((i64)((*p).tag)==(i64)68) || ((i64)((*p).tag)==(i64)69) || ((i64)((*p).tag)==(i64)70) || ((i64)((*p).tag)==(i64)71)) {
        strcpy((i8 *)(str),(i8 *)(cc_lib_getopcjname((i64)((*p).tag))));
        cc_support_gs_additem(dest,(byte*)"(");
        cc_lib_jeval(dest,(*p).a);
        cc_support_gs_additem(dest,str);
        cc_lib_jeval(dest,(*p).b);
        cc_support_gs_additem(dest,(byte*)")");
    }else if (((i64)((*p).tag)==(i64)59) || ((i64)((*p).tag)==(i64)60) || ((i64)((*p).tag)==(i64)61) || ((i64)((*p).tag)==(i64)27) || ((i64)((*p).tag)==(i64)28)) {
        strcpy((i8 *)(str),(i8 *)(cc_lib_getopcjname((i64)((*p).tag))));
        cc_support_gs_additem(dest,str);
        cc_support_gs_additem(dest,(byte*)"(");
        cc_lib_jeval(dest,(*p).a);
        cc_support_gs_additem(dest,(byte*)")");
    }else if (((i64)((*p).tag)==(i64)31)) {
        cc_lib_jeval(dest,(*p).a);
        cc_support_gs_additem(dest,(byte*)"(");
        q = (*p).b;
        L554 :;
        while (!!(q)) {
            cc_lib_jeval(dest,q);
            q = (*q).nextunit;
            if (!!(q)) {
                cc_support_gs_additem(dest,(byte*)",");
            };
L555 :;
        }L556 :;
        ;
        cc_support_gs_additem(dest,(byte*)")");
    }else if (((i64)((*p).tag)==(i64)50)) {
        cc_lib_jeval(dest,(*p).a);
        cc_support_gs_additem(dest,(byte*)".");
        mlib_gs_str(dest,(byte*)"???");
    }else if (((i64)((*p).tag)==(i64)51)) {
        cc_lib_jeval(dest,(*p).a);
        cc_support_gs_additem(dest,(byte*)"->");
        cc_lib_jeval(dest,(*p).b);
    }else if (((i64)((*p).tag)==(i64)29) || ((i64)((*p).tag)==(i64)30)) {
        lb = ((i64)((*p).tag) == (i64)30);
        cc_support_gs_additem(dest,(!!(lb)?(byte*)"(":(byte*)"{"));
        q = (*p).a;
        L557 :;
        while (!!(q)) {
            cc_lib_jeval(dest,q);
            q = (*q).nextunit;
            if (!!(q)) {
                cc_support_gs_additem(dest,(byte*)",");
            };
L558 :;
        }L559 :;
        ;
        cc_support_gs_additem(dest,(!!(lb)?(byte*)")":(byte*)"}"));
    }else if (((i64)((*p).tag)==(i64)12)) {
        cc_lib_jeval(dest,(*p).a);
        cc_support_gs_additem(dest,(byte*)"=");
        cc_lib_jeval(dest,(*p).b);
    }else if (((i64)((*p).tag)==(i64)32)) {
        cc_lib_jeval(dest,(*p).a);
        cc_support_gs_additem(dest,(byte*)"?");
        cc_lib_jeval(dest,(*p).b);
        cc_support_gs_additem(dest,(byte*)":");
        cc_lib_jeval(dest,(*p).c);
    }else if (((i64)((*p).tag)==(i64)57)) {
        cc_support_gs_additem(dest,cc_lib_strmode((i64)((*p).mode),(i64)1));
        cc_support_gs_additem(dest,(byte*)"(");
        cc_lib_jeval(dest,(*p).a);
        cc_support_gs_additem(dest,(byte*)")");
    }else if (((i64)((*p).tag)==(i64)53)) {
        cc_support_gs_additem(dest,(byte*)"*(");
        cc_lib_jeval(dest,(*p).a);
        if (!!((*p).b)) {
            cc_support_gs_additem(dest,(byte*)"+");
            cc_lib_jeval(dest,(*p).b);
        };
        cc_support_gs_additem(dest,(byte*)")");
    }else if (((i64)((*p).tag)==(i64)6)) {
        cc_support_gs_additem(dest,(byte*)"<JBLOCK>");
    }else if (((i64)((*p).tag)==(i64)73)) {
        cc_support_gs_additem(dest,(byte*)"++");
        cc_lib_jeval(dest,(*p).a);
    }else if (((i64)((*p).tag)==(i64)74)) {
        cc_support_gs_additem(dest,(byte*)"--");
        cc_lib_jeval(dest,(*p).a);
    }else if (((i64)((*p).tag)==(i64)75)) {
        cc_lib_jeval(dest,(*p).a);
        cc_support_gs_additem(dest,(byte*)"++");
    }else if (((i64)((*p).tag)==(i64)76)) {
        cc_lib_jeval(dest,(*p).a);
        cc_support_gs_additem(dest,(byte*)"--");
    }else if (((i64)((*p).tag)==(i64)2)) {
        mlib_gs_str(dest,(byte*)"<nullunit>");
    }else if (((i64)((*p).tag)==(i64)58)) {
        mlib_gs_str(dest,(byte*)"scale((");
        cc_lib_jeval(dest,(*p).a);
        if (((i64)((*p).scale) > (i64)0)) {
            mlib_gs_str(dest,(byte*)")*");
            mlib_gs_strint(dest,(i64)((*p).scale));
        } else {
            mlib_gs_str(dest,(byte*)")/");
            mlib_gs_strint(dest,-((i64)((*p).scale)));
        };
        mlib_gs_str(dest,(byte*)")");
    } else {
        mlib_gs_str(dest,(byte*)"<CAN'T DO JEVAL>");
    };
}

byte * cc_lib_getopcjname(i64 opc) {
    static byte str[20];
    byte *  name;
    byte *  s;
    name = cc_tables_jtagnames[(opc)];
    s = (byte *)(strchr((i8 *)(name),(i64)32));
    if (!!(s)) {
        memcpy((void *)(str),(void *)(name),(u64)((s - name)));
        str[(((s - name) + (i64)1))-1] = (u64)0u;
        return str;
    } else {
        return name;
    };
}

byte * cc_lib_strmode(i64 m,i64 expand) {
    static byte str[16384];
    cc_lib_istrmode(m,expand,str);
    return str;
}

byte * cc_lib_strmode2(i64 m,i64 expand) {
    static byte str[16384];
    cc_lib_istrmode(m,expand,str);
    return str;
}

void cc_lib_istrmode(i64 m,i64 expand,byte * dest) {
    struct cc_decls_strec *  d;
    struct cc_decls_strec *  q;
    i64 needcomma;
    i64 i;
    i64 target;
    i64 t;
    i64 n;
    struct mlib_strbuffer sxx;
    struct mlib_strbuffer *  xx;
    struct cc_decls_paramrec *  pm;
    xx = &sxx;
    if ((m < (i64)22)) {
        strcpy((i8 *)(dest),(i8 *)(cc_lib_typename(m)));
        return;
    };
    t = cc_decls_ttbasetype[(m)];
    if ((t==(i64)16)) {
        if (!!((u64)(cc_decls_ttconst[(m)]))) {
            strcpy((i8 *)(dest),(i8 *)((byte*)"const ref "));
        } else {
            strcpy((i8 *)(dest),(i8 *)((byte*)"ref "));
        };
        target = cc_decls_tttarget[(m)];
        if (((target >= (i64)0) && (cc_decls_ttbasetype[(cc_decls_tttarget[(m)])] == (i64)20))) {
            strcat((i8 *)(dest),(i8 *)(cc_lib_typename(cc_decls_tttarget[(m)])));
        } else {
            cc_lib_istrmode(cc_decls_tttarget[(m)],(i64)0,(dest + (i64)(strlen((i8 *)(dest)))));
        };
    }else if ((t==(i64)19)) {
        if (!!(cc_decls_ttlength[(m)])) {
            msysnewc_m_print_startstr(dest);
            msysnewc_m_print_setfmt((byte*)"[#]");
            msysnewc_m_print_i64(cc_decls_ttlength[(m)],NULL);
            msysnewc_m_print_end();
            ;
        } else {
            strcpy((i8 *)(dest),(i8 *)((byte*)"[]"));
        };
        cc_lib_istrmode(cc_decls_tttarget[(m)],(i64)0,(dest + (i64)(strlen((i8 *)(dest)))));
    }else if ((t==(i64)15)) {
        strcpy((i8 *)(dest),(i8 *)((byte*)"enum "));
        strcat((i8 *)(dest),(i8 *)(cc_lib_typename(m)));
    }else if ((t==(i64)20) || (t==(i64)21)) {
        if (!(!!(expand))) {
            strcpy((i8 *)(dest),(i8 *)(cc_lib_typename(m)));
            return;
        };
        strcpy((i8 *)(dest),(i8 *)(cc_lib_typename(cc_decls_ttbasetype[(m)])));
        strcat((i8 *)(dest),(i8 *)((byte*)"("));
        d = cc_decls_ttnamedef[(m)];
        needcomma = (i64)0;
        q = (*d).deflist;
        L560 :;
        while (!!(q)) {
            if (!!(needcomma)) {
                strcat((i8 *)(dest),(i8 *)((byte*)","));
            };
            needcomma = (i64)1;
            cc_lib_istrmode((i64)((*q).mode),(i64)0,(dest + (i64)(strlen((i8 *)(dest)))));
            strcat((i8 *)(dest),(i8 *)((byte*)" "));
            strcat((i8 *)(dest),(i8 *)((*q).name));
            q = (*q).nextdef;
L561 :;
        }L562 :;
        ;
        strcat((i8 *)(dest),(i8 *)((byte*)")"));
    }else if ((t==(i64)1)) {
        strcpy((i8 *)(dest),(i8 *)(cc_lib_typename(m)));
    }else if ((t==(i64)17)) {
        strcpy((i8 *)(dest),(i8 *)((byte*)"proc[PM]("));
        pm = cc_decls_ttparams[(m)];
        n = (i64)((*pm).nparams);
        L563 :;
        for (i=(i64)1;i<=n;i+=(i64)1) {
L564 :;
            cc_lib_istrmode((i64)((*pm).mode),(i64)0,(dest + (i64)(strlen((i8 *)(dest)))));
            if ((i != n)) {
                strcat((i8 *)(dest),(i8 *)((byte*)","));
            };
            pm = (*pm).nextparam;
L565 :;
        }L566 :;
        ;
        strcat((i8 *)(dest),(i8 *)((byte*)")"));
        cc_lib_istrmode(cc_decls_tttarget[(m)],(i64)0,(dest + (i64)(strlen((i8 *)(dest)))));
    } else {
        if ((t < (i64)22)) {
            strcpy((i8 *)(dest),(i8 *)(cc_lib_typename(m)));
            return;
        } else {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(cc_lib_typename(m),NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            cc_support_mcerror((byte*)"NEWSTRMODE");
        };
    };
}

i64 cc_lib_countunits(struct cc_decls_unitrec * p) {
    i64 n;
    n = (i64)0;
    L567 :;
    while (!!(p)) {
        ++n;
        p = (*p).nextunit;
L568 :;
    }L569 :;
    ;
    return n;
}

static void cc_lib_purgesymbol(struct cc_decls_strec * p,struct cc_decls_strec * prev,i64 del) {
    struct cc_decls_strec *  q;
    if (((i64)((*p).nameid)==(i64)10)) {
        return;
    };
    cc_lib_purgesymbollist((*p).deflist,(i64)0,del);
    if (!!(prev)) {
        (*prev).nextdef = (*p).nextdef;
    } else {
        (*(*p).owner).deflist = (*p).nextdef;
    };
    q = (*p).prevdupl;
    (*q).nextdupl = (*p).nextdupl;
    if (!!(del)) {
        mlib_pcm_free((void *)(p),(i64)128);
    };
}

void cc_lib_purgesymbollist(struct cc_decls_strec * p,i64 ismodule,i64 del) {
    cc_support_serror((byte*)"PURGESYMBOL");
}

void cc_lib_purgeprocs(struct cc_decls_strec * p,i64 del) {
    L570 :;
    while (!!(p)) {
        if (((i64)((u64)((*p).nameid)) == (i64)6)) {
            cc_lib_purgeproc(p,del);
        };
        p = (*p).nextdef;
L571 :;
    }L572 :;
    ;
}

void cc_lib_purgeproc(struct cc_decls_strec * p,i64 del) {
    struct cc_decls_strec *  q;
    struct cc_decls_strec *  prev;
    struct cc_decls_strec *  r;
    q = (*p).deflist;
    prev = (struct cc_decls_strec *)(0);
    L573 :;
    while (!!(q)) {
        r = (*q).nextdef;
        if (((i64)((u64)((*q).nameid)) == (i64)8)) {
            cc_lib_purgesymbol(q,prev,del);
        } else {
            prev = q;
        };
        q = r;
L574 :;
    }L575 :;
    ;
}

void cc_lib_printmodelist(void * f) {
    byte *  mstr;
    struct mlib_strbuffer destv;
    struct mlib_strbuffer *  dest;
    i64 m;
    dest = &destv;
    msysnewc_m_print_startfile(f);
    msysnewc_m_print_str((byte*)"MODELIST",NULL);
    msysnewc_m_print_i64(cc_decls_ntypes,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    mlib_gs_init(dest);
    mlib_gs_leftstr(dest,(byte*)"#",(i64)4,(i64)32);
    mlib_gs_leftstr(dest,(byte*)"Name",(i64)13,(i64)32);
    mlib_gs_leftstr(dest,(byte*)"Base",(i64)13,(i64)32);
    mlib_gs_leftstr(dest,(byte*)"Bit",(i64)3,(i64)32);
    mlib_gs_leftstr(dest,(byte*)"Target",(i64)14,(i64)32);
    mlib_gs_leftstr(dest,(byte*)"Len",(i64)4,(i64)32);
    mlib_gs_leftstr(dest,(byte*)"Size",(i64)5,(i64)32);
    mlib_gs_leftstr(dest,(byte*)"C",(i64)3,(i64)32);
    mlib_gs_leftstr(dest,(byte*)"R",(i64)3,(i64)32);
    mlib_gs_leftstr(dest,(byte*)"V",(i64)3,(i64)32);
    mlib_gs_leftstr(dest,(byte*)"@Cnst",(i64)5,(i64)32);
    mlib_gs_leftstr(dest,(byte*)"@Ref",(i64)5,(i64)32);
    mlib_gs_leftstr(dest,(byte*)"Tag",(i64)8,(i64)32);
    mlib_gs_leftstr(dest,(byte*)"Mode",(i64)32,(i64)32);
    mlib_gs_println(dest,f);
    L576 :;
    for (m=(i64)0;m<=cc_decls_ntypes;m+=(i64)1) {
L577 :;
        mlib_gs_init(dest);
        mlib_gs_leftint(dest,m,(i64)4,(i64)32);
        mlib_gs_leftstr(dest,cc_lib_typename(m),(i64)13,(i64)32);
        mlib_gs_leftstr(dest,cc_lib_typename(cc_decls_ttbasetype[(m)]),(i64)13,(i64)32);
        mlib_gs_leftint(dest,cc_decls_ttbitwidth[(m)],(i64)3,(i64)32);
        if (!!(cc_decls_tttarget[(m)])) {
            mlib_gs_leftint(dest,cc_decls_tttarget[(m)],(i64)3,(i64)32);
            mlib_gs_leftstr(dest,cc_lib_typename(cc_decls_tttarget[(m)]),(i64)11,(i64)32);
        } else {
            mlib_gs_leftstr(dest,(byte*)"-",(i64)14,(i64)32);
        };
        if ((cc_decls_ttbasetype[(m)]==(i64)19) || (cc_decls_ttbasetype[(m)]==(i64)20) || (cc_decls_ttbasetype[(m)]==(i64)21)) {
            mlib_gs_leftint(dest,cc_decls_ttlength[(m)],(i64)4,(i64)32);
        } else {
            mlib_gs_leftstr(dest,(byte*)"",(i64)4,(i64)32);
        };
        mlib_gs_leftint(dest,cc_decls_ttsize[(m)],(i64)5,(i64)32);
        mlib_gs_leftint(dest,(i64)(cc_decls_ttconst[(m)]),(i64)3,(i64)32);
        mlib_gs_leftint(dest,(i64)(cc_decls_ttrestrict[(m)]),(i64)3,(i64)32);
        mlib_gs_leftint(dest,(i64)(cc_decls_ttvolatile[(m)]),(i64)3,(i64)32);
        mlib_gs_leftint(dest,cc_decls_ttconsttype[(m)],(i64)5,(i64)32);
        mlib_gs_leftint(dest,cc_decls_ttreftype[(m)],(i64)5,(i64)32);
        if (!!(cc_decls_ttnamedef[(m)])) {
            mlib_gs_leftstr(dest,(*cc_decls_ttnamedef[(m)]).name,(i64)8,(i64)32);
        } else {
            mlib_gs_leftstr(dest,(byte*)"-",(i64)8,(i64)32);
        };
        mstr = cc_lib_strmode(m,(i64)1);
        if (((i64)(strlen((i8 *)(mstr))) < (i64)16)) {
            mlib_gs_str(dest,mstr);
        } else {
            mlib_gs_println(dest,f);
            mlib_gs_init(dest);
            mlib_gs_str(dest,(byte*)"\t\t");
            mlib_gs_str(dest,mstr);
        };
        mlib_gs_println(dest,f);
L578 :;
    }L579 :;
    ;
    msysnewc_m_print_startfile(f);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
}

byte * cc_lib_typename(i64 m) {
    i64 basem;
    static byte str[300];
    basem = cc_decls_ttbasetype[(m)];
    if ((basem==(i64)20) || (basem==(i64)21)) {
        strcpy((i8 *)(str),((basem == (i64)20)?(i8 *)((byte*)"struct "):(i8 *)((byte*)"union ")));
        if (!!(cc_decls_ttnamedef[(m)])) {
            strcat((i8 *)(str),(i8 *)((*cc_decls_ttnamedef[(m)]).name));
        };
        return str;
    }else if ((basem==(i64)19)) {
        return (byte*)"<array>";
    }else if ((basem==(i64)15)) {
        if (!!(cc_decls_ttnamedef[(m)])) {
            return (*cc_decls_ttnamedef[(m)]).name;
        };
        return (byte*)"<enum>";
    } else {
        if (!!((u64)(cc_decls_ttconst[(m)]))) {
            strcpy((i8 *)(str),(i8 *)((byte*)"const "));
            strcat((i8 *)(str),(i8 *)(cc_tables_stdtypenames[(basem)]));
            return str;
        };
        return cc_tables_stdtypenames[(basem)];
    };
    return (byte*)"";
}

struct cc_decls_unitrec * cc_lib_allocunitrec(void) {
    struct cc_decls_unitrec *  p;
    if (!!(cc_lib_remainingunits--)) {
        p = cc_lib_unitheapptr;
        ++cc_lib_unitheapptr;
        (*p).lineno = (u64)(cc_decls_lx.lineno);
        if (((i64)((u64)(cc_decls_lx.fileno)) <= (i64)255)) {
            (*p).fileno = (u64)(cc_decls_lx.fileno);
        };
        return p;
    };
    p = (cc_lib_unitheapptr = (struct cc_decls_unitrec *)(mlib_pcm_alloc((i64)3200000)));
    memset((void *)(p),(i64)0,(u64)((i64)3200000));
    cc_lib_remainingunits = (i64)49999;
    ++cc_lib_unitheapptr;
    (*p).lineno = (u64)(cc_decls_lx.lineno);
    if (((i64)((u64)(cc_decls_lx.fileno)) <= (i64)255)) {
        (*p).fileno = (u64)(cc_decls_lx.fileno);
    };
    return p;
}

static i64 cc_lib_copymode(i64 m) {
    if ((cc_decls_ntypes >= (i64)20000)) {
        cc_support_serror((byte*)"Too many types");
    };
    ++cc_decls_ntypes;
    cc_decls_ttnamedef[(cc_decls_ntypes)] = cc_decls_ttnamedef[(m)];
    cc_decls_ttbasetype[(cc_decls_ntypes)] = cc_decls_ttbasetype[(m)];
    cc_decls_ttlength[(cc_decls_ntypes)] = cc_decls_ttlength[(m)];
    cc_decls_ttconst[(cc_decls_ntypes)] = (u64)(cc_decls_ttconst[(m)]);
    cc_decls_ttrestrict[(cc_decls_ntypes)] = (u64)(cc_decls_ttrestrict[(m)]);
    cc_decls_ttvolatile[(cc_decls_ntypes)] = (u64)(cc_decls_ttvolatile[(m)]);
    cc_decls_ttusertype[(cc_decls_ntypes)] = cc_decls_ttusertype[(m)];
    cc_decls_ttsize[(cc_decls_ntypes)] = cc_decls_ttsize[(m)];
    cc_decls_ttbitwidth[(cc_decls_ntypes)] = cc_decls_ttbitwidth[(m)];
    cc_decls_tttarget[(cc_decls_ntypes)] = cc_decls_tttarget[(m)];
    cc_decls_ttparams[(cc_decls_ntypes)] = cc_decls_ttparams[(m)];
    cc_decls_ttisref[(cc_decls_ntypes)] = (u64)(cc_decls_ttisref[(m)]);
    return cc_decls_ntypes;
}

static i64 cc_lib_createnewmode(i64 m) {
    if ((cc_decls_ntypes >= (i64)20000)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"STRMODE(M)=",NULL);
        msysnewc_m_print_str(cc_lib_strmode(m,(i64)1),NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        cc_support_serror((byte*)"Too many types/cnm");
    };
    ++cc_decls_ntypes;
    cc_decls_ttbasetype[(cc_decls_ntypes)] = m;
    cc_decls_ttsize[(cc_decls_ntypes)] = cc_decls_ttsize[(m)];
    cc_decls_ttbitwidth[(cc_decls_ntypes)] = cc_decls_ttbitwidth[(m)];
    return cc_decls_ntypes;
}

void cc_lib_addlistunit(struct cc_decls_unitrec * * ulist,struct cc_decls_unitrec * * ulistx,struct cc_decls_unitrec * p) {
    if (((*ulist) == 0)) {
        (*ulist) = ((*ulistx) = p);
    } else {
        (*(*ulistx)).nextunit = p;
    };
    (*p).nextunit = (struct cc_decls_unitrec *)(0);
    (*ulistx) = p;
}

void cc_lib_addlistdef(struct cc_decls_strec * * ulist,struct cc_decls_strec * * ulistx,struct cc_decls_strec * p) {
    if (((*ulist) == 0)) {
        (*ulist) = ((*ulistx) = p);
    } else {
        (*(*ulistx)).nextdef = p;
    };
    (*p).nextdef = (struct cc_decls_strec *)(0);
    (*ulistx) = p;
}

void cc_lib_addlistparam(struct cc_decls_paramrec * * ulist,struct cc_decls_paramrec * * ulistx,struct cc_decls_paramrec * p) {
    if (((*ulist) == 0)) {
        (*ulist) = ((*ulistx) = p);
    } else {
        (*(*ulistx)).nextparam = p;
    };
    (*p).nextparam = (struct cc_decls_paramrec *)(0);
    (*ulistx) = p;
}

void cc_lib_checksymbol(i64 symbol) {
    byte str[256];
    if (((i64)((u64)(cc_decls_lx.symbol)) != symbol)) {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_setfmt((byte*)"# expected, not #");
        msysnewc_m_print_str(cc_tables_symbolnames[(symbol)-1],NULL);
        msysnewc_m_print_str(cc_tables_symbolnames[((i64)(cc_decls_lx.symbol))-1],NULL);
        msysnewc_m_print_end();
        ;
        if (((i64)((u64)(cc_decls_lx.symbol)) == (i64)69)) {
            strcat((i8 *)(str),(i8 *)((byte*)" \""));
            strcat((i8 *)(str),(i8 *)(cc_lib_getstname(cc_decls_lx.symptr)));
            strcat((i8 *)(str),(i8 *)((byte*)"\""));
        };
        cc_support_serror(str);
    };
}

void cc_lib_skipsymbol(i64 symbol) {
    if (((i64)((u64)(cc_decls_lx.symbol)) != symbol)) {
        cc_lib_checksymbol(symbol);
    };
    cc_lex_lex();
}

void cc_lib_inittypetables(void) {
    i64 i;
    i64 size;
    i64 bitsize;
    i64 s;
    i64 t;
    i64 u;
    i64 av_1;
    i64 av_2;
    i64 av_3;
    L580 :;
    for (i=(i64)0;i<=(i64)21;i+=(i64)1) {
L581 :;
        cc_decls_ttbasetype[(i)] = i;
        bitsize = (i64)(cc_tables_stdtypewidths[(i)]);
        size = (bitsize / (i64)8);
        cc_decls_ttsize[(i)] = size;
        cc_decls_ttbitwidth[(i)] = bitsize;
L582 :;
    }L583 :;
    ;
    cc_decls_ntypes = (i64)21;
    cc_decls_trefchar = cc_lib_createrefmode((i64)2);
    cc_decls_trefwchar = cc_lib_createrefmode((i64)8);
    L584 :;
    for (i=(i64)1;i<=(i64)144;i+=(i64)1) {
L585 :;
        s = (i64)(cc_tables_dominantsetuptable[(i)-1][((i64)1)-1]);
        t = (i64)(cc_tables_dominantsetuptable[(i)-1][((i64)2)-1]);
        u = (i64)(cc_tables_dominantsetuptable[(i)-1][((i64)3)-1]);
        cc_tables_dominantmode[(s)][(t)] = (u64)(u);
L586 :;
    }L587 :;
    ;
    L588 :;
    for (i=(i64)1;i<=(i64)144;i+=(i64)1) {
L589 :;
        s = (i64)(cc_tables_convsetuptable[(i)-1][((i64)1)-1]);
        t = (i64)(cc_tables_convsetuptable[(i)-1][((i64)2)-1]);
        u = (i64)(cc_tables_convsetuptable[(i)-1][((i64)3)-1]);
        cc_tables_conversionops[(s)][(t)] = (u64)(u);
L590 :;
    }L591 :;
    ;
    cc_decls_ntypesreset = cc_decls_ntypes;
}

struct cc_decls_strec * cc_lib_createdupldef(struct cc_decls_strec * owner,struct cc_decls_strec * symptr,i64 id) {
    struct cc_decls_strec *  p;
    struct cc_decls_strec *  q;
    p = cc_lib_newstrec();
    (*p).name = (*symptr).name;
    (*p).namelen = (u64)((*symptr).namelen);
    (*p).symbol = (u64)((i64)69);
    (*p).owner = owner;
    (*p).nameid = (u64)(id);
    (*p).namespace = (u64)(cc_tables_namespaces[(id)]);
    if (!!((q = (*symptr).nextdupl))) {
        (*q).prevdupl = p;
    };
    (*p).nextdupl = q;
    (*p).prevdupl = symptr;
    (*symptr).nextdupl = p;
    if (!!(owner)) {
        if (((*owner).deflist == 0)) {
            (*owner).deflist = ((*owner).deflistx = p);
        } else {
            (*(*owner).deflistx).nextdef = p;
            (*owner).deflistx = p;
        };
    };
    return p;
}

struct cc_decls_strec * cc_lib_createnewmoduledef(struct cc_decls_strec * owner,struct cc_decls_strec * symptr) {
    struct cc_decls_strec *  p;
    p = cc_lib_createdupldef(owner,symptr,(i64)3);
    return p;
}

struct cc_decls_strec * cc_lib_createnewproc(struct cc_decls_strec * owner,struct cc_decls_strec * symptr) {
    struct cc_decls_strec *  p;
    struct cc_decls_strec *  q;
    p = cc_lib_createdupldef(owner,symptr,(i64)6);
    q = p;
    L592 :;
    while (!!((q = (*q).nextdupl))) {
        if (((*q).owner == owner)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((*q).name,NULL);
            msysnewc_m_print_str((byte*)"in",NULL);
            msysnewc_m_print_str((*owner).name,NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            cc_support_serror((byte*)"Dupl proc name");
        };
L593 :;
    }L594 :;
    ;
    return p;
}

struct cc_decls_strec * cc_lib_resolvename(struct cc_decls_strec * owner,struct cc_decls_strec * symptr,i64 ns,i64 blockno) {
    i64 nsblock;
    struct cc_decls_strec *  d;
    if (((i64)((u64)((*symptr).nameid)) > (i64)1)) {
        return symptr;
    };
    if ((ns == (i64)3)) {
        return cc_lib_resolvelabel(owner,symptr);
    };
    if ((!!(blockno) && ((i64)(cc_decls_blockcounts[(blockno)]) == (i64)0))) {
        blockno = (i64)(cc_decls_blockowner[(blockno)]);
    };
    L595 :;
    while (1) {
        nsblock = ((ns << (i64)16) | blockno);
        d = symptr;
        L597 :;
        while (!!((d = (*d).nextdupl))) {
            if (((((i64)((u64)((*owner).nameid)) == (i64)6) && ((*d).owner != owner)) && ((i64)((u64)((*(*d).owner).nameid)) == (i64)6))) {
                goto L599 ;
            };
            if ((((*d).owner == owner) && ((i64)((u64)((*d).nsblock)) == nsblock))) {
                return d;
            };
L598 :;
        }L599 :;
        ;
        if ((blockno == (i64)0)) {
            if (((i64)((*owner).nameid)==(i64)6)) {
                owner = cc_decls_stmodule;
                goto L595 ;
            }else if (((i64)((*owner).nameid)==(i64)13)) {
                owner = (*owner).owner;
                if ((owner == 0)) {
                    return (struct cc_decls_strec *)(0);
                };
            } else {
                return (struct cc_decls_strec *)(0);
            };
        } else if (((blockno = (i64)(cc_decls_blockowner[(blockno)])) == (i64)0)) {
            owner = cc_decls_stmodule;
        };
    }L596 :;
    ;
    return (struct cc_decls_strec *)(0);
}

struct cc_decls_strec * cc_lib_resolvelabel(struct cc_decls_strec * owner,struct cc_decls_strec * symptr) {
    struct cc_decls_strec *  d;
    d = symptr;
    L600 :;
    while (!!((d = (*d).nextdupl))) {
        if (((((i64)((u64)((*owner).nameid)) == (i64)6) && ((*d).owner != owner)) && ((i64)((u64)((*(*d).owner).nameid)) == (i64)6))) {
            goto L602 ;
        };
        if ((((*d).owner == owner) && ((i64)((u64)((*d).namespace)) == (i64)3))) {
            return d;
        };
L601 :;
    }L602 :;
    ;
    return (struct cc_decls_strec *)(0);
}

struct cc_decls_strec * cc_lib_checkdupl(struct cc_decls_strec * owner,struct cc_decls_strec * symptr,i64 ns,i64 blockno) {
    i64 nsblock;
    struct cc_decls_strec *  d;
    d = symptr;
    nsblock = ((ns << (i64)16) | blockno);
    L603 :;
    while (!!((d = (*d).nextdupl))) {
        if ((((*d).owner == owner) && ((i64)((u64)((*d).nsblock)) == nsblock))) {
            return d;
        };
L604 :;
    }L605 :;
    ;
    return (struct cc_decls_strec *)(0);
}

struct cc_decls_strec * cc_lib_checkdupl_inproc(struct cc_decls_strec * owner,struct cc_decls_strec * symptr,i64 ns,i64 blockno) {
    i64 nsblock;
    struct cc_decls_strec *  d;
    d = symptr;
    nsblock = ((ns << (i64)16) | blockno);
    L606 :;
    while ((!!((d = (*d).nextdupl)) && ((*d).owner == owner))) {
        if (((i64)((u64)((*d).nsblock)) == nsblock)) {
            return d;
        };
L607 :;
    }L608 :;
    ;
    return (struct cc_decls_strec *)(0);
}

i64 cc_lib_getalignment(i64 m) {
    i64 a;
    if ((cc_decls_ttbasetype[(m)]==(i64)19)) {
        return cc_lib_getalignment(cc_decls_tttarget[(m)]);
    }else if ((cc_decls_ttbasetype[(m)]==(i64)20) || (cc_decls_ttbasetype[(m)]==(i64)21)) {
        a = (i64)((*cc_decls_ttnamedef[(m)]).attribs.ax_align);
        if ((a == (i64)0)) {
            return (i64)16;
        };
        return a;
    };
    a = cc_decls_ttsize[(m)];
    if ((a==(i64)1) || (a==(i64)2) || (a==(i64)4) || (a==(i64)8)) {
        return a;
    };
    msysnewc_m_print_startcon();
    msysnewc_m_print_str(cc_lib_strmode(m,(i64)1),NULL);
    msysnewc_m_print_i64(a,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    cc_support_serror((byte*)"GETALIGN SIZE NOT 1248");
    return (i64)0;
}

i64 cc_lib_isexported(struct cc_decls_strec * d) {
    if (((i64)((u64)((*d).nameid)) == (i64)6)) {
        if ((!!((*d).code) && (((i64)((u64)((*d).scope)) == (i64)3) || ((i64)((u64)((*d).scope)) == (i64)4)))) {
            return (i64)1;
        };
    } else {
        if (((i64)((u64)((*d).scope)) == (i64)4)) {
            return (i64)1;
        };
    };
    return (i64)0;
}

i64 cc_lib_isimported(struct cc_decls_strec * d) {
    if (((i64)((u64)((*d).nameid)) == (i64)6)) {
        if ((((*d).code == 0) && (((i64)((u64)((*d).scope)) == (i64)3) || ((i64)((u64)((*d).scope)) == (i64)4)))) {
            return (i64)1;
        };
    } else {
        if (((i64)((u64)((*d).scope)) == (i64)3)) {
            return (i64)1;
        };
    };
    return (i64)0;
}

i64 cc_lib_isstructunion(i64 m) {
    if ((cc_decls_ttbasetype[(m)]==(i64)20) || (cc_decls_ttbasetype[(m)]==(i64)21)) {
        if ((cc_decls_ttsize[(m)]==(i64)1) || (cc_decls_ttsize[(m)]==(i64)2) || (cc_decls_ttsize[(m)]==(i64)4) || (cc_decls_ttsize[(m)]==(i64)8)) {
        } else {
            return (i64)1;
        };
    };
    return (i64)0;
}

byte * cc_lib_getstname(struct cc_decls_strec * d) {
    static byte name[256];
    memcpy((void *)(name),(void *)((*d).name),(u64)((*d).namelen));
    name[(((i64)((u64)((*d).namelen)) + (i64)1))-1] = (u64)0u;
    return name;
}

i64 cc_lib_isrealcc(i64 m) {
    m = cc_decls_ttbasetype[(m)];
    return (((i64)11 <= m) && (m <= (i64)13));
}

i64 cc_lib_isintcc(i64 m) {
    m = cc_decls_ttbasetype[(m)];
    return (((i64)2 <= m) && (m <= (i64)10));
}

static void cc_parse_readmodule(void) {
    i64 linkage;
    i64 m;
    i64 mbase;
    i64 commaseen;
    i64 wasdef;
    struct cc_decls_strec *  d;
    struct cc_decls_paramrec *  pm;
    i64 t;
    i64 nitems;
    i64 wasenum;
    L609 :;
    while (((i64)((u64)(cc_decls_lx.symbol)) != (i64)58)) {
        nitems = (i64)0;
        if (((i64)(cc_decls_lx.symbol)==(i64)98)) {
            cc_lex_lex();
            t = cc_parse_readcasttype(&d,(i64)0,&pm);
            cc_lib_skipsymbol((i64)9);
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((byte*)"Type is:",NULL);
            msysnewc_m_print_str(cc_lib_strmode(t,(i64)1),NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            goto L610 ;
        }else if (((i64)(cc_decls_lx.symbol)==(i64)101)) {
            nitems = (i64)1;
        }else if (((i64)(cc_decls_lx.symbol)==(i64)9)) {
            cc_support_serror((byte*)"Extra semicolon 2");
        };
        wasenum = (i64)(cc_decls_lx.symbol);
        if (((i64)((u64)(cc_decls_lx.symbol)) == (i64)101)) {
            nitems = (i64)1;
        };
        mbase = cc_parse_readdeclspec(cc_decls_stmodule,&linkage);
        commaseen = (i64)0;
        L612 :;
        if (((i64)(cc_decls_lx.symbol)==(i64)69) || ((i64)(cc_decls_lx.symbol)==(i64)25) || ((i64)(cc_decls_lx.symbol)==(i64)13)) {
            ++nitems;
            m = cc_parse_readtype(cc_decls_stmodule,&d,mbase,&pm);
            if ((d == 0)) {
                cc_support_serror((byte*)"Var name expected");
            };
            if ((linkage == (i64)5)) {
                if (!!(pm)) {
                    m = cc_lib_createprocmode(m,pm);
                };
                d = cc_parse_createtypedef(cc_decls_stmodule,d,m);
                cc_parse_constantseen = (u64)((i64)0);
            } else if (!!(pm)) {
                //readfn:
L614 :;
;
                if ((((i64)((u64)(cc_decls_lx.symbol)) == (i64)17) && !!(commaseen))) {
                    cc_support_serror((byte*)"fn def after comma");
                };
                d = cc_parse_readfunction(d,m,linkage,pm,&wasdef);
                if (!!(wasdef)) {
                    goto L613 ;
                };
            } else if ((cc_decls_ttbasetype[(m)] == (i64)17)) {
                pm = cc_decls_ttparams[(m)];
                m = cc_decls_tttarget[(m)];
                cc_parse_constantseen = (u64)((i64)0);
                goto L614 ;
;
            } else {
                d = cc_parse_readmodulevar(d,m,linkage);
                cc_parse_constantseen = (u64)((i64)0);
            };
            if (((i64)(cc_decls_lx.symbol)==(i64)8)) {
                commaseen = (i64)1;
                cc_lex_lex();
            } else {
                cc_lib_skipsymbol((i64)9);
                goto L613 ;
            };
        }else if (((i64)(cc_decls_lx.symbol)==(i64)103)) {
            cc_parse_constantseen = (u64)((i64)1);
            cc_lex_lex();
            goto L610 ;
        }else if (((i64)(cc_decls_lx.symbol)==(i64)104)) {
            cc_parse_readstructinfosym();
        } else {
            if ((cc_decls_ttbasetype[(mbase)]==(i64)15) || (cc_decls_ttbasetype[(mbase)]==(i64)20) || (cc_decls_ttbasetype[(mbase)]==(i64)21)) {
                cc_lib_skipsymbol((i64)9);
                goto L613 ;
            }else if ((cc_decls_ttbasetype[(mbase)]==(i64)4)) {
                cc_lib_skipsymbol((i64)9);
                goto L613 ;
            } else {
                cc_support_serror_s((byte*)"Decl error %s",cc_lib_typename(mbase));
            };
        }goto L612 ;
L613 :;
        ;
        if (((nitems == (i64)0) && !!(cc_decls_fmodern))) {
            if ((cc_decls_ttbasetype[(mbase)]==(i64)20) || (cc_decls_ttbasetype[(mbase)]==(i64)21) || (cc_decls_ttbasetype[(mbase)]==(i64)15)) {
            } else {
                if ((wasenum != (i64)91)) {
                    msysnewc_m_print_startcon();
                    msysnewc_m_print_str((byte*)"STRMODE(MBASE)=",NULL);
                    msysnewc_m_print_str(cc_lib_strmode(mbase,(i64)1),NULL);
                    msysnewc_m_print_newline();
                    msysnewc_m_print_end();
                    ;
                    cc_support_serror((byte*)"Empty declaration");
                };
            };
        };
L610 :;
    }L611 :;
    ;
}

i64 cc_parse_parsemodule(i64 n) {
    struct cc_decls_strec *  owner;
    cc_parse_loopindex = (i64)((u64)((cc_parse_iscallbackfnx = (u64)((cc_parse_constantseen = (u64)((cc_parse_ingeneric = (u64)((i64)0))))))));
    cc_parse_ist_symptr = (struct cc_decls_strec *)(0);
    memset((void *)(&cc_parse_casevaluestack),(i64)0,(u64)((i64)800));
    cc_lex_startlex((byte*)"PARSETEST",cc_decls_moduletable[(n)].fileno);
    owner = cc_decls_stmodule;
    cc_decls_currproc = (struct cc_decls_strec *)(0);
    cc_parse_loopindex = (i64)0;
    cc_lex_lex();
    cc_parse_readmodule();
    cc_lex_endlex();
    return (i64)1;
}

static i64 cc_parse_readdeclspec(struct cc_decls_strec * owner,i64 * linkage) {
    struct cc_parse_readdeclspec_declrec d;
    struct cc_decls_unitrec *  p;
    i64 t;
    i64 mod;
    i64 m;
    i64 fstruct;
    memset((void *)(&d),(i64)0,(u64)((i64)15));
    fstruct = (mod = (i64)0);
    L615 :;
    switch ((i64)(cc_decls_lx.symbol)) {
    case 72:;
    {
        switch ((i64)(cc_decls_lx.subcode)) {
        case 5:;
        case 2:;
        case 6:;
        case 7:;
        case 10:;
        case 1:;
        {
            if (!!((i64)(d.typeno))) {
                if (!!(fstruct)) {
                    cc_lib_checksymbol((i64)9);
                } else {
                    goto L617 ;
;
                };
            };
            d.typeno = (i64)(cc_tables_typespectypes[((i64)(cc_decls_lx.subcode))-1]);
        }break;
        case 3:;
        {
            if (((!!((u64)(d.isshort)) || !!((u64)(d.islong))) || !!((u64)(d.isllong)))) {
                goto L617 ;
;
            };
            d.isshort = (u64)((mod = (i64)1));
        }break;
        case 4:;
        {
            if ((!!((u64)(d.isllong)) || !!((u64)(d.isshort)))) {
                goto L617 ;
;
            } else if (!!((u64)(d.islong))) {
                d.islong = (u64)((i64)0);
                d.isllong = (u64)((i64)1);
            } else {
                d.islong = (u64)((i64)1);
            };
            mod = (i64)1;
        }break;
        case 8:;
        {
            if ((!!((u64)(d.issigned)) || !!((u64)(d.isunsigned)))) {
                goto L617 ;
;
            };
            d.issigned = (u64)((mod = (i64)1));
        }break;
        case 9:;
        {
            if ((!!((u64)(d.issigned)) || !!((u64)(d.isunsigned)))) {
                goto L617 ;
;
            };
            d.isunsigned = (u64)((mod = (i64)1));
        }break;
        case 11:;
        {
            if (((!!((i64)(d.typeno)) && ((i64)(d.typeno) != (i64)11)) && ((i64)(d.typeno) != (i64)12))) {
                goto L617 ;
;
            };
            d.typeno = (i64)14;
        }break;
        default: {
            //tserror:
L617 :;
;
            cc_support_serror_s((byte*)"declspec/ts %s",cc_tables_typespecnames[((i64)(cc_decls_lx.subcode))-1]);
        }
        } //SW
;
        cc_lex_lex();
    }break;
    case 88:;
    {
        if (((i64)(cc_decls_lx.subcode)==(i64)1)) {
            d.isconst = (u64)((i64)1);
        }else if (((i64)(cc_decls_lx.subcode)==(i64)2)) {
            d.isvolatile = (u64)((i64)1);
        }else if (((i64)(cc_decls_lx.subcode)==(i64)3)) {
            d.isrestrict = (u64)((i64)1);
        };
        cc_lex_lex();
    }break;
    case 87:;
    {
        if (!!((u64)(d.linkage))) {
            cc_support_serror((byte*)"Dual storage spec");
        };
        d.linkage = (u64)(cc_decls_lx.subcode);
        cc_lex_lex();
    }break;
    case 89:;
    {
        if (((i64)(cc_decls_lx.subcode)==(i64)1)) {
            d.isinline = (u64)((i64)1);
        }else if (((i64)(cc_decls_lx.subcode)==(i64)3)) {
            cc_decls_callbackflag = (i64)1;
        };
        cc_lex_lex();
    }break;
    case 85:;
    case 86:;
    {
        if (!!((i64)(d.typeno))) {
            cc_support_serror((byte*)"struct?");
        };
        d.typeno = cc_parse_readstructdecl(owner);
        d.isusertype = (u64)((i64)1);
        fstruct = (i64)1;
    }break;
    case 91:;
    {
        if (!!((i64)(d.typeno))) {
            cc_support_serror((byte*)"enum?");
        };
        cc_parse_readenumdecl(owner);
        d.typeno = (i64)4;
        d.isusertype = (u64)((i64)1);
    }break;
    case 69:;
    {
        if ((!(!!((i64)(d.typeno))) && !!((m = cc_parse_isusertype(owner))))) {
            if (!!(mod)) {
                d.typeno = (i64)4;
                goto L616 ;
            };
            d.typeno = m;
            d.isusertype = (u64)((i64)1);
            cc_lex_lex();
        } else {
            if ((((i64)(d.typeno) == (i64)0) && !(!!(mod)))) {
                cc_support_serror_s((byte*)"Implicit decls not allowed: %s",(*cc_decls_lx.symptr).name);
            };
            if (((i64)(d.typeno) == (i64)0)) {
                d.typeno = (i64)4;
            };
            goto L616 ;
        };
    }break;
    case 99:;
    {
        cc_lex_lex();
        cc_lib_skipsymbol((i64)13);
        cc_parse_intypeof = (i64)1;
        p = cc_parse_readterm();
        cc_parse_intypeof = (i64)0;
        cc_lib_skipsymbol((i64)14);
        if ((!!((i64)(d.typeno)) || !!(mod))) {
            cc_support_serror((byte*)"typeof");
        };
        d.typeno = (i64)((*(*p).def).mode);
    }break;
    case 101:;
    {
        cc_parse_dostaticassert();
    }break;
    default: {
        goto L616 ;
    }
    } //SW
goto L615 ;
L616 :;
    ;
    t = (!!((i64)(d.typeno))?(i64)(d.typeno):(i64)4);
    if (!(!!((u64)(d.isusertype)))) {
        if ((t==(i64)4)) {
            if (!!((u64)(d.isshort))) {
                t = (!!((u64)(d.isunsigned))?(i64)8:(i64)3);
            } else if (!!((u64)(d.islong))) {
                if (!!(cc_decls_wintarget)) {
                    t = (!!((u64)(d.isunsigned))?(i64)9:(i64)4);
                } else {
                    t = (!!((u64)(d.isunsigned))?(i64)10:(i64)5);
                };
            } else if (!!((u64)(d.isllong))) {
                t = (!!((u64)(d.isunsigned))?(i64)10:(i64)5);
            } else if (!!((u64)(d.isunsigned))) {
                t = (i64)9;
            };
        }else if ((t==(i64)2)) {
            if (((!!((u64)(d.isshort)) || !!((u64)(d.islong))) || !!((u64)(d.isllong)))) {
                cc_support_serror((byte*)"char decl?");
            };
            t = (!!((u64)(d.isunsigned))?(i64)7:(i64)2);
        }else if ((t==(i64)12)) {
            if ((((!!((u64)(d.isshort)) || !!((u64)(d.isllong))) || !!((u64)(d.issigned))) || !!((u64)(d.isunsigned)))) {
                cc_support_serror((byte*)"dbl decl?");
            };
        }else if ((t==(i64)14)) {
            if ((((!!((u64)(d.isshort)) || !!((u64)(d.isllong))) || !!((u64)(d.issigned))) || !!((u64)(d.isunsigned)))) {
                cc_support_serror((byte*)"Complex?");
            };
        } else {
            if (!!(mod)) {
                cc_support_serror((byte*)"declspec/float");
            };
        };
    };
    if (!!((u64)(d.isconst))) {
        t = cc_lib_createconstmode(t);
    };
    (*linkage) = (i64)(d.linkage);
    return t;
}

static i64 cc_parse_istypestarter(void) {
    struct cc_decls_strec *  d;
    switch ((i64)(cc_decls_lx.symbol)) {
    case 72:;
    {
        return (i64)1;
    }break;
    case 88:;
    {
        return (i64)1;
    }break;
    case 69:;
    {
        d = cc_lib_resolvename((!!(cc_decls_currproc)?cc_decls_currproc:cc_decls_stmodule),cc_decls_lx.symptr,(i64)1,cc_decls_currblockno);
        if (!!(d)) {
            cc_decls_lx.symptr = d;
            return ((i64)((u64)((*d).nameid)) == (i64)5);
        };
    }break;
    case 85:;
    case 86:;
    case 91:;
    {
        return (i64)1;
    }break;
    default: {
    }
    } //SW
;
    return (i64)0;
}

static struct cc_decls_unitrec * cc_parse_readexpression(void) {
    struct cc_decls_unitrec *  p;
    struct cc_decls_unitrec *  ulist;
    struct cc_decls_unitrec *  ulistx;
    if (((i64)(cc_decls_nextlx.symbol)==(i64)9) || ((i64)(cc_decls_nextlx.symbol)==(i64)14)) {
        return cc_parse_readterm();
    };
    p = cc_parse_readassignexpr();
    if (((i64)((u64)(cc_decls_lx.symbol)) == (i64)8)) {
        ulist = (ulistx = (struct cc_decls_unitrec *)(0));
        L618 :;
        while (1) {
            cc_lib_addlistunit(&ulist,&ulistx,p);
            if (((i64)((u64)(cc_decls_lx.symbol)) != (i64)8)) {
                goto L619 ;
            };
            cc_lex_lex();
            p = cc_parse_readassignexpr();
        }L619 :;
        ;
        p = cc_lib_createunit1((i64)30,ulist);
        if (!!(ulistx)) {
            (*p).mode = (i64)((*ulistx).mode);
        };
        return p;
    };
    return p;
}

static struct cc_decls_unitrec * cc_parse_readassignexpr(void) {
    struct cc_decls_unitrec *  p;
    struct cc_decls_unitrec *  q;
    struct cc_decls_unitrec *  r;
    i64 opc;
    i64 oldpmode;
    if (((i64)(cc_decls_nextlx.symbol)==(i64)8) || ((i64)(cc_decls_nextlx.symbol)==(i64)9) || ((i64)(cc_decls_nextlx.symbol)==(i64)14)) {
        return cc_parse_readterm();
    }else if (((i64)(cc_decls_nextlx.symbol)==(i64)11)) {
        p = cc_parse_readterm();
        opc = (i64)(cc_decls_lx.symbol);
        goto L620 ;
;
    };
    p = cc_parse_readcondexpr();
    switch ((opc = (i64)(cc_decls_lx.symbol))) {
    case 11:;
    case 48:;
    case 49:;
    case 50:;
    case 46:;
    case 47:;
    case 54:;
    case 55:;
    case 52:;
    case 53:;
    case 51:;
    {
        //gotp:
L620 :;
;
        cc_lex_lex();
        oldpmode = (i64)((*p).mode);
        cc_parse_checklvalue(p);
        q = cc_parse_readassignexpr();
        if (!!((u64)(cc_decls_ttisref[((i64)((*p).mode))]))) {
            return cc_parse_createassignopref(opc,p,q);
        };
        q = cc_parse_coercemode(q,oldpmode);
        if (!!((u64)(cc_decls_ttconst[(oldpmode)]))) {
            cc_support_terror((byte*)"Modifying read-only var");
        };
        if ((((i64)((*q).tag) == (i64)57) && (opc == (i64)11))) {
            (*q).convtomem = (u64)((i64)1);
        };
        if ((((i64)((*p).tag) == (i64)53) && ((i64)((*(*p).a).tag) == (i64)1))) {
            cc_support_terror((byte*)"Modifying constant?");
        };
        r = cc_lib_createunit2((i64)(cc_tables_symboltojtag[(opc)-1]),p,q);
        (*r).mode = oldpmode;
        return r;
    }break;
    default: {
    }
    } //SW
;
    return p;
}

static struct cc_decls_unitrec * cc_parse_readcondexpr(void) {
    struct cc_decls_unitrec *  x;
    struct cc_decls_unitrec *  y;
    struct cc_decls_unitrec *  pcond;
    i64 s;
    i64 t;
    i64 u;
    pcond = cc_parse_readorlexpr();
    if (((i64)((u64)(cc_decls_lx.symbol)) == (i64)19)) {
        cc_parse_coercecond(pcond);
        cc_lex_lex();
        x = cc_parse_readexpression();
        cc_lib_skipsymbol((i64)10);
        y = cc_parse_readcondexpr();
        if (!!((u = (i64)(cc_tables_dominantmode[((s = cc_decls_ttbasetype[((i64)((*x).mode))]))][((t = cc_decls_ttbasetype[((i64)((*y).mode))]))])))) {
            x = cc_parse_coercemode(x,u);
            y = cc_parse_coercemode(y,u);
            if (((((i64)((*pcond).tag) == (i64)1) && ((i64)((*x).tag) == (i64)1)) && ((i64)((*y).tag) == (i64)1))) {
                return (!!((*pcond).value)?x:y);
            };
        } else if (((s == (i64)16) && (t == (i64)16))) {
            u = (i64)((*x).mode);
        } else if (((((s == (i64)16) && (t == (i64)4)) && ((i64)((*y).tag) == (i64)1)) && ((*y).value == (i64)0))) {
            u = (i64)((*x).mode);
            cc_parse_coercemode(y,u);
        } else if (((((s == (i64)4) && (t == (i64)16)) && ((i64)((*x).tag) == (i64)1)) && ((*x).value == (i64)0))) {
            u = (i64)((*y).mode);
            cc_parse_coercemode(x,u);
        } else if (((s == (i64)20) && (t == (i64)20))) {
            u = (i64)((*x).mode);
        } else if (((s == (i64)21) && (t == (i64)21))) {
            u = (i64)((*x).mode);
        } else if (((s == t) && (t == (i64)1))) {
            u = (i64)1;
        } else {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(cc_lib_strmode((i64)((*x).mode),(i64)1),NULL);
            msysnewc_m_print_str(cc_lib_strmode((i64)((*y).mode),(i64)1),NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            cc_support_terror((byte*)"?: incompatible types");
        };
        pcond = cc_lib_createunit3((i64)32,pcond,x,y);
        (*pcond).mode = u;
    };
    return pcond;
}

static struct cc_decls_unitrec * cc_parse_readorlexpr(void) {
    struct cc_decls_unitrec *  x;
    struct cc_decls_unitrec *  y;
    x = cc_parse_readandlexpr();
    L621 :;
    while (((i64)((u64)(cc_decls_lx.symbol)) == (i64)31)) {
        cc_lex_lex();
        y = cc_parse_readandlexpr();
        cc_parse_coercecond(x);
        cc_parse_coercecond(y);
        if ((((i64)((*x).tag) == (i64)1) && ((i64)((*y).tag) == (i64)1))) {
            (*x).value = ((!!((*x).value) || !!((*y).value))?(i64)1:(i64)0);
            goto L622 ;
        };
        x = cc_lib_createunit2((i64)26,x,y);
        (*x).mode = (i64)4;
L622 :;
    }L623 :;
    ;
    return x;
}

static struct cc_decls_unitrec * cc_parse_readandlexpr(void) {
    struct cc_decls_unitrec *  x;
    struct cc_decls_unitrec *  y;
    x = cc_parse_readiorexpr();
    L624 :;
    while (((i64)((u64)(cc_decls_lx.symbol)) == (i64)32)) {
        cc_lex_lex();
        y = cc_parse_readiorexpr();
        cc_parse_coercecond(x);
        cc_parse_coercecond(y);
        if ((((i64)((*x).tag) == (i64)1) && ((i64)((*y).tag) == (i64)1))) {
            (*x).value = ((!!((*x).value) && !!((*y).value))?(i64)1:(i64)0);
            goto L625 ;
        };
        x = cc_lib_createunit2((i64)25,x,y);
        (*x).mode = (i64)4;
L625 :;
    }L626 :;
    ;
    return x;
}

static struct cc_decls_unitrec * cc_parse_readiorexpr(void) {
    struct cc_decls_unitrec *  x;
    struct cc_decls_unitrec *  y;
    i64 u;
    x = cc_parse_readixorexpr();
    L627 :;
    while (((i64)((u64)(cc_decls_lx.symbol)) == (i64)28)) {
        cc_lex_lex();
        y = cc_parse_readixorexpr();
        if (!!((u = (i64)(cc_tables_dominantmode[(cc_decls_ttbasetype[((i64)((*x).mode))])][(cc_decls_ttbasetype[((i64)((*y).mode))])])))) {
            if ((u >= (i64)11)) {
                cc_support_terror((byte*)"float|float");
            };
            x = cc_parse_coercemode(x,u);
            y = cc_parse_coercemode(y,u);
        } else {
            cc_support_terror((byte*)"invalid | operands");
        };
        if ((((i64)((*x).tag) == (i64)1) && ((i64)((*y).tag) == (i64)1))) {
            if ((u==(i64)4) || (u==(i64)5) || (u==(i64)9) || (u==(i64)10)) {
                (*x).value |= (*y).value;
                goto L628 ;
            };
        };
        x = cc_lib_createunit2((i64)46,x,y);
        (*x).mode = u;
L628 :;
    }L629 :;
    ;
    return x;
}

static struct cc_decls_unitrec * cc_parse_readixorexpr(void) {
    struct cc_decls_unitrec *  x;
    struct cc_decls_unitrec *  y;
    i64 u;
    x = cc_parse_readiandexpr();
    L630 :;
    while (((i64)((u64)(cc_decls_lx.symbol)) == (i64)30)) {
        cc_lex_lex();
        y = cc_parse_readiandexpr();
        if (!!((u = (i64)(cc_tables_dominantmode[(cc_decls_ttbasetype[((i64)((*x).mode))])][(cc_decls_ttbasetype[((i64)((*y).mode))])])))) {
            if ((u >= (i64)11)) {
                cc_support_terror((byte*)"float^float");
            };
            x = cc_parse_coercemode(x,u);
            y = cc_parse_coercemode(y,u);
        } else {
            cc_support_terror((byte*)"invalid ^ operands");
        };
        if ((((i64)((*x).tag) == (i64)1) && ((i64)((*y).tag) == (i64)1))) {
            if ((u==(i64)4) || (u==(i64)5) || (u==(i64)9) || (u==(i64)10)) {
                (*x).value ^= (*y).value;
                goto L631 ;
            };
        };
        x = cc_lib_createunit2((i64)47,x,y);
        (*x).mode = u;
L631 :;
    }L632 :;
    ;
    return x;
}

static struct cc_decls_unitrec * cc_parse_readiandexpr(void) {
    struct cc_decls_unitrec *  x;
    struct cc_decls_unitrec *  y;
    i64 u;
    x = cc_parse_readeqexpr();
    L633 :;
    while (((i64)((u64)(cc_decls_lx.symbol)) == (i64)29)) {
        cc_lex_lex();
        y = cc_parse_readeqexpr();
        if (!!((u = (i64)(cc_tables_dominantmode[(cc_decls_ttbasetype[((i64)((*x).mode))])][(cc_decls_ttbasetype[((i64)((*y).mode))])])))) {
            if ((u >= (i64)11)) {
                cc_support_terror((byte*)"float&float");
            };
            x = cc_parse_coercemode(x,u);
            y = cc_parse_coercemode(y,u);
        } else {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(cc_lib_strmode((i64)((*x).mode),(i64)1),NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(cc_lib_strmode((i64)((*y).mode),(i64)1),NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            cc_support_terror((byte*)"invalid & operands");
        };
        if ((((i64)((*x).tag) == (i64)1) && ((i64)((*y).tag) == (i64)1))) {
            if ((u==(i64)4) || (u==(i64)5) || (u==(i64)9) || (u==(i64)10)) {
                (*x).value &= (*y).value;
                goto L634 ;
            };
        };
        x = cc_lib_createunit2((i64)45,x,y);
        (*x).mode = u;
L634 :;
    }L635 :;
    ;
    return x;
}

static struct cc_decls_unitrec * cc_parse_readeqexpr(void) {
    struct cc_decls_unitrec *  x;
    struct cc_decls_unitrec *  y;
    i64 opc;
    i64 s;
    i64 t;
    i64 u;
    i64 ss;
    i64 tt;
    x = cc_parse_readrelexpr();
    L636 :;
    while ((((opc = (i64)(cc_decls_lx.symbol)) == (i64)40) || (opc == (i64)41))) {
        cc_lex_lex();
        y = cc_parse_readrelexpr();
        if (!!((u = (i64)(cc_tables_dominantmode[((s = cc_decls_ttbasetype[((i64)((*x).mode))]))][((t = cc_decls_ttbasetype[((i64)((*y).mode))]))])))) {
            x = cc_parse_coercemode(x,u);
            y = cc_parse_coercemode(y,u);
        } else if (((s == (i64)16) && (t == (i64)16))) {
            if (((ss = cc_decls_tttarget[((i64)((*x).mode))]) != (tt = cc_decls_tttarget[((i64)((*y).mode))]))) {
                if (((ss != (i64)1) && (tt != (i64)1))) {
                    if (!(!!(cc_parse_checkpointertypes((i64)((*x).mode),(i64)((*y).mode),(i64)1)))) {
                        cc_support_terror((byte*)"Comparing distinct pointers/eq");
                    };
                };
            };
        } else if (((s == (i64)16) && (t == (i64)4))) {
            if ((((i64)((*y).tag) != (i64)1) || ((*y).value != (i64)0))) {
                cc_support_terror((byte*)"Can't compare pointer to int");
            };
        } else if (((s == (i64)4) && (t == (i64)16))) {
            if ((((i64)((*x).tag) != (i64)1) || ((*x).value != (i64)0))) {
                cc_support_terror((byte*)"Can't compare pointer to int2");
            };
        } else {
            cc_support_terror((byte*)"invalid == operands");
        };
        if ((((i64)((*x).tag) == (i64)1) && ((i64)((*y).tag) == (i64)1))) {
            if ((u==(i64)4) || (u==(i64)5) || (u==(i64)9) || (u==(i64)10) || (u==(i64)0)) {
                if ((opc == (i64)40)) {
                    (*x).value = ((*x).value == (*y).value);
                } else {
                    (*x).value = ((*x).value != (*y).value);
                };
                goto L637 ;
            };
        };
        x = cc_lib_createunit2((i64)(cc_tables_symboltojtag[(opc)-1]),x,y);
        (*x).mode = (i64)4;
L637 :;
    }L638 :;
    ;
    return x;
}

static struct cc_decls_unitrec * cc_parse_readrelexpr(void) {
    struct cc_decls_unitrec *  x;
    struct cc_decls_unitrec *  y;
    i64 opc;
    i64 s;
    i64 t;
    i64 u;
    i64 a;
    i64 b;
    i64 c;
    u64 aa;
    u64 bb;
    u64 cc;
    x = cc_parse_readshiftexpr();
    L639 :;
    while ((((((opc = (i64)(cc_decls_lx.symbol)) == (i64)42) || (opc == (i64)43)) || (opc == (i64)44)) || (opc == (i64)45))) {
        cc_lex_lex();
        y = cc_parse_readshiftexpr();
        if (!!((u = (i64)(cc_tables_dominantmode[((s = cc_decls_ttbasetype[((i64)((*x).mode))]))][((t = cc_decls_ttbasetype[((i64)((*y).mode))]))])))) {
            x = cc_parse_coercemode(x,u);
            y = cc_parse_coercemode(y,u);
        } else if (((s == (i64)16) && (t == (i64)16))) {
            if (!(!!(cc_parse_checkpointertypes((i64)((*x).mode),(i64)((*y).mode),(i64)1)))) {
                cc_support_terror((byte*)"Comparing distinct pointers/rel");
            };
        } else {
            cc_support_terror((byte*)"invalid rel operands");
        };
        if ((((i64)((*x).tag) == (i64)1) && ((i64)((*y).tag) == (i64)1))) {
            a = (*x).value;
            b = (*y).value;
            if ((u==(i64)4) || (u==(i64)5)) {
                if ((opc==(i64)42)) {
                    c = (a < b);
                }else if ((opc==(i64)43)) {
                    c = (a <= b);
                }else if ((opc==(i64)44)) {
                    c = (a >= b);
                } else {
                    c = (a > b);
                };
                (*x).value = c;
                goto L640 ;
            }else if ((u==(i64)9) || (u==(i64)10)) {
                aa = (u64)((*x).value);
                bb = (u64)((*y).value);
                if ((opc==(i64)42)) {
                    cc = (u64)((aa < bb));
                }else if ((opc==(i64)43)) {
                    cc = (u64)((aa <= bb));
                }else if ((opc==(i64)44)) {
                    cc = (u64)((aa >= bb));
                } else {
                    cc = (u64)((aa > bb));
                };
                (*x).value = (i64)(cc);
                goto L640 ;
            };
        };
        x = cc_lib_createunit2((i64)(cc_tables_symboltojtag[(opc)-1]),x,y);
        (*x).mode = (i64)4;
L640 :;
    }L641 :;
    ;
    return x;
}

static struct cc_decls_unitrec * cc_parse_readshiftexpr(void) {
    struct cc_decls_unitrec *  x;
    struct cc_decls_unitrec *  y;
    i64 opc;
    i64 u;
    x = cc_parse_readaddexpr();
    L642 :;
    while ((((opc = (i64)(cc_decls_lx.symbol)) == (i64)33) || (opc == (i64)34))) {
        cc_lex_lex();
        y = cc_parse_readaddexpr();
        cc_parse_coercebasetype(x);
        if (!((((u = cc_decls_ttbasetype[((i64)((*x).mode))]) >= (i64)2) && (u <= (i64)10)))) {
            cc_support_terror((byte*)"shift:Not an int");
        };
        y = cc_parse_coercemode(y,(i64)4);
        if ((((i64)((*x).tag) == (i64)1) && ((i64)((*y).tag) == (i64)1))) {
            if ((u==(i64)4) || (u==(i64)5)) {
                if ((opc == (i64)33)) {
                    (*x).value = ((*x).value << (*y).value);
                } else {
                    (*x).value = ((*x).value >> (*y).value);
                };
                goto L643 ;
            }else if ((u==(i64)9) || (u==(i64)10)) {
                if ((opc == (i64)33)) {
                    (*x).uvalue = ((*x).uvalue << (*y).value);
                } else {
                    (*x).uvalue = ((*x).uvalue >> (*y).value);
                };
                goto L643 ;
            };
        };
        x = cc_lib_createunit2(((opc == (i64)33)?(i64)48:(i64)49),x,y);
        (*x).mode = u;
L643 :;
    }L644 :;
    ;
    return x;
}

static struct cc_decls_unitrec * cc_parse_readaddexpr(void) {
    struct cc_decls_unitrec *  p;
    struct cc_decls_unitrec *  q;
    i64 opc;
    p = cc_parse_readmulexpr();
    L645 :;
    while ((((opc = (i64)(cc_decls_lx.symbol)) == (i64)23) || (opc == (i64)24))) {
        cc_lex_lex();
        q = cc_parse_readmulexpr();
        if ((opc == (i64)23)) {
            p = cc_parse_createaddop(p,q);
        } else {
            p = cc_parse_createsubop(p,q);
        };
L646 :;
    }L647 :;
    ;
    return p;
}

static struct cc_decls_unitrec * cc_parse_readmulexpr(void) {
    struct cc_decls_unitrec *  p;
    struct cc_decls_unitrec *  q;
    i64 opc;
    p = cc_parse_readterm();
    L648 :;
    while (((((opc = (i64)(cc_decls_lx.symbol)) == (i64)25) || (opc == (i64)26)) || (opc == (i64)27))) {
        cc_lex_lex();
        q = cc_parse_readterm();
        if ((opc==(i64)25)) {
            p = cc_parse_createmulop(p,q);
        }else if ((opc==(i64)26)) {
            p = cc_parse_createdivop(p,q);
        }else if ((opc==(i64)27)) {
            p = cc_parse_createremop(p,q);
        };
L649 :;
    }L650 :;
    ;
    return p;
}

static struct cc_decls_unitrec * cc_parse_readterm(void) {
    struct cc_decls_unitrec *  p;
    struct cc_decls_unitrec *  q;
    i64 t;
    i64 opc;
    i64 shift;
    i64 newlen;
    i64 slength;
    i64 fwide;
    byte *  pbyte;
    i64 a;
    struct cc_decls_strec *  d;
    byte *  ss;
    byte *  s;
    struct cc_decls_paramrec *  pm;
    i64 av_1;
    switch ((i64)(cc_decls_lx.symbol)) {
    case 60:;
    case 61:;
    {
        p = cc_lib_createconstunit((u64)(cc_decls_lx.value),(i64)(cc_decls_lx.subcode));
        cc_lex_lex();
    }break;
    case 69:;
    {
        if (((i64)((u64)((*cc_decls_lx.symptr).nameid)) <= (i64)1)) {
            d = cc_lib_resolvename((!!(cc_decls_currproc)?cc_decls_currproc:cc_decls_stmodule),cc_decls_lx.symptr,(i64)1,cc_decls_currblockno);
            if ((d == 0)) {
                cc_support_serror_s((byte*)"Undefined name \"%s\"",cc_lib_getstname(cc_decls_lx.symptr));
            };
        } else {
            d = cc_decls_lx.symptr;
        };
        (*d).attribs.ax_used = (u64)((i64)1);
        if (((i64)((*d).nameid)==(i64)11)) {
            p = cc_lib_createconstunit((u64)((*d).index),(i64)4);
        }else if (((i64)((*d).nameid)==(i64)14)) {
            p = cc_lib_createconstunit((u64)((*(*d).code).value),(i64)((*d).mode));
        }else if (((i64)((*d).nameid)==(i64)6)) {
            if (((i64)((u64)(cc_decls_nextlx.symbol)) != (i64)13)) {
                p = cc_lib_createunit0((i64)5);
                (*p).def = d;
                (*p).mode = cc_lib_createrefmode(cc_lib_createprocmode((i64)((*d).mode),(*d).paramlist));
            } else {
                goto L651 ;
;
            };
        } else {
            //doname:
L651 :;
;
            p = cc_lib_createname(d);
            (*p).mode = (t = (i64)((*d).mode));
            if ((cc_decls_ttbasetype[(t)] == (i64)19)) {
                if (!(!!(cc_parse_intypeof))) {
                    (*p).alength = cc_decls_ttlength[(t)];
                    p = cc_parse_createaddrofop(p);
                    (*p).mode = cc_lib_createrefmode(cc_decls_tttarget[(t)]);
                };
            } else if (((((i64)((u64)((*d).nameid)) != (i64)6) && ((i64)((u64)((*d).nameid)) != (i64)14)) && (cc_decls_ttsize[(t)] < (i64)4))) {
                cc_parse_fixmemopnd(p);
            } else if (((i64)((u64)((*d).nameid)) == (i64)9)) {
                if (!!(cc_lib_isstructunion((i64)((*p).mode)))) {
                    (*p).lineno = (u64)(cc_decls_lx.lineno);
                    (*p).mode = cc_lib_createrefmode((i64)((*p).mode));
                    p = cc_parse_createptrop(p);
                    (*p).mode = (i64)((*d).mode);
                };
            };
        };
        (*p).lineno = (u64)(cc_decls_lx.lineno);
        cc_lex_lex();
    }break;
    case 64:;
    case 65:;
    {
        fwide = ((i64)((u64)(cc_decls_lx.symbol)) == (i64)65);
        s = cc_decls_lx.svalue;
        slength = (i64)(cc_decls_lx.length);
        L652 :;
        while (((i64)((u64)(cc_decls_nextlx.symbol)) == (i64)64)) {
            newlen = (slength + (i64)(cc_decls_nextlx.length));
            ss = (byte *)(mlib_pcm_alloc((newlen + (i64)1)));
            memcpy((void *)(ss),(void *)(s),(u64)(slength));
            memcpy((void *)((ss + slength)),(void *)(cc_decls_nextlx.svalue),(u64)(cc_decls_nextlx.length));
            (*(ss + newlen)) = (u64)0u;
            s = ss;
            slength = newlen;
            cc_lex_lex();
L653 :;
        }L654 :;
        ;
        if (!!(fwide)) {
            p = cc_lib_createwstringconstunit((u16 *)(s),slength);
            (*p).wslength = slength;
            (*p).mode = cc_decls_trefwchar;
        } else {
            p = cc_lib_createstringconstunit(s,slength);
            (*p).slength = slength;
            (*p).mode = cc_decls_trefchar;
        };
        cc_lex_lex();
    }break;
    case 68:;
    {
        p = cc_parse_readstrinclude();
    }break;
    case 62:;
    {
        a = (i64)0;
        shift = (i64)0;
        pbyte = cc_decls_lx.svalue;
        if (((i64)(cc_decls_lx.length) > (i64)8)) {
            cc_support_serror((byte*)"char const too long");
        };
        if (((i64)(cc_decls_lx.length) > (i64)1)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((byte*)"MULTICHAR CONST:",NULL);
            msysnewc_m_print_str(cc_decls_lx.svalue,NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
        };
        av_1 = (i64)(cc_decls_lx.length);
        while (av_1-- > 0) {
L655 :;
            a = (a | (i64)(((u64)((*pbyte)) << shift)));
            shift += (i64)8;
            ++pbyte;
L656 :;
        }L657 :;
        ;
        p = cc_lib_createconstunit((u64)(a),(((i64)(cc_decls_lx.length) <= (i64)4)?(i64)4:(i64)5));
        cc_lex_lex();
    }break;
    case 23:;
    {
        cc_lex_lex();
        p = cc_parse_readterm();
    }break;
    case 24:;
    {
        cc_lex_lex();
        p = cc_parse_createnegop(cc_parse_readterm());
    }break;
    case 36:;
    {
        cc_lex_lex();
        p = cc_parse_readterm();
        cc_parse_coercecond(p);
        p = cc_lib_createunit1((i64)27,p);
        (*p).mode = (i64)4;
        if ((((i64)((*(*p).a).tag) == (i64)27) && ((i64)((*(*(*p).a).a).tag) == (i64)27))) {
            (*p).a = (*(*(*p).a).a).a;
        };
    }break;
    case 35:;
    {
        cc_lex_lex();
        p = cc_parse_createinotop(cc_parse_readterm());
    }break;
    case 29:;
    {
        cc_lex_lex();
        if (((i64)((u64)(cc_decls_lx.symbol)) == (i64)25)) {
            cc_lex_lex();
            p = cc_parse_readterm();
        } else {
            p = cc_parse_createaddrofop(cc_parse_readterm());
        };
    }break;
    case 32:;
    {
        cc_support_serror((byte*)"rt/&&label");
    }break;
    case 25:;
    {
        cc_lex_lex();
        p = cc_parse_createptrop(cc_parse_readterm());
    }break;
    case 37:;
    case 38:;
    {
        opc = (i64)(cc_tables_symboltojtag[((i64)(cc_decls_lx.symbol))-1]);
        cc_lex_lex();
        p = cc_parse_createincrop(opc,cc_parse_readterm());
    }break;
    case 39:;
    {
        cc_lex_lex();
        cc_lib_skipsymbol((i64)13);
        p = cc_parse_createabsop(cc_parse_readexpression());
        cc_lib_skipsymbol((i64)14);
    }break;
    case 56:;
    {
        cc_lex_lex();
        cc_lib_skipsymbol((i64)13);
        p = cc_parse_createsqrtop(cc_parse_readexpression());
        cc_lib_skipsymbol((i64)14);
    }break;
    case 13:;
    {
        cc_lex_lex();
        if (!!(cc_parse_istypestarter())) {
            t = cc_parse_readcasttype(&d,(i64)0,&pm);
            cc_lib_skipsymbol((i64)14);
            if (((i64)((u64)(cc_decls_lx.symbol)) == (i64)17)) {
                cc_support_serror((byte*)"rt/compound lit");
            } else {
                p = cc_parse_docast(cc_parse_readterm(),t,(i64)1,(i64)0);
            };
        } else {
            p = cc_parse_readexpression();
            cc_lib_skipsymbol((i64)14);
        };
    }break;
    case 92:;
    {
        cc_lex_lex();
        if (((i64)((u64)(cc_decls_lx.symbol)) == (i64)13)) {
            cc_lex_lex();
            if (!!(cc_parse_istypestarter())) {
                t = cc_parse_readcasttype(&d,(i64)0,&pm);
                cc_lib_skipsymbol((i64)14);
                p = cc_lib_createconstunit((u64)(cc_decls_ttsize[(t)]),(i64)10);
            } else {
                p = cc_parse_readexpression();
                cc_lib_skipsymbol((i64)14);
                p = cc_parse_createsizeofop(p);
            };
        } else {
            p = cc_parse_createsizeofop(cc_parse_readterm());
        };
    }break;
    case 93:;
    {
        cc_lex_lex();
        if (((i64)((u64)(cc_decls_lx.symbol)) == (i64)13)) {
            cc_lex_lex();
            if (!!(cc_parse_istypestarter())) {
                t = cc_parse_readcasttype(&d,(i64)0,&pm);
                cc_lib_skipsymbol((i64)14);
                p = cc_lib_createconstunit((u64)(cc_decls_ttlength[(t)]),(i64)4);
            } else {
                p = cc_parse_readexpression();
                cc_lib_skipsymbol((i64)14);
                p = cc_parse_createlengthofop(p);
            };
        } else {
            p = cc_parse_createlengthofop(cc_parse_readterm());
        };
    }break;
    case 95:;
    {
        p = cc_parse_readgeneric();
    }break;
    case 96:;
    {
        cc_support_serror((byte*)"rt/alignof");
    }break;
    case 100:;
    {
        cc_lex_lex();
        cc_lib_skipsymbol((i64)13);
        t = cc_parse_readcasttype(&d,(i64)0,&pm);
        cc_lib_skipsymbol((i64)14);
        p = cc_lib_createstringconstunit(mlib_pcm_copyheapstring(cc_lib_strmode(t,(i64)1)),(i64)-1);
    }break;
    case 102:;
    {
        p = cc_lib_createunit0((i64)77);
        (*p).mode = (i64)5;
        cc_lex_lex();
    }break;
    default: {
        cc_lex_ps((byte*)"RT");
        cc_support_serror((byte*)"Readterm?");
    }
    } //SW
;
    L658 :;
    switch ((i64)(cc_decls_lx.symbol)) {
    case 15:;
    {
        cc_lex_lex();
        q = cc_parse_readexpression();
        cc_lib_skipsymbol((i64)16);
        p = cc_parse_createindexop(p,q);
    }break;
    case 2:;
    case 3:;
    {
        opc = (i64)(cc_tables_symboltojtag[((i64)(cc_decls_lx.symbol))-1]);
        cc_lex_lex();
        cc_lib_checksymbol((i64)69);
        d = cc_decls_lx.symptr;
        cc_lex_lex();
        p = cc_parse_createdotop(opc,p,d);
    }break;
    case 13:;
    {
        cc_lex_lex();
        if (((i64)((u64)(cc_decls_lx.symbol)) == (i64)14)) {
            q = (struct cc_decls_unitrec *)(0);
            cc_lex_lex();
        } else {
            q = cc_parse_readexprlist((struct cc_decls_unitrec *)(0));
            cc_lib_skipsymbol((i64)14);
        };
        p = cc_parse_createcall(p,q);
    }break;
    case 37:;
    {
        cc_lex_lex();
        p = cc_parse_createincrop((i64)75,p);
    }break;
    case 38:;
    {
        cc_lex_lex();
        p = cc_parse_createincrop((i64)76,p);
    }break;
    default: {
        goto L659 ;
    }
    } //SW
goto L658 ;
L659 :;
    ;
    return p;
}

static struct cc_decls_unitrec * cc_parse_readexprlist(struct cc_decls_unitrec * p) {
    struct cc_decls_unitrec *  ulist;
    struct cc_decls_unitrec *  ulistx;
    ulist = (ulistx = p);
    L660 :;
    while (1) {
        p = cc_parse_readassignexpr();
        cc_lib_addlistunit(&ulist,&ulistx,p);
        if (((i64)((u64)(cc_decls_lx.symbol)) != (i64)8)) {
            goto L661 ;
        };
        cc_lex_lex();
    }L661 :;
    ;
    return ulist;
}

static struct cc_decls_strec * cc_parse_readmodulevar(struct cc_decls_strec * d,i64 m,i64 linkage) {
    struct cc_decls_strec *  e;
    i64 scope;
    i64 emode;
    e = cc_lib_checkdupl(cc_decls_stmodule,d,(i64)1,(i64)0);
    if (!!(e)) {
        if (((i64)((u64)((*e).nameid)) != (i64)7)) {
            cc_support_serror_ss((byte*)"var: name in use %s %s",(*e).name,cc_tables_namenames[((i64)((*e).nameid))]);
        };
        emode = (i64)((*e).mode);
        if ((emode != m)) {
            if (!(!!(cc_parse_comparemode(emode,m)))) {
                //redef:
L662 :;
;
                cc_support_serror_s((byte*)"var: redefining %s",(*e).name);
            };
            if ((cc_decls_ttbasetype[(emode)]==(i64)19)) {
                if ((cc_decls_ttlength[(emode)] == (i64)0)) {
                    (*e).mode = m;
                } else if ((!!(cc_decls_ttlength[(m)]) && (cc_decls_ttlength[(emode)] != cc_decls_ttlength[(m)]))) {
                    goto L662 ;
;
                };
            };
        };
        d = e;
        scope = (i64)((*d).scope);
        if (((((scope == (i64)2) && (linkage == (i64)0)) || ((scope == (i64)4) && (linkage == (i64)1))) || ((scope == (i64)3) && (linkage == (i64)1)))) {
        } else if (((scope == (i64)3) && (linkage == (i64)0))) {
            scope = (i64)4;
        };
    } else {
        d = cc_lib_createdupldef(cc_decls_stmodule,d,(!!((u64)(cc_parse_constantseen))?(i64)14:(i64)7));
        (*d).mode = m;
        if ((linkage==(i64)1)) {
            scope = (i64)2;
        }else if ((linkage==(i64)4)) {
            scope = (i64)3;
        } else {
            scope = (i64)4;
        };
    };
    if (((i64)((u64)(cc_decls_lx.symbol)) == (i64)11)) {
        if (!!((*d).code)) {
            cc_support_serror_s((byte*)"Can't init twice %s",(*d).name);
        };
        if ((scope == (i64)3)) {
            cc_support_serror_s((byte*)"Can't init extern %s",(*d).name);
        };
        cc_lex_lex();
        (*d).code = cc_parse_readinitexpr(cc_decls_stmodule,(i64)((*d).mode));
        if (((i64)((u64)((*d).nameid)) == (i64)14)) {
            if (!((((i64)2 <= cc_decls_ttbasetype[((i64)((*d).mode))]) && (cc_decls_ttbasetype[((i64)((*d).mode))] <= (i64)13)))) {
                cc_support_serror((byte*)"constant only for int/float");
            };
            if (((i64)((*(*d).code).tag) != (i64)1)) {
                cc_support_serror((byte*)"constant expr must be constant");
            };
        };
    } else if (!!((u64)(cc_parse_constantseen))) {
        cc_support_serror((byte*)"constant must be initialised");
    };
    (*d).scope = (u64)(scope);
    return d;
}

static struct cc_decls_strec * cc_parse_readframevar(struct cc_decls_strec * d,i64 m,i64 linkage) {
    struct cc_decls_strec *  e;
    i64 scope;
    i64 id;
    e = cc_lib_checkdupl_inproc(cc_decls_currproc,d,(i64)1,cc_decls_currblockno);
    if (!!(e)) {
        cc_support_serror_s((byte*)"var: name in use %s",(*e).name);
        d = e;
        scope = (i64)((*d).scope);
        if (((((scope == (i64)2) && (linkage == (i64)0)) || ((scope == (i64)4) && (linkage == (i64)1))) || ((scope == (i64)3) && (linkage == (i64)1)))) {
        } else if (((scope == (i64)3) && (linkage == (i64)0))) {
            scope = (i64)4;
        };
    } else {
        id = (i64)8;
        scope = (i64)1;
        if ((linkage==(i64)1)) {
            id = (i64)7;
        }else if ((linkage==(i64)4)) {
            scope = (i64)3;
            id = (i64)7;
        };
        d = cc_lib_createdupldef(cc_decls_currproc,d,id);
        (*d).mode = m;
        (*d).blockno = (u64)(cc_decls_currblockno);
        cc_decls_blockcounts[(cc_decls_currblockno)] = (i64)1;
    };
    if (((i64)((u64)(cc_decls_lx.symbol)) == (i64)11)) {
        if (!!((*d).code)) {
            cc_support_serror_s((byte*)"Can't init twice %s",(*d).name);
        };
        if ((scope == (i64)3)) {
            cc_support_serror_s((byte*)"Can't init extern %s",(*d).name);
        };
        cc_lex_lex();
        (*d).code = cc_parse_readinitexpr(cc_decls_currproc,(i64)((*d).mode));
    };
    (*d).scope = (u64)(scope);
    return d;
}

static i64 cc_parse_readtype(struct cc_decls_strec * owner,struct cc_decls_strec * * d,i64 m,struct cc_decls_paramrec * * pm) {
    i64 modtype[20];
    void *  modvalue[20];
    i64 nmodifiers;
    i64 i;
    nmodifiers = (i64)0;
    (*pm) = (struct cc_decls_paramrec *)(0);
    cc_parse_readnamedtype(owner,d,&modtype,&modvalue,&nmodifiers);
    L663 :;
    for (i=nmodifiers;i>=(i64)1;i-=(i64)1) {
L664 :;
        if ((modtype[(i)-1]==(i64)65)) {
            m = cc_lib_createarraymode(m,(i64)(modvalue[(i)-1]));
        }else if ((modtype[(i)-1]==(i64)82)) {
            m = cc_lib_createrefmode(m);
        }else if ((modtype[(i)-1]==(i64)67)) {
            m = cc_lib_createconstmode(m);
        }else if ((modtype[(i)-1]==(i64)70)) {
            if ((i == (i64)1)) {
                (*pm) = (struct cc_decls_paramrec *)(modvalue[((i64)1)-1]);
            } else {
                m = cc_lib_createprocmode(m,(struct cc_decls_paramrec *)(modvalue[(i)-1]));
            };
        };
L665 :;
    }L666 :;
    ;
    return m;
}

static void cc_parse_readnamedtype(struct cc_decls_strec * owner,struct cc_decls_strec * * d,i64 (*modtype)[],void * (*modvalue)[],i64 * nmodifiers) {
    i64 length;
    i64 fconst[20];
    i64 nrefs;
    struct cc_decls_unitrec *  pdim;
    (*d) = (struct cc_decls_strec *)(0);
    nrefs = (i64)0;
    if (((i64)((u64)(cc_decls_lx.symbol)) == (i64)89)) {
        cc_lex_lex();
    };
    L667 :;
    while (((i64)((u64)(cc_decls_lx.symbol)) == (i64)25)) {
        ++nrefs;
        fconst[(nrefs)-1] = (i64)0;
        cc_lex_lex();
        L670 :;
        while (((i64)((u64)(cc_decls_lx.symbol)) == (i64)88)) {
            if (((i64)(cc_decls_lx.subcode)==(i64)1)) {
                fconst[(nrefs)-1] = (i64)1;
            }else if (((i64)(cc_decls_lx.subcode)==(i64)2) || ((i64)(cc_decls_lx.subcode)==(i64)3)) {
            } else {
                cc_support_serror((byte*)"rnt1");
            };
            cc_lex_lex();
L671 :;
        }L672 :;
        ;
L668 :;
    }L669 :;
    ;
    if (((i64)(cc_decls_lx.symbol)==(i64)69)) {
        (*d) = cc_decls_lx.symptr;
        cc_lex_lex();
    }else if (((i64)(cc_decls_lx.symbol)==(i64)13)) {
        cc_lex_lex();
        cc_parse_readnamedtype(owner,d,modtype,modvalue,nmodifiers);
        cc_lib_skipsymbol((i64)14);
    };
    L673 :;
    if (((i64)(cc_decls_lx.symbol)==(i64)15)) {
        cc_lex_lex();
        if (((i64)((u64)(cc_decls_lx.symbol)) == (i64)16)) {
            length = (i64)0;
        } else {
            pdim = cc_parse_readassignexpr();
            if (((i64)((*pdim).tag) == (i64)1)) {
                length = (*pdim).value;
            } else {
                cc_support_serror((byte*)"Can't do VLAs");
            };
            cc_lib_checksymbol((i64)16);
        };
        if ((length < (i64)0)) {
            cc_support_terror((byte*)"Negative array dim");
        };
        cc_lex_lex();
        (*modtype)[(++(*nmodifiers))-1] = (i64)65;
        (*modvalue)[((*nmodifiers))-1] = (void *)(length);
    }else if (((i64)(cc_decls_lx.symbol)==(i64)13)) {
        cc_lex_lex();
        (*modtype)[(++(*nmodifiers))-1] = (i64)70;
        (*modvalue)[((*nmodifiers))-1] = (void *)(cc_parse_readparams(owner));
    } else {
        goto L674 ;
    }goto L673 ;
L674 :;
    ;
    L675 :;
    while (!!(nrefs)) {
        if (!!(fconst[(nrefs)-1])) {
            (*modtype)[(++(*nmodifiers))-1] = (i64)67;
        };
        (*modtype)[(++(*nmodifiers))-1] = (i64)82;
        --nrefs;
L676 :;
    }L677 :;
    ;
}

static i64 cc_parse_readconstintexpr(void) {
    struct cc_decls_unitrec *  p;
    p = cc_parse_readassignexpr();
    if (((i64)((*p).tag)==(i64)1)) {
        return (*p).value;
    } else {
        cc_support_serror_s((byte*)"readconstint %s",cc_tables_jtagnames[((i64)((*p).tag))]);
    };
    return (i64)0;
}

static struct cc_decls_unitrec * cc_parse_readinitexpr(struct cc_decls_strec * owner,i64 m) {
    struct cc_decls_unitrec *  p;
    p = cc_parse_readinitexpr2(owner,m,(i64)1);
    return p;
}

static struct cc_decls_unitrec * cc_parse_readinitexpr2(struct cc_decls_strec * owner,i64 m,i64 istop) {
    struct cc_decls_unitrec *  ulist;
    struct cc_decls_unitrec *  ulistx;
    struct cc_decls_unitrec *  p;
    i64 mbase;
    i64 melem;
    i64 mm;
    i64 dim;
    i64 count;
    struct cc_decls_strec *  d;
    struct cc_decls_strec *  e;
    i64 braces;
    mbase = cc_decls_ttbasetype[(m)];
    count = (i64)0;
    if (((i64)((u64)(cc_decls_lx.symbol)) == (i64)17)) {
        cc_lex_lex();
        count = (i64)0;
        if ((mbase==(i64)19)) {
            dim = cc_decls_ttlength[(m)];
            if ((!(!!(istop)) && (dim == (i64)0))) {
                cc_support_terror((byte*)"init/0-size array");
            };
            melem = cc_decls_tttarget[(m)];
            if (((cc_decls_ttbasetype[(melem)] == (i64)7) && ((i64)((u64)(cc_decls_lx.symbol)) == (i64)64))) {
                braces = (i64)1;
                goto L678 ;
;
            };
        }else if ((mbase==(i64)20) || (mbase==(i64)21)) {
            d = cc_decls_ttnamedef[(m)];
            e = (*d).deflist;
            if ((e == 0)) {
                cc_support_terror((byte*)"init/Empty struct");
            };
            melem = (i64)((*e).mode);
        } else {
            p = cc_parse_readassignexpr();
            p = cc_parse_coercemode(p,m);
            cc_lib_skipsymbol((i64)18);
            return p;
        };
        ulist = (ulistx = (struct cc_decls_unitrec *)(0));
        L679 :;
        while (1) {
            p = cc_parse_readinitexpr2(owner,melem,(i64)0);
            ++count;
            if ((mbase==(i64)19)) {
                if ((!!(dim) && (count > dim))) {
                    cc_support_terror((byte*)"Too many array elems");
                };
                if ((((cc_decls_ttbasetype[(melem)] == (i64)19) && (cc_decls_ttbasetype[(cc_decls_tttarget[(melem)])] == (i64)7)) && ((i64)((*p).mode) == cc_decls_trefchar))) {
                } else {
                    p = cc_parse_coercemode(p,melem);
                };
            }else if ((mbase==(i64)20)) {
                mm = (i64)((*e).mode);
                if ((((cc_decls_ttbasetype[(mm)] == (i64)19) && (cc_decls_ttbasetype[(cc_decls_tttarget[(mm)])] == (i64)7)) && ((i64)((*p).mode) == cc_decls_trefchar))) {
                } else {
                    p = cc_parse_coercemode(p,mm);
                };
                e = (*e).nextdef;
                if ((e == 0)) {
                    if ((((i64)((u64)(cc_decls_lx.symbol)) == (i64)8) && ((i64)((u64)(cc_decls_nextlx.symbol)) != (i64)18))) {
                        cc_support_terror((byte*)"Too many struct elems");
                    };
                } else {
                    melem = (i64)((*e).mode);
                };
            }else if ((mbase==(i64)21)) {
                p = cc_parse_coercemode(p,melem);
                ulist = (ulistx = p);
                goto L681 ;
;
            };
            cc_lib_addlistunit(&ulist,&ulistx,p);
            if (((i64)((u64)(cc_decls_lx.symbol)) != (i64)8)) {
                goto L680 ;
            };
            if (((i64)((u64)(cc_decls_nextlx.symbol)) == (i64)18)) {
                cc_lex_lex();
                goto L680 ;
            };
            cc_lex_lex();
        }L680 :;
        ;
        if (((mbase == (i64)19) && (dim == (i64)0))) {
            cc_decls_ttlength[(m)] = count;
            cc_decls_ttsize[(m)] = (count * cc_decls_ttsize[(melem)]);
        };
        //donestruct:
L681 :;
;
        cc_lib_skipsymbol((i64)18);
        p = cc_lib_createunit1((i64)29,ulist);
        (*p).count = count;
        (*p).mode = m;
    } else {
        braces = (i64)0;
        if ((mbase==(i64)19)) {
            //doarraystring:
L678 :;
;
            if (((((i64)((u64)(cc_decls_lx.symbol)) != (i64)64) && ((i64)((u64)(cc_decls_lx.symbol)) != (i64)65)) && (cc_decls_tttarget[(m)] != (i64)7))) {
                cc_support_terror((byte*)"{} initialiser expected");
            };
            p = cc_parse_readassignexpr();
            if (((i64)((*p).tag) == (i64)1)) {
                (*p).strarray = (u64)((i64)1);
            };
            if (((i64)((*p).mode)==cc_decls_trefchar)) {
            }else if (((i64)((*p).mode)==cc_decls_trefwchar)) {
            } else {
                cc_support_terror((byte*)"Array init");
            };
            (*p).mode = m;
            if (((dim = cc_decls_ttlength[(m)]) == (i64)0)) {
                cc_decls_ttlength[(m)] = (cc_decls_ttsize[(m)] = ((i64)((*p).slength) + (i64)1));
            } else {
                if (((i64)((*p).slength) > dim)) {
                    cc_support_terror((byte*)"Init str too long");
                };
            };
            if (!!(braces)) {
                cc_lib_skipsymbol((i64)18);
            };
            return p;
        };
        p = cc_parse_readassignexpr();
        p = cc_parse_coercemode(p,m);
    };
    return p;
}

static void cc_parse_pushblock(void) {
    i64 n;
    i64 m;
    if ((cc_decls_blocklevel >= (i64)100)) {
        cc_support_serror((byte*)"Too many block levels");
    };
    if ((cc_decls_nextblockno >= (i64)2100)) {
        cc_support_serror((byte*)"Too many blocks");
    };
    ++cc_decls_blocklevel;
    ++cc_decls_nextblockno;
    n = cc_decls_currblockno;
    m = cc_decls_blocklevel;
    L682 :;
    while ((!!(m) && ((i64)(cc_decls_blockcounts[((i64)(cc_decls_blockstack[(m)]))]) == (i64)0))) {
        --m;
        n = (i64)(cc_decls_blockstack[(m)]);
L683 :;
    }L684 :;
    ;
    cc_decls_blockowner[(cc_decls_nextblockno)] = n;
    cc_decls_currblockno = (i64)((cc_decls_blockstack[(cc_decls_blocklevel)] = cc_decls_nextblockno));
    cc_decls_blockcounts[(cc_decls_currblockno)] = (i64)0;
}

static void cc_parse_popblock(void) {
    cc_decls_currblockno = (i64)(cc_decls_blockstack[(--cc_decls_blocklevel)]);
}

static struct cc_decls_unitrec * cc_parse_readcompoundstmt(i64 params) {
    struct cc_decls_unitrec *  ulist;
    struct cc_decls_unitrec *  ulistx;
    struct cc_decls_unitrec *  p;
    struct cc_decls_unitrec *  q;
    ulist = (ulistx = (struct cc_decls_unitrec *)(0));
    cc_lex_lex();
    cc_parse_pushblock();
    if (!!(params)) {
        cc_decls_blockcounts[((i64)1)] = (i64)1;
    };
    L685 :;
    while (((i64)((u64)(cc_decls_lx.symbol)) != (i64)18)) {
        p = cc_parse_readstatement();
        if ((p == 0)) {
            goto L686 ;
        };
        if (((i64)((*p).tag) == (i64)7)) {
            L688 :;
            do {
                q = (*p).nextunit;
                if ((!!((*(*p).def).code) && ((i64)((u64)((*(*p).def).nameid)) != (i64)7))) {
                    (*p).tag = (i64)8;
                    (*p).nextunit = (struct cc_decls_unitrec *)(0);
                    cc_lib_addlistunit(&ulist,&ulistx,p);
                };
                p = q;
L689 :;
            } while (!(p == 0));L690 :;
            ;
        } else {
            cc_lib_addlistunit(&ulist,&ulistx,p);
        };
L686 :;
    }L687 :;
    ;
    cc_lex_lex();
    cc_parse_popblock();
    return cc_lib_createunit3((i64)6,ulist,(struct cc_decls_unitrec *)(0),ulistx);
}

static struct cc_decls_unitrec * cc_parse_readblock(i64 ifelse) {
    if (!(!!((i64)0))) {
        return cc_parse_readstatement();
    };
    if ((((i64)((u64)(cc_decls_lx.symbol)) == (i64)73) && !!(ifelse))) {
        return cc_parse_readstatement();
    };
    if (((i64)((u64)(cc_decls_lx.symbol)) != (i64)17)) {
        cc_support_serror((byte*)"{...} statement expected");
    };
    return cc_parse_readcompoundstmt((i64)0);
}

static struct cc_decls_unitrec * cc_parse_readstatement(void) {
    struct cc_decls_unitrec *  p;
    struct mlib_strbuffer *  ss;
    struct cc_decls_strec *  d;
    i64 index;
    switch ((i64)(cc_decls_lx.symbol)) {
    case 73:;
    {
        return cc_parse_readifstmt();
    }break;
    case 77:;
    {
        return cc_parse_readforstmt();
    }break;
    case 78:;
    {
        return cc_parse_readwhilestmt();
    }break;
    case 79:;
    {
        return cc_parse_readdostmt();
    }break;
    case 80:;
    {
        return cc_parse_readreturnstmt();
    }break;
    case 84:;
    {
        return cc_parse_readswitchstmt();
    }break;
    case 17:;
    {
        return cc_parse_readcompoundstmt((i64)0);
    }break;
    case 83:;
    {
        return cc_parse_readgotostmt();
    }break;
    case 81:;
    {
        if (!!(cc_parse_loopindex)) {
            if (((u64)(cc_parse_looptypestack[(cc_parse_loopindex)-1]) == (u64)76u)) {
                p = cc_lib_createunit0((i64)21);
                cc_lex_lex();
            } else {
                p = cc_lib_createunit0((i64)24);
                cc_lex_lex();
            };
        } else {
            cc_support_serror((byte*)"break outside loop/sw");
        };
    }break;
    case 82:;
    {
        index = cc_parse_loopindex;
        L691 :;
        while ((!!(index) && ((u64)(cc_parse_looptypestack[(index)-1]) != (u64)76u))) {
            --index;
L692 :;
        }L693 :;
        ;
        if ((index == (i64)0)) {
            cc_support_serror((byte*)"continue outside loop");
        };
        p = cc_lib_createunit0((i64)22);
        cc_lex_lex();
    }break;
    case 75:;
    {
        return cc_parse_readcaselabel();
    }break;
    case 76:;
    {
        cc_lex_lex();
        cc_lib_skipsymbol((i64)10);
        return cc_lib_createunit1((i64)20,cc_parse_readstatement());
    }break;
    case 97:;
    {
        cc_lex_lex();
        p = cc_parse_readexpression();
        ss = cc_lib_strexpr(p);
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"Mode is:",NULL);
        msysnewc_m_print_str((*ss).strptr,NULL);
        msysnewc_m_print_str((byte*)":",NULL);
        msysnewc_m_print_str(cc_lib_strmode((i64)((*p).mode),(i64)1),NULL);
        msysnewc_m_print_str((byte*)"\ton line",NULL);
        msysnewc_m_print_u64(cc_decls_lx.lineno,NULL);
        msysnewc_m_print_str((byte*)"Size is",NULL);
        msysnewc_m_print_i64(cc_decls_ttsize[((i64)((*p).mode))],NULL);
        msysnewc_m_print_end();
        ;
        if (!!((u64)(cc_decls_ttisref[((i64)((*p).mode))]))) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((byte*)" target size",NULL);
            msysnewc_m_print_i64(cc_decls_ttsize[(cc_decls_tttarget[((i64)((*p).mode))])],NULL);
            msysnewc_m_print_end();
            ;
        };
        msysnewc_m_print_startcon();
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    }break;
    case 101:;
    {
        cc_parse_dostaticassert();
    }break;
    case 9:;
    {
        cc_lex_lex();
        return (struct cc_decls_unitrec *)(0);
    }break;
    case 69:;
    {
        if (((i64)((u64)(cc_decls_nextlx.symbol)) == (i64)10)) {
            p = cc_lib_createunit1((i64)18,(struct cc_decls_unitrec *)(0));
            d = cc_lib_resolvename(cc_decls_currproc,cc_decls_lx.symptr,(i64)3,(i64)0);
            if (!!(d)) {
                if (!!((i64)((*d).index))) {
                    msysnewc_m_print_startcon();
                    msysnewc_m_print_str((*cc_decls_lx.symptr).name,NULL);
                    msysnewc_m_print_newline();
                    msysnewc_m_print_end();
                    ;
                    cc_support_terror((byte*)"Duplicate label");
                } else {
                    (*d).index = ++cc_decls_labelno;
                };
            } else {
                d = cc_lib_createdupldef(cc_decls_currproc,cc_decls_lx.symptr,(i64)15);
                (*d).mode = (i64)1;
                (*d).index = ++cc_decls_labelno;
            };
            (*p).def = d;
            cc_lex_lex();
            cc_lex_lex();
            if (((i64)((u64)(cc_decls_lx.symbol)) == (i64)18)) {
            } else if ((!!(cc_parse_istypestarter()) || ((i64)((u64)(cc_decls_lx.symbol)) == (i64)87))) {
            } else {
                (*p).a = cc_parse_readstatement();
            };
            return p;
        } else {
            cc_parse_ist_symptr = (struct cc_decls_strec *)(0);
            if (!!(cc_parse_isusertype(cc_decls_currproc))) {
                goto L694 ;
;
            };
            if (!!(cc_parse_ist_symptr)) {
                cc_decls_lx.symptr = cc_parse_ist_symptr;
            };
            p = cc_parse_readexpression();
        };
    }break;
    case 72:;
    case 88:;
    case 87:;
    case 89:;
    case 85:;
    case 86:;
    case 91:;
    case 99:;
    {
        //doreaddecl:
L694 :;
;
        return cc_parse_readlocaldecl();
    }break;
    default: {
        p = cc_parse_readexpression();
    }
    } //SW
;
    cc_lib_skipsymbol((i64)9);
    return p;
}

static struct cc_decls_unitrec * cc_parse_readifstmt(void) {
    struct cc_decls_unitrec *  pcond;
    struct cc_decls_unitrec *  pbody;
    struct cc_decls_unitrec *  pelse;
    cc_lex_lex();
    pcond = cc_parse_readcond();
    cc_parse_coercecond(pcond);
    pbody = cc_parse_readblock((i64)0);
    pelse = (struct cc_decls_unitrec *)(0);
    if (((i64)((u64)(cc_decls_lx.symbol)) == (i64)74)) {
        cc_lex_lex();
        pelse = cc_parse_readblock((i64)1);
    };
    return cc_lib_createunit3((i64)13,pcond,pbody,pelse);
}

static struct cc_decls_unitrec * cc_parse_readforstmt(void) {
    struct cc_decls_unitrec *  pinit;
    struct cc_decls_unitrec *  pcond;
    struct cc_decls_unitrec *  pincr;
    struct cc_decls_unitrec *  pbody;
    struct cc_decls_unitrec *  ulist;
    struct cc_decls_unitrec *  ulistx;
    struct cc_decls_unitrec *  p;
    i64 linkage;
    i64 hasblock;
    i64 m;
    i64 mbase;
    struct cc_decls_paramrec *  pm;
    struct cc_decls_strec *  d;
    cc_lex_lex();
    cc_lib_skipsymbol((i64)13);
    hasblock = (i64)0;
    if (((i64)((u64)(cc_decls_lx.symbol)) != (i64)9)) {
        if (!!(cc_parse_istypestarter())) {
            hasblock = (i64)1;
            cc_parse_pushblock();
            mbase = cc_parse_readdeclspec(cc_decls_currproc,&linkage);
            ulist = (ulistx = (struct cc_decls_unitrec *)(0));
            L695 :;
            if (((i64)(cc_decls_lx.symbol)==(i64)69) || ((i64)(cc_decls_lx.symbol)==(i64)25) || ((i64)(cc_decls_lx.symbol)==(i64)13)) {
                m = cc_parse_readtype(cc_decls_currproc,&d,mbase,&pm);
                if ((d == 0)) {
                    cc_support_serror((byte*)"Var name expected");
                };
                if (((linkage == (i64)5) || !!(pm))) {
                    cc_support_serror((byte*)"Not allowed in for stmt");
                };
                cc_parse_insidefor = (i64)1;
                d = cc_parse_readframevar(d,m,linkage);
                cc_parse_insidefor = (i64)0;
                if (!!((*d).code)) {
                    p = cc_lib_createunit0((i64)8);
                    (*p).def = d;
                    cc_lib_addlistunit(&ulist,&ulistx,p);
                };
                if (((i64)(cc_decls_lx.symbol)==(i64)8)) {
                    cc_lex_lex();
                } else {
                    goto L696 ;
                };
            } else {
                cc_support_serror((byte*)"For decl error");
            }goto L695 ;
L696 :;
            ;
            pinit = cc_lib_createunit3((i64)6,ulist,(struct cc_decls_unitrec *)(0),ulistx);
        } else {
            pinit = cc_parse_readexpression();
        };
    } else {
        pinit = cc_lib_createunit0((i64)2);
    };
    cc_lib_skipsymbol((i64)9);
    if (((i64)((u64)(cc_decls_lx.symbol)) != (i64)9)) {
        pcond = cc_parse_readexpression();
        cc_parse_coercecond(pcond);
    } else {
        pcond = cc_lib_createunit0((i64)2);
    };
    cc_lib_skipsymbol((i64)9);
    if (((i64)((u64)(cc_decls_lx.symbol)) != (i64)14)) {
        pincr = cc_parse_readexprstmt();
    } else {
        pincr = (struct cc_decls_unitrec *)(0);
    };
    cc_lib_skipsymbol((i64)14);
    cc_parse_pushloop((i64)76);
    pbody = cc_parse_readblock((i64)0);
    cc_parse_poploop();
    if (!!(hasblock)) {
        cc_parse_popblock();
    };
    (*pinit).nextunit = pcond;
    (*pcond).nextunit = pincr;
    return cc_lib_createunit2((i64)14,pinit,pbody);
}

static struct cc_decls_unitrec * cc_parse_readwhilestmt(void) {
    struct cc_decls_unitrec *  pcond;
    struct cc_decls_unitrec *  pbody;
    cc_lex_lex();
    pcond = cc_parse_readcond();
    cc_parse_coercecond(pcond);
    cc_parse_pushloop((i64)76);
    pbody = cc_parse_readblock((i64)0);
    cc_parse_poploop();
    return cc_lib_createunit2((i64)15,pcond,pbody);
}

static struct cc_decls_unitrec * cc_parse_readdostmt(void) {
    struct cc_decls_unitrec *  pbody;
    struct cc_decls_unitrec *  pcond;
    cc_lex_lex();
    cc_parse_pushloop((i64)76);
    pbody = cc_parse_readblock((i64)0);
    cc_parse_poploop();
    cc_lib_skipsymbol((i64)78);
    pcond = cc_parse_readcond();
    cc_parse_coercecond(pcond);
    cc_lib_skipsymbol((i64)9);
    return cc_lib_createunit2((i64)16,pbody,pcond);
}

static struct cc_decls_unitrec * cc_parse_readreturnstmt(void) {
    struct cc_decls_unitrec *  p;
    cc_lex_lex();
    p = (struct cc_decls_unitrec *)(0);
    if (((i64)((u64)(cc_decls_lx.symbol)) != (i64)9)) {
        if (((i64)((*cc_decls_currproc).mode) == (i64)1)) {
            cc_support_terror((byte*)"Can't return value in void function");
        };
        p = cc_parse_readexpression();
        p = cc_parse_coercemode(p,(i64)((*cc_decls_currproc).mode));
        cc_lib_checksymbol((i64)9);
    } else if (((i64)((*cc_decls_currproc).mode) != (i64)1)) {
        cc_support_terror((byte*)"Return value needed");
    };
    cc_lex_lex();
    return cc_lib_createunit1((i64)10,p);
}

static struct cc_decls_unitrec * cc_parse_readgotostmt(void) {
    struct cc_decls_strec *  d;
    struct cc_decls_unitrec *  p;
    cc_lex_lex();
    cc_lib_checksymbol((i64)69);
    d = cc_lib_resolvename(cc_decls_currproc,cc_decls_lx.symptr,(i64)3,(i64)0);
    if ((d == 0)) {
        d = cc_lib_createdupldef(cc_decls_currproc,cc_decls_lx.symptr,(i64)15);
        (*d).mode = (i64)1;
    };
    p = cc_lib_createunit1((i64)17,(struct cc_decls_unitrec *)(0));
    (*p).def = d;
    cc_lex_lex();
    cc_lib_skipsymbol((i64)9);
    return p;
}

static struct cc_decls_unitrec * cc_parse_readswitchstmt(void) {
    struct cc_decls_unitrec *  pindex;
    struct cc_decls_unitrec *  pstmt;
    struct cc_decls_unitrec *  p;
    cc_lex_lex();
    pindex = cc_parse_readcond();
    cc_parse_coercemode(pindex,(i64)4);
    cc_parse_pushloop((i64)83);
    pstmt = cc_parse_readblock((i64)0);
    p = cc_lib_createunit2((i64)23,pindex,pstmt);
    (*p).nextcase = cc_parse_casevaluestack[(cc_parse_loopindex)-1];
    cc_parse_poploop();
    return p;
}

static struct cc_decls_unitrec * cc_parse_readcaselabel(void) {
    struct cc_decls_unitrec *  p;
    i64 value;
    cc_lex_lex();
    value = cc_parse_readconstintexpr();
    cc_lib_skipsymbol((i64)10);
    p = cc_lib_createunit1((i64)19,cc_parse_readstatement());
    (*p).value = value;
    cc_parse_addcasevalue(value);
    return p;
}

static struct cc_decls_unitrec * cc_parse_readexprstmt(void) {
    return cc_parse_readexpression();
}

static struct cc_decls_unitrec * cc_parse_readcond(void) {
    struct cc_decls_unitrec *  pcond;
    cc_lib_skipsymbol((i64)13);
    pcond = cc_parse_readexpression();
    cc_lib_skipsymbol((i64)14);
    return pcond;
}

static i64 cc_parse_isusertype(struct cc_decls_strec * owner) {
    struct cc_decls_strec *  d;
    d = cc_lib_resolvename(owner,cc_decls_lx.symptr,(i64)1,cc_decls_currblockno);
    if (!!(d)) {
        if (((i64)((u64)((*d).nameid)) == (i64)5)) {
            return (i64)((*d).mode);
        };
        cc_parse_ist_symptr = d;
    };
    return (i64)0;
}

static struct cc_decls_unitrec * cc_parse_readlocaldecl(void) {
    i64 m;
    i64 mbase;
    i64 linkage;
    i64 nitems;
    i64 wasenum;
    i64 wasdef;
    struct cc_decls_strec *  d;
    struct cc_decls_unitrec *  ulist;
    struct cc_decls_unitrec *  ulistx;
    struct cc_decls_unitrec *  p;
    struct cc_decls_paramrec *  pm;
    ulist = (ulistx = (struct cc_decls_unitrec *)(0));
    wasenum = (i64)(cc_decls_lx.symbol);
    mbase = cc_parse_readdeclspec(cc_decls_currproc,&linkage);
    nitems = (i64)0;
    L697 :;
    if (((i64)(cc_decls_lx.symbol)==(i64)69) || ((i64)(cc_decls_lx.symbol)==(i64)25) || ((i64)(cc_decls_lx.symbol)==(i64)13)) {
        ++nitems;
        m = cc_parse_readtype(cc_decls_currproc,&d,mbase,&pm);
        if ((d == 0)) {
            cc_support_serror((byte*)"Var name expected");
        };
        if ((linkage == (i64)5)) {
            d = cc_parse_createtypedef(cc_decls_currproc,d,m);
        } else if (!!(pm)) {
            if (((i64)((u64)(cc_decls_lx.symbol)) == (i64)17)) {
                cc_support_serror((byte*)"Nested function");
            };
            d = cc_parse_readfunction(d,m,linkage,pm,&wasdef);
        } else {
            d = cc_parse_readframevar(d,m,linkage);
            p = cc_lib_createunit0((i64)7);
            (*p).def = d;
            cc_lib_addlistunit(&ulist,&ulistx,p);
        };
        if (((i64)(cc_decls_lx.symbol)==(i64)8)) {
            cc_lex_lex();
        } else {
            cc_lib_skipsymbol((i64)9);
            goto L698 ;
        };
    } else {
        if ((cc_decls_ttbasetype[(mbase)]==(i64)15) || (cc_decls_ttbasetype[(mbase)]==(i64)20) || (cc_decls_ttbasetype[(mbase)]==(i64)21)) {
            cc_lib_skipsymbol((i64)9);
            goto L698 ;
        }else if ((cc_decls_ttbasetype[(mbase)]==(i64)4)) {
            cc_lib_skipsymbol((i64)9);
            goto L698 ;
        } else {
            cc_support_serror_s((byte*)"Local decl error %s",cc_lib_typename(m));
        };
    }goto L697 ;
L698 :;
    ;
    if (((nitems == (i64)0) && !!(cc_decls_fmodern))) {
        if ((cc_decls_ttbasetype[(mbase)]==(i64)20) || (cc_decls_ttbasetype[(mbase)]==(i64)21) || (cc_decls_ttbasetype[(mbase)]==(i64)15)) {
        } else {
            if ((wasenum != (i64)91)) {
                cc_support_serror((byte*)"Empty local declaration");
            };
        };
    };
    return ulist;
}

static struct cc_decls_strec * cc_parse_createtypedef(struct cc_decls_strec * owner,struct cc_decls_strec * symptr,i64 mode) {
    struct cc_decls_strec *  d;
    d = cc_lib_checkdupl(owner,symptr,(i64)1,cc_decls_currblockno);
    if (!!(d)) {
        if (((i64)((u64)((*d).nameid)) != (i64)5)) {
            cc_support_serror_s((byte*)"Typedef name in use %s",(*d).name);
        };
        if (((i64)((*d).mode) != mode)) {
            if (!(!!(cc_parse_comparemode((i64)((*d).mode),mode)))) {
                cc_support_serror_s((byte*)"Typedef redefined or can't match types %s",(*d).name);
            };
        };
        return d;
    };
    d = cc_lib_createdupldef(owner,symptr,(i64)5);
    (*d).mode = mode;
    cc_decls_tttypedef[(mode)] = d;
    (*d).blockno = (u64)(cc_decls_currblockno);
    cc_decls_blockcounts[(cc_decls_currblockno)] = (i64)1;
    return d;
}

static struct cc_decls_paramrec * cc_parse_readparams(struct cc_decls_strec * owner) {
    struct cc_decls_paramrec *  ulist;
    struct cc_decls_paramrec *  ulistx;
    struct cc_decls_paramrec *  pm;
    struct cc_decls_paramrec *  q;
    i64 m;
    i64 nparams;
    i64 variadic;
    i64 flags;
    i64 nnames;
    struct cc_decls_strec *  d;
    ulist = (ulistx = (struct cc_decls_paramrec *)(0));
    variadic = (nparams = (nnames = (i64)0));
    if (!!(cc_decls_callbackflag)) {
        cc_parse_iscallbackfnx = (u64)((i64)1);
        cc_decls_callbackflag = (i64)0;
    };
    L699 :;
    while (((i64)((u64)(cc_decls_lx.symbol)) != (i64)14)) {
        if (((i64)((u64)(cc_decls_lx.symbol)) == (i64)21)) {
            variadic = (i64)1;
            cc_lex_lex();
            goto L701 ;
        };
        m = cc_parse_readcasttype(&d,(i64)1,&pm);
        if (!!(pm)) {
            m = cc_lib_createrefmode(cc_lib_createprocmode(m,pm));
        };
        if ((cc_decls_ttbasetype[(m)]==(i64)19)) {
            m = cc_lib_createrefmode(cc_decls_tttarget[(m)]);
        }else if ((cc_decls_ttbasetype[(m)]==(i64)17)) {
            m = cc_lib_createrefmode(cc_lib_createprocmode(m,cc_decls_ttparams[(m)]));
        };
        pm = (struct cc_decls_paramrec *)(mlib_pcm_allocz((i64)24));
        (*pm).def = d;
        (*pm).mode = m;
        ++nparams;
        if (!!(d)) {
            ++nnames;
            q = ulist;
            L702 :;
            while (!!(q)) {
                if (((*q).def == d)) {
                    cc_support_serror_ss((byte*)"Param name reused %s %s",(*d).name,cc_tables_namenames[((i64)((*d).nameid))]);
                };
                q = (*q).nextparam;
L703 :;
            }L704 :;
            ;
        };
        cc_lib_addlistparam(&ulist,&ulistx,pm);
        if (((i64)(cc_decls_lx.symbol)==(i64)8)) {
            cc_lex_lex();
        }else if (((i64)(cc_decls_lx.symbol)==(i64)21) || ((i64)(cc_decls_lx.symbol)==(i64)14)) {
        } else {
            cc_support_serror((byte*)"bad symbol in paramlist");
        };
L700 :;
    }L701 :;
    ;
    flags = (i64)0;
    cc_lib_skipsymbol((i64)14);
    if (!!(variadic)) {
        flags = (i64)3;
    } else if ((nparams == (i64)0)) {
        if (!!(cc_decls_fmodern)) {
            cc_support_terror((byte*)"() Params not allowed");
        } else {
            flags = (i64)1;
        };
    } else if (((nparams == (i64)1) && (m == (i64)1))) {
        flags = (i64)2;
        nparams = (i64)0;
        (*ulist).mode = (i64)0;
    };
    if ((ulist == 0)) {
        ulist = (struct cc_decls_paramrec *)(mlib_pcm_allocz((i64)24));
    };
    (*ulist).nparams = nparams;
    (*ulist).flags = flags;
    return ulist;
}

static i64 cc_parse_readcasttype(struct cc_decls_strec * * d,i64 allowname,struct cc_decls_paramrec * * pm) {
    struct cc_decls_strec *  owner;
    i64 m;
    i64 linkage;
    owner = (!!(cc_decls_currproc)?cc_decls_currproc:cc_decls_stmodule);
    linkage = (i64)0;
    (*d) = (struct cc_decls_strec *)(0);
    m = cc_parse_readdeclspec(owner,&linkage);
    (*pm) = (struct cc_decls_paramrec *)(0);
    if (((i64)(cc_decls_lx.symbol)==(i64)69) || ((i64)(cc_decls_lx.symbol)==(i64)25) || ((i64)(cc_decls_lx.symbol)==(i64)13) || ((i64)(cc_decls_lx.symbol)==(i64)15)) {
        m = cc_parse_readtype(owner,d,m,pm);
        if ((!!((*d)) && !(!!(allowname)))) {
            cc_support_serror_s((byte*)"NAME not allowed in cast type %s",(*(*d)).name);
        };
    };
    return m;
}

static struct cc_decls_strec * cc_parse_readfunction(struct cc_decls_strec * d,i64 m,i64 linkage,struct cc_decls_paramrec * pm,i64 * wasdef) {
    struct cc_decls_strec *  f;
    struct cc_decls_strec *  owner;
    i64 scope;
    owner = cc_decls_stmodule;
    (*wasdef) = (i64)0;
    f = cc_lib_checkdupl(owner,d,(i64)1,(i64)0);
    if (!!(f)) {
        if (((i64)((u64)((*f).nameid)) != (i64)6)) {
            cc_support_serror_s((byte*)"fn: name in use %s",(*d).name);
        };
        d = f;
        scope = (i64)((*d).scope);
        if (((((scope == (i64)2) && (linkage == (i64)0)) || ((scope == (i64)4) && (linkage == (i64)1))) || ((scope == (i64)3) && (linkage == (i64)1)))) {
        } else if (((scope == (i64)3) && (linkage == (i64)0))) {
            scope = (i64)4;
        };
    } else {
        d = cc_lib_createdupldef(owner,d,(i64)6);
        (*d).mode = m;
        if ((linkage==(i64)1)) {
            scope = (i64)2;
        }else if ((linkage==(i64)4)) {
            scope = (i64)3;
        } else {
            scope = (i64)4;
        };
    };
    if ((!!((u64)(cc_parse_iscallbackfnx)) || !!(cc_decls_fcallback))) {
        (*d).attribs.ax_callback = (u64)((i64)1);
        cc_parse_iscallbackfnx = (u64)((i64)0);
    };
    (*d).paramlist = pm;
    (*d).scope = (u64)(scope);
    if (((i64)((u64)(cc_decls_lx.symbol)) == (i64)17)) {
        (*wasdef) = (i64)1;
        if (!!((*d).code)) {
            cc_support_serror_s((byte*)"Can't define function twice %s",(*d).name);
        };
        if ((scope == (i64)3)) {
        };
        cc_parse_readfunctionbody(d);
        if (((i64)((u64)(cc_decls_lx.symbol)) == (i64)9)) {
            cc_support_serror((byte*)"; after function def");
        };
    };
    return d;
}

static void cc_parse_readfunctionbody(struct cc_decls_strec * f) {
    struct cc_decls_strec *  e;
    struct cc_decls_unitrec *  p;
    struct cc_decls_paramrec *  pm;
    i64 pmcount;
    i64 av_1;
    cc_decls_currproc = f;
    cc_decls_nextblockno = (cc_decls_currblockno = (i64)0);
    pmcount = (i64)0;
    pm = (*f).paramlist;
    if (!!((*pm).def)) {
        av_1 = (i64)((*pm).nparams);
        while (av_1-- > 0) {
L705 :;
            e = cc_lib_createdupldef(f,(*pm).def,(i64)9);
            (*e).blockno = (u64)((i64)1);
            (*e).mode = (i64)((*pm).mode);
            pm = (*pm).nextparam;
            pmcount = (i64)1;
L706 :;
        }L707 :;
        ;
    } else if (!!((i64)((*pm).nparams))) {
        cc_support_serror((byte*)"Param names missing");
    };
    p = cc_parse_readcompoundstmt(pmcount);
    (*cc_decls_currproc).code = p;
    cc_decls_currproc = (struct cc_decls_strec *)(0);
}

static struct cc_decls_unitrec * cc_parse_createnegop(struct cc_decls_unitrec * p) {
    struct cc_decls_unitrec *  q;
    i64 t;
    t = (i64)((*p).mode);
    if (((i64)((*p).tag) == (i64)1)) {
        if ((t==(i64)4) || (t==(i64)5) || (t==(i64)10)) {
            (*p).value = -((*p).value);
            return p;
        }else if ((t==(i64)9)) {
            (*p).value = (-((*p).value) & (i64)4294967295);
            return p;
        }else if ((t==(i64)12)) {
            (*p).xvalue = -((*p).xvalue);
            return p;
        };
    };
    //retry:
L708 :;
;
    if (((t >= (i64)2) && (t <= (i64)13))) {
        cc_parse_coercebasetype(p);
        q = cc_lib_createunit1((i64)59,p);
    } else if (!!((u64)(cc_decls_ttconst[(t)]))) {
        t = cc_decls_ttconsttype[(t)];
        goto L708 ;
;
    } else {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str(cc_lib_strmode(t,(i64)1),NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        cc_support_terror((byte*)"neg bad type");
    };
    (*q).mode = (i64)((*p).mode);
    return q;
}

static struct cc_decls_unitrec * cc_parse_createabsop(struct cc_decls_unitrec * p) {
    struct cc_decls_unitrec *  q;
    i64 t;
    t = (i64)((*p).mode);
    if (((i64)((*p).tag) == (i64)1)) {
        if ((t==(i64)4) || (t==(i64)5)) {
            (*p).value = labs((*p).value);
            return p;
        };
    };
    if (!!(cc_lib_isintcc(t))) {
        cc_parse_coercebasetype(p);
        q = cc_lib_createunit1((i64)60,p);
    } else {
        cc_support_terror((byte*)"abs bad type");
    };
    (*q).mode = (i64)((*p).mode);
    return q;
}

static struct cc_decls_unitrec * cc_parse_createsqrtop(struct cc_decls_unitrec * p) {
    struct cc_decls_unitrec *  q;
    i64 t;
    t = (i64)((*p).mode);
    if (((i64)((*p).tag) == (i64)1)) {
        if ((t==(i64)11) || (t==(i64)12)) {
            (*p).value = (i64)(sqrt(((*p).xvalue)));
            return p;
        };
    };
    cc_parse_coercemode(p,(i64)12);
    q = cc_lib_createunit1((i64)72,p);
    (*q).mode = (i64)12;
    return q;
}

static struct cc_decls_unitrec * cc_parse_createinotop(struct cc_decls_unitrec * p) {
    struct cc_decls_unitrec *  q;
    i64 t;
    t = cc_decls_ttbasetype[((i64)((*p).mode))];
    if (((i64)((*p).tag) == (i64)1)) {
        if ((t==(i64)4) || (t==(i64)5) || (t==(i64)9) || (t==(i64)10)) {
            (*p).value = ~((*p).value);
            return p;
        };
    };
    if (!!(cc_lib_isintcc(t))) {
        cc_parse_coercebasetype(p);
        q = cc_lib_createunit1((i64)61,p);
    } else {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str(cc_lib_strmode(t,(i64)1),NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        cc_support_terror((byte*)"! bad type");
    };
    (*q).mode = (i64)((*p).mode);
    return q;
}

static struct cc_decls_unitrec * cc_parse_createptrop(struct cc_decls_unitrec * p) {
    struct cc_decls_unitrec *  q;
    i64 t;
    i64 m;
    if (!(!!((u64)(cc_decls_ttisref[((t = (i64)((*p).mode)))])))) {
        cc_support_terror((byte*)"* not pointer");
    };
    m = cc_decls_tttarget[(t)];
    if (((i64)((*p).tag)==(i64)56)) {
        q = (*p).a;
        if (!!((i64)((*p).alength))) {
            (*q).mode = cc_decls_tttarget[((i64)((*p).mode))];
        };
        return q;
    };
    q = cc_lib_createunit1((i64)53,p);
    (*q).mode = m;
    q = cc_parse_arraytopointer(q);
    cc_parse_fixmemopnd(q);
    return q;
}

static struct cc_decls_unitrec * cc_parse_createincrop(i64 opc,struct cc_decls_unitrec * p) {
    struct cc_decls_unitrec *  q;
    i64 t;
    t = (i64)((*p).mode);
    cc_parse_checklvalue(p);
    if (!(((!!(cc_lib_isintcc(t)) && (t != (i64)6)) || !!((u64)(cc_decls_ttisref[(t)]))))) {
        cc_support_terror((byte*)"++ bad type");
    };
    q = cc_lib_createunit1(opc,p);
    (*q).mode = (i64)((*p).mode);
    return q;
}

static struct cc_decls_unitrec * cc_parse_createlengthofop(struct cc_decls_unitrec * p) {
    struct cc_decls_unitrec *  q;
    i64 t;
    i64 size;
    t = (i64)((*p).mode);
    switch ((i64)((*p).tag)) {
    case 3:;
    {
        size = cc_decls_ttlength[((i64)((*(*p).def).mode))];
    }break;
    case 1:;
    {
        if ((t == cc_decls_trefchar)) {
            size = ((i64)((*p).slength) + (i64)1);
        } else {
            size = cc_decls_ttlength[(t)];
        };
    }break;
    case 53:;
    {
        if ((!!((u64)(cc_decls_ttisref[(t)])) && !!((i64)((*p).alength)))) {
            size = (cc_decls_ttlength[(cc_decls_tttarget[(t)])] * (i64)((*p).alength));
        } else {
            size = cc_decls_ttlength[(t)];
        };
    }break;
    case 4:;
    {
        return cc_parse_createsizeofop((*p).a);
    }break;
    default: {
        size = cc_decls_ttlength[(t)];
    }
    } //SW
;
    q = cc_lib_createconstunit((u64)(size),(i64)4);
    return q;
}

static struct cc_decls_unitrec * cc_parse_createaddrofop(struct cc_decls_unitrec * p) {
    struct cc_decls_unitrec *  q;
    i64 t;
    i64 alength;
    alength = (i64)0;
    //restartx:
L709 :;
;
    t = (i64)((*p).mode);
    switch ((i64)((*p).tag)) {
    case 3:;
    {
        if (!!((i64)((*p).alength))) {
            t = (i64)((*(*p).def).mode);
            alength = (i64)((*p).alength);
        };
    }break;
    case 56:;
    {
        if ((((i64)((*(*p).a).tag) == (i64)3) && !!((i64)((*(*p).a).alength)))) {
            (*p).mode = cc_lib_createrefmode((i64)((*(*(*p).a).def).mode));
            (*p).alength = (i64)((*(*p).a).alength);
            return p;
        };
    }break;
    case 50:;
    {
        q = (*p).a;
        if ((((i64)((*q).tag) == (i64)53) && ((i64)((*(*q).a).tag) == (i64)1))) {
            p = cc_lib_createconstunit((u64)(((i64)((*p).offset) + (*(*q).a).value)),(i64)4);
            return p;
        };
        goto L710 ;
;
    }break;
    case 54:;
    {
        if (!!((i64)((*p).alength))) {
            (*p).mode = cc_lib_createrefmode(cc_lib_createarraymode(cc_decls_tttarget[((i64)((*p).mode))],(i64)((*p).alength)));
            return p;
        };
    }break;
    case 4:;
    {
        p = (*p).a;
        goto L709 ;
;
    }break;
    case 5:;
    {
        return p;
    }break;
    default: {
        //cad1:
L710 :;
;
        cc_parse_checklvalue(p);
    }
    } //SW
;
    p = cc_lib_createunit1((i64)56,p);
    (*p).mode = cc_lib_createrefmode(t);
    (*p).alength = alength;
    return p;
}

static struct cc_decls_unitrec * cc_parse_createaddop(struct cc_decls_unitrec * x,struct cc_decls_unitrec * y) {
    struct cc_decls_unitrec *  z;
    i64 s;
    i64 t;
    i64 u;
    i64 opc;
    i64 elemsize;
    s = cc_decls_ttbasetype[(cc_parse_getmemmode(x))];
    t = cc_decls_ttbasetype[(cc_parse_getmemmode(y))];
    opc = (i64)40;
    if (!!((u = (i64)(cc_tables_dominantmode[(s)][(t)])))) {
        x = cc_parse_coercemode(x,u);
        y = cc_parse_coercemode(y,u);
    } else if ((s == (i64)16)) {
        //doaddref:
L711 :;
;
        u = (i64)((*x).mode);
        elemsize = cc_decls_ttsize[(cc_decls_tttarget[(u)])];
        if ((((i64)((*x).tag) == (i64)1) && ((i64)((*y).tag) == (i64)1))) {
            (*x).value += ((*y).value * elemsize);
            return x;
        };
        y = cc_parse_coercemode(y,(i64)5);
        z = cc_lib_createunit2((i64)54,x,y);
        (*z).mode = u;
        (*z).ptrscale = elemsize;
        return z;
    } else if ((t == (i64)16)) {
        {struct cc_decls_unitrec *  temp = x; x = y; y = temp; };
        goto L711 ;
;
    } else {
        cc_support_terror((byte*)"Sub bad types");
    };
    if ((((i64)((*x).tag) == (i64)1) && ((i64)((*y).tag) == (i64)1))) {
        return cc_parse_eval_add(opc,x,y,u);
    };
    z = cc_lib_createunit2(opc,x,y);
    (*z).mode = u;
    return z;
}

static struct cc_decls_unitrec * cc_parse_createsubop(struct cc_decls_unitrec * x,struct cc_decls_unitrec * y) {
    struct cc_decls_unitrec *  z;
    i64 s;
    i64 t;
    i64 u;
    i64 opc;
    i64 elemsize;
    s = cc_decls_ttbasetype[(cc_parse_getmemmode(x))];
    t = cc_decls_ttbasetype[(cc_parse_getmemmode(y))];
    opc = (i64)41;
    if (!!((u = (i64)(cc_tables_dominantmode[(s)][(t)])))) {
        x = cc_parse_coercemode(x,u);
        y = cc_parse_coercemode(y,u);
    } else if ((s == (i64)16)) {
        if ((t != (i64)16)) {
            u = (i64)((*x).mode);
            elemsize = cc_decls_ttsize[(cc_decls_tttarget[(u)])];
            y = cc_parse_coercemode(y,(i64)5);
            z = cc_lib_createunit2((i64)55,x,y);
            (*z).mode = u;
            (*z).ptrscale = elemsize;
            return z;
        } else {
            z = cc_lib_createunit2(opc,x,y);
            (*z).mode = (i64)5;
            z = cc_parse_divunit(z,cc_decls_tttarget[((i64)((*x).mode))]);
            (*z).mode = (i64)5;
            return z;
        };
        y = cc_parse_mulunit(y,cc_decls_tttarget[((i64)((*x).mode))]);
    } else {
        cc_support_terror((byte*)"Sub bad types");
    };
    if ((((i64)((*x).tag) == (i64)1) && ((i64)((*y).tag) == (i64)1))) {
        return cc_parse_eval_sub(opc,x,y,u);
    };
    z = cc_lib_createunit2(opc,x,y);
    (*z).mode = u;
    return z;
}

static struct cc_decls_unitrec * cc_parse_createmulop(struct cc_decls_unitrec * x,struct cc_decls_unitrec * y) {
    struct cc_decls_unitrec *  z;
    i64 s;
    i64 t;
    i64 u;
    i64 opc;
    s = cc_decls_ttbasetype[(cc_parse_getmemmode(x))];
    t = cc_decls_ttbasetype[(cc_parse_getmemmode(y))];
    opc = (i64)42;
    if (!!((u = (i64)(cc_tables_dominantmode[(s)][(t)])))) {
        x = cc_parse_coercemode(x,u);
        y = cc_parse_coercemode(y,u);
    } else {
        cc_support_terror((byte*)"Mul bad types");
    };
    if ((((i64)((*x).tag) == (i64)1) && ((i64)((*y).tag) == (i64)1))) {
        return cc_parse_eval_mul(opc,x,y,u);
    };
    z = cc_lib_createunit2(opc,x,y);
    (*z).mode = u;
    return z;
}

static struct cc_decls_unitrec * cc_parse_createdivop(struct cc_decls_unitrec * x,struct cc_decls_unitrec * y) {
    struct cc_decls_unitrec *  z;
    i64 s;
    i64 t;
    i64 u;
    i64 opc;
    s = cc_decls_ttbasetype[(cc_parse_getmemmode(x))];
    t = cc_decls_ttbasetype[(cc_parse_getmemmode(y))];
    opc = (i64)43;
    if (!!((u = (i64)(cc_tables_dominantmode[(s)][(t)])))) {
        x = cc_parse_coercemode(x,u);
        y = cc_parse_coercemode(y,u);
    } else {
        cc_support_terror((byte*)"Div bad types");
    };
    if ((((i64)((*x).tag) == (i64)1) && ((i64)((*y).tag) == (i64)1))) {
        return cc_parse_eval_div(opc,x,y,u);
    } else if (((i64)((*y).tag) == (i64)1)) {
        opc = (i64)42;
        (*y).xvalue = ((double)1. / (*y).xvalue);
    };
    z = cc_lib_createunit2(opc,x,y);
    (*z).mode = u;
    return z;
}

static struct cc_decls_unitrec * cc_parse_createremop(struct cc_decls_unitrec * x,struct cc_decls_unitrec * y) {
    struct cc_decls_unitrec *  z;
    i64 s;
    i64 t;
    i64 u;
    i64 opc;
    s = cc_decls_ttbasetype[((i64)((*x).mode))];
    t = cc_decls_ttbasetype[((i64)((*y).mode))];
    opc = (i64)44;
    if (!!((u = (i64)(cc_tables_dominantmode[(s)][(t)])))) {
        if (((u == (i64)12) || (u == (i64)11))) {
            u = (i64)4;
        };
        x = cc_parse_coercemode(x,u);
        y = cc_parse_coercemode(y,u);
    } else {
        cc_support_terror((byte*)"Rem bad types");
    };
    if ((((i64)((*x).tag) == (i64)1) && ((i64)((*y).tag) == (i64)1))) {
        return cc_parse_eval_rem(opc,x,y,u);
    };
    z = cc_lib_createunit2(opc,x,y);
    (*z).mode = u;
    return z;
}

static void cc_parse_insertunit(struct cc_decls_unitrec * p,i64 tag) {
    struct cc_decls_unitrec *  q;
    q = cc_lib_createunit0((i64)0);
    (*q) = (*p);
    (*p).tag = tag;
    (*p).a = q;
    (*p).b = ((*p).c = (struct cc_decls_unitrec *)(0));
    (*p).lineno = (u64)((*q).lineno);
    (*p).simple = (u64)((i64)0);
    (*p).nextunit = (*q).nextunit;
    (*q).nextunit = (struct cc_decls_unitrec *)(0);
}

static struct cc_decls_unitrec * cc_parse_eval_add(i64 opc,struct cc_decls_unitrec * x,struct cc_decls_unitrec * y,i64 t) {
    struct cc_decls_unitrec *  z;
    if ((t==(i64)4) || (t==(i64)5) || (t==(i64)9) || (t==(i64)10)) {
        (*x).value += (*y).value;
        return x;
    }else if ((t==(i64)12)) {
        (*x).xvalue += (*y).xvalue;
        return x;
    } else {
        if ((cc_decls_ttbasetype[(t)] == (i64)16)) {
            (*x).value += ((*y).value * cc_decls_ttsize[(cc_decls_tttarget[(t)])]);
            return x;
        };
    };
    z = cc_lib_createunit2(opc,x,y);
    (*z).mode = t;
    return z;
}

static struct cc_decls_unitrec * cc_parse_eval_sub(i64 opc,struct cc_decls_unitrec * x,struct cc_decls_unitrec * y,i64 t) {
    struct cc_decls_unitrec *  z;
    if ((t==(i64)4) || (t==(i64)5) || (t==(i64)9) || (t==(i64)10)) {
        (*x).value -= (*y).value;
        return x;
    }else if ((t==(i64)12)) {
        (*x).xvalue -= (*y).xvalue;
        return x;
    } else {
        if ((cc_decls_ttbasetype[(t)] == (i64)16)) {
            if ((cc_decls_ttbasetype[((i64)((*y).mode))] == (i64)16)) {
                cc_support_terror((byte*)"EVALSUB/REF");
            };
            return x;
        };
    };
    z = cc_lib_createunit2(opc,x,y);
    (*z).mode = t;
    return z;
}

static struct cc_decls_unitrec * cc_parse_eval_mul(i64 opc,struct cc_decls_unitrec * x,struct cc_decls_unitrec * y,i64 t) {
    struct cc_decls_unitrec *  z;
    if ((t==(i64)4) || (t==(i64)5) || (t==(i64)3) || (t==(i64)2)) {
        (*x).value *= (*y).value;
        return x;
    }else if ((t==(i64)9) || (t==(i64)10) || (t==(i64)8) || (t==(i64)7)) {
        (*x).uvalue = ((*x).uvalue * (*y).uvalue);
        return x;
    }else if ((t==(i64)12)) {
        (*x).xvalue *= (*y).xvalue;
        return x;
    };
    z = cc_lib_createunit2(opc,x,y);
    (*z).mode = t;
    return z;
}

static struct cc_decls_unitrec * cc_parse_eval_div(i64 opc,struct cc_decls_unitrec * x,struct cc_decls_unitrec * y,i64 t) {
    struct cc_decls_unitrec *  z;
    if ((t==(i64)4) || (t==(i64)5)) {
        if (((*y).value == (i64)0)) {
            cc_support_serror((byte*)"div 0");
        };
        (*x).value = ((*x).value / (*y).value);
        return x;
    }else if ((t==(i64)9) || (t==(i64)10)) {
        if (((*y).value == (i64)0)) {
            cc_support_serror((byte*)"div 0");
        };
        (*x).uvalue = ((*x).uvalue / (*y).uvalue);
        return x;
    }else if ((t==(i64)12)) {
        (*x).xvalue /= (*y).xvalue;
        return x;
    };
    z = cc_lib_createunit2(opc,x,y);
    (*z).mode = t;
    return z;
}

static struct cc_decls_unitrec * cc_parse_eval_rem(i64 opc,struct cc_decls_unitrec * x,struct cc_decls_unitrec * y,i64 t) {
    struct cc_decls_unitrec *  z;
    if ((t==(i64)4) || (t==(i64)5)) {
        if (((*y).value == (i64)0)) {
            cc_support_serror((byte*)"rem 0");
        };
        (*x).value = ((*x).value % (*y).value);
        return x;
    };
    z = cc_lib_createunit2(opc,x,y);
    (*z).mode = t;
    return z;
}

static i64 cc_parse_eval_convert(struct cc_decls_unitrec * p,i64 t,i64 opc) {
    i64 s;
    if ((opc == (i64)1)) {
        //dosoft:
L712 :;
;
        (*p).mode = t;
        return (i64)1;
    };
    s = (i64)((*p).mode);
    if ((s == t)) {
        return (i64)1;
    };
    if ((s==(i64)4) || (s==(i64)3) || (s==(i64)2) || (s==(i64)5)) {
        if ((t==(i64)12) || (t==(i64)11)) {
            (*p).xvalue = (double)((*p).value);
            (*p).mode = t;
            return (i64)1;
        }else if ((t==(i64)10) || (t==(i64)5) || (t==(i64)9) || (t==(i64)4) || (t==(i64)3) || (t==(i64)2) || (t==(i64)7) || (t==(i64)8)) {
            //dotrunc:
L713 :;
;
            if ((cc_decls_ttsize[(t)]==(i64)1)) {
                (*p).value &= (i64)255;
            }else if ((cc_decls_ttsize[(t)]==(i64)2)) {
                (*p).value &= (i64)65535;
            }else if ((cc_decls_ttsize[(t)]==(i64)4)) {
                (*p).value = ((*p).value & (i64)4294967295);
            };
            goto L712 ;
;
        };
        if (!!((u64)(cc_decls_ttisref[(t)]))) {
            (*p).mode = t;
            return (i64)1;
        };
    }else if ((s==(i64)9) || (s==(i64)7) || (s==(i64)8) || (s==(i64)10)) {
        if ((t==(i64)12) || (t==(i64)11)) {
            return (i64)0;
            (*p).mode = t;
            return (i64)1;
        }else if ((t==(i64)10) || (t==(i64)5) || (t==(i64)4) || (t==(i64)9) || (t==(i64)10) || (t==(i64)8) || (t==(i64)2) || (t==(i64)7) || (t==(i64)3)) {
            goto L713 ;
;
        };
        if (!!((u64)(cc_decls_ttisref[(t)]))) {
            (*p).mode = t;
            return (i64)1;
        };
    }else if ((s==(i64)12)) {
        if ((t==(i64)4) || (t==(i64)5)) {
            (*p).value = (i64)((*p).xvalue);
            (*p).mode = t;
            return (i64)1;
        }else if ((t==(i64)11)) {
            (*p).mode = (i64)11;
            return (i64)1;
        };
    } else {
        if (!!((u64)(cc_decls_ttisref[((i64)((*p).mode))]))) {
            if ((t==(i64)4) || (t==(i64)5) || (t==(i64)9) || (t==(i64)10)) {
                (*p).mode = t;
                return (i64)1;
            };
        };
    };
    return (i64)0;
}

static void cc_parse_coercecond(struct cc_decls_unitrec * p) {
    i64 t;
    if (((t = (i64)((*p).mode)) == (i64)4)) {
        return;
    };
    //retry:
L714 :;
;
    if ((cc_decls_ttbasetype[(t)]==(i64)11) || (cc_decls_ttbasetype[(t)]==(i64)12) || (cc_decls_ttbasetype[(t)]==(i64)16)) {
        goto L715 ;
;
    } else {
        if (!!(cc_lib_isintcc(t))) {
            //doint:
L715 :;
;
            if ((((i64)((*p).tag) == (i64)1) && !!((*p).value))) {
                (*p).value = (i64)1;
            } else {
                cc_parse_insertunit(p,(i64)28);
            };
        } else if (!!((u64)(cc_decls_ttconst[(t)]))) {
            t = cc_decls_ttconsttype[(t)];
            goto L714 ;
;
        } else {
            cc_support_serror_s((byte*)"Invalid condition %s",cc_lib_strmode(t,(i64)1));
        };
    };
    (*p).mode = (i64)4;
}

static void cc_parse_coercebasetype(struct cc_decls_unitrec * p) {
    i64 t;
    if ((((t = (i64)((*p).mode)) >= (i64)2) && (t <= (i64)3))) {
        p = cc_parse_coercemode(p,(i64)4);
    } else if (((t >= (i64)6) && (t <= (i64)8))) {
        p = cc_parse_coercemode(p,(i64)9);
    };
}

static void cc_parse_checklvalue(struct cc_decls_unitrec * p) {
    if (((i64)((*p).tag)==(i64)3)) {
        if (((i64)((u64)((*(*p).def).nameid)) == (i64)14)) {
            cc_support_serror((byte*)"'constant' name can't be lvalue");
        };
    }else if (((i64)((*p).tag)==(i64)53)) {
    }else if (((i64)((*p).tag)==(i64)5)) {
    }else if (((i64)((*p).tag)==(i64)4)) {
        if (((i64)((*(*p).a).tag)==(i64)3) || ((i64)((*(*p).a).tag)==(i64)53) || ((i64)((*(*p).a).tag)==(i64)50)) {
            (*p) = (*(*p).a);
        } else {
            cc_support_terror((byte*)"CHECKLV/WIDEN");
        };
    }else if (((i64)((*p).tag)==(i64)50)) {
    }else if (((i64)((*p).tag)==(i64)1)) {
        if (!(!!((u64)(cc_decls_ttisref[((i64)((*p).mode))])))) {
            goto L716 ;
;
        };
    }else if (((i64)((*p).tag)==(i64)57)) {
        if (((i64)((*(*p).a).tag) == (i64)3)) {
            return;
        };
    } else {
        //notlv:
L716 :;
;
        cc_lib_printunit(0,p,(i64)0,(byte*)"*");
        cc_support_terror_s((byte*)"Not lvalue: %s",cc_tables_jtagnames[((i64)((*p).tag))]);
    };
}

static struct cc_decls_unitrec * cc_parse_createcall(struct cc_decls_unitrec * p,struct cc_decls_unitrec * q) {
    struct cc_decls_unitrec *  r;
    struct cc_decls_unitrec *  s;
    struct cc_decls_unitrec *  u;
    struct cc_decls_strec *  d;
    struct cc_decls_paramrec *  pm;
    i64 i;
    i64 nparams;
    i64 aparams;
    i64 retmode;
    i64 mproc;
    i64 c;
    byte str[1024];
    byte *  ss;
    byte *  tt;
    byte *  uu;
    struct mlib_strbuffer *  exprstr;
    i64 av_1;
    d = (struct cc_decls_strec *)(0);
    if (((i64)((*p).tag)==(i64)53)) {
        //doptr:
L717 :;
;
        mproc = (i64)((*p).mode);
        L718 :;
        while ((cc_decls_ttbasetype[(mproc)] == (i64)16)) {
            r = cc_lib_createunit1((i64)53,p);
            mproc = cc_decls_tttarget[(mproc)];
            (*r).mode = mproc;
            p = r;
L719 :;
        }L720 :;
        ;
        if ((cc_decls_ttbasetype[(mproc)] != (i64)17)) {
            cc_support_serror_s((byte*)"Not function pointer: %s",cc_lib_typename(mproc));
        };
        pm = cc_decls_ttparams[(mproc)];
        retmode = cc_decls_tttarget[(mproc)];
    }else if (((i64)((*p).tag)==(i64)3) || ((i64)((*p).tag)==(i64)5)) {
        d = (*p).def;
        if (((i64)((u64)((*d).nameid)) == (i64)6)) {
            pm = (*d).paramlist;
            retmode = (i64)((*d).mode);
        } else {
            r = cc_lib_createunit1((i64)53,p);
            (*r).mode = cc_decls_tttarget[((i64)((*d).mode))];
            (*r).mode = (i64)((*p).mode);
            p = r;
            goto L717 ;
;
        };
    }else if (((i64)((*p).tag)==(i64)50) || ((i64)((*p).tag)==(i64)31) || ((i64)((*p).tag)==(i64)32)) {
        r = cc_lib_createunit1((i64)53,p);
        (*r).mode = cc_decls_tttarget[((i64)((*p).mode))];
        p = r;
        goto L717 ;
;
    } else {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"JTAGNAMES[P^.TAG]=",NULL);
        msysnewc_m_print_str(cc_tables_jtagnames[((i64)((*p).tag))],NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        cc_lib_printunit(0,p,(i64)0,(byte*)"*");
        cc_support_serror((byte*)"ccall?");
    };
    nparams = (i64)((*pm).nparams);
    aparams = (i64)0;
    s = q;
    L721 :;
    while (!!(s)) {
        ++aparams;
        s = (*s).nextunit;
L722 :;
    }L723 :;
    ;
    if ((aparams < nparams)) {
        cc_support_terror((byte*)"Too few args");
    } else if ((((aparams > nparams) && ((i64)((*pm).flags) != (i64)3)) && ((i64)((*pm).flags) != (i64)1))) {
        if (((i64)((*pm).flags) != (i64)1)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_i64(aparams,NULL);
            msysnewc_m_print_i64(nparams,NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            cc_support_terror((byte*)"Too many args");
        } else if (!!(cc_decls_fmodern)) {
            cc_support_terror((byte*)"Can't call () param function");
        };
    };
    s = q;
    L724 :;
    for (i=(i64)1;i<=aparams;i+=(i64)1) {
L725 :;
        if ((i <= nparams)) {
            cc_parse_coercemode_inplace(s,(i64)((*pm).mode));
            pm = (*pm).nextparam;
        } else {
            if (((i64)((*s).mode) == (i64)1)) {
                cc_support_terror((byte*)"Variadic param is void");
            };
            cc_parse_coercebasetype(s);
        };
        s = (*s).nextunit;
L726 :;
    }L727 :;
    ;
    r = cc_lib_createunit2((i64)31,p,q);
    (*r).mode = retmode;
    (*r).aparams = aparams;
    if (((((!!(d) && !!(mlib_eqstring((*d).name,(byte*)"printf"))) && !!(q)) && ((i64)((*q).tag) == (i64)1)) && ((i64)((*q).slength) < (i64)512))) {
        ss = (*q).svalue;
        tt = str;
        u = (*q).nextunit;
        L728 :;
        while (!!((c = (i64)((*ss++))))) {
            if ((((c == (i64)37) && (((*ss) == (i64)63) || ((*ss) == (i64)61))) && !!(u))) {
                if (((u64)((*ss)) == '=')) {
                    ++ss;
                    exprstr = cc_lib_strexpr(u);
                    uu = (*exprstr).strptr;
                    mlib_convucstring(uu);
                    av_1 = (i64)((*exprstr).length);
                    while (av_1-- > 0) {
L731 :;
                        (*tt++) = (u64)((*uu++));
L732 :;
                    }L733 :;
                    ;
                    (*tt++) = '=';
                };
                ++ss;
                (*tt++) = '%';
                if ((cc_decls_ttbasetype[((i64)((*u).mode))]==(i64)4)) {
                    (*tt++) = 'd';
                }else if ((cc_decls_ttbasetype[((i64)((*u).mode))]==(i64)5)) {
                    (*tt++) = 'l';
                    (*tt++) = 'l';
                    (*tt++) = 'd';
                }else if ((cc_decls_ttbasetype[((i64)((*u).mode))]==(i64)9)) {
                    (*tt++) = 'u';
                }else if ((cc_decls_ttbasetype[((i64)((*u).mode))]==(i64)10)) {
                    (*tt++) = 'l';
                    (*tt++) = 'l';
                    (*tt++) = 'u';
                }else if ((cc_decls_ttbasetype[((i64)((*u).mode))]==(i64)11) || (cc_decls_ttbasetype[((i64)((*u).mode))]==(i64)12) || (cc_decls_ttbasetype[((i64)((*u).mode))]==(i64)13)) {
                    (*tt++) = 'f';
                }else if ((cc_decls_ttbasetype[((i64)((*u).mode))]==(i64)16)) {
                    if ((cc_decls_tttarget[((i64)((*u).mode))] == (i64)2)) {
                        (*tt++) = 's';
                    } else {
                        (*tt++) = 'p';
                    };
                } else {
                    (*tt++) = '?';
                };
                u = (*u).nextunit;
            } else {
                (*tt++) = (u64)(c);
            };
L729 :;
        }L730 :;
        ;
        (*tt) = (u64)0u;
        (*q).svalue = mlib_pcm_copyheapstring(str);
        (*q).slength = (i64)(strlen((i8 *)(str)));
    };
    return r;
}

static struct cc_decls_unitrec * cc_parse_arraytopointer(struct cc_decls_unitrec * p) {
    struct cc_decls_unitrec *  q;
    i64 offset;
    i64 t;
    i64 elemmode;
    i64 refmode;
    t = (i64)((*p).mode);
    elemmode = cc_decls_tttarget[(t)];
    if ((cc_decls_ttbasetype[(t)] == (i64)19)) {
        refmode = cc_lib_createrefmode(elemmode);
        if (((i64)((*p).tag)==(i64)53)) {
            p = (*p).a;
        }else if (((i64)((*p).tag)==(i64)50)) {
            offset = (i64)((*p).offset);
            (*p).tag = (i64)54;
            (*p).ptrscale = (i64)0;
            q = cc_lib_createunit1((i64)56,(*p).a);
            (*q).mode = refmode;
            (*p).a = q;
            (*p).b = cc_lib_createconstunit((u64)(offset),(i64)4);
        } else {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((byte*)"ATP:",NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            cc_lib_printunit(0,p,(i64)0,(byte*)"*");
            cc_support_terror((byte*)"ATP?");
        };
        (*p).mode = refmode;
        (*p).alength = cc_decls_ttlength[(t)];
    };
    return p;
}

static struct cc_decls_unitrec * cc_parse_createindexop(struct cc_decls_unitrec * p,struct cc_decls_unitrec * q) {
    struct cc_decls_unitrec *  a;
    a = cc_parse_createaddop(p,q);
    return cc_parse_createptrop(a);
}

static i64 cc_parse_readstructdecl(struct cc_decls_strec * owner) {
    struct cc_decls_strec *  d;
    struct cc_decls_strec *  e;
    struct cc_decls_strec *  currrecord;
    struct cc_decls_strec *  ulist;
    struct cc_decls_strec *  ulistx;
    struct cc_decls_strec *  tagowner;
    i64 funion;
    i64 linkage;
    i64 mbase;
    i64 m;
    i64 offset;
    i64 recsize;
    i64 maxsize;
    i64 maxalignment;
    i64 alignment;
    i64 size;
    struct cc_decls_paramrec *  pm;
    struct cc_decls_fieldrec *  fieldlist;
    funion = ((i64)((u64)(cc_decls_lx.symbol)) == (i64)86);
    cc_lex_lex();
    tagowner = (!!(cc_decls_currproc)?cc_decls_currproc:cc_decls_stmodule);
    if (((i64)((u64)(cc_decls_lx.symbol)) == (i64)17)) {
        d = cc_lex_addnamestr(cc_lib_nextautotype());
    } else {
        cc_lib_checksymbol((i64)69);
        d = cc_decls_lx.symptr;
        cc_lex_lex();
        if (((i64)((u64)(cc_decls_lx.symbol)) != (i64)17)) {
            e = cc_lib_resolvename(tagowner,d,(i64)2,cc_decls_currblockno);
            if (!!(e)) {
                if (((i64)((u64)((*e).nameid)) != (i64)13)) {
                    cc_support_serror_s((byte*)"Struct tag in use %s",(*e).name);
                };
                return (i64)((*e).mode);
            };
            e = cc_lib_createdupldef(tagowner,d,(i64)13);
            (*e).mode = cc_lib_createstructmode(e,(!!(funion)?(i64)21:(i64)20));
            (*e).blockno = (u64)(cc_decls_currblockno);
            cc_decls_blockcounts[(cc_decls_currblockno)] = (i64)1;
            return (i64)((*e).mode);
        };
    };
    e = cc_lib_checkdupl(tagowner,d,(i64)2,cc_decls_currblockno);
    if (!!(e)) {
        if (((i64)((u64)((*e).nameid)) != (i64)13)) {
            cc_support_serror_s((byte*)"Struct tag in use %s",(*e).name);
        };
        if (!!((*e).deflist)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((byte*)"Prev",NULL);
            msysnewc_m_print_i64(((i64)((u64)((*e).lineno)) & (i64)1677215),NULL);
            msysnewc_m_print_str(cc_decls_sourcefilenames[((i64)(((u64)((*e).lineno) >> (i64)24)))],NULL);
            msysnewc_m_print_str(cc_decls_sourcefilepaths[((i64)(((u64)((*e).lineno) >> (i64)24)))],NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            cc_support_serror_s((byte*)"Redefining struct %s",(*e).name);
        };
    } else {
        e = cc_lib_createdupldef(tagowner,d,(i64)13);
        (*e).mode = cc_lib_createstructmode(e,(!!(funion)?(i64)21:(i64)20));
        (*e).blockno = (u64)(cc_decls_currblockno);
        cc_decls_blockcounts[(cc_decls_currblockno)] = (i64)1;
    };
    cc_lex_lex();
    currrecord = e;
    ulist = (ulistx = (struct cc_decls_strec *)(0));
    offset = (maxsize = (recsize = (i64)0));
    maxalignment = (i64)1;
    fieldlist = (struct cc_decls_fieldrec *)(0);
    m = (i64)-1;
    L734 :;
    while (((i64)((u64)(cc_decls_lx.symbol)) != (i64)18)) {
        mbase = cc_parse_readdeclspec(currrecord,&linkage);
        L737 :;
        if (((i64)(cc_decls_lx.symbol)==(i64)69) || ((i64)(cc_decls_lx.symbol)==(i64)25) || ((i64)(cc_decls_lx.symbol)==(i64)13)) {
            m = cc_parse_readtype(currrecord,&d,mbase,&pm);
            if ((d == 0)) {
                cc_support_serror((byte*)"Field name expected");
            };
            if (((linkage == (i64)5) || !!(pm))) {
                cc_support_serror((byte*)"typedef or function inside struct");
            };
            e = cc_lib_checkdupl(currrecord,d,(i64)4,(i64)0);
            if (!!(e)) {
                cc_support_serror_s((byte*)"member name in use %s",(*e).name);
            };
            if ((linkage != (i64)0)) {
                cc_support_serror((byte*)"Can't use ss in struct");
            };
            //addanonfield:
L739 :;
;
            d = cc_lib_createdupldef((struct cc_decls_strec *)(0),d,(i64)10);
            (*d).mode = m;
            cc_lib_addlistdef(&ulist,&ulistx,d);
            (*currrecord).deflist = ulist;
            (*currrecord).deflistx = ulistx;
            (*d).owner = currrecord;
            alignment = cc_lib_getalignment(m);
            if ((alignment > maxalignment)) {
                maxalignment = alignment;
            };
            (*d).offset = cc_parse_roundoffset(offset,alignment);
            size = cc_decls_ttsize[(m)];
            recsize += ((*d).offset - offset);
            offset = (*d).offset;
            cc_parse_addnewfield(&fieldlist,d,offset);
            if (!!(funion)) {
                maxsize = (maxsize>size?maxsize:size);
            } else {
                offset += size;
                recsize += size;
            };
            if (((i64)((u64)(cc_decls_lx.symbol)) == (i64)10)) {
                cc_lex_lex();
                cc_parse_readassignexpr();
            };
            if (((i64)(cc_decls_lx.symbol)==(i64)8)) {
                cc_lex_lex();
            } else {
                cc_lib_skipsymbol((i64)9);
                goto L738 ;
            };
        }else if (((i64)(cc_decls_lx.symbol)==(i64)10)) {
            cc_lex_lex();
            cc_parse_readassignexpr();
            cc_lib_skipsymbol((i64)9);
            goto L738 ;
        } else {
            if ((cc_decls_ttbasetype[(mbase)]==(i64)20) || (cc_decls_ttbasetype[(mbase)]==(i64)21)) {
                d = cc_lib_getautofieldname();
                m = mbase;
                goto L739 ;
;
            } else {
                if ((m == (i64)-1)) {
                    cc_support_serror((byte*)"Struct decl error");
                } else {
                    cc_support_serror_s((byte*)"Struct decl error %s",cc_lib_typename(m));
                };
            };
        }goto L737 ;
L738 :;
        ;
L735 :;
    }L736 :;
    ;
    cc_lib_skipsymbol((i64)18);
    (*currrecord).nextfield = fieldlist;
    cc_decls_ttsize[((i64)((*currrecord).mode))] = cc_parse_roundoffset((!!(funion)?maxsize:recsize),maxalignment);
    (*currrecord).attribs.ax_align = (u64)(maxalignment);
    return (i64)((*currrecord).mode);
}

static i64 cc_parse_checkpointertypes(i64 s,i64 t,i64 hard) {
    i64 starget;
    i64 ttarget;
    i64 sconst;
    i64 tconst;
    starget = cc_decls_tttarget[(s)];
    ttarget = cc_decls_tttarget[(t)];
    sconst = (i64)0;
    tconst = (i64)0;
    if (!!((u64)(cc_decls_ttconst[(starget)]))) {
        starget = cc_decls_ttconsttype[(starget)];
        sconst = (i64)1;
    };
    if (!!((u64)(cc_decls_ttconst[(ttarget)]))) {
        ttarget = cc_decls_ttconsttype[(ttarget)];
        tconst = (i64)1;
    };
    if (((!(!!(hard)) && !!(sconst)) && !(!!(tconst)))) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str(cc_lib_strmode(s,(i64)1),NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        msysnewc_m_print_startcon();
        msysnewc_m_print_str(cc_lib_strmode(t,(i64)1),NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        cc_support_terror((byte*)"const to non-const pointer");
    };
    if ((starget == ttarget)) {
        return (i64)1;
    };
    s = starget;
    t = ttarget;
    if (((cc_decls_ttbasetype[(s)] == (i64)1) || (cc_decls_ttbasetype[(t)] == (i64)1))) {
        return (i64)1;
    };
    if ((!!((u64)(cc_decls_ttisref[(s)])) && !!((u64)(cc_decls_ttisref[(t)])))) {
        return cc_parse_checkpointertypes(s,t,hard);
    } else if (((cc_decls_ttbasetype[(s)] == (i64)19) && (cc_decls_ttbasetype[(t)] == (i64)19))) {
        if ((cc_decls_ttlength[(s)] != cc_decls_ttlength[(t)])) {
            if ((!!(cc_decls_ttlength[(s)]) && !!(cc_decls_ttlength[(t)]))) {
                return (i64)0;
            };
        };
        starget = cc_decls_tttarget[(s)];
        ttarget = cc_decls_tttarget[(t)];
        if ((starget == ttarget)) {
            return (i64)1;
        };
        if ((!!((u64)(cc_decls_ttisref[(starget)])) && !!((u64)(cc_decls_ttisref[(ttarget)])))) {
            return cc_parse_checkpointertypes(starget,ttarget,hard);
        };
        if (((cc_decls_ttbasetype[(starget)] == (i64)19) && (cc_decls_ttbasetype[(ttarget)] == (i64)19))) {
            return cc_parse_checkpointertypes(starget,ttarget,hard);
        };
    } else if (((cc_decls_ttbasetype[(s)] == (i64)17) && (cc_decls_ttbasetype[(t)] == (i64)17))) {
        return (i64)1;
    };
    return (i64)0;
}

static i64 cc_parse_comparemode(i64 s,i64 t) {
    if ((s == t)) {
        return (i64)1;
    };
    if (((cc_decls_ttbasetype[(s)] == (i64)19) && (cc_decls_ttbasetype[(s)] == (i64)19))) {
        if ((cc_parse_comparemode(cc_decls_tttarget[(s)],cc_decls_tttarget[(t)]) == (i64)0)) {
            return (i64)0;
        };
        if ((((cc_decls_ttlength[(s)] == (i64)0) || (cc_decls_ttlength[(t)] == (i64)0)) || (cc_decls_ttlength[(s)] == cc_decls_ttlength[(t)]))) {
            return (i64)1;
        };
    };
    return (i64)0;
}

static i64 cc_parse_readenumdecl(struct cc_decls_strec * owner) {
    struct cc_decls_strec *  d;
    struct cc_decls_strec *  e;
    cc_lex_lex();
    if (((i64)((u64)(cc_decls_lx.symbol)) == (i64)17)) {
        cc_parse_readenumnames(owner);
        return (i64)15;
    };
    cc_lib_checksymbol((i64)69);
    d = cc_decls_lx.symptr;
    cc_lex_lex();
    if (((i64)((u64)(cc_decls_lx.symbol)) != (i64)17)) {
        e = cc_lib_checkdupl(owner,d,(i64)2,cc_decls_currblockno);
        if (!!(e)) {
            if (((i64)((u64)((*e).nameid)) != (i64)12)) {
                cc_support_serror_s((byte*)"Enum tag in use %s",(*e).name);
            };
        };
        e = cc_lib_createdupldef(owner,d,(i64)12);
        (*e).mode = cc_lib_createenummode(e);
        (*e).blockno = (u64)(cc_decls_currblockno);
        cc_decls_blockcounts[(cc_decls_currblockno)] = (i64)1;
        return (i64)((*e).mode);
    };
    e = cc_lib_checkdupl(owner,d,(i64)2,cc_decls_currblockno);
    if (!!(e)) {
        if (((i64)((u64)((*e).nameid)) != (i64)12)) {
            cc_support_serror_s((byte*)"Enum tag in use %s",(*e).name);
        };
        if (!!((*e).deflist)) {
            cc_support_serror_s((byte*)"Redefining enum %s",(*e).name);
        };
    } else {
        e = cc_lib_createdupldef(owner,d,(i64)12);
        (*e).mode = cc_lib_createenummode(e);
        (*e).blockno = (u64)(cc_decls_currblockno);
        cc_decls_blockcounts[(cc_decls_currblockno)] = (i64)1;
    };
    cc_parse_readenumnames(owner);
    cc_decls_ttnamedef[((i64)((*e).mode))] = e;
    return (i64)((*e).mode);
}

static void cc_parse_readenumnames(struct cc_decls_strec * owner) {
    struct cc_decls_strec *  d;
    struct cc_decls_strec *  ulist;
    struct cc_decls_strec *  ulistx;
    i64 enumseq;
    ulist = (ulistx = (struct cc_decls_strec *)(0));
    enumseq = (i64)0;
    cc_lex_lex();
    if (((i64)((*owner).nameid)==(i64)6) || ((i64)((*owner).nameid)==(i64)3)) {
    } else {
        owner = (!!(cc_decls_currproc)?cc_decls_currproc:cc_decls_stmodule);
    };
    L740 :;
    while (((i64)((u64)(cc_decls_lx.symbol)) == (i64)69)) {
        d = cc_lib_checkdupl(owner,cc_decls_lx.symptr,(i64)1,cc_decls_currblockno);
        if (!!(d)) {
            cc_support_serror_s((byte*)"enum name reused %s",(*d).name);
        };
        d = cc_lib_createdupldef(owner,cc_decls_lx.symptr,(i64)11);
        cc_lex_lex();
        if (((i64)((u64)(cc_decls_lx.symbol)) == (i64)11)) {
            cc_lex_lex();
            enumseq = cc_parse_readconstintexpr();
        };
        (*d).index = enumseq;
        (*d).blockno = (u64)(cc_decls_currblockno);
        cc_decls_blockcounts[(cc_decls_currblockno)] = (i64)1;
        ++enumseq;
        if (((i64)((u64)(cc_decls_lx.symbol)) == (i64)8)) {
            cc_lex_lex();
        };
L741 :;
    }L742 :;
    ;
    cc_lib_skipsymbol((i64)18);
}

static struct cc_decls_unitrec * cc_parse_createdotop(i64 opc,struct cc_decls_unitrec * p,struct cc_decls_strec * d) {
    struct cc_decls_unitrec *  poffset;
    struct cc_decls_strec *  f;
    struct cc_decls_strec *  prec;
    struct cc_decls_strec *  gend;
    i64 m;
    i64 offset;
    struct cc_decls_fieldrec *  fl;
    m = (i64)((*p).mode);
    if ((opc == (i64)51)) {
        if (!(!!((u64)(cc_decls_ttisref[(m)])))) {
            cc_support_serror((byte*)"-> needs pointer");
        };
        m = cc_decls_tttarget[(m)];
    };
    if ((cc_decls_ttbasetype[(m)]==(i64)20) || (cc_decls_ttbasetype[(m)]==(i64)21)) {
    } else {
        cc_support_serror((byte*)". -> not a struct");
    };
    prec = cc_decls_ttnamedef[(m)];
    f = d;
    L743 :;
    while (!!((f = (*f).nextdupl))) {
        if (((*f).owner == prec)) {
            offset = (*f).offset;
            goto L745 ;
        };
L744 :;
    }L745 :;
    ;
    if (!(!!(f))) {
        gend = d;
        L746 :;
        while (!!((*gend).prevdupl)) {
            gend = (*gend).prevdupl;
L747 :;
        }L748 :;
        ;
        fl = (*prec).nextfield;
        L749 :;
        while (!!(fl)) {
            if (((*fl).gendef == gend)) {
                f = (*fl).def;
                offset = (*fl).offset;
                goto L751 ;
            };
            fl = (*fl).nextfield;
L750 :;
        }L751 :;
        ;
    };
    if (!(!!(f))) {
        cc_support_terror_ss((byte*)"Not a field of struct %s %s",(*d).name,cc_lib_strmode(m,(i64)1));
    };
    poffset = cc_lib_createconstunit((u64)(offset),(i64)4);
    if ((opc == (i64)51)) {
        p = cc_parse_createptrop(p);
    };
    p = cc_lib_createunit1((i64)50,p);
    (*p).offset = offset;
    (*p).mode = (i64)((*f).mode);
    p = cc_parse_arraytopointer(p);
    cc_parse_fixmemopnd(p);
    return p;
}

static struct cc_decls_unitrec * cc_parse_mulunit(struct cc_decls_unitrec * p,i64 elemtype) {
    i64 elemsize;
    if (((elemsize = cc_decls_ttsize[(elemtype)]) != (i64)1)) {
        if (((i64)((*p).tag) == (i64)1)) {
            (*p).value = ((*p).value * elemsize);
        } else {
            p = cc_lib_createunit1((i64)58,p);
            (*p).scale = elemsize;
            (*p).mode = (i64)5;
        };
    };
    return p;
}

static struct cc_decls_unitrec * cc_parse_divunit(struct cc_decls_unitrec * p,i64 elemtype) {
    i64 elemsize;
    if (((elemsize = cc_decls_ttsize[(elemtype)]) != (i64)1)) {
        if (((i64)((*p).tag) == (i64)1)) {
            (*p).value = ((*p).value / elemsize);
        } else {
            p = cc_lib_createunit1((i64)58,p);
            (*p).scale = -(elemsize);
            (*p).mode = (i64)5;
        };
    };
    return p;
}

static struct cc_decls_unitrec * cc_parse_createassignopref(i64 opc,struct cc_decls_unitrec * p,struct cc_decls_unitrec * q) {
    i64 pmode;
    i64 qmode;
    i64 rmode;
    i64 elemmode;
    struct cc_decls_unitrec *  r;
    pmode = (rmode = (i64)((*p).mode));
    elemmode = cc_decls_tttarget[(pmode)];
    qmode = (i64)((*q).mode);
    if ((opc==(i64)11)) {
        q = cc_parse_coercemode(q,pmode);
        r = cc_lib_createunit2((i64)12,p,q);
    }else if ((opc==(i64)46)) {
        if (!!((u64)(cc_decls_ttisref[(qmode)]))) {
            cc_support_serror((byte*)"ptr+=ptr");
        };
        q = cc_parse_coercemode(q,(i64)5);
        r = cc_lib_createunit2((i64)62,p,cc_parse_mulunit(q,elemmode));
    }else if ((opc==(i64)47)) {
        if (!!((u64)(cc_decls_ttisref[(qmode)]))) {
            if (!(!!(cc_parse_comparemode(pmode,qmode)))) {
                cc_support_serror((byte*)"-= refs don't match");
            };
            r = cc_parse_divunit(cc_lib_createunit2((i64)41,p,q),elemmode);
            rmode = (i64)4;
        } else {
            r = cc_lib_createunit2((i64)63,p,cc_parse_mulunit(q,elemmode));
        };
    } else {
        cc_support_serror((byte*)"Not allowed on ptrs");
    };
    (*r).mode = rmode;
    return r;
}

static void cc_parse_addnewfield(struct cc_decls_fieldrec * * flist,struct cc_decls_strec * d,i64 offset) {
    struct cc_decls_strec *  e;
    struct cc_decls_fieldrec *  f;
    if (((u64)((*(*d).name)) != '$')) {
        f = (struct cc_decls_fieldrec *)(mlib_pcm_allocz((i64)32));
        (*f).def = d;
        L752 :;
        while (!!((*d).prevdupl)) {
            d = (*d).prevdupl;
L753 :;
        }L754 :;
        ;
        (*f).gendef = d;
        (*f).offset = offset;
        (*f).nextfield = (*flist);
        (*flist) = f;
    } else {
        e = (*cc_decls_ttnamedef[((i64)((*d).mode))]).deflist;
        L755 :;
        while (!!(e)) {
            cc_parse_addnewfield(flist,e,(offset + (*e).offset));
            e = (*e).nextdef;
L756 :;
        }L757 :;
        ;
    };
}

static void cc_parse_pushloop(i64 looptype) {
    if ((cc_parse_loopindex >= (i64)100)) {
        cc_support_serror((byte*)"Too many nested loop or switch");
    };
    ++cc_parse_loopindex;
    cc_parse_looptypestack[(cc_parse_loopindex)-1] = (u64)(looptype);
    cc_parse_casevaluestack[(cc_parse_loopindex)-1] = (struct cc_decls_caserec *)(0);
}

static void cc_parse_poploop(void) {
    if (!!(cc_parse_loopindex)) {
        --cc_parse_loopindex;
    } else {
        cc_support_serror((byte*)"poploop?");
    };
}

static void cc_parse_addcasevalue(i64 value) {
    struct cc_decls_caserec *  p;
    i64 index;
    index = cc_parse_loopindex;
    L758 :;
    while ((!!(index) && ((u64)(cc_parse_looptypestack[(index)-1]) != (u64)83u))) {
        --index;
L759 :;
    }L760 :;
    ;
    if ((index == (i64)0)) {
        cc_support_serror((byte*)"case not inside switch stmt");
    };
    p = (struct cc_decls_caserec *)(mlib_pcm_alloc((i64)16));
    (*p).value = value;
    (*p).nextcase = cc_parse_casevaluestack[(index)-1];
    cc_parse_casevaluestack[(index)-1] = p;
}

static i64 cc_parse_roundoffset(i64 offset,i64 alignment) {
    i64 mask;
    if (!!(cc_decls_structpadding)) {
        if ((alignment == (i64)1)) {
            return offset;
        };
        mask = (alignment - (i64)1);
        L761 :;
        while (!!((offset & mask))) {
            ++offset;
L762 :;
        }L763 :;
        ;
    };
    return offset;
}

static void cc_parse_fixmemopnd(struct cc_decls_unitrec * p) {
    i64 t;
    if (!!((u64)(cc_parse_ingeneric))) {
        return;
    };
    if (((t = cc_decls_ttbasetype[((i64)((*p).mode))])==(i64)2) || ((t = cc_decls_ttbasetype[((i64)((*p).mode))])==(i64)3)) {
        cc_parse_insertunit(p,(i64)4);
        (*p).mode = (i64)4;
    }else if (((t = cc_decls_ttbasetype[((i64)((*p).mode))])==(i64)7) || ((t = cc_decls_ttbasetype[((i64)((*p).mode))])==(i64)8) || ((t = cc_decls_ttbasetype[((i64)((*p).mode))])==(i64)6)) {
        cc_parse_insertunit(p,(i64)4);
        (*p).mode = (i64)9;
    };
}

static struct cc_decls_unitrec * cc_parse_docast(struct cc_decls_unitrec * p,i64 t,i64 hard,i64 inplace) {
    struct cc_decls_unitrec *  q;
    i64 s;
    i64 opc;
    s = (i64)((*p).mode);
    //retry:
L764 :;
;
    if ((s == t)) {
        return p;
    };
    opc = (i64)0;
    if (((s < (i64)16) && (t < (i64)16))) {
        opc = (i64)(cc_tables_conversionops[(s)][(t)]);
    } else if ((!!((u64)(cc_decls_ttisref[(s)])) && !!((u64)(cc_decls_ttisref[(t)])))) {
        if (!!(cc_parse_checkpointertypes(s,t,hard))) {
            (*p).mode = t;
            return p;
        };
    } else if (!!((u64)(cc_decls_ttconst[(s)]))) {
        s = cc_decls_ttconsttype[(s)];
        goto L764 ;
;
    } else if (!!((u64)(cc_decls_ttconst[(t)]))) {
        t = cc_decls_ttconsttype[(t)];
        goto L764 ;
;
    } else if ((((!!((u64)(cc_decls_ttisref[(t)])) && !!(cc_lib_isintcc(s))) && ((i64)((*p).tag) == (i64)1)) && ((*p).value == (i64)0))) {
        opc = (i64)1;
    };
    if ((opc == (i64)0)) {
        if (!(!!(hard))) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(cc_lib_strmode(s,(i64)1),NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(cc_lib_strmode(t,(i64)1),NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            cc_support_terror_ss((byte*)"Can't do conversion %s => %s",cc_lib_typename(s),cc_lib_typename(t));
        };
        opc = (i64)2;
    };
    if (((i64)((*p).tag)==(i64)1)) {
        if (!!(cc_parse_eval_convert(p,t,opc))) {
            return p;
        };
    }else if (((i64)((*p).tag)==(i64)5)) {
        (*p).mode = t;
        return p;
    }else if (((i64)((*p).tag)==(i64)40)) {
        if ((((i64)((*(*p).a).tag) == (i64)1) && ((i64)((*(*p).b).tag) == (i64)1))) {
            (*p).value = ((*(*p).a).value + (*(*p).b).value);
            (*p).mode = t;
            (*p).tag = (i64)1;
            return p;
        };
    };
    if (!!(inplace)) {
        cc_parse_insertunit(p,(i64)57);
        (*p).mode = t;
        (*p).opcode = opc;
        return (struct cc_decls_unitrec *)(0);
    } else {
        q = cc_lib_createunit1((i64)57,p);
        (*q).opcode = opc;
        (*q).mode = t;
    };
    return q;
}

static struct cc_decls_unitrec * cc_parse_coercemode(struct cc_decls_unitrec * p,i64 t) {
    if (((i64)((*p).mode) == t)) {
        return p;
    };
    cc_parse_docast(p,t,(i64)0,(i64)1);
    return p;
}

static void cc_parse_coercemode_inplace(struct cc_decls_unitrec * p,i64 t) {
    if (((i64)((*p).mode) == t)) {
        return;
    };
    cc_parse_docast(p,t,(i64)0,(i64)1);
}

static void cc_parse_dostaticassert(void) {
    i64 x;
    byte str[256];
    cc_lex_lex();
    cc_lib_skipsymbol((i64)13);
    x = cc_parse_readconstintexpr();
    cc_lib_skipsymbol((i64)8);
    cc_lib_checksymbol((i64)64);
    if (!(!!(x))) {
        memcpy((void *)(str),(void *)(cc_decls_lx.svalue),(u64)(cc_decls_lx.length));
        str[(((i64)(cc_decls_lx.length) + (i64)1))-1] = (u64)0u;
        cc_support_serror(str);
    };
    cc_lex_lex();
    cc_lib_skipsymbol((i64)14);
}

static struct cc_decls_unitrec * cc_parse_createsizeofop(struct cc_decls_unitrec * p) {
    struct cc_decls_unitrec *  q;
    i64 t;
    i64 size;
    t = (i64)((*p).mode);
    switch ((i64)((*p).tag)) {
    case 3:;
    {
        if (!!((i64)((*p).alength))) {
            size = (cc_decls_ttsize[((i64)((*(*p).def).mode))] / (i64)((*p).alength));
        } else {
            size = cc_decls_ttsize[((i64)((*(*p).def).mode))];
        };
    }break;
    case 1:;
    {
        if ((t==cc_decls_trefchar)) {
            size = ((i64)((*p).slength) + (i64)1);
        }else if ((t==cc_decls_trefwchar)) {
            size = (((i64)((*p).wslength) + (i64)1) * (i64)2);
        } else {
            size = cc_decls_ttsize[(t)];
        };
    }break;
    case 53:;
    {
        if ((!!((u64)(cc_decls_ttisref[(t)])) && !!((i64)((*p).alength)))) {
            size = (cc_decls_ttsize[(cc_decls_tttarget[(t)])] * (i64)((*p).alength));
        } else {
            size = cc_decls_ttsize[(t)];
        };
    }break;
    case 54:;
    {
        if (!!((i64)((*p).alength))) {
            size = (cc_decls_ttsize[(cc_decls_tttarget[(t)])] * (i64)((*p).alength));
        } else {
            goto L765 ;
;
        };
    }break;
    case 56:;
    {
        if ((((i64)((*(*p).a).tag) == (i64)3) && !!((i64)((*(*p).a).alength)))) {
            size = cc_decls_ttsize[((i64)((*(*(*p).a).def).mode))];
        };
    }break;
    case 4:;
    {
        return cc_parse_createsizeofop((*p).a);
    }break;
    default: {
        //cad1:
L765 :;
;
        size = cc_decls_ttsize[(t)];
    }
    } //SW
;
    q = cc_lib_createconstunit((u64)(size),(i64)10);
    return q;
}

static struct cc_decls_unitrec * cc_parse_readgeneric(void) {
    struct cc_decls_unitrec *  pexpr;
    struct cc_decls_unitrec *  pmatch;
    struct cc_decls_unitrec *  p;
    struct cc_decls_paramrec *  pm;
    i64 m;
    i64 t;
    i64 def;
    i64 oldingeneric;
    i64 count;
    struct cc_decls_strec *  d;
    cc_lex_lex();
    cc_lib_checksymbol((i64)13);
    cc_lex_lex();
    oldingeneric = (i64)(cc_parse_ingeneric);
    cc_parse_ingeneric = (u64)((i64)1);
    pexpr = cc_parse_readassignexpr();
    cc_parse_ingeneric = (u64)(oldingeneric);
    m = (i64)((*pexpr).mode);
    pmatch = (struct cc_decls_unitrec *)(0);
    def = (i64)0;
    count = (i64)0;
    cc_lib_checksymbol((i64)8);
    L766 :;
    do {
        cc_lex_lex();
        if (((i64)((u64)(cc_decls_lx.symbol)) == (i64)76)) {
            if (!!(def)) {
                cc_support_serror((byte*)"generic/default twice");
            };
            def = (i64)1;
            if ((count == (i64)0)) {
                t = (i64)-1;
            } else {
                t = (i64)-2;
            };
            cc_lex_lex();
        } else {
            t = cc_parse_readcasttype(&d,(i64)0,&pm);
        };
        cc_lib_checksymbol((i64)10);
        cc_lex_lex();
        p = cc_parse_readassignexpr();
        if (((t == (i64)-1) || (t == m))) {
            pmatch = p;
            ++count;
        };
L767 :;
    } while (!((i64)((u64)(cc_decls_lx.symbol)) != (i64)8));L768 :;
    ;
    cc_lib_checksymbol((i64)14);
    cc_lex_lex();
    if (!(!!(pmatch))) {
        cc_support_serror((byte*)"Generic: no type match");
    };
    if ((count > (i64)1)) {
        cc_support_serror((byte*)"Generic: multiple types match");
    };
    return pmatch;
}

static void cc_parse_readstructinfosym(void) {
    struct cc_decls_strec *  d;
    struct cc_decls_strec *  e;
    struct cc_decls_paramrec *  pm;
    i64 m;
    i64 nfields;
    void *  f;
    byte *  name;
    byte str[256];
    cc_lex_lex();
    m = cc_parse_readcasttype(&d,(i64)0,&pm);
    if ((cc_decls_ttbasetype[(m)] != (i64)20)) {
        cc_support_serror((byte*)"Struct type expected");
    };
    d = cc_decls_tttypedef[(m)];
    e = (*d).deflist;
    nfields = (i64)0;
    L769 :;
    while (!!(e)) {
        ++nfields;
        e = (*e).nextdef;
L770 :;
    }L771 :;
    ;
    name = (*d).name;
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_str((byte*)"$",NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_str(name,NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_str((byte*)"_info.h",NULL);
    msysnewc_m_print_end();
    ;
    f = fopen((i8 *)(str),(i8 *)((byte*)"w"));
    msysnewc_m_print_startfile(f);
    msysnewc_m_print_str((byte*)"memberinfo_t $",NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_str(name,NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_str((byte*)"[] = {",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    e = (*cc_decls_ttnamedef[(m)]).deflist;
    nfields = (i64)0;
    L772 :;
    while (!!(e)) {
        msysnewc_m_print_startfile(f);
        msysnewc_m_print_str((byte*)"    {\"#\", #,#,#,#,#,#}#",NULL);
        msysnewc_m_print_str((*e).name,NULL);
        msysnewc_m_print_i64((*e).mode,NULL);
        msysnewc_m_print_i64(cc_decls_ttbasetype[((i64)((*e).mode))],NULL);
        msysnewc_m_print_i64(cc_decls_tttarget[((i64)((*e).mode))],NULL);
        msysnewc_m_print_i64(cc_decls_ttsize[((i64)((*e).mode))],NULL);
        msysnewc_m_print_i64((*e).offset,NULL);
        msysnewc_m_print_i64((i64)0,NULL);
        msysnewc_m_print_str((!!((*e).nextdef)?(byte*)",":(byte*)""),NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        ++nfields;
        e = (*e).nextdef;
L773 :;
    }L774 :;
    ;
    msysnewc_m_print_startfile(f);
    msysnewc_m_print_str((byte*)"};",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startfile(f);
    msysnewc_m_print_str((byte*)"enum {$#_length = #};",NULL);
    msysnewc_m_print_str(name,NULL);
    msysnewc_m_print_i64(nfields,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    fclose(f);
}

static i64 cc_parse_getmemmode(struct cc_decls_unitrec * p) {
    if (((i64)((*p).tag) == (i64)4)) {
        return (i64)((*(*p).a).mode);
    } else {
        return (i64)((*p).mode);
    };
}

static struct cc_decls_unitrec * cc_parse_readstrinclude(void) {
    struct cc_decls_unitrec *  p;
    byte *  text;
    cc_lex_lex();
    cc_lib_checksymbol((i64)13);
    cc_lex_lex();
    p = cc_parse_readexpression();
    cc_lib_checksymbol((i64)14);
    cc_lex_lex();
    if ((((i64)((*p).tag) != (i64)1) || ((i64)((*p).mode) != cc_decls_trefchar))) {
        cc_support_serror((byte*)"String const expected");
    };
    text = (byte *)(mlib_readfile((*p).svalue));
    if (!(!!(text))) {
        cc_support_serror_s((byte*)"Can't read strinclude file: %s",(*p).svalue);
    };
    return cc_lib_createstringconstunit(text,(i64)(strlen((i8 *)(text))));
}

i64 cc_genmcl_codegen_mcl(i64 n) {
    struct cc_decls_strec *  d;
    struct cc_decls_strec *  e;
    cc_libmcl_mclinit();
    cc_decls_stmodule = cc_decls_moduletable[(n)].stmodule;
    d = (*cc_decls_stmodule).deflist;
    L775 :;
    while (!!(d)) {
        if (((i64)((*d).nameid)==(i64)7)) {
            cc_genmcl_dostaticvar(d);
        }else if (((i64)((*d).nameid)==(i64)6)) {
            e = (*d).deflist;
            L778 :;
            while (!!(e)) {
                if (((i64)((*e).nameid)==(i64)7)) {
                    cc_genmcl_dostaticvar_fn(e);
                }else if (((i64)((*e).nameid)==(i64)8)) {
                    if (!!((*e).code)) {
                        if ((((i64)((*(*e).code).tag) == (i64)29) || ((cc_decls_ttbasetype[((i64)((*e).mode))] == (i64)19) && ((i64)((*(*e).code).tag) == (i64)1)))) {
                            cc_genmcl_dostaticvar_fn(e);
                        };
                    };
                };
                e = (*e).nextdef;
L779 :;
            }L780 :;
            ;
        };
        d = (*d).nextdef;
L776 :;
    }L777 :;
    ;
    cc_libmcl_modulecode = cc_libmcl_mccode;
    d = (*cc_decls_stmodule).deflist;
    L781 :;
    while (!!(d)) {
        if (((i64)((*d).nameid)==(i64)6)) {
            if (!!((*d).code)) {
                cc_genmcl_genprocdef(d);
            };
        };
        d = (*d).nextdef;
L782 :;
    }L783 :;
    ;
    return (i64)1;
}

static void cc_genmcl_genprocdef(struct cc_decls_strec * p) {
    byte str[256];
    i64 paramoffset;
    i64 nparams;
    struct cc_decls_strec *  d;
    i64 n;
    i64 lab;
    i64 np;
    i64 offset;
    i64 i;
    i64 ismain;
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  bx;
    i64 paramtypes[4];
    cc_libmcl_setsegment((i64)67,(i64)1);
    cc_libmcl_initmcdest();
    cc_libmcl_setalign((i64)16);
    cc_libmcl_genassem((byte*)"!------------------------------------");
    cc_decls_currproc = p;
    cc_genmcl_dolabel(p);
    cc_libmcl_frameoffset = (i64)0;
    paramoffset = (i64)16;
    nparams = (i64)0;
    d = (*p).deflist;
    L784 :;
    while (!!(d)) {
        switch ((i64)((*d).nameid)) {
        case 8:;
        {
            cc_libmcl_frameoffset -= cc_libmcl_roundsizetg(cc_decls_ttsize[((i64)((*d).mode))]);
            (*d).offset = cc_libmcl_frameoffset;
        }break;
        case 9:;
        {
            (*d).offset = paramoffset;
            paramoffset += (i64)8;
            ++nparams;
            if ((nparams <= (i64)4)) {
                paramtypes[(nparams)-1] = (i64)((*d).mode);
            };
        }break;
        default: {
        }
        } //SW
;
        d = (*d).nextdef;
L785 :;
    }L786 :;
    ;
    cc_libmcl_structretoffset = (i64)0;
    cc_libmcl_stacksetinstr = (struct cc_libmcl_mclrec *)(0);
    cc_libmcl_retbeforeblock = (i64)0;
    if ((cc_decls_ttsize[((i64)((*p).mode))] > (i64)8)) {
        cc_libmcl_frameoffset -= (i64)8;
        cc_libmcl_structretoffset = cc_libmcl_frameoffset;
    };
    cc_libmcl_currblocksize = (i64)0;
    cc_libmcl_framebytes = -(cc_libmcl_frameoffset);
    cc_libmcl_parambytes = (paramoffset - (i64)16);
    cc_libmcl_iscallbackproc = cc_libmcl_iscallbackfn(p);
    n = (i64)7;
    L787 :;
    while (!!((cc_libmcl_framebytes & n))) {
        ++cc_libmcl_framebytes;
        --cc_libmcl_frameoffset;
L788 :;
    }L789 :;
    ;
    L790 :;
    while (!!((cc_libmcl_parambytes & n))) {
        ++cc_libmcl_parambytes;
L791 :;
    }L792 :;
    ;
    cc_libmcl_setsegment((i64)67,(i64)1);
    ismain = (i64)0;
    if (!!(mlib_eqstring((*p).name,(byte*)"main"))) {
        ismain = (i64)1;
        if (!!(cc_libmcl_parambytes)) {
            cc_genmcl_genmainprelude();
        };
        if (((i64)((*p).mode) != (i64)4)) {
            cc_support_gerror((byte*)"main needs int return type",(struct cc_decls_unitrec *)(0));
        };
    };
    cc_genmcl_genprocentry(cc_libmcl_framebytes,cc_libmcl_parambytes);
    if (!!(nparams)) {
        np = ((i64)4<nparams?(i64)4:nparams);
        if (((i64)((*(*p).paramlist).flags) == (i64)3)) {
            L793 :;
            for (i=(np + (i64)1);i<=(i64)4;i+=(i64)1) {
L794 :;
                paramtypes[(i)-1] = (i64)1;
L795 :;
            }L796 :;
            ;
            np = (i64)4;
        };
        offset = (i64)16;
        L797 :;
        for (i=(i64)1;i<=np;i+=(i64)1) {
L798 :;
            ax = cc_libmcl_genireg((i64)15,(i64)8);
            (*ax).value = offset;
            (*ax).valtype = (u64)((i64)1);
            if (!!(cc_lib_isrealcc(paramtypes[(i)-1]))) {
                cc_libmcl_genmc((i64)10,ax,cc_libmcl_genxreg((((i64)1 + i) - (i64)1),cc_decls_ttsize[(paramtypes[(i)-1])]));
            } else {
                cc_libmcl_genmc((i64)5,ax,cc_libmcl_genreg((((i64)11 + i) - (i64)1),(i64)8));
            };
            offset += (i64)8;
L799 :;
        }L800 :;
        ;
    };
    if (!!(cc_libmcl_structretoffset)) {
        bx = cc_libmcl_genindex((i64)15,(i64)0,(i64)1,cc_libmcl_structretoffset,(i64)0,(i64)0,(struct cc_decls_strec *)(0));
        cc_libmcl_genmc((i64)5,bx,cc_libmcl_genreg((i64)10,(i64)8));
    };
    if (!!(cc_libmcl_iscallbackproc)) {
        strcpy((i8 *)(str),(i8 *)((byte*)"m$pushcallback*"));
        cc_libmcl_genmc((i64)15,cc_libmcl_genname(str),(struct cc_libmcl_opndrec *)(0));
    };
    cc_libmcl_stackaligned = (i64)1;
    cc_libmcl_retindex = (lab = cc_libmcl_createfwdlabel());
    cc_libmcl_gencomment((byte*)"-------------------------------------------------");
    cc_libmcl_enterproc((*p).name);
    cc_blockmcl_do_stmt((*p).code);
    cc_libmcl_definefwdlabel(cc_libmcl_retindex);
    cc_libmcl_gencomment((byte*)"-------------------------------------------------");
    if (!!(ismain)) {
        cc_libmcl_pushstack((i64)32);
        cc_libmcl_genmc((i64)5,cc_libmcl_genreg((i64)11,(i64)8),cc_libmcl_genint((i64)0,(i64)4));
        cc_libmcl_genmc((i64)15,cc_libmcl_genname((byte*)"exit*"),(struct cc_libmcl_opndrec *)(0));
    } else {
        cc_libmcl_leaveproc((*p).name);
        cc_libmcl_genreturn(cc_libmcl_framebytes,cc_libmcl_parambytes);
    };
    if (((i64)((*p).mode) != (i64)1)) {
        if (!(!!(cc_genmcl_checkblockreturn((*p).code)))) {
            if (!(!!(mlib_eqstring((*p).name,(byte*)"main")))) {
                cc_support_gerror_s((byte*)"Function needs explicit return statement: %s",(*p).name,(struct cc_decls_unitrec *)(0));
            };
        };
    };
    cc_libmcl_gencomment((byte*)"");
    (*p).mclcode = (void *)(cc_libmcl_mccode);
}

static i64 cc_genmcl_checkblockreturn(struct cc_decls_unitrec * p) {
    struct cc_decls_unitrec *  e;
    i64 m;
    if (!(!!(cc_decls_fmodern))) {
        return (i64)1;
    };
    if ((p == 0)) {
        return (i64)0;
    };
    m = (i64)((*p).mode);
    if (((i64)((*p).tag)==(i64)10)) {
        return (i64)1;
    }else if (((i64)((*p).tag)==(i64)13)) {
        return (!!(cc_genmcl_checkblockreturn((*p).b)) && !!(cc_genmcl_checkblockreturn((*p).c)));
    }else if (((i64)((*p).tag)==(i64)23)) {
        return (i64)1;
        return cc_genmcl_checkblockreturn((*p).b);
    }else if (((i64)((*p).tag)==(i64)6)) {
        e = (*p).a;
        if (!!(e)) {
            L801 :;
            while ((!!(e) && !!((*e).nextunit))) {
                e = (*e).nextunit;
L802 :;
            }L803 :;
            ;
            return cc_genmcl_checkblockreturn(e);
        };
    }else if (((i64)((*p).tag)==(i64)18)) {
        return cc_genmcl_checkblockreturn((*p).a);
    }else if (((i64)((*p).tag)==(i64)17) || ((i64)((*p).tag)==(i64)15) || ((i64)((*p).tag)==(i64)16)) {
        return (i64)1;
    };
    return (i64)0;
}

static void cc_genmcl_dolabel(struct cc_decls_strec * d) {
    byte str[256];
    strcpy((i8 *)(str),(i8 *)((byte*)"`"));
    strcat((i8 *)(str),(i8 *)(cc_libmcl_getfullname(d)));
    strcat((i8 *)(str),(!!(cc_lib_isexported(d))?(i8 *)((byte*)"::"):(i8 *)((byte*)":")));
    cc_libmcl_genmc((i64)4,cc_libmcl_genname(str),(struct cc_libmcl_opndrec *)(0));
}

static void cc_genmcl_dolabel_fn(struct cc_decls_strec * d,i64 dollar) {
    byte str[256];
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_setfmt((byte*)"`##.#.#:");
    msysnewc_m_print_str((!!(dollar)?(byte*)"$":(byte*)""),NULL);
    msysnewc_m_print_str((*(*d).owner).name,NULL);
    msysnewc_m_print_str((*d).name,NULL);
    msysnewc_m_print_u64((*d).blockno,NULL);
    msysnewc_m_print_end();
    ;
    cc_libmcl_genmc((i64)4,cc_libmcl_genname(str),(struct cc_libmcl_opndrec *)(0));
}

static void cc_genmcl_dostaticvar(struct cc_decls_strec * d) {
    i64 align;
    if (((i64)((*d).scope)==(i64)3)) {
        return;
    };
    align = cc_lib_getalignment((i64)((*d).mode));
    if (!!((*d).code)) {
        cc_libmcl_setsegment((i64)73,align);
        cc_genmcl_dolabel(d);
        cc_genmcl_genidata((*d).code,(i64)1,(i64)1,(i64)0);
    } else {
        cc_libmcl_setsegment((i64)90,align);
        cc_genmcl_dolabel(d);
        cc_libmcl_genmc((i64)57,cc_libmcl_genint(cc_decls_ttsize[((i64)((*d).mode))],(i64)4),(struct cc_libmcl_opndrec *)(0));
    };
}

static void cc_genmcl_dostaticvar_fn(struct cc_decls_strec * d) {
    i64 align;
    if (((i64)((*d).scope)==(i64)3)) {
        cc_genmcl_dostaticvar(d);
        return;
    };
    align = cc_lib_getalignment((i64)((*d).mode));
    if (!!((*d).code)) {
        cc_libmcl_setsegment((i64)73,align);
        cc_genmcl_dolabel_fn(d,((i64)((u64)((*d).nameid)) == (i64)8));
        cc_genmcl_genidata((*d).code,(i64)1,(i64)1,(i64)0);
    } else {
        cc_libmcl_setsegment((i64)90,align);
        cc_genmcl_dolabel_fn(d,(i64)0);
        cc_libmcl_genmc((i64)57,cc_libmcl_genint(cc_decls_ttsize[((i64)((*d).mode))],(i64)4),(struct cc_libmcl_opndrec *)(0));
    };
}

static void cc_genmcl_genprocentry(i64 fbytes,i64 pbytes) {
    if ((!!(fbytes) || !!(pbytes))) {
        cc_libmcl_genmc((i64)6,cc_libmcl_dframeopnd,(struct cc_libmcl_opndrec *)(0));
        cc_libmcl_genmc((i64)5,cc_libmcl_dframeopnd,cc_libmcl_dstackopnd);
        if (!!(fbytes)) {
            cc_libmcl_pushstack(cc_libmcl_roundto(fbytes,(i64)16));
        };
    } else {
        cc_libmcl_pushstack((i64)8);
    };
    cc_libmcl_stacksetinstr = cc_libmcl_mccodex;
}

static void cc_genmcl_genidata(struct cc_decls_unitrec * p,i64 doterm,i64 am,i64 offset) {
    i64 t;
    i64 length;
    i64 n;
    i64 i;
    i64 offset1;
    i64 offset2;
    i64 size;
    i64 padding;
    i64 isunion;
    struct cc_decls_unitrec *  q;
    struct cc_decls_unitrec *  a;
    struct cc_decls_unitrec *  b;
    struct cc_decls_strec *  d;
    float sx;
    byte str[256];
    byte str2[16];
    struct cc_libmcl_opndrec *  ax;
    i64 av_1;
    i64 av_2;
    t = (i64)((*p).mode);
    a = (*p).a;
    b = (*p).b;
    if (((i64)((*p).tag)==(i64)29)) {
        n = (i64)((*p).count);
        if ((cc_decls_ttbasetype[(t)] == (i64)19)) {
            length = cc_decls_ttlength[(t)];
            q = a;
            L804 :;
            for (i=(i64)1;i<=n;i+=(i64)1) {
L805 :;
                cc_genmcl_genidata(q,(i64)1,(i64)1,(i64)0);
                q = (*q).nextunit;
L806 :;
            }L807 :;
            ;
            if ((n < length)) {
                n = ((length - n) * cc_decls_ttsize[(cc_decls_tttarget[(t)])]);
                L808 :;
                while ((n >= (i64)8)) {
                    cc_libmcl_genmc((i64)61,cc_libmcl_genint((i64)0,(i64)8),(struct cc_libmcl_opndrec *)(0));
                    n -= (i64)8;
L809 :;
                }L810 :;
                ;
                av_1 = n;
                while (av_1-- > 0) {
L811 :;
                    cc_libmcl_genmc((i64)58,cc_libmcl_genint((i64)0,(i64)4),(struct cc_libmcl_opndrec *)(0));
L812 :;
                }L813 :;
                ;
            };
        } else {
            isunion = (cc_decls_ttbasetype[(t)] == (i64)21);
            d = (*cc_decls_ttnamedef[(t)]).deflist;
            size = cc_decls_ttsize[(t)];
            offset1 = (offset2 = (i64)0);
            q = a;
            L814 :;
            for (i=(i64)1;i<=n;i+=(i64)1) {
L815 :;
                cc_genmcl_genidata(q,(i64)0,(i64)1,(i64)0);
                if (((cc_decls_ttbasetype[((i64)((*q).mode))] == (i64)16) && !!((u64)((*q).strarray)))) {
                    offset1 += (i64)((*q).slength);
                } else {
                    offset1 += cc_decls_ttsize[((i64)((*q).mode))];
                };
                d = (*d).nextdef;
                if ((!!(d) && !(!!(isunion)))) {
                    offset2 = (*d).offset;
                } else {
                    offset2 = size;
                };
                padding = (offset2 - offset1);
                if ((padding > (i64)0)) {
                    padding = (offset2 - offset1);
                    if ((padding > (i64)0)) {
                        cc_libmcl_genmc((i64)57,cc_libmcl_genint(padding,(i64)4),(struct cc_libmcl_opndrec *)(0));
                    };
                    offset1 = offset2;
                };
                q = (*q).nextunit;
L816 :;
            }L817 :;
            ;
            if ((offset2 < size)) {
                n = (size - offset2);
                L818 :;
                while ((n >= (i64)8)) {
                    cc_libmcl_genmc((i64)61,cc_libmcl_genint((i64)0,(i64)8),(struct cc_libmcl_opndrec *)(0));
                    n -= (i64)8;
L819 :;
                }L820 :;
                ;
                av_2 = n;
                while (av_2-- > 0) {
L821 :;
                    cc_libmcl_genmc((i64)58,cc_libmcl_genint((i64)0,(i64)4),(struct cc_libmcl_opndrec *)(0));
L822 :;
                }L823 :;
                ;
            };
        };
        return;
    }else if (((i64)((*p).tag)==(i64)1)) {
        if ((!!(cc_lib_isintcc(t)) || !!(cc_lib_isrealcc(t)))) {
            if ((t == (i64)11)) {
                sx = (float)((*p).xvalue);
                cc_libmcl_genmc((i64)60,cc_libmcl_genint((i64)(*(i32*)&sx),(i64)4),(struct cc_libmcl_opndrec *)(0));
            } else {
                cc_libmcl_genmc((cc_decls_ttsize[(t)]==1?(i64)58:(cc_decls_ttsize[(t)]==2?(i64)59:(cc_decls_ttsize[(t)]==3?(i64)0:(cc_decls_ttsize[(t)]==4?(i64)60:(cc_decls_ttsize[(t)]==5?(i64)0:(cc_decls_ttsize[(t)]==6?(i64)0:(cc_decls_ttsize[(t)]==7?(i64)0:(cc_decls_ttsize[(t)]==8?(i64)61:(i64)0)))))))),cc_libmcl_genint((*p).value,cc_decls_ttsize[(t)]),(struct cc_libmcl_opndrec *)(0));
            };
        } else if ((cc_decls_ttbasetype[(t)] == (i64)16)) {
            padding = (i64)0;
            //doref:
L824 :;
;
            if (((*p).value == (i64)0)) {
                cc_libmcl_genmc((i64)61,cc_libmcl_genint((i64)0,(i64)8),(struct cc_libmcl_opndrec *)(0));
            } else if (!!((u64)((*p).strarray))) {
                if ((cc_decls_ttsize[(cc_decls_tttarget[(t)])] == (i64)1)) {
                    cc_libmcl_genmc((i64)62,cc_libmcl_genstrimm((*p).svalue,(i64)((*p).slength)),(struct cc_libmcl_opndrec *)(0));
                } else {
                    cc_libmcl_genmc((i64)63,cc_libmcl_genwstrimm((*p).wsvalue,(i64)((*p).wslength)),(struct cc_libmcl_opndrec *)(0));
                };
                if ((padding > (i64)0)) {
                    cc_libmcl_genmc((i64)57,cc_libmcl_genint(padding,(i64)4),(struct cc_libmcl_opndrec *)(0));
                };
            } else if (!!((u64)((*p).isstrconst))) {
                cc_libmcl_genmc((i64)61,cc_libmcl_genstrimm((*p).svalue,(i64)((*p).slength)),(struct cc_libmcl_opndrec *)(0));
                if ((padding > (i64)0)) {
                    cc_libmcl_genmc((i64)57,cc_libmcl_genint(padding,(i64)4),(struct cc_libmcl_opndrec *)(0));
                };
            } else if (!!((u64)((*p).iswstrconst))) {
                cc_libmcl_genmc((i64)61,cc_libmcl_genwstrimm((*p).wsvalue,(i64)((*p).wslength)),(struct cc_libmcl_opndrec *)(0));
                if ((padding > (i64)0)) {
                    cc_libmcl_genmc((i64)57,cc_libmcl_genint(padding,(i64)4),(struct cc_libmcl_opndrec *)(0));
                };
            } else {
                cc_libmcl_genmc((i64)61,cc_libmcl_genint((*p).value,(i64)4),(struct cc_libmcl_opndrec *)(0));
            };
        } else if ((cc_decls_ttbasetype[(t)] == (i64)19)) {
            padding = ((cc_decls_ttlength[(t)] - (i64)((*p).slength)) * cc_decls_ttsize[(cc_decls_tttarget[(t)])]);
            goto L824 ;
;
        } else {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(cc_lib_strmode(t,(i64)1),NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            cc_support_gerror((byte*)"IDATA/SCALAR",(struct cc_decls_unitrec *)(0));
        };
        return;
    }else if (((i64)((*p).tag)==(i64)3) || ((i64)((*p).tag)==(i64)5)) {
        d = (*p).def;
        if (((i64)((*d).nameid)==(i64)7) || ((i64)((*d).nameid)==(i64)6)) {
            ax = cc_libmcl_genmemaddr_d(d);
            if (!!(ax)) {
                ax = cc_libmcl_applyoffset(ax,offset,(i64)0);
            };
            cc_libmcl_genmc((((am == (i64)0) || (cc_decls_ttsize[((i64)((*p).mode))] == (i64)8))?(i64)61:(i64)60),ax,(struct cc_libmcl_opndrec *)(0));
        } else {
            cc_support_gerror((byte*)"Idata &frame",p);
        };
        return;
    }else if (((i64)((*p).tag)==(i64)40)) {
        if ((((i64)((*a).tag) == (i64)3) && ((i64)((*b).tag) == (i64)1))) {
            d = (*a).def;
            if (((i64)((*d).nameid)==(i64)7)) {
                strcpy((i8 *)(str),(i8 *)((byte*)"`"));
                if (((i64)((u64)((*d).scope)) == (i64)1)) {
                    strcat((i8 *)(str),(i8 *)((*cc_decls_currproc).name));
                    strcat((i8 *)(str),(i8 *)((byte*)","));
                };
                strcat((i8 *)(str),(i8 *)((*d).name));
                strcat((i8 *)(str),(i8 *)((byte*)"+"));
                msysnewc_getstrint((*b).value,str2);
                strcat((i8 *)(str),(i8 *)(str2));
                cc_libmcl_genmc((i64)61,cc_libmcl_genname(str),(struct cc_libmcl_opndrec *)(0));
            } else {
                cc_support_gerror((byte*)"Add/Idata &frame",(struct cc_decls_unitrec *)(0));
            };
        } else if (((((i64)((*a).tag) == (i64)1) && ((i64)((*b).tag) == (i64)1)) && (cc_decls_ttbasetype[((i64)((*a).mode))] == (i64)16))) {
            msysnewc_m_print_startstr(str);
            msysnewc_m_print_i64((*a).value,NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_str((byte*)"+",NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_i64((*b).value,NULL);
            msysnewc_m_print_end();
            ;
            cc_libmcl_genmc((i64)61,cc_libmcl_genname(str),(struct cc_libmcl_opndrec *)(0));
        } else {
            cc_support_gerror((byte*)"1:Runtime or unsupported expr in static data",(struct cc_decls_unitrec *)(0));
        };
        return;
    }else if (((i64)((*p).tag)==(i64)56)) {
        if (((i64)((*a).tag) == (i64)53)) {
            cc_genmcl_genidata((*a).a,(i64)1,(i64)1,offset);
        } else {
            cc_genmcl_genidata(a,(i64)1,(i64)0,offset);
        };
    }else if (((i64)((*p).tag)==(i64)54) || ((i64)((*p).tag)==(i64)55)) {
        if (((i64)((*b).tag) != (i64)1)) {
            cc_support_gerror((byte*)"Complex ptr expr in static data",(struct cc_decls_unitrec *)(0));
        };
        cc_genmcl_genidata(a,(i64)1,(i64)1,(((*b).value * (i64)((*p).ptrscale)) + offset));
    }else if (((i64)((*p).tag)==(i64)57)) {
        cc_genmcl_genidata(a,(i64)1,(i64)1,offset);
    } else {
        cc_lib_printunit(0,p,(i64)0,(byte*)"*");
        cc_support_gerror((byte*)"2:Runtime expr in static data",p);
    };
}

static void cc_genmcl_genmainprelude(void) {
    cc_libmcl_genassem((byte*)"\tsub\tDstack,152");
    cc_libmcl_genassem((byte*)"\tsub\tDstack,8");
    cc_libmcl_genassem((byte*)"\tlea\tD0,[Dstack+8]");
    cc_libmcl_genassem((byte*)"\tpush\tD0");
    cc_libmcl_genassem((byte*)"\tsub\tDstack,32");
    cc_libmcl_genassem((byte*)"\tlea\tD0,[Dstack+196]");
    cc_libmcl_genassem((byte*)"\tmov\t[Dstack],D0");
    cc_libmcl_genassem((byte*)"\tlea\tD0,[Dstack+184]");
    cc_libmcl_genassem((byte*)"\tmov\t[Dstack+8],D0");
    cc_libmcl_genassem((byte*)"\tlea\tD0,[Dstack+176]");
    cc_libmcl_genassem((byte*)"\tmov\t[Dstack+16],D0");
    cc_libmcl_genassem((byte*)"\tmov\tA0,0");
    cc_libmcl_genassem((byte*)"\tmov\t[Dstack+24],A0");
    cc_libmcl_genassem((byte*)"\tmov\tD10,[Dstack]");
    cc_libmcl_genassem((byte*)"\tmov\tD11,[Dstack+8]");
    cc_libmcl_genassem((byte*)"\tmov\tD12,[Dstack+16]");
    cc_libmcl_genassem((byte*)"\tmov\tD13,[Dstack+24]");
    cc_libmcl_genassem((byte*)"\tcall\t__getmainargs*");
    cc_libmcl_genassem((byte*)"\tadd\tDstack,48");
    cc_libmcl_genassem((byte*)"\tsub\tDstack,32");
    cc_libmcl_genassem((byte*)"\tmov\tA0,[Dstack+180]");
    cc_libmcl_genassem((byte*)"\tmov\t[Dstack],A0");
    cc_libmcl_genassem((byte*)"\tmov\tD0,[Dstack+168]");
    cc_libmcl_genassem((byte*)"\tmov\t[Dstack+8],D0");
    cc_libmcl_genassem((byte*)"\tmov\tD10,[Dstack]");
    cc_libmcl_genassem((byte*)"\tmov\tD11,[Dstack+8]");
    cc_libmcl_genassem((byte*)"\tcall\t.main");
    cc_libmcl_genassem((byte*)"\tmov A10,A0");
    cc_libmcl_genassem((byte*)"\tcall exit*");
    cc_libmcl_gencomment((byte*)"");
    cc_libmcl_genassem((byte*)".main::");
}

void cc_libmcl_mclinit(void) {
    cc_libmcl_zero_opnd = cc_libmcl_genint((i64)0,(i64)4);
    cc_libmcl_zero_unit = cc_lib_createconstunit((u64)((i64)0),(i64)4);
    (*cc_libmcl_zero_unit).mode = (i64)4;
    cc_libmcl_dframeopnd = cc_libmcl_genreg((i64)15,(i64)8);
    cc_libmcl_dstackopnd = cc_libmcl_genreg((i64)16,(i64)8);
    cc_libmcl_initmcdest();
}

i64 cc_libmcl_gettargetdata(i64 f64) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"GETTARGETDATA",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    return (i64)1;
}

void cc_libmcl_initmcdest(void) {
    cc_libmcl_mccode = (cc_libmcl_mccodex = (struct cc_libmcl_mclrec *)(0));
}

void cc_libmcl_genmc(i64 opcode,struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    struct cc_libmcl_mclrec *  m;
    struct cc_libmcl_mclrec *  oldm;
    m = (struct cc_libmcl_mclrec *)(mlib_pcm_alloc((i64)32));
    (*m).lineno = cc_decls_clineno;
    (*m).opcode = (u64)(opcode);
    (*m).a = a;
    (*m).b = b;
    if ((opcode==(i64)5)) {
        if ((((!!(a) && ((i64)((u64)((*a).mode)) == (i64)1)) && !!(b)) && ((i64)((u64)((*b).mode)) == (i64)4))) {
            oldm = cc_libmcl_mccodex;
            if ((((!!(oldm) && ((i64)((u64)((*oldm).opcode)) == (i64)5)) && ((i64)((u64)((*(*oldm).a).mode)) == (i64)4)) && ((i64)((u64)((*(*oldm).b).mode)) == (i64)1))) {
                if ((!!(cc_libmcl_sameoperand(a,(*oldm).b)) && !!(cc_libmcl_sameoperand((*oldm).a,b)))) {
                    return;
                };
            };
        };
    }else if ((opcode==(i64)18)) {
        if (((i64)((*cc_libmcl_mccodex).opcode)==(i64)16) || ((i64)((*cc_libmcl_mccodex).opcode)==(i64)17) || ((i64)((*cc_libmcl_mccodex).opcode)==(i64)18)) {
            return;
        };
    }else if ((opcode==(i64)6) || (opcode==(i64)7)) {
        cc_libmcl_stackaligned ^= (i64)1;
    };
    if (!!(cc_libmcl_mccode)) {
        (*cc_libmcl_mccodex).nextmcl = m;
        cc_libmcl_mccodex = m;
    } else {
        cc_libmcl_mccode = (cc_libmcl_mccodex = m);
    };
}

void cc_libmcl_genmc_cond(i64 opcode,i64 cond,struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    cc_libmcl_genmc(opcode,a,b);
    (*cc_libmcl_mccodex).cond = (u64)(cond);
}

struct cc_libmcl_mclrec * cc_libmcl_lastmc(void) {
    return cc_libmcl_mccodex;
}

void cc_libmcl_genmcstr(i64 opcode,byte * s) {
    cc_libmcl_genmc(opcode,cc_libmcl_genstrimm(s,(i64)-1),(struct cc_libmcl_opndrec *)(0));
}

static struct cc_libmcl_opndrec * cc_libmcl_newopnd(void) {
    struct cc_libmcl_opndrec *  a;
    a = (struct cc_libmcl_opndrec *)(mlib_pcm_allocz((i64)32));
    return a;
}

struct cc_libmcl_opndrec * cc_libmcl_duplopnd(struct cc_libmcl_opndrec * a) {
    struct cc_libmcl_opndrec *  b;
    b = (struct cc_libmcl_opndrec *)(mlib_pcm_alloc((i64)32));
    (*b) = (*a);
    return b;
}

struct cc_libmcl_opndrec * cc_libmcl_genxreg(i64 xreg,i64 size) {
    struct cc_libmcl_opndrec *  a;
    a = cc_libmcl_newopnd();
    (*a).mode = (u64)((i64)6);
    (*a).reg = (u64)(xreg);
    (*a).size = size;
    return a;
}

struct cc_libmcl_opndrec * cc_libmcl_genindex(i64 areg,i64 ireg,i64 scale,i64 offset,i64 size,i64 labno,struct cc_decls_strec * def) {
    struct cc_libmcl_opndrec *  a;
    a = cc_libmcl_newopnd();
    (*a).mode = (u64)((i64)4);
    (*a).reg = (u64)(areg);
    (*a).regix = (u64)(ireg);
    (*a).scale = (u64)(scale);
    (*a).size = (!!(size)?size:scale);
    (*a).value = offset;
    if (!!(offset)) {
        (*a).valtype = (u64)((i64)1);
    };
    (*a).def = def;
    if (!!(labno)) {
        (*a).valtype = (u64)((i64)5);
        (*a).value = labno;
    } else if ((!!(def) && !!(cc_libmcl_isframe(def)))) {
        if (!!(areg)) {
            cc_support_gerror((byte*)"gen/index/areg",(struct cc_decls_unitrec *)(0));
        };
        (*a).reg = (u64)((i64)15);
    };
    return a;
}

static void cc_libmcl_writemclblock(struct cc_libmcl_mclrec * m) {
    i64 i;
    i = (i64)1;
    L825 :;
    while (!!(m)) {
        cc_libmcl_writemcl(i,m);
        ++i;
        m = (*m).nextmcl;
L826 :;
    }L827 :;
    ;
}

struct mlib_strbuffer * cc_libmcl_writemclcode(byte * caption,i64 nmodule) {
    struct cc_decls_strec *  d;
    mlib_gs_init(cc_libmcl_dest);
    mlib_gs_strln(cc_libmcl_dest,caption);
    mlib_gs_strln(cc_libmcl_dest,(byte*)"---------------------------------------------");
    mlib_gs_strln(cc_libmcl_dest,(byte*)"MODULE CODE");
    cc_libmcl_writemclblock(cc_libmcl_modulecode);
    mlib_gs_strln(cc_libmcl_dest,(byte*)"---------------------------------------------");
    d = (*cc_decls_moduletable[(nmodule)].stmodule).deflist;
    L828 :;
    while (!!(d)) {
        if ((((i64)((u64)((*d).nameid)) == (i64)6) && !!((*d).mclcode))) {
            mlib_gs_str(cc_libmcl_dest,(byte*)"PROC:");
            mlib_gs_strln(cc_libmcl_dest,(*d).name);
            cc_libmcl_writemclblock((struct cc_libmcl_mclrec *)((*d).mclcode));
        };
        d = (*d).nextdef;
L829 :;
    }L830 :;
    ;
    mlib_gs_strln(cc_libmcl_dest,(byte*)"---------------------------------------------");
    return cc_libmcl_dest;
}

void cc_libmcl_gencomment(byte * s) {
    if (((s == 0) || ((i64)((*s)) == (i64)0))) {
        cc_libmcl_genmc((i64)2,(struct cc_libmcl_opndrec *)(0),(struct cc_libmcl_opndrec *)(0));
    } else {
        cc_libmcl_genmcstr((i64)1,s);
    };
}

struct cc_libmcl_opndrec * cc_libmcl_genstrimm(byte * s,i64 length) {
    struct cc_libmcl_opndrec *  a;
    a = cc_libmcl_newopnd();
    (*a).mode = (u64)((i64)2);
    if ((length < (i64)0)) {
        length = (i64)(strlen((i8 *)(s)));
    };
    (*a).svalue = (byte *)(mlib_pcm_alloc((length + (i64)1)));
    memcpy((void *)((*a).svalue),(void *)(s),(u64)((length + (i64)1)));
    (*a).valtype = (u64)((i64)3);
    (*a).size = (i64)8;
    (*a).slength = length;
    return a;
}

struct cc_libmcl_opndrec * cc_libmcl_genwstrimm(u16 * s,i64 length) {
    struct cc_libmcl_opndrec *  a;
    a = cc_libmcl_newopnd();
    (*a).mode = (u64)((i64)2);
    (*a).wsvalue = (u16 *)(mlib_pcm_alloc(((length * (i64)2) + (i64)2)));
    memcpy((void *)((*a).wsvalue),(void *)(s),(u64)(((length + (i64)1) * (i64)2)));
    (*a).valtype = (u64)((i64)4);
    (*a).size = (i64)8;
    (*a).slength = length;
    return a;
}

struct cc_libmcl_opndrec * cc_libmcl_genname(byte * s) {
    struct cc_libmcl_opndrec *  a;
    a = cc_libmcl_newopnd();
    (*a).mode = (u64)((i64)2);
    (*a).svalue = mlib_pcm_copyheapstring(s);
    (*a).valtype = (u64)((i64)6);
    (*a).size = (i64)8;
    return a;
}

static void cc_libmcl_writemcl(i64 index,struct cc_libmcl_mclrec * mcl) {
    mlib_gs_strln(cc_libmcl_dest,cc_libmcl_strmcl(mcl));
}

byte * cc_libmcl_strmcl(struct cc_libmcl_mclrec * mcl) {
    static byte str[512];
    byte opnds[512];
    byte opnd2[256];
    byte opcname[128];
    struct cc_libmcl_opndrec *  a;
    struct cc_libmcl_opndrec *  b;
    i64 opcode;
    i64 cond;
    i64 sizepref;
    opcode = (i64)((*mcl).opcode);
    cond = (i64)((*mcl).cond);
    a = (*mcl).a;
    b = (*mcl).b;
    if ((opcode==(i64)67)) {
        return (*a).svalue;
    }else if ((opcode==(i64)2)) {
        return (byte*)"";
    }else if ((opcode==(i64)1)) {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_str((byte*)";",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str((*a).svalue,NULL);
        msysnewc_m_print_end();
        ;
        return str;
    }else if ((opcode==(i64)4)) {
        strcpy((i8 *)(str),(i8 *)((*a).svalue));
        return str;
    }else if ((opcode==(i64)3)) {
        if (!!(b)) {
            msysnewc_m_print_startstr(str);
            msysnewc_m_print_setfmt((byte*)"L#:#\t<#>");
            msysnewc_m_print_i64((*a).value,NULL);
            msysnewc_m_print_str((!!((u64)((*a).isglobal))?(byte*)":":(byte*)""),NULL);
            msysnewc_m_print_str((*(*b).def).name,NULL);
            msysnewc_m_print_end();
            ;
        } else {
            msysnewc_m_print_startstr(str);
            msysnewc_m_print_setfmt((byte*)"L#:#");
            msysnewc_m_print_i64((*a).value,NULL);
            msysnewc_m_print_str((!!((u64)((*a).isglobal))?(byte*)":":(byte*)""),NULL);
            msysnewc_m_print_end();
            ;
        };
        return str;
    };
    if ((opcode==(i64)19)) {
        msysnewc_m_print_startstr(opcname);
        msysnewc_m_print_str((byte*)"j",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str(cc_libmcl_asmcondnames[(cond)],NULL);
        msysnewc_m_print_end();
        ;
    }else if ((opcode==(i64)40)) {
        msysnewc_m_print_startstr(opcname);
        msysnewc_m_print_str((byte*)"set",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str(cc_libmcl_asmcondnames[(cond)],NULL);
        msysnewc_m_print_end();
        ;
    }else if ((opcode==(i64)9)) {
        msysnewc_m_print_startstr(opcname);
        msysnewc_m_print_str((byte*)"cmov",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str(cc_libmcl_asmcondnames[(cond)],NULL);
        msysnewc_m_print_end();
        ;
    } else {
        strcpy((i8 *)(opcname),(i8 *)((cc_libmcl_mclnames[(opcode)-1] + (i64)2)));
    };
    mlib_ipadstr(opcname,(i64)11,(byte*)" ");
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_str((byte*)"\t",NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_str(opcname,NULL);
    msysnewc_m_print_end();
    ;
    if ((!!(a) && !!(b))) {
        sizepref = cc_libmcl_needsizeprefix(opcode,a,b);
        strcpy((i8 *)(opnd2),(i8 *)(cc_libmcl_stropnd(b,sizepref,(i64)0)));
        msysnewc_m_print_startstr(opnds);
        msysnewc_m_print_setfmt((byte*)"#,\t#");
        msysnewc_m_print_str(cc_libmcl_stropnd(a,sizepref,(i64)0),NULL);
        msysnewc_m_print_str(opnd2,NULL);
        msysnewc_m_print_end();
        ;
    } else if ((!!(a) && !!((u64)((*a).mode)))) {
        if ((opcode == (i64)15)) {
            strcpy((i8 *)(opnds),(i8 *)(cc_libmcl_stropnd(a,(i64)0,(i64)0)));
        } else {
            strcpy((i8 *)(opnds),(i8 *)(cc_libmcl_stropnd(a,(i64)1,(i64)0)));
        };
    } else {
        opnds[((i64)1)-1] = (u64)0u;
    };
    if (!!((u64)(opnds[((i64)1)-1]))) {
        strcat((i8 *)(str),(i8 *)(opnds));
    };
    return str;
}

byte * cc_libmcl_stropnd(struct cc_libmcl_opndrec * a,i64 sizeprefix,i64 debug) {
    static byte str[512];
    byte str2[128];
    byte *  plus;
    byte *  t;
    if (((i64)((*a).mode)==(i64)1)) {
        return cc_libmcl_getregname((i64)((*a).reg),(i64)((*a).size));
    }else if (((i64)((*a).mode)==(i64)2)) {
        return cc_libmcl_strvalue(a);
    }else if (((i64)((*a).mode)==(i64)4)) {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_str(cc_libmcl_getsizeprefix((i64)((*a).size),sizeprefix),NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str((byte*)"[",NULL);
        msysnewc_m_print_end();
        ;
        plus = (byte*)"";
        if (!!((u64)((*a).reg))) {
            strcat((i8 *)(str),(i8 *)(cc_libmcl_getregname((i64)((*a).reg),(i64)8)));
            plus = (byte*)"+";
        };
        if (!!((u64)((*a).regix))) {
            strcat((i8 *)(str),(i8 *)(plus));
            strcat((i8 *)(str),(i8 *)(cc_libmcl_getregname((i64)((*a).regix),(i64)8)));
            plus = (byte*)"+";
            if (((i64)((u64)((*a).scale)) > (i64)1)) {
                msysnewc_m_print_startstr(str2);
                msysnewc_m_print_str((byte*)"*",NULL);
                msysnewc_m_print_nogap();
                msysnewc_m_print_u64((*a).scale,NULL);
                msysnewc_m_print_end();
                ;
                strcat((i8 *)(str),(i8 *)(str2));
            };
        };
        if ((!!((*a).def) || !!((u64)((*a).valtype)))) {
            t = cc_libmcl_strvalue(a);
            if (((u64)((*t)) != '-')) {
                strcat((i8 *)(str),(i8 *)(plus));
            };
            strcat((i8 *)(str),(i8 *)(t));
        };
        strcat((i8 *)(str),(i8 *)((byte*)"]"));
    }else if (((i64)((*a).mode)==(i64)3)) {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_setfmt((byte*)"/#/*#");
        msysnewc_m_print_str((*a).svalue,NULL);
        msysnewc_m_print_i64((*a).slength,NULL);
        msysnewc_m_print_end();
        ;
    }else if (((i64)((*a).mode)==(i64)6)) {
        return cc_libmcl_fgetregname((i64)((*a).reg),(i64)((*a).size));
    } else {
        return (byte*)"<BAD OPND>";
    };
    return str;
}

byte * cc_libmcl_strvalue(struct cc_libmcl_opndrec * a) {
    static byte str[512];
    byte str2[128];
    struct cc_decls_strec *  def;
    i64 value;
    def = (*a).def;
    value = (*a).value;
    if (!!(def)) {
        if (((i64)((*def).nameid)==(i64)7)) {
            if (((i64)((u64)((*(*def).owner).nameid)) == (i64)6)) {
                msysnewc_m_print_startstr(str);
                msysnewc_m_print_setfmt((byte*)"`#.#.#");
                msysnewc_m_print_str((*(*def).owner).name,NULL);
                msysnewc_m_print_str((*def).name,NULL);
                msysnewc_m_print_u64((*def).blockno,NULL);
                msysnewc_m_print_end();
                ;
            } else {
                strcpy((i8 *)(str),(i8 *)(cc_libmcl_getfullname(def)));
                if (!!(cc_lib_isimported(def))) {
                    strcat((i8 *)(str),(i8 *)((byte*)"*"));
                };
            };
        }else if (((i64)((*def).nameid)==(i64)8) || ((i64)((*def).nameid)==(i64)9)) {
            strcpy((i8 *)(str),(i8 *)(cc_libmcl_getfullname(def)));
        } else {
            strcpy((i8 *)(str),(i8 *)(cc_libmcl_getfullname(def)));
            if (!!(cc_lib_isimported(def))) {
                strcat((i8 *)(str),(i8 *)((byte*)"*"));
            };
        };
        if ((((i64)((u64)((*a).valtype)) == (i64)1) && (value != (i64)0))) {
            msysnewc_m_print_startstr(str2);
            msysnewc_m_print_str(((value > (i64)0)?(byte*)"+":(byte*)""),NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_i64(value,NULL);
            msysnewc_m_print_end();
            ;
            strcat((i8 *)(str),(i8 *)(str2));
        };
        return str;
    };
    if (((i64)((*a).valtype)==(i64)1) || ((i64)((*a).valtype)==(i64)9)) {
        msysnewc_getstrint(value,str);
    }else if (((i64)((*a).valtype)==(i64)2) || ((i64)((*a).valtype)==(i64)10)) {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_r64((*a).xvalue,NULL);
        msysnewc_m_print_end();
        ;
    }else if (((i64)((*a).valtype)==(i64)3) || ((i64)((*a).valtype)==(i64)7)) {
        if ((((i64)(strlen((i8 *)((*a).svalue))) + (i64)4) < (i64)512)) {
            msysnewc_m_print_startstr(str);
            msysnewc_m_print_setfmt((byte*)"\"#\"*#");
            msysnewc_m_print_str((*a).svalue,NULL);
            msysnewc_m_print_i64((*a).slength,NULL);
            msysnewc_m_print_end();
            ;
        } else {
            return (byte*)"<LONGSTR>";
        };
    }else if (((i64)((*a).valtype)==(i64)4) || ((i64)((*a).valtype)==(i64)8)) {
        return (byte*)"<WSTRING>";
    }else if (((i64)((*a).valtype)==(i64)6)) {
        return (*a).svalue;
    }else if (((i64)((*a).valtype)==(i64)5)) {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_str((byte*)"L",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_i64(value,NULL);
        msysnewc_m_print_end();
        ;
    } else {
        str[((i64)1)-1] = (u64)0u;
    };
    return str;
}

void cc_libmcl_setsegment(i64 seg,i64 align) {
    if ((seg == cc_libmcl_currsegment)) {
        return;
    };
    if ((seg==(i64)73)) {
        cc_libmcl_genmc((i64)65,cc_libmcl_genname((byte*)"idata"),(struct cc_libmcl_opndrec *)(0));
    }else if ((seg==(i64)90)) {
        cc_libmcl_genmc((i64)65,cc_libmcl_genname((byte*)"zdata"),(struct cc_libmcl_opndrec *)(0));
    }else if ((seg==(i64)67)) {
        cc_libmcl_genmc((i64)65,cc_libmcl_genname((byte*)"code"),(struct cc_libmcl_opndrec *)(0));
    }else if ((seg==(i64)82)) {
        cc_libmcl_genmc((i64)65,cc_libmcl_genname((byte*)"rodata"),(struct cc_libmcl_opndrec *)(0));
    };
    cc_libmcl_currsegment = seg;
    cc_libmcl_currzdataalign = (cc_libmcl_curridataalign = (i64)0);
    cc_libmcl_setalign(align);
}

byte * cc_libmcl_getprocname(struct cc_decls_strec * d) {
    if (!!(mlib_eqstring((*d).name,(byte*)"main"))) {
        return (byte*)"main";
    } else if (!!(mlib_eqstring((*d).name,(byte*)"start"))) {
        return (byte*)"start";
    } else {
        return cc_lib_getdottedname(d);
    };
    return (byte*)"";
}

i64 cc_libmcl_widenstr(byte * s,i64 w) {
    L831 :;
    while (((i64)(strlen((i8 *)(s))) >= (w - (i64)2))) {
        w += (i64)8;
L832 :;
    }L833 :;
    ;
    return w;
}

void cc_libmcl_genassem(byte * s) {
    cc_libmcl_genmcstr((i64)67,s);
}

byte * cc_libmcl_strlabel(i64 n) {
    static byte str[16];
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_str((byte*)"L",NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_i64(n,NULL);
    msysnewc_m_print_end();
    ;
    return str;
}

struct cc_libmcl_opndrec * cc_libmcl_makeindirect(struct cc_libmcl_opndrec * a,i64 size) {
    struct cc_libmcl_opndrec *  b;
    b = cc_libmcl_duplopnd(a);
    if (((i64)((*b).mode)==(i64)1)) {
        (*b).mode = (u64)((i64)4);
    } else {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"STROPND(B)=",NULL);
        msysnewc_m_print_str(cc_libmcl_stropnd(b,(i64)0,(i64)0),NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        cc_support_gerror((byte*)"makeind",(struct cc_decls_unitrec *)(0));
    };
    if (!!(size)) {
        (*b).size = size;
    };
    return b;
}

struct cc_libmcl_opndrec * cc_libmcl_applyoffset(struct cc_libmcl_opndrec * a,i64 offset,i64 size) {
    struct cc_libmcl_opndrec *  b;
    if (((offset == (i64)0) && (size == (i64)0))) {
        return a;
    };
    b = cc_libmcl_duplopnd(a);
    (*b).value += offset;
    (*b).valtype = (u64)((i64)1);
    if (!!(size)) {
        (*b).size = size;
    };
    return b;
}

struct cc_libmcl_opndrec * cc_libmcl_applysize(struct cc_libmcl_opndrec * a,i64 size) {
    if (((i64)((*a).size) != size)) {
        a = cc_libmcl_duplopnd(a);
        (*a).size = size;
    };
    return a;
}

i64 cc_libmcl_isframe(struct cc_decls_strec * d) {
    if (((i64)((*d).nameid)==(i64)8) || ((i64)((*d).nameid)==(i64)9)) {
        return (i64)1;
    };
    return (i64)0;
}

void cc_libmcl_genreturn(i64 fbytes,i64 pbytes) {
    byte str[256];
    i64 iscallback;
    iscallback = cc_libmcl_iscallbackfn(cc_decls_currproc);
    cc_libmcl_retbeforeblock = (i64)1;
    if ((!!(fbytes) || !!(pbytes))) {
        if (!!(fbytes)) {
            cc_libmcl_popstack(cc_libmcl_roundto(fbytes,(i64)16));
        };
        cc_libmcl_genmc((i64)7,cc_libmcl_dframeopnd,(struct cc_libmcl_opndrec *)(0));
        if (!!(iscallback)) {
            strcpy((i8 *)(str),(i8 *)((byte*)"\tcall m$popcallback*"));
            cc_libmcl_genassem(str);
        };
        cc_libmcl_genmc((i64)16,(struct cc_libmcl_opndrec *)(0),(struct cc_libmcl_opndrec *)(0));
    } else {
        if (!!(iscallback)) {
            strcpy((i8 *)(str),(i8 *)((byte*)"\tcall m$popcallback*"));
            cc_libmcl_genassem(str);
        };
        cc_libmcl_popstack((i64)8);
        cc_libmcl_genmc((i64)16,(struct cc_libmcl_opndrec *)(0),(struct cc_libmcl_opndrec *)(0));
    };
    cc_libmcl_stackaligned = (i64)1;
}

byte * cc_libmcl_getsizeprefix(i64 size,i64 enable) {
    if (!(!!(enable))) {
        return (byte*)"";
    };
    if ((size==(i64)1)) {
        return (byte*)"byte ";
    }else if ((size==(i64)2)) {
        return (byte*)"word16 ";
    }else if ((size==(i64)4)) {
        return (byte*)"word32 ";
    }else if ((size==(i64)8)) {
        return (byte*)"word64 ";
    };
    return (byte*)"N:";
}

i64 cc_libmcl_needsizeprefix(i64 opcode,struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    if ((opcode==(i64)12) || (opcode==(i64)11) || (opcode==(i64)74) || (opcode==(i64)73) || (opcode==(i64)89) || (opcode==(i64)90)) {
        return (i64)1;
    }else if ((opcode==(i64)50)) {
        return (i64)1;
    }else if ((opcode==(i64)33) || (opcode==(i64)71) || (opcode==(i64)70)) {
        if (((i64)((u64)((*a).mode)) == (i64)4)) {
            return (i64)1;
        };
        return (i64)0;
    };
    if ((((((i64)((u64)((*a).mode)) == (i64)1) || ((i64)((u64)((*a).mode)) == (i64)6)) || ((i64)((u64)((*b).mode)) == (i64)1)) || ((i64)((u64)((*b).mode)) == (i64)6))) {
        return (i64)0;
    };
    return (i64)1;
}

struct cc_libmcl_opndrec * cc_libmcl_changeopndsize(struct cc_libmcl_opndrec * a,i64 size) {
    struct cc_libmcl_opndrec *  b;
    if (((i64)((*a).size) != size)) {
        b = cc_libmcl_duplopnd(a);
        (*b).size = size;
        return b;
    };
    return a;
}

struct cc_libmcl_opndrec * cc_libmcl_genint(i64 x,i64 size) {
    struct cc_libmcl_opndrec *  a;
    a = cc_libmcl_newopnd();
    (*a).mode = (u64)((i64)2);
    (*a).value = x;
    (*a).valtype = (u64)((i64)1);
    (*a).size = size;
    return a;
}

struct cc_libmcl_opndrec * cc_libmcl_genreal(double x,i64 size) {
    struct cc_libmcl_opndrec *  a;
    a = cc_libmcl_newopnd();
    (*a).mode = (u64)((i64)2);
    (*a).xvalue = x;
    (*a).valtype = (u64)((i64)2);
    (*a).size = size;
    return a;
}

struct cc_libmcl_opndrec * cc_libmcl_genimm(struct cc_decls_unitrec * p,i64 size) {
    struct cc_libmcl_opndrec *  a;
    i64 t;
    a = cc_libmcl_newopnd();
    (*a).mode = (u64)((i64)2);
    if (((i64)((*p).tag)==(i64)1)) {
        t = (i64)((*p).mode);
        if (!!(cc_lib_isintcc(t))) {
            (*a).value = (*p).value;
            (*a).valtype = (u64)((i64)1);
            (*a).size = (!!(size)?size:cc_decls_ttsize[(t)]);
        } else if (!!(cc_lib_isrealcc(t))) {
            (*a).xvalue = (*p).xvalue;
            (*a).valtype = (u64)((i64)2);
            (*a).size = (!!(size)?size:cc_decls_ttsize[(t)]);
        } else {
            cc_support_gerror((byte*)"GENIMM/MODE?",(struct cc_decls_unitrec *)(0));
        };
    }else if (((i64)((*p).tag)==(i64)3)) {
        (*a).def = (*p).def;
        (*a).size = cc_decls_ttsize[((i64)((*(*p).def).mode))];
    } else {
        cc_support_gerror((byte*)"genimm/unit",(struct cc_decls_unitrec *)(0));
    };
    return a;
}

struct cc_libmcl_opndrec * cc_libmcl_genlabel(i64 x,i64 isglobal) {
    struct cc_libmcl_opndrec *  a;
    a = cc_libmcl_newopnd();
    (*a).size = (i64)8;
    (*a).mode = (u64)((i64)2);
    (*a).value = x;
    (*a).valtype = (u64)((i64)5);
    (*a).isglobal = (u64)(isglobal);
    return a;
}

struct cc_libmcl_opndrec * cc_libmcl_genmem_u(struct cc_decls_unitrec * p,i64 size) {
    return cc_libmcl_genmem_d((*p).def,cc_decls_ttsize[((i64)((*p).mode))]);
}

struct cc_libmcl_opndrec * cc_libmcl_genmem_d(struct cc_decls_strec * d,i64 size) {
    struct cc_libmcl_opndrec *  a;
    ++cc_libmcl_nmem;
    a = cc_libmcl_newopnd();
    (*a).mode = (u64)((i64)4);
    if ((!!(cc_libmcl_isframe(d)) && !!(cc_libmcl_fshowfullnames))) {
        (*a).reg = (u64)((i64)15);
    };
    (*a).def = d;
    (*a).size = (!!(size)?size:cc_decls_ttsize[((i64)((*d).mode))]);
    return a;
}

struct cc_libmcl_opndrec * cc_libmcl_genmemaddr_u(struct cc_decls_unitrec * p) {
    return cc_libmcl_genmemaddr_d((*p).def);
}

struct cc_libmcl_opndrec * cc_libmcl_genmemaddr_d(struct cc_decls_strec * d) {
    struct cc_libmcl_opndrec *  a;
    ++cc_libmcl_nmemaddr;
    a = cc_libmcl_newopnd();
    (*a).mode = (u64)((i64)2);
    if ((!!(cc_libmcl_isframe(d)) && !!(cc_libmcl_fshowfullnames))) {
        (*a).reg = (u64)((i64)15);
    };
    (*a).def = d;
    (*a).size = (i64)8;
    return a;
}

struct cc_libmcl_opndrec * cc_libmcl_genreg(i64 reg,i64 size) {
    static i64 isnormal[9] = {(i64)0,(i64)1,(i64)1,(i64)0,(i64)1,(i64)0,(i64)0,(i64)0,(i64)1};
    struct cc_libmcl_opndrec *  a;
    if (((size <= (i64)8) && !!(isnormal[(size)]))) {
        a = cc_libmcl_newopnd();
        (*a).mode = (u64)((i64)1);
        (*a).reg = (u64)(reg);
        (*a).size = size;
    } else {
        cc_support_gerror((byte*)"GENREG/BLOCK SIZE",(struct cc_decls_unitrec *)(0));
    };
    return a;
}

struct cc_libmcl_opndrec * cc_libmcl_genireg(i64 reg,i64 size) {
    struct cc_libmcl_opndrec *  a;
    a = cc_libmcl_newopnd();
    (*a).mode = (u64)((i64)4);
    (*a).reg = (u64)(reg);
    (*a).size = size;
    return a;
}

i64 cc_libmcl_getopndsize_u(struct cc_decls_unitrec * p) {
    return cc_decls_ttsize[((i64)((*p).mode))];
}

i64 cc_libmcl_getopndsize_d(struct cc_decls_strec * d) {
    return cc_decls_ttsize[((i64)((*d).mode))];
}

i64 cc_libmcl_getmclcond(i64 opc,i64 m) {
    i64 signedx;
    signedx = (i64)(cc_tables_stdtypesigned[(cc_decls_ttbasetype[(m)])]);
    if (!!(cc_lib_isrealcc(m))) {
        if ((opc==(i64)36)) {
            return (i64)16;
        }else if ((opc==(i64)37)) {
            return (i64)18;
        }else if ((opc==(i64)39)) {
            return (i64)17;
        }else if ((opc==(i64)38)) {
            return (i64)19;
        }else if ((opc==(i64)34)) {
            return (i64)20;
        }else if ((opc==(i64)35)) {
            return (i64)21;
        };
    } else {
        if ((opc==(i64)36)) {
            return (!!(signedx)?(i64)12:(i64)2);
        }else if ((opc==(i64)37)) {
            return (!!(signedx)?(i64)14:(i64)6);
        }else if ((opc==(i64)39)) {
            return (!!(signedx)?(i64)13:(i64)3);
        }else if ((opc==(i64)38)) {
            return (!!(signedx)?(i64)15:(i64)7);
        }else if ((opc==(i64)34)) {
            return (i64)4;
        }else if ((opc==(i64)35)) {
            return (i64)5;
        };
    };
    return (i64)0;
}

byte * cc_libmcl_getfullname(struct cc_decls_strec * d) {
    return (*d).name;
}

i64 cc_libmcl_roundsizetg(i64 size) {
    L834 :;
    while (!!((size & (i64)7))) {
        ++size;
L835 :;
    }L836 :;
    ;
    return size;
}

i64 cc_libmcl_iscallbackfn(struct cc_decls_strec * p) {
    return (i64)((*p).attribs.ax_callback);
}

byte * cc_libmcl_getregname(i64 reg,i64 size) {
    static byte *  prefix[8] = {(byte*)"B",(byte*)"W",(byte*)"",(byte*)"A",(byte*)"",(byte*)"",(byte*)"",(byte*)"D"};
    static byte str[32];
    byte str2[16];
    byte *  rs;
    if ((size > (i64)8)) {
        return (byte*)"DBIG";
    };
    if ((reg==(i64)0)) {
        return (byte*)"-";
    }else if ((reg==(i64)15)) {
        rs = (byte*)"frame";
    }else if ((reg==(i64)16)) {
        rs = (byte*)"stack";
    } else {
        msysnewc_getstrint((reg - (i64)1),str2);
        rs = str2;
    };
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_str(prefix[(size)-1],NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_str(rs,NULL);
    msysnewc_m_print_end();
    ;
    return str;
}

byte * cc_libmcl_getblockname(i64 reg,i64 size) {
    static byte str[32];
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_setfmt((byte*)"N#(#)");
    msysnewc_m_print_i64((reg - (i64)1),NULL);
    msysnewc_m_print_i64(size,NULL);
    msysnewc_m_print_end();
    ;
    return str;
}

byte * cc_libmcl_fgetregname(i64 reg,i64 size) {
    static byte str[32];
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_str(((size == (i64)8)?(byte*)"DX":(byte*)"SX"),NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_i64((reg - (i64)1),NULL);
    msysnewc_m_print_end();
    ;
    return str;
}

i64 cc_libmcl_issimple(struct cc_decls_unitrec * p) {
    if (!(!!((i64)1))) {
        return (i64)0;
    };
    return cc_libmcl_issimple0(p,(i64)0);
}

static i64 cc_libmcl_issimple0(struct cc_decls_unitrec * p,i64 level) {
    struct cc_decls_unitrec *  a;
    ++level;
    if ((level > (i64)5)) {
        return (i64)0;
    };
    a = (*p).a;
    switch ((i64)((*p).tag)) {
    case 1:;
    case 3:;
    case 5:;
    {
        return (i64)1;
    }break;
    case 53:;
    {
        if ((((i64)((*a).tag) == (i64)54) || ((i64)((*a).tag) == (i64)55))) {
            if ((!!(cc_libmcl_issimple0((*a).a,level)) && !!(cc_libmcl_issimple0((*a).b,level)))) {
                return (i64)1;
            };
        } else {
            return cc_libmcl_issimple0(a,level);
        };
    }break;
    case 40:;
    case 41:;
    case 45:;
    case 46:;
    case 47:;
    {
        //dobin:
L837 :;
;
        if ((!!(cc_libmcl_issimple0(a,level)) && !!(cc_libmcl_issimple0((*p).b,level)))) {
            return (i64)1;
        };
    }break;
    case 42:;
    {
        if ((cc_libmcl_gettypecat(p) == (i64)73)) {
            goto L837 ;
;
        };
    }break;
    case 57:;
    {
        if (((i64)((*p).opcode)==(i64)1) || ((i64)((*p).opcode)==(i64)2) || ((i64)((*p).opcode)==(i64)3) || ((i64)((*p).opcode)==(i64)4)) {
            return cc_libmcl_issimple0(a,level);
        };
    }break;
    case 56:;
    {
        return cc_libmcl_issimple0(a,level);
    }break;
    case 50:;
    {
        return cc_libmcl_issimple0(a,level);
    }break;
    case 48:;
    case 49:;
    {
        if ((!!(cc_libmcl_issimple0(a,level)) && ((i64)((*(*p).b).tag) == (i64)1))) {
            return (i64)1;
        };
    }break;
    default: {
    }
    } //SW
;
    return (i64)0;
}

i64 cc_libmcl_issimplepm(struct cc_decls_unitrec * p) {
    if (!(!!((i64)1))) {
        return (i64)0;
    };
    if (((i64)((*p).tag)==(i64)1) || ((i64)((*p).tag)==(i64)3)) {
        return (i64)1;
    };
    return (i64)0;
}

i64 cc_libmcl_getaregs(struct cc_libmcl_opndrec * ax) {
    i64 n;
    if (((i64)((*ax).mode)==(i64)1)) {
        return (i64)1;
    }else if (((i64)((*ax).mode)==(i64)4)) {
        n = (i64)0;
        if ((!!((u64)((*ax).reg)) && ((i64)((u64)((*ax).reg)) != (i64)15))) {
            ++n;
        };
        if (!!((u64)((*ax).regix))) {
            ++n;
        };
        return n;
    }else if (((i64)((*ax).mode)==(i64)6)) {
        return (i64)0;
    } else {
        cc_support_gerror((byte*)"getaregs",(struct cc_decls_unitrec *)(0));
    };
    return (i64)0;
}

i64 cc_libmcl_getlregs(struct cc_libmcl_opndrec * ax) {
    if (((i64)((*ax).mode)==(i64)1) || ((i64)((*ax).mode)==(i64)6)) {
        return (i64)1;
    }else if (((i64)((*ax).mode)==(i64)4)) {
        if (((!!((u64)((*ax).reg)) && ((i64)((u64)((*ax).reg)) != (i64)15)) || !!((u64)((*ax).regix)))) {
            return (i64)1;
        };
    }else if (((i64)((*ax).mode)==(i64)2)) {
        return (i64)0;
    } else {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str(cc_libmcl_opndnames[((i64)((*ax).mode))],NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        cc_support_gerror((byte*)"getlregs",(struct cc_decls_unitrec *)(0));
    };
    return (i64)0;
}

i64 cc_libmcl_isintconst(struct cc_decls_unitrec * p) {
    if ((((i64)((*p).tag) == (i64)1) && !!(cc_lib_isintcc((i64)((*p).mode))))) {
        return (i64)1;
    };
    return (i64)0;
}

i64 cc_libmcl__getnextreg(struct cc_libmcl_opndrec * ax,i64 reg) {
    i64 maxreg;
    i64 r;
    i64 rix;
    r = (i64)((*ax).reg);
    rix = (i64)((*ax).regix);
    if (((i64)((*ax).mode)==(i64)1) || ((i64)((*ax).mode)==(i64)6)) {
        if ((r < (i64)15)) {
            return ((r + (i64)1) + (i64)1);
        };
    }else if (((i64)((*ax).mode)==(i64)4)) {
        maxreg = (i64)0;
        if (((r >= (i64)15) && (rix > (i64)15))) {
        } else if ((r > (i64)15)) {
            maxreg = rix;
        } else if ((rix > (i64)15)) {
            maxreg = r;
        } else {
            if ((r != (i64)15)) {
                maxreg = (r>rix?r:rix);
            } else {
                maxreg = rix;
            };
        };
        if (!!(maxreg)) {
            return (maxreg + (i64)1);
        };
    };
    if ((reg == (i64)0)) {
        reg = (i64)1;
    };
    return reg;
}

i64 cc_libmcl_getnextreg(struct cc_libmcl_opndrec * ax,i64 r) {
    static i64 maxreg = (i64)0;
    i64 reg;
    reg = cc_libmcl__getnextreg(ax,r);
    if ((reg > maxreg)) {
        maxreg = reg;
    };
    return reg;
}

i64 cc_libmcl_ispoweroftwo(i64 x) {
    i64 a;
    i64 n;
    i64 av_1;
    a = (i64)1;
    n = (i64)0;
    av_1 = (i64)30;
    while (av_1-- > 0) {
L838 :;
        ++n;
        a = (a << (i64)1);
        if ((a == x)) {
            return n;
        };
L839 :;
    }L840 :;
    ;
    return (i64)0;
}

static i64 cc_libmcl_sameoperand(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    if (((u64)((*a).mode) != (u64)((*b).mode))) {
        return (i64)0;
    };
    if (((i64)((*a).size) != (i64)((*b).size))) {
        return (i64)0;
    };
    if (((*a).value != (*b).value)) {
        return (i64)0;
    };
    if (((u64)((*a).reg) != (u64)((*b).reg))) {
        return (i64)0;
    };
    if (((u64)((*a).regix) != (u64)((*b).regix))) {
        return (i64)0;
    };
    if (((u64)((*a).valtype) != (u64)((*b).valtype))) {
        return (i64)0;
    };
    if (((u64)((*a).scale) != (u64)((*b).scale))) {
        return (i64)0;
    };
    if ((((!!((*a).def) && !!((*b).def)) && ((*a).def == (*b).def)) && ((*a).value == (*b).value))) {
        return (i64)1;
    } else if (((((*a).def == 0) && ((*b).def == 0)) && ((*a).value == (*b).value))) {
        return (i64)1;
    };
    return (i64)0;
}

static struct cc_libmcl_mclrec * cc_libmcl_findlastmcl(void) {
    cc_support_gerror((byte*)"FINDLASTMCL",(struct cc_decls_unitrec *)(0));
    return (struct cc_libmcl_mclrec *)(0);
}

void cc_libmcl_genmsource(i64 lineno) {
}

i64 cc_libmcl_roundto(i64 a,i64 n) {
    --n;
    L841 :;
    while (!!((a & n))) {
        ++a;
L842 :;
    }L843 :;
    ;
    return a;
}

void cc_libmcl_pushstack(i64 n) {
    if (!!(n)) {
        cc_libmcl_genmc((i64)22,cc_libmcl_dstackopnd,cc_libmcl_genint(n,(i64)4));
        if (!!((n & (i64)8))) {
            cc_libmcl_stackaligned ^= (i64)1;
        };
    };
}

void cc_libmcl_pushstackfp(i64 n) {
    i64 av_1;
    if (!!(n)) {
        cc_libmcl_genmc((i64)5,cc_libmcl_genreg((i64)14,(i64)8),cc_libmcl_genint((i64)0,(i64)4));
        av_1 = (n / (i64)8);
        while (av_1-- > 0) {
L844 :;
            cc_libmcl_genmc((i64)6,cc_libmcl_genreg((i64)14,(i64)8),(struct cc_libmcl_opndrec *)(0));
L845 :;
        }L846 :;
        ;
        if (!!((n & (i64)8))) {
            cc_libmcl_stackaligned ^= (i64)1;
        };
    };
}

void cc_libmcl_popstack(i64 n) {
    if (!!(n)) {
        cc_libmcl_genmc((i64)21,cc_libmcl_dstackopnd,cc_libmcl_genint(n,(i64)4));
        if (!!((n & (i64)8))) {
            cc_libmcl_stackaligned ^= (i64)1;
        };
    };
}

i64 cc_libmcl_definelabel(void) {
    cc_libmcl_genmc((i64)3,cc_libmcl_genlabel(++cc_decls_labelno,(i64)0),(struct cc_libmcl_opndrec *)(0));
    return cc_decls_labelno;
}

i64 cc_libmcl_createfwdlabel(void) {
    return ++cc_decls_labelno;
}

void cc_libmcl_definefwdlabel(i64 lab) {
    cc_libmcl_genmc((i64)3,cc_libmcl_genlabel(lab,(i64)0),(struct cc_libmcl_opndrec *)(0));
}

void cc_libmcl_genjumpl(i64 lab) {
    cc_libmcl_genmc((i64)18,cc_libmcl_genlabel(lab,(i64)0),(struct cc_libmcl_opndrec *)(0));
}

void cc_libmcl_setalign(i64 align) {
    if ((align > (i64)1)) {
        cc_libmcl_genmc((i64)64,cc_libmcl_genint(align,(i64)4),(struct cc_libmcl_opndrec *)(0));
    };
}

i64 cc_libmcl_gettypecat(struct cc_decls_unitrec * a) {
    return (i64)(cc_tables_stdtypecat[(cc_decls_ttbasetype[((i64)((*a).mode))])]);
}

void cc_libmcl_doblockcall(i64 size) {
    struct cc_libmcl_opndrec *  ax;
    if (!!(cc_libmcl_retbeforeblock)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)".",NULL);
        msysnewc_m_print_end();
        ;
    };
    L847 :;
    while (!!((size & (i64)15))) {
        ++size;
L848 :;
    }L849 :;
    ;
    if ((cc_libmcl_currblocksize == (i64)0)) {
        cc_libmcl_currblocksize = size;
        cc_libmcl_frameoffset -= size;
        cc_libmcl_framebytes += size;
        (*(*cc_libmcl_stacksetinstr).b).value = cc_libmcl_roundto(cc_libmcl_framebytes,(i64)16);
    } else if ((cc_libmcl_currblocksize < size)) {
        cc_libmcl_frameoffset -= (size - cc_libmcl_currblocksize);
        cc_libmcl_framebytes += (size - cc_libmcl_currblocksize);
        cc_libmcl_currblocksize = size;
        (*(*cc_libmcl_stacksetinstr).b).value = cc_libmcl_roundto(cc_libmcl_framebytes,(i64)16);
    };
    ax = cc_libmcl_genreg((i64)10,(i64)8);
    cc_libmcl_genmc((i64)8,ax,cc_libmcl_genindex((i64)15,(i64)0,(i64)1,cc_libmcl_frameoffset,(i64)0,(i64)0,(struct cc_decls_strec *)(0)));
}

struct cc_libmcl_opndrec * cc_libmcl_getblockreg(i64 size) {
    struct cc_libmcl_opndrec *  ax;
    L850 :;
    while (!!((size & (i64)15))) {
        ++size;
L851 :;
    }L852 :;
    ;
    if ((cc_libmcl_currblocksize < size)) {
        cc_support_gerror((byte*)"getblockreg?",(struct cc_decls_unitrec *)(0));
    };
    cc_libmcl_genmc((i64)8,(ax = cc_libmcl_genreg((i64)1,(i64)8)),cc_libmcl_genindex((i64)15,(i64)0,(i64)1,cc_libmcl_frameoffset,(i64)0,(i64)0,(struct cc_decls_strec *)(0)));
    return ax;
}

void cc_libmcl_copyretvalue(i64 size) {
    byte str[256];
    cc_libmcl_genassem((byte*)";-----------");
    cc_libmcl_genassem((byte*)"\tpush d0");
    cc_libmcl_genassem((byte*)"\tpush d0");
    cc_libmcl_genassem((byte*)"\tsub dstack,32");
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_setfmt((byte*)"\tmov d10,[dframe#]");
    msysnewc_m_print_i64(cc_libmcl_structretoffset,NULL);
    msysnewc_m_print_end();
    ;
    cc_libmcl_genassem(str);
    cc_libmcl_genassem((byte*)"\tmov d11,d0");
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_str((byte*)"\tmov d12,",NULL);
    msysnewc_m_print_i64(size,NULL);
    msysnewc_m_print_end();
    ;
    cc_libmcl_genassem(str);
    cc_libmcl_genassem((byte*)"\tcall memcpy*");
    cc_libmcl_genassem((byte*)"\tadd dstack,32");
    cc_libmcl_genassem((byte*)"\tpop d0");
    cc_libmcl_genassem((byte*)"\tpop d0");
    cc_libmcl_genassem((byte*)";-----------");
}

void cc_libmcl_enterproc(byte * name) {
    return;
    if ((!!(mlib_eqstring(name,(byte*)"$showentry")) || !!(mlib_eqstring(name,(byte*)"$showreturn")))) {
        return;
    };
    cc_libmcl_genmc((i64)22,cc_libmcl_genreg((i64)16,(i64)8),cc_libmcl_genint((i64)32,(i64)4));
    cc_libmcl_genmc((i64)5,cc_libmcl_genreg((i64)11,(i64)8),cc_libmcl_genstrimm(name,(i64)-1));
    cc_libmcl_genmc((i64)15,cc_libmcl_genname((byte*)"$showentry*"),(struct cc_libmcl_opndrec *)(0));
    cc_libmcl_genmc((i64)21,cc_libmcl_genreg((i64)16,(i64)8),cc_libmcl_genint((i64)32,(i64)4));
}

void cc_libmcl_leaveproc(byte * name) {
    return;
    if ((!!(mlib_eqstring(name,(byte*)"$showentry")) || !!(mlib_eqstring(name,(byte*)"$showreturn")))) {
        return;
    };
    cc_libmcl_genmc((i64)22,cc_libmcl_genreg((i64)16,(i64)8),cc_libmcl_genint((i64)32,(i64)4));
    cc_libmcl_genmc((i64)5,cc_libmcl_genreg((i64)11,(i64)8),cc_libmcl_genstrimm(name,(i64)-1));
    cc_libmcl_genmc((i64)15,cc_libmcl_genname((byte*)"$showreturn*"),(struct cc_libmcl_opndrec *)(0));
    cc_libmcl_genmc((i64)21,cc_libmcl_genreg((i64)16,(i64)8),cc_libmcl_genint((i64)32,(i64)4));
}

void cc_blockmcl_do_stmt(struct cc_decls_unitrec * p) {
    i64 oldclineno;
    i64 value;
    i64 i;
    struct cc_decls_unitrec *  a;
    struct cc_decls_unitrec *  b;
    byte str[256];
    if ((p == 0)) {
        return;
    };
    oldclineno = cc_decls_clineno;
    cc_decls_clineno = (i64)((((u64)((*p).fileno) << (i64)24) + (u64)((*p).lineno)));
    a = (*p).a;
    b = (*p).b;
    switch ((i64)((*p).tag)) {
    case 6:;
    {
        L853 :;
        while (!!(a)) {
            cc_blockmcl_do_stmt(a);
            a = (*a).nextunit;
L854 :;
        }L855 :;
        ;
    }break;
    case 8:;
    {
        cc_blockmcl_do_decl((*p).def);
    }break;
    case 31:;
    {
        cc_blockmcl_dx_call(p,a,b,(i64)1);
    }break;
    case 10:;
    {
        cc_blockmcl_do_return(a);
    }break;
    case 12:;
    {
        cc_blockmcl_do_assign(a,b);
    }break;
    case 13:;
    {
        cc_blockmcl_do_if(a,b,(*p).c);
    }break;
    case 14:;
    {
        cc_blockmcl_do_for(a,b);
    }break;
    case 15:;
    {
        cc_blockmcl_do_while(a,b);
    }break;
    case 16:;
    {
        cc_blockmcl_do_dowhile(a,b);
    }break;
    case 17:;
    {
        cc_blockmcl_do_goto((*p).def);
    }break;
    case 18:;
    {
        cc_blockmcl_do_labeldef((*p).def);
        cc_blockmcl_do_stmt(a);
    }break;
    case 19:;
    {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_setfmt((byte*)"case");
        msysnewc_m_print_i64((*p).index,NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str((byte*)":",NULL);
        msysnewc_m_print_end();
        ;
        cc_libmcl_gencomment(mlib_pcm_copyheapstring(str));
        if ((cc_blockmcl_sw_ncases == (i64)0)) {
            cc_libmcl_genmc((i64)3,cc_libmcl_genlabel((*cc_blockmcl_sw_labeltable)[((((*p).value - cc_blockmcl_sw_lower) + (i64)1))-1],(i64)0),(struct cc_libmcl_opndrec *)(0));
        } else {
            value = (*p).value;
            L856 :;
            for (i=(i64)1;i<=cc_blockmcl_sw_ncases;i+=(i64)1) {
L857 :;
                if (((*cc_blockmcl_sw_valuetable)[(i)-1] == value)) {
                    cc_libmcl_genmc((i64)3,cc_libmcl_genlabel((*cc_blockmcl_sw_labeltable)[(i)-1],(i64)0),(struct cc_libmcl_opndrec *)(0));
                    goto L859 ;
                };
L858 :;
            }
            {
                cc_support_gerror((byte*)"case: serial switch not found",(struct cc_decls_unitrec *)(0));
            }L859 :;
            ;
        };
        cc_blockmcl_do_stmt(a);
    }break;
    case 20:;
    {
        cc_blockmcl_sw_defaultseen = (u64)((i64)1);
        cc_libmcl_gencomment((byte*)"default:");
        cc_libmcl_genmc((i64)3,cc_libmcl_genlabel(cc_blockmcl_sw_defaultlabel,(i64)0),(struct cc_libmcl_opndrec *)(0));
        cc_blockmcl_do_stmt(a);
    }break;
    case 24:;
    {
        cc_libmcl_genjumpl(cc_blockmcl_sw_breaklabel);
    }break;
    case 21:;
    {
        cc_libmcl_genjumpl(cc_blockmcl_breakstack[(cc_blockmcl_loopindex)-1]);
    }break;
    case 22:;
    {
        cc_libmcl_genjumpl(cc_blockmcl_continuestack[(cc_blockmcl_loopindex)-1]);
    }break;
    case 23:;
    {
        cc_blockmcl_do_switch(p,a,b);
    }break;
    case 62:;
    {
        ++cc_blockmcl_naddto;
        cc_blockmcl_dx_addto((i64)21,a,b,(i64)0);
    }break;
    case 63:;
    {
        ++cc_blockmcl_naddto;
        cc_blockmcl_dx_addto((i64)22,a,b,(i64)0);
    }break;
    case 64:;
    {
        ++cc_blockmcl_naddto;
        cc_blockmcl_dx_multo(a,b,(i64)0);
    }break;
    case 65:;
    case 66:;
    {
        ++cc_blockmcl_naddto;
        cc_blockmcl_dx_divto(p,a,b,(i64)0);
    }break;
    case 67:;
    {
        ++cc_blockmcl_naddto;
        cc_blockmcl_dx_addto((i64)28,a,b,(i64)0);
    }break;
    case 68:;
    {
        ++cc_blockmcl_naddto;
        cc_blockmcl_dx_addto((i64)29,a,b,(i64)0);
    }break;
    case 69:;
    {
        ++cc_blockmcl_naddto;
        cc_blockmcl_dx_addto((i64)30,a,b,(i64)0);
    }break;
    case 70:;
    case 71:;
    {
        ++cc_blockmcl_naddto;
        cc_blockmcl_dx_shlto(p,a,b,(i64)0);
    }break;
    case 73:;
    case 75:;
    {
        cc_blockmcl_do_preincr(a,(i64)21,(i64)38);
    }break;
    case 74:;
    case 76:;
    {
        cc_blockmcl_do_preincr(a,(i64)22,(i64)39);
    }break;
    case 30:;
    {
        cc_blockmcl_do_exprlist(a);
    }break;
    default: {
        if ((((i64)((*p).tag) != (i64)1) || !(!!(cc_decls_fshownames)))) {
            cc_blockmcl_loneexpr(p);
        };
    }
    } //SW
;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_expr(struct cc_decls_unitrec * p,i64 reg,i64 am) {
    i64 oldclineno;
    i64 m;
    struct cc_decls_unitrec *  a;
    struct cc_decls_unitrec *  b;
    struct cc_libmcl_opndrec *  tx;
    if ((p == 0)) {
        return (struct cc_libmcl_opndrec *)(0);
    };
    if (((reg > (i64)9) && (reg < (i64)11))) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"DOEXPR TOO MANY REGS?",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
    oldclineno = cc_decls_clineno;
    cc_decls_clineno = (i64)((((u64)((*p).fileno) << (i64)24) + (u64)((*p).lineno)));
    tx = (struct cc_libmcl_opndrec *)(0);
    a = (*p).a;
    b = (*p).b;
    m = (i64)((*p).mode);
    switch ((i64)((*p).tag)) {
    case 1:;
    {
        return cc_blockmcl_dx_const(p,reg);
    }break;
    case 3:;
    {
        return cc_blockmcl_dx_name(p,reg,am);
    }break;
    case 4:;
    {
        return cc_blockmcl_dx_widen(a,m,reg);
    }break;
    case 5:;
    {
        return cc_libmcl_genmemaddr_u(p);
    }break;
    case 12:;
    {
        return cc_blockmcl_dx_assign(a,b,reg);
    }break;
    case 25:;
    case 26:;
    {
        return cc_blockmcl_dx_andorl(p,reg);
    }break;
    case 27:;
    {
        return cc_blockmcl_dx_notl(a,reg);
    }break;
    case 28:;
    {
        return cc_blockmcl_dx_istruel(a,reg);
    }break;
    case 30:;
    {
        return cc_blockmcl_dx_exprlist(a,reg);
    }break;
    case 31:;
    {
        return cc_blockmcl_dx_call(p,a,b,reg);
    }break;
    case 32:;
    {
        return cc_blockmcl_dx_ifx(a,b,(*p).c,reg);
    }break;
    case 34:;
    case 35:;
    case 36:;
    case 37:;
    case 39:;
    case 38:;
    {
        return cc_blockmcl_dx_eq(p,a,b,reg);
    }break;
    case 40:;
    {
        if ((!!((u64)(cc_decls_ttisref[((i64)((*a).mode))])) && (cc_decls_ttsize[((i64)((*b).mode))] <= (i64)4))) {
            (*b).mode = (i64)10;
        };
        return cc_blockmcl_dx_add(a,b,reg);
    }break;
    case 41:;
    {
        return cc_blockmcl_dx_sub(a,b,reg);
    }break;
    case 42:;
    {
        return cc_blockmcl_dx_mul(p,a,b,reg);
    }break;
    case 43:;
    {
        return cc_blockmcl_dx_div(p,a,b,reg);
    }break;
    case 44:;
    {
        return cc_blockmcl_dx_rem(p,a,b,reg);
    }break;
    case 45:;
    {
        return cc_blockmcl_dx_iand((i64)28,a,b,reg);
    }break;
    case 46:;
    {
        return cc_blockmcl_dx_iand((i64)29,a,b,reg);
    }break;
    case 47:;
    {
        return cc_blockmcl_dx_iand((i64)30,a,b,reg);
    }break;
    case 48:;
    case 49:;
    {
        return cc_blockmcl_dx_shl(p,a,b,reg);
    }break;
    case 53:;
    {
        return cc_blockmcl_dx_ptr(p,a,reg,am);
    }break;
    case 54:;
    {
        return cc_blockmcl_dx_addptr(p,a,b,reg,am);
    }break;
    case 55:;
    {
        return cc_blockmcl_dx_subptr(a,b,reg,am);
    }break;
    case 57:;
    {
        if ((m == (i64)1)) {
            return cc_blockmcl_evalexpr(a,reg);
        } else {
            return cc_blockmcl_dx_convert(a,m,(i64)((*p).opcode),reg);
        };
    }break;
    case 58:;
    {
        return cc_blockmcl_dx_scale(p,a,b,reg);
    }break;
    case 59:;
    {
        return cc_blockmcl_dx_neg(a,reg);
    }break;
    case 61:;
    {
        return cc_blockmcl_dx_inot(a,reg);
    }break;
    case 73:;
    case 74:;
    {
        return cc_blockmcl_dx_preincrx(p,a,reg);
    }break;
    case 75:;
    case 76:;
    {
        return cc_blockmcl_dx_postincrx(p,a,reg);
    }break;
    case 62:;
    {
        ++cc_blockmcl_naddtox;
        return cc_blockmcl_dx_addto((i64)21,a,b,reg);
    }break;
    case 63:;
    {
        ++cc_blockmcl_naddtox;
        return cc_blockmcl_dx_addto((i64)22,a,b,reg);
    }break;
    case 64:;
    {
        ++cc_blockmcl_naddtox;
        return cc_blockmcl_dx_multo(a,b,reg);
    }break;
    case 65:;
    case 66:;
    {
        ++cc_blockmcl_naddtox;
        return cc_blockmcl_dx_divto(p,a,b,reg);
    }break;
    case 67:;
    {
        ++cc_blockmcl_naddtox;
        return cc_blockmcl_dx_addto((i64)28,a,b,reg);
    }break;
    case 68:;
    {
        ++cc_blockmcl_naddtox;
        return cc_blockmcl_dx_addto((i64)29,a,b,reg);
    }break;
    case 69:;
    {
        ++cc_blockmcl_naddtox;
        return cc_blockmcl_dx_addto((i64)30,a,b,reg);
    }break;
    case 70:;
    case 71:;
    {
        ++cc_blockmcl_naddtox;
        return cc_blockmcl_dx_shlto(p,a,b,reg);
    }break;
    case 72:;
    {
        return cc_blockmcl_dx_sqrt(a,reg);
    }break;
    case 56:;
    {
        return cc_blockmcl_dx_addrof(p,a,reg,am);
    }break;
    case 50:;
    {
        return cc_blockmcl_dx_dot(p,a,b,reg,am);
    }break;
    default: {
        cc_support_gerror_s((byte*)"DX-EXPR: can't do tag: %s",cc_tables_jtagnames[((i64)((*p).tag))],(struct cc_decls_unitrec *)(0));
    }
    } //SW
;
    if ((tx == 0)) {
        cc_support_gerror_s((byte*)"DX-EXPR: NO RESULT: %s",cc_tables_jtagnames[((i64)((*p).tag))],(struct cc_decls_unitrec *)(0));
    };
    cc_decls_clineno = oldclineno;
    return tx;
}

static void cc_blockmcl_loneexpr(struct cc_decls_unitrec * p) {
    if ((!!(p) && ((i64)((*p).tag) != (i64)2))) {
        cc_blockmcl_loadexpr(p,(i64)1,(i64)0);
    };
}

static void cc_blockmcl_do_assign(struct cc_decls_unitrec * a,struct cc_decls_unitrec * b) {
    struct cc_libmcl_opndrec *  lhs;
    struct cc_libmcl_opndrec *  rhs;
    i64 reg;
    i64 tx;
    if ((cc_decls_ttsize[((i64)((*a).mode))]==(i64)1) || (cc_decls_ttsize[((i64)((*a).mode))]==(i64)2) || (cc_decls_ttsize[((i64)((*a).mode))]==(i64)4) || (cc_decls_ttsize[((i64)((*a).mode))]==(i64)8)) {
    } else {
        cc_blockmcl_do_assignblock(a,b,(i64)0);
        return;
    };
    reg = (i64)1;
    if (!!(cc_libmcl_issimple(a))) {
        if (!!(cc_libmcl_issimple(b))) {
            lhs = cc_blockmcl_getlvalueopnd(a,reg);
            if (!!(cc_libmcl_isintconst(b))) {
                rhs = cc_blockmcl_evalexpr(b,cc_libmcl_getnextreg(lhs,reg));
            } else {
                rhs = cc_blockmcl_loadexpr(b,cc_libmcl_getnextreg(lhs,reg),(i64)1);
            };
        } else {
            rhs = cc_blockmcl_loadexpr(b,reg,(i64)1);
            lhs = cc_blockmcl_getlvalueopnd(a,cc_libmcl_getnextreg(rhs,reg));
        };
    } else {
        if (!!(cc_libmcl_issimple(b))) {
            lhs = cc_blockmcl_getlvalueopnd(a,reg);
            rhs = cc_blockmcl_loadexpr(b,cc_libmcl_getnextreg(lhs,reg),(i64)1);
        } else {
            tx = cc_blockmcl_saveexpr(b,(i64)1);
            lhs = cc_blockmcl_getlvalueopnd(a,(i64)1);
            rhs = cc_blockmcl_restoreexpr(tx,cc_libmcl_getnextreg(lhs,reg));
        };
    };
    cc_blockmcl_storeopnd(lhs,rhs);
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_assign(struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg) {
    struct cc_libmcl_opndrec *  lhs;
    struct cc_libmcl_opndrec *  rhs;
    struct cc_libmcl_opndrec *  rx;
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  bx;
    i64 tx;
    if ((cc_decls_ttsize[((i64)((*a).mode))]==(i64)1) || (cc_decls_ttsize[((i64)((*a).mode))]==(i64)2) || (cc_decls_ttsize[((i64)((*a).mode))]==(i64)4) || (cc_decls_ttsize[((i64)((*a).mode))]==(i64)8)) {
    } else {
        return cc_blockmcl_do_assignblock(a,b,reg);
    };
    if (!!(cc_libmcl_issimple(a))) {
        if (!!(cc_libmcl_issimple(b))) {
            lhs = cc_blockmcl_getlvalueopnd(a,reg);
            rhs = cc_blockmcl_loadexpr(b,cc_libmcl_getnextreg(lhs,reg),(i64)1);
            cc_blockmcl_storeopnd(lhs,rhs);
        } else {
            rhs = cc_blockmcl_loadexpr(b,reg,(i64)1);
            lhs = cc_blockmcl_getlvalueopnd(a,cc_libmcl_getnextreg(rhs,reg));
            cc_blockmcl_storeopnd(lhs,rhs);
        };
    } else {
        if (!!(cc_libmcl_issimple(b))) {
            lhs = cc_blockmcl_getlvalueopnd(a,reg);
            rhs = cc_blockmcl_loadexpr(b,cc_libmcl_getnextreg(lhs,reg),(i64)1);
            cc_blockmcl_storeopnd(lhs,rhs);
        } else {
            tx = cc_blockmcl_saveexpr(b,(i64)1);
            ax = cc_blockmcl_getlvalueopnd(a,(i64)1);
            bx = cc_blockmcl_restoreexpr(tx,cc_libmcl_getnextreg(ax,reg));
            cc_blockmcl_storeopnd(ax,bx);
            rhs = bx;
        };
    };
    if (((i64)((*rhs).mode)==(i64)1)) {
        if (((i64)((u64)((*rhs).reg)) != reg)) {
            rx = cc_libmcl_genreg(reg,(i64)((*rhs).size));
            cc_libmcl_genmc((i64)5,rx,rhs);
            return rx;
        };
    }else if (((i64)((*rhs).mode)==(i64)6)) {
        if (((i64)((u64)((*rhs).reg)) != reg)) {
            rx = cc_libmcl_genxreg(reg,(i64)((*rhs).size));
            cc_libmcl_genmc((i64)10,rx,rhs);
            return rx;
        };
    };
    return rhs;
}

static i64 cc_blockmcl_saveexpr(struct cc_decls_unitrec * a,i64 reg) {
    cc_blockmcl_pushexpr(a,reg);
    return cc_decls_ttsize[((i64)((*a).mode))];
}

static i64 cc_blockmcl_fsaveexpr(struct cc_decls_unitrec * a,i64 reg) {
    cc_blockmcl_fpushexpr(a,reg);
    return cc_decls_ttsize[((i64)((*a).mode))];
}

static struct cc_libmcl_opndrec * cc_blockmcl_restoreexpr(i64 tx,i64 reg) {
    struct cc_libmcl_opndrec *  rx;
    cc_libmcl_genmc((i64)7,(rx = cc_libmcl_genreg(reg,(i64)8)),(struct cc_libmcl_opndrec *)(0));
    rx = cc_libmcl_duplopnd(rx);
    (*rx).size = tx;
    return rx;
}

static struct cc_libmcl_opndrec * cc_blockmcl_frestoreexpr(i64 tx,i64 reg) {
    struct cc_libmcl_opndrec *  rx;
    cc_libmcl_genmc((i64)7,(rx = cc_libmcl_genxreg(reg,tx)),(struct cc_libmcl_opndrec *)(0));
    rx = cc_libmcl_duplopnd(rx);
    (*rx).size = tx;
    return rx;
}

static struct cc_libmcl_opndrec * cc_blockmcl_getlvalueopnd(struct cc_decls_unitrec * a,i64 reg) {
    return cc_blockmcl_evalexpr(a,reg);
}

static void cc_blockmcl_storeopnd(struct cc_libmcl_opndrec * ax,struct cc_libmcl_opndrec * bx) {
    if (((i64)((u64)((*bx).mode)) == (i64)6)) {
        cc_libmcl_genmc((i64)10,ax,bx);
    } else {
        if (((i64)((*ax).size)==(i64)1) || ((i64)((*ax).size)==(i64)2) || ((i64)((*ax).size)==(i64)4)) {
            bx = cc_libmcl_changeopndsize(bx,(i64)((*ax).size));
        };
        cc_libmcl_genmc((i64)5,ax,bx);
    };
}

static void cc_blockmcl_pushexpr(struct cc_decls_unitrec * a,i64 reg) {
    struct cc_libmcl_opndrec *  ax;
    if (!!(a)) {
        ax = cc_blockmcl_dx_expr(a,reg,(i64)1);
        cc_libmcl_genmc((i64)6,ax,(struct cc_libmcl_opndrec *)(0));
    } else {
        cc_libmcl_genmc((i64)6,cc_libmcl_zero_opnd,(struct cc_libmcl_opndrec *)(0));
    };
}

static void cc_blockmcl_fpushexpr(struct cc_decls_unitrec * a,i64 reg) {
    struct cc_libmcl_opndrec *  ax;
    ax = cc_blockmcl_dx_expr(a,reg,(i64)1);
    cc_libmcl_genmc((i64)6,ax,(struct cc_libmcl_opndrec *)(0));
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_const(struct cc_decls_unitrec * p,i64 reg) {
    struct cc_libmcl_opndrec *  ax;
    i64 t;
    if ((((t = cc_decls_ttbasetype[((i64)((*p).mode))]) >= (i64)2) && (t <= (i64)10))) {
        return cc_libmcl_genint((*p).value,cc_decls_ttsize[((i64)((*p).mode))]);
    } else if (((t >= (i64)11) && (t <= (i64)13))) {
        ax = cc_libmcl_genreal((*p).xvalue,cc_decls_ttsize[((i64)((*p).mode))]);
        return ax;
    } else if ((t == (i64)16)) {
        if (!!((u64)((*p).isstrconst))) {
            return cc_libmcl_genstrimm((*p).svalue,(i64)((*p).slength));
        } else if (!!((u64)((*p).iswstrconst))) {
            return cc_libmcl_genwstrimm((*p).wsvalue,(i64)((*p).wslength));
        };
        return cc_libmcl_genint((*p).value,(i64)8);
    };
    cc_support_gerror_s((byte*)"dxconst %s",cc_lib_strmode((i64)((*p).mode),(i64)1),(struct cc_decls_unitrec *)(0));
    return ax;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_constant(struct cc_decls_strec * d,i64 reg) {
    struct cc_libmcl_opndrec *  ax;
    i64 t;
    if ((((t = cc_decls_ttbasetype[((i64)((*d).mode))]) >= (i64)2) && (t <= (i64)10))) {
        return cc_libmcl_genint((*(*d).code).value,cc_decls_ttsize[((i64)((*d).mode))]);
    } else if (((t >= (i64)11) && (t <= (i64)13))) {
        ax = cc_libmcl_genreal((*(*d).code).xvalue,cc_decls_ttsize[((i64)((*d).mode))]);
        return ax;
    };
    cc_support_gerror_s((byte*)"dxconstant %s",cc_lib_strmode((i64)((*d).mode),(i64)1),(struct cc_decls_unitrec *)(0));
    return ax;
}

static void cc_blockmcl_do_labeldef(struct cc_decls_strec * d) {
    cc_libmcl_genmc((i64)3,cc_libmcl_genlabel((i64)((*d).index),(i64)0),cc_libmcl_genmemaddr_d(d));
}

static void cc_blockmcl_do_goto(struct cc_decls_strec * d) {
    if (((i64)((*d).index) == (i64)0)) {
        cc_support_gerror_s((byte*)"Label not defined: %s",(*d).name,(struct cc_decls_unitrec *)(0));
    };
    cc_libmcl_genmc((i64)18,cc_libmcl_genlabel((i64)((*d).index),(i64)0),(struct cc_libmcl_opndrec *)(0));
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_add(struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg) {
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  bx;
    i64 tx;
    if ((cc_libmcl_gettypecat(a) == (i64)82)) {
        return cc_blockmcl_dx_fadd((i64)21,a,b,reg);
    };
    if (!!(cc_libmcl_issimple(b))) {
        //simpleadd:
L860 :;
;
        ax = cc_blockmcl_loadexpr(a,reg,(i64)0);
        bx = cc_blockmcl_evalexpr(b,cc_libmcl_getnextreg(ax,reg));
    } else if (!!(cc_libmcl_issimple(a))) {
        ax = cc_blockmcl_loadexpr(b,reg,(i64)0);
        bx = cc_blockmcl_evalexpr(a,cc_libmcl_getnextreg(ax,reg));
    } else {
        tx = cc_blockmcl_saveexpr(a,reg);
        ax = cc_blockmcl_loadexpr(b,reg,(i64)0);
        bx = cc_blockmcl_restoreexpr(tx,cc_libmcl_getnextreg(ax,reg));
    };
    cc_libmcl_genmc((i64)21,ax,bx);
    return ax;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_fadd(i64 opc,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg) {
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  bx;
    i64 tx;
    if (!!(cc_libmcl_issimple(b))) {
        ax = cc_blockmcl_floadexpr(a,reg);
        if (((((opc == (i64)23) && ((i64)((*a).tag) == (i64)3)) && ((i64)((*b).tag) == (i64)3)) && ((*a).def == (*b).def))) {
            bx = ax;
        } else {
            bx = cc_blockmcl_fevalexpr(b,cc_libmcl_getnextreg(ax,reg));
        };
    } else if ((!!(cc_libmcl_issimple(a)) && ((opc == (i64)21) || (opc == (i64)23)))) {
        ax = cc_blockmcl_floadexpr(b,reg);
        bx = cc_blockmcl_fevalexpr(a,cc_libmcl_getnextreg(ax,reg));
    } else {
        tx = cc_blockmcl_fsaveexpr(b,reg);
        ax = cc_blockmcl_floadexpr(a,reg);
        bx = cc_blockmcl_frestoreexpr(tx,cc_libmcl_getnextreg(ax,reg));
    };
    if ((opc==(i64)21)) {
        cc_libmcl_genmc((i64)44,ax,bx);
    }else if ((opc==(i64)22)) {
        cc_libmcl_genmc((i64)45,ax,bx);
    }else if ((opc==(i64)23)) {
        cc_libmcl_genmc((i64)46,ax,bx);
    }else if ((opc==(i64)24)) {
        cc_libmcl_genmc((i64)47,ax,bx);
    };
    return ax;
}

static struct cc_libmcl_opndrec * cc_blockmcl_loadexpr(struct cc_decls_unitrec * a,i64 reg,i64 isassign) {
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  rx;
    ax = cc_blockmcl_dx_expr(a,reg,(i64)1);
    if (((i64)((*ax).size)==(i64)1) || ((i64)((*ax).size)==(i64)2) || ((i64)((*ax).size)==(i64)4) || ((i64)((*ax).size)==(i64)8)) {
    } else {
        if (((i64)((*ax).mode)==(i64)4)) {
            if (((((*ax).def == 0) && ((i64)((u64)((*ax).regix)) == (i64)0)) && ((*ax).value == (i64)0))) {
                return cc_libmcl_genreg((i64)((*ax).reg),(i64)8);
            };
            rx = cc_libmcl_genreg((reg + cc_libmcl_getaregs(ax)),(i64)8);
            cc_libmcl_genmc((i64)8,rx,ax);
            return rx;
        }else if (((i64)((*ax).mode)==(i64)1)) {
            return ax;
        }else if (((i64)((*ax).mode)==(i64)2)) {
        } else {
            cc_support_gerror((byte*)"loadexpr block not mem/reg",(struct cc_decls_unitrec *)(0));
        };
    };
    if (((i64)((*ax).mode)==(i64)1)) {
        if (((i64)((u64)((*ax).reg)) == reg)) {
            return ax;
        };
        rx = cc_libmcl_genreg(reg,(i64)((*ax).size));
        cc_libmcl_genmc((i64)5,rx,ax);
        return rx;
    }else if (((i64)((*ax).mode)==(i64)6)) {
        if ((!!(isassign) && ((i64)((u64)((*ax).reg)) == reg))) {
            return ax;
        };
        rx = cc_libmcl_genreg(reg,(i64)((*ax).size));
        cc_libmcl_genmc((i64)10,rx,ax);
        return rx;
    };
    rx = cc_libmcl_genreg(reg,(i64)((*ax).size));
    cc_libmcl_genmc((i64)5,rx,ax);
    return rx;
}

static struct cc_libmcl_opndrec * cc_blockmcl_evalexpr(struct cc_decls_unitrec * p,i64 reg) {
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  rx;
    ax = cc_blockmcl_dx_expr(p,reg,(i64)1);
    if (((i64)((u64)((*ax).mode)) == (i64)6)) {
        rx = cc_libmcl_genreg((i64)((*ax).reg),(i64)((*ax).size));
        cc_libmcl_genmc((i64)10,rx,ax);
        return rx;
    };
    return ax;
}

static struct cc_libmcl_opndrec * cc_blockmcl_evaladdr(struct cc_decls_unitrec * p,i64 reg) {
    return cc_blockmcl_dx_expr(p,reg,(i64)0);
}

static struct cc_libmcl_opndrec * cc_blockmcl_evalptr(struct cc_decls_unitrec * p,i64 reg) {
    return cc_blockmcl_dx_expr(p,reg,(i64)2);
}

static struct cc_libmcl_opndrec * cc_blockmcl_floadexpr(struct cc_decls_unitrec * a,i64 xreg) {
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  rx;
    ax = cc_blockmcl_dx_expr(a,xreg,(i64)1);
    rx = cc_libmcl_genxreg(xreg,cc_libmcl_getopndsize_u(a));
    if (((i64)((*ax).mode)==(i64)6)) {
        if (((i64)((u64)((*ax).reg)) == xreg)) {
            return ax;
        };
        cc_libmcl_genmc((i64)10,rx,ax);
        return rx;
    }else if (((i64)((*ax).mode)==(i64)1)) {
        rx = cc_libmcl_genxreg((i64)((*ax).reg),(i64)((*ax).size));
        cc_libmcl_genmc((i64)10,rx,ax);
        return rx;
    };
    cc_libmcl_genmc((i64)10,rx,ax);
    return rx;
}

static struct cc_libmcl_opndrec * cc_blockmcl_fevalexpr(struct cc_decls_unitrec * p,i64 xreg) {
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  rx;
    ax = cc_blockmcl_dx_expr(p,xreg,(i64)1);
    if (((i64)((u64)((*ax).mode)) == (i64)1)) {
        rx = cc_libmcl_genxreg(xreg,cc_libmcl_getopndsize_u(p));
        cc_libmcl_genmc((i64)10,rx,ax);
        return rx;
    };
    return ax;
}

static void cc_blockmcl_do_if(struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,struct cc_decls_unitrec * c) {
    i64 lab1;
    i64 lab2;
    lab1 = cc_libmcl_createfwdlabel();
    cc_blockmcl_genjumpcond((i64)0,a,lab1,(i64)1);
    cc_blockmcl_do_stmt(b);
    if (!!(c)) {
        lab2 = cc_libmcl_createfwdlabel();
        cc_libmcl_genjumpl(lab2);
        cc_libmcl_definefwdlabel(lab1);
        cc_blockmcl_do_stmt(c);
        cc_libmcl_definefwdlabel(lab2);
    } else {
        cc_libmcl_definefwdlabel(lab1);
    };
}

static void cc_blockmcl_genjumpcond(i64 opc,struct cc_decls_unitrec * p,i64 lab,i64 reg) {
    struct cc_decls_unitrec *  q;
    struct cc_decls_unitrec *  r;
    i64 lab2;
    struct cc_libmcl_opndrec *  ax;
    q = (*p).a;
    r = (*p).b;
    switch ((i64)((*p).tag)) {
    case 25:;
    {
        if ((opc==(i64)0)) {
            cc_blockmcl_genjumpcond((i64)0,q,lab,reg);
            cc_blockmcl_genjumpcond((i64)0,r,lab,reg);
        }else if ((opc==(i64)1)) {
            lab2 = cc_libmcl_createfwdlabel();
            cc_blockmcl_genjumpcond((i64)0,q,lab2,reg);
            cc_blockmcl_genjumpcond((i64)1,r,lab,reg);
            cc_libmcl_definefwdlabel(lab2);
        };
    }break;
    case 26:;
    {
        if ((opc==(i64)0)) {
            lab2 = cc_libmcl_createfwdlabel();
            cc_blockmcl_genjumpcond((i64)1,q,lab2,reg);
            cc_blockmcl_genjumpcond((i64)0,r,lab,reg);
            cc_libmcl_definefwdlabel(lab2);
        }else if ((opc==(i64)1)) {
            cc_blockmcl_genjumpcond((i64)1,q,lab,reg);
            cc_blockmcl_genjumpcond((i64)1,r,lab,reg);
        };
    }break;
    case 27:;
    {
        if ((opc==(i64)0)) {
            cc_blockmcl_genjumpcond((i64)1,q,lab,reg);
        }else if ((opc==(i64)1)) {
            cc_blockmcl_genjumpcond((i64)0,q,lab,reg);
        };
    }break;
    case 28:;
    {
        cc_blockmcl_genjumpcond(opc,q,lab,reg);
    }break;
    case 34:;
    case 35:;
    case 36:;
    case 37:;
    case 39:;
    case 38:;
    {
        cc_blockmcl_gcomparejump(opc,p,q,r,lab,reg);
    }break;
    case 30:;
    {
        L861 :;
        while ((!!(q) && !!((r = (*q).nextunit)))) {
            cc_blockmcl_dx_expr(q,reg,(i64)1);
            q = r;
L862 :;
        }L863 :;
        ;
        cc_blockmcl_genjumpcond(opc,q,lab,reg);
    }break;
    default: {
        if (((i64)((*p).tag)==(i64)73)) {
            cc_blockmcl_do_preincr((*p).a,(i64)21,(i64)38);
        }else if (((i64)((*p).tag)==(i64)74)) {
            cc_blockmcl_do_preincr((*p).a,(i64)22,(i64)39);
        } else {
            ax = cc_blockmcl_loadexpr(p,reg,(i64)0);
            cc_libmcl_genmc((i64)32,ax,cc_libmcl_genint((i64)0,(i64)4));
        };
        cc_libmcl_genmc_cond((i64)19,(!!(opc)?(i64)5:(i64)4),cc_libmcl_genlabel(lab,(i64)0),(struct cc_libmcl_opndrec *)(0));
    }
    } //SW
;
}

static void cc_blockmcl_gcomparejump(i64 jumpopc,struct cc_decls_unitrec * p,struct cc_decls_unitrec * lhs,struct cc_decls_unitrec * rhs,i64 lab,i64 reg) {
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  bx;
    i64 mclcond;
    i64 cond;
    i64 tx;
    cond = (i64)((*p).tag);
    if ((jumpopc == (i64)0)) {
        cond = cc_blockmcl_reversecond(cond);
    };
    mclcond = cc_libmcl_getmclcond(cond,(i64)((*lhs).mode));
    if ((mclcond==(i64)16) || (mclcond==(i64)17) || (mclcond==(i64)18) || (mclcond==(i64)19) || (mclcond==(i64)20) || (mclcond==(i64)21)) {
        if (!!(cc_libmcl_issimple(rhs))) {
            ax = cc_blockmcl_floadexpr(lhs,reg);
            bx = cc_blockmcl_fevalexpr(rhs,cc_libmcl_getnextreg(ax,reg));
        } else {
            tx = cc_blockmcl_saveexpr(rhs,reg);
            ax = cc_blockmcl_floadexpr(lhs,reg);
            bx = cc_blockmcl_frestoreexpr(tx,cc_libmcl_getnextreg(ax,reg));
        };
        cc_libmcl_genmc((i64)48,ax,bx);
    } else {
        if (!!(cc_libmcl_issimple(rhs))) {
            ax = cc_blockmcl_loadexpr(lhs,reg,(i64)0);
            bx = cc_blockmcl_evalexpr(rhs,cc_libmcl_getnextreg(ax,reg));
            cc_libmcl_genmc((i64)32,ax,bx);
        } else if (!!(cc_libmcl_issimple(lhs))) {
            mclcond = cc_blockmcl_reversemclcond(mclcond);
            ax = cc_blockmcl_loadexpr(rhs,reg,(i64)0);
            bx = cc_blockmcl_evalexpr(lhs,cc_libmcl_getnextreg(ax,reg));
            cc_libmcl_genmc((i64)32,ax,bx);
        } else {
            cc_blockmcl_pushexpr(rhs,reg);
            ax = cc_blockmcl_loadexpr(lhs,reg,(i64)0);
            bx = cc_libmcl_genreg(cc_libmcl_getnextreg(ax,reg),(i64)((*ax).size));
            cc_libmcl_genmc((i64)7,cc_libmcl_changeopndsize(bx,(i64)8),(struct cc_libmcl_opndrec *)(0));
            cc_libmcl_genmc((i64)32,ax,bx);
        };
    };
    cc_libmcl_genmc_cond((i64)19,mclcond,cc_libmcl_genlabel(lab,(i64)0),(struct cc_libmcl_opndrec *)(0));
}

static i64 cc_blockmcl_reversecond(i64 op) {
    if ((op==(i64)34)) {
        return (i64)35;
    }else if ((op==(i64)35)) {
        return (i64)34;
    }else if ((op==(i64)36)) {
        return (i64)39;
    }else if ((op==(i64)37)) {
        return (i64)38;
    }else if ((op==(i64)39)) {
        return (i64)36;
    }else if ((op==(i64)38)) {
        return (i64)37;
    };
    return (i64)0;
}

static void cc_blockmcl_do_preincr(struct cc_decls_unitrec * a,i64 addop,i64 incrop) {
    struct cc_libmcl_opndrec *  ptropnd;
    i64 size;
    ptropnd = cc_blockmcl_getlvalueopnd(a,(i64)1);
    if (((cc_decls_ttbasetype[((i64)((*a).mode))] == (i64)16) && (cc_decls_ttsize[(cc_decls_tttarget[((i64)((*a).mode))])] != (i64)1))) {
        size = cc_decls_ttsize[(cc_decls_tttarget[((i64)((*a).mode))])];
        cc_libmcl_genmc(addop,ptropnd,cc_libmcl_genint(size,(i64)4));
    } else {
        cc_libmcl_genmc(incrop,ptropnd,(struct cc_libmcl_opndrec *)(0));
    };
}

static i64 cc_blockmcl_reversemclcond(i64 cond) {
    switch (cond) {
    case 12:;
    {
        cond = (i64)15;
    }break;
    case 14:;
    {
        cond = (i64)13;
    }break;
    case 13:;
    {
        cond = (i64)14;
    }break;
    case 15:;
    {
        cond = (i64)12;
    }break;
    case 2:;
    {
        cond = (i64)7;
    }break;
    case 6:;
    {
        cond = (i64)3;
    }break;
    case 3:;
    {
        cond = (i64)6;
    }break;
    case 7:;
    {
        cond = (i64)2;
    }break;
    case 16:;
    {
        cond = (i64)19;
    }break;
    case 18:;
    {
        cond = (i64)17;
    }break;
    case 17:;
    {
        cond = (i64)18;
    }break;
    case 19:;
    {
        cond = (i64)16;
    }break;
    default: {
    }
    } //SW
;
    return cond;
}

static void cc_blockmcl_do_while(struct cc_decls_unitrec * pcond,struct cc_decls_unitrec * pbody) {
    i64 lab_b;
    i64 lab_c;
    i64 lab_d;
    if ((((i64)((*pcond).tag) == (i64)1) && !!((*pcond).value))) {
        cc_blockmcl_do_while1(pbody);
        return;
    };
    lab_c = cc_libmcl_createfwdlabel();
    lab_d = cc_libmcl_createfwdlabel();
    cc_blockmcl_stacklooplabels(lab_c,lab_d);
    cc_libmcl_genjumpl(lab_c);
    lab_b = cc_libmcl_definelabel();
    cc_blockmcl_do_stmt(pbody);
    cc_libmcl_definefwdlabel(lab_c);
    cc_blockmcl_genjumpcond((i64)1,pcond,lab_b,(i64)1);
    cc_libmcl_definefwdlabel(lab_d);
    --cc_blockmcl_loopindex;
}

static void cc_blockmcl_do_while1(struct cc_decls_unitrec * pbody) {
    i64 lab_b;
    i64 lab_c;
    i64 lab_d;
    lab_c = cc_libmcl_createfwdlabel();
    lab_d = cc_libmcl_createfwdlabel();
    cc_blockmcl_stacklooplabels(lab_c,lab_d);
    lab_b = cc_libmcl_definelabel();
    cc_blockmcl_do_stmt(pbody);
    cc_libmcl_definefwdlabel(lab_c);
    cc_libmcl_genjumpl(lab_b);
    cc_libmcl_definefwdlabel(lab_d);
    --cc_blockmcl_loopindex;
}

static void cc_blockmcl_stacklooplabels(i64 a,i64 b) {
    cc_blockmcl_continuestack[(++cc_blockmcl_loopindex)-1] = a;
    cc_blockmcl_breakstack[(cc_blockmcl_loopindex)-1] = b;
}

static void cc_blockmcl_do_dowhile(struct cc_decls_unitrec * pbody,struct cc_decls_unitrec * pcond) {
    i64 lab_b;
    i64 lab_c;
    i64 lab_d;
    lab_c = cc_libmcl_createfwdlabel();
    lab_d = cc_libmcl_createfwdlabel();
    cc_blockmcl_stacklooplabels(lab_c,lab_d);
    lab_b = cc_libmcl_definelabel();
    cc_blockmcl_do_stmt(pbody);
    cc_libmcl_definefwdlabel(lab_c);
    cc_blockmcl_genjumpcond((i64)1,pcond,lab_b,(i64)1);
    cc_libmcl_definefwdlabel(lab_d);
    --cc_blockmcl_loopindex;
}

static void cc_blockmcl_do_for(struct cc_decls_unitrec * pinit,struct cc_decls_unitrec * pbody) {
    struct cc_decls_unitrec *  pcond;
    struct cc_decls_unitrec *  pincr;
    i64 lab_b;
    i64 lab_c;
    i64 lab_d;
    i64 lab_cond;
    pcond = (*pinit).nextunit;
    pincr = (*pcond).nextunit;
    lab_c = cc_libmcl_createfwdlabel();
    lab_d = cc_libmcl_createfwdlabel();
    lab_cond = cc_libmcl_createfwdlabel();
    if (((i64)((*pinit).tag) != (i64)2)) {
        cc_blockmcl_do_stmt(pinit);
    };
    cc_libmcl_genjumpl(lab_cond);
    cc_blockmcl_stacklooplabels(lab_c,lab_d);
    lab_b = cc_libmcl_definelabel();
    cc_blockmcl_do_stmt(pbody);
    cc_libmcl_definefwdlabel(lab_c);
    cc_blockmcl_do_stmt(pincr);
    cc_libmcl_definefwdlabel(lab_cond);
    if (((i64)((*pcond).tag) != (i64)2)) {
        cc_blockmcl_genjumpcond((i64)1,pcond,lab_b,(i64)1);
    } else {
        cc_libmcl_genjumpl(lab_b);
    };
    cc_libmcl_definefwdlabel(lab_d);
    --cc_blockmcl_loopindex;
}

static i64 cc_blockmcl_pushffparams(struct cc_decls_unitrec * p,i64 variadic) {
    struct cc_libmcl_opndrec *  rx;
    struct cc_libmcl_opndrec *  fx;
    byte iscomplex[4];
    i64 i;
    i64 m;
    i64 n;
    i64 dummypush;
    i64 size;
    i64 popbytes;
    i64 ncomplex;
    struct cc_decls_unitrec *  q;
    struct cc_decls_unitrec *  paramlist[200];
    n = (i64)0;
    L864 :;
    while (!!(p)) {
        if ((n >= (i64)200)) {
            cc_support_gerror((byte*)"TOO MANY PARAMS",(struct cc_decls_unitrec *)(0));
        };
        ++n;
        paramlist[(n)-1] = p;
        p = (*p).nextunit;
L865 :;
    }L866 :;
    ;
    m = (n>(i64)4?n:(i64)4);
    dummypush = (i64)0;
    if (((!!((m & (i64)1)) && !!(cc_libmcl_stackaligned)) || (((m & (i64)1) == (i64)0) && !(!!(cc_libmcl_stackaligned))))) {
        dummypush = (i64)1;
        if ((n > (i64)4)) {
            cc_libmcl_pushstack((i64)8);
        };
        popbytes = ((m + (i64)1) * (i64)8);
    } else {
        popbytes = (m * (i64)8);
    };
    L867 :;
    for (i=n;i>=(i64)5;i-=(i64)1) {
L868 :;
        q = paramlist[(i)-1];
        if ((!!(variadic) && (cc_decls_ttbasetype[((i64)((*q).mode))] == (i64)11))) {
            cc_blockmcl_pushfloatparam(q);
        } else {
            cc_blockmcl_pushexpr(q,(i64)1);
        };
L869 :;
    }L870 :;
    ;
    if ((!!(dummypush) && (n <= (i64)4))) {
        cc_libmcl_pushstack((i64)40);
    } else {
        cc_libmcl_pushstack((i64)32);
    };
    n = (n<(i64)4?n:(i64)4);
    if ((n == (i64)1)) {
        cc_blockmcl_pushoneparam(paramlist[(i)-1],variadic);
        return popbytes;
    };
    ncomplex = (i64)0;
    L871 :;
    for (i=n;i>=(i64)1;i-=(i64)1) {
L872 :;
        q = paramlist[(i)-1];
        if (!!(cc_libmcl_issimplepm(q))) {
            iscomplex[(i)-1] = (u64)((i64)0);
        } else {
            cc_blockmcl_pushexpr(q,(i64)1);
            iscomplex[(i)-1] = (u64)((i64)1);
            ++ncomplex;
        };
L873 :;
    }L874 :;
    ;
    L875 :;
    for (i=(i64)1;i<=n;i+=(i64)1) {
L876 :;
        q = paramlist[(i)-1];
        if ((cc_libmcl_gettypecat(q) != (i64)82)) {
            if (!!((u64)(iscomplex[(i)-1]))) {
                cc_libmcl_genmc((i64)7,(rx = cc_libmcl_genreg((((i64)11 + i) - (i64)1),(i64)8)),(struct cc_libmcl_opndrec *)(0));
            } else {
                rx = cc_blockmcl_loadexpr(q,(((i64)11 + i) - (i64)1),(i64)0);
            };
        } else {
            if ((!!(variadic) && (cc_decls_ttbasetype[((i64)((*q).mode))] == (i64)11))) {
                cc_blockmcl_loadfloatparam(q,(i - (i64)1),(i64)(iscomplex[(i)-1]));
            } else {
                size = cc_decls_ttsize[((i64)((*q).mode))];
                if (!!((u64)(iscomplex[(i)-1]))) {
                    cc_libmcl_genmc((i64)7,(rx = cc_libmcl_genreg((i64)14,(i64)8)),(struct cc_libmcl_opndrec *)(0));
                    cc_libmcl_genmc((i64)10,(fx = cc_libmcl_genxreg((((i64)1 + i) - (i64)1),size)),cc_libmcl_changeopndsize(rx,size));
                } else {
                    fx = cc_blockmcl_floadexpr(q,(((i64)1 + i) - (i64)1));
                };
                if (!!(variadic)) {
                    cc_libmcl_genmc((i64)10,cc_libmcl_genreg((((i64)11 + i) - (i64)1),size),fx);
                };
            };
        };
L877 :;
    }L878 :;
    ;
    return popbytes;
}

static void cc_blockmcl_pushoneparam(struct cc_decls_unitrec * q,i64 variadic) {
    struct cc_libmcl_opndrec *  fx;
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  bx;
    if ((cc_libmcl_gettypecat(q) != (i64)82)) {
        if (!!(cc_libmcl_issimple(q))) {
            cc_blockmcl_loadexpr(q,(i64)11,(i64)0);
        } else {
            ax = cc_blockmcl_loadexpr(q,(i64)1,(i64)0);
            bx = cc_libmcl_genreg((i64)11,(i64)((*ax).size));
            cc_libmcl_genmc((i64)5,bx,ax);
        };
    } else {
        fx = cc_blockmcl_floadexpr(q,(i64)1);
        if (!!(variadic)) {
            cc_libmcl_genmc((i64)10,cc_libmcl_genreg((i64)11,cc_decls_ttsize[((i64)((*q).mode))]),fx);
        };
    };
}

static void cc_blockmcl_pushfloatparam(struct cc_decls_unitrec * q) {
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  bx;
    struct cc_libmcl_opndrec *  fx;
    fx = cc_blockmcl_floadexpr(q,(i64)14);
    cc_libmcl_genmc((i64)53,(ax = cc_libmcl_changeopndsize(fx,(i64)8)),fx);
    cc_libmcl_genmc((i64)10,(bx = cc_libmcl_genreg((i64)14,(i64)8)),ax);
    cc_libmcl_genmc((i64)6,bx,(struct cc_libmcl_opndrec *)(0));
}

static void cc_blockmcl_loadfloatparam(struct cc_decls_unitrec * q,i64 regoffset,i64 iscomplex) {
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  ax32;
    struct cc_libmcl_opndrec *  fx;
    struct cc_libmcl_opndrec *  fx32;
    fx = cc_libmcl_genxreg(((i64)1 + regoffset),(i64)8);
    fx32 = cc_libmcl_genxreg(((i64)1 + regoffset),(i64)4);
    ax = cc_libmcl_genreg(((i64)11 + regoffset),(i64)8);
    ax32 = cc_libmcl_genreg(((i64)11 + regoffset),(i64)4);
    if (!!(iscomplex)) {
        cc_libmcl_genmc((i64)7,ax,(struct cc_libmcl_opndrec *)(0));
        cc_libmcl_genmc((i64)10,fx32,ax32);
        cc_libmcl_genmc((i64)53,fx,fx32);
        cc_libmcl_genmc((i64)10,ax,fx);
    } else {
        cc_blockmcl_floadexpr(q,((i64)1 + regoffset));
        cc_libmcl_genmc((i64)53,fx,fx32);
        cc_libmcl_genmc((i64)10,ax,fx);
    };
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_call(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg) {
    struct cc_libmcl_opndrec *  result;
    struct cc_libmcl_opndrec *  cx;
    struct cc_libmcl_opndrec *  sx;
    struct cc_decls_paramrec *  pm;
    i64 isfnptr;
    i64 variadic;
    i64 nparams;
    i64 retmode;
    i64 nbytes;
    i64 retsize;
    i64 m;
    i64 nregparams;
    i64 i;
    retmode = (i64)((*p).mode);
    if ((retmode == (i64)1)) {
        retmode = (i64)4;
    };
    if (((i64)((*a).tag)==(i64)53)) {
        m = (i64)((*a).mode);
        L879 :;
        while ((cc_decls_ttbasetype[(m)] == (i64)16)) {
            m = cc_decls_tttarget[(m)];
L880 :;
        }L881 :;
        ;
        pm = cc_decls_ttparams[(m)];
        isfnptr = (i64)1;
    } else {
        pm = (*(*a).def).paramlist;
        isfnptr = (i64)0;
    };
    variadic = ((i64)((*pm).flags) == (i64)3);
    nparams = (i64)((*pm).nparams);
    nbytes = cc_blockmcl_pushffparams(b,variadic);
    retsize = cc_decls_ttsize[(retmode)];
    if ((retsize > (i64)8)) {
        cc_libmcl_doblockcall(retsize);
    };
    if (!(!!(isfnptr))) {
        cc_libmcl_genmc((i64)15,cc_libmcl_genmemaddr_u(a),(struct cc_libmcl_opndrec *)(0));
    } else {
        if (!!(cc_libmcl_issimple(a))) {
            cc_libmcl_genmc((i64)15,cc_libmcl_changeopndsize(cc_blockmcl_loadexpr((*a).a,(i64)1,(i64)0),(i64)8),(struct cc_libmcl_opndrec *)(0));
        } else {
            nregparams = (nparams<(i64)4?nparams:(i64)4);
            sx = cc_libmcl_genireg((i64)16,(i64)8);
            L882 :;
            for (i=(i64)1;i<=nregparams;i+=(i64)1) {
L883 :;
                cc_libmcl_genmc((i64)5,cc_libmcl_applyoffset(sx,((i - (i64)1) * (i64)8),(i64)0),cc_libmcl_genreg((((i64)11 + i) - (i64)1),(i64)8));
L884 :;
            }L885 :;
            ;
            cx = cc_libmcl_changeopndsize(cc_blockmcl_loadexpr((*a).a,(i64)1,(i64)0),(i64)8);
            sx = cc_libmcl_genireg((i64)16,(i64)8);
            L886 :;
            for (i=(i64)1;i<=nregparams;i+=(i64)1) {
L887 :;
                cc_libmcl_genmc((i64)5,cc_libmcl_genreg((((i64)11 + i) - (i64)1),(i64)8),cc_libmcl_applyoffset(sx,((i - (i64)1) * (i64)8),(i64)0));
L888 :;
            }L889 :;
            ;
            cc_libmcl_genmc((i64)15,cx,(struct cc_libmcl_opndrec *)(0));
        };
    };
    cc_libmcl_popstack(nbytes);
    if ((cc_libmcl_gettypecat(p) == (i64)82)) {
        result = cc_libmcl_genxreg(reg,retsize);
    } else if ((retsize <= (i64)8)) {
        result = cc_libmcl_genreg(reg,retsize);
    } else {
        result = cc_libmcl_getblockreg(retsize);
    };
    return result;
}

static void cc_blockmcl_do_return(struct cc_decls_unitrec * a) {
    cc_libmcl_leaveproc((*cc_decls_currproc).name);
    if (!!(a)) {
        if (!!(cc_lib_isrealcc((i64)((*a).mode)))) {
            cc_blockmcl_floadexpr(a,(i64)1);
        } else {
            cc_blockmcl_loadexpr(a,(i64)1,(i64)0);
            if (!!(cc_libmcl_structretoffset)) {
                cc_libmcl_copyretvalue(cc_decls_ttsize[((i64)((*a).mode))]);
            };
        };
    };
    cc_libmcl_genreturn(cc_libmcl_framebytes,cc_libmcl_parambytes);
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_sub(struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg) {
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  bx;
    i64 tx;
    i64 doneg;
    if ((cc_libmcl_gettypecat(a) == (i64)82)) {
        return cc_blockmcl_dx_fadd((i64)22,a,b,reg);
    };
    doneg = (i64)0;
    if (!!(cc_libmcl_issimple(b))) {
        //simplesub:
L890 :;
;
        ax = cc_blockmcl_loadexpr(a,reg,(i64)0);
        bx = cc_blockmcl_evalexpr(b,cc_libmcl_getnextreg(ax,reg));
    } else if (!!(cc_libmcl_issimple(a))) {
        ax = cc_blockmcl_loadexpr(b,reg,(i64)0);
        bx = cc_blockmcl_evalexpr(a,cc_libmcl_getnextreg(ax,reg));
        doneg = (i64)1;
    } else {
        tx = cc_blockmcl_saveexpr(b,reg);
        ax = cc_blockmcl_loadexpr(a,reg,(i64)0);
        bx = cc_blockmcl_restoreexpr(tx,cc_libmcl_getnextreg(ax,reg));
    };
    cc_libmcl_genmc((i64)22,ax,bx);
    if (!!(doneg)) {
        cc_libmcl_genmc((i64)36,ax,(struct cc_libmcl_opndrec *)(0));
    };
    return ax;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_mul(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg) {
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  bx;
    i64 x;
    i64 n;
    i64 tx;
    if ((cc_libmcl_gettypecat(a)==(i64)82)) {
        return cc_blockmcl_dx_fadd((i64)23,a,b,reg);
    };
    if ((((i64)((*b).tag) == (i64)1) && !!(cc_lib_isintcc((i64)((*b).mode))))) {
        x = (*b).value;
        if (!!((n = cc_libmcl_ispoweroftwo(x)))) {
            (*p).tag = (i64)48;
            (*b).value = n;
            return cc_blockmcl_dx_shl(p,a,b,reg);
        };
    };
    if (!!(cc_libmcl_issimple(b))) {
        ax = cc_blockmcl_loadexpr(a,reg,(i64)0);
        if (((((i64)((*a).tag) == (i64)3) && ((i64)((*b).tag) == (i64)3)) && ((*a).def == (*b).def))) {
            bx = ax;
        } else {
            bx = cc_blockmcl_evalexpr(b,cc_libmcl_getnextreg(ax,reg));
        };
    } else if (!!(cc_libmcl_issimple(a))) {
        ax = cc_blockmcl_loadexpr(b,reg,(i64)0);
        bx = cc_blockmcl_evalexpr(a,cc_libmcl_getnextreg(ax,reg));
    } else {
        tx = cc_blockmcl_saveexpr(b,reg);
        ax = cc_blockmcl_loadexpr(a,reg,(i64)0);
        bx = cc_blockmcl_restoreexpr(tx,cc_libmcl_getnextreg(ax,reg));
    };
    cc_libmcl_genmc((i64)23,ax,bx);
    return ax;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_div(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg) {
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  bx;
    i64 opc;
    i64 n;
    i64 tx;
    if ((cc_libmcl_gettypecat(a)==(i64)82)) {
        return cc_blockmcl_dx_fadd((i64)24,a,b,reg);
    }else if ((cc_libmcl_gettypecat(a)==(i64)73)) {
        opc = (i64)24;
    } else {
        opc = (i64)25;
    };
    if ((((i64)((*b).tag) == (i64)1) && !!(cc_lib_isintcc((i64)((*b).mode))))) {
        if (!!((n = cc_libmcl_ispoweroftwo((*b).value)))) {
            (*p).tag = (i64)49;
            (*b).value = n;
            return cc_blockmcl_dx_shl(p,a,b,reg);
        };
    };
    if ((reg != (i64)1)) {
        cc_support_gerror((byte*)"DIV REG NOT ZERO",(struct cc_decls_unitrec *)(0));
    };
    if (!!(cc_libmcl_issimple(b))) {
        ax = cc_blockmcl_loadexpr(a,reg,(i64)0);
        if (((i64)((*b).tag) == (i64)1)) {
            bx = cc_blockmcl_loadexpr(b,cc_libmcl_getnextreg(ax,reg),(i64)0);
        } else {
            bx = cc_blockmcl_evalexpr(b,cc_libmcl_getnextreg(ax,reg));
        };
    } else {
        tx = cc_blockmcl_saveexpr(b,reg);
        ax = cc_blockmcl_loadexpr(a,reg,(i64)0);
        bx = cc_blockmcl_restoreexpr(tx,cc_libmcl_getnextreg(ax,reg));
    };
    cc_libmcl_genmc(opc,bx,(struct cc_libmcl_opndrec *)(0));
    return ax;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_shl(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg) {
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  bx;
    i64 opc;
    i64 tx;
    if (((i64)((*p).tag) == (i64)48)) {
        opc = (i64)33;
    } else {
        if ((cc_libmcl_gettypecat(p)==(i64)73)) {
            opc = (i64)34;
        } else {
            opc = (i64)35;
        };
    };
    if ((!!(cc_libmcl_issimple(b)) && (reg != (i64)11))) {
        ax = cc_blockmcl_loadexpr(a,reg,(i64)0);
        if (((i64)((*b).tag) == (i64)1)) {
            bx = cc_blockmcl_evalexpr(b,(i64)11);
        } else {
            bx = cc_blockmcl_loadexpr(b,(i64)11,(i64)0);
        };
    } else {
        tx = cc_blockmcl_saveexpr(b,reg);
        ax = cc_blockmcl_loadexpr(a,reg,(i64)0);
        bx = cc_blockmcl_restoreexpr(tx,cc_libmcl_getnextreg(ax,reg));
    };
    cc_libmcl_genmc(opc,ax,bx);
    return ax;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_iand(i64 opc,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg) {
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  bx;
    i64 tx;
    if (!!(cc_libmcl_issimple(b))) {
        ax = cc_blockmcl_loadexpr(a,reg,(i64)0);
        bx = cc_blockmcl_evalexpr(b,cc_libmcl_getnextreg(ax,reg));
    } else if (!!(cc_libmcl_issimple(a))) {
        ax = cc_blockmcl_loadexpr(b,reg,(i64)0);
        bx = cc_blockmcl_evalexpr(a,cc_libmcl_getnextreg(ax,reg));
    } else {
        tx = cc_blockmcl_saveexpr(b,reg);
        ax = cc_blockmcl_loadexpr(a,reg,(i64)0);
        bx = cc_blockmcl_restoreexpr(tx,cc_libmcl_getnextreg(ax,reg));
    };
    cc_libmcl_genmc(opc,ax,bx);
    return ax;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_preincrx(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,i64 reg) {
    i64 opc;
    i64 size;
    struct cc_libmcl_opndrec *  ptropnd;
    struct cc_libmcl_opndrec *  result;
    ptropnd = cc_blockmcl_getlvalueopnd(a,reg);
    opc = (i64)5;
    result = cc_libmcl_genreg(cc_libmcl_getnextreg(ptropnd,reg),cc_libmcl_getopndsize_u(p));
    if (((i64)((*result).size) > (i64)((*ptropnd).size))) {
        cc_support_gerror((byte*)"PREINCRX WIDENING NEEDED",(struct cc_decls_unitrec *)(0));
    };
    cc_libmcl_genmc(opc,result,ptropnd);
    if (((cc_decls_ttbasetype[((i64)((*a).mode))] == (i64)16) && (cc_decls_ttsize[(cc_decls_tttarget[((i64)((*a).mode))])] != (i64)1))) {
        size = cc_decls_ttsize[(cc_decls_tttarget[((i64)((*a).mode))])];
        if (((i64)((*p).tag) == (i64)73)) {
            opc = (i64)21;
        } else {
            opc = (i64)22;
        };
        cc_libmcl_genmc(opc,result,cc_libmcl_genint(size,(i64)4));
    } else {
        cc_libmcl_genmc((((i64)((*p).tag) == (i64)73)?(i64)38:(i64)39),result,(struct cc_libmcl_opndrec *)(0));
    };
    cc_blockmcl_storeopnd(ptropnd,result);
    return result;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_postincrx(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,i64 reg) {
    i64 opc;
    i64 size;
    struct cc_libmcl_opndrec *  ptropnd;
    struct cc_libmcl_opndrec *  result;
    struct cc_libmcl_opndrec *  rr1;
    result = cc_libmcl_genreg(reg,cc_libmcl_getopndsize_u(p));
    ptropnd = cc_blockmcl_getlvalueopnd(a,(reg + (i64)1));
    opc = (i64)5;
    if (((i64)((*result).size) > (i64)((*ptropnd).size))) {
        cc_support_gerror((byte*)"POSTINCRX WIDENING NEEDED",(struct cc_decls_unitrec *)(0));
    };
    cc_libmcl_genmc(opc,(rr1 = cc_libmcl_genreg((cc_libmcl_getnextreg(ptropnd,reg) + (i64)1),cc_libmcl_getopndsize_u(p))),ptropnd);
    cc_libmcl_genmc((i64)5,result,rr1);
    if (((cc_decls_ttbasetype[((i64)((*a).mode))] == (i64)16) && (cc_decls_ttsize[(cc_decls_tttarget[((i64)((*a).mode))])] != (i64)1))) {
        size = cc_decls_ttsize[(cc_decls_tttarget[((i64)((*a).mode))])];
        if (((i64)((*p).tag) == (i64)75)) {
            opc = (i64)21;
        } else {
            opc = (i64)22;
        };
        cc_libmcl_genmc(opc,rr1,cc_libmcl_genint(size,(i64)4));
    } else {
        cc_libmcl_genmc((((i64)((*p).tag) == (i64)75)?(i64)38:(i64)39),rr1,(struct cc_libmcl_opndrec *)(0));
    };
    cc_blockmcl_storeopnd(ptropnd,rr1);
    return result;
}

static struct cc_libmcl_opndrec * cc_blockmcl_makeindexopnd(struct cc_decls_unitrec * a,struct cc_decls_unitrec * index,i64 scale,i64 size,i64 offset,i64 reg) {
    i64 mulfactor;
    i64 tx;
    i64 reg2;
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  ix;
    struct cc_libmcl_opndrec *  m;
    struct cc_decls_strec *  d;
    if ((!!(index) && ((i64)((*index).tag) == (i64)1))) {
        offset += ((*index).value * scale);
        index = (struct cc_decls_unitrec *)(0);
    };
    if (!!(index)) {
        if ((scale==(i64)1) || (scale==(i64)2) || (scale==(i64)4) || (scale==(i64)8)) {
            mulfactor = (i64)1;
        } else {
            mulfactor = scale;
            scale = (i64)1;
        };
    };
    if (((i64)((*a).tag) == (i64)3)) {
        d = (*a).def;
        if ((((i64)((u64)((*d).nameid)) == (i64)9) && !!(cc_lib_isstructunion((i64)((*d).mode))))) {
            goto L891 ;
;
        };
        if (!!(index)) {
            if ((mulfactor == (i64)1)) {
                ix = cc_blockmcl_loadexpr(index,reg,(i64)0);
                m = cc_libmcl_genindex((i64)0,(i64)((*ix).reg),scale,offset,size,(i64)0,d);
            } else {
                cc_blockmcl_loadexpr(index,reg,(i64)0);
                cc_blockmcl_mulreg(reg,mulfactor);
                m = cc_libmcl_genindex((i64)0,reg,scale,offset,size,(i64)0,d);
            };
        } else {
            m = cc_libmcl_genindex((i64)0,(i64)0,(i64)1,offset,size,(i64)0,d);
        };
    } else {
        //mx2:
L891 :;
;
        if (!!(index)) {
            if (!!(cc_libmcl_issimple(a))) {
                if ((mulfactor == (i64)1)) {
                    ix = cc_blockmcl_loadexpr(index,reg,(i64)0);
                    ax = cc_blockmcl_loadexpr(a,(reg + (i64)1),(i64)0);
                    m = cc_libmcl_genindex((i64)((*ax).reg),(i64)((*ix).reg),scale,offset,size,(i64)0,(struct cc_decls_strec *)(0));
                } else {
                    cc_blockmcl_loadexpr(index,reg,(i64)0);
                    cc_blockmcl_mulreg(reg,mulfactor);
                    cc_blockmcl_loadexpr(a,(reg + (i64)1),(i64)0);
                    m = cc_libmcl_genindex((reg + (i64)1),reg,scale,offset,size,(i64)0,(struct cc_decls_strec *)(0));
                };
            } else if (!!(cc_libmcl_issimple(index))) {
                cc_blockmcl_loadexpr(a,reg,(i64)0);
                cc_blockmcl_loadexpr(index,(reg + (i64)1),(i64)0);
                cc_blockmcl_mulreg((reg + (i64)1),mulfactor);
                m = cc_libmcl_genindex(reg,(reg + (i64)1),scale,offset,size,(i64)0,(struct cc_decls_strec *)(0));
            } else {
                tx = cc_blockmcl_saveexpr(a,reg);
                ix = cc_blockmcl_loadexpr(index,reg,(i64)0);
                cc_blockmcl_mulreg(reg,mulfactor);
                ax = cc_blockmcl_restoreexpr(tx,(reg2 = cc_libmcl_getnextreg(ix,reg)));
                m = cc_libmcl_genindex(reg2,reg,scale,offset,size,(i64)0,(struct cc_decls_strec *)(0));
            };
        } else {
            ax = cc_blockmcl_loadexpr(a,reg,(i64)0);
            m = cc_libmcl_genindex((i64)((*ax).reg),(i64)0,scale,offset,size,(i64)0,(struct cc_decls_strec *)(0));
        };
    };
    return m;
}

static void cc_blockmcl_mulreg(i64 reg,i64 x) {
    i64 n;
    if ((x > (i64)1)) {
        if (!!((n = cc_libmcl_ispoweroftwo(x)))) {
            cc_libmcl_genmc((i64)33,cc_libmcl_genreg(reg,(i64)8),cc_libmcl_genint(n,(i64)4));
        } else {
            cc_libmcl_genmc((i64)23,cc_libmcl_genreg(reg,(i64)8),cc_libmcl_genint(x,(i64)4));
        };
    };
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_ptr(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,i64 reg,i64 am) {
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  bx;
    if ((am == (i64)0)) {
        return cc_blockmcl_loadexpr(a,reg,(i64)0);
    };
    if ((cc_decls_ttbasetype[((i64)((*p).mode))] == (i64)17)) {
        cc_support_gerror((byte*)"deref/proc",(struct cc_decls_unitrec *)(0));
    };
    ax = cc_blockmcl_evalptr(a,reg);
    if (((i64)((*a).tag)==(i64)54) || ((i64)((*a).tag)==(i64)55)) {
        if (((i64)((u64)((*ax).mode)) != (i64)1)) {
            ax = cc_libmcl_applysize(ax,cc_decls_ttsize[((i64)((*p).mode))]);
            return ax;
        };
    }else if (((i64)((*a).tag)==(i64)56)) {
        return cc_blockmcl_dx_expr((*a).a,reg,am);
    };
    if (((i64)((u64)((*ax).mode)) != (i64)1)) {
        cc_libmcl_genmc((i64)5,(bx = cc_libmcl_genreg(reg,(i64)8)),ax);
        ax = bx;
    };
    ax = cc_libmcl_makeindirect(ax,cc_decls_ttsize[((i64)((*p).mode))]);
    return ax;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_addptr(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg,i64 am) {
    i64 size;
    i64 scale;
    i64 mulfactor;
    i64 reg1;
    i64 tx;
    i64 offset;
    struct cc_libmcl_opndrec *  m;
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  bx;
    struct cc_libmcl_opndrec *  rx;
    struct cc_decls_unitrec *  pname;
    size = (scale = cc_decls_ttsize[(cc_decls_tttarget[((i64)((*a).mode))])]);
    if (((i64)((*p).ptrscale) == (i64)0)) {
        scale = (i64)1;
    };
    offset = (i64)0;
    if (((i64)((*b).tag) == (i64)1)) {
        (*b).value *= scale;
        offset = (*b).value;
        scale = (i64)1;
    };
    if ((scale==(i64)2) || (scale==(i64)4) || (scale==(i64)8)) {
        mulfactor = (i64)1;
    } else {
        mulfactor = scale;
        scale = (i64)1;
    };
    reg1 = (reg + (i64)1);
    if (((i64)((*b).tag) == (i64)1)) {
        if (((i64)((*a).tag)==(i64)56)) {
            pname = (*a).a;
            if (((i64)((*pname).tag) != (i64)3)) {
                goto L892 ;
;
            };
            m = cc_libmcl_genindex((i64)0,(i64)0,(i64)1,offset,size,(i64)0,(*pname).def);
        } else {
            //other:
L892 :;
;
            cc_blockmcl_loadexpr(a,reg,(i64)0);
            m = cc_libmcl_genindex(reg,(i64)0,scale,(*b).value,size,(i64)0,(struct cc_decls_strec *)(0));
        };
    } else if ((((i64)((*a).tag) == (i64)56) && ((i64)((*(*a).a).tag) == (i64)3))) {
        pname = (*a).a;
        bx = cc_blockmcl_loadexpr(b,reg,(i64)0);
        cc_blockmcl_mulreg((i64)((*bx).reg),mulfactor);
        bx = cc_libmcl_makeindirect(bx,size);
        (*bx).regix = (u64)((*bx).reg);
        (*bx).reg = (u64)((i64)0);
        (*bx).scale = (u64)(scale);
        (*bx).def = (*pname).def;
        if (!!(cc_libmcl_isframe((*pname).def))) {
            (*bx).reg = (u64)((i64)15);
        };
        m = bx;
    } else if (!!(cc_libmcl_issimple(b))) {
        cc_blockmcl_loadexpr(a,reg,(i64)0);
        cc_blockmcl_loadexpr(b,reg1,(i64)0);
        cc_blockmcl_mulreg(reg1,mulfactor);
        m = cc_libmcl_genindex(reg,reg1,scale,(i64)0,size,(i64)0,(struct cc_decls_strec *)(0));
    } else if (!!(cc_libmcl_issimple(a))) {
        cc_blockmcl_loadexpr(b,reg,(i64)0);
        cc_blockmcl_mulreg(reg,mulfactor);
        cc_blockmcl_loadexpr(a,reg1,(i64)0);
        m = cc_libmcl_genindex(reg1,reg,scale,(i64)0,size,(i64)0,(struct cc_decls_strec *)(0));
    } else {
        //cxcx:
L893 :;
;
        tx = cc_blockmcl_saveexpr(b,reg);
        ax = cc_blockmcl_loadexpr(a,reg,(i64)0);
        bx = cc_blockmcl_restoreexpr(tx,cc_libmcl_getnextreg(ax,reg));
        cc_blockmcl_mulreg((i64)((*bx).reg),mulfactor);
        m = cc_libmcl_genindex(reg,(i64)((*bx).reg),scale,(i64)0,size,(i64)0,(struct cc_decls_strec *)(0));
    };
    if ((am==(i64)1)) {
        cc_libmcl_genmc((i64)8,(rx = cc_libmcl_genreg(reg,(i64)8)),m);
        return rx;
    };
    return m;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_subptr(struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg,i64 am) {
    i64 size;
    i64 scale;
    i64 mulfactor;
    i64 reg1;
    i64 tx;
    i64 offset;
    struct cc_libmcl_opndrec *  m;
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  bx;
    struct cc_libmcl_opndrec *  rx;
    size = (scale = cc_decls_ttsize[(cc_decls_tttarget[((i64)((*a).mode))])]);
    if ((cc_decls_ttbasetype[((i64)((*b).mode))] == (i64)16)) {
        ax = cc_blockmcl_dx_sub(a,b,reg);
        cc_blockmcl_divreg((i64)((*ax).reg),scale);
        return ax;
    };
    offset = (i64)0;
    if (((i64)((*b).tag) == (i64)1)) {
        (*b).value = ((*b).value * scale);
        offset = -((*b).value);
        scale = (i64)1;
    };
    mulfactor = scale;
    scale = (i64)1;
    reg1 = (reg + (i64)1);
    if ((((i64)((*a).tag) == (i64)56) && ((i64)((*(*a).a).tag) == (i64)3))) {
        a = (*a).a;
    };
    if (((i64)((*b).tag) == (i64)1)) {
        cc_blockmcl_loadexpr(a,reg,(i64)0);
        m = cc_libmcl_genindex(reg,(i64)0,scale,offset,size,(i64)0,(struct cc_decls_strec *)(0));
        if ((am == (i64)2)) {
            return m;
        };
        cc_libmcl_genmc((i64)8,(rx = cc_libmcl_genreg(reg,(i64)8)),m);
        return rx;
    } else if (!!(cc_libmcl_issimple(b))) {
        ax = cc_blockmcl_loadexpr(a,reg,(i64)0);
        bx = cc_blockmcl_loadexpr(b,reg1,(i64)0);
        cc_blockmcl_mulreg(reg1,mulfactor);
    } else if (!!(cc_libmcl_issimple(a))) {
        bx = cc_blockmcl_loadexpr(b,reg,(i64)0);
        cc_blockmcl_mulreg(reg,mulfactor);
        ax = cc_blockmcl_loadexpr(a,reg1,(i64)0);
    } else {
        //cxcx:
L894 :;
;
        tx = cc_blockmcl_saveexpr(b,reg);
        ax = cc_blockmcl_loadexpr(a,reg,(i64)0);
        bx = cc_blockmcl_restoreexpr(tx,cc_libmcl_getnextreg(ax,reg));
        cc_blockmcl_mulreg((i64)((*bx).reg),mulfactor);
    };
    m = cc_libmcl_genindex(reg,(i64)((*bx).reg),scale,(i64)0,size,(i64)0,(struct cc_decls_strec *)(0));
    cc_libmcl_genmc((i64)22,ax,bx);
    return ax;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_convert(struct cc_decls_unitrec * a,i64 t,i64 opc,i64 reg) {
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  rx;
    i64 ssize;
    i64 tsize;
    ssize = cc_decls_ttsize[((i64)((*a).mode))];
    tsize = cc_decls_ttsize[(t)];
    if ((opc==(i64)7) || (opc==(i64)8) || (opc==(i64)10) || (opc==(i64)9)) {
        ax = cc_blockmcl_fevalexpr(a,reg);
    } else {
        ax = cc_blockmcl_evalexpr(a,reg);
    };
    if ((opc==(i64)1)) {
        //dosoft:
L895 :;
;
        return ax;
    }else if ((opc==(i64)2)) {
        rx = cc_libmcl_genreg(reg,tsize);
        if ((tsize < ssize)) {
            cc_libmcl_genmc((i64)14,rx,ax);
        } else if ((tsize > ssize)) {
            cc_libmcl_genmc((i64)12,rx,ax);
        } else {
            return ax;
        };
    }else if ((opc==(i64)3) || (opc==(i64)4)) {
        if (((i64)((u64)((*ax).mode)) == (i64)2)) {
            (*ax).size = tsize;
            return ax;
        };
        if ((ssize == tsize)) {
            return ax;
        };
        rx = cc_libmcl_genreg(reg,tsize);
        cc_libmcl_genmc(((opc == (i64)3)?(i64)11:(i64)12),rx,ax);
    }else if ((opc==(i64)5) || (opc==(i64)6)) {
        rx = cc_libmcl_genxreg(reg,tsize);
        cc_libmcl_genmc(((opc == (i64)5)?(i64)52:(i64)51),rx,ax);
    }else if ((opc==(i64)7) || (opc==(i64)8)) {
        rx = cc_libmcl_genreg(reg,tsize);
        cc_libmcl_genmc(((opc == (i64)7)?(i64)50:(i64)49),rx,ax);
    }else if ((opc==(i64)10) || (opc==(i64)9)) {
        rx = cc_libmcl_genxreg(reg,tsize);
        cc_libmcl_genmc(((opc == (i64)10)?(i64)54:(i64)53),rx,ax);
    }else if ((opc==(i64)11) || (opc==(i64)12)) {
        rx = cc_libmcl_genreg(reg,tsize);
        cc_libmcl_genmc((i64)14,rx,ax);
    } else {
        cc_support_gerror_s((byte*)"Convert op not implem: %s",cc_tables_convnames[(opc)],(struct cc_decls_unitrec *)(0));
    };
    return rx;
}

static void cc_blockmcl_do_decl(struct cc_decls_strec * d) {
    struct cc_libmcl_opndrec *  ax;
    struct cc_decls_unitrec *  a;
    struct cc_decls_unitrec *  dest;
    byte str[256];
    i64 nbytes;
    a = (*d).code;
    if (((i64)((*a).tag) != (i64)29)) {
        if (((cc_decls_ttbasetype[((i64)((*d).mode))] == (i64)19) && ((i64)((*a).tag) == (i64)1))) {
            goto L896 ;
;
        };
        if ((cc_libmcl_gettypecat(a) == (i64)82)) {
            ax = cc_blockmcl_floadexpr(a,(i64)1);
            cc_libmcl_genmc((i64)10,cc_libmcl_genmem_d(d,(i64)0),ax);
        } else if (((i64)((*a).tag) != (i64)1)) {
            if ((cc_decls_ttsize[((i64)((*a).mode))]==(i64)1) || (cc_decls_ttsize[((i64)((*a).mode))]==(i64)2) || (cc_decls_ttsize[((i64)((*a).mode))]==(i64)4) || (cc_decls_ttsize[((i64)((*a).mode))]==(i64)8)) {
                ax = cc_blockmcl_loadexpr(a,(i64)1,(i64)0);
                cc_libmcl_genmc((i64)5,cc_libmcl_genmem_d(d,(i64)0),ax);
            } else {
                dest = cc_lib_createname(d);
                (*dest).mode = (i64)((*d).mode);
                cc_blockmcl_do_assignblock(dest,a,(i64)1);
            };
        } else {
            cc_libmcl_genmc((i64)5,cc_libmcl_genmem_d(d,(i64)0),cc_blockmcl_evalexpr(a,(i64)1));
        };
        return;
    };
    //copyl:
L896 :;
;
    nbytes = cc_decls_ttsize[((i64)((*d).mode))];
    cc_libmcl_pushstack((i64)32);
    cc_libmcl_genmc((i64)8,cc_libmcl_genreg((i64)11,(i64)8),cc_libmcl_genmem_d(d,(i64)0));
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_setfmt((byte*)"`$#.#.#");
    msysnewc_m_print_str((*cc_decls_currproc).name,NULL);
    msysnewc_m_print_str((*d).name,NULL);
    msysnewc_m_print_u64((*d).blockno,NULL);
    msysnewc_m_print_end();
    ;
    cc_libmcl_genmc((i64)5,cc_libmcl_genreg((i64)12,(i64)8),cc_libmcl_genname(str));
    cc_libmcl_genmc((i64)5,cc_libmcl_genreg((i64)13,(i64)8),cc_libmcl_genint(nbytes,(i64)4));
    cc_libmcl_genmc((i64)15,cc_libmcl_genname((byte*)"memcpy*"),(struct cc_libmcl_opndrec *)(0));
    cc_libmcl_popstack((i64)32);
}

static struct cc_libmcl_opndrec * cc_blockmcl_do_assignblock(struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 regx) {
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  bx;
    struct cc_libmcl_opndrec *  rx;
    struct cc_libmcl_opndrec *  rs;
    struct cc_libmcl_opndrec *  rd;
    struct cc_libmcl_opndrec *  rcount;
    struct cc_libmcl_opndrec *  bx2;
    struct cc_libmcl_opndrec *  rsa;
    struct cc_libmcl_opndrec *  rda;
    i64 rev;
    i64 workreg;
    i64 nwords;
    i64 lab;
    i64 regcount;
    i64 regsource;
    i64 regdest;
    i64 offset;
    i64 n;
    i64 oddbytes;
    i64 reg;
    i64 av_1;
    reg = (!!(regx)?regx:(i64)1);
    rev = (i64)0;
    if (!!(cc_libmcl_issimple(b))) {
        ax = cc_blockmcl_getlvalueopnd(a,reg);
        bx = cc_blockmcl_getlvalueopnd(b,cc_libmcl_getnextreg(ax,reg));
    } else if (!!(cc_libmcl_issimple(a))) {
        rev = (i64)1;
        ax = cc_blockmcl_getlvalueopnd(b,reg);
        bx = cc_blockmcl_getlvalueopnd(a,cc_libmcl_getnextreg(ax,reg));
    } else {
        bx = cc_blockmcl_getlvalueopnd(b,reg);
        if (((i64)((u64)((*bx).mode)) != (i64)1)) {
            cc_libmcl_genmc((i64)8,(bx2 = cc_libmcl_genreg(reg,(i64)8)),bx);
        } else {
            bx2 = bx;
        };
        cc_libmcl_genmc((i64)6,bx2,(struct cc_libmcl_opndrec *)(0));
        ax = cc_blockmcl_getlvalueopnd(a,reg);
        cc_libmcl_genmc((i64)7,(bx = cc_libmcl_genreg(cc_libmcl_getnextreg(ax,reg),(i64)8)),(struct cc_libmcl_opndrec *)(0));
        bx = cc_libmcl_genireg((i64)((*bx).reg),(i64)4);
    };
    if (((i64)((u64)((*ax).mode)) == (i64)1)) {
        ax = cc_libmcl_genireg((i64)((*ax).reg),(i64)4);
    };
    if (((i64)((u64)((*bx).mode)) == (i64)1)) {
        bx = cc_libmcl_genireg((i64)((*bx).reg),(i64)4);
    };
    if (!!(rev)) {
        {struct cc_libmcl_opndrec *  temp = ax; ax = bx; bx = temp; };
    };
    if (((cc_libmcl_getnextreg(ax,(i64)0) > (i64)5) || (cc_libmcl_getnextreg(bx,(i64)0) > (i64)5))) {
        cc_support_gerror((byte*)"ASSIGNBLOCK/REG",(struct cc_decls_unitrec *)(0));
    };
    workreg = (i64)5;
    n = cc_decls_ttsize[((i64)((*a).mode))];
    oddbytes = (n % (i64)8);
    n -= oddbytes;
    nwords = (n / (i64)8);
    if ((((i64)1 <= nwords) && (nwords <= (i64)4))) {
        offset = (i64)0;
        ax = cc_libmcl_changeopndsize(ax,(i64)8);
        bx = cc_libmcl_changeopndsize(bx,(i64)8);
        rx = cc_libmcl_genreg(workreg,(i64)8);
        av_1 = nwords;
        while (av_1-- > 0) {
L897 :;
            cc_libmcl_genmc((i64)5,rx,cc_libmcl_applyoffset(bx,offset,(i64)0));
            cc_libmcl_genmc((i64)5,cc_libmcl_applyoffset(ax,offset,(i64)0),rx);
            offset += (i64)8;
L898 :;
        }L899 :;
        ;
        rs = bx;
        rd = ax;
    } else if ((nwords != (i64)0)) {
        lab = ++cc_decls_labelno;
        regcount = (workreg + (i64)1);
        regsource = (regcount + (i64)1);
        regdest = (regsource + (i64)1);
        cc_libmcl_genmc((i64)8,(rsa = cc_libmcl_genreg(regsource,(i64)8)),bx);
        cc_libmcl_genmc((i64)8,(rda = cc_libmcl_genreg(regdest,(i64)8)),ax);
        rs = cc_libmcl_genireg(regsource,(i64)8);
        rd = cc_libmcl_genireg(regdest,(i64)8);
        rx = cc_libmcl_genreg(workreg,(i64)8);
        rcount = cc_libmcl_genreg(regcount,(i64)4);
        cc_libmcl_genmc((i64)5,rcount,cc_libmcl_genint(nwords,(i64)4));
        cc_libmcl_genmc((i64)3,cc_libmcl_genlabel(lab,(i64)0),(struct cc_libmcl_opndrec *)(0));
        cc_libmcl_genmc((i64)5,rx,rs);
        cc_libmcl_genmc((i64)5,rd,rx);
        cc_libmcl_genmc((i64)21,rsa,cc_libmcl_genint((i64)8,(i64)4));
        cc_libmcl_genmc((i64)21,rda,cc_libmcl_genint((i64)8,(i64)4));
        cc_libmcl_genmc((i64)39,rcount,(struct cc_libmcl_opndrec *)(0));
        cc_libmcl_genmc_cond((i64)19,(i64)5,cc_libmcl_genlabel(lab,(i64)0),(struct cc_libmcl_opndrec *)(0));
        offset = (i64)0;
    } else {
        rd = cc_libmcl_changeopndsize(ax,(i64)8);
        rs = cc_libmcl_changeopndsize(bx,(i64)8);
        offset = (i64)0;
    };
    if (!!(oddbytes)) {
        n = oddbytes;
        if ((n >= (i64)4)) {
            rx = cc_libmcl_genreg(workreg,(i64)4);
            cc_libmcl_genmc((i64)5,rx,cc_libmcl_applyoffset(rs,offset,(i64)0));
            cc_libmcl_genmc((i64)5,cc_libmcl_applyoffset(rd,offset,(i64)0),rx);
            n -= (i64)4;
            offset += (i64)4;
        };
        if ((n >= (i64)2)) {
            rx = cc_libmcl_genreg(workreg,(i64)2);
            cc_libmcl_genmc((i64)5,rx,cc_libmcl_applyoffset(rs,offset,(i64)0));
            cc_libmcl_genmc((i64)5,cc_libmcl_applyoffset(rd,offset,(i64)0),rx);
            n -= (i64)2;
            offset += (i64)2;
        };
        if ((n == (i64)1)) {
            rx = cc_libmcl_genreg(workreg,(i64)1);
            cc_libmcl_genmc((i64)5,rx,cc_libmcl_applyoffset(rs,offset,(i64)0));
            cc_libmcl_genmc((i64)5,cc_libmcl_applyoffset(rd,offset,(i64)0),rx);
        };
    };
    if (!!(regx)) {
        return cc_blockmcl_getlvalueopnd(a,reg);
    };
    return cc_libmcl_genint((i64)0,(i64)4);
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_widen(struct cc_decls_unitrec * a,i64 m,i64 reg) {
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  bx;
    i64 opc;
    opc = ((cc_libmcl_gettypecat(a) == (i64)73)?(i64)11:(i64)12);
    ax = cc_blockmcl_evalexpr(a,reg);
    if ((cc_decls_ttsize[(m)] == (i64)((*ax).size))) {
        return ax;
    };
    bx = cc_libmcl_genreg(reg,cc_decls_ttsize[(m)]);
    cc_libmcl_genmc(opc,bx,ax);
    return bx;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_neg(struct cc_decls_unitrec * a,i64 reg) {
    struct cc_libmcl_opndrec *  ax;
    if ((cc_libmcl_gettypecat(a) == (i64)82)) {
        return cc_blockmcl_dx_fneg(a,reg);
    };
    ax = cc_blockmcl_loadexpr(a,reg,(i64)0);
    cc_libmcl_genmc((i64)36,ax,(struct cc_libmcl_opndrec *)(0));
    return ax;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_fneg(struct cc_decls_unitrec * a,i64 reg) {
    struct cc_libmcl_opndrec *  fx;
    fx = cc_blockmcl_floadexpr(a,reg);
    cc_libmcl_genmc((i64)41,fx,(struct cc_libmcl_opndrec *)(0));
    return fx;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_inot(struct cc_decls_unitrec * a,i64 reg) {
    struct cc_libmcl_opndrec *  ax;
    ax = cc_blockmcl_loadexpr(a,reg,(i64)0);
    cc_libmcl_genmc((i64)37,ax,(struct cc_libmcl_opndrec *)(0));
    return ax;
}

static void cc_blockmcl_do_switch(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b) {
    i64 labeltable[500];
    i64 valuetable[500];
    byte flags[500];
    i64 defaultlabel;
    i64 breakswlabel;
    i64 switchlabel;
    i64 lower;
    i64 upper;
    i64 length;
    i64 value;
    i64 ncases;
    byte serialsw;
    i64 i;
    i64 index;
    struct cc_decls_caserec *  pcase;
    struct cc_libmcl_opndrec *  ax;
    i64 (*old_labeltable)[];
    i64 (*old_valuetable)[];
    i64 old_ncases;
    i64 old_lower;
    byte old_defaultseen;
    i64 old_defaultlabel;
    i64 old_breaklabel;
    pcase = (*p).nextcase;
    ncases = (length = (i64)0);
    L900 :;
    while (!!(pcase)) {
        ++ncases;
        if ((ncases > (i64)500)) {
            cc_support_gerror((byte*)"Too many cases on one switch",(struct cc_decls_unitrec *)(0));
        };
        valuetable[(ncases)-1] = (value = (*pcase).value);
        if ((ncases == (i64)1)) {
            lower = (upper = value);
        } else {
            lower = (lower<value?lower:value);
            upper = (upper>value?upper:value);
        };
        pcase = (*pcase).nextcase;
L901 :;
    }L902 :;
    ;
    if (!!((*p).nextcase)) {
        length = ((upper - lower) + (i64)1);
    } else {
        length = (i64)0;
    };
    defaultlabel = cc_libmcl_createfwdlabel();
    breakswlabel = cc_libmcl_createfwdlabel();
    if ((length > (i64)500)) {
        serialsw = (u64)((i64)1);
        ax = cc_blockmcl_loadexpr(a,(i64)1,(i64)0);
        L903 :;
        for (i=(i64)1;i<=ncases;i+=(i64)1) {
L904 :;
            labeltable[(i)-1] = cc_libmcl_createfwdlabel();
            cc_libmcl_genmc((i64)32,ax,cc_libmcl_genint(valuetable[(i)-1],(i64)4));
            cc_libmcl_genmc_cond((i64)19,(i64)4,cc_libmcl_genlabel(labeltable[(i)-1],(i64)0),(struct cc_libmcl_opndrec *)(0));
L905 :;
        }L906 :;
        ;
        cc_libmcl_genmc((i64)18,cc_libmcl_genlabel(defaultlabel,(i64)0),(struct cc_libmcl_opndrec *)(0));
    } else if ((length == (i64)0)) {
        cc_libmcl_genmc((i64)18,cc_libmcl_genlabel(defaultlabel,(i64)0),(struct cc_libmcl_opndrec *)(0));
    } else {
        serialsw = (u64)((i64)0);
        memset((void *)(&flags),(i64)0,(u64)(length));
        L907 :;
        for (i=(i64)1;i<=length;i+=(i64)1) {
L908 :;
            labeltable[(i)-1] = defaultlabel;
L909 :;
        }L910 :;
        ;
        L911 :;
        for (i=(i64)1;i<=ncases;i+=(i64)1) {
L912 :;
            value = valuetable[(i)-1];
            index = ((value - lower) + (i64)1);
            labeltable[(index)-1] = cc_libmcl_createfwdlabel();
            if (!!((u64)(flags[(index)-1]))) {
                cc_support_gerror_s((byte*)"Dupl case value: %d",(byte *)(value),(struct cc_decls_unitrec *)(0));
            };
            flags[(index)-1] = (u64)((i64)1);
L913 :;
        }L914 :;
        ;
        switchlabel = cc_libmcl_createfwdlabel();
        ax = cc_blockmcl_loadexpr(a,(i64)1,(i64)0);
        cc_libmcl_genmc((i64)22,ax,cc_libmcl_genint(lower,(i64)4));
        cc_libmcl_genmc((i64)32,ax,cc_libmcl_genint(length,(i64)4));
        cc_libmcl_genmc_cond((i64)19,(i64)3,cc_libmcl_genlabel(defaultlabel,(i64)0),(struct cc_libmcl_opndrec *)(0));
        cc_libmcl_genmc((i64)18,cc_libmcl_genindex((i64)0,(i64)1,(i64)8,(i64)0,(i64)0,switchlabel,(struct cc_decls_strec *)(0)),(struct cc_libmcl_opndrec *)(0));
        cc_libmcl_setsegment((i64)73,(i64)8);
        cc_libmcl_definefwdlabel(switchlabel);
        L915 :;
        for (i=(i64)1;i<=length;i+=(i64)1) {
L916 :;
            cc_libmcl_genmc((i64)61,cc_libmcl_genlabel(labeltable[(i)-1],(i64)0),(struct cc_libmcl_opndrec *)(0));
L917 :;
        }L918 :;
        ;
        cc_libmcl_setsegment((i64)67,(i64)1);
    };
    old_labeltable = cc_blockmcl_sw_labeltable;
    old_valuetable = cc_blockmcl_sw_valuetable;
    old_lower = cc_blockmcl_sw_lower;
    old_ncases = cc_blockmcl_sw_ncases;
    old_defaultseen = (u64)(cc_blockmcl_sw_defaultseen);
    old_defaultlabel = cc_blockmcl_sw_defaultlabel;
    old_breaklabel = cc_blockmcl_sw_breaklabel;
    cc_blockmcl_sw_labeltable = &labeltable;
    cc_blockmcl_sw_valuetable = &valuetable;
    cc_blockmcl_sw_lower = lower;
    cc_blockmcl_sw_ncases = (!!((u64)(serialsw))?ncases:(i64)0);
    cc_blockmcl_sw_defaultseen = (u64)((i64)0);
    cc_blockmcl_sw_defaultlabel = defaultlabel;
    cc_blockmcl_sw_breaklabel = breakswlabel;
    cc_blockmcl_do_stmt(b);
    if (!(!!((u64)(cc_blockmcl_sw_defaultseen)))) {
        cc_libmcl_definefwdlabel(defaultlabel);
    };
    cc_libmcl_definefwdlabel(breakswlabel);
    cc_blockmcl_sw_labeltable = old_labeltable;
    cc_blockmcl_sw_valuetable = old_valuetable;
    cc_blockmcl_sw_lower = old_lower;
    cc_blockmcl_sw_ncases = old_ncases;
    cc_blockmcl_sw_defaultseen = (u64)(old_defaultseen);
    cc_blockmcl_sw_defaultlabel = old_defaultlabel;
    cc_blockmcl_sw_breaklabel = old_breaklabel;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_rem(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg) {
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  bx;
    i64 tx;
    i64 n;
    i64 opc;
    if ((cc_libmcl_gettypecat(a)==(i64)73)) {
        opc = (i64)26;
    } else {
        opc = (i64)27;
        if ((((i64)((*b).tag) == (i64)1) && !!(cc_lib_isintcc((i64)((*b).mode))))) {
            if (!!((n = cc_libmcl_ispoweroftwo((*b).value)))) {
                (*p).tag = (i64)49;
                (*b).value = ((*b).value - (i64)1);
                return cc_blockmcl_dx_iand((i64)28,a,b,reg);
            };
        };
    };
    if ((reg != (i64)1)) {
        cc_support_gerror((byte*)"REM REG NOT ZERO",(struct cc_decls_unitrec *)(0));
    };
    if (!!(cc_libmcl_issimple(b))) {
        ax = cc_blockmcl_loadexpr(a,reg,(i64)0);
        if (((i64)((*b).tag) == (i64)1)) {
            bx = cc_blockmcl_loadexpr(b,cc_libmcl_getnextreg(ax,reg),(i64)0);
        } else {
            bx = cc_blockmcl_evalexpr(b,cc_libmcl_getnextreg(ax,reg));
        };
    } else {
        tx = cc_blockmcl_saveexpr(b,reg);
        ax = cc_blockmcl_loadexpr(a,reg,(i64)0);
        bx = cc_blockmcl_restoreexpr(tx,cc_libmcl_getnextreg(ax,reg));
    };
    cc_libmcl_genmc(opc,bx,(struct cc_libmcl_opndrec *)(0));
    return ax;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_ifx(struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,struct cc_decls_unitrec * c,i64 reg) {
    struct cc_libmcl_opndrec *  bx;
    struct cc_libmcl_opndrec *  result;
    i64 lab1;
    i64 lab2;
    i64 isreal;
    lab1 = cc_libmcl_createfwdlabel();
    lab2 = cc_libmcl_createfwdlabel();
    isreal = (cc_libmcl_gettypecat(b) == (i64)82);
    cc_blockmcl_genjumpcond((i64)0,a,lab1,reg);
    if (!!(isreal)) {
        result = cc_blockmcl_floadexpr(b,reg);
    } else {
        result = cc_blockmcl_loadexpr(b,reg,(i64)0);
    };
    cc_libmcl_genjumpl(lab2);
    cc_libmcl_definefwdlabel(lab1);
    if (!!(isreal)) {
        bx = cc_blockmcl_floadexpr(c,reg);
    } else {
        bx = cc_blockmcl_loadexpr(c,reg,(i64)0);
    };
    cc_libmcl_definefwdlabel(lab2);
    return result;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_addto(i64 opc,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 regx) {
    struct cc_libmcl_opndrec *  rhs;
    struct cc_libmcl_opndrec *  ptropnd;
    struct cc_libmcl_opndrec *  rr2;
    i64 reg;
    i64 tx;
    if ((cc_libmcl_gettypecat(b) == (i64)82)) {
        return cc_blockmcl_dx_faddto(opc,a,b,regx);
    };
    reg = (!!(regx)?regx:(i64)1);
    if (!!(cc_libmcl_issimple(b))) {
        ptropnd = cc_blockmcl_getlvalueopnd(a,reg);
        if ((((i64)((*b).tag) == (i64)1) && ((i64)((*b).mode) == (i64)4))) {
            rhs = cc_blockmcl_evalexpr(b,cc_libmcl_getnextreg(ptropnd,reg));
        } else {
            rhs = cc_blockmcl_loadexpr(b,cc_libmcl_getnextreg(ptropnd,reg),(i64)0);
        };
        rhs = cc_libmcl_changeopndsize(rhs,(i64)((*ptropnd).size));
        cc_libmcl_genmc(opc,ptropnd,rhs);
    } else if (!!(cc_libmcl_issimple(a))) {
        rhs = cc_blockmcl_loadexpr(b,reg,(i64)0);
        ptropnd = cc_blockmcl_getlvalueopnd(a,cc_libmcl_getnextreg(rhs,reg));
        rhs = cc_libmcl_changeopndsize(rhs,(i64)((*ptropnd).size));
        cc_libmcl_genmc(opc,ptropnd,rhs);
    } else {
        tx = cc_blockmcl_saveexpr(b,reg);
        ptropnd = cc_blockmcl_getlvalueopnd(a,reg);
        rr2 = cc_blockmcl_restoreexpr(tx,cc_libmcl_getnextreg(ptropnd,reg));
        rr2 = cc_libmcl_changeopndsize(rr2,(i64)((*ptropnd).size));
        cc_libmcl_genmc(opc,ptropnd,rr2);
    };
    return ptropnd;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_faddto(i64 opc,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 regx) {
    struct cc_libmcl_opndrec *  work;
    struct cc_libmcl_opndrec *  rhs;
    struct cc_libmcl_opndrec *  ptropnd;
    i64 reg;
    i64 tx;
    reg = (!!(regx)?regx:(i64)1);
    if (!!(cc_libmcl_issimple(b))) {
        ptropnd = cc_blockmcl_getlvalueopnd(a,reg);
        reg = cc_libmcl_getnextreg(ptropnd,reg);
        rhs = cc_blockmcl_fevalexpr(b,reg);
        reg = cc_libmcl_getnextreg(rhs,reg);
    } else if (!!(cc_libmcl_issimple(a))) {
        rhs = cc_blockmcl_fevalexpr(b,reg);
        reg = cc_libmcl_getnextreg(rhs,reg);
        ptropnd = cc_blockmcl_getlvalueopnd(a,reg);
        reg = cc_libmcl_getnextreg(ptropnd,reg);
    } else {
        tx = cc_blockmcl_saveexpr(b,reg);
        ptropnd = cc_blockmcl_getlvalueopnd(a,reg);
        reg = cc_libmcl_getnextreg(ptropnd,reg);
        rhs = cc_blockmcl_frestoreexpr(tx,reg);
        ++reg;
    };
    work = cc_libmcl_genxreg(reg,cc_libmcl_getopndsize_u(b));
    cc_libmcl_genmc((i64)10,work,ptropnd);
    if ((opc==(i64)21)) {
        opc = (i64)44;
    }else if ((opc==(i64)22)) {
        opc = (i64)45;
    }else if ((opc==(i64)23)) {
        opc = (i64)46;
    }else if ((opc==(i64)24)) {
        opc = (i64)47;
    };
    cc_libmcl_genmc(opc,work,rhs);
    cc_libmcl_genmc((i64)10,ptropnd,work);
    return ptropnd;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_eq(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg) {
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  bx;
    struct cc_libmcl_opndrec *  rx;
    struct cc_libmcl_opndrec *  rxb;
    i64 mclcond;
    i64 tx;
    mclcond = cc_libmcl_getmclcond((i64)((*p).tag),(i64)((*a).mode));
    if ((mclcond==(i64)20) || (mclcond==(i64)21) || (mclcond==(i64)16) || (mclcond==(i64)17) || (mclcond==(i64)18) || (mclcond==(i64)19)) {
        if (!!(cc_libmcl_issimple(b))) {
            ax = cc_blockmcl_floadexpr(a,reg);
            bx = cc_blockmcl_fevalexpr(b,cc_libmcl_getnextreg(ax,reg));
        } else if (!!(cc_libmcl_issimple(a))) {
            mclcond = cc_blockmcl_reversemclcond(mclcond);
            ax = cc_blockmcl_floadexpr(b,reg);
            bx = cc_blockmcl_fevalexpr(a,cc_libmcl_getnextreg(ax,reg));
        } else {
            tx = cc_blockmcl_saveexpr(b,reg);
            ax = cc_blockmcl_floadexpr(a,reg);
            bx = cc_blockmcl_frestoreexpr(tx,cc_libmcl_getnextreg(ax,reg));
        };
        cc_libmcl_genmc((i64)48,ax,bx);
    } else {
        if (!!(cc_libmcl_issimple(b))) {
            ax = cc_blockmcl_loadexpr(a,reg,(i64)0);
            bx = cc_blockmcl_evalexpr(b,cc_libmcl_getnextreg(ax,reg));
        } else if (!!(cc_libmcl_issimple(a))) {
            mclcond = cc_blockmcl_reversemclcond(mclcond);
            ax = cc_blockmcl_loadexpr(b,reg,(i64)0);
            bx = cc_blockmcl_evalexpr(a,reg);
        } else {
            tx = cc_blockmcl_saveexpr(b,reg);
            ax = cc_blockmcl_loadexpr(a,reg,(i64)0);
            bx = cc_blockmcl_restoreexpr(tx,cc_libmcl_getnextreg(ax,reg));
        };
        cc_libmcl_genmc((i64)32,ax,bx);
    };
    rx = cc_libmcl_genreg(reg,(i64)4);
    rxb = cc_libmcl_genreg(reg,(i64)1);
    cc_libmcl_genmc_cond((i64)40,mclcond,rxb,(struct cc_libmcl_opndrec *)(0));
    cc_libmcl_genmc((i64)12,rx,rxb);
    return rx;
}

static void cc_blockmcl_do_exprlist(struct cc_decls_unitrec * a) {
    L919 :;
    while (!!(a)) {
        cc_blockmcl_do_stmt(a);
        a = (*a).nextunit;
L920 :;
    }L921 :;
    ;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_exprlist(struct cc_decls_unitrec * a,i64 reg) {
    struct cc_libmcl_opndrec *  ax;
    L922 :;
    while (!!(a)) {
        ax = cc_blockmcl_dx_expr(a,reg,(i64)1);
        a = (*a).nextunit;
L923 :;
    }L924 :;
    ;
    return ax;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_shlto(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 regx) {
    struct cc_libmcl_opndrec *  rhs;
    struct cc_libmcl_opndrec *  ptropnd;
    struct cc_libmcl_opndrec *  rr2;
    i64 reg;
    i64 tx;
    i64 opc;
    if (((i64)((*p).tag) == (i64)70)) {
        opc = (i64)33;
    } else {
        if ((cc_libmcl_gettypecat(p)==(i64)73)) {
            opc = (i64)34;
        } else {
            opc = (i64)35;
        };
    };
    reg = (!!(regx)?regx:(i64)1);
    if (!!(cc_libmcl_issimple(b))) {
        ptropnd = cc_blockmcl_getlvalueopnd(a,reg);
        if ((((i64)((*b).tag) == (i64)1) && ((i64)((*b).mode) == (i64)4))) {
            rhs = cc_blockmcl_evalexpr(b,cc_libmcl_getnextreg(ptropnd,reg));
        } else {
            rhs = cc_blockmcl_loadexpr(b,cc_libmcl_getnextreg(ptropnd,reg),(i64)0);
        };
        rhs = cc_libmcl_changeopndsize(rhs,(i64)((*ptropnd).size));
        cc_libmcl_genmc(opc,ptropnd,rhs);
    } else if (!!(cc_libmcl_issimple(a))) {
        rhs = cc_blockmcl_loadexpr(b,reg,(i64)0);
        ptropnd = cc_blockmcl_getlvalueopnd(a,cc_libmcl_getnextreg(rhs,reg));
        rhs = cc_libmcl_changeopndsize(rhs,(i64)((*ptropnd).size));
        cc_libmcl_genmc(opc,ptropnd,rhs);
    } else {
        tx = cc_blockmcl_saveexpr(b,reg);
        ptropnd = cc_blockmcl_getlvalueopnd(a,reg);
        rr2 = cc_blockmcl_restoreexpr(tx,cc_libmcl_getnextreg(ptropnd,reg));
        rr2 = cc_libmcl_changeopndsize(rr2,(i64)((*ptropnd).size));
        cc_libmcl_genmc(opc,ptropnd,rr2);
    };
    return ptropnd;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_multo(struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 regx) {
    struct cc_libmcl_opndrec *  work;
    struct cc_libmcl_opndrec *  rhs;
    struct cc_libmcl_opndrec *  ptropnd;
    i64 reg;
    i64 tx;
    i64 sgned;
    if ((cc_libmcl_gettypecat(b)==(i64)82)) {
        return cc_blockmcl_dx_faddto((i64)23,a,b,regx);
    }else if ((cc_libmcl_gettypecat(b)==(i64)73)) {
        sgned = (i64)1;
    } else {
        sgned = (i64)0;
    };
    reg = (!!(regx)?regx:(i64)1);
    work = cc_libmcl_genreg(reg,cc_libmcl_getopndsize_u(b));
    ++reg;
    if (!!(cc_libmcl_issimple(b))) {
        ptropnd = cc_blockmcl_getlvalueopnd(a,reg);
        reg = cc_libmcl_getnextreg(ptropnd,reg);
        rhs = cc_blockmcl_evalexpr(b,reg);
        reg = cc_libmcl_getnextreg(rhs,reg);
    } else if (!!(cc_libmcl_issimple(a))) {
        rhs = cc_blockmcl_evalexpr(b,reg);
        reg = cc_libmcl_getnextreg(rhs,reg);
        ptropnd = cc_blockmcl_getlvalueopnd(a,reg);
        reg = cc_libmcl_getnextreg(ptropnd,reg);
    } else {
        tx = cc_blockmcl_saveexpr(b,reg);
        ptropnd = cc_blockmcl_getlvalueopnd(a,reg);
        reg = cc_libmcl_getnextreg(ptropnd,reg);
        rhs = cc_blockmcl_restoreexpr(tx,reg);
        ++reg;
    };
    cc_blockmcl_loadviaptr(work,ptropnd,sgned);
    cc_libmcl_genmc((i64)23,work,rhs);
    cc_libmcl_genmc((i64)5,ptropnd,cc_libmcl_changeopndsize(work,(i64)((*ptropnd).size)));
    return ptropnd;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_notl(struct cc_decls_unitrec * a,i64 reg) {
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  rx;
    struct cc_libmcl_opndrec *  rxb;
    if (((i64)((*a).tag) == (i64)27)) {
        return cc_blockmcl_dx_istruel((*a).a,reg);
    };
    ax = cc_blockmcl_loadexpr(a,reg,(i64)0);
    cc_libmcl_genmc((i64)28,ax,ax);
    rx = cc_libmcl_genreg(reg,(i64)4);
    rxb = cc_libmcl_genreg(reg,(i64)1);
    cc_libmcl_genmc_cond((i64)40,(i64)4,rxb,(struct cc_libmcl_opndrec *)(0));
    cc_libmcl_genmc((i64)12,rx,rxb);
    return rx;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_istruel(struct cc_decls_unitrec * a,i64 reg) {
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  rx;
    struct cc_libmcl_opndrec *  rxb;
    ax = cc_blockmcl_loadexpr(a,reg,(i64)0);
    cc_libmcl_genmc((i64)28,ax,ax);
    rx = cc_libmcl_genreg(reg,(i64)4);
    rxb = cc_libmcl_genreg(reg,(i64)1);
    cc_libmcl_genmc_cond((i64)40,(i64)5,rxb,(struct cc_libmcl_opndrec *)(0));
    cc_libmcl_genmc((i64)12,rx,rxb);
    return rx;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_andorl(struct cc_decls_unitrec * p,i64 reg) {
    i64 lab1;
    i64 lab2;
    struct cc_libmcl_opndrec *  rx;
    lab1 = cc_libmcl_createfwdlabel();
    cc_blockmcl_genjumpcond((i64)0,p,lab1,(i64)1);
    rx = cc_libmcl_genreg(reg,(i64)4);
    lab2 = cc_libmcl_createfwdlabel();
    cc_libmcl_genmc((i64)5,rx,cc_libmcl_genint((i64)1,(i64)4));
    cc_libmcl_genjumpl(lab2);
    cc_libmcl_definefwdlabel(lab1);
    cc_libmcl_genmc((i64)5,rx,cc_libmcl_genint((i64)0,(i64)4));
    cc_libmcl_definefwdlabel(lab2);
    return rx;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_sqrt(struct cc_decls_unitrec * a,i64 reg) {
    struct cc_libmcl_opndrec *  fx;
    fx = cc_blockmcl_floadexpr(a,reg);
    cc_libmcl_genmc((i64)43,fx,fx);
    return fx;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_scale(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg) {
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  bx;
    struct cc_libmcl_opndrec *  cx;
    i64 opc;
    i64 scale;
    i64 n;
    ax = cc_blockmcl_loadexpr(a,reg,(i64)0);
    scale = (i64)((*p).scale);
    opc = (i64)23;
    if ((scale < (i64)0)) {
        scale = -(scale);
        opc = (i64)24;
    };
    n = cc_libmcl_ispoweroftwo(scale);
    if ((n == (i64)0)) {
        bx = cc_libmcl_genint(scale,(i64)4);
        if ((opc == (i64)23)) {
            cc_libmcl_genmc((i64)23,ax,bx);
        } else {
            if (((i64)((u64)((*ax).reg)) != (i64)1)) {
                cc_support_gerror((byte*)"scale/div by non-power-of-two/not r0",(struct cc_decls_unitrec *)(0));
            };
            cc_libmcl_genmc((i64)5,(cx = cc_libmcl_genreg((reg + (i64)1),(i64)((*ax).size))),bx);
            cc_libmcl_genmc((i64)24,cx,(struct cc_libmcl_opndrec *)(0));
        };
    } else {
        bx = cc_libmcl_genint(n,(i64)4);
        if ((opc == (i64)23)) {
            cc_libmcl_genmc((i64)33,ax,bx);
        } else {
            cc_libmcl_genmc((i64)34,ax,bx);
        };
    };
    return ax;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_divto(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 regx) {
    struct cc_libmcl_opndrec *  work;
    struct cc_libmcl_opndrec *  rhs;
    struct cc_libmcl_opndrec *  ptropnd;
    i64 reg;
    i64 tx;
    i64 opc;
    i64 sgned;
    if ((cc_libmcl_gettypecat(b)==(i64)82)) {
        return cc_blockmcl_dx_faddto((i64)24,a,b,regx);
    }else if ((cc_libmcl_gettypecat(b)==(i64)73)) {
        opc = (((i64)((*p).tag) == (i64)65)?(i64)24:(i64)26);
        sgned = (i64)1;
    } else {
        opc = (((i64)((*p).tag) == (i64)65)?(i64)25:(i64)27);
        sgned = (i64)0;
    };
    reg = (!!(regx)?regx:(i64)1);
    if ((reg != (i64)1)) {
        cc_support_gerror((byte*)"DIVTO: not R0",(struct cc_decls_unitrec *)(0));
    };
    work = cc_libmcl_genreg(reg,cc_libmcl_getopndsize_u(b));
    ++reg;
    if (!!(cc_libmcl_issimple(b))) {
        ptropnd = cc_blockmcl_getlvalueopnd(a,reg);
        reg = cc_libmcl_getnextreg(ptropnd,reg);
        rhs = cc_blockmcl_evalexpr(b,reg);
        reg = cc_libmcl_getnextreg(rhs,reg);
    } else if (!!(cc_libmcl_issimple(a))) {
        rhs = cc_blockmcl_evalexpr(b,reg);
        reg = cc_libmcl_getnextreg(rhs,reg);
        ptropnd = cc_blockmcl_getlvalueopnd(a,reg);
        reg = cc_libmcl_getnextreg(ptropnd,reg);
    } else {
        tx = cc_blockmcl_saveexpr(b,reg);
        ptropnd = cc_blockmcl_getlvalueopnd(a,reg);
        reg = cc_libmcl_getnextreg(ptropnd,reg);
        rhs = cc_blockmcl_restoreexpr(tx,reg);
        ++reg;
    };
    cc_blockmcl_loadviaptr(work,ptropnd,sgned);
    cc_libmcl_genmc(opc,rhs,(struct cc_libmcl_opndrec *)(0));
    cc_libmcl_genmc((i64)5,ptropnd,cc_libmcl_changeopndsize(work,(i64)((*ptropnd).size)));
    return ptropnd;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_name(struct cc_decls_unitrec * p,i64 reg,i64 am) {
    struct cc_libmcl_opndrec *  ax;
    if (((i64)((*(*p).def).nameid)==(i64)6)) {
        return cc_libmcl_genmemaddr_u(p);
    };
    ax = cc_libmcl_genmem_u(p,(i64)0);
    return ax;
}

static void cc_blockmcl_divreg(i64 reg,i64 x) {
    struct cc_libmcl_opndrec *  rr2;
    i64 n;
    if ((x > (i64)1)) {
        if (!!((n = cc_libmcl_ispoweroftwo(x)))) {
            cc_libmcl_genmc((i64)34,cc_libmcl_genreg(reg,(i64)8),cc_libmcl_genint(n,(i64)4));
        } else {
            if ((reg != (i64)1)) {
                cc_support_gerror((byte*)"DIVREG NOT R0",(struct cc_decls_unitrec *)(0));
            };
            cc_libmcl_genmc((i64)66,(struct cc_libmcl_opndrec *)(0),(struct cc_libmcl_opndrec *)(0));
            cc_libmcl_genmc((i64)5,(rr2 = cc_libmcl_genreg((i64)3,(i64)8)),cc_libmcl_genint(x,(i64)4));
            cc_libmcl_genmc((i64)24,rr2,(struct cc_libmcl_opndrec *)(0));
        };
    };
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_addrof(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,i64 reg,i64 am) {
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  bx;
    if (((i64)((*a).tag) == (i64)3)) {
        ax = cc_libmcl_genmem_u(a,(i64)0);
    } else {
        ax = cc_blockmcl_evaladdr(a,reg);
    };
    if (((am != (i64)0) && ((i64)((u64)((*ax).mode)) != (i64)1))) {
        cc_libmcl_genmc((i64)8,(bx = cc_libmcl_genreg(reg,(i64)8)),ax);
        return bx;
    };
    return ax;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_dot(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg,i64 am) {
    struct cc_libmcl_opndrec *  ax;
    ax = cc_blockmcl_evalexpr(a,reg);
    ax = cc_libmcl_applyoffset(ax,(i64)((*p).offset),cc_decls_ttsize[((i64)((*p).mode))]);
    return ax;
}

static void cc_blockmcl_loadviaptr(struct cc_libmcl_opndrec * w,struct cc_libmcl_opndrec * ptropnd,i64 sgned) {
    if (((i64)((*w).size) <= (i64)((*ptropnd).size))) {
        cc_libmcl_genmc((i64)5,w,ptropnd);
        return;
    };
    cc_libmcl_genmc((!!(sgned)?(i64)11:(i64)12),w,ptropnd);
}

i64 cc_genasm_codegen_writeasm(i64 moduleno,byte * outfile) {
    struct cc_decls_strec *  d;
    mlib_gs_init(cc_libmcl_dest);
    cc_genasm_inita64();
    cc_decls_stmodule = cc_decls_moduletable[(moduleno)].stmodule;
    mlib_gs_str(cc_libmcl_dest,(byte*)"!x64 output for ");
    mlib_gs_str(cc_libmcl_dest,(*cc_decls_stmodule).name);
    mlib_gs_strln(cc_libmcl_dest,(byte*)".c");
    cc_genasm_writetoasm(cc_libmcl_modulecode);
    d = (*cc_decls_stmodule).deflist;
    L925 :;
    while (!!(d)) {
        if (((i64)((*d).nameid)==(i64)6)) {
            cc_decls_currproc = d;
            cc_genasm_writetoasm((struct cc_libmcl_mclrec *)((*d).mclcode));
        };
        d = (*d).nextdef;
L926 :;
    }L927 :;
    ;
    cc_genasm_writefabs();
    cc_genasm_genstringtable();
    cc_genasm_genwstringtable();
    cc_genasm_genrealtable();
    cc_genasm_gendinttable();
    cc_genasm_terma64();
    if (!!(cc_decls_fastasm)) {
    } else {
        if (!!(cc_decls_fverbose)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((byte*)"Writing",NULL);
            msysnewc_m_print_str(outfile,NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_str((byte*)":",NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
        };
        mlib_writefile(outfile,(byte *)((*cc_libmcl_dest).strptr),(i64)((*cc_libmcl_dest).length));
    };
    cc_decls_moduletable[(moduleno)].asmstr = (*cc_libmcl_dest).strptr;
    return (i64)1;
}

void cc_genasm_inita64(void) {
    cc_genasm_initasmline();
    cc_genasm_stringtable = (byte * (*)[])(mlib_pcm_alloc((i64)8192));
    cc_genasm_stringlentable = (i64 (*)[])(mlib_pcm_alloc((i64)8192));
    cc_genasm_realtable = (double (*)[])(mlib_pcm_alloc((i64)128));
    cc_genasm_dinttable = (i64 (*)[])(mlib_pcm_alloc((i64)128));
    cc_genasm_stringtablesize = (i64)1024;
    cc_genasm_realtablesize = (i64)16;
    cc_genasm_dinttablesize = (i64)16;
}

void cc_genasm_terma64(void) {
}

static void cc_genasm_writetoasm(struct cc_libmcl_mclrec * m) {
    L928 :;
    while (!!(m)) {
        cc_genasm_mcltoa64(m);
        m = (*m).nextmcl;
L929 :;
    }L930 :;
    ;
}

void cc_genasm_mcltoa64(struct cc_libmcl_mclrec * m) {
    i64 opcode;
    i64 cond;
    struct cc_libmcl_opndrec *  a;
    struct cc_libmcl_opndrec *  b;
    cc_genasm_currmcl = m;
    opcode = (i64)((*m).opcode);
    cond = (i64)((*m).cond);
    a = (*m).a;
    b = (*m).b;
    switch (opcode) {
    case 1:;
    {
        cc_genasm_do_comment(a,b);
    }break;
    case 2:;
    {
        cc_genasm_do_blank(a,b);
    }break;
    case 68:;
    {
        cc_genasm_do_end(a,b);
    }break;
    case 3:;
    {
        cc_genasm_do_label(a,b);
    }break;
    case 4:;
    {
        cc_genasm_do_labelname(a,b);
    }break;
    case 5:;
    {
        cc_genasm_do_mov(a,b);
    }break;
    case 6:;
    {
        cc_genasm_do_push(a);
    }break;
    case 7:;
    {
        cc_genasm_do_pop(a);
    }break;
    case 8:;
    {
        cc_genasm_do_lea(a,b);
    }break;
    case 9:;
    {
        cc_genasm_do_cmovcc(a,b,cond);
    }break;
    case 10:;
    {
        cc_genasm_do_fmov(a,b);
    }break;
    case 11:;
    {
        cc_genasm_do_changeop((i64)74);
    }break;
    case 12:;
    {
        cc_genasm_do_changeop((i64)73);
    }break;
    case 13:;
    {
        cc_genasm_do_inarrow(a,b);
    }break;
    case 14:;
    {
        cc_genasm_do_unarrow(a,b);
    }break;
    case 15:;
    {
        cc_genasm_do_call(a,b);
    }break;
    case 16:;
    {
        cc_genasm_do_ret(a,b);
    }break;
    case 17:;
    {
        cc_genasm_do_retn(a,b);
    }break;
    case 18:;
    {
        cc_genasm_do_jmp(a,b);
    }break;
    case 19:;
    {
        cc_genasm_do_jmpcc(a,b,cond);
    }break;
    case 20:;
    {
        cc_genasm_do_exch(a,b);
    }break;
    case 21:;
    {
        cc_genasm_do_add(a,b);
    }break;
    case 22:;
    {
        cc_genasm_do_sub(a,b);
    }break;
    case 23:;
    {
        cc_genasm_do_imul(a,b);
    }break;
    case 24:;
    case 25:;
    {
        cc_genasm_do_idiv(a);
    }break;
    case 26:;
    {
        cc_genasm_do_irem(a);
    }break;
    case 27:;
    {
        cc_genasm_do_urem(a);
    }break;
    case 28:;
    {
        cc_genasm_do_and(a,b);
    }break;
    case 29:;
    {
        cc_genasm_do_or(a,b);
    }break;
    case 30:;
    {
        cc_genasm_do_xor(a,b);
    }break;
    case 31:;
    {
        cc_genasm_do_test(a,b);
    }break;
    case 32:;
    {
        cc_genasm_do_cmp(a,b);
    }break;
    case 33:;
    {
        cc_genasm_do_shl((i64)33,a,b);
    }break;
    case 34:;
    {
        cc_genasm_do_shl((i64)70,a,b);
    }break;
    case 35:;
    {
        cc_genasm_do_shl((i64)71,a,b);
    }break;
    case 36:;
    {
        cc_genasm_do_neg(a,b);
    }break;
    case 37:;
    {
        cc_genasm_do_not(a,b);
    }break;
    case 38:;
    {
        cc_genasm_do_inc(a,b);
    }break;
    case 39:;
    {
        cc_genasm_do_dec(a,b);
    }break;
    case 40:;
    {
        cc_genasm_do_setcc(a,b,cond);
    }break;
    case 41:;
    {
        cc_genasm_do_fneg(a);
    }break;
    case 42:;
    {
        cc_genasm_do_fabs(a);
    }break;
    case 43:;
    {
        cc_genasm_do_changeop((((i64)((*a).size) == (i64)4)?(i64)95:(i64)96));
    }break;
    case 44:;
    {
        if (((i64)((u64)((*b).mode)) == (i64)2)) {
            cc_genasm_convertimm(b,(i64)1);
        };
        cc_genasm_do_changeop((((i64)((*a).size) == (i64)4)?(i64)79:(i64)80));
    }break;
    case 45:;
    {
        if (((i64)((u64)((*b).mode)) == (i64)2)) {
            cc_genasm_convertimm(b,(i64)1);
        };
        cc_genasm_do_changeop((((i64)((*a).size) == (i64)4)?(i64)81:(i64)82));
    }break;
    case 46:;
    {
        if (((i64)((u64)((*b).mode)) == (i64)2)) {
            cc_genasm_convertimm(b,(i64)1);
        };
        cc_genasm_do_changeop((((i64)((*a).size) == (i64)4)?(i64)83:(i64)84));
    }break;
    case 47:;
    {
        if (((i64)((u64)((*b).mode)) == (i64)2)) {
            cc_genasm_convertimm(b,(i64)1);
        };
        cc_genasm_do_changeop((((i64)((*a).size) == (i64)4)?(i64)85:(i64)86));
    }break;
    case 48:;
    {
        if (((i64)((u64)((*b).mode)) == (i64)2)) {
            cc_genasm_convertimm(b,(i64)1);
        };
        cc_genasm_do_changeop((((i64)((*a).size) == (i64)4)?(i64)87:(i64)88));
    }break;
    case 49:;
    {
        cc_genasm_do_ufix(a,b);
    }break;
    case 50:;
    {
        cc_genasm_do_ifix(a,b);
    }break;
    case 51:;
    {
        cc_genasm_do_ufloat(a,b);
    }break;
    case 52:;
    {
        cc_genasm_do_ifloat(a,b);
    }break;
    case 53:;
    {
        cc_genasm_convertimm(b,(i64)0);
        cc_genasm_do_changeop((i64)91);
    }break;
    case 54:;
    {
        cc_genasm_do_changeop((i64)92);
    }break;
    case 55:;
    {
        cc_genasm_do_changeop((((i64)((*a).size) == (i64)4)?(i64)97:(i64)99));
    }break;
    case 56:;
    {
        cc_genasm_do_changeop((((i64)((*a).size) == (i64)4)?(i64)98:(i64)100));
    }break;
    case 58:;
    {
        cc_genasm_do_db(a,b);
    }break;
    case 59:;
    {
        cc_genasm_do_dw(a,b);
    }break;
    case 60:;
    {
        cc_genasm_do_dd(a,b);
    }break;
    case 61:;
    {
        cc_genasm_do_dq(a,b);
    }break;
    case 62:;
    {
        cc_genasm_do_defstr((*a).svalue,(i64)((*a).slength));
    }break;
    case 63:;
    {
        cc_genasm_do_defwstr((*a).wsvalue,(i64)((*a).wslength));
    }break;
    case 64:;
    {
        cc_genasm_do_align(a,b);
    }break;
    case 65:;
    {
        cc_genasm_do_segment(a,b);
    }break;
    case 67:;
    {
        cc_genasm_do_assem(a,b);
    }break;
    case 57:;
    {
        cc_genasm_convmcl();
    }break;
    default: {
        cc_support_gerror_s((byte*)"a64:UNKNOWN MCL OP: %s",cc_libmcl_mclnames[(opcode)-1],(struct cc_decls_unitrec *)(0));
    }
    } //SW
;
}

static void cc_genasm_passthru(i64 opc) {
    cc_genasm_strmclx(cc_genasm_currmcl);
    mlib_gs_strn(cc_libmcl_dest,cc_genasm_asmstart,(cc_genasm_asmptr - cc_genasm_asmstart));
}

static void cc_genasm_convmcl(void) {
    cc_genasm_strmclx(cc_genasm_currmcl);
    mlib_gs_strn(cc_libmcl_dest,cc_genasm_asmstart,(cc_genasm_asmptr - cc_genasm_asmstart));
}

static void cc_genasm_do_changeop(i64 opc) {
    (*cc_genasm_currmcl).opcode = (u64)(opc);
    cc_genasm_convmcl();
}

static void cc_genasm_do_comment(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    mlib_gs_str(cc_libmcl_dest,(byte*)"! ");
    mlib_gs_strln(cc_libmcl_dest,(*a).svalue);
}

static void cc_genasm_do_blank(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    mlib_gs_line(cc_libmcl_dest);
}

static void cc_genasm_do_end(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    cc_genasm_passthru((i64)68);
}

static void cc_genasm_do_label(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    cc_genasm_passthru((i64)3);
}

static void cc_genasm_do_labelname(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    cc_genasm_passthru((i64)4);
}

static void cc_genasm_do_mov(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    struct cc_libmcl_mclrec *  m;
    if ((((i64)((u64)((*a).mode)) == (i64)1) && ((i64)((u64)((*b).mode)) == (i64)2))) {
        cc_genasm_convertimm(b,(i64)0);
    } else if ((((i64)((u64)((*a).mode)) == (i64)4) && ((i64)((u64)((*b).mode)) == (i64)2))) {
        if (((i64)((*b).size) == (i64)8)) {
            cc_genasm_convertimm(b,(i64)0);
            m = cc_genasm_currmcl;
            cc_libmcl_initmcdest();
            cc_libmcl_genmc((i64)5,cc_libmcl_genreg((i64)14,(i64)8),b);
            cc_genasm_domclseq(cc_libmcl_mccode);
            cc_genasm_currmcl = m;
            (*m).b = cc_libmcl_genreg((i64)14,(i64)8);
        } else {
            if (((i64)((*a).size) == (i64)8)) {
                cc_genasm_convertimm(b,(i64)-1);
            } else {
                cc_genasm_convertimm(b,(i64)0);
            };
        };
    };
    cc_genasm_convmcl();
}

static void cc_genasm_do_push(struct cc_libmcl_opndrec * a) {
    if (((i64)((*a).mode)==(i64)1)) {
        if (((i64)((*a).size) != (i64)8)) {
            (*a).size = (i64)8;
        };
    }else if (((i64)((*a).mode)==(i64)2)) {
        cc_genasm_convertimm(a,(i64)1);
        if (((i64)((*a).size) != (i64)8)) {
            (*a).size = (i64)8;
        };
    }else if (((i64)((*a).mode)==(i64)4)) {
        if (((i64)((*a).size) != (i64)8)) {
            cc_libmcl_initmcdest();
            if (((i64)((*a).size)==(i64)1) || ((i64)((*a).size)==(i64)2) || ((i64)((*a).size)==(i64)4) || ((i64)((*a).size)==(i64)8)) {
                cc_libmcl_genmc((i64)5,cc_libmcl_genreg((i64)14,(i64)((*a).size)),a);
            } else {
                cc_libmcl_genmc((i64)8,cc_libmcl_genreg((i64)14,(i64)8),a);
            };
            cc_libmcl_genmc((i64)6,cc_libmcl_genreg((i64)14,(i64)8),(struct cc_libmcl_opndrec *)(0));
            cc_genasm_domclseq(cc_libmcl_mccode);
            return;
        };
    }else if (((i64)((*a).mode)==(i64)6)) {
        if (((i64)((*a).size) == (i64)4)) {
            mlib_gs_str(cc_libmcl_dest,(byte*)"\tmovd A13, ");
            mlib_gs_strln(cc_libmcl_dest,cc_genasm_fgetregnamex((i64)((*a).reg)));
        } else {
            mlib_gs_str(cc_libmcl_dest,(byte*)"\tmovq D13, ");
            mlib_gs_strln(cc_libmcl_dest,cc_genasm_fgetregnamex((i64)((*a).reg)));
        };
        mlib_gs_strln(cc_libmcl_dest,(byte*)"\tpush D13");
        return;
    };
    cc_genasm_convmcl();
}

static void cc_genasm_do_pop(struct cc_libmcl_opndrec * a) {
    if (((i64)((*a).mode)==(i64)6)) {
        mlib_gs_strln(cc_libmcl_dest,(byte*)"\tpop D13");
        if (((i64)((*a).size) == (i64)4)) {
            mlib_gs_str(cc_libmcl_dest,(byte*)"\tmovd ");
            mlib_gs_str(cc_libmcl_dest,cc_genasm_fgetregnamex((i64)((*a).reg)));
            mlib_gs_strln(cc_libmcl_dest,(byte*)", A13");
        } else {
            mlib_gs_str(cc_libmcl_dest,(byte*)"\tmovq ");
            mlib_gs_str(cc_libmcl_dest,cc_genasm_fgetregnamex((i64)((*a).reg)));
            mlib_gs_strln(cc_libmcl_dest,(byte*)", D13");
        };
        return;
    };
    cc_genasm_convmcl();
}

static void cc_genasm_do_lea(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    cc_genasm_passthru((i64)8);
}

static void cc_genasm_do_cmovcc(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b,i64 cond) {
    cc_genasm_passthru((i64)9);
}

static void cc_genasm_do_fmov(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    if (((i64)((u64)((*b).mode)) == (i64)2)) {
        cc_genasm_convertimm(b,(i64)1);
    };
    cc_genasm_do_changeop((((i64)((*a).size) == (i64)4)?(i64)77:(i64)78));
}

static void cc_genasm_do_iwiden(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    cc_genasm_passthru((i64)11);
}

static void cc_genasm_do_uwiden(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    cc_genasm_passthru((i64)12);
}

static void cc_genasm_do_inarrow(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    cc_genasm_passthru((i64)13);
}

static void cc_genasm_do_unarrow(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    i64 asize;
    asize = (i64)((*a).size);
    if ((asize == (i64)4)) {
        (*cc_genasm_currmcl).b = cc_libmcl_changeopndsize(b,(i64)4);
        cc_genasm_do_changeop((i64)5);
    } else {
        if ((((i64)((u64)((*b).mode)) == (i64)1) && ((u64)((*a).reg) == (u64)((*b).reg)))) {
        } else {
            cc_libmcl_initmcdest();
            cc_libmcl_genmc((i64)5,cc_libmcl_changeopndsize(a,(i64)((*b).size)),b);
            cc_genasm_domclseq(cc_libmcl_mccode);
        };
        cc_libmcl_initmcdest();
        if ((asize > (i64)2)) {
            cc_support_gerror((byte*)"unarrow 4->8?",(struct cc_decls_unitrec *)(0));
        };
        cc_libmcl_genmc((i64)28,a,cc_libmcl_genint((asize==1?(i64)255:(asize==2?(i64)65535:(i64)0)),(i64)4));
        cc_genasm_domclseq(cc_libmcl_mccode);
    };
}

static void cc_genasm_do_call(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    cc_genasm_passthru((i64)15);
}

static void cc_genasm_do_ret(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    cc_genasm_passthru((i64)16);
}

static void cc_genasm_do_retn(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    cc_genasm_passthru((i64)17);
}

static void cc_genasm_do_jmp(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    cc_genasm_passthru((i64)18);
}

static void cc_genasm_do_jmpcc(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b,i64 cond) {
    cc_genasm_passthru((i64)19);
}

static void cc_genasm_do_exch(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    cc_genasm_passthru((i64)20);
}

static void cc_genasm_do_add(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    if (((i64)((u64)((*b).mode)) == (i64)2)) {
        cc_genasm_convertimm(b,(i64)1);
    };
    cc_genasm_passthru((i64)21);
}

static void cc_genasm_do_sub(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    if (((i64)((u64)((*b).mode)) == (i64)2)) {
        cc_genasm_convertimm(b,(i64)1);
    };
    cc_genasm_passthru((i64)22);
}

static void cc_genasm_do_imul(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    if ((!!(b) && !!((u64)((*b).mode)))) {
        (*cc_genasm_currmcl).opcode = (u64)((i64)69);
    };
    if (((i64)((u64)((*b).mode)) == (i64)2)) {
        cc_genasm_convertimm(b,(i64)1);
    };
    cc_genasm_convmcl();
}

static void cc_genasm_do_idiv(struct cc_libmcl_opndrec * a) {
    struct cc_libmcl_opndrec *  dx;
    struct cc_libmcl_mclrec *  m;
    if (((i64)((u64)((*a).mode)) == (i64)2)) {
        m = cc_genasm_currmcl;
        cc_libmcl_initmcdest();
        cc_libmcl_genmc((i64)5,(dx = cc_libmcl_genreg((i64)14,(i64)((*a).size))),a);
        cc_genasm_domclseq(cc_libmcl_mccode);
        cc_genasm_currmcl = m;
        (*cc_genasm_currmcl).a = dx;
    };
    if (((i64)((u64)((*a).reg)) == (i64)12)) {
        cc_support_gerror((byte*)"asm/div/dividing by edx",(struct cc_decls_unitrec *)(0));
    };
    if (((i64)((u64)((*cc_genasm_currmcl).opcode)) == (i64)24)) {
        mlib_gs_strln(cc_libmcl_dest,(((i64)((*a).size) <= (i64)4)?(byte*)"\tcdq":(byte*)"\tcqo"));
        cc_genasm_convmcl();
    } else {
        mlib_gs_strln(cc_libmcl_dest,(byte*)"\txor rdx,rdx");
        cc_genasm_do_changeop((i64)72);
    };
}

static void cc_genasm_do_irem(struct cc_libmcl_opndrec * a) {
    (*cc_genasm_currmcl).opcode = (u64)((i64)24);
    cc_genasm_do_idiv(a);
    mlib_gs_strln(cc_libmcl_dest,(byte*)"\txchg rax,rdx");
}

static void cc_genasm_do_urem(struct cc_libmcl_opndrec * a) {
    (*cc_genasm_currmcl).opcode = (u64)((i64)25);
    cc_genasm_do_idiv(a);
    mlib_gs_strln(cc_libmcl_dest,(byte*)"\txchg rax,rdx");
}

static void cc_genasm_do_and(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    if (((i64)((u64)((*b).mode)) == (i64)2)) {
        if (((i64)((*a).size) <= (i64)4)) {
            (*b).value = ((*b).value & (i64)4294967295);
            cc_genasm_convertimm(b,(i64)0);
        } else {
            cc_genasm_convertimm(b,(i64)1);
        };
    };
    cc_genasm_passthru((i64)28);
}

static void cc_genasm_do_or(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    if (((i64)((u64)((*b).mode)) == (i64)2)) {
        if (((i64)((*a).size) <= (i64)4)) {
            (*b).value = ((*b).value & (i64)4294967295);
            cc_genasm_convertimm(b,(i64)0);
        } else {
            cc_genasm_convertimm(b,(i64)1);
        };
    };
    cc_genasm_passthru((i64)29);
}

static void cc_genasm_do_xor(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    if (((i64)((u64)((*b).mode)) == (i64)2)) {
        if (((i64)((*a).size) <= (i64)4)) {
            (*b).value = ((*b).value & (i64)4294967295);
            cc_genasm_convertimm(b,(i64)0);
        } else {
            cc_genasm_convertimm(b,(i64)1);
        };
    };
    cc_genasm_passthru((i64)30);
}

static void cc_genasm_do_test(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    if (((i64)((u64)((*b).mode)) == (i64)2)) {
        cc_genasm_convertimm(b,(i64)1);
    };
    cc_genasm_passthru((i64)31);
}

static void cc_genasm_do_cmp(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    if (((i64)((u64)((*b).mode)) == (i64)2)) {
        cc_genasm_convertimm(b,(i64)1);
    };
    cc_genasm_passthru((i64)32);
}

static void cc_genasm_do_shl(i64 opc,struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    i64 exchreg;
    i64 breg;
    (*cc_genasm_currmcl).opcode = (u64)(opc);
    if (((i64)((*b).mode)==(i64)1)) {
        breg = (i64)((*b).reg);
        if ((((i64)((u64)((*a).mode)) == (i64)1) && ((i64)((u64)((*a).reg)) == (i64)11))) {
            mlib_gs_str(cc_libmcl_dest,(byte*)"\txchg D10,");
            mlib_gs_strln(cc_libmcl_dest,cc_genasm_getregnamex(breg,(i64)8));
            (*cc_genasm_currmcl).a = cc_libmcl_genreg(breg,(i64)((*a).size));
            (*cc_genasm_currmcl).b = cc_libmcl_genreg((i64)11,(i64)1);
            cc_genasm_convmcl();
            mlib_gs_str(cc_libmcl_dest,(byte*)"\txchg D10,");
            mlib_gs_strln(cc_libmcl_dest,cc_genasm_getregnamex(breg,(i64)8));
        } else {
            (*b).size = (i64)1;
            exchreg = (i64)0;
            if (((i64)((u64)((*b).reg)) != (i64)11)) {
                mlib_gs_str(cc_libmcl_dest,(byte*)"\txchg D10,");
                mlib_gs_strln(cc_libmcl_dest,cc_genasm_getregnamex((i64)((*b).reg),(i64)8));
                exchreg = (i64)((*b).reg);
                (*b).reg = (u64)((i64)11);
            };
            cc_genasm_convmcl();
            if (!!(exchreg)) {
                mlib_gs_str(cc_libmcl_dest,(byte*)"\txchg D10,");
                mlib_gs_strln(cc_libmcl_dest,cc_genasm_getregnamex(exchreg,(i64)8));
            };
        };
        return;
    }else if (((i64)((*b).mode)==(i64)2)) {
    }else if (((i64)((*b).mode)==(i64)4)) {
        cc_support_gerror((byte*)"SHL/MEM",(struct cc_decls_unitrec *)(0));
    };
    cc_genasm_convmcl();
}

static void cc_genasm_do_neg(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    cc_genasm_passthru((i64)36);
}

static void cc_genasm_do_not(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    cc_genasm_passthru((i64)37);
}

static void cc_genasm_do_inc(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    cc_genasm_passthru((i64)38);
}

static void cc_genasm_do_dec(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    cc_genasm_passthru((i64)39);
}

static void cc_genasm_do_setcc(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b,i64 cond) {
    cc_genasm_passthru((i64)40);
}

static void cc_genasm_do_fneg(struct cc_libmcl_opndrec * a) {
    if (((i64)((*a).size) == (i64)4)) {
        (*cc_genasm_currmcl).opcode = (u64)((i64)101);
        (*cc_genasm_currmcl).b = cc_libmcl_genname((byte*)"[fchsmask_ps]");
    } else {
        (*cc_genasm_currmcl).opcode = (u64)((i64)102);
        (*cc_genasm_currmcl).b = cc_libmcl_genname((byte*)"[fchsmask_pd]");
    };
    cc_libmcl_fchsused = (i64)1;
    cc_genasm_convmcl();
}

static void cc_genasm_do_fabs(struct cc_libmcl_opndrec * a) {
    if (((i64)((*a).size) == (i64)4)) {
        (*cc_genasm_currmcl).opcode = (u64)((i64)103);
        (*cc_genasm_currmcl).b = cc_libmcl_genname((byte*)"[fabsmask_ps]");
    } else {
        (*cc_genasm_currmcl).opcode = (u64)((i64)104);
        (*cc_genasm_currmcl).b = cc_libmcl_genname((byte*)"[fabsmask_pd]");
    };
    cc_libmcl_fabsused = (i64)1;
    cc_genasm_convmcl();
}

static void cc_genasm_do_fsqrt(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    cc_genasm_passthru((i64)43);
}

static void cc_genasm_do_ufix(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    cc_genasm_do_ifix(a,b);
}

static void cc_genasm_do_ifix(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    cc_genasm_do_changeop((((i64)((*b).size) == (i64)4)?(i64)93:(i64)94));
}

static void cc_genasm_do_ufloat(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    struct cc_libmcl_opndrec *  rx;
    struct cc_libmcl_opndrec *  fx;
    byte *  name;
    rx = cc_libmcl_genreg((i64)11,(i64)((*b).size));
    fx = cc_libmcl_genxreg((i64)16,(i64)((*a).size));
    if (((i64)((*a).size) == (i64)4)) {
        if (((i64)((*b).size) == (i64)4)) {
            name = (byte*)"m$ufloat_r32u32*";
        } else {
            name = (byte*)"m$ufloat_r32u64*";
        };
    } else {
        if (((i64)((*b).size) == (i64)4)) {
            name = (byte*)"m$ufloat_r64u32*";
        } else {
            name = (byte*)"m$ufloat_r64u64*";
        };
    };
    cc_libmcl_initmcdest();
    cc_libmcl_genmc((i64)5,rx,b);
    cc_libmcl_genmc((i64)15,cc_libmcl_genname(name),(struct cc_libmcl_opndrec *)(0));
    cc_libmcl_genmc((i64)10,a,fx);
    cc_genasm_domclseq(cc_libmcl_mccode);
}

static void cc_genasm_do_ifloat(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    cc_genasm_do_changeop((((i64)((*a).size) == (i64)4)?(i64)89:(i64)90));
}

static void cc_genasm_do_db(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    cc_genasm_passthru((i64)58);
}

static void cc_genasm_do_dw(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    cc_genasm_passthru((i64)59);
}

static void cc_genasm_do_dd(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    cc_genasm_convertimm(a,(i64)0);
    cc_genasm_passthru((i64)60);
}

static void cc_genasm_do_dq(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    cc_genasm_convertimm(a,(i64)0);
    cc_genasm_passthru((i64)61);
}

static void cc_genasm_do_align(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    cc_genasm_passthru((i64)64);
}

static void cc_genasm_do_segment(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    cc_genasm_passthru((i64)65);
}

static void cc_genasm_do_assem(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    mlib_gs_strln(cc_libmcl_dest,(*a).svalue);
}

static void cc_genasm_strmclasm(struct cc_libmcl_mclrec * mcl) {
    struct cc_libmcl_opndrec *  a;
    struct cc_libmcl_opndrec *  b;
    i64 opcode;
    i64 cond;
    i64 sizepref;
    i64 n;
    cc_genasm_initasmline();
    opcode = (i64)((*mcl).opcode);
    cond = (i64)((*mcl).cond);
    a = (*mcl).a;
    b = (*mcl).b;
    if ((opcode==(i64)67)) {
        cc_genasm_asmstr((*a).svalue);
        return;
    }else if ((opcode==(i64)2)) {
        return;
    }else if ((opcode==(i64)1)) {
        cc_genasm_asmchar((i64)33);
        cc_genasm_asmstr((*a).svalue);
        return;
    }else if ((opcode==(i64)4)) {
        cc_genasm_asmstr((*a).svalue);
        return;
    }else if ((opcode==(i64)3)) {
        cc_genasm_asmchar((i64)76);
        cc_genasm_asmint((*a).value);
        cc_genasm_asmchar((i64)58);
        if (!!((u64)((*a).isglobal))) {
            cc_genasm_asmchar((i64)58);
        };
        if (!!(b)) {
            cc_genasm_asmstr((byte*)"\t!<");
            cc_genasm_asmstr((*(*b).def).name);
            cc_genasm_asmchar((i64)62);
        };
        return;
    };
    cc_genasm_asmchar((i64)9);
    if ((opcode==(i64)19)) {
        cc_genasm_asmchar((i64)106);
        cc_genasm_asmstr(cc_libmcl_asmcondnames[(cond)]);
    }else if ((opcode==(i64)40)) {
        cc_genasm_asmstr((byte*)"set");
        cc_genasm_asmstr(cc_libmcl_asmcondnames[(cond)]);
    }else if ((opcode==(i64)9)) {
        cc_genasm_asmstr((byte*)"cmov");
        cc_genasm_asmstr(cc_libmcl_asmcondnames[(cond)]);
    } else {
        cc_genasm_asmstr((cc_libmcl_mclnames[(opcode)-1] + ((opcode <= (i64)68)?(i64)2:(i64)3)));
    };
    n = (cc_genasm_asmptr - cc_genasm_asmstart);
    L931 :;
    while ((n < (i64)11)) {
        cc_genasm_asmchar((i64)32);
        ++n;
L932 :;
    }L933 :;
    ;
    if ((!!(a) && !!(b))) {
        sizepref = cc_libmcl_needsizeprefix(opcode,a,b);
        cc_genasm_stropndx(a,sizepref,(i64)0);
        cc_genasm_asmstr((byte*)",\t");
        cc_genasm_stropndx(b,sizepref,(i64)0);
    } else if ((!!(a) && !!((u64)((*a).mode)))) {
        if ((opcode == (i64)15)) {
            cc_genasm_stropndx(a,(i64)0,(i64)0);
        } else {
            cc_genasm_stropndx(a,(i64)1,(i64)0);
        };
    };
}

void cc_genasm_stropndx(struct cc_libmcl_opndrec * a,i64 sizeprefix,i64 debug) {
    byte *  plus;
    byte *  p;
    byte *  q;
    i64 av_1;
    if (((i64)((*a).mode)==(i64)1)) {
        cc_genasm_asmstr(cc_libmcl_getregname((i64)((*a).reg),(i64)((*a).size)));
    }else if (((i64)((*a).mode)==(i64)2)) {
        cc_genasm_strvaluex(a);
    }else if (((i64)((*a).mode)==(i64)4)) {
        if (!!(sizeprefix)) {
            cc_genasm_asmstr(cc_libmcl_getsizeprefix((i64)((*a).size),(i64)1));
        };
        cc_genasm_asmchar((i64)91);
        plus = (byte*)"";
        if (!!((u64)((*a).reg))) {
            if (((!!(cc_decls_fshownames) && !!((*a).def)) && ((i64)((u64)((*a).reg)) == (i64)15))) {
            } else {
                cc_genasm_asmstr(cc_genasm_getregnamex((i64)((*a).reg),(i64)8));
                plus = (byte*)"+";
            };
        };
        if (!!((u64)((*a).regix))) {
            cc_genasm_asmstr(plus);
            cc_genasm_asmstr(cc_genasm_getregnamex((i64)((*a).regix),(i64)8));
            plus = (byte*)"+";
            if (((i64)((u64)((*a).scale)) > (i64)1)) {
                cc_genasm_asmchar((i64)42);
                cc_genasm_asmint((i64)((*a).scale));
            };
        };
        if ((!!((*a).def) || !!((u64)((*a).valtype)))) {
            p = cc_genasm_asmptr;
            cc_genasm_asmchar((i64)32);
            q = cc_genasm_asmptr;
            cc_genasm_strvaluex(a);
            if ((((u64)((*q)) != '-') && ((u64)((*plus)) == '+'))) {
                (*p) = '+';
            };
            if (((u64)((*p)) == ' ')) {
                av_1 = ((cc_genasm_asmptr - p) - (i64)1);
                while (av_1-- > 0) {
L934 :;
                    (*p) = (u64)((*(p + (i64)1)));
                    ++p;
L935 :;
                }L936 :;
                ;
                --cc_genasm_asmptr;
            };
        };
        cc_genasm_asmchar((i64)93);
    }else if (((i64)((*a).mode)==(i64)3)) {
        cc_genasm_asmchar((i64)47);
        cc_genasm_asmstr((*a).svalue);
        cc_genasm_asmchar((i64)47);
    }else if (((i64)((*a).mode)==(i64)6)) {
        cc_genasm_asmstr(cc_genasm_fgetregnamex((i64)((*a).reg)));
    } else {
        cc_genasm_asmstr((byte*)"<BAD OPND>");
    };
}

static void cc_genasm_strmclx(struct cc_libmcl_mclrec * mcl) {
    cc_genasm_strmclasm(mcl);
    (*cc_genasm_asmptr++) = (u64)10u;
    (*cc_genasm_asmptr) = (u64)0u;
}

static byte * cc_genasm_fgetregnamex(i64 reg) {
    static byte str[16];
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_str((byte*)"XMM",NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_i64((reg - (i64)1),NULL);
    msysnewc_m_print_end();
    ;
    return str;
}

byte * cc_genasm_getstringname(i64 n) {
    static byte str[16];
    if ((n == (i64)0)) {
        cc_libmcl_kk0used = (i64)1;
    };
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_str((byte*)"KK",NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_i64(n,NULL);
    msysnewc_m_print_end();
    ;
    return str;
}

byte * cc_genasm_getwstringname(i64 n) {
    static byte str[16];
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_str((byte*)"WW",NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_i64(n,NULL);
    msysnewc_m_print_end();
    ;
    return str;
}

byte * cc_genasm_getrealname(i64 n) {
    static byte str[16];
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_str((byte*)"R.",NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_i64(n,NULL);
    msysnewc_m_print_end();
    ;
    return str;
}

byte * cc_genasm_getsrealname(i64 n) {
    static byte str[16];
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_str((byte*)"SR.",NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_i64(n,NULL);
    msysnewc_m_print_end();
    ;
    return str;
}

byte * cc_genasm_getdintname(i64 n) {
    static byte str[16];
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_str((byte*)"DD.",NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_i64(n,NULL);
    msysnewc_m_print_end();
    ;
    return str;
}

i64 cc_genasm_getstringindex(byte * s,i64 length) {
    if (((s == 0) || (length == (i64)0))) {
        cc_libmcl_kk0used = (i64)1;
        return (i64)0;
    };
    if ((cc_genasm_nstrings >= cc_genasm_stringtablesize)) {
        cc_genasm_extendstringtable();
    };
    (*cc_genasm_stringtable)[(++cc_genasm_nstrings)-1] = s;
    (*cc_genasm_stringlentable)[(cc_genasm_nstrings)-1] = length;
    return cc_genasm_nstrings;
}

i64 cc_genasm_getwstringindex(u16 * s,i64 length) {
    if ((cc_genasm_nwstrings >= (i64)1024)) {
        cc_support_gerror((byte*)"Too many wide strings",(struct cc_decls_unitrec *)(0));
    };
    cc_genasm_wstringtable[(++cc_genasm_nwstrings)-1] = s;
    cc_genasm_wstringlentable[(cc_genasm_nwstrings)-1] = length;
    return cc_genasm_nwstrings;
}

static i64 cc_genasm_getrealindex(double x) {
    if ((cc_genasm_nreals >= cc_genasm_realtablesize)) {
        cc_genasm_extendrealtable();
    };
    (*cc_genasm_realtable)[(++cc_genasm_nreals)-1] = x;
    return cc_genasm_nreals;
}

static i64 cc_genasm_getdintindex(i64 x) {
    if ((cc_genasm_ndints >= cc_genasm_dinttablesize)) {
        cc_genasm_extenddinttable();
    };
    (*cc_genasm_dinttable)[(++cc_genasm_ndints)-1] = x;
    return cc_genasm_ndints;
}

static void cc_genasm_strvaluex(struct cc_libmcl_opndrec * a) {
    struct cc_decls_strec *  d;
    i64 value;
    d = (*a).def;
    value = (*a).value;
    if (!!(d)) {
        if (((i64)((*d).nameid)==(i64)7)) {
            if (((i64)((u64)((*(*d).owner).nameid)) == (i64)6)) {
                cc_genasm_asmchar((i64)96);
                cc_genasm_asmstr((*(*d).owner).name);
                cc_genasm_asmchar((i64)46);
                cc_genasm_asmstr((*d).name);
                cc_genasm_asmchar((i64)46);
                cc_genasm_asmint((i64)((*d).blockno));
            } else {
                cc_genasm_asmchar((i64)96);
                cc_genasm_asmstr(cc_libmcl_getfullname(d));
                if (!!(cc_lib_isimported(d))) {
                    cc_genasm_asmchar((i64)42);
                };
            };
        }else if (((i64)((*d).nameid)==(i64)8) || ((i64)((*d).nameid)==(i64)9)) {
            if (!!(cc_decls_fshownames)) {
                cc_genasm_asmstr((*d).name);
            } else {
                cc_genasm_asmint((*d).offset);
            };
        } else {
            cc_genasm_asmchar((i64)96);
            cc_genasm_asmstr(cc_libmcl_getfullname(d));
            if (!!(cc_lib_isimported(d))) {
                cc_genasm_asmchar((i64)42);
            };
        };
        if ((((i64)((u64)((*a).valtype)) == (i64)1) && (value != (i64)0))) {
            if ((value > (i64)0)) {
                cc_genasm_asmchar((i64)43);
            };
            cc_genasm_asmint(value);
        };
        return;
    };
    if (((i64)((*a).valtype)==(i64)9)) {
        cc_genasm_asmstr(cc_genasm_getdintname((i64)((*a).index)));
        return;
    }else if (((i64)((*a).valtype)==(i64)10)) {
        if (!!((u64)((*a).isfloat))) {
            cc_genasm_asmstr(cc_genasm_getsrealname((i64)((*a).index)));
        } else {
            cc_genasm_asmstr(cc_genasm_getrealname((i64)((*a).index)));
        };
        return;
    }else if (((i64)((*a).valtype)==(i64)7)) {
        cc_genasm_asmstr(cc_genasm_getstringname((i64)((*a).index)));
        return;
    }else if (((i64)((*a).valtype)==(i64)8)) {
        cc_genasm_asmstr(cc_genasm_getwstringname((i64)((*a).index)));
        return;
    };
    cc_genasm_asmstr(cc_libmcl_strvalue(a));
}

static void cc_genasm_convertimm(struct cc_libmcl_opndrec * a,i64 sx) {
    i64 value;
    if (!!((*a).def)) {
        return;
    };
    value = (*a).value;
    if (((i64)((*a).valtype)==(i64)1)) {
        if ((labs(sx)==(i64)1)) {
            if ((((i64)-2147483648 <= value) && (value <= (i64)2147483647))) {
            } else {
                if ((sx < (i64)0)) {
                    cc_support_gerror((byte*)"conv/imm1",(struct cc_decls_unitrec *)(0));
                };
                (*a).index = cc_genasm_getdintindex(value);
                (*a).valtype = (u64)((i64)9);
                (*a).mode = (u64)((i64)4);
            };
        }else if ((labs(sx)==(i64)2)) {
            if ((((i64)0 <= value) && (value <= (i64)4294967295))) {
            } else {
                if ((sx < (i64)0)) {
                    cc_support_gerror((byte*)"conv/imm2",(struct cc_decls_unitrec *)(0));
                };
                (*a).index = cc_genasm_getdintindex(value);
                (*a).valtype = (u64)((i64)9);
                (*a).mode = (u64)((i64)4);
            };
        };
    }else if (((i64)((*a).valtype)==(i64)2)) {
        (*a).index = cc_genasm_getrealindex((*a).xvalue);
        (*a).valtype = (u64)((i64)10);
        (*a).mode = (u64)((i64)4);
        (*a).isfloat = (u64)(((i64)((*a).size) == (i64)4));
    }else if (((i64)((*a).valtype)==(i64)3)) {
        (*a).index = cc_genasm_getstringindex((*a).svalue,(i64)((*a).slength));
        (*a).valtype = (u64)((i64)7);
    }else if (((i64)((*a).valtype)==(i64)4)) {
        (*a).index = cc_genasm_getwstringindex((*a).wsvalue,(i64)((*a).wslength));
        (*a).valtype = (u64)((i64)8);
    };
}

static void cc_genasm_genstringtable(void) {
    i64 i;
    i64 col;
    if (!((!!(cc_genasm_nstrings) || !!(cc_libmcl_kk0used)))) {
        return;
    };
    mlib_gs_strln(cc_libmcl_dest,(byte*)"!String Table");
    mlib_gs_strln(cc_libmcl_dest,(byte*)"\tsegment idata");
    mlib_gs_str(cc_libmcl_dest,(byte*)"\talign ");
    mlib_gs_strint(cc_libmcl_dest,(i64)8);
    mlib_gs_line(cc_libmcl_dest);
    if (!!(cc_libmcl_kk0used)) {
        mlib_gs_strln(cc_libmcl_dest,(byte*)"kk0:    db 0");
    };
    L937 :;
    for (i=(i64)1;i<=cc_genasm_nstrings;i+=(i64)1) {
L938 :;
        col = (i64)((*cc_libmcl_dest).length);
        mlib_gs_str(cc_libmcl_dest,cc_genasm_getstringname(i));
        mlib_gs_str(cc_libmcl_dest,(byte*)":");
        mlib_gs_padto(cc_libmcl_dest,(i64)8,(i64)32);
        cc_genasm_genstring((*cc_genasm_stringtable)[(i)-1],(*cc_genasm_stringlentable)[(i)-1]);
L939 :;
    }L940 :;
    ;
    mlib_gs_line(cc_libmcl_dest);
}

static void cc_genasm_genwstringtable(void) {
    i64 i;
    i64 col;
    if (!(!!(cc_genasm_nwstrings))) {
        return;
    };
    mlib_gs_strln(cc_libmcl_dest,(byte*)"!Wide String Table");
    mlib_gs_strln(cc_libmcl_dest,(byte*)"\tsegment idata");
    mlib_gs_str(cc_libmcl_dest,(byte*)"\talign ");
    mlib_gs_strint(cc_libmcl_dest,(i64)8);
    mlib_gs_line(cc_libmcl_dest);
    L941 :;
    for (i=(i64)1;i<=cc_genasm_nwstrings;i+=(i64)1) {
L942 :;
        col = (i64)((*cc_libmcl_dest).length);
        mlib_gs_str(cc_libmcl_dest,cc_genasm_getwstringname(i));
        mlib_gs_str(cc_libmcl_dest,(byte*)":");
        mlib_gs_padto(cc_libmcl_dest,(i64)8,(i64)32);
        cc_genasm_genwstring(cc_genasm_wstringtable[(i)-1],cc_genasm_wstringlentable[(i)-1]);
L943 :;
    }L944 :;
    ;
    mlib_gs_line(cc_libmcl_dest);
}

static void cc_genasm_do_defstr(byte * s,i64 length) {
    mlib_gs_str(cc_libmcl_dest,(byte*)"\t");
    cc_genasm_genstring(s,length);
}

static void cc_genasm_do_defwstr(u16 * s,i64 length) {
    mlib_gs_str(cc_libmcl_dest,(byte*)"\t");
    cc_genasm_genwstring(s,length);
}

static void cc_genasm_genrealtable(void) {
    struct cc_genasm_genrealtable_fprec fp;
    double x;
    i64 i;
    byte str[1282];
    if (!(!!(cc_genasm_nreals))) {
        return;
    };
    mlib_gs_strln(cc_libmcl_dest,(byte*)"!Real64 Table");
    mlib_gs_strln(cc_libmcl_dest,(byte*)"\tsegment idata");
    mlib_gs_str(cc_libmcl_dest,(byte*)"\talign ");
    mlib_gs_strint(cc_libmcl_dest,(i64)8);
    mlib_gs_line(cc_libmcl_dest);
    L945 :;
    for (i=(i64)1;i<=cc_genasm_nreals;i+=(i64)1) {
L946 :;
        x = (*cc_genasm_realtable)[(i)-1];
        fp.x64 = x;
        mlib_gs_str(cc_libmcl_dest,cc_genasm_getrealname(i));
        mlib_gs_str(cc_libmcl_dest,(byte*)":");
        mlib_gs_padto(cc_libmcl_dest,(i64)10,(i64)32);
        mlib_gs_str(cc_libmcl_dest,(byte*)"dq ");
        mlib_gs_strint(cc_libmcl_dest,fp.ix64);
        mlib_gs_str(cc_libmcl_dest,(byte*)"\t; ");
        strcpy((i8 *)(str),(i8 *)(msysnewc_strint(fp.ix64,(byte*)"z16H")));
        mlib_gs_str(cc_libmcl_dest,str);
        strcpy((i8 *)(str),(i8 *)(msysnewc_strreal(x,(byte*)".30g")));
        mlib_gs_strln(cc_libmcl_dest,str);
L947 :;
    }L948 :;
    ;
    mlib_gs_line(cc_libmcl_dest);
    mlib_gs_strln(cc_libmcl_dest,(byte*)"!Real32 Table");
    L949 :;
    for (i=(i64)1;i<=cc_genasm_nreals;i+=(i64)1) {
L950 :;
        x = (*cc_genasm_realtable)[(i)-1];
        fp.x32 = (float)(x);
        mlib_gs_str(cc_libmcl_dest,cc_genasm_getsrealname(i));
        mlib_gs_str(cc_libmcl_dest,(byte*)":");
        mlib_gs_padto(cc_libmcl_dest,(i64)10,(i64)32);
        mlib_gs_str(cc_libmcl_dest,(byte*)"dd ");
        mlib_gs_strint(cc_libmcl_dest,(i64)(fp.ix32));
        mlib_gs_str(cc_libmcl_dest,(byte*)"\t; ");
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_r64((double)(fp.x32),(byte*)".30g");
        msysnewc_m_print_end();
        ;
        mlib_gs_strln(cc_libmcl_dest,str);
L951 :;
    }L952 :;
    ;
    mlib_gs_line(cc_libmcl_dest);
}

static void cc_genasm_gendinttable(void) {
    i64 i;
    i64 x;
    if (!(!!(cc_genasm_ndints))) {
        return;
    };
    mlib_gs_strln(cc_libmcl_dest,(byte*)"!Int64 Table");
    mlib_gs_strln(cc_libmcl_dest,(byte*)"\tsegment idata");
    mlib_gs_str(cc_libmcl_dest,(byte*)"\talign ");
    mlib_gs_strint(cc_libmcl_dest,(i64)8);
    mlib_gs_line(cc_libmcl_dest);
    L953 :;
    for (i=(i64)1;i<=cc_genasm_ndints;i+=(i64)1) {
L954 :;
        x = (*cc_genasm_dinttable)[(i)-1];
        mlib_gs_str(cc_libmcl_dest,cc_genasm_getdintname(i));
        mlib_gs_str(cc_libmcl_dest,(byte*)":");
        mlib_gs_str(cc_libmcl_dest,(byte*)"dq ");
        mlib_gs_strint(cc_libmcl_dest,x);
        mlib_gs_line(cc_libmcl_dest);
L955 :;
    }L956 :;
    ;
    mlib_gs_line(cc_libmcl_dest);
}

static void cc_genasm_writefabs(void) {
    if ((!!(cc_libmcl_fabsused) || !!(cc_libmcl_fchsused))) {
        mlib_gs_strln(cc_libmcl_dest,(byte*)"\tsegment idata");
        mlib_gs_strln(cc_libmcl_dest,(byte*)"\talign 16");
        if (!!(cc_libmcl_fchsused)) {
            mlib_gs_strln(cc_libmcl_dest,(byte*)"fchsmask_ps:\tdq 0x80000000'80000000, 0x80000000'80000000");
            mlib_gs_strln(cc_libmcl_dest,(byte*)"fchsmask_pd:\tdq 0x80000000'00000000, 0x80000000'00000000");
        };
        if (!!(cc_libmcl_fabsused)) {
            mlib_gs_strln(cc_libmcl_dest,(byte*)"fabsmask_ps:\tdq 0x7fffffff'7fffffff, 0x7fffffff'7fffffff");
            mlib_gs_strln(cc_libmcl_dest,(byte*)"fabsmask_pd:\tdq 0x7fffffff'ffffffff, 0x7fffffff'ffffffff");
        };
    };
}

static void cc_genasm_domclseq(struct cc_libmcl_mclrec * m) {
    L957 :;
    while (!!(m)) {
        cc_genasm_mcltoa64(m);
        m = (*m).nextmcl;
L958 :;
    }L959 :;
    ;
}

static void cc_genasm_asmstr(byte * s) {
    L960 :;
    while (!!((u64)((*s)))) {
        (*cc_genasm_asmptr++) = (u64)((*s++));
L961 :;
    }L962 :;
    ;
}

static void cc_genasm_asmstrln(byte * s) {
    byte c;
    L963 :;
    while (!!((u64)((c = (u64)((*s)))))) {
        (*cc_genasm_asmptr) = (u64)(c);
        ++cc_genasm_asmptr;
        ++s;
L964 :;
    }L965 :;
    ;
    (*cc_genasm_asmptr) = (u64)10u;
    ++cc_genasm_asmptr;
}

static void cc_genasm_asmline(void) {
    (*cc_genasm_asmptr) = (u64)10u;
    ++cc_genasm_asmptr;
}

static void cc_genasm_asmln(void) {
    cc_genasm_asmline();
}

static void cc_genasm_asmint(i64 a) {
    byte *  s;
    s = cc_genasm_asmptr;
    msysnewc_getstrint(a,s);
    cc_genasm_asmptr += (i64)(strlen((i8 *)(s)));
}

static void cc_genasm_asmchar(i64 c) {
    (*cc_genasm_asmptr) = (u64)(c);
    ++cc_genasm_asmptr;
}

static void cc_genasm_asmterm(void) {
    (*cc_genasm_asmptr) = (u64)0u;
}

static void cc_genasm_initasmline(void) {
    cc_genasm_asmptr = (cc_genasm_asmstart = cc_genasm_asmbuffer);
    cc_genasm_asmend = (cc_genasm_asmbuffer + (i64)20000);
}

static byte * cc_genasm_getregnamex(i64 reg,i64 size) {
    static byte *  regnames[8][17] = {
    {
        (byte*)"-",
        (byte*)"B0",
        (byte*)"B1",
        (byte*)"B2",
        (byte*)"B3",
        (byte*)"B4",
        (byte*)"B5",
        (byte*)"B6",
        (byte*)"B7",
        (byte*)"B8",
        (byte*)"B9",
        (byte*)"B10",
        (byte*)"B11",
        (byte*)"B12",
        (byte*)"B13",
        (byte*)"B14",
        (byte*)"B15"
},
    {
        (byte*)"-",
        (byte*)"W0",
        (byte*)"W1",
        (byte*)"W2",
        (byte*)"W3",
        (byte*)"W4",
        (byte*)"W5",
        (byte*)"W6",
        (byte*)"W7",
        (byte*)"W8",
        (byte*)"W9",
        (byte*)"W10",
        (byte*)"W11",
        (byte*)"W12",
        (byte*)"W13",
        (byte*)"W14",
        (byte*)"W15"
},
    {
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
},
    {
        (byte*)"-",
        (byte*)"A0",
        (byte*)"A1",
        (byte*)"A2",
        (byte*)"A3",
        (byte*)"A4",
        (byte*)"A5",
        (byte*)"A6",
        (byte*)"A7",
        (byte*)"A8",
        (byte*)"A9",
        (byte*)"A10",
        (byte*)"A11",
        (byte*)"A12",
        (byte*)"A13",
        (byte*)"Aframe",
        (byte*)"Astack"
},
    {
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
},
    {
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
},
    {
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
},
    {
        (byte*)"-",
        (byte*)"D0",
        (byte*)"D1",
        (byte*)"D2",
        (byte*)"D3",
        (byte*)"D4",
        (byte*)"D5",
        (byte*)"D6",
        (byte*)"D7",
        (byte*)"D8",
        (byte*)"D9",
        (byte*)"D10",
        (byte*)"D11",
        (byte*)"D12",
        (byte*)"D13",
        (byte*)"Dframe",
        (byte*)"Dstack"
}
};
    return regnames[(size)-1][(reg)];
}

static void cc_genasm_genstring(byte * s,i64 length) {
    i64 state;
    i64 a;
    i64 av_1;
    mlib_gs_str(cc_libmcl_dest,(byte*)"db ");
    if ((length == (i64)0)) {
        mlib_gs_strln(cc_libmcl_dest,(byte*)"0");
        return;
    };
    state = (i64)0;
    av_1 = length;
    while (av_1-- > 0) {
L966 :;
        a = (i64)((*s++));
        if ((((a < (i64)32) || (a >= (i64)127)) || (a == (i64)34))) {
            if ((state == (i64)1)) {
                mlib_gs_str(cc_libmcl_dest,(byte*)"\",");
                state = (i64)0;
            };
            mlib_gs_strint(cc_libmcl_dest,a);
            mlib_gs_str(cc_libmcl_dest,(byte*)",");
        } else {
            if ((state == (i64)0)) {
                mlib_gs_str(cc_libmcl_dest,(byte*)"\"");
                state = (i64)1;
            };
            mlib_gs_char(cc_libmcl_dest,a);
        };
L967 :;
    }L968 :;
    ;
    if ((state == (i64)1)) {
        mlib_gs_str(cc_libmcl_dest,(byte*)"\",");
    };
    mlib_gs_str(cc_libmcl_dest,(byte*)"0");
    mlib_gs_line(cc_libmcl_dest);
}

static void cc_genasm_genwstring(u16 * s,i64 length) {
    i64 i;
    i64 state;
    mlib_gs_str(cc_libmcl_dest,(byte*)"dw ");
    if ((length == (i64)0)) {
        mlib_gs_strln(cc_libmcl_dest,(byte*)"0");
        return;
    };
    state = (i64)0;
    L969 :;
    for (i=(i64)1;i<=length;i+=(i64)1) {
L970 :;
        mlib_gs_strint(cc_libmcl_dest,(i64)((*s++)));
        mlib_gs_str(cc_libmcl_dest,(byte*)",");
L971 :;
    }L972 :;
    ;
    mlib_gs_str(cc_libmcl_dest,(byte*)"0");
    mlib_gs_line(cc_libmcl_dest);
}

static void cc_genasm_extendrealtable(void) {
    double (*oldrealtable)[];
    i64 oldrealtablesize;
    i64 i;
    oldrealtablesize = cc_genasm_realtablesize;
    oldrealtable = cc_genasm_realtable;
    cc_genasm_realtablesize *= (i64)2;
    cc_genasm_realtable = (double (*)[])(mlib_pcm_alloc(((i64)8 * cc_genasm_realtablesize)));
    L973 :;
    for (i=(i64)1;i<=cc_genasm_nreals;i+=(i64)1) {
L974 :;
        (*cc_genasm_realtable)[(i)-1] = (*oldrealtable)[(i)-1];
L975 :;
    }L976 :;
    ;
    mlib_pcm_free((void *)(oldrealtable),((i64)8 * oldrealtablesize));
}

static void cc_genasm_extenddinttable(void) {
    i64 (*olddinttable)[];
    i64 olddinttablesize;
    i64 i;
    olddinttablesize = cc_genasm_dinttablesize;
    olddinttable = cc_genasm_dinttable;
    cc_genasm_dinttablesize *= (i64)2;
    cc_genasm_dinttable = (i64 (*)[])(mlib_pcm_alloc(((i64)8 * cc_genasm_dinttablesize)));
    L977 :;
    for (i=(i64)1;i<=cc_genasm_ndints;i+=(i64)1) {
L978 :;
        (*cc_genasm_dinttable)[(i)-1] = (*olddinttable)[(i)-1];
L979 :;
    }L980 :;
    ;
    mlib_pcm_free((void *)(olddinttable),((i64)8 * olddinttablesize));
}

static void cc_genasm_extendstringtable(void) {
    byte * (*oldstringtable)[];
    i64 (*oldstringlentable)[];
    i64 oldstringtablesize;
    i64 i;
    oldstringtablesize = cc_genasm_stringtablesize;
    oldstringtable = cc_genasm_stringtable;
    oldstringlentable = cc_genasm_stringlentable;
    cc_genasm_stringtablesize *= (i64)2;
    cc_genasm_stringtable = (byte * (*)[])(mlib_pcm_alloc(((i64)8 * cc_genasm_stringtablesize)));
    cc_genasm_stringlentable = (i64 (*)[])(mlib_pcm_alloc(((i64)8 * cc_genasm_stringtablesize)));
    L981 :;
    for (i=(i64)1;i<=cc_genasm_nstrings;i+=(i64)1) {
L982 :;
        (*cc_genasm_stringtable)[(i)-1] = (*oldstringtable)[(i)-1];
        (*cc_genasm_stringlentable)[(i)-1] = (*oldstringlentable)[(i)-1];
L983 :;
    }L984 :;
    ;
    mlib_pcm_free((void *)(oldstringtable),((i64)8 * oldstringtablesize));
    mlib_pcm_free((void *)(oldstringlentable),((i64)8 * oldstringtablesize));
}

void cc_export_writemheader(byte * infile) {
    byte mfile[300];
    struct cc_decls_strec *  d;
    struct cc_decls_strec *  e;
    i64 i;
    strcpy((i8 *)(mfile),(i8 *)(mlib_pcm_copyheapstring(mlib_changeext(infile,(byte*)".m"))));
    mlib_gs_init(cc_export_mm);
    cc_export_mmstr((byte*)"importdll ");
    cc_export_mmstr(mlib_extractbasefile(infile));
    cc_export_mmstrln((byte*)" =");
    cc_decls_stmodule = cc_decls_moduletable[((i64)1)].stmodule;
    d = (*cc_decls_stmodule).deflist;
    L985 :;
    while (!!(d)) {
        if (!!(cc_headers_isheaderfile(cc_decls_sourcefilenames[((i64)(((u64)((*d).lineno) >> (i64)24)))]))) {
            d = (*d).nextdef;
            goto L986 ;
        };
        if (((i64)((*d).nameid)==(i64)7)) {
            cc_export_mmstr((byte*)"    ");
            cc_export_mmmode((i64)((*d).mode),(i64)1);
            cc_export_mmstr((byte*)" ");
            cc_export_mmstr(cc_export_fixname((*d).name));
            if (!!((*d).code)) {
                cc_export_mmstr((byte*)" =");
                cc_export_mmstr((*cc_lib_strexpr((*d).code)).strptr);
            };
            cc_export_mmline();
        }else if (((i64)((*d).nameid)==(i64)6)) {
            ++cc_export_nallprocs;
            cc_export_writefunction(d);
        }else if (((i64)((*d).nameid)==(i64)5)) {
        }else if (((i64)((*d).nameid)==(i64)11)) {
            cc_export_mmstr((byte*)"    const ");
            cc_export_mmleftstr(cc_export_fixname((*d).name),(i64)34);
            cc_export_mmstr((byte*)" = ");
            cc_export_mmint((i64)((*d).index));
            cc_export_mmline();
        }else if (((i64)((*d).nameid)==(i64)1)) {
            cc_export_mmstr((byte*)"MACRO ");
            cc_export_mmstrln(cc_export_fixname((*d).name));
        }else if (((i64)((*d).nameid)==(i64)13)) {
            ++cc_export_nallrecs;
            cc_export_writerecord((i64)((*d).mode),(i64)82,(i64)1);
        };
        d = (*d).nextdef;
L986 :;
    }L987 :;
    ;
    L988 :;
    for (i=(i64)0;i<=cc_decls_hstmask;i+=(i64)1) {
L989 :;
        e = (*cc_decls_hashtable)[(i)];
        if (((!!((*e).name) && ((i64)((u64)((*e).symbol)) == (i64)69)) && ((i64)((u64)((*e).nameid)) == (i64)1))) {
            if (!(!!(cc_headers_isheaderfile(cc_decls_sourcefilenames[((i64)(((u64)((*e).lineno) >> (i64)24)))])))) {
                if (!!((*e).tokenlist)) {
                    cc_export_mmstr((byte*)"    const ");
                    cc_export_mmleftstr(cc_export_fixname((*e).name),(i64)34);
                    cc_export_mmstr((byte*)" = ");
                    cc_export_showmacroseq((*e).tokenlist);
                    cc_export_mmstrln((byte*)"    ! macro");
                };
            };
        };
L990 :;
    }L991 :;
    ;
    cc_export_mmstrln((byte*)"end");
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"DONE",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"NALLPROCS=",NULL);
    msysnewc_m_print_i64(cc_export_nallprocs,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"NALLRECS=",NULL);
    msysnewc_m_print_i64(cc_export_nallrecs,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    cc_decls_moduletable[((i64)1)].mhdrstr = (*cc_export_mm).strptr;
    if (!!(cc_decls_logdest)) {
        msysnewc_m_print_startfile(cc_decls_logdev);
        msysnewc_m_print_str((byte*)"M HEADERS\n=========",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        msysnewc_m_print_startfile(cc_decls_logdev);
        msysnewc_m_print_str((*cc_export_mm).strptr,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"Writing M Header:",NULL);
    msysnewc_m_print_str(mfile,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    mlib_writefile(mfile,(byte *)((*cc_export_mm).strptr),(i64)((*cc_export_mm).length));
}

static void cc_export_showmacroseq(struct cc_decls_tokenrec * tk) {
    L992 :;
    while (!!(tk)) {
        cc_lex_emittoken(tk,cc_export_mm,(i64)0);
        tk = (*tk).nexttoken;
L993 :;
    }L994 :;
    ;
}

static void cc_export_mmstr(byte * s) {
    mlib_gs_str(cc_export_mm,s);
}

static void cc_export_mmleftstr(byte * s,i64 n) {
    mlib_gs_leftstr(cc_export_mm,s,n,(i64)32);
}

static void cc_export_mmstrln(byte * s) {
    mlib_gs_strln(cc_export_mm,s);
}

static void cc_export_mmint(i64 a) {
    byte str[32];
    msysnewc_getstrint(a,str);
    mlib_gs_str(cc_export_mm,str);
}

static void cc_export_mmline(void) {
    mlib_gs_line(cc_export_mm);
}

static void cc_export_writefunction(struct cc_decls_strec * d) {
    struct cc_decls_paramrec *  pm;
    i64 n;
    i64 isvar;
    i64 i;
    if (((i64)((*d).mode) == (i64)1)) {
        cc_export_mmstr((byte*)"    clang proc     ");
    } else {
        cc_export_mmstr((byte*)"    clang function ");
    };
    cc_export_mmstr((byte*)"\"");
    cc_export_mmstr((*d).name);
    cc_export_mmstr((byte*)"\"");
    cc_export_mmleftstr((byte*)" ",((i64)34 - (i64)(strlen((i8 *)((*d).name)))));
    cc_export_mmstr((byte*)"(");
    pm = (*d).paramlist;
    n = (i64)((*pm).nparams);
    isvar = ((i64)((*pm).flags) == (i64)3);
    L995 :;
    for (i=(i64)1;i<=n;i+=(i64)1) {
L996 :;
        cc_export_mmmode((i64)((*pm).mode),(i64)1);
        if (((i != n) || !!(isvar))) {
            cc_export_mmstr((byte*)",");
        };
        pm = (*pm).nextparam;
L997 :;
    }L998 :;
    ;
    if (!!(isvar)) {
        cc_export_mmstr((byte*)"...");
    };
    cc_export_mmstr((byte*)")");
    if (((i64)((*d).mode) != (i64)1)) {
        cc_export_mmmode((i64)((*d).mode),(i64)1);
    };
    cc_export_mmline();
}

static void cc_export_mmmode(i64 m,i64 expand) {
    i64 t;
    i64 u;
    t = cc_decls_ttbasetype[(m)];
    if ((t==(i64)16)) {
        cc_export_mmstr((byte*)"ref ");
        u = cc_decls_tttarget[(m)];
        if ((cc_decls_ttbasetype[(u)] == (i64)17)) {
            cc_export_writefnptr(u);
        } else {
            cc_export_mmmode(cc_decls_tttarget[(m)],(i64)1);
        };
    }else if ((t==(i64)19)) {
        cc_export_mmstr((byte*)"[");
        if (!!(cc_decls_ttlength[(m)])) {
            cc_export_mmint(cc_decls_ttlength[(m)]);
        };
        cc_export_mmstr((byte*)"]");
        cc_export_mmmode(cc_decls_tttarget[(m)],(i64)1);
    }else if ((t==(i64)15)) {
        cc_export_mmstr((byte*)"int");
    }else if ((t==(i64)20) || (t==(i64)21)) {
        cc_export_mmstr(cc_export_fixname((*cc_decls_ttnamedef[(m)]).name));
    }else if ((t==(i64)17)) {
        cc_export_mmstr((byte*)"<PROC>");
    } else {
        cc_export_mmstr(cc_tables_stdtypemnames[(t)]);
    };
}

static void cc_export_writerecord(i64 m,i64 rectype,i64 level) {
    struct cc_decls_strec *  d;
    struct cc_decls_strec *  e;
    i64 emode;
    i64 av_1;
    i64 av_2;
    i64 av_3;
    i64 av_4;
    av_1 = level;
    while (av_1-- > 0) {
L999 :;
        cc_export_mmstr((byte*)"    ");
L1000 :;
    }L1001 :;
    ;
    ++level;
    d = cc_decls_ttnamedef[(m)];
    if ((rectype == (i64)82)) {
        cc_export_mmstr((byte*)"record ");
        cc_export_mmstr(cc_export_fixname((*d).name));
        cc_export_mmstrln((byte*)" =");
    } else {
        cc_export_mmstrln(((rectype == (i64)83)?(byte*)"struct":(byte*)"union"));
    };
    e = (*d).deflist;
    if ((e == 0)) {
        av_2 = level;
        while (av_2-- > 0) {
L1002 :;
            cc_export_mmstr((byte*)"    ");
L1003 :;
        }L1004 :;
        ;
        cc_export_mmstrln((byte*)"var int dummy    !empty record");
    };
    L1005 :;
    while (!!(e)) {
        emode = (i64)((*e).mode);
        av_3 = level;
        while (av_3-- > 0) {
L1008 :;
            cc_export_mmstr((byte*)"    ");
L1009 :;
        }L1010 :;
        ;
        if (!!(strchr((i8 *)((*e).name),(i64)36))) {
            if ((cc_decls_ttbasetype[(emode)]==(i64)21)) {
                cc_export_writerecord(emode,(i64)85,level);
            }else if ((cc_decls_ttbasetype[(emode)]==(i64)20)) {
                cc_export_writerecord(emode,(i64)83,level);
            };
        } else {
            cc_export_mmstr((byte*)"var ");
            cc_export_mmmode((i64)((*e).mode),(i64)1);
            cc_export_mmstr((byte*)" ");
            cc_export_mmstrln(cc_export_fixname((*e).name));
        };
        e = (*e).nextdef;
L1006 :;
    }L1007 :;
    ;
    av_4 = (level - (i64)1);
    while (av_4-- > 0) {
L1011 :;
        cc_export_mmstr((byte*)"    ");
L1012 :;
    }L1013 :;
    ;
    cc_export_mmstrln((byte*)"end");
    cc_export_mmline();
}

static void cc_export_writefnptr(i64 m) {
    struct cc_decls_paramrec *  pm;
    i64 isvar;
    i64 n;
    i64 target;
    i64 i;
    target = cc_decls_tttarget[(m)];
    if ((target == (i64)1)) {
        cc_export_mmstr((byte*)"clang proc(");
    } else {
        cc_export_mmstr((byte*)"clang function(");
    };
    pm = cc_decls_ttparams[(m)];
    n = (i64)((*pm).nparams);
    isvar = ((i64)((*pm).flags) == (i64)3);
    L1014 :;
    for (i=(i64)1;i<=n;i+=(i64)1) {
L1015 :;
        cc_export_mmmode((i64)((*pm).mode),(i64)1);
        if (((i != n) || !!(isvar))) {
            cc_export_mmstr((byte*)",");
        };
        pm = (*pm).nextparam;
L1016 :;
    }L1017 :;
    ;
    if (!!(isvar)) {
        cc_export_mmstr((byte*)"...");
    };
    cc_export_mmstr((byte*)")");
    if ((target != (i64)1)) {
        cc_export_mmmode(target,(i64)1);
    };
}

static byte * cc_export_fixname(byte * name) {
    static byte *  reservedwords[8] = {(byte*)"function",(byte*)"read",(byte*)"type",(byte*)"next",(byte*)"stop",(byte*)"callback",(byte*)"len",(byte*)"$dummy"};
    byte str[128];
    i64 av_1;
    i64 i;
    L1018 :;
    for (i=(i64)1;i<=(i64)8;i+=(i64)1) {
L1019 :;
        if (!!(mlib_eqstring(reservedwords[(i)-1],name))) {
            strcpy((i8 *)(str),(i8 *)(name));
            strcat((i8 *)(str),(i8 *)((byte*)"$"));
            return mlib_pcm_copyheapstring(str);
        };
L1020 :;
    }L1021 :;
    ;
    return name;
}

i64 cc_assembler_assembler(byte * outputfile,byte * (*asmfiles)[],byte * (*dllfiles)[],i64 nasmfiles,i64 ndllfiles,i64 fobj,i64 fcaption,byte * (*assemsources)[],byte * entrypointname) {
    i64 i;
    cc_assembler_initall();
    L1022 :;
    for (i=(i64)1;i<=nasmfiles;i+=(i64)1) {
L1023 :;
        cc_assembler_addmodule((*asmfiles)[(i)-1]);
L1024 :;
    }L1025 :;
    ;
    ax_decls_searchlibs[((i64)1)-1] = (byte*)"ucrtbase";
    ax_decls_searchlibs[((i64)1)-1] = (byte*)"msvcrt";
    ax_decls_searchlibs[((i64)2)-1] = (byte*)"gdi32";
    ax_decls_searchlibs[((i64)3)-1] = (byte*)"user32";
    ax_decls_searchlibs[((i64)4)-1] = (byte*)"kernel32";
    ax_decls_nsearchlibs = (i64)4;
    L1026 :;
    for (i=(i64)1;i<=ndllfiles;i+=(i64)1) {
L1027 :;
        cc_assembler_addsearchlib((*dllfiles)[(i)-1]);
L1028 :;
    }L1029 :;
    ;
    if ((ax_decls_nmodules == (i64)0)) {
        cc_assembler_loaderror((byte*)"No input files specified");
    };
    if (!!(fcaption)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"Assembling to",NULL);
        msysnewc_m_print_str(outputfile,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
    cc_assembler_loadsourcefiles(assemsources);
    cc_assembler_parsemodules();
    if (!!(fobj)) {
        ax_genss_genss();
        ax_writeobj_writess(outputfile);
    } else {
        ax_genss_genss();
        ax_writeexe_initsectiontable();
        ax_writeexe_genexe(entrypointname,(byte*)"",(i64)0);
        ax_writeexe_writeexe(outputfile,(i64)0);
    };
    return (i64)1;
}

static void cc_assembler_loadsourcefiles(byte * (*assemsources)[]) {
    i64 i;
    byte *  source;
    L1030 :;
    for (i=(i64)1;i<=ax_decls_nmodules;i+=(i64)1) {
L1031 :;
        if (!!(assemsources)) {
            source = (*assemsources)[(i)-1];
        } else {
            source = (byte *)(mlib_readfile(ax_decls_moduletable[(i)-1].filename));
            if ((source == 0)) {
                cc_assembler_loaderror_s((byte*)"Can't load file: %s",ax_decls_moduletable[(i)-1].filename);
            };
        };
        ax_decls_moduletable[(i)-1].source = source;
L1032 :;
    }L1033 :;
    ;
}

static void cc_assembler_parsemodules(void) {
    i64 i;
    struct ax_lib_mclrec *  m;
    L1034 :;
    for (i=(i64)1;i<=ax_decls_nmodules;i+=(i64)1) {
L1035 :;
        ax_decls_currmoduleno = i;
        ax_decls_modulenamelist = (struct ax_decls_strec *)(0);
        ax_parse_readmodule(i);
        ax_parse_checkundefined();
        if (!!(ax_decls_nundefined)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((byte*)"Couldn't assemble - press key",NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            osnos_os_getch();
            exit((i64)1);
        };
        cc_assembler_scanglobals();
        cc_assembler_resethashtable();
L1036 :;
    }L1037 :;
    ;
    m = ax_lib_mccode;
    L1038 :;
    while (!!(m)) {
        cc_assembler_fixopnd((*m).a);
        cc_assembler_fixopnd((*m).b);
        m = (*m).nextmcl;
L1039 :;
    }L1040 :;
    ;
}

static void cc_assembler_fixopnd(struct ax_decls_opndrec * a) {
    struct ax_decls_strec *  d;
    if ((a == 0)) {
        return;
    };
    if (!!((*a).labeldef)) {
        d = (*a).labeldef;
        if (!!((*d).basedef)) {
            (*a).labeldef = (*d).basedef;
        };
    };
}

static void cc_assembler_initall(void) {
    ax_lex_initlex();
    ax_lib_initlib();
}

static void cc_assembler_loaderror(byte * mess) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"Error:",NULL);
    msysnewc_m_print_str(mess,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    exit((i64)1);
}

static void cc_assembler_loaderror_s(byte * mess,byte * s) {
    byte str[256];
    strcpy((i8 *)(str),(i8 *)(mess));
    strcat((i8 *)(str),(i8 *)(mess));
    cc_assembler_loaderror(str);
}

static void cc_assembler_addmodule(byte * name) {
    if ((ax_decls_nmodules >= (i64)200)) {
        cc_assembler_loaderror((byte*)"Too many modules");
    };
    ++ax_decls_nmodules;
    ax_decls_moduletable[(ax_decls_nmodules)-1].filename = mlib_pcm_copyheapstring(name);
    ax_decls_moduletable[(ax_decls_nmodules)-1].name = mlib_pcm_copyheapstring(mlib_extractfile(name));
    ax_decls_moduletable[(ax_decls_nmodules)-1].source = (byte*)"<empty>";
}

static void cc_assembler_addsearchlib(byte * name) {
    byte str[300];
    if ((ax_decls_nsearchlibs >= (i64)30)) {
        cc_assembler_loaderror((byte*)"Too many libraries");
    };
    ++ax_decls_nsearchlibs;
    strcpy((i8 *)(str),(i8 *)(name));
    str[(((i64)(strlen((i8 *)(name))) - (i64)3))-1] = (u64)0u;
    ax_decls_searchlibs[(ax_decls_nsearchlibs)-1] = mlib_pcm_copyheapstring(str);
}

static struct ax_decls_strec * cc_assembler_getemptyst(struct ax_decls_strec * d) {
    struct ax_decls_strec *  dnew;
    if (!!((u64)((*d).ksymbol))) {
        dnew = (struct ax_decls_strec *)(mlib_pcm_allocz((i64)128));
        (*dnew).name = (*d).name;
        (*dnew).namelen = (u64)((*d).namelen);
        (*dnew).ksymbol = (u64)((*d).ksymbol);
        (*dnew).subcode = (u64)((*d).subcode);
        (*dnew).regsize = (u64)((*d).regsize);
        return dnew;
    };
    return (struct ax_decls_strec *)(0);
}

static struct ax_decls_strec * cc_assembler_findduplname(struct ax_decls_strec * d) {
    struct ax_decls_strec *  e;
    if (!!((*d).basedef)) {
        return (*d).basedef;
    };
    e = ax_decls_dupltable[((i64)((*d).htfirstindex))];
    L1041 :;
    while (!!(e)) {
        if ((((u64)((*d).namelen) == (u64)((*e).namelen)) && ((i64)(memcmp((void *)((*d).name),(void *)((*e).name),(u64)((*d).namelen))) == (i64)0))) {
            (*d).basedef = e;
            return e;
        };
        e = (*e).nextdupl;
L1042 :;
    }L1043 :;
    ;
    return (struct ax_decls_strec *)(0);
}

static void cc_assembler_adddupl(struct ax_decls_strec * d) {
    (*d).nextdupl = ax_decls_dupltable[((i64)((*d).htfirstindex))];
    ax_decls_dupltable[((i64)((*d).htfirstindex))] = d;
}

static void cc_assembler_scanglobals(void) {
    struct ax_decls_strec *  d;
    struct ax_decls_strec *  e;
    d = ax_decls_modulenamelist;
    L1044 :;
    while (!!(d)) {
        if (((i64)((*d).symbol)==(i64)21)) {
            e = cc_assembler_findduplname(d);
            if (!!(e)) {
                if (((i64)((*e).symbol)==(i64)21)) {
                }else if (((i64)((*e).symbol)==(i64)22)) {
                    (*d).symbol = (u64)((i64)22);
                    (*d).reftype = (u64)(((*e).reftype = (u64)((i64)1)));
                };
            } else {
                ax_lib_addimport(d);
                cc_assembler_adddupl(d);
            };
        }else if (((i64)((*d).symbol)==(i64)22)) {
            e = cc_assembler_findduplname(d);
            if (!!(e)) {
                if (((i64)((*e).symbol)==(i64)21)) {
                    (*e).symbol = (u64)((i64)22);
                    (*d).reftype = (u64)(((*e).reftype = (u64)((i64)1)));
                }else if (((i64)((*e).symbol)==(i64)22)) {
                    msysnewc_m_print_startcon();
                    msysnewc_m_print_str(ax_decls_moduletable[((i64)((*d).moduleno))-1].name,NULL);
                    msysnewc_m_print_str((*d).name,NULL);
                    msysnewc_m_print_u64((*d).htindex,NULL);
                    msysnewc_m_print_newline();
                    msysnewc_m_print_end();
                    ;
                    msysnewc_m_print_startcon();
                    msysnewc_m_print_str(ax_decls_moduletable[((i64)((*e).moduleno))-1].name,NULL);
                    msysnewc_m_print_str((*e).name,NULL);
                    msysnewc_m_print_u64((*e).htindex,NULL);
                    msysnewc_m_print_newline();
                    msysnewc_m_print_end();
                    ;
                    ax_lib_serror_s((byte*)"Multiply-defined global: %s",(*d).name);
                };
            } else {
                e = d;
                ax_lib_addimport(d);
                cc_assembler_adddupl(d);
            };
        };
        d = (*d).nextdef;
L1045 :;
    }L1046 :;
    ;
}

static void cc_assembler_resethashtable(void) {
    struct ax_decls_strec *  d;
    d = ax_decls_modulenamelist;
    L1047 :;
    while (!!(d)) {
        ax_decls_lexhashtable[((i64)((*d).htindex))] = cc_assembler_getemptyst(d);
        d = (*d).nextdef;
L1048 :;
    }L1049 :;
    ;
    ax_decls_modulenamelist = (struct ax_decls_strec *)(0);
}

void ax_lex_lex(void) {
    i64 i;
    i64 c;
    i64 hsum;
    i64 length;
    byte *  pstart;
    ax_lex_lxsubcode = (i64)0;
    L1050 :;
    switch ((c = (i64)((*ax_lex_lxsptr++)))) {
    case 97:;
    case 98:;
    case 99:;
    case 100:;
    case 101:;
    case 102:;
    case 103:;
    case 104:;
    case 105:;
    case 106:;
    case 107:;
    case 108:;
    case 109:;
    case 110:;
    case 111:;
    case 112:;
    case 113:;
    case 114:;
    case 115:;
    case 116:;
    case 117:;
    case 118:;
    case 119:;
    case 120:;
    case 121:;
    case 122:;
    case 36:;
    case 95:;
    case 46:;
    {
        pstart = (ax_lex_lxsptr - (i64)1);
        //doname:
L1052 :;
;
        hsum = (i64)((*pstart));
        L1053 :;
        switch ((c = (i64)((*ax_lex_lxsptr++)))) {
        case 97:;
        case 98:;
        case 99:;
        case 100:;
        case 101:;
        case 102:;
        case 103:;
        case 104:;
        case 105:;
        case 106:;
        case 107:;
        case 108:;
        case 109:;
        case 110:;
        case 111:;
        case 112:;
        case 113:;
        case 114:;
        case 115:;
        case 116:;
        case 117:;
        case 118:;
        case 119:;
        case 120:;
        case 121:;
        case 122:;
        case 48:;
        case 49:;
        case 50:;
        case 51:;
        case 52:;
        case 53:;
        case 54:;
        case 55:;
        case 56:;
        case 57:;
        case 95:;
        case 36:;
        case 46:;
        {
            hsum = (((hsum << (i64)4) - hsum) + c);
        }break;
        case 65:;
        case 66:;
        case 67:;
        case 68:;
        case 69:;
        case 70:;
        case 71:;
        case 72:;
        case 73:;
        case 74:;
        case 75:;
        case 76:;
        case 77:;
        case 78:;
        case 79:;
        case 80:;
        case 81:;
        case 82:;
        case 83:;
        case 84:;
        case 85:;
        case 86:;
        case 87:;
        case 88:;
        case 89:;
        case 90:;
        {
            (*(ax_lex_lxsptr - (i64)1)) = (u64)((c + (i64)32));
            hsum = ((((hsum << (i64)4) - hsum) + c) + (i64)32);
        }break;
        default: {
            --ax_lex_lxsptr;
            goto L1054 ;
        }
        } //SW
goto L1053 ;
L1054 :;
        ;
        ax_lex_lxlength = (ax_lex_lxsptr - pstart);
        ax_lex_lxhashvalue = ((hsum << (i64)5) - hsum);
        if (!!(ax_lex_lookuplex((byte *)(pstart),ax_lex_lxlength))) {
            if (!!((u64)((*ax_lex_lxsymptr).ksymbol))) {
                ax_lex_lxsymbol = (i64)((*ax_lex_lxsymptr).ksymbol);
                ax_lex_lxsubcode = (i64)((*ax_lex_lxsymptr).subcode);
            } else {
                ax_lex_lxsymbol = (i64)((*ax_lex_lxsymptr).symbol);
            };
        } else {
            ax_lex_lxsymbol = (i64)17;
        };
        return;
    }break;
    case 65:;
    case 66:;
    case 67:;
    case 68:;
    case 69:;
    case 70:;
    case 71:;
    case 72:;
    case 73:;
    case 74:;
    case 75:;
    case 76:;
    case 77:;
    case 78:;
    case 79:;
    case 80:;
    case 81:;
    case 82:;
    case 83:;
    case 84:;
    case 85:;
    case 86:;
    case 87:;
    case 88:;
    case 89:;
    case 90:;
    {
        pstart = (ax_lex_lxsptr - (i64)1);
        c = (i64)((u64)(((*pstart) = (u64)(((i64)((u64)((*pstart))) + (i64)32)))));
        goto L1052 ;
;
    }break;
    case 48:;
    case 49:;
    case 50:;
    case 51:;
    case 52:;
    case 53:;
    case 54:;
    case 55:;
    case 56:;
    case 57:;
    {
        ax_lex_readnumber(c);
        return;
    }break;
    case 96:;
    {
        pstart = ax_lex_lxsptr;
        hsum = (i64)0;
        L1055 :;
        switch ((c = (i64)((*ax_lex_lxsptr)))) {
        case 65:;
        case 66:;
        case 67:;
        case 68:;
        case 69:;
        case 70:;
        case 71:;
        case 72:;
        case 73:;
        case 74:;
        case 75:;
        case 76:;
        case 77:;
        case 78:;
        case 79:;
        case 80:;
        case 81:;
        case 82:;
        case 83:;
        case 84:;
        case 85:;
        case 86:;
        case 87:;
        case 88:;
        case 89:;
        case 90:;
        case 97:;
        case 98:;
        case 99:;
        case 100:;
        case 101:;
        case 102:;
        case 103:;
        case 104:;
        case 105:;
        case 106:;
        case 107:;
        case 108:;
        case 109:;
        case 110:;
        case 111:;
        case 112:;
        case 113:;
        case 114:;
        case 115:;
        case 116:;
        case 117:;
        case 118:;
        case 119:;
        case 120:;
        case 121:;
        case 122:;
        case 48:;
        case 49:;
        case 50:;
        case 51:;
        case 52:;
        case 53:;
        case 54:;
        case 55:;
        case 56:;
        case 57:;
        case 95:;
        case 36:;
        case 46:;
        {
            ++ax_lex_lxsptr;
            hsum = (((hsum << (i64)4) - hsum) + c);
        }break;
        default: {
            goto L1056 ;
        }
        } //SW
goto L1055 ;
L1056 :;
        ;
        ax_lex_lxsymbol = (i64)17;
        if ((pstart == ax_lex_lxsptr)) {
            ax_lex_lxerror((byte*)"NULL ` name");
        };
        ax_lex_lxlength = (ax_lex_lxsptr - pstart);
        ax_lex_lxhashvalue = ((hsum << (i64)5) - hsum);
        if (!!(ax_lex_lookuplex((byte *)(pstart),ax_lex_lxlength))) {
            ax_lex_lxsymbol = (i64)((*ax_lex_lxsymptr).symbol);
            if ((ax_lex_lxsymbol == (i64)0)) {
                ax_lex_lxsymbol = (i64)((u64)(((*ax_lex_lxsymptr).symbol = (u64)((i64)17))));
            };
        };
        return;
    }break;
    case 33:;
    case 59:;
    case 35:;
    {
        L1057 :;
        while (!!((u64)(ax_lex_commentmap[((i64)((*ax_lex_lxsptr++)))]))) {
L1058 :;
        }L1059 :;
        ;
        if (((i64)((u64)((*(ax_lex_lxsptr - (i64)1)))) == (i64)0)) {
            --ax_lex_lxsptr;
        };
        ++ax_decls_lxlineno;
        ax_lex_lxsymbol = (i64)11;
        return;
    }break;
    case 44:;
    {
        ax_lex_lxsymbol = (i64)2;
        return;
    }break;
    case 58:;
    {
        if (((u64)((*ax_lex_lxsptr)) == (u64)58u)) {
            ax_lex_lxsymbol = (i64)4;
            ++ax_lex_lxsptr;
        } else {
            ax_lex_lxsymbol = (i64)3;
        };
        return;
    }break;
    case 91:;
    {
        ax_lex_lxsymbol = (i64)5;
        return;
    }break;
    case 93:;
    {
        ax_lex_lxsymbol = (i64)6;
        return;
    }break;
    case 43:;
    {
        ax_lex_lxsymbol = (i64)7;
        return;
    }break;
    case 45:;
    {
        ax_lex_lxsymbol = (i64)8;
        return;
    }break;
    case 42:;
    {
        ax_lex_lxsymbol = (i64)9;
        return;
    }break;
    case 61:;
    {
        ax_lex_lxsymbol = (i64)10;
        return;
    }break;
    case 39:;
    {
        pstart = ax_lex_lxsptr;
        L1060 :;
        while (1) {
            switch ((i64)((*ax_lex_lxsptr++))) {
            case 39:;
            {
                goto L1061 ;
            }break;
            case 13:;
            case 10:;
            {
                ax_lex_lxerror((byte*)"String not terminated");
            }break;
            default: {
            }
            } //SW
;
        }L1061 :;
        ;
        length = ((ax_lex_lxsptr - pstart) - (i64)1);
        ax_lex_lxvalue = (i64)0;
        L1062 :;
        for (i=length;i>=(i64)1;i-=(i64)1) {
L1063 :;
            ax_lex_lxvalue = ((ax_lex_lxvalue << (i64)8) + (i64)((u64)((*((pstart + i) - (i64)1)))));
L1064 :;
        }L1065 :;
        ;
        ax_lex_lxsymbol = (i64)14;
        return;
    }break;
    case 34:;
    {
        pstart = ax_lex_lxsptr;
        L1066 :;
        while (1) {
            switch ((i64)((*ax_lex_lxsptr++))) {
            case 34:;
            {
                ax_lex_lxsvalue = (byte *)(pstart);
                ax_lex_lxlength = ((ax_lex_lxsptr - pstart) - (i64)1);
                (*(ax_lex_lxsvalue + ax_lex_lxlength)) = (u64)0u;
                ax_lex_lxsymbol = (i64)16;
                return;
            }break;
            case 13:;
            case 10:;
            case 26:;
            case 0:;
            {
                ax_lex_lxerror((byte*)"String not terminated");
            }break;
            default: {
            }
            } //SW
;
        }L1067 :;
        ;
    }break;
    case 32:;
    case 9:;
    {
    }break;
    case 13:;
    {
    }break;
    case 10:;
    {
        ++ax_decls_lxlineno;
        ax_lex_lxsymbol = (i64)11;
        return;
    }break;
    case 0:;
    case 26:;
    {
        ax_lex_lxsymbol = (i64)12;
        --ax_lex_lxsptr;
        return;
    }break;
    default: {
        ax_lex_lxsymbol = (i64)1;
        ax_lex_lxvalue = c;
        return;
    }
    } //SW
goto L1050 ;
L1051 :;
    ;
}

void ax_lex_initlex(void) {
    i64 i;
    ax_lex_lxsubcode = (i64)0;
    ax_lex_lxsymbol = (i64)1;
    ax_decls_lxlineno = (i64)0;
    L1068 :;
    for (i=(i64)0;i<=(i64)255;i+=(i64)1) {
L1069 :;
        switch (i) {
        case 65:;
        case 66:;
        case 67:;
        case 68:;
        case 69:;
        case 70:;
        case 71:;
        case 72:;
        case 73:;
        case 74:;
        case 75:;
        case 76:;
        case 77:;
        case 78:;
        case 79:;
        case 80:;
        case 81:;
        case 82:;
        case 83:;
        case 84:;
        case 85:;
        case 86:;
        case 87:;
        case 88:;
        case 89:;
        case 90:;
        case 97:;
        case 98:;
        case 99:;
        case 100:;
        case 101:;
        case 102:;
        case 103:;
        case 104:;
        case 105:;
        case 106:;
        case 107:;
        case 108:;
        case 109:;
        case 110:;
        case 111:;
        case 112:;
        case 113:;
        case 114:;
        case 115:;
        case 116:;
        case 117:;
        case 118:;
        case 119:;
        case 120:;
        case 121:;
        case 122:;
        case 36:;
        case 95:;
        case 48:;
        case 49:;
        case 50:;
        case 51:;
        case 52:;
        case 53:;
        case 54:;
        case 55:;
        case 56:;
        case 57:;
        {
            ax_lex_alphamap[(i)] = (u64)1u;
        }break;
        default: {
        }
        } //SW
;
        switch (i) {
        case 48:;
        case 49:;
        case 50:;
        case 51:;
        case 52:;
        case 53:;
        case 54:;
        case 55:;
        case 56:;
        case 57:;
        {
            ax_lex_digitmap[(i)] = (u64)1u;
        }break;
        default: {
        }
        } //SW
;
        ax_lex_commentmap[(i)] = (u64)1u;
L1070 :;
    }L1071 :;
    ;
    ax_lex_commentmap[((i64)0)] = (u64)0u;
    ax_lex_commentmap[((i64)10)] = (u64)0u;
    ax_lex_inithashtable();
}

static void ax_lex_readreal(byte (*s)[],i64 slen,i64 intlen,i64 exponseen) {
    i64 i;
    i64 fractlen;
    i64 expon;
    i64 exponsign;
    i64 c;
    i64 digs;
    i64 av_1;
    i64 av_2;
    if (((intlen == (i64)0) || (intlen == slen))) {
        fractlen = (i64)0;
    } else {
        fractlen = (slen - intlen);
    };
    expon = (i64)0;
    exponsign = (i64)0;
    if (!!(exponseen)) {
        if (((c = (i64)((*ax_lex_lxsptr++)))==(i64)43)) {
        }else if (((c = (i64)((*ax_lex_lxsptr++)))==(i64)45)) {
            exponsign = (i64)1;
        } else {
            --ax_lex_lxsptr;
        };
        digs = (i64)0;
        L1072 :;
        switch ((c = (i64)((*ax_lex_lxsptr++)))) {
        case 48:;
        case 49:;
        case 50:;
        case 51:;
        case 52:;
        case 53:;
        case 54:;
        case 55:;
        case 56:;
        case 57:;
        {
            expon = (((expon * (i64)10) + c) - (i64)48);
            ++digs;
        }break;
        default: {
            --ax_lex_lxsptr;
            goto L1073 ;
        }
        } //SW
goto L1072 ;
L1073 :;
        ;
        if ((digs == (i64)0)) {
            ax_lex_lxerror((byte*)"Exponent error");
        };
        if (!!(exponsign)) {
            expon = -(expon);
        };
    };
    expon = (expon - fractlen);
    ax_lex_lxxvalue = (double)0.;
    L1074 :;
    for (i=(i64)1;i<=slen;i+=(i64)1) {
L1075 :;
        c = (i64)((*s)[(i)-1]);
        ax_lex_lxxvalue = ((ax_lex_lxxvalue * (double)10.) + (double)((c - (i64)48)));
L1076 :;
    }L1077 :;
    ;
    if ((expon > (i64)0)) {
        av_1 = expon;
        while (av_1-- > 0) {
L1078 :;
            ax_lex_lxxvalue = (ax_lex_lxxvalue * (double)10.);
L1079 :;
        }L1080 :;
        ;
    } else if ((expon < (i64)0)) {
        av_2 = -(expon);
        while (av_2-- > 0) {
L1081 :;
            ax_lex_lxxvalue = (ax_lex_lxxvalue / (double)10.);
L1082 :;
        }L1083 :;
        ;
    };
    ax_lex_lxsymbol = (i64)15;
}

static void ax_lex_readnumber(i64 c) {
    byte str[256];
    i64 i;
    i64 d;
    i64 intlen;
    i64 slen;
    d = (i64)((*ax_lex_lxsptr));
    if ((d==(i64)120) || (d==(i64)88)) {
        if ((c==(i64)48)) {
            ++ax_lex_lxsptr;
            ax_lex_readhex();
            return;
        }else if ((c==(i64)50)) {
            ++ax_lex_lxsptr;
            ax_lex_readbinary();
            return;
        } else {
            msysnewc_m_print_startcon();
            msysnewc_m_print_i64(c,NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            ax_lex_lxerror((byte*)"Base not supported");
        };
    };
    str[((i64)1)-1] = (u64)(c);
    slen = (i64)1;
    intlen = (i64)0;
    L1084 :;
    switch ((c = (i64)((*ax_lex_lxsptr++)))) {
    case 48:;
    case 49:;
    case 50:;
    case 51:;
    case 52:;
    case 53:;
    case 54:;
    case 55:;
    case 56:;
    case 57:;
    {
        str[(++slen)-1] = (u64)(c);
    }break;
    case 95:;
    case 39:;
    case 96:;
    {
    }break;
    case 46:;
    {
        intlen = slen;
    }break;
    case 101:;
    case 69:;
    {
        ax_lex_readreal(&str,slen,intlen,(i64)1);
        return;
    }break;
    default: {
        --ax_lex_lxsptr;
        goto L1085 ;
    }
    } //SW
goto L1084 ;
L1085 :;
    ;
    if (!!(intlen)) {
        ax_lex_readreal(&str,slen,intlen,(i64)0);
        return;
    };
    if (((slen > (i64)20) || ((slen == (i64)20) && (mlib_cmpstring(str,(byte*)"18446744073709551615") > (i64)0)))) {
        ax_lex_lxerror((byte*)"Overflow in 64-bit value");
    };
    ax_lex_lxsymbol = (i64)14;
    ax_lex_lxvalue = (i64)0;
    L1086 :;
    for (i=(i64)1;i<=slen;i+=(i64)1) {
L1087 :;
        ax_lex_lxvalue = (((ax_lex_lxvalue * (i64)10) + (i64)(str[(i)-1])) - (i64)48);
L1088 :;
    }L1089 :;
    ;
}

static void ax_lex_readbinary(void) {
    i64 ndigs;
    ndigs = (i64)0;
    ax_lex_lxvalue = (i64)0;
    L1090 :;
    switch ((i64)((*ax_lex_lxsptr++))) {
    case 48:;
    {
        ax_lex_lxvalue = (ax_lex_lxvalue * (i64)2);
        ++ndigs;
    }break;
    case 49:;
    {
        ax_lex_lxvalue = ((ax_lex_lxvalue * (i64)2) + (i64)1);
        ++ndigs;
    }break;
    case 50:;
    case 51:;
    case 52:;
    case 53:;
    case 54:;
    case 55:;
    case 56:;
    case 57:;
    {
        ax_lex_lxerror((byte*)"Bad binary digit");
    }break;
    case 95:;
    case 39:;
    case 96:;
    {
    }break;
    default: {
        --ax_lex_lxsptr;
        goto L1091 ;
    }
    } //SW
goto L1090 ;
L1091 :;
    ;
    if ((ndigs == (i64)0)) {
        ax_lex_lxerror((byte*)"No bin digits");
    } else if ((ndigs > (i64)64)) {
        ax_lex_lxerror((byte*)"Overflow in binary number");
    };
    ax_lex_lxsymbol = (i64)14;
}

static void ax_lex_readhex(void) {
    i64 ndigs;
    i64 c;
    ndigs = (i64)0;
    ax_lex_lxvalue = (i64)0;
    L1092 :;
    switch ((c = (i64)((*ax_lex_lxsptr++)))) {
    case 48:;
    case 49:;
    case 50:;
    case 51:;
    case 52:;
    case 53:;
    case 54:;
    case 55:;
    case 56:;
    case 57:;
    {
        ax_lex_lxvalue = (((ax_lex_lxvalue * (i64)16) + c) - (i64)48);
        ++ndigs;
    }break;
    case 65:;
    case 66:;
    case 67:;
    case 68:;
    case 69:;
    case 70:;
    {
        ax_lex_lxvalue = ((ax_lex_lxvalue * (i64)16) + ((c - (i64)65) + (i64)10));
        ++ndigs;
    }break;
    case 97:;
    case 98:;
    case 99:;
    case 100:;
    case 101:;
    case 102:;
    {
        ax_lex_lxvalue = ((ax_lex_lxvalue * (i64)16) + ((c - (i64)97) + (i64)10));
        ++ndigs;
    }break;
    case 95:;
    case 39:;
    case 96:;
    {
    }break;
    default: {
        --ax_lex_lxsptr;
        goto L1093 ;
    }
    } //SW
goto L1092 ;
L1093 :;
    ;
    if ((ndigs == (i64)0)) {
        ax_lex_lxerror((byte*)"No hex digits");
    } else if ((ndigs > (i64)16)) {
        ax_lex_lxerror((byte*)"Overflow in hex number");
    };
    ax_lex_lxsymbol = (i64)14;
}

void ax_lex_ps(byte * caption) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_str(caption,NULL);
    msysnewc_m_print_str((byte*)":",NULL);
    msysnewc_m_print_end();
    ;
    ax_lex_printsymbol(0);
}

void ax_lex_printsymbol(void * dev) {
    byte str[256];
    i64 av_1;
    strcpy((i8 *)(str),(i8 *)(ax_tables_symbolnames[(ax_lex_lxsymbol)-1]));
    str[(((i64)(strlen((i8 *)(str))) - (i64)2))-1] = (u64)0u;
    msysnewc_m_print_startfile(dev);
    msysnewc_m_print_str(str,NULL);
    msysnewc_m_print_end();
    ;
    av_1 = ((i64)14 - (i64)(strlen((i8 *)(str))));
    while (av_1-- > 0) {
L1094 :;
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((byte*)" ",NULL);
        msysnewc_m_print_end();
        ;
L1095 :;
    }L1096 :;
    ;
    if ((ax_lex_lxsymbol==(i64)17)) {
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((*ax_lex_lxsymptr).name,NULL);
        msysnewc_m_print_end();
        ;
    }else if ((ax_lex_lxsymbol==(i64)14)) {
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_i64(ax_lex_lxvalue,NULL);
        msysnewc_m_print_end();
        ;
    }else if ((ax_lex_lxsymbol==(i64)15)) {
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_r64(ax_lex_lxxvalue,NULL);
        msysnewc_m_print_end();
        ;
    }else if ((ax_lex_lxsymbol==(i64)16)) {
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((byte*)"\"",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str(ax_lex_lxsvalue,NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str((byte*)"\"",NULL);
        msysnewc_m_print_end();
        ;
    }else if ((ax_lex_lxsymbol==(i64)1)) {
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_i64(ax_lex_lxvalue,NULL);
        msysnewc_m_print_end();
        ;
    } else {
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str(ax_tables_symbolnames[(ax_lex_lxsymbol)-1],NULL);
        msysnewc_m_print_end();
        ;
        if (!!(ax_lex_lxsubcode)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((byte*)" ",NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_i64(ax_lex_lxsubcode,NULL);
            msysnewc_m_print_end();
            ;
        };
    };
    msysnewc_m_print_startfile(dev);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
}

static void ax_lex_clearhashtable(void) {
}

static void ax_lex_inithashtable(void) {
    byte str[32];
    i64 i;
    i64 av_1;
    i64 av_2;
    i64 av_3;
    i64 av_4;
    i64 av_5;
    i64 av_6;
    i64 av_7;
    i64 av_8;
    i64 av_9;
    i64 av_10;
    if (((i64)8388608 > (i64)65536)) {
    };
    ax_lex_clearhashtable();
    L1097 :;
    for (i=(i64)1;i<=(i64)145;i+=(i64)1) {
L1098 :;
        ax_lex_addreservedword((ax_tables_mclnames[(i)-1] + (i64)2),(i64)23,i);
L1099 :;
    }L1100 :;
    ;
    L1101 :;
    for (i=(i64)1;i<=(i64)136;i+=(i64)1) {
L1102 :;
        ax_lex_addreservedword(ax_tables_dregnames[(i)-1],(i64)24,(i64)(ax_tables_regindices[(i)-1]));
        (*ax_lex_lxsymptr).regsize = (u64)(ax_tables_regsizes[(i)-1]);
L1103 :;
    }L1104 :;
    ;
    L1105 :;
    for (i=(i64)1;i<=(i64)16;i+=(i64)1) {
L1106 :;
        ax_lex_addreservedword(ax_tables_xregnames[(i)-1],(i64)25,i);
L1107 :;
    }L1108 :;
    ;
    L1109 :;
    for (i=(i64)1;i<=(i64)8;i+=(i64)1) {
L1110 :;
        ax_lex_addreservedword(ax_tables_fregnames[(i)-1],(i64)26,i);
L1111 :;
    }L1112 :;
    ;
    L1113 :;
    for (i=(i64)1;i<=(i64)8;i+=(i64)1) {
L1114 :;
        ax_lex_addreservedword(ax_tables_mregnames[(i)-1],(i64)27,i);
L1115 :;
    }L1116 :;
    ;
    L1117 :;
    for (i=(i64)1;i<=(i64)18;i+=(i64)1) {
L1118 :;
        ax_lex_addreservedword(ax_tables_jmpccnames[(i)-1],(i64)28,(i64)(ax_tables_jmpcccodes[(i)-1]));
L1119 :;
    }L1120 :;
    ;
    L1121 :;
    for (i=(i64)1;i<=(i64)18;i+=(i64)1) {
L1122 :;
        ax_lex_addreservedword(ax_tables_setccnames[(i)-1],(i64)29,(i64)(ax_tables_setcccodes[(i)-1]));
L1123 :;
    }L1124 :;
    ;
    L1125 :;
    for (i=(i64)1;i<=(i64)18;i+=(i64)1) {
L1126 :;
        ax_lex_addreservedword(ax_tables_cmovccnames[(i)-1],(i64)30,(i64)(ax_tables_cmovcccodes[(i)-1]));
L1127 :;
    }L1128 :;
    ;
    L1129 :;
    for (i=(i64)1;i<=(i64)8;i+=(i64)1) {
L1130 :;
        ax_lex_addreservedword(ax_tables_prefixnames[(i)-1],(i64)31,(i64)(ax_tables_prefixsizes[(i)-1]));
L1131 :;
    }L1132 :;
    ;
    L1133 :;
    for (i=(i64)1;i<=(i64)5;i+=(i64)1) {
L1134 :;
        strcpy((i8 *)(str),(i8 *)(ax_tables_segmentnames[(i)-1]));
        str[(((i64)(strlen((i8 *)(str))) - (i64)3))-1] = (u64)0u;
        ax_lex_addreservedword(mlib_pcm_copyheapstring(str),(i64)32,i);
L1135 :;
    }L1136 :;
    ;
    ax_lex_addreservedword((byte*)"aframe",(i64)24,(i64)15);
    (*ax_lex_lxsymptr).regsize = (u64)((i64)4);
    ax_lex_addreservedword((byte*)"dframe",(i64)24,(i64)15);
    (*ax_lex_lxsymptr).regsize = (u64)((i64)8);
    ax_lex_addreservedword((byte*)"astack",(i64)24,(i64)16);
    (*ax_lex_lxsymptr).regsize = (u64)((i64)4);
    ax_lex_addreservedword((byte*)"dstack",(i64)24,(i64)16);
    (*ax_lex_lxsymptr).regsize = (u64)((i64)8);
    ax_lex_addreservedword((byte*)"dprog",(i64)24,(i64)9);
    (*ax_lex_lxsymptr).regsize = (u64)((i64)8);
    ax_lex_addreservedword((byte*)"dsptr",(i64)24,(i64)10);
    (*ax_lex_lxsymptr).regsize = (u64)((i64)8);
}

static void ax_lex_addreservedword(byte * name,i64 symbol,i64 subcode) {
    ax_lex_lxhashvalue = ax_lex_gethashvalue(name);
    if (!!(ax_lex_lookuplex(name,(i64)0))) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"NAME=",NULL);
        msysnewc_m_print_str(name,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        ax_lex_lxerror((byte*)"DUPL NAME");
    };
    (*ax_lex_lxsymptr).symbol = (u64)((i64)0);
    (*ax_lex_lxsymptr).ksymbol = (u64)(symbol);
    (*ax_lex_lxsymptr).subcode = (u64)(subcode);
}

void ax_lex_printhashtable(void * devx,byte * caption) {
    struct ax_decls_strec *  r;
    i64 count;
    i64 i;
    i64 av_1;
    msysnewc_m_print_startfile(devx);
    msysnewc_m_print_str(caption,NULL);
    msysnewc_m_print_str((byte*)":",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    count = (i64)0;
    L1137 :;
    for (i=(i64)0;i<=(i64)8388607;i+=(i64)1) {
L1138 :;
        r = ax_decls_lexhashtable[(i)];
        if ((!!(r) && !!((*r).name))) {
            count += (i64)1;
        };
L1139 :;
    }L1140 :;
    ;
    msysnewc_m_print_startfile(devx);
    msysnewc_m_print_i64(count,NULL);
    msysnewc_m_print_str((byte*)" items in table",NULL);
    msysnewc_m_print_i64((i64)8388608,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
}

static i64 ax_lex_lookuplex(byte * name,i64 length) {
    i64 j;
    i64 wrapped;
    i64 insource;
    i64 firstj;
    insource = length;
    if ((length == (i64)0)) {
        length = (i64)(strlen((i8 *)(name)));
    };
    firstj = (j = (ax_lex_lxhashvalue & (i64)8388607));
    wrapped = (i64)0;
    L1141 :;
    while (1) {
        ax_lex_lxsymptr = ax_decls_lexhashtable[(j)];
        if ((ax_lex_lxsymptr == 0)) {
            goto L1142 ;
        };
        if ((((i64)((u64)((*ax_lex_lxsymptr).namelen)) == length) && ((i64)(memcmp((void *)((*ax_lex_lxsymptr).name),(void *)(name),(u64)(length))) == (i64)0))) {
            return (i64)1;
        };
        if ((++j > (i64)8388608)) {
            if (!!(wrapped)) {
                msysnewc_m_print_startcon();
                msysnewc_m_print_str((byte*)"???????HASHTABLE FULL",NULL);
                msysnewc_m_print_i64((i64)8388608,NULL);
                msysnewc_m_print_i64(ax_decls_lxlineno,NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
                exit((i64)1);
            };
            wrapped = (i64)1;
            j = (i64)1;
        };
    }L1142 :;
    ;
    if (!!(insource)) {
        name = ax_lex_makestring(name,length);
    };
    if ((ax_lex_lxsymptr == 0)) {
        ax_lex_lxsymptr = (struct ax_decls_strec *)(mlib_pcm_allocz((i64)128));
        ax_decls_lexhashtable[(j)] = ax_lex_lxsymptr;
    };
    (*ax_lex_lxsymptr).name = name;
    (*ax_lex_lxsymptr).namelen = (u64)(length);
    (*ax_lex_lxsymptr).symbol = (u64)((i64)17);
    (*ax_lex_lxsymptr).ksymbol = (u64)((i64)0);
    (*ax_lex_lxsymptr).htindex = (u64)(j);
    (*ax_lex_lxsymptr).htfirstindex = (u64)(firstj);
    (*ax_lex_lxsymptr).moduleno = ax_decls_currmoduleno;
    return (i64)0;
}

void ax_lex_initsourcefile(byte * source) {
    ax_lex_lxstart = (ax_lex_lxsptr = (byte *)(source));
    ax_decls_lxlineno = (i64)1;
}

struct ax_decls_strec * ax_lex_addnamestr(byte * name) {
    ax_lex_lxhashvalue = ax_lex_gethashvalue(name);
    ax_lex_lookuplex(mlib_pcm_copyheapstring(name),(i64)0);
    return ax_lex_lxsymptr;
}

void ax_lex_lxerror(byte * m) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_setfmt((byte*)"\r\n\r\n Lexical Error\n*** # *** on line #");
    msysnewc_m_print_str(m,NULL);
    msysnewc_m_print_i64(ax_decls_lxlineno,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    exit((i64)1);
}

i64 ax_lex_gethashvalue(byte * s) {
    i64 c;
    i64 hsum;
    if (((i64)((*s)) == (i64)0)) {
        return (i64)0;
    };
    hsum = (i64)((*s++));
    L1143 :;
    while (1) {
        c = (i64)((*s++));
        if ((c == (i64)0)) {
            goto L1144 ;
        };
        hsum = (((hsum << (i64)4) - hsum) + c);
    }L1144 :;
    ;
    return ((hsum << (i64)5) - hsum);
}

void ax_lex_skiptoeol(void) {
    L1145 :;
    do {
        ax_lex_lex();
L1146 :;
    } while (!((ax_lex_lxsymbol == (i64)11) || (ax_lex_lxsymbol == (i64)12)));L1147 :;
    ;
}

static byte * ax_lex_makestring(byte * p,i64 length) {
    byte *  s;
    s = (byte *)(mlib_pcm_alloc((length + (i64)1)));
    memcpy((void *)(s),(void *)(p),(u64)(length));
    (*(s + length)) = (u64)0u;
    return s;
}

void ax_parse_readmodule(i64 moduleno) {
    struct ax_decls_strec *  symptr;
    i64 sym;
    ax_lex_initsourcefile(ax_decls_moduletable[(moduleno)-1].source);
    ax_lex_lxsymbol = (i64)11;
    ax_lib_genmc((i64)116,ax_lib_genint((i64)1,(i64)4),(struct ax_decls_opndrec *)(0));
    L1148 :;
    while ((ax_lex_lxsymbol == (i64)11)) {
        ax_lex_lex();
        switch (ax_lex_lxsymbol) {
        case 23:;
        {
            ax_parse_readinstr();
        }break;
        case 17:;
        {
            symptr = ax_lex_lxsymptr;
            ax_lex_lex();
            sym = ax_lex_lxsymbol;
            if ((sym==(i64)10)) {
                ax_lex_lex();
                if ((ax_lex_lxsymbol==(i64)24)) {
                    ax_lib_createregalias(symptr,(i64)((*ax_lex_lxsymptr).subcode),(i64)((*ax_lex_lxsymptr).regsize));
                    ax_lex_lex();
                }else if ((ax_lex_lxsymbol==(i64)25)) {
                    ax_lib_createxregalias(symptr,(i64)((*ax_lex_lxsymptr).subcode));
                    ax_lex_lex();
                } else {
                    ax_lib_createnamedconst(symptr,ax_parse_readexpression());
                };
            }else if ((sym==(i64)3) || (sym==(i64)4)) {
                ax_lib_createlabel(symptr,((sym == (i64)3)?(i64)20:(i64)22));
                ax_lib_genmc((i64)4,ax_lib_genlab(symptr,(i64)4),(struct ax_decls_opndrec *)(0));
                (*symptr).reftype = (u64)((i64)1);
                ax_lex_lxsymbol = (i64)11;
                goto L1148 ;
            } else {
                msysnewc_m_print_startcon();
                msysnewc_m_print_str((*symptr).name,NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
                ax_lib_serror((byte*)"colon expected after label");
            };
        }break;
        case 19:;
        {
            symptr = ax_lex_lxsymptr;
            ax_lex_lex();
            if ((ax_lex_lxsymbol==(i64)10)) {
                ax_lib_serror_s((byte*)"Redefining label as const: %s",(*symptr).name);
            }else if ((ax_lex_lxsymbol==(i64)3) || (ax_lex_lxsymbol==(i64)4)) {
                (*symptr).fwdrefs = (struct ax_decls_fwdrec *)(0);
                ax_lib_genmc((i64)4,ax_lib_genlab(symptr,(i64)4),(struct ax_decls_opndrec *)(0));
                (*symptr).symbol = ((ax_lex_lxsymbol == (i64)3)?(u64)((i64)20):(u64)((i64)22));
                (*symptr).reftype = (u64)((i64)1);
                ax_lex_lxsymbol = (i64)11;
                goto L1148 ;
            } else {
                ax_lib_serror((byte*)"Instruction expected");
            };
        }break;
        case 21:;
        {
            ax_lib_serror_s((byte*)"Defining imported name: %s",(*symptr).name);
        }break;
        case 20:;
        case 22:;
        {
            ax_lib_serror_s((byte*)"Redefining symbol: %s",(*symptr).name);
        }break;
        case 18:;
        {
            ax_lib_serror_s((byte*)"2:Const redefined: %s",(*symptr).name);
        }break;
        case 28:;
        {
            ax_parse_readcondinstr((i64)24);
        }break;
        case 29:;
        {
            ax_parse_readcondinstr((i64)56);
        }break;
        case 30:;
        {
            ax_parse_readcondinstr((i64)13);
        }break;
        case 11:;
        {
        }break;
        case 12:;
        {
            return;
        }break;
        default: {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((byte*)"Unknown symbol:",NULL);
            msysnewc_m_print_str(ax_tables_symbolnames[(ax_lex_lxsymbol)-1],NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
        }
        } //SW
;
L1149 :;
    }L1150 :;
    ;
    ax_lib_serror((byte*)"EOL expected");
}

void ax_parse_checkundefined(void) {
    struct ax_decls_strec *  d;
    d = ax_decls_modulenamelist;
    L1151 :;
    while (!!(d)) {
        if (((i64)((u64)((*d).symbol)) == (i64)19)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((byte*)"Undefined:",NULL);
            msysnewc_m_print_str(mlib_padstr((*d).name,(i64)20,(byte*)" "),NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            ++ax_decls_nundefined;
        };
        d = (*d).nextdef;
L1152 :;
    }L1153 :;
    ;
}

static void ax_parse_checksymbol(i64 symbol) {
    byte str[265];
    if ((ax_lex_lxsymbol != symbol)) {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_setfmt((byte*)"# expected not #");
        msysnewc_m_print_str(ax_tables_symbolnames[(symbol)-1],NULL);
        msysnewc_m_print_str(ax_tables_symbolnames[(ax_lex_lxsymbol)-1],NULL);
        msysnewc_m_print_end();
        ;
        ax_lib_serror(str);
    };
}

static void ax_parse_readinstr(void) {
    i64 opcode;
    struct ax_decls_opndrec *  a;
    struct ax_decls_opndrec *  b;
    struct ax_decls_opndrec *  c;
    opcode = ax_lex_lxsubcode;
    ax_lex_lex();
    switch (opcode) {
    case 111:;
    case 112:;
    case 113:;
    case 114:;
    case 115:;
    {
        L1154 :;
        while (1) {
            if ((ax_lex_lxsymbol == (i64)16)) {
                a = ax_lib_genstrimm(ax_lex_lxsvalue);
                ax_lex_lex();
                ax_lib_genmc(opcode,a,(struct ax_decls_opndrec *)(0));
            } else {
                a = ax_parse_readoperand();
                ax_lib_genmc(opcode,a,(struct ax_decls_opndrec *)(0));
            };
            if ((ax_lex_lxsymbol == (i64)2)) {
                ax_lex_lex();
            } else {
                goto L1155 ;
            };
        }L1155 :;
        ;
    }break;
    case 116:;
    {
        ax_parse_checksymbol((i64)32);
        ax_lib_genmc((i64)116,ax_lib_genint(ax_lex_lxsubcode,(i64)4),(struct ax_decls_opndrec *)(0));
        ax_lex_lex();
    }break;
    case 117:;
    {
        ax_lib_genmc((i64)116,ax_lib_genint((i64)2,(i64)4),(struct ax_decls_opndrec *)(0));
    }break;
    case 118:;
    {
        ax_lib_genmc((i64)116,ax_lib_genint((i64)3,(i64)4),(struct ax_decls_opndrec *)(0));
    }break;
    case 119:;
    {
        ax_lib_genmc((i64)116,ax_lib_genint((i64)1,(i64)4),(struct ax_decls_opndrec *)(0));
    }break;
    case 33:;
    {
        a = ax_parse_readoperand();
        ax_parse_checksymbol((i64)2);
        ax_lex_lex();
        b = ax_parse_readoperand();
        ax_parse_checksymbol((i64)2);
        ax_lex_lex();
        c = ax_parse_readoperand();
        ax_lib_serror((byte*)"IMUL3 CAN'T DO 3 OPNDS");
    }break;
    case 87:;
    case 88:;
    {
        a = ax_parse_readoperand();
        ax_parse_checksymbol((i64)2);
        ax_lex_lex();
        b = ax_parse_readoperand();
        ax_parse_checksymbol((i64)2);
        ax_lex_lex();
        c = ax_parse_readoperand();
        if (((i64)((u64)((*c).mode)) != (i64)2)) {
            ax_lib_serror((byte*)"pcmpistr/not int");
        };
        ax_lib_genmc(opcode,a,b);
        (*ax_lib_mccodex).c = (u64)((*c).value);
    }break;
    case 8:;
    {
        L1156 :;
        do {
            ax_lex_lex();
L1157 :;
        } while (!(ax_lex_lxsymbol == (i64)11));L1158 :;
        ;
    }break;
    default: {
        a = (b = (struct ax_decls_opndrec *)(0));
        if ((ax_lex_lxsymbol != (i64)11)) {
            a = ax_parse_readoperand();
            if ((ax_lex_lxsymbol == (i64)2)) {
                ax_lex_lex();
                b = ax_parse_readoperand();
            };
        };
        ax_lib_genmc(opcode,a,b);
    }
    } //SW
;
}

static void ax_parse_readcondinstr(i64 opc) {
    struct ax_decls_opndrec *  a;
    struct ax_decls_opndrec *  b;
    a = ax_lib_genint(ax_lex_lxsubcode,(i64)4);
    ax_lex_lex();
    b = ax_parse_readoperand();
    if (((ax_lex_lxsymbol == (i64)2) && (opc == (i64)13))) {
        ax_lib_genmc((i64)6,b,(struct ax_decls_opndrec *)(0));
        ax_lex_lex();
        b = ax_parse_readoperand();
    };
    ax_lib_genmc(opc,a,b);
}

static struct ax_decls_opndrec * ax_parse_readoperand(void) {
    struct ax_decls_opndrec *  p;
    i64 size;
    switch (ax_lex_lxsymbol) {
    case 24:;
    {
        p = ax_lib_regtable[(ax_lex_lxsubcode)-1][((i64)((*ax_lex_lxsymptr).regsize))-1];
        ax_lex_lex();
        return p;
    }break;
    case 5:;
    {
        ax_lex_lex();
        return ax_parse_readaddrmode((i64)0);
    }break;
    case 25:;
    {
        p = ax_lib_genxreg(ax_lex_lxsubcode);
        ax_lex_lex();
        return p;
    }break;
    case 31:;
    {
        size = ax_lex_lxsubcode;
        ax_lex_lex();
        ax_parse_checksymbol((i64)5);
        ax_lex_lex();
        return ax_parse_readaddrmode(size);
    }break;
    default: {
        return ax_parse_readexpression();
    }
    } //SW
;
    return (struct ax_decls_opndrec *)(0);
}

static struct ax_decls_opndrec * ax_parse_readexpression(void) {
    struct ax_decls_strec *  labelx;
    i64 valuex;
    i64 typex;
    ax_parse_readterm();
    L1159 :;
    if ((ax_lex_lxsymbol==(i64)7)) {
        labelx = ax_parse_exprlabeldef;
        valuex = ax_parse_exprvalue;
        typex = ax_parse_exprtype;
        ax_lex_lex();
        ax_parse_readterm();
        if (!!(ax_parse_exprlabeldef)) {
            ax_lib_serror((byte*)"+label?");
        };
        ax_parse_exprlabeldef = labelx;
        if ((!!(typex) || !!(ax_parse_exprtype))) {
            ax_lib_serror((byte*)"add real");
        };
        ax_parse_exprvalue += valuex;
    }else if ((ax_lex_lxsymbol==(i64)8)) {
        labelx = ax_parse_exprlabeldef;
        valuex = ax_parse_exprvalue;
        typex = ax_parse_exprtype;
        ax_lex_lex();
        ax_parse_readterm();
        if (!!(ax_parse_exprlabeldef)) {
            ax_lib_serror((byte*)"+label?");
        };
        ax_parse_exprlabeldef = labelx;
        if ((!!(typex) || !!(ax_parse_exprtype))) {
            ax_lib_serror((byte*)"sub real");
        };
        ax_parse_exprvalue = (valuex - ax_parse_exprvalue);
    } else {
        goto L1160 ;
    }goto L1159 ;
L1160 :;
    ;
    return ax_lib_genimm_expr(ax_parse_exprlabeldef,ax_parse_exprvalue,ax_parse_exprtype,(i64)4);
}

static void ax_parse_readterm(void) {
    struct ax_decls_strec *  symptr;
    double x;
    ax_parse_exprlabeldef = (struct ax_decls_strec *)(0);
    ax_parse_exprvalue = (i64)0;
    ax_parse_exprtype = (i64)0;
    switch (ax_lex_lxsymbol) {
    case 19:;
    case 20:;
    case 22:;
    {
        ax_parse_exprlabeldef = ax_lex_lxsymptr;
        ax_lex_lex();
        if ((ax_lex_lxsymbol == (i64)9)) {
            ax_lib_serror((byte*)"* applied to non-extern label or applied inconsistently");
        };
    }break;
    case 21:;
    {
        ax_parse_exprlabeldef = ax_lex_lxsymptr;
        ax_lex_lex();
        if ((ax_lex_lxsymbol != (i64)9)) {
            ax_lib_serror((byte*)"* missing or applied inconsistently");
        };
        ax_lex_lex();
    }break;
    case 18:;
    {
        ax_parse_exprlabeldef = (*(*ax_lex_lxsymptr).expr).labeldef;
        ax_parse_exprvalue = (*(*ax_lex_lxsymptr).expr).value;
        ax_parse_exprtype = (i64)((*(*ax_lex_lxsymptr).expr).valtype);
        ax_lex_lex();
    }break;
    case 17:;
    {
        symptr = ax_lex_lxsymptr;
        ax_parse_exprlabeldef = symptr;
        ax_lex_lex();
        if ((ax_lex_lxsymbol == (i64)9)) {
            ax_lib_createlabel(symptr,(i64)21);
            ax_lex_lex();
        } else {
            ax_lib_createlabel(symptr,(i64)19);
        };
    }break;
    case 14:;
    {
        ax_parse_exprvalue = ax_lex_lxvalue;
        ax_lex_lex();
    }break;
    case 15:;
    {
        ax_parse_exprvalue = *(i64*)&ax_lex_lxxvalue;
        ax_parse_exprtype = (i64)82;
        ax_lex_lex();
    }break;
    case 8:;
    {
        ax_lex_lex();
        ax_parse_readterm();
        if (!(!!(ax_parse_exprlabeldef))) {
            if (!(!!(ax_parse_exprtype))) {
                ax_parse_exprvalue = -(ax_parse_exprvalue);
            } else {
                x = -(*(double*)&ax_parse_exprvalue);
                ax_parse_exprvalue = *(i64*)&x;
            };
        } else {
            ax_lib_serror((byte*)"neg/label");
        };
    }break;
    case 7:;
    {
        ax_lex_lex();
        ax_parse_readterm();
    }break;
    default: {
        ax_lib_serror((byte*)"READTERM");
    }
    } //SW
;
}

static void ax_parse_readreg(i64 * reg,i64 * regsize,i64 * scale) {
    (*reg) = ax_lex_lxsubcode;
    (*regsize) = (i64)((*ax_lex_lxsymptr).regsize);
    ax_lex_lex();
    if ((ax_lex_lxsymbol == (i64)9)) {
        ax_lex_lex();
        ax_parse_checksymbol((i64)14);
        if ((ax_lex_lxvalue==(i64)1) || (ax_lex_lxvalue==(i64)2) || (ax_lex_lxvalue==(i64)4) || (ax_lex_lxvalue==(i64)8)) {
        } else {
            ax_lib_serror((byte*)"*n must be 1,2,4,8");
        };
        (*scale) = ax_lex_lxvalue;
        ax_lex_lex();
    } else {
        (*scale) = (i64)0;
    };
}

static struct ax_decls_opndrec * ax_parse_readaddrmode(i64 size) {
    i64 reg;
    i64 regsize;
    i64 scale;
    i64 regix;
    i64 regixsize;
    i64 scaleix;
    struct ax_decls_opndrec *  x;
    struct ax_decls_opndrec *  p;
    reg = (regix = (i64)0);
    regsize = (regixsize = (i64)0);
    scale = (scaleix = (i64)0);
    x = (struct ax_decls_opndrec *)(0);
    if ((ax_lex_lxsymbol == (i64)24)) {
        ax_parse_readreg(&reg,&regsize,&scale);
        if ((ax_lex_lxsymbol==(i64)7)) {
            ax_lex_lex();
            if ((ax_lex_lxsymbol == (i64)24)) {
                ax_parse_readreg(&regix,&regixsize,&scaleix);
                if ((ax_lex_lxsymbol==(i64)7) || (ax_lex_lxsymbol==(i64)8)) {
                    x = ax_parse_readexpression();
                };
            } else {
                x = ax_parse_readexpression();
            };
        }else if ((ax_lex_lxsymbol==(i64)8)) {
            x = ax_parse_readexpression();
        };
    } else {
        x = ax_parse_readexpression();
    };
    if ((!!(scale) && !!(scaleix))) {
        ax_lib_serror((byte*)"Two *N scales");
    };
    ax_parse_checksymbol((i64)6);
    ax_lex_lex();
    if ((!!(scale) && !(!!(scaleix)))) {
        {i64 temp = reg; reg = regix; regix = temp; };
        {i64 temp = regsize; regsize = regixsize; regixsize = temp; };
        {i64 temp = scale; scale = scaleix; scaleix = temp; };
    };
    if ((scaleix == (i64)0)) {
        scaleix = (i64)1;
    };
    if (((!!(regsize) && !!(regixsize)) && (regsize != regixsize))) {
        ax_lib_serror((byte*)"Addr reg size mismatch");
    };
    p = ax_lib_genindex(reg,regix,scaleix,x,size,(((regsize == (i64)4) || (regixsize == (i64)4))?(i64)4:(i64)8));
    return p;
}

void ax_lib_initlib(void) {
    i64 reg;
    i64 size;
    ax_lib_zero_opnd = ax_lib_genint((i64)0,(i64)4);
    L1161 :;
    for (reg=(i64)1;reg<=(i64)16;reg+=(i64)1) {
L1162 :;
        L1165 :;
        for (size=(i64)1;size<=(i64)8;size+=(i64)1) {
L1166 :;
            if ((size==(i64)1) || (size==(i64)2) || (size==(i64)4) || (size==(i64)8)) {
                ax_lib_regtable[(reg)-1][(size)-1] = ax_lib_genreg0(reg,size);
            };
L1167 :;
        }L1168 :;
        ;
L1163 :;
    }L1164 :;
    ;
    L1169 :;
    for (reg=(i64)17;reg<=(i64)20;reg+=(i64)1) {
L1170 :;
        ax_lib_regtable[(reg)-1][((i64)1)-1] = ax_lib_genreg0(reg,(i64)1);
L1171 :;
    }L1172 :;
    ;
    ax_decls_ss_symboltable = (struct ax_decls_strec * (*)[])(mlib_pcm_alloc((i64)131072));
    ax_decls_ss_symboltablesize = (i64)16384;
    ax_decls_ss_nsymbols = (i64)0;
}

void ax_lib_genmc(i64 opcode,struct ax_decls_opndrec * a,struct ax_decls_opndrec * b) {
    struct ax_lib_mclrec *  m;
    i64 nopnds;
    m = (struct ax_lib_mclrec *)(mlib_pcm_alloc((i64)36));
    ++ax_decls_nmclasm;
    (*m).nextmcl = (struct ax_lib_mclrec *)(0);
    if ((ax_lex_lxsymbol == (i64)11)) {
        (*m).lineno = (ax_decls_lxlineno - (i64)1);
    } else {
        (*m).lineno = ax_decls_lxlineno;
    };
    (*m).opcode = (u64)(opcode);
    nopnds = ((a == 0)?(i64)0:((b == 0)?(i64)1:(i64)2));
    if (((nopnds == (i64)2) && ((opcode == (i64)87) || (opcode == (i64)88)))) {
        nopnds = (i64)3;
    };
    if ((nopnds < (i64)((u64)(ax_tables_mclnopnds[(opcode)-1])))) {
        ax_lib_serror((byte*)"Too few operands");
    } else if ((nopnds > (i64)((u64)(ax_tables_mclnopnds[(opcode)-1])))) {
        ax_lib_serror((byte*)"Too many operands");
    };
    (*m).a = a;
    (*m).b = b;
    if (!!(ax_lib_mccode)) {
        (*ax_lib_mccodex).nextmcl = m;
        ax_lib_mccodex = m;
    } else {
        ax_lib_mccode = (ax_lib_mccodex = m);
    };
}

void ax_lib_genmcstr(i64 opcode,byte * s) {
    ax_lib_genmc(opcode,ax_lib_genstrimm(s),(struct ax_decls_opndrec *)(0));
}

static struct ax_decls_opndrec * ax_lib_newopnd(i64 mode) {
    struct ax_decls_opndrec *  a;
    ++ax_decls_nmclopndsasm;
    a = (struct ax_decls_opndrec *)(mlib_pcm_allocz((i64)24));
    (*a).mode = (u64)(mode);
    return a;
}

struct ax_decls_opndrec * ax_lib_genxreg(i64 xreg) {
    struct ax_decls_opndrec *  a;
    a = ax_lib_newopnd((i64)5);
    (*a).reg = (u64)(xreg);
    (*a).size = (u64)((i64)16);
    return a;
}

struct ax_decls_opndrec * ax_lib_genindex(i64 areg,i64 ireg,i64 scale,struct ax_decls_opndrec * x,i64 size,i64 addrsize) {
    struct ax_decls_opndrec *  a;
    if (!!(x)) {
        a = x;
        (*x).mode = (u64)((i64)3);
    } else {
        a = ax_lib_newopnd((i64)3);
    };
    (*a).reg = (u64)(areg);
    (*a).regix = (u64)(ireg);
    (*a).scale = (u64)(scale);
    (*a).size = (u64)(size);
    (*a).addrsize = (u64)(addrsize);
    return a;
}

struct mlib_strbuffer * ax_lib_writemclblock(void) {
    i64 i;
    struct ax_lib_mclrec *  m;
    mlib_gs_init(ax_lib_dest);
    mlib_gs_strln(ax_lib_dest,(byte*)"MC CODE");
    m = ax_lib_mccode;
    i = (i64)1;
    L1173 :;
    while (!!(m)) {
        ax_lib_writemcl(i,m);
        m = (*m).nextmcl;
        ++i;
L1174 :;
    }L1175 :;
    ;
    return ax_lib_dest;
}

void ax_lib_gencomment(byte * s) {
    if ((s == 0)) {
        ax_lib_genmc((i64)2,(struct ax_decls_opndrec *)(0),(struct ax_decls_opndrec *)(0));
    } else {
        ax_lib_genmcstr((i64)1,s);
    };
}

struct ax_decls_opndrec * ax_lib_genstrimm(byte * s) {
    struct ax_decls_opndrec *  a;
    a = ax_lib_newopnd((i64)6);
    (*a).svalue = s;
    return a;
}

static byte * ax_lib_getsizetag(i64 size) {
    if ((size==(i64)1)) {
        return (byte*)"b";
    }else if ((size==(i64)2)) {
        return (byte*)"h";
    }else if ((size==(i64)4)) {
        return (byte*)"w";
    }else if ((size==(i64)8)) {
        return (byte*)"d";
    };
    ax_lib_gerror((byte*)"GETSIZETAG?");
    return (byte *)(0);
}

static void ax_lib_writemcl(i64 index,struct ax_lib_mclrec * mcl) {
    byte mclstr[512];
    byte str[512];
    byte *  semi;
    strcpy((i8 *)(mclstr),(i8 *)(ax_lib_strmcl(mcl)));
    if (((i64)(mclstr[((i64)1)-1]) == (i64)0)) {
        return;
    };
    if (((i64)((*mcl).opcode)==(i64)1)) {
        semi = (byte*)";";
    } else {
        semi = (byte*)" ";
    };
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_str(semi,(byte*)"z3");
    msysnewc_m_print_i64(index,(byte*)"z4");
    msysnewc_m_print_nogap();
    msysnewc_m_print_str((byte*)" ",NULL);
    msysnewc_m_print_end();
    ;
    mlib_gs_str(ax_lib_dest,str);
    mlib_gs_strln(ax_lib_dest,mclstr);
}

byte * ax_lib_strmcl(struct ax_lib_mclrec * mcl) {
    static byte str[512];
    byte str2[128];
    i64 opcode;
    i64 sizepref;
    opcode = (i64)((*mcl).opcode);
    if ((opcode==(i64)7)) {
        return (*(*mcl).a).svalue;
    }else if ((opcode==(i64)2)) {
        return (byte*)"";
    }else if ((opcode==(i64)1)) {
        strcpy((i8 *)(str),(i8 *)((byte*)";"));
        strcat((i8 *)(str),(i8 *)((*(*mcl).a).svalue));
        return str;
    }else if ((opcode==(i64)4)) {
        strcpy((i8 *)(str),(i8 *)((*(*(*mcl).a).labeldef).name));
        strcat((i8 *)(str),(i8 *)((byte*)":"));
        return str;
    };
    strcpy((i8 *)(str),(i8 *)((byte*)"\t\t"));
    if ((opcode==(i64)24)) {
        strcat((i8 *)(str),(i8 *)((byte*)"j"));
        strcat((i8 *)(str),(i8 *)(ax_tables_condnames[((*(*mcl).a).value)]));
    }else if ((opcode==(i64)56)) {
        strcat((i8 *)(str),(i8 *)((byte*)"set"));
        strcat((i8 *)(str),(i8 *)(ax_tables_condnames[((*(*mcl).a).value)]));
    }else if ((opcode==(i64)13)) {
        strcat((i8 *)(str),(i8 *)((byte*)"cmov"));
        strcat((i8 *)(str),(i8 *)(ax_tables_condnames[((*(*mcl).a).value)]));
    } else {
        strcat((i8 *)(str),(i8 *)((ax_tables_mclnames[(opcode)-1] + (i64)2)));
    };
    mlib_ipadstr(str,(i64)12,(byte*)" ");
    if ((!!((*mcl).a) && !!((*mcl).b))) {
        sizepref = ax_lib_needsizeprefix((i64)((*mcl).opcode),(*mcl).a,(*mcl).b);
        strcat((i8 *)(str),(i8 *)(ax_lib_stropnd((*mcl).a,sizepref)));
        strcat((i8 *)(str),(i8 *)((byte*)",\t"));
        strcat((i8 *)(str),(i8 *)(ax_lib_stropnd((*mcl).b,sizepref)));
    } else if (!!((*mcl).a)) {
        if (((i64)((u64)((*mcl).opcode)) == (i64)19)) {
            strcat((i8 *)(str),(i8 *)(ax_lib_stropnd((*mcl).a,(i64)0)));
        } else {
            strcat((i8 *)(str),(i8 *)(ax_lib_stropnd((*mcl).a,(i64)1)));
        };
    };
    if ((opcode==(i64)87) || (opcode==(i64)88)) {
        msysnewc_m_print_startstr(str2);
        msysnewc_m_print_setfmt((byte*)", #");
        msysnewc_m_print_u64((*mcl).c,NULL);
        msysnewc_m_print_end();
        ;
        strcat((i8 *)(str),(i8 *)(str2));
    };
    return str;
}

byte * ax_lib_stropnd(struct ax_decls_opndrec * a,i64 sizeprefix) {
    static byte str[256];
    byte *  plus;
    byte *  s;
    i64 value;
    struct ax_decls_strec *  d;
    if (((i64)((*a).mode)==(i64)1)) {
        return ax_lib_getregname((i64)((*a).reg),(i64)((*a).size));
    }else if (((i64)((*a).mode)==(i64)2)) {
        d = (*a).labeldef;
        value = (*a).value;
        if (!!(d)) {
            if (((i64)((u64)((*d).symbol)) == (i64)18)) {
                return ax_lib_inttostr((*(*d).expr).value);
            };
            s = ax_lib_getfullname(d);
            if (!!(value)) {
                if ((value > (i64)0)) {
                    strcpy((i8 *)(str),(i8 *)(s));
                    strcat((i8 *)(str),(i8 *)((byte*)"+"));
                    strcat((i8 *)(str),(i8 *)(ax_lib_inttostr(value)));
                } else {
                    strcpy((i8 *)(str),(i8 *)(s));
                    strcat((i8 *)(str),(i8 *)(ax_lib_inttostr(value)));
                };
                return str;
            } else {
                strcpy((i8 *)(str),(i8 *)(s));
                return str;
            };
        };
        if (((i64)((u64)((*a).valtype)) == (i64)0)) {
            return ax_lib_inttostr(value);
        } else {
            return ax_lib_realtostr(*(double*)&value);
        };
    }else if (((i64)((*a).mode)==(i64)3)) {
        str[((i64)1)-1] = (u64)0u;
        strcat((i8 *)(str),(i8 *)(ax_lib_getsizeprefix((i64)((*a).size),sizeprefix)));
        strcat((i8 *)(str),(i8 *)((byte*)"["));
        plus = (byte*)"";
        if (!!((u64)((*a).reg))) {
            strcat((i8 *)(str),(i8 *)(ax_lib_getregname((i64)((*a).reg),(i64)((*a).addrsize))));
            plus = (byte*)"+";
        };
        if (!!((u64)((*a).regix))) {
            strcat((i8 *)(str),(i8 *)(plus));
            strcat((i8 *)(str),(i8 *)(ax_lib_getregname((i64)((*a).regix),(i64)((*a).addrsize))));
            plus = (byte*)"+";
            if (((i64)((u64)((*a).scale)) > (i64)1)) {
                strcat((i8 *)(str),(i8 *)((byte*)"*"));
                strcat((i8 *)(str),(i8 *)(ax_lib_inttostr((i64)((*a).scale))));
            };
        };
        if (!!((*a).labeldef)) {
            strcat((i8 *)(str),(i8 *)(plus));
            strcat((i8 *)(str),(i8 *)(ax_lib_strdef((*a).labeldef)));
            plus = (byte*)"+";
        };
        if (((*a).value > (i64)0)) {
            strcat((i8 *)(str),(i8 *)(plus));
            strcat((i8 *)(str),(i8 *)(ax_lib_inttostr((*a).value)));
        } else if (((*a).value < (i64)0)) {
            strcat((i8 *)(str),(i8 *)(ax_lib_inttostr((*a).value)));
        };
        strcat((i8 *)(str),(i8 *)((byte*)"]"));
    }else if (((i64)((*a).mode)==(i64)6)) {
        if (((i64)(strlen((i8 *)((*a).svalue))) >= (i64)256)) {
            msysnewc_m_print_startstr(str);
            msysnewc_m_print_str((byte*)"\"<Long string>\"",NULL);
            msysnewc_m_print_end();
            ;
        } else {
            msysnewc_m_print_startstr(str);
            msysnewc_m_print_str((byte*)"\"",NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_str((*a).svalue,NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_str((byte*)"\"",NULL);
            msysnewc_m_print_end();
            ;
        };
    }else if (((i64)((*a).mode)==(i64)4)) {
        return ax_lib_opndnames[((*a).value)];
    }else if (((i64)((*a).mode)==(i64)5)) {
        return ax_lib_xgetregname((i64)((*a).reg));
    } else {
        return (byte*)"<BAD OPND>";
    };
    return str;
}

static byte * ax_lib_strdef(struct ax_decls_strec * def) {
    if (((i64)((u64)((*def).symbol)) == (i64)18)) {
        return ax_lib_inttostr((*(*def).expr).value);
    };
    return ax_lib_getfullname(def);
}

void ax_lib_setsegment(i64 seg) {
    if ((seg == ax_lib_currsegment)) {
        return;
    };
    if ((seg==(i64)68)) {
        ax_lib_genmcstr((i64)116,(byte*)".data");
    }else if ((seg==(i64)90)) {
        ax_lib_genmcstr((i64)116,(byte*)".bss");
    }else if ((seg==(i64)67)) {
        ax_lib_genmcstr((i64)116,(byte*)".text");
    }else if ((seg==(i64)82)) {
        ax_lib_genmcstr((i64)116,(byte*)".rodata");
    };
    ax_lib_currsegment = seg;
}

static byte * ax_lib_getsizeprefix(i64 size,i64 enable) {
    if (!(!!(enable))) {
        return (byte*)"";
    };
    if ((size==(i64)1)) {
        return (byte*)"byte ";
    }else if ((size==(i64)2)) {
        return (byte*)"word ";
    }else if ((size==(i64)4)) {
        return (byte*)"dword ";
    }else if ((size==(i64)8)) {
        return (byte*)"qword ";
    }else if ((size==(i64)0)) {
        return (byte*)"";
    };
    return (byte*)"N:";
}

static i64 ax_lib_needsizeprefix(i64 opcode,struct ax_decls_opndrec * a,struct ax_decls_opndrec * b) {
    if ((opcode==(i64)16) || (opcode==(i64)17)) {
        return (i64)1;
    }else if ((opcode==(i64)81) || (opcode==(i64)82)) {
        return (i64)1;
    };
    if ((((((i64)((u64)((*a).mode)) == (i64)1) || ((i64)((u64)((*a).mode)) == (i64)5)) || ((i64)((u64)((*b).mode)) == (i64)1)) || ((i64)((u64)((*b).mode)) == (i64)5))) {
        return (i64)0;
    };
    return (i64)1;
}

struct ax_decls_opndrec * ax_lib_genimm_expr(struct ax_decls_strec * d,i64 value,i64 t,i64 size) {
    struct ax_decls_opndrec *  a;
    a = ax_lib_newopnd((i64)2);
    (*a).size = (u64)(size);
    (*a).labeldef = d;
    (*a).value = value;
    (*a).valtype = (u64)(t);
    return a;
}

struct ax_decls_opndrec * ax_lib_genint(i64 x,i64 size) {
    struct ax_decls_opndrec *  a;
    a = ax_lib_newopnd((i64)2);
    (*a).size = (u64)(size);
    (*a).value = x;
    return a;
}

struct ax_decls_opndrec * ax_lib_genlab(struct ax_decls_strec * d,i64 size) {
    struct ax_decls_opndrec *  a;
    a = ax_lib_newopnd((i64)2);
    (*a).size = (u64)(size);
    (*a).labeldef = d;
    return a;
}

struct ax_decls_opndrec * ax_lib_genmem(struct ax_decls_strec * d,i64 size) {
    struct ax_decls_opndrec *  a;
    a = ax_lib_genlab(d,size);
    (*a).mode = (u64)((i64)3);
    return a;
}

struct ax_decls_opndrec * ax_lib_genreg0(i64 reg,i64 size) {
    struct ax_decls_opndrec *  a;
    a = ax_lib_newopnd((i64)1);
    (*a).reg = (u64)(reg);
    (*a).size = (u64)(size);
    return a;
}

byte * ax_lib_getfullname(struct ax_decls_strec * d) {
    static byte str[256];
    byte *  ms;
    ms = (byte*)"";
    if (!!((*d).basedef)) {
        ms = (*(*d).basedef).name;
    };
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_setfmt((byte*)"<# : ## &:# SYM:## M:#>");
    msysnewc_m_print_str((*d).name,NULL);
    msysnewc_m_print_str((byte*)"#",NULL);
    msysnewc_m_print_i64((*d).moduleno,NULL);
    msysnewc_m_print_ptr(d,(byte*)"8");
    msysnewc_m_print_i64(((i64)(strlen((i8 *)(ax_tables_symbolnames[((i64)((*d).symbol))-1]))) - (i64)3),(byte*)"v");
    msysnewc_m_print_str(ax_tables_symbolnames[((i64)((*d).symbol))-1],(byte*)".*");
    msysnewc_m_print_str(ms,NULL);
    msysnewc_m_print_end();
    ;
    return str;
    return (*d).name;
}

byte * ax_lib_getregname(i64 reg,i64 size) {
    byte *  prefix;
    byte *  rs;
    static byte str[32];
    if ((reg==(i64)0)) {
        return (byte*)"-";
    }else if ((reg==(i64)15)) {
        rs = (byte*)"frame";
    }else if ((reg==(i64)16)) {
        rs = (byte*)"stack";
    } else {
        rs = ax_lib_inttostr((reg - (i64)1));
    };
    if ((size==(i64)1)) {
        prefix = (byte*)"B";
    }else if ((size==(i64)2)) {
        prefix = (byte*)"W";
    }else if ((size==(i64)4)) {
        prefix = (byte*)"A";
    } else {
        prefix = (byte*)"D";
    };
    strcpy((i8 *)(str),(i8 *)(prefix));
    strcat((i8 *)(str),(i8 *)(rs));
    return str;
}

byte * ax_lib_xgetregname(i64 reg) {
    static byte str[16];
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_str((byte*)"xmm",NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_i64((reg - (i64)1),NULL);
    msysnewc_m_print_end();
    ;
    return str;
}

void ax_lib_printst(void * f) {
    struct ax_decls_strec *  r;
    r = ax_decls_modulenamelist;
    L1176 :;
    while (!!(r)) {
        ax_lib_printstrec(f,r);
        r = (*r).nextdef;
L1177 :;
    }L1178 :;
    ;
}

void ax_lib_printstrec(void * f,struct ax_decls_strec * d) {
    if (((i64)((*d).symbol)==(i64)19) || ((i64)((*d).symbol)==(i64)20) || ((i64)((*d).symbol)==(i64)22)) {
        msysnewc_m_print_startfile(f);
        msysnewc_m_print_str((byte*)"Label:       ",NULL);
        msysnewc_m_print_str(mlib_padstr((*d).name,(i64)16,(byte*)" "),NULL);
        msysnewc_m_print_str((((i64)((u64)((*d).scope)) == (i64)1)?(byte*)"U":(byte*)"-"),NULL);
        msysnewc_m_print_str(ax_tables_symbolnames[((i64)((*d).symbol))-1],NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str((byte*)"\t",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str(mlib_padstr((!!((u64)((*d).segment))?ax_tables_segmentnames[((i64)((*d).segment))-1]:(byte*)"no seg"),(i64)12,(byte*)" "),NULL);
        msysnewc_m_print_i64((*d).offset,NULL);
        msysnewc_m_print_ptr((*d).fwdrefs,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    }else if (((i64)((*d).symbol)==(i64)21)) {
        msysnewc_m_print_startfile(f);
        msysnewc_m_print_str((byte*)"Label:       ",NULL);
        msysnewc_m_print_str(mlib_padstr((*d).name,(i64)16,(byte*)" "),NULL);
        msysnewc_m_print_str((byte*)"EXTERN",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    }else if (((i64)((*d).symbol)==(i64)18)) {
        msysnewc_m_print_startfile(f);
        msysnewc_m_print_str((byte*)"Named const: ",NULL);
        msysnewc_m_print_str(mlib_padstr((*d).name,(i64)16,(byte*)" "),NULL);
        msysnewc_m_print_str((byte*)"=",NULL);
        msysnewc_m_print_str(ax_lib_stropnd((*d).expr,(i64)0),NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    } else {
        msysnewc_m_print_startfile(f);
        msysnewc_m_print_str((byte*)"??",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
}

void ax_lib_adddef(struct ax_decls_strec * d) {
    (*d).nextdef = ax_decls_modulenamelist;
    ax_decls_modulenamelist = d;
}

void ax_lib_addimport(struct ax_decls_strec * d) {
    struct ax_decls_stlistrec *  p;
    p = (struct ax_decls_stlistrec *)(mlib_pcm_alloc((i64)16));
    (*p).def = d;
    (*p).nextitem = ax_decls_globalimportlist;
    ax_decls_globalimportlist = p;
}

void ax_lib_createlabel(struct ax_decls_strec * symptr,i64 symbol) {
    (*symptr).symbol = (u64)(symbol);
    (*symptr).stindex = (i64)0;
    (*symptr).moduleno = ax_decls_currmoduleno;
    ax_lib_adddef(symptr);
}

void ax_lib_createnamedconst(struct ax_decls_strec * symptr,struct ax_decls_opndrec * expr) {
    (*symptr).symbol = (u64)((i64)18);
    (*symptr).expr = expr;
    ax_lib_adddef(symptr);
}

void ax_lib_createregalias(struct ax_decls_strec * symptr,i64 regindex,i64 regsize) {
    (*symptr).symbol = (u64)((i64)24);
    (*symptr).ksymbol = (u64)((i64)24);
    (*symptr).subcode = (u64)(regindex);
    (*symptr).regsize = (u64)(regsize);
    ax_lib_adddef(symptr);
}

void ax_lib_createxregalias(struct ax_decls_strec * symptr,i64 regindex) {
    (*symptr).symbol = (u64)((i64)25);
    (*symptr).ksymbol = (u64)((i64)25);
    (*symptr).subcode = (u64)(regindex);
    ax_lib_adddef(symptr);
}

void ax_lib_gerror(byte * mess) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"SS code gen error:",NULL);
    msysnewc_m_print_str(mess,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"On line:",NULL);
    msysnewc_m_print_i64(ax_decls_alineno,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    exit((i64)1);
}

void ax_lib_serror(byte * mess) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"Syntax error: '",NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_str(mess,NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_str((byte*)"' on line",NULL);
    msysnewc_m_print_i64(ax_decls_lxlineno,NULL);
    msysnewc_m_print_str(ax_decls_moduletable[(ax_decls_currmoduleno)-1].name,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    exit((i64)1);
}

void ax_lib_serror_s(byte * mess,byte * param) {
    byte str[256];
    sprintf((i8 *)(str),(i8 *)(mess),param);
    ax_lib_serror(str);
}

static byte * ax_lib_inttostr(i64 a) {
    static byte str[64];
    msysnewc_getstrint(a,str);
    return str;
}

static byte * ax_lib_realtostr(double a) {
    static byte str[64];
    strcpy((i8 *)(str),(i8 *)(msysnewc_strreal(a,(byte *)(0))));
    return str;
}

struct ax_decls_dbuffer * ax_lib_buffercreate(i64 size) {
    struct ax_decls_dbuffer *  a;
    a = (struct ax_decls_dbuffer *)(mlib_pcm_alloc((i64)32));
    (*a).alloc = size;
    (*a).pstart = ((*a).pcurr = (byte *)(mlib_pcm_alloc((*a).alloc)));
    (*a).pend = ((*a).pstart + (*a).alloc);
    return a;
}

static void ax_lib_bufferexpand(struct ax_decls_dbuffer * a) {
    i64 newalloc;
    i64 usedbytes;
    byte *  p;
    newalloc = ((*a).alloc * (i64)2);
    usedbytes = ((*a).pcurr - (*a).pstart);
    if ((usedbytes > (*a).alloc)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"dbuffer error",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        msysnewc_m_print_startcon();
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        msysnewc_m_print_startcon();
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        msysnewc_m_print_startcon();
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        exit(0);
    };
    p = (byte *)(mlib_pcm_alloc(newalloc));
    memcpy((void *)(p),(void *)((*a).pstart),(u64)(usedbytes));
    (*a).pstart = p;
    (*a).pcurr = (p + usedbytes);
    (*a).alloc = newalloc;
    (*a).pend = (p + newalloc);
}

void ax_lib_buffercheck(struct ax_decls_dbuffer * a,i64 n) {
    L1179 :;
    while ((((*a).pend - (*a).pcurr) < n)) {
        ax_lib_bufferexpand(a);
L1180 :;
    }L1181 :;
    ;
}

i64 ax_lib_bufferlength(struct ax_decls_dbuffer * a) {
    return ((*a).pcurr - (*a).pstart);
}

void * ax_lib_bufferelemptr(struct ax_decls_dbuffer * a,i64 offset) {
    return (void *)(((*a).pstart + offset));
}

void ax_lib_addbyte(struct ax_decls_dbuffer * a,i64 x) {
    (*(*a).pcurr) = (u64)(x);
    ++(*a).pcurr;
}

void ax_lib_addword(struct ax_decls_dbuffer * a,i64 x) {
    (*(*a).pcurr16) = (u64)(x);
    ++(*a).pcurr16;
}

void ax_lib_adddword(struct ax_decls_dbuffer * a,i64 x) {
    (*(*a).pcurr32) = (u64)(x);
    ++(*a).pcurr32;
}

void ax_lib_addqword(struct ax_decls_dbuffer * a,i64 x) {
    (*(*a).pcurr64) = (u64)(x);
    ++(*a).pcurr64;
}

void ax_lib_printmodulesymbols(void * f) {
    struct ax_decls_strec *  d;
    struct ax_decls_strec *  e;
    msysnewc_m_print_startfile(f);
    msysnewc_m_print_str((byte*)"MODULE SYMBOLS IN",NULL);
    msysnewc_m_print_str(ax_decls_moduletable[(ax_decls_currmoduleno)-1].name,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    d = ax_decls_modulenamelist;
    L1182 :;
    while (!!(d)) {
        msysnewc_m_print_startfile(f);
        msysnewc_m_print_str((byte*)"   ",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str(mlib_padstr((*d).name,(i64)14,(byte*)" "),NULL);
        msysnewc_m_print_str(mlib_padstr(ax_tables_symbolnames[((i64)((*d).symbol))-1],(i64)12,(byte*)" "),NULL);
        msysnewc_m_print_end();
        ;
        msysnewc_m_print_startfile(f);
        msysnewc_m_print_setfmt((byte*)"|| # # #");
        msysnewc_m_print_u64((*d).htfirstindex,(byte*)"6");
        msysnewc_m_print_u64((*d).htindex,(byte*)"6");
        msysnewc_m_print_ptr(d,(byte*)"8H");
        msysnewc_m_print_end();
        ;
        e = ax_decls_dupltable[((i64)((*d).htfirstindex))];
        if (!!(e)) {
            msysnewc_m_print_startfile(f);
            msysnewc_m_print_str((byte*)"||",NULL);
            msysnewc_m_print_end();
            ;
            L1185 :;
            while (!!(e)) {
                msysnewc_m_print_startfile(f);
                msysnewc_m_print_str((byte*)"(",NULL);
                msysnewc_m_print_nogap();
                msysnewc_m_print_str((*e).name,NULL);
                msysnewc_m_print_nogap();
                msysnewc_m_print_str((byte*)")",NULL);
                msysnewc_m_print_end();
                ;
                e = (*e).nextdupl;
L1186 :;
            }L1187 :;
            ;
        };
        msysnewc_m_print_startfile(f);
        msysnewc_m_print_str((byte*)" BASE:",NULL);
        msysnewc_m_print_str((!!((*d).basedef)?(*(*d).basedef).name:(byte*)""),NULL);
        msysnewc_m_print_ptr((*d).basedef,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        d = (*d).nextdef;
L1183 :;
    }L1184 :;
    ;
    msysnewc_m_print_startfile(f);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
}

void ax_lib_printimportsymbols(void * f) {
    struct ax_decls_strec *  d;
    struct ax_decls_stlistrec *  p;
    msysnewc_m_print_startfile(f);
    msysnewc_m_print_str((byte*)"GLOBAL IMPORT TABLE",NULL);
    msysnewc_m_print_ptr(ax_decls_globalimportlist,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    p = ax_decls_globalimportlist;
    L1188 :;
    while (!!(p)) {
        d = (*p).def;
        msysnewc_m_print_startfile(f);
        msysnewc_m_print_str((byte*)"   ",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str(mlib_padstr((*d).name,(i64)14,(byte*)" "),NULL);
        msysnewc_m_print_str(mlib_padstr(ax_tables_symbolnames[((i64)((*d).symbol))-1],(i64)12,(byte*)" "),NULL);
        msysnewc_m_print_end();
        ;
        msysnewc_m_print_startfile(f);
        msysnewc_m_print_str((byte*)"D^.OFFSET=",NULL);
        msysnewc_m_print_i64((*d).offset,NULL);
        msysnewc_m_print_str(ax_tables_reftypenames[((i64)((*d).reftype))],NULL);
        msysnewc_m_print_ptr((void *)(d),NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        p = (*p).nextitem;
L1189 :;
    }L1190 :;
    ;
    msysnewc_m_print_startfile(f);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
}

void ax_lib_printdupltable(void * f) {
    byte str[256];
    struct ax_decls_strec *  d;
    i64 i;
    i64 av_1;
    msysnewc_m_print_startfile(f);
    msysnewc_m_print_str((byte*)"DUPL TABLE",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    L1191 :;
    for (i=(i64)0;i<=(i64)8388607;i+=(i64)1) {
L1192 :;
        if (!!(ax_decls_dupltable[(i)])) {
            d = ax_decls_dupltable[(i)];
            msysnewc_m_print_startfile(f);
            msysnewc_m_print_str((byte*)"\t",NULL);
            msysnewc_m_print_u64((*d).htfirstindex,NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_str((byte*)":",NULL);
            msysnewc_m_print_end();
            ;
            L1195 :;
            while (!!(d)) {
                msysnewc_m_print_startstr(str);
                msysnewc_m_print_setfmt((byte*)"(# # (#) #) ");
                msysnewc_m_print_u64((*d).htindex,(byte*)"6");
                msysnewc_m_print_str((*d).name,NULL);
                msysnewc_m_print_str(ax_decls_moduletable[((i64)((*d).moduleno))-1].name,NULL);
                msysnewc_m_print_ptr(d,(byte*)"8H");
                msysnewc_m_print_end();
                ;
                d = (*d).nextdupl;
L1196 :;
            }L1197 :;
            ;
            msysnewc_m_print_startfile(f);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
        };
L1193 :;
    }L1194 :;
    ;
    msysnewc_m_print_startfile(f);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
}

void ax_genss_genss(void) {
    i64 index;
    struct ax_lib_mclrec *  m;
    ax_decls_ss_zdatalen = (i64)0;
    ax_decls_ss_zdata = ax_lib_buffercreate((i64)1024);
    ax_decls_ss_idata = ax_lib_buffercreate((i64)1024);
    ax_decls_ss_code = ax_lib_buffercreate((i64)1024);
    ax_decls_ss_idatarelocs = (struct ax_decls_relocrec *)(0);
    ax_decls_ss_coderelocs = (struct ax_decls_relocrec *)(0);
    ax_decls_ss_nsymbols = (i64)0;
    ax_genss_switchseg((i64)1);
    ax_decls_alineno = (i64)9999;
    ax_genss_extraparam = (struct ax_decls_opndrec *)(0);
    m = ax_lib_mccode;
    index = (i64)0;
    L1198 :;
    while (!!(m)) {
        ax_decls_alineno = (*m).lineno;
        ax_genss_doinstr(m,++index);
        m = (*m).nextmcl;
L1199 :;
    }L1200 :;
    ;
    ax_genss_switchseg((i64)0);
    if (!!(ax_lib_bufferlength(ax_decls_ss_zdata))) {
        ax_lib_gerror((byte*)"Zdata contains code or data");
    };
}

static void ax_genss_doinstr(struct ax_lib_mclrec * m,i64 index) {
    struct ax_decls_opndrec *  a;
    struct ax_decls_opndrec *  b;
    struct ax_decls_strec *  d;
    i64 x;
    i64 offset;
    i64 shortjmp;
    i64 n;
    i64 av_1;
    i64 av_2;
    ax_genss_currmcl = m;
    ax_lib_buffercheck(ax_genss_currdata,(i64)1024);
    ax_genss_rex = (ax_genss_sizeoverride = (ax_genss_addroverride = (ax_genss_f2override = (ax_genss_f3override = (i64)0))));
    a = (*m).a;
    b = (*m).b;
    switch ((i64)((*m).opcode)) {
    case 4:;
    {
        d = (*a).labeldef;
        (*d).reftype = (u64)((i64)2);
        (*d).segment = (u64)(ax_genss_currseg);
        (*d).offset = ax_genss_getcurrdatalen((i64)6);
        if (((i64)((u64)((*d).symbol)) == (i64)22)) {
            ax_genss_getstindex(d);
        };
        ax_genss_dofwdrefs(d);
    }break;
    case 19:;
    {
        ax_genss_do_call(a);
    }break;
    case 23:;
    {
        ax_genss_do_jmp(a,m);
    }break;
    case 24:;
    {
        offset = ax_genss_getrel32((*b).labeldef,(ax_genss_getcurrdatalen((i64)7) + (i64)1));
        if ((offset < (i64)0)) {
            if ((offset < (i64)-126)) {
                ax_genss_genbyte((i64)15);
                ax_genss_genbyte(((i64)128 + (*a).value));
                ax_genss_gendword((offset - (i64)4));
            } else {
                ax_genss_genbyte(((i64)112 + (*(*m).a).value));
                ax_genss_genbyte(offset);
            };
        } else {
            shortjmp = ax_genss_checkshortjump(m,(*b).labeldef);
            if (!(!!(shortjmp))) {
                ax_genss_genbyte((i64)15);
                ax_genss_genbyte(((i64)128 + (*a).value));
                ax_genss_genrel32(b);
            } else {
                ax_genss_genbyte(((i64)112 + (*a).value));
                ax_genss_genrel8(b);
            };
        };
    }break;
    case 111:;
    {
        ax_genss_genopnd(a,(i64)1);
    }break;
    case 112:;
    {
        ax_genss_genopnd(a,(i64)2);
    }break;
    case 113:;
    {
        ax_genss_genopnd(a,(i64)4);
    }break;
    case 114:;
    {
        ax_genss_genopnd(a,(i64)8);
    }break;
    case 115:;
    {
        ax_genss_genrel32(a);
    }break;
    case 116:;
    {
        ax_genss_switchseg((*a).value);
    }break;
    case 5:;
    case 145:;
    {
        ax_genss_genbyte((i64)(ax_tables_mclcodes[((i64)((*m).opcode))-1]));
    }break;
    case 52:;
    {
        ax_genss_genbyte((i64)102);
        ax_genss_genbyte((i64)152);
    }break;
    case 53:;
    {
        ax_genss_genbyte((i64)102);
        ax_genss_genbyte((i64)153);
    }break;
    case 54:;
    {
        ax_genss_genbyte((i64)153);
    }break;
    case 55:;
    {
        ax_genss_genbyte((i64)72);
        ax_genss_genbyte((i64)153);
    }break;
    case 20:;
    {
        ax_genss_genbyte((i64)195);
    }break;
    case 22:;
    {
        ax_genss_genbyte((i64)201);
    }break;
    case 21:;
    {
        if (((i64)((u64)((*a).mode)) != (i64)2)) {
            ax_lib_gerror((byte*)"retn?");
        };
        ax_genss_genbyte((i64)194);
        ax_genss_genword((*a).value);
    }break;
    case 10:;
    {
        ax_genss_do_push(a);
    }break;
    case 11:;
    {
        ax_genss_do_pop(a);
    }break;
    case 50:;
    case 51:;
    {
        ax_genss_do_inc(a,(i64)(ax_tables_mclcodes[((i64)((*m).opcode))-1]));
    }break;
    case 48:;
    case 49:;
    case 31:;
    case 30:;
    case 35:;
    case 34:;
    {
        ax_genss_do_neg(a,(i64)(ax_tables_mclcodes[((i64)((*m).opcode))-1]));
    }break;
    case 26:;
    case 27:;
    case 36:;
    case 37:;
    case 38:;
    case 28:;
    case 29:;
    case 40:;
    {
        ax_genss_do_arith(a,b,(i64)(ax_tables_mclcodes[((i64)((*m).opcode))-1]));
    }break;
    case 9:;
    {
        ax_genss_do_mov(a,b);
    }break;
    case 12:;
    {
        ax_genss_do_lea(a,b);
    }break;
    case 16:;
    {
        ax_genss_do_movsx(a,b,(i64)190);
    }break;
    case 17:;
    {
        ax_genss_do_movsx(a,b,(i64)182);
    }break;
    case 18:;
    {
        ax_genss_do_movsxd(a,b);
    }break;
    case 25:;
    {
        ax_genss_do_exch(a,b);
    }break;
    case 32:;
    {
        ax_genss_do_imul2(a,b);
    }break;
    case 121:;
    case 122:;
    case 123:;
    case 124:;
    {
        if (((i64)((u64)((*a).mode)) == (i64)2)) {
            n = ((*a).value * (i64)((u64)(ax_tables_mclcodes[((i64)((*m).opcode))-1])));
            ax_lib_buffercheck(ax_genss_currdata,n);
            if ((ax_genss_currseg==(i64)1)) {
                av_1 = n;
                while (av_1-- > 0) {
L1201 :;
                    ax_genss_genbyte((i64)144);
L1202 :;
                }L1203 :;
                ;
            }else if ((ax_genss_currseg==(i64)2)) {
                av_2 = n;
                while (av_2-- > 0) {
L1204 :;
                    ax_genss_genbyte((i64)0);
L1205 :;
                }L1206 :;
                ;
            } else {
                ax_decls_ss_zdatalen += n;
            };
        } else {
            ax_lib_gerror((byte*)"resb?");
        };
    }break;
    case 120:;
    {
        if (((i64)((u64)((*a).mode)) == (i64)2)) {
            x = (*a).value;
            if (((x < (i64)1) || (x > (i64)16384))) {
                ax_lib_gerror((byte*)"align2");
            };
            if ((ax_genss_currseg != (i64)3)) {
                L1207 :;
                while (!!((ax_lib_bufferlength(ax_genss_currdata) % x))) {
                    ax_genss_genbyte(((ax_genss_currseg == (i64)1)?(i64)144:(i64)0));
L1208 :;
                }L1209 :;
                ;
            } else {
                L1210 :;
                while (!!((ax_decls_ss_zdatalen % x))) {
                    ++ax_decls_ss_zdatalen;
L1211 :;
                }L1212 :;
                ;
            };
        } else {
            ax_lib_gerror((byte*)"align?");
        };
    }break;
    case 41:;
    case 43:;
    case 42:;
    case 44:;
    case 45:;
    case 46:;
    case 47:;
    {
        ax_genss_do_shift(a,b,(i64)(ax_tables_mclcodes[((i64)((*m).opcode))-1]));
    }break;
    case 39:;
    {
        ax_genss_do_test(a,b);
    }break;
    case 128:;
    case 127:;
    case 126:;
    {
        ax_genss_do_loop(a,(i64)(ax_tables_mclcodes[((i64)((*m).opcode))-1]));
    }break;
    case 129:;
    {
        ax_genss_do_jcxz(a,(i64)4);
    }break;
    case 130:;
    {
        ax_genss_do_jcxz(a,(i64)8);
    }break;
    case 125:;
    {
        ax_genss_genbyte((i64)215);
    }break;
    case 56:;
    {
        ax_genss_do_setcc(a,b);
    }break;
    case 14:;
    {
        ax_genss_do_movxmm(a,b,(i64)4);
    }break;
    case 15:;
    {
        ax_genss_do_movxmm(a,b,(i64)8);
    }break;
    case 61:;
    case 62:;
    case 63:;
    case 64:;
    case 60:;
    case 107:;
    case 108:;
    {
        ax_genss_do_arithxmm(a,b,(i64)243,(i64)(ax_tables_mclcodes[((i64)((*m).opcode))-1]));
    }break;
    case 65:;
    case 66:;
    case 67:;
    case 68:;
    case 59:;
    case 109:;
    case 110:;
    {
        ax_genss_do_arithxmm(a,b,(i64)242,(i64)(ax_tables_mclcodes[((i64)((*m).opcode))-1]));
    }break;
    case 74:;
    case 72:;
    {
        ax_genss_do_logicxmm(a,b,(i64)(ax_tables_mclcodes[((i64)((*m).opcode))-1]),(i64)4);
    }break;
    case 73:;
    case 71:;
    case 76:;
    case 75:;
    {
        ax_genss_do_logicxmm(a,b,(i64)(ax_tables_mclcodes[((i64)((*m).opcode))-1]),(i64)8);
    }break;
    case 87:;
    case 88:;
    {
        ax_genss_do_pcmpistri(a,b,(i64)((*m).c),(i64)(ax_tables_mclcodes[((i64)((*m).opcode))-1]));
    }break;
    case 69:;
    {
        ax_genss_do_arithxmm(a,b,(i64)0,(i64)47);
    }break;
    case 70:;
    {
        ax_genss_do_arithxmm(a,b,(i64)102,(i64)47);
    }break;
    case 84:;
    {
        ax_genss_do_convertfloat(a,b,(i64)243);
    }break;
    case 83:;
    {
        ax_genss_do_convertfloat(a,b,(i64)242);
    }break;
    case 77:;
    {
        ax_genss_do_fix(a,b,(i64)243,(i64)45);
    }break;
    case 78:;
    {
        ax_genss_do_fix(a,b,(i64)242,(i64)45);
    }break;
    case 79:;
    {
        ax_genss_do_fix(a,b,(i64)243,(i64)44);
    }break;
    case 80:;
    {
        ax_genss_do_fix(a,b,(i64)242,(i64)44);
    }break;
    case 81:;
    {
        ax_genss_do_float(a,b,(i64)243);
    }break;
    case 82:;
    {
        ax_genss_do_float(a,b,(i64)242);
    }break;
    case 6:;
    {
        ax_genss_extraparam = a;
    }break;
    case 13:;
    {
        ax_genss_do_cmovcc(a,ax_genss_extraparam,b);
    }break;
    case 99:;
    case 100:;
    case 101:;
    case 102:;
    case 103:;
    case 104:;
    case 105:;
    case 106:;
    {
        ax_genss_genbyte((i64)217);
        ax_genss_genbyte((i64)(ax_tables_mclcodes[((i64)((*m).opcode))-1]));
    }break;
    case 89:;
    case 90:;
    case 91:;
    {
        ax_genss_do_fmem(a,(i64)1,(i64)(ax_tables_mclcodes[((i64)((*m).opcode))-1]));
    }break;
    case 92:;
    case 93:;
    case 94:;
    {
        ax_genss_do_fmem(a,(i64)0,(i64)(ax_tables_mclcodes[((i64)((*m).opcode))-1]));
    }break;
    case 95:;
    case 96:;
    case 97:;
    case 98:;
    {
        ax_genss_genbyte((i64)222);
        ax_genss_genbyte((i64)(ax_tables_mclcodes[((i64)((*m).opcode))-1]));
    }break;
    case 131:;
    {
        ax_genss_genbyte((i64)166);
    }break;
    case 132:;
    {
        ax_genss_genbyte((i64)102);
        ax_genss_genbyte((i64)167);
    }break;
    case 133:;
    {
        ax_genss_genbyte((i64)167);
    }break;
    case 134:;
    {
        ax_genss_genbyte((i64)72);
        ax_genss_genbyte((i64)167);
    }break;
    case 135:;
    {
        ax_genss_genbyte((i64)15);
        ax_genss_genbyte((i64)(ax_tables_mclcodes[((i64)((*m).opcode))-1]));
    }break;
    case 85:;
    case 86:;
    {
        ax_genss_do_movdqx(a,b,(i64)(ax_tables_mclcodes[((i64)((*m).opcode))-1]));
    }break;
    case 137:;
    {
        ax_genss_genbyte((i64)219);
        ax_genss_genbyte((i64)227);
    }break;
    case 138:;
    case 139:;
    case 140:;
    case 141:;
    case 142:;
    case 143:;
    case 144:;
    {
        ax_genss_genbyte((i64)217);
        ax_genss_genbyte((i64)(ax_tables_mclcodes[((i64)((*m).opcode))-1]));
    }break;
    case 136:;
    {
        ax_genss_do_popcnt(a,b);
    }break;
    case 57:;
    case 58:;
    {
        ax_genss_do_bsf(a,b,(i64)(ax_tables_mclcodes[((i64)((*m).opcode))-1]));
    }break;
    default: {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"*** CAN'T DO OPCODE",NULL);
        msysnewc_m_print_str(ax_tables_mclnames[((i64)((*m).opcode))-1],NULL);
        msysnewc_m_print_str((byte*)"line",NULL);
        msysnewc_m_print_i64(ax_decls_alineno,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    }
    } //SW
;
}

static void ax_genss_genbyte(i64 x) {
    (*(*ax_genss_currdata).pcurr++) = (u64)(x);
}

static void ax_genss_genword(i64 x) {
    ax_lib_addword(ax_genss_currdata,x);
}

static void ax_genss_gendword(i64 x) {
    ax_lib_adddword(ax_genss_currdata,x);
}

static void ax_genss_genqword(i64 x) {
    ax_lib_addqword(ax_genss_currdata,x);
}

static void ax_genss_genopnd(struct ax_decls_opndrec * a,i64 size) {
    byte *  s;
    i64 x;
    i64 length;
    if ((size == (i64)0)) {
        size = (i64)((*a).size);
    };
    switch ((i64)((*a).mode)) {
    case 2:;
    case 3:;
    {
    }break;
    case 6:;
    {
        s = (*a).svalue;
        length = (i64)(strlen((i8 *)(s)));
        if ((length > (i64)100)) {
            ax_lib_buffercheck(ax_genss_currdata,msysnewc_m_imax((i64)1024,(length + (i64)1)));
        };
        L1213 :;
        while (!!((u64)((*s)))) {
            ax_genss_genbyte((i64)((*s++)));
L1214 :;
        }L1215 :;
        ;
        return;
    }break;
    default: {
        ax_lib_gerror((byte*)"GENOPND/bad opnd");
    }
    } //SW
;
    if ((!!((*a).labeldef) && (size <= (i64)2))) {
        ax_lib_gerror((byte*)"8/16-BIT RELOC");
    };
    if ((size==(i64)1)) {
        ax_genss_genbyte((*a).value);
    }else if ((size==(i64)2)) {
        ax_genss_genword((*a).value);
    }else if ((size==(i64)4)) {
        if (!!((*a).labeldef)) {
            ax_genss_genabs32(a);
        } else {
            if (!!((u64)((*a).valtype))) {
                ax_genss_gendword(ax_genss_getr32bits((*a).xvalue));
            } else {
                ax_genss_gendword((*a).value);
            };
        };
    }else if ((size==(i64)8)) {
        if (!!((*a).labeldef)) {
            ax_genss_genabs64(a);
        } else {
            x = (*a).value;
            if (!!((u64)((*a).valtype))) {
                ax_genss_genqword(*(i64*)&x);
            } else {
                ax_genss_genqword(x);
            };
        };
    };
}

static void ax_genss_addrelocitem(i64 reloctype,struct ax_decls_strec * d) {
    struct ax_decls_relocrec *  r;
    i64 stindex;
    i64 adjust;
    stindex = ax_genss_getstindex(d);
    adjust = (i64)4;
    if ((reloctype == (i64)1)) {
        adjust = (i64)8;
    };
    r = (struct ax_decls_relocrec *)(mlib_pcm_alloc((i64)32));
    (*r).nextreloc = ax_genss_currrelocs;
    (*r).reloctype = reloctype;
    (*r).offset = (ax_genss_getcurrdatalen((i64)1) - adjust);
    (*r).stindex = stindex;
    ++ax_genss_nrelocs;
    ax_genss_currrelocs = r;
}

static i64 ax_genss_getstindex(struct ax_decls_strec * d) {
    if (((i64)((*d).stindex) == (i64)0)) {
        if ((ax_decls_ss_nsymbols >= ax_decls_ss_symboltablesize)) {
            ax_genss_extendsymboltable();
        };
        (*d).stindex = ++ax_decls_ss_nsymbols;
        (*ax_decls_ss_symboltable)[((i64)((*d).stindex))-1] = d;
    };
    return (i64)((*d).stindex);
}

static void ax_genss_genrel32(struct ax_decls_opndrec * a) {
    struct ax_decls_strec *  d;
    d = (*a).labeldef;
    if ((d == 0)) {
        ax_genss_gendword((*a).value);
        return;
    };
    if (((i64)((*d).reftype)==(i64)2)) {
        if (((i64)((u64)((*d).segment)) != ax_genss_currseg)) {
            ax_lib_gerror((byte*)"Rel label across segments");
        };
        ax_genss_gendword(((i64)((*d).offset) - (ax_genss_getcurrdatalen((i64)2) + (i64)4)));
    }else if (((i64)((*d).reftype)==(i64)1)) {
        (*d).fwdrefs = ax_genss_addfwdref((*d).fwdrefs,ax_genss_getcurrdatalen((i64)3),(i64)4,(i64)0);
        ax_genss_gendword((i64)0);
    } else {
        ax_genss_gendword((*a).value);
        ax_genss_addrelocitem((i64)4,d);
    };
}

static void ax_genss_genabs32(struct ax_decls_opndrec * a) {
    struct ax_decls_strec *  d;
    d = (*a).labeldef;
    if (((i64)((*d).reftype)==(i64)2)) {
        ax_genss_gendword(((i64)((*d).offset) + (*a).value));
        ax_genss_addrelocitem((i64)2,d);
    }else if (((i64)((*d).reftype)==(i64)1)) {
        (*d).fwdrefs = ax_genss_addfwdref((*d).fwdrefs,ax_genss_getcurrdatalen((i64)4),(i64)2,ax_genss_currseg);
        ax_genss_gendword((*a).value);
        ax_genss_addrelocitem((i64)2,d);
    } else {
        ax_genss_gendword((*a).value);
        ax_genss_addrelocitem((i64)2,d);
    };
}

static void ax_genss_genabs64(struct ax_decls_opndrec * a) {
    struct ax_decls_strec *  d;
    d = (*a).labeldef;
    if (((i64)((*d).reftype)==(i64)2)) {
        ax_genss_genqword(((i64)((*d).offset) + (*a).value));
        ax_genss_addrelocitem((i64)1,d);
    }else if (((i64)((*d).reftype)==(i64)1)) {
        (*d).fwdrefs = ax_genss_addfwdref((*d).fwdrefs,ax_genss_getcurrdatalen((i64)5),(i64)2,ax_genss_currseg);
        ax_genss_genqword((*a).value);
        ax_genss_addrelocitem((i64)1,d);
    } else {
        ax_genss_genqword((*a).value);
        ax_genss_addrelocitem((i64)1,d);
    };
}

static i64 ax_genss_getrel32(struct ax_decls_strec * d,i64 offset) {
    if (((i64)((u64)((*d).reftype)) == (i64)2)) {
        if (((i64)((u64)((*d).segment)) != ax_genss_currseg)) {
            ax_lib_gerror((byte*)"Rel label across segments2");
        };
        return ((i64)((*d).offset) - (offset + (i64)1));
    } else {
        return (i64)2147483647;
    };
}

static void ax_genss_dofwdrefs(struct ax_decls_strec * d) {
    struct ax_decls_fwdrec *  f;
    i64 offset;
    byte *  p8;
    i32 *  p32;
    i64 *  p64;
    struct ax_decls_dbuffer *  data;
    if (((*d).fwdrefs == 0)) {
        return;
    };
    f = (*d).fwdrefs;
    L1216 :;
    while (!!(f)) {
        offset = (i64)((*f).offset);
        if (((i64)((*f).reltype)==(i64)4)) {
            p32 = (i32 *)(ax_lib_bufferelemptr(ax_genss_currdata,offset));
            (*p32) = (((i64)((*d).offset) - offset) - (i64)4);
        }else if (((i64)((*f).reltype)==(i64)2) || ((i64)((*f).reltype)==(i64)1)) {
            if (((i64)((*f).seg)==(i64)1)) {
                data = ax_decls_ss_code;
            }else if (((i64)((*f).seg)==(i64)3)) {
                ax_lib_gerror((byte*)"Fwd ref in zdata");
            }else if (((i64)((*f).seg)==(i64)2)) {
                data = ax_decls_ss_idata;
            };
            p32 = (i32 *)(ax_lib_bufferelemptr(data,offset));
            if (((i64)((*f).reltype) == (i64)2)) {
                (*p32) = ((i64)((*p32)) + (i64)((*d).offset));
            } else {
                p64 = (i64 *)(p32);
                (*p64) = ((*p64) + (i64)((*d).offset));
            };
        }else if (((i64)((*f).reltype)==(i64)6)) {
            p8 = (byte *)(ax_lib_bufferelemptr(ax_genss_currdata,offset));
            (*p8) = (u64)((((i64)((*d).offset) - offset) - (i64)1));
        } else {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(ax_objdecls_relocnames[((i64)((*f).reltype))],NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            ax_lib_gerror((byte*)"DOFWDREFS/CAN'T DO RELTYPE");
        };
        f = (*f).nextfwd;
L1217 :;
    }L1218 :;
    ;
}

static void ax_genss_genrex(void) {
    if (!!(ax_genss_sizeoverride)) {
        ax_genss_genbyte((i64)102);
    };
    if (!!(ax_genss_addroverride)) {
        ax_genss_genbyte((i64)103);
    };
    if (!!(ax_genss_rex)) {
        if ((ax_genss_rex < (i64)64)) {
            ax_genss_genbyte(((i64)64 + ax_genss_rex));
        } else {
            ax_genss_genbyte(ax_genss_rex);
        };
    };
}

static i64 ax_genss_isbytesized(i64 x) {
    return (((i64)-128 <= x) && (x <= (i64)127));
}

static i64 ax_genss_isdwordsized(i64 x) {
    return (((i64)-2147483648 <= x) && (x <= (i64)2147483647));
}

static void ax_genss_do_push(struct ax_decls_opndrec * a) {
    i64 code;
    i64 am;
    if (((i64)((*a).mode)==(i64)1)) {
        if (((i64)((u64)((*a).size)) != (i64)8)) {
            ax_lib_gerror((byte*)"pushreg not 64-bit");
        };
        code = (i64)(ax_tables_regcodes[((i64)((*a).reg))]);
        if ((code >= (i64)8)) {
            ax_genss_rex = (i64)1;
            code &= (i64)7;
        };
        ax_genss_genrex();
        ax_genss_genbyte(((i64)80 + code));
    }else if (((i64)((*a).mode)==(i64)2)) {
        if (!!((*a).labeldef)) {
            ax_genss_genbyte((i64)104);
            ax_genss_genopnd(a,(i64)4);
        } else if (!!(ax_genss_isbytesized((*a).value))) {
            ax_genss_genbyte((i64)106);
            ax_genss_genbyte((*a).value);
        } else if (!!(ax_genss_isdwordsized((*a).value))) {
            ax_genss_genbyte((i64)104);
            ax_genss_gendword((*a).value);
        } else {
            ax_lib_gerror((byte*)"push imm value too large");
        };
    }else if (((i64)((*a).mode)==(i64)3)) {
        if (((i64)((u64)((*a).size)) != (i64)8)) {
            ax_lib_gerror((byte*)"push not 64-bit");
        };
        am = ax_genss_genrm(a,(i64)6);
        ax_genss_genrex();
        ax_genss_genbyte((i64)255);
        ax_genss_genamode(a,am);
    } else {
        ax_lib_gerror((byte*)"push opnd?");
    };
}

static void ax_genss_do_pop(struct ax_decls_opndrec * a) {
    i64 code;
    i64 am;
    if (((i64)((*a).mode)==(i64)1)) {
        if (((i64)((u64)((*a).size)) != (i64)8)) {
            ax_lib_gerror((byte*)"popreg not 64-bit");
        };
        code = (i64)(ax_tables_regcodes[((i64)((*a).reg))]);
        if ((code >= (i64)8)) {
            ax_genss_rex = (i64)1;
            code &= (i64)7;
        };
        ax_genss_genrex();
        ax_genss_genbyte(((i64)88 + code));
    }else if (((i64)((*a).mode)==(i64)3)) {
        if (((i64)((u64)((*a).size)) != (i64)8)) {
            ax_lib_gerror((byte*)"pop not 64-bit");
        };
        am = ax_genss_genrm(a,(i64)0);
        ax_genss_genrex();
        ax_genss_genbyte((i64)143);
        ax_genss_genamode(a,am);
    } else {
        ax_lib_gerror((byte*)"pop opnd?");
    };
}

static void ax_genss_do_inc(struct ax_decls_opndrec * a,i64 code) {
    i64 opc;
    i64 am;
    opc = (((i64)((u64)((*a).size)) == (i64)1)?(i64)254:(i64)255);
    if (((i64)((*a).mode)==(i64)1) || ((i64)((*a).mode)==(i64)3)) {
        am = ax_genss_genrm(a,code);
        ax_genss_checkhighreg(a);
        ax_genss_setopsize(a);
        ax_genss_genrex();
        ax_genss_genbyte(opc);
        ax_genss_genamode(a,am);
    } else {
        ax_lib_gerror((byte*)"inc/opnd?");
    };
}

static void ax_genss_do_neg(struct ax_decls_opndrec * a,i64 code) {
    i64 opc;
    i64 am;
    opc = (((i64)((u64)((*a).size)) == (i64)1)?(i64)246:(i64)247);
    if (((i64)((*a).mode)==(i64)1) || ((i64)((*a).mode)==(i64)3)) {
        am = ax_genss_genrm(a,code);
        ax_genss_checkhighreg(a);
        ax_genss_setopsize(a);
        ax_genss_genrex();
        ax_genss_genbyte(opc);
        ax_genss_genamode(a,am);
    } else {
        ax_lib_gerror((byte*)"neg/div/etc opnd?");
    };
}

static void ax_genss_genamode(struct ax_decls_opndrec * a,i64 am) {
    i64 sib;
    i64 mode;
    i64 dispsize;
    sib = (am >> (i64)16);
    mode = ((am >> (i64)8) & (i64)255);
    dispsize = (am & (i64)255);
    ax_genss_genbyte(mode);
    if ((sib >= (i64)0)) {
        ax_genss_genbyte(sib);
    };
    if ((dispsize==(i64)0)) {
    }else if ((dispsize==(i64)1)) {
        ax_genss_genbyte((*a).value);
    }else if ((dispsize==(i64)4)) {
        if (!!((*a).labeldef)) {
            ax_genss_genabs32(a);
        } else {
            ax_genss_gendword((*a).value);
        };
    } else {
        ax_lib_gerror((byte*)"genamode size 2/8");
    };
}

static i64 ax_genss_makemodrm(i64 mode,i64 opc,i64 rm) {
    return (((mode << (i64)6) + (opc << (i64)3)) + rm);
}

static void ax_genss_setopsize(struct ax_decls_opndrec * a) {
    if (((i64)((*a).size)==(i64)1)) {
    }else if (((i64)((*a).size)==(i64)2)) {
        ax_genss_sizeoverride = (i64)1;
    }else if (((i64)((*a).size)==(i64)8)) {
        ax_genss_rex |= (i64)8;
    }else if (((i64)((*a).size)==(i64)4)) {
    } else {
        ax_lib_gerror((byte*)"Operand size not set");
    };
}

static void ax_genss_setaddrsize(struct ax_decls_opndrec * a) {
    if ((((i64)((u64)((*a).mode)) == (i64)3) && ((i64)((u64)((*a).addrsize)) == (i64)4))) {
        ax_genss_addroverride = (i64)1;
    };
}

static i64 ax_genss_getdispsize(struct ax_decls_opndrec * a,i64 mand) {
    if (!!((*a).labeldef)) {
        return (i64)4;
    };
    if ((!!((*a).value) || !!(mand))) {
        return (!!(ax_genss_isbytesized((*a).value))?(i64)1:(i64)4);
    } else {
        return (i64)0;
    };
}

static i64 ax_genss_genrm(struct ax_decls_opndrec * a,i64 opc) {
    static i64 scaletable[8] = {(i64)0,(i64)1,(i64)0,(i64)2,(i64)0,(i64)0,(i64)0,(i64)3};
    i64 mode;
    i64 rm;
    i64 scale;
    i64 dispsize;
    i64 needsib;
    i64 sib;
    i64 index;
    i64 base;
    i64 reg;
    i64 regix;
    i64 code;
    mode = (rm = (i64)0);
    scale = (i64)0;
    dispsize = (i64)0;
    needsib = (i64)0;
    sib = (i64)-1;
    if ((((i64)((u64)((*a).mode)) == (i64)3) && ((i64)((u64)((*a).addrsize)) == (i64)4))) {
        ax_genss_addroverride = (i64)1;
    };
    if (((i64)((*a).mode)==(i64)1)) {
        code = ax_genss_getregcodeb((i64)((*a).reg));
        return ax_genss_makeam(ax_genss_makemodrm((i64)3,opc,code),sib,dispsize);
    }else if (((i64)((*a).mode)==(i64)3)) {
    }else if (((i64)((*a).mode)==(i64)5)) {
        code = ax_genss_getregcodebx((i64)((*a).reg));
        return ax_genss_makeam(ax_genss_makemodrm((i64)3,opc,code),sib,dispsize);
    } else {
        ax_lib_gerror((byte*)"genrm not mem");
    };
    reg = (i64)((*a).reg);
    regix = (i64)((*a).regix);
    if (((reg == regix) && (regix == (i64)0))) {
        mode = (i64)0;
        rm = (i64)4;
        scale = (i64)1;
        index = (i64)4;
        base = (i64)5;
        dispsize = (i64)4;
    } else if ((((i64)((u64)((*a).scale)) <= (i64)1) && (regix == (i64)0))) {
        dispsize = ax_genss_getdispsize(a,(i64)0);
        if (!!(dispsize)) {
            mode = ((dispsize == (i64)1)?(i64)1:(i64)2);
        };
        rm = (i64)(ax_tables_regcodes[(reg)]);
        if (((rm != (i64)4) && (rm != (i64)12))) {
            base = rm;
            if ((((rm == (i64)5) || (rm == (i64)13)) && (dispsize == (i64)0))) {
                mode = (i64)1;
                dispsize = (i64)1;
            };
            index = (i64)0;
        } else {
            index = (i64)4;
            base = rm;
            scale = (i64)1;
        };
    } else if ((!!(regix) && (reg == (i64)0))) {
        dispsize = (i64)4;
        mode = (i64)0;
        rm = (i64)4;
        scale = (!!((u64)((*a).scale))?(i64)((*a).scale):(i64)1);
        base = (i64)5;
        index = (i64)(ax_tables_regcodes[(regix)]);
        if ((regix == (i64)16)) {
            ax_lib_gerror((byte*)"Scaled rstack?");
        };
    } else {
        dispsize = ax_genss_getdispsize(a,(i64)0);
        if (!!(dispsize)) {
            mode = ((dispsize == (i64)1)?(i64)1:(i64)2);
        };
        rm = (i64)4;
        scale = (!!((u64)((*a).scale))?(i64)((*a).scale):(i64)1);
        if ((reg == (i64)0)) {
            base = (i64)5;
        } else {
            if ((((reg == (i64)15) || (reg == (i64)8)) && (dispsize == (i64)0))) {
                mode = (i64)1;
                dispsize = (i64)1;
            };
            base = (i64)(ax_tables_regcodes[(reg)]);
        };
        if ((regix == (i64)0)) {
            index = (i64)4;
        } else {
            index = (i64)(ax_tables_regcodes[(regix)]);
        };
        if ((!!(regix) && !(!!(reg)))) {
            dispsize = (i64)4;
        };
        if (((regix == (i64)16) && (scale > (i64)1))) {
            ax_lib_gerror((byte*)"Can't scale rstack");
        };
    };
    if ((index >= (i64)8)) {
        ax_genss_rex |= (i64)2;
        index &= (i64)7;
    };
    if ((base >= (i64)8)) {
        ax_genss_rex |= (i64)1;
        base &= (i64)7;
    };
    if (!!(scale)) {
        sib = (((scaletable[(scale)-1] << (i64)6) + (index << (i64)3)) + base);
    };
    rm &= (i64)7;
    return ax_genss_makeam(ax_genss_makemodrm(mode,opc,rm),sib,dispsize);
}

static void ax_genss_genrmbyte(i64 mode,i64 opc,i64 rm) {
    ax_genss_genbyte((((mode << (i64)6) + (opc << (i64)3)) + rm));
}

static i64 ax_genss_makeam(i64 m,i64 s,i64 d) {
    return (((s << (i64)16) + (m << (i64)8)) + d);
}

static void ax_genss_do_arith(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b,i64 code) {
    i64 am;
    i64 regcode;
    i64 opc;
    i64 dispsize;
    i64 x;
    if (((i64)((*a).mode)==(i64)1)) {
        if (((i64)((*b).mode)==(i64)1) || ((i64)((*b).mode)==(i64)3)) {
            regcode = ax_genss_getregcoder((i64)((*a).reg));
            am = ax_genss_genrm(b,regcode);
            ax_genss_checkhighreg(a);
            ax_genss_checkhighreg(b);
            ax_genss_setopsize(a);
            opc = ((code << (i64)3) | (((i64)((u64)((*a).size)) == (i64)1)?(i64)2:(i64)3));
            ax_genss_genrex();
            ax_genss_genbyte(opc);
            ax_genss_genamode(b,am);
        }else if (((i64)((*b).mode)==(i64)2)) {
            //doregimm:
L1219 :;
;
            if (!!((*b).labeldef)) {
                if (((code < (i64)0) || (code > (i64)7))) {
                    ax_lib_gerror((byte*)"non-add arith/label");
                };
                if (((i64)((u64)((*a).size)) < (i64)4)) {
                    ax_lib_gerror((byte*)"add imm/size");
                };
                am = ax_genss_genrm(a,code);
                ax_genss_setopsize(a);
                ax_genss_genrex();
                ax_genss_genbyte((i64)129);
                ax_genss_genamode(a,am);
                ax_genss_genopnd(b,(i64)4);
                return;
            };
            x = (*b).value;
            dispsize = (i64)1;
            if (((i64)((u64)((*a).size)) == (i64)1)) {
                opc = (i64)128;
            } else if ((((i64)-128 <= x) && (x <= (i64)127))) {
                opc = (i64)131;
            } else {
                if (!((((i64)-2147483648 <= x) && (x <= (i64)4294967295)))) {
                    ax_lib_gerror((byte*)"3:exceeding word32 value");
                };
                opc = (i64)129;
                dispsize = (((i64)((u64)((*a).size)) == (i64)2)?(i64)2:(i64)4);
            };
            am = ax_genss_genrm(a,code);
            ax_genss_checkhighreg(a);
            ax_genss_setopsize(a);
            ax_genss_genrex();
            ax_genss_genbyte(opc);
            ax_genss_genamode(a,am);
            if ((dispsize==(i64)1)) {
                ax_genss_genbyte(x);
            }else if ((dispsize==(i64)2)) {
                ax_genss_genword(x);
            }else if ((dispsize==(i64)4)) {
                ax_genss_gendword(x);
            };
        } else {
            ax_lib_gerror((byte*)"ADD reg,???");
        };
    }else if (((i64)((*a).mode)==(i64)3)) {
        if (((i64)((*b).mode)==(i64)1)) {
            regcode = ax_genss_getregcoder((i64)((*b).reg));
            am = ax_genss_genrm(a,regcode);
            ax_genss_checkhighreg(b);
            ax_genss_setopsize(b);
            opc = ((code << (i64)3) | (((i64)((u64)((*b).size)) == (i64)1)?(i64)0:(i64)1));
            ax_genss_genrex();
            ax_genss_genbyte(opc);
            ax_genss_genamode(a,am);
        }else if (((i64)((*b).mode)==(i64)2)) {
            goto L1219 ;
;
        } else {
            ax_lib_gerror((byte*)"ADD mem,???");
        };
    } else {
        ax_lib_gerror((byte*)"Can't add to this opnd");
    };
}

static void ax_genss_do_mov(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b) {
    i64 regcode;
    i64 am;
    i64 value;
    if (((i64)((*a).mode)==(i64)1)) {
        if (((i64)((*b).mode)==(i64)1) || ((i64)((*b).mode)==(i64)3)) {
            if ((((u64)((*a).size) != (u64)((*b).size)) && !!((u64)((*b).size)))) {
                ax_lib_gerror((byte*)"Opnd size mismatch");
            };
            ax_genss_checkhighreg(a);
            ax_genss_checkhighreg(b);
            regcode = ax_genss_getregcoder((i64)((*a).reg));
            am = ax_genss_genrm(b,regcode);
            ax_genss_setopsize(a);
            ax_genss_genrex();
            ax_genss_genbyte((((i64)((u64)((*a).size)) == (i64)1)?(i64)138:(i64)139));
            ax_genss_genamode(b,am);
        }else if (((i64)((*b).mode)==(i64)2)) {
            value = (*b).value;
            regcode = ax_genss_getregcodeb((i64)((*a).reg));
            if ((!!((*b).labeldef) && ((i64)((u64)((*a).size)) <= (i64)2))) {
                ax_lib_gerror((byte*)"mov imm?");
            };
            if (((i64)((*a).size)==(i64)1)) {
                ax_genss_checkhighreg(a);
                if (((i64)((*a).reg)==(i64)6) || ((i64)((*a).reg)==(i64)4) || ((i64)((*a).reg)==(i64)15) || ((i64)((*a).reg)==(i64)16)) {
                    ax_genss_rex |= (i64)64;
                };
                if (!((((i64)-128 <= value) && (value <= (i64)255)))) {
                    ax_lib_gerror((byte*)"exceeding byte value");
                };
                ax_genss_genrex();
                ax_genss_genbyte(((i64)176 + regcode));
                ax_genss_genbyte(value);
            }else if (((i64)((*a).size)==(i64)2)) {
                if (!((((i64)-32768 <= value) && (value <= (i64)65535)))) {
                    ax_lib_gerror((byte*)"exceeding word16 value");
                };
                ax_genss_genbyte((i64)102);
                ax_genss_genrex();
                ax_genss_genbyte(((i64)184 + regcode));
                ax_genss_genword(value);
            }else if (((i64)((*a).size)==(i64)4)) {
                if (!!((*b).labeldef)) {
                    ax_genss_genrex();
                    ax_genss_genbyte(((i64)184 + regcode));
                    ax_genss_genopnd(b,(i64)4);
                } else {
                    if (!((((i64)-2147483648 <= value) && (value <= (i64)((u64)4294967295u))))) {
                        msysnewc_m_print_startcon();
                        msysnewc_m_print_i64(value,NULL);
                        msysnewc_m_print_ptr((void *)(value),NULL);
                        msysnewc_m_print_newline();
                        msysnewc_m_print_end();
                        ;
                        ax_lib_gerror((byte*)"1:exceeding word32 value");
                    };
                    //doreg32:
L1220 :;
;
                    ax_genss_genrex();
                    ax_genss_genbyte(((i64)184 + regcode));
                    ax_genss_gendword(value);
                };
            } else {
                if (!!((*b).labeldef)) {
                    ax_genss_rex |= (i64)8;
                    ax_genss_genrex();
                    ax_genss_genbyte(((i64)184 + regcode));
                    ax_genss_genopnd(b,(i64)8);
                } else {
                    if (((value >= (i64)0) && (value <= (i64)4294967295))) {
                        goto L1220 ;
;
                    };
                    ax_genss_rex |= (i64)8;
                    ax_genss_genrex();
                    ax_genss_genbyte(((i64)184 + regcode));
                    ax_genss_genqword(value);
                };
            };
        } else {
            ax_lib_gerror((byte*)"MOV REG/??");
        };
    }else if (((i64)((*a).mode)==(i64)3)) {
        if (((i64)((*b).mode)==(i64)1)) {
            if ((((u64)((*a).size) != (u64)((*b).size)) && !!((u64)((*a).size)))) {
                ax_lib_gerror((byte*)"Opnd size mismatch");
            };
            regcode = ax_genss_getregcoder((i64)((*b).reg));
            ax_genss_checkhighreg(b);
            am = ax_genss_genrm(a,regcode);
            ax_genss_setopsize(b);
            ax_genss_genrex();
            ax_genss_genbyte((((i64)((u64)((*b).size)) == (i64)1)?(i64)136:(i64)137));
            ax_genss_genamode(a,am);
        }else if (((i64)((*b).mode)==(i64)2)) {
            value = (*b).value;
            am = ax_genss_genrm(a,(i64)0);
            if ((!!((*b).labeldef) && ((i64)((u64)((*a).size)) <= (i64)2))) {
                ax_lib_gerror((byte*)"mov imm?");
            };
            if (((i64)((u64)((*a).size)) == (i64)0)) {
                (*a).size = (u64)((i64)1);
            };
            if (((i64)((*a).size)==(i64)0) || ((i64)((*a).size)==(i64)1)) {
                if (!((((i64)-128 <= value) && (value <= (i64)255)))) {
                    ax_lib_gerror((byte*)"exceeding byte value");
                };
                ax_genss_setopsize(a);
                ax_genss_genrex();
                ax_genss_genbyte((i64)198);
                ax_genss_genamode(a,am);
                ax_genss_genbyte(value);
            }else if (((i64)((*a).size)==(i64)2)) {
                if (!((((i64)-32768 <= value) && (value <= (i64)65535)))) {
                    ax_lib_gerror((byte*)"exceeding word16 value");
                };
                ax_genss_setopsize(a);
                ax_genss_genrex();
                ax_genss_genbyte((i64)199);
                ax_genss_genamode(a,am);
                ax_genss_genword(value);
            }else if (((i64)((*a).size)==(i64)4) || ((i64)((*a).size)==(i64)8)) {
                if (!(!!((*b).labeldef))) {
                    if (!((((i64)-2147483648 <= value) && (value <= (i64)4294967295)))) {
                        ax_lib_gerror((byte*)"2:exceeding word32 value");
                    };
                };
                ax_genss_setopsize(a);
                ax_genss_genrex();
                ax_genss_genbyte((i64)199);
                ax_genss_genamode(a,am);
                ax_genss_genopnd(b,(i64)4);
            };
        } else {
            ax_lib_gerror((byte*)"MOV MEM/?");
        };
    } else {
        ax_lib_gerror((byte*)"MOV ?/..");
    };
}

static i64 ax_genss_getregcoder(i64 reg) {
    i64 regcode;
    regcode = (i64)(ax_tables_regcodes[(reg)]);
    if ((regcode >= (i64)8)) {
        regcode -= (i64)8;
        ax_genss_rex |= (i64)4;
    };
    return regcode;
}

static i64 ax_genss_getregcodeb(i64 reg) {
    i64 regcode;
    regcode = (i64)(ax_tables_regcodes[(reg)]);
    if ((regcode >= (i64)8)) {
        regcode -= (i64)8;
        ax_genss_rex |= (i64)1;
    };
    return regcode;
}

static i64 ax_genss_getregcodebx(i64 reg) {
    i64 regcode;
    regcode = (reg - (i64)1);
    if ((regcode >= (i64)8)) {
        regcode -= (i64)8;
        ax_genss_rex |= (i64)1;
    };
    return regcode;
}

static i64 ax_genss_getregcoderx(i64 reg) {
    i64 regcode;
    regcode = (reg - (i64)1);
    if ((regcode >= (i64)8)) {
        regcode -= (i64)8;
        ax_genss_rex |= (i64)4;
    };
    return regcode;
}

static void ax_genss_do_lea(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b) {
    i64 regcode;
    i64 am;
    if (!((((i64)((u64)((*a).mode)) == (i64)1) && ((i64)((u64)((*b).mode)) == (i64)3)))) {
        ax_lib_gerror((byte*)"LEA not reg/mem");
    };
    if (((i64)((u64)((*a).size)) < (i64)4)) {
        ax_lib_gerror((byte*)"LEA size error");
    };
    regcode = ax_genss_getregcoder((i64)((*a).reg));
    am = ax_genss_genrm(b,regcode);
    ax_genss_setopsize(a);
    ax_genss_genrex();
    ax_genss_genbyte((i64)141);
    ax_genss_genamode(b,am);
}

static void ax_genss_do_movsx(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b,i64 opc) {
    i64 am;
    i64 regcode;
    if (((i64)((u64)((*a).mode)) != (i64)1)) {
        ax_lib_gerror((byte*)"movsx not reg");
    };
    if ((((i64)((u64)((*a).size)) == (i64)8) && ((i64)((u64)((*b).size)) == (i64)4))) {
        if ((opc == (i64)190)) {
            ax_genss_do_movsxd(a,b);
        } else {
            a = ax_lib_regtable[((i64)((*a).reg))-1][((i64)4)-1];
            ax_genss_do_mov(a,b);
        };
        return;
    };
    if ((((i64)((u64)((*a).size)) == (i64)1) || ((u64)((*a).size) <= (u64)((*b).size)))) {
        ax_lib_gerror((byte*)"movsx size error");
    };
    if (((opc == (i64)182) && ((i64)((u64)((*b).size)) == (i64)4))) {
        ax_lib_gerror((byte*)"movsx 4=>8 bytes?");
    };
    if (((i64)((*b).mode)==(i64)1)) {
    }else if (((i64)((*b).mode)==(i64)3)) {
        if (((i64)((u64)((*b).size)) == (i64)0)) {
            ax_lib_gerror((byte*)"movsx need size prefix");
        };
        if (((i64)((u64)((*b).size)) == (i64)8)) {
            ax_lib_gerror((byte*)"movsx size 8");
        };
    } else {
        ax_lib_gerror((byte*)"movsx not reg/mem");
    };
    regcode = ax_genss_getregcoder((i64)((*a).reg));
    am = ax_genss_genrm(b,regcode);
    ax_genss_setopsize(a);
    ax_genss_checkhighreg(b);
    ax_genss_genrex();
    ax_genss_genbyte((i64)15);
    ax_genss_genbyte((((i64)((u64)((*b).size)) == (i64)1)?opc:(opc + (i64)1)));
    ax_genss_genamode(b,am);
}

static void ax_genss_checkhighreg(struct ax_decls_opndrec * a) {
    if (((i64)((u64)((*a).mode)) == (i64)1)) {
        if (((i64)((*a).reg)==(i64)6) || ((i64)((*a).reg)==(i64)4) || ((i64)((*a).reg)==(i64)15) || ((i64)((*a).reg)==(i64)16)) {
            ax_genss_rex |= (i64)64;
        };
    };
}

static void ax_genss_do_exch(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b) {
    i64 regcode;
    i64 am;
    if ((((((i64)((u64)((*a).mode)) == (i64)1) && ((i64)((u64)((*b).mode)) == (i64)1)) && (((i64)((u64)((*a).reg)) == (i64)1) || ((i64)((u64)((*b).reg)) == (i64)1))) && ((i64)((u64)((*a).size)) != (i64)1))) {
        if (((i64)((u64)((*a).reg)) != (i64)1)) {
            {struct ax_decls_opndrec *  temp = a; a = b; b = temp; };
        };
        if (((u64)((*a).size) != (u64)((*b).size))) {
            ax_lib_gerror((byte*)"exch size");
        };
        ax_genss_setopsize(a);
        regcode = ax_genss_getregcodeb((i64)((*b).reg));
        ax_genss_genrex();
        ax_genss_genbyte(((i64)144 + regcode));
        return;
    };
    if (((i64)((u64)((*a).mode)) == (i64)3)) {
        {struct ax_decls_opndrec *  temp = a; a = b; b = temp; };
    };
    if (!((((i64)((u64)((*a).mode)) == (i64)1) && (((i64)((u64)((*b).mode)) == (i64)1) || ((i64)((u64)((*b).mode)) == (i64)3))))) {
        ax_lib_gerror((byte*)"exch opnds");
    };
    if ((((i64)((u64)((*b).size)) == (i64)0) && ((i64)((u64)((*b).mode)) == (i64)3))) {
        (*b).size = (u64)((*a).size);
    };
    if (((u64)((*a).size) != (u64)((*b).size))) {
        ax_lib_gerror((byte*)"exch size");
    };
    if (((i64)((u64)((*a).size)) == (i64)1)) {
        ax_genss_checkhighreg(a);
        ax_genss_checkhighreg(b);
    };
    regcode = ax_genss_getregcoder((i64)((*a).reg));
    am = ax_genss_genrm(b,regcode);
    ax_genss_setopsize(a);
    ax_genss_genrex();
    ax_genss_genbyte((((i64)((u64)((*a).size)) == (i64)1)?(i64)134:(i64)135));
    ax_genss_genamode(b,am);
}

static void ax_genss_do_movsxd(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b) {
    i64 regcode;
    i64 am;
    if ((((i64)((u64)((*b).mode)) == (i64)3) && ((i64)((u64)((*b).size)) == (i64)0))) {
        (*b).size = (u64)((i64)4);
    };
    if ((((i64)((u64)((*a).size)) != (i64)8) || ((i64)((u64)((*b).size)) > (i64)4))) {
        ax_lib_gerror((byte*)"movsxd size");
    };
    if ((((i64)((u64)((*a).mode)) != (i64)1) || (((i64)((u64)((*b).mode)) != (i64)1) && ((i64)((u64)((*b).mode)) != (i64)3)))) {
        ax_lib_gerror((byte*)"movsxd opnds");
    };
    regcode = ax_genss_getregcoder((i64)((*a).reg));
    am = ax_genss_genrm(b,regcode);
    ax_genss_setopsize(a);
    ax_genss_genrex();
    ax_genss_genbyte((i64)99);
    ax_genss_genamode(b,am);
}

static void ax_genss_do_imul2(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b) {
    i64 regcode;
    i64 am;
    i64 opc;
    i64 value;
    if (((i64)((u64)((*a).mode)) != (i64)1)) {
        ax_lib_gerror((byte*)"imul2 opnds");
    };
    if (((i64)((u64)((*b).size)) == (i64)0)) {
        (*b).size = (u64)((*a).size);
    };
    if (((i64)((u64)((*a).size)) == (i64)1)) {
        ax_lib_gerror((byte*)"imul2 byte");
    };
    if (((i64)((*b).mode)==(i64)1) || ((i64)((*b).mode)==(i64)3)) {
        if (((u64)((*a).size) != (u64)((*b).size))) {
            ax_lib_gerror((byte*)"imul2 size");
        };
        regcode = ax_genss_getregcoder((i64)((*a).reg));
        am = ax_genss_genrm(b,regcode);
        ax_genss_setopsize(a);
        ax_genss_genrex();
        ax_genss_genbyte((i64)15);
        ax_genss_genbyte((i64)175);
        ax_genss_genamode(b,am);
    }else if (((i64)((*b).mode)==(i64)2)) {
        if (!!((*b).labeldef)) {
            ax_lib_gerror((byte*)"mul/label");
        };
        value = (*b).value;
        regcode = ax_genss_getregcoder((i64)((*a).reg));
        regcode = ax_genss_getregcodeb((i64)((*a).reg));
        opc = (((i64)192 + (regcode << (i64)3)) + regcode);
        ax_genss_setopsize(a);
        ax_genss_genrex();
        if ((((i64)-128 <= value) && (value <= (i64)127))) {
            ax_genss_genbyte((i64)107);
            ax_genss_genbyte(opc);
            ax_genss_genbyte(value);
        } else if (((i64)((u64)((*a).size)) == (i64)2)) {
            ax_genss_genbyte((i64)105);
            ax_genss_genbyte(opc);
            ax_genss_genword(value);
        } else {
            ax_genss_genbyte((i64)105);
            ax_genss_genbyte(opc);
            ax_genss_gendword(value);
        };
    } else {
        ax_lib_gerror((byte*)"imul2 opnds");
    };
}

static void ax_genss_do_imul3(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b,struct ax_decls_opndrec * c) {
    i64 value;
    i64 regcode1;
    i64 regcode2;
    i64 opc;
    if ((((i64)((u64)((*a).mode)) != (i64)1) || ((i64)((u64)((*b).mode)) != (i64)1))) {
        ax_lib_gerror((byte*)"imul3 opnds");
    };
    if (((i64)((u64)((*a).size)) == (i64)1)) {
        ax_lib_gerror((byte*)"imul3 byte");
    };
    if (((i64)((u64)((*c).mode)) != (i64)2)) {
        ax_lib_gerror((byte*)"imul3 not imm");
    };
    value = (*c).value;
    regcode1 = ax_genss_getregcoder((i64)((*a).reg));
    regcode2 = ax_genss_getregcodeb((i64)((*b).reg));
    opc = (((i64)192 + (regcode1 << (i64)3)) + regcode2);
    ax_genss_setopsize(a);
    ax_genss_genrex();
    if ((((i64)-128 <= value) && (value <= (i64)127))) {
        ax_genss_genbyte((i64)107);
        ax_genss_genbyte(opc);
        ax_genss_genbyte(value);
    } else if (((i64)((u64)((*a).size)) == (i64)2)) {
        ax_genss_genbyte((i64)105);
        ax_genss_genbyte(opc);
        ax_genss_genword(value);
    } else {
        ax_genss_genbyte((i64)105);
        ax_genss_genbyte(opc);
        ax_genss_gendword(value);
    };
}

static void ax_genss_do_shift(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b,i64 opc) {
    i64 am;
    i64 w;
    if ((((i64)((u64)((*a).mode)) != (i64)1) && ((i64)((u64)((*a).mode)) != (i64)3))) {
        ax_lib_gerror((byte*)"shift opnds1?");
    };
    am = ax_genss_genrm(a,opc);
    ax_genss_checkhighreg(a);
    ax_genss_setopsize(a);
    ax_genss_genrex();
    w = (((i64)((u64)((*a).size)) == (i64)1)?(i64)0:(i64)1);
    if (((i64)((*b).mode)==(i64)2)) {
        if (!!((*b).labeldef)) {
            ax_lib_gerror((byte*)"shift/label");
        };
        if (((*b).value == (i64)1)) {
            ax_genss_genbyte(((i64)208 + w));
            ax_genss_genamode(a,am);
        } else {
            ax_genss_genbyte(((i64)192 + w));
            ax_genss_genamode(a,am);
            ax_genss_genbyte((*b).value);
        };
    }else if (((i64)((*b).mode)==(i64)1)) {
        if ((((i64)((u64)((*b).reg)) != (i64)11) || ((i64)((u64)((*b).size)) != (i64)1))) {
            ax_lib_gerror((byte*)"cl or b10 needed");
        };
        ax_genss_genbyte(((i64)210 + w));
        ax_genss_genamode(a,am);
    } else {
        ax_lib_gerror((byte*)"shift opnds2?");
    };
}

static void ax_genss_do_test(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b) {
    i64 value;
    i64 opc;
    i64 am;
    i64 regcode;
    if (((((i64)((u64)((*a).mode)) == (i64)1) && ((i64)((u64)((*a).reg)) == (i64)1)) && ((i64)((u64)((*b).mode)) == (i64)2))) {
        value = (*b).value;
        if (((i64)((*a).size)==(i64)1)) {
            ax_genss_genbyte((i64)168);
            ax_genss_genbyte(value);
        }else if (((i64)((*a).size)==(i64)2)) {
            ax_genss_genbyte((i64)102);
            ax_genss_genbyte((i64)169);
            ax_genss_genword(value);
        }else if (((i64)((*a).size)==(i64)4)) {
            ax_genss_genbyte((i64)169);
            ax_genss_gendword(value);
        } else {
            ax_genss_genbyte((i64)72);
            ax_genss_genbyte((i64)169);
            ax_genss_gendword(value);
        };
    } else if (((((i64)((u64)((*a).mode)) == (i64)1) || ((i64)((u64)((*a).mode)) == (i64)3)) && ((i64)((u64)((*b).mode)) == (i64)2))) {
        opc = (((i64)((u64)((*a).size)) == (i64)1)?(i64)246:(i64)247);
        value = (*b).value;
        am = ax_genss_genrm(a,(i64)0);
        ax_genss_checkhighreg(a);
        ax_genss_setopsize(a);
        ax_genss_genrex();
        ax_genss_genbyte(opc);
        ax_genss_genamode(a,am);
        if (((i64)((*a).size)==(i64)1)) {
            ax_genss_genbyte(value);
        }else if (((i64)((*a).size)==(i64)2)) {
            ax_genss_genword(value);
        } else {
            ax_genss_gendword(value);
        };
    } else if ((((i64)((u64)((*a).mode)) == (i64)1) && (((i64)((u64)((*b).mode)) == (i64)1) || ((i64)((u64)((*b).mode)) == (i64)3)))) {
        //doregmem:
L1221 :;
;
        regcode = ax_genss_getregcoder((i64)((*a).reg));
        am = ax_genss_genrm(b,regcode);
        ax_genss_checkhighreg(a);
        ax_genss_checkhighreg(b);
        ax_genss_setopsize(a);
        ax_genss_genrex();
        ax_genss_genbyte((((i64)((u64)((*a).size)) == (i64)1)?(i64)132:(i64)133));
        ax_genss_genamode(b,am);
    } else if ((((i64)((u64)((*a).mode)) == (i64)3) && ((i64)((u64)((*b).mode)) == (i64)1))) {
        {struct ax_decls_opndrec *  temp = a; a = b; b = temp; };
        goto L1221 ;
;
    } else {
        ax_lib_gerror((byte*)"test opnds");
    };
}

static void ax_genss_do_loop(struct ax_decls_opndrec * a,i64 opc) {
    i64 offset;
    offset = ax_genss_getrel32((*a).labeldef,(ax_genss_getcurrdatalen((i64)9) + (i64)1));
    if ((offset < (i64)0)) {
        if ((offset < (i64)-126)) {
            ax_lib_gerror((byte*)"loop jmp out of range");
        };
        ax_genss_genbyte(opc);
        ax_genss_genbyte(offset);
    } else {
        ax_lib_gerror((byte*)"Can't do loopxx fwd jump");
    };
}

static void ax_genss_do_jcxz(struct ax_decls_opndrec * a,i64 opsize) {
    i64 offset;
    offset = ax_genss_getrel32((*a).labeldef,(ax_genss_getcurrdatalen((i64)10) + (i64)1));
    if ((offset < (i64)0)) {
        if ((offset < (i64)-126)) {
            ax_lib_gerror((byte*)"jcxz jmp out of range");
        };
        if ((opsize == (i64)4)) {
            ax_genss_genbyte((i64)103);
        };
        ax_genss_genbyte((i64)227);
        ax_genss_genbyte(offset);
    } else {
        ax_lib_gerror((byte*)"Can't do jcxz fwd jump");
    };
}

static void ax_genss_do_setcc(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b) {
    i64 am;
    if (((((i64)((u64)((*b).mode)) != (i64)1) && ((i64)((u64)((*b).reg)) != (i64)3)) || ((i64)((u64)((*b).size)) > (i64)1))) {
        ax_lib_gerror((byte*)"setcc opnd/size");
    };
    am = ax_genss_genrm(b,(i64)0);
    ax_genss_checkhighreg(b);
    ax_genss_genrex();
    ax_genss_genbyte((i64)15);
    ax_genss_genbyte(((i64)144 + (*a).value));
    ax_genss_genamode(b,am);
}

static void ax_genss_do_movxmm(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b,i64 size) {
    i64 am;
    i64 regcode;
    i64 regcode1;
    i64 regcode2;
    if (((i64)((*a).mode)==(i64)1)) {
        if (((i64)((*b).mode)==(i64)5)) {
            if (((i64)((u64)((*a).size)) != size)) {
                ax_lib_gerror((byte*)"1:movdq size");
            };
            regcode = ax_genss_getregcoderx((i64)((*b).reg));
            am = ax_genss_genrm(a,regcode);
            ax_genss_setopsize(a);
            ax_genss_genbyte((i64)102);
            ax_genss_genrex();
            ax_genss_genbyte((i64)15);
            ax_genss_genbyte((i64)126);
            ax_genss_genamode(b,am);
        } else {
            ax_lib_gerror((byte*)"movdq reg,?");
        };
    }else if (((i64)((*a).mode)==(i64)5)) {
        if (((i64)((*b).mode)==(i64)1)) {
            if (((i64)((u64)((*b).size)) != size)) {
                ax_lib_gerror((byte*)"3:movdq size");
            };
            regcode = ax_genss_getregcoderx((i64)((*a).reg));
            am = ax_genss_genrm(b,regcode);
            ax_genss_setopsize(b);
            ax_genss_genbyte((i64)102);
            ax_genss_genrex();
            ax_genss_genbyte((i64)15);
            ax_genss_genbyte((i64)110);
            ax_genss_genamode(a,am);
        }else if (((i64)((*b).mode)==(i64)5)) {
            regcode1 = ax_genss_getregcoderx((i64)((*a).reg));
            regcode2 = ax_genss_getregcodebx((i64)((*b).reg));
            ax_genss_genbyte((i64)243);
            ax_genss_genrex();
            ax_genss_genbyte((i64)15);
            ax_genss_genbyte((i64)126);
            ax_genss_genbyte((((i64)192 + (regcode1 << (i64)3)) + regcode2));
        }else if (((i64)((*b).mode)==(i64)3)) {
            if ((!!((u64)((*b).size)) && ((i64)((u64)((*b).size)) != size))) {
                ax_lib_gerror((byte*)"4:movdq size");
            };
            regcode = ax_genss_getregcoderx((i64)((*a).reg));
            am = ax_genss_genrm(b,regcode);
            if ((size == (i64)4)) {
                ax_genss_genbyte((i64)102);
                ax_genss_genrex();
                ax_genss_genbyte((i64)15);
                ax_genss_genbyte((i64)110);
            } else {
                ax_genss_genbyte((i64)243);
                ax_genss_genrex();
                ax_genss_genbyte((i64)15);
                ax_genss_genbyte((i64)126);
            };
            ax_genss_genamode(b,am);
        } else {
            ax_lib_gerror((byte*)"movdq xreg,?");
        };
    }else if (((i64)((*a).mode)==(i64)3)) {
        if (((i64)((*b).mode)==(i64)5)) {
            if ((!!((u64)((*a).size)) && ((i64)((u64)((*a).size)) != size))) {
                ax_lib_gerror((byte*)"5:movdq size");
            };
            regcode = ax_genss_getregcoderx((i64)((*b).reg));
            am = ax_genss_genrm(a,regcode);
            if ((size == (i64)4)) {
                ax_genss_genbyte((i64)102);
                ax_genss_genrex();
                ax_genss_genbyte((i64)15);
                ax_genss_genbyte((i64)126);
            } else {
                ax_genss_genbyte((i64)102);
                ax_genss_genrex();
                ax_genss_genbyte((i64)15);
                ax_genss_genbyte((i64)214);
            };
            ax_genss_genamode(a,am);
        } else {
            ax_lib_gerror((byte*)"movdq mem,?");
        };
    } else {
        ax_lib_gerror((byte*)"movdq opnds");
    };
}

static void ax_genss_do_arithxmm(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b,i64 prefix,i64 opc) {
    i64 am;
    i64 regcode;
    if ((((i64)((u64)((*a).mode)) != (i64)5) || (((i64)((u64)((*b).mode)) != (i64)5) && ((i64)((u64)((*b).mode)) != (i64)3)))) {
        ax_lib_gerror((byte*)"arithxmm opnds");
    };
    if (((i64)((u64)((*b).mode)) == (i64)5)) {
        regcode = ax_genss_getregcoderx((i64)((*a).reg));
        am = ax_genss_genrm(b,regcode);
        if (!!(prefix)) {
            ax_genss_genbyte(prefix);
        };
        ax_genss_genrex();
        ax_genss_genbyte((i64)15);
        ax_genss_genbyte(opc);
        ax_genss_genamode(a,am);
    } else {
        regcode = ax_genss_getregcoderx((i64)((*a).reg));
        am = ax_genss_genrm(b,regcode);
        if (!!(prefix)) {
            ax_genss_genbyte(prefix);
        };
        ax_genss_genrex();
        ax_genss_genbyte((i64)15);
        ax_genss_genbyte(opc);
        ax_genss_genamode(b,am);
    };
}

static void ax_genss_do_logicxmm(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b,i64 opc,i64 size) {
    i64 am;
    i64 regcode;
    if ((((i64)((u64)((*a).mode)) != (i64)5) || (((i64)((u64)((*b).mode)) != (i64)5) && ((i64)((u64)((*b).mode)) != (i64)3)))) {
        ax_lib_gerror((byte*)"logicxmm opnds");
    };
    if ((size == (i64)8)) {
        ax_genss_genbyte((i64)102);
    };
    if (((i64)((u64)((*b).mode)) == (i64)5)) {
        regcode = ax_genss_getregcoderx((i64)((*a).reg));
        am = ax_genss_genrm(b,regcode);
        ax_genss_genrex();
        ax_genss_genbyte((i64)15);
        ax_genss_genbyte(opc);
        ax_genss_genamode(b,am);
    } else {
        regcode = ax_genss_getregcoderx((i64)((*a).reg));
        am = ax_genss_genrm(b,regcode);
        ax_genss_genrex();
        ax_genss_genbyte((i64)15);
        ax_genss_genbyte(opc);
        ax_genss_genamode(b,am);
    };
}

static void ax_genss_do_convertfloat(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b,i64 prefix) {
    i64 am;
    i64 regcode;
    if ((((i64)((u64)((*a).mode)) != (i64)5) || (((i64)((u64)((*b).mode)) != (i64)5) && ((i64)((u64)((*b).mode)) != (i64)3)))) {
        ax_lib_gerror((byte*)"convertfloat opnds");
    };
    ax_genss_genbyte(prefix);
    if (((i64)((u64)((*a).mode)) == (i64)5)) {
        regcode = ax_genss_getregcoderx((i64)((*a).reg));
        am = ax_genss_genrm(b,regcode);
        ax_genss_genrex();
        ax_genss_genbyte((i64)15);
        ax_genss_genbyte((i64)90);
        ax_genss_genamode(b,am);
    } else {
        regcode = ax_genss_getregcoderx((i64)((*b).reg));
        am = ax_genss_genrm(a,regcode);
        ax_genss_genrex();
        ax_genss_genbyte((i64)15);
        ax_genss_genbyte((i64)90);
        ax_genss_genamode(b,am);
    };
}

static void ax_genss_do_fix(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b,i64 prefix,i64 opc) {
    i64 am;
    i64 regcode;
    if ((((i64)((u64)((*a).mode)) != (i64)1) || (((i64)((u64)((*b).mode)) != (i64)5) && ((i64)((u64)((*b).mode)) != (i64)3)))) {
        ax_lib_gerror((byte*)"fix opnds");
    };
    ax_genss_genbyte(prefix);
    if (((i64)((u64)((*b).mode)) == (i64)5)) {
        regcode = ax_genss_getregcoder((i64)((*a).reg));
        am = ax_genss_genrm(b,regcode);
        ax_genss_setopsize(a);
    } else {
        regcode = ax_genss_getregcoder((i64)((*a).reg));
        am = ax_genss_genrm(b,regcode);
        ax_genss_setopsize(a);
    };
    ax_genss_genrex();
    ax_genss_genbyte((i64)15);
    ax_genss_genbyte(opc);
    ax_genss_genamode(b,am);
}

static void ax_genss_do_float(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b,i64 prefix) {
    i64 am;
    i64 regcode;
    if ((((i64)((u64)((*a).mode)) != (i64)5) || (((i64)((u64)((*b).mode)) != (i64)1) && ((i64)((u64)((*b).mode)) != (i64)3)))) {
        ax_lib_gerror((byte*)"float opnds");
    };
    if (((i64)((u64)((*b).mode)) == (i64)3)) {
        if (((i64)((u64)((*b).size)) == (i64)0)) {
            (*b).size = (u64)((i64)4);
        };
        if ((((i64)((u64)((*b).size)) != (i64)4) && ((i64)((u64)((*b).size)) != (i64)8))) {
            ax_lib_gerror((byte*)"float size");
        };
    };
    ax_genss_genbyte(prefix);
    regcode = ax_genss_getregcoderx((i64)((*a).reg));
    am = ax_genss_genrm(b,regcode);
    ax_genss_setopsize(b);
    ax_genss_genrex();
    ax_genss_genbyte((i64)15);
    ax_genss_genbyte((i64)42);
    ax_genss_genamode(b,am);
}

static void ax_genss_do_call(struct ax_decls_opndrec * a) {
    i64 am;
    if (((i64)((*a).mode)==(i64)2)) {
        ax_genss_genbyte((i64)232);
        ax_genss_genrel32(a);
    } else {
        if (((i64)((*a).size)==(i64)0)) {
            (*a).size = (u64)((i64)8);
        }else if (((i64)((*a).size)==(i64)1) || ((i64)((*a).size)==(i64)2) || ((i64)((*a).size)==(i64)4)) {
            ax_lib_gerror((byte*)"call[]size");
        };
        am = ax_genss_genrm(a,(i64)2);
        ax_genss_setopsize(a);
        ax_genss_setaddrsize(a);
        ax_genss_genrex();
        ax_genss_genbyte((i64)255);
        ax_genss_genamode(a,am);
    };
}

static void ax_genss_do_jmp(struct ax_decls_opndrec * a,struct ax_lib_mclrec * m) {
    i64 am;
    i64 offset;
    i64 shortjmp;
    if (((i64)((*a).mode)==(i64)2)) {
        offset = ax_genss_getrel32((*a).labeldef,(ax_genss_getcurrdatalen((i64)11) + (i64)1));
        if (((offset < (i64)0) && (offset > (i64)-126))) {
            ax_genss_genbyte((i64)235);
            ax_genss_genbyte(offset);
        } else {
            shortjmp = (i64)0;
            if ((offset > (i64)0)) {
                shortjmp = ax_genss_checkshortjump(m,(*a).labeldef);
            };
            if (!(!!(shortjmp))) {
                ax_genss_genbyte((i64)233);
                ax_genss_genrel32(a);
            } else {
                ax_genss_genbyte((i64)235);
                ax_genss_genrel8(a);
            };
        };
    } else {
        if (((i64)((*a).size)==(i64)0)) {
            (*a).size = (u64)((i64)8);
        }else if (((i64)((*a).size)==(i64)1) || ((i64)((*a).size)==(i64)2) || ((i64)((*a).size)==(i64)4)) {
            ax_lib_gerror((byte*)"jmp[]size");
        };
        am = ax_genss_genrm(a,(i64)4);
        ax_genss_setopsize(a);
        ax_genss_setaddrsize(a);
        ax_genss_genrex();
        ax_genss_genbyte((i64)255);
        ax_genss_genamode(a,am);
    };
}

static i64 ax_genss_getcurrdatalen(i64 id) {
    if ((ax_genss_currseg == (i64)3)) {
        return ax_decls_ss_zdatalen;
    };
    return ax_lib_bufferlength(ax_genss_currdata);
}

static void ax_genss_do_cmovcc(struct ax_decls_opndrec * c,struct ax_decls_opndrec * a,struct ax_decls_opndrec * b) {
    i64 am;
    i64 regcode;
    if ((((u64)((*a).size) != (u64)((*b).size)) && !!((u64)((*b).size)))) {
        ax_lib_gerror((byte*)"Opnd size mismatch");
    };
    if (((i64)((u64)((*a).size)) == (i64)1)) {
        ax_lib_gerror((byte*)"cmov/byte");
    };
    regcode = ax_genss_getregcoder((i64)((*a).reg));
    am = ax_genss_genrm(b,regcode);
    ax_genss_setopsize(a);
    ax_genss_genrex();
    ax_genss_genbyte((i64)15);
    ax_genss_genbyte(((i64)64 + (*c).value));
    ax_genss_genamode(b,am);
}

static void ax_genss_do_fmem(struct ax_decls_opndrec * a,i64 freal,i64 code) {
    i64 am;
    i64 mf;
    if (((i64)((u64)((*a).mode)) != (i64)3)) {
        ax_lib_gerror((byte*)"fmem/not mem");
    };
    if (!!(freal)) {
        if (((i64)((*a).size)==(i64)4)) {
            mf = (i64)0;
        }else if (((i64)((*a).size)==(i64)8)) {
            mf = (i64)2;
        }else if (((i64)((*a).size)==(i64)16)) {
            mf = (i64)1;
            if ((code==(i64)0)) {
                code = (i64)5;
            }else if ((code==(i64)3)) {
                code = (i64)7;
            } else {
                ax_lib_gerror((byte*)"r80 not allowed");
            };
        } else {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((byte*)"SIZE=",NULL);
            msysnewc_m_print_u64((*a).size,NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            ax_lib_gerror((byte*)"fmem size");
        };
    } else {
        if (((i64)((*a).size)==(i64)2)) {
            mf = (i64)3;
        }else if (((i64)((*a).size)==(i64)4)) {
            mf = (i64)1;
        }else if (((i64)((*a).size)==(i64)8)) {
            mf = (i64)3;
            if ((code==(i64)0)) {
                code = (i64)5;
            }else if ((code==(i64)3)) {
                code = (i64)7;
            } else {
                ax_lib_gerror((byte*)"fst i64?");
            };
        } else {
            ax_lib_gerror((byte*)"fmem int size");
        };
    };
    am = ax_genss_genrm(a,code);
    ax_genss_genrex();
    ax_genss_genbyte(((i64)217 + (mf << (i64)1)));
    ax_genss_genamode(a,am);
}

static i64 ax_genss_getr32bits(double x) {
    float sx;
    sx = (float)(x);
    return (i64)(*(i32*)&sx);
}

static void ax_genss_genrel8(struct ax_decls_opndrec * a) {
    struct ax_decls_strec *  d;
    d = (*a).labeldef;
    if (((i64)((u64)((*d).reftype)) == (i64)1)) {
        (*d).fwdrefs = ax_genss_addfwdref((*d).fwdrefs,ax_genss_getcurrdatalen((i64)3),(i64)6,(i64)0);
        ax_genss_genbyte((i64)0);
    } else {
        ax_lib_gerror((byte*)"genrel8");
    };
}

static i64 ax_genss_checkshortjump(struct ax_lib_mclrec * m,struct ax_decls_strec * d) {
    i64 n;
    n = (i64)0;
    m = (*m).nextmcl;
    L1222 :;
    while ((!!(m) && (n <= (i64)8))) {
        ++n;
        if ((((i64)((u64)((*m).opcode)) == (i64)4) && ((*(*m).a).labeldef == d))) {
            return (i64)1;
        };
        m = (*m).nextmcl;
L1223 :;
    }L1224 :;
    ;
    return (i64)0;
}

static struct ax_decls_fwdrec * ax_genss_addfwdref(struct ax_decls_fwdrec * p,i64 offset,i64 reltype,i64 seg) {
    struct ax_decls_fwdrec *  q;
    q = (struct ax_decls_fwdrec *)(mlib_pcm_alloc((i64)16));
    (*q).nextfwd = p;
    (*q).offset = offset;
    (*q).reltype = reltype;
    (*q).seg = seg;
    return q;
}

static void ax_genss_switchseg(i64 newseg) {
    if ((newseg == ax_genss_currseg)) {
        return;
    };
    if ((ax_genss_currseg==(i64)1)) {
        ax_decls_ss_coderelocs = ax_genss_currrelocs;
        ax_decls_ss_ncoderelocs = ax_genss_nrelocs;
    }else if ((ax_genss_currseg==(i64)2)) {
        ax_decls_ss_idatarelocs = ax_genss_currrelocs;
        ax_decls_ss_nidatarelocs = ax_genss_nrelocs;
    };
    ax_genss_currseg = newseg;
    if ((ax_genss_currseg==(i64)1)) {
        ax_genss_currdata = ax_decls_ss_code;
        ax_genss_currrelocs = ax_decls_ss_coderelocs;
        ax_genss_nrelocs = ax_decls_ss_ncoderelocs;
    }else if ((ax_genss_currseg==(i64)2)) {
        ax_genss_currdata = ax_decls_ss_idata;
        ax_genss_currrelocs = ax_decls_ss_idatarelocs;
        ax_genss_nrelocs = ax_decls_ss_nidatarelocs;
    }else if ((ax_genss_currseg==(i64)3)) {
        ax_genss_currdata = ax_decls_ss_zdata;
    };
}

static void ax_genss_do_movdqx(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b,i64 opc) {
    i64 am;
    i64 regcode;
    if (((i64)((*a).mode)==(i64)5)) {
        if (((i64)((*b).mode)==(i64)5)) {
            regcode = ax_genss_getregcodebx((i64)((*b).reg));
            am = ax_genss_genrm(a,regcode);
            ax_genss_genbyte(opc);
            ax_genss_genrex();
            ax_genss_genbyte((i64)15);
            ax_genss_genbyte((i64)111);
            ax_genss_genamode(a,am);
        }else if (((i64)((*b).mode)==(i64)3)) {
            regcode = ax_genss_getregcoderx((i64)((*a).reg));
            am = ax_genss_genrm(b,regcode);
            ax_genss_genbyte(opc);
            ax_genss_genrex();
            ax_genss_genbyte((i64)15);
            ax_genss_genbyte((i64)111);
            ax_genss_genamode(b,am);
        } else {
            ax_lib_gerror((byte*)"movdqx?");
        };
    }else if (((i64)((*a).mode)==(i64)3)) {
        if (((i64)((*b).mode)==(i64)5)) {
            regcode = ax_genss_getregcoderx((i64)((*b).reg));
            am = ax_genss_genrm(a,regcode);
            ax_genss_genbyte(opc);
            ax_genss_genrex();
            ax_genss_genbyte((i64)15);
            ax_genss_genbyte((i64)127);
            ax_genss_genamode(a,am);
        } else {
            ax_lib_gerror((byte*)"movdqx");
        };
    } else {
        ax_lib_gerror((byte*)"movdqx");
    };
}

static void ax_genss_do_popcnt(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b) {
    i64 am;
    i64 regcode;
    if (((i64)((u64)((*b).mode)) == (i64)3)) {
        if (((i64)((u64)((*b).size)) == (i64)0)) {
            (*b).size = (u64)((i64)8);
        };
    };
    ax_genss_genbyte((i64)243);
    regcode = ax_genss_getregcodebx((i64)((*a).reg));
    am = ax_genss_genrm(b,regcode);
    ax_genss_setopsize(a);
    ax_genss_genrex();
    ax_genss_genbyte((i64)15);
    ax_genss_genbyte((i64)184);
    ax_genss_genamode(b,am);
}

static void ax_genss_do_bsf(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b,i64 opc) {
    i64 am;
    i64 regcode;
    if (((i64)((u64)((*b).mode)) == (i64)3)) {
        if (((i64)((u64)((*b).size)) == (i64)0)) {
            (*b).size = (u64)((i64)8);
        };
    };
    if (((u64)((*a).size) != (u64)((*b).size))) {
        ax_lib_gerror((byte*)"bsf size");
    };
    regcode = ax_genss_getregcodebx((i64)((*a).reg));
    am = ax_genss_genrm(b,regcode);
    ax_genss_setopsize(a);
    ax_genss_genrex();
    ax_genss_genbyte((i64)15);
    ax_genss_genbyte(opc);
    ax_genss_genamode(b,am);
}

static void ax_genss_extendsymboltable(void) {
    struct ax_decls_strec * (*oldsymboltable)[];
    i64 oldsymboltablesize;
    i64 i;
    oldsymboltablesize = ax_decls_ss_symboltablesize;
    oldsymboltable = ax_decls_ss_symboltable;
    ax_decls_ss_symboltablesize *= (i64)2;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"EXTENDING SYMBOL TABLE TO",NULL);
    msysnewc_m_print_i64(ax_decls_ss_symboltablesize,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    ax_decls_ss_symboltable = (struct ax_decls_strec * (*)[])(mlib_pcm_alloc(((i64)8 * ax_decls_ss_symboltablesize)));
    L1225 :;
    for (i=(i64)1;i<=ax_decls_ss_nsymbols;i+=(i64)1) {
L1226 :;
        (*ax_decls_ss_symboltable)[(i)-1] = (*oldsymboltable)[(i)-1];
L1227 :;
    }L1228 :;
    ;
    mlib_pcm_free((void *)(oldsymboltable),((i64)8 * oldsymboltablesize));
}

static void ax_genss_do_pcmpistri(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b,i64 c,i64 opc) {
    i64 am;
    i64 regcode;
    if ((((i64)((u64)((*a).mode)) != (i64)5) || (((i64)((u64)((*b).mode)) != (i64)5) && ((i64)((u64)((*b).mode)) != (i64)3)))) {
        ax_lib_gerror((byte*)"pcmpistrx opnds");
    };
    ax_genss_genbyte((i64)102);
    if (((i64)((u64)((*b).mode)) == (i64)5)) {
        {struct ax_decls_opndrec *  temp = a; a = b; b = temp; };
        regcode = ax_genss_getregcoderx((i64)((*b).reg));
        am = ax_genss_genrm(a,regcode);
        ax_genss_genrex();
        ax_genss_genbyte((i64)15);
        ax_genss_genbyte((i64)58);
        ax_genss_genbyte(opc);
        ax_genss_genamode(a,am);
    } else {
        regcode = ax_genss_getregcoderx((i64)((*a).reg));
        am = ax_genss_genrm(b,regcode);
        ax_genss_genrex();
        ax_genss_genbyte((i64)15);
        ax_genss_genbyte((i64)58);
        ax_genss_genbyte(opc);
        ax_genss_genamode(b,am);
    };
    ax_genss_genbyte(c);
}

void ax_writeexe_writeexe(byte * outfile,i64 dodll) {
    i64 i;
    ax_writeexe_dllfilename = outfile;
    ax_writeexe_isdll = dodll;
    ax_writeexe_datastart = (ax_writeexe_dataptr = (byte *)(mlib_pcm_allocz(ax_writeexe_filesize)));
    ax_writeexe_writedosstub();
    ax_writeexe_writepesig();
    ax_writeexe_writefileheader();
    ax_writeexe_writeoptheader();
    L1229 :;
    for (i=(i64)1;i<=ax_writeexe_nsections;i+=(i64)1) {
L1230 :;
        ax_writeexe_writesectionheader(&ax_writeexe_sectiontable[(i)-1]);
L1231 :;
    }L1232 :;
    ;
    ax_writeexe_writepadding(ax_writeexe_sectiontable[((i64)1)-1].rawoffset);
    L1233 :;
    for (i=(i64)1;i<=ax_writeexe_nsections;i+=(i64)1) {
L1234 :;
        ax_writeexe_writesectiondata(&ax_writeexe_sectiontable[(i)-1]);
L1235 :;
    }L1236 :;
    ;
    if (!!(ax_decls_fverbose)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"Writing file:",NULL);
        msysnewc_m_print_str(outfile,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
    if ((mlib_writefile(outfile,ax_writeexe_datastart,(ax_writeexe_dataptr - ax_writeexe_datastart)) == (i64)0)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"Error writing exe file (possibly still running)",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        exit((i64)1);
    };
}

void ax_writeexe_genexe(byte * entrypoint,byte * outfile,i64 dodll) {
    ax_writeexe_dllfilename = outfile;
    ax_writeexe_isdll = dodll;
    ax_writeexe_imagebase = (!!(ax_writeexe_isdll)?(u64)((i64)1713635328):(u64)((i64)4194304));
    ax_writeexe_userentrypoint = entrypoint;
    ax_writeexe_loadlibs();
    ax_writeexe_scanst();
    ax_writeexe_getoffsets();
    ax_writeexe_relocdata(&ax_writeexe_sectiontable[((i64)1)-1]);
    ax_writeexe_relocdata(&ax_writeexe_sectiontable[((i64)2)-1]);
}

static void ax_writeexe_loadlibs(void) {
    i64 i;
    i64 hinst;
    byte filename[300];
    L1237 :;
    for (i=(i64)1;i<=ax_decls_nsearchlibs;i+=(i64)1) {
L1238 :;
        strcpy((i8 *)(filename),(i8 *)(ax_decls_searchlibs[(i)-1]));
        strcat((i8 *)(filename),(i8 *)((byte*)".dll"));
        hinst = (i64)(osnos_os_getdllinst(filename));
        if ((hinst == (i64)0)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(ax_decls_searchlibs[(i)-1],NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(filename,NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            ax_lib_gerror((byte*)"Can't load search lib");
        };
        ax_writeexe_libinsttable[(i)-1] = hinst;
        ax_writeexe_libinstnames[(i)-1] = mlib_pcm_copyheapstring(filename);
L1239 :;
    }L1240 :;
    ;
}

void ax_writeexe_initsectiontable(void) {
    ax_writeexe_sectiontable[((i64)1)-1].name = (byte*)".text";
    ax_writeexe_sectiontable[((i64)1)-1].segtype = (i64)1;
    ax_writeexe_sectiontable[((i64)1)-1].data = ax_decls_ss_code;
    ax_writeexe_sectiontable[((i64)1)-1].virtsize = ax_lib_bufferlength(ax_decls_ss_code);
    if ((ax_lib_bufferlength(ax_decls_ss_idata) == (i64)0)) {
        ax_lib_addqword(ax_decls_ss_idata,(i64)0);
    };
    ax_writeexe_sectiontable[((i64)2)-1].name = (byte*)".data";
    ax_writeexe_sectiontable[((i64)2)-1].segtype = (i64)2;
    ax_writeexe_sectiontable[((i64)2)-1].data = ax_decls_ss_idata;
    ax_writeexe_sectiontable[((i64)2)-1].virtsize = ax_lib_bufferlength(ax_decls_ss_idata);
    ax_writeexe_sectiontable[((i64)2)-1].rawsize = ax_writeexe_roundtoblock(ax_writeexe_sectiontable[((i64)2)-1].virtsize,(i64)512);
    ax_writeexe_sectiontable[((i64)2)-1].nrelocs = ax_decls_ss_nidatarelocs;
    ax_writeexe_sectiontable[((i64)2)-1].relocs = ax_decls_ss_idatarelocs;
    if ((ax_decls_ss_zdatalen == (i64)0)) {
        ax_decls_ss_zdatalen = (i64)16;
    };
    ax_writeexe_sectiontable[((i64)3)-1].name = (byte*)".bss";
    ax_writeexe_sectiontable[((i64)3)-1].segtype = (i64)3;
    ax_writeexe_sectiontable[((i64)3)-1].virtsize = ax_decls_ss_zdatalen;
    ax_writeexe_sectiontable[((i64)1)-1].rawsize = ax_writeexe_roundtoblock(ax_writeexe_sectiontable[((i64)1)-1].virtsize,(i64)512);
    ax_writeexe_sectiontable[((i64)1)-1].nrelocs = ax_decls_ss_ncoderelocs;
    ax_writeexe_sectiontable[((i64)1)-1].relocs = ax_decls_ss_coderelocs;
    ax_writeexe_sectiontable[((i64)4)-1].name = (byte*)".idata";
    ax_writeexe_sectiontable[((i64)4)-1].segtype = (i64)5;
    ax_writeexe_sectiontable[((i64)4)-1].virtsize = (i64)0;
    ax_writeexe_sectiontable[((i64)4)-1].rawsize = (i64)0;
    ax_writeexe_nsections = (i64)4;
}

static i64 ax_writeexe_roundtoblock(i64 n,i64 align) {
    if (((n & (align - (i64)1)) == (i64)0)) {
        return n;
    };
    return (n + (align - (n & (align - (i64)1))));
}

static byte * ax_writeexe_extractlibname(byte * name,i64 * libno,i64 moduleno) {
    byte *  s;
    byte *  name2;
    byte str[256];
    i64 i;
    i64 n;
    name2 = (byte *)(0);
    //reenter:
L1241 :;
;
    s = name;
    (*libno) = (i64)0;
    L1242 :;
    while (!!((u64)((*s)))) {
        if (((u64)((*s)) == '.')) {
            memcpy((void *)(str),(void *)(name),(u64)((s - name)));
            str[(((s - name) + (i64)1))-1] = (u64)0u;
            strcat((i8 *)(str),(i8 *)((byte*)".dll"));
            L1245 :;
            for (i=(i64)1;i<=ax_writeexe_ndlls;i+=(i64)1) {
L1246 :;
                if (!!(mlib_eqstring(str,ax_writeexe_dlltable[(i)-1].name))) {
                    (*libno) = i;
                    ++ax_writeexe_dlltable[((*libno))-1].nprocs;
                    return (!!(name2)?name2:(s + (i64)1));
                };
L1247 :;
            }L1248 :;
            ;
            if ((ax_writeexe_ndlls >= (i64)50)) {
                ax_lib_gerror((byte*)"Too many libs");
            };
            (*libno) = ++ax_writeexe_ndlls;
            ax_writeexe_dlltable[((*libno))-1].name = mlib_pcm_copyheapstring(str);
            ax_writeexe_dlltable[((*libno))-1].nprocs = (i64)1;
            return (!!(name2)?name2:(s + (i64)1));
        };
        ++s;
L1243 :;
    }L1244 :;
    ;
    L1249 :;
    for (i=(i64)1;i<=ax_decls_nsearchlibs;i+=(i64)1) {
L1250 :;
        if (!!(osnos_os_getdllprocaddr(ax_writeexe_libinsttable[(i)-1],name))) {
            n = i;
            goto L1252 ;
        };
L1251 :;
    }
    {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str(name,NULL);
        msysnewc_m_print_str(ax_decls_moduletable[(moduleno)-1].name,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        ax_lib_gerror((byte*)"Can't find external function");
    }L1252 :;
    ;
    if (!!(((*libno) = ax_writeexe_libnotable[(n)-1]))) {
        ++ax_writeexe_dlltable[((*libno))-1].nprocs;
        return name;
    };
    strcpy((i8 *)(str),(i8 *)(ax_decls_searchlibs[(n)-1]));
    strcat((i8 *)(str),(i8 *)((byte*)".dll"));
    if ((ax_writeexe_ndlls >= (i64)50)) {
        ax_lib_gerror((byte*)"2:Too many libs");
    };
    (*libno) = ++ax_writeexe_ndlls;
    ax_writeexe_dlltable[((*libno))-1].name = mlib_pcm_copyheapstring(str);
    ax_writeexe_dlltable[((*libno))-1].nprocs = (i64)1;
    ax_writeexe_libnotable[(n)-1] = (*libno);
    return name;
}

static void ax_writeexe_scanst(void) {
    i64 i;
    i64 libno;
    struct ax_decls_strec *  d;
    byte *  name;
    L1253 :;
    for (i=(i64)1;i<=ax_decls_ss_nsymbols;i+=(i64)1) {
L1254 :;
        d = (*ax_decls_ss_symboltable)[(i)-1];
        if (((i64)((*d).symbol)==(i64)21)) {
            if ((ax_writeexe_nimports >= (i64)3000)) {
                ax_lib_gerror((byte*)"genexe: Too many imports");
            };
            ++ax_writeexe_nimports;
            name = ax_writeexe_extractlibname((*d).name,&libno,(i64)((*d).moduleno));
            ax_writeexe_importtable[(ax_writeexe_nimports)-1].libno = libno;
            ax_writeexe_importtable[(ax_writeexe_nimports)-1].name = name;
            ax_writeexe_importtable[(ax_writeexe_nimports)-1].def = d;
            (*d).importindex = ax_writeexe_nimports;
        }else if (((i64)((*d).symbol)==(i64)22)) {
            if (!!(ax_writeexe_userentrypoint)) {
                if (!!(mlib_eqstring((*d).name,ax_writeexe_userentrypoint))) {
                    ax_writeexe_stentrypoint = d;
                };
            } else {
                if ((!!(mlib_eqstring((*d).name,(byte*)"main")) && !(!!(ax_writeexe_isdll)))) {
                    ax_writeexe_stentrypoint = d;
                } else if ((!!(mlib_eqstring((*d).name,(byte*)"start")) && !(!!(ax_writeexe_isdll)))) {
                    ax_writeexe_stentrypoint2 = d;
                } else if ((!!(mlib_eqstring((*d).name,(byte*)"dllmain")) && !!(ax_writeexe_isdll))) {
                    ax_writeexe_stentrypoint = d;
                };
            };
            if ((ax_writeexe_nexports >= (i64)3000)) {
                ax_lib_gerror((byte*)"gendll: Too many exports");
            };
            ++ax_writeexe_nexports;
            ax_writeexe_exporttable[(ax_writeexe_nexports)-1].def = d;
            ax_writeexe_exporttable[(ax_writeexe_nexports)-1].name = (*d).name;
        };
L1255 :;
    }L1256 :;
    ;
}

static void ax_writeexe_relocdata(struct ax_objdecls_sectionrec * s) {
    struct ax_objdecls_sectionrec *  u;
    struct ax_decls_relocrec *  r;
    byte *  p;
    u32 *  p32;
    u64 *  p64;
    struct ax_decls_strec *  d;
    u64 thunkoffset;
    i64 index;
    p = (byte *)(ax_lib_bufferelemptr((*s).data,(i64)0));
    r = (*s).relocs;
    L1257 :;
    while (!!(r)) {
        d = (*ax_decls_ss_symboltable)[((*r).stindex)-1];
        index = (i64)((*d).importindex);
        thunkoffset = (u64)(ax_writeexe_importtable[(index)-1].thunkoffset);
        if (((*r).reloctype==(i64)4)) {
            if (((i64)((u64)((*d).symbol)) != (i64)21)) {
                ax_lib_gerror((byte*)"rel32/not imported");
            };
            (*(u32 *)((p + (*r).offset))) = (u64)((((i64)(thunkoffset) - (*r).offset) - (i64)4));
        }else if (((*r).reloctype==(i64)2) || ((*r).reloctype==(i64)1)) {
            if (((i64)((u64)((*d).symbol)) == (i64)21)) {
                (*(u32 *)((p + (*r).offset))) = (u64)(((i64)((ax_writeexe_imagebase + thunkoffset)) + ax_writeexe_sectiontable[((i64)1)-1].virtoffset));
            } else {
                if (((i64)((*d).segment)==(i64)3)) {
                    u = &ax_writeexe_sectiontable[((i64)3)-1];
                }else if (((i64)((*d).segment)==(i64)2)) {
                    u = &ax_writeexe_sectiontable[((i64)2)-1];
                }else if (((i64)((*d).segment)==(i64)1)) {
                    u = &ax_writeexe_sectiontable[((i64)1)-1];
                };
                p32 = (u32 *)((p + (*r).offset));
                if (((*r).reloctype == (i64)2)) {
                    (*p32) = (u64)((((i64)((u64)((*p32))) + (*u).virtoffset) + (i64)(ax_writeexe_imagebase)));
                } else {
                    p64 = (u64 *)(p32);
                    (*p64) = (u64)((((i64)((*p64)) + (*u).virtoffset) + (i64)(ax_writeexe_imagebase)));
                };
            };
        } else {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(ax_objdecls_relocnames[((*r).reloctype)],NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            ax_lib_gerror((byte*)"Can't do this rel type");
        };
        r = (*r).nextreloc;
L1258 :;
    }L1259 :;
    ;
}

static void ax_writeexe_getbaserelocs(struct ax_objdecls_sectionrec * s) {
    struct ax_objdecls_sectionrec *  u;
    struct ax_decls_relocrec *  r;
    byte *  p;
    struct ax_decls_strec *  d;
    p = (byte *)(ax_lib_bufferelemptr((*s).data,(i64)0));
    r = (*s).relocs;
    L1260 :;
    while (!!(r)) {
        d = (*ax_decls_ss_symboltable)[((*r).stindex)-1];
        if (((*r).reloctype==(i64)2) || ((*r).reloctype==(i64)1)) {
            if (((i64)((u64)((*d).symbol)) == (i64)21)) {
            } else {
                if (((i64)((*d).segment)==(i64)3)) {
                    u = &ax_writeexe_sectiontable[((i64)3)-1];
                }else if (((i64)((*d).segment)==(i64)2)) {
                    u = &ax_writeexe_sectiontable[((i64)2)-1];
                }else if (((i64)((*d).segment)==(i64)1)) {
                    u = &ax_writeexe_sectiontable[((i64)1)-1];
                };
                ax_writeexe_newbasereloc(((*u).virtoffset + (*r).offset),(*r).reloctype);
            };
        };
        r = (*r).nextreloc;
L1261 :;
    }L1262 :;
    ;
}

static void ax_writeexe_writerecordx(void * r,i64 length) {
    memcpy((void *)(ax_writeexe_dataptr),r,(u64)(length));
    ax_writeexe_dataptr += length;
}

static void ax_writeexe_writedosstub(void) {
    static byte stubdata[128] = {
    (u8)77u,
    (u8)90u,
    (u8)144u,
    (u8)0u,
    (u8)3u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)4u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)255u,
    (u8)255u,
    (u8)0u,
    (u8)0u,
    (u8)184u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)64u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)128u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)14u,
    (u8)31u,
    (u8)186u,
    (u8)14u,
    (u8)0u,
    (u8)180u,
    (u8)9u,
    (u8)205u,
    (u8)33u,
    (u8)184u,
    (u8)1u,
    (u8)76u,
    (u8)205u,
    (u8)33u,
    (u8)84u,
    (u8)104u,
    (u8)105u,
    (u8)115u,
    (u8)32u,
    (u8)112u,
    (u8)114u,
    (u8)111u,
    (u8)103u,
    (u8)114u,
    (u8)97u,
    (u8)109u,
    (u8)32u,
    (u8)99u,
    (u8)97u,
    (u8)110u,
    (u8)110u,
    (u8)111u,
    (u8)116u,
    (u8)32u,
    (u8)98u,
    (u8)101u,
    (u8)32u,
    (u8)114u,
    (u8)117u,
    (u8)110u,
    (u8)32u,
    (u8)105u,
    (u8)110u,
    (u8)32u,
    (u8)68u,
    (u8)79u,
    (u8)83u,
    (u8)32u,
    (u8)109u,
    (u8)111u,
    (u8)100u,
    (u8)101u,
    (u8)46u,
    (u8)13u,
    (u8)13u,
    (u8)10u,
    (u8)36u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u
};
    ax_writeexe_writerecordx((void *)(&stubdata),(i64)128);
}

static void ax_writeexe_writepesig(void) {
    (*ax_writeexe_dataptr++) = (u64)80u;
    (*ax_writeexe_dataptr++) = (u64)69u;
    (*ax_writeexe_dataptr++) = (u64)((i64)0);
    (*ax_writeexe_dataptr++) = (u64)((i64)0);
}

static void ax_writeexe_writepadding(i64 offset) {
    ax_writeexe_dataptr = (ax_writeexe_datastart + offset);
}

static void ax_writeexe_writefileheader(void) {
    struct ax_objdecls_imagefileheader header;
    memset((void *)(&header),(i64)0,(u64)((i64)20));
    header.machine = (u64)((i64)34404);
    header.nsections = (u64)(ax_writeexe_nsections);
    header.optheadersize = (u64)((i64)240);
    header.characteristics = (u64)((i64)559);
    if (!!(ax_writeexe_isdll)) {
        header.characteristics = (u64)((i64)8750);
    };
    ax_writeexe_writerecordx((void *)(&header),(i64)20);
}

static void ax_writeexe_writeoptheader(void) {
    struct ax_objdecls_optionalheader header;
    memset((void *)(&header),(i64)0,(u64)((i64)240));
    header.magic = (u64)((i64)523);
    header.majorlv = (u64)((i64)1);
    header.minorlv = (u64)((i64)0);
    header.codesize = (u64)(ax_writeexe_sectiontable[((i64)1)-1].rawsize);
    header.idatasize = (u64)((ax_writeexe_sectiontable[((i64)2)-1].rawsize + ax_writeexe_sectiontable[((i64)4)-1].rawsize));
    header.zdatasize = (u64)(ax_writeexe_roundtoblock(ax_writeexe_sectiontable[((i64)3)-1].virtsize,(i64)512));
    if ((ax_writeexe_stentrypoint == 0)) {
        ax_writeexe_stentrypoint = ax_writeexe_stentrypoint2;
        if ((ax_writeexe_stentrypoint == 0)) {
            ax_writeexe_stentrypoint = ax_writeexe_stentrypoint3;
            if (!!(ax_writeexe_stentrypoint)) {
                msysnewc_m_print_startcon();
                msysnewc_m_print_str((byte*)"Using tertiary 'WinMain' entry point",NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
            };
        };
    };
    if ((ax_writeexe_stentrypoint == 0)) {
        if (!!(ax_writeexe_userentrypoint)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(ax_writeexe_userentrypoint,NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            ax_lib_gerror((byte*)"User entry point not found");
        } else {
            if (!(!!(ax_writeexe_isdll))) {
                ax_lib_gerror((byte*)"Entry point not found: main or start");
            };
        };
    } else {
        header.entrypoint = (u64)((ax_writeexe_sectiontable[((i64)1)-1].virtoffset + (i64)((*ax_writeexe_stentrypoint).offset)));
    };
    header.codebase = (u64)((i64)4096);
    header.imagebase = ax_writeexe_imagebase;
    header.sectionalignment = (u64)((i64)4096);
    header.filealignment = (u64)((i64)512);
    header.majorosv = (u64)((i64)4);
    header.minorosv = (u64)((i64)0);
    header.majorssv = (u64)((i64)5);
    header.minorssv = (u64)((i64)2);
    header.imagesize = (u64)(ax_writeexe_imagesize);
    header.headerssize = (u64)(ax_writeexe_sectiontable[((i64)1)-1].rawoffset);
    header.subsystem = (u64)((i64)3);
    header.stackreserve = (u64)((i64)4194304);
    header.stackcommit = (u64)((i64)2097152);
    header.heapreserve = (u64)((i64)1048576);
    header.heapcommit = (u64)((i64)4096);
    header.rvadims = (u64)((i64)16);
    header.importtable.virtualaddr = (u64)(ax_writeexe_sectiontable[((i64)4)-1].virtoffset);
    header.importtable.size = (u64)(((ax_writeexe_sectiontable[((i64)4)-1].virtsize - ax_writeexe_exportdirvirtsize) - ax_writeexe_blockdirvirtsize));
    if (!!(ax_writeexe_isdll)) {
        header.dllcharacteristics = (u64)((i64)64);
        header.exporttable.virtualaddr = (u64)(ax_writeexe_exportdirvirtaddr);
        header.exporttable.size = (u64)(ax_writeexe_exportdirvirtsize);
        header.basereloctable.virtualaddr = (u64)(ax_writeexe_blockdirvirtaddr);
        header.basereloctable.size = (u64)(ax_writeexe_blockdirvirtsize);
    };
    header.iat.virtualaddr = (u64)(ax_writeexe_fileiatoffset);
    header.iat.size = (u64)(ax_writeexe_fileiatsize);
    ax_writeexe_writerecordx((void *)(&header),(i64)240);
}

static void ax_writeexe_writesectionheader(struct ax_objdecls_sectionrec * s) {
    struct ax_objdecls_imagesectionheader sheader;
    memset((void *)(&sheader),(i64)0,(u64)((i64)40));
    strcpy((i8 *)(&sheader.name[((i64)1)-1]),(i8 *)((*s).name));
    sheader.virtual_size = (u64)((*s).virtsize);
    sheader.virtual_address = (u64)((*s).virtoffset);
    sheader.rawdata_offset = (u64)((*s).rawoffset);
    sheader.rawdata_size = (u64)((*s).rawsize);
    if (((*s).segtype==(i64)3)) {
        sheader.characteristics = (u64)((i64)3226468480);
    }else if (((*s).segtype==(i64)2)) {
        sheader.characteristics = (u64)((i64)3226468416);
    }else if (((*s).segtype==(i64)1)) {
        sheader.characteristics = (u64)((i64)1615855648);
    }else if (((*s).segtype==(i64)5)) {
        sheader.characteristics = (u64)((i64)1076887616);
    };
    ax_writeexe_writerecordx((void *)(&sheader),(i64)40);
}

static void ax_writeexe_writesectiondata(struct ax_objdecls_sectionrec * s) {
    if (((*s).segtype==(i64)5)) {
        ax_writeexe_writerecordx((void *)((*s).bytedata),(*s).virtsize);
        if (((*s).rawsize > (*s).virtsize)) {
            ax_writeexe_dataptr += ((*s).rawsize - (*s).virtsize);
        };
    }else if (((*s).segtype==(i64)3)) {
    } else {
        ax_writeexe_writerecordx(ax_lib_bufferelemptr((*s).data,(i64)0),(*s).rawsize);
    };
}

static void ax_writeexe_getoffsets(void) {
    i64 fileoffset;
    i64 imageoffset;
    i64 i;
    i64 diroffset;
    i64 impdirno;
    i64 hinttableoffset;
    i64 j;
    i64 codesize;
    i64 length;
    i64 thunkoffset;
    i64 offset;
    i64 dirstartoffset;
    byte *  pcode;
    byte *  pimpdir;
    struct ax_objdecls_importdirrec *  pdir;
    i64 *  paddr;
    i64 *  pname;
    i64 iatoffset;
    byte *  phint;
    u32 *  pextra;
    i64 xxx;
    i64 av_1;
    byte *  thunkptr;
    byte *  codebase;
    i64 thunkaddr;
    fileoffset = (i64)392;
    fileoffset += ((i64)40 * ax_writeexe_nsections);
    fileoffset = ax_writeexe_roundtoblock(fileoffset,(i64)512);
    imageoffset = (i64)4096;
    codesize = ax_writeexe_sectiontable[((i64)1)-1].virtsize;
    pcode = (byte *)(ax_lib_bufferelemptr(ax_decls_ss_code,codesize));
    L1263 :;
    while (!!((codesize & (i64)7))) {
        (*pcode++) = (u64)((i64)144);
        ++codesize;
L1264 :;
    }L1265 :;
    ;
    thunkoffset = codesize;
    codesize += (ax_writeexe_nimports * (i64)8);
    ax_writeexe_sectiontable[((i64)1)-1].virtsize = codesize;
    ax_writeexe_sectiontable[((i64)1)-1].rawsize = ax_writeexe_roundtoblock(codesize,(i64)512);
    ax_lib_buffercheck(ax_decls_ss_code,((codesize - thunkoffset) + (i64)16));
    L1266 :;
    for (i=(i64)1;i<=ax_writeexe_nsections;i+=(i64)1) {
L1267 :;
        if ((ax_writeexe_sectiontable[(i)-1].segtype != (i64)3)) {
            ax_writeexe_sectiontable[(i)-1].rawoffset = fileoffset;
        };
        if ((ax_writeexe_sectiontable[(i)-1].segtype != (i64)3)) {
            fileoffset = ax_writeexe_roundtoblock((fileoffset + ax_writeexe_sectiontable[(i)-1].virtsize),(i64)512);
        };
        ax_writeexe_sectiontable[(i)-1].virtoffset = imageoffset;
        if ((ax_writeexe_sectiontable[(i)-1].segtype == (i64)5)) {
            diroffset = imageoffset;
            impdirno = i;
        };
        imageoffset = ax_writeexe_roundtoblock((imageoffset + ax_writeexe_sectiontable[(i)-1].virtsize),(i64)4096);
L1268 :;
    }L1269 :;
    ;
    if (!!(ax_writeexe_isdll)) {
        ax_writeexe_getbaserelocs(&ax_writeexe_sectiontable[((i64)1)-1]);
        ax_writeexe_getbaserelocs(&ax_writeexe_sectiontable[((i64)2)-1]);
    };
    diroffset += ((ax_writeexe_ndlls + (i64)1) * (i64)20);
    L1270 :;
    for (i=(i64)1;i<=ax_writeexe_ndlls;i+=(i64)1) {
L1271 :;
        ax_writeexe_dlltable[(i)-1].nametableoffset = diroffset;
        diroffset += ((ax_writeexe_dlltable[(i)-1].nprocs + (i64)1) * (i64)8);
L1272 :;
    }L1273 :;
    ;
    ax_writeexe_fileiatoffset = diroffset;
    L1274 :;
    for (i=(i64)1;i<=ax_writeexe_ndlls;i+=(i64)1) {
L1275 :;
        ax_writeexe_dlltable[(i)-1].addrtableoffset = diroffset;
        diroffset += ((ax_writeexe_dlltable[(i)-1].nprocs + (i64)1) * (i64)8);
L1276 :;
    }L1277 :;
    ;
    ax_writeexe_fileiatsize = (diroffset - ax_writeexe_fileiatoffset);
    hinttableoffset = diroffset;
    L1278 :;
    for (i=(i64)1;i<=ax_writeexe_nimports;i+=(i64)1) {
L1279 :;
        length = ((i64)(strlen((i8 *)(ax_writeexe_importtable[(i)-1].name))) + (i64)3);
        if (!!((length & (i64)1))) {
            ++length;
        };
        ax_writeexe_importtable[(i)-1].hintnameoffset = diroffset;
        diroffset += length;
L1280 :;
    }L1281 :;
    ;
    diroffset = ax_writeexe_roundtoblock(diroffset,(i64)4);
    L1282 :;
    for (i=(i64)1;i<=ax_writeexe_ndlls;i+=(i64)1) {
L1283 :;
        length = ((i64)(strlen((i8 *)(ax_writeexe_dlltable[(i)-1].name))) + (i64)1);
        if (!!((length & (i64)1))) {
            ++length;
        };
        ax_writeexe_dlltable[(i)-1].dllextraoffset = diroffset;
        diroffset += (ax_writeexe_dlltable[(i)-1].nprocs * (i64)4);
        ax_writeexe_dlltable[(i)-1].dllnameoffset = diroffset;
        diroffset += length;
L1284 :;
    }L1285 :;
    ;
    dirstartoffset = ax_writeexe_sectiontable[(impdirno)-1].virtoffset;
    if (!!(ax_writeexe_isdll)) {
        ax_writeexe_exportdirvirtaddr = diroffset;
        ax_writeexe_exportdiroffset = (diroffset - dirstartoffset);
        ax_writeexe_exportdirvirtsize = ax_writeexe_getexporttablesize();
        diroffset += ax_writeexe_exportdirvirtsize;
        ax_writeexe_scanbaserelocs();
        ax_writeexe_blockdirvirtaddr = diroffset;
        ax_writeexe_blockdiroffset = (diroffset - dirstartoffset);
        ax_writeexe_blockdirvirtsize = ax_writeexe_basetablesize;
        diroffset += ax_writeexe_blockdirvirtsize;
    };
    offset = (diroffset - dirstartoffset);
    ax_writeexe_sectiontable[(impdirno)-1].virtsize = offset;
    ax_writeexe_sectiontable[(impdirno)-1].rawsize = ax_writeexe_roundtoblock(offset,(i64)512);
    ax_writeexe_filesize = ax_writeexe_roundtoblock((fileoffset + offset),(i64)512);
    ax_writeexe_imagesize = ax_writeexe_roundtoblock((imageoffset + (diroffset - dirstartoffset)),(i64)4096);
    pimpdir = (ax_writeexe_sectiontable[(impdirno)-1].bytedata = (byte *)(mlib_pcm_allocz(offset)));
    pdir = (struct ax_objdecls_importdirrec *)(pimpdir);
    L1286 :;
    for (i=(i64)1;i<=ax_writeexe_ndlls;i+=(i64)1) {
L1287 :;
        (*pdir).implookuprva = (u64)(ax_writeexe_dlltable[(i)-1].nametableoffset);
        (*pdir).impaddressrva = (u64)(ax_writeexe_dlltable[(i)-1].addrtableoffset);
        (*pdir).namerva = (u64)(ax_writeexe_dlltable[(i)-1].dllnameoffset);
        ++pdir;
        iatoffset = ax_writeexe_dlltable[(i)-1].addrtableoffset;
        paddr = (i64 *)(((pimpdir + iatoffset) - dirstartoffset));
        pname = (i64 *)(((pimpdir + ax_writeexe_dlltable[(i)-1].nametableoffset) - dirstartoffset));
        L1290 :;
        for (j=(i64)1;j<=ax_writeexe_nimports;j+=(i64)1) {
L1291 :;
            if ((ax_writeexe_importtable[(j)-1].libno == i)) {
                (*pname) = ((*paddr) = ax_writeexe_importtable[(j)-1].hintnameoffset);
                ax_writeexe_importtable[(j)-1].iatoffset = iatoffset;
                iatoffset += (i64)8;
                ++pname;
                ++paddr;
            };
L1292 :;
        }L1293 :;
        ;
L1288 :;
    }L1289 :;
    ;
    L1294 :;
    for (i=(i64)1;i<=ax_writeexe_nimports;i+=(i64)1) {
L1295 :;
        phint = ((pimpdir + ax_writeexe_importtable[(i)-1].hintnameoffset) - dirstartoffset);
        phint += (i64)2;
        strcpy((i8 *)(phint),(i8 *)(ax_writeexe_importtable[(i)-1].name));
L1296 :;
    }L1297 :;
    ;
    xxx = dirstartoffset;
    L1298 :;
    for (i=(i64)1;i<=ax_writeexe_ndlls;i+=(i64)1) {
L1299 :;
        pextra = (u32 *)(((pimpdir + ax_writeexe_dlltable[(i)-1].dllextraoffset) - dirstartoffset));
        L1302 :;
        for (j=(i64)1;j<=ax_writeexe_dlltable[(i)-1].nprocs;j+=(i64)1) {
L1303 :;
            (*pextra) = (u64)(xxx);
            ++pextra;
L1304 :;
        }L1305 :;
        ;
        xxx += (i64)20;
        phint = ((pimpdir + ax_writeexe_dlltable[(i)-1].dllnameoffset) - dirstartoffset);
        strcpy((i8 *)(phint),(i8 *)(ax_writeexe_dlltable[(i)-1].name));
L1300 :;
    }L1301 :;
    ;
    if (!!(ax_writeexe_isdll)) {
        ax_writeexe_writeexporttable((pimpdir + ax_writeexe_exportdiroffset));
        ax_writeexe_writebasereloctable((pimpdir + ax_writeexe_blockdiroffset));
    };
    thunkptr = (byte *)(ax_lib_bufferelemptr(ax_decls_ss_code,thunkoffset));
    codebase = (byte *)(ax_lib_bufferelemptr(ax_decls_ss_code,(i64)0));
    L1306 :;
    for (i=(i64)1;i<=ax_writeexe_nimports;i+=(i64)1) {
L1307 :;
        ax_writeexe_importtable[(i)-1].thunkoffset = (thunkptr - codebase);
        (*thunkptr++) = (u64)((i64)72);
        (*thunkptr++) = (u64)((i64)255);
        (*thunkptr++) = (u64)((i64)36);
        (*thunkptr++) = (u64)((i64)37);
        thunkaddr = ((i64)(ax_writeexe_imagebase) + ax_writeexe_importtable[(i)-1].iatoffset);
        (*(i32 *)(thunkptr)) = thunkaddr;
        thunkptr += (i64)4;
L1308 :;
    }L1309 :;
    ;
}

static i64 ax_writeexe_getsectionno(i64 segment) {
    if ((segment==(i64)3)) {
        return (i64)3;
    }else if ((segment==(i64)2)) {
        return (i64)2;
    }else if ((segment==(i64)1)) {
        return (i64)1;
    } else {
        ax_lib_gerror((byte*)"GSN");
        return (i64)0;
    };
}

static void ax_writeexe_writeexporttable(byte * pstart) {
    i64 sortindex[3000];
    struct ax_objdecls_exportdirrec *  phdr;
    u32 *  paddrtable;
    u32 *  pnametable;
    u16 *  pordtable;
    byte *  pdllname;
    byte *  pnames;
    i64 addrtableoffset;
    i64 nametableoffset;
    i64 ordtableoffset;
    i64 dllnameoffset;
    i64 namesoffset;
    i64 virtoffset;
    i64 sectionno;
    struct ax_decls_strec *  d;
    i64 i;
    phdr = (struct ax_objdecls_exportdirrec *)(pstart);
    (*phdr).timedatestamp = (u64)((i64)1602876664);
    (*phdr).ordinalbase = (u64)((i64)1);
    (*phdr).naddrtable = (u64)(ax_writeexe_nexports);
    (*phdr).nnamepointers = (u64)(ax_writeexe_nexports);
    addrtableoffset = (i64)40;
    nametableoffset = (addrtableoffset + (ax_writeexe_nexports * (i64)4));
    ordtableoffset = (nametableoffset + (ax_writeexe_nexports * (i64)4));
    dllnameoffset = (ordtableoffset + (ax_writeexe_nexports * (i64)2));
    namesoffset = ((dllnameoffset + (i64)(strlen((i8 *)(ax_writeexe_dllfilename)))) + (i64)1);
    virtoffset = (ax_writeexe_sectiontable[((i64)4)-1].virtoffset + ax_writeexe_exportdiroffset);
    paddrtable = (u32 *)((pstart + addrtableoffset));
    pnametable = (u32 *)((pstart + nametableoffset));
    pordtable = (u16 *)((pstart + ordtableoffset));
    pdllname = (byte *)((pstart + dllnameoffset));
    pnames = (byte *)((pstart + namesoffset));
    (*phdr).namerva = (u64)((dllnameoffset + virtoffset));
    (*phdr).expaddressrva = (u64)((addrtableoffset + virtoffset));
    (*phdr).namepointerrva = (u64)((nametableoffset + virtoffset));
    (*phdr).ordtablerva = (u64)((ordtableoffset + virtoffset));
    strcpy((i8 *)(pdllname),(i8 *)(ax_writeexe_dllfilename));
    if ((ax_writeexe_nexports > (i64)3000)) {
        ax_lib_gerror((byte*)"Too many exports - can't sort");
    };
    ax_writeexe_sortexports(&sortindex);
    L1310 :;
    for (i=(i64)1;i<=ax_writeexe_nexports;i+=(i64)1) {
L1311 :;
        d = ax_writeexe_exporttable[(sortindex[(i)-1])-1].def;
        sectionno = ax_writeexe_getsectionno((i64)((*d).segment));
        strcpy((i8 *)(pnames),(i8 *)((*d).name));
        (*pnametable) = (u64)((namesoffset + virtoffset));
        ++pnametable;
        namesoffset += ((i64)(strlen((i8 *)((*d).name))) + (i64)1);
        pnames += ((i64)(strlen((i8 *)((*d).name))) + (i64)1);
        (*paddrtable) = (u64)(((i64)((*d).offset) + ax_writeexe_sectiontable[(sectionno)-1].virtoffset));
        ++paddrtable;
        (*pordtable) = (u64)((i - (i64)1));
        ++pordtable;
L1312 :;
    }L1313 :;
    ;
}

static i64 ax_writeexe_getexporttablesize(void) {
    i64 size;
    i64 i;
    size = (i64)40;
    size += (ax_writeexe_nexports * (i64)4);
    size += (ax_writeexe_nexports * (i64)4);
    size += (ax_writeexe_nexports * (i64)2);
    size += ((i64)(strlen((i8 *)(ax_writeexe_dllfilename))) + (i64)1);
    L1314 :;
    for (i=(i64)1;i<=ax_writeexe_nexports;i+=(i64)1) {
L1315 :;
        size += ((i64)(strlen((i8 *)((*ax_writeexe_exporttable[(i)-1].def).name))) + (i64)1);
L1316 :;
    }L1317 :;
    ;
    return size;
}

static void ax_writeexe_newbasereloc(i64 addr,i64 reltype) {
    struct ax_writeexe_basereloc *  p;
    p = (struct ax_writeexe_basereloc *)(mlib_pcm_allocz((i64)16));
    (*p).address = (u64)(addr);
    (*p).reloctype = reltype;
    (*p).nextitem = ax_writeexe_basereloclist;
    ax_writeexe_basereloclist = p;
    ++ax_writeexe_nbaserelocs;
    ax_writeexe_maxrelocaddr=(ax_writeexe_maxrelocaddr>addr?ax_writeexe_maxrelocaddr:addr);
;
}

static void ax_writeexe_scanbaserelocs(void) {
    i64 baseaddr;
    i64 addr;
    i64 nextblock;
    struct ax_writeexe_basereloc *  p;
    i64 i;
    baseaddr = (i64)4096;
    ax_writeexe_nbaseblocks = (i64)0;
    L1318 :;
    do {
        nextblock = (baseaddr + (i64)4096);
        if ((ax_writeexe_nbaseblocks >= (i64)500)) {
            ax_lib_gerror((byte*)"Too many blocks");
        };
        ++ax_writeexe_nbaseblocks;
        ax_writeexe_blockbases[(ax_writeexe_nbaseblocks)-1] = baseaddr;
        ax_writeexe_blockcounts[(ax_writeexe_nbaseblocks)-1] = (i64)0;
        p = ax_writeexe_basereloclist;
        L1321 :;
        while (!!(p)) {
            addr = (i64)((*p).address);
            if (((addr >= baseaddr) && (addr < nextblock))) {
                ++ax_writeexe_blockcounts[(ax_writeexe_nbaseblocks)-1];
            };
            p = (*p).nextitem;
L1322 :;
        }L1323 :;
        ;
        baseaddr = nextblock;
L1319 :;
    } while (!(baseaddr > ax_writeexe_maxrelocaddr));L1320 :;
    ;
    L1324 :;
    for (i=(i64)1;i<=ax_writeexe_nbaseblocks;i+=(i64)1) {
L1325 :;
        if (!!((i64)(ax_writeexe_blockcounts[(i)-1]))) {
            if (!!(((i64)(ax_writeexe_blockcounts[(i)-1]) & (i64)1))) {
                ++ax_writeexe_blockcounts[(i)-1];
                ++ax_writeexe_blockpadding[(i)-1];
            };
            ax_writeexe_blockbytes[(i)-1] = (((i64)(ax_writeexe_blockcounts[(i)-1]) * (i64)2) + (i64)8);
            ax_writeexe_basetablesize += (i64)(ax_writeexe_blockbytes[(i)-1]);
        };
L1326 :;
    }L1327 :;
    ;
}

static void ax_writeexe_writebasereloctable(byte * pstart) {
    u32 *  p32;
    u16 *  p16;
    i64 baseaddr;
    i64 addr;
    i64 nextblock;
    struct ax_writeexe_basereloc *  q;
    i64 i;
    p32 = (u32 *)(pstart);
    L1328 :;
    for (i=(i64)1;i<=ax_writeexe_nbaseblocks;i+=(i64)1) {
L1329 :;
        if (!!((i64)(ax_writeexe_blockcounts[(i)-1]))) {
            (*p32) = (u64)(ax_writeexe_blockbases[(i)-1]);
            ++p32;
            (*p32) = (u64)(ax_writeexe_blockbytes[(i)-1]);
            ++p32;
            p16 = (u16 *)(p32);
            q = ax_writeexe_basereloclist;
            baseaddr = ax_writeexe_blockbases[(i)-1];
            nextblock = (baseaddr + (i64)4096);
            L1332 :;
            while (!!(q)) {
                addr = (i64)((*q).address);
                if (((addr >= baseaddr) && (addr < nextblock))) {
                    (*p16) = (u64)(((addr - baseaddr) + ((((i64)((*q).reloctype) == (i64)2)?(i64)3:(i64)10) << (i64)12)));
                    ++p16;
                };
                q = (*q).nextitem;
L1333 :;
            }L1334 :;
            ;
            if (!!((u64)(ax_writeexe_blockpadding[(i)-1]))) {
                (*p16++) = (u64)((i64)0);
            };
            p32 = (u32 *)(p16);
        };
L1330 :;
    }L1331 :;
    ;
}

static void ax_writeexe_sortexports(i64 (*sortindex)[]) {
    struct ax_decls_strec *  d;
    struct ax_decls_strec *  e;
    i64 swapped;
    i64 av_1;
    i64 i;
    L1335 :;
    for (i=(i64)1;i<=ax_writeexe_nexports;i+=(i64)1) {
L1336 :;
        (*sortindex)[(i)-1] = i;
L1337 :;
    }L1338 :;
    ;
    L1339 :;
    do {
        swapped = (i64)0;
        L1342 :;
        for (i=(i64)1;i<=(ax_writeexe_nexports - (i64)1);i+=(i64)1) {
L1343 :;
            d = ax_writeexe_exporttable[((*sortindex)[(i)-1])-1].def;
            e = ax_writeexe_exporttable[((*sortindex)[((i + (i64)1))-1])-1].def;
            if (((i64)(strcmp((i8 *)((*d).name),(i8 *)((*e).name))) > (i64)0)) {
                swapped = (i64)1;
                {i64 temp = (*sortindex)[(i)-1]; (*sortindex)[(i)-1] = (*sortindex)[((i + (i64)1))-1]; (*sortindex)[((i + (i64)1))-1] = temp; };
            };
L1344 :;
        }L1345 :;
        ;
L1340 :;
    } while (!!(!!(swapped)));L1341 :;
    ;
}

byte * ax_disasm_decodeinstr(byte * * cptr,byte * baseaddr) {
    i64 n;
    i64 w;
    i64 opc;
    i64 reg;
    i64 op;
    byte *  pstart;
    static byte str[256];
    byte str2[128];
    i64 av_1;
    i64 av_2;
    ax_disasm_deststr[((i64)1)-1] = (u64)0u;
    pstart = (ax_disasm_codeptr = (*cptr));
    ax_disasm_rex = (i64)0;
    ax_disasm_opsize = (i64)1;
    ax_disasm_f2override = (ax_disasm_f3override = (ax_disasm_sizeoverride = (ax_disasm_addroverride = (i64)0)));
    ax_disasm_basereg = (ax_disasm_indexreg = (ax_disasm_offset = (i64)0));
    //retry:
L1346 :;
;
    switch ((opc = (i64)((*ax_disasm_codeptr++)))) {
    case 0:;
    case 1:;
    case 8:;
    case 9:;
    case 16:;
    case 17:;
    case 24:;
    case 25:;
    case 32:;
    case 33:;
    case 40:;
    case 41:;
    case 48:;
    case 49:;
    case 56:;
    case 57:;
    {
        op = (opc >> (i64)3);
        ax_disasm_decodeaddr((opc & (i64)1));
        ax_disasm_getsilx(&ax_disasm_basereg);
        ax_disasm_getsil(&ax_disasm_rmreg);
        ax_disasm_genstr(ax_disasm_opnames[(op)]);
        ax_disasm_printaddrmode((i64)0);
        ax_disasm_genstr((byte*)", ");
        ax_disasm_genstr(ax_disasm_strreg(ax_disasm_rmreg,ax_disasm_opsize));
    }break;
    case 2:;
    case 3:;
    case 10:;
    case 11:;
    case 18:;
    case 19:;
    case 26:;
    case 27:;
    case 34:;
    case 35:;
    case 42:;
    case 43:;
    case 50:;
    case 51:;
    case 58:;
    case 59:;
    {
        op = (opc >> (i64)3);
        ax_disasm_decodeaddr((opc & (i64)1));
        ax_disasm_genstr(ax_disasm_opnames[(op)]);
        ax_disasm_genstr((byte*)" ");
        ax_disasm_getsil(&ax_disasm_rmreg);
        ax_disasm_genstr(ax_disasm_strreg(ax_disasm_rmreg,ax_disasm_opsize));
        ax_disasm_genstr((byte*)", ");
        ax_disasm_printaddrmode((i64)0);
    }break;
    case 4:;
    case 5:;
    case 12:;
    case 13:;
    case 20:;
    case 21:;
    case 28:;
    case 29:;
    case 36:;
    case 37:;
    case 44:;
    case 45:;
    case 52:;
    case 53:;
    case 60:;
    case 61:;
    {
        ax_disasm_genstr(ax_disasm_opnames[((opc >> (i64)3))]);
        ax_disasm_genstr((byte*)" ");
        if (!!((opc & (i64)1))) {
            ax_disasm_opsize = (i64)4;
            if (!!(ax_disasm_sizeoverride)) {
                ax_disasm_opsize = (i64)2;
            };
            if (!!((ax_disasm_rex & (i64)8))) {
                ax_disasm_opsize = (i64)8;
            };
        };
        ax_disasm_genstr(ax_disasm_strreg((i64)1,ax_disasm_opsize));
        ax_disasm_genstr((byte*)", ");
        ax_disasm_genintd(ax_disasm_readimm());
    }break;
    case 15:;
    {
        ax_disasm_decodetwobyteinstr();
    }break;
    case 64:;
    case 65:;
    case 66:;
    case 67:;
    case 68:;
    case 69:;
    case 70:;
    case 71:;
    case 72:;
    case 73:;
    case 74:;
    case 75:;
    case 76:;
    case 77:;
    case 78:;
    case 79:;
    {
        ax_disasm_rex = opc;
        goto L1346 ;
;
    }break;
    case 80:;
    case 81:;
    case 82:;
    case 83:;
    case 84:;
    case 85:;
    case 86:;
    case 87:;
    {
        reg = ax_disasm_getreg((opc & (i64)7),(ax_disasm_rex & (i64)1));
        ax_disasm_genstr((byte*)"push ");
        ax_disasm_genstr(ax_disasm_strreg(reg,(i64)8));
    }break;
    case 88:;
    case 89:;
    case 90:;
    case 91:;
    case 92:;
    case 93:;
    case 94:;
    case 95:;
    {
        reg = ax_disasm_getreg((opc & (i64)7),(ax_disasm_rex & (i64)1));
        ax_disasm_genstr((byte*)"pop ");
        ax_disasm_genstr(ax_disasm_strreg(reg,(i64)8));
    }break;
    case 99:;
    {
        ax_disasm_decodeaddr((i64)1);
        ax_disasm_genstr((byte*)"movsxd ");
        ax_disasm_genstr(ax_disasm_strreg(ax_disasm_rmreg,ax_disasm_opsize));
        ax_disasm_genstr((byte*)", ");
        ax_disasm_opsize = (i64)4;
        ax_disasm_printaddrmode((i64)0);
    }break;
    case 102:;
    {
        ax_disasm_sizeoverride = (i64)1;
        goto L1346 ;
;
    }break;
    case 103:;
    {
        ax_disasm_addroverride = (i64)1;
        goto L1346 ;
;
    }break;
    case 104:;
    {
        ax_disasm_genstr((byte*)"push ");
        ax_disasm_genintd(ax_disasm_readint32());
    }break;
    case 106:;
    {
        ax_disasm_genstr((byte*)"push ");
        ax_disasm_genintd(ax_disasm_readsbyte());
    }break;
    case 105:;
    case 107:;
    {
        ax_disasm_decodeaddr((i64)1);
        if ((ax_disasm_basereg != ax_disasm_rmreg)) {
            ax_disasm_genstr((byte*)"imul3");
            ax_disasm_genstr((byte*)" ");
            ax_disasm_genstr(ax_disasm_strreg(ax_disasm_rmreg,ax_disasm_opsize));
            ax_disasm_genstr((byte*)", ");
        } else {
            ax_disasm_genstr((byte*)"imul2");
        };
        ax_disasm_printaddrmode((i64)0);
        ax_disasm_genstr((byte*)", ");
        ax_disasm_opsize = (!!((opc & (i64)2))?(i64)1:ax_disasm_opsize);
        ax_disasm_genintd(ax_disasm_readimm());
    }break;
    case 112:;
    case 113:;
    case 114:;
    case 115:;
    case 116:;
    case 117:;
    case 118:;
    case 119:;
    case 120:;
    case 121:;
    case 122:;
    case 123:;
    case 124:;
    case 125:;
    case 126:;
    case 127:;
    {
        ax_disasm_genstr((byte*)"j");
        ax_disasm_genstr(ax_disasm_condnames[((opc & (i64)15))]);
        ax_disasm_genstr((byte*)" ");
        ax_disasm_genintd(ax_disasm_readsbyte());
    }break;
    case 128:;
    case 129:;
    case 130:;
    case 131:;
    {
        ax_disasm_decodeaddr((opc & (i64)1));
        ax_disasm_genstr(ax_disasm_opnames[(ax_disasm_rmopc)]);
        ax_disasm_getsilx(&ax_disasm_basereg);
        ax_disasm_printaddrmode((i64)0);
        ax_disasm_genstr((byte*)", ");
        if ((opc != (i64)131)) {
            ax_disasm_genintd(ax_disasm_readimm());
        } else {
            ax_disasm_genintd(ax_disasm_readsbyte());
        };
    }break;
    case 132:;
    case 133:;
    {
        ax_disasm_decodeaddr((opc & (i64)1));
        ax_disasm_getsilx(&ax_disasm_basereg);
        ax_disasm_getsil(&ax_disasm_rmreg);
        ax_disasm_genstr((byte*)"test ");
        ax_disasm_printaddrmode((i64)0);
        ax_disasm_genstr((byte*)", ");
        ax_disasm_genstr(ax_disasm_strreg(ax_disasm_rmreg,ax_disasm_opsize));
    }break;
    case 134:;
    case 135:;
    {
        ax_disasm_decodeaddr((opc & (i64)1));
        ax_disasm_genstr((byte*)"exch2 ");
        ax_disasm_getsilx(&ax_disasm_basereg);
        ax_disasm_getsil(&ax_disasm_rmreg);
        ax_disasm_genstr(ax_disasm_strreg(ax_disasm_rmreg,ax_disasm_opsize));
        ax_disasm_genstr((byte*)",");
        ax_disasm_printaddrmode((i64)0);
    }break;
    case 136:;
    case 137:;
    {
        ax_disasm_decodeaddr((opc & (i64)1));
        ax_disasm_genstr((byte*)"mov");
        ax_disasm_getsilx(&ax_disasm_basereg);
        ax_disasm_getsil(&ax_disasm_rmreg);
        ax_disasm_printaddrmode((i64)0);
        ax_disasm_genstr((byte*)", ");
        ax_disasm_genstr(ax_disasm_strreg(ax_disasm_rmreg,ax_disasm_opsize));
    }break;
    case 138:;
    case 139:;
    {
        ax_disasm_decodeaddr((opc & (i64)1));
        ax_disasm_genstr((byte*)"mov ");
        ax_disasm_getsilx(&ax_disasm_basereg);
        ax_disasm_getsil(&ax_disasm_rmreg);
        ax_disasm_genstr(ax_disasm_strreg(ax_disasm_rmreg,ax_disasm_opsize));
        ax_disasm_genstr((byte*)", ");
        ax_disasm_printaddrmode((i64)0);
    }break;
    case 141:;
    {
        ax_disasm_decodeaddr((i64)1);
        ax_disasm_genstr((byte*)"lea ");
        ax_disasm_genstr(ax_disasm_strreg(ax_disasm_rmreg,ax_disasm_opsize));
        ax_disasm_genstr((byte*)", ");
        ax_disasm_printaddrmode((i64)0);
    }break;
    case 143:;
    {
        ax_disasm_decodeaddr((i64)1);
        ax_disasm_opsize = (i64)1;
        ax_disasm_genstr((byte*)"pop");
        ax_disasm_printaddrmode((i64)0);
    }break;
    case 144:;
    {
        if (!!(ax_disasm_rex)) {
            goto L1347 ;
;
        };
        ax_disasm_genstr((byte*)"nop");
    }break;
    case 145:;
    case 146:;
    case 147:;
    case 148:;
    case 149:;
    case 150:;
    case 151:;
    {
        //doexch:
L1347 :;
;
        reg = ((opc & (i64)7) + (i64)1);
        if (!!((ax_disasm_rex & (i64)1))) {
            reg += (i64)8;
        };
        ax_disasm_opsize = (!!(ax_disasm_sizeoverride)?(i64)2:(i64)4);
        if (!!((ax_disasm_rex & (i64)8))) {
            ax_disasm_opsize = (i64)8;
        };
        ax_disasm_genstr((byte*)"xchg ");
        ax_disasm_genstr(ax_disasm_strreg((i64)1,ax_disasm_opsize));
        ax_disasm_genstr((byte*)", ");
        ax_disasm_genstr(ax_disasm_strreg(reg,ax_disasm_opsize));
    }break;
    case 152:;
    {
        if (!!(ax_disasm_sizeoverride)) {
            ax_disasm_genstr((byte*)"cbw");
        } else {
            ax_disasm_genstr((byte*)"cbw???");
        };
    }break;
    case 153:;
    {
        if (!!(ax_disasm_sizeoverride)) {
            ax_disasm_genstr((byte*)"cwd");
        } else if (!!((ax_disasm_rex & (i64)8))) {
            ax_disasm_genstr((byte*)"cqo");
        } else {
            ax_disasm_genstr((byte*)"cdq");
        };
    }break;
    case 155:;
    {
        ax_disasm_genstr((byte*)"wait");
    }break;
    case 156:;
    {
        ax_disasm_genstr((byte*)"pushf");
    }break;
    case 157:;
    {
        ax_disasm_genstr((byte*)"popf");
    }break;
    case 158:;
    {
        ax_disasm_genstr((byte*)"sahf");
    }break;
    case 159:;
    {
        ax_disasm_genstr((byte*)"lahf");
    }break;
    case 164:;
    case 165:;
    case 166:;
    case 167:;
    case 170:;
    case 171:;
    case 172:;
    case 173:;
    case 174:;
    case 175:;
    {
        ax_disasm_genstr((((opc >> (i64)1) & (i64)7)==1?(byte*)"?":(((opc >> (i64)1) & (i64)7)==2?(byte*)"movs":(((opc >> (i64)1) & (i64)7)==3?(byte*)"cmps":(((opc >> (i64)1) & (i64)7)==4?(byte*)"?":(((opc >> (i64)1) & (i64)7)==5?(byte*)"stos":(((opc >> (i64)1) & (i64)7)==6?(byte*)"lods":(((opc >> (i64)1) & (i64)7)==7?(byte*)"scas":(byte*)"?"))))))));
        if (((opc & (i64)1) == (i64)0)) {
            ax_disasm_genstr((byte*)"b");
        } else {
            if (!!((ax_disasm_rex & (i64)8))) {
                ax_disasm_genstr((byte*)"q");
            } else if (!!(ax_disasm_sizeoverride)) {
                ax_disasm_genstr((byte*)"w");
            } else {
                ax_disasm_genstr((byte*)"d");
            };
        };
    }break;
    case 168:;
    case 169:;
    {
        ax_disasm_genstr((byte*)"test ");
        if (!!((opc & (i64)1))) {
            ax_disasm_opsize = (!!(ax_disasm_sizeoverride)?(i64)2:(i64)4);
            if (!!((ax_disasm_rex & (i64)8))) {
                ax_disasm_opsize = (i64)8;
            };
        };
        ax_disasm_genstr(ax_disasm_strreg((i64)1,ax_disasm_opsize));
        ax_disasm_genstr((byte*)", ");
        ax_disasm_genintd(ax_disasm_readimm());
    }break;
    case 176:;
    case 177:;
    case 178:;
    case 179:;
    case 180:;
    case 181:;
    case 182:;
    case 183:;
    case 184:;
    case 185:;
    case 186:;
    case 187:;
    case 188:;
    case 189:;
    case 190:;
    case 191:;
    {
        reg = ((opc & (i64)7) + (i64)1);
        if (!!((ax_disasm_rex & (i64)1))) {
            reg += (i64)8;
        };
        if (!!((opc & (i64)8))) {
            ax_disasm_opsize = (!!(ax_disasm_sizeoverride)?(i64)2:(i64)4);
            if (!!((ax_disasm_rex & (i64)8))) {
                ax_disasm_opsize = (i64)8;
            };
        };
        ax_disasm_genstr((byte*)"mov ");
        ax_disasm_getsil(&reg);
        ax_disasm_genstr(ax_disasm_strreg(reg,ax_disasm_opsize));
        ax_disasm_genstr((byte*)", ");
        ax_disasm_genintd(ax_disasm_readimm8());
    }break;
    case 192:;
    case 193:;
    case 208:;
    case 209:;
    case 210:;
    case 211:;
    {
        ax_disasm_decodeaddr((opc & (i64)1));
        ax_disasm_getsilx(&ax_disasm_basereg);
        ax_disasm_genstr(((ax_disasm_rmopc + (i64)1)==1?(byte*)"rol":((ax_disasm_rmopc + (i64)1)==2?(byte*)"ror":((ax_disasm_rmopc + (i64)1)==3?(byte*)"rcl":((ax_disasm_rmopc + (i64)1)==4?(byte*)"rcr":((ax_disasm_rmopc + (i64)1)==5?(byte*)"shl":((ax_disasm_rmopc + (i64)1)==6?(byte*)"shr":((ax_disasm_rmopc + (i64)1)==7?(byte*)"?":((ax_disasm_rmopc + (i64)1)==8?(byte*)"sar":(byte*)"?")))))))));
        ax_disasm_printaddrmode((i64)0);
        if ((opc <= (i64)193)) {
            ax_disasm_genstr((byte*)", ");
            ax_disasm_genintd(ax_disasm_readbyte());
        } else {
            ax_disasm_genstr((!!((opc & (i64)2))?(byte*)", cl":(byte*)", 1"));
        };
    }break;
    case 194:;
    {
        ax_disasm_genstr((byte*)"retn ");
        ax_disasm_genintd((i64)(ax_disasm_readword16()));
    }break;
    case 195:;
    {
        ax_disasm_genstr((byte*)"ret");
    }break;
    case 198:;
    case 199:;
    {
        ax_disasm_decodeaddr((opc & (i64)1));
        ax_disasm_genstr((byte*)"mov");
        ax_disasm_printaddrmode((i64)0);
        ax_disasm_genstr((byte*)", ");
        ax_disasm_genintd(ax_disasm_readimm());
    }break;
    case 215:;
    {
        ax_disasm_genstr((byte*)"xlat");
    }break;
    case 216:;
    case 217:;
    case 218:;
    case 219:;
    case 220:;
    case 221:;
    case 222:;
    case 223:;
    {
        ax_disasm_decode8087((opc & (i64)7));
    }break;
    case 224:;
    {
        ax_disasm_genstr((byte*)"loopnz ");
        ax_disasm_genintd(ax_disasm_readsbyte());
    }break;
    case 225:;
    {
        ax_disasm_genstr((byte*)"loopz ");
        ax_disasm_genintd(ax_disasm_readsbyte());
    }break;
    case 226:;
    {
        ax_disasm_genstr((byte*)"loop ");
        ax_disasm_genintd(ax_disasm_readsbyte());
    }break;
    case 227:;
    {
        if (!!(ax_disasm_addroverride)) {
            ax_disasm_genstr((byte*)"jecxz ");
        } else {
            ax_disasm_genstr((byte*)"jrcxz ");
        };
        ax_disasm_genintd(ax_disasm_readsbyte());
    }break;
    case 232:;
    {
        ax_disasm_genstr((byte*)"call ");
        ax_disasm_genintd(ax_disasm_readint32());
    }break;
    case 233:;
    {
        ax_disasm_genstr((byte*)"[4] jmp ");
        ax_disasm_genintd(ax_disasm_readint32());
    }break;
    case 235:;
    {
        ax_disasm_genstr((byte*)"jmp ");
        ax_disasm_genintd(ax_disasm_readsbyte());
    }break;
    case 242:;
    {
        if ((((i64)((u64)((*ax_disasm_codeptr))) != (i64)15) && (((i64)((u64)((*ax_disasm_codeptr))) < (i64)64) && ((i64)((u64)((*ax_disasm_codeptr))) > (i64)79)))) {
            ax_disasm_genstr((byte*)"repne");
        } else {
            ax_disasm_f2override = (i64)1;
            goto L1346 ;
;
        };
    }break;
    case 243:;
    {
        if ((((i64)((u64)((*ax_disasm_codeptr))) != (i64)15) && (((i64)((u64)((*ax_disasm_codeptr))) < (i64)64) && ((i64)((u64)((*ax_disasm_codeptr))) > (i64)79)))) {
            ax_disasm_genstr((byte*)"repe");
        } else {
            ax_disasm_f3override = (i64)1;
            goto L1346 ;
;
        };
    }break;
    case 244:;
    {
        return (byte *)(0);
    }break;
    case 246:;
    case 247:;
    {
        ax_disasm_decodeaddr((opc & (i64)1));
        ax_disasm_getsilx(&ax_disasm_basereg);
        ax_disasm_genstr(((ax_disasm_rmopc + (i64)1)==1?(byte*)"test":((ax_disasm_rmopc + (i64)1)==2?(byte*)"?":((ax_disasm_rmopc + (i64)1)==3?(byte*)"not":((ax_disasm_rmopc + (i64)1)==4?(byte*)"neg":((ax_disasm_rmopc + (i64)1)==5?(byte*)"mul":((ax_disasm_rmopc + (i64)1)==6?(byte*)"imul":((ax_disasm_rmopc + (i64)1)==7?(byte*)"div":((ax_disasm_rmopc + (i64)1)==8?(byte*)"idiv":(byte*)"?")))))))));
        ax_disasm_printaddrmode((i64)0);
        if ((ax_disasm_rmopc == (i64)0)) {
            if ((ax_disasm_opsize == (i64)8)) {
                ax_disasm_opsize = (i64)4;
            };
            ax_disasm_genstr((byte*)", ");
            ax_disasm_genintd(ax_disasm_readimm());
        };
    }break;
    case 254:;
    {
        w = (i64)0;
        goto L1348 ;
;
    }break;
    case 255:;
    {
        w = (i64)1;
        //doff:
L1348 :;
;
        ax_disasm_decodeaddr(w);
        if ((ax_disasm_rmopc==(i64)0)) {
            ax_disasm_getsilx(&ax_disasm_basereg);
            ax_disasm_genstr((byte*)"inc");
        }else if ((ax_disasm_rmopc==(i64)1)) {
            ax_disasm_getsilx(&ax_disasm_basereg);
            ax_disasm_genstr((byte*)"dec");
        }else if ((ax_disasm_rmopc==(i64)2)) {
            ax_disasm_opsize = (i64)8;
            ax_disasm_genstr((byte*)"icall");
        }else if ((ax_disasm_rmopc==(i64)4)) {
            ax_disasm_opsize = (i64)8;
            ax_disasm_genstr((byte*)"jmp");
        }else if ((ax_disasm_rmopc==(i64)6)) {
            ax_disasm_opsize = (i64)8;
            ax_disasm_genstr((byte*)"push");
        } else {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((byte*)"FFxx?",NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
        };
        ax_disasm_printaddrmode((i64)0);
    }break;
    default: {
        ax_disasm_genstr((byte*)"Unknown opcode: ");
        ax_disasm_genhex(opc);
    }
    } //SW
;
    if (!!(baseaddr)) {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_ptr(baseaddr,(byte*)"z6h");
        msysnewc_m_print_nogap();
        msysnewc_m_print_str((byte*)": ",NULL);
        msysnewc_m_print_end();
        ;
    } else {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_ptr(pstart,(byte*)"z6h");
        msysnewc_m_print_nogap();
        msysnewc_m_print_str((byte*)": ",NULL);
        msysnewc_m_print_end();
        ;
    };
    n = (ax_disasm_codeptr - pstart);
    av_1 = n;
    while (av_1-- > 0) {
L1349 :;
        msysnewc_m_print_startstr(str2);
        msysnewc_m_print_i64((i64)((*pstart++)),(byte*)"z2H");
        msysnewc_m_print_nogap();
        msysnewc_m_print_str((byte*)" ",NULL);
        msysnewc_m_print_end();
        ;
        strcat((i8 *)(str),(i8 *)(str2));
L1350 :;
    }L1351 :;
    ;
    av_2 = ((i64)14 - n);
    while (av_2-- > 0) {
L1352 :;
        strcat((i8 *)(str),(i8 *)((byte*)"-- "));
L1353 :;
    }L1354 :;
    ;
    strcat((i8 *)(str),(i8 *)(ax_disasm_deststr));
    (*cptr) = ax_disasm_codeptr;
    return str;
}

static void ax_disasm_decodetwobyteinstr(void) {
    i64 opc;
    i64 rhssize;
    i64 third;
    i64 imm;
    byte *  opcstr;
    switch ((opc = (i64)((*ax_disasm_codeptr++)))) {
    case 42:;
    {
        ax_disasm_decodeaddr((i64)1);
        if (!!(ax_disasm_f3override)) {
            ax_disasm_genstr((byte*)"cvtsi2ss ");
        } else {
            ax_disasm_genstr((byte*)"cvtsi2sd ");
        };
        ax_disasm_genstr(ax_disasm_strxmm(ax_disasm_rmreg));
        ax_disasm_genstr((byte*)", ");
        ax_disasm_printaddrmode((i64)0);
    }break;
    case 44:;
    {
        ax_disasm_decodeaddr((i64)1);
        if (!!(ax_disasm_f3override)) {
            ax_disasm_genstr((byte*)"cvttss2si ");
            rhssize = (i64)4;
        } else {
            ax_disasm_genstr((byte*)"cvttsd2si ");
            rhssize = (i64)8;
        };
        if (!!((ax_disasm_rex & (i64)8))) {
            ax_disasm_genstr(ax_disasm_strreg(ax_disasm_rmreg,(i64)8));
        } else {
            ax_disasm_genstr(ax_disasm_strreg(ax_disasm_rmreg,(i64)4));
        };
        ax_disasm_genstr((byte*)", ");
        ax_disasm_opsize = rhssize;
        ax_disasm_printaddrmode((i64)1);
    }break;
    case 45:;
    {
        ax_disasm_decodeaddr((i64)1);
        if (!!(ax_disasm_f3override)) {
            ax_disasm_genstr((byte*)"cvtss2si ");
            rhssize = (i64)4;
        } else {
            ax_disasm_genstr((byte*)"cvtsd2si ");
            rhssize = (i64)8;
        };
        if (!!((ax_disasm_rex & (i64)8))) {
            ax_disasm_genstr(ax_disasm_strreg(ax_disasm_rmreg,(i64)8));
        } else {
            ax_disasm_genstr(ax_disasm_strreg(ax_disasm_rmreg,(i64)4));
        };
        ax_disasm_genstr((byte*)", ");
        ax_disasm_opsize = rhssize;
        ax_disasm_printaddrmode((i64)1);
    }break;
    case 47:;
    {
        ax_disasm_decodeaddr((i64)1);
        if (!!(ax_disasm_sizeoverride)) {
            ax_disasm_opsize = (i64)8;
            ax_disasm_genstr((byte*)"comisd ");
        } else {
            ax_disasm_opsize = (i64)4;
            ax_disasm_genstr((byte*)"comiss ");
        };
        ax_disasm_genstr(ax_disasm_strxmm(ax_disasm_rmreg));
        ax_disasm_genstr((byte*)", ");
        ax_disasm_printaddrmode((i64)1);
    }break;
    case 58:;
    {
        third = (i64)((*ax_disasm_codeptr++));
        if ((third==(i64)99)) {
            ax_disasm_genstr((byte*)"pcmpistri ");
        }else if ((third==(i64)98)) {
            ax_disasm_genstr((byte*)"pcmpistrm ");
        } else {
            ax_disasm_genstr((byte*)"Unknown opcode 2-byte opcode: 0F ");
            ax_disasm_genhex(opc);
            return;
        };
        ax_disasm_decodeaddr((i64)1);
        ax_disasm_genstr(ax_disasm_strxmm(ax_disasm_rmreg));
        ax_disasm_genstr((byte*)", ");
        ax_disasm_printaddrmode((i64)1);
        ax_disasm_genstr((byte*)", ");
        imm = (i64)((*ax_disasm_codeptr++));
        ax_disasm_genintd(imm);
    }break;
    case 64:;
    case 65:;
    case 66:;
    case 67:;
    case 68:;
    case 69:;
    case 70:;
    case 71:;
    case 72:;
    case 73:;
    case 74:;
    case 75:;
    case 76:;
    case 77:;
    case 78:;
    case 79:;
    {
        ax_disasm_decodeaddr((i64)1);
        ax_disasm_genstr((byte*)"cmov");
        ax_disasm_genstr(ax_disasm_condnames[((opc & (i64)15))]);
        ax_disasm_genstr((byte*)" ");
        ax_disasm_genstr(ax_disasm_strreg(ax_disasm_rmreg,ax_disasm_opsize));
        ax_disasm_genstr((byte*)", ");
        ax_disasm_printaddrmode((i64)0);
    }break;
    case 81:;
    {
        ax_disasm_decodeaddr((i64)1);
        ax_disasm_opsize = (!!(ax_disasm_f3override)?(i64)4:(i64)8);
        ax_disasm_genstr(((ax_disasm_opsize == (i64)4)?(byte*)"sqrtss ":(byte*)"sqrtsd "));
        ax_disasm_genstr(ax_disasm_strxmm(ax_disasm_rmreg));
        ax_disasm_genstr((byte*)", ");
        ax_disasm_printaddrmode((i64)1);
    }break;
    case 84:;
    {
        ax_disasm_decodeaddr((i64)1);
        ax_disasm_genstr((!!(ax_disasm_sizeoverride)?(byte*)"andpd ":(byte*)"andps "));
        ax_disasm_genstr(ax_disasm_strxmm(ax_disasm_rmreg));
        ax_disasm_genstr((byte*)", ");
        ax_disasm_opsize = (!!(ax_disasm_sizeoverride)?(i64)8:(i64)4);
        ax_disasm_printaddrmode((i64)1);
    }break;
    case 87:;
    {
        ax_disasm_decodeaddr((i64)1);
        ax_disasm_genstr((!!(ax_disasm_sizeoverride)?(byte*)"xorpd ":(byte*)"xorps "));
        ax_disasm_genstr(ax_disasm_strxmm(ax_disasm_rmreg));
        ax_disasm_genstr((byte*)", ");
        ax_disasm_opsize = (!!(ax_disasm_sizeoverride)?(i64)8:(i64)4);
        ax_disasm_printaddrmode((i64)1);
    }break;
    case 88:;
    {
        opcstr = (byte*)"adds";
        //doarith:
L1355 :;
;
        ax_disasm_genstr(opcstr);
        ax_disasm_decodeaddr((i64)1);
        if (!!(ax_disasm_f2override)) {
            ax_disasm_opsize = (i64)8;
            ax_disasm_genstr((byte*)"d ");
        } else {
            ax_disasm_opsize = (i64)4;
            ax_disasm_genstr((byte*)"s ");
        };
        ax_disasm_genstr(ax_disasm_strxmm(ax_disasm_rmreg));
        ax_disasm_genstr((byte*)", ");
        ax_disasm_printaddrmode((i64)1);
    }break;
    case 89:;
    {
        opcstr = (byte*)"muls";
        goto L1355 ;
;
    }break;
    case 90:;
    {
        ax_disasm_decodeaddr((i64)1);
        if (!!(ax_disasm_f3override)) {
            ax_disasm_genstr((byte*)"cvtss2sd ");
            rhssize = (i64)4;
        } else {
            ax_disasm_genstr((byte*)"cvtsd2ss ");
            rhssize = (i64)8;
        };
        ax_disasm_genstr(ax_disasm_strxmm(ax_disasm_rmreg));
        ax_disasm_genstr((byte*)", ");
        ax_disasm_opsize = rhssize;
        ax_disasm_printaddrmode((i64)1);
    }break;
    case 92:;
    {
        opcstr = (byte*)"subs";
        goto L1355 ;
;
    }break;
    case 93:;
    {
        opcstr = (byte*)"mins";
        goto L1355 ;
;
    }break;
    case 94:;
    {
        opcstr = (byte*)"divs";
        goto L1355 ;
;
    }break;
    case 95:;
    {
        opcstr = (byte*)"maxs";
        goto L1355 ;
;
    }break;
    case 110:;
    {
        ax_disasm_decodeaddr((i64)1);
        ax_disasm_opsize = (!!((ax_disasm_rex & (i64)8))?(i64)8:(i64)4);
        ax_disasm_genstr(((ax_disasm_opsize == (i64)4)?(byte*)"movd ":(byte*)"movq "));
        if (!!(ax_disasm_sizeoverride)) {
            ax_disasm_genstr(ax_disasm_strxmm(ax_disasm_rmreg));
        } else {
            ax_disasm_genstr(ax_disasm_strmmx(ax_disasm_rmreg));
        };
        ax_disasm_genstr((byte*)", ");
        ax_disasm_printaddrmode((i64)0);
    }break;
    case 111:;
    {
        ax_disasm_decodeaddr((i64)1);
        ax_disasm_opsize = (i64)16;
        if (!!(ax_disasm_sizeoverride)) {
            ax_disasm_genstr((byte*)"movdqa ");
        } else if (!!(ax_disasm_f3override)) {
            ax_disasm_genstr((byte*)"movdqu ");
        } else {
            ax_disasm_genstr((byte*)"No 66/F3 ");
        };
        ax_disasm_genstr(ax_disasm_strxmm(ax_disasm_rmreg));
        ax_disasm_genstr((byte*)", ");
        ax_disasm_printaddrmode((i64)1);
    }break;
    case 126:;
    {
        ax_disasm_decodeaddr((i64)1);
        if (!!(ax_disasm_f3override)) {
            ax_disasm_opsize = (i64)8;
            ax_disasm_genstr((byte*)"movq ");
            ax_disasm_genstr(ax_disasm_strxmm(ax_disasm_rmreg));
            ax_disasm_genstr((byte*)", ");
            ax_disasm_printaddrmode((i64)1);
        } else if (!!((ax_disasm_rex & (i64)8))) {
            ax_disasm_opsize = (i64)8;
            ax_disasm_genstr((byte*)"movq ");
            ax_disasm_printaddrmode((i64)0);
            ax_disasm_genstr((byte*)", ");
            ax_disasm_genstr(ax_disasm_strxmm(ax_disasm_rmreg));
        } else {
            ax_disasm_opsize = (i64)4;
            ax_disasm_genstr((byte*)"movd ");
            ax_disasm_printaddrmode((i64)0);
            ax_disasm_genstr((byte*)", ");
            if (!!(ax_disasm_sizeoverride)) {
                ax_disasm_genstr(ax_disasm_strxmm(ax_disasm_rmreg));
            } else {
                ax_disasm_genstr(ax_disasm_strmmx(ax_disasm_rmreg));
            };
        };
    }break;
    case 127:;
    {
        ax_disasm_decodeaddr((i64)1);
        ax_disasm_opsize = (i64)16;
        if (!!(ax_disasm_sizeoverride)) {
            ax_disasm_genstr((byte*)"movdqa ");
        } else if (!!(ax_disasm_f3override)) {
            ax_disasm_genstr((byte*)"movdqu ");
        } else {
            ax_disasm_genstr((byte*)"No 66/F3 ");
        };
        ax_disasm_printaddrmode((i64)1);
        ax_disasm_genstr((byte*)", ");
        ax_disasm_genstr(ax_disasm_strxmm(ax_disasm_rmreg));
    }break;
    case 128:;
    case 129:;
    case 130:;
    case 131:;
    case 132:;
    case 133:;
    case 134:;
    case 135:;
    case 136:;
    case 137:;
    case 138:;
    case 139:;
    case 140:;
    case 141:;
    case 142:;
    case 143:;
    {
        ax_disasm_genstr((byte*)"[long] j");
        ax_disasm_genstr(ax_disasm_condnames[((opc & (i64)15))]);
        ax_disasm_genstr((byte*)" ");
        if (!!(ax_disasm_sizeoverride)) {
            ax_disasm_genintd(ax_disasm_readint16());
        } else {
            ax_disasm_genintd(ax_disasm_readint32());
        };
    }break;
    case 144:;
    case 145:;
    case 146:;
    case 147:;
    case 148:;
    case 149:;
    case 150:;
    case 151:;
    case 152:;
    case 153:;
    case 154:;
    case 155:;
    case 156:;
    case 157:;
    case 158:;
    case 159:;
    {
        ax_disasm_decodeaddr((i64)0);
        ax_disasm_genstr((byte*)"set");
        ax_disasm_genstr(ax_disasm_condnames[((opc & (i64)15))]);
        ax_disasm_genstr((byte*)" ");
        ax_disasm_getsilx(&ax_disasm_basereg);
        ax_disasm_printaddrmode((i64)0);
    }break;
    case 175:;
    {
        ax_disasm_decodeaddr((i64)1);
        ax_disasm_genstr((byte*)"imul ");
        ax_disasm_genstr(ax_disasm_strreg(ax_disasm_rmreg,ax_disasm_opsize));
        ax_disasm_genstr((byte*)", ");
        ax_disasm_printaddrmode((i64)0);
    }break;
    case 182:;
    case 183:;
    case 190:;
    case 191:;
    {
        ax_disasm_decodeaddr((i64)1);
        ax_disasm_genstr(((opc < (i64)190)?(byte*)"movzx ":(byte*)"movsx "));
        ax_disasm_genstr(ax_disasm_strreg(ax_disasm_rmreg,ax_disasm_opsize));
        ax_disasm_genstr((byte*)", ");
        ax_disasm_opsize = (!!((opc & (i64)1))?(i64)2:(i64)1);
        ax_disasm_printaddrmode((i64)0);
    }break;
    case 184:;
    {
        ax_disasm_decodeaddr((i64)1);
        ax_disasm_genstr((byte*)"popcnt ");
        ax_disasm_genstr(ax_disasm_strreg(ax_disasm_rmreg,ax_disasm_opsize));
        ax_disasm_genstr((byte*)", ");
        ax_disasm_printaddrmode((i64)0);
    }break;
    case 188:;
    case 189:;
    {
        ax_disasm_decodeaddr((i64)1);
        ax_disasm_genstr(((opc == (i64)188)?(byte*)"bsf ":(byte*)"bsr "));
        ax_disasm_genstr(ax_disasm_strreg(ax_disasm_rmreg,ax_disasm_opsize));
        ax_disasm_genstr((byte*)", ");
        ax_disasm_printaddrmode((i64)0);
    }break;
    case 214:;
    {
        ax_disasm_decodeaddr((i64)1);
        ax_disasm_opsize = (i64)8;
        ax_disasm_genstr((byte*)"movq ");
        ax_disasm_printaddrmode((i64)1);
        ax_disasm_genstr((byte*)",");
        ax_disasm_genstr(ax_disasm_strxmm(ax_disasm_rmreg));
    }break;
    case 219:;
    {
        ax_disasm_decodeaddr((i64)1);
        ax_disasm_genstr((byte*)"pand ");
        ax_disasm_genstr(ax_disasm_strxmm(ax_disasm_rmreg));
        ax_disasm_genstr((byte*)", ");
        ax_disasm_opsize = (i64)8;
        ax_disasm_printaddrmode((i64)1);
    }break;
    case 239:;
    {
        ax_disasm_decodeaddr((i64)1);
        ax_disasm_genstr((byte*)"pxor ");
        ax_disasm_genstr(ax_disasm_strxmm(ax_disasm_rmreg));
        ax_disasm_genstr((byte*)", ");
        ax_disasm_opsize = (i64)8;
        ax_disasm_printaddrmode((i64)1);
    }break;
    default: {
        //error:
L1356 :;
;
        ax_disasm_genstr((byte*)"Unknown opcode 2-byte opcode: 0F ");
        ax_disasm_genhex(opc);
    }
    } //SW
;
}

static void ax_disasm_decodeaddr(i64 w) {
    i64 modrm;
    i64 xxx;
    i64 mode;
    i64 sib;
    i64 rm;
    ax_disasm_basereg = (ax_disasm_indexreg = (i64)0);
    ax_disasm_scale = (i64)1;
    ax_disasm_offset = (i64)0;
    if (!!(w)) {
        ax_disasm_opsize = (!!(ax_disasm_sizeoverride)?(i64)2:(i64)4);
        if (!!((ax_disasm_rex & (i64)8))) {
            ax_disasm_opsize = (i64)8;
        };
    } else {
        ax_disasm_opsize = (i64)1;
    };
    modrm = (i64)((*ax_disasm_codeptr++));
    mode = (modrm >> (i64)6);
    xxx = ((modrm >> (i64)3) & (i64)7);
    rm = (modrm & (i64)7);
    if ((mode == (i64)3)) {
        ax_disasm_basereg = (rm + (i64)1);
        ax_disasm_addrmode = (i64)1;
    } else if ((rm != (i64)4)) {
        if (((mode == (i64)0) && (rm == (i64)5))) {
            ax_disasm_offset = ax_disasm_readint32();
            ax_disasm_addrmode = (i64)2;
        } else {
            ax_disasm_basereg = (rm + (i64)1);
            ax_disasm_addrmode = (i64)2;
            if ((mode==(i64)1)) {
                ax_disasm_offset = ax_disasm_readsbyte();
            }else if ((mode==(i64)2)) {
                ax_disasm_offset = ax_disasm_readint32();
            };
        };
    } else {
        ax_disasm_addrmode = (i64)2;
        sib = ax_disasm_readbyte();
        ax_disasm_indexreg = (((sib >> (i64)3) & (i64)7) + (i64)1);
        ax_disasm_basereg = ((sib & (i64)7) + (i64)1);
        ax_disasm_scale = (((sib >> (i64)6) + (i64)1)==1?(i64)1:(((sib >> (i64)6) + (i64)1)==2?(i64)2:(((sib >> (i64)6) + (i64)1)==3?(i64)4:(((sib >> (i64)6) + (i64)1)==4?(i64)8:(i64)0))));
        if ((((mode == (i64)0) && (ax_disasm_basereg == (i64)6)) && (ax_disasm_indexreg == (i64)5))) {
            ax_disasm_indexreg = (ax_disasm_basereg = (i64)0);
            ax_disasm_offset = ax_disasm_readint32();
        } else if (((mode == (i64)0) && (ax_disasm_basereg == (i64)6))) {
            ax_disasm_basereg = (i64)0;
            ax_disasm_offset = ax_disasm_readint32();
        } else if (((mode == (i64)0) && (ax_disasm_indexreg == (i64)5))) {
            ax_disasm_indexreg = (i64)0;
        } else {
            if ((mode==(i64)1)) {
                ax_disasm_offset = ax_disasm_readsbyte();
            }else if ((mode==(i64)2)) {
                ax_disasm_offset = ax_disasm_readint32();
            };
            if ((ax_disasm_indexreg == (i64)5)) {
                ax_disasm_indexreg = (i64)0;
            };
        };
    };
    if ((!!(ax_disasm_basereg) && !!((ax_disasm_rex & (i64)1)))) {
        ax_disasm_basereg += (i64)8;
    };
    if ((!!(ax_disasm_indexreg) && !!((ax_disasm_rex & (i64)2)))) {
        ax_disasm_indexreg += (i64)8;
    };
    ax_disasm_rmreg = (xxx + (i64)1);
    if (!!((ax_disasm_rex & (i64)4))) {
        ax_disasm_rmreg += (i64)8;
    };
    ax_disasm_rmopc = xxx;
}

static i64 ax_disasm_readbyte(void) {
    return (i64)((*ax_disasm_codeptr++));
}

static i64 ax_disasm_readsbyte(void) {
    return (i64)((*(i8 *)(ax_disasm_codeptr++)));
}

static u64 ax_disasm_readword16(void) {
    u64 a;
    a = (u64)((*(u16 *)(ax_disasm_codeptr)));
    ax_disasm_codeptr += (i64)2;
    return a;
}

static i64 ax_disasm_readint16(void) {
    i64 a;
    a = (i64)((*(i16 *)(ax_disasm_codeptr)));
    ax_disasm_codeptr += (i64)2;
    return a;
}

static u64 ax_disasm_readword32(void) {
    u64 a;
    a = (u64)((*(u32 *)(ax_disasm_codeptr)));
    ax_disasm_codeptr += (i64)4;
    return a;
}

static i64 ax_disasm_readint32(void) {
    i64 a;
    a = (i64)((*(i32 *)(ax_disasm_codeptr)));
    ax_disasm_codeptr += (i64)4;
    return a;
}

static i64 ax_disasm_readint64(void) {
    i64 a;
    a = (*(i64 *)(ax_disasm_codeptr));
    ax_disasm_codeptr += (i64)8;
    return a;
}

static i64 ax_disasm_getreg(i64 regcode,i64 upper) {
    if (!!(upper)) {
        return ((regcode + (i64)8) + (i64)1);
    };
    return (regcode + (i64)1);
}

byte * ax_disasm_strreg(i64 reg,i64 opsize) {
    static byte *  regnames8[20] = {
    (byte*)"al",
    (byte*)"cl",
    (byte*)"dl",
    (byte*)"bl",
    (byte*)"spl",
    (byte*)"bpl",
    (byte*)"sil",
    (byte*)"dil",
    (byte*)"r8b",
    (byte*)"r9b",
    (byte*)"r10b",
    (byte*)"r11b",
    (byte*)"r12b",
    (byte*)"r13b",
    (byte*)"r14b",
    (byte*)"r15b",
    (byte*)"ah",
    (byte*)"bh",
    (byte*)"ch",
    (byte*)"dh"
};
    static byte *  regnames16[16] = {
    (byte*)"ax",
    (byte*)"cx",
    (byte*)"dx",
    (byte*)"bx",
    (byte*)"sp",
    (byte*)"bp",
    (byte*)"si",
    (byte*)"di",
    (byte*)"r8w",
    (byte*)"r9w",
    (byte*)"r10w",
    (byte*)"r11w",
    (byte*)"r12w",
    (byte*)"r13w",
    (byte*)"r14w",
    (byte*)"r15w"
};
    static byte *  regnames32[16] = {
    (byte*)"eax",
    (byte*)"ecx",
    (byte*)"edx",
    (byte*)"ebx",
    (byte*)"esp",
    (byte*)"ebp",
    (byte*)"esi",
    (byte*)"edi",
    (byte*)"r8d",
    (byte*)"r9d",
    (byte*)"r10d",
    (byte*)"r11d",
    (byte*)"r12d",
    (byte*)"r13d",
    (byte*)"r14d",
    (byte*)"r15d"
};
    static byte *  regnames64[16] = {
    (byte*)"rax",
    (byte*)"rcx",
    (byte*)"rdx",
    (byte*)"rbx",
    (byte*)"rsp",
    (byte*)"rbp",
    (byte*)"rsi",
    (byte*)"rdi",
    (byte*)"r8",
    (byte*)"r9",
    (byte*)"r10",
    (byte*)"r11",
    (byte*)"r12",
    (byte*)"r13",
    (byte*)"r14",
    (byte*)"r15"
};
    static byte *  mregnames8[20] = {
    (byte*)"B0",
    (byte*)"B10",
    (byte*)"B11",
    (byte*)"B4",
    (byte*)"B15",
    (byte*)"B14",
    (byte*)"B5",
    (byte*)"B3",
    (byte*)"B12",
    (byte*)"B13",
    (byte*)"B1",
    (byte*)"B2",
    (byte*)"B6",
    (byte*)"B7",
    (byte*)"B8",
    (byte*)"B9",
    (byte*)"B16",
    (byte*)"B18",
    (byte*)"B19",
    (byte*)"B17"
};
    static byte *  mregnames16[16] = {
    (byte*)"W0",
    (byte*)"W10",
    (byte*)"W11",
    (byte*)"W4",
    (byte*)"Wsp",
    (byte*)"Wbp",
    (byte*)"W5",
    (byte*)"W3",
    (byte*)"W12",
    (byte*)"W13",
    (byte*)"W1",
    (byte*)"W2",
    (byte*)"W6",
    (byte*)"W7",
    (byte*)"W8",
    (byte*)"W9"
};
    static byte *  mregnames32[16] = {
    (byte*)"A0",
    (byte*)"A10",
    (byte*)"A11",
    (byte*)"A4",
    (byte*)"Astack",
    (byte*)"Aframe",
    (byte*)"A5",
    (byte*)"A3",
    (byte*)"A12",
    (byte*)"A13",
    (byte*)"A1",
    (byte*)"A2",
    (byte*)"A6",
    (byte*)"A7",
    (byte*)"A8",
    (byte*)"A9"
};
    static byte *  mregnames64[16] = {
    (byte*)"D0",
    (byte*)"D10",
    (byte*)"D11",
    (byte*)"D4",
    (byte*)"Dstack",
    (byte*)"Dframe",
    (byte*)"D5",
    (byte*)"D3",
    (byte*)"D12",
    (byte*)"D13",
    (byte*)"D1",
    (byte*)"D2",
    (byte*)"D6",
    (byte*)"D7",
    (byte*)"D8",
    (byte*)"D9"
};
    if ((reg == (i64)0)) {
        return (byte*)"<>";
    };
    if (!!((i64)0)) {
        if ((opsize==(i64)1)) {
            return mregnames8[(reg)-1];
        }else if ((opsize==(i64)2)) {
            return mregnames16[(reg)-1];
        }else if ((opsize==(i64)4)) {
            return mregnames32[(reg)-1];
        }else if ((opsize==(i64)8)) {
            return mregnames64[(reg)-1];
        };
    } else {
        if ((opsize==(i64)1)) {
            return regnames8[(reg)-1];
        }else if ((opsize==(i64)2)) {
            return regnames16[(reg)-1];
        }else if ((opsize==(i64)4)) {
            return regnames32[(reg)-1];
        }else if ((opsize==(i64)8)) {
            return regnames64[(reg)-1];
        };
    };
    return (byte*)"";
}

static byte * ax_disasm_strfreg(i64 freg) {
    static byte *  fregnames[8] = {(byte*)"st0",(byte*)"st1",(byte*)"st2",(byte*)"st3",(byte*)"st4",(byte*)"st5",(byte*)"st6",(byte*)"st7"};
    return fregnames[(freg)-1];
}

static void ax_disasm_printaddrmode(i64 xmm) {
    byte *  plus;
    i64 addrsize;
    ax_disasm_genstr((byte*)" ");
    if ((ax_disasm_addrmode==(i64)1)) {
        if (!!(xmm)) {
            ax_disasm_genstr(ax_disasm_strxmm(ax_disasm_basereg));
        } else {
            ax_disasm_getsilx(&ax_disasm_basereg);
            ax_disasm_genstr(ax_disasm_strreg(ax_disasm_basereg,ax_disasm_opsize));
        };
        return;
    };
    if ((ax_disasm_opsize==(i64)1)) {
        ax_disasm_genstr((byte*)"byte ");
    }else if ((ax_disasm_opsize==(i64)2)) {
        ax_disasm_genstr((byte*)"word ");
    }else if ((ax_disasm_opsize==(i64)4)) {
        ax_disasm_genstr((byte*)"dword ");
    }else if ((ax_disasm_opsize==(i64)8)) {
        ax_disasm_genstr((byte*)"qword ");
    }else if ((ax_disasm_opsize==(i64)10)) {
        ax_disasm_genstr((byte*)"tword ");
    }else if ((ax_disasm_opsize==(i64)16)) {
        ax_disasm_genstr((byte*)"oword ");
    } else {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"///OPSIZE",NULL);
        msysnewc_m_print_i64(ax_disasm_opsize,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
    ax_disasm_genstr((byte*)"[");
    plus = (byte*)"";
    addrsize = (!!(ax_disasm_addroverride)?(i64)4:(i64)8);
    if (!!(ax_disasm_basereg)) {
        ax_disasm_genstr(ax_disasm_strreg(ax_disasm_basereg,addrsize));
        plus = (byte*)"+";
    };
    if (!!(ax_disasm_indexreg)) {
        ax_disasm_genstr(plus);
        ax_disasm_genstr(ax_disasm_strreg(ax_disasm_indexreg,addrsize));
        if ((ax_disasm_scale > (i64)1)) {
            ax_disasm_genstr((byte*)"*");
            ax_disasm_genintd(ax_disasm_scale);
        };
        plus = (byte*)"+";
    };
    if ((!!(ax_disasm_offset) || ((ax_disasm_basereg == (i64)0) && (ax_disasm_indexreg == (i64)0)))) {
        if (((ax_disasm_basereg == (i64)0) && (ax_disasm_indexreg == (i64)0))) {
            ax_disasm_genhex(ax_disasm_offset);
        } else {
            if ((ax_disasm_offset > (i64)0)) {
                ax_disasm_genstr(plus);
            };
            ax_disasm_genintd(ax_disasm_offset);
        };
    };
    ax_disasm_genstr((byte*)"]");
    if ((ax_disasm_addrmode == (i64)3)) {
        ax_disasm_genstr((byte*)"+RIP");
    };
}

static void ax_disasm_genstr(byte * s) {
    strcat((i8 *)(ax_disasm_deststr),(i8 *)(s));
}

static void ax_disasm_genintd(i64 a) {
    ax_disasm_genstr(msysnewc_strint(a,(byte *)(0)));
}

static void ax_disasm_genhex(i64 a) {
    ax_disasm_genstr(msysnewc_strint(a,(byte*)"h"));
}

static i64 ax_disasm_readimm(void) {
    if ((ax_disasm_opsize==(i64)1)) {
        return ax_disasm_readsbyte();
    }else if ((ax_disasm_opsize==(i64)2)) {
        return ax_disasm_readint16();
    }else if ((ax_disasm_opsize==(i64)4) || (ax_disasm_opsize==(i64)8)) {
        return ax_disasm_readint32();
    };
    return (i64)0;
}

static i64 ax_disasm_readimm8(void) {
    if ((ax_disasm_opsize < (i64)8)) {
        return ax_disasm_readimm();
    };
    return ax_disasm_readint64();
}

static byte * ax_disasm_strxmm(i64 reg) {
    static byte str[32];
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_str((byte*)"xmm",NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_i64((reg - (i64)1),NULL);
    msysnewc_m_print_end();
    ;
    return str;
}

static byte * ax_disasm_strmmx(i64 reg) {
    static byte str[32];
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_str((byte*)"mmx",NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_i64((reg - (i64)1),NULL);
    msysnewc_m_print_end();
    ;
    return str;
}

static void ax_disasm_decode8087(i64 ttt) {
    byte bb;
    i64 longopc;
    i64 freg;
    i64 shortopc;
    bb = (u64)((*ax_disasm_codeptr++));
    longopc = ((ttt << (i64)8) + (i64)((u64)(bb)));
    freg = (((i64)((u64)(bb)) & (i64)7) + (i64)1);
    if ((longopc==(i64)1753)) {
        ax_disasm_genstr((byte*)"fcompp");
    }else if ((longopc==(i64)484)) {
        ax_disasm_genstr((byte*)"ftst");
    }else if ((longopc==(i64)485)) {
        ax_disasm_genstr((byte*)"fxam");
    }else if ((longopc==(i64)494)) {
        ax_disasm_genstr((byte*)"fldz");
    }else if ((longopc==(i64)488)) {
        ax_disasm_genstr((byte*)"fld1");
    }else if ((longopc==(i64)491)) {
        ax_disasm_genstr((byte*)"fldpi");
    }else if ((longopc==(i64)489)) {
        ax_disasm_genstr((byte*)"fldl2t");
    }else if ((longopc==(i64)490)) {
        ax_disasm_genstr((byte*)"fldl2e");
    }else if ((longopc==(i64)492)) {
        ax_disasm_genstr((byte*)"fldlg2");
    }else if ((longopc==(i64)493)) {
        ax_disasm_genstr((byte*)"fldln2");
    }else if ((longopc==(i64)506)) {
        ax_disasm_genstr((byte*)"fsqrt");
    }else if ((longopc==(i64)510)) {
        ax_disasm_genstr((byte*)"fsin");
    }else if ((longopc==(i64)511)) {
        ax_disasm_genstr((byte*)"fcos");
    }else if ((longopc==(i64)507)) {
        ax_disasm_genstr((byte*)"fsincos");
    }else if ((longopc==(i64)509)) {
        ax_disasm_genstr((byte*)"fscale");
    }else if ((longopc==(i64)504)) {
        ax_disasm_genstr((byte*)"fprem");
    }else if ((longopc==(i64)508)) {
        ax_disasm_genstr((byte*)"frndint");
    }else if ((longopc==(i64)500)) {
        ax_disasm_genstr((byte*)"fxtract");
    }else if ((longopc==(i64)481)) {
        ax_disasm_genstr((byte*)"fabs");
    }else if ((longopc==(i64)480)) {
        ax_disasm_genstr((byte*)"fchs");
    }else if ((longopc==(i64)498)) {
        ax_disasm_genstr((byte*)"fptan");
    }else if ((longopc==(i64)499)) {
        ax_disasm_genstr((byte*)"fpatan");
    }else if ((longopc==(i64)496)) {
        ax_disasm_genstr((byte*)"f2xm1");
    }else if ((longopc==(i64)497)) {
        ax_disasm_genstr((byte*)"fyl2x");
    }else if ((longopc==(i64)505)) {
        ax_disasm_genstr((byte*)"fyl2xp1");
    }else if ((longopc==(i64)995)) {
        ax_disasm_genstr((byte*)"finit");
    }else if ((longopc==(i64)992)) {
        ax_disasm_genstr((byte*)"feni");
    }else if ((longopc==(i64)993)) {
        ax_disasm_genstr((byte*)"fdisi");
    }else if ((longopc==(i64)994)) {
        ax_disasm_genstr((byte*)"fclex");
    }else if ((longopc==(i64)503)) {
        ax_disasm_genstr((byte*)"fincstp");
    }else if ((longopc==(i64)502)) {
        ax_disasm_genstr((byte*)"fdecstp");
    }else if ((longopc==(i64)464)) {
        ax_disasm_genstr((byte*)"fnop");
    } else {
        if (((longopc & (i64)2040)==(i64)448)) {
            ax_disasm_genstr((byte*)"fld ");
            ax_disasm_genstr(ax_disasm_strfreg(freg));
        }else if (((longopc & (i64)2040)==(i64)1488)) {
            ax_disasm_genstr((byte*)"fst ");
            ax_disasm_genstr(ax_disasm_strfreg(freg));
        }else if (((longopc & (i64)2040)==(i64)1496)) {
            ax_disasm_genstr((byte*)"fstp ");
            ax_disasm_genstr(ax_disasm_strfreg(freg));
        }else if (((longopc & (i64)2040)==(i64)456)) {
            ax_disasm_genstr((byte*)"fxch ");
            ax_disasm_genstr(ax_disasm_strfreg(freg));
        }else if (((longopc & (i64)2040)==(i64)208)) {
            ax_disasm_genstr((byte*)"fcom ");
            ax_disasm_genstr(ax_disasm_strfreg(freg));
        }else if (((longopc & (i64)2040)==(i64)216)) {
            ax_disasm_genstr((byte*)"fcomp ");
            ax_disasm_genstr(ax_disasm_strfreg(freg));
        }else if (((longopc & (i64)2040)==(i64)1472)) {
            ax_disasm_genstr((byte*)"ffree ");
            ax_disasm_genstr(ax_disasm_strfreg(freg));
        } else {
            if (((longopc & (i64)504)==(i64)192)) {
                ax_disasm_do87arith((byte*)"fadd",ttt,freg);
            }else if (((longopc & (i64)504)==(i64)224)) {
                ax_disasm_do87arith((byte*)"fsub",ttt,freg);
            }else if (((longopc & (i64)504)==(i64)232)) {
                ax_disasm_do87arith((byte*)"fsubr",ttt,freg);
            }else if (((longopc & (i64)504)==(i64)200)) {
                ax_disasm_do87arith((byte*)"fmul",ttt,freg);
            }else if (((longopc & (i64)504)==(i64)240)) {
                ax_disasm_do87arith((byte*)"fdiv",ttt,freg);
            }else if (((longopc & (i64)504)==(i64)248)) {
                ax_disasm_do87arith((byte*)"fdivr",ttt,freg);
            } else {
                --ax_disasm_codeptr;
                ax_disasm_decodeaddr((i64)0);
                shortopc = ((ttt << (i64)3) + ax_disasm_rmopc);
                if ((shortopc==(i64)61)) {
                    ax_disasm_do87mem((byte*)"fld",(i64)4);
                }else if ((shortopc==(i64)29)) {
                    ax_disasm_do87mem((byte*)"fld",(i64)5);
                }else if ((shortopc==(i64)60)) {
                    ax_disasm_do87mem((byte*)"fldbcd",(i64)-1);
                }else if ((shortopc==(i64)63)) {
                    ax_disasm_do87mem((byte*)"fstp",(i64)4);
                }else if ((shortopc==(i64)31)) {
                    ax_disasm_do87mem((byte*)"fstp",(i64)5);
                }else if ((shortopc==(i64)62)) {
                    ax_disasm_do87mem((byte*)"fstpbcd",(i64)-1);
                }else if ((shortopc==(i64)13)) {
                    ax_disasm_do87mem((byte*)"fldcw",(i64)-1);
                }else if ((shortopc==(i64)15)) {
                    ax_disasm_do87mem((byte*)"fstcw",(i64)-1);
                }else if ((shortopc==(i64)47)) {
                    ax_disasm_do87mem((byte*)"fstsw",(i64)-1);
                }else if ((shortopc==(i64)14)) {
                    ax_disasm_do87mem((byte*)"fstenv",(i64)-1);
                }else if ((shortopc==(i64)12)) {
                    ax_disasm_do87mem((byte*)"fldenv",(i64)-1);
                }else if ((shortopc==(i64)46)) {
                    ax_disasm_do87mem((byte*)"fsave",(i64)-1);
                }else if ((shortopc==(i64)44)) {
                    ax_disasm_do87mem((byte*)"frstor",(i64)-1);
                } else {
                    if (((shortopc & (i64)15)==(i64)8)) {
                        ax_disasm_do87mem((byte*)"fld",(ttt >> (i64)1));
                    }else if (((shortopc & (i64)15)==(i64)10)) {
                        ax_disasm_do87mem((byte*)"fst",(ttt >> (i64)1));
                    }else if (((shortopc & (i64)15)==(i64)11)) {
                        ax_disasm_do87mem((byte*)"fstp",(ttt >> (i64)1));
                    }else if (((shortopc & (i64)15)==(i64)2)) {
                        ax_disasm_do87mem((byte*)"fcom",(ttt >> (i64)1));
                    }else if (((shortopc & (i64)15)==(i64)3)) {
                        ax_disasm_do87mem((byte*)"fcomp",(ttt >> (i64)1));
                    }else if (((shortopc & (i64)15)==(i64)0)) {
                        ax_disasm_do87mem((byte*)"fadd",(ttt >> (i64)1));
                    }else if (((shortopc & (i64)15)==(i64)4)) {
                        ax_disasm_do87mem((byte*)"fsub",(ttt >> (i64)1));
                    }else if (((shortopc & (i64)15)==(i64)5)) {
                        ax_disasm_do87mem((byte*)"fsubr",(ttt >> (i64)1));
                    }else if (((shortopc & (i64)15)==(i64)1)) {
                        ax_disasm_do87mem((byte*)"fmul",(ttt >> (i64)1));
                    }else if (((shortopc & (i64)15)==(i64)6)) {
                        ax_disasm_do87mem((byte*)"fdiv",(ttt >> (i64)1));
                    }else if (((shortopc & (i64)15)==(i64)7)) {
                        ax_disasm_do87mem((byte*)"fdivr",(ttt >> (i64)1));
                    } else {
                        ax_disasm_genstr((byte*)"UNKNOWN x87 OPCODE");
                    };
                };
            };
        };
    };
}

static void ax_disasm_do87arith(byte * opcstr,i64 ttt,i64 freg) {
    i64 d;
    i64 p;
    d = (ttt & (i64)4);
    p = (ttt & (i64)2);
    ax_disasm_genstr(opcstr);
    if (!!(p)) {
        ax_disasm_genstr((byte*)"p");
    };
    ax_disasm_genstr((byte*)" ");
    if ((d == (i64)0)) {
        ax_disasm_genstr((byte*)"st0, ");
        ax_disasm_genstr(ax_disasm_strfreg(freg));
    } else {
        ax_disasm_genstr(ax_disasm_strfreg(freg));
        ax_disasm_genstr((byte*)", st0");
    };
}

static void ax_disasm_do87mem(byte * opcstr,i64 mf) {
    ax_disasm_genstr((byte*)"f");
    if ((mf==(i64)0)) {
        ax_disasm_opsize = (i64)4;
    }else if ((mf==(i64)1)) {
        ax_disasm_genstr((byte*)"i");
        ax_disasm_opsize = (i64)4;
    }else if ((mf==(i64)2)) {
        ax_disasm_opsize = (i64)8;
    }else if ((mf==(i64)3)) {
        ax_disasm_genstr((byte*)"i");
        ax_disasm_opsize = (i64)2;
    }else if ((mf==(i64)4)) {
        ax_disasm_genstr((byte*)"i");
        ax_disasm_opsize = (i64)8;
    }else if ((mf==(i64)5)) {
        ax_disasm_opsize = (i64)10;
    };
    ax_disasm_genstr((opcstr + (i64)1));
    ax_disasm_genstr((byte*)" ");
    ax_disasm_printaddrmode((i64)0);
}

static void ax_disasm_getsil(i64 * reg) {
    if (((((ax_disasm_opsize == (i64)1) && !(!!(ax_disasm_rex))) && ((*reg) >= (i64)5)) && ((*reg) <= (i64)8))) {
        (*reg) += (i64)12;
    };
}

static void ax_disasm_getsilx(i64 * reg) {
    if ((((((ax_disasm_addrmode == (i64)1) && (ax_disasm_opsize == (i64)1)) && (ax_disasm_rex == (i64)0)) && ((*reg) >= (i64)5)) && ((*reg) <= (i64)8))) {
        (*reg) += (i64)12;
    };
}

void ax_writeobj_writess(byte * outfile) {
    ax_writeobj_writecoff(outfile);
}

static void ax_writeobj_writerecord(void * r,i64 length) {
    memcpy((void *)(ax_writeobj_dataptr),r,(u64)(length));
    ax_writeobj_dataptr += length;
}

static void ax_writeobj_writerelocs(struct ax_decls_relocrec * r,i64 nrelocs) {
    static struct ax_objdecls_coffrelocrec s;
    struct ax_decls_strec *  d;
    if ((nrelocs == (i64)0)) {
        return;
    };
    L1357 :;
    while (!!(r)) {
        if (((*r).reloctype==(i64)2) || ((*r).reloctype==(i64)1)) {
            d = (*ax_decls_ss_symboltable)[((*r).stindex)-1];
            if (((i64)((*d).segment)==(i64)3)) {
                s.stindex = (i64)2;
            }else if (((i64)((*d).segment)==(i64)2)) {
                s.stindex = (i64)4;
            }else if (((i64)((*d).segment)==(i64)1)) {
                s.stindex = (i64)6;
            }else if (((i64)((*d).segment)==(i64)0)) {
                s.stindex = ((*r).stindex + ax_writeobj_stoffset);
            } else {
                ax_lib_gerror((byte*)"wrelocs/bad seg");
            };
        } else {
            s.stindex = ((*r).stindex + ax_writeobj_stoffset);
        };
        s.reloctype = (*r).reloctype;
        s.virtualaddr = (*r).offset;
        memcpy((void *)(ax_writeobj_dataptr),(void *)(&s),(u64)((i64)10));
        ax_writeobj_dataptr += (i64)10;
        r = (*r).nextreloc;
L1358 :;
    }L1359 :;
    ;
}

static void ax_writeobj_writedata(struct ax_decls_dbuffer * data) {
    memcpy((void *)(ax_writeobj_dataptr),ax_lib_bufferelemptr(data,(i64)0),(u64)(ax_lib_bufferlength(data)));
    ax_writeobj_dataptr += ax_lib_bufferlength(data);
}

static void ax_writeobj_writesymboltable(void) {
    i64 i;
    L1360 :;
    for (i=(i64)1;i<=ax_writeobj_nsymbols;i+=(i64)1) {
L1361 :;
        ax_writeobj_writerecord((void *)(&ax_writeobj_symboltable[(i)]),(i64)18);
L1362 :;
    }L1363 :;
    ;
}

static void ax_writeobj_writestringtable(void) {
    i32 *  p;
    i64 i;
    i64 n;
    p = (i32 *)(ax_writeobj_dataptr);
    (*p) = ax_writeobj_nextstringoffset;
    ax_writeobj_dataptr += (i64)4;
    L1364 :;
    for (i=(i64)1;i<=ax_writeobj_nstrings;i+=(i64)1) {
L1365 :;
        n = (ax_writeobj_stringlengths[(i)-1] + (i64)1);
        memcpy((void *)(ax_writeobj_dataptr),(void *)(ax_writeobj_stringtable[(i)-1]),(u64)(n));
        ax_writeobj_dataptr += n;
L1366 :;
    }L1367 :;
    ;
}

static struct ax_objdecls_imagesymbol * ax_writeobj_makesymbol(byte * name,i64 namelen,i64 value,i64 sectionno,i64 symtype,i64 storage,i64 naux) {
    static struct ax_objdecls_imagesymbol r;
    if ((namelen == (i64)0)) {
        namelen = (i64)(strlen((i8 *)(name)));
    };
    if ((namelen < (i64)8)) {
        strcpy((i8 *)(&r.shortname[((i64)1)-1]),(i8 *)(name));
    } else if ((namelen == (i64)8)) {
        memcpy((void *)(&r.shortname[((i64)1)-1]),(void *)(name),(u64)(namelen));
    } else {
        r.shortx = (u64)((i64)0);
        r.longx = (u64)(ax_writeobj_addstringentry(name,namelen));
    };
    r.value = (u64)(value);
    r.sectionno = sectionno;
    r.symtype = (u64)(symtype);
    r.storageclass = (u64)(storage);
    r.nauxsymbols = (u64)(naux);
    return &r;
}

static void ax_writeobj_addsymbol(struct ax_objdecls_imagesymbol * r) {
    if ((ax_writeobj_nsymbols >= (i64)10001)) {
        ax_lib_gerror((byte*)"as:Too many symbols");
    };
    memcpy((void *)(&ax_writeobj_symboltable[(++ax_writeobj_nsymbols)]),(void *)(r),(u64)((i64)18));
}

static void ax_writeobj_initsymboltable(byte * filename) {
    ax_writeobj_nsymbols = (i64)0;
    ax_writeobj_addsymbol(ax_writeobj_makesymbol((byte*)".file",(i64)0,(i64)0,(i64)-2,(i64)0,(i64)103,(i64)1));
    ax_writeobj_addsymbol(ax_writeobj_strtoaux(filename));
    ax_writeobj_addsymbol(ax_writeobj_makesymbol((byte*)".bss",(i64)0,(i64)0,(i64)1,(i64)0,(i64)3,(i64)1));
    ax_writeobj_addsymbol((struct ax_objdecls_imagesymbol *)(ax_writeobj_sectiontoaux((struct ax_decls_dbuffer *)(0),(i64)0)));
    ax_writeobj_addsymbol(ax_writeobj_makesymbol((byte*)".data",(i64)0,(i64)0,(i64)2,(i64)0,(i64)3,(i64)1));
    ax_writeobj_addsymbol((struct ax_objdecls_imagesymbol *)(ax_writeobj_sectiontoaux(ax_decls_ss_idata,ax_decls_ss_nidatarelocs)));
    ax_writeobj_addsymbol(ax_writeobj_makesymbol((byte*)".text",(i64)0,(i64)0,(i64)3,(i64)0,(i64)3,(i64)1));
    ax_writeobj_addsymbol((struct ax_objdecls_imagesymbol *)(ax_writeobj_sectiontoaux(ax_decls_ss_code,ax_decls_ss_ncoderelocs)));
}

static struct ax_objdecls_imagesymbol * ax_writeobj_strtoaux(byte * s) {
    static struct ax_objdecls_imagesymbol r;
    byte *  p;
    i64 n;
    p = (byte *)(&r);
    memset((void *)(p),(i64)0,(u64)((i64)18));
    n = (i64)0;
    L1368 :;
    while ((((i64)((*s)) != (i64)0) && (n < (i64)18))) {
        (*p++) = (u64)((*s++));
        ++n;
L1369 :;
    }L1370 :;
    ;
    return &r;
}

static struct ax_objdecls_auxsectionrec * ax_writeobj_sectiontoaux(struct ax_decls_dbuffer * data,i64 nrelocs) {
    static struct ax_objdecls_auxsectionrec r;
    memset((void *)(&r),(i64)0,(u64)((i64)18));
    if ((data == 0)) {
        r.length = ax_decls_ss_zdatalen;
    } else {
        r.length = ax_lib_bufferlength(data);
    };
    r.nrelocs = nrelocs;
    return &r;
}

static i64 ax_writeobj_addstringentry(byte * s,i64 length) {
    i64 offset;
    offset = ax_writeobj_nextstringoffset;
    if ((ax_writeobj_nstrings > (i64)5000)) {
        ax_lib_gerror((byte*)"W:too many strings");
    };
    ax_writeobj_stringtable[(++ax_writeobj_nstrings)-1] = s;
    ax_writeobj_stringlengths[(ax_writeobj_nstrings)-1] = length;
    ax_writeobj_nextstringoffset += (length + (i64)1);
    return offset;
}

static void ax_writeobj_convertsymboltable(void) {
    struct ax_decls_strec *  s;
    byte *  name;
    i64 i;
    i64 sect;
    i64 scope;
    ax_writeobj_stoffset = (ax_writeobj_nsymbols - (i64)1);
    ax_writeobj_nstrings = (i64)0;
    ax_writeobj_nextstringoffset = (i64)4;
    L1371 :;
    for (i=(i64)1;i<=ax_decls_ss_nsymbols;i+=(i64)1) {
L1372 :;
        s = (*ax_decls_ss_symboltable)[(i)-1];
        name = (*s).name;
        if (((i64)((*s).segment)==(i64)3)) {
            sect = (i64)1;
        }else if (((i64)((*s).segment)==(i64)2)) {
            sect = (i64)2;
        }else if (((i64)((*s).segment)==(i64)1)) {
            sect = (i64)3;
        } else {
            sect = (i64)0;
        };
        if (((i64)((*s).symbol)==(i64)19) || ((i64)((*s).symbol)==(i64)20)) {
            scope = (i64)3;
        }else if (((i64)((*s).symbol)==(i64)21) || ((i64)((*s).symbol)==(i64)22)) {
            scope = (i64)2;
        } else {
            scope = (i64)0;
        };
        ax_writeobj_addsymbol(ax_writeobj_makesymbol((*s).name,(i64)((*s).namelen),(i64)((*s).offset),sect,(i64)0,scope,(i64)0));
L1373 :;
    }L1374 :;
    ;
}

static void ax_writeobj_writecoff(byte * outfile) {
    struct ax_objdecls_imagefileheader header;
    struct ax_objdecls_imagesectionheader zsection;
    struct ax_objdecls_imagesectionheader isection;
    struct ax_objdecls_imagesectionheader csection;
    i64 offset;
    memset((void *)(&header),(i64)0,(u64)((i64)20));
    memset((void *)(&zsection),(i64)0,(u64)((i64)40));
    memset((void *)(&isection),(i64)0,(u64)((i64)40));
    memset((void *)(&csection),(i64)0,(u64)((i64)40));
    header.machine = (u64)((i64)34404);
    header.nsections = (u64)((i64)3);
    strcpy((i8 *)(&zsection.name[((i64)1)-1]),(i8 *)((byte*)".bss"));
    zsection.rawdata_size = (u64)(ax_decls_ss_zdatalen);
    zsection.characteristics = (u64)((i64)3225419904);
    if (((ax_decls_ss_nidatarelocs >= (i64)65536) || (ax_decls_ss_ncoderelocs >= (i64)65536))) {
        ax_lib_gerror((byte*)"Too many relocs (exceeds 16-bit field)");
    };
    strcpy((i8 *)(&isection.name[((i64)1)-1]),(i8 *)((byte*)".data"));
    isection.rawdata_size = (u64)(ax_lib_bufferlength(ax_decls_ss_idata));
    isection.nrelocs = (u64)(ax_decls_ss_nidatarelocs);
    isection.characteristics = (u64)((i64)3226468416);
    strcpy((i8 *)(&csection.name[((i64)1)-1]),(i8 *)((byte*)".text"));
    csection.rawdata_size = (u64)(ax_lib_bufferlength(ax_decls_ss_code));
    csection.nrelocs = (u64)(ax_decls_ss_ncoderelocs);
    csection.characteristics = (u64)((i64)1615855648);
    ax_writeobj_initsymboltable(outfile);
    ax_writeobj_convertsymboltable();
    offset = (i64)20;
    offset += (i64)120;
    if (!!((u64)(isection.nrelocs))) {
        isection.relocations_ptr = (u64)(offset);
        offset += ((i64)((u64)(isection.nrelocs)) * (i64)10);
    };
    if (!!((u64)(csection.nrelocs))) {
        csection.relocations_ptr = (u64)(offset);
        offset += ((i64)((u64)(csection.nrelocs)) * (i64)10);
    };
    isection.rawdata_offset = (u64)(offset);
    offset += (i64)(isection.rawdata_size);
    csection.rawdata_offset = (u64)(offset);
    offset += (i64)(csection.rawdata_size);
    header.symtaboffset = (u64)(offset);
    offset += (ax_writeobj_nsymbols * (i64)18);
    header.nsymbols = (u64)(ax_writeobj_nsymbols);
    offset += ax_writeobj_nextstringoffset;
    ax_writeobj_datastart = (ax_writeobj_dataptr = (byte *)(malloc((u64)(offset))));
    ax_writeobj_writerecord((void *)(&header),(i64)20);
    ax_writeobj_writerecord((void *)(&zsection),(i64)40);
    ax_writeobj_writerecord((void *)(&isection),(i64)40);
    ax_writeobj_writerecord((void *)(&csection),(i64)40);
    ax_writeobj_writerelocs(ax_decls_ss_idatarelocs,ax_decls_ss_nidatarelocs);
    ax_writeobj_writerelocs(ax_decls_ss_coderelocs,ax_decls_ss_ncoderelocs);
    ax_writeobj_writedata(ax_decls_ss_idata);
    ax_writeobj_writedata(ax_decls_ss_code);
    ax_writeobj_writesymboltable();
    ax_writeobj_writestringtable();
    if (!!(ax_decls_fverbose)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"Writing file:",NULL);
        msysnewc_m_print_str(outfile,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
    mlib_writefile(outfile,ax_writeobj_datastart,(ax_writeobj_dataptr - ax_writeobj_datastart));
}


/* ********** End of C Code ********** */
